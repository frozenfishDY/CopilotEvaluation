{"id": "1", "path": "output2\\c\\Easy\\1-two-sum.c", "hypo_code": "int* twoSum(int* nums, int numsSize, int target, int* returnSize){\n    int *result = (int *)malloc(2 * sizeof(int));\n    for(int i = 0; i < numsSize; i++){\n        for(int j = i + 1; j < numsSize; j++){\n            if(nums[i] + nums[j] == target){\n                result[0] = i;\n                result[1] = j;\n                *returnSize = 2;\n                return result;\n            }\n        }\n    }\n    return result;\n   \n}", "prefix": "int* twoSum(int* nums, int numsSize, int target, int* returnSize"}
{"id": "2", "path": "output2\\c\\Easy\\2-palindrome-number.c", "hypo_code": "bool isPalindrome(int x){\n    if(x < 0){\n        return false;\n    }\n    int temp = x;\n    int reverse = 0;\n    while(temp != 0){\n        reverse = reverse * 10 + temp % 10;\n        temp = temp / 10;\n    }\n    if(reverse == x){\n        return true;\n    }\n    return false;\n   \n\n}", "prefix": "bool isPalindrome(int x"}
{"id": "3", "path": "output2\\c\\Easy\\3-roman-to-integer.c", "hypo_code": "int romanToInt(char * s){\n    int result = 0;\n    int i = 0;\n    while(s[i] != '\\0'){\n        if(s[i] == 'I'){\n            if(s[i + 1] == 'V'){\n                result += 4;\n                i++;\n            }else if(s[i + 1] == 'X'){\n                result += 9;\n                i++;\n            }else{\n                result += 1;\n            }\n        }else if(s[i] == 'V'){\n            result += 5;\n        }else if(s[i] == 'X'){\n            if(s[i + 1] == 'L'){\n                result += 40;\n                i++;\n            }else if(s[i + 1] == 'C'){\n                result += 90;\n                i++;\n            }else{\n                result += 10;\n            }\n        }else if(s[i] == 'L'){\n            result += 50;\n        }else if(s[i] == 'C'){\n            if(s[i + 1] == 'D'){\n                result += 400;\n                i++;\n            }else if(s[i + 1] == 'M'){\n                result += 900;\n                i++;\n            }else{\n                result += 100;\n            }\n        }else if(s[i] == 'D'){\n            result += 500;\n        }else if(s[i] == 'M'){\n            result += 1000;\n        }\n        i++;\n    }\n    return result;\n    \n\n}", "prefix": "int romanToInt(char * s"}
{"id": "4", "path": "output2\\c\\Easy\\4-longest-common-prefix.c", "hypo_code": "char * longestCommonPrefix(char ** strs, int strsSize){\n    if(strsSize == 0){\n        return \"\";\n    }\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int flag = 0;\n    char *result = (char *)malloc(100 * sizeof(char));\n    while(strs[0][i] != '\\0'){\n        for(j = 1; j < strsSize; j++){\n            if(strs[0][i] != strs[j][i]){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 1){\n            break;\n        }\n        result[k] = strs[0][i];\n        k++;\n        i++;\n    }\n    result[k] = '\\0';\n    return result;\n\n}", "prefix": "char * longestCommonPrefix(char ** strs, int strsSize"}
{"id": "5", "path": "output2\\c\\Easy\\5-valid-parentheses.c", "hypo_code": "bool isValid(char * s){\n    int len = strlen(s);\n    if(len % 2 != 0){\n        return false;\n    }\n    char *stack = (char *)malloc(len * sizeof(char));\n    int top = -1;\n    for(int i = 0; i < len; i++){\n        if(s[i] == '(' || s[i] == '[' || s[i] == '{'){\n            top++;\n            stack[top] = s[i];\n        }\n        else if(s[i] == ')'){\n            if(top == -1 || stack[top] != '('){\n                return false;\n            }\n            top--;\n        }\n        else if(s[i] == ']'){\n            if(top == -1 || stack[top] != '['){\n                return false;\n            }\n            top--;\n        }\n        else if(s[i] == '}'){\n            if(top == -1 || stack[top] != '{'){\n                return false;\n            }\n            top--;\n        }\n    }\n    if(top == -1){\n        return true;\n    }\n    return false;\n    \n\n}", "prefix": "bool isValid(char * s"}
{"id": "6", "path": "output2\\c\\Easy\\6-merge-two-sorted-lists.c", "hypo_code": "struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){\n    struct ListNode *result = (struct ListNode *)malloc(sizeof(struct ListNode));\n    struct ListNode *temp = result;\n    while(list1 != NULL && list2 != NULL){\n        if(list1->val < list2->val){\n            temp->next = list1;\n            list1 = list1->next;\n        }\n        else{\n            temp->next = list2;\n            list2 = list2->next;\n        }\n        temp = temp->next;\n    }\n    if(list1 != NULL){\n        temp->next = list1;\n    }\n    if(list2 != NULL){\n        temp->next = list2;\n    }\n    return result->next;\n    \n\n}", "prefix": "struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2"}
{"id": "7", "path": "output2\\c\\Easy\\7-remove-duplicates-from-sorted-array.c", "hypo_code": "int removeDuplicates(int* nums, int numsSize){\n    if(numsSize == 0){\n        return 0;\n    }\n    int i = 0;\n    int j = 1;\n    while(j < numsSize){\n        if(nums[i] != nums[j]){\n            i++;\n            nums[i] = nums[j];\n        }\n        j++;\n    }\n    return i + 1;\n\n}", "prefix": "int removeDuplicates(int* nums, int numsSize"}
{"id": "8", "path": "output2\\c\\Easy\\8-remove-element.c", "hypo_code": "int removeElement(int* nums, int numsSize, int val){\n    int i = 0;\n    int j = 0;\n    while(j < numsSize){\n        if(nums[j] != val){\n            nums[i] = nums[j];\n            i++;\n        }\n        j++;\n    }\n    return i;\n\n}", "prefix": "int removeElement(int* nums, int numsSize, int val"}
{"id": "9", "path": "output2\\c\\Easy\\9-find-the-index-of-the-first-occurrence-in-a-string.c", "hypo_code": "int strStr(char * haystack, char * needle){ \n    int i = 0, j = 0, k = 0;\n    int len1 = strlen(haystack);\n    int len2 = strlen(needle);\n    if (len2 == 0) return 0;\n    if (len1 < len2) return -1;\n    for (i = 0; i < len1; i++) {\n        if (haystack[i] == needle[j]) {\n            k = i;\n            while (haystack[i] == needle[j] && j < len2) {\n                i++;\n                j++;\n            }\n            if (j == len2) return k;\n            else {\n                i = k;\n                j = 0;\n            }\n        }\n    }\n    return -1;\n\n\n\n\n\n     \n}", "prefix": "int strStr(char * haystack, char * needle"}
{"id": "10", "path": "output2\\c\\Easy\\10-search-insert-position.c", "hypo_code": "int searchInsert(int* nums, int numsSize, int target){\n    int i = 0;\n    while(i < numsSize){\n        if(nums[i] >= target){\n            return i;\n        }\n        i++;\n    }\n    return i;\n\n}", "prefix": "int searchInsert(int* nums, int numsSize, int target"}
{"id": "11", "path": "output2\\c\\Easy\\11-length-of-last-word.c", "hypo_code": "int lengthOfLastWord(char * s){\n    int len = strlen(s);\n    int i = len - 1;\n    int count = 0;\n    while(i >= 0){\n        if(s[i] == ' '){\n            if(count == 0){\n                i--;\n                continue;\n            }\n            else{\n                break;\n            }\n        }\n        count++;\n        i--;\n    }\n    return count;\n\n}", "prefix": "int lengthOfLastWord(char * s"}
{"id": "12", "path": "output2\\c\\Easy\\12-plus-one.c", "hypo_code": "int* plusOne(int* digits, int digitsSize, int* returnSize){\n    int i = digitsSize - 1;\n    int carry = 1;\n    while(i >= 0 && carry == 1){\n        if(digits[i] == 9){\n            digits[i] = 0;\n            carry = 1;\n        }else{\n            digits[i] += 1;\n            carry = 0;\n        }\n        i--;\n    }\n    if(carry == 1){\n        int *result = (int *)malloc(sizeof(int) * (digitsSize + 1));\n        result[0] = 1;\n        for(int i = 0; i < digitsSize; i++){\n            result[i + 1] = digits[i];\n        }\n        *returnSize = digitsSize + 1;\n        return result;\n    }else{\n        *returnSize = digitsSize;\n        return digits;\n    }\n\n}", "prefix": "int* plusOne(int* digits, int digitsSize, int* returnSize"}
{"id": "13", "path": "output2\\c\\Easy\\13-add-binary.c", "hypo_code": "char * addBinary(char * a, char * b){\n    int aLen = strlen(a);\n    int bLen = strlen(b);\n    int maxLen = aLen > bLen ? aLen : bLen;\n    char *result = (char *)malloc(sizeof(char) * (maxLen + 2));\n    int carry = 0;\n    int i = aLen - 1;\n    int j = bLen - 1;\n    int k = maxLen;\n    while(i >= 0 || j >= 0){\n        int aBit = i >= 0 ? a[i] - '0' : 0;\n        int bBit = j >= 0 ? b[j] - '0' : 0;\n        int sum = aBit + bBit + carry;\n        if(sum == 0){\n            result[k] = '0';\n            carry = 0;\n        }else if(sum == 1){\n            result[k] = '1';\n            carry = 0;\n        }else if(sum == 2){\n            result[k] = '0';\n            carry = 1;\n        }else if(sum == 3){\n            result[k] = '1';\n            carry = 1;\n        }\n        i--;\n        j--;\n        k--;\n    }\n    if(carry == 1){\n        result[0] = '1';\n        result[maxLen + 1] = '\\0';\n        return result;\n    }else{\n        result[maxLen + 1] = '\\0';\n        return result + 1;\n    }\n\n}", "prefix": "char * addBinary(char * a, char * b"}
{"id": "14", "path": "output2\\c\\Easy\\14-sqrtx.c", "hypo_code": "int mySqrt(int x){\n    if(x == 0){\n        return 0;\n    }\n    int left = 1;\n    int right = x;\n    while(left < right){\n        int mid = left + (right - left) / 2;\n        if(mid > x / mid){\n            right = mid;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return left - 1;\n\n}", "prefix": "int mySqrt(int x"}
{"id": "15", "path": "output2\\c\\Easy\\15-climbing-stairs.c", "hypo_code": "int climbStairs(int n){\n    if(n == 1){\n        return 1;\n    }\n    int *dp = (int *)malloc(sizeof(int) * (n + 1));\n    dp[1] = 1;\n    dp[2] = 2;\n    for(int i = 3; i <= n; i++){\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n\n}", "prefix": "int climbStairs(int n"}
{"id": "16", "path": "output2\\c\\Easy\\16-remove-duplicates-from-sorted-list.c", "hypo_code": "struct ListNode* deleteDuplicates(struct ListNode* head){\n    struct ListNode *p = head;\n    while(p != NULL && p->next != NULL){\n        if(p->val == p->next->val){\n            p->next = p->next->next;\n        }else{\n            p = p->next;\n        }\n    }\n    return head;\n\n}", "prefix": "struct ListNode* deleteDuplicates(struct ListNode* head"}
{"id": "17", "path": "output2\\c\\Easy\\17-merge-sorted-array.c", "hypo_code": "void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){\n    int i = m - 1;\n    int j = n - 1;\n    int k = m + n - 1;\n    while(i >= 0 && j >= 0){\n        if(nums1[i] > nums2[j]){\n            nums1[k] = nums1[i];\n            i--;\n        }else{\n            nums1[k] = nums2[j];\n            j--;\n        }\n        k--;\n    }\n    while(j >= 0){\n        nums1[k] = nums2[j];\n        j--;\n        k--;\n    }\n\n}", "prefix": "void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n"}
{"id": "18", "path": "output2\\c\\Easy\\18-binary-tree-inorder-traversal.c", "hypo_code": "int* inorderTraversal(struct TreeNode* root, int* returnSize){\n    int *result = (int *)malloc(sizeof(int) * 100);\n    int index = 0;\n    struct TreeNode *p = root;\n    struct TreeNode *pre = NULL;\n    while(p != NULL){\n        if(p->left == NULL){\n            result[index++] = p->val;\n            p = p->right;\n        }else{\n            pre = p->left;\n            while(pre->right != NULL && pre->right != p){\n                pre = pre->right;\n            }\n            if(pre->right == NULL){\n                pre->right = p;\n                p = p->left;\n            }else{\n                pre->right = NULL;\n                result[index++] = p->val;\n                p = p->right;\n            }\n        }\n    }\n    *returnSize = index;\n    return result;\n\n}", "prefix": "int* inorderTraversal(struct TreeNode* root, int* returnSize"}
{"id": "19", "path": "output2\\c\\Easy\\19-same-tree.c", "hypo_code": "bool isSameTree(struct TreeNode* p, struct TreeNode* q){\n    if(p == NULL && q == NULL){\n        return true;\n    }else if(p == NULL || q == NULL){\n        return false;\n    }else{\n        if(p->val == q->val){\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        }else{\n            return false;\n        }\n    }\n\n}", "prefix": "bool isSameTree(struct TreeNode* p, struct TreeNode* q"}
{"id": "20", "path": "output2\\c\\Easy\\20-symmetric-tree.c", "hypo_code": "bool isSymmetric(struct TreeNode* root){\n    if(root == NULL){\n        return true;\n    }\n    return isSymmetricTree(root->left, root->right);\n\n}", "prefix": "bool isSymmetric(struct TreeNode* root"}
{"id": "21", "path": "output2\\c\\Easy\\21-maximum-depth-of-binary-tree.c", "hypo_code": "int maxDepth(struct TreeNode* root){\n    if(root == NULL){\n        return 0;\n    }\n    int left = maxDepth(root->left);\n    int right = maxDepth(root->right);\n    return left > right ? left + 1 : right + 1;\n\n}", "prefix": "int maxDepth(struct TreeNode* root"}
{"id": "22", "path": "output2\\c\\Easy\\22-convert-sorted-array-to-binary-search-tree.c", "hypo_code": "struct TreeNode* sortedArrayToBST(int* nums, int numsSize){\n    if(numsSize == 0){\n        return NULL;\n    }\n    int mid = numsSize / 2;\n    struct TreeNode *root = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    root->val = nums[mid];\n    root->left = sortedArrayToBST(nums, mid);\n    root->right = sortedArrayToBST(nums + mid + 1, numsSize - mid - 1);\n    return root;\n\n}", "prefix": "struct TreeNode* sortedArrayToBST(int* nums, int numsSize"}
{"id": "23", "path": "output2\\c\\Easy\\23-balanced-binary-tree.c", "hypo_code": "bool isBalanced(struct TreeNode* root){\n    if(root == NULL){\n        return true;\n    }\n    int left = maxDepth(root->left);\n    int right = maxDepth(root->right);\n    if(abs(left - right) > 1){\n        return false;\n    }\n    return isBalanced(root->left) && isBalanced(root->right);\n\n}", "prefix": "bool isBalanced(struct TreeNode* root"}
{"id": "24", "path": "output2\\c\\Easy\\24-minimum-depth-of-binary-tree.c", "hypo_code": "int minDepth(struct TreeNode* root){\n    if(root == NULL){\n        return 0;\n    }\n    int left = minDepth(root->left);\n    int right = minDepth(root->right);\n    if(left == 0 || right == 0){\n        return left + right + 1;\n    }\n    return left < right ? left + 1 : right + 1;\n\n}", "prefix": "int minDepth(struct TreeNode* root"}
{"id": "25", "path": "output2\\c\\Easy\\25-path-sum.c", "hypo_code": "bool hasPathSum(struct TreeNode* root, int targetSum){\n    if(root == NULL){\n        return false;\n    }\n    if(root->left == NULL && root->right == NULL){\n        return targetSum == root->val;\n    }\n    return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\n\n}", "prefix": "bool hasPathSum(struct TreeNode* root, int targetSum"}
{"id": "26", "path": "output2\\c\\Easy\\26-pascals-triangle.c", "hypo_code": "int** generate(int numRows, int* returnSize, int** returnColumnSizes){\n    int **result = (int **)malloc(sizeof(int *) * numRows);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * numRows);\n    for(int i = 0; i < numRows; i++){\n        result[i] = (int *)malloc(sizeof(int) * (i + 1));\n        (*returnColumnSizes)[i] = i + 1;\n        for(int j = 0; j <= i; j++){\n            if(j == 0 || j == i){\n                result[i][j] = 1;\n            }else{\n                result[i][j] = result[i - 1][j - 1] + result[i - 1][j];\n            }\n        }\n    }\n    *returnSize = numRows;\n    return result;\n    \n\n}", "prefix": "int** generate(int numRows, int* returnSize, int** returnColumnSizes"}
{"id": "27", "path": "output2\\c\\Easy\\27-pascals-triangle-ii.c", "hypo_code": "int* getRow(int rowIndex, int* returnSize){\n    int *result = (int *)malloc(sizeof(int) * (rowIndex + 1));\n    for(int i = 0; i <= rowIndex; i++){\n        result[i] = 1;\n        for(int j = i - 1; j > 0; j--){\n            result[j] = result[j - 1] + result[j];\n        }\n    }\n    *returnSize = rowIndex + 1;\n    return result;\n\n}", "prefix": "int* getRow(int rowIndex, int* returnSize"}
{"id": "28", "path": "output2\\c\\Easy\\28-best-time-to-buy-and-sell-stock.c", "hypo_code": "int maxProfit(int* prices, int pricesSize){\n    int min = prices[0];\n    int max = 0;\n    for(int i = 1; i < pricesSize; i++){\n        if(prices[i] < min){\n            min = prices[i];\n        }else if(prices[i] - min > max){\n            max = prices[i] - min;\n        }\n    }\n    return max;\n\n}", "prefix": "int maxProfit(int* prices, int pricesSize"}
{"id": "29", "path": "output2\\c\\Easy\\29-valid-palindrome.c", "hypo_code": "bool isPalindrome(char * s){\n    int len = strlen(s);\n    if(len == 0){\n        return true;\n    }\n    int i = 0;\n    int j = len - 1;\n    while(i < j){\n        if(!isalnum(s[i])){\n            i++;\n            continue;\n        }\n        if(!isalnum(s[j])){\n            j--;\n            continue;\n        }\n        if(tolower(s[i]) != tolower(s[j])){\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n\n}", "prefix": "bool isPalindrome(char * s"}
{"id": "30", "path": "output2\\c\\Easy\\30-single-number.c", "hypo_code": "int singleNumber(int* nums, int numsSize){\n    int result = 0;\n    for(int i = 0; i < numsSize; i++){\n        result ^= nums[i];\n    }\n    return result;\n\n}", "prefix": "int singleNumber(int* nums, int numsSize"}
{"id": "31", "path": "output2\\c\\Easy\\31-linked-list-cycle.c", "hypo_code": "bool hasCycle(struct ListNode *head) {\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    while(fast != NULL && fast->next != NULL){\n        slow = slow->next;\n        fast = fast->next->next;\n        if(slow == fast){\n            return true;\n        }\n    }\n    return false;\n    \n}", "prefix": "bool hasCycle(struct ListNode *head"}
{"id": "32", "path": "output2\\c\\Easy\\32-binary-tree-preorder-traversal.c", "hypo_code": "int* preorderTraversal(struct TreeNode* root, int* returnSize){\n    int *result = (int *)malloc(sizeof(int) * 100);\n    int index = 0;\n    struct TreeNode *p = root;\n    struct TreeNode *pre = NULL;\n    while(p != NULL){\n        if(p->left == NULL){\n            result[index++] = p->val;\n            p = p->right;\n        }else{\n            pre = p->left;\n            while(pre->right != NULL && pre->right != p){\n                pre = pre->right;\n            }\n            if(pre->right == NULL){\n                pre->right = p;\n                result[index++] = p->val;\n                p = p->left;\n            }else{\n                pre->right = NULL;\n                p = p->right;\n            }\n        }\n    }\n    *returnSize = index;\n    return result;\n\n}", "prefix": "int* preorderTraversal(struct TreeNode* root, int* returnSize"}
{"id": "33", "path": "output2\\c\\Easy\\33-binary-tree-postorder-traversal.c", "hypo_code": "int* postorderTraversal(struct TreeNode* root, int* returnSize){\n    int *result = (int *)malloc(sizeof(int) * 100);\n    int index = 0;\n    struct TreeNode *p = root;\n    struct TreeNode *pre = NULL;\n    while(p != NULL){\n        if(p->left == NULL){\n            result[index++] = p->val;\n            p = p->right;\n        }else{\n            pre = p->left;\n            while(pre->right != NULL && pre->right != p){\n                pre = pre->right;\n            }\n            if(pre->right == NULL){\n                pre->right = p;\n                p = p->left;\n            }else{\n                pre->right = NULL;\n                result[index++] = p->val;\n                p = p->right;\n            }\n        }\n    }\n    *returnSize = index;\n    return result;\n\n}", "prefix": "int* postorderTraversal(struct TreeNode* root, int* returnSize"}
{"id": "34", "path": "output2\\c\\Easy\\34-intersection-of-two-linked-lists.c", "hypo_code": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    struct ListNode *p = headA;\n    struct ListNode *q = headB;\n    while(p != q){\n        p = p == NULL ? headB : p->next;\n        q = q == NULL ? headA : q->next;\n    }\n    return p;\n    \n}", "prefix": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB"}
{"id": "35", "path": "output2\\c\\Easy\\35-excel-sheet-column-title.c", "hypo_code": "char * convertToTitle(int columnNumber){\n    char *res = (char *)malloc(sizeof(char) * 8);\n    int i = 0;\n    while (columnNumber > 0) {\n        res[i++] = (columnNumber - 1) % 26 + 'A';\n        columnNumber = (columnNumber - 1) / 26;\n    }\n    res[i] = '\\0';\n    int len = strlen(res);\n    for (i = 0; i < len / 2; i++) {\n        char tmp = res[i];\n        res[i] = res[len - i - 1];\n        res[len - i - 1] = tmp;\n    }\n    return res;\n\n}", "prefix": "char * convertToTitle(int columnNumber"}
{"id": "36", "path": "output2\\c\\Easy\\36-majority-element.c", "hypo_code": "int majorityElement(int* nums, int numsSize){\n    int i = 0, j = 0;\n    int count = 0;\n    for (i = 0; i < numsSize; i++) {\n        if (count == 0) {\n            j = nums[i];\n            count++;\n        } else {\n            if (j == nums[i]) count++;\n            else count--;\n        }\n    }\n    return j;\n   \n\n}", "prefix": "int majorityElement(int* nums, int numsSize"}
{"id": "37", "path": "output2\\c\\Easy\\37-excel-sheet-column-number.c", "hypo_code": "int titleToNumber(char * columnTitle){\n\n}", "prefix": "int titleToNumber(char * columnTitle"}
{"id": "42", "path": "output2\\c\\Easy\\42-reverse-bits.c", "hypo_code": "uint32_t reverseBits(uint32_t n) {\n    uint32_t res = 0;\n    int i = 0;\n    for (i = 0; i < 32; i++) {\n        res = (res << 1) + (n & 1);\n        n >>= 1;\n    }\n    return res;\n\n    \n}", "prefix": "int i = 0"}
{"id": "43", "path": "output2\\c\\Easy\\43-number-of-1-bits.c", "hypo_code": "int hammingWeight(uint32_t n) {\n    int count = 0;\n    while (n > 0) {\n        if (n & 1) count++;\n        n >>= 1;\n    }\n    return count;\n    \n}", "prefix": "int hammingWeight(uint32_t n"}
{"id": "48", "path": "output2\\c\\Easy\\48-happy-number.c", "hypo_code": "bool isHappy(int n){  \n     int sum = 0;\n    int count = 0;\n    while (count < 100) {\n        while (n > 0) {\n            sum += (n % 10) * (n % 10);\n            n /= 10;\n        }\n        if (sum == 1) return true;\n        n = sum;\n        sum = 0;\n        count++;\n    }\n    return false;\n\n}", "prefix": "bool isHappy(int n"}
{"id": "49", "path": "output2\\c\\Easy\\49-remove-linked-list-elements.c", "hypo_code": "struct ListNode* removeElements(struct ListNode* head, int val){\n    struct ListNode *p = head;\n    struct ListNode *pre = NULL;\n    while(p != NULL){\n        if(p->val == val){\n            if(pre == NULL){\n                head = p->next;\n            }else{\n                pre->next = p->next;\n            }\n            p = p->next;\n        }else{\n            pre = p;\n            p = p->next;\n        }\n    }\n    return head;\n\n}", "prefix": "struct ListNode* removeElements(struct ListNode* head, int val"}
{"id": "50", "path": "output2\\c\\Easy\\50-isomorphic-strings.c", "hypo_code": "bool isIsomorphic(char * s, char * t){\n    int sLen = strlen(s);\n    int tLen = strlen(t);\n    if(sLen != tLen){\n        return false;\n    }\n    int sMap[128] = {0};\n    int tMap[128] = {0};\n    for(int i = 0; i < sLen; i++){\n        if(sMap[s[i]] != tMap[t[i]]){\n            return false;\n        }\n        sMap[s[i]] = i + 1;\n        tMap[t[i]] = i + 1;\n    }\n    return true;\n\n}", "prefix": "bool isIsomorphic(char * s, char * t"}
{"id": "51", "path": "output2\\c\\Easy\\51-reverse-linked-list.c", "hypo_code": "struct ListNode* reverseList(struct ListNode* head){\n    struct ListNode *p = head;\n    struct ListNode *pre = NULL;\n    while(p != NULL){\n        struct ListNode *next = p->next;\n        p->next = pre;\n        pre = p;\n        p = next;\n    }\n    return pre;\n\n}", "prefix": "struct ListNode* reverseList(struct ListNode* head"}
{"id": "52", "path": "output2\\c\\Easy\\52-contains-duplicate.c", "hypo_code": "bool containsDuplicate(int* nums, int numsSize){\n    int map[100000] = {0};\n    for(int i = 0; i < numsSize; i++){\n        if(map[nums[i]] == 1){\n            return true;\n        }\n        map[nums[i]] = 1;\n    }\n    return false;\n\n}", "prefix": "bool containsDuplicate(int* nums, int numsSize"}
{"id": "53", "path": "output2\\c\\Easy\\53-contains-duplicate-ii.c", "hypo_code": "bool containsNearbyDuplicate(int* nums, int numsSize, int k){\n    int map[100000] = {0};\n    for(int i = 0; i < numsSize; i++){\n        if(map[nums[i]] != 0 && i + 1 - map[nums[i]] <= k){\n            return true;\n        }\n        map[nums[i]] = i + 1;\n    }\n    return false;\n\n}", "prefix": "bool containsNearbyDuplicate(int* nums, int numsSize, int k"}
{"id": "54", "path": "output2\\c\\Easy\\54-count-complete-tree-nodes.c", "hypo_code": "int countNodes(struct TreeNode* root){ \n     if (root == NULL) return 0;\n    return countNodes(root->left) + countNodes(root->right) + 1;\n\n     \n\n}", "prefix": "int countNodes(struct TreeNode* root"}
{"id": "56", "path": "output2\\c\\Easy\\56-invert-binary-tree.c", "hypo_code": "struct TreeNode* invertTree(struct TreeNode* root){\n    if(root == NULL){\n        return NULL;\n    }\n    struct TreeNode *temp = root->left;\n    root->left = root->right;\n    root->right = temp;\n    invertTree(root->left);\n    invertTree(root->right);\n    return root;\n\n}", "prefix": "struct TreeNode* invertTree(struct TreeNode* root"}
{"id": "57", "path": "output2\\c\\Easy\\57-summary-ranges.c", "hypo_code": "char ** summaryRanges(int* nums, int numsSize, int* returnSize){\n    if(numsSize == 0){\n        *returnSize = 0;\n        return NULL;\n    }\n    char **result = (char **)malloc(sizeof(char *) * numsSize);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int count = 0;\n    while(i < numsSize){\n        j = i;\n        while(j < numsSize - 1 && nums[j] + 1 == nums[j + 1]){\n            j++;\n        }\n        if(i == j){\n            result[k] = (char *)malloc(sizeof(char) * 10);\n            sprintf(result[k], \"%d\", nums[i]);\n            k++;\n        }else{\n            result[k] = (char *)malloc(sizeof(char) * 20);\n            sprintf(result[k], \"%d->%d\", nums[i], nums[j]);\n            k++;\n        }\n        i = j + 1;\n    }\n    *returnSize = k;\n    return result;\n\n}", "prefix": "char ** summaryRanges(int* nums, int numsSize, int* returnSize"}
{"id": "58", "path": "output2\\c\\Easy\\58-power-of-two.c", "hypo_code": "bool isPowerOfTwo(int n){\n    if(n <= 0){\n        return false;\n    }\n    while(n != 1){\n        if(n % 2 != 0){\n            return false;\n        }\n        n = n / 2;\n    }\n    return true;\n\n}", "prefix": "bool isPowerOfTwo(int n"}
{"id": "60", "path": "output2\\c\\Easy\\60-palindrome-linked-list.c", "hypo_code": "bool isPalindrome(struct ListNode* head){\n    if(head == NULL){\n        return true;\n    }\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    while(fast != NULL && fast->next != NULL){\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    struct ListNode *prev = NULL;\n    struct ListNode *curr = slow;\n    struct ListNode *next = NULL;\n    while(curr != NULL){\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    struct ListNode *temp = head;\n    while(prev != NULL){\n        if(temp->val != prev->val){\n            return false;\n        }\n        temp = temp->next;\n        prev = prev->next;\n    }\n    return true;\n\n}", "prefix": "bool isPalindrome(struct ListNode* head"}
{"id": "61", "path": "output2\\c\\Easy\\61-valid-anagram.c", "hypo_code": "bool isAnagram(char * s, char * t){\n    int len1 = strlen(s);\n    int len2 = strlen(t);\n    if(len1 != len2){\n        return false;\n    }\n    int arr[26] = {0};\n    for(int i = 0; i < len1; i++){\n        arr[s[i] - 'a']++;\n        arr[t[i] - 'a']--;\n    }\n    for(int i = 0; i < 26; i++){\n        if(arr[i] != 0){\n            return false;\n        }\n    }\n    return true;\n\n}", "prefix": "bool isAnagram(char * s, char * t"}
{"id": "62", "path": "output2\\c\\Easy\\62-binary-tree-paths.c", "hypo_code": "char ** binaryTreePaths(struct TreeNode* root, int* returnSize){\n      char **res = (char **)malloc(sizeof(char *) * 1000);\n        int i = 0;\n        if (root == NULL) {\n            *returnSize = 0;\n            return res;\n        }\n        if (root->left == NULL && root->right == NULL) {\n            res[i] = (char *)malloc(sizeof(char) * 1000);\n            sprintf(res[i], \"%d\", root->val);\n            *returnSize = 1;\n            return res;\n        }\n        int leftSize = 0, rightSize = 0;\n        char **left = binaryTreePaths(root->left, &leftSize);\n        char **right = binaryTreePaths(root->right, &rightSize);\n        for (i = 0; i < leftSize; i++) {\n            res[i] = (char *)malloc(sizeof(char) * 1000);\n            sprintf(res[i], \"%d->%s\", root->val, left[i]);\n        }\n        for (i = 0; i < rightSize; i++) {\n            res[i + leftSize] = (char *)malloc(sizeof(char) * 1000);\n            sprintf(res[i + leftSize], \"%d->%s\", root->val, right[i]);\n        }\n        *returnSize = leftSize + rightSize;\n        return res;      \n \n \n \n   \n\n        \n}", "prefix": "char ** binaryTreePaths(struct TreeNode* root, int* returnSize"}
{"id": "63", "path": "output2\\c\\Easy\\63-add-digits.c", "hypo_code": "int addDigits(int num){\n   if (num == 0) return 0;\n   return num % 9 == 0 ? 9 : num % 9;\n\n}", "prefix": "int addDigits(int num"}
{"id": "64", "path": "output2\\c\\Easy\\64-ugly-number.c", "hypo_code": "bool isUgly(int n){\n    if (n == 0) return false;\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;\n            continue;\n        }\n        if (n % 3 == 0) {\n            n /= 3;\n            continue;\n        }\n        if (n % 5 == 0) {\n            n /= 5;\n            continue;\n        }\n        return false;\n    }\n    return true;\n\n}", "prefix": "bool isUgly(int n"}
{"id": "65", "path": "output2\\c\\Easy\\65-missing-number.c", "hypo_code": "int missingNumber(int* nums, int numsSize){\n    int sum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n    }\n    return (1 + numsSize) * numsSize / 2 - sum;\n\n}", "prefix": "int missingNumber(int* nums, int numsSize"}
{"id": "66", "path": "output2\\c\\Easy\\66-first-bad-version.c", "hypo_code": "int firstBadVersion(int n) {\n    int left = 1, right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) right = mid;\n        else left = mid + 1;\n    }\n    return left;  \n}", "prefix": "int firstBadVersion(int n"}
{"id": "67", "path": "output2\\c\\Easy\\67-move-zeroes.c", "hypo_code": "void moveZeroes(int* nums, int numsSize){\n    int i = 0, j = 0;\n    for (i = 0; i < numsSize; i++) {\n        if (nums[i] != 0) nums[j++] = nums[i];\n    }\n    for (i = j; i < numsSize; i++) {\n        nums[i] = 0;\n    }\n\n}", "prefix": "void moveZeroes(int* nums, int numsSize"}
{"id": "68", "path": "output2\\c\\Easy\\68-word-pattern.c", "hypo_code": "bool wordPattern(char * pattern, char * s){\n    char *map[26] = {NULL};\n    char *token = strtok(s, \" \");\n    int i = 0;\n    while (token) {\n        if (i >= strlen(pattern)) return false;\n        char *p = map[pattern[i] - 'a'];\n        if (p == NULL) {\n            for (int j = 0; j < 26; j++) {\n                if (map[j] && strcmp(map[j], token) == 0) return false;\n            }\n            map[pattern[i] - 'a'] = token;\n        } else if (strcmp(p, token) != 0) return false;\n        token = strtok(NULL, \" \");\n        i++;\n    }\n    return i == strlen(pattern);\n\n}", "prefix": "bool wordPattern(char * pattern, char * s"}
{"id": "69", "path": "output2\\c\\Easy\\69-nim-game.c", "hypo_code": "bool canWinNim(int n){\n  return n % 4 != 0;\n}", "prefix": "bool canWinNim(int n"}
{"id": "71", "path": "output2\\c\\Easy\\71-power-of-three.c", "hypo_code": "bool isPowerOfThree(int n){\n     return n > 0 && 1162261467 % n == 0\n\n}", "prefix": "bool isPowerOfThree(int n"}
{"id": "72", "path": "output2\\c\\Easy\\72-counting-bits.c", "hypo_code": "int* countBits(int n, int* returnSize){\n    *returnSize = n + 1;\n  int *array = (int *)malloc((*returnSize) * sizeof(int));\n  memset(array, 0, (*returnSize) * sizeof(int));\n  for(int i = 1; i <= n; i++) {\n    array[i] = array[i >> 1] + (i & 1);\n  }\n  return array;\n\n}", "prefix": "int* countBits(int n, int* returnSize"}
{"id": "73", "path": "output2\\c\\Easy\\73-power-of-four.c", "hypo_code": "bool isPowerOfFour(int n){\n    return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;\n\n}", "prefix": "bool isPowerOfFour(int n"}
{"id": "74", "path": "output2\\c\\Easy\\74-reverse-string.c", "hypo_code": "void reverseString(char* s, int sSize){\n    char temp;\n  for(int i = 0; i < sSize / 2; i++) {\n    temp = s[i];\n    s[i] = s[sSize - 1 - i];\n    s[sSize - 1 - i] = temp;\n  }\n\n}", "prefix": "void reverseString(char* s, int sSize"}
{"id": "75", "path": "output2\\c\\Easy\\75-reverse-vowels-of-a-string.c", "hypo_code": "char * reverseVowels(char * s){\n    int i = 0, j = strlen(s) - 1;\n  char temp;\n  while(i < j) {\n    while(i < j && !strchr(\"aeiouAEIOU\", s[i])) {\n      i++;\n    }\n    while(i < j && !strchr(\"aeiouAEIOU\", s[j])) {\n      j--;\n    }\n    temp = s[i];\n    s[i] = s[j];\n    s[j] = temp;\n    i++;\n    j--;\n  }\n  return s;\n\n}", "prefix": "char * reverseVowels(char * s"}
{"id": "76", "path": "output2\\c\\Easy\\76-intersection-of-two-arrays.c", "hypo_code": "int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\n    int *array = (int *)malloc(nums1Size * sizeof(int));\n  *returnSize = 0;\n  if(nums1Size == 0 || nums2Size == 0) {\n    return array;\n  }\n  int *hash = (int *)malloc(1000 * sizeof(int));\n  memset(hash, 0, 1000 * sizeof(int));\n  for(int i = 0; i < nums1Size; i++) {\n    hash[nums1[i]] = 1;\n  }\n  for(int i = 0; i < nums2Size; i++) {\n    if(hash[nums2[i]] == 1) {\n      hash[nums2[i]] = 2;\n    }\n  }\n  for(int i = 0; i < 1000; i++) {\n    if(hash[i] == 2) {\n      array[*returnSize] = i;\n      (*returnSize)++;\n    }\n  }\n  return array;\n\n}", "prefix": "int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize"}
{"id": "77", "path": "output2\\c\\Easy\\77-intersection-of-two-arrays-ii.c", "hypo_code": "int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\n  int *array = (int *)malloc(nums1Size * sizeof(int));\n  *returnSize = 0;\n  if(nums1Size == 0 || nums2Size == 0) {\n    return array;\n  }\n  int *hash = (int *)malloc(1000 * sizeof(int));\n  memset(hash, 0, 1000 * sizeof(int));\n  for(int i = 0; i < nums1Size; i++) {\n    hash[nums1[i]]++;\n  }\n  for(int i = 0; i < nums2Size; i++) {\n    if(hash[nums2[i]] > 0) {\n      hash[nums2[i]]--;\n      array[*returnSize] = nums2[i];\n      (*returnSize)++;\n    }\n  }\n  return array;\n   \n\n}", "prefix": "int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize"}
{"id": "78", "path": "output2\\c\\Easy\\78-valid-perfect-square.c", "hypo_code": "bool isPerfectSquare(int num){\n    if(num == 1){\n        return true;\n    }\n    int left = 1;\n    int right = num / 2;\n    while(left <= right){\n        int mid = left + (right - left) / 2;\n        if(mid == num / mid && num % mid == 0){\n            return true;\n        }\n        else if(mid < num / mid){\n            left = mid + 1;\n        }\n        else{\n            right = mid - 1;\n        }\n    }\n    return false;\n\n}", "prefix": "bool isPerfectSquare(int num"}
{"id": "79", "path": "output2\\c\\Easy\\79-guess-number-higher-or-lower.c", "hypo_code": "int guessNumber(int n){\n    int left = 1;\n    int right = n;\n    while(left <= right){\n        int mid = left + (right - left) / 2;\n        int result = guess(mid);\n        if(result == 0){\n            return mid;\n        }\n        else if(result == -1){\n            right = mid - 1;\n        }\n        else{\n            left = mid + 1;\n        }\n    }\n    return -1;\n\t\n}", "prefix": "int guessNumber(int n"}
{"id": "80", "path": "output2\\c\\Easy\\80-ransom-note.c", "hypo_code": "bool canConstruct(char * ransomNote, char * magazine){\n    int len1 = strlen(ransomNote);\n    int len2 = strlen(magazine);\n    if(len1 > len2){\n        return false;\n    }\n    int arr[26] = {0};\n    for(int i = 0; i < len2; i++){\n        arr[magazine[i] - 'a']++;\n    }\n    for(int i = 0; i < len1; i++){\n        arr[ransomNote[i] - 'a']--;\n        if(arr[ransomNote[i] - 'a'] < 0){\n            return false;\n        }\n    }\n    return true;\n\n}", "prefix": "bool canConstruct(char * ransomNote, char * magazine"}
{"id": "81", "path": "output2\\c\\Easy\\81-first-unique-character-in-a-string.c", "hypo_code": "int firstUniqChar(char * s){\n    int count[26] = {0};\n    int i = 0;\n    while(s[i] != '\\0'){\n        count[s[i] - 'a']++;\n        i++;\n    }\n    i = 0;\n    while(s[i] != '\\0'){\n        if(count[s[i] - 'a'] == 1){\n            return i;\n        }\n        i++;\n    }\n    return -1;\n\n}", "prefix": "int firstUniqChar(char * s"}
{"id": "82", "path": "output2\\c\\Easy\\82-find-the-difference.c", "hypo_code": "char findTheDifference(char * s, char * t){\n    int len1 = strlen(s);\n    int len2 = strlen(t);\n    int arr[26] = {0};\n    for(int i = 0; i < len1; i++){\n        arr[s[i] - 'a']++;\n    }\n    for(int i = 0; i < len2; i++){\n        arr[t[i] - 'a']--;\n        if(arr[t[i] - 'a'] < 0){\n            return t[i];\n        }\n    }\n    return 'a';\n\n}", "prefix": "char findTheDifference(char * s, char * t"}
{"id": "83", "path": "output2\\c\\Easy\\83-is-subsequence.c", "hypo_code": "bool isSubsequence(char * s, char * t){\n    int sLen = strlen(s);\n    int tLen = strlen(t);\n    if(sLen == 0){\n        return true;\n    }\n    if(tLen == 0){\n        return false;\n    }\n    int i = 0;\n    int j = 0;\n    while(i < sLen && j < tLen){\n        if(s[i] == t[j]){\n            i++;\n        }\n        j++;\n    }\n    if(i == sLen){\n        return true;\n    }\n    return false;\n\n}", "prefix": "bool isSubsequence(char * s, char * t"}
{"id": "84", "path": "output2\\c\\Easy\\84-binary-watch.c", "hypo_code": "char ** readBinaryWatch(int turnedOn, int* returnSize){\n    char **result = (char **)malloc(sizeof(char *) * 1000);\n    int count = 0;\n    for(int i = 0; i < 12; i++){\n        for(int j = 0; j < 60; j++){\n            int sum = 0;\n            int temp = i;\n            while(temp > 0){\n                sum += temp % 2;\n                temp /= 2;\n            }\n            temp = j;\n            while(temp > 0){\n                sum += temp % 2;\n                temp /= 2;\n            }\n            if(sum == turnedOn){\n                result[count] = (char *)malloc(sizeof(char) * 10);\n                sprintf(result[count], \"%d:%02d\", i, j);\n                count++;\n            }\n        }\n    }\n    *returnSize = count;\n    return result;\n\n}", "prefix": "char ** readBinaryWatch(int turnedOn, int* returnSize"}
{"id": "85", "path": "output2\\c\\Easy\\85-sum-of-left-leaves.c", "hypo_code": "int sumOfLeftLeaves(struct TreeNode* root){\n    if(root == NULL){\n        return 0;\n    }\n    int sum = 0;\n    if(root->left != NULL && root->left->left == NULL && root->left->right == NULL){\n        sum += root->left->val;\n    }\n    sum += sumOfLeftLeaves(root->left);\n    sum += sumOfLeftLeaves(root->right);\n    return sum;\n\n}", "prefix": "int sumOfLeftLeaves(struct TreeNode* root"}
{"id": "86", "path": "output2\\c\\Easy\\86-convert-a-number-to-hexadecimal.c", "hypo_code": "char * toHex(int num){\n    if(num == 0){\n        return \"0\";\n    }\n    char *result = (char *)malloc(sizeof(char) * 9);\n    int index = 0;\n    while(num != 0 && index < 8){\n        int temp = num & 0xf;\n        if(temp < 10){\n            result[index++] = temp + '0';\n        }\n        else{\n            result[index++] = temp - 10 + 'a';\n        }\n        num >>= 4;\n    }\n    result[index] = '\\0';\n    int left = 0;\n    int right = index - 1;\n    while(left < right){\n        char temp = result[left];\n        result[left] = result[right];\n        result[right] = temp;\n        left++;\n        right--;\n    }\n    return result;\n\n}", "prefix": "char * toHex(int num"}
{"id": "87", "path": "output2\\c\\Easy\\87-longest-palindrome.c", "hypo_code": "int longestPalindrome(char * s){\n    int len = strlen(s);\n    int arr[52] = {0};\n    for(int i = 0; i < len; i++){\n        if(s[i] >= 'a' && s[i] <= 'z'){\n            arr[s[i] - 'a']++;\n        }\n        else{\n            arr[s[i] - 'A' + 26]++;\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < 52; i++){\n        if(arr[i] % 2 == 0){\n            count += arr[i];\n        }\n        else{\n            count += arr[i] - 1;\n        }\n    }\n    if(count < len){\n        count++;\n    }\n    return count;\n\n}", "prefix": "int longestPalindrome(char * s"}
{"id": "88", "path": "output2\\c\\Easy\\88-fizz-buzz.c", "hypo_code": "char ** fizzBuzz(int n, int* returnSize){\n    char **result = (char **)malloc(sizeof(char *) * n);\n    for(int i = 0; i < n; i++){\n        result[i] = (char *)malloc(sizeof(char) * 10);\n        if((i + 1) % 3 == 0 && (i + 1) % 5 == 0){\n            sprintf(result[i], \"FizzBuzz\");\n        }else if((i + 1) % 3 == 0){\n            sprintf(result[i], \"Fizz\");\n        }else if((i + 1) % 5 == 0){\n            sprintf(result[i], \"Buzz\");\n        }else{\n            sprintf(result[i], \"%d\", i + 1);\n        }\n    }\n    *returnSize = n;\n    return result;\n\n}", "prefix": "char ** fizzBuzz(int n, int* returnSize"}
{"id": "89", "path": "output2\\c\\Easy\\89-third-maximum-number.c", "hypo_code": "int thirdMax(int* nums, int numsSize){\n    int max1 = INT_MIN;\n    int max2 = INT_MIN;\n    int max3 = INT_MIN;\n    int i = 0;\n    int flag = 0;\n    while(i < numsSize){\n        if(nums[i] > max1){\n            max3 = max2;\n            max2 = max1;\n            max1 = nums[i];\n        }else if(nums[i] > max2 && nums[i] < max1){\n            max3 = max2;\n            max2 = nums[i];\n        }else if(nums[i] > max3 && nums[i] < max2){\n            max3 = nums[i];\n        }\n        i++;\n    }\n    if(max3 == INT_MIN){\n        return max1;\n    }\n    return max3;\n\n}", "prefix": "int thirdMax(int* nums, int numsSize"}
{"id": "90", "path": "output2\\c\\Easy\\90-add-strings.c", "hypo_code": "char * addStrings(char * num1, char * num2){\n    int len1 = strlen(num1);\n    int len2 = strlen(num2);\n    int len = len1 > len2 ? len1 : len2;\n    char *result = (char *)malloc(sizeof(char) * (len + 2));\n    int index = 0;\n    int carry = 0;\n    int i = len1 - 1;\n    int j = len2 - 1;\n    while(i >= 0 || j >= 0){\n        int temp = carry;\n        if(i >= 0){\n            temp += num1[i] - '0';\n            i--;\n        }\n        if(j >= 0){\n            temp += num2[j] - '0';\n            j--;\n        }\n        result[index++] = temp % 10 + '0';\n        carry = temp / 10;\n    }\n    if(carry != 0){\n        result[index++] = carry + '0';\n    }\n    result[index] = '\\0';\n    int left = 0;\n    int right = index - 1;\n    while(left < right){\n        char temp = result[left];\n        result[left] = result[right];\n        result[right] = temp;\n        left++;\n        right--;\n    }\n    return result;\n\n}", "prefix": "char * addStrings(char * num1, char * num2"}
{"id": "91", "path": "output2\\c\\Easy\\91-number-of-segments-in-a-string.c", "hypo_code": "int countSegments(char * s){\n    int count = 0;\n    int i = 0;\n    while(s[i] != '\\0'){\n        if(s[i] != ' ' && (i == 0 || s[i - 1] == ' ')){\n            count++;\n        }\n        i++;\n    }\n    return count;\n\n}", "prefix": "int countSegments(char * s"}
{"id": "92", "path": "output2\\c\\Easy\\92-arranging-coins.c", "hypo_code": "int arrangeCoins(int n){\n    int i = 1;\n    while(n >= i){\n        n = n - i;\n        i++;\n    }\n    return i - 1;\n\n}", "prefix": "int arrangeCoins(int n"}
{"id": "93", "path": "output2\\c\\Easy\\93-find-all-numbers-disappeared-in-an-array.c", "hypo_code": "int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){\n    int *result = (int *)malloc(sizeof(int) * numsSize);\n    int i = 0;\n    int j = 0;\n    while(i < numsSize){\n        result[i] = i + 1;\n        i++;\n    }\n    i = 0;\n    while(i < numsSize){\n        result[nums[i] - 1] = 0;\n        i++;\n    }\n    i = 0;\n    while(i < numsSize){\n        if(result[i] != 0){\n            result[j] = result[i];\n            j++;\n        }\n        i++;\n    }\n    *returnSize = j;\n    return result;\n\n}", "prefix": "int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize"}
{"id": "94", "path": "output2\\c\\Easy\\94-assign-cookies.c", "hypo_code": "int findContentChildren(int* g, int gSize, int* s, int sSize){\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    qsort(g, gSize, sizeof(int), cmpfunc);\n    qsort(s, sSize, sizeof(int), cmpfunc);\n    while(i < gSize && j < sSize){\n        if(g[i] <= s[j]){\n            count++;\n            i++;\n            j++;\n        }else{\n            j++;\n        }\n    }\n    return count;\n\n\n}", "prefix": "int findContentChildren(int* g, int gSize, int* s, int sSize"}
{"id": "95", "path": "output2\\c\\Easy\\95-repeated-substring-pattern.c", "hypo_code": "bool repeatedSubstringPattern(char * s){\n    int len = strlen(s);\n    for(int i = 1; i <= len / 2; i++){\n        if(len % i == 0){\n            int j = i;\n            while(j < len){\n                if(s[j] != s[j - i]){\n                    break;\n                }\n                j++;\n            }\n            if(j == len){\n                return true;\n            }\n        }\n    }\n    return false;\n\n}", "prefix": "bool repeatedSubstringPattern(char * s"}
{"id": "96", "path": "output2\\c\\Easy\\96-hamming-distance.c", "hypo_code": "int hammingDistance(int x, int y){\n    int count = 0;\n    int i = 0;\n    while(i < 32){\n        if((x & 1) != (y & 1)){\n            count++;\n        }\n        x = x >> 1;\n        y = y >> 1;\n        i++;\n    }\n    return count;\n\n}", "prefix": "int hammingDistance(int x, int y"}
{"id": "97", "path": "output2\\c\\Easy\\97-island-perimeter.c", "hypo_code": "int islandPerimeter(int** grid, int gridSize, int* gridColSize){\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    for(i = 0; i < gridSize; i++){\n        for(j = 0; j < gridColSize[i]; j++){\n            if(grid[i][j] == 1){\n                if(i == 0){\n                    count++;\n                }\n                if(i == gridSize - 1){\n                    count++;\n                }\n                if(j == 0){\n                    count++;\n                }\n                if(j == gridColSize[i] - 1){\n                    count++;\n                }\n                if(i > 0 && grid[i - 1][j] == 0){\n                    count++;\n                }\n                if(i < gridSize - 1 && grid[i + 1][j] == 0){\n                    count++;\n                }\n                if(j > 0 && grid[i][j - 1] == 0){\n                    count++;\n                }\n                if(j < gridColSize[i] - 1 && grid[i][j + 1] == 0){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int islandPerimeter(int** grid, int gridSize, int* gridColSize"}
{"id": "98", "path": "output2\\c\\Easy\\98-number-complement.c", "hypo_code": "int findComplement(int num){\n    int i = 0;\n    int count = 0;\n    while(i < 32){\n        if((num & 1) == 0){\n            count += 1 << i;\n        }\n        num = num >> 1;\n        i++;\n    }\n    return count;\n\n\n}", "prefix": "int findComplement(int num"}
{"id": "99", "path": "output2\\c\\Easy\\99-license-key-formatting.c", "hypo_code": "char * licenseKeyFormatting(char * s, int k){\n    int len = strlen(s);\n    int count = 0;\n    for(int i = 0; i < len; i++){\n        if(s[i] != '-'){\n            count++;\n        }\n    }\n    int first = count % k;\n    int second = count / k;\n    char *result = (char *)malloc(sizeof(char) * (count + second + 1));\n    int index = 0;\n    int temp = 0;\n    for(int i = 0; i < len; i++){\n        if(s[i] != '-'){\n            if(temp < first){\n                if(s[i] >= 'a' && s[i] <= 'z'){\n                    result[index++] = s[i] - 32;\n                }\n                else{\n                    result[index++] = s[i];\n                }\n                temp++;\n            }\n            else{\n                if(temp == k){\n                    result[index++] = '-';\n                    temp = 0;\n                }\n                if(s[i] >= 'a' && s[i] <= 'z'){\n                    result[index++] = s[i] - 32;\n                }\n                else{\n                    result[index++] = s[i];\n                }\n                temp++;\n            }\n        }\n    }\n    result[index] = '\\0';\n    return result;\n\n}", "prefix": "char * licenseKeyFormatting(char * s, int k"}
{"id": "100", "path": "output2\\c\\Easy\\100-max-consecutive-ones.c", "hypo_code": "int findMaxConsecutiveOnes(int* nums, int numsSize){\n    int max = 0;\n    int count = 0;\n    int i = 0;\n    while(i < numsSize){\n        if(nums[i] == 1){\n            count++;\n        }else{\n            if(count > max){\n                max = count;\n            }\n            count = 0;\n        }\n        i++;\n    }\n    if(count > max){\n        max = count;\n    }\n    return max;\n\n}", "prefix": "int findMaxConsecutiveOnes(int* nums, int numsSize"}
{"id": "101", "path": "output2\\c\\Easy\\101-construct-the-rectangle.c", "hypo_code": "int* constructRectangle(int area, int* returnSize){\n    int *result = (int *)malloc(sizeof(int) * 2);\n    int i = 1;\n    int j = area;\n    while(i <= j){\n        if(i * j == area){\n            result[0] = j;\n            result[1] = i;\n            break;\n        }else if(i * j > area){\n            j--;\n        }else{\n            i++;\n        }\n    }\n    *returnSize = 2;\n    return result;\n\n}", "prefix": "int* constructRectangle(int area, int* returnSize"}
{"id": "102", "path": "output2\\c\\Easy\\102-teemo-attacking.c", "hypo_code": "int findPoisonedDuration(int* timeSeries, int timeSeriesSize, int duration){\n    int i = 0;\n    int count = 0;\n    while(i < timeSeriesSize - 1){\n        if(timeSeries[i + 1] - timeSeries[i] >= duration){\n            count += duration;\n        }else{\n            count += timeSeries[i + 1] - timeSeries[i];\n        }\n        i++;\n    }\n    if(timeSeriesSize > 0){\n        count += duration;\n    }\n    return count;\n\n\n}", "prefix": "int findPoisonedDuration(int* timeSeries, int timeSeriesSize, int duration"}
{"id": "103", "path": "output2\\c\\Easy\\103-next-greater-element-i.c", "hypo_code": "int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\n    int* ans = (int*)malloc(nums1Size * sizeof(int));\n    *returnSize = nums1Size;\n    for(int i = 0; i < nums1Size; i++){\n        int j = 0;\n        while(nums2[j] != nums1[i]){\n            j++;\n        }\n        while(j < nums2Size && nums2[j] <= nums1[i]){\n            j++;\n        }\n        if(j == nums2Size){\n            ans[i] = -1;\n        }else{\n            ans[i] = nums2[j];\n        }\n    }\n    return ans;\n\n}", "prefix": "int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize"}
{"id": "104", "path": "output2\\c\\Easy\\104-keyboard-row.c", "hypo_code": "char ** findWords(char ** words, int wordsSize, int* returnSize){\n    char* row1 = \"qwertyuiop\";\n    char* row2 = \"asdfghjkl\";\n    char* row3 = \"zxcvbnm\";\n    char** ans = (char**)malloc(wordsSize * sizeof(char*));\n    *returnSize = 0;\n    for(int i = 0; i < wordsSize; i++){\n        int j = 0;\n        int row = 0;\n        while(words[i][j] != '\\0'){\n            if(strchr(row1, tolower(words[i][j])) != NULL){\n                if(row == 0){\n                    row = 1;\n                }else if(row != 1){\n                    break;\n                }\n            }else if(strchr(row2, tolower(words[i][j])) != NULL){\n                if(row == 0){\n                    row = 2;\n                }else if(row != 2){\n                    break;\n                }\n            }else if(strchr(row3, tolower(words[i][j])) != NULL){\n                if(row == 0){\n                    row = 3;\n                }else if(row != 3){\n                    break;\n                }\n            }\n            j++;\n        }\n        if(words[i][j] == '\\0'){\n            ans[*returnSize] = (char*)malloc((j + 1) * sizeof(char));\n            strcpy(ans[*returnSize], words[i]);\n            (*returnSize)++;\n        }\n    }\n    return ans;\n\n}", "prefix": "char ** findWords(char ** words, int wordsSize, int* returnSize"}
{"id": "105", "path": "output2\\c\\Easy\\105-find-mode-in-binary-search-tree.c", "hypo_code": "int* findMode(struct TreeNode* root, int* returnSize){\n    int* ans = (int*)malloc(10000 * sizeof(int));\n    *returnSize = 0;\n    int max = 0;\n    int count = 0;\n    int prev = 0;\n    struct TreeNode* curr = root;\n    struct TreeNode* pre = NULL;\n    while(curr != NULL){\n        if(curr->left == NULL){\n            if(prev == curr->val){\n                count++;\n            }else{\n                count = 1;\n            }\n            if(count > max){\n                max = count;\n                *returnSize = 0;\n                ans[*returnSize] = curr->val;\n                (*returnSize)++;\n            }else if(count == max){\n                ans[*returnSize] = curr->val;\n                (*returnSize)++;\n            }\n            prev = curr->val;\n            curr = curr->right;\n        }else{\n            pre = curr->left;\n            while(pre->right != NULL && pre->right != curr){\n                pre = pre->right;\n            }\n            if(pre->right == NULL){\n                pre->right = curr;\n                curr = curr->left;\n            }else{\n                pre->right = NULL;\n                if(prev == curr->val){\n                    count++;\n                }else{\n                    count = 1;\n                }\n                if(count > max){\n                    max = count;\n                    *returnSize = 0;\n                    ans[*returnSize] = curr->val;\n                    (*returnSize)++;\n                }else if(count == max){\n                    ans[*returnSize] = curr->val;\n                    (*returnSize)++;\n                }\n                prev = curr->val;\n                curr = curr->right;\n            }\n        }\n    }\n    return ans;\n\n}", "prefix": "int* findMode(struct TreeNode* root, int* returnSize"}
{"id": "106", "path": "output2\\c\\Easy\\106-base-7.c", "hypo_code": "char * convertToBase7(int num){\n    char* ans = (char*)malloc(12 * sizeof(char));\n    int i = 0;\n    if(num == 0){\n        ans[i] = '0';\n        i++;\n    }else{\n        int sign = 1;\n        if(num < 0){\n            sign = -1;\n            num = -num;\n        }\n        while(num > 0){\n            ans[i] = num % 7 + '0';\n            num /= 7;\n            i++;\n        }\n        if(sign == -1){\n            ans[i] = '-';\n            i++;\n        }\n    }\n    ans[i] = '\\0';\n    int j = 0;\n    i--;\n    while(j < i){\n        char temp = ans[j];\n        ans[j] = ans[i];\n        ans[i] = temp;\n        j++;\n        i--;\n    }\n    return ans;\n    \n\n}", "prefix": "char * convertToBase7(int num"}
{"id": "107", "path": "output2\\c\\Easy\\107-relative-ranks.c", "hypo_code": "char ** findRelativeRanks(int* score, int scoreSize, int* returnSize){\n    int* sorted = (int*)malloc(scoreSize * sizeof(int));\n    for(int i = 0; i < scoreSize; i++){\n        sorted[i] = score[i];\n    }\n    qsort(sorted, scoreSize, sizeof(int), cmpfunc);\n    char** ans = (char**)malloc(scoreSize * sizeof(char*));\n    *returnSize = scoreSize;\n    for(int i = 0; i < scoreSize; i++){\n        int j = 0;\n        while(score[i] != sorted[j]){\n            j++;\n        }\n        if(j == 0){\n            ans[i] = (char*)malloc(10 * sizeof(char));\n            strcpy(ans[i], \"Gold Medal\");\n        }else if(j == 1){\n            ans[i] = (char*)malloc(12 * sizeof(char));\n            strcpy(ans[i], \"Silver Medal\");\n        }else if(j == 2){\n            ans[i] = (char*)malloc(12 * sizeof(char));\n            strcpy(ans[i], \"Bronze Medal\");\n        }else{\n            ans[i] = (char*)malloc(10 * sizeof(char));\n            sprintf(ans[i], \"%d\", j + 1);\n        }\n    }\n    return ans;\n\n\n}", "prefix": "char ** findRelativeRanks(int* score, int scoreSize, int* returnSize"}
{"id": "108", "path": "output2\\c\\Easy\\108-perfect-number.c", "hypo_code": "bool checkPerfectNumber(int num){\n    if(num == 1){\n        return false;\n    }\n    int sum = 1;\n    for(int i = 2; i * i <= num; i++){\n        if(num % i == 0){\n            sum += i;\n            if(i * i != num){\n                sum += num / i;\n            }\n        }\n    }\n    return sum == num;\n\n}", "prefix": "bool checkPerfectNumber(int num"}
{"id": "109", "path": "output2\\c\\Easy\\109-fibonacci-number.c", "hypo_code": "int fib(int n){\n    if(n == 0){\n        return 0;\n    }\n    if(n == 1){\n        return 1;\n    }\n    int a = 0;\n    int b = 1;\n    int c = 0;\n    for(int i = 2; i <= n; i++){\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n\n}", "prefix": "int fib(int n"}
{"id": "111", "path": "output2\\c\\Easy\\111-detect-capital.c", "hypo_code": "bool detectCapitalUse(char * word){\n    int i = 0;\n    int count = 0;\n    while(word[i] != '\\0'){\n        if(word[i] >= 'A' && word[i] <= 'Z'){\n            count++;\n        }\n        i++;\n    }\n    if(count == 0 || count == i || (count == 1 && word[0] >= 'A' && word[0] <= 'Z')){\n        return true;\n    }\n    return false;\n\n}", "prefix": "bool detectCapitalUse(char * word"}
{"id": "112", "path": "output2\\c\\Easy\\112-longest-uncommon-subsequence-i.c", "hypo_code": "int findLUSlength(char * a, char * b){\n    int len1 = strlen(a);\n    int len2 = strlen(b);\n    if(len1 != len2){\n        return len1 > len2 ? len1 : len2;\n    }\n    else{\n        if(strcmp(a, b) == 0){\n            return -1;\n        }\n        else{\n            return len1;\n        }\n    }\n\n}", "prefix": "int findLUSlength(char * a, char * b"}
{"id": "113", "path": "output2\\c\\Easy\\113-minimum-absolute-difference-in-bst.c", "hypo_code": "int getMinimumDifference(struct TreeNode* root){\n    int min = INT_MAX;\n    int prev = -1;\n    struct TreeNode* curr = root;\n    struct TreeNode* pre = NULL;\n    while(curr != NULL){\n        if(curr->left == NULL){\n            if(prev != -1){\n                int diff = curr->val - prev;\n                if(diff < min){\n                    min = diff;\n                }\n            }\n            prev = curr->val;\n            curr = curr->right;\n        }else{\n            pre = curr->left;\n            while(pre->right != NULL && pre->right != curr){\n                pre = pre->right;\n            }\n            if(pre->right == NULL){\n                pre->right = curr;\n                curr = curr->left;\n            }else{\n                pre->right = NULL;\n                int diff = curr->val - prev;\n                if(diff < min){\n                    min = diff;\n                }\n                prev = curr->val;\n                curr = curr->right;\n            }\n        }\n    }\n    return min;\n\n}", "prefix": "int getMinimumDifference(struct TreeNode* root"}
{"id": "114", "path": "output2\\c\\Easy\\114-reverse-string-ii.c", "hypo_code": "char * reverseStr(char * s, int k){\n    int len = strlen(s);\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    while(i < len){\n        if(i + k <= len){\n            j = i + k - 1;\n        }\n        else{\n            j = len - 1;\n        }\n        while(i < j){\n            temp = s[i];\n            s[i] = s[j];\n            s[j] = temp;\n            i++;\n            j--;\n        }\n        i += k;\n    }\n    return s;\n\n}", "prefix": "char * reverseStr(char * s, int k"}
{"id": "115", "path": "output2\\c\\Easy\\115-diameter-of-binary-tree.c", "hypo_code": "int diameterOfBinaryTree(struct TreeNode* root){\n    int max = 0;\n    int count = 0;\n    int prev = 0;\n    struct TreeNode* curr = root;\n    struct TreeNode* pre = NULL;\n    while(curr != NULL){\n        if(curr->left == NULL){\n            if(prev == curr->val){\n                count++;\n            }else{\n                count = 1;\n            }\n            if(count > max){\n                max = count;\n            }\n            prev = curr->val;\n            curr = curr->right;\n        }else{\n            pre = curr->left;\n            while(pre->right != NULL && pre->right != curr){\n                pre = pre->right;\n            }\n            if(pre->right == NULL){\n                pre->right = curr;\n                curr = curr->left;\n            }else{\n                pre->right = NULL;\n                if(prev == curr->val){\n                    count++;\n                }else{\n                    count = 1;\n                }\n                if(count > max){\n                    max = count;\n                }\n                prev = curr->val;\n                curr = curr->right;\n            }\n        }\n    }\n    return max;\n\n}", "prefix": "int diameterOfBinaryTree(struct TreeNode* root"}
{"id": "116", "path": "output2\\c\\Easy\\116-student-attendance-record-i.c", "hypo_code": "bool checkRecord(char * s){\n    int len = strlen(s);\n    int countA = 0;\n    int countL = 0;\n    for(int i = 0; i < len; i++){\n        if(s[i] == 'A'){\n            countA++;\n            countL = 0;\n        }\n        else if(s[i] == 'L'){\n            countL++;\n        }\n        else{\n            countL = 0;\n        }\n        if(countA >= 2 || countL >= 3){\n            return false;\n        }\n    }\n    return true;\n\n}", "prefix": "bool checkRecord(char * s"}
{"id": "117", "path": "output2\\c\\Easy\\117-reverse-words-in-a-string-iii.c", "hypo_code": "char * reverseWords(char * s){\n    int len = strlen(s);\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    while(i < len){\n        if(s[i] == ' '){\n            i++;\n            continue;\n        }\n        j = i;\n        while(j < len && s[j] != ' '){\n            j++;\n        }\n        j--;\n        while(i < j){\n            temp = s[i];\n            s[i] = s[j];\n            s[j] = temp;\n            i++;\n            j--;\n        }\n        i = j + 1;\n    }\n    return s;\n\n}", "prefix": "char * reverseWords(char * s"}
{"id": "118", "path": "output2\\c\\Easy\\118-maximum-depth-of-n-ary-tree.c", "hypo_code": "int maxDepth(struct Node* root) {\n    if(root == NULL){\n        return 0;\n    }\n    int max = 0;\n    for(int i = 0; i < root->numChildren; i++){\n        int depth = maxDepth(root->children[i]);\n        if(depth > max){\n            max = depth;\n        }\n    }\n    return max + 1;\n    \n}", "prefix": "int maxDepth(struct Node* root"}
{"id": "119", "path": "output2\\c\\Easy\\119-array-partition.c", "hypo_code": "int arrayPairSum(int* nums, int numsSize){\n    int result = 0;\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    for(i = 0; i < numsSize - 1; i++){\n        for(j = 0; j < numsSize - i - 1; j++){\n            if(nums[j] > nums[j + 1]){\n                temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n            }\n        }\n    }\n    for(i = 0; i < numsSize; i += 2){\n        result += nums[i];\n    }\n    return result;\n\n}", "prefix": "int arrayPairSum(int* nums, int numsSize"}
{"id": "120", "path": "output2\\c\\Easy\\120-binary-tree-tilt.c", "hypo_code": "int findTilt(struct TreeNode* root){\n    if(root == NULL){\n        return 0;\n    }\n    int left = findTilt(root->left);\n    int right = findTilt(root->right);\n    int sum = 0;\n    if(root->left != NULL){\n        sum += root->left->val;\n    }\n    if(root->right != NULL){\n        sum += root->right->val;\n    }\n    return abs(sum - root->val) + left + right;\n\n}", "prefix": "int findTilt(struct TreeNode* root"}
{"id": "121", "path": "output2\\c\\Easy\\121-reshape-the-matrix.c", "hypo_code": "int** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){\n    int **result = (int **)malloc(sizeof(int *) * r);\n    int *columnSize = (int *)malloc(sizeof(int) * r);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    if(matSize * (*matColSize) != r * c){\n        *returnSize = matSize;\n        *returnColumnSizes = matColSize;\n        return mat;\n    }\n    for(i = 0; i < r; i++){\n        result[i] = (int *)malloc(sizeof(int) * c);\n        columnSize[i] = c;\n    }\n    for(i = 0; i < matSize; i++){\n        for(j = 0; j < *matColSize; j++){\n            result[k][l] = mat[i][j];\n            l++;\n            if(l == c){\n                l = 0;\n                k++;\n            }\n        }\n    }\n    *returnSize = r;\n    *returnColumnSizes = columnSize;\n    return result;\n\n}", "prefix": "int** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes"}
{"id": "122", "path": "output2\\c\\Easy\\122-subtree-of-another-tree.c", "hypo_code": "bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot){\n    if(root == NULL){\n        return false;\n    }\n    if(isSameTree(root, subRoot)){\n        return true;\n    }\n    return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);\n\n}", "prefix": "bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot"}
{"id": "123", "path": "output2\\c\\Easy\\123-distribute-candies.c", "hypo_code": "int distributeCandies(int* candyType, int candyTypeSize){\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    int max = candyTypeSize / 2;\n    int temp = 0;\n    for(i = 0; i < candyTypeSize - 1; i++){\n        for(j = 0; j < candyTypeSize - i - 1; j++){\n            if(candyType[j] > candyType[j + 1]){\n                temp = candyType[j];\n                candyType[j] = candyType[j + 1];\n                candyType[j + 1] = temp;\n            }\n        }\n    }\n    for(i = 0; i < candyTypeSize; i++){\n        if(i == 0){\n            count++;\n        }else if(candyType[i] != candyType[i - 1]){\n            count++;\n        }\n    }\n    if(count > max){\n        return max;\n    }else{\n        return count;\n    }\n\n}", "prefix": "int distributeCandies(int* candyType, int candyTypeSize"}
{"id": "127", "path": "output2\\c\\Easy\\127-n-ary-tree-preorder-traversal.c", "hypo_code": "int* preorder(struct Node* root, int* returnSize) {\n    int *result = (int *)malloc(sizeof(int) * 100);\n    int index = 0;\n    struct Node *p = root;\n    struct Node *pre = NULL;\n    while(p != NULL){\n        if(p->numChildren == 0){\n            result[index++] = p->val;\n            p = p->children[0];\n        }else{\n            pre = p->children[p->numChildren - 1];\n            while(pre->numChildren != 0 && pre->children[pre->numChildren - 1] != p){\n                pre = pre->children[pre->numChildren - 1];\n            }\n            if(pre->numChildren == 0){\n                pre->children[pre->numChildren++] = p;\n                result[index++] = p->val;\n                p = p->children[0];\n            }else{\n                pre->numChildren--;\n                p = p->children[0];\n            }\n        }\n    }\n    *returnSize = index;\n    return result;\n    \n}", "prefix": "int* preorder(struct Node* root, int* returnSize"}
{"id": "128", "path": "output2\\c\\Easy\\128-n-ary-tree-postorder-traversal.c", "hypo_code": "int* postorder(struct Node* root, int* returnSize) {\n       \n\n       \n}", "prefix": "int* postorder(struct Node* root, int* returnSize"}
{"id": "129", "path": "output2\\c\\Easy\\129-longest-harmonious-subsequence.c", "hypo_code": "int findLHS(int* nums, int numsSize){\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    int result = 0;\n    int count = 0;\n    for(i = 0; i < numsSize - 1; i++){\n        for(j = 0; j < numsSize - i - 1; j++){\n            if(nums[j] > nums[j + 1]){\n                temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n            }\n        }\n    }\n    for(i = 0; i < numsSize; i++){\n        count = 1;\n        for(j = i + 1; j < numsSize; j++){\n            if(nums[j] - nums[i] == 1){\n                count++;\n            }\n            else if(nums[j] - nums[i] > 1){\n                break;\n            }\n        }\n        if(count > result){\n            result = count;\n        }\n    }\n    return result;\n\n}", "prefix": "int findLHS(int* nums, int numsSize"}
{"id": "132", "path": "output2\\c\\Easy\\132-range-addition-ii.c", "hypo_code": "int maxCount(int m, int n, int** ops, int opsSize, int* opsColSize){\n    int row = m;\n  int col = n;\n  for(int i = 0; i < opsSize; i++) {\n    if(ops[i][0] < row) {\n      row = ops[i][0];\n    }\n    if(ops[i][1] < col) {\n      col = ops[i][1];\n    }\n  }\n  return row * col;\n\n}", "prefix": "int maxCount(int m, int n, int** ops, int opsSize, int* opsColSize"}
{"id": "133", "path": "output2\\c\\Easy\\133-minimum-index-sum-of-two-lists.c", "hypo_code": "char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){\n    int *hash = (int *)malloc(list1Size * sizeof(int));\n  memset(hash, 0, list1Size * sizeof(int));\n  for(int i = 0; i < list1Size; i++) {\n    for(int j = 0; j < list2Size; j++) {\n      if(strcmp(list1[i], list2[j]) == 0) {\n        hash[i] = j + i;\n      }\n    }\n  }\n  int min = hash[0];\n  for(int i = 0; i < list1Size; i++) {\n    if(hash[i] < min) {\n      min = hash[i];\n    }\n  }\n  char **array = (char **)malloc(list1Size * sizeof(char *));\n  *returnSize = 0;\n  for(int i = 0; i < list1Size; i++) {\n    if(hash[i] == min) {\n      array[*returnSize] = (char *)malloc(30 * sizeof(char));\n      array[*returnSize] = list1[i];\n      (*returnSize)++;\n    }\n  }\n  return array;\n\n}", "prefix": "char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize"}
{"id": "134", "path": "output2\\c\\Easy\\134-can-place-flowers.c", "hypo_code": "bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n){\n  int count = 0;\n  for(int i = 0; i < flowerbedSize; i++) {\n    if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbedSize - 1 || flowerbed[i + 1] == 0)) {\n      flowerbed[i] = 1;\n      count++;\n    }\n  }\n  return count >= n;\n}", "prefix": "bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n"}
{"id": "135", "path": "output2\\c\\Easy\\135-construct-string-from-binary-tree.c", "hypo_code": "char * tree2str(struct TreeNode* root){\n    if(root == NULL) {\n    return \"\";\n  }\n  char *left = tree2str(root->left);\n  char *right = tree2str(root->right);\n  char *result = (char *)malloc(sizeof(char) * 10000);\n  if(left == \"\" && right == \"\") {\n    sprintf(result, \"%d\", root->val);\n    return result;\n  }\n  if(left == \"\") {\n    sprintf(result, \"%d()(%s)\", root->val, right);\n    return result;\n  }\n  if(right == \"\") {\n    sprintf(result, \"%d(%s)\", root->val, left);\n    return result;\n  }\n  sprintf(result, \"%d(%s)(%s)\", root->val, left, right);\n  return result;\n\n}", "prefix": "char * tree2str(struct TreeNode* root"}
{"id": "138", "path": "output2\\c\\Easy\\138-merge-two-binary-trees.c", "hypo_code": "struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\nif(root1 == NULL) {\n    return root2;\n  }\n  if(root2 == NULL) {\n    return root1;\n  }\n  root1->val += root2->val;\n  root1->left = mergeTrees(root1->left, root2->left);\n  root1->right = mergeTrees(root1->right, root2->right);\n  return root1;\n}", "prefix": "struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2"}
{"id": "142", "path": "output2\\c\\Easy\\142-maximum-product-of-three-numbers.c", "hypo_code": "int maximumProduct(int* nums, int numsSize){\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    int result = 0;\n    int count = 0;\n    for(i = 0; i < numsSize - 1; i++){\n        for(j = 0; j < numsSize - i - 1; j++){\n            if(nums[j] > nums[j + 1]){\n                temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n            }\n        }\n    }\n    if(nums[0] * nums[1] * nums[numsSize - 1] > nums[numsSize - 1] * nums[numsSize - 2] * nums[numsSize - 3]){\n        return nums[0] * nums[1] * nums[numsSize - 1];\n    }else{\n        return nums[numsSize - 1] * nums[numsSize - 2] * nums[numsSize - 3];\n    }\n\n}", "prefix": "int maximumProduct(int* nums, int numsSize"}
{"id": "143", "path": "output2\\c\\Easy\\143-average-of-levels-in-binary-tree.c", "hypo_code": "double* averageOfLevels(struct TreeNode* root, int* returnSize){\n    double *result = (double *)malloc(sizeof(double) * 100);\n    int *count = (int *)malloc(sizeof(int) * 100);\n    int index = 0;\n    struct TreeNode *p = root;\n    struct TreeNode *pre = NULL;\n    while(p != NULL){\n        if(p->left == NULL && p->right == NULL){\n            result[index] += p->val;\n            count[index]++;\n            p = p->left;\n        }else{\n            pre = p->right;\n            while(pre->left != NULL && pre->left != p){\n                pre = pre->left;\n            }\n            if(pre->left == NULL){\n                pre->left = p;\n                result[index] += p->val;\n                count[index]++;\n                p = p->left;\n            }else{\n                pre->left = NULL;\n                p = p->right;\n            }\n        }\n        if(p == NULL){\n            index++;\n            p = root;\n        }\n    }\n    *returnSize = index;\n    for(int i = 0; i < index; i++){\n        result[i] /= count[i];\n    }\n    return result;\n\n}", "prefix": "double* averageOfLevels(struct TreeNode* root, int* returnSize"}
{"id": "144", "path": "output2\\c\\Easy\\144-maximum-average-subarray-i.c", "hypo_code": "double findMaxAverage(int* nums, int numsSize, int k){\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    int result = 0;\n    int count = 0;\n    for(i = 0; i < numsSize - 1; i++){\n        for(j = 0; j < numsSize - i - 1; j++){\n            if(nums[j] > nums[j + 1]){\n                temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n            }\n        }\n    }\n    for(i = 0; i < numsSize - k + 1; i++){\n        count = 0;\n        for(j = i; j < i + k; j++){\n            count += nums[j];\n        }\n        if(count > result){\n            result = count;\n        }\n    }\n    return (double)result / k;\n\n\n}", "prefix": "double findMaxAverage(int* nums, int numsSize, int k"}
{"id": "145", "path": "output2\\c\\Easy\\145-set-mismatch.c", "hypo_code": "int* findErrorNums(int* nums, int numsSize, int* returnSize){\n    int *result = (int *)malloc(sizeof(int) * 2);\n    int *count = (int *)malloc(sizeof(int) * (numsSize + 1));\n    for(int i = 0; i < numsSize; i++){\n        count[nums[i]]++;\n    }\n    for(int i = 1; i <= numsSize; i++){\n        if(count[i] == 2){\n            result[0] = i;\n        }else if(count[i] == 0){\n            result[1] = i;\n        }\n    }\n    *returnSize = 2;\n    return result;\n\n}", "prefix": "int* findErrorNums(int* nums, int numsSize, int* returnSize"}
{"id": "146", "path": "output2\\c\\Easy\\146-two-sum-iv-input-is-a-bst.c", "hypo_code": "bool findTarget(struct TreeNode* root, int k){\n    if(root == NULL){\n        return false;\n    }\n    struct TreeNode *p = root;\n    struct TreeNode *pre = NULL;\n    while(p != NULL){\n        if(p->left == NULL && p->right == NULL){\n            p = p->left;\n        }else{\n            pre = p->right;\n            while(pre->left != NULL && pre->left != p){\n                pre = pre->left;\n            }\n            if(pre->left == NULL){\n                pre->left = p;\n                p = p->left;\n            }else{\n                pre->left = NULL;\n                p = p->right;\n            }\n        }\n        if(p == NULL){\n            p = root;\n        }\n    }\n    return false;\n\n}", "prefix": "bool findTarget(struct TreeNode* root, int k"}
{"id": "147", "path": "output2\\c\\Easy\\147-robot-return-to-origin.c", "hypo_code": "bool judgeCircle(char * moves){\n    int len = strlen(moves);\n    int x = 0;\n    int y = 0;\n    for(int i = 0; i < len; i++){\n        if(moves[i] == 'R'){\n            x++;\n        }\n        else if(moves[i] == 'L'){\n            x--;\n        }\n        else if(moves[i] == 'U'){\n            y++;\n        }\n        else{\n            y--;\n        }\n    }\n    if(x == 0 && y == 0){\n        return true;\n    }\n    else{\n        return false;\n    }\n\n}", "prefix": "bool judgeCircle(char * moves"}
{"id": "148", "path": "output2\\c\\Easy\\148-image-smoother.c", "hypo_code": "int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes){\n    int **result = (int **)malloc(sizeof(int *) * imgSize);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * imgSize);\n    for(int i = 0; i < imgSize; i++){\n        result[i] = (int *)malloc(sizeof(int) * imgColSize[i]);\n        (*returnColumnSizes)[i] = imgColSize[i];\n    }\n    for(int i = 0; i < imgSize; i++){\n        for(int j = 0; j < imgColSize[i]; j++){\n            int sum = 0;\n            int count = 0;\n            for(int k = i - 1; k <= i + 1; k++){\n                for(int l = j - 1; l <= j + 1; l++){\n                    if(k >= 0 && k < imgSize && l >= 0 && l < imgColSize[i]){\n                        sum += img[k][l];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n    *returnSize = imgSize;\n    return result;\n\n}", "prefix": "int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes"}
{"id": "149", "path": "output2\\c\\Easy\\149-second-minimum-node-in-a-binary-tree.c", "hypo_code": "int findSecondMinimumValue(struct TreeNode* root){\n    if(root == NULL){\n        return -1;\n    }\n    int left = root->left->val;\n    int right = root->right->val;\n    if(left == root->val){\n        left = findSecondMinimumValue(root->left);\n    }\n    if(right == root->val){\n        right = findSecondMinimumValue(root->right);\n    }\n    if(left != -1 && right != -1){\n        return left < right ? left : right;\n    }\n    if(left != -1){\n        return left;\n    }\n    return right;\n\n}", "prefix": "int findSecondMinimumValue(struct TreeNode* root"}
{"id": "150", "path": "output2\\c\\Easy\\150-longest-continuous-increasing-subsequence.c", "hypo_code": "int findLengthOfLCIS(int* nums, int numsSize){\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    int result = 0;\n    int count = 0;\n    for(i = 0; i < numsSize - 1; i++){\n        for(j = 0; j < numsSize - i - 1; j++){\n            if(nums[j] > nums[j + 1]){\n                temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n            }\n        }\n    }\n    for(i = 0; i < numsSize - 1; i++){\n        if(nums[i] < nums[i + 1]){\n            count++;\n        }else{\n            count = 0;\n        }\n        if(count > result){\n            result = count;\n        }\n    }\n    return result + 1;\n\n}", "prefix": "int findLengthOfLCIS(int* nums, int numsSize"}
{"id": "151", "path": "output2\\c\\Easy\\151-valid-palindrome-ii.c", "hypo_code": "bool validPalindrome(char * s){\n    int len = strlen(s);\n    int i = 0;\n    int j = len - 1;\n    while(i < j){\n        if(s[i] != s[j]){\n            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\n        }\n        i++;\n        j--;\n    }\n    return true;\n\n}", "prefix": "bool validPalindrome(char * s"}
{"id": "152", "path": "output2\\c\\Easy\\152-baseball-game.c", "hypo_code": "int calPoints(char ** operations, int operationsSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum = 0;\n    int temp = 0;\n    int flag = 0;\n    int *arr = (int *)malloc(sizeof(int) * operationsSize);\n    for(i = 0; i < operationsSize; i++){\n        if(operations[i][0] == 'C'){\n            arr[j - 1] = 0;\n            j--;\n        }\n        else if(operations[i][0] == 'D'){\n            arr[j] = arr[j - 1] * 2;\n            j++;\n        }\n        else if(operations[i][0] == '+'){\n            arr[j] = arr[j - 1] + arr[j - 2];\n            j++;\n        }\n        else{\n            arr[j] = atoi(operations[i]);\n            j++;\n        }\n    }\n    for(k = 0; k < j; k++){\n        sum += arr[k];\n    }\n    return sum;\n\n}", "prefix": "int calPoints(char ** operations, int operationsSize"}
{"id": "153", "path": "output2\\c\\Easy\\153-binary-number-with-alternating-bits.c", "hypo_code": "bool hasAlternatingBits(int n){\n    int last = n & 1;\n    n = n >> 1;\n    while(n != 0){\n        int cur = n & 1;\n        if(cur == last){\n            return false;\n        }\n        last = cur;\n        n = n >> 1;\n    }\n    return true;\n\n}", "prefix": "bool hasAlternatingBits(int n"}
{"id": "154", "path": "output2\\c\\Easy\\154-count-binary-substrings.c", "hypo_code": "int countBinarySubstrings(char * s){\n    int len = strlen(s);\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < len){\n        j = i;\n        while(j < len && s[j] == s[i]){\n            j++;\n        }\n        int k = j;\n        while(k < len && s[k] != s[i] && k - j < j - i){\n            k++;\n        }\n        if(k - j == j - i){\n            count++;\n        }\n        i = j;\n    }\n    return count;\n\n}", "prefix": "int countBinarySubstrings(char * s"}
{"id": "155", "path": "output2\\c\\Easy\\155-degree-of-an-array.c", "hypo_code": "int findShortestSubArray(int* nums, int numsSize){\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    int result = 0;\n    int count = 0;\n    for(i = 0; i < numsSize - 1; i++){\n        for(j = 0; j < numsSize - i - 1; j++){\n            if(nums[j] > nums[j + 1]){\n                temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n            }\n        }\n    }\n    for(i = 0; i < numsSize - 1; i++){\n        if(nums[i] < nums[i + 1]){\n            count++;\n        }else{\n            count = 0;\n        }\n        if(count > result){\n            result = count;\n        }\n    }\n    return result + 1;\n\n}", "prefix": "int findShortestSubArray(int* nums, int numsSize"}
{"id": "156", "path": "output2\\c\\Easy\\156-search-in-a-binary-search-tree.c", "hypo_code": "struct TreeNode* searchBST(struct TreeNode* root, int val){\n    if(root == NULL){\n        return NULL;\n    }\n    if(root->val == val){\n        return root;\n    }\n    if(root->val > val){\n        return searchBST(root->left, val);\n    }\n    return searchBST(root->right, val);\n\n}", "prefix": "struct TreeNode* searchBST(struct TreeNode* root, int val"}
{"id": "158", "path": "output2\\c\\Easy\\158-binary-search.c", "hypo_code": "int search(int* nums, int numsSize, int target){\n    int left = 0;\n    int right = numsSize - 1;\n    while(left <= right){\n        int mid = (left + right) / 2;\n        if(nums[mid] == target){\n            return mid;\n        }else if(nums[mid] < target){\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return -1;\n\n}", "prefix": "int search(int* nums, int numsSize, int target"}
{"id": "161", "path": "output2\\c\\Easy\\161-to-lower-case.c", "hypo_code": "char * toLowerCase(char * s){\n    int len = strlen(s);\n    int i = 0;\n    for(i = 0; i < len; i++){\n        if(s[i] >= 'A' && s[i] <= 'Z'){\n            s[i] = s[i] + 32;\n        }\n    }\n    return s;\n\n}", "prefix": "char * toLowerCase(char * s"}
{"id": "162", "path": "output2\\c\\Easy\\162-1-bit-and-2-bit-characters.c", "hypo_code": "bool isOneBitCharacter(int* bits, int bitsSize){\n    int i = 0;\n  while(i < bitsSize - 1) {\n    if(bits[i] == 1) {\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n  return i == bitsSize - 1;\n\n}", "prefix": "bool isOneBitCharacter(int* bits, int bitsSize"}
{"id": "163", "path": "output2\\c\\Easy\\163-find-pivot-index.c", "hypo_code": "int pivotIndex(int* nums, int numsSize){\nif(numsSize == 0) {\n    return -1;\n  }\n  int sum = 0;\n  for(int i = 0; i < numsSize; i++) {\n    sum += nums[i];\n  }\n  int leftSum = 0;\n  for(int i = 0; i < numsSize; i++) {\n    if(leftSum == sum - leftSum - nums[i]) {\n      return i;\n    }\n    leftSum += nums[i];\n  }\n  return -1;\n}", "prefix": "int pivotIndex(int* nums, int numsSize"}
{"id": "164", "path": "output2\\c\\Easy\\164-self-dividing-numbers.c", "hypo_code": "int* selfDividingNumbers(int left, int right, int* returnSize){\n *returnSize = 0;\n  int *array = (int *)malloc((right - left + 1) * sizeof(int));\n  for(int i = left; i <= right; i++) {\n    int temp = i;\n    int flag = 1;\n    while(temp != 0) {\n      int digit = temp % 10;\n      if(digit == 0 || i % digit != 0) {\n        flag = 0;\n        break;\n      }\n      temp /= 10;\n    }\n    if(flag == 1) {\n      array[*returnSize] = i;\n      (*returnSize)++;\n    }\n  }\n  return array;\n}", "prefix": "int* selfDividingNumbers(int left, int right, int* returnSize"}
{"id": "165", "path": "output2\\c\\Easy\\165-flood-fill.c", "hypo_code": "int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes){\n*returnSize = imageSize;\n  *returnColumnSizes = (int *)malloc(imageSize * sizeof(int));\n  for(int i = 0; i < imageSize; i++) {\n    (*returnColumnSizes)[i] = *imageColSize;\n  }\n  if(imageSize == 0 || imageColSize == 0) {\n    return image;\n  }\n  if(image[sr][sc] == color) {\n    return image;\n  }\n  int oldColor = image[sr][sc];\n  image[sr][sc] = color;\n  if(sr > 0 && image[sr - 1][sc] == oldColor) {\n    floodFill(image, imageSize, imageColSize, sr - 1, sc, color, returnSize, returnColumnSizes);\n  }\n  if(sr < imageSize - 1 && image[sr + 1][sc] == oldColor) {\n    floodFill(image, imageSize, imageColSize, sr + 1, sc, color, returnSize, returnColumnSizes);\n  }\n  if(sc > 0 && image[sr][sc - 1] == oldColor) {\n    floodFill(image, imageSize, imageColSize, sr, sc - 1, color, returnSize, returnColumnSizes);\n  }\n  if(sc < *imageColSize - 1 && image[sr][sc + 1] == oldColor) {\n    floodFill(image, imageSize, imageColSize, sr, sc + 1, color, returnSize, returnColumnSizes);\n  }\n  return image;\n}", "prefix": "int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes"}
{"id": "166", "path": "output2\\c\\Easy\\166-find-smallest-letter-greater-than-target.c", "hypo_code": "char nextGreatestLetter(char* letters, int lettersSize, char target){\n  int left = 0;\n  int right = lettersSize;\n  while(left < right) {\n    int mid = left + (right - left) / 2;\n    if(letters[mid] <= target) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return letters[left % lettersSize];\n}", "prefix": "char nextGreatestLetter(char* letters, int lettersSize, char target"}
{"id": "167", "path": "output2\\c\\Easy\\167-min-cost-climbing-stairs.c", "hypo_code": "int minCostClimbingStairs(int* cost, int costSize){\nint dp[costSize + 1];\n  dp[0] = 0;\n  dp[1] = 0;\n  for(int i = 2; i <= costSize; i++) {\n    dp[i] = fmin(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n  }\n  return dp[costSize];\n}", "prefix": "int minCostClimbingStairs(int* cost, int costSize"}
{"id": "168", "path": "output2\\c\\Easy\\168-largest-number-at-least-twice-of-others.c", "hypo_code": "int dominantIndex(int* nums, int numsSize){\n    if(numsSize == 1) return 0;\n  int max = nums[0], secondMax = nums[1], maxIndex = 0;\n  for(int i = 1; i < numsSize; i++) {\n    if(nums[i] > max) {\n      secondMax = max;\n      max = nums[i];\n      maxIndex = i;\n    } else if(nums[i] > secondMax) {\n      secondMax = nums[i];\n    }\n  }\n  return max >= secondMax * 2 ? maxIndex : -1;\n\n}", "prefix": "int dominantIndex(int* nums, int numsSize"}
{"id": "169", "path": "output2\\c\\Easy\\169-shortest-completing-word.c", "hypo_code": "char * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize){\n     int licensePlateCount[26] = {0};\n  for(int i = 0; i < strlen(licensePlate); i++) {\n    if(isalpha(licensePlate[i])) {\n      licensePlateCount[tolower(licensePlate[i]) - 'a']++;\n    }\n  }\n  int minLen = INT_MAX;\n  char *res = NULL;\n  for(int i = 0; i < wordsSize; i++) {\n    int wordCount[26] = {0};\n    for(int j = 0; j < strlen(words[i]); j++) {\n      wordCount[words[i][j] - 'a']++;\n    }\n    bool match = true;\n    for(int j = 0; j < 26; j++) {\n      if(licensePlateCount[j] > wordCount[j]) {\n        match = false;\n        break;\n      }\n    }\n    if(match && strlen(words[i]) < minLen) {\n      res = words[i];\n      minLen = strlen(words[i]);\n    }\n  }\n  return res;\n\n}", "prefix": "char * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize"}
{"id": "170", "path": "output2\\c\\Easy\\170-prime-number-of-set-bits-in-binary-representation.c", "hypo_code": "int countPrimeSetBits(int left, int right){\nint count = 0;\n  int prime[21] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0,\n                   0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0};\n  for(int i = left; i <= right; i++) {\n    int temp = i;\n    int bitCount = 0;\n    while(temp != 0) {\n      bitCount++;\n      temp &= (temp - 1);\n    }\n    if(prime[bitCount] == 1) {\n      count++;\n    }\n  }\n  return count;\n}", "prefix": "int countPrimeSetBits(int left, int right"}
{"id": "171", "path": "output2\\c\\Easy\\171-toeplitz-matrix.c", "hypo_code": "bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){\n int m = matrixSize;\n  int n = matrixColSize[0];\n  for(int i = 0; i < m - 1; i++) {\n    for(int j = 0; j < n - 1; j++) {\n      if(matrix[i][j] != matrix[i + 1][j + 1]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "prefix": "bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "172", "path": "output2\\c\\Easy\\172-jewels-and-stones.c", "hypo_code": "int numJewelsInStones(char * jewels, char * stones){\nint jewelsLen = strlen(jewels);\n    int stonesLen = strlen(stones);\n    int res = 0;\n    for(int i = 0; i < jewelsLen; i++) {\n        for(int j = 0; j < stonesLen; j++) {\n            if(jewels[i] == stones[j]) {\n                res++;\n            }\n        }\n    }\n    return res;\n}", "prefix": "int numJewelsInStones(char * jewels, char * stones"}
{"id": "173", "path": "output2\\c\\Easy\\173-minimum-distance-between-bst-nodes.c", "hypo_code": "int minDiffInBST(struct TreeNode* root){\nint minDiff = INT_MAX, prev = -1;\n  traverse(root, &prev, &minDiff);\n  return minDiff;\n}\nvoid traverse(struct TreeNode* root, int* prev, int* minDiff) {\n  if(root == NULL) {\n    return;\n  }\n  traverse(root->left, prev, minDiff);\n  if(*prev != -1 && root->val - *prev < *minDiff) {\n    *minDiff = root->val - *prev;\n  }\n  *prev = root->val;\n  traverse(root->right, prev, minDiff);\n}", "prefix": "int minDiffInBST(struct TreeNode* root"}
{"id": "174", "path": "output2\\c\\Easy\\174-rotate-string.c", "hypo_code": "bool rotateString(char * s, char * goal){\n\n}", "prefix": "bool rotateString(char * s, char * goal"}
{"id": "175", "path": "output2\\c\\Easy\\175-unique-morse-code-words.c", "hypo_code": "int uniqueMorseRepresentations(char ** words, int wordsSize){\nchar *morseCode[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\n                         \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\n                         \"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n  int res = 0;\n  char *transformed[wordsSize];\n  for(int i = 0; i < wordsSize; i++) {\n    transformed[i] = (char *)malloc(sizeof(char) * 100);\n    transformed[i][0] = '\\0';\n    for(int j = 0; j < strlen(words[i]); j++) {\n      strcat(transformed[i], morseCode[words[i][j] - 'a']);\n    }\n  }\n  for(int i = 0; i < wordsSize; i++) {\n    int j;\n    for(j = 0; j < i; j++) {\n      if(strcmp(transformed[i], transformed[j]) == 0) {\n        break;\n      }\n    }\n    if(j == i) {\n      res++;\n    }\n  }\n  return res;\n}", "prefix": "int uniqueMorseRepresentations(char ** words, int wordsSize"}
{"id": "176", "path": "output2\\c\\Easy\\176-number-of-lines-to-write-string.c", "hypo_code": "int* numberOfLines(int* widths, int widthsSize, char * s, int* returnSize){\n*returnSize = 2;\n  int *result = (int *)malloc(sizeof(int) * 2);\n  result[0] = 1;\n  result[1] = 0;\n  for(int i = 0; i < strlen(s); i++) {\n    int width = widths[s[i] - 'a'];\n    if(result[1] + width > 100) {\n      result[0]++;\n      result[1] = width;\n    } else {\n      result[1] += width;\n    }\n  }\n  return result;\n}", "prefix": "int* numberOfLines(int* widths, int widthsSize, char * s, int* returnSize"}
{"id": "177", "path": "output2\\c\\Easy\\177-largest-triangle-area.c", "hypo_code": "double largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\ndouble maxArea = 0;\n  for(int i = 0; i < pointsSize - 2; i++) {\n    for(int j = i + 1; j < pointsSize - 1; j++) {\n      for(int k = j + 1; k < pointsSize; k++) {\n        int x1 = points[i][0], y1 = points[i][1];\n        int x2 = points[j][0], y2 = points[j][1];\n        int x3 = points[k][0], y3 = points[k][1];\n        double area = 0.5 * abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\n        if(area > maxArea) {\n          maxArea = area;\n        }\n      }\n    }\n  }\n  return maxArea;\n}", "prefix": "double largestTriangleArea(int** points, int pointsSize, int* pointsColSize"}
{"id": "178", "path": "output2\\c\\Easy\\178-most-common-word.c", "hypo_code": "char * mostCommonWord(char * paragraph, char ** banned, int bannedSize){\nchar *res = NULL;\n  int maxCount = 0;\n  char *p = strtok(paragraph, \"!?',;.\");\n  char *map[1000];\n  int mapSize = 0;\n  while(p != NULL) {\n    map[mapSize++] = p;\n    p = strtok(NULL, \"!?',;.\");\n  }\n  int count[mapSize];\n  memset(count, 0, sizeof(count));\n  for(int i = 0; i < mapSize; i++) {\n    for(int j = 0; j < bannedSize; j++) {\n      if(strcmp(map[i], banned[j]) == 0) {\n        count[i] = -1;\n        break;\n      }\n    }\n    if(count[i] == -1) continue;\n    count[i]++;\n    if(count[i] > maxCount) {\n      res = map[i];\n      maxCount = count[i];\n    }\n  }\n  return res;\n}", "prefix": "char * mostCommonWord(char * paragraph, char ** banned, int bannedSize"}
{"id": "179", "path": "output2\\c\\Easy\\179-shortest-distance-to-a-character.c", "hypo_code": "int* shortestToChar(char * s, char c, int* returnSize){\nint *res = (int *)malloc(sizeof(int) * strlen(s));\n  int prev = -100000;\n  for(int i = 0; i < strlen(s); i++) {\n    if(s[i] == c) prev = i;\n    res[i] = i - prev;\n  }\n  prev = 20000;\n  for(int i = strlen(s) - 1; i >= 0; i--) {\n    if(s[i] == c) prev = i;\n    res[i] = fmin(res[i], prev - i);\n  }\n  *returnSize = strlen(s);\n  return res;\n}", "prefix": "int* shortestToChar(char * s, char c, int* returnSize"}
{"id": "180", "path": "output2\\c\\Easy\\180-goat-latin.c", "hypo_code": "char * toGoatLatin(char * sentence){\n char *words[101];\n  int wordsSize = 0;\n  char *p = strtok(sentence, \" \");\n  while(p) {\n    words[wordsSize++] = p;\n    p = strtok(NULL, \" \");\n  }\n  char *res = (char *)malloc(sizeof(char) * 10001);\n  res[0] = '\\0';\n  for(int i = 0; i < wordsSize; i++) {\n    if(tolower(words[i][0]) == 'a' || tolower(words[i][0]) == 'e' || tolower(words[i][0]) == 'i' || tolower(words[i][0]) == 'o' || tolower(words[i][0]) == 'u') {\n      strcat(res, words[i]);\n    } else {\n      strcat(res, words[i] + 1);\n      strncat(res, words[i], 1);\n    }\n    strcat(res, \"ma\");\n    for(int j = 0; j < i + 1; j++) {\n      strcat(res, \"a\");\n    }\n    if(i != wordsSize - 1) {\n      strcat(res, \" \");\n    }\n  }\n  return res;\n}", "prefix": "char * toGoatLatin(char * sentence"}
{"id": "181", "path": "output2\\c\\Easy\\181-positions-of-large-groups.c", "hypo_code": "int** largeGroupPositions(char * s, int* returnSize, int** returnColumnSizes){\n int len = strlen(s);\n    int** ret = (int**)malloc(sizeof(int*) * len);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * len);\n    *returnSize = 0;\n    int i = 0;\n    while(i < len){\n        int j = i + 1;\n        while(s[j] == s[i]){\n            j++;\n        }\n        if(j - i >= 3){\n            int* tmp = (int*)malloc(sizeof(int) * 2);\n            tmp[0] = i;\n            tmp[1] = j - 1;\n            ret[*returnSize] = tmp;\n            (*returnColumnSizes)[*returnSize] = 2;\n            (*returnSize)++;\n        }\n        i = j;\n    }\n    return ret;\n}", "prefix": "int** largeGroupPositions(char * s, int* returnSize, int** returnColumnSizes"}
{"id": "182", "path": "output2\\c\\Easy\\182-flipping-an-image.c", "hypo_code": "int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){\n*returnSize = imageSize;\n    *returnColumnSizes = imageColSize;\n    int** ret = (int**)malloc(sizeof(int*) * imageSize);\n    for(int i = 0; i < imageSize; i++){\n        int* tmp = (int*)malloc(sizeof(int) * imageColSize[i]);\n        for(int j = 0; j < imageColSize[i]; j++){\n            tmp[j] = 1 - image[i][imageColSize[i] - 1 - j];\n        }\n        ret[i] = tmp;\n    }\n    return ret;\n}", "prefix": "int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes"}
{"id": "183", "path": "output2\\c\\Easy\\183-rectangle-overlap.c", "hypo_code": "bool isRectangleOverlap(int* rec1, int rec1Size, int* rec2, int rec2Size){\nif(rec1[0] == rec1[2] || rec1[1] == rec1[3] || rec2[0] == rec2[2] || rec2[1] == rec2[3]){\n        return false;\n    }\n    if(rec1[0] >= rec2[2] || rec1[2] <= rec2[0] || rec1[1] >= rec2[3] || rec1[3] <= rec2[1]){\n        return false;\n    }\n    return true;\n}", "prefix": "bool isRectangleOverlap(int* rec1, int rec1Size, int* rec2, int rec2Size"}
{"id": "184", "path": "output2\\c\\Easy\\184-backspace-string-compare.c", "hypo_code": "bool backspaceCompare(char * s, char * t){\nint i = 0;\n    int j = 0;\n    int len = strlen(s);\n    int len_t = strlen(t);\n    while(i < len){\n        if(s[i] == '#'){\n            if(i > 0){\n                int k = i;\n                while(k < len){\n                    s[k - 1] = s[k];\n                    k++;\n                }\n                len--;\n                i--;\n            }\n        }\n        i++;\n    }\n    while(j < len_t){\n        if(t[j] == '#'){\n            if(j > 0){\n                int k = j;\n                while(k < len_t){\n                    t[k - 1] = t[k];\n                    k++;\n                }\n                len_t--;\n                j--;\n            }\n        }\n        j++;\n    }\n    if(len != len_t){\n        return false;\n    }\n    for(int m = 0; m < len; m++){\n        if(s[m] != t[m]){\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool backspaceCompare(char * s, char * t"}
{"id": "185", "path": "output2\\c\\Easy\\185-buddy-strings.c", "hypo_code": "bool buddyStrings(char * s, char * goal){\n        int len_s = strlen(s);\n    int len_g = strlen(goal);\n    if(len_s != len_g){\n        return false;\n    }\n    int diff = 0;\n    int diff_index[2];\n    for(int i = 0; i < len_s; i++){\n        if(s[i] != goal[i]){\n            diff++;\n            if(diff > 2){\n                return false;\n            }\n            diff_index[diff - 1] = i;\n        }\n    }\n    if(diff == 0){\n        int repeat[26] = {0};\n        for(int i = 0; i < len_s; i++){\n            if(repeat[s[i] - 'a'] == 1){\n                return true;\n            }\n            repeat[s[i] - 'a']++;\n        }\n        return false;\n    }\n    if(diff == 2){\n        if(s[diff_index[0]] == goal[diff_index[1]] && s[diff_index[1]] == goal[diff_index[0]]){\n            return true;\n        }\n    }\n    return false;\n}", "prefix": "bool buddyStrings(char * s, char * goal"}
{"id": "186", "path": "output2\\c\\Easy\\186-lemonade-change.c", "hypo_code": "bool lemonadeChange(int* bills, int billsSize){\nint change[3] = {0};\n    for(int i = 0; i < billsSize; i++) {\n        if(bills[i] == 5) {\n            change[0]++;\n        } else if(bills[i] == 10) {\n            if(change[0] > 0) {\n                change[0]--;\n                change[1]++;\n            } else {\n                return false;\n            }\n        } else {\n            if(change[1] > 0 && change[0] > 0) {\n                change[1]--;\n                change[0]--;\n                change[2]++;\n            } else if(change[0] > 2) {\n                change[0] -= 3;\n                change[2]++;\n            } else {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool lemonadeChange(int* bills, int billsSize"}
{"id": "187", "path": "output2\\c\\Easy\\187-transpose-matrix.c", "hypo_code": "int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){\n     *returnSize = matrixColSize[0];\n    *returnColumnSizes = (int*)malloc(sizeof(int) * (*returnSize));\n    for(int i = 0; i < *returnSize; i++){\n        (*returnColumnSizes)[i] = matrixSize;\n    }\n    int** ret = (int**)malloc(sizeof(int*) * (*returnSize));\n    for(int i = 0; i < *returnSize; i++){\n        int* tmp = (int*)malloc(sizeof(int) * matrixSize);\n        for(int j = 0; j < matrixSize; j++){\n            tmp[j] = matrix[j][i];\n        }\n        ret[i] = tmp;\n    }\n    return ret;\n}", "prefix": "int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes"}
{"id": "188", "path": "output2\\c\\Easy\\188-binary-gap.c", "hypo_code": "int binaryGap(int n){\nint max = 0;\n    int index = 0;\n    int last = -1;\n    while(n > 0){\n        if(n % 2 == 1){\n            if(last != -1){\n                if(index - last > max){\n                    max = index - last;\n                }\n            }\n            last = index;\n        }\n        index++;\n        n /= 2;\n    }\n    return max;\n}", "prefix": "int binaryGap(int n"}
{"id": "189", "path": "output2\\c\\Easy\\189-leaf-similar-trees.c", "hypo_code": "bool leafSimilar(struct TreeNode* root1, struct TreeNode* root2){\nint* arr1 = (int*)malloc(sizeof(int) * 200);\n  int* arr2 = (int*)malloc(sizeof(int) * 200);\n  int len1 = 0, len2 = 0;\n  traverse(root1, arr1, &len1);\n  traverse(root2, arr2, &len2);\n  if(len1 != len2) {\n    return false;\n  }\n  for(int i = 0; i < len1; i++) {\n    if(arr1[i] != arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nvoid traverse(struct TreeNode* root, int* arr, int* len) {\n  if(root == NULL) {\n    return;\n  }\n  if(root->left == NULL && root->right == NULL) {\n    arr[(*len)++] = root->val;\n  }\n  traverse(root->left, arr, len);\n  traverse(root->right, arr, len);\n}", "prefix": "bool leafSimilar(struct TreeNode* root1, struct TreeNode* root2"}
{"id": "190", "path": "output2\\c\\Easy\\190-middle-of-the-linked-list.c", "hypo_code": "struct ListNode* middleNode(struct ListNode* head){\nstruct ListNode* fast = head;\n    struct ListNode* slow = head;\n    while(fast != NULL && fast->next != NULL) {\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    return slow;\n}", "prefix": "struct ListNode* middleNode(struct ListNode* head"}
{"id": "191", "path": "output2\\c\\Easy\\191-projection-area-of-3d-shapes.c", "hypo_code": "int projectionArea(int** grid, int gridSize, int* gridColSize){\nint xy = 0;\n  int xz = 0;\n  int yz = 0;\n  int n = gridSize;\n  for(int i = 0; i < n; i++) {\n    int max_xz = 0;\n    int max_yz = 0;\n    for(int j = 0; j < n; j++) {\n      if(grid[i][j] > 0) {\n        xy++;\n      }\n      if(grid[i][j] > max_xz) {\n        max_xz = grid[i][j];\n      }\n      if(grid[j][i] > max_yz) {\n        max_yz = grid[j][i];\n      }\n    }\n    xz += max_xz;\n    yz += max_yz;\n  }\n  return xy + xz + yz;\n}", "prefix": "int projectionArea(int** grid, int gridSize, int* gridColSize"}
{"id": "192", "path": "output2\\c\\Easy\\192-uncommon-words-from-two-sentences.c", "hypo_code": "char ** uncommonFromSentences(char * s1, char * s2, int* returnSize){\nchar *words[201];\n  int wordsSize = 0;\n  char *p = strtok(s1, \" \");\n  while(p) {\n    words[wordsSize++] = p;\n    p = strtok(NULL, \" \");\n  }\n  p = strtok(s2, \" \");\n  while(p) {\n    words[wordsSize++] = p;\n    p = strtok(NULL, \" \");\n  }\n  char **res = (char **)malloc(sizeof(char *) * 201);\n  *returnSize = 0;\n  for(int i = 0; i < wordsSize; i++) {\n    int j = 0;\n    for(; j < wordsSize; j++) {\n      if(i == j) {\n        continue;\n      }\n      if(strcmp(words[i], words[j]) == 0) {\n        break;\n      }\n    }\n    if(j == wordsSize) {\n      res[(*returnSize)++] = words[i];\n    }\n  }\n  return res;\n}", "prefix": "char ** uncommonFromSentences(char * s1, char * s2, int* returnSize"}
{"id": "193", "path": "output2\\c\\Easy\\193-fair-candy-swap.c", "hypo_code": "int* fairCandySwap(int* aliceSizes, int aliceSizesSize, int* bobSizes, int bobSizesSize, int* returnSize){\nint aliceSum = 0;\n    int bobSum = 0;\n    for(int i = 0; i < aliceSizesSize; i++){\n        aliceSum += aliceSizes[i];\n    }\n    for(int i = 0; i < bobSizesSize; i++){\n        bobSum += bobSizes[i];\n    }\n    int* ret = (int*)malloc(sizeof(int) * 2);\n    *returnSize = 2;\n    int delta = (bobSum - aliceSum) / 2;\n    for(int i = 0; i < aliceSizesSize; i++){\n        for(int j = 0; j < bobSizesSize; j++){\n            if(aliceSizes[i] - bobSizes[j] == delta){\n                ret[0] = aliceSizes[i];\n                ret[1] = bobSizes[j];\n                return ret;\n            }\n        }\n    }\n    return ret;\n}", "prefix": "int* fairCandySwap(int* aliceSizes, int aliceSizesSize, int* bobSizes, int bobSizesSize, int* returnSize"}
{"id": "194", "path": "output2\\c\\Easy\\194-surface-area-of-3d-shapes.c", "hypo_code": "int surfaceArea(int** grid, int gridSize, int* gridColSize){\nint xy = 0;\n    int xz = 0;\n    int yz = 0;\n    int n = gridSize;\n    for(int i = 0; i < n; i++) {\n        int max_xz = 0;\n        int max_yz = 0;\n        for(int j = 0; j < n; j++) {\n            if(grid[i][j] > 0) {\n                xy++;\n            }\n            if(grid[i][j] > max_xz) {\n                max_xz = grid[i][j];\n            }\n            if(grid[j][i] > max_yz) {\n                max_yz = grid[j][i];\n            }\n        }\n        xz += max_xz;\n        yz += max_yz;\n    }\n    return xy + xz + yz;\n}", "prefix": "int surfaceArea(int** grid, int gridSize, int* gridColSize"}
{"id": "195", "path": "output2\\c\\Easy\\195-monotonic-array.c", "hypo_code": "bool isMonotonic(int* nums, int numsSize){\nbool inc = true;\n    bool dec = true;\n    for(int i = 0; i < numsSize - 1; i++){\n        if(nums[i] > nums[i + 1]){\n            inc = false;\n        }\n        if(nums[i] < nums[i + 1]){\n            dec = false;\n        }\n    }\n    return inc || dec;\n}", "prefix": "bool isMonotonic(int* nums, int numsSize"}
{"id": "196", "path": "output2\\c\\Easy\\196-increasing-order-search-tree.c", "hypo_code": "struct TreeNode* increasingBST(struct TreeNode* root){\nif(root == NULL) {\n        return NULL;\n    }\n    struct TreeNode* newRoot = increasingBST(root->left);\n    struct TreeNode* tmp = newRoot;\n    if(tmp != NULL) {\n        while(tmp->right != NULL) {\n            tmp = tmp->right;\n        }\n        tmp->right = root;\n    } else {\n        newRoot = root;\n    }\n    root->left = NULL;\n    root->right = increasingBST(root->right);\n    return newRoot;\n}", "prefix": "struct TreeNode* increasingBST(struct TreeNode* root"}
{"id": "197", "path": "output2\\c\\Easy\\197-sort-array-by-parity.c", "hypo_code": "int* sortArrayByParity(int* nums, int numsSize, int* returnSize){\nint* ret = (int*)malloc(sizeof(int) * numsSize);\n    *returnSize = numsSize;\n    int left = 0;\n    int right = numsSize - 1;\n    for(int i = 0; i < numsSize; i++){\n        if(nums[i] % 2 == 0){\n            ret[left++] = nums[i];\n        }else{\n            ret[right--] = nums[i];\n        }\n    }\n    return ret;\n}", "prefix": "int* sortArrayByParity(int* nums, int numsSize, int* returnSize"}
{"id": "198", "path": "output2\\c\\Easy\\198-smallest-range-i.c", "hypo_code": "int smallestRangeI(int* nums, int numsSize, int k){\nint min = nums[0];\n    int max = nums[0];\n    for(int i = 0; i < numsSize; i++) {\n        if(nums[i] < min) {\n            min = nums[i];\n        }\n        if(nums[i] > max) {\n            max = nums[i];\n        }\n    }\n    int diff = max - min;\n    if(diff <= 2 * k) {\n        return 0;\n    }\n    return diff - 2 * k;\n}", "prefix": "int smallestRangeI(int* nums, int numsSize, int k"}
{"id": "199", "path": "output2\\c\\Easy\\199-x-of-a-kind-in-a-deck-of-cards.c", "hypo_code": "bool hasGroupsSizeX(int* deck, int deckSize){\nint count[10000] = {0};\n    int min = deckSize;\n    for(int i = 0; i < deckSize; i++){\n        count[deck[i]]++;\n    }\n    for(int i = 0; i < 10000; i++){\n        if(count[i] > 0 && count[i] < min){\n            min = count[i];\n        }\n    }\n    for(int i = 2; i <= min; i++){\n        int j = 0;\n        for(; j < 10000; j++){\n            if(count[j] % i != 0){\n                break;\n            }\n        }\n        if(j == 10000){\n            return true;\n        }\n    }\n    return false;\n}", "prefix": "bool hasGroupsSizeX(int* deck, int deckSize"}
{"id": "200", "path": "output2\\c\\Easy\\200-reverse-only-letters.c", "hypo_code": "char * reverseOnlyLetters(char * s){\nint len = strlen(s);\n    char *res = (char *)malloc(sizeof(char) * (len + 1));\n    int i = 0;\n    int j = len - 1;\n    while(i < len){\n        if(s[i] >= 'A' && s[i] <= 'Z'){\n            while(j >= 0){\n                if(s[j] >= 'A' && s[j] <= 'Z'){\n                    res[i] = s[j];\n                    j--;\n                    break;\n                }\n                j--;\n            }\n        }else if(s[i] >= 'a' && s[i] <= 'z'){\n            while(j >= 0){\n                if(s[j] >= 'a' && s[j] <= 'z'){\n                    res[i] = s[j];\n                    j--;\n                    break;\n                }\n                j--;\n            }\n        }else{\n            res[i] = s[i];\n        }\n        i++;\n    }\n    res[len] = '\\0';\n    return res;\n}", "prefix": "char * reverseOnlyLetters(char * s"}
{"id": "201", "path": "output2\\c\\Easy\\201-sort-array-by-parity-ii.c", "hypo_code": "int* sortArrayByParityII(int* nums, int numsSize, int* returnSize){\nint *returnNums = malloc(sizeof(int)*numsSize);\n    int i,j;\n    for(i=0,j=0;i<numsSize;i++){\n        if(nums[i]%2==0){\n            returnNums[j]=nums[i];\n            j+=2;\n        }\n    }\n    for(i=0,j=1;i<numsSize;i++){\n        if(nums[i]%2==1){\n            returnNums[j]=nums[i];\n            j+=2;\n        }\n    }\n    *returnSize=numsSize;\n    return returnNums;\n}", "prefix": "int* sortArrayByParityII(int* nums, int numsSize, int* returnSize"}
{"id": "202", "path": "output2\\c\\Easy\\202-long-pressed-name.c", "hypo_code": "bool isLongPressedName(char * name, char * typed){\nint i=0,j=0;\n    while(name[i]!='\\0'){\n        if(name[i]==typed[j]){\n            i++;\n            j++;\n        }else if(j>0&&typed[j]==typed[j-1]){\n            j++;\n        }else{\n            return false;\n        }\n    }\n    while(typed[j]!='\\0'){\n        if(typed[j]==typed[j-1]){\n            j++;\n        }else{\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool isLongPressedName(char * name, char * typed"}
{"id": "203", "path": "output2\\c\\Easy\\203-unique-email-addresses.c", "hypo_code": "int numUniqueEmails(char ** emails, int emailsSize){\nint i,j,k;\n    char *temp;\n    for(i=0;i<emailsSize;i++){\n        for(j=0,k=0;emails[i][j]!='@';j++){\n            if(emails[i][j]=='.'){\n                continue;\n            }else if(emails[i][j]=='+'){\n                while(emails[i][j]!='@'){\n                    j++;\n                }\n                break;\n            }else{\n                emails[i][k++]=emails[i][j];\n            }\n        }\n        emails[i][k]='\\0';\n    }\n    for(i=0;i<emailsSize;i++){\n        for(j=i+1;j<emailsSize;j++){\n            if(strcmp(emails[i],emails[j])==0){\n                emails[j][0]='\\0';\n            }\n        }\n    }\n    int count=0;\n    for(i=0;i<emailsSize;i++){\n        if(emails[i][0]!='\\0'){\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int numUniqueEmails(char ** emails, int emailsSize"}
{"id": "205", "path": "output2\\c\\Easy\\205-range-sum-of-bst.c", "hypo_code": "int rangeSumBST(struct TreeNode* root, int low, int high){\nif(root==NULL){\n        return 0;\n    }\n    if(root->val<low){\n        return rangeSumBST(root->right,low,high);\n    }\n    if(root->val>high){\n        return rangeSumBST(root->left,low,high);\n    }\n    return root->val+rangeSumBST(root->left,low,high)+rangeSumBST(root->right,low,high);\n\n}", "prefix": "int rangeSumBST(struct TreeNode* root, int low, int high"}
{"id": "206", "path": "output2\\c\\Easy\\206-valid-mountain-array.c", "hypo_code": "bool validMountainArray(int* arr, int arrSize){\nif(arrSize < 3)\n        return false;\n    int i;\n    bool flag = true;\n    for(i=1;i<arrSize;i++){\n        if(arr[i] == arr[i-1])\n            return false;\n        if(arr[i] < arr[i-1]){\n            if(i == 1)\n                return false;\n            flag = false;\n            break;\n        }\n    }\n    if(flag)\n        return false;\n    for(;i<arrSize;i++){\n        if(arr[i] >= arr[i-1])\n            return false;\n    }\n    return true;\n}", "prefix": "bool validMountainArray(int* arr, int arrSize"}
{"id": "207", "path": "output2\\c\\Easy\\207-di-string-match.c", "hypo_code": "int* diStringMatch(char * s, int* returnSize){\nint len = strlen(s);\n    int *res = (int *)malloc(sizeof(int) * (len + 1));\n    int i = 0;\n    int j = len;\n    int k = 0;\n    while(k <= len){\n        if(s[k] == 'I'){\n            res[k] = i;\n            i++;\n        }else{\n            res[k] = j;\n            j--;\n        }\n        k++;\n    }\n    *returnSize = len + 1;\n    return res;\n}", "prefix": "int* diStringMatch(char * s, int* returnSize"}
{"id": "208", "path": "output2\\c\\Easy\\208-delete-columns-to-make-sorted.c", "hypo_code": "int minDeletionSize(char ** strs, int strsSize){\nint i,j,k;\n    int count=0;\n    for(i=0;i<strlen(strs[0]);i++){\n        for(j=0;j<strsSize-1;j++){\n            if(strs[j][i]>strs[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int minDeletionSize(char ** strs, int strsSize"}
{"id": "209", "path": "output2\\c\\Easy\\209-verifying-an-alien-dictionary.c", "hypo_code": "bool isAlienSorted(char ** words, int wordsSize, char * order){\nint i,j;\n    int orderMap[26];\n    for(i=0;i<26;i++){\n        orderMap[order[i]-'a'] = i;\n    }\n    for(i=0;i<wordsSize-1;i++){\n        for(j=0;words[i][j]!='\\0'&&words[i+1][j]!='\\0';j++){\n            if(orderMap[words[i][j]-'a']>orderMap[words[i+1][j]-'a'])\n                return false;\n            else if(orderMap[words[i][j]-'a']<orderMap[words[i+1][j]-'a'])\n                break;\n        }\n        if(words[i][j]=='\\0'&&words[i+1][j]!='\\0')\n            return true;\n        if(words[i][j]!='\\0'&&words[i+1][j]=='\\0')\n            return false;\n    }\n    return true;\n}", "prefix": "bool isAlienSorted(char ** words, int wordsSize, char * order"}
{"id": "210", "path": "output2\\c\\Easy\\210-n-repeated-element-in-size-2n-array.c", "hypo_code": "int repeatedNTimes(int* nums, int numsSize){\nint i;\n    for(i=0;i<numsSize-2;i++){\n        if(nums[i]==nums[i+1]||nums[i]==nums[i+2])\n            return nums[i];\n    }\n    return nums[numsSize-1];\n}", "prefix": "int repeatedNTimes(int* nums, int numsSize"}
{"id": "211", "path": "output2\\c\\Easy\\211-univalued-binary-tree.c", "hypo_code": "bool isUnivalTree(struct TreeNode* root){\nif(root==NULL){\n        return true;\n    }\n    int val=root->val;\n    return isUnivalTree(root->left)&&isUnivalTree(root->right)&&root->val==val;\n\n}", "prefix": "bool isUnivalTree(struct TreeNode* root"}
{"id": "212", "path": "output2\\c\\Easy\\212-largest-perimeter-triangle.c", "hypo_code": "int largestPerimeter(int* nums, int numsSize){\nint i,j;\n    int temp;\n    for(i=0;i<numsSize-1;i++){\n        for(j=i+1;j<numsSize;j++){\n            if(nums[i]<nums[j]){\n                temp=nums[i];\n                nums[i]=nums[j];\n                nums[j]=temp;\n            }\n        }\n    }\n    for(i=0;i<numsSize-2;i++){\n        if(nums[i]<nums[i+1]+nums[i+2]){\n            return nums[i]+nums[i+1]+nums[i+2];\n        }\n    }\n    return 0;\n}", "prefix": "int largestPerimeter(int* nums, int numsSize"}
{"id": "213", "path": "output2\\c\\Easy\\213-squares-of-a-sorted-array.c", "hypo_code": "int* sortedSquares(int* nums, int numsSize, int* returnSize){\nint *returnNums = malloc(sizeof(int)*numsSize);\n    int i,j;\n    for(i=0;i<numsSize;i++){\n        returnNums[i]=nums[i]*nums[i];\n    }\n    for(i=0;i<numsSize-1;i++){\n        for(j=0;j<numsSize-i-1;j++){\n            if(returnNums[j]>returnNums[j+1]){\n                int temp=returnNums[j];\n                returnNums[j]=returnNums[j+1];\n                returnNums[j+1]=temp;\n            }\n        }\n    }\n    *returnSize=numsSize;\n    return returnNums;\n}", "prefix": "int* sortedSquares(int* nums, int numsSize, int* returnSize"}
{"id": "214", "path": "output2\\c\\Easy\\214-add-to-array-form-of-integer.c", "hypo_code": "int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\nint *returnNums = malloc(sizeof(int)*numSize);\n    int i,j;\n    int temp;\n    for(i=numSize-1;i>=0;i--){\n        temp=k%10;\n        k/=10;\n        returnNums[i]=temp+num[i];\n    }\n    *returnSize=numSize;\n    return returnNums;\n}", "prefix": "int* addToArrayForm(int* num, int numSize, int k, int* returnSize"}
{"id": "215", "path": "output2\\c\\Easy\\215-cousins-in-binary-tree.c", "hypo_code": "bool isCousins(struct TreeNode* root, int x, int y){\nint depth[101];\n    int parent[101];\n    memset(depth,0,sizeof(depth));\n    memset(parent,0,sizeof(parent));\n    int top=0;\n    struct TreeNode* stack[101];\n    stack[top++]=root;\n    int i;\n    while(top>0){\n        struct TreeNode* node=stack[--top];\n        if(node->left!=NULL){\n            depth[node->left->val]=depth[node->val]+1;\n            parent[node->left->val]=node->val;\n            stack[top++]=node->left;\n        }\n        if(node->right!=NULL){\n            depth[node->right->val]=depth[node->val]+1;\n            parent[node->right->val]=node->val;\n            stack[top++]=node->right;\n        }\n    }\n    if(depth[x]!=depth[y]){\n        return false;\n    }\n    if(parent[x]==parent[y]){\n        return false;\n    }\n    return true;\n}", "prefix": "bool isCousins(struct TreeNode* root, int x, int y"}
{"id": "216", "path": "output2\\c\\Easy\\216-find-the-town-judge.c", "hypo_code": "int findJudge(int n, int** trust, int trustSize, int* trustColSize){\nint i,j;\n    int count[1000]={0};\n    for(i=0;i<trustSize;i++){\n        count[trust[i][0]-1]--;\n        count[trust[i][1]-1]++;\n    }\n    for(i=0;i<n;i++){\n        if(count[i]==n-1)\n            return i+1;\n    }\n    return -1;\n}", "prefix": "int findJudge(int n, int** trust, int trustSize, int* trustColSize"}
{"id": "217", "path": "output2\\c\\Easy\\217-available-captures-for-rook.c", "hypo_code": "int numRookCaptures(char** board, int boardSize, int* boardColSize){\nint i,j;\n    int x,y;\n    int res = 0;\n    for(i=0;i<boardSize;i++){\n        for(j=0;j<*boardColSize;j++){\n            if(board[i][j]=='R'){\n                x=i;\n                y=j;\n                break;\n            }\n        }\n    }\n    for(i=x;i<boardSize;i++){\n        if(board[i][y]=='B')\n            break;\n        if(board[i][y]=='p'){\n            res++;\n            break;\n        }\n    }\n    for(i=x;i>=0;i--){\n        if(board[i][y]=='B')\n            break;\n        if(board[i][y]=='p'){\n            res++;\n            break;\n        }\n    }\n    for(j=y;j<*boardColSize;j++){\n        if(board[x][j]=='B')\n            break;\n        if(board[x][j]=='p'){\n            res++;\n            break;\n        }\n    }\n    for(j=y;j>=0;j--){\n        if(board[x][j]=='B')\n            break;\n        if(board[x][j]=='p'){\n            res++;\n            break;\n        }\n    }\n    return res;\n}", "prefix": "int numRookCaptures(char** board, int boardSize, int* boardColSize"}
{"id": "218", "path": "output2\\c\\Easy\\218-find-common-characters.c", "hypo_code": "char ** commonChars(char ** words, int wordsSize, int* returnSize){\nint charCount[26];\n    memset(charCount, 0x7f, sizeof(charCount));\n    for(int i = 0; i < wordsSize; i++) {\n        int tmp[26] = {0};\n        for(int j = 0; words[i][j]; j++) {\n            tmp[words[i][j] - 'a']++;\n        }\n        for(int j = 0; j < 26; j++) {\n            charCount[j] = fmin(charCount[j], tmp[j]);\n        }\n    }\n    char **res = (char **)malloc(sizeof(char *) * 101);\n    *returnSize = 0;\n    for(int i = 0; i < 26; i++) {\n        for(int j = 0; j < charCount[i]; j++) {\n            res[(*returnSize)] = (char *)malloc(2);\n            res[(*returnSize)][0] = 'a' + i;\n            res[(*returnSize)++][1] = '\\0';\n        }\n    }\n    return res;\n}", "prefix": "char ** commonChars(char ** words, int wordsSize, int* returnSize"}
{"id": "219", "path": "output2\\c\\Easy\\219-maximize-sum-of-array-after-k-negations.c", "hypo_code": "int largestSumAfterKNegations(int* nums, int numsSize, int k){\nint i,j,temp;\n    for(i=0;i<numsSize-1;i++){\n        for(j=i+1;j<numsSize;j++){\n            if(nums[i]>nums[j]){\n                temp=nums[i];\n                nums[i]=nums[j];\n                nums[j]=temp;\n            }\n        }\n    }\n    for(i=0;i<numsSize;i++){\n        if(nums[i]<0&&k>0){\n            nums[i]=-nums[i];\n            k--;\n        }\n    }\n    for(i=0;i<numsSize-1;i++){\n        for(j=i+1;j<numsSize;j++){\n            if(nums[i]>nums[j]){\n                temp=nums[i];\n                nums[i]=nums[j];\n                nums[j]=temp;\n            }\n        }\n    }\n    if(k%2==1){\n        nums[0]=-nums[0];\n    }\n    temp=0;\n    for(i=0;i<numsSize;i++){\n        temp+=nums[i];\n    }\n    return temp;\n}", "prefix": "int largestSumAfterKNegations(int* nums, int numsSize, int k"}
{"id": "220", "path": "output2\\c\\Easy\\220-complement-of-base-10-integer.c", "hypo_code": "int bitwiseComplement(int n){\nint num = 0;\n    int i = 0;\n    if (n == 0) {\n        return 1;\n    }\n    while (n != 0) {\n        if (n % 2 == 0) {\n            num += pow(2, i);\n        }\n        i++;\n        n /= 2;\n    }\n    return num;\n}", "prefix": "int bitwiseComplement(int n"}
{"id": "221", "path": "output2\\c\\Easy\\221-partition-array-into-three-parts-with-equal-sum.c", "hypo_code": "bool canThreePartsEqualSum(int* arr, int arrSize){\nint sum=0;\n    int i=0;\n    for(i=0;i<arrSize;i++){\n        sum+=arr[i];\n    }\n    if(sum%3!=0){\n        return false;\n    }\n    int avg=sum/3;\n    int count=0;\n    sum=0;\n    for(i=0;i<arrSize;i++){\n        sum+=arr[i];\n        if(sum==avg){\n            count++;\n            sum=0;\n        }\n    }\n    if(count==3){\n        return true;\n    }\n    return false;\n}", "prefix": "bool canThreePartsEqualSum(int* arr, int arrSize"}
{"id": "222", "path": "output2\\c\\Easy\\222-binary-prefix-divisible-by-5.c", "hypo_code": "bool* prefixesDivBy5(int* nums, int numsSize, int* returnSize){\nbool *returnNums = malloc(sizeof(bool)*numsSize);\n    int i,j;\n    int temp=0;\n    for(i=0;i<numsSize;i++){\n        temp=(temp*2+nums[i])%5;\n        returnNums[i]=temp==0?true:false;\n    }\n    *returnSize=numsSize;\n    return returnNums;\n}", "prefix": "bool* prefixesDivBy5(int* nums, int numsSize, int* returnSize"}
{"id": "223", "path": "output2\\c\\Easy\\223-remove-outermost-parentheses.c", "hypo_code": "char * removeOuterParentheses(char * s){\nint len = strlen(s);\n    char *res = (char *)malloc(sizeof(char) * (len + 1));\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int count = 0;\n    while(k < len){\n        if(s[k] == '('){\n            count++;\n        }else{\n            count--;\n        }\n        if(count == 0){\n            res[j++] = s[i + 1];\n            k++;\n            i = k;\n        }else{\n            k++;\n        }\n    }\n    res[j] = '\\0';\n    return res;\n}", "prefix": "char * removeOuterParentheses(char * s"}
{"id": "224", "path": "output2\\c\\Easy\\224-sum-of-root-to-leaf-binary-numbers.c", "hypo_code": "int sumRootToLeaf(struct TreeNode* root){\nint sum = 0;\n    dfs(root, 0, &sum);\n    return sum;\n}\n\nvoid dfs(struct TreeNode* root, int val, int* sum) {\n    if(root == NULL) return;\n    val = val * 2 + root->val;\n    if(root->left == NULL && root->right == NULL) {\n        *sum += val;\n        return;\n    }\n    dfs(root->left, val, sum);\n    dfs(root->right, val, sum);\n}", "prefix": "int sumRootToLeaf(struct TreeNode* root"}
{"id": "225", "path": "output2\\c\\Easy\\225-divisor-game.c", "hypo_code": "bool divisorGame(int n){\nreturn n%2==0;\n}", "prefix": "bool divisorGame(int n"}
{"id": "226", "path": "output2\\c\\Easy\\226-matrix-cells-in-distance-order.c", "hypo_code": "int** allCellsDistOrder(int rows, int cols, int rCenter, int cCenter, int* returnSize, int** returnColumnSizes){\nint i,j;\n    for(i=0;i<rows;i++){\n        for(j=0;j<cols;j++){\n            returnNums[i*cols+j]=(int *)malloc(sizeof(int)*2);\n            returnNums[i*cols+j][0]=i;\n            returnNums[i*cols+j][1]=j;\n        }\n    }\n    int *distance=(int *)malloc(sizeof(int)*rows*cols);\n    for(i=0;i<rows;i++){\n        for(j=0;j<cols;j++){\n            distance[i*cols+j]=abs(i-rCenter)+abs(j-cCenter);\n        }\n    }\n    for(i=0;i<rows*cols-1;i++){\n        for(j=0;j<rows*cols-i-1;j++){\n            if(distance[j]>distance[j+1]){\n                int temp=distance[j];\n                distance[j]=distance[j+1];\n                distance[j+1]=temp;\n                int *temp1=returnNums[j];\n                returnNums[j]=returnNums[j+1];\n                returnNums[j+1]=temp1;\n            }\n        }\n    }\n    *returnSize=rows*cols;\n    *returnColumnSizes=(int *)malloc(sizeof(int)*rows*cols);\n    for(i=0;i<rows*cols;i++){\n        (*returnColumnSizes)[i]=2;\n    }\n    return returnNums;\n\n}", "prefix": "int** allCellsDistOrder(int rows, int cols, int rCenter, int cCenter, int* returnSize, int** returnColumnSizes"}
{"id": "227", "path": "output2\\c\\Easy\\227-valid-boomerang.c", "hypo_code": "bool isBoomerang(int** points, int pointsSize, int* pointsColSize){\nint x1 = points[0][0] - points[1][0];\n    int x2 = points[0][0] - points[2][0];\n    int y1 = points[0][1] - points[1][1];\n    int y2 = points[0][1] - points[2][1];\n    return x1 * y2 != x2 * y1;\n}", "prefix": "bool isBoomerang(int** points, int pointsSize, int* pointsColSize"}
{"id": "228", "path": "output2\\c\\Easy\\228-last-stone-weight.c", "hypo_code": "int lastStoneWeight(int* stones, int stonesSize){\nint i,j;\n    for(i=0;i<stonesSize-1;i++){\n        for(j=i+1;j<stonesSize;j++){\n            if(stones[i]<stones[j]){\n                int temp=stones[i];\n                stones[i]=stones[j];\n                stones[j]=temp;\n            }\n        }\n        stones[i+1]=stones[i]-stones[i+1];\n    }\n    return stones[stonesSize-1];\n}", "prefix": "int lastStoneWeight(int* stones, int stonesSize"}
{"id": "229", "path": "output2\\c\\Easy\\229-remove-all-adjacent-duplicates-in-string.c", "hypo_code": "char * removeDuplicates(char * s){\nint i=0,j=0;\n    while(s[i]!='\\0'){\n        if(j>0&&s[i]==s[j-1]){\n            j--;\n        }else{\n            s[j++]=s[i];\n        }\n        i++;\n    }\n    s[j]='\\0';\n    return s;\n}", "prefix": "char * removeDuplicates(char * s"}
{"id": "231", "path": "output2\\c\\Easy\\231-height-checker.c", "hypo_code": "int heightChecker(int* heights, int heightsSize){\nint i,j,k;\n    int temp;\n    int count=0;\n    for(i=0;i<heightsSize-1;i++){\n        for(j=i+1;j<heightsSize;j++){\n            if(heights[i]>heights[j]){\n                temp=heights[i];\n                heights[i]=heights[j];\n                heights[j]=temp;\n            }\n        }\n    }\n    for(i=0;i<heightsSize;i++){\n        if(heights[i]!=i+1){\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int heightChecker(int* heights, int heightsSize"}
{"id": "233", "path": "output2\\c\\Easy\\233-greatest-common-divisor-of-strings.c", "hypo_code": "char * gcdOfStrings(char * str1, char * str2){\nint len1 = strlen(str1);\n    int len2 = strlen(str2);\n    if(len1 < len2){\n        char *temp = str1;\n        str1 = str2;\n        str2 = temp;\n        int temp_len = len1;\n        len1 = len2;\n        len2 = temp_len;\n    }\n    int len = len2;\n    char *result = (char *)malloc(sizeof(char) * (len + 1));\n    result[len] = '\\0';\n    int i = 0;\n    for(i = 1; i <= len; i++){\n        if(len1 % i != 0 || len2 % i != 0){\n            continue;\n        }\n        int j = 0;\n        for(j = 0; j < len1; j++){\n            if(str1[j] != str1[j % i]){\n                break;\n            }\n        }\n        if(j != len1){\n            continue;\n        }\n        for(j = 0; j < len2; j++){\n            if(str2[j] != str1[j % i]){\n                break;\n            }\n        }\n        if(j == len2){\n            strncpy(result, str1, i);\n            return result;\n        }\n    }\n    return result;\n}", "prefix": "char * gcdOfStrings(char * str1, char * str2"}
{"id": "235", "path": "output2\\c\\Easy\\235-occurrences-after-bigram.c", "hypo_code": "char ** findOcurrences(char * text, char * first, char * second, int* returnSize){\nchar **res = (char **)malloc(sizeof(char *) * 1000);\n  *returnSize = 0;\n  char *p = strtok(text, \" \");\n  char *last = NULL;\n  char *lastlast = NULL;\n  while(p) {\n    if(lastlast != NULL && last != NULL && strcmp(lastlast, first) == 0 && strcmp(last, second) == 0) {\n      res[(*returnSize)++] = p;\n    }\n    lastlast = last;\n    last = p;\n    p = strtok(NULL, \" \");\n  }\n  return res;\n}", "prefix": "char ** findOcurrences(char * text, char * first, char * second, int* returnSize"}
{"id": "237", "path": "output2\\c\\Easy\\237-duplicate-zeros.c", "hypo_code": "void duplicateZeros(int* arr, int arrSize){\nint i,j;\n    for(i=0;i<arrSize-1;i++){\n        if(arr[i]==0){\n            for(j=arrSize-1;j>i+1;j--){\n                arr[j]=arr[j-1];\n            }\n            arr[i+1]=0;\n            i++;\n        }\n    }\n}", "prefix": "void duplicateZeros(int* arr, int arrSize"}
{"id": "238", "path": "output2\\c\\Easy\\238-distribute-candies-to-people.c", "hypo_code": "int* distributeCandies(int candies, int num_people, int* returnSize){\nint i,j;\n    int temp;\n    for(i=num_people-1;i>=0;i--){\n        temp=candies%num_people;\n        candies/=num_people;\n        returnNums[i]=temp;\n    }\n    *returnSize=num_people;\n    return returnNums;\n}", "prefix": "int* distributeCandies(int candies, int num_people, int* returnSize"}
{"id": "239", "path": "output2\\c\\Easy\\239-defanging-an-ip-address.c", "hypo_code": "char * defangIPaddr(char * address){\nint len = strlen(address);\n    char *res = (char *)malloc(sizeof(char) * (len + 7));\n    int i = 0;\n    int j = 0;\n    while(address[i] != '\\0'){\n        if(address[i] == '.'){\n            res[j++] = '[';\n            res[j++] = '.';\n            res[j++] = ']';\n        }else{\n            res[j++] = address[i];\n        }\n        i++;\n    }\n    res[j] = '\\0';\n    return res;\n}", "prefix": "char * defangIPaddr(char * address"}
{"id": "241", "path": "output2\\c\\Easy\\241-relative-sort-array.c", "hypo_code": "int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize){\nint *returnNums = malloc(sizeof(int)*arr1Size);\n    int i,j,k;\n    for(i=0,j=0;i<arr2Size;i++){\n        for(k=0;k<arr1Size;k++){\n            if(arr1[k]==arr2[i]){\n                returnNums[j]=arr1[k];\n                j++;\n            }\n        }\n    }\n    for(i=0;i<arr1Size;i++){\n        for(k=0;k<arr2Size;k++){\n            if(arr1[i]==arr2[k]){\n                break;\n            }\n        }\n        if(k==arr2Size){\n            returnNums[j]=arr1[i];\n            j++;\n        }\n    }\n    *returnSize=arr1Size;\n    return returnNums;\n}", "prefix": "int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize"}
{"id": "242", "path": "output2\\c\\Easy\\242-number-of-equivalent-domino-pairs.c", "hypo_code": "int numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\nint i,j,count=0;\n    for(i=0;i<dominoesSize-1;i++){\n        for(j=i+1;j<dominoesSize;j++){\n            if((dominoes[i][0]==dominoes[j][0]&&dominoes[i][1]==dominoes[j][1])||(dominoes[i][0]==dominoes[j][1]&&dominoes[i][1]==dominoes[j][0]))\n                count++;\n        }\n    }\n    return count;\n}", "prefix": "int numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize"}
{"id": "243", "path": "output2\\c\\Easy\\243-n-th-tribonacci-number.c", "hypo_code": "int tribonacci(int n){\nif(n==0)return 0;\n    if(n==1||n==2)return 1;\n    int a=0,b=1,c=1;\n    int i;\n    for(i=3;i<=n;i++){\n        int temp=c;\n        c=a+b+c;\n        a=b;\n        b=temp;\n    }\n    return c;\n}", "prefix": "int tribonacci(int n"}
{"id": "246", "path": "output2\\c\\Easy\\246-day-of-the-year.c", "hypo_code": "int dayOfYear(char * date){\nint year, month, day;\n    int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\n    sscanf(date, \"%d-%d-%d\", &year, &month, &day);\n    if((year%4 == 0 && year%100 != 0) || year%400 == 0)\n        days[1] = 29;\n    int i, sum = 0;\n    for(i=0;i<month-1;i++)\n        sum += days[i];\n    return sum + day;\n}", "prefix": "int dayOfYear(char * date"}
{"id": "247", "path": "output2\\c\\Easy\\247-find-words-that-can-be-formed-by-characters.c", "hypo_code": "int countCharacters(char ** words, int wordsSize, char * chars){\nint i,j,k;\n    int count=0;\n    int charsMap[26]={0};\n    for(i=0;i<strlen(chars);i++){\n        charsMap[chars[i]-'a']++;\n    }\n    for(i=0;i<wordsSize;i++){\n        int tempMap[26]={0};\n        for(j=0;j<strlen(words[i]);j++){\n            tempMap[words[i][j]-'a']++;\n        }\n        for(j=0;j<26;j++){\n            if(tempMap[j]>charsMap[j]){\n                break;\n            }\n        }\n        if(j==26){\n            count+=strlen(words[i]);\n        }\n    }\n    return count;\n}", "prefix": "int countCharacters(char ** words, int wordsSize, char * chars"}
{"id": "249", "path": "output2\\c\\Easy\\249-prime-arrangements.c", "hypo_code": "int numPrimeArrangements(int n){\nint i,j,count=0;\n    long long int sum=1;\n    for(i=2;i<=n;i++){\n        for(j=2;j<i;j++){\n            if(i%j==0){\n                break;\n            }\n        }\n        if(j==i){\n            count++;\n        }\n    }\n    for(i=1;i<=count;i++){\n        sum=sum*i%1000000007;\n    }\n    for(i=1;i<=n-count;i++){\n        sum=sum*i%1000000007;\n    }\n    return sum;\n}", "prefix": "int numPrimeArrangements(int n"}
{"id": "251", "path": "output2\\c\\Easy\\251-distance-between-bus-stops.c", "hypo_code": "int distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){\nint i,j,sum1=0,sum2=0;\n    for(i=start;i!=destination;i=(i+1)%distanceSize){\n        sum1+=distance[i];\n    }\n    for(i=destination;i!=start;i=(i+1)%distanceSize){\n        sum2+=distance[i];\n    }\n    if(sum1>sum2){\n        return sum2;\n    }\n    else{\n        return sum1;\n    }\n}", "prefix": "int distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination"}
{"id": "252", "path": "output2\\c\\Easy\\252-day-of-the-week.c", "hypo_code": "char * dayOfTheWeek(int day, int month, int year){\nint sum = 0;\n    int i;\n    char *week[7]={\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n    for(i=1971;i<year;i++){\n        if(i%4==0&&i%100!=0||i%400==0){\n            sum+=366;\n        }else{\n            sum+=365;\n        }\n    }\n    int monthDay[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n    for(i=0;i<month-1;i++){\n        if(i==1&&year%4==0&&year%100!=0||year%400==0){\n            sum+=29;\n        }else{\n            sum+=monthDay[i];\n        }\n    }\n    sum+=day;\n    return week[(sum+4)%7];\n}", "prefix": "char * dayOfTheWeek(int day, int month, int year"}
{"id": "253", "path": "output2\\c\\Easy\\253-maximum-number-of-balloons.c", "hypo_code": "int maxNumberOfBalloons(char * text){\nint b=0,a=0,l=0,o=0,n=0,i;\n    for(i=0;text[i]!='\\0';i++){\n        switch(text[i]){\n            case 'b':\n                b++;\n                break;\n            case 'a':\n                a++;\n                break;\n            case 'l':\n                l++;\n                break;\n            case 'o':\n                o++;\n                break;\n            case 'n':\n                n++;\n                break;\n        }\n    }\n    if(b==0||a==0||l<2||o<2||n==0){\n        return 0;\n    }\n    while(b>0&&a>0&&l>1&&o>1&&n>0){\n        b--;\n        a--;\n        l-=2;\n        o-=2;\n        n--;\n    }\n    return 1+n;\n}", "prefix": "int maxNumberOfBalloons(char * text"}
{"id": "254", "path": "output2\\c\\Easy\\254-minimum-absolute-difference.c", "hypo_code": "int** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes){\nint i,j;\n    for(i=0;i<arrSize;i++){\n        returnNums[i]=arr[i];\n    }\n    for(i=0;i<arrSize-1;i++){\n        for(j=0;j<arrSize-i-1;j++){\n            if(returnNums[j]>returnNums[j+1]){\n                int temp=returnNums[j];\n                returnNums[j]=returnNums[j+1];\n                returnNums[j+1]=temp;\n            }\n        }\n    }\n    int min=returnNums[1]-returnNums[0];\n    for(i=1;i<arrSize-1;i++){\n        if(returnNums[i+1]-returnNums[i]<min){\n            min=returnNums[i+1]-returnNums[i];\n        }\n    }\n    int count=0;\n    for(i=0;i<arrSize-1;i++){\n        if(returnNums[i+1]-returnNums[i]==min){\n            count++;\n        }\n    }\n    *returnSize=count;\n    int **returnNums2 = malloc(sizeof(int*)*count);\n    *returnColumnSizes = malloc(sizeof(int)*count);\n    int k=0;\n    for(i=0;i<arrSize-1;i++){\n        if(returnNums[i+1]-returnNums[i]==min){\n            (*returnColumnSizes)[k]=2;\n            returnNums2[k]=malloc(sizeof(int)*2);\n            returnNums2[k][0]=returnNums[i];\n            returnNums2[k][1]=returnNums[i+1];\n            k++;\n        }\n    }\n    return returnNums2;\n}", "prefix": "int** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes"}
{"id": "255", "path": "output2\\c\\Easy\\255-unique-number-of-occurrences.c", "hypo_code": "bool uniqueOccurrences(int* arr, int arrSize){\nint count[2001]={0};\n    int i;\n    for(i=0;i<arrSize;i++){\n        count[arr[i]+1000]++;\n    }\n    int count2[1001]={0};\n    for(i=0;i<2001;i++){\n        if(count[i]!=0){\n            count2[count[i]]++;\n            if(count2[count[i]]>1){\n                return false;\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool uniqueOccurrences(int* arr, int arrSize"}
{"id": "257", "path": "output2\\c\\Easy\\257-minimum-cost-to-move-chips-to-the-same-position.c", "hypo_code": "int minCostToMoveChips(int* position, int positionSize){\nint i;\n    int odd=0,even=0;\n    for(i=0;i<positionSize;i++){\n        if(position[i]%2==0){\n            even++;\n        }else{\n            odd++;\n        }\n    }\n    if(odd>even){\n        return even;\n    }else{\n        return odd;\n    }\n}", "prefix": "int minCostToMoveChips(int* position, int positionSize"}
{"id": "258", "path": "output2\\c\\Easy\\258-split-a-string-in-balanced-strings.c", "hypo_code": "int balancedStringSplit(char * s){\nint i, count = 0, res = 0;\n    for(i=0;s[i]!='\\0';i++){\n        if(s[i]=='L') count++;\n        else count--;\n        if(count==0) res++;\n    }\n    return res;\n}", "prefix": "int balancedStringSplit(char * s"}
{"id": "259", "path": "output2\\c\\Easy\\259-check-if-it-is-a-straight-line.c", "hypo_code": "bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize){\nint i;\n    if(coordinatesSize==2)\n        return true;\n    for(i=1;i<coordinatesSize-1;i++){\n        if((coordinates[i][1]-coordinates[i-1][1])*(coordinates[i+1][0]-coordinates[i][0])!=(coordinates[i+1][1]-coordinates[i][1])*(coordinates[i][0]-coordinates[i-1][0]))\n            return false;\n    }\n    return true;\n}", "prefix": "bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize"}
{"id": "261", "path": "output2\\c\\Easy\\261-cells-with-odd-values-in-a-matrix.c", "hypo_code": "int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize){\nint i,j;\n    int **matrix = (int **)malloc(sizeof(int *)*m);\n    for(i=0;i<m;i++){\n        matrix[i] = (int *)malloc(sizeof(int)*n);\n    }\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            matrix[i][j]=0;\n        }\n    }\n    for(i=0;i<indicesSize;i++){\n        for(j=0;j<n;j++){\n            matrix[indices[i][0]][j]++;\n        }\n        for(j=0;j<m;j++){\n            matrix[j][indices[i][1]]++;\n        }\n    }\n    int count=0;\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            if(matrix[i][j]%2==1){\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize"}
{"id": "262", "path": "output2\\c\\Easy\\262-shift-2d-grid.c", "hypo_code": "int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\nint **returnNums = malloc(sizeof(int*)*gridSize);\n    *returnColumnSizes = malloc(sizeof(int)*gridSize);\n    int i,j;\n    for(i=0;i<gridSize;i++){\n        returnNums[i] = malloc(sizeof(int)*(*gridColSize));\n        (*returnColumnSizes)[i] = *gridColSize;\n    }\n    for(i=0;i<gridSize;i++){\n        for(j=0;j<*gridColSize;j++){\n            int temp = (i*(*gridColSize)+j+k)%(gridSize*(*gridColSize));\n            returnNums[temp/(*gridColSize)][temp%(*gridColSize)] = grid[i][j];\n        }\n    }\n    *returnSize = gridSize;\n    return returnNums;\n}", "prefix": "int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes"}
{"id": "263", "path": "output2\\c\\Easy\\263-minimum-time-visiting-all-points.c", "hypo_code": "int minTimeToVisitAllPoints(int** points, int pointsSize, int* pointsColSize){\nint i,j;\n    int sum=0;\n    for(i=0;i<pointsSize-1;i++){\n        int x=abs(points[i][0]-points[i+1][0]);\n        int y=abs(points[i][1]-points[i+1][1]);\n        if(x>y){\n            sum=sum+y+x-y;\n        }\n        else{\n            sum=sum+x+y-x;\n        }\n    }\n    return sum;\n}", "prefix": "int minTimeToVisitAllPoints(int** points, int pointsSize, int* pointsColSize"}
{"id": "264", "path": "output2\\c\\Easy\\264-find-winner-on-a-tic-tac-toe-game.c", "hypo_code": "char * tictactoe(int** moves, int movesSize, int* movesColSize){\nint i,j;\n    int a[3][3]={0};\n    for(i=0;i<movesSize;i++){\n        if(i%2==0){\n            a[moves[i][0]][moves[i][1]]=1;\n        }\n        else{\n            a[moves[i][0]][moves[i][1]]=2;\n        }\n    }\n    for(i=0;i<3;i++){\n        if(a[i][0]==a[i][1]&&a[i][1]==a[i][2]){\n            if(a[i][0]==1)\n                return \"A\";\n            if(a[i][0]==2)\n                return \"B\";\n        }\n        if(a[0][i]==a[1][i]&&a[1][i]==a[2][i]){\n            if(a[0][i]==1)\n                return \"A\";\n            if(a[0][i]==2)\n                return \"B\";\n        }\n    }\n    if(a[0][0]==a[1][1]&&a[1][1]==a[2][2]){\n        if(a[0][0]==1)\n            return \"A\";\n        if(a[0][0]==2)\n            return \"B\";\n    }\n    if(a[0][2]==a[1][1]&&a[1][1]==a[2][0]){\n        if(a[0][2]==1)\n            return \"A\";\n        if(a[0][2]==2)\n            return \"B\";\n    }\n    if(movesSize==9)\n        return \"Draw\";\n    return \"Pending\";\n\n\n}", "prefix": "char * tictactoe(int** moves, int movesSize, int* movesColSize"}
{"id": "266", "path": "output2\\c\\Easy\\266-subtract-the-product-and-sum-of-digits-of-an-integer.c", "hypo_code": "int subtractProductAndSum(int n){\nint sum=0,product=1;\n    while(n>0){\n        sum+=n%10;\n        product*=n%10;\n        n/=10;\n    }\n    return product-sum;\n}", "prefix": "int subtractProductAndSum(int n"}
{"id": "267", "path": "output2\\c\\Easy\\267-element-appearing-more-than-25-in-sorted-array.c", "hypo_code": "int findSpecialInteger(int* arr, int arrSize){\nint i;\n    int count=1;\n    int temp=arr[0];\n    for(i=1;i<arrSize;i++){\n        if(arr[i]==temp){\n            count++;\n            if(count>arrSize/4){\n                return temp;\n            }\n        }else{\n            temp=arr[i];\n            count=1;\n        }\n    }\n    return temp;\n}", "prefix": "int findSpecialInteger(int* arr, int arrSize"}
{"id": "268", "path": "output2\\c\\Easy\\268-convert-binary-number-in-a-linked-list-to-integer.c", "hypo_code": "int getDecimalValue(struct ListNode* head){\nint ans=0;\n    while(head!=NULL){\n        ans=ans*2+head->val;\n        head=head->next;\n    }\n    return ans;\n}", "prefix": "int getDecimalValue(struct ListNode* head"}
{"id": "269", "path": "output2\\c\\Easy\\269-find-numbers-with-even-number-of-digits.c", "hypo_code": "int findNumbers(int* nums, int numsSize){\nint i, j, ret = 0;\n    for(i=0;i<numsSize;i++){\n        for(j=0;nums[i]>0;j++){\n            nums[i] /= 10;\n        }\n        if(j%2==0)\n            ret++;\n    }\n    return ret;\n}", "prefix": "int findNumbers(int* nums, int numsSize"}
{"id": "270", "path": "output2\\c\\Easy\\270-replace-elements-with-greatest-element-on-right-side.c", "hypo_code": "int* replaceElements(int* arr, int arrSize, int* returnSize){\nint* ret = (int*)malloc(sizeof(int) * arrSize);\n    *returnSize = arrSize;\n    int max = arr[arrSize - 1];\n    ret[arrSize - 1] = -1;\n    for(int i = arrSize - 2; i >= 0; i--){\n        ret[i] = max;\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    return ret;\n}", "prefix": "int* replaceElements(int* arr, int arrSize, int* returnSize"}
{"id": "271", "path": "output2\\c\\Easy\\271-find-n-unique-integers-sum-up-to-zero.c", "hypo_code": "int* sumZero(int n, int* returnSize){\nint* ret = (int*)malloc(sizeof(int) * n);\n    *returnSize = n;\n    int mid = n / 2;\n    for(int i = 0; i < n; i++){\n        ret[i] = i - mid;\n    }\n    if(n % 2 == 0){\n        ret[mid] = 0;\n    }\n    return ret;\n}", "prefix": "int* sumZero(int n, int* returnSize"}
{"id": "272", "path": "output2\\c\\Easy\\272-decrypt-string-from-alphabet-to-integer-mapping.c", "hypo_code": "char * freqAlphabets(char * s){\nint i = len - 1;\n    int j = len - 1;\n    while(i >= 0){\n        if(s[i] == '#'){\n            s[j--] = (s[i - 2] - '0') * 10 + s[i - 1] - '0' - 1 + 'a';\n            i -= 3;\n        }else{\n            s[j--] = s[i--] - '0' - 1 + 'a';\n        }\n    }\n    return s + j + 1;\n}", "prefix": "char * freqAlphabets(char * s"}
{"id": "273", "path": "output2\\c\\Easy\\273-decompress-run-length-encoded-list.c", "hypo_code": "int* decompressRLElist(int* nums, int numsSize, int* returnSize){\nint i,j;\n    for(i=0,j=0;i<numsSize;i+=2){\n        for(int k=0;k<nums[i];k++){\n            returnNums[j++]=nums[i+1];\n        }\n    }\n    *returnSize=j;\n    return returnNums;\n}", "prefix": "int* decompressRLElist(int* nums, int numsSize, int* returnSize"}
{"id": "274", "path": "output2\\c\\Easy\\274-convert-integer-to-the-sum-of-two-no-zero-integers.c", "hypo_code": "int* getNoZeroIntegers(int n, int* returnSize){  \n int *returnNums = malloc(sizeof(int)*2);\n\tint i,j;\n\tint temp;\n\tfor(i=1;i<n;i++){\n\t\ttemp=n-i;\n\t\tfor(j=i;j>0;j/=10){\n\t\t\tif(j%10==0){\n\t\t\t\ttemp=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(temp!=0){\n\t\t\tfor(j=temp;j>0;j/=10){\n\t\t\t\tif(j%10==0){\n\t\t\t\t\ttemp=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(temp!=0){\n\t\t\treturnNums[0]=i;\n\t\t\treturnNums[1]=temp;\n\t\t\t*returnSize=2;\n\t\t\treturn returnNums;\n\t\t}\n\t}\n\treturn NULL;\n}", "prefix": "int* getNoZeroIntegers(int n, int* returnSize"}
{"id": "275", "path": "output2\\c\\Easy\\275-maximum-69-number.c", "hypo_code": "int maximum69Number (int num){\nint i;\n    char str[5];\n    sprintf(str,\"%d\",num);\n    for(i=0;i<strlen(str);i++){\n        if(str[i]=='6'){\n            str[i]='9';\n            break;\n        }\n    }\n    return atoi(str);\n}", "prefix": "int maximum69Number (int num"}
{"id": "277", "path": "output2\\c\\Easy\\277-rank-transform-of-an-array.c", "hypo_code": "int* arrayRankTransform(int* arr, int arrSize, int* returnSize){\nint i,j;\n    int temp;\n    for(i=0;i<arrSize;i++){\n        returnNums[i]=arr[i];\n    }\n    for(i=0;i<arrSize-1;i++){\n        for(j=0;j<arrSize-i-1;j++){\n            if(returnNums[j]>returnNums[j+1]){\n                temp=returnNums[j];\n                returnNums[j]=returnNums[j+1];\n                returnNums[j+1]=temp;\n            }\n        }\n    }\n    for(i=0,j=1;i<arrSize;i++){\n        if(returnNums[i]!=returnNums[i+1]){\n            returnNums[i]=j;\n            j++;\n        }else{\n            returnNums[i]=j;\n        }\n    }\n    *returnSize=arrSize;\n    return returnNums;\n}", "prefix": "int* arrayRankTransform(int* arr, int arrSize, int* returnSize"}
{"id": "278", "path": "output2\\c\\Easy\\278-remove-palindromic-subsequences.c", "hypo_code": "int removePalindromeSub(char * s){\nint i,j;\n    if(s[0]==0)\n        return 0;\n    for(i=0,j=strlen(s)-1;i<j;i++,j--){\n        if(s[i]!=s[j])\n            return 2;\n    }\n    return 1;\n}", "prefix": "int removePalindromeSub(char * s"}
{"id": "279", "path": "output2\\c\\Easy\\279-the-k-weakest-rows-in-a-matrix.c", "hypo_code": "int* kWeakestRows(int** mat, int matSize, int* matColSize, int k, int* returnSize){\nint i,j;\n    int *sum = malloc(sizeof(int)*matSize);\n    for(i=0;i<matSize;i++){\n        sum[i]=0;\n        for(j=0;j<matColSize[i];j++){\n            if(mat[i][j]==1){\n                sum[i]++;\n            }\n        }\n    }\n    int *sumCopy = malloc(sizeof(int)*matSize);\n    for(i=0;i<matSize;i++){\n        sumCopy[i]=sum[i];\n    }\n    int min=0;\n    int minIndex=0;\n    for(i=0;i<k;i++){\n        min=sumCopy[0];\n        minIndex=0;\n        for(j=1;j<matSize;j++){\n            if(sumCopy[j]<min){\n                min=sumCopy[j];\n                minIndex=j;\n            }\n        }\n        returnNums[i]=minIndex;\n        sumCopy[minIndex]=101;\n    }\n    *returnSize=k;\n    return returnNums;\n}", "prefix": "int* kWeakestRows(int** mat, int matSize, int* matColSize, int k, int* returnSize"}
{"id": "280", "path": "output2\\c\\Easy\\280-number-of-steps-to-reduce-a-number-to-zero.c", "hypo_code": "int numberOfSteps(int num){\nint result = 0;\n    while(num > 0){\n        if(num % 2 == 0)\n            num /= 2;\n        else\n            num -= 1;\n        result++;\n    }\n    return result;\n}", "prefix": "int numberOfSteps(int num"}
{"id": "281", "path": "output2\\c\\Easy\\281-check-if-n-and-its-double-exist.c", "hypo_code": "bool checkIfExist(int* arr, int arrSize){\nint i, j;\n\tfor (i = 0; i < arrSize; ++i) {\n\t\tfor (j = 0; j < arrSize; ++j) {\n\t\t\tif (i != j && arr[i] == 2 * arr[j]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "prefix": "bool checkIfExist(int* arr, int arrSize"}
{"id": "282", "path": "output2\\c\\Easy\\282-count-negative-numbers-in-a-sorted-matrix.c", "hypo_code": "int countNegatives(int** grid, int gridSize, int* gridColSize){\nint row = 0, col = *gridColSize - 1, result = 0;\n\twhile(row < gridSize && col >= 0){\n\t\tif(grid[row][col] < 0){\n\t\t\tresult += gridSize - row;\n\t\t\tcol--;\n\t\t}else{\n\t\t\trow++;\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int countNegatives(int** grid, int gridSize, int* gridColSize"}
{"id": "283", "path": "output2\\c\\Easy\\283-sort-integers-by-the-number-of-1-bits.c", "hypo_code": "int* sortByBits(int* arr, int arrSize, int* returnSize){\nint i,j;\n    *returnSize=arrSize;\n    int *returnArr=(int *)malloc(sizeof(int)*arrSize);\n    for(i=0;i<arrSize;i++){\n        int temp=0;\n        int tempArr=arr[i];\n        while(tempArr){\n            temp+=tempArr%2;\n            tempArr/=2;\n        }\n        returnArr[i]=temp;\n    }\n    for(i=0;i<arrSize;i++){\n        for(j=0;j<arrSize-i-1;j++){\n            if(returnArr[j]>returnArr[j+1]){\n                int temp=returnArr[j];\n                returnArr[j]=returnArr[j+1];\n                returnArr[j+1]=temp;\n                temp=arr[j];\n                arr[j]=arr[j+1];\n                arr[j+1]=temp;\n            }\n        }\n    }\n    return returnArr;\n}", "prefix": "int* sortByBits(int* arr, int arrSize, int* returnSize"}
{"id": "284", "path": "output2\\c\\Easy\\284-number-of-days-between-two-dates.c", "hypo_code": "int daysBetweenDates(char * date1, char * date2){  \n    int days = 0;\n    int year1 = 0, month1 = 0, day1 = 0;\n    int year2 = 0, month2 = 0, day2 = 0;\n    sscanf(date1, \"%d-%d-%d\", &year1, &month1, &day1);\n    sscanf(date2, \"%d-%d-%d\", &year2, &month2, &day2);\n    \n    int daysOfMonths[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\n    if((year1 % 4 == 0 && year1 % 100 != 0) || year1 % 400 == 0)\n        daysOfMonths[1] = 29;\n    int i = 0;\n    for(i = 0; i < month1 - 1; i++)\n        days += daysOfMonths[i];\n    days += day1;\n    \n    if((year2 % 4 == 0 && year2 % 100 != 0) || year2 % 400 == 0)\n        daysOfMonths[1] = 29;\n    else\n        daysOfMonths[1] = 28;\n    for(i = 0; i < month2 - 1; i++)\n        days -= daysOfMonths[i];\n    days -= day2;\n    \n    if(year1 == year2)\n        return abs(days);\n    else{\n        int year = 0;\n        if(year1 < year2){\n            for(year = year1; year < year2; year++){\n                if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n                    days += 366;\n                else\n                    days += 365;\n            }\n        }\n        else{\n            for(year = year2; year < year1; year++){\n                if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n                    days -= 366;\n                else\n                    days -= 365;\n            }\n        }\n    }\n    return abs(days);\n}", "prefix": "int daysBetweenDates(char * date1, char * date2"}
{"id": "285", "path": "output2\\c\\Easy\\285-how-many-numbers-are-smaller-than-the-current-number.c", "hypo_code": "int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){\nint i,j;\n    *returnSize=numsSize;\n    int *returnNums=(int *)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        int temp=0;\n        for(j=0;j<numsSize;j++){\n            if(nums[i]>nums[j]){\n                temp++;\n            }\n        }\n        returnNums[i]=temp;\n    }\n    return returnNums;\n}", "prefix": "int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize"}
{"id": "286", "path": "output2\\c\\Easy\\286-increasing-decreasing-string.c", "hypo_code": "char * sortString(char * s){\nint i, j, k, l, len = strlen(s);\n    char *result = malloc(sizeof(char) * (len + 1));\n    int *count = calloc(26, sizeof(int));\n    for(i = 0; i < len; i++)\n        count[s[i] - 'a']++;\n    for(i = 0, j = 0, k = 25; i < len;){\n        if(count[j] > 0){\n            result[i++] = j + 'a';\n            count[j]--;\n        }\n        if(count[k] > 0){\n            result[i++] = k + 'a';\n            count[k]--;\n        }\n        if(j == k)\n            break;\n        if(j < k)\n            j++;\n        else\n            k--;\n    }\n    result[len] = '\\0';\n    return result;\n}", "prefix": "char * sortString(char * s"}
{"id": "287", "path": "output2\\c\\Easy\\287-generate-a-string-with-characters-that-have-odd-counts.c", "hypo_code": "char * generateTheString(int n){\nchar *result = (char *)malloc(sizeof(char) * (n + 1));\n    if(n % 2 == 0){\n        result[0] = 'a';\n        for(int i = 1; i < n; i++)\n            result[i] = 'b';\n    }\n    else{\n        for(int i = 0; i < n; i++)\n            result[i] = 'a';\n    }\n    result[n] = '\\0';\n    return result;\n}", "prefix": "char * generateTheString(int n"}
{"id": "290", "path": "output2\\c\\Easy\\290-lucky-numbers-in-a-matrix.c", "hypo_code": "int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\nint i,j,k;\n    *returnSize=0;\n    int *returnNums=(int *)malloc(sizeof(int)*matrixSize*matrixColSize[0]);\n    for(i=0;i<matrixSize;i++){\n        int min=matrix[i][0];\n        int minCol=0;\n        for(j=1;j<matrixColSize[i];j++){\n            if(matrix[i][j]<min){\n                min=matrix[i][j];\n                minCol=j;\n            }\n        }\n        bool flag=true;\n        for(k=0;k<matrixSize;k++){\n            if(matrix[k][minCol]>min){\n                flag=false;\n                break;\n            }\n        }\n        if(flag){\n            returnNums[*returnSize]=min;\n            (*returnSize)++;\n        }\n    }\n    return returnNums;\n}", "prefix": "int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize"}
{"id": "291", "path": "output2\\c\\Easy\\291-find-the-distance-value-between-two-arrays.c", "hypo_code": "int findTheDistanceValue(int* arr1, int arr1Size, int* arr2, int arr2Size, int d){\nint i,j,count=0;\n    for(i=0;i<arr1Size;i++){\n        int temp=0;\n        for(j=0;j<arr2Size;j++){\n            if(arr1[i]>arr2[j]){\n                temp++;\n            }\n        }\n        if(temp==arr2Size)\n            count++;\n    }\n    return count;\n}", "prefix": "int findTheDistanceValue(int* arr1, int arr1Size, int* arr2, int arr2Size, int d"}
{"id": "292", "path": "output2\\c\\Easy\\292-create-target-array-in-the-given-order.c", "hypo_code": "int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize){\nint i,j;\n    *returnSize=numsSize;\n    int *returnNums=(int *)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        for(j=numsSize-1;j>index[i];j--){\n            returnNums[j]=returnNums[j-1];\n        }\n        returnNums[index[i]]=nums[i];\n    }\n    return returnNums;\n}", "prefix": "int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize"}
{"id": "293", "path": "output2\\c\\Easy\\293-find-lucky-integer-in-an-array.c", "hypo_code": "int findLucky(int* arr, int arrSize){\nint i,j;\n    for(i=0;i<arrSize;i++){\n        int temp=0;\n        for(j=0;j<arrSize;j++){\n            if(arr[i]==arr[j]){\n                temp++;\n            }\n        }\n        if(temp==arr[i]){\n            return arr[i];\n        }\n    }\n    return -1;\n}", "prefix": "int findLucky(int* arr, int arrSize"}
{"id": "294", "path": "output2\\c\\Easy\\294-count-largest-group.c", "hypo_code": "int countLargestGroup(int n){\nint i,j,count=0;\n    for(i=1;i<=n;i++){\n        int temp=0;\n        for(j=1;j<=9;j++){\n            if(i>10){\n                if(i%10==j)\n                    temp++;\n                i/=10;\n            }else{\n                if(i==j)\n                    temp++;\n            }\n        }\n        if(temp==n)\n            count++;\n    }\n    return count;\n}", "prefix": "int countLargestGroup(int n"}
{"id": "295", "path": "output2\\c\\Easy\\295-minimum-subsequence-in-non-increasing-order.c", "hypo_code": "int* minSubsequence(int* nums, int numsSize, int* returnSize){\n*returnSize=0;\n    int *returnNums=(int *)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        for(j=0;j<numsSize-i-1;j++){\n            if(nums[j]<nums[j+1]){\n                int temp=nums[j];\n                nums[j]=nums[j+1];\n                nums[j+1]=temp;\n            }\n        }\n    }\n    int sum=0;\n    for(i=0;i<numsSize;i++){\n        sum+=nums[i];\n    }\n    int tempSum=0;\n    for(i=0;i<numsSize;i++){\n        tempSum+=nums[i];\n        returnNums[*returnSize]=nums[i];\n        (*returnSize)++;\n        if(tempSum>sum/2){\n            break;\n        }\n    }\n    return returnNums;\n}", "prefix": "int* minSubsequence(int* nums, int numsSize, int* returnSize"}
{"id": "297", "path": "output2\\c\\Easy\\297-string-matching-in-an-array.c", "hypo_code": "char ** stringMatching(char ** words, int wordsSize, int* returnSize){\nint i,j;\n    *returnSize=0;\n    char **returnWords=(char **)malloc(sizeof(char *)*wordsSize);\n    for(i=0;i<wordsSize;i++){\n        for(j=0;j<wordsSize;j++){\n            if(i!=j){\n                char *p=strstr(words[j],words[i]);\n                if(p!=NULL){\n                    returnWords[*returnSize]=words[i];\n                    (*returnSize)++;\n                    break;\n                }\n            }\n        }\n    }\n    return returnWords;\n\n}", "prefix": "char ** stringMatching(char ** words, int wordsSize, int* returnSize"}
{"id": "298", "path": "output2\\c\\Easy\\298-minimum-value-to-get-positive-step-by-step-sum.c", "hypo_code": "int minStartValue(int* nums, int numsSize){\nint i, min = 0, sum = 0;\n    for (i = 0; i < numsSize; ++i) {\n        sum += nums[i];\n        if (sum < min) {\n            min = sum;\n        }\n    }\n    return 1 - min;\n}", "prefix": "int minStartValue(int* nums, int numsSize"}
{"id": "299", "path": "output2\\c\\Easy\\299-reformat-the-string.c", "hypo_code": "char * reformat(char * s){\nint i, j, k, l, len = strlen(s);\n    char *result = malloc(sizeof(char) * (len + 1));\n    int *count = calloc(26, sizeof(int));\n    for(i = 0; i < len; i++)\n        count[s[i] - 'a']++;\n    for(i = 0, j = 0, k = 25; i < len;){\n        if(count[j] > 0){\n            result[i++] = j + 'a';\n            count[j]--;\n        }\n        if(count[k] > 0){\n            result[i++] = k + 'a';\n            count[k]--;\n        }\n        if(j == k)\n            break;\n        if(j < k)\n            j++;\n        else\n            k--;\n    }\n    result[len] = '\\0';\n    return result;\n}", "prefix": "char * reformat(char * s"}
{"id": "300", "path": "output2\\c\\Easy\\300-maximum-score-after-splitting-a-string.c", "hypo_code": "int maxScore(char * s){\nint i,j,count=0,max=0;\n    for(i=0;i<strlen(s)-1;i++){\n        count=0;\n        for(j=0;j<=i;j++){\n            if(s[j]=='0')\n                count++;\n        }\n        for(j=i+1;j<strlen(s);j++){\n            if(s[j]=='1')\n                count++;\n        }\n        if(count>max)\n            max=count;\n    }\n    return max;\n}", "prefix": "int maxScore(char * s"}
{"id": "301", "path": "output2\\c\\Easy\\301-kids-with-the-greatest-number-of-candies.c", "hypo_code": "bool* kidsWithCandies(int* candies, int candiesSize, int extraCandies, int* returnSize){\n*returnSize=candiesSize;\n    bool *returnNums=(bool *)malloc(sizeof(bool)*candiesSize);\n    int maxCandies=candies[0];\n    for(i=1;i<candiesSize;i++){\n        if(maxCandies<candies[i]){\n            maxCandies=candies[i];\n        }\n    }\n    for(i=0;i<candiesSize;i++){\n        if(candies[i]+extraCandies>=maxCandies){\n            returnNums[i]=true;\n        }else{\n            returnNums[i]=false;\n        }\n    }\n    return returnNums;\n}", "prefix": "bool* kidsWithCandies(int* candies, int candiesSize, int extraCandies, int* returnSize"}
{"id": "302", "path": "output2\\c\\Easy\\302-destination-city.c", "hypo_code": "char * destCity(char *** paths, int pathsSize, int* pathsColSize){\nint i,j,k;\n    char *returnCity=(char *)malloc(sizeof(char)*11);\n    for(i=0;i<pathsSize;i++){\n        for(j=0;j<pathsSize;j++){\n            if(strcmp(paths[i][1],paths[j][0])==0){\n                break;\n            }\n        }\n        if(j==pathsSize){\n            strcpy(returnCity,paths[i][1]);\n            return returnCity;\n        }\n    }\n    return NULL;\n}", "prefix": "char * destCity(char *** paths, int pathsSize, int* pathsColSize"}
{"id": "303", "path": "output2\\c\\Easy\\303-check-if-all-1s-are-at-least-length-k-places-away.c", "hypo_code": "bool kLengthApart(int* nums, int numsSize, int k){\nint i, j = -1;\n\tfor (i = 0; i < numsSize; ++i) {\n\t\tif (nums[i] == 1) {\n\t\t\tif (j != -1 && i - j - 1 < k) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tj = i;\n\t\t}\n\t}\n\treturn true;\n}", "prefix": "bool kLengthApart(int* nums, int numsSize, int k"}
{"id": "304", "path": "output2\\c\\Easy\\304-consecutive-characters.c", "hypo_code": "int maxPower(char * s){\nint i,j=1,max=1;\n    for(i=0;i<strlen(s)-1;i++){\n        if(s[i]==s[i+1]){\n            j++;\n            if(max<j)\n                max=j;\n        }\n        else\n            j=1;\n    }\n    return max;\n}", "prefix": "int maxPower(char * s"}
{"id": "305", "path": "output2\\c\\Easy\\305-number-of-students-doing-homework-at-a-given-time.c", "hypo_code": "int busyStudent(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int queryTime){\nint i,count=0;\n    for(i=0;i<startTimeSize;i++){\n        if(queryTime>=startTime[i]&&queryTime<=endTime[i])\n            count++;\n    }\n    return count;\n}", "prefix": "int busyStudent(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int queryTime"}
{"id": "306", "path": "output2\\c\\Easy\\306-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence.c", "hypo_code": "int isPrefixOfWord(char * sentence, char * searchWord){\nint i=0,j=0,k=0;\n    while(sentence[i]){\n        if(sentence[i]==' '){\n            j++;\n            k=0;\n        }\n        else if(sentence[i]==searchWord[k]){\n            k++;\n            if(searchWord[k]=='\\0')\n                return j+1;\n        }\n        else\n            k=0;\n        i++;\n    }\n    return -1;\n}", "prefix": "int isPrefixOfWord(char * sentence, char * searchWord"}
{"id": "307", "path": "output2\\c\\Easy\\307-make-two-arrays-equal-by-reversing-subarrays.c", "hypo_code": "bool canBeEqual(int* target, int targetSize, int* arr, int arrSize){\nint i,j;\n    for(i=0;i<targetSize;i++){\n        for(j=0;j<arrSize;j++){\n            if(target[i]==arr[j]){\n                arr[j]=0;\n                break;\n            }\n        }\n    }\n    for(i=0;i<arrSize;i++){\n        if(arr[i]!=0)\n            return false;\n    }\n    return true;\n}", "prefix": "bool canBeEqual(int* target, int targetSize, int* arr, int arrSize"}
{"id": "308", "path": "output2\\c\\Easy\\308-maximum-product-of-two-elements-in-an-array.c", "hypo_code": "int maxProduct(int* nums, int numsSize){\nint i, j, max = 0;\n    for (i = 0; i < numsSize; ++i) {\n        for (j = i + 1; j < numsSize; ++j) {\n            int temp = (nums[i] - 1) * (nums[j] - 1);\n            if (temp > max) {\n                max = temp;\n            }\n        }\n    }\n    return max;\n}", "prefix": "int maxProduct(int* nums, int numsSize"}
{"id": "309", "path": "output2\\c\\Easy\\309-shuffle-the-array.c", "hypo_code": "int* shuffle(int* nums, int numsSize, int n, int* returnSize){\nint i;\n    for(i=0;i<n;i++){\n        returnNums[i*2]=nums[i];\n        returnNums[i*2+1]=nums[i+n];\n    }\n    *returnSize=numsSize;\n    return returnNums;\n}", "prefix": "int* shuffle(int* nums, int numsSize, int n, int* returnSize"}
{"id": "310", "path": "output2\\c\\Easy\\310-final-prices-with-a-special-discount-in-a-shop.c", "hypo_code": "int* finalPrices(int* prices, int pricesSize, int* returnSize){\nint i,j;\n    *returnSize=pricesSize;\n    int *returnPrices=(int *)malloc(sizeof(int)*pricesSize);\n    for(i=0;i<pricesSize;i++){\n        int temp=0;\n        for(j=i+1;j<pricesSize;j++){\n            if(prices[j]<=prices[i]){\n                temp=prices[j];\n                break;\n            }\n        }\n        returnPrices[i]=prices[i]-temp;\n    }\n    return returnPrices;\n}", "prefix": "int* finalPrices(int* prices, int pricesSize, int* returnSize"}
{"id": "311", "path": "output2\\c\\Easy\\311-running-sum-of-1d-array.c", "hypo_code": "int* runningSum(int* nums, int numsSize, int* returnSize){\n    int i;\n    *returnSize=numsSize;\n    int *returnNums=(int *)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        if(i==0){\n            returnNums[i]=nums[i];\n        }else{\n            returnNums[i]=returnNums[i-1]+nums[i];\n        }\n    }\n    return returnNums;\n}", "prefix": "int* runningSum(int* nums, int numsSize, int* returnSize"}
{"id": "313", "path": "output2\\c\\Easy\\313-xor-operation-in-an-array.c", "hypo_code": "int xorOperation(int n, int start){\nint i;\n    int result = start;\n    for (i = 1; i < n; i++) {\n        result ^= (start + 2 * i);\n    }\n    return result;\n}", "prefix": "int xorOperation(int n, int start"}
{"id": "314", "path": "output2\\c\\Easy\\314-average-salary-excluding-the-minimum-and-maximum-salary.c", "hypo_code": "double average(int* salary, int salarySize){\nint i, j, min = 0, max = 0;\n    double sum = 0;\n    for (i = 0; i < salarySize; ++i) {\n        if (salary[i] < salary[min]) {\n            min = i;\n        }\n        if (salary[i] > salary[max]) {\n            max = i;\n        }\n    }\n    for (i = 0; i < salarySize; ++i) {\n        if (i != min && i != max) {\n            sum += salary[i];\n        }\n    }\n    return sum / (salarySize - 2);\n}", "prefix": "double average(int* salary, int salarySize"}
{"id": "315", "path": "output2\\c\\Easy\\315-path-crossing.c", "hypo_code": "bool isPathCrossing(char * path){\nint x=0,y=0,i,j;\n    int **pathArr=(int **)malloc(sizeof(int *)*strlen(path));\n    for(i=0;i<strlen(path);i++){\n        pathArr[i]=(int *)malloc(sizeof(int)*2);\n    }\n    for(i=0;i<strlen(path);i++){\n        if(path[i]=='N'){\n            y++;\n        }\n        else if(path[i]=='S'){\n            y--;\n        }\n        else if(path[i]=='E'){\n            x++;\n        }\n        else if(path[i]=='W'){\n            x--;\n        }\n        pathArr[i][0]=x;\n        pathArr[i][1]=y;\n    }\n    for(i=0;i<strlen(path);i++){\n        for(j=i+1;j<strlen(path);j++){\n            if(pathArr[i][0]==pathArr[j][0]&&pathArr[i][1]==pathArr[j][1])\n                return true;\n        }\n    }\n    return false;\n}", "prefix": "bool isPathCrossing(char * path"}
{"id": "316", "path": "output2\\c\\Easy\\316-can-make-arithmetic-progression-from-sequence.c", "hypo_code": "bool canMakeArithmeticProgression(int* arr, int arrSize){\nint i, j, temp;\n    for(i=0;i<arrSize;i++){\n        for(j=i+1;j<arrSize;j++){\n            if(arr[i]>arr[j]){\n                temp=arr[i];\n                arr[i]=arr[j];\n                arr[j]=temp;\n            }\n        }\n    }\n    int diff=arr[1]-arr[0];\n    for(i=2;i<arrSize;i++){\n        if(arr[i]-arr[i-1]!=diff)\n            return false;\n    }\n    return true;\n}", "prefix": "bool canMakeArithmeticProgression(int* arr, int arrSize"}
{"id": "317", "path": "output2\\c\\Easy\\317-reformat-date.c", "hypo_code": "char * reformatDate(char * date){ \nchar *result = (char *)malloc(sizeof(char) * 11);\n    int i = 0, j = 0;\n    char *month = (char *)malloc(sizeof(char) * 4);\n    char *day = (char *)malloc(sizeof(char) * 3);\n    char *year = (char *)malloc(sizeof(char) * 5);\n    for(i = 0; i < 4; i++)\n        year[i] = date[i + 8];\n    year[4] = '\\0';\n    for(i = 0; i < 3; i++)\n        month[i] = date[i + 4];\n    month[3] = '\\0';\n    for(i = 0; i < 2; i++)\n        day[i] = date[i + 1];\n    day[2] = '\\0';\n    char *months[12] = {\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\n    for(i = 0; i < 12; i++){\n        if(strcmp(month, months[i]) == 0){\n            if(i < 9)\n                sprintf(month, \"0%d\", i + 1);\n            else\n                sprintf(month, \"%d\", i + 1);\n            break;\n        }\n    }\n    sprintf(result, \"%s-%s-%s\", year, month, day);\n    return result;\n}", "prefix": "char * reformatDate(char * date"}
{"id": "318", "path": "output2\\c\\Easy\\318-number-of-good-pairs.c", "hypo_code": "int numIdenticalPairs(int* nums, int numsSize){\nint i,j,count=0;\n    for(i=0;i<numsSize-1;i++){\n        for(j=i+1;j<numsSize;j++){\n            if(nums[i]==nums[j])\n                count++;\n        }\n    }\n    return count;\n}", "prefix": "int numIdenticalPairs(int* nums, int numsSize"}
{"id": "320", "path": "output2\\c\\Easy\\320-water-bottles.c", "hypo_code": "int numWaterBottles(int numBottles, int numExchange){\nint i,j,count=0;\n    count=numBottles;\n    while(numBottles>=numExchange){\n        i=numBottles/numExchange;\n        j=numBottles%numExchange;\n        count+=i;\n        numBottles=i+j;\n    }\n    return count;\n}", "prefix": "int numWaterBottles(int numBottles, int numExchange"}
{"id": "321", "path": "output2\\c\\Easy\\321-count-odd-numbers-in-an-interval-range.c", "hypo_code": "int countOdds(int low, int high){\nint result = 0;\n    if(low % 2 == 0){\n        result = (high - low) / 2;\n    }else{\n        result = (high - low + 1) / 2;\n    }\n    return result;\n}", "prefix": "int countOdds(int low, int high"}
{"id": "323", "path": "output2\\c\\Easy\\323-shuffle-string.c", "hypo_code": "char * restoreString(char * s, int* indices, int indicesSize){\nint i;\n    for(i = 0; i < indicesSize; i++)\n    {\n        res[indices[i]] = s[i];\n    }\n    res[indicesSize] = '\\0';\n    return res;\n}", "prefix": "char * restoreString(char * s, int* indices, int indicesSize"}
{"id": "324", "path": "output2\\c\\Easy\\324-count-good-triplets.c", "hypo_code": "int countGoodTriplets(int* arr, int arrSize, int a, int b, int c){\nint i, j, k, count = 0;\n\tfor (i = 0; i < arrSize; ++i) {\n\t\tfor (j = i + 1; j < arrSize; ++j) {\n\t\t\tif (abs(arr[i] - arr[j]) <= a) {\n\t\t\t\tfor (k = j + 1; k < arrSize; ++k) {\n\t\t\t\t\tif (abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c) {\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int countGoodTriplets(int* arr, int arrSize, int a, int b, int c"}
{"id": "325", "path": "output2\\c\\Easy\\325-kth-missing-positive-number.c", "hypo_code": "int findKthPositive(int* arr, int arrSize, int k){\nint i, j = 0;\n\tfor (i = 1; i <= arr[arrSize - 1]; ++i) {\n\t\tif (i == arr[j]) {\n\t\t\t++j;\n\t\t} else {\n\t\t\tif (--k == 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\treturn arr[arrSize - 1] + k;\n}", "prefix": "int findKthPositive(int* arr, int arrSize, int k"}
{"id": "326", "path": "output2\\c\\Easy\\326-make-the-string-great.c", "hypo_code": "char * makeGood(char * s){\nint i = 0, j = 0;\n    while(s[i] != '\\0') {\n        if(j > 0 && abs(s[j - 1] - s[j]) == 32) {\n            j--;\n        } else {\n            s[j] = s[i];\n            j++;\n        }\n        i++;\n    }\n    s[j] = '\\0';\n    return s;\n}", "prefix": "char * makeGood(char * s"}
{"id": "327", "path": "output2\\c\\Easy\\327-three-consecutive-odds.c", "hypo_code": "bool threeConsecutiveOdds(int* arr, int arrSize){\nint i;\n    for (i = 0; i < arrSize - 2; ++i) {\n        if (arr[i] % 2 == 1 && arr[i + 1] % 2 == 1 && arr[i + 2] % 2 == 1) {\n            return true;\n        }\n    }\n    return false;\n}", "prefix": "bool threeConsecutiveOdds(int* arr, int arrSize"}
{"id": "328", "path": "output2\\c\\Easy\\328-thousand-separator.c", "hypo_code": "char * thousandSeparator(int n){\nint i, j = 0, k = 0, l = 0, m = 0;\n    char *str = (char*)malloc(sizeof(char) * 10);\n    if(n == 0){\n        str[0] = '0';\n        str[1] = '\\0';\n        return str;\n    }\n    while(n != 0){\n        str[k++] = n % 10 + '0';\n        n /= 10;\n        j++;\n        if(j % 3 == 0){\n            str[k++] = '.';\n            l++;\n        }\n    }\n    str[k] = '\\0';\n    if(str[k - 1] == '.')\n        str[k - 1] = '\\0';\n    for(i = 0; i < k / 2; i++){\n        m = str[i];\n        str[i] = str[k - i - 1];\n        str[k - i - 1] = m;\n    }\n    return str;\n}", "prefix": "char * thousandSeparator(int n"}
{"id": "329", "path": "output2\\c\\Easy\\329-most-visited-sector-in-a-circular-track.c", "hypo_code": "int* mostVisited(int n, int* rounds, int roundsSize, int* returnSize){\nint i,j;\n    int *returnNums=(int *)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        returnNums[i]=0;\n    }\n    for(i=0;i<roundsSize-1;i++){\n        if(rounds[i]<rounds[i+1]){\n            for(j=rounds[i];j<=rounds[i+1];j++){\n                returnNums[j-1]++;\n            }\n        }else{\n            for(j=rounds[i];j<=n;j++){\n                returnNums[j-1]++;\n            }\n            for(j=1;j<=rounds[i+1];j++){\n                returnNums[j-1]++;\n            }\n        }\n    }\n    int max=returnNums[0];\n    for(i=1;i<n;i++){\n        if(max<returnNums[i]){\n            max=returnNums[i];\n        }\n    }\n    *returnSize=0;\n    for(i=0;i<n;i++){\n        if(max==returnNums[i]){\n            (*returnSize)++;\n        }\n    }\n    int *returnArr=(int *)malloc(sizeof(int)*(*returnSize));\n    j=0;\n    for(i=0;i<n;i++){\n        if(max==returnNums[i]){\n            returnArr[j]=i+1;\n            j++;\n        }\n    }\n    return returnArr;\n}", "prefix": "int* mostVisited(int n, int* rounds, int roundsSize, int* returnSize"}
{"id": "330", "path": "output2\\c\\Easy\\330-detect-pattern-of-length-m-repeated-k-or-more-times.c", "hypo_code": "bool containsPattern(int* arr, int arrSize, int m, int k){\nint i, j, l;\n\tfor (i = 0; i <= arrSize - m * k; ++i) {\n\t\tfor (j = i + m, l = 1; j < arrSize && l < k; j += m) {\n\t\t\tfor (int n = 0; n < m; ++n) {\n\t\t\t\tif (arr[i + n] != arr[j + n]) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t}\n\t\t\t++l;\n\t\t}\n\t\tif (l == k) {\n\t\t\treturn true;\n\t\t}\n\t\tnext:;\n\t}\n\treturn false;\n}", "prefix": "bool containsPattern(int* arr, int arrSize, int m, int k"}
{"id": "331", "path": "output2\\c\\Easy\\331-matrix-diagonal-sum.c", "hypo_code": "int diagonalSum(int** mat, int matSize, int* matColSize){\nint i, j, result = 0;\n\tfor (i = 0; i < matSize; ++i) {\n\t\tresult += mat[i][i];\n\t\tresult += mat[i][matSize - 1 - i];\n\t}\n\tif (matSize % 2 == 1) {\n\t\tresult -= mat[matSize / 2][matSize / 2];\n\t}\n\treturn result;\n}", "prefix": "int diagonalSum(int** mat, int matSize, int* matColSize"}
{"id": "332", "path": "output2\\c\\Easy\\332-replace-all-s-to-avoid-consecutive-repeating-characters.c", "hypo_code": "char * modifyString(char * s){\nint i,j,k;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='?'){\n            for(j='a';j<='z';j++){\n                if(i==0){\n                    if(s[i+1]!=j){\n                        s[i]=j;\n                        break;\n                    }\n                }\n                else if(i==strlen(s)-1){\n                    if(s[i-1]!=j){\n                        s[i]=j;\n                        break;\n                    }\n                }\n                else if(s[i-1]!=j && s[i+1]!=j){\n                    s[i]=j;\n                    break;\n                }\n            }\n        }\n    }\n    return s;\n}", "prefix": "char * modifyString(char * s"}
{"id": "334", "path": "output2\\c\\Easy\\334-special-positions-in-a-binary-matrix.c", "hypo_code": "int numSpecial(int** mat, int matSize, int* matColSize){\nint i,j,k;\n    int *row=(int *)malloc(sizeof(int)*matSize);\n    int *col=(int *)malloc(sizeof(int)*matColSize[0]);\n    memset(row,0,sizeof(int)*matSize);\n    memset(col,0,sizeof(int)*matColSize[0]);\n    for(i=0;i<matSize;i++){\n        for(j=0;j<matColSize[i];j++){\n            if(mat[i][j]==1){\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    int count=0;\n    for(i=0;i<matSize;i++){\n        for(j=0;j<matColSize[i];j++){\n            if(mat[i][j]==1&&row[i]==1&&col[j]==1)\n                count++;\n        }\n    }\n    return count;\n}", "prefix": "int numSpecial(int** mat, int matSize, int* matColSize"}
{"id": "336", "path": "output2\\c\\Easy\\336-sum-of-all-odd-length-subarrays.c", "hypo_code": "int sumOddLengthSubarrays(int* arr, int arrSize){\nint i, j, sum = 0;\n    for (i = 0; i < arrSize; ++i) {\n        for (j = i; j < arrSize; j += 2) {\n            sum += arr[j];\n        }\n    }\n    return sum;\n}", "prefix": "int sumOddLengthSubarrays(int* arr, int arrSize"}
{"id": "337", "path": "output2\\c\\Easy\\337-rearrange-spaces-between-words.c", "hypo_code": "char * reorderSpaces(char * text){\nint i,j=0,k=0,l=0,m=0,n=0;\n    for(i=0;i<strlen(text);i++){\n        if(text[i]==' ')\n            k++;\n    }\n    char *temp = (char *)malloc(sizeof(char) * (strlen(text) + 1));\n    for(i=0;i<strlen(text);i++){\n        if(text[i]!=' '){\n            temp[j]=text[i];\n            j++;\n        }\n        else{\n            if(text[i+1]!=' '){\n                temp[j]=' ';\n                j++;\n            }\n            else\n                continue;\n        }\n    }\n    temp[j]='\\0';\n    char *result = (char *)malloc(sizeof(char) * (strlen(text) + 1));\n    if(k==0){\n        for(i=0;i<strlen(text);i++){\n            result[i]=text[i];\n        }\n        result[i]='\\0';\n        return result;\n    }\n    else if(j==1){\n        for(i=0;i<strlen(text);i++){\n            if(text[i]!=' '){\n                result[i]=text[i];\n            }\n            else\n                break;\n        }\n        result[i]='\\0';\n        for(i=0;i<k;i++){\n            strcat(result,\" \");\n        }\n        return result;\n    }\n    else{\n        for(i=0;i<strlen(temp);i++){\n            if(temp[i]==' ')\n                l++;\n        }\n        m=l/(j-1);\n        n=l%(j-1);\n        for(i=0;i<j-1;i++){\n            result[i]=temp[i];\n            for(int p=0;p<m;p++){\n                strcat(result,\" \");\n            }\n        }\n        result[i]='\\0';\n        for(i=0;i<n;i++){\n            strcat(result,\" \");\n        }\n        return result;\n    }\n}", "prefix": "char * reorderSpaces(char * text"}
{"id": "338", "path": "output2\\c\\Easy\\338-crawler-log-folder.c", "hypo_code": "int minOperations(char ** logs, int logsSize){\nint i = 0, j = 0, k = 0;\n    for (i = 0; i < logsSize; i++){\n        if (logs[i][0] == '.' && logs[i][1] == '.'){\n            if (k > 0)\n                k--;\n        }\n        else if (logs[i][0] == '.')\n            continue;\n        else\n            k++;\n    }\n    return k;\n}", "prefix": "int minOperations(char ** logs, int logsSize"}
{"id": "340", "path": "output2\\c\\Easy\\340-special-array-with-x-elements-greater-than-or-equal-x.c", "hypo_code": "int specialArray(int* nums, int numsSize){\nint i,j;\n    for(i=0;i<=numsSize;i++){\n        int temp=0;\n        for(j=0;j<numsSize;j++){\n            if(nums[j]>=i)\n                temp++;\n        }\n        if(temp==i)\n            return i;\n    }\n    return -1;\n}", "prefix": "int specialArray(int* nums, int numsSize"}
{"id": "341", "path": "output2\\c\\Easy\\341-maximum-nesting-depth-of-the-parentheses.c", "hypo_code": "int maxDepth(char * s){\nint i,j=0,max=0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='('){\n            j++;\n            if(max<j)\n                max=j;\n        }\n        if(s[i]==')')\n            j--;\n    }\n    return max;\n}", "prefix": "int maxDepth(char * s"}
{"id": "342", "path": "output2\\c\\Easy\\342-mean-of-array-after-removing-some-elements.c", "hypo_code": "double trimMean(int* arr, int arrSize){\nint i, j, temp;\n    for(i=0;i<arrSize-1;i++){\n        for(j=i+1;j<arrSize;j++){\n            if(arr[i]>arr[j]){\n                temp=arr[i];\n                arr[i]=arr[j];\n                arr[j]=temp;\n            }\n        }\n    }\n    int sum=0;\n    for(i=arrSize/20;i<arrSize-arrSize/20;i++){\n        sum+=arr[i];\n    }\n    return (double)sum/(arrSize-arrSize/10);\n}", "prefix": "double trimMean(int* arr, int arrSize"}
{"id": "343", "path": "output2\\c\\Easy\\343-largest-substring-between-two-equal-characters.c", "hypo_code": "int maxLengthBetweenEqualCharacters(char * s){\nint i, j, k, l, m, n = 0;\n    for(i = 0; i < strlen(s); i++){\n        for(j = i + 1; j < strlen(s); j++){\n            if(s[i] == s[j]){\n                k = j - i - 1;\n                if(k > n)\n                    n = k;\n            }\n        }\n    }\n    if(n == 0)\n        return -1;\n    return n;\n}", "prefix": "int maxLengthBetweenEqualCharacters(char * s"}
{"id": "344", "path": "output2\\c\\Easy\\344-slowest-key.c", "hypo_code": "char slowestKey(int* releaseTimes, int releaseTimesSize, char * keysPressed){\nint i, max = releaseTimes[0];\n    char result = keysPressed[0];\n    for(i = 1; i < releaseTimesSize; i++){\n        if(releaseTimes[i] - releaseTimes[i - 1] > max){\n            max = releaseTimes[i] - releaseTimes[i - 1];\n            result = keysPressed[i];\n        }\n        else if(releaseTimes[i] - releaseTimes[i - 1] == max && keysPressed[i] > result){\n            result = keysPressed[i];\n        }\n    }\n    return result;\n}", "prefix": "char slowestKey(int* releaseTimes, int releaseTimesSize, char * keysPressed"}
{"id": "346", "path": "output2\\c\\Easy\\346-sort-array-by-increasing-frequency.c", "hypo_code": "int* frequencySort(int* nums, int numsSize, int* returnSize){\nint i,j;\n    *returnSize=numsSize;\n    int *returnNums=(int *)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        int temp=0;\n        for(j=0;j<numsSize;j++){\n            if(nums[i]>nums[j]){\n                temp++;\n            }\n        }\n        returnNums[i]=temp;\n    }\n    return returnNums;\n}", "prefix": "int* frequencySort(int* nums, int numsSize, int* returnSize"}
{"id": "347", "path": "output2\\c\\Easy\\347-check-array-formation-through-concatenation.c", "hypo_code": "bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\nint i,j,k;\n    for(i=0;i<arrSize;i++){\n        bool flag=false;\n        for(j=0;j<piecesSize;j++){\n            if(arr[i]==pieces[j][0]){\n                flag=true;\n                break;\n            }\n        }\n        if(!flag)\n            return false;\n        for(k=1;k<piecesColSize[j];k++){\n            if(arr[i+k]!=pieces[j][k])\n                return false;\n        }\n        i+=k-1;\n    }\n    return true;\n}", "prefix": "bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize"}
{"id": "348", "path": "output2\\c\\Easy\\348-get-maximum-in-generated-array.c", "hypo_code": "int getMaximumGenerated(int n){\nint i,j;\n    if(n==0)\n        return 0;\n    int *nums=(int *)malloc(sizeof(int)*(n+1));\n    nums[0]=0;\n    nums[1]=1;\n    int max=nums[1];\n    for(i=2;i<=n;i++){\n        nums[i]=i%2==0?nums[i/2]:nums[i/2]+nums[i/2+1];\n        if(nums[i]>max)\n            max=nums[i];\n    }\n    return max;\n}", "prefix": "int getMaximumGenerated(int n"}
{"id": "349", "path": "output2\\c\\Easy\\349-defuse-the-bomb.c", "hypo_code": "int* decrypt(int* code, int codeSize, int k, int* returnSize){\nint i,j;\n    *returnSize=codeSize;\n    int *returnNums=(int *)malloc(sizeof(int)*codeSize);\n    if(k>0){\n        for(i=0;i<codeSize;i++){\n            int temp=0;\n            for(j=1;j<=k;j++){\n                temp+=code[(i+j)%codeSize];\n            }\n            returnNums[i]=temp;\n        }\n    }else if(k<0){\n        for(i=0;i<codeSize;i++){\n            int temp=0;\n            for(j=-1;j>=k;j--){\n                temp+=code[(i+j+codeSize)%codeSize];\n            }\n            returnNums[i]=temp;\n        }\n    }else{\n        for(i=0;i<codeSize;i++){\n            returnNums[i]=0;\n        }\n    }\n    return returnNums;\n}", "prefix": "int* decrypt(int* code, int codeSize, int k, int* returnSize"}
{"id": "352", "path": "output2\\c\\Easy\\352-check-if-two-string-arrays-are-equivalent.c", "hypo_code": "bool arrayStringsAreEqual(char ** word1, int word1Size, char ** word2, int word2Size){\nint i = 0, j = 0, k = 0, l = 0;\n    while(i < word1Size && j < word2Size){\n        while(word1[i][k] != '\\0' && word2[j][l] != '\\0'){\n            if(word1[i][k] != word2[j][l]){\n                return false;\n            }\n            k++;\n            l++;\n        }\n        if(word1[i][k] == '\\0'){\n            k = 0;\n            i++;\n        }\n        if(word2[j][l] == '\\0'){\n            l = 0;\n            j++;\n        }\n    }\n    if(i < word1Size || j < word2Size){\n        return false;\n    }\n    return true;\n}", "prefix": "bool arrayStringsAreEqual(char ** word1, int word1Size, char ** word2, int word2Size"}
{"id": "354", "path": "output2\\c\\Easy\\354-maximum-repeating-substring.c", "hypo_code": "int maxRepeating(char * sequence, char * word){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    while(sequence[i] != '\\0'){\n        while(word[j] != '\\0' && sequence[i] == word[j]){\n            i++;\n            j++;\n        }\n        if(word[j] == '\\0'){\n            cnt++;\n        }\n        if(cnt > max){\n            max = cnt;\n        }\n        if(sequence[i] != word[j]){\n            j = 0;\n            cnt = 0;\n            i++;\n        }\n    }\n    return max;\n}", "prefix": "int maxRepeating(char * sequence, char * word"}
{"id": "355", "path": "output2\\c\\Easy\\355-richest-customer-wealth.c", "hypo_code": "int maximumWealth(int** accounts, int accountsSize, int* accountsColSize){\nint i = 0, j = 0, max = 0, sum = 0;\n    for(i = 0; i < accountsSize; i++){\n        for(j = 0; j < *accountsColSize; j++){\n            sum += accounts[i][j];\n        }\n        if(sum > max){\n            max = sum;\n        }\n        sum = 0;\n    }\n    return max;\n}", "prefix": "int maximumWealth(int** accounts, int accountsSize, int* accountsColSize"}
{"id": "356", "path": "output2\\c\\Easy\\356-goal-parser-interpretation.c", "hypo_code": "char * interpret(char * command){\nint i = 0, j = 0, k = 0, l = 0, cnt = 0;\n    while(command[i] != '\\0'){\n        if(command[i] == 'G'){\n            cnt++;\n        }\n        if(command[i] == '(' && command[i+1] == ')'){\n            cnt++;\n            i++;\n        }\n        if(command[i] == '(' && command[i+1] == 'a'){\n            cnt++;\n            i++;\n        }\n        i++;\n    }\n    char *p = (char *)malloc(sizeof(char) * (cnt + 1));\n    i = 0;\n    while(command[i] != '\\0'){\n        if(command[i] == 'G'){\n            p[j] = 'G';\n            j++;\n        }\n        if(command[i] == '(' && command[i+1] == ')'){\n            p[j] = 'o';\n            j++;\n            i++;\n        }\n        if(command[i] == '(' && command[i+1] == 'a'){\n            p[j] = 'a';\n            j++;\n            p[j] = 'l';\n            j++;\n            i++;\n        }\n        i++;\n    }\n    p[j] = '\\0';\n    return p;\n}", "prefix": "char * interpret(char * command"}
{"id": "358", "path": "output2\\c\\Easy\\358-count-the-number-of-consistent-strings.c", "hypo_code": "int countConsistentStrings(char * allowed, char ** words, int wordsSize){\nint i = 0, j = 0, k = 0, l = 0, cnt = 0, flag = 0;\n    while(words[i] != NULL){\n        while(words[i][j] != '\\0'){\n            while(allowed[k] != '\\0'){\n                if(words[i][j] == allowed[k]){\n                    flag = 1;\n                    break;\n                }\n                k++;\n            }\n            if(flag == 0){\n                break;\n            }\n            flag = 0;\n            k = 0;\n            j++;\n        }\n        if(words[i][j] == '\\0'){\n            cnt++;\n        }\n        j = 0;\n        i++;\n    }\n    return cnt;\n}", "prefix": "int countConsistentStrings(char * allowed, char ** words, int wordsSize"}
{"id": "359", "path": "output2\\c\\Easy\\359-count-of-matches-in-tournament.c", "hypo_code": "int numberOfMatches(int n){\nint i = 0, j = 0, k = 0, l = 0, cnt = 0;\n    while(n > 1){\n        if(n % 2 == 0){\n            cnt += n / 2;\n            n /= 2;\n        }\n        else{\n            cnt += (n - 1) / 2;\n            n = (n - 1) / 2 + 1;\n        }\n    }\n    return cnt;\n}", "prefix": "int numberOfMatches(int n"}
{"id": "361", "path": "output2\\c\\Easy\\361-reformat-phone-number.c", "hypo_code": "char * reformatNumber(char * number){\nint i = 0, j = 0, k = 0, l = 0, cnt = 0, flag = 0;\n    while(number[i] != '\\0'){\n        if(number[i] != ' ' && number[i] != '-'){\n            cnt++;\n        }\n        i++;\n    }\n    char *p = (char *)malloc(sizeof(char) * (cnt + cnt / 3 + 2));\n    i = 0;\n    while(number[i] != '\\0'){\n        if(number[i] != ' ' && number[i] != '-'){\n            p[j] = number[i];\n            j++;\n            if(j % 3 == 0 && j != 0 && j != cnt + cnt / 3 + 1){\n                p[j] = '-';\n                j++;\n            }\n        }\n        i++;\n    }\n    if(j == cnt + cnt / 3 + 1){\n        p[j] = '\\0';\n    }\n    else{\n        p[j - 1] = '\\0';\n    }\n    return p;\n}", "prefix": "char * reformatNumber(char * number"}
{"id": "362", "path": "output2\\c\\Easy\\362-number-of-students-unable-to-eat-lunch.c", "hypo_code": "int countStudents(int* students, int studentsSize, int* sandwiches, int sandwichesSize){\nint i = 0, j = 0, k = 0, l = 0, cnt = 0, flag = 0;\n    while(i < studentsSize){\n        while(j < sandwichesSize){\n            if(students[i] == sandwiches[j]){\n                students[i] = -1;\n                sandwiches[j] = -1;\n                i++;\n                j = 0;\n                break;\n            }\n            j++;\n        }\n        if(j == sandwichesSize){\n            break;\n        }\n    }\n    while(i < studentsSize){\n        if(students[i] == -1){\n            cnt++;\n        }\n        i++;\n    }\n    return cnt;\n}", "prefix": "int countStudents(int* students, int studentsSize, int* sandwiches, int sandwichesSize"}
{"id": "363", "path": "output2\\c\\Easy\\363-determine-if-string-halves-are-alike.c", "hypo_code": "bool halvesAreAlike(char * s){\nint i = 0, j = 0, k = 0, l = 0, cnt = 0;\n    while(s[i] != '\\0'){\n        if(s[i] == 'a' || s[i] == 'A' || \n           s[i] == 'e' || s[i] == 'E' ||\n           s[i] == 'i' || s[i] == 'I' ||\n           s[i] == 'o' || s[i] == 'O' ||\n           s[i] == 'u' || s[i] == 'U'){\n            cnt++;\n        }\n        i++;\n    }\n    i = 0;\n    while(s[i] != '\\0'){\n        if(s[i] == 'a' || s[i] == 'A' || \n           s[i] == 'e' || s[i] == 'E' ||\n           s[i] == 'i' || s[i] == 'I' ||\n           s[i] == 'o' || s[i] == 'O' ||\n           s[i] == 'u' || s[i] == 'U'){\n            cnt--;\n        }\n        if(cnt < 0){\n            return false;\n        }\n        i++;\n    }\n    return true;\n}", "prefix": "bool halvesAreAlike(char * s"}
{"id": "364", "path": "output2\\c\\Easy\\364-maximum-units-on-a-truck.c", "hypo_code": "int maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize){\nint i = 0, j = 0, k = 0, l = 0, sum = 0, max = 0, tmp = 0;\n    for(i = 0; i < boxTypesSize; i++){\n        for(j = i + 1; j < boxTypesSize; j++){\n            if(boxTypes[i][1] < boxTypes[j][1]){\n                tmp = boxTypes[i][1];\n                boxTypes[i][1] = boxTypes[j][1];\n                boxTypes[j][1] = tmp;\n                tmp = boxTypes[i][0];\n                boxTypes[i][0] = boxTypes[j][0];\n                boxTypes[j][0] = tmp;\n            }\n        }\n    }\n    for(i = 0; i < boxTypesSize; i++){\n        if(boxTypes[i][0] <= truckSize){\n            sum += boxTypes[i][0] * boxTypes[i][1];\n            truckSize -= boxTypes[i][0];\n        }\n        else{\n            sum += truckSize * boxTypes[i][1];\n            break;\n        }\n    }\n    return sum;\n}", "prefix": "int maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize"}
{"id": "365", "path": "output2\\c\\Easy\\365-calculate-money-in-leetcode-bank.c", "hypo_code": "int totalMoney(int n){\nint i = 0, j = 0, k = 0, l = 0, sum = 0, tmp = 0, cnt = 0;\n    for(i = 1; i <= n; i++){\n        if(i % 7 == 0){\n            tmp = i / 7 + cnt;\n            sum += tmp * 7 + 28;\n            cnt++;\n        }\n        else{\n            sum += tmp + 1;\n        }\n    }\n    return sum;\n}", "prefix": "int totalMoney(int n"}
{"id": "366", "path": "output2\\c\\Easy\\366-decode-xored-array.c", "hypo_code": "int* decode(int* encoded, int encodedSize, int first, int* returnSize){\nint i = 0, j = 0, k = 0, l = 0;\n    *returnSize = encodedSize + 1;\n    int *arr = (int*)malloc(sizeof(int) * (*returnSize));\n    arr[0] = first;\n    for(i = 0; i < encodedSize; i++){\n        arr[i + 1] = arr[i] ^ encoded[i];\n    }\n    return arr;\n}", "prefix": "int* decode(int* encoded, int encodedSize, int first, int* returnSize"}
{"id": "367", "path": "output2\\c\\Easy\\367-number-of-rectangles-that-can-form-the-largest-square.c", "hypo_code": "int countGoodRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 1;\n    for(i = 0; i < rectanglesSize; i++){\n        if(rectangles[i][0] < rectangles[i][1]){\n            rectangles[i][0] = rectangles[i][1];\n        }\n        if(rectangles[i][0] > max){\n            max = rectangles[i][0];\n        }\n    }\n    for(i = 0; i < rectanglesSize; i++){\n        if(rectangles[i][0] == max){\n            cnt++;\n        }\n    }\n    return cnt;\n}", "prefix": "int countGoodRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize"}
{"id": "370", "path": "output2\\c\\Easy\\370-find-the-highest-altitude.c", "hypo_code": "int largestAltitude(int* gain, int gainSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, sum = 0;\n    for(i = 0; i < gainSize; i++){\n        sum += gain[i];\n        if(sum > max){\n            max = sum;\n        }\n    }\n    return max;\n\n}", "prefix": "int largestAltitude(int* gain, int gainSize"}
{"id": "371", "path": "output2\\c\\Easy\\371-latest-time-by-replacing-hidden-digits.c", "hypo_code": "char * maximumTime(char * time){ \n  int i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    while(time[i] != '\\0'){\n        if(time[i] == '?'){\n            if(i == 0){\n                if(time[1] == '\\0' || time[1] == '?' || time[1] < '4'){\n                    time[i] = '2';\n                }\n                else{\n                    time[i] = '1';\n                }\n            }\n            if(i == 1){\n                if(time[0] == '2'){\n                    time[i] = '3';\n                }\n                else{\n                    time[i] = '9';\n                }\n            }\n            if(i == 3){\n                time[i] = '5';\n            }\n            if(i == 4){\n                time[i] = '9';\n            }\n        }\n        i++;\n    }\n    return time;\n}", "prefix": "char * maximumTime(char * time"}
{"id": "373", "path": "output2\\c\\Easy\\373-maximum-number-of-balls-in-a-box.c", "hypo_code": "int countBalls(int lowLimit, int highLimit){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(46, sizeof(int));\n    for(i = lowLimit; i <= highLimit; i++){\n        j = i;\n        cnt = 0;\n        while(j != 0){\n            cnt += j % 10;\n            j /= 10;\n        }\n        p[cnt]++;\n    }\n    for(i = 0; i < 46; i++){\n        if(p[i] > max){\n            max = p[i];\n        }\n    }\n    return max;\n}", "prefix": "int countBalls(int lowLimit, int highLimit"}
{"id": "374", "path": "output2\\c\\Easy\\374-sum-of-unique-elements.c", "hypo_code": "int sumOfUnique(int* nums, int numsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "int sumOfUnique(int* nums, int numsSize"}
{"id": "375", "path": "output2\\c\\Easy\\375-check-if-array-is-sorted-and-rotated.c", "hypo_code": "bool check(int* nums, int numsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 0; i < numsSize; i++){\n        if(nums[i] > nums[(i + 1) % numsSize]){\n            cnt++;\n        }\n    }\n    return (cnt < 2);\n}", "prefix": "bool check(int* nums, int numsSize"}
{"id": "377", "path": "output2\\c\\Easy\\377-minimum-changes-to-make-alternating-binary-string.c", "hypo_code": "int minOperations(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(s);\n    for(i = 0; i < len; i++){\n        if(i % 2 == 0){\n            if(s[i] == '0'){\n                cnt++;\n            }\n        }\n        else{\n            if(s[i] == '1'){\n                cnt++;\n            }\n        }\n    }\n    max = cnt;\n    cnt = 0;\n    for(i = 0; i < len; i++){\n        if(i % 2 == 0){\n            if(s[i] == '1'){\n                cnt++;\n            }\n        }\n        else{\n            if(s[i] == '0'){\n                cnt++;\n            }\n        }\n    }\n    if(cnt < max){\n        max = cnt;\n    }\n    return max;\n\n\n}", "prefix": "int minOperations(char * s"}
{"id": "378", "path": "output2\\c\\Easy\\378-longest-nice-substring.c", "hypo_code": "char * longestNiceSubstring(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "char * longestNiceSubstring(char * s"}
{"id": "379", "path": "output2\\c\\Easy\\379-merge-strings-alternately.c", "hypo_code": "char * mergeAlternately(char * word1, char * word2){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    char *p = (char *)calloc(201, sizeof(char));\n    while(word1[i] != '\\0' && word2[i] != '\\0'){\n        p[j++] = word1[i];\n        p[j++] = word2[i];\n        i++;\n    }\n    while(word1[i] != '\\0'){\n        p[j++] = word1[i];\n        i++;\n    }\n    while(word2[i] != '\\0'){\n        p[j++] = word2[i];\n        i++;\n    }\n    return p;\n}", "prefix": "char * mergeAlternately(char * word1, char * word2"}
{"id": "380", "path": "output2\\c\\Easy\\380-count-items-matching-a-rule.c", "hypo_code": "int countMatches(char *** items, int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 0; i < itemsSize; i++){\n        if(strcmp(ruleKey, \"type\") == 0){\n            if(strcmp(items[i][0], ruleValue) == 0){\n                cnt++;\n            }\n        }\n        else if(strcmp(ruleKey, \"color\") == 0){\n            if(strcmp(items[i][1], ruleValue) == 0){\n                cnt++;\n            }\n        }\n        else{\n            if(strcmp(items[i][2], ruleValue) == 0){\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}", "prefix": "int countMatches(char *** items, int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue"}
{"id": "381", "path": "output2\\c\\Easy\\381-find-nearest-point-that-has-the-same-x-or-y-coordinate.c", "hypo_code": "int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){\nint i = 0, j = 0, k = 0, l = 0, min = 10001, cnt = 0, minIndex = -1;\n    for(i = 0; i < pointsSize; i++){\n        if((x == points[i][0]) || (y == points[i][1])){\n            cnt = abs(x - points[i][0]) + abs(y - points[i][1]);\n            if(cnt < min){\n                min = cnt;\n                minIndex = i;\n            }\n        }\n    }\n    return minIndex;\n}", "prefix": "int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize"}
{"id": "382", "path": "output2\\c\\Easy\\382-check-if-binary-string-has-at-most-one-segment-of-ones.c", "hypo_code": "bool checkOnesSegment(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(s);\n    for(i = 0; i < len; i++){\n        if(s[i] == '1'){\n            if(i != 0 && s[i - 1] == '0'){\n                cnt++;\n            }\n        }\n    }\n    return (cnt < 2);\n}", "prefix": "bool checkOnesSegment(char * s"}
{"id": "384", "path": "output2\\c\\Easy\\384-check-if-one-string-swap-can-make-strings-equal.c", "hypo_code": "bool areAlmostEqual(char * s1, char * s2){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(s1), pos1 = -1, pos2 = -1;\n    if(strcmp(s1, s2) == 0){\n        return true;\n    }\n    for(i = 0; i < len; i++){\n        if(s1[i] != s2[i]){\n            if(pos1 == -1){\n                pos1 = i;\n            }\n            else if(pos2 == -1){\n                pos2 = i;\n            }\n            else{\n                return false;\n            }\n        }\n    }\n    if(pos2 == -1){\n        return false;\n    }\n    if(s1[pos1] == s2[pos2] && s1[pos2] == s2[pos1]){\n        return true;\n    }\n    return false;\n}", "prefix": "bool areAlmostEqual(char * s1, char * s2"}
{"id": "385", "path": "output2\\c\\Easy\\385-find-center-of-star-graph.c", "hypo_code": "int findCenter(int** edges, int edgesSize, int* edgesColSize){\n    int i = 0;\n    int j = 0;\n    int result = 0;\n    int count = 0;\n    for(i = 0; i < edgesSize; i++){\n        for(j = 0; j < edgesColSize[i]; j++){\n            if(edges[i][j] == edges[i][j + 1]){\n                result = edges[i][j];\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int findCenter(int** edges, int edgesSize, int* edgesColSize"}
{"id": "387", "path": "output2\\c\\Easy\\387-second-largest-digit-in-a-string.c", "hypo_code": "int secondHighest(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "int secondHighest(char * s"}
{"id": "388", "path": "output2\\c\\Easy\\388-maximum-ascending-subarray-sum.c", "hypo_code": "int maxAscendingSum(int* nums, int numsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 0; i < numsSize; i++){\n        cnt = nums[i];\n        j = i + 1;\n        while(j < numsSize && nums[j] > nums[j - 1]){\n            cnt += nums[j];\n            j++;\n        }\n        if(cnt > max){\n            max = cnt;\n        }\n    }\n    return max;\n}", "prefix": "int maxAscendingSum(int* nums, int numsSize"}
{"id": "389", "path": "output2\\c\\Easy\\389-number-of-different-integers-in-a-string.c", "hypo_code": "int numDifferentIntegers(char * word){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "int numDifferentIntegers(char * word"}
{"id": "390", "path": "output2\\c\\Easy\\390-determine-color-of-a-chessboard-square.c", "hypo_code": "bool squareIsWhite(char * coordinates){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(coordinates);\n    return (((coordinates[0] - 'a') + (coordinates[1] - '0')) % 2 == 0);\n\n}", "prefix": "bool squareIsWhite(char * coordinates"}
{"id": "391", "path": "output2\\c\\Easy\\391-truncate-sentence.c", "hypo_code": "char * truncateSentence(char * s, int k){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "char * truncateSentence(char * s, int k"}
{"id": "392", "path": "output2\\c\\Easy\\392-sign-of-the-product-of-an-array.c", "hypo_code": "int arraySign(int* nums, int numsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 0; i < numsSize; i++){\n        if(nums[i] == 0){\n            return 0;\n        }\n        if(nums[i] < 0){\n            cnt++;\n        }\n    }\n    return (cnt % 2 == 0 ? 1 : -1);\n}", "prefix": "int arraySign(int* nums, int numsSize"}
{"id": "393", "path": "output2\\c\\Easy\\393-minimum-operations-to-make-the-array-increasing.c", "hypo_code": "int minOperations(int* nums, int numsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 1; i < numsSize; i++){\n        if(nums[i] <= nums[i - 1]){\n            cnt += (nums[i - 1] - nums[i] + 1);\n            nums[i] = nums[i - 1] + 1;\n        }\n    }\n    return cnt;\n}", "prefix": "int minOperations(int* nums, int numsSize"}
{"id": "394", "path": "output2\\c\\Easy\\394-check-if-the-sentence-is-pangram.c", "hypo_code": "bool checkIfPangram(char * sentence){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(sentence);\n    int *p = (int *)calloc(26, sizeof(int));\n    for(i = 0; i < len; i++){\n        p[sentence[i] - 'a']++;\n    }\n    for(i = 0; i < 26; i++){\n        if(p[i] == 0){\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool checkIfPangram(char * sentence"}
{"id": "395", "path": "output2\\c\\Easy\\395-sum-of-digits-in-base-k.c", "hypo_code": "int sumBase(int n, int k){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    while(n != 0){\n        cnt += n % k;\n        n /= k;\n    }\n    return cnt;\n}", "prefix": "int sumBase(int n, int k"}
{"id": "396", "path": "output2\\c\\Easy\\396-replace-all-digits-with-characters.c", "hypo_code": "char * replaceDigits(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(s);\n    for(i = 1; i < len; i += 2){\n        s[i] = s[i-1] + (s[i] - '0');\n    }\n    return s;\n}", "prefix": "char * replaceDigits(char * s"}
{"id": "397", "path": "output2\\c\\Easy\\397-minimum-distance-to-the-target-element.c", "hypo_code": "int getMinDistance(int* nums, int numsSize, int target, int start){\nint i = 0, j = 0, k = 0, l = 0, min = 10001, cnt = 0;\n    for(i = 0; i < numsSize; i++){\n        if(nums[i] == target){\n            cnt = abs(i - start);\n            if(cnt < min){\n                min = cnt;\n            }\n        }\n    }\n    return min;\n}", "prefix": "int getMinDistance(int* nums, int numsSize, int target, int start"}
{"id": "398", "path": "output2\\c\\Easy\\398-maximum-population-year.c", "hypo_code": "int maximumPopulation(int** logs, int logsSize, int* logsColSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < logsSize; i++){\n        for(j = logs[i][0]; j < logs[i][1]; j++){\n            p[j - 1950]++;\n        }\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] > max){\n            max = p[i];\n            cnt = i;\n        }\n    }\n    return cnt + 1950;\n}", "prefix": "int maximumPopulation(int** logs, int logsSize, int* logsColSize"}
{"id": "399", "path": "output2\\c\\Easy\\399-sorting-the-sentence.c", "hypo_code": "char * sortSentence(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    char *p = (char *)calloc(101, sizeof(char));\n    char *q = (char *)calloc(101, sizeof(char));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "char * sortSentence(char * s"}
{"id": "400", "path": "output2\\c\\Easy\\400-sum-of-all-subset-xor-totals.c", "hypo_code": "int subsetXORSum(int* nums, int numsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 0; i < numsSize; i++){\n        cnt = nums[i];\n        j = i + 1;\n        while(j < numsSize && nums[j] > nums[j - 1]){\n            cnt += nums[j];\n            j++;\n        }\n        if(cnt > max){\n            max = cnt;\n        }\n    }\n    return max;\n}", "prefix": "int subsetXORSum(int* nums, int numsSize"}
{"id": "401", "path": "output2\\c\\Easy\\401-longer-contiguous-segments-of-ones-than-zeros.c", "hypo_code": "bool checkZeroOnes(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(s);\n    for(i = 0; i < len; i++){\n        if(s[i] == '1'){\n            if(i != 0 && s[i - 1] == '0'){\n                cnt++;\n            }\n        }\n    }\n    return (cnt < 2);\n}", "prefix": "bool checkZeroOnes(char * s"}
{"id": "403", "path": "output2\\c\\Easy\\403-substrings-of-size-three-with-distinct-characters.c", "hypo_code": "int countGoodSubstrings(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "int countGoodSubstrings(char * s"}
{"id": "404", "path": "output2\\c\\Easy\\404-check-if-word-equals-summation-of-two-words.c", "hypo_code": "bool isSumEqual(char * firstWord, char * secondWord, char * targetWord){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len1 = strlen(firstWord), len2 = strlen(secondWord), len3 = strlen(targetWord), sum1 = 0, sum2 = 0, sum3 = 0;\n    for(i = 0; i < len1; i++){\n        sum1 = sum1 * 10 + (firstWord[i] - 'a');\n    }\n    for(i = 0; i < len2; i++){\n        sum2 = sum2 * 10 + (secondWord[i] - 'a');\n    }\n    for(i = 0; i < len3; i++){\n        sum3 = sum3 * 10 + (targetWord[i] - 'a');\n    }\n    if(sum1 + sum2 == sum3){\n        return true;\n    }\n    return false;\n}", "prefix": "bool isSumEqual(char * firstWord, char * secondWord, char * targetWord"}
{"id": "405", "path": "output2\\c\\Easy\\405-determine-whether-matrix-can-be-obtained-by-rotation.c", "hypo_code": "bool findRotation(int** mat, int matSize, int* matColSize, int** target, int targetSize, int* targetColSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int **p = (int **)calloc(matSize, sizeof(int *));\n    for(i = 0; i < matSize; i++){\n        p[i] = (int *)calloc(*matColSize, sizeof(int));\n    }\n    for(i = 0; i < matSize; i++){\n        for(j = 0; j < *matColSize; j++){\n            p[i][j] = mat[i][j];\n        }\n    }\n    for(i = 0; i < 4; i++){\n        for(j = 0; j < matSize; j++){\n            for(k = 0; k < *matColSize; k++){\n                if(p[j][k] != target[j][k]){\n                    break;\n                }\n            }\n            if(k != *matColSize){\n                break;\n            }\n        }\n        if(j == matSize){\n            return true;\n        }\n        for(j = 0; j < matSize; j++){\n            for(k = 0; k < *matColSize; k++){\n                p[j][k] = mat[matSize - k - 1][j];\n            }\n        }\n    }\n    return false;\n}", "prefix": "bool findRotation(int** mat, int matSize, int* matColSize, int** target, int targetSize, int* targetColSize"}
{"id": "407", "path": "output2\\c\\Easy\\407-check-if-all-the-integers-in-a-range-are-covered.c", "hypo_code": "bool isCovered(int** ranges, int rangesSize, int* rangesColSize, int left, int right){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(51, sizeof(int));\n    for(i = 0; i < rangesSize; i++){\n        for(j = ranges[i][0]; j <= ranges[i][1]; j++){\n            p[j]++;\n        }\n    }\n    for(i = left; i <= right; i++){\n        if(p[i] == 0){\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool isCovered(int** ranges, int rangesSize, int* rangesColSize, int left, int right"}
{"id": "408", "path": "output2\\c\\Easy\\408-redistribute-characters-to-make-all-strings-equal.c", "hypo_code": "bool makeEqual(char ** words, int wordsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = 0;\n    int *p = (int *)calloc(26, sizeof(int));\n    for(i = 0; i < wordsSize; i++){\n        len = strlen(words[i]);\n        for(j = 0; j < len; j++){\n            p[words[i][j] - 'a']++;\n        }\n    }\n    for(i = 0; i < 26; i++){\n        if(p[i] % wordsSize != 0){\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool makeEqual(char ** words, int wordsSize"}
{"id": "409", "path": "output2\\c\\Easy\\409-largest-odd-number-in-string.c", "hypo_code": "char * largestOddNumber(char * num){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "char * largestOddNumber(char * num"}
{"id": "410", "path": "output2\\c\\Easy\\410-remove-one-element-to-make-the-array-strictly-increasing.c", "hypo_code": "bool canBeIncreasing(int* nums, int numsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 1; i < numsSize; i++){\n        if(nums[i] <= nums[i - 1]){\n            cnt++;\n            if(i > 1 && nums[i] <= nums[i - 2]){\n                nums[i] = nums[i - 1];\n            }\n        }\n    }\n    return (cnt < 2);\n}", "prefix": "bool canBeIncreasing(int* nums, int numsSize"}
{"id": "411", "path": "output2\\c\\Easy\\411-maximum-product-difference-between-two-pairs.c", "hypo_code": "int maxProductDifference(int* nums, int numsSize){\nqsort(nums, numsSize, sizeof(int), cmp);\n    return (nums[numsSize - 1] * nums[numsSize - 2] - nums[0] * nums[1]);\n\n}", "prefix": "int maxProductDifference(int* nums, int numsSize"}
{"id": "412", "path": "output2\\c\\Easy\\412-build-array-from-permutation.c", "hypo_code": "int* buildArray(int* nums, int numsSize, int* returnSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    *returnSize = numsSize;\n    int *p = (int *)malloc(sizeof(int) * numsSize);\n    for(i = 0; i < numsSize; i++){\n        p[i] = nums[nums[i]];\n    }\n    return p;\n}", "prefix": "int* buildArray(int* nums, int numsSize, int* returnSize"}
{"id": "413", "path": "output2\\c\\Easy\\413-count-square-sum-triples.c", "hypo_code": "int countTriples(int n){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 1; i <= n; i++){\n        for(j = 1; j <= n; j++){\n            for(k = 1; k <= n; k++){\n                if(i*i + j*j == k*k){\n                    cnt++;\n                }\n            }\n        }\n    }\n    return cnt;\n}", "prefix": "int countTriples(int n"}
{"id": "414", "path": "output2\\c\\Easy\\414-concatenation-of-array.c", "hypo_code": "int* getConcatenation(int* nums, int numsSize, int* returnSize){\nint *p = (int *)calloc(numsSize * 2, sizeof(int));\n    *returnSize = numsSize * 2;\n    for(int i = 0; i < numsSize; i++){\n        p[i] = nums[i];\n        p[i + numsSize] = nums[i];\n    }\n    return p;\n}", "prefix": "int* getConcatenation(int* nums, int numsSize, int* returnSize"}
{"id": "415", "path": "output2\\c\\Easy\\415-maximum-number-of-words-you-can-type.c", "hypo_code": "int canBeTypedWords(char * text, char * brokenLetters){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "int canBeTypedWords(char * text, char * brokenLetters"}
{"id": "416", "path": "output2\\c\\Easy\\416-check-if-all-characters-have-equal-number-of-occurrences.c", "hypo_code": "bool areOccurrencesEqual(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(s);\n    int *p = (int *)calloc(26, sizeof(int));\n    for(i = 0; i < len; i++){\n        p[s[i] - 'a']++;\n    }\n    for(i = 0; i < 26; i++){\n        if(p[i] > 0){\n            if(max == 0){\n                max = p[i];\n            }\n            else if(max != p[i]){\n                return false;\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool areOccurrencesEqual(char * s"}
{"id": "417", "path": "output2\\c\\Easy\\417-sum-of-digits-of-string-after-convert.c", "hypo_code": "int getLucky(char * s, int k){\nint *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "int getLucky(char * s, int k"}
{"id": "418", "path": "output2\\c\\Easy\\418-three-divisors.c", "hypo_code": "bool isThree(int n){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    if(n == 1){\n        return false;\n    }\n    for(i = 2; i < n; i++){\n        if(n % i == 0){\n            cnt++;\n        }\n    }\n    return (cnt == 1);\n}", "prefix": "bool isThree(int n"}
{"id": "419", "path": "output2\\c\\Easy\\419-delete-characters-to-make-fancy-string.c", "hypo_code": "char * makeFancyString(char * s){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(s);\n    char *p = (char *)calloc(len + 1, sizeof(char));\n    for(i = 0; i < len; i++){\n        if(i < 2){\n            p[j++] = s[i];\n        }\n        else{\n            if(s[i] != s[i - 1] || s[i] != s[i - 2]){\n                p[j++] = s[i];\n            }\n        }\n    }\n    return p;\n}", "prefix": "char * makeFancyString(char * s"}
{"id": "420", "path": "output2\\c\\Easy\\420-check-if-string-is-a-prefix-of-array.c", "hypo_code": "bool isPrefixString(char * s, char ** words, int wordsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = strlen(s), len2 = 0;\n    for(i = 0; i < wordsSize; i++){\n        len2 += strlen(words[i]);\n        if(len2 == len){\n            if(strcmp(s, words[i]) == 0){\n                return true;\n            }\n            return false;\n        }\n        else if(len2 > len){\n            return false;\n        }\n        else{\n            if(strncmp(s, words[i], strlen(words[i])) == 0){\n                s += strlen(words[i]);\n            }\n            else{\n                return false;\n            }\n        }\n    }\n    return false;\n\n}", "prefix": "bool isPrefixString(char * s, char ** words, int wordsSize"}
{"id": "422", "path": "output2\\c\\Easy\\422-number-of-strings-that-appear-as-substrings-in-word.c", "hypo_code": "int numOfStrings(char ** patterns, int patternsSize, char * word){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0, len = 0;\n    for(i = 0; i < patternsSize; i++){\n        if(strstr(word, patterns[i]) != NULL){\n            cnt++;\n        }\n    }\n    return cnt;\n}", "prefix": "int numOfStrings(char ** patterns, int patternsSize, char * word"}
{"id": "423", "path": "output2\\c\\Easy\\423-find-if-path-exists-in-graph.c", "hypo_code": "bool validPath(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(n, sizeof(int));\n    for(i = 0; i < edgesSize; i++){\n        p[edges[i][0]]++;\n        p[edges[i][1]]++;\n    }\n    return (p[source] && p[destination]);\n}", "prefix": "bool validPath(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination"}
{"id": "424", "path": "output2\\c\\Easy\\424-minimum-time-to-type-word-using-special-typewriter.c", "hypo_code": "int minTimeToType(char * word){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int len = strlen(word);\n    char *p = (char *)calloc(len + 1, sizeof(char));\n    strcpy(p, word);\n    for(i = 0; i < len; i++){\n        if(p[i] == 'z'){\n            p[i] = 'a';\n        }\n    }\n    for(i = 0; i < len; i++){\n        if(i == 0){\n            if(p[i] <= 'm'){\n                cnt += p[i] - 'a';\n            }else{\n                cnt += 'z' - p[i] + 1;\n            }\n        }else{\n            if(p[i] >= p[i - 1]){\n                cnt += p[i] - p[i - 1];\n            }else{\n                cnt += 'z' - p[i - 1] + 1 + p[i] - 'a';\n            }\n        }\n    }\n    return cnt + len;\n}", "prefix": "int minTimeToType(char * word"}
{"id": "426", "path": "output2\\c\\Easy\\426-find-greatest-common-divisor-of-array.c", "hypo_code": "int findGCD(int* nums, int numsSize){\nqsort(nums, numsSize, sizeof(int), cmp);\n    for(i = nums[0]; i > 0; i--){\n        if(nums[0] % i == 0 && nums[numsSize - 1] % i == 0){\n            return i;\n        }\n    }\n    return 0;\n}", "prefix": "int findGCD(int* nums, int numsSize"}
{"id": "427", "path": "output2\\c\\Easy\\427-minimum-difference-between-highest-and-lowest-of-k-scores.c", "hypo_code": "int minimumDifference(int* nums, int numsSize, int k){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "int minimumDifference(int* nums, int numsSize, int k"}
{"id": "428", "path": "output2\\c\\Easy\\428-find-the-middle-index-in-array.c", "hypo_code": "int findMiddleIndex(int* nums, int numsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(numsSize + 1, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[i + 1] = p[i] + nums[i];\n    }\n    for(i = 0; i < numsSize; i++){\n        if(p[i] == p[numsSize] - p[i + 1]){\n            return i;\n        }\n    }\n    return -1;\n}", "prefix": "int findMiddleIndex(int* nums, int numsSize"}
{"id": "429", "path": "output2\\c\\Easy\\429-count-special-quadruplets.c", "hypo_code": "int countQuadruplets(int* nums, int numsSize){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 0; i < numsSize; i++){\n        for(j = i + 1; j < numsSize; j++){\n            for(k = j + 1; k < numsSize; k++){\n                for(l = k + 1; l < numsSize; l++){\n                    if(nums[i] + nums[j] + nums[k] == nums[l]){\n                        cnt++;\n                    }\n                }\n            }\n        }\n    }\n    return cnt;\n}", "prefix": "int countQuadruplets(int* nums, int numsSize"}
{"id": "430", "path": "output2\\c\\Easy\\430-reverse-prefix-of-word.c", "hypo_code": "char * reversePrefix(char * word, char ch){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    int *p = (int *)calloc(101, sizeof(int));\n    for(i = 0; i < numsSize; i++){\n        p[nums[i]]++;\n    }\n    for(i = 0; i < 101; i++){\n        if(p[i] == 1){\n            cnt += i;\n        }\n    }\n    return cnt;\n}", "prefix": "char * reversePrefix(char * word, char ch"}
{"id": "431", "path": "output2\\c\\Easy\\431-count-number-of-pairs-with-absolute-difference-k.c", "hypo_code": "int countKDifference(int* nums, int numsSize, int k){\nint i = 0, j = 0, k = 0, l = 0, max = 0, cnt = 0;\n    for(i = 0; i < numsSize; i++){\n        for(j = i + 1; j < numsSize; j++){\n            if(abs(nums[i] - nums[j]) == k){\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}", "prefix": "int countKDifference(int* nums, int numsSize, int k"}
{"id": "432", "path": "output2\\c\\Easy\\432-final-value-of-variable-after-performing-operations.c", "hypo_code": "int finalValueAfterOperations(char ** operations, int operationsSize){\nint result = 0;\n\tfor (int i = 0; i < operationsSize; i++) {\n\t\tif (operations[i][1] == '+') {\n\t\t\tresult++;\n\t\t} else {\n\t\t\tresult--;\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int finalValueAfterOperations(char ** operations, int operationsSize"}
{"id": "433", "path": "output2\\c\\Easy\\433-maximum-difference-between-increasing-elements.c", "hypo_code": "int maximumDifference(int* nums, int numsSize){\nint maxDiff = -1;\n\tint min = nums[0];\n\tfor (int i = 1; i < numsSize; i++) {\n\t\tif (nums[i] > min) {\n\t\t\tmaxDiff = nums[i] - min > maxDiff ? nums[i] - min : maxDiff;\n\t\t} else {\n\t\t\tmin = nums[i];\n\t\t}\n\t}\n\treturn maxDiff;\n}", "prefix": "int maximumDifference(int* nums, int numsSize"}
{"id": "434", "path": "output2\\c\\Easy\\434-convert-1d-array-into-2d-array.c", "hypo_code": "int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes){\nif (originalSize != m * n)\n    {\n        *returnSize = 0;\n        return NULL;\n    }\n    int** result = (int**)malloc(sizeof(int*) * m);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * m);\n    for (int i = 0; i < m; i++)\n    {\n        result[i] = (int*)malloc(sizeof(int) * n);\n        (*returnColumnSizes)[i] = n;\n    }\n    for (int i = 0; i < originalSize; i++)\n    {\n        result[i / n][i % n] = original[i];\n    }\n    *returnSize = m;\n    return result;\n}", "prefix": "int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes"}
{"id": "435", "path": "output2\\c\\Easy\\435-minimum-moves-to-convert-string.c", "hypo_code": "int minimumMoves(char * s){\nint count = 0;\n    for (int i = 0; i < strlen(s); i++)\n    {\n        if (s[i] == 'X')\n        {\n            count++;\n            i += 2;\n        }\n    }\n    return count;\n}", "prefix": "int minimumMoves(char * s"}
{"id": "436", "path": "output2\\c\\Easy\\436-two-out-of-three.c", "hypo_code": "int* twoOutOfThree(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* returnSize){\nint* hash = (int*)calloc(101, sizeof(int));\n    for (int i = 0; i < nums1Size; i++)\n    {\n        hash[nums1[i]] |= 1;\n    }\n    for (int i = 0; i < nums2Size; i++)\n    {\n        hash[nums2[i]] |= 2;\n    }\n    for (int i = 0; i < nums3Size; i++)\n    {\n        hash[nums3[i]] |= 4;\n    }\n    int* result = (int*)malloc(sizeof(int) * 101);\n    *returnSize = 0;\n    for (int i = 0; i <= 100; i++)\n    {\n        if (hash[i] == 1 || hash[i] == 2 || hash[i] == 4 || hash[i] == 3 || hash[i] == 5 || hash[i] == 6)\n        {\n            result[(*returnSize)++] = i;\n        }\n    }\n    return result;\n}", "prefix": "int* twoOutOfThree(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* returnSize"}
{"id": "437", "path": "output2\\c\\Easy\\437-minimum-number-of-moves-to-seat-everyone.c", "hypo_code": "int minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize){\nint result = 0;\n    for (int i = 0; i < seatsSize; i++)\n    {\n        for (int j = i; j < seatsSize; j++)\n        {\n            if (seats[i] > seats[j])\n            {\n                int temp = seats[i];\n                seats[i] = seats[j];\n                seats[j] = temp;\n            }\n        }\n    }\n    for (int i = 0; i < studentsSize; i++)\n    {\n        for (int j = i; j < studentsSize; j++)\n        {\n            if (students[i] > students[j])\n            {\n                int temp = students[i];\n                students[i] = students[j];\n                students[j] = temp;\n            }\n        }\n    }\n    for (int i = 0; i < seatsSize; i++)\n    {\n        result += abs(seats[i] - students[i]);\n    }\n    return result;\n}", "prefix": "int minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize"}
{"id": "438", "path": "output2\\c\\Easy\\438-check-if-numbers-are-ascending-in-a-sentence.c", "hypo_code": "bool areNumbersAscending(char * s){\nint current = -1;\n    char* token = strtok(s, \" \");\n    while (token != NULL)\n    {\n        if (isdigit(token[0]))\n        {\n            if (atoi(token) <= current)\n            {\n                return false;\n            }\n            else\n            {\n                current = atoi(token);\n            }\n        }\n        token = strtok(NULL, \" \");\n    }\n    return true;\n}", "prefix": "bool areNumbersAscending(char * s"}
{"id": "439", "path": "output2\\c\\Easy\\439-number-of-valid-words-in-a-sentence.c", "hypo_code": "int countValidWords(char * sentence){\nint count = 0;\n    char* token = strtok(sentence, \" \");\n    while (token != NULL)\n    {\n        bool isValid = true;\n        for (int i = 0; i < strlen(token); i++)\n        {\n            if (isupper(token[i]) || isdigit(token[i]))\n            {\n                isValid = false;\n                break;\n            }\n        }\n        if (isValid)\n        {\n            count++;\n        }\n        token = strtok(NULL, \" \");\n    }\n    return count;\n}", "prefix": "int countValidWords(char * sentence"}
{"id": "440", "path": "output2\\c\\Easy\\440-kth-distinct-string-in-an-array.c", "hypo_code": "char * kthDistinct(char ** arr, int arrSize, int k){\nint* hash = (int*)calloc(26, sizeof(int));\n    int* distinct = (int*)calloc(arrSize, sizeof(int));\n    int distinctSize = 0;\n    for (int i = 0; i < arrSize; i++)\n    {\n        if (hash[arr[i][0] - 'a'] == 0)\n        {\n            distinct[distinctSize++] = arr[i][0] - 'a';\n        }\n        hash[arr[i][0] - 'a']++;\n    }\n    if (k > distinctSize)\n    {\n        return \"\";\n    }\n    return arr[distinct[k - 1]];\n}", "prefix": "char * kthDistinct(char ** arr, int arrSize, int k"}
{"id": "441", "path": "output2\\c\\Easy\\441-smallest-index-with-equal-value.c", "hypo_code": "int smallestEqual(int* nums, int numsSize){\nfor (int i = 0; i < numsSize; i++)\n    {\n        if (i % 10 == nums[i])\n        {\n            return i;\n        }\n    }\n    return -1;\n}", "prefix": "int smallestEqual(int* nums, int numsSize"}
{"id": "442", "path": "output2\\c\\Easy\\442-count-vowel-substrings-of-a-string.c", "hypo_code": "int countVowelSubstrings(char * word){\nint count = 0;\n    for (int i = 0; i < strlen(word); i++)\n    {\n        if (word[i] == 'a')\n        {\n            count++;\n        }\n        else if (word[i] == 'e')\n        {\n            count++;\n        }\n        else if (word[i] == 'i')\n        {\n            count++;\n        }\n        else if (word[i] == 'o')\n        {\n            count++;\n        }\n        else if (word[i] == 'u')\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int countVowelSubstrings(char * word"}
{"id": "443", "path": "output2\\c\\Easy\\443-check-whether-two-strings-are-almost-equivalent.c", "hypo_code": "bool checkAlmostEquivalent(char * word1, char * word2){\nint* hash1 = (int*)calloc(26, sizeof(int));\n    int* hash2 = (int*)calloc(26, sizeof(int));\n    for (int i = 0; i < strlen(word1); i++)\n    {\n        hash1[word1[i] - 'a']++;\n    }\n    for (int i = 0; i < strlen(word2); i++)\n    {\n        hash2[word2[i] - 'a']++;\n    }\n    int count = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        if (abs(hash1[i] - hash2[i]) > 3)\n        {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool checkAlmostEquivalent(char * word1, char * word2"}
{"id": "444", "path": "output2\\c\\Easy\\444-time-needed-to-buy-tickets.c", "hypo_code": "int timeRequiredToBuy(int* tickets, int ticketsSize, int k){\nint result = 0;\n    for (int i = 0; i < ticketsSize; i++)\n    {\n        for (int j = i; j < ticketsSize; j++)\n        {\n            if (tickets[i] > tickets[j])\n            {\n                int temp = tickets[i];\n                tickets[i] = tickets[j];\n                tickets[j] = temp;\n            }\n        }\n    }\n    for (int i = 0; i <= k; i++)\n    {\n        result += tickets[i];\n    }\n    return result;\n}", "prefix": "int timeRequiredToBuy(int* tickets, int ticketsSize, int k"}
{"id": "445", "path": "output2\\c\\Easy\\445-two-furthest-houses-with-different-colors.c", "hypo_code": "int maxDistance(int* colors, int colorsSize){\nint result = 0;\n    for (int i = 0; i < colorsSize; i++)\n    {\n        for (int j = i; j < colorsSize; j++)\n        {\n            if (colors[i] > colors[j])\n            {\n                int temp = colors[i];\n                colors[i] = colors[j];\n                colors[j] = temp;\n            }\n        }\n    }\n    for (int i = 0; i < colorsSize; i++)\n    {\n        for (int j = colorsSize - 1; j >= i; j--)\n        {\n            if (colors[i] != colors[j])\n            {\n                int temp = j - i;\n                if (temp > result)\n                {\n                    result = temp;\n                }\n                break;\n            }\n        }\n    }\n    return result;\n}", "prefix": "int maxDistance(int* colors, int colorsSize"}
{"id": "447", "path": "output2\\c\\Easy\\447-count-common-words-with-one-occurrence.c", "hypo_code": "int countWords(char ** words1, int words1Size, char ** words2, int words2Size){\nint* hash1 = (int*)calloc(1000, sizeof(int));\n    int* hash2 = (int*)calloc(1000, sizeof(int));\n    int count = 0;\n    for (int i = 0; i < words1Size; i++)\n    {\n        hash1[words1[i][0] - 'a']++;\n    }\n    for (int i = 0; i < words2Size; i++)\n    {\n        hash2[words2[i][0] - 'a']++;\n    }\n    for (int i = 0; i < 1000; i++)\n    {\n        if (hash1[i] == 1 && hash2[i] == 1)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int countWords(char ** words1, int words1Size, char ** words2, int words2Size"}
{"id": "448", "path": "output2\\c\\Easy\\448-find-target-indices-after-sorting-array.c", "hypo_code": "int* targetIndices(int* nums, int numsSize, int target, int* returnSize){\nint* result = (int*)malloc(sizeof(int) * numsSize);\n    *returnSize = 0;\n    for (int i = 0; i < numsSize; i++)\n    {\n        if (nums[i] == target)\n        {\n            result[(*returnSize)++] = i;\n        }\n    }\n    return result;\n}", "prefix": "int* targetIndices(int* nums, int numsSize, int target, int* returnSize"}
{"id": "449", "path": "output2\\c\\Easy\\449-finding-3-digit-even-numbers.c", "hypo_code": "int* findEvenNumbers(int* digits, int digitsSize, int* returnSize){\nint* result = (int*)malloc(sizeof(int) * 100);\n    *returnSize = 0;\n    for (int i = 0; i < digitsSize; i++)\n    {\n        for (int j = 0; j < digitsSize; j++)\n        {\n            for (int k = 0; k < digitsSize; k++)\n            {\n                if (i == j || j == k || i == k)\n                {\n                    continue;\n                }\n                int number = digits[i] * 100 + digits[j] * 10 + digits[k];\n                if (number % 2 == 0)\n                {\n                    result[(*returnSize)++] = number;\n                }\n            }\n        }\n    }\n    return result;\n}", "prefix": "int* findEvenNumbers(int* digits, int digitsSize, int* returnSize"}
{"id": "450", "path": "output2\\c\\Easy\\450-find-subsequence-of-length-k-with-the-largest-sum.c", "hypo_code": "int* maxSubsequence(int* nums, int numsSize, int k, int* returnSize){\nint* result = (int*)malloc(sizeof(int) * k);\n    *returnSize = 0;\n    int* stack = (int*)malloc(sizeof(int) * numsSize);\n    int top = -1;\n    int remain = numsSize - k;\n    for (int i = 0; i < numsSize; i++)\n    {\n        while (top >= 0 && stack[top] < nums[i] && remain > 0)\n        {\n            top--;\n            remain--;\n        }\n        if (top < k - 1)\n        {\n            stack[++top] = nums[i];\n        }\n        else\n        {\n            remain--;\n        }\n    }\n    for (int i = 0; i < k; i++)\n    {\n        result[i] = stack[i];\n    }\n    *returnSize = k;\n    return result;\n}", "prefix": "int* maxSubsequence(int* nums, int numsSize, int k, int* returnSize"}
{"id": "451", "path": "output2\\c\\Easy\\451-rings-and-rods.c", "hypo_code": "int countPoints(char * rings){\nint count = 0;\n    for (int i = 0; i < strlen(rings); i++)\n    {\n        if (rings[i] == 'R')\n        {\n            for (int j = i; j < strlen(rings); j++)\n            {\n                if (rings[j] == 'G')\n                {\n                    for (int k = j; k < strlen(rings); k++)\n                    {\n                        if (rings[k] == 'B')\n                        {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}", "prefix": "int countPoints(char * rings"}
{"id": "452", "path": "output2\\c\\Easy\\452-find-first-palindromic-string-in-the-array.c", "hypo_code": "char * firstPalindrome(char ** words, int wordsSize){\n    int* hash = (int*)calloc(26, sizeof(int));\n    for (int i = 0; i < wordsSize; i++)\n    {\n        int start = 0;\n        int end = strlen(words[i]) - 1;\n        while (start < end)\n        {\n            if (words[i][start] != words[i][end])\n            {\n                break;\n            }\n            start++;\n            end--;\n        }\n        if (start >= end)\n        {\n            return words[i];\n        }\n    }\n    return \"\";\n\n}", "prefix": "char * firstPalindrome(char ** words, int wordsSize"}
{"id": "453", "path": "output2\\c\\Easy\\453-maximum-number-of-words-found-in-sentences.c", "hypo_code": "int mostWordsFound(char ** sentences, int sentencesSize){\nint max = 0;\n    for (int i = 0; i < sentencesSize; i++)\n    {\n        int count = 0;\n        char* token = strtok(sentences[i], \" \");\n        while (token != NULL)\n        {\n            count++;\n            token = strtok(NULL, \" \");\n        }\n        if (count > max)\n        {\n            max = count;\n        }\n    }\n    return max;\n}", "prefix": "int mostWordsFound(char ** sentences, int sentencesSize"}
{"id": "454", "path": "output2\\c\\Easy\\454-a-number-after-a-double-reversal.c", "hypo_code": "bool isSameAfterReversals(int num){\nint reversed = 0;\n    int original = num;\n    while (num != 0)\n    {\n        reversed = reversed * 10 + num % 10;\n        num /= 10;\n    }\n    while (reversed != 0)\n    {\n        if (reversed % 10 != original % 10)\n        {\n            return false;\n        }\n        reversed /= 10;\n        original /= 10;\n    }\n    return true;\n}", "prefix": "bool isSameAfterReversals(int num"}
{"id": "455", "path": "output2\\c\\Easy\\455-check-if-all-as-appears-before-all-bs.c", "hypo_code": "bool checkString(char * s){\nint a = 0;\n    int b = 0;\n    for (int i = 0; i < strlen(s); i++)\n    {\n        if (s[i] == 'a')\n        {\n            a++;\n        }\n        else if (s[i] == 'b')\n        {\n            b++;\n        }\n        if (b > a)\n        {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool checkString(char * s"}
{"id": "456", "path": "output2\\c\\Easy\\456-capitalize-the-title.c", "hypo_code": "char * capitalizeTitle(char * title){\nint length = strlen(title);\n    char* result = (char*)calloc(length + 1, sizeof(char));\n    result[0] = toupper(title[0]);\n    int index = 1;\n    for (int i = 1; i < length; i++)\n    {\n        if (title[i - 1] == ' ')\n        {\n            result[index] = toupper(title[i]);\n        }\n        else\n        {\n            result[index] = tolower(title[i]);\n        }\n        index++;\n    }\n    return result;\n}", "prefix": "char * capitalizeTitle(char * title"}
{"id": "457", "path": "output2\\c\\Easy\\457-check-if-every-row-and-column-contains-all-numbers.c", "hypo_code": "bool checkValid(int** matrix, int matrixSize, int* matrixColSize){\nint* hash = (int*)calloc(matrixSize, sizeof(int));\n    for (int i = 0; i < matrixSize; i++)\n    {\n        memset(hash, 0, sizeof(int) * matrixSize);\n        for (int j = 0; j < matrixSize; j++)\n        {\n            hash[matrix[i][j] - 1]++;\n        }\n        for (int j = 0; j < matrixSize; j++)\n        {\n            if (hash[j] != 1)\n            {\n                return false;\n            }\n        }\n    }\n    for (int i = 0; i < matrixSize; i++)\n    {\n        memset(hash, 0, sizeof(int) * matrixSize);\n        for (int j = 0; j < matrixSize; j++)\n        {\n            hash[matrix[j][i] - 1]++;\n        }\n        for (int j = 0; j < matrixSize; j++)\n        {\n            if (hash[j] != 1)\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool checkValid(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "458", "path": "output2\\c\\Easy\\458-divide-a-string-into-groups-of-size-k.c", "hypo_code": "char ** divideString(char * s, int k, char fill, int* returnSize){\nint length = strlen(s);\n    int groupCount = length / k;\n    if (length % k != 0)\n    {\n        groupCount++;\n    }\n    char** result = (char**)malloc(sizeof(char*) * groupCount);\n    *returnSize = groupCount;\n    for (int i = 0; i < groupCount; i++)\n    {\n        result[i] = (char*)malloc(sizeof(char) * (k + 1));\n        memset(result[i], fill, sizeof(char) * k);\n        result[i][k] = '\\0';\n    }\n    for (int i = 0; i < length; i++)\n    {\n        result[i / k][i % k] = s[i];\n    }\n    return result;\n}", "prefix": "char ** divideString(char * s, int k, char fill, int* returnSize"}
{"id": "459", "path": "output2\\c\\Easy\\459-minimum-cost-of-buying-candies-with-discount.c", "hypo_code": "int minimumCost(int* cost, int costSize){\nint* hash = (int*)calloc(101, sizeof(int));\n    for (int i = 0; i < costSize; i++)\n    {\n        hash[cost[i]]++;\n    }\n    int result = 0;\n    int free = 0;\n    for (int i = 100; i >= 1; i--)\n    {\n        while (hash[i] > 0)\n        {\n            if (free > 0)\n            {\n                free--;\n            }\n            else\n            {\n                result += i;\n            }\n            hash[i]--;\n            if (hash[i / 2] > 0)\n            {\n                free += hash[i / 2];\n                hash[i / 2] = 0;\n            }\n        }\n    }\n    return result;\n}", "prefix": "int minimumCost(int* cost, int costSize"}
{"id": "460", "path": "output2\\c\\Easy\\460-count-elements-with-strictly-smaller-and-greater-elements.c", "hypo_code": "int countElements(int* nums, int numsSize){\nint count = 0;\n    for (int i = 0; i < numsSize; i++)\n    {\n        int small = 0;\n        int large = 0;\n        for (int j = 0; j < numsSize; j++)\n        {\n            if (nums[j] < nums[i])\n            {\n                small++;\n            }\n            if (nums[j] > nums[i])\n            {\n                large++;\n            }\n        }\n        if (small > 0 && large > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int countElements(int* nums, int numsSize"}
{"id": "461", "path": "output2\\c\\Easy\\461-keep-multiplying-found-values-by-two.c", "hypo_code": "int findFinalValue(int* nums, int numsSize, int original){\nfor (int i = 0; i < numsSize; i++)\n    {\n        if (nums[i] == original)\n        {\n            original *= 2;\n        }\n    }\n    return original;\n}", "prefix": "int findFinalValue(int* nums, int numsSize, int original"}
{"id": "462", "path": "output2\\c\\Easy\\462-minimum-sum-of-four-digit-number-after-splitting-digits.c", "hypo_code": "int minimumSum(int num){\nint result = 0;\n    int a = num / 1000;\n    num %= 1000;\n    int b = num / 100;\n    num %= 100;\n    int c = num / 10;\n    num %= 10;\n    int d = num;\n    if (a == d && b == c)\n    {\n        result = a * 2;\n    }\n    else if (a == d)\n    {\n        result = a + b * 10 + c * 10 + d;\n    }\n    else if (b == c)\n    {\n        result = a * 10 + b * 10 + c + d;\n    }\n    else\n    {\n        result = a * 10 + b + c * 10 + d;\n    }\n    return result;\n\n}", "prefix": "int minimumSum(int num"}
{"id": "463", "path": "output2\\c\\Easy\\463-sort-even-and-odd-indices-independently.c", "hypo_code": "int* sortEvenOdd(int* nums, int numsSize, int* returnSize){\nint* even = (int*)malloc(sizeof(int) * (numsSize / 2));\n    int* odd = (int*)malloc(sizeof(int) * (numsSize / 2));\n    int evenSize = 0, oddSize = 0;\n    for (int i = 0; i < numsSize; i++)\n    {\n        if (i % 2 == 0)\n        {\n            even[evenSize++] = nums[i];\n        }\n        else\n        {\n            odd[oddSize++] = nums[i];\n        }\n    }\n    qsort(even, evenSize, sizeof(int), compare);\n    qsort(odd, oddSize, sizeof(int), compare);\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    *returnSize = numsSize;\n    for (int i = 0; i < evenSize; i++)\n    {\n        result[2 * i] = even[i];\n    }\n    for (int i = 0; i < oddSize; i++)\n    {\n        result[2 * i + 1] = odd[i];\n    }\n    return result;\n}", "prefix": "int* sortEvenOdd(int* nums, int numsSize, int* returnSize"}
{"id": "464", "path": "output2\\c\\Easy\\464-count-operations-to-obtain-zero.c", "hypo_code": "int countOperations(int num1, int num2){\nint count = 0;\n    while (num1 != 0 && num2 != 0)\n    {\n        if (num1 > num2)\n        {\n            num1 -= num2;\n        }\n        else\n        {\n            num2 -= num1;\n        }\n        count++;\n    }\n    return count;\n}", "prefix": "int countOperations(int num1, int num2"}
{"id": "465", "path": "output2\\c\\Easy\\465-count-equal-and-divisible-pairs-in-an-array.c", "hypo_code": "int countPairs(int* nums, int numsSize, int k){\nint result = 0;\n    for (int i = 0; i < numsSize; i++)\n    {\n        for (int j = i + 1; j < numsSize; j++)\n        {\n            if (nums[i] == nums[j] && (i * j) % k == 0)\n            {\n                result++;\n            }\n        }\n    }\n    return result;\n}", "prefix": "int countPairs(int* nums, int numsSize, int k"}
{"id": "466", "path": "output2\\c\\Easy\\466-count-integers-with-even-digit-sum.c", "hypo_code": "int countEven(int num){\nint count = 0;\n    for (int i = 1; i <= num; i++)\n    {\n        int temp = i;\n        int sum = 0;\n        while (temp != 0)\n        {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (sum % 2 == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int countEven(int num"}
{"id": "467", "path": "output2\\c\\Easy\\467-counting-words-with-a-given-prefix.c", "hypo_code": "int prefixCount(char ** words, int wordsSize, char * pref){\nint count = 0;\n    for (int i = 0; i < wordsSize; i++)\n    {\n        int j = 0;\n        while (words[i][j] != '\\0' && pref[j] != '\\0')\n        {\n            if (words[i][j] != pref[j])\n            {\n                break;\n            }\n            j++;\n        }\n        if (pref[j] == '\\0')\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int prefixCount(char ** words, int wordsSize, char * pref"}
{"id": "468", "path": "output2\\c\\Easy\\468-most-frequent-number-following-key-in-an-array.c", "hypo_code": "int mostFrequent(int* nums, int numsSize, int key){\nint result = 0;\n    int* map = (int*)malloc(sizeof(int) * 1001);\n    memset(map, 0, sizeof(int) * 1001);\n    for (int i = 0; i < numsSize - 1; i++)\n    {\n        if (nums[i] == key)\n        {\n            map[nums[i + 1]]++;\n        }\n    }\n    for (int i = 0; i < 1001; i++)\n    {\n        if (map[i] > map[result])\n        {\n            result = i;\n        }\n    }\n    free(map);\n    return result;\n}", "prefix": "int mostFrequent(int* nums, int numsSize, int key"}
{"id": "469", "path": "output2\\c\\Easy\\469-cells-in-a-range-on-an-excel-sheet.c", "hypo_code": "char ** cellsInRange(char * s, int* returnSize){\nint* result = (int*)malloc(sizeof(int) * numsSize);\n    *returnSize = 0;\n    for (int i = 0; i < numsSize; i++)\n    {\n        if (nums[i] == target)\n        {\n            result[(*returnSize)++] = i;\n        }\n    }\n    return result;\n}", "prefix": "char ** cellsInRange(char * s, int* returnSize"}
{"id": "470", "path": "output2\\c\\Easy\\470-find-all-k-distant-indices-in-an-array.c", "hypo_code": "int* findKDistantIndices(int* nums, int numsSize, int key, int k, int* returnSize){\nint* result = (int*)malloc(sizeof(int) * numsSize);\n    *returnSize = 0;\n    for (int i = 0; i < numsSize; i++)\n    {\n        if (nums[i] == key)\n        {\n            result[(*returnSize)++] = i;\n        }\n    }\n    return result;\n}", "prefix": "int* findKDistantIndices(int* nums, int numsSize, int key, int k, int* returnSize"}
{"id": "471", "path": "output2\\c\\Easy\\471-divide-array-into-equal-pairs.c", "hypo_code": "bool divideArray(int* nums, int numsSize){\nint i, j, temp;\n    for (i = 0; i < numsSize - 1; i++) {\n        for (j = 0; j < numsSize - 1 - i; j++) {\n            if (nums[j] > nums[j + 1]) {\n                temp = nums[j + 1];\n                nums[j + 1] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n\n    \n    for (i = 0; i < numsSize - 1; i += 2) {\n        if (nums[i] != nums[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool divideArray(int* nums, int numsSize"}
{"id": "472", "path": "output2\\c\\Easy\\472-count-hills-and-valleys-in-an-array.c", "hypo_code": "int countHillValley(int* nums, int numsSize){\nint i, j, temp, count = 0;\n    for (i = 0; i < numsSize - 1; i++) {\n        for (j = 0; j < numsSize - 1 - i; j++) {\n            if (nums[j] > nums[j + 1]) {\n                temp = nums[j + 1];\n                nums[j + 1] = nums[j];\n                nums[j] = temp;\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int countHillValley(int* nums, int numsSize"}
{"id": "473", "path": "output2\\c\\Easy\\473-find-the-difference-of-two-arrays.c", "hypo_code": "int** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes){\nint i, j, temp, count = 0;\n    int** result = (int**)malloc(sizeof(int*) * 2);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * 2);\n    for (i = 0; i < 2; i++) {\n        result[i] = (int*)malloc(sizeof(int) * 1000);\n        (*returnColumnSizes)[i] = 0;\n    }\n    for (i = 0; i < nums1Size; i++) {\n        for (j = 0; j < nums2Size; j++) {\n            if (nums1[i] == nums2[j]) {\n                break;\n            }\n        }\n        if (j == nums2Size) {\n            result[0][count++] = nums1[i];\n            (*returnColumnSizes)[0] = count;\n        }\n    }\n    count = 0;\n    for (i = 0; i < nums2Size; i++) {\n        for (j = 0; j < nums1Size; j++) {\n            if (nums2[i] == nums1[j]) {\n                break;\n            }\n        }\n        if (j == nums1Size) {\n            result[1][count++] = nums2[i];\n            (*returnColumnSizes)[1] = count;\n        }\n    }\n    *returnSize = 2;\n    return result;\n}", "prefix": "int** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes"}
{"id": "474", "path": "output2\\c\\Easy\\474-minimum-bit-flips-to-convert-number.c", "hypo_code": "int minBitFlips(int start, int goal){\nint i, j, temp, count = 0;\n    for (i = 0; i < numsSize - 1; i++) {\n        for (j = 0; j < numsSize - 1 - i; j++) {\n            if (nums[j] > nums[j + 1]) {\n                temp = nums[j + 1];\n                nums[j + 1] = nums[j];\n                nums[j] = temp;\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int minBitFlips(int start, int goal"}
{"id": "475", "path": "output2\\c\\Easy\\475-minimum-number-of-operations-to-convert-time.c", "hypo_code": "int convertTime(char * current, char * correct){\nint i, j, temp;\n    for (i = 0; i < numsSize - 1; i++) {\n        for (j = 0; j < numsSize - 1 - i; j++) {\n            if (nums[j] > nums[j + 1]) {\n                temp = nums[j + 1];\n                nums[j + 1] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int convertTime(char * current, char * correct"}
{"id": "476", "path": "output2\\c\\Easy\\476-largest-number-after-digit-swaps-by-parity.c", "hypo_code": "int largestInteger(int num){\nint i, j, temp, count = 0;\n    for (i = 0; i < numsSize - 1; i++) {\n        for (j = 0; j < numsSize - 1 - i; j++) {\n            if (nums[j] > nums[j + 1]) {\n                temp = nums[j + 1];\n                nums[j + 1] = nums[j];\n                nums[j] = temp;\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int largestInteger(int num"}
{"id": "477", "path": "output2\\c\\Easy\\477-add-two-integers.c", "hypo_code": "int sum(int num1, int num2){\nint i, j, temp, count = 0;\n    for (i = 0; i < numsSize - 1; i++) {\n        for (j = 0; j < numsSize - 1 - i; j++) {\n            if (nums[j] > nums[j + 1]) {\n                temp = nums[j + 1];\n                nums[j + 1] = nums[j];\n                nums[j] = temp;\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int sum(int num1, int num2"}
{"id": "478", "path": "output2\\c\\Easy\\478-root-equals-sum-of-children.c", "hypo_code": "bool checkTree(struct TreeNode* root){\nif (root == NULL) {\n        return true;\n    }\n    \n    if (root->left != NULL && root->right != NULL) {\n        if (root->val != root->left->val + root->right->val) {\n            return false;\n        }\n    }\n    return checkTree(root->left) && checkTree(root->right);\n\n}", "prefix": "bool checkTree(struct TreeNode* root"}
{"id": "479", "path": "output2\\c\\Easy\\479-find-closest-number-to-zero.c", "hypo_code": "int findClosestNumber(int* nums, int numsSize){\nint i, j, temp, count = 0;\n    for (i = 0; i < numsSize - 1; i++) {\n        for (j = 0; j < numsSize - 1 - i; j++) {\n            if (nums[j] > nums[j + 1]) {\n                temp = nums[j + 1];\n                nums[j + 1] = nums[j];\n                nums[j] = temp;\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int findClosestNumber(int* nums, int numsSize"}
{"id": "480", "path": "output2\\c\\Easy\\480-calculate-digit-sum-of-a-string.c", "hypo_code": "char * digitSum(char * s, int k){\nint i, j, temp;\n    for (i = 0; i < numsSize - 1; i++) {\n        for (j = 0; j < numsSize - 1 - i; j++) {\n            if (nums[j] > nums[j + 1]) {\n                temp = nums[j + 1];\n                nums[j + 1] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n\n    \n    for (i = 0; i < numsSize - 1; i += 2) {\n        if (nums[i] != nums[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "char * digitSum(char * s, int k"}
{"id": "481", "path": "output2\\c\\Easy\\481-intersection-of-multiple-arrays.c", "hypo_code": "int* intersection(int** nums, int numsSize, int* numsColSize, int* returnSize){\nint *res = NULL;\n    int resSize = 0;\n    int *hash = (int*)calloc(1000, sizeof(int));\n    int i = 0, j = 0, k = 0;\n    for (; i < numsSize; i++) {\n        memset(hash, 0, 1000 * sizeof(int));\n        for (j = 0; j < numsColSize[i]; j++) {\n            hash[nums[i][j] - 1]++;\n            if (hash[nums[i][j] - 1] == numsSize) {\n                int *tmp = (int*)realloc(res, sizeof(int) * (resSize + 1));\n                if (NULL != tmp) {\n                    res = tmp;\n                    res[resSize++] = nums[i][j];\n                }\n            }\n        }\n    }\n    *returnSize = resSize;\n    return res;\n}", "prefix": "int* intersection(int** nums, int numsSize, int* numsColSize, int* returnSize"}
{"id": "482", "path": "output2\\c\\Easy\\482-count-prefixes-of-a-given-string.c", "hypo_code": "int countPrefixes(char ** words, int wordsSize, char * s){\nint res = 0;\n    int i = 0, j = 0;\n    for (; i < wordsSize; i++) {\n        for (j = 0; j < strlen(words[i]); j++) {\n            if (words[i][j] != s[j]) {\n                break;\n            }\n        }\n        if (j == strlen(words[i])) {\n            res++;\n        }\n    }\n    return res;\n}", "prefix": "int countPrefixes(char ** words, int wordsSize, char * s"}
{"id": "483", "path": "output2\\c\\Easy\\483-remove-digit-from-number-to-maximize-result.c", "hypo_code": "char * removeDigit(char * number, char digit){\nint i = 0, j = 0;\n    for (; i < strlen(number); i++) {\n        if (number[i] == digit) {\n            break;\n        }\n    }\n    char *res = (char*)calloc(strlen(number), sizeof(char));\n    for (j = 0; j < strlen(number); j++) {\n        if (j != i) {\n            res[j] = number[j];\n        }\n    }\n    return res;\n}", "prefix": "char * removeDigit(char * number, char digit"}
{"id": "484", "path": "output2\\c\\Easy\\484-largest-3-same-digit-number-in-string.c", "hypo_code": "char * largestGoodInteger(char * num){\nint i = 0, j = 0, k = 0;\n    int max = 0;\n    char *res = (char*)calloc(4, sizeof(char));\n    for (; i < strlen(num) - 2; i++) {\n        int tmp = 0;\n        for (j = 0; j < 3; j++) {\n            tmp = tmp * 10 + num[i + j] - '0';\n        }\n        for (j = 0; j < 3; j++) {\n            if (num[i + j] != num[i]) {\n                break;\n            }\n        }\n        if (j == 3 && tmp > max) {\n            max = tmp;\n            sprintf(res, \"%d\", max);\n        }\n    }\n    return res;\n}", "prefix": "char * largestGoodInteger(char * num"}
{"id": "485", "path": "output2\\c\\Easy\\485-find-the-k-beauty-of-a-number.c", "hypo_code": "int divisorSubstrings(int num, int k){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    char *numStr = (char*)calloc(10, sizeof(char));\n    sprintf(numStr, \"%d\", num);\n    for (; i < strlen(numStr) - k + 1; i++) {\n        int tmp = 0;\n        for (j = 0; j < k; j++) {\n            tmp = tmp * 10 + numStr[i + j] - '0';\n        }\n        if (num % tmp == 0) {\n            res++;\n        }\n    }\n    return res;\n}\nint kthBeauty(int num, int k){\nint res = 0;\n    int i = 0;\n    for (; i < strlen(num); i++) {\n        res += divisorSubstrings(num, i);\n    }\n    return res;\n}", "prefix": "int divisorSubstrings(int num, int k"}
{"id": "486", "path": "output2\\c\\Easy\\486-find-resultant-array-after-removing-anagrams.c", "hypo_code": "char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\nint *hash = (int*)calloc(26, sizeof(int));\n    int i = 0, j = 0;\n    for (; i < wordsSize; i++) {\n        memset(hash, 0, 26 * sizeof(int));\n        for (j = 0; j < strlen(words[i]); j++) {\n            hash[words[i][j] - 'a']++;\n        }\n        for (j = i + 1; j < wordsSize; j++) {\n            int k = 0;\n            for (; k < strlen(words[j]); k++) {\n                if (hash[words[j][k] - 'a'] > 0) {\n                    hash[words[j][k] - 'a']--;\n                } else {\n                    break;\n                }\n            }\n            if (k == strlen(words[j])) {\n                words[j] = \"\";\n            }\n        }\n    }\n    int resSize = 0;\n    char **res = (char**)calloc(wordsSize, sizeof(char*));\n    for (i = 0; i < wordsSize; i++) {\n        if (strlen(words[i]) > 0) {\n            res[resSize++] = words[i];\n        }\n    }\n    *returnSize = resSize;\n    return res;\n}", "prefix": "char ** removeAnagrams(char ** words, int wordsSize, int* returnSize"}
{"id": "487", "path": "output2\\c\\Easy\\487-percentage-of-letter-in-string.c", "hypo_code": "int percentageLetter(char * s, char letter){\nint res = 0;\n    int i = 0;\n    for (; i < strlen(s); i++) {\n        if (s[i] == letter) {\n            res++;\n        }\n    }\n    return res * 100 / strlen(s);\n}", "prefix": "int percentageLetter(char * s, char letter"}
{"id": "488", "path": "output2\\c\\Easy\\488-check-if-number-has-equal-digit-count-and-digit-value.c", "hypo_code": "bool digitCount(char * num){\nint i = 0, j = 0, k = 0;\n    for (; i < strlen(num); i++) {\n        int count = 0;\n        for (j = 0; j < strlen(num); j++) {\n            if (num[j] == num[i]) {\n                count++;\n            }\n        }\n        if (count != num[i] - '0') {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool digitCount(char * num"}
{"id": "489", "path": "output2\\c\\Easy\\489-rearrange-characters-to-make-target-string.c", "hypo_code": "int rearrangeCharacters(char * s, char * target){\nint res = 0;\n    int i = 0, j = 0;\n    for (; i < strlen(s); i++) {\n        for (j = 0; j < strlen(target); j++) {\n            if (s[i] == target[j]) {\n                s[i] = ' ';\n                break;\n            }\n        }\n    }\n    for (i = 0; i < strlen(s); i++) {\n        if (s[i] != ' ') {\n            return 0;\n        }\n    }\n    return 1;\n}", "prefix": "int rearrangeCharacters(char * s, char * target"}
{"id": "490", "path": "output2\\c\\Easy\\490-min-max-game.c", "hypo_code": "int minMaxGame(int* nums, int numsSize){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *newNums = NULL;\n    int newNumsSize = 0;\n    while (numsSize > 1) {\n        newNums = (int*)realloc(newNums, sizeof(int) * (numsSize / 2));\n        newNumsSize = 0;\n        for (i = 0; i < numsSize; i += 2) {\n            if (i + 1 < numsSize) {\n                if (nums[i] > nums[i + 1]) {\n                    newNums[newNumsSize++] = nums[i];\n                } else {\n                    newNums[newNumsSize++] = nums[i + 1];\n                }\n            } else {\n                newNums[newNumsSize++] = nums[i];\n            }\n        }\n        numsSize = newNumsSize;\n        memcpy(nums, newNums, sizeof(int) * numsSize);\n    }\n    return nums[0];\n}", "prefix": "int minMaxGame(int* nums, int numsSize"}
{"id": "491", "path": "output2\\c\\Easy\\491-strong-password-checker-ii.c", "hypo_code": "bool strongPasswordCheckerII(char * password){\nint i = 0;\n    int lowercase = 0, uppercase = 0, digit = 0, special = 0;\n    for (; i < strlen(password); i++) {\n        if (password[i] >= 'a' && password[i] <= 'z') {\n            lowercase = 1;\n        } else if (password[i] >= 'A' && password[i] <= 'Z') {\n            uppercase = 1;\n        } else if (password[i] >= '0' && password[i] <= '9') {\n            digit = 1;\n        } else {\n            special = 1;\n        }\n    }\n    if (strlen(password) < 8) {\n        return false;\n    }\n    if (lowercase == 0 || uppercase == 0 || digit == 0 || special == 0) {\n        return false;\n    }\n    for (i = 0; i < strlen(password) - 1; i++) {\n        if (password[i] == password[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool strongPasswordCheckerII(char * password"}
{"id": "492", "path": "output2\\c\\Easy\\492-calculate-amount-paid-in-taxes.c", "hypo_code": "double calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income){\ndouble res = 0;\n    int i = 0;\n    for (; i < bracketsSize; i++) {\n        if (income <= brackets[i][0]) {\n            res += income * brackets[i][1] / 100.0;\n            break;\n        } else {\n            res += brackets[i][0] * brackets[i][1] / 100.0;\n            income -= brackets[i][0];\n        }\n    }\n    return res;\n}", "prefix": "double calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income"}
{"id": "493", "path": "output2\\c\\Easy\\493-greatest-english-letter-in-upper-and-lower-case.c", "hypo_code": "char * greatestLetter(char * s){\nint i = 0;\n    int *l = (int*)calloc(26, sizeof(int));\n    int *u = (int*)calloc(26, sizeof(int));\n    for (; i < strlen(s); i++) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            l[s[i] - 'a']++;\n        } else {\n            u[s[i] - 'A']++;\n        }\n    }\n    for (i = 25; i >= 0; i--) {\n        if (l[i] > 0 && u[i] > 0) {\n            char *res = (char*)calloc(2, sizeof(char));\n            res[0] = i + 'A';\n            return res;\n        }\n    }\n    return \"\";\n}", "prefix": "char * greatestLetter(char * s"}
{"id": "494", "path": "output2\\c\\Easy\\494-count-asterisks.c", "hypo_code": "int countAsterisks(char * s){\nint res = 0;\n    int i = 0, j = 0;\n    for (; i < strlen(s); i++) {\n        if (s[i] == '|') {\n            i++;\n            for (; i < strlen(s); i++) {\n                if (s[i] == '|') {\n                    break;\n                }\n                if (s[i] == '*') {\n                    res++;\n                }\n            }\n        }\n    }\n    return res;\n}", "prefix": "int countAsterisks(char * s"}
{"id": "495", "path": "output2\\c\\Easy\\495-check-if-matrix-is-x-matrix.c", "hypo_code": "bool checkXMatrix(int** grid, int gridSize, int* gridColSize){\nint i = 0, j = 0, k = 0;\n    for (; i < gridSize; i++) {\n        for (j = 0; j < gridColSize[i]; j++) {\n            if (i != j && grid[i][j] != 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool checkXMatrix(int** grid, int gridSize, int* gridColSize"}
{"id": "496", "path": "output2\\c\\Easy\\496-decode-the-message.c", "hypo_code": "char * decodeMessage(char * key, char * message){\nchar *res = (char*)calloc(strlen(message) + 1, sizeof(char));\n    int i = 0, j = 0, k = 0;\n    int hash[26] = {0};\n    for (; i < strlen(key); i++) {\n        if (key[i] != ' ') {\n            hash[key[i] - 'a'] = 1;\n        }\n    }\n    for (i = 0; i < 26; i++) {\n        if (hash[i] == 0) {\n            return \"\";\n        }\n    }\n    for (i = 0; i < strlen(message); i++) {\n        if (message[i] == ' ') {\n            res[i] = ' ';\n        } else {\n            for (j = 0; j < strlen(key); j++) {\n                if (key[j] == message[i]) {\n                    res[i] = j + 'a';\n                    break;\n                }\n            }\n        }\n    }\n    return res;\n}", "prefix": "char * decodeMessage(char * key, char * message"}
{"id": "497", "path": "output2\\c\\Easy\\497-evaluate-boolean-binary-tree.c", "hypo_code": "bool evaluateTree(struct TreeNode* root){\nif (root->left == NULL && root->right == NULL) {\n        return root->val == 1;\n    }\n    if (root->val == 2) {\n        return evaluateTree(root->left) || evaluateTree(root->right);\n    } else {\n        return evaluateTree(root->left) && evaluateTree(root->right);\n    }\n}", "prefix": "bool evaluateTree(struct TreeNode* root"}
{"id": "498", "path": "output2\\c\\Easy\\498-minimum-amount-of-time-to-fill-cups.c", "hypo_code": "int fillCups(int* amount, int amountSize){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int min = amount[0];\n    int max = amount[0];\n    for (; i < amountSize; i++) {\n        if (amount[i] < min) {\n            min = amount[i];\n        }\n        if (amount[i] > max) {\n            max = amount[i];\n        }\n    }\n    int diff = max - min;\n    for (i = 0; i < amountSize; i++) {\n        if (amount[i] != min) {\n            res += amount[i] - min;\n        }\n    }\n    return res;\n\n}", "prefix": "int fillCups(int* amount, int amountSize"}
{"id": "499", "path": "output2\\c\\Easy\\499-maximum-number-of-pairs-in-array.c", "hypo_code": "int* numberOfPairs(int* nums, int numsSize, int* returnSize){\nint *res = (int*)calloc(2, sizeof(int));\n    int resSize = 2;\n    int *hash = (int*)calloc(101, sizeof(int));\n    int i = 0;\n    for (; i < numsSize; i++) {\n        hash[nums[i]]++;\n    }\n    for (i = 0; i < 101; i++) {\n        if (hash[i] > 1) {\n            res[0] += hash[i] * (hash[i] - 1) / 2;\n        }\n    }\n    res[1] = numsSize - res[0] * 2;\n    *returnSize = resSize;\n    return res;\n}", "prefix": "int* numberOfPairs(int* nums, int numsSize, int* returnSize"}
{"id": "500", "path": "output2\\c\\Easy\\500-best-poker-hand.c", "hypo_code": "char * bestHand(int* ranks, int ranksSize, char* suits, int suitsSize){\nint res = 0;\n    int i = 0, j = 0;\n    int max = 0;\n    char *ret = (char*)calloc(20, sizeof(char));\n    for (; i < ranksSize; i++) {\n        if (ranks[i] > max) {\n            max = ranks[i];\n        }\n    }\n    if (max == 13) {\n        sprintf(ret, \"Flush\");\n        return ret;\n    }\n    for (i = 0; i < ranksSize; i++) {\n        for (j = 0; j < suitsSize; j++) {\n            if (suits[i] == suits[j]) {\n                break;\n            }\n        }\n        if (j == suitsSize) {\n            return ret;\n        }\n    }\n    for (i = 0; i < ranksSize; i++) {\n        for (j = 0; j < ranksSize; j++) {\n            if (ranks[i] == ranks[j]) {\n                break;\n            }\n        }\n        if (j == ranksSize) {\n            return ret;\n        }\n    }\n    sprintf(ret, \"Pair\");\n    return ret;\n}", "prefix": "char * bestHand(int* ranks, int ranksSize, char* suits, int suitsSize"}
{"id": "501", "path": "output2\\c\\Easy\\501-first-letter-to-appear-twice.c", "hypo_code": "char repeatedCharacter(char * s){\nint i = 0;\n    int *l = (int*)calloc(26, sizeof(int));\n    for (; i < strlen(s); i++) {\n        l[s[i] - 'a']++;\n        if (l[s[i] - 'a'] == 2) {\n            char *res = (char*)calloc(2, sizeof(char));\n            res[0] = s[i];\n            return res;\n        }\n    }\n    return \"\";\n}", "prefix": "char repeatedCharacter(char * s"}
{"id": "503", "path": "output2\\c\\Easy\\503-make-array-zero-by-subtracting-equal-amounts.c", "hypo_code": "int minimumOperations(int* nums, int numsSize){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int min = 101;\n    for (; i < numsSize; i++) {\n        if (nums[i] > 0 && nums[i] < min) {\n            min = nums[i];\n        }\n    }\n    for (i = 0; i < numsSize; i++) {\n        if (nums[i] > 0) {\n            res += nums[i] / min;\n            if (nums[i] % min > 0) {\n                res++;\n            }\n        }\n    }\n    return res;\n}", "prefix": "int minimumOperations(int* nums, int numsSize"}
{"id": "504", "path": "output2\\c\\Easy\\504-merge-similar-items.c", "hypo_code": "int** mergeSimilarItems(int** items1, int items1Size, int* items1ColSize, int** items2, int items2Size, int* items2ColSize, int* returnSize, int** returnColumnSizes){\nint **res = NULL;\n    int resSize = 0;\n    int *hash = (int*)calloc(1000, sizeof(int));\n    int i = 0, j = 0, k = 0;\n    for (; i < items1Size; i++) {\n        memset(hash, 0, 1000 * sizeof(int));\n        for (j = 0; j < items1ColSize[i]; j++) {\n            hash[items1[i][j] - 1]++;\n            if (hash[items1[i][j] - 1] == items1Size) {\n                int *tmp = (int*)realloc(res, sizeof(int) * (resSize + 1));\n                if (NULL != tmp) {\n                    res = tmp;\n                    res[resSize++] = items1[i][j];\n                }\n            }\n        }\n    }\n    *returnSize = resSize;\n    return res;\n}", "prefix": "int** mergeSimilarItems(int** items1, int items1Size, int* items1ColSize, int** items2, int items2Size, int* items2ColSize, int* returnSize, int** returnColumnSizes"}
{"id": "505", "path": "output2\\c\\Easy\\505-number-of-arithmetic-triplets.c", "hypo_code": "int arithmeticTriplets(int* nums, int numsSize, int diff){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int arithmeticTriplets(int* nums, int numsSize, int diff"}
{"id": "506", "path": "output2\\c\\Easy\\506-largest-local-values-in-a-matrix.c", "hypo_code": "int** largestLocal(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){\nint **res = NULL;\n    int resSize = 0;\n    int i = 0, j = 0, k = 0;\n    int **hash = (int**)calloc(gridSize - 2, sizeof(int*));\n    for (i = 0; i < gridSize - 2; i++) {\n        hash[i] = (int*)calloc(gridColSize[i] - 2, sizeof(int));\n        for (j = 0; j < gridColSize[i] - 2; j++) {\n            hash[i][j] = grid[i + 1][j + 1];\n            for (k = -1; k <= 1; k++) {\n                if (grid[i][j + 1 + k] > hash[i][j]) {\n                    hash[i][j] = grid[i][j + 1 + k];\n                }\n                if (grid[i + 1][j + k] > hash[i][j]) {\n                    hash[i][j] = grid[i + 1][j + k];\n                }\n                if (grid[i + 2][j + 1 + k] > hash[i][j]) {\n                    hash[i][j] = grid[i + 2][j + 1 + k];\n                }\n            }\n        }\n    }\n    res = (int**)calloc(gridSize - 2, sizeof(int*));\n    *returnColumnSizes = (int*)calloc(gridSize - 2, sizeof(int));\n    for (i = 0; i < gridSize - 2; i++) {\n        res[i] = (int*)calloc(gridColSize[i] - 2, sizeof(int));\n        (*returnColumnSizes)[i] = gridColSize[i] - 2;\n        for (j = 0; j < gridColSize[i] - 2; j++) {\n            res[i][j] = hash[i][j];\n        }\n    }\n    *returnSize = gridSize - 2;\n    return res;\n}", "prefix": "int** largestLocal(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes"}
{"id": "507", "path": "output2\\c\\Easy\\507-minimum-recolors-to-get-k-consecutive-black-blocks.c", "hypo_code": "int minimumRecolors(char * blocks, int k){\nint i = 0, j = 0;\n    int res = 0;\n    for (; i < strlen(blocks); i++) {\n        int count = 0;\n        for (j = i; j < strlen(blocks); j++) {\n            if (blocks[j] == 'B') {\n                count++;\n            }\n            if (count == k) {\n                break;\n            }\n        }\n        if (count < k) {\n            return -1;\n        }\n        res++;\n        i = j;\n    }\n    return res;\n}", "prefix": "int minimumRecolors(char * blocks, int k"}
{"id": "508", "path": "output2\\c\\Easy\\508-minimum-hours-of-training-to-win-a-competition.c", "hypo_code": "int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\nint res = 0;\n    int i = 0, j = 0;\n    int *dp = (int*)calloc(initialExperience + 1, sizeof(int));\n    dp[initialExperience] = initialEnergy;\n    for (i = 0; i < energySize; i++) {\n        for (j = 0; j < initialExperience; j++) {\n            if (dp[j] >= energy[i]) {\n                dp[j] -= energy[i];\n                dp[j + 1] = dp[j] + experience[i];\n            }\n        }\n    }\n    for (i = 0; i <= initialExperience; i++) {\n        if (dp[i] != 0) {\n            return i;\n        }\n    }\n    return i;\n}", "prefix": "int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize"}
{"id": "509", "path": "output2\\c\\Easy\\509-longest-subsequence-with-limited-sum.c", "hypo_code": "int* answerQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\nint *res = (int*)calloc(queriesSize, sizeof(int));\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = fmax(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    for (i = 0; i < queriesSize; i++) {\n        for (j = 0; j < numsSize; j++) {\n            if (nums[j] <= queries[i]) {\n                res[i] = fmax(res[i], dp[j]);\n            }\n        }\n    }\n    *returnSize = queriesSize;\n    return res;\n}", "prefix": "int* answerQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize"}
{"id": "510", "path": "output2\\c\\Easy\\510-find-subarrays-with-equal-sum.c", "hypo_code": "bool findSubarrays(int* nums, int numsSize){\nint i = 0, j = 0, k = 0;\n    int *sum = (int*)calloc(numsSize + 1, sizeof(int));\n    for (; i < numsSize; i++) {\n        sum[i + 1] = sum[i] + nums[i];\n    }\n    for (i = 0; i < numsSize - 1; i++) {\n        for (j = i + 2; j < numsSize; j++) {\n            if (sum[i + 1] == sum[j + 1] - sum[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "prefix": "bool findSubarrays(int* nums, int numsSize"}
{"id": "511", "path": "output2\\c\\Easy\\511-check-distances-between-same-letters.c", "hypo_code": "bool checkDistances(char * s, int* distance, int distanceSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    char c = 0;\n    int d = 0;\n    int n = strlen(s);\n    int *a = (int*)malloc(sizeof(int) * 26);\n    memset(a, 0, sizeof(int) * 26);\n    for (i = 0; i < n; i++) {\n        c = s[i];\n        d = distance[c - 'a'];\n        if (d == 0) {\n            continue;\n        }\n        if (a[c - 'a'] == 0) {\n            a[c - 'a'] = i + 1;\n            continue;\n        }\n        if (i - a[c - 'a'] + 1 != d) {\n            return false;\n        }\n        a[c - 'a'] = i + 1;\n    }\n    return true;\n}", "prefix": "bool checkDistances(char * s, int* distance, int distanceSize"}
{"id": "512", "path": "output2\\c\\Easy\\512-most-frequent-even-element.c", "hypo_code": "int mostFrequentEven(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int *a = (int*)malloc(sizeof(int) * 100001);\n    memset(a, 0, sizeof(int) * 100001);\n    for (i = 0; i < numsSize; i++) {\n        a[nums[i]]++;\n    }\n    for (i = 100000; i >= 0; i--) {\n        if (a[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return -1;\n}", "prefix": "int mostFrequentEven(int* nums, int numsSize"}
{"id": "513", "path": "output2\\c\\Easy\\513-count-days-spent-together.c", "hypo_code": "int countDaysTogether(char * arriveAlice, char * leaveAlice, char * arriveBob, char * leaveBob){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int a1 = 0;\n    int a2 = 0;\n    int a3 = 0;\n    int a4 = 0;\n    int b1 = 0;\n    int b2 = 0;\n    int b3 = 0;\n    int b4 = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    a1 = (arriveAlice[0] - '0') * 10 + arriveAlice[1] - '0';\n    a2 = (arriveAlice[3] - '0') * 10 + arriveAlice[4] - '0';\n    a3 = (leaveAlice[0] - '0') * 10 + leaveAlice[1] - '0';\n    a4 = (leaveAlice[3] - '0') * 10 + leaveAlice[4] - '0';\n    b1 = (arriveBob[0] - '0') * 10 + arriveBob[1] - '0';\n    b2 = (arriveBob[3] - '0') * 10 + arriveBob[4] - '0';\n    b3 = (leaveBob[0] - '0') * 10 + leaveBob[1] - '0';\n    b4 = (leaveBob[3] - '0') * 10 + leaveBob[4] - '0';\n    a = a1 * 100 + a2;\n    b = a3 * 100 + a4;\n    c = b1 * 100 + b2;\n    d = b3 * 100 + b4;\n    if (a > b || c > d) {\n        return 0;\n    }\n    if (b < c || d < a) {\n        return 0;\n    }\n    return (b > d ? d : b) - (a > c ? a : c) + 1;\n}", "prefix": "int countDaysTogether(char * arriveAlice, char * leaveAlice, char * arriveBob, char * leaveBob"}
{"id": "514", "path": "output2\\c\\Easy\\514-smallest-even-multiple.c", "hypo_code": "int smallestEvenMultiple(int n){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    if (n % 2 == 0) {\n        return n;\n    }\n    return n * 2;\n}", "prefix": "int smallestEvenMultiple(int n"}
{"id": "515", "path": "output2\\c\\Easy\\515-sort-the-people.c", "hypo_code": "char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    char *t = NULL;\n    char **a = (char**)malloc(sizeof(char*) * namesSize);\n    for (i = 0; i < namesSize; i++) {\n        a[i] = (char*)malloc(sizeof(char) * 21);\n        strcpy(a[i], names[i]);\n    }\n    *returnSize = namesSize;\n    for (i = 0; i < namesSize; i++) {\n        for (j = i + 1; j < namesSize; j++) {\n            if (heights[i] < heights[j]) {\n                t = a[i];\n                a[i] = a[j];\n                a[j] = t;\n                k = heights[i];\n                heights[i] = heights[j];\n                heights[j] = k;\n            }\n        }\n    }\n    return a;\n}", "prefix": "char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize"}
{"id": "516", "path": "output2\\c\\Easy\\516-remove-letter-to-equalize-frequency.c", "hypo_code": "bool equalFrequency(char * word){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int n = strlen(word);\n    int *x = (int*)malloc(sizeof(int) * 26);\n    memset(x, 0, sizeof(int) * 26);\n    int *y = (int*)malloc(sizeof(int) * 26);\n    memset(y, 0, sizeof(int) * 26);\n    for (i = 0; i < n; i++) {\n        x[word[i] - 'a']++;\n    }\n    for (i = 0; i < 26; i++) {\n        if (x[i] == 0) {\n            continue;\n        }\n        y[x[i] - 1]++;\n    }\n    for (i = 0; i < 26; i++) {\n        if (y[i] == 0) {\n            continue;\n        }\n        if (y[i] == 1) {\n            a++;\n        }\n        if (y[i] == 2) {\n            b++;\n        }\n        if (y[i] > 2) {\n            c++;\n        }\n    }\n    if (c > 0) {\n        return false;\n    }\n    if (a == 0) {\n        return true;\n    }\n    if (a > 1) {\n        return false;\n    }\n    if (b == 0) {\n        return true;\n    }\n    if (b > 1) {\n        return false;\n    }\n    return true;\n}", "prefix": "bool equalFrequency(char * word"}
{"id": "517", "path": "output2\\c\\Easy\\517-number-of-common-factors.c", "hypo_code": "int commonFactors(int a, int b){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int *c = (int*)calloc(1001, sizeof(int));\n    for (i = 1; i <= a; i++) {\n        if (a % i == 0) {\n            c[i]++;\n        }\n    }\n    for (i = 1; i <= b; i++) {\n        if (b % i == 0) {\n            c[i]++;\n        }\n    }\n    for (i = 1; i < 1001; i++) {\n        if (c[i] == 2) {\n            n++;\n        }\n    }\n    return n;\n}", "prefix": "int commonFactors(int a, int b"}
{"id": "518", "path": "output2\\c\\Easy\\518-the-employee-that-worked-on-the-longest-task.c", "hypo_code": "int hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(n, sizeof(int));\n    for (i = 0; i < logsSize; i++) {\n        dp[logs[i][0]] += logs[i][1];\n    }\n    for (i = 1; i < n; i++) {\n        if (dp[i] > dp[res]) {\n            res = i;\n        }\n    }\n    return res;\n\n}", "prefix": "int hardestWorker(int n, int** logs, int logsSize, int* logsColSize"}
{"id": "519", "path": "output2\\c\\Easy\\519-number-of-valid-clock-times.c", "hypo_code": "int countTime(char * time){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int res = 0;\n    if (time[0] == '?') {\n        a = 0;\n        b = 9;\n    } else {\n        a = time[0] - '0';\n        b = time[0] - '0';\n    }\n    if (time[1] == '?') {\n        c = 0;\n        d = 9;\n    } else {\n        c = time[1] - '0';\n        d = time[1] - '0';\n    }\n    if (time[3] == '?') {\n        e = 0;\n    } else {\n        e = time[3] - '0';\n    }\n    if (time[4] == '?') {\n        x = 0;\n        y = 9;\n        z = 9;\n    } else {\n        x = time[3] - '0';\n        y = time[3] - '0';\n        z = time[4] - '0';\n    }\n    for (i = a; i <= b; i++) {\n        for (j = c; j <= d; j++) {\n            for (k = e; k <= 5; k++) {\n                for (l = x; l <= y; l++) {\n                    for (m = z; m <= 9; m++) {\n                        if (i == 2 && j > 3) {\n                            break;\n                        }\n                        res++;\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}", "prefix": "int countTime(char * time"}
{"id": "520", "path": "output2\\c\\Easy\\520-largest-positive-integer-that-exists-with-its-negative.c", "hypo_code": "int findMaxK(int* nums, int numsSize){\nint i = 0, j = 0, k = 0;\n    int *a = (int*)calloc(2001, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        a[nums[i] + 1000]++;\n    }\n    for (i = 0; i < 1001; i++) {\n        if (a[i] != 0 && a[i + 1000] != 0) {\n            k = i;\n        }\n    }\n    if (k == 0) {\n        return -1;\n    }\n    return k;\n}", "prefix": "int findMaxK(int* nums, int numsSize"}
{"id": "521", "path": "output2\\c\\Easy\\521-determine-if-two-events-have-conflict.c", "hypo_code": "bool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    a = (event1[0][0] - '0') * 10 + event1[0][1] - '0';\n    b = (event1[0][3] - '0') * 10 + event1[0][4] - '0';\n    c = (event1[1][0] - '0') * 10 + event1[1][1] - '0';\n    d = (event1[1][3] - '0') * 10 + event1[1][4] - '0';\n    e = (event2[0][0] - '0') * 10 + event2[0][1] - '0';\n    x = (event2[0][3] - '0') * 10 + event2[0][4] - '0';\n    y = (event2[1][0] - '0') * 10 + event2[1][1] - '0';\n    z = (event2[1][3] - '0') * 10 + event2[1][4] - '0';\n    if ((a < e && c < e) || (a > y && c > y) || (e < a && y < a) || (e > c && y > c)) {\n        return false;\n    }\n    if ((b < x && d < x) || (b > z && d > z) || (x < b && z < b) || (x > d && z > d)) {\n        return false;\n    }\n    return true;\n}", "prefix": "bool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size"}
{"id": "522", "path": "output2\\c\\Easy\\522-odd-string-difference.c", "hypo_code": "char * oddString(char ** words, int wordsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = strlen(words[0]);\n    int *a = (int*)malloc(sizeof(int) * (n - 1));\n    int *b = (int*)malloc(sizeof(int) * (n - 1));\n    char *res = (char*)malloc(sizeof(char) * (n + 1));\n    memset(a, 0, sizeof(int) * (n - 1));\n    memset(b, 0, sizeof(int) * (n - 1));\n    memset(res, 0, sizeof(char) * (n + 1));\n    for (i = 0; i < wordsSize; i++) {\n        for (j = 0; j < n - 1; j++) {\n            a[j] = words[i][j + 1] - words[i][j];\n        }\n        if (i == 0) {\n            memcpy(b, a, sizeof(int) * (n - 1));\n            continue;\n        }\n        for (j = 0; j < n - 1; j++) {\n            if (a[j] == b[j]) {\n                continue;\n            }\n            if (a[j] + b[j] == 0) {\n                continue;\n            }\n            break;\n        }\n        if (j == n - 1) {\n            memcpy(res, words[i], sizeof(char) * (n + 1));\n            break;\n        }\n    }\n    return res;\n}", "prefix": "char * oddString(char ** words, int wordsSize"}
{"id": "523", "path": "output2\\c\\Easy\\523-average-value-of-even-numbers-that-are-divisible-by-three.c", "hypo_code": "int averageValue(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    for (i = 0; i < numsSize; i++) {\n        if (nums[i] % 2 == 0 && nums[i] % 3 == 0) {\n            k += nums[i];\n            n++;\n        }\n    }\n    if (n == 0) {\n        return 0;\n    }\n    return k / n;\n\n}", "prefix": "int averageValue(int* nums, int numsSize"}
{"id": "524", "path": "output2\\c\\Easy\\524-apply-operations-to-an-array.c", "hypo_code": "int* applyOperations(int* nums, int numsSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    for (i = 0; i < numsSize - 1; i++) {\n        if (nums[i] == nums[i + 1]) {\n            nums[i] *= 2;\n            nums[i + 1] = 0;\n        }\n    }\n    for (i = 0; i < numsSize; i++) {\n        if (nums[i] == 0) {\n            for (j = i + 1; j < numsSize; j++) {\n                if (nums[j] != 0) {\n                    nums[i] = nums[j];\n                    nums[j] = 0;\n                    break;\n                }\n            }\n        }\n    }\n    *returnSize = numsSize;\n    return nums;\n}", "prefix": "int* applyOperations(int* nums, int numsSize, int* returnSize"}
{"id": "525", "path": "output2\\c\\Easy\\525-number-of-distinct-averages.c", "hypo_code": "int distinctAverages(int* nums, int numsSize){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int distinctAverages(int* nums, int numsSize"}
{"id": "526", "path": "output2\\c\\Easy\\526-convert-the-temperature.c", "hypo_code": "double* convertTemperature(double celsius, int* returnSize){\ndouble *a = (double*)malloc(sizeof(double) * 2);\n    a[0] = celsius + 273.15;\n    a[1] = celsius * 1.80 + 32.00;\n    *returnSize = 2;\n    return a;\n}", "prefix": "double* convertTemperature(double celsius, int* returnSize"}
{"id": "527", "path": "output2\\c\\Easy\\527-number-of-unequal-triplets-in-array.c", "hypo_code": "int unequalTriplets(int* nums, int numsSize){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int unequalTriplets(int* nums, int numsSize"}
{"id": "528", "path": "output2\\c\\Easy\\528-minimum-cuts-to-divide-a-circle.c", "hypo_code": "int numberOfCuts(int n){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    if (n == 1) {\n        return 0;\n    }\n    if (n % 2 == 0) {\n        return 1 + numberOfCuts(n / 2);\n    }\n    return 2 + numberOfCuts(n / 2);\n}", "prefix": "int numberOfCuts(int n"}
{"id": "529", "path": "output2\\c\\Easy\\529-find-the-pivot-integer.c", "hypo_code": "int pivotInteger(int n){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int *a = (int*)calloc(n + 1, sizeof(int));\n    int *b = (int*)calloc(n + 1, sizeof(int));\n    for (i = 1; i <= n; i++) {\n        a[i] = a[i - 1] + i;\n    }\n    for (i = n; i > 0; i--) {\n        b[i] = b[i + 1] + i;\n    }\n    for (i = 1; i <= n; i++) {\n        if (a[i] == b[i]) {\n            return i;\n        }\n    }\n    return -1;\n}", "prefix": "int pivotInteger(int n"}
{"id": "530", "path": "output2\\c\\Easy\\530-circular-sentence.c", "hypo_code": "bool isCircularSentence(char * sentence){\n    int len = strlen(sentence);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int count = 0;\n    while(i < len){\n        if(sentence[i] == ' '){\n            i++;\n            continue;\n        }\n        j = i;\n        while(j < len && sentence[j] != ' '){\n            j++;\n        }\n        count++;\n        if(count > 1){\n            if(sentence[i] != sentence[k]){\n                return false;\n            }\n        }\n        k = j - 1;\n        i = j + 1;\n    }\n    return true;\n\n\n}", "prefix": "bool isCircularSentence(char * sentence"}
{"id": "531", "path": "output2\\c\\Easy\\531-maximum-value-of-a-string-in-an-array.c", "hypo_code": "int maximumValue(char ** strs, int strsSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int flag = 0;\n    int result = 0;\n    int temp = 0;\n    for(i = 0; i < strsSize - 1; i++){\n        for(j = 0; j < strsSize - i - 1; j++){\n            if(strlen(strs[j]) > strlen(strs[j + 1])){\n                char *temp = strs[j];\n                strs[j] = strs[j + 1];\n                strs[j + 1] = temp;\n            }\n        }\n    }\n    for(i = 0; i < strsSize; i++){\n        for(j = 0; j < strlen(strs[i]); j++){\n            if(strs[i][j] >= '0' && strs[i][j] <= '9'){\n                flag = 1;\n            }else{\n                flag = 0;\n                break;\n            }\n        }\n        if(flag == 1){\n            temp = atoi(strs[i]);\n        }else{\n            temp = strlen(strs[i]);\n        }\n        if(temp > result){\n            result = temp;\n        }\n    }\n    return result;\n\n}", "prefix": "int maximumValue(char ** strs, int strsSize"}
{"id": "532", "path": "output2\\c\\Easy\\532-delete-greatest-value-in-each-row.c", "hypo_code": "int deleteGreatestValue(int** grid, int gridSize, int* gridColSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int max = 0;\n    int result = 0;\n    int temp = 0;\n    int flag = 0;\n    int *arr = (int *)malloc(sizeof(int) * gridSize);\n    for(i = 0; i < gridSize; i++){\n        max = grid[i][0];\n        for(j = 0; j < gridColSize[i]; j++){\n            if(grid[i][j] > max){\n                max = grid[i][j];\n            }\n        }\n        arr[i] = max;\n    }\n    for(i = 0; i < gridSize; i++){\n        for(j = 0; j < gridColSize[i]; j++){\n            if(grid[i][j] == arr[i]){\n                for(k = j; k < gridColSize[i] - 1; k++){\n                    grid[i][k] = grid[i][k + 1];\n                }\n                gridColSize[i]--;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < gridSize; i++){\n        if(gridColSize[i] == 0){\n            flag = 1;\n        }\n    }\n    if(flag == 1){\n        return 0;\n    }\n    for(i = 0; i < gridSize; i++){\n        max = grid[i][0];\n        for(j = 0; j < gridColSize[i]; j++){\n            if(grid[i][j] > max){\n                max = grid[i][j];\n            }\n        }\n        result += max;\n    }\n    return result;\n\n}", "prefix": "int deleteGreatestValue(int** grid, int gridSize, int* gridColSize"}
{"id": "533", "path": "output2\\c\\Easy\\533-count-pairs-of-similar-strings.c", "hypo_code": "int similarPairs(char ** words, int wordsSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int count = 0;\n    int arr[26] = {0};\n    int arr1[26] = {0};\n    for(i = 0; i < wordsSize; i++){\n        for(j = 0; j < 26; j++){\n            arr[j] = 0;\n            arr1[j] = 0;\n        }\n        for(j = 0; j < strlen(words[i]); j++){\n            arr[words[i][j] - 'a']++;\n        }\n        for(j = i + 1; j < wordsSize; j++){\n            for(k = 0; k < strlen(words[j]); k++){\n                arr1[words[j][k] - 'a']++;\n            }\n            for(k = 0; k < 26; k++){\n                if(arr[k] != arr1[k]){\n                    break;\n                }\n            }\n            if(k == 26){\n                count++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int similarPairs(char ** words, int wordsSize"}
{"id": "534", "path": "output2\\c\\Easy\\534-maximum-enemy-forts-that-can-be-captured.c", "hypo_code": "int captureForts(int* forts, int fortsSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int max = 0;\n    int temp = 0;\n    int flag = 0;\n    for(i = 0; i < fortsSize; i++){\n        if(forts[i] == 1){\n            flag = 1;\n            for(j = i + 1; j < fortsSize; j++){\n                if(forts[j] == 0){\n                    temp++;\n                }\n                else if(forts[j] == 1){\n                    break;\n                }\n            }\n            for(k = i - 1; k >= 0; k--){\n                if(forts[k] == 0){\n                    temp++;\n                }\n                else if(forts[k] == 1){\n                    break;\n                }\n            }\n            max = max > temp ? max : temp;\n            temp = 0;\n        }\n    }\n    if(flag == 0){\n        return 0;\n    }\n    else{\n        return max;\n    }\n\n}", "prefix": "int captureForts(int* forts, int fortsSize"}
{"id": "535", "path": "output2\\c\\Easy\\535-shortest-distance-to-target-string-in-a-circular-array.c", "hypo_code": "int closetTarget(char ** words, int wordsSize, char * target, int startIndex){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int len = strlen(target);\n    int min = 0;\n    int temp = 0;\n    int flag = 0;\n    for(i = startIndex; i < wordsSize; i++){\n        if(strstr(words[i], target) != NULL){\n            min = i - startIndex;\n            flag = 1;\n            break;\n        }\n    }\n    for(i = startIndex - 1; i >= 0; i--){\n        if(strstr(words[i], target) != NULL){\n            temp = startIndex - i;\n            if(flag == 0){\n                min = temp;\n                flag = 1;\n            }\n            else{\n                min = min > temp ? temp : min;\n            }\n            break;\n        }\n    }\n    if(flag == 0){\n        return -1;\n    }\n    else{\n        return min;\n    }\n\n}", "prefix": "int closetTarget(char ** words, int wordsSize, char * target, int startIndex"}
{"id": "536", "path": "output2\\c\\Easy\\536-count-the-digits-that-divide-a-number.c", "hypo_code": "int countDigits(int num){\n    int count = 0;\n    int temp = num;\n    while(temp != 0){\n        temp /= 10;\n        count++;\n    }\n    return count;\n\n}", "prefix": "int countDigits(int num"}
{"id": "537", "path": "output2\\c\\Easy\\537-categorize-box-according-to-criteria.c", "hypo_code": "char * categorizeBox(int length, int width, int height, int mass){\n    if(length >= 10000 || width >= 10000 || height >= 10000 || length * width * height >= 1000000000){\n        if(mass >= 100){\n            return \"Both\";\n        }else{\n            return \"Bulky\";\n        }\n    }else{\n        if(mass >= 100){\n            return \"Heavy\";\n        }else{\n            return \"Neither\";\n        }\n    }\n\n}", "prefix": "char * categorizeBox(int length, int width, int height, int mass"}
{"id": "538", "path": "output2\\c\\Easy\\538-maximum-count-of-positive-integer-and-negative-integer.c", "hypo_code": "int maximumCount(int* nums, int numsSize){\n    int pos = 0;\n    int neg = 0;\n    int i = 0;\n    while(i < numsSize){\n        if(nums[i] > 0){\n            pos++;\n        }else if(nums[i] < 0){\n            neg++;\n        }\n        i++;\n    }\n    if(pos > neg){\n        return pos;\n    }else{\n        return neg;\n    }\n\n}", "prefix": "int maximumCount(int* nums, int numsSize"}
{"id": "539", "path": "output2\\c\\Easy\\539-difference-between-element-sum-and-digit-sum-of-an-array.c", "hypo_code": "int differenceOfSum(int* nums, int numsSize){\n    int elementSum = 0;\n    int digitSum = 0;\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    for(i = 0; i < numsSize; i++){\n        elementSum += nums[i];\n        temp = nums[i];\n        while(temp > 0){\n            digitSum += temp % 10;\n            temp /= 10;\n        }\n    }\n    return abs(elementSum - digitSum);\n\n}", "prefix": "int differenceOfSum(int* nums, int numsSize"}
{"id": "540", "path": "output2\\c\\Easy\\540-minimum-common-value.c", "hypo_code": "int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int i = 0;\n    int j = 0;\n    while(i < nums1Size && j < nums2Size){\n        if(nums1[i] == nums2[j]){\n            return nums1[i];\n        }else if(nums1[i] < nums2[j]){\n            i++;\n        }else{\n            j++;\n        }\n    }\n    return -1;\n\n}", "prefix": "int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "541", "path": "output2\\c\\Easy\\541-alternating-digit-sum.c", "hypo_code": "int alternateDigitSum(int n){\n    int sum = 0;\n    int sign = 1;\n    while(n > 0){\n        sum += sign * (n % 10);\n        sign *= -1;\n        n /= 10;\n    }\n    return sum;\n\n}", "prefix": "int alternateDigitSum(int n"}
{"id": "542", "path": "output2\\c\\Easy\\542-count-distinct-numbers-on-board.c", "hypo_code": "int distinctIntegers(int n){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(n, sizeof(int));\n    for (i = 0; i < n; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (n % i == 1) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int distinctIntegers(int n"}
{"id": "543", "path": "output2\\c\\Easy\\543-separate-the-digits-in-an-array.c", "hypo_code": "int* separateDigits(int* nums, int numsSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int *a = (int*)malloc(sizeof(int) * 10000);\n    memset(a, 0, sizeof(int) * 10000);\n    for (i = 0; i < numsSize; i++) {\n        while (nums[i] != 0) {\n            a[n] = nums[i] % 10;\n            n++;\n            nums[i] /= 10;\n        }\n    }\n    *returnSize = n;\n    return a;\n}", "prefix": "int* separateDigits(int* nums, int numsSize, int* returnSize"}
{"id": "544", "path": "output2\\c\\Easy\\544-take-gifts-from-the-richest-pile.c", "hypo_code": "long long pickGifts(int* gifts, int giftsSize, int k){\nlong long res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(giftsSize, sizeof(int));\n    for (i = 0; i < giftsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (gifts[i] - gifts[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "long long pickGifts(int* gifts, int giftsSize, int k"}
{"id": "545", "path": "output2\\c\\Easy\\545-find-the-array-concatenation-value.c", "hypo_code": "long long findTheArrayConcVal(int* nums, int numsSize){\nlong long res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "long long findTheArrayConcVal(int* nums, int numsSize"}
{"id": "546", "path": "output2\\c\\Easy\\546-maximum-difference-by-remapping-a-digit.c", "hypo_code": "int minMaxDifference(int num){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int minMaxDifference(int num"}
{"id": "547", "path": "output2\\c\\Easy\\547-merge-two-2d-arrays-by-summing-values.c", "hypo_code": "int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int **res = (int**)calloc(nums1Size + nums2Size, sizeof(int*));\n    int *col = (int*)calloc(nums1Size + nums2Size, sizeof(int));\n    *returnSize = 0;\n    for (i = 0; i < nums1Size; i++) {\n        for (j = 0; j < nums2Size; j++) {\n            if (nums1[i][0] == nums2[j][0]) {\n                nums1[i][1] += nums2[j][1];\n                nums2[j][1] = 0;\n            }\n        }\n    }\n    for (i = 0; i < nums1Size; i++) {\n        if (nums1[i][1] != 0) {\n            res[*returnSize] = (int*)calloc(2, sizeof(int));\n            col[*returnSize] = 2;\n            res[*returnSize][0] = nums1[i][0];\n            res[*returnSize][1] = nums1[i][1];\n            (*returnSize)++;\n        }\n    }\n    for (i = 0; i < nums2Size; i++) {\n        if (nums2[i][1] != 0) {\n            res[*returnSize] = (int*)calloc(2, sizeof(int));\n            col[*returnSize] = 2;\n            res[*returnSize][0] = nums2[i][0];\n            res[*returnSize][1] = nums2[i][1];\n            (*returnSize)++;\n        }\n    }\n    *returnColumnSizes = col;\n    return res;\n}", "prefix": "int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes"}
{"id": "548", "path": "output2\\c\\Easy\\548-left-and-right-sum-differences.c", "hypo_code": "int* leftRightDifference(int* nums, int numsSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int *a = (int*)malloc(sizeof(int) * numsSize);\n    memset(a, 0, sizeof(int) * numsSize);\n    int *b = (int*)malloc(sizeof(int) * numsSize);\n    memset(b, 0, sizeof(int) * numsSize);\n    for (i = 0; i < numsSize; i++) {\n        for (j = 0; j < i; j++) {\n            a[i] += nums[j];\n        }\n    }\n    for (i = 0; i < numsSize; i++) {\n        for (j = i + 1; j < numsSize; j++) {\n            b[i] += nums[j];\n        }\n    }\n    for (i = 0; i < numsSize; i++) {\n        a[i] = abs(a[i] - b[i]);\n    }\n    *returnSize = numsSize;\n    return a;\n}", "prefix": "int* leftRightDifference(int* nums, int numsSize, int* returnSize"}
{"id": "549", "path": "output2\\c\\Easy\\549-split-with-minimum-sum.c", "hypo_code": "int splitNum(int num){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int *a = (int*)calloc(10, sizeof(int));\n    while (num > 0) {\n        a[num % 10]++;\n        num /= 10;\n    }\n    for (i = 1; i < 10; i++) {\n        if (a[i] > 0) {\n            for (j = 0; j < a[i]; j++) {\n                if (k % 2 == 0) {\n                    m = m * 10 + i;\n                } else {\n                    n = n * 10 + i;\n                }\n                k++;\n            }\n        }\n    }\n    return m + n;\n}", "prefix": "int splitNum(int num"}
{"id": "550", "path": "output2\\c\\Easy\\550-pass-the-pillow.c", "hypo_code": "int passThePillow(int n, int time){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    return time % (n - 1) + 1;\n\n}", "prefix": "int passThePillow(int n, int time"}
{"id": "551", "path": "output2\\c\\Easy\\551-count-the-number-of-vowel-strings-in-range.c", "hypo_code": "int vowelStrings(char ** words, int wordsSize, int left, int right){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int vowelStrings(char ** words, int wordsSize, int left, int right"}
{"id": "552", "path": "output2\\c\\Easy\\552-distribute-money-to-maximum-children.c", "hypo_code": "int distMoney(int money, int children){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(money, sizeof(int));\n    for (i = 0; i < money; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int distMoney(int money, int children"}
{"id": "553", "path": "output2\\c\\Easy\\553-number-of-even-and-odd-bits.c", "hypo_code": "int* evenOddBit(int n, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int o = 0;\n    int *a = (int*)malloc(sizeof(int) * 2);\n    while (n > 0) {\n        if (n % 2 == 1) {\n            if (i % 2 == 0) {\n                a[0]++;\n            }\n            else {\n                a[1]++;\n            }\n        }\n        n /= 2;\n        i++;\n    }\n    *returnSize = 2;\n    return a;\n}", "prefix": "int* evenOddBit(int n, int* returnSize"}
{"id": "554", "path": "output2\\c\\Easy\\554-k-items-with-the-maximum-sum.c", "hypo_code": "int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(money, sizeof(int));\n    for (i = 0; i < money; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k"}
{"id": "555", "path": "output2\\c\\Easy\\555-form-smallest-number-from-two-digit-arrays.c", "hypo_code": "int minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int *c = (int*)calloc(10, sizeof(int));\n    int *d = (int*)calloc(10, sizeof(int));\n    for (i = 0; i < nums1Size; i++) {\n        c[nums1[i]]++;\n    }\n    for (i = 0; i < nums2Size; i++) {\n        d[nums2[i]]++;\n    }\n    for (i = 0; i < 10; i++) {\n        if (c[i] > 0 && d[i] > 0) {\n            return i;\n        }\n    }\n    return 0;\n}", "prefix": "int minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "556", "path": "output2\\c\\Easy\\556-find-the-longest-balanced-substring-of-a-binary-string.c", "hypo_code": "int findTheLongestBalancedSubstring(char * s){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(strlen(s), sizeof(int));\n    for (i = 0; i < strlen(s); i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (s[i] - s[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int findTheLongestBalancedSubstring(char * s"}
{"id": "557", "path": "output2\\c\\Easy\\557-prime-in-diagonal.c", "hypo_code": "int diagonalPrime(int** nums, int numsSize, int* numsColSize){\nint i = 0, j = 0, k = 0;\n    int max = 0;\n    int *dp = (int*)calloc(4000000, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        for (j = 0; j < numsColSize[i]; j++) {\n            if (dp[nums[i][j]] == 0) {\n                dp[nums[i][j]] = 1;\n                if (isPrime(nums[i][j]) == 1) {\n                    if (nums[i][j] > max) {\n                        max = nums[i][j];\n                    }\n                }\n            }\n        }\n    }\n    return max;\n}", "prefix": "int diagonalPrime(int** nums, int numsSize, int* numsColSize"}
{"id": "565", "path": "output2\\c\\Easy\\565-find-the-width-of-columns-of-a-grid.c", "hypo_code": "int* findColumnWidth(int** grid, int gridSize, int* gridColSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int *a = (int*)malloc(sizeof(int) * (*gridColSize));\n    for (i = 0; i < *gridColSize; i++) {\n        k = 0;\n        for (j = 0; j < gridSize; j++) {\n            if (grid[j][i] < 0) {\n                k++;\n            }\n            l = grid[j][i];\n            if (l < 0) {\n                l *= -1;\n            }\n            while (l > 0) {\n                l /= 10;\n                k++;\n            }\n        }\n        a[i] = k;\n    }\n    *returnSize = *gridColSize;\n    return a;\n}", "prefix": "int* findColumnWidth(int** grid, int gridSize, int* gridColSize, int* returnSize"}
{"id": "566", "path": "output2\\c\\Easy\\566-row-with-maximum-ones.c", "hypo_code": "int* rowAndMaximumOnes(int** mat, int matSize, int* matColSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int *a = (int*)malloc(sizeof(int) * 2);\n    int *c = (int*)calloc(matSize, sizeof(int));\n    for (i = 0; i < matSize; i++) {\n        for (j = 0; j < matColSize[i]; j++) {\n            if (mat[i][j] == 1) {\n                c[i]++;\n            }\n        }\n    }\n    for (i = 0; i < matSize; i++) {\n        if (c[i] > n) {\n            n = c[i];\n            m = i;\n        }\n    }\n    *returnSize = 2;\n    a[0] = m;\n    a[1] = n;\n    return a;\n}", "prefix": "int* rowAndMaximumOnes(int** mat, int matSize, int* matColSize, int* returnSize"}
{"id": "567", "path": "output2\\c\\Easy\\567-find-the-maximum-divisibility-score.c", "hypo_code": "int maxDivScore(int* nums, int numsSize, int* divisors, int divisorsSize){\nint i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int maxDivScore(int* nums, int numsSize, int* divisors, int divisorsSize"}
{"id": "569", "path": "output2\\c\\Easy\\569-calculate-delayed-arrival-time.c", "hypo_code": "int findDelayedArrivalTime(int arrivalTime, int delayedTime){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    if (arrivalTime + delayedTime < 24) {\n        return arrivalTime + delayedTime;\n    }\n    return (arrivalTime + delayedTime) % 24;\n}", "prefix": "int findDelayedArrivalTime(int arrivalTime, int delayedTime"}
{"id": "570", "path": "output2\\c\\Easy\\570-sum-multiples.c", "hypo_code": "int sumOfMultiples(int n){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    for (i = 1; i <= n; i++) {\n        if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {\n            m += i;\n        }\n    }\n    return m;\n}", "prefix": "int sumOfMultiples(int n"}
{"id": "571", "path": "output2\\c\\Easy\\571-maximum-sum-with-exactly-k-elements.c", "hypo_code": "int maximizeSum(int* nums, int numsSize, int k){\nint res = 0;\n    int i = 0;\n    int j = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int maximizeSum(int* nums, int numsSize, int k"}
{"id": "572", "path": "output2\\c\\Easy\\572-determine-the-winner-of-a-bowling-game.c", "hypo_code": "int isWinner(int* player1, int player1Size, int* player2, int player2Size){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    for (i = 0; i < player1Size; i++) {\n        if (i >= 2 && player1[i] == 10 && player1[i - 1] == 10) {\n            k += 2 * player1[i];\n        } else if (i >= 1 && player1[i] == 10 && player1[i - 1] == 10) {\n            k += 2 * player1[i];\n        } else {\n            k += player1[i];\n        }\n    }\n    for (i = 0; i < player2Size; i++) {\n        if (i >= 2 && player2[i] == 10 && player2[i - 1] == 10) {\n            l += 2 * player2[i];\n        } else if (i >= 1 && player2[i] == 10 && player2[i - 1] == 10) {\n            l += 2 * player2[i];\n        } else {\n            l += player2[i];\n        }\n    }\n    if (k > l) {\n        return 1;\n    } else if (k < l) {\n        return 2;\n    } else {\n        return 0;\n    }\n}", "prefix": "int isWinner(int* player1, int player1Size, int* player2, int player2Size"}
{"id": "576", "path": "output2\\c\\Easy\\576-find-the-distinct-difference-array.c", "hypo_code": "int* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int *a = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        for (j = i; j < numsSize; j++) {\n            for (k = i; k < j; k++) {\n                if (nums[j] == nums[k]) {\n                    break;\n                }\n            }\n            if (k == j) {\n                a[i]++;\n            }\n        }\n    }\n    for (i = 0; i < numsSize - 1; i++) {\n        a[i] -= a[i + 1];\n    }\n    *returnSize = numsSize;\n    return a;\n}", "prefix": "int* distinctDifferenceArray(int* nums, int numsSize, int* returnSize"}
{"id": "578", "path": "output2\\c\\Easy\\578-number-of-senior-citizens.c", "hypo_code": "int countSeniors(char ** details, int detailsSize){\n  int res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(detailsSize, sizeof(int));\n    for (i = 0; i < detailsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (details[i] - details[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int countSeniors(char ** details, int detailsSize"}
{"id": "579", "path": "output2\\c\\Easy\\579-find-the-losers-of-the-circular-game.c", "hypo_code": "int* circularGameLosers(int n, int k, int* returnSize){\nint i = 0;\n    int j = 0;\n    int *res = (int*)calloc(n, sizeof(int));\n    *returnSize = n;\n    for (i = 0; i < n; i++) {\n        res[i] = i + 1;\n    }\n    int idx = 0;\n    while (1) {\n        int cnt = 0;\n        for (i = idx; i < n; i++) {\n            if (res[i] != 0) {\n                cnt++;\n            }\n            if (cnt == k) {\n                res[i] = 0;\n                break;\n            }\n        }\n        if (i == n) {\n            for (i = 0; i < n; i++) {\n                if (res[i] != 0) {\n                    cnt++;\n                }\n                if (cnt == k) {\n                    res[i] = 0;\n                    break;\n                }\n            }\n        }\n        if (cnt == n - 1) {\n            break;\n        }\n        idx = i;\n    }\n    int *ans = (int*)calloc(n - 1, sizeof(int));\n    int ansIdx = 0;\n    for (i = 0; i < n; i++) {\n        if (res[i] != 0) {\n            ans[ansIdx] = res[i];\n            ansIdx++;\n        }\n    }\n    *returnSize = ansIdx;\n    return ans;\n}", "prefix": "int* circularGameLosers(int n, int k, int* returnSize"}
{"id": "581", "path": "output2\\c\\Easy\\581-minimum-string-length-after-removing-substrings.c", "hypo_code": "int minLength(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = strlen(s);\n    int res = 0;\n    int *dp = (int*)calloc(n, sizeof(int));\n    for (i = 0; i < n; i++) {\n        dp[i] = 1;\n        if (i > 0 && s[i] == 'B' && s[i - 1] == 'A') {\n            dp[i] = 0;\n            if (i > 1) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        if (i > 0 && s[i] == 'D' && s[i - 1] == 'C') {\n            dp[i] = 0;\n            if (i > 1) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        if (dp[i] == 0) {\n            dp[i] = dp[i - 1];\n        }\n    }\n    res = dp[n - 1];\n    free(dp);\n    return res;\n}", "prefix": "int minLength(char * s"}
{"id": "582", "path": "output2\\c\\Easy\\582-lexicographically-smallest-palindrome.c", "hypo_code": "char * makeSmallestPalindrome(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = strlen(s);\n    int *a = (int*)malloc(sizeof(int) * n);\n    memset(a, 0, sizeof(int) * n);\n    for (i = 0; i < n / 2; i++) {\n        if (s[i] != s[n - 1 - i]) {\n            break;\n        }\n    }\n    if (i == n / 2) {\n        return s;\n    }\n    for (i = 0; i < n / 2; i++) {\n        if (s[i] == s[n - 1 - i]) {\n            continue;\n        }\n        break;\n    }\n    if (i == n / 2) {\n        s[n / 2] = 'a';\n        return s;\n    }\n    for (i = 0; i < n / 2; i++) {\n        if (s[i] == s[n - 1 - i]) {\n            continue;\n        }\n        a[i] = 1;\n        break;\n    }\n    if (i == n / 2) {\n        s[n / 2] = 'a';\n        return s;\n    }\n    for (i = 0; i < n / 2; i++) {\n        if (a[i] == 0) {\n            continue;\n        }\n        s[i] = s[n - 1 - i];\n        break;\n    }\n    return s;\n}", "prefix": "char * makeSmallestPalindrome(char * s"}
{"id": "585", "path": "output2\\c\\Easy\\585-buy-two-chocolates.c", "hypo_code": "int buyChoco(int* prices, int pricesSize, int money){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int *a = (int*)calloc(101, sizeof(int));\n    for (i = 0; i < pricesSize; i++) {\n        a[prices[i]]++;\n    }\n    for (i = 1; i <= 100; i++) {\n        if (a[i] != 0) {\n            n = i;\n            break;\n        }\n    }\n    for (i = 100; i >= 1; i--) {\n        if (a[i] != 0) {\n            o = i;\n            break;\n        }\n    }\n    if (n + o > money) {\n        return money;\n    }\n    return money - n - o;\n}", "prefix": "int buyChoco(int* prices, int pricesSize, int money"}
{"id": "586", "path": "output2\\c\\Easy\\586-remove-trailing-zeros-from-a-string.c", "hypo_code": "char * removeTrailingZeros(char * num){\nint i = 0, j = 0, k = 0;\n    char *a = (char*)calloc(1001, sizeof(char));\n    for (i = 0; i < strlen(num); i++) {\n        if (num[i] != '0') {\n            a[j++] = num[i];\n        }\n    }\n    if (j == 0) {\n        a[0] = '0';\n        return a;\n    }\n    a[j] = '\\0';\n    return a;\n}", "prefix": "char * removeTrailingZeros(char * num"}
{"id": "588", "path": "output2\\c\\Easy\\588-minimize-string-length.c", "hypo_code": "int minimizedStringLength(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = strlen(s);\n    int *a = (int*)malloc(sizeof(int) * 26);\n    memset(a, 0, sizeof(int) * 26);\n    int *b = (int*)malloc(sizeof(int) * 26);\n    memset(b, 0, sizeof(int) * 26);\n    for (i = 0; i < n; i++) {\n        a[s[i] - 'a']++;\n    }\n    for (i = 0; i < 26; i++) {\n        if (a[i] == 0) {\n            continue;\n        }\n        b[a[i] - 1]++;\n    }\n    for (i = 0; i < 26; i++) {\n        if (b[i] == 0) {\n            continue;\n        }\n        if (b[i] == 1) {\n            m++;\n        }\n        if (b[i] > 2) {\n            m += b[i] - 2;\n        }\n    }\n    return n - m;\n}", "prefix": "int minimizedStringLength(char * s"}
{"id": "589", "path": "output2\\c\\Easy\\589-semi-ordered-permutation.c", "hypo_code": "int semiOrderedPermutation(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    for (i = 0; i < numsSize; i++) {\n        if (nums[i] == 1) {\n            k = i;\n        }\n        if (nums[i] == numsSize) {\n            l = i;\n        }\n    }\n    if (k == 0 && l == numsSize - 1) {\n        return 0;\n    }\n    if (k == numsSize - 1 && l == 0) {\n        return 0;\n    }\n    if (k == 0 || l == numsSize - 1) {\n        return 1;\n    }\n    return 2;\n}", "prefix": "int semiOrderedPermutation(int* nums, int numsSize"}
{"id": "595", "path": "output2\\c\\Easy\\595-check-if-the-number-is-fascinating.c", "hypo_code": "bool isFascinating(int n){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int x = n;\n    int y = 2 * n;\n    int z = 3 * n;\n    int *p = (int*)malloc(sizeof(int) * 10);\n    memset(p, 0, sizeof(int) * 10);\n    while (x > 0) {\n        p[x % 10]++;\n        x /= 10;\n    }\n    while (y > 0) {\n        p[y % 10]++;\n        y /= 10;\n    }\n    while (z > 0) {\n        p[z % 10]++;\n        z /= 10;\n    }\n    for (i = 1; i < 10; i++) {\n        if (p[i] == 0) {\n            return false;\n        }\n        if (p[i] > 1) {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool isFascinating(int n"}
{"id": "596", "path": "output2\\c\\Easy\\596-neither-minimum-nor-maximum.c", "hypo_code": "int findNonMinOrMax(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int max = 0;\n    int min = 0;\n    for (i = 0; i < numsSize; i++) {\n        if (nums[i] > max) {\n            max = nums[i];\n            m = i;\n        }\n        if (nums[i] < min) {\n            min = nums[i];\n            l = i;\n        }\n    }\n    for (i = 0; i < numsSize; i++) {\n        if (i != m && i != l) {\n            return nums[i];\n        }\n    }\n    return -1;\n}", "prefix": "int findNonMinOrMax(int* nums, int numsSize"}
{"id": "597", "path": "output2\\c\\Easy\\597-total-distance-traveled.c", "hypo_code": "int distanceTraveled(int mainTank, int additionalTank){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(mainTank + 1, sizeof(int));\n    dp[mainTank] = additionalTank;\n    for (i = 0; i < mainTank; i++) {\n        for (j = 0; j < mainTank; j++) {\n            if (dp[j] >= 5) {\n                dp[j] -= 5;\n                dp[j + 1] = dp[j] + 1;\n            }\n        }\n    }\n    for (i = 0; i <= mainTank; i++) {\n        if (dp[i] != 0) {\n            return i * 10;\n        }\n    }\n    return i * 10;\n}", "prefix": "int distanceTraveled(int mainTank, int additionalTank"}
{"id": "598", "path": "output2\\c\\Easy\\598-find-maximum-number-of-string-pairs.c", "hypo_code": "int maximumNumberOfStringPairs(char ** words, int wordsSize){\n\n}", "prefix": "int maximumNumberOfStringPairs(char ** words, int wordsSize"}
{"id": "599", "path": "output2\\c\\Easy\\599-number-of-beautiful-pairs.c", "hypo_code": "int countBeautifulPairs(int* nums, int numsSize){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int countBeautifulPairs(int* nums, int numsSize"}
{"id": "600", "path": "output2\\c\\Easy\\600-longest-even-odd-subarray-with-threshold.c", "hypo_code": "int longestAlternatingSubarray(int* nums, int numsSize, int threshold){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int longestAlternatingSubarray(int* nums, int numsSize, int threshold"}
{"id": "601", "path": "output2\\c\\Easy\\601-longest-alternating-subarray.c", "hypo_code": "int alternatingSubarray(int* nums, int numsSize){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(numsSize, sizeof(int));\n    for (i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[i] - nums[j] == diff) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int alternatingSubarray(int* nums, int numsSize"}
{"id": "602", "path": "output2\\c\\Easy\\602-find-the-maximum-achievable-number.c", "hypo_code": "int theMaximumAchievableX(int num, int t){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    for (i = 0; i < t; i++) {\n        if (num % 2 == 0) {\n            num /= 2;\n        } else {\n            num = (num + 1) / 2;\n        }\n    }\n    return num;\n}", "prefix": "int theMaximumAchievableX(int num, int t"}
{"id": "603", "path": "output2\\c\\Easy\\603-sum-of-squares-of-special-elements.c", "hypo_code": "int sumOfSquares(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int res = 0;\n    for (i = 1; i <= numsSize; i++) {\n        if (numsSize % i == 0) {\n            res += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return res;\n}", "prefix": "int sumOfSquares(int* nums, int numsSize"}
{"id": "604", "path": "output2\\c\\Easy\\604-check-if-array-is-good.c", "hypo_code": "bool isGood(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int res = 0;\n    for (i = 1; i <= numsSize; i++) {\n        if (numsSize % i == 0) {\n            res += nums[i - 1] * nums[i - 1];\n        }\n    }\n    return res;\n}", "prefix": "bool isGood(int* nums, int numsSize"}
{"id": "605", "path": "output2\\c\\Easy\\605-split-strings-by-separator.c", "hypo_code": "char ** splitWordsBySeparator(char ** words, int wordsSize, char separator, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int *x = (int*)malloc(sizeof(int) * wordsSize);\n    char **res = (char**)malloc(sizeof(char*) * wordsSize * 2);\n    memset(x, 0, sizeof(int) * wordsSize);\n    memset(res, 0, sizeof(char*) * wordsSize * 2);\n    for (i = 0; i < wordsSize; i++) {\n        n = strlen(words[i]);\n        for (j = 0; j < n; j++) {\n            if (words[i][j] == separator) {\n                x[i]++;\n            }\n        }\n    }\n    for (i = 0; i < wordsSize; i++) {\n        if (x[i] == 0) {\n            res[a++] = words[i];\n            continue;\n        }\n        n = strlen(words[i]);\n        res[a] = (char*)malloc(sizeof(char) * (n + 1));\n        memset(res[a], 0, sizeof(char) * (n + 1));\n        for (j = 0; j < n; j++) {\n            if (words[i][j] == separator) {\n                res[a++][b] = '\\0';\n                b = 0;\n                continue;\n            }\n            res[a][b++] = words[i][j];\n        }\n        res[a++][b] = '\\0';\n        b = 0;\n    }\n    *returnSize = a;\n    return res;\n}", "prefix": "char ** splitWordsBySeparator(char ** words, int wordsSize, char separator, int* returnSize"}
{"id": "606", "path": "output2\\c\\Easy\\606-number-of-employees-who-met-the-target.c", "hypo_code": "int numberOfEmployeesWhoMetTarget(int* hours, int hoursSize, int target){\nint res = 0;\n    int i = 0, j = 0, k = 0;\n    int *dp = (int*)calloc(hoursSize, sizeof(int));\n    for (i = 0; i < hoursSize; i++) {\n        if (hours[i] >= target) {\n            res++;\n        }\n        dp[i] = hours[i] >= target ? 1 : 0;\n        for (j = 0; j < i; j++) {\n            if (hours[i] + hours[j] >= target) {\n                dp[i] = dp[j] + 1;\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n}", "prefix": "int numberOfEmployeesWhoMetTarget(int* hours, int hoursSize, int target"}
{"id": "607", "path": "output2\\c\\Easy\\607-account-balance-after-rounded-purchase.c", "hypo_code": "int accountBalanceAfterPurchase(int purchaseAmount){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    if (purchaseAmount % 10 == 0) {\n        return 100 - purchaseAmount;\n    }\n    k = purchaseAmount / 10;\n    l = k * 10;\n    if (purchaseAmount - l > 5) {\n        k++;\n    }\n    return 100 - k * 10;\n}", "prefix": "int accountBalanceAfterPurchase(int purchaseAmount"}
{"id": "608", "path": "output2\\c\\Easy\\608-faulty-keyboard.c", "hypo_code": "char * finalString(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = strlen(s);\n    char *res = (char*)malloc(sizeof(char) * (n + 1));\n    memset(res, 0, sizeof(char) * (n + 1));\n    for (i = 0; i < n; i++) {\n        if (s[i] == 'i') {\n            for (j = 0; j < (i + 1) / 2; j++) {\n                res[j] = s[i - j - 1];\n            }\n            for (; j < i + 1; j++) {\n                res[j] = s[j];\n            }\n            continue;\n        }\n        res[i] = s[i];\n    }\n    return res;\n}", "prefix": "char * finalString(char * s"}
{"id": "609", "path": "output2\\c\\Easy\\609-max-pair-sum-in-an-array.c", "hypo_code": "int maxSum(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int res = 0;\n    for (i = 0; i < numsSize; i++) {\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[i] == nums[j]) {\n                res = nums[i] + nums[j];\n            }\n        }\n    }\n    return res;\n}", "prefix": "int maxSum(int* nums, int numsSize"}
{"id": "610", "path": "output2\\c\\Medium\\610-add-two-numbers.c", "hypo_code": "struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\n    struct ListNode* result = NULL;\n    struct ListNode* temp = NULL;\n    struct ListNode* prev = NULL;\n    int carry = 0;\n    int sum = 0;\n    while(l1 != NULL || l2 != NULL){\n        sum = carry + (l1 ? l1->val : 0) + (l2 ? l2->val : 0);\n        carry = (sum >= 10) ? 1 : 0;\n        sum = sum % 10;\n        temp = (struct ListNode*)malloc(sizeof(struct ListNode));\n        temp->val = sum;\n        temp->next = NULL;\n        if(result == NULL){\n            result = temp;\n        }\n        else{\n            prev->next = temp;\n        }\n        prev = temp;\n        if(l1){\n            l1 = l1->next;\n        }\n        if(l2){\n            l2 = l2->next;\n        }\n    }\n    if(carry > 0){\n        temp->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n        temp->next->val = carry;\n        temp->next->next = NULL;\n    }\n    return result;\n\n}", "prefix": "struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2"}
{"id": "611", "path": "output2\\c\\Medium\\611-longest-substring-without-repeating-characters.c", "hypo_code": "int lengthOfLongestSubstring(char * s){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int max = 0;\n    int count = 0;\n    int len = strlen(s);\n    int flag = 0;\n    for(i = 0; i < len; i++){\n        for(j = i; j < len; j++){\n            for(k = i; k < j; k++){\n                if(s[k] == s[j]){\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag == 1){\n                flag = 0;\n                break;\n            }\n            count++;\n        }\n        if(count > max){\n            max = count;\n        }\n        count = 0;\n    }\n    return max;\n\n}", "prefix": "int lengthOfLongestSubstring(char * s"}
{"id": "612", "path": "output2\\c\\Medium\\612-longest-palindromic-substring.c", "hypo_code": "char * longestPalindrome(char * s){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int len = strlen(s);\n    int max = 0;\n    int count = 0;\n    int flag = 0;\n    char* result = NULL;\n    for(i = 0; i < len; i++){\n        for(j = i; j < len; j++){\n            for(k = i; k < j; k++){\n                if(s[k] == s[j]){\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag == 1){\n                flag = 0;\n                break;\n            }\n            count++;\n        }\n        if(count > max){\n            max = count;\n            result = (char*)malloc(sizeof(char) * (max + 1));\n            for(k = 0; k < max; k++){\n                result[k] = s[i + k];\n            }\n            result[k] = '\\0';\n        }\n        count = 0;\n    }\n    return result;\n\n}", "prefix": "char * longestPalindrome(char * s"}
{"id": "613", "path": "output2\\c\\Medium\\613-zigzag-conversion.c", "hypo_code": "char * convert(char * s, int numRows){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int len = strlen(s);\n    int flag = 0;\n    int count = 0;\n    int max = 0;\n    char* result = NULL;\n    if(numRows == 1){\n        return s;\n    }\n    for(i = 0; i < numRows; i++){\n        for(j = i; j < len; j += (2 * numRows - 2)){\n            if(i == 0 || i == numRows - 1){\n                count++;\n            }\n            else{\n                if(flag == 0){\n                    count++;\n                    flag = 1;\n                }\n                else{\n                    if(j + (numRows - i - 1) * 2 < len){\n                        count += 2;\n                    }\n                    else{\n                        count++;\n                    }\n                    flag = 0;\n                }\n            }\n        }\n        if(count > max){\n            max = count;\n        }\n        count = 0;\n        flag = 0;\n    }\n    result = (char*)malloc(sizeof(char) * (max + 1));\n    for(i = 0; i < numRows; i++){\n        for(j = i; j < len; j += (2 * numRows - 2)){\n            result[k++] = s[j];\n            if(i == 0 || i == numRows - 1){\n                continue;\n            }\n            else{\n                if(flag == 0){\n                    flag = 1;\n                }\n                else{\n                    if(j + (numRows - i - 1) * 2 < len){\n                        result[k++] = s[j + (numRows - i - 1) * 2];\n                    }\n                    flag = 0;\n                }\n            }\n        }\n        flag = 0;\n    }\n    result[k] = '\\0';\n    return result;\n\n}", "prefix": "char * convert(char * s, int numRows"}
{"id": "614", "path": "output2\\c\\Medium\\614-reverse-integer.c", "hypo_code": "int reverse(int x){\n    int result = 0;\n    int temp = 0;\n    while(x != 0){\n        temp = x % 10;\n        x = x / 10;\n        if(result > INT_MAX / 10 || (result == INT_MAX / 10 && temp > 7)){\n            return 0;\n        }\n        if(result < INT_MIN / 10 || (result == INT_MIN / 10 && temp < -8)){\n            return 0;\n        }\n        result = result * 10 + temp;\n    }\n    return result;\n\n}", "prefix": "int reverse(int x"}
{"id": "615", "path": "output2\\c\\Medium\\615-string-to-integer-atoi.c", "hypo_code": "int myAtoi(char * s){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int len = strlen(s);\n    int flag = 0;\n    int sign = 1;\n    int result = 0;\n    int temp = 0;\n    for(i = 0; i < len; i++){\n        if(s[i] == ' '){\n            continue;\n        }\n        else if(s[i] == '-'){\n            sign = -1;\n            i++;\n            break;\n        }\n        else if(s[i] == '+'){\n            sign = 1;\n            i++;\n            break;\n        }\n        else if(s[i] >= '0' && s[i] <= '9'){\n            break;\n        }\n        else{\n            return 0;\n        }\n    }\n    for(j = i; j < len; j++){\n        if(s[j] >= '0' && s[j] <= '9'){\n            temp = s[j] - '0';\n            if(result > INT_MAX / 10 || (result == INT_MAX / 10 && temp > 7)){\n                if(sign == 1){\n                    return INT_MAX;\n                }\n                else{\n                    return INT_MIN;\n                }\n            }\n            result = result * 10 + temp;\n        }\n        else{\n            break;\n        }\n    }\n    return result * sign;\n\n}", "prefix": "int myAtoi(char * s"}
{"id": "616", "path": "output2\\c\\Medium\\616-container-with-most-water.c", "hypo_code": "int maxArea(int* height, int heightSize){\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    int area = 0;\n    for(i = 0; i < heightSize; i++){\n        for(j = i + 1; j < heightSize; j++){\n            area = (j - i) * (height[i] < height[j] ? height[i] : height[j]);\n            if(area > max){\n                max = area;\n            }\n        }\n    }\n    return max;\n\n}", "prefix": "int maxArea(int* height, int heightSize"}
{"id": "617", "path": "output2\\c\\Medium\\617-integer-to-roman.c", "hypo_code": "char * intToRoman(int num){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int len = 0;\n    int count = 0;\n    char* result = NULL;\n    char* roman = \"IVXLCDM\";\n    int value[7] = {1, 5, 10, 50, 100, 500, 1000};\n    for(i = 6; i >= 0; i--){\n        count = num / value[i];\n        num = num % value[i];\n        if(count == 0){\n            continue;\n        }\n        if(count == 4){\n            if(i % 2 == 0){\n                len += 2;\n            }\n            else{\n                len += 3;\n            }\n        }\n        else{\n            len += count;\n        }\n    }\n    result = (char*)malloc(sizeof(char) * (len + 1));\n    for(i = 6; i >= 0; i--){\n        count = num / value[i];\n        num = num % value[i];\n        if(count == 0){\n            continue;\n        }\n        if(count == 4){\n            if(i % 2 == 0){\n                result[k++] = roman[i];\n                result[k++] = roman[i + 1];\n            }\n            else{\n                result[k++] = roman[i - 1];\n                result[k++] = roman[i + 1];\n            }\n        }\n        else{\n            for(j = 0; j < count; j++){\n                result[k++] = roman[i];\n            }\n        }\n    }\n    result[k] = '\\0';\n    return result;\n\n}", "prefix": "char * intToRoman(int num"}
{"id": "618", "path": "output2\\c\\Medium\\618-3sum.c", "hypo_code": "int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int count = 0;\n    int** result = NULL;\n    *returnSize = 0;\n    *returnColumnSizes = (int*)malloc(sizeof(int) * numsSize);\n    for(i = 0; i < numsSize; i++){\n        for(j = i + 1; j < numsSize; j++){\n            for(k = j + 1; k < numsSize; k++){\n                if(nums[i] + nums[j] + nums[k] == 0){\n                    count++;\n                    *returnSize = count;\n                    result = (int**)realloc(result, sizeof(int*) * count);\n                    result[count - 1] = (int*)malloc(sizeof(int) * 3);\n                    result[count - 1][0] = nums[i];\n                    result[count - 1][1] = nums[j];\n                    result[count - 1][2] = nums[k];\n                    (*returnColumnSizes)[count - 1] = 3;\n                }\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes"}
{"id": "619", "path": "output2\\c\\Medium\\619-3sum-closest.c", "hypo_code": "int threeSumClosest(int* nums, int numsSize, int target){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int sum = 0;\n    int min = 0;\n    int result = 0;\n    int flag = 0;\n    for(i = 0; i < numsSize; i++){\n        for(j = i + 1; j < numsSize; j++){\n            for(k = j + 1; k < numsSize; k++){\n                sum = nums[i] + nums[j] + nums[k];\n                if(flag == 0){\n                    min = abs(sum - target);\n                    result = sum;\n                    flag = 1;\n                }\n                if(abs(sum - target) < min){\n                    min = abs(sum - target);\n                    result = sum;\n                }\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int threeSumClosest(int* nums, int numsSize, int target"}
{"id": "620", "path": "output2\\c\\Medium\\620-letter-combinations-of-a-phone-number.c", "hypo_code": "char ** letterCombinations(char * digits, int* returnSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int len = strlen(digits);\n    int count = 0;\n    int max = 0;\n    char** result = NULL;\n    char* temp = NULL;\n    char* temp2 = NULL;\n    char* temp3 = NULL;\n    char* temp4 = NULL;\n    char* temp5 = NULL;\n    char* temp6 = NULL;\n    char* temp7 = NULL;\n    char* temp8 = NULL;\n    char* temp9 = NULL;\n    char* temp10 = NULL;\n    char* temp11 = NULL;\n    char* temp12 = NULL;\n    char* temp13 = NULL;\n    char* temp14 = NULL;\n    char* temp15 = NULL;\n    char* temp16 = NULL;\n    char* temp17 = NULL;\n    char* temp18 = NULL;\n    char* temp19 = NULL;\n    char* temp20 = NULL;\n    char* temp21 = NULL;\n    char* temp22 = NULL;\n    char* temp23 = NULL;\n    char* temp24 = NULL;\n    char* temp25 = NULL;\n    char* temp26 = NULL;\n    char* temp27 = NULL;\n    char* temp28 = NULL;\n    char* temp29 = NULL;\n    char* temp30 = NULL;\n    char* temp31 = NULL;\n    char* temp32 = NULL;\n    char* temp33 = NULL;\n    char* temp34 = NULL;\n    char* temp35 = NULL;\n    char* temp36 = NULL;\n    char* temp37 = NULL;\n    char* temp38 = NULL;\n    char* temp39 = NULL;\n    char* temp40 = NULL;\n    char* temp41 = NULL;\n    char* temp42 = NULL;\n    char* temp43 = NULL;\n    char* temp44 = NULL;\n    char* temp45 = NULL;\n    char* temp46 = NULL;\n    char* temp47 = NULL;\n    char* temp48 = NULL;\n    char* temp49 = NULL;\n    char* temp50 = NULL;\n    char* temp51 = NULL;\n    char* temp52 = NULL;\n    char* temp53 = NULL;\n    char* temp54 = NULL;\n    char* temp55 = NULL;\n    char* temp56 = NULL;\n    char* temp57 = NULL;\n                   \n\n}", "prefix": "char ** letterCombinations(char * digits, int* returnSize"}
{"id": "621", "path": "output2\\c\\Medium\\621-4sum.c", "hypo_code": "int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n}", "prefix": "int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes"}
{"id": "622", "path": "output2\\c\\Medium\\622-remove-nth-node-from-end-of-list.c", "hypo_code": "struct ListNode* removeNthFromEnd(struct ListNode* head, int n){\n    struct ListNode* temp = head;\n    struct ListNode* prev = NULL;\n    int count = 0;\n    while(temp != NULL){\n        count++;\n        temp = temp->next;\n    }\n    if(count == n){\n        head = head->next;\n        return head;\n    }\n    temp = head;\n    while(temp != NULL){\n        if(count == n){\n            prev->next = temp->next;\n            return head;\n        }\n        count--;\n        prev = temp;\n        temp = temp->next;\n    }\n    return head;\n\n}", "prefix": "struct ListNode* removeNthFromEnd(struct ListNode* head, int n"}
{"id": "623", "path": "output2\\c\\Medium\\623-generate-parentheses.c", "hypo_code": "char ** generateParenthesis(int n, int* returnSize){\n         \n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int count = 0;\n    int max = 0;\n    char** result = NULL;\n    char* temp = NULL;\n    char* temp2 = NULL;\n    char* temp3 = NULL;\n    char* temp4 = NULL;\n    char* temp5 = NULL;\n    char* temp6 = NULL;\n    char* temp7 = NULL;\n    char* temp8 = NULL;\n    char* temp9 = NULL;\n    char* temp10 = NULL;\n    char* temp11 = NULL;\n    char* temp12 = NULL;\n    char* temp13 = NULL;\n    char* temp14 = NULL;\n    char* temp15 = NULL;\n    char* temp16 = NULL;\n    char* temp17 = NULL;\n    char* temp18 = NULL;\n    char* temp19 = NULL;\n    char* temp20 = NULL;\n    char* temp21 = NULL;\n    char* temp22 = NULL;\n    char* temp23 = NULL;\n    char* temp24 = NULL;\n    char* temp25 = NULL;\n    char* temp26 = NULL;\n    char* temp27 = NULL;\n    char* temp28 = NULL;\n    char* temp29 = NULL;\n    char* temp30 = NULL;\n    char* temp31 = NULL;\n    char* temp32 = NULL;\n    char* temp33 = NULL;\n    char* temp34 = NULL;\n    char* temp35 = NULL;\n    char* temp36 = NULL;\n    char* temp37 = NULL;\n    char* temp38 = NULL;\n}", "prefix": "char ** generateParenthesis(int n, int* returnSize"}
{"id": "624", "path": "output2\\c\\Medium\\624-swap-nodes-in-pairs.c", "hypo_code": "struct ListNode* swapPairs(struct ListNode* head){\n    struct ListNode* temp = head;\n    struct ListNode* prev = NULL;\n    struct ListNode* next = NULL;\n    int count = 0;\n    while(temp != NULL){\n        count++;\n        temp = temp->next;\n    }\n    if(count == 1){\n        return head;\n    }\n    temp = head;\n    while(temp != NULL){\n        if(count == 1){\n            return head;\n        }\n        if(count % 2 == 0){\n            next = temp->next;\n            temp->next = prev;\n            prev->next = next;\n            if(count == 2){\n                head = temp;\n            }\n            temp = next;\n        }\n        else{\n            prev = temp;\n            temp = temp->next;\n        }\n        count--;\n    }\n    return head;\n\n}", "prefix": "struct ListNode* swapPairs(struct ListNode* head"}
{"id": "625", "path": "output2\\c\\Medium\\625-divide-two-integers.c", "hypo_code": "int divide(int dividend, int divisor){\nif (dividend == INT_MIN && divisor == -1) return INT_MAX;\n    if (dividend == INT_MIN && divisor == 1) return INT_MIN;\n    if (dividend == INT_MAX && divisor == 1) return INT_MAX;\n    if (dividend == INT_MAX && divisor == -1) return INT_MIN + 1;\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n    long long a = labs(dividend);\n    long long b = labs(divisor);\n    int res = 0;\n    while (a >= b) {\n        long long c = b;\n        for (int i = 0; a >= c; i++, c <<= 1) {\n            a -= c;\n            res += 1 << i;\n        }\n    }\n    return sign == 1 ? res : -res;\n}", "prefix": "int divide(int dividend, int divisor"}
{"id": "626", "path": "output2\\c\\Medium\\626-next-permutation.c", "hypo_code": "void nextPermutation(int* nums, int numsSize){\n    int i = numsSize - 1;\n    int j = numsSize - 1;\n    int temp = 0;\n    while(i > 0){\n        if(nums[i] > nums[i - 1]){\n            while(j >= i){\n                if(nums[j] > nums[i - 1]){\n                    temp = nums[j];\n                    nums[j] = nums[i - 1];\n                    nums[i - 1] = temp;\n                    break;\n                }\n                j--;\n            }\n            break;\n        }\n        i--;\n    }\n    j = numsSize - 1;\n    while(i < j){\n        temp = nums[j];\n        nums[j] = nums[i];\n        nums[i] = temp;\n        i++;\n        j--;\n    }\n\n}", "prefix": "void nextPermutation(int* nums, int numsSize"}
{"id": "627", "path": "output2\\c\\Medium\\627-search-in-rotated-sorted-array.c", "hypo_code": "int search(int* nums, int numsSize, int target){\n    int low = 0;\n    int high = numsSize - 1;\n    int mid = 0;\n    while(low <= high){\n        mid = (low + high) / 2;\n        if(nums[mid] == target){\n            return mid;\n        }\n        if(nums[low] <= nums[mid]){\n            if(target >= nums[low] && target < nums[mid]){\n                high = mid - 1;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        else{\n            if(target > nums[mid] && target <= nums[high]){\n                low = mid + 1;\n            }\n            else{\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n\n}", "prefix": "int search(int* nums, int numsSize, int target"}
{"id": "628", "path": "output2\\c\\Medium\\628-find-first-and-last-position-of-element-in-sorted-array.c", "hypo_code": "int* searchRange(int* nums, int numsSize, int target, int* returnSize){\n    int low = 0;\n    int high = numsSize - 1;\n    int mid = 0;\n    int* result = (int*)malloc(sizeof(int) * 2);\n    result[0] = -1;\n    result[1] = -1;\n    *returnSize = 2;\n    while(low <= high){\n        mid = (low + high) / 2;\n        if(nums[mid] == target){\n            int i = mid;\n            int j = mid;\n            while(i >= 0 && nums[i] == target){\n                i--;\n            }\n            while(j < numsSize && nums[j] == target){\n                j++;\n            }\n            result[0] = i + 1;\n            result[1] = j - 1;\n            return result;\n        }\n        if(nums[low] <= nums[mid]){\n            if(target >= nums[low] && target < nums[mid]){\n                high = mid - 1;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        else{\n            if(target > nums[mid] && target <= nums[high]){\n                low = mid + 1;\n            }\n            else{\n                high = mid - 1;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int* searchRange(int* nums, int numsSize, int target, int* returnSize"}
{"id": "629", "path": "output2\\c\\Medium\\629-valid-sudoku.c", "hypo_code": "bool isValidSudoku(char** board, int boardSize, int* boardColSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int arr[9] = {0};\n    for(i = 0; i < 9; i++){\n        for(j = 0; j < 9; j++){\n            if(board[i][j] != '.'){\n                arr[board[i][j] - '1']++;\n            }\n        }\n        for(k = 0; k < 9; k++){\n            if(arr[k] > 1){\n                return false;\n            }\n        }\n        for(l = 0; l < 9; l++){\n            arr[l] = 0;\n        }\n    }\n    for(m = 0; m < 9; m++){\n        for(n = 0; n < 9; n++){\n            if(board[n][m] != '.'){\n                arr[board[n][m] - '1']++;\n            }\n        }\n        for(o = 0; o < 9; o++){\n            if(arr[o] > 1){\n                return false;\n            }\n        }\n        for(p = 0; p < 9; p++){\n            arr[p] = 0;\n        }\n    }\n    for(q = 0; q < 9; q++){\n        for(r = 0; r < 9; r++){\n            if(board[q][r] != '.'){\n                arr[board[q][r] - '1']++;\n            }\n        }\n        for(s = 0; s < 9; s++){\n            if(arr[s] > 1){\n                return false;\n\n}", "prefix": "bool isValidSudoku(char** board, int boardSize, int* boardColSize"}
{"id": "630", "path": "output2\\c\\Medium\\630-count-and-say.c", "hypo_code": "char * countAndSay(int n){\n    char *result = (char*)malloc(sizeof(char)*1000);\n    char *temp = (char*)malloc(sizeof(char)*1000);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int count = 0;\n    if(n == 1){\n        result[0] = '1';\n        result[1] = '\\0';\n        return result;\n    }\n    result = countAndSay(n-1);\n    while(result[i] != '\\0'){\n        count = 1;\n        while(result[i] == result[i+1]){\n            count++;\n            i++;\n        }\n        temp[j] = count + '0';\n        temp[j+1] = result[i];\n        j = j + 2;\n        i++;\n    }\n    temp[j] = '\\0';\n    return temp;\n\n}", "prefix": "char * countAndSay(int n"}
{"id": "631", "path": "output2\\c\\Medium\\631-combination-sum.c", "hypo_code": "int** combinationSum(int* candidates, int candidatesSize, \nint target, int* returnSize, \nint** returnColumnSizes){\n    int i = 0;int j = 0;int k = 0;int l = 0;int m = 0;int n = 0;\n    int o = 0;int p = 0;int q = 0;int r = 0;int s = 0;int t = 0;\n    int u = 0;int v = 0;int w = 0;int x = 0;int y = 0;int z = 0;\n    int a = 0;int b = 0;int c = 0;int d = 0;int e = 0;int f = 0;\n    int g = 0;int h = 0;\n    int** result = NULL;int* temp = NULL;int* temp2 = NULL;int* temp3 = NULL;\n    int* temp4 = NULL;int* temp5 = NULL;int* temp6 = NULL;int* temp7 = NULL;\n    int* temp8 = NULL;int* temp9 = NULL;int* temp10 = NULL;int* temp11 = NULL;\n    int* temp12 = NULL;int* temp13 = NULL;int* temp14 = NULL;int* temp15 = NULL;\n    int* temp16 = NULL;int* temp17 = NULL;int* temp18 = NULL;int* temp19 = NULL;\n    int* temp20 = NULL;int* temp21 = NULL;int* temp22 = NULL;int* temp23 = NULL;\n    int* temp24 = NULL;int* temp25 = NULL;int* temp26 = NULL;int* temp27 = NULL;\n    int* temp28 = NULL;int* temp29 = NULL;int* temp30 = NULL;int* temp31 = NULL;\n    int* temp32 = NULL;int* temp33 = NULL;int* temp34 = NULL;int* temp35 = NULL;\n    int* temp36 = NULL;int* temp37 = NULL;int* temp38 = NULL;int* temp39 = NULL\n}", "prefix": "int** combinationSum(int* candidates, int candidatesSize"}
{"id": "632", "path": "output2\\c\\Medium\\632-combination-sum-ii.c", "hypo_code": "int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n\n}", "prefix": "int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes"}
{"id": "633", "path": "output2\\c\\Medium\\633-multiply-strings.c", "hypo_code": "char * multiply(char * num1, char * num2){\n    int len1 = strlen(num1);\n    int len2 = strlen(num2);\n    int len = len1 + len2;\n    char* result = (char*)malloc(sizeof(char) * (len + 1));\n    result[len] = '\\0';\n    for(int i = 0; i < len; i++){\n        result[i] = '0';\n    }\n    for(int i = len1 - 1; i >= 0; i--){\n        for(int j = len2 - 1; j >= 0; j--){\n            int temp = (num1[i] - '0') * (num2[j] - '0');\n            int sum = temp + (result[i + j + 1] - '0');\n            result[i + j + 1] = sum % 10 + '0';\n            result[i + j] += sum / 10;\n        }\n    }\n    int i = 0;\n    while(result[i] == '0'){\n        i++;\n    }\n    if(i == len){\n        return \"0\";\n    }\n    return result + i;\n\n}", "prefix": "char * multiply(char * num1, char * num2"}
{"id": "634", "path": "output2\\c\\Medium\\634-jump-game-ii.c", "hypo_code": "int jump(int* nums, int numsSize){\n    int jumps = 0;\n    int currentJumpEnd = 0;\n    int farthest = 0;\n    for(int i = 0; i < numsSize - 1; i++){\n        farthest = fmax(farthest, i + nums[i]);\n        if(i == currentJumpEnd){\n            jumps++;\n            currentJumpEnd = farthest;\n        }\n    }\n    return jumps;\n\n}", "prefix": "int jump(int* nums, int numsSize"}
{"id": "635", "path": "output2\\c\\Medium\\635-permutations.c", "hypo_code": "int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n     \n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n}", "prefix": "int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes"}
{"id": "636", "path": "output2\\c\\Medium\\636-permutations-ii.c", "hypo_code": "int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n\n}", "prefix": "int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes"}
{"id": "637", "path": "output2\\c\\Medium\\637-rotate-image.c", "hypo_code": "void rotate(int** matrix, int matrixSize, int* matrixColSize){\n    int temp;\n    for(int i = 0; i < matrixSize; i++){\n        for(int j = i; j < matrixSize; j++){\n            temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    }\n    for(int i = 0; i < matrixSize; i++){\n        for(int j = 0; j < matrixSize / 2; j++){\n            temp = matrix[i][j];\n            matrix[i][j] = matrix[i][matrixSize - j - 1];\n            matrix[i][matrixSize - j - 1] = temp;\n        }\n    }\n\n}", "prefix": "void rotate(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "638", "path": "output2\\c\\Medium\\638-group-anagrams.c", "hypo_code": "char *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n\n}", "prefix": "char *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes"}
{"id": "639", "path": "output2\\c\\Medium\\639-powx-n.c", "hypo_code": "double myPow(double x, int n){\n    if(n == 0){\n        return 1;\n    }\n    if(n == 1){\n        return x;\n    }\n    if(n == -1){\n        return 1 / x;\n    }\n    double temp = myPow(x, n / 2);\n    if(n % 2 == 0){\n        return temp * temp;\n    }\n    else{\n        return temp * temp * x;\n    }\n\n}", "prefix": "double myPow(double x, int n"}
{"id": "640", "path": "output2\\c\\Medium\\640-maximum-subarray.c", "hypo_code": "int maxSubArray(int* nums, int numsSize){\n    int max = nums[0];\n    int sum = 0;\n    for(int i = 0; i < numsSize; i++){\n        sum += nums[i];\n        if(sum > max){\n            max = sum;\n        }\n        if(sum < 0){\n            sum = 0;\n        }\n    }\n    return max;\n\n}", "prefix": "int maxSubArray(int* nums, int numsSize"}
{"id": "641", "path": "output2\\c\\Medium\\641-spiral-matrix.c", "hypo_code": "int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int count = 0;\n    int max = 0;\n    int* result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n\n}", "prefix": "int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize"}
{"id": "642", "path": "output2\\c\\Medium\\642-jump-game.c", "hypo_code": "bool canJump(int* nums, int numsSize){\n    int max = 0;\n    for(int i = 0; i < numsSize; i++){\n        if(i > max){\n            return false;\n        }\n        max = fmax(max, i + nums[i]);\n    }\n    return true;\n\n}", "prefix": "bool canJump(int* nums, int numsSize"}
{"id": "643", "path": "output2\\c\\Medium\\643-merge-intervals.c", "hypo_code": "int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n\n}", "prefix": "int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes"}
{"id": "644", "path": "output2\\c\\Medium\\644-insert-interval.c", "hypo_code": "int** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n}", "prefix": "int** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes"}
{"id": "645", "path": "output2\\c\\Medium\\645-spiral-matrix-ii.c", "hypo_code": "int** generateMatrix(int n, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL;\n    int* temp40 =\n\n}", "prefix": "int** generateMatrix(int n, int* returnSize, int** returnColumnSizes"}
{"id": "646", "path": "output2\\c\\Medium\\646-rotate-list.c", "hypo_code": "struct ListNode* rotateRight(struct ListNode* head, int k){\n    if(head == NULL){\n        return NULL;\n    }\n    struct ListNode* temp = head;\n    int len = 1;\n    while(temp->next != NULL){\n        temp = temp->next;\n        len++;\n    }\n    temp->next = head;\n    k = k % len;\n    for(int i = 0; i < len - k; i++){\n        temp = temp->next;\n    }\n    head = temp->next;\n    temp->next = NULL;\n    return head;\n\n}", "prefix": "struct ListNode* rotateRight(struct ListNode* head, int k"}
{"id": "647", "path": "output2\\c\\Medium\\647-unique-paths.c", "hypo_code": "int uniquePaths(int m, int n){\n    int dp[m][n];\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n            if(i == 0 || j == 0){\n                dp[i][j] = 1;\n            }\n            else{\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n\n}", "prefix": "int uniquePaths(int m, int n"}
{"id": "648", "path": "output2\\c\\Medium\\648-unique-paths-ii.c", "hypo_code": "int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize){\n    int dp[obstacleGridSize][*obstacleGridColSize];\n    for(int i = 0; i < obstacleGridSize; i++){\n        for(int j = 0; j < *obstacleGridColSize; j++){\n            if(obstacleGrid[i][j] == 1){\n                dp[i][j] = 0;\n            }\n            else if(i == 0 && j == 0){\n                dp[i][j] = 1;\n            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j - 1];\n            }\n            else if(j == 0){\n                dp[i][j] = dp[i - 1][j];\n            }\n            else{\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[obstacleGridSize - 1][*obstacleGridColSize - 1];\n\n}", "prefix": "int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize"}
{"id": "649", "path": "output2\\c\\Medium\\649-minimum-path-sum.c", "hypo_code": "int minPathSum(int** grid, int gridSize, int* gridColSize){\n    int dp[gridSize][*gridColSize];\n    for(int i = 0; i < gridSize; i++){\n        for(int j = 0; j < *gridColSize; j++){\n            if(i == 0 && j == 0){\n                dp[i][j] = grid[i][j];\n            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n            }\n            else if(j == 0){\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n            }\n            else{\n                dp[i][j] = fmin(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n    }\n    return dp[gridSize - 1][*gridColSize - 1];\n\n}", "prefix": "int minPathSum(int** grid, int gridSize, int* gridColSize"}
{"id": "650", "path": "output2\\c\\Medium\\650-simplify-path.c", "hypo_code": "char * simplifyPath(char * path){\n    int len = strlen(path);\n    char* result = (char*)malloc(sizeof(char) * (len + 1));\n    result[0] = '\\0';\n    int i = 0;\n    int j = 0;\n    while(i < len){\n        if(path[i] == '/'){\n            i++;\n            continue;\n        }\n        if(path[i] == '.'){\n            if(i + 1 < len && path[i + 1] == '.'){\n                if(j > 0){\n                    j--;\n                    while(j > 0 && result[j] != '/'){\n                        j--;\n                    }\n                }\n                i += 2;\n            }\n            else if(i + 1 < len && path[i + 1] == '/'){\n                i += 2;\n            }\n            else{\n                result[j++] = path[i++];\n            }\n        }\n        else{\n            result[j++] = path[i++];\n        }\n    }\n    if(j == 0){\n        result[j++] = '/';\n    }\n    else if(result[j - 1] == '/'){\n        j--;\n    }\n    result[j] = '\\0';\n    return result;\n\n}", "prefix": "char * simplifyPath(char * path"}
{"id": "651", "path": "output2\\c\\Medium\\651-edit-distance.c", "hypo_code": "int minDistance(char * word1, char * word2){\nint len1 = strlen(word1);\n    int len2 = strlen(word2);\n    int dp[len1 + 1][len2 + 1];\n    for (int i = 0; i <= len1; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= len2; j++) {\n        dp[0][j] = j;\n    }\n    for (int i = 1; i <= len1; i++) {\n        for (int j = 1; j <= len2; j++){\n            if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = 1 + fmin(fmin(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1] - 1);\n            } else {\n                dp[i][j] = 1 + fmin(fmin(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]);\n            }\n        }\n    }\n    return dp[len1][len2];\n}", "prefix": "int minDistance(char * word1, char * word2"}
{"id": "652", "path": "output2\\c\\Medium\\652-set-matrix-zeroes.c", "hypo_code": "void setZeroes(int** matrix, int matrixSize, int* matrixColSize){\n    int row[matrixSize];\n    int col[*matrixColSize];\n    for(int i = 0; i < matrixSize; i++){\n        row[i] = 0;\n    }\n    for(int i = 0; i < *matrixColSize; i++){\n        col[i] = 0;\n    }\n    for(int i = 0; i < matrixSize; i++){\n        for(int j = 0; j < *matrixColSize; j++){\n            if(matrix[i][j] == 0){\n                row[i] = 1;\n                col[j] = 1;\n            }\n        }\n    }\n    for(int i = 0; i < matrixSize; i++){\n        for(int j = 0; j < *matrixColSize; j++){\n            if(row[i] == 1 || col[j] == 1){\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n}", "prefix": "void setZeroes(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "653", "path": "output2\\c\\Medium\\653-search-a-2d-matrix.c", "hypo_code": "bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\n    int left = 0;\n    int right = matrixSize * *matrixColSize - 1;\n    int mid;\n    while(left <= right){\n        mid = (left + right) / 2;\n        if(matrix[mid / *matrixColSize][mid % *matrixColSize] == target){\n            return true;\n        }\n        else if(matrix[mid / *matrixColSize][mid % *matrixColSize] < target){\n            left = mid + 1;\n        }\n        else{\n            right = mid - 1;\n        }\n    }\n    return false;\n\n}", "prefix": "bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target"}
{"id": "654", "path": "output2\\c\\Medium\\654-sort-colors.c", "hypo_code": "void sortColors(int* nums, int numsSize){\n    int red = 0;\n    int white = 0;\n    int blue = 0;\n    for(int i = 0; i < numsSize; i++){\n        if(nums[i] == 0){\n            red++;\n        }\n        else if(nums[i] == 1){\n            white++;\n        }\n        else{\n            blue++;\n        }\n    }\n    for(int i = 0; i < numsSize; i++){\n        if(red > 0){\n            nums[i] = 0;\n            red--;\n        }\n        else if(white > 0){\n            nums[i] = 1;\n            white--;\n        }\n        else{\n            nums[i] = 2;\n            blue--;\n        }\n    }\n\n}", "prefix": "void sortColors(int* nums, int numsSize"}
{"id": "655", "path": "output2\\c\\Medium\\655-combinations.c", "hypo_code": "int** combine(int n, int k, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n\n}", "prefix": "int** combine(int n, int k, int* returnSize, int** returnColumnSizes"}
{"id": "656", "path": "output2\\c\\Medium\\656-subsets.c", "hypo_code": "int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n\n}", "prefix": "int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes"}
{"id": "657", "path": "output2\\c\\Medium\\657-word-search.c", "hypo_code": "bool exist(char** board, int boardSize, int* boardColSize, char * word){\n    int i = 0;int j = 0;int k = 0;int l = 0;int m = 0;int n = 0;int o = 0;int p = 0;int q = 0;int r = 0;int s = 0;int t = 0;int u = 0;int v = 0;int w = 0;int x = 0;int y = 0;int z = 0;int a = 0;int b = 0;int c = 0;int d = 0;int e = 0;int f = 0;int g = 0;int h = 0;int arr[boardSize][*boardColSize];\n    for(i = 0; i < boardSize; i++){\n        for(j = 0; j < *boardColSize; j++){\n            arr[i][j] = 0;\n        }\n    }\n    for(k = 0; k < boardSize; k++){\n        for(l = 0; l < *boardColSize; l++){\n            if(board[k][l] == word[0]){\n                arr[k][l] = 1;\n                if(word[1] == '\\0'){\n                    return true;\n                }\n                for(m = 0; m < boardSize; m++){\n                    for(n = 0; n < *boardColSize; n++){\n                        if(arr[m][n] == 1){\n                            if(m - 1 >= 0 && arr[m - 1][n] == 0 && board[m - 1][n] == word[1]){\n                                arr[m - 1][n] = 1;\n                                if(word[2] == '\\0'){\n                                    return true;\n                                }\n                                for(o = 0; o < boardSize; o++){\n                                    for(p = 0; p < *boardColSize; p++){\n                                        if(arr[o][p] == 1){\n                                            if(o - 1 >= 0 && arr[o - 1][p] == 0 && board[o - 1][p] == word[2]){\n                                                arr[o - 1][p] = 1;\n                                                if(word[3] == '\\0'){\n                                                    return true;\n                                                }\n                                                for(q = 0; q < boardSize; q++){\n                                                    for(r = 0; r < *boardColSize; r++){\n                                                        if(arr[q][r] == 1){\n                                                            if(q - 1 >= 0 && arr[q - 1][r] == 0 && board[q - 1][r] == word[3]){\n                                                                arr[q - 1][r] = 1;\n                                                                \n                                                                if(word[4] == '\\0'){\n                                                                    return true;\n                                                                }\n                                                                for(s = 0; s < boardSize; s++){\n                                                                    for(t = 0; t < *boardColSize; t++){\n                                                                        if(arr[s][t] == 1){\n                                                                            if(s - 1 >= 0 && arr[s - 1][t] == 0 && board[s - 1][t] == word[4]){\n                                                                                arr[s - 1][t] = 1;\n                                                                                if(word[5] == '\\0'){\n                                                                                    return true;\n                                                                                }\n                                                                                for(u = 0; u < boardSize; u++){\n                                                                                    for(v = 0; v < *boardColSize; v++){\n                                                                                        if(arr[u][v] == 1){\n                                                                                            if(u - 1 >= 0 && arr[u - 1][v] == 0 && board[u - 1][v] == word[5]){\n                                                                                                arr[u - 1][v] = 1;\n                                                                                                if(word[6] == '\\0'){\n                                                                                                    return true;\n                                                                                                }\n                                                                                                for(w = 0; w < boardSize; w++){\n                                                                                                    for(x = 0; x < *boardColSize; x++){\n                                                                                                        if(arr[w][x] == 1){\n                                                                                                            if(w - 1 >= 0 && arr[w - 1][x] == 0 && board[w - 1][x] == word[6]){\n                                                                                                                arr[w - 1][x] = 1;\n                                                                                                                if(word[7] == '\\0'){\n                                                                                                                    return true;\n                                                                                                                }\n                                                                                                                for(y = 0; y < boardSize; y++){\n                                                                                                                    for(z = 0; z < *boardColSize; z++){\n                                                                                                                        if(arr[y][z] == 1){\n                                                                                                                            if(y - 1 >= 0 && arr[y - 1][z] == 0 && board[y -\n\n}", "prefix": "bool exist(char** board, int boardSize, int* boardColSize, char * word"}
{"id": "658", "path": "output2\\c\\Medium\\658-remove-duplicates-from-sorted-array-ii.c", "hypo_code": "int removeDuplicates(int* nums, int numsSize){\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < numsSize){\n        if(i == 0 || nums[i] != nums[i - 1]){\n            count = 1;\n            nums[j] = nums[i];\n            j++;\n        }\n        else if(nums[i] == nums[i - 1]){\n            count++;\n            if(count <= 2){\n                nums[j] = nums[i];\n                j++;\n            }\n        }\n        i++;\n    }\n    return j;\n\n}", "prefix": "int removeDuplicates(int* nums, int numsSize"}
{"id": "659", "path": "output2\\c\\Medium\\659-search-in-rotated-sorted-array-ii.c", "hypo_code": "bool search(int* nums, int numsSize, int target){\n    int left = 0;\n    int right = numsSize - 1;\n    while(left <= right){\n        int mid = left + (right - left) / 2;\n        if(nums[mid] == target){\n            return true;\n        }\n        if(nums[left] == nums[mid]){\n            left++;\n        }\n        else if(nums[left] < nums[mid]){\n            if(nums[left] <= target && target < nums[mid]){\n                right = mid - 1;\n            }\n            else{\n                left = mid + 1;\n            }\n        }\n        else{\n            if(nums[mid] < target && target <= nums[right]){\n                left = mid + 1;\n            }\n            else{\n                right = mid - 1;\n            }\n        }\n    }\n    return false;\n\n}", "prefix": "bool search(int* nums, int numsSize, int target"}
{"id": "660", "path": "output2\\c\\Medium\\660-remove-duplicates-from-sorted-list-ii.c", "hypo_code": "struct ListNode* deleteDuplicates(struct ListNode* head){\n    struct ListNode* temp = head;\n    struct ListNode* prev = NULL;\n    struct ListNode* next = NULL;\n    int count = 0;\n    while(temp != NULL){\n        count++;\n        temp = temp->next;\n    }\n    if(count == 1){\n        return head;\n    }\n    temp = head;\n    while(temp != NULL){\n        if(count == 1){\n            return head;\n        }\n        if(count % 2 == 0){\n            next = temp->next;\n            temp->next = prev;\n            prev->next = next;\n            if(count == 2){\n                head = temp;\n            }\n            temp = next;\n        }\n        else{\n            prev = temp;\n            temp = temp->next;\n        }\n        count--;\n    }\n    return head;\n\n}", "prefix": "struct ListNode* deleteDuplicates(struct ListNode* head"}
{"id": "661", "path": "output2\\c\\Medium\\661-partition-list.c", "hypo_code": "struct ListNode* partition(struct ListNode* head, int x){\n    struct ListNode* temp = head;\n    struct ListNode* prev = NULL;\n    struct ListNode* next = NULL;\n    int count = 0;\n    while(temp != NULL){\n        count++;\n        temp = temp->next;\n    }\n    if(count == 1){\n        return head;\n    }\n    temp = head;\n    while(temp != NULL){\n        if(count == 1){\n            return head;\n        }\n        if(count % 2 == 0){\n            next = temp->next;\n            temp->next = prev;\n            prev->next = next;\n            if(count == 2){\n                head = temp;\n            }\n            temp = next;\n        }\n        else{\n            prev = temp;\n            temp = temp->next;\n        }\n        count--;\n    }\n    return head;\n\n}", "prefix": "struct ListNode* partition(struct ListNode* head, int x"}
{"id": "662", "path": "output2\\c\\Medium\\662-gray-code.c", "hypo_code": "int* grayCode(int n, int* returnSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int* result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL;\n    int* temp40 =\n\n}", "prefix": "int* grayCode(int n, int* returnSize"}
{"id": "663", "path": "output2\\c\\Medium\\663-subsets-ii.c", "hypo_code": "int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n\n}", "prefix": "int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes"}
{"id": "664", "path": "output2\\c\\Medium\\664-decode-ways.c", "hypo_code": "int numDecodings(char * s){\n    int len = strlen(s);\n    if(len == 0){\n        return 0;\n    }\n    int *dp = (int*)malloc(sizeof(int) * (len + 1));\n    dp[0] = 1;\n    dp[1] = s[0] == '0' ? 0 : 1;\n    for(int i = 2; i <= len; i++){\n        if(s[i-1] == '0'){\n            if(s[i-2] == '1' || s[i-2] == '2'){\n                dp[i] = dp[i-2];\n            }else{\n                dp[i] = 0;\n            }\n        }else{\n            if(s[i-2] == '1' || (s[i-2] == '2' && s[i-1] >= '1' && s[i-1] <= '6')){\n                dp[i] = dp[i-1] + dp[i-2];\n            }else{\n                dp[i] = dp[i-1];\n            }\n        }\n    }\n    return dp[len];\n\n}", "prefix": "int numDecodings(char * s"}
{"id": "665", "path": "output2\\c\\Medium\\665-reverse-linked-list-ii.c", "hypo_code": "struct ListNode* reverseBetween(struct ListNode* head, int left, int right){\n    struct ListNode* temp = head;\n    struct ListNode* prev = NULL;\n    struct ListNode* next = NULL;\n    int count = 0;\n    while(temp != NULL){\n        count++;\n        temp = temp->next;\n    }\n    if(count == 1){\n        return head;\n    }\n    temp = head;\n    while(temp != NULL){\n        if(count == 1){\n            return head;\n        }\n        if(count % 2 == 0){\n            next = temp->next;\n            temp->next = prev;\n            prev->next = next;\n            if(count == 2){\n                head = temp;\n            }\n            temp = next;\n        }\n        else{\n            prev = temp;\n            temp = temp->next;\n        }\n        count--;\n    }\n    return head;\n\n\n}", "prefix": "struct ListNode* reverseBetween(struct ListNode* head, int left, int right"}
{"id": "666", "path": "output2\\c\\Medium\\666-restore-ip-addresses.c", "hypo_code": "char ** restoreIpAddresses(char * s, int* returnSize){\n    int len = strlen(s);\n    char **result = (char**)malloc(sizeof(char*) * 1000);\n    int resultSize = 0;\n    for(int i = 1; i <= 3; i++){\n        for(int j = 1; j <= 3; j++){\n            for(int k = 1; k <= 3; k++){\n                for(int l = 1; l <= 3; l++){\n                    if(i + j + k + l == len){\n                        int a = atoi(s);\n                        int b = atoi(s + i);\n                        int c = atoi(s + i + j);\n                        int d = atoi(s + i + j + k);\n                        if(a <= 255 && b <= 255 && c <= 255 && d <= 255){\n                            char *temp = (char*)malloc(sizeof(char) * (len + 4));\n                            sprintf(temp, \"%d.%d.%d.%d\", a, b, c, d);\n                            if(strlen(temp) == len + 3){\n                                result[resultSize++] = temp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    *returnSize = resultSize;\n    return result;\n\n}", "prefix": "char ** restoreIpAddresses(char * s, int* returnSize"}
{"id": "667", "path": "output2\\c\\Medium\\667-unique-binary-search-trees-ii.c", "hypo_code": "struct TreeNode** generateTrees(int n, int* returnSize){\n    struct TreeNode** result = NULL;\n    struct TreeNode* temp = NULL;\n    struct TreeNode* temp2 = NULL;\n    struct TreeNode* temp3 = NULL;\n    struct TreeNode* temp4 = NULL;\n    struct TreeNode* temp5 = NULL;\n    struct TreeNode* temp6 = NULL;\n    struct TreeNode* temp7 = NULL;\n    struct TreeNode* temp8 = NULL;\n    struct TreeNode* temp9 = NULL;\n    struct TreeNode* temp10 = NULL;\n    struct TreeNode* temp11 = NULL;\n    struct TreeNode* temp12 = NULL;\n    struct TreeNode* temp13 = NULL;\n    struct TreeNode* temp14 = NULL;\n    struct TreeNode* temp15 = NULL;\n    struct TreeNode* temp16 = NULL;\n    struct TreeNode* temp17 = NULL;\n    struct TreeNode* temp18 = NULL;\n    struct TreeNode* temp19 = NULL;\n    struct TreeNode* temp20 = NULL;\n    struct TreeNode* temp21 = NULL;\n    struct TreeNode* temp22 = NULL;\n    struct TreeNode* temp23 = NULL;\n    struct TreeNode* temp24 = NULL;\n    struct TreeNode* temp25 = NULL;\n    struct TreeNode* temp26 = NULL;\n    struct TreeNode* temp27 = NULL;\n    struct TreeNode* temp28 = NULL;\n    struct TreeNode* temp29 = NULL;\n    struct TreeNode* temp30 = NULL;\n    struct TreeNode* temp31 = NULL;\n    struct TreeNode* temp32 = NULL;\n    struct TreeNode* temp33 = NULL;\n    struct TreeNode* temp34 = NULL;\n    struct TreeNode* temp35 = NULL;\n    struct TreeNode* temp36 = NULL;\n    struct TreeNode* temp37 = NULL;\n    struct TreeNode* temp38 = NULL;\n    struct TreeNode* temp39 = NULL;\n    struct TreeNode* temp40 = NULL;\n    struct TreeNode* temp41 = NULL;\n    struct TreeNode* temp42 = NULL;\n    struct TreeNode* temp43 = NULL;\n    struct TreeNode* temp44 = NULL;\n    struct TreeNode* temp45 = NULL;\n    struct TreeNode* temp46 = NULL;\n    struct TreeNode* temp47 = NULL;\n    struct TreeNode* temp48 = NULL;\n    struct TreeNode* temp49 = NULL;\n    struct TreeNode* temp50 = NULL;\n    struct TreeNode* temp51 = NULL;\n    struct TreeNode* temp52 = NULL;\n    struct TreeNode* temp53 = NULL;\n    struct TreeNode* temp54 = NULL;\n    struct TreeNode* temp55\n\n}", "prefix": "struct TreeNode** generateTrees(int n, int* returnSize"}
{"id": "668", "path": "output2\\c\\Medium\\668-unique-binary-search-trees.c", "hypo_code": "int numTrees(int n){\n    int* result = (int*)malloc(sizeof(int) * (n + 1));\n    result[0] = 1;\n    result[1] = 1;\n    for(int i = 2; i <= n; i++){\n        result[i] = 0;\n        for(int j = 0; j < i; j++){\n            result[i] += result[j] * result[i - j - 1];\n        }\n    }\n    return result[n];\n\n}", "prefix": "int numTrees(int n"}
{"id": "669", "path": "output2\\c\\Medium\\669-interleaving-string.c", "hypo_code": "bool isInterleave(char * s1, char * s2, char * s3){\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int len3 = strlen(s3);\n    if(len1 + len2 != len3){\n        return false;\n    }\n    bool dp[len1 + 1][len2 + 1];\n    for(int i = 0; i <= len1; i++){\n        for(int j = 0; j <= len2; j++){\n            if(i == 0 && j == 0){\n                dp[i][j] = true;\n            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];\n            }\n            else if(j == 0){\n                dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1];\n            }\n            else{\n                dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\n            }\n        }\n    }\n    return dp[len1][len2];\n\n}", "prefix": "bool isInterleave(char * s1, char * s2, char * s3"}
{"id": "670", "path": "output2\\c\\Medium\\670-validate-binary-search-tree.c", "hypo_code": "bool isValidBST(struct TreeNode* root){\n    if(root == NULL){\n        return true;\n    }\n    if(root->left == NULL && root->right == NULL){\n        return true;\n    }\n    if(root->left != NULL && root->right != NULL){\n        if(root->left->val >= root->val || root->right->val <= root->val){\n            return false;\n        }\n    }\n    if(root->left != NULL && root->right == NULL){\n        if(root->left->val >= root->val){\n            return false;\n        }\n    }\n    if(root->left == NULL && root->right != NULL){\n        if(root->right->val <= root->val){\n            return false;\n        }\n    }\n    if(root->left != NULL){\n        if(root->left->val >= root->val){\n            return false;\n        }\n        if(isValidBST(root->left) == false){\n            return false;\n        }\n    }\n    if(root->right != NULL){\n        if(root->right->val <= root->val){\n            return false;\n        }\n        if(isValidBST(root->right) == false){\n            return false;\n        }\n    }\n    return true;\n\n}", "prefix": "bool isValidBST(struct TreeNode* root"}
{"id": "671", "path": "output2\\c\\Medium\\671-recover-binary-search-tree.c", "hypo_code": "void recoverTree(struct TreeNode* root){\n    struct TreeNode* temp = root;\n    struct TreeNode* prev = NULL;\n    struct TreeNode* next = NULL;\n    int count = 0;\n    while(temp != NULL){\n        count++;\n        temp = temp->next;\n    }\n    if(count == 1){\n        return head;\n    }\n    temp = root;\n    while(temp != NULL){\n        if(count == 1){\n            return head;\n        }\n        if(count % 2 == 0){\n            next = temp->next;\n            temp->next = prev;\n            prev->next = next;\n            if(count == 2){\n                head = temp;\n            }\n            temp = next;\n        }\n        else{\n            prev = temp;\n            temp = temp->next;\n        }\n        count--;\n    }\n    return head;\n\n}", "prefix": "void recoverTree(struct TreeNode* root"}
{"id": "672", "path": "output2\\c\\Medium\\672-binary-tree-level-order-traversal.c", "hypo_code": "int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\n    int** result = NULL;\n    int* columnSizes = NULL;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n    int by = 0;\n\n\n}", "prefix": "int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes"}
{"id": "673", "path": "output2\\c\\Medium\\673-binary-tree-zigzag-level-order-traversal.c", "hypo_code": "int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\n    int** result = NULL;\n    int* columnSizes = NULL;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n    int by = 0;\n\n}", "prefix": "int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes"}
{"id": "674", "path": "output2\\c\\Medium\\674-construct-binary-tree-from-preorder-and-inorder-traversal.c", "hypo_code": "struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){\n    if(preorderSize == 0){\n        return NULL;\n    }\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = preorder[0];\n    root->left = NULL;\n    root->right = NULL;\n    int i = 0;\n    for(i = 0; i < inorderSize; i++){\n        if(inorder[i] == preorder[0]){\n            break;\n        }\n    }\n    root->left = buildTree(preorder + 1, i, inorder, i);\n    root->right = buildTree(preorder + i + 1, preorderSize - i - 1, inorder + i + 1, inorderSize - i - 1);\n    return root;\n\n}", "prefix": "struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize"}
{"id": "675", "path": "output2\\c\\Medium\\675-construct-binary-tree-from-inorder-and-postorder-traversal.c", "hypo_code": "struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){\n    if(inorderSize == 0){\n        return NULL;\n    }\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = postorder[postorderSize - 1];\n    root->left = NULL;\n    root->right = NULL;\n    int i = 0;\n    for(i = 0; i < inorderSize; i++){\n        if(inorder[i] == postorder[postorderSize - 1]){\n            break;\n        }\n    }\n    root->left = buildTree(inorder, i, postorder, i);\n    root->right = buildTree(inorder + i + 1, inorderSize - i - 1, postorder + i, postorderSize - i - 1);\n    return root;\n\n}", "prefix": "struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize"}
{"id": "676", "path": "output2\\c\\Medium\\676-binary-tree-level-order-traversal-ii.c", "hypo_code": "int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\n    int** result = NULL;\n    int* columnSizes = NULL;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n    int by = 0;\n\n}", "prefix": "int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes"}
{"id": "677", "path": "output2\\c\\Medium\\677-convert-sorted-list-to-binary-search-tree.c", "hypo_code": "struct TreeNode* sortedListToBST(struct ListNode* head){\n    if(head == NULL){\n        return NULL;\n    }\n    struct ListNode* temp = head;\n    int count = 0;\n    while(temp != NULL){\n        count++;\n        temp = temp->next;\n    }\n    if(count == 1){\n        struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        root->val = head->val;\n        root->left = NULL;\n        root->right = NULL;\n        return root;\n    }\n    int i = 0;\n    temp = head;\n    while(i < count / 2 - 1){\n        temp = temp->next;\n        i++;\n    }\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = temp->next->val;\n    root->left = sortedListToBST(head);\n    root->right = sortedListToBST(temp->next->next);\n    return root;\n\n}", "prefix": "struct TreeNode* sortedListToBST(struct ListNode* head"}
{"id": "678", "path": "output2\\c\\Medium\\678-path-sum-ii.c", "hypo_code": "int** pathSum(struct TreeNode* root, int targetSum, int* returnSize, int** returnColumnSizes){\n    int** result = NULL;\n    int* columnSizes = NULL;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n    int by = 0;\n\n}", "prefix": "int** pathSum(struct TreeNode* root, int targetSum, int* returnSize, int** returnColumnSizes"}
{"id": "679", "path": "output2\\c\\Medium\\679-flatten-binary-tree-to-linked-list.c", "hypo_code": "void flatten(struct TreeNode* root){\n    if(root == NULL){\n        return;\n    }\n    if(root->left == NULL && root->right == NULL){\n        return;\n    }\n    if(root->left != NULL){\n        flatten(root->left);\n        struct TreeNode* temp = root->right;\n        root->right = root->left;\n        root->left = NULL;\n        struct TreeNode* temp1 = root->right;\n        while(temp1->right != NULL){\n            temp1 = temp1->right;\n        }\n        temp1->right = temp;\n    }\n    flatten(root->right);\n\n}", "prefix": "void flatten(struct TreeNode* root"}
{"id": "680", "path": "output2\\c\\Medium\\680-populating-next-right-pointers-in-each-node.c", "hypo_code": "struct Node* connect(struct Node* root) {\n    if(root == NULL){\n        return NULL;\n    }\n    struct Node* temp = root;\n    while(temp->left != NULL){\n        struct Node* temp1 = temp;\n        while(temp1 != NULL){\n            temp1->left->next = temp1->right;\n            if(temp1->next != NULL){\n                temp1->right->next = temp1->next->left;\n            }\n            temp1 = temp1->next;\n        }\n        temp = temp->left;\n    }\n    return root;\n\t\n}", "prefix": "struct Node* connect(struct Node* root"}
{"id": "681", "path": "output2\\c\\Medium\\681-populating-next-right-pointers-in-each-node-ii.c", "hypo_code": "struct Node* connect(struct Node* root) {\n    if(root == NULL){\n        return NULL;\n    }\n    struct Node* temp = root;\n    while(temp != NULL){\n        struct Node* temp1 = temp;\n        struct Node* temp2 = NULL;\n        while(temp1 != NULL){\n            if(temp1->left != NULL){\n                if(temp2 == NULL){\n                    temp2 = temp1->left;\n                }\n                else{\n                    temp2->next = temp1->left;\n                    temp2 = temp2->next;\n                }\n            }\n            if(temp1->right != NULL){\n                if(temp2 == NULL){\n                    temp2 = temp1->right;\n                }\n                else{\n                    temp2->next = temp1->right;\n                    temp2 = temp2->next;\n                }\n            }\n            temp1 = temp1->next;\n        }\n        temp = temp2;\n    }\n    return root;\n\t\n}", "prefix": "struct Node* connect(struct Node* root"}
{"id": "682", "path": "output2\\c\\Medium\\682-triangle.c", "hypo_code": "int minimumTotal(int** triangle, int triangleSize, int* triangleColSize){\n    int dp[triangleSize][*triangleColSize];\n    for(int i = 0; i < triangleSize; i++){\n        for(int j = 0; j < *triangleColSize; j++){\n            if(i == 0 && j == 0){\n                dp[i][j] = triangle[i][j];\n            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j - 1] + triangle[i][j];\n            }\n            else if(j == 0){\n                dp[i][j] = dp[i - 1][j] + triangle[i][j];\n            }\n            else{\n                dp[i][j] = fmin(dp[i - 1][j], dp[i][j - 1]) + triangle[i][j];\n            }\n        }\n    }\n    int min = dp[triangleSize - 1][0];\n    for(int i = 1; i < *triangleColSize; i++){\n        if(dp[triangleSize - 1][i] < min){\n            min = dp[triangleSize - 1][i];\n        }\n    }\n    return min;\n\n}", "prefix": "int minimumTotal(int** triangle, int triangleSize, int* triangleColSize"}
{"id": "683", "path": "output2\\c\\Medium\\683-best-time-to-buy-and-sell-stock-ii.c", "hypo_code": "int maxProfit(int* prices, int pricesSize){\n    int profit = 0;\n    for(int i = 1; i < pricesSize; i++){\n        if(prices[i] > prices[i - 1]){\n            profit += prices[i] - prices[i - 1];\n        }\n    }\n    return profit;\n\n}", "prefix": "int maxProfit(int* prices, int pricesSize"}
{"id": "684", "path": "output2\\c\\Medium\\684-longest-consecutive-sequence.c", "hypo_code": "int longestConsecutive(int* nums, int numsSize){\n    int max = 0;\n    int* hash = (int*)calloc(numsSize, sizeof(int));\n    for(int i = 0; i < numsSize; i++){\n        if(hash[i] == 0){\n            int count = 1;\n            int num = nums[i];\n            hash[i] = 1;\n            for(int j = i + 1; j < numsSize; j++){\n                if(nums[j] == num + 1){\n                    count++;\n                    num++;\n                    hash[j] = 1;\n                }\n            }\n            num = nums[i];\n            for(int j = i - 1; j >= 0; j--){\n                if(nums[j] == num - 1){\n                    count++;\n                    num--;\n                    hash[j] = 1;\n                }\n            }\n            if(count > max){\n                max = count;\n            }\n        }\n    }\n    return max;\n\n}", "prefix": "int longestConsecutive(int* nums, int numsSize"}
{"id": "685", "path": "output2\\c\\Medium\\685-sum-root-to-leaf-numbers.c", "hypo_code": "int sumNumbers(struct TreeNode* root){\n    if(root == NULL){\n        return 0;\n    }\n    if(root->left == NULL && root->right == NULL){\n        return root->val;\n    }\n    int sum = 0;\n    if(root->left != NULL){\n        root->left->val += root->val * 10;\n        sum += sumNumbers(root->left);\n    }\n    if(root->right != NULL){\n        root->right->val += root->val * 10;\n        sum += sumNumbers(root->right);\n    }\n    return sum;\n\n}", "prefix": "int sumNumbers(struct TreeNode* root"}
{"id": "686", "path": "output2\\c\\Medium\\686-surrounded-regions.c", "hypo_code": "void solve(char** board, int boardSize, int* boardColSize){\n    int* visited = (int*)calloc(boardSize * *boardColSize, sizeof(int));\n    for(int i = 0; i < boardSize; i++){\n        for(int j = 0; j < *boardColSize; j++){\n            if(board[i][j] == 'O' && visited[i * *boardColSize + j] == 0){\n                int* queue = (int*)malloc(sizeof(int) * boardSize * *boardColSize);\n                int front = 0;\n                int rear = 0;\n                int count = 0;\n                int flag = 0;\n                queue[rear++] = i * *boardColSize + j;\n                visited[i * *boardColSize + j] = 1;\n                while(front != rear){\n                    int x = queue[front] / *boardColSize;\n                    int y = queue[front] % *boardColSize;\n                    front++;\n                    count++;\n                    if(x == 0 || x == boardSize - 1 || y == 0 || y == *boardColSize - 1){\n                        flag = 1;\n                    }\n                    if(x - 1 >= 0 && board[x - 1][y] == 'O' && visited[(x - 1) * *boardColSize + y] == 0){\n                        queue[rear++] = (x - 1) * *boardColSize + y;\n                        visited[(x - 1) * *boardColSize + y] = 1;\n                    }\n                    if(x + 1 < boardSize && board[x + 1][y] == 'O' && visited[(x + 1) * *boardColSize + y] == 0){\n                        queue[rear++] = (x + 1) * *boardColSize + y;\n                        visited[(x + 1) * *boardColSize + y] = 1;\n                    }\n                    if(y - 1 >= 0 && board[x][y - 1] == 'O' && visited[x * *boardColSize + y - 1] == 0){\n                        queue[rear++] = x * *boardColSize + y - 1;\n                        visited[x * *boardColSize + y - 1] = 1;\n                    }\n                    if(y + 1 < *boardColSize && board[x][y + 1] == 'O' && visited[x * *boardColSize + y + 1] == 0){\n                        queue[rear++] = x * *boardColSize + y + 1;\n                        visited[x * *boardColSize + y + 1] = 1;\n                    }\n                    \n\n}", "prefix": "void solve(char** board, int boardSize, int* boardColSize"}
{"id": "687", "path": "output2\\c\\Medium\\687-palindrome-partitioning.c", "hypo_code": "char *** partition(char * s, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n\n}", "prefix": "char *** partition(char * s, int* returnSize, int** returnColumnSizes"}
{"id": "688", "path": "output2\\c\\Medium\\688-clone-graph.c", "hypo_code": "struct Node *cloneGraph(struct Node *s) {\n    if (s == NULL) {\n        return NULL;\n    }\n    struct Node *t = malloc(sizeof(struct Node));\n    t->val = s->val;\n    t->numNeighbors = s->numNeighbors;\n    t->neighbors = malloc(sizeof(struct Node *) * t->numNeighbors);\n    for (int i = 0; i < t->numNeighbors; i++) {\n        t->neighbors[i] = cloneGraph(s->neighbors[i]);\n    }\n    return t;\n\t\n}", "prefix": "struct Node *cloneGraph(struct Node *s"}
{"id": "689", "path": "output2\\c\\Medium\\689-gas-station.c", "hypo_code": "int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize){\n    int start = 0;\n    int end = 0;\n    int sum = 0;\n    while(start < gasSize){\n        sum += gas[end] - cost[end];\n        if(sum < 0){\n            start = end + 1;\n            sum = 0;\n        }\n        end = (end + 1) % gasSize;\n        if(start == end){\n            return start;\n        }\n    }\n    return -1;\n\n}", "prefix": "int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize"}
{"id": "690", "path": "output2\\c\\Medium\\690-single-number-ii.c", "hypo_code": "int singleNumber(int* nums, int numsSize){\n    int result = 0;\n    for(int i = 0; i < 32; i++){\n        int count = 0;\n        for(int j = 0; j < numsSize; j++){\n            if(nums[j] & (1 << i)){\n                count++;\n            }\n        }\n        if(count % 3 != 0){\n            result |= (1 << i);\n        }\n    }\n    return result;\n\n}", "prefix": "int singleNumber(int* nums, int numsSize"}
{"id": "691", "path": "output2\\c\\Medium\\691-copy-list-with-random-pointer.c", "hypo_code": "struct Node* copyRandomList(struct Node* head) {\n    if(head == NULL){\n        return NULL;\n    }\n    struct Node* temp = head;\n    while(temp != NULL){\n        struct Node* temp1 = malloc(sizeof(struct Node));\n        temp1->val = temp->val;\n        temp1->next = temp->next;\n        temp->next = temp1;\n        temp = temp->next->next;\n    }\n    temp = head;\n    while(temp != NULL){\n        if(temp->random != NULL){\n            temp->next->random = temp->random->next;\n        }\n        temp = temp->next->next;\n    }\n    temp = head;\n    struct Node* temp2 = head->next;\n    struct Node* temp3 = head->next;\n    while(temp != NULL){\n        temp->next = temp->next->next;\n        if(temp3->next != NULL){\n            temp3->next = temp3->next->next;\n        }\n        temp = temp->next;\n        temp3 = temp3->next;\n    }\n    return temp2;\n\t\n}", "prefix": "struct Node* copyRandomList(struct Node* head"}
{"id": "692", "path": "output2\\c\\Medium\\692-word-break.c", "hypo_code": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\n    int len = strlen(s);\n    bool* dp = (bool*)calloc(len + 1, sizeof(bool));\n    dp[0] = true;\n    for(int i = 1; i <= len; i++){\n        for(int j = 0; j < wordDictSize; j++){\n            int wordLen = strlen(wordDict[j]);\n            if(i >= wordLen && strncmp(s + i - wordLen, wordDict[j], wordLen) == 0 && dp[i - wordLen]){\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[len];\n\n}", "prefix": "bool wordBreak(char * s, char ** wordDict, int wordDictSize"}
{"id": "693", "path": "output2\\c\\Medium\\693-linked-list-cycle-ii.c", "hypo_code": "struct ListNode *detectCycle(struct ListNode *head) {\n    if(head == NULL){\n        return NULL;\n    }\n    struct ListNode* temp = head;\n    struct ListNode* temp1 = head;\n    while(temp != NULL && temp1 != NULL && temp1->next != NULL){\n        temp = temp->next;\n        temp1 = temp1->next->next;\n        if(temp == temp1){\n            break;\n        }\n    }\n    if(temp == NULL || temp1 == NULL || temp1->next == NULL){\n        return NULL;\n    }\n    temp = head;\n    while(temp != temp1){\n        temp = temp->next;\n        temp1 = temp1->next;\n    }\n    return temp;\n    \n}", "prefix": "struct ListNode *detectCycle(struct ListNode *head"}
{"id": "694", "path": "output2\\c\\Medium\\694-reorder-list.c", "hypo_code": "void reorderList(struct ListNode* head){\n    if(head == NULL){\n        return;\n    }\n    struct ListNode* temp = head;\n    int count = 0;\n    while(temp != NULL){\n        count++;\n        temp = temp->next;\n    }\n    if(count == 1){\n        return;\n    }\n    int i = 0;\n    temp = head;\n    while(i < count / 2 - 1){\n        temp = temp->next;\n        i++;\n    }\n    struct ListNode* temp1 = temp->next;\n    temp->next = NULL;\n    temp = temp1;\n    struct ListNode* temp2 = temp->next;\n    temp->next = NULL;\n    while(temp2 != NULL){\n        temp1 = temp2->next;\n        temp2->next = temp;\n        temp = temp2;\n        temp2 = temp1;\n    }\n    temp1 = head;\n    while(temp != NULL){\n        temp2 = temp1->next;\n        temp1->next = temp;\n        temp1 = temp2;\n        temp2 = temp->next;\n        temp->next = temp1;\n        temp = temp2;\n    }\n    return;\n\n}", "prefix": "void reorderList(struct ListNode* head"}
{"id": "696", "path": "output2\\c\\Medium\\696-insertion-sort-list.c", "hypo_code": "struct ListNode* insertionSortList(struct ListNode* head){\n    if(head == NULL){\n        return NULL;\n    }\n    struct ListNode* temp = head;\n    struct ListNode* temp1 = head;\n    struct ListNode* temp2 = head;\n    struct ListNode* temp3 = head;\n    struct ListNode* temp4 = head;\n    struct ListNode* temp5 = head;\n    struct ListNode* temp6 = head;\n    struct ListNode* temp7 = head;\n    struct ListNode* temp8 = head;\n    struct ListNode* temp9 = head;\n    struct ListNode* temp10 = head;\n    struct ListNode* temp11 = head;\n    struct ListNode* temp12 = head;\n    struct ListNode* temp13 = head;\n    struct ListNode* temp14 = head;\n    struct ListNode* temp15 = head;\n    struct ListNode* temp16 = head;\n    struct ListNode* temp17 = head;\n    struct ListNode* temp18 = head;\n    struct ListNode* temp19 = head;\n    struct ListNode* temp20 = head;\n    struct ListNode* temp21 = head;\n    struct ListNode* temp22 = head;\n    struct ListNode* temp23 = head;\n    struct ListNode* temp24 = head;\n    struct ListNode* temp25 = head;\n    struct ListNode* temp26 = head;\n    struct ListNode* temp27 = head;\n    struct ListNode* temp28 = head;\n    struct ListNode* temp29 = head;\n    struct ListNode* temp30 = head;\n    struct ListNode* temp31 = head;\n    struct ListNode* temp32 = head;\n    struct ListNode* temp33 = head;\n    struct ListNode* temp34 = head;\n    struct ListNode* temp35 = head;\n    struct ListNode* temp36 = head;\n    struct ListNode* temp37 = head;\n    struct ListNode* temp38 = head;\n    struct ListNode* temp39 = head;\n    struct ListNode* temp40 = head;\n    struct ListNode* temp41 = head;\n    struct ListNode* temp42 = head;\n    struct ListNode* temp43 = head;\n    struct ListNode* temp44 = head;\n    struct ListNode* temp45 = head;\n    struct ListNode* temp46 = head;\n    struct ListNode* temp47 = head;\n    struct ListNode* temp48 = head;\n    struct ListNode* temp49 = head;\n    struct ListNode* temp50 = head;\n    struct ListNode* temp51 = head;\n    struct ListNode* temp52 = head;\n    struct ListNode* temp53 = head;\n    struct\n\n}", "prefix": "struct ListNode* insertionSortList(struct ListNode* head"}
{"id": "697", "path": "output2\\c\\Medium\\697-sort-list.c", "hypo_code": "struct ListNode* sortList(struct ListNode* head){\n    if(head == NULL || head->next == NULL){\n        return head;\n    }\n    struct ListNode* temp = head;\n    struct ListNode* temp1 = head;\n    struct ListNode* temp2 = head;\n    while(temp1 != NULL && temp1->next != NULL){\n        temp2 = temp;\n        temp = temp->next;\n        temp1 = temp1->next->next;\n    }\n    temp2->next = NULL;\n    struct ListNode* left = sortList(head);\n    struct ListNode* right = sortList(temp);\n    struct ListNode* temp3 = (struct ListNode*)malloc(sizeof(struct ListNode));\n    temp3->next = NULL;\n    struct ListNode* temp4 = temp3;\n    while(left != NULL && right != NULL){\n        if(left->val < right->val){\n            temp4->next = left;\n            left = left->next;\n        }\n        else{\n            temp4->next = right;\n            right = right->next;\n        }\n        temp4 = temp4->next;\n    }\n    if(left != NULL){\n        temp4->next = left;\n    }\n    if(right != NULL){\n        temp4->next = right;\n    }\n    return temp3->next;\n    \n\n}", "prefix": "struct ListNode* sortList(struct ListNode* head"}
{"id": "698", "path": "output2\\c\\Medium\\698-evaluate-reverse-polish-notation.c", "hypo_code": "int evalRPN(char ** tokens, int tokensSize){\n    int* stack = (int*)calloc(tokensSize, sizeof(int));\n    int top = -1;\n    for(int i = 0; i < tokensSize; i++){\n        if(strcmp(tokens[i], \"+\") == 0){\n            int a = stack[top--];\n            int b = stack[top--];\n            stack[++top] = a + b;\n        }\n        else if(strcmp(tokens[i], \"-\") == 0){\n            int a = stack[top--];\n            int b = stack[top--];\n            stack[++top] = b - a;\n        }\n        else if(strcmp(tokens[i], \"*\") == 0){\n            int a = stack[top--];\n            int b = stack[top--];\n            stack[++top] = a * b;\n        }\n        else if(strcmp(tokens[i], \"/\") == 0){\n            int a = stack[top--];\n            int b = stack[top--];\n            stack[++top] = b / a;\n        }\n        else{\n            stack[++top] = atoi(tokens[i]);\n        }\n    }\n    return stack[top];\n\n}", "prefix": "int evalRPN(char ** tokens, int tokensSize"}
{"id": "699", "path": "output2\\c\\Medium\\699-reverse-words-in-a-string.c", "hypo_code": "char * reverseWords(char * s){\n    int len = strlen(s);\n    char* result = (char*)malloc(sizeof(char) * (len + 1));\n    result[0] = '\\0';\n    int i = len - 1;\n    int j = len;\n    while(i >= 0){\n        if(s[i] == ' '){\n            i--;\n            continue;\n        }\n        j = i;\n        while(i >= 0 && s[i] != ' '){\n            i--;\n        }\n        if(result[0] != '\\0'){\n            strcat(result, \" \");\n        }\n        strncat(result, s + i + 1, j - i);\n    }\n    return result;\n\n}", "prefix": "char * reverseWords(char * s"}
{"id": "700", "path": "output2\\c\\Medium\\700-maximum-product-subarray.c", "hypo_code": "int maxProduct(int* nums, int numsSize){\n    int max = nums[0];\n    int min = nums[0];\n    int result = nums[0];\n    for(int i = 1; i < numsSize; i++){\n        int temp = max;\n        max = fmax(nums[i], fmax(nums[i] * max, nums[i] * min));\n        min = fmin(nums[i], fmin(nums[i] * temp, nums[i] * min));\n        if(max > result){\n            result = max;\n        }\n    }\n    return result;\n\n}", "prefix": "int maxProduct(int* nums, int numsSize"}
{"id": "701", "path": "output2\\c\\Medium\\701-find-minimum-in-rotated-sorted-array.c", "hypo_code": "int findMin(int* nums, int numsSize){\n    int low = 0;\n    int high = numsSize - 1;\n    int mid = 0;\n    while(low < high){\n        mid = (low + high) / 2;\n        if(nums[mid] > nums[high]){\n            low = mid + 1;\n        }\n        else{\n            high = mid;\n        }\n    }\n    return nums[low];\n\n}", "prefix": "int findMin(int* nums, int numsSize"}
{"id": "703", "path": "output2\\c\\Medium\\703-find-peak-element.c", "hypo_code": "int findPeakElement(int* nums, int numsSize){\nif (numsSize == 1) return 0;\n    int left = 0, right = numsSize - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if ((mid == 0 || nums[mid] >= nums[mid - 1]) && (mid == numsSize - 1 || nums[mid] >= nums[mid + 1])) {\n            return mid;\n        } else if (mid > 0 && nums[mid] < nums[mid - 1]) {\n            right = mid - 1;\n        } else if (mid < numsSize - 1 && nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        }\n    }\n    return -1;\n}", "prefix": "int findPeakElement(int* nums, int numsSize"}
{"id": "704", "path": "output2\\c\\Medium\\704-compare-version-numbers.c", "hypo_code": "int compareVersion(char * version1, char * version2){\nint len1 = strlen(version1);\n    int len2 = strlen(version2);\n    int i = 0, j = 0;\n    while (i < len1 || j < len2) {\n        int num1 = 0, num2 = 0;\n        while (i < len1 && version1[i] != '.') {\n            num1 = num1 * 10 + version1[i++] - '0';\n        }\n        while (j < len2 && version2[j] != '.') {\n            num2 = num2 * 10 + version2[j++] - '0';\n        }\n        if (num1 > num2) return 1;\n        else if (num1 < num2) return -1;\n        i++, j++;\n    }\n    return 0;\n}", "prefix": "int compareVersion(char * version1, char * version2"}
{"id": "705", "path": "output2\\c\\Medium\\705-fraction-to-recurring-decimal.c", "hypo_code": "char * fractionToDecimal(int numerator, int denominator){\nif (numerator == 0) {\n        return \"0\";\n    }\n    char *res = (char *)malloc(sizeof(char) * 10000);\n    int index = 0;\n    long long a = labs(numerator);\n    long long b = labs(denominator);\n    if ((numerator > 0) ^ (denominator > 0)) {\n        res[index++] = '-';\n    }\n    res[index++] = a / b + '0';\n    long long c = a % b;\n    if (c == 0) {\n        res[index] = '\\0';\n        return res;\n    }\n    res[index++] = '.';\n    int *map = (int *)malloc(sizeof(int) * 10000);\n    memset(map, 0, sizeof(int) * 10000);\n    while (c != 0) {\n        if (map[c] != 0) {\n            res[map[c]] = '(';\n            res[index++] = ')';\n            res[index] = '\\0';\n            return res;\n        }\n        map[c] = index;\n        c *= 10;\n        res[index++] = c / b + '0';\n        c %= b;\n    }\n    res[index] = '\\0';\n    return res;\n}", "prefix": "char * fractionToDecimal(int numerator, int denominator"}
{"id": "706", "path": "output2\\c\\Medium\\706-two-sum-ii-input-array-is-sorted.c", "hypo_code": "int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){\n*returnSize = 2;\n    int *res = (int *)malloc(sizeof(int) * 2);\n    int left = 0, right = numbersSize - 1;\n    while (left < right) {\n        int sum = numbers[left] + numbers[right];\n        if (sum == target) {\n            res[0] = left + 1;\n            res[1] = right + 1;\n            return res;\n        } else if (sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return res;\n}", "prefix": "int* twoSum(int* numbers, int numbersSize, int target, int* returnSize"}
{"id": "707", "path": "output2\\c\\Medium\\707-factorial-trailing-zeroes.c", "hypo_code": "int trailingZeroes(int n){\nint res = 0;\n    while (n >= 5) {\n        res += n / 5;\n        n /= 5;\n    }\n    return res;\n}", "prefix": "int trailingZeroes(int n"}
{"id": "712", "path": "output2\\c\\Medium\\712-largest-number.c", "hypo_code": "char * largestNumber(int* nums, int numsSize){\nchar *res = (char *)malloc(sizeof(char) * 1000);\n    char **s = (char **)malloc(sizeof(char *) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        s[i] = (char *)malloc(sizeof(char) * 10);\n        sprintf(s[i], \"%d\", nums[i]);\n    }\n    qsort(s, numsSize, sizeof(char *), cmp);\n    if (s[0][0] == '0') {\n        res[0] = '0';\n        res[1] = '\\0';\n        return res;\n    }\n    for (int i = 0; i < numsSize; i++) {\n        strcat(res, s[i]);\n    }\n    return res;\n}", "prefix": "char * largestNumber(int* nums, int numsSize"}
{"id": "715", "path": "output2\\c\\Medium\\715-repeated-dna-sequences.c", "hypo_code": "char ** findRepeatedDnaSequences(char * s, int* returnSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n\n}", "prefix": "char ** findRepeatedDnaSequences(char * s, int* returnSize"}
{"id": "716", "path": "output2\\c\\Medium\\716-rotate-array.c", "hypo_code": "void rotate(int* nums, int numsSize, int k){\n    int temp[numsSize];\n    for(int i = 0; i < numsSize; i++){\n        temp[(i + k) % numsSize] = nums[i];\n    }\n    for(int i = 0; i < numsSize; i++){\n        nums[i] = temp[i];\n    }\n\n}", "prefix": "void rotate(int* nums, int numsSize, int k"}
{"id": "719", "path": "output2\\c\\Medium\\719-house-robber.c", "hypo_code": "int rob(int* nums, int numsSize){\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    if(numsSize == 0){\n        return 0;\n    }\n    if(numsSize == 1){\n        return nums[0];\n    }\n    if(numsSize == 2){\n        return fmax(nums[0], nums[1]);\n    }\n    result[0] = nums[0];\n    result[1] = fmax(nums[0], nums[1]);\n    for(int i = 2; i < numsSize; i++){\n        result[i] = fmax(result[i - 1], result[i - 2] + nums[i]);\n    }\n    return result[numsSize - 1];\n\n}", "prefix": "int rob(int* nums, int numsSize"}
{"id": "720", "path": "output2\\c\\Medium\\720-binary-tree-right-side-view.c", "hypo_code": "int* rightSideView(struct TreeNode* root, int* returnSize){\n    int* result = NULL;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n    int by = 0;\n    int bz = 0;\n\n\n}", "prefix": "int* rightSideView(struct TreeNode* root, int* returnSize"}
{"id": "721", "path": "output2\\c\\Medium\\721-number-of-islands.c", "hypo_code": "int numIslands(char** grid, int gridSize, int* gridColSize){\n    int* visited = (int*)calloc(gridSize * *gridColSize, sizeof(int));\n    int count = 0;\n    for(int i = 0; i < gridSize; i++){\n        for(int j = 0; j < *gridColSize; j++){\n            if(grid[i][j] == '1' && visited[i * *gridColSize + j] == 0){\n                count++;\n                int* queue = (int*)malloc(sizeof(int) * gridSize * *gridColSize);\n                int front = 0;\n                int rear = 0;\n                queue[rear++] = i * *gridColSize + j;\n                visited[i * *gridColSize + j] = 1;\n                while(front != rear){\n                    int x = queue[front] / *gridColSize;\n                    int y = queue[front] % *gridColSize;\n                    front++;\n                    if(x + 1 < gridSize && grid[x + 1][y] == '1' && visited[(x + 1) * *gridColSize + y] == 0){\n                        queue[rear++] = (x + 1) * *gridColSize + y;\n                        visited[(x + 1) * *gridColSize + y] = 1;\n                    }\n                    if(y + 1 < *gridColSize && grid[x][y + 1] == '1' && visited[x * *gridColSize + y + 1] == 0){\n                        queue[rear++] = x * *gridColSize + y + 1;\n                        visited[x * *gridColSize + y + 1] = 1;\n                    }\n                    if(x - 1 >= 0 && grid[x - 1][y] == '1' && visited[(x - 1) * *gridColSize + y] == 0){\n                        queue[rear++] = (x - 1) * *gridColSize + y;\n                        visited[(x - 1) * *gridColSize + y] = 1;\n                    }\n                    if(y - 1 >= 0 && grid[x][y - 1] == '1' && visited[x * *gridColSize + y - 1] == 0){\n                        queue[rear++] = x * *gridColSize + y - 1;\n                        visited[x * *grid ColSize + y - 1] = 1;\n                        \n\n}", "prefix": "int numIslands(char** grid, int gridSize, int* gridColSize"}
{"id": "722", "path": "output2\\c\\Medium\\722-bitwise-and-of-numbers-range.c", "hypo_code": "int rangeBitwiseAnd(int left, int right){\n    int count = 0;\n    while(left != right){\n        left >>= 1;\n        right >>= 1;\n        count++;\n    }\n    return left << count;\n\n}", "prefix": "int rangeBitwiseAnd(int left, int right"}
{"id": "723", "path": "output2\\c\\Medium\\723-count-primes.c", "hypo_code": "int countPrimes(int n){\n    int* result = (int*)malloc(sizeof(int) * n);\n    for(int i = 0; i < n; i++){\n        result[i] = 1;\n    }\n    for(int i = 2; i * i < n; i++){\n        if(result[i] == 1){\n            for(int j = i * i; j < n; j += i){\n                result[j] = 0;\n            }\n        }\n    }\n    int count = 0;\n    for(int i = 2; i < n; i++){\n        if(result[i] == 1){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int countPrimes(int n"}
{"id": "724", "path": "output2\\c\\Medium\\724-course-schedule.c", "hypo_code": "bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){\n    int* inDegree = (int*)malloc(sizeof(int) * numCourses);\n    memset(inDegree, 0, sizeof(int) * numCourses);\n    for(int i = 0; i < prerequisitesSize; i++){\n        inDegree[prerequisites[i][0]]++;\n    }\n    int count = 0;\n    int* queue = (int*)malloc(sizeof(int) * numCourses);\n    int front = 0;\n    int rear = 0;\n    for(int i = 0; i < numCourses; i++){\n        if(inDegree[i] == 0){\n            queue[rear++] = i;\n        }\n    }\n    while(front != rear){\n        int course = queue[front++];\n        count++;\n        for(int i = 0; i < prerequisitesSize; i++){\n            if(prerequisites[i][1] == course){\n                inDegree[prerequisites[i][0]]--;\n                if(inDegree[prerequisites[i][0]] == 0){\n                    queue[rear++] = prerequisites[i][0];\n                }\n            }\n        }\n    }\n    return count == numCourses;\n\n}", "prefix": "bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize"}
{"id": "726", "path": "output2\\c\\Medium\\726-minimum-size-subarray-sum.c", "hypo_code": "int minSubArrayLen(int target, int* nums, int numsSize){\n    int result = 0;\n    int sum = 0;\n    int left = 0;\n    int right = 0;\n    while(right < numsSize){\n        sum += nums[right];\n        while(sum >= target){\n            if(result == 0 || result > right - left + 1){\n                result = right - left + 1;\n            }\n            sum -= nums[left];\n            left++;\n        }\n        right++;\n    }\n    return result;\n\n}", "prefix": "int minSubArrayLen(int target, int* nums, int numsSize"}
{"id": "727", "path": "output2\\c\\Medium\\727-course-schedule-ii.c", "hypo_code": "int* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize){\n    int* inDegree = (int*)malloc(sizeof(int) * numCourses);\n    memset(inDegree, 0, sizeof(int) * numCourses);\n    for(int i = 0; i < prerequisitesSize; i++){\n        inDegree[prerequisites[i][0]]++;\n    }\n    int count = 0;\n    int* queue = (int*)malloc(sizeof(int) * numCourses);\n    int front = 0;\n    int rear = 0;\n    for(int i = 0; i < numCourses; i++){\n        if(inDegree[i] == 0){\n            queue[rear++] = i;\n        }\n    }\n    int* res = (int*)malloc(sizeof(int) * numCourses);\n    while(front != rear){\n        int course = queue[front++];\n        res[count++] = course;\n        for(int i = 0; i < prerequisitesSize; i++){\n            if(prerequisites[i][1] == course){\n                inDegree[prerequisites[i][0]]--;\n                if(inDegree[prerequisites[i][0]] == 0){\n                    queue[rear++] = prerequisites[i][0];\n                }\n            }\n        }\n    }\n    if(count == numCourses){\n        *returnSize = count;\n        return res;\n    }\n    *returnSize = 0;\n    return NULL;\n\n}", "prefix": "int* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize"}
{"id": "729", "path": "output2\\c\\Medium\\729-house-robber-ii.c", "hypo_code": "int rob(int* nums, int numsSize){\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    if(numsSize == 0){\n        return 0;\n    }\n    if(numsSize == 1){\n        return nums[0];\n    }\n    if(numsSize == 2){\n        return fmax(nums[0], nums[1]);\n    }\n    result[0] = nums[0];\n    result[1] = fmax(nums[0], nums[1]);\n    for(int i = 2; i < numsSize; i++){\n        result[i] = fmax(result[i - 1], result[i - 2] + nums[i]);\n    }\n    return result[numsSize - 1];\n\n\n}", "prefix": "int rob(int* nums, int numsSize"}
{"id": "730", "path": "output2\\c\\Medium\\730-kth-largest-element-in-an-array.c", "hypo_code": "int findKthLargest(int* nums, int numsSize, int k){\n    int left = 0;\n    int right = numsSize - 1;\n    while(left <= right){\n        int pivot = nums[left];\n        int i = left;\n        int j = right;\n        while(i < j){\n            while(i < j && nums[j] <= pivot){\n                j--;\n            }\n            nums[i] = nums[j];\n            while(i < j && nums[i] >= pivot){\n                i++;\n            }\n            nums[j] = nums[i];\n        }\n        nums[i] = pivot;\n        if(i == k - 1){\n            return nums[i];\n        }\n        else if(i < k - 1){\n            left = i + 1;\n        }\n        else{\n            right = i - 1;\n        }\n    }\n    return -1;\n\n}", "prefix": "int findKthLargest(int* nums, int numsSize, int k"}
{"id": "731", "path": "output2\\c\\Medium\\731-combination-sum-iii.c", "hypo_code": "int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL;\n\n}", "prefix": "int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes"}
{"id": "732", "path": "output2\\c\\Medium\\732-maximal-square.c", "hypo_code": "int maximalSquare(char** matrix, int matrixSize, int* matrixColSize){\n    int max = 0;\n    int** result = (int**)malloc(sizeof(int*) * matrixSize);\n    for(int i = 0; i < matrixSize; i++){\n        result[i] = (int*)malloc(sizeof(int) * matrixColSize[0]);\n        for(int j = 0; j < matrixColSize[0]; j++){\n            result[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < matrixSize; i++){\n        for(int j = 0; j < matrixColSize[0]; j++){\n            if(matrix[i][j] == '1'){\n                if(i == 0 || j == 0){\n                    result[i][j] = 1;\n                }else{\n                    result[i][j] = 1 + fmin(fmin(result[i - 1][j], result[i][j - 1]), result[i - 1][j - 1]);\n                }\n                if(result[i][j] > max){\n                    max = result[i][j];\n                }\n            }\n        }\n    }\n    return max * max;\n\n}", "prefix": "int maximalSquare(char** matrix, int matrixSize, int* matrixColSize"}
{"id": "733", "path": "output2\\c\\Medium\\733-rectangle-area.c", "hypo_code": "int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2){\n    int area1 = (ax2 - ax1) * (ay2 - ay1);\n    int area2 = (bx2 - bx1) * (by2 - by1);\n    int overlap = 0;\n    if(ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1){\n        int x1 = ax1 > bx1 ? ax1 : bx1;\n        int x2 = ax2 < bx2 ? ax2 : bx2;\n        int y1 = ay1 > by1 ? ay1 : by1;\n        int y2 = ay2 < by2 ? ay2 : by2;\n        overlap = (x2 - x1) * (y2 - y1);\n    }\n    return area1 + area2 - overlap;\n\n}", "prefix": "int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2"}
{"id": "734", "path": "output2\\c\\Medium\\734-basic-calculator-ii.c", "hypo_code": "int calculate(char * s){\n    int len = strlen(s);\n    int* stack = (int*)malloc(sizeof(int) * len);\n    int top = -1;\n    int num = 0;\n    char sign = '+';\n    for(int i = 0; i < len; i++){\n        if(s[i] >= '0' && s[i] <= '9'){\n            num = num * 10 + s[i] - '0';\n        }\n        if((s[i] < '0' && s[i] != ' ') || i == len - 1){\n            if(sign == '+'){\n                stack[++top] = num;\n            }\n            else if(sign == '-'){\n                stack[++top] = -num;\n            }\n            else if(sign == '*'){\n                stack[top] = stack[top] * num;\n            }\n            else if(sign == '/'){\n                stack[top] = stack[top] / num;\n            }\n            sign = s[i];\n            num = 0;\n        }\n    }\n    int result = 0;\n    for(int i = 0; i <= top; i++){\n        result += stack[i];\n    }\n    return result;\n\n}", "prefix": "int calculate(char * s"}
{"id": "735", "path": "output2\\c\\Medium\\735-majority-element-ii.c", "hypo_code": "int* majorityElement(int* nums, int numsSize, int* returnSize){\n*returnSize = 0;\n    int *res = (int *)malloc(sizeof(int) * 2);\n    int candidate1 = 0, candidate2 = 0, count1 = 0, count2 = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] == candidate1) {\n            count1++;\n        } else if (nums[i] == candidate2) {\n            count2++;\n        } else if (count1 == 0) {\n            candidate1 = nums[i];\n            count1++;\n        } else if (count2 == 0) {\n            candidate2 = nums[i];\n            count2++;\n        } else {\n            count1--;\n            count2--;\n        }\n    }\n    count1 = 0, count2 = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] == candidate1) {\n            count1++;\n        } else if (nums[i] == candidate2) {\n            count2++;\n        }\n    }\n    if (count1 > numsSize / 3) {\n        res[(*returnSize)++] = candidate1;\n    }\n    if (count2 > numsSize / 3) {\n        res[(*returnSize)++] = candidate2;\n    }\n    return res;\n}", "prefix": "int* majorityElement(int* nums, int numsSize, int* returnSize"}
{"id": "736", "path": "output2\\c\\Medium\\736-kth-smallest-element-in-a-bst.c", "hypo_code": "int kthSmallest(struct TreeNode* root, int k){\n    int left = 0;\n    int right = 0;\n    struct TreeNode* leftNode = root;\n    struct TreeNode* rightNode = root;\n    while(leftNode != NULL){\n        left++;\n        leftNode = leftNode->left;\n    }\n    while(rightNode != NULL){\n        right++;\n        rightNode = rightNode->right;\n    }\n    if(left == right){\n        return (1 << left) - 1;\n    }\n    return 1 + kthSmallest(root->left, k) + kthSmallest(root->right, k);\n\n}", "prefix": "int kthSmallest(struct TreeNode* root, int k"}
{"id": "737", "path": "output2\\c\\Medium\\737-lowest-common-ancestor-of-a-binary-search-tree.c", "hypo_code": "struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if(root == NULL){\n        return NULL;\n    }\n    if(root->val > p->val && root->val > q->val){\n        return lowestCommonAncestor(root->left, p, q);\n    }\n    if(root->val < p->val && root->val < q->val){\n        return lowestCommonAncestor(root->right, p, q);\n    }\n    return root;\n    \n}", "prefix": "struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q"}
{"id": "738", "path": "output2\\c\\Medium\\738-lowest-common-ancestor-of-a-binary-tree.c", "hypo_code": "struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if(root == NULL){\n        return NULL;\n    }\n    if(root == p || root == q){\n        return root;\n    }\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\n    if(left != NULL && right != NULL){\n        return root;\n    }\n    if(left != NULL){\n        return left;\n    }\n    if(right != NULL){\n        return right;\n    }\n    return NULL;\n    \n}", "prefix": "struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q"}
{"id": "739", "path": "output2\\c\\Medium\\739-delete-node-in-a-linked-list.c", "hypo_code": "void deleteNode(struct ListNode* node) {\n    struct ListNode* temp = node->next;\n    node->val = temp->val;\n    node->next = temp->next;\n    free(temp);\n    return;\n    \n}", "prefix": "void deleteNode(struct ListNode* node"}
{"id": "740", "path": "output2\\c\\Medium\\740-product-of-array-except-self.c", "hypo_code": "int* productExceptSelf(int* nums, int numsSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    int* left = (int*)malloc(sizeof(int) * numsSize);\n    int* right = (int*)malloc(sizeof(int) * numsSize);\n    left[0] = 1;\n    right[numsSize - 1] = 1;\n    for(int i = 1; i < numsSize; i++){\n        left[i] = left[i - 1] * nums[i - 1];\n    }\n    for(int i = numsSize - 2; i >= 0; i--){\n        right[i] = right[i + 1] * nums[i + 1];\n    }\n    for(int i = 0; i < numsSize; i++){\n        result[i] = left[i] * right[i];\n    }\n    *returnSize = numsSize;\n    return result;\n\n}", "prefix": "int* productExceptSelf(int* nums, int numsSize, int* returnSize"}
{"id": "741", "path": "output2\\c\\Medium\\741-search-a-2d-matrix-ii.c", "hypo_code": "bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\n    int row = 0;\n    int col = *matrixColSize - 1;\n    while(row < matrixSize && col >= 0){\n        if(matrix[row][col] == target){\n            return true;\n        }\n        else if(matrix[row][col] > target){\n            col--;\n        }\n        else{\n            row++;\n        }\n    }\n    return false;\n\n}", "prefix": "bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target"}
{"id": "742", "path": "output2\\c\\Medium\\742-different-ways-to-add-parentheses.c", "hypo_code": "int* diffWaysToCompute(char * expression, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 10000);\n    int resultSize = 0;\n    int expressionSize = strlen(expression);\n    for(int i = 0; i < expressionSize; i++){\n        if(expression[i] == '+' || expression[i] == '-' || expression[i] == '*'){\n            int* left = diffWaysToCompute(strndup(expression, i), returnSize);\n            int* right = diffWaysToCompute(strndup(expression + i + 1, expressionSize - i - 1), returnSize);\n            for(int j = 0; j < *returnSize; j++){\n                for(int k = 0; k < *returnSize; k++){\n                    if(expression[i] == '+'){\n                        result[resultSize++] = left[j] + right[k];\n                    }\n                    else if(expression[i] == '-'){\n                        result[resultSize++] = left[j] - right[k];\n                    }\n                    else if(expression[i] == '*'){\n                        result[resultSize++] = left[j] * right[k];\n                    }\n                }\n            }\n        }\n    }\n    if(resultSize == 0){\n        result[resultSize++] = atoi(expression);\n    }\n    *returnSize = resultSize;\n    return result;\n\n}", "prefix": "int* diffWaysToCompute(char * expression, int* returnSize"}
{"id": "743", "path": "output2\\c\\Medium\\743-single-number-iii.c", "hypo_code": "int* singleNumber(int* nums, int numsSize, int* returnSize){\n*returnSize = 0;\n    int *res = (int *)malloc(sizeof(int) * 2);\n    int xor = 0;\n    for (int i = 0; i < numsSize; i++) {\n        xor ^= nums[i];\n    }\n    int mask = 1;\n    while ((xor & mask) == 0) {\n        mask <<= 1;\n    }\n    for (int i = 0; i < numsSize; i++) {\n        if ((nums[i] & mask) == 0) {\n            res[0] ^= nums[i];\n        } else {\n            res[1] ^= nums[i];\n        }\n    }\n    return res;\n}", "prefix": "int* singleNumber(int* nums, int numsSize, int* returnSize"}
{"id": "744", "path": "output2\\c\\Medium\\744-ugly-number-ii.c", "hypo_code": "int nthUglyNumber(int n){\nif (n <= 0) {\n        return 0;\n    }\n    int *uglyNumbers = (int *)malloc(sizeof(int) * n);\n    int index2 = 0, index3 = 0, index5 = 0;\n    uglyNumbers[0] = 1;\n    int next = 1;\n    while (next < n) {\n        int min = min3(uglyNumbers[index2] * 2, uglyNumbers[index3] * 3, uglyNumbers[index5] * 5);\n        uglyNumbers[next] = min;\n        while (uglyNumbers[index2] * 2 <= uglyNumbers[next]) {\n            index2++;\n        }\n        while (uglyNumbers[index3] * 3 <= uglyNumbers[next]) {\n            index3++;\n        }\n        while (uglyNumbers[index5] * 5 <= uglyNumbers[next]) {\n            index5++;\n        }\n        next++;\n    }\n    return uglyNumbers[n - 1];\n\n}", "prefix": "int nthUglyNumber(int n"}
{"id": "745", "path": "output2\\c\\Medium\\745-h-index.c", "hypo_code": "int hIndex(int* citations, int citationsSize){\nif (citationsSize <= 0) {\n        return 0;\n    }\n    int *count = (int *)malloc(sizeof(int) * (citationsSize + 1));\n    memset(count, 0, sizeof(int) * (citationsSize + 1));\n    for (int i = 0; i < citationsSize; i++) {\n        if (citations[i] > citationsSize) {\n            count[citationsSize]++;\n        } else {\n            count[citations[i]]++;\n        }\n    }\n    int sum = 0;\n    for (int i = citationsSize; i >= 0; i--) {\n        sum += count[i];\n        if (sum >= i) {\n            return i;\n        }\n    }\n    return 0;\n}", "prefix": "int hIndex(int* citations, int citationsSize"}
{"id": "746", "path": "output2\\c\\Medium\\746-h-index-ii.c", "hypo_code": "int hIndex(int* citations, int citationsSize){\nif (citationsSize <= 0) {\n        return 0;\n    }\n    int left = 0, right = citationsSize - 1;\n    while (left <= right) {\n        int mid = left + ((right - left) >> 1);\n        if (citations[mid] >= citationsSize - mid) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return citationsSize - left;\n}", "prefix": "int hIndex(int* citations, int citationsSize"}
{"id": "747", "path": "output2\\c\\Medium\\747-perfect-squares.c", "hypo_code": "int numSquares(int n){\nif (n <= 0) {\n        return 0;\n    }\n    int *dp = (int *)malloc(sizeof(int) * (n + 1));\n    memset(dp, 0, sizeof(int) * (n + 1));\n    for (int i = 1; i <= n; i++) {\n        dp[i] = i;\n        for (int j = 1; i - j * j >= 0; j++) {\n            dp[i] = min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    return dp[n];\n}", "prefix": "int numSquares(int n"}
{"id": "749", "path": "output2\\c\\Medium\\749-find-the-duplicate-number.c", "hypo_code": "int findDuplicate(int* nums, int numsSize){\nif (numsSize <= 0) {\n        return 0;\n    }\n    int slow = 0, fast = 0;\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n    int ptr = 0;\n    while (ptr != slow) {\n        ptr = nums[ptr];\n        slow = nums[slow];\n    }\n    return slow;\n}", "prefix": "int findDuplicate(int* nums, int numsSize"}
{"id": "750", "path": "output2\\c\\Medium\\750-game-of-life.c", "hypo_code": "void gameOfLife(int** board, int boardSize, int* boardColSize){\nint neighbors[3] = {0, 1, -1};\n    int rows = boardSize;\n    int cols = *boardColSize;\n    for (int row = 0; row < rows; row++) {\n        for (int col = 0; col < cols; col++) {\n            int liveNeighbors = 0;\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    if (!(neighbors[i] == 0 && neighbors[j] == 0)) {\n                        int r = (row + neighbors[i]);\n                        int c = (col + neighbors[j]);\n                        if ((r < rows && r >= 0) && (c < cols && c >= 0) && (abs(board[r][c]) == 1)) {\n                            liveNeighbors++;\n                        }\n                    }\n                }\n            }\n            if ((board[row][col] == 1) && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                board[row][col] = -1;\n            }\n            if (board[row][col] == 0 && liveNeighbors == 3) {\n                board[row][col] = 2;\n            }\n        }\n    }\n    for (int row = 0; row < rows; row++) {\n        for (int col = 0; col < cols; col++) {\n            if (board[row][col] > 0) {\n                board[row][col] = 1;\n            } else {\n                board[row][col] = 0;\n            }\n        }\n    }\n}", "prefix": "void gameOfLife(int** board, int boardSize, int* boardColSize"}
{"id": "751", "path": "output2\\c\\Medium\\751-bulls-and-cows.c", "hypo_code": "char * getHint(char * secret, char * guess){\n    int len = strlen(secret);\n    int bulls = 0;\n    int cows = 0;\n    int* secretCount = (int*)calloc(10, sizeof(int));\n    int* guessCount = (int*)calloc(10, sizeof(int));\n    for(int i = 0; i < len; i++){\n        if(secret[i] == guess[i]){\n            bulls++;\n        }else{\n            secretCount[secret[i] - '0']++;\n            guessCount[guess[i] - '0']++;\n        }\n    }\n    for(int i = 0; i < 10; i++){\n        cows += secretCount[i] < guessCount[i] ? secretCount[i] : guessCount[i];\n    }\n    char* result = (char*)malloc(sizeof(char) * (len + 1));\n    sprintf(result, \"%dA%dB\", bulls, cows);\n    return result;\n\n}", "prefix": "char * getHint(char * secret, char * guess"}
{"id": "752", "path": "output2\\c\\Medium\\752-longest-increasing-subsequence.c", "hypo_code": "int lengthOfLIS(int* nums, int numsSize){\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    for(int i = 0; i < numsSize; i++){\n        result[i] = 1;\n    }\n    for(int i = 1; i < numsSize; i++){\n        for(int j = 0; j < i; j++){\n            if(nums[i] > nums[j]){\n                result[i] = fmax(result[i], result[j] + 1);\n            }\n        }\n    }\n    int max = 0;\n    for(int i = 0; i < numsSize; i++){\n        if(result[i] > max){\n            max = result[i];\n        }\n    }\n    return max;\n\n}", "prefix": "int lengthOfLIS(int* nums, int numsSize"}
{"id": "754", "path": "output2\\c\\Medium\\754-additive-number.c", "hypo_code": "bool isAdditiveNumber(char * num){\n    int len = strlen(num);\n    for(int i = 1; i <= len / 2; i++){\n        for(int j = 1; j <= (len - i) / 2; j++){\n            if(isValid(i, j, num)){\n                return true;\n            }\n        }\n    }\n    return false;\n\n}", "prefix": "bool isAdditiveNumber(char * num"}
{"id": "756", "path": "output2\\c\\Medium\\756-best-time-to-buy-and-sell-stock-with-cooldown.c", "hypo_code": "int maxProfit(int* prices, int pricesSize){\n    int dp[pricesSize][2];\n    dp[0][0] = 0;\n    dp[0][1] = -prices[0];\n    for(int i = 1; i < pricesSize; i++){\n        dp[i][0] = dp[i - 1][0] > dp[i - 1][1] + prices[i] ? dp[i - 1][0] : dp[i - 1][1] + prices[i];\n        if(i == 1){\n            dp[i][1] = dp[i - 1][1] > -prices[i] ? dp[i - 1][1] : -prices[i];\n        }\n        else{\n            dp[i][1] = dp[i - 1][1] > dp[i - 2][0] - prices[i] ? dp[i - 1][1] : dp[i - 2][0] - prices[i];\n        }\n    }\n    return dp[pricesSize - 1][0];\n\n}", "prefix": "int maxProfit(int* prices, int pricesSize"}
{"id": "757", "path": "output2\\c\\Medium\\757-minimum-height-trees.c", "hypo_code": "int* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * n);\n    int resultSize = 0;\n    if(n == 1){\n        result[resultSize++] = 0;\n    }\n    else{\n        int* degree = (int*)malloc(sizeof(int) * n);\n        memset(degree, 0, sizeof(int) * n);\n        int** graph = (int**)malloc(sizeof(int*) * n);\n        for(int i = 0; i < n; i++){\n            graph[i] = (int*)malloc(sizeof(int) * n);\n            memset(graph[i], 0, sizeof(int) * n);\n        }\n        for(int i = 0; i < edgesSize; i++){\n            degree[edges[i][0]]++;\n            degree[edges[i][1]]++;\n            graph[edges[i][0]][edges[i][1]] = 1;\n            graph[edges[i][1]][edges[i][0]] = 1;\n        }\n        int* queue = (int*)malloc(sizeof(int) * n);\n        int queueSize = 0;\n        for(int i = 0; i < n; i++){\n            if(degree[i] == 1){\n                queue[queueSize++] = i;\n            }\n        }\n        while(queueSize > 0){\n            int* newQueue = (int*)malloc(sizeof(int) * n);\n            int newQueueSize = 0;\n            for(int i = 0; i < queueSize; i++){\n                int node = queue[i];\n                result[resultSize++] = node;\n                for(int j = 0; j < n; j++){\n                    if(graph[node][j] == 1){\n                        degree[j]--;\n                        if(degree[j] == 1){\n                            newQueue[newQueueSize++] = j;\n                        }\n                    }\n                }\n            }\n            queue = newQueue;\n            queueSize = newQueueSize;\n        }\n    }\n    *returnSize = resultSize;\n    return result;\n\n}", "prefix": "int* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize"}
{"id": "758", "path": "output2\\c\\Medium\\758-super-ugly-number.c", "hypo_code": "int nthSuperUglyNumber(int n, int* primes, int primesSize){\nif (n <= 0) {\n        return 0;\n    }\n    int *uglyNumbers = (int *)malloc(sizeof(int) * n);\n    int *indexs = (int *)malloc(sizeof(int) * primesSize);\n    memset(indexs, 0, sizeof(int) * primesSize);\n    uglyNumbers[0] = 1;\n    int next = 1;\n    while (next < n) {\n        int min = INT_MAX;\n        int minIndex = -1;\n        for (int i = 0; i < primesSize; i++) {\n            int temp = uglyNumbers[indexs[i]] * primes[i];\n            if (temp < min) {\n                min = temp;\n                minIndex = i;\n            } else if (temp == min) {\n                indexs[i]++;\n            }\n        }\n        uglyNumbers[next] = min;\n        indexs[minIndex]++;\n        next++;\n    }\n    return uglyNumbers[n - 1];\n}", "prefix": "int nthSuperUglyNumber(int n, int* primes, int primesSize"}
{"id": "759", "path": "output2\\c\\Medium\\759-remove-duplicate-letters.c", "hypo_code": "char * removeDuplicateLetters(char * s){\n    int* count = (int*)malloc(sizeof(int) * 26);\n    for(int i = 0; i < 26; i++){\n        count[i] = 0;\n    }\n    int sSize = strlen(s);\n    for(int i = 0; i < sSize; i++){\n        count[s[i] - 'a']++;\n    }\n    int* visited = (int*)malloc(sizeof(int) * 26);\n    for(int i = 0; i < 26; i++){\n        visited[i] = 0;\n    }\n    char* result = (char*)malloc(sizeof(char) * (sSize + 1));\n    int resultSize = 0;\n    for(int i = 0; i < sSize; i++){\n        count[s[i] - 'a']--;\n        if(visited[s[i] - 'a'] == 1){\n            continue;\n        }\n        while(resultSize > 0 && result[resultSize - 1] > s[i] && count[result[resultSize - 1] - 'a'] > 0){\n            visited[result[resultSize - 1] - 'a'] = 0;\n            resultSize--;\n        }\n        result[resultSize++] = s[i];\n        visited[s[i] - 'a'] = 1;\n    }\n    result[resultSize] = '\\0';\n    return result;\n\n}", "prefix": "char * removeDuplicateLetters(char * s"}
{"id": "760", "path": "output2\\c\\Medium\\760-maximum-product-of-word-lengths.c", "hypo_code": "int maxProduct(char ** words, int wordsSize){\n    int* result = (int*)malloc(sizeof(int) * wordsSize);\n    for(int i = 0; i < wordsSize; i++){\n        result[i] = 0;\n    }\n    for(int i = 0; i < wordsSize; i++){\n        for(int j = 0; j < strlen(words[i]); j++){\n            result[i] |= 1 << (words[i][j] - 'a');\n        }\n    }\n    int max = 0;\n    for(int i = 0; i < wordsSize; i++){\n        for(int j = i + 1; j < wordsSize; j++){\n            if((result[i] & result[j]) == 0){\n                int temp = strlen(words[i]) * strlen(words[j]);\n                if(temp > max){\n                    max = temp;\n                }\n            }\n        }\n    }\n    return max;\n\n}", "prefix": "int maxProduct(char ** words, int wordsSize"}
{"id": "761", "path": "output2\\c\\Medium\\761-bulb-switcher.c", "hypo_code": "int bulbSwitch(int n){\n    return (int)sqrt(n);\n\n}", "prefix": "int bulbSwitch(int n"}
{"id": "762", "path": "output2\\c\\Medium\\762-coin-change.c", "hypo_code": "int coinChange(int* coins, int coinsSize, int amount){\nif (amount <= 0) {\n        return 0;\n    }\n    int *dp = (int *)malloc(sizeof(int) * (amount + 1));\n    memset(dp, 0, sizeof(int) * (amount + 1));\n    for (int i = 1; i <= amount; i++) {\n        dp[i] = amount + 1;\n        for (int j = 0; j < coinsSize; j++) {\n            if (coins[j] <= i) {\n                dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n            }\n        }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}", "prefix": "int coinChange(int* coins, int coinsSize, int amount"}
{"id": "763", "path": "output2\\c\\Medium\\763-wiggle-sort-ii.c", "hypo_code": "void wiggleSort(int* nums, int numsSize){\nint *tmp = (int *)malloc(sizeof(int) * numsSize);\n    memcpy(tmp, nums, sizeof(int) * numsSize);\n    int mid = (numsSize + 1) >> 1;\n    int left = mid - 1, right = numsSize - 1;\n    for (int i = 0; i < numsSize; i++) {\n        if ((i & 1) == 0) {\n            nums[i] = tmp[left--];\n        } else {\n            nums[i] = tmp[right--];\n        }\n    }\n}", "prefix": "void wiggleSort(int* nums, int numsSize"}
{"id": "764", "path": "output2\\c\\Medium\\764-odd-even-linked-list.c", "hypo_code": "struct ListNode* oddEvenList(struct ListNode* head){\nif (head == NULL || head->next == NULL) {\n        return head;\n    }\n    struct ListNode *odd = head, *even = head->next, *evenHead = even;\n    while (even != NULL && even->next != NULL) {\n        odd->next = even->next;\n        odd = odd->next;\n        even->next = odd->next;\n        even = even->next;        \n    }\n    odd->next = evenHead;\n    return head;\n}", "prefix": "struct ListNode* oddEvenList(struct ListNode* head"}
{"id": "765", "path": "output2\\c\\Medium\\765-verify-preorder-serialization-of-a-binary-tree.c", "hypo_code": "bool isValidSerialization(char * preorder){\nint n = strlen(preorder);\n    int i = 0;\n    int slots = 1;\n    while (i < n) {\n        if (slots == 0) {\n            return false;\n        }\n        if (preorder[i] == ',') {\n            i++;\n        } else if (preorder[i] == '#') {\n            slots--;\n            i++;\n        } else {\n            while (i < n && preorder[i] != ',') {\n                i++;\n            }\n            slots++;\n        }\n    }\n    return slots == 0;\n}", "prefix": "bool isValidSerialization(char * preorder"}
{"id": "766", "path": "output2\\c\\Medium\\766-increasing-triplet-subsequence.c", "hypo_code": "bool increasingTriplet(int* nums, int numsSize){\nint min1 = 0x7fffffff, min2 = 0x7fffffff;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] <= min1) {\n            min1 = nums[i];\n        } else if (nums[i] <= min2) {\n            min2 = nums[i];\n        } else {\n            return true;\n        }\n    }\n    return false;\n}", "prefix": "bool increasingTriplet(int* nums, int numsSize"}
{"id": "767", "path": "output2\\c\\Medium\\767-house-robber-iii.c", "hypo_code": "int rob(struct TreeNode* root){\nif (root == NULL) {\n        return 0;\n    }\n    int val = 0;\n    if (root->left != NULL) {\n        val += rob(root->left->left) + rob(root->left->right);\n    }\n    if (root->right != NULL) {\n        val += rob(root->right->left) + rob(root->right->right);\n    }\n    return fmax(val + root->val, rob(root->left) + rob(root->right));\n\n}", "prefix": "int rob(struct TreeNode* root"}
{"id": "769", "path": "output2\\c\\Medium\\769-integer-break.c", "hypo_code": "int integerBreak(int n){\nif (n <= 0) {\n        return 0;\n    }\n    int *dp = (int *)malloc(sizeof(int) * (n + 1));\n    memset(dp, 0, sizeof(int) * (n + 1));\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j < i; j++) {\n            dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j)));\n        }\n    }\n    return dp[n];\n}", "prefix": "int integerBreak(int n"}
{"id": "770", "path": "output2\\c\\Medium\\770-top-k-frequent-elements.c", "hypo_code": "int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\n*returnSize = 0;\n    int *res = (int *)malloc(sizeof(int) * k);\n    int *freq = (int *)malloc(sizeof(int) * (numsSize + 1));\n    memset(freq, 0, sizeof(int) * (numsSize + 1));\n    for (int i = 0; i < numsSize; i++) {\n        freq[nums[i]]++;\n    }\n    int max = 0;\n    for (int i = 0; i < numsSize + 1; i++) {\n        if (freq[i] > max) {\n            max = freq[i];\n        }\n    }\n    int **buckets = (int **)malloc(sizeof(int *) * (max + 1));\n    memset(buckets, 0, sizeof(int *) * (max + 1));\n    for (int i = 0; i < numsSize + 1; i++) {\n        if (freq[i] > 0) {\n            if (buckets[freq[i]] == NULL) {\n                buckets[freq[i]] = (int *)malloc(sizeof(int) * (numsSize + 1));\n                memset(buckets[freq[i]], 0, sizeof(int) * (numsSize + 1));\n            }\n            buckets[freq[i]][0]++;\n            buckets[freq[i]][buckets[freq[i]][0]] = i;\n        }\n    }\n    int idx = 0;\n    for (int i = max; i > 0 && idx < k; i--) {\n        if (buckets[i] != NULL) {\n            int len = buckets[i][0];\n            for (int j = 1; j <= len && idx < k; j++) {\n                res[idx++] = buckets[i][j];\n            }\n        }\n    }\n    return res;\n}", "prefix": "int* topKFrequent(int* nums, int numsSize, int k, int* returnSize"}
{"id": "772", "path": "output2\\c\\Medium\\772-count-numbers-with-unique-digits.c", "hypo_code": "int countNumbersWithUniqueDigits(int n){\nif (n == 0) {\n        return 1;\n    }\n    int dp[9] = {0};\n    dp[0] = 1;\n    dp[1] = 10;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + (dp[i - 1] - dp[i - 2]) * (10 - i + 1);\n    }\n    return dp[n];\n}", "prefix": "int countNumbersWithUniqueDigits(int n"}
{"id": "773", "path": "output2\\c\\Medium\\773-water-and-jug-problem.c", "hypo_code": "bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity){       \n         \n}", "prefix": "bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity"}
{"id": "774", "path": "output2\\c\\Medium\\774-largest-divisible-subset.c", "hypo_code": "int* largestDivisibleSubset(int* nums, int numsSize, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * numsSize);\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tint max = 0, max_i = 0;\n\t*returnSize = 0;\n\tif (numsSize == 0) return res;\n\tqsort(nums, numsSize, sizeof(int), cmp);\n\tfor (int i = 0; i < numsSize; i++) {\n\t\tdp[i] = 1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (nums[i] % nums[j] == 0 && dp[i] < dp[j] + 1) {\n\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t}\n\t\t}\n\t\tif (max < dp[i]) {\n\t\t\tmax = dp[i];\n\t\t\tmax_i = i;\n\t\t}\n\t}\n\tfor (int i = max_i, temp = nums[max_i], j = max - 1; i >= 0; i--) {\n\t\tif (temp % nums[i] == 0 && dp[i] == j) {\n\t\t\tres[(*returnSize)++] = nums[i];\n\t\t\ttemp = nums[i];\n\t\t\tj--;\n\t\t}\n\t}\n\tfree(dp);\n\treturn res;\n}", "prefix": "int* largestDivisibleSubset(int* nums, int numsSize, int* returnSize"}
{"id": "775", "path": "output2\\c\\Medium\\775-sum-of-two-integers.c", "hypo_code": "int getSum(int a, int b){\n    int result = 0;\n    int carry = 0;\n    for(int i = 0; i < 32; i++){\n        int bitA = (a >> i) & 1;\n        int bitB = (b >> i) & 1;\n        int bitResult = bitA ^ bitB ^ carry;\n        carry = (bitA & bitB) | (bitA & carry) | (bitB & carry);\n        result |= bitResult << i;\n    }\n    return result;\n\n}", "prefix": "int getSum(int a, int b"}
{"id": "776", "path": "output2\\c\\Medium\\776-super-pow.c", "hypo_code": "int superPow(int a, int* b, int bSize){\n    int result = 1;\n    for(int i = 0; i < bSize; i++){\n        result = pow(result, 10) * pow(a, b[i]) % 1337;\n    }\n    return result;\n\n}", "prefix": "int superPow(int a, int* b, int bSize"}
{"id": "777", "path": "output2\\c\\Medium\\777-find-k-pairs-with-smallest-sums.c", "hypo_code": "int** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * k);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * k);\n    int resultSize = 0;\n    int* nums1Index = (int*)malloc(sizeof(int) * nums1Size);\n    int* nums2Index = (int*)malloc(sizeof(int) * nums2Size);\n    for(int i = 0; i < nums1Size; i++){\n        nums1Index[i] = 0;\n    }\n    for(int i = 0; i < nums2Size; i++){\n        nums2Index[i] = 0;\n    }\n    for(int i = 0; i < k; i++){\n        int min = INT_MAX;\n        int minIndex = -1;\n        for(int j = 0; j < nums1Size; j++){\n            if(nums1Index[j] < nums2Size && nums1[j] + nums2[nums1Index[j]] < min){\n                min = nums1[j] + nums2[nums1Index[j]];\n                minIndex = j;\n            }\n        }\n        if(minIndex == -1){\n            break;\n        }\n        result[resultSize] = (int*)malloc(sizeof(int) * 2);\n        result[resultSize][0] = nums1[minIndex];\n        result[resultSize][1] = nums2[nums1Index[minIndex]];\n        (*returnColumnSizes)[resultSize] = 2;\n        resultSize++;\n        nums1Index[minIndex]++;\n    }\n    *returnSize = resultSize;\n    return result;\n\n}", "prefix": "int** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes"}
{"id": "778", "path": "output2\\c\\Medium\\778-guess-number-higher-or-lower-ii.c", "hypo_code": "int getMoneyAmount(int n){\n    int** dp = (int**)malloc(sizeof(int*) * (n + 1));\n    for(int i = 0; i <= n; i++){\n        dp[i] = (int*)malloc(sizeof(int) * (n + 1));\n        memset(dp[i], 0, sizeof(int) * (n + 1));\n    }\n    for(int i = 2; i <= n; i++){\n        for(int j = i - 1; j > 0; j--){\n            int min = INT_MAX;\n            for(int k = j + 1; k < i; k++){\n                int temp = k + max(dp[j][k - 1], dp[k + 1][i]);\n                min = min < temp ? min : temp;\n            }\n            dp[j][i] = j + 1 == i ? j : min;\n        }\n    }\n    return dp[1][n];\n\n}", "prefix": "int getMoneyAmount(int n"}
{"id": "779", "path": "output2\\c\\Medium\\779-wiggle-subsequence.c", "hypo_code": "int wiggleMaxLength(int* nums, int numsSize){\n    if(numsSize < 2){\n        return numsSize;\n    }\n    int* up = (int*)malloc(sizeof(int) * numsSize);\n    int* down = (int*)malloc(sizeof(int) * numsSize);\n    up[0] = 1;\n    down[0] = 1;\n    for(int i = 1; i < numsSize; i++){\n        if(nums[i] > nums[i - 1]){\n            up[i] = down[i - 1] + 1;\n            down[i] = down[i - 1];\n        }else if(nums[i] < nums[i - 1]){\n            down[i] = up[i - 1] + 1;\n            up[i] = up[i - 1];\n        }else{\n            up[i] = up[i - 1];\n            down[i] = down[i - 1];\n        }\n    }\n    return fmax(up[numsSize - 1], down[numsSize - 1]);\n\n}", "prefix": "int wiggleMaxLength(int* nums, int numsSize"}
{"id": "780", "path": "output2\\c\\Medium\\780-combination-sum-iv.c", "hypo_code": "int combinationSum4(int* nums, int numsSize, int target){\n    int* result = (int*)malloc(sizeof(int) * (target + 1));\n    result[0] = 1;\n    for(int i = 1; i <= target; i++){\n        result[i] = 0;\n        for(int j = 0; j < numsSize; j++){\n            if(i - nums[j] >= 0){\n                result[i] += result[i - nums[j]];\n            }\n        }\n    }\n    return result[target];\n\n}", "prefix": "int combinationSum4(int* nums, int numsSize, int target"}
{"id": "781", "path": "output2\\c\\Medium\\781-kth-smallest-element-in-a-sorted-matrix.c", "hypo_code": "int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k){\n    int left = matrix[0][0];\n    int right = matrix[matrixSize - 1][matrixSize - 1];\n    while(left < right){\n        int mid = left + (right - left) / 2;\n        int count = 0;\n        for(int i = 0; i < matrixSize; i++){\n            int j = 0;\n            while(j < matrixSize && matrix[i][j] <= mid){\n                j++;\n            }\n            count += j;\n        }\n        if(count < k){\n            left = mid + 1;\n        }\n        else{\n            right = mid;\n        }\n    }\n    return left;\n\n}", "prefix": "int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k"}
{"id": "785", "path": "output2\\c\\Medium\\785-mini-parser.c", "hypo_code": "struct NestedInteger* deserialize(char * s){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    struct NestedInteger* res = NestedIntegerInit();\n    struct NestedInteger* temp = NestedIntegerInit();\n    struct NestedInteger** temp2 = NULL;\n    while (i < len) {\n        if (s[i] == '[') {\n            if (j != i) {\n                NestedIntegerSetInteger(temp, atoi(s + j));\n                NestedIntegerAdd(res, temp);\n                temp = NestedIntegerInit();\n            }\n            temp2 = NestedIntegerGetList(res);\n            temp = NestedIntegerInit();\n            temp2[k++] = temp;\n            i++;\n            j = i;\n        } else if (s[i] == ']') {\n            if (j != i) {\n                NestedIntegerSetInteger(temp, atoi(s + j));\n                NestedIntegerAdd(res, temp);\n                temp = NestedIntegerInit();\n            }\n            temp = temp2[--k];\n            temp2[k] = NULL;\n            i++;\n            j = i;\n        } else if (s[i] == ',') {\n            if (j != i) {\n                NestedIntegerSetInteger(temp, atoi(s + j));\n                NestedIntegerAdd(res, temp);\n                temp = NestedIntegerInit();\n            }\n            i++;\n            j = i;\n        } else {\n            i++;\n        }\n    }\n    if (j != i) {\n        NestedIntegerSetInteger(temp, atoi(s + j));\n        NestedIntegerAdd(res, temp);\n    }\n    temp = NestedIntegerGetList(res)[0];\n    free(res);\n    return temp;\n}", "prefix": "struct NestedInteger* deserialize(char * s"}
{"id": "786", "path": "output2\\c\\Medium\\786-lexicographical-numbers.c", "hypo_code": "int* lexicalOrder(int n, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * n);\n    int resultSize = 0;\n    int current = 1;\n    for(int i = 0; i < n; i++){\n        result[resultSize++] = current;\n        if(current * 10 <= n){\n            current *= 10;\n        }else{\n            if(current >= n){\n                current /= 10;\n            }\n            current++;\n            while(current % 10 == 0){\n                current /= 10;\n            }\n        }\n    }\n    *returnSize = resultSize;\n    return result;\n\n}", "prefix": "int* lexicalOrder(int n, int* returnSize"}
{"id": "787", "path": "output2\\c\\Medium\\787-longest-absolute-file-path.c", "hypo_code": "int lengthLongestPath(char * input){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(input);\n    struct NestedInteger* res = NestedIntegerInit();\n    struct NestedInteger* temp = NestedIntegerInit();\n    struct NestedInteger** temp2 = NULL;\n    while (i < len) {\n        if (input[i] == '\\n') {\n            if (j == 0) {\n                NestedIntegerSetInteger(temp, atoi(input + i - j));\n                NestedIntegerAdd(res, temp);\n            } else {\n                NestedIntegerSetInteger(temp, atoi(input + i - j));\n                NestedIntegerAdd(temp2[k], temp);\n            }\n            j = 0;\n            k = 0;\n            i++;\n            continue;\n        }\n        if (input[i] == '[') {\n            temp2 = (struct NestedInteger**)malloc(sizeof(struct NestedInteger*) * 1000);\n            NestedIntegerAdd(res, temp2[k]);\n            k++;\n            i++;\n            continue;\n        }\n        if (input[i] == ']') {\n            k--;\n            i++;\n            continue;\n        }\n        if (input[i] == ',') {\n            NestedIntegerSetInteger(temp, atoi(input + i - j));\n            NestedIntegerAdd(temp2[k], temp);\n            j = 0;\n            i++;\n            continue;\n        }\n        j++;\n        i++;\n    }\n    return res;\n}", "prefix": "int lengthLongestPath(char * input"}
{"id": "788", "path": "output2\\c\\Medium\\788-elimination-game.c", "hypo_code": "int lastRemaining(int n){\n    int head = 1;\n    int step = 1;\n    int remaining = n;\n    int left = 1;\n    while(remaining > 1){\n        if(left || remaining % 2 == 1){\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        left = !left;\n    }\n    return head;\n\n}", "prefix": "int lastRemaining(int n"}
{"id": "789", "path": "output2\\c\\Medium\\789-utf-8-validation.c", "hypo_code": "bool validUtf8(int* data, int dataSize){\n    int count = 0;\n    for(int i = 0; i < dataSize; i++){\n        if(count == 0){\n            if((data[i] >> 3) == 0b11110){\n                count = 3;\n            }else if((data[i] >> 4) == 0b1110){\n                count = 2;\n            }else if((data[i] >> 5) == 0b110){\n                count = 1;\n            }else if((data[i] >> 7) == 0b0){\n                count = 0;\n            }else{\n                return false;\n            }\n        }else{\n            if((data[i] >> 6) == 0b10){\n                count--;\n            }else{\n                return false;\n            }\n        }\n    }\n    return count == 0;\n\n}", "prefix": "bool validUtf8(int* data, int dataSize"}
{"id": "790", "path": "output2\\c\\Medium\\790-decode-string.c", "hypo_code": "char * decodeString(char * s){\n    int length = strlen(s);\n    char* result = (char*)malloc(sizeof(char) * (length + 1));\n    int resultSize = 0;\n    int* count = (int*)malloc(sizeof(int) * length);\n    int countSize = 0;\n    for(int i = 0; i < length; i++){\n        if(s[i] >= '0' && s[i] <= '9'){\n            int start = i;\n            while(s[i] >= '0' && s[i] <= '9'){\n                i++;\n            }\n            char* temp = (char*)malloc(sizeof(char) * (i - start + 1));\n            strncpy(temp, s + start, i - start);\n            temp[i - start] = '\\0';\n            count[countSize++] = atoi(temp);\n            free(temp);\n        }\n        if(s[i] == '['){\n            continue;\n        }\n        if(s[i] == ']'){\n            int tempSize = 0;\n            char* temp = (char*)malloc(sizeof(char) * (resultSize + 1));\n            while(resultSize > 0 && result[resultSize - 1] != '['){\n                temp[tempSize++] = result[--resultSize];\n            }\n            resultSize--;\n            int tempCount = count[--countSize];\n            for(int j = 0; j < tempCount; j++){\n                for(int k = tempSize - 1; k >= 0; k--){\n                    result[resultSize++] = temp[k];\n                }\n            }\n            free(temp);\n        }else{\n            result[resultSize++] = s[i];\n        }\n    }\n    result[resultSize] = '\\0';\n    return result;\n\n}", "prefix": "char * decodeString(char * s"}
{"id": "791", "path": "output2\\c\\Medium\\791-longest-substring-with-at-least-k-repeating-characters.c", "hypo_code": "int longestSubstring(char * s, int k){\n    int* result = (int*)malloc(sizeof(int) * 26);\n    for(int i = 0; i < 26; i++){\n        result[i] = 0;\n    }\n    int length = strlen(s);\n    for(int i = 0; i < length; i++){\n        result[s[i] - 'a']++;\n    }\n    int max = 0;\n    int start = 0;\n    for(int i = 0; i < length; i++){\n        if(result[s[i] - 'a'] < k){\n            int temp = longestSubstring(s + start, k);\n            if(temp > max){\n                max = temp;\n            }\n            start = i + 1;\n        }\n    }\n    if(start == 0){\n        return length;\n    }\n    int temp = longestSubstring(s + start, k);\n    if(temp > max){\n        max = temp;\n    }\n    return max;\n\n}", "prefix": "int longestSubstring(char * s, int k"}
{"id": "792", "path": "output2\\c\\Medium\\792-rotate-function.c", "hypo_code": "int maxRotateFunction(int* nums, int numsSize){\n    int sum = 0;\n    int f = 0;\n    for(int i = 0; i < numsSize; i++){\n        sum += nums[i];\n        f += i * nums[i];\n    }\n    int max = f;\n    for(int i = 1; i < numsSize; i++){\n        f += sum - numsSize * nums[numsSize - i];\n        if(f > max){\n            max = f;\n        }\n    }\n    return max;\n\n}", "prefix": "int maxRotateFunction(int* nums, int numsSize"}
{"id": "793", "path": "output2\\c\\Medium\\793-integer-replacement.c", "hypo_code": "int integerReplacement(int n){\n    int count = 0;\n    while(n != 1){\n        if(n % 2 == 0){\n            n /= 2;\n        }else{\n            if(n == 3 || (n + 1) % 4 == 0){\n                n--;\n            }else{\n                n++;\n            }\n        }\n        count++;\n    }\n    return count;\n\n}", "prefix": "int integerReplacement(int n"}
{"id": "795", "path": "output2\\c\\Medium\\795-evaluate-division.c", "hypo_code": "double* calcEquation(char *** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char *** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    double* result = (double*)malloc(sizeof(double) * queriesSize);\n    *returnSize = queriesSize;\n    for(int i = 0; i < queriesSize; i++){\n        result[i] = -1.0;\n    }\n    for(int i = 0; i < queriesSize; i++){\n        if(strcmp(queries[i][0], queries[i][1]) == 0){\n            result[i] = 1.0;\n        }\n    }\n    for(int i = 0; i < equationsSize; i++){\n        for(int j = 0; j < queriesSize; j++){\n            if(strcmp(equations[i][0], queries[j][0]) == 0 && strcmp(equations[i][1], queries[j][1]) == 0){\n                result[j] = values[i];\n            }\n            else if(strcmp(equations[i][0], queries[j][1]) == 0 && strcmp(equations[i][1], queries[j][0]) == 0){\n                result[j] = 1.0 / values[i];\n            }\n        }\n    }\n    for(int i = 0; i < equationsSize; i++){\n        for(int j = 0; j < queriesSize; j++){\n            if(strcmp(equations[i][0], queries[j][0]) == 0){\n                for(int k = 0; k < equationsSize; k++){\n                    if(strcmp(equations[i][1], equations[k][0]) == 0 && strcmp(equations[k][1], queries[j][1]) == 0){\n                        result[j] = values[i] * values[k];\n                    }\n                    else if(strcmp(equations[i][1], equations[k][1]) == 0 && strcmp(equations[k][0], queries[j][1]) == 0){\n                        result[j] = values[i] / values[k];\n                    }\n                }\n            }\n            else if(strcmp(equations[i][0], queries[j][1]) == 0){\n                for(int k = 0; k < equationsSize; k++){\n                    if(strcmp(equations[i][1], equations[k][0]) == 0 && strcmp(equations[k][1], queries[j][0]) == 0){\n                        result[j] = 1.0 / values[i] / values[k];\n                    }\n                    else if(strcmp(equations[i][1], equations[k][1]) == 0 && strcmp(equations[k][0], queries[j][0]) == 0){\n                        result[j] = 1.0 / values[i] * values[k];\n                    }  \n\n                    \n\n}", "prefix": "double* calcEquation(char *** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char *** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "796", "path": "output2\\c\\Medium\\796-nth-digit.c", "hypo_code": "int findNthDigit(int n){\n    int digit = 1;\n    long long count = 9;\n    int start = 1;\n    while(n > count){\n        n -= count;\n        digit++;\n        count = 9 * start * digit;\n        start *= 10;\n    }\n    int num = start + (n - 1) / digit;\n    int index = (n - 1) % digit;\n    return to_string(num)[index] - '0';\n\n}", "prefix": "int findNthDigit(int n"}
{"id": "797", "path": "output2\\c\\Medium\\797-remove-k-digits.c", "hypo_code": "char * removeKdigits(char * num, int k){\n    int len = strlen(num);\n    if(len == k){\n        return \"0\";\n    }\n    char* result = (char*)malloc(sizeof(char) * (len + 1));\n    int top = 0;\n    for(int i = 0; i < len; i++){\n        while(top > 0 && result[top - 1] > num[i] && k > 0){\n            top--;\n            k--;\n        }\n        result[top++] = num[i];\n    }\n    top -= k;\n    result[top] = '\\0';\n    int index = 0;\n    while(result[index] == '0'){\n        index++;\n    }\n    if(index == top){\n        return \"0\";\n    }\n    return result + index;\n\n}", "prefix": "char * removeKdigits(char * num, int k"}
{"id": "798", "path": "output2\\c\\Medium\\798-queue-reconstruction-by-height.c", "hypo_code": "int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * peopleSize);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * peopleSize);\n    for(int i = 0; i < peopleSize; i++){\n        result[i] = (int*)malloc(sizeof(int) * 2);\n        (*returnColumnSizes)[i] = 2;\n    }\n    int* height = (int*)malloc(sizeof(int) * 1001);\n    for(int i = 0; i < 1001; i++){\n        height[i] = 0;\n    }\n    for(int i = 0; i < peopleSize; i++){\n        height[people[i][0]]++;\n    }\n    int* heightIndex = (int*)malloc(sizeof(int) * 1001);\n    for(int i = 0; i < 1001; i++){\n        heightIndex[i] = 0;\n    }\n    for(int i = 0; i < peopleSize; i++){\n        int count = 0;\n        for(int j = 0; j < people[i][0]; j++){\n            count += height[j];\n        }\n        int index = count + people[i][1];\n        while(heightIndex[people[i][0]] < index){\n            heightIndex[people[i][0]]++;\n            while(height[people[i][0]] == 0){\n                people[i][0]++;\n            }\n        }\n        result[index][0] = people[i][0];\n        result[index][1] = people[i][1];\n        height[people[i][0]]--;\n    }\n    *returnSize = peopleSize;\n    return result;\n\n}", "prefix": "int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes"}
{"id": "799", "path": "output2\\c\\Medium\\799-arithmetic-slices.c", "hypo_code": "int numberOfArithmeticSlices(int* nums, int numsSize){\n    if(numsSize < 3){\n        return 0;\n    }\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    result[0] = 0;\n    result[1] = 0;\n    for(int i = 2; i < numsSize; i++){\n        if(nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]){\n            result[i] = result[i - 1] + 1;\n        }else{\n            result[i] = 0;\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < numsSize; i++){\n        count += result[i];\n    }\n    return count;\n\n}", "prefix": "int numberOfArithmeticSlices(int* nums, int numsSize"}
{"id": "800", "path": "output2\\c\\Medium\\800-partition-equal-subset-sum.c", "hypo_code": "bool canPartition(int* nums, int numsSize){\n    int sum = 0;\n    for(int i = 0; i < numsSize; i++){\n        sum += nums[i];\n    }\n    if(sum % 2 != 0){\n        return false;\n    }\n    int target = sum / 2;\n    bool* dp = (bool*)malloc(sizeof(bool) * (target + 1));\n    for(int i = 0; i <= target; i++){\n        dp[i] = false;\n    }\n    dp[0] = true;\n    for(int i = 0; i < numsSize; i++){\n        for(int j = target; j >= nums[i]; j--){\n            dp[j] = dp[j] || dp[j - nums[i]];\n        }\n    }\n    return dp[target];\n\n}", "prefix": "bool canPartition(int* nums, int numsSize"}
{"id": "801", "path": "output2\\c\\Medium\\801-pacific-atlantic-water-flow.c", "hypo_code": "int** pacificAtlantic(int** heights, int heightsSize, int* heightsColSize, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * heightsSize * (*heightsColSize));\n    *returnColumnSizes = (int*)malloc(sizeof(int) * heightsSize * (*heightsColSize));\n    int resultSize = 0;\n    for(int i = 0; i < heightsSize; i++){\n        for(int j = 0; j < *heightsColSize; j++){\n            if(isPacificAtlantic(heights, heightsSize, *heightsColSize, i, j)){\n                result[resultSize] = (int*)malloc(sizeof(int) * 2);\n                (*returnColumnSizes)[resultSize] = 2;\n                result[resultSize][0] = i;\n                result[resultSize][1] = j;\n                resultSize++;\n            }\n        }\n    }\n    *returnSize = resultSize;\n    return result;\n\n}", "prefix": "int** pacificAtlantic(int** heights, int heightsSize, int* heightsColSize, int* returnSize, int** returnColumnSizes"}
{"id": "802", "path": "output2\\c\\Medium\\802-battleships-in-a-board.c", "hypo_code": "int countBattleships(char** board, int boardSize, int* boardColSize){\nint count = 0;\n    for (int i = 0; i < boardSize; i++) {\n        for (int j = 0; j < *boardColSize; j++) {\n            if (board[i][j] == 'X' && (i == 0 || board[i - 1][j] == '.') && (j == 0 || board[i][j - 1] == '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int countBattleships(char** board, int boardSize, int* boardColSize"}
{"id": "803", "path": "output2\\c\\Medium\\803-maximum-xor-of-two-numbers-in-an-array.c", "hypo_code": "int findMaximumXOR(int* nums, int numsSize){\nint max = 0;\n    for (int i = 0; i < numsSize; i++) {\n        for (int j = i; j < numsSize; j++) {\n            int temp = nums[i] ^ nums[j];\n            if (max < temp) {\n                max = temp;\n            }\n        }\n    }\n    return max;\n}", "prefix": "int findMaximumXOR(int* nums, int numsSize"}
{"id": "804", "path": "output2\\c\\Medium\\804-reconstruct-original-digits-from-english.c", "hypo_code": "char * originalDigits(char * s){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    int* count = (int*)malloc(sizeof(int) * 10);\n    memset(count, 0, sizeof(int) * 10);\n    for (i = 0; i < len; i++) {\n        switch (s[i]) {\n            case 'z':\n                count[0]++;\n                break;\n            case 'w':\n                count[2]++;\n                break;\n            case 'u':\n                count[4]++;\n                break;\n            case 'x':\n                count[6]++;\n                break;\n            case 'g':\n                count[8]++;\n                break;\n            case 's':\n                count[7]++;\n                break;\n            case 'f':\n                count[5]++;\n                break;\n            case 'h':\n                count[3]++;\n                break;\n            case 'i':\n                count[9]++;\n                break;\n            case 'o':\n                count[1]++;\n                break;\n        }\n    }\n    count[7] -= count[6];\n    count[5] -= count[4];\n    count[3] -= count[8];\n    count[9] = count[9] - count[8] - count[6] - count[5];\n    count[1] = count[1] - count[0] - count[2] - count[4];\n    char* res = (char*)malloc(sizeof(char) * (len + 1));\n    memset(res, 0, sizeof(char) * (len + 1));\n    for (i = 0; i < 10; i++) {\n        for (j = 0; j < count[i]; j++) {\n            res[k++] = (char)(i + '0');\n        }\n    }\n    return res;\n}", "prefix": "char * originalDigits(char * s"}
{"id": "805", "path": "output2\\c\\Medium\\805-longest-repeating-character-replacement.c", "hypo_code": "int characterReplacement(char * s, int k){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    int max = 0;\n    int* count = (int*)malloc(sizeof(int) * 26);\n    memset(count, 0, sizeof(int) * 26);\n    while (j < len) {\n        count[s[j] - 'A']++;\n        max = max > count[s[j] - 'A'] ? max : count[s[j] - 'A'];\n        if (j - i + 1 - max > k) {\n            count[s[i] - 'A']--;\n            i++;\n        }\n        j++;\n    }\n    return j - i;\n}", "prefix": "int characterReplacement(char * s, int k"}
{"id": "807", "path": "output2\\c\\Medium\\807-n-ary-tree-level-order-traversal.c", "hypo_code": "int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {\n    if (root == NULL) {\n        *returnSize = 0;\n        return NULL;\n    }\n    int** res = (int**)malloc(sizeof(int*) * 1000);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * 1000);\n    int i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    struct Node** queue = (struct Node**)malloc(sizeof(struct Node*) * 1000);\n    int queueSize = 0;\n    queue[queueSize++] = root;\n    while (queueSize != 0) {\n        int size = queueSize;\n        res[i] = (int*)malloc(sizeof(int) * size);\n        (*returnColumnSizes)[i] = size;\n        for (j = 0; j < size; j++) {\n            struct Node* node = queue[0];\n            queueSize--;\n            queue++;\n            res[i][j] = node->val;\n            for (k = 0; k < node->numChildren; k++) {\n                queue[queueSize++] = node->children[k];\n            }\n        }\n        i++;\n    }\n    *returnSize = i;\n    return res;\n}", "prefix": "int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes"}
{"id": "809", "path": "output2\\c\\Medium\\809-minimum-genetic-mutation.c", "hypo_code": "int minMutation(char * startGene, char * endGene, char ** bank, int bankSize){\n    int* visited = (int*)malloc(sizeof(int) * bankSize);\n    for(int i = 0; i < bankSize; i++){\n        visited[i] = 0;\n    }\n    int count = 0;\n    int* queue = (int*)malloc(sizeof(int) * bankSize);\n    int queueSize = 0;\n    int* nextQueue = (int*)malloc(sizeof(int) * bankSize);\n    int nextQueueSize = 0;\n    for(int i = 0; i < bankSize; i++){\n        if(isMutation(startGene, bank[i])){\n            queue[queueSize++] = i;\n            visited[i] = 1;\n        }\n    }\n    while(queueSize > 0){\n        count++;\n        for(int i = 0; i < queueSize; i++){\n            if(strcmp(bank[queue[i]], endGene) == 0){\n                return count;\n            }\n            for(int j = 0; j < bankSize; j++){\n                if(!visited[j] && isMutation(bank[queue[i]], bank[j])){\n                    nextQueue[nextQueueSize++] = j;\n                    visited[j] = 1;\n                }\n            }\n        }\n        int* temp = queue;\n        queue = nextQueue;\n        nextQueue = temp;\n        queueSize = nextQueueSize;\n        nextQueueSize = 0;\n    }\n    return -1;\n\n}", "prefix": "int minMutation(char * startGene, char * endGene, char ** bank, int bankSize"}
{"id": "810", "path": "output2\\c\\Medium\\810-non-overlapping-intervals.c", "hypo_code": "int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize){\n    if(intervalsSize == 0){\n        return 0;\n    }\n    int* dp = (int*)malloc(sizeof(int) * intervalsSize);\n    for(int i = 0; i < intervalsSize; i++){\n        dp[i] = 1;\n    }\n    int max = 1;\n    for(int i = 1; i < intervalsSize; i++){\n        for(int j = 0; j < i; j++){\n            if(intervals[i][0] >= intervals[j][1]){\n                dp[i] = fmax(dp[i], dp[j] + 1);\n            }\n        }\n        max = fmax(max, dp[i]);\n    }\n    return intervalsSize - max;\n\n}", "prefix": "int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize"}
{"id": "811", "path": "output2\\c\\Medium\\811-find-right-interval.c", "hypo_code": "int* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * intervalsSize);\n    *returnSize = intervalsSize;\n    for(int i = 0; i < intervalsSize; i++){\n        int minIndex = -1;\n        int minStart = INT_MAX;\n        for(int j = 0; j < intervalsSize; j++){\n            if(i != j && intervals[j][0] >= intervals[i][1] && intervals[j][0] < minStart){\n                minStart = intervals[j][0];\n                minIndex = j;\n            }\n        }\n        result[i] = minIndex;\n    }\n    return result;\n\n}", "prefix": "int* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize"}
{"id": "812", "path": "output2\\c\\Medium\\812-path-sum-iii.c", "hypo_code": "int pathSum(struct TreeNode* root, int targetSum){\n    if(root == NULL){\n        return 0;\n    }\n    int count = 0;\n    int sum = 0;\n    int* dp = (int*)malloc(sizeof(int) * 1000);\n    for(int i = 0; i < 1000; i++){\n        dp[i] = 0;\n    }\n    dp[0] = 1;\n    pathSumHelper(root, targetSum, dp, &count, sum);\n    return count;\n\n}", "prefix": "int pathSum(struct TreeNode* root, int targetSum"}
{"id": "813", "path": "output2\\c\\Medium\\813-find-all-anagrams-in-a-string.c", "hypo_code": "int* findAnagrams(char * s, char * p, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 10000);\n    *returnSize = 0;\n    int* sCount = (int*)malloc(sizeof(int) * 26);\n    int* pCount = (int*)malloc(sizeof(int) * 26);\n    for(int i = 0; i < 26; i++){\n        sCount[i] = 0;\n        pCount[i] = 0;\n    }\n    int pLength = strlen(p);\n    for(int i = 0; i < pLength; i++){\n        pCount[p[i] - 'a']++;\n    }\n    int sLength = strlen(s);\n    for(int i = 0; i < sLength; i++){\n        sCount[s[i] - 'a']++;\n        if(i >= pLength){\n            sCount[s[i - pLength] - 'a']--;\n        }\n        int j = 0;\n        for(j = 0; j < 26; j++){\n            if(sCount[j] != pCount[j]){\n                break;\n            }\n        }\n        if(j == 26){\n            result[*returnSize] = i - pLength + 1;\n            (*returnSize)++;\n        }\n    }\n    return result;\n\n}", "prefix": "int* findAnagrams(char * s, char * p, int* returnSize"}
{"id": "814", "path": "output2\\c\\Medium\\814-find-all-duplicates-in-an-array.c", "hypo_code": "int* findDuplicates(int* nums, int numsSize, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * numsSize);\n\t*returnSize = 0;\n\tfor (int i = 0; i < numsSize; i++) {\n\t\tint index = abs(nums[i]) - 1;\n\t\tif (nums[index] < 0) {\n\t\t\tres[(*returnSize)++] = abs(nums[i]);\n\t\t}\n\t\tnums[index] = -nums[index];\n\t}\n\treturn res;\n}", "prefix": "int* findDuplicates(int* nums, int numsSize, int* returnSize"}
{"id": "815", "path": "output2\\c\\Medium\\815-string-compression.c", "hypo_code": "int compress(char* chars, int charsSize){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    int max = 0;\n    int* count = (int*)malloc(sizeof(int) * 26);\n    memset(count, 0, sizeof(int) * 26);\n    while (j < len) {\n        count[s[j] - 'A']++;\n        max = max > count[s[j] - 'A'] ? max : count[s[j] - 'A'];\n        if (j - i + 1 - max > k) {\n            count[s[i] - 'A']--;\n            i++;\n        }\n        j++;\n    }\n    return j - i;\n}", "prefix": "int compress(char* chars, int charsSize"}
{"id": "816", "path": "output2\\c\\Medium\\816-add-two-numbers-ii.c", "hypo_code": "struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\n    struct ListNode* result = NULL;\n    struct ListNode* temp = NULL;\n    struct ListNode* prev = NULL;\n    int carry = 0;\n    int sum = 0;\n    while(l1 != NULL || l2 != NULL){\n        sum = carry + (l1 ? l1->val : 0) + (l2 ? l2->val : 0);\n        carry = (sum >= 10) ? 1 : 0;\n        sum = sum % 10;\n        temp = (struct ListNode*)malloc(sizeof(struct ListNode));\n        temp->val = sum;\n        temp->next = NULL;\n        if(result == NULL){\n            result = temp;\n        }\n        else{\n            prev->next = temp;\n        }\n        prev = temp;\n        if(l1){\n            l1 = l1->next;\n        }\n        if(l2){\n            l2 = l2->next;\n        }\n    }\n    if(carry > 0){\n        temp->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n        temp->next->val = carry;\n        temp->next->next = NULL;\n    }\n    return result;\n\n\n}", "prefix": "struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2"}
{"id": "817", "path": "output2\\c\\Medium\\817-number-of-boomerangs.c", "hypo_code": "int numberOfBoomerangs(int** points, int pointsSize, int* pointsColSize){\n    int result = 0;\n    for(int i = 0; i < pointsSize; i++){\n        int* distance = (int*)malloc(sizeof(int) * pointsSize);\n        for(int j = 0; j < pointsSize; j++){\n            distance[j] = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n        }\n        for(int j = 0; j < pointsSize; j++){\n            int count = 0;\n            for(int k = 0; k < pointsSize; k++){\n                if(distance[j] == distance[k]){\n                    count++;\n                }\n            }\n            result += count * (count - 1);\n        }\n    }\n    return result;\n\n}", "prefix": "int numberOfBoomerangs(int** points, int pointsSize, int* pointsColSize"}
{"id": "819", "path": "output2\\c\\Medium\\819-delete-node-in-a-bst.c", "hypo_code": "struct TreeNode* deleteNode(struct TreeNode* root, int key){\n    if(root == NULL){\n        return NULL;\n    }\n    if(root->val == key){\n        if(root->left == NULL){\n            return root->right;\n        }\n        if(root->right == NULL){\n            return root->left;\n        }\n        struct TreeNode* temp = root->right;\n        while(temp->left != NULL){\n            temp = temp->left;\n        }\n        temp->left = root->left;\n        return root->right;\n    }\n    if(root->val > key){\n        root->left = deleteNode(root->left, key);\n    }else{\n        root->right = deleteNode(root->right, key);\n    }\n    return root;\n\n}", "prefix": "struct TreeNode* deleteNode(struct TreeNode* root, int key"}
{"id": "820", "path": "output2\\c\\Medium\\820-sort-characters-by-frequency.c", "hypo_code": "char * frequencySort(char * s){\n    int* count = (int*)malloc(sizeof(int) * 128);\n    for(int i = 0; i < 128; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < strlen(s); i++){\n        count[s[i]]++;\n    }\n    int max = 0;\n    for(int i = 0; i < 128; i++){\n        if(count[i] > max){\n            max = count[i];\n        }\n    }\n    char** result = (char**)malloc(sizeof(char*) * (max + 1));\n    for(int i = 0; i <= max; i++){\n        result[i] = (char*)malloc(sizeof(char) * (strlen(s) + 1));\n        result[i][0] = '\\0';\n    }\n    for(int i = 0; i < 128; i++){\n        if(count[i] > 0){\n            for(int j = 0; j < count[i]; j++){\n                char temp[2];\n                temp[0] = i;\n                temp[1] = '\\0';\n                strcat(result[count[i]], temp);\n            }\n        }\n    }\n    char* finalResult = (char*)malloc(sizeof(char) * (strlen(s) + 1));\n    finalResult[0] = '\\0';\n    for(int i = max; i >= 0; i--){\n        if(result[i][0] != '\\0'){\n            strcat(finalResult, result[i]);\n        }\n    }\n    return finalResult;\n\n}", "prefix": "char * frequencySort(char * s"}
{"id": "821", "path": "output2\\c\\Medium\\821-minimum-number-of-arrows-to-burst-balloons.c", "hypo_code": "int findMinArrowShots(int** points, int pointsSize, int* pointsColSize){   \n        \n \n}", "prefix": "int findMinArrowShots(int** points, int pointsSize, int* pointsColSize"}
{"id": "822", "path": "output2\\c\\Medium\\822-minimum-moves-to-equal-array-elements.c", "hypo_code": "int minMoves(int* nums, int numsSize){\n    int min = nums[0];\n    for(int i = 1; i < numsSize; i++){\n        if(nums[i] < min){\n            min = nums[i];\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < numsSize; i++){\n        count += nums[i] - min;\n    }\n    return count;\n\n}", "prefix": "int minMoves(int* nums, int numsSize"}
{"id": "823", "path": "output2\\c\\Medium\\823-4sum-ii.c", "hypo_code": "int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\n    int* nums1Count = (int*)malloc(sizeof(int) * 2001);\n    int* nums2Count = (int*)malloc(sizeof(int) * 2001);\n    int* nums3Count = (int*)malloc(sizeof(int) * 2001);\n    int* nums4Count = (int*)malloc(sizeof(int) * 2001);\n    for(int i = 0; i < 2001; i++){\n        nums1Count[i] = 0;\n        nums2Count[i] = 0;\n        nums3Count[i] = 0;\n        nums4Count[i] = 0;\n    }\n    for(int i = 0; i < nums1Size; i++){\n        nums1Count[nums1[i] + 1000]++;\n        nums2Count[nums2[i] + 1000]++;\n        nums3Count[nums3[i] + 1000]++;\n        nums4Count[nums4[i] + 1000]++;\n    }\n    int* nums1CountSum = (int*)malloc(sizeof(int) * 2001);\n    int* nums2CountSum = (int*)malloc(sizeof(int) * 2001);\n    int* nums3CountSum = (int*)malloc(sizeof(int) * 2001);\n    int* nums4CountSum = (int*)malloc(sizeof(int) * 2001);\n    nums1CountSum[0] = nums1Count[0];\n    nums2CountSum[0] = nums2Count[0];\n    nums3CountSum[0] = nums3Count[0];\n    nums4CountSum[0] = nums4Count[0];\n    for(int i = 1; i < 2001; i++){\n        nums1CountSum[i] = nums1CountSum[i - 1] + nums1Count[i];\n        nums2CountSum[i] = nums2CountSum[i - 1] + nums2Count[i];\n        nums3CountSum[i] = nums3CountSum[i - 1] + nums3Count[i];\n        nums4CountSum[i] = nums4CountSum[i - 1] + nums4Count[i];\n    }\n    int* nums1CountSumReverse = (int*)malloc(sizeof(int) * 2001);\n    int* nums2CountSumReverse = (int*)malloc(sizeof(int) * 2001 );\n\n}", "prefix": "int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size"}
{"id": "824", "path": "output2\\c\\Medium\\824-132-pattern.c", "hypo_code": "bool find132pattern(int* nums, int numsSize){\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    int resultSize = 0;\n    for(int i = 0; i < numsSize; i++){\n        int num = nums[i];\n        for(int j = 2; j <= num; j++){\n            if(num % j == 0){\n                result[resultSize++] = j;\n                while(num % j == 0){\n                    num /= j;\n                }\n            }\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < resultSize; i++){\n        int j = 0;\n        for(; j < i; j++){\n            if(result[j] == result[i]){\n                break;\n            }\n        }\n        if(j == i){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "bool find132pattern(int* nums, int numsSize"}
{"id": "825", "path": "output2\\c\\Medium\\825-circular-array-loop.c", "hypo_code": "bool circularArrayLoop(int* nums, int numsSize){\n    int* visited = (int*)malloc(sizeof(int) * numsSize);\n    for(int i = 0; i < numsSize; i++){\n        visited[i] = 0;\n    }\n    for(int i = 0; i < numsSize; i++){\n        if(visited[i] == 0){\n            int* path = (int*)malloc(sizeof(int) * numsSize);\n            int pathSize = 0;\n            int num = nums[i];\n            int index = i;\n            while(visited[index] == 0){\n                visited[index] = 1;\n                path[pathSize++] = index;\n                index = (index + num) % numsSize;\n                if(index < 0){\n                    index += numsSize;\n                }\n                num = nums[index];\n                if(num == 0){\n                    break;\n                }\n                if(num > 0 && nums[i] < 0){\n                    break;\n                }\n                if(num < 0 && nums[i] > 0){\n                    break;\n                }\n            }\n            if(pathSize > 1 && index == path[0]){\n                return true;\n            }\n        }\n    }\n    return false;\n\n}", "prefix": "bool circularArrayLoop(int* nums, int numsSize"}
{"id": "826", "path": "output2\\c\\Medium\\826-minimum-moves-to-equal-array-elements-ii.c", "hypo_code": "int minMoves2(int* nums, int numsSize){\n    int* numsCount = (int*)malloc(sizeof(int) * 100000);\n    for(int i = 0; i < 100000; i++){\n        numsCount[i] = 0;\n    }\n    for(int i = 0; i < numsSize; i++){\n        numsCount[nums[i] + 50000]++;\n    }\n    int* numsCountSum = (int*)malloc(sizeof(int) * 100000);\n    numsCountSum[0] = numsCount[0];\n    for(int i = 1; i < 100000; i++){\n        numsCountSum[i] = numsCountSum[i - 1] + numsCount[i];\n    }\n    int* numsCountSumReverse = (int*)malloc(sizeof(int) * 100000);\n    numsCountSumReverse[99999] = numsCount[99999];\n    for(int i = 99998; i >= 0; i--){\n        numsCountSumReverse[i] = numsCountSumReverse[i + 1] + numsCount[i];\n    }\n    int min = numsCountSum[0];\n    for(int i = 1; i < 100000; i++){\n        if(numsCountSum[i] < min){\n            min = numsCountSum[i];\n        }\n    }\n    int minIndex = 0;\n    for(int i = 0; i < 100000; i++){\n        if(numsCountSum[i] == min){\n            minIndex = i;\n            break;\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < minIndex; i++){\n        count += numsCount[i] * (minIndex - i);\n    }\n    for(int i = minIndex + 1; i < 100000; i++){\n        count += numsCount[i] * (i - minIndex);\n    }\n    return count;\n\n}", "prefix": "int minMoves2(int* nums, int numsSize"}
{"id": "827", "path": "output2\\c\\Medium\\827-can-i-win.c", "hypo_code": "bool canIWin(int maxChoosableInteger, int desiredTotal){\n    if(desiredTotal <= maxChoosableInteger){\n        return true;\n    }\n    if((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal){\n        return false;\n    }\n    int* used = (int*)malloc(sizeof(int) * maxChoosableInteger);\n    for(int i = 0; i < maxChoosableInteger; i++){\n        used[i] = 0;\n    }\n    return canIWinHelper(used, maxChoosableInteger, desiredTotal);\n\n}", "prefix": "bool canIWin(int maxChoosableInteger, int desiredTotal"}
{"id": "828", "path": "output2\\c\\Medium\\828-unique-substrings-in-wraparound-string.c", "hypo_code": "int findSubstringInWraproundString(char * s){\n    int* count = (int*)malloc(sizeof(int) * 26);\n    for(int i = 0; i < 26; i++){\n        count[i] = 0;\n    }\n    int len = strlen(s);\n    int max = 0;\n    for(int i = 0; i < len; i++){\n        if(i > 0 && (s[i] - s[i - 1] == 1 || s[i - 1] - s[i] == 25)){\n            max++;\n        }else{\n            max = 1;\n        }\n        int index = s[i] - 'a';\n        if(count[index] < max){\n            count[index] = max;\n        }\n    }\n    int result = 0;\n    for(int i = 0; i < 26; i++){\n        result += count[i];\n    }\n    return result;\n\n}", "prefix": "int findSubstringInWraproundString(char * s"}
{"id": "829", "path": "output2\\c\\Medium\\829-validate-ip-address.c", "hypo_code": "char * validIPAddress(char * queryIP){\n    int len = strlen(queryIP);\n    int count = 0;\n    for(int i = 0; i < len; i++){\n        if(queryIP[i] == '.'){\n            count++;\n        }\n    }\n    if(count == 3){\n        int start = 0;\n        int end = 0;\n        for(int i = 0; i < len; i++){\n            if(queryIP[i] == '.'){\n                end = i;\n                if(end - start > 3 || end - start == 0){\n                    return \"Neither\";\n                }\n                if(end - start > 1 && queryIP[start] == '0'){\n                    return \"Neither\";\n                }\n                int num = 0;\n                for(int j = start; j < end; j++){\n                    if(queryIP[j] < '0' || queryIP[j] > '9'){\n                        return \"Neither\";\n                    }\n                    num = num * 10 + (queryIP[j] - '0');\n                }\n                if(num > 255){\n                    return \"Neither\";\n                }\n                start = end + 1;\n            }\n        }\n        end = len;\n        if(end - start > 3 || end - start == 0){\n            return \"Neither\";\n        }\n        if(end - start > 1 && queryIP[start] == '0'){\n            return \"Neither\";\n        }\n        int num = 0;\n        for(int j = start; j < end; j++){\n            if(queryIP[j] < '0' || queryIP[j] > '9'){\n                return \"Neither\";\n            }\n            num = num * 10 + (queryIP[j] - '0');\n        }\n        if(num > 255){\n            return \"Neither\";\n        }\n        return \"IPv4\";\n    }\n    count = 0;\n    for(int i = 0; i < len; i++){\n        if(queryIP[i] == ':'){\n            count++;\n        }\n    }\n    if(count == 7){\n        int start = 0;\n        int end = 0;\n        for(int i = 0; i < len; i++){\n            if(queryIP[i] == ':'){\n                end = i;\n                if(end - start > 4 || end - start == 0){\n                    return \"Neither\";\n                }\n                for(int j = start; j < end; j++){\n                    if((queryIP[j] < '0' || queryIP[j] > '9') && (queryIP[j] < 'a' || queryIP[j] > 'f') && (queryIP[j] < 'A' || queryIP[j] > 'F')){\n                        return \"Neither\";\n                    }\n\n}", "prefix": "char * validIPAddress(char * queryIP"}
{"id": "830", "path": "output2\\c\\Medium\\830-implement-rand10-using-rand7.c", "hypo_code": "int rand10() {\n    int result = 0;\n    do{\n        result = (rand7() - 1) * 7 + rand7();\n    }while(result > 40);\n    return result % 10 + 1;\n    \n}", "prefix": "int rand10"}
{"id": "831", "path": "output2\\c\\Medium\\831-matchsticks-to-square.c", "hypo_code": "bool makesquare(int* matchsticks, int matchsticksSize){\n    int sum = 0;\n    for(int i = 0; i < matchsticksSize; i++){\n        sum += matchsticks[i];\n    }\n    if(sum % 4 != 0){\n        return false;\n    }\n    int target = sum / 4;\n    int* visited = (int*)malloc(sizeof(int) * matchsticksSize);\n    for(int i = 0; i < matchsticksSize; i++){\n        visited[i] = 0;\n    }\n    for(int i = 0; i < 4; i++){\n        if(!dfs(matchsticks, matchsticksSize, visited, target, 0)){\n            return false;\n        }\n    }\n    return true;\n\n\n}", "prefix": "bool makesquare(int* matchsticks, int matchsticksSize"}
{"id": "832", "path": "output2\\c\\Medium\\832-ones-and-zeroes.c", "hypo_code": "int findMaxForm(char ** strs, int strsSize, int m, int n){\n    int** dp = (int**)malloc(sizeof(int*) * (m + 1));\n    for(int i = 0; i <= m; i++){\n        dp[i] = (int*)malloc(sizeof(int) * (n + 1));\n        for(int j = 0; j <= n; j++){\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < strsSize; i++){\n        int zero = 0;\n        int one = 0;\n        for(int j = 0; strs[i][j] != '\\0'; j++){\n            if(strs[i][j] == '0'){\n                zero++;\n            }else{\n                one++;\n            }\n        }\n        for(int j = m; j >= zero; j--){\n            for(int k = n; k >= one; k--){\n                dp[j][k] = fmax(dp[j][k], dp[j - zero][k - one] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n\n}", "prefix": "int findMaxForm(char ** strs, int strsSize, int m, int n"}
{"id": "833", "path": "output2\\c\\Medium\\833-heaters.c", "hypo_code": "int findRadius(int* houses, int housesSize, int* heaters, int heatersSize){\n    int result = 0;\n    for(int i = 0; i < housesSize; i++){\n        int min = INT_MAX;\n        for(int j = 0; j < heatersSize; j++){\n            int temp = abs(houses[i] - heaters[j]);\n            if(temp < min){\n                min = temp;\n            }\n        }\n        if(min > result){\n            result = min;\n        }\n    }\n    return result;\n\n}", "prefix": "int findRadius(int* houses, int housesSize, int* heaters, int heatersSize"}
{"id": "834", "path": "output2\\c\\Medium\\834-total-hamming-distance.c", "hypo_code": "int totalHammingDistance(int* nums, int numsSize){\n    int count = 0;\n    for(int i = 0; i < 32; i++){\n        int bitCount = 0;\n        for(int j = 0; j < numsSize; j++){\n            bitCount += (nums[j] >> i) & 1;\n        }\n        count += bitCount * (numsSize - bitCount);\n    }\n    return count;\n\n}", "prefix": "int totalHammingDistance(int* nums, int numsSize"}
{"id": "836", "path": "output2\\c\\Medium\\836-magical-string.c", "hypo_code": "int magicalString(int n){\n    if(n == 0){\n        return 0;\n    }\n    if(n <= 3){\n        return 1;\n    }\n    int* result = (int*)malloc(sizeof(int) * n);\n    result[0] = 1;\n    result[1] = 2;\n    result[2] = 2;\n    int count = 1;\n    int index = 2;\n    int i = 3;\n    while(i < n){\n        for(int j = 0; j < result[index]; j++){\n            result[i++] = 3 - result[i - 1];\n            if(result[i - 1] == 1 && i <= n){\n                count++;\n            }\n        }\n        index++;\n    }\n    return count;\n\n}", "prefix": "int magicalString(int n"}
{"id": "837", "path": "output2\\c\\Medium\\837-predict-the-winner.c", "hypo_code": "bool predictTheWinner(int* nums, int numsSize){\nint** dp = (int**)malloc(sizeof(int*) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        dp[i] = (int*)malloc(sizeof(int) * numsSize);\n    }\n    for (int i = 0; i < numsSize; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (int i = numsSize - 2; i >= 0; i--) {\n        for (int j = i + 1; j < numsSize; j++) {\n            dp[i][j] = fmax(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][numsSize - 1] >= 0;\n}", "prefix": "bool predictTheWinner(int* nums, int numsSize"}
{"id": "838", "path": "output2\\c\\Medium\\838-non-decreasing-subsequences.c", "hypo_code": "int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\nint** res = (int**)malloc(sizeof(int*) * 20000);\n\t*returnColumnSizes = (int*)malloc(sizeof(int) * 20000);\n\tint* temp = (int*)malloc(sizeof(int) * numsSize);\n\t*returnSize = 0;\n\tdfs(nums, numsSize, 0, temp, 0, res, returnSize, returnColumnSizes);\n\treturn res;\n}\n\nvoid dfs(int* nums, int numsSize, int index, int* temp, int tempSize, int** res, int* returnSize, int** returnColumnSizes) {\n\tif (tempSize >= 2) {\n\t\tres[*returnSize] = (int*)malloc(sizeof(int) * tempSize);\n\t\t(*returnColumnSizes)[*returnSize] = tempSize;\n\t\tfor (int i = 0; i < tempSize; i++) {\n\t\t\tres[*returnSize][i] = temp[i];\n\t\t}\n\t\t(*returnSize)++;\n\t}\n\tif (index == numsSize) {\n\t\treturn;\n\t}\n\tint visited[201] = {0};\n\tfor (int i = index; i < numsSize; i++) {\n\t\tif (visited[nums[i] + 100] == 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (tempSize == 0 || nums[i] >= temp[tempSize - 1]) {\n\t\t\tvisited[nums[i] + 100] = 1;\n\t\t\ttemp[tempSize] = nums[i];\n\t\t\tdfs(nums, numsSize, i + 1, temp, tempSize + 1, res, returnSize, returnColumnSizes);\n\t\t}\n\t}\n}", "prefix": "int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes"}
{"id": "839", "path": "output2\\c\\Medium\\839-target-sum.c", "hypo_code": "int findTargetSumWays(int* nums, int numsSize, int target){\nint res = 0;\n    dfs(nums, numsSize, target, 0, &res);\n    return res;\n}\n\nvoid dfs(int* nums, int numsSize, int target, int index, int* res) {\n    if (index == numsSize) {\n        if (target == 0) {\n            (*res)++;\n        }\n        return;\n    }\n    dfs(nums, numsSize, target - nums[index], index + 1, res);\n    dfs(nums, numsSize, target + nums[index], index + 1, res);\n}", "prefix": "int findTargetSumWays(int* nums, int numsSize, int target"}
{"id": "841", "path": "output2\\c\\Medium\\841-diagonal-traverse.c", "hypo_code": "int* findDiagonalOrder(int** mat, int matSize, int* matColSize, int* returnSize){\nint row = matSize, col = matColSize[0];\n\tint* res = (int*)malloc(sizeof(int) * row * col);\n\t*returnSize = 0;\n\tif (row == 0 || col == 0) {\n\t\treturn res;\n\t}\n\tint i = 0, j = 0, k = 0;\n\twhile (i < row && j < col) {\n\t\tres[(*returnSize)++] = mat[i][j];\n\t\tif ((i + j) % 2 == 0) {\n\t\t\tif (j == col - 1) {\n\t\t\t\ti++;\n\t\t\t} else if (i == 0) {\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i == row - 1) {\n\t\t\t\tj++;\n\t\t\t} else if (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "prefix": "int* findDiagonalOrder(int** mat, int matSize, int* matColSize, int* returnSize"}
{"id": "842", "path": "output2\\c\\Medium\\842-next-greater-element-ii.c", "hypo_code": "int* nextGreaterElements(int* nums, int numsSize, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * numsSize);\n\t*returnSize = 0;\n\tif (numsSize == 0) return res;\n\tint* stack = (int*)malloc(sizeof(int) * numsSize * 2);\n\tint top = -1;\n\tfor (int i = 2 * numsSize - 1; i >= 0; i--) {\n\t\twhile (top != -1 && stack[top] <= nums[i % numsSize]) {\n\t\t\ttop--;\n\t\t}\n\t\tres[(*returnSize)++] = top == -1 ? -1 : stack[top];\n\t\tstack[++top] = nums[i % numsSize];\n\t}\n\tfree(stack);\n\treturn res;\n}", "prefix": "int* nextGreaterElements(int* nums, int numsSize, int* returnSize"}
{"id": "843", "path": "output2\\c\\Medium\\843-most-frequent-subtree-sum.c", "hypo_code": "int* findFrequentTreeSum(struct TreeNode* root, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * 10000);\n    *returnSize = 0;\n    if (root == NULL) {\n        return res;\n    }\n    int* hash = (int*)malloc(sizeof(int) * 10000);\n    memset(hash, 0, sizeof(int) * 10000);\n    int max = 0;\n    dfs(root, hash, returnSize, &max);\n    for (int i = 0; i < 10000; i++) {\n        if (hash[i] == max) {\n            res[(*returnSize)++] = i;\n        }\n    }\n    return res;\n}\nint dfs(struct TreeNode* root, int* hash, int* returnSize, int* max) {\n    if (root == NULL) {\n        return 0;\n    }\n    int left = dfs(root->left, hash, returnSize, max);\n    int right = dfs(root->right, hash, returnSize, max);\n    int sum = left + right + root->val;\n    hash[sum]++;\n    if (hash[sum] > *max) {\n        *max = hash[sum];\n    }\n    return sum;\n}", "prefix": "int* findFrequentTreeSum(struct TreeNode* root, int* returnSize"}
{"id": "844", "path": "output2\\c\\Medium\\844-find-bottom-left-tree-value.c", "hypo_code": "int findBottomLeftValue(struct TreeNode* root){\nint res = 0;\n\tstruct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);\n\tint queueSize = 0;\n\tqueue[queueSize++] = root;\n\twhile (queueSize != 0) {\n\t\tint size = queueSize;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tstruct TreeNode* node = queue[0];\n\t\t\tqueueSize--;\n\t\t\tqueue++;\n\t\t\tif (i == 0) {\n\t\t\t\tres = node->val;\n\t\t\t}\n\t\t\tif (node->left != NULL) {\n\t\t\t\tqueue[queueSize++] = node->left;\n\t\t\t}\n\t\t\tif (node->right != NULL) {\n\t\t\t\tqueue[queueSize++] = node->right;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "prefix": "int findBottomLeftValue(struct TreeNode* root"}
{"id": "845", "path": "output2\\c\\Medium\\845-find-largest-value-in-each-tree-row.c", "hypo_code": "int* largestValues(struct TreeNode* root, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * 10000);\n\t*returnSize = 0;\n\tif (root == NULL) {\n\t\treturn res;\n\t}\n\tstruct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);\n\tint queueSize = 0;\n\tqueue[queueSize++] = root;\n\twhile (queueSize != 0) {\n\t\tint size = queueSize;\n\t\tint max = INT_MIN;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tstruct TreeNode* node = queue[0];\n\t\t\tqueueSize--;\n\t\t\tqueue++;\n\t\t\tif (node->val > max) {\n\t\t\t\tmax = node->val;\n\t\t\t}\n\t\t\tif (node->left != NULL) {\n\t\t\t\tqueue[queueSize++] = node->left;\n\t\t\t}\n\t\t\tif (node->right != NULL) {\n\t\t\t\tqueue[queueSize++] = node->right;\n\t\t\t}\n\t\t}\n\t\tres[(*returnSize)++] = max;\n\t}\n\treturn res;\n}", "prefix": "int* largestValues(struct TreeNode* root, int* returnSize"}
{"id": "846", "path": "output2\\c\\Medium\\846-longest-palindromic-subsequence.c", "hypo_code": "int longestPalindromeSubseq(char * s){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    int** dp = (int**)malloc(sizeof(int*) * len);\n    for (i = 0; i < len; i++) {\n        dp[i] = (int*)malloc(sizeof(int) * len);\n        memset(dp[i], 0, sizeof(int) * len);\n    }\n    for (i = len - 1; i >= 0; i--) {\n        dp[i][i] = 1;\n        for (j = i + 1; j < len; j++) {\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = dp[i][j - 1] > dp[i + 1][j] ? dp[i][j - 1] : dp[i + 1][j];\n            }\n        }\n    }\n    return dp[0][len - 1];\n}", "prefix": "int longestPalindromeSubseq(char * s"}
{"id": "847", "path": "output2\\c\\Medium\\847-coin-change-ii.c", "hypo_code": "int change(int amount, int* coins, int coinsSize){\nint dp[amount + 1];\n    memset(dp, 0, sizeof(int) * (amount + 1));\n    dp[0] = 1;\n    for (int i = 0; i < coinsSize; i++) {\n        for (int j = coins[i]; j <= amount; j++) {\n            dp[j] += dp[j - coins[i]];\n        }\n    }\n    return dp[amount];\n}", "prefix": "int change(int amount, int* coins, int coinsSize"}
{"id": "849", "path": "output2\\c\\Medium\\849-longest-uncommon-subsequence-ii.c", "hypo_code": "int findLUSlength(char ** strs, int strsSize){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    int max = 0;\n    int* count = (int*)malloc(sizeof(int) * 26);\n    memset(count, 0, sizeof(int) * 26);\n    while (j < len) {\n        count[s[j] - 'A']++;\n        max = max > count[s[j] - 'A'] ? max : count[s[j] - 'A'];\n        if (j - i + 1 - max > k) {\n            count[s[i] - 'A']--;\n            i++;\n        }\n        j++;\n    }\n    return j - i;\n}", "prefix": "int findLUSlength(char ** strs, int strsSize"}
{"id": "850", "path": "output2\\c\\Medium\\850-continuous-subarray-sum.c", "hypo_code": "bool checkSubarraySum(int* nums, int numsSize, int k){\nint sum = 0, pre = 0;\n    int map[100000] = {0};\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n        int t = (sum % k + k) % k;\n        if (map[t] != 0) {\n            return true;\n        }\n        map[pre]++;\n        pre = t;\n    }\n    return false;\n}", "prefix": "bool checkSubarraySum(int* nums, int numsSize, int k"}
{"id": "851", "path": "output2\\c\\Medium\\851-longest-word-in-dictionary-through-deleting.c", "hypo_code": "char * findLongestWord(char * s, char ** dictionary, int dictionarySize){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    char* res = (char*)malloc(sizeof(char) * (len + 1));\n    memset(res, 0, sizeof(char) * (len + 1));\n    for (i = 0; i < dictionarySize; i++) {\n        char* tmp = dictionary[i];\n        int tmpLen = strlen(tmp);\n        if (tmpLen < len || (tmpLen == len && strcmp(tmp, res) > 0)) {\n            continue;\n        }\n        int i = 0, j = 0;\n        while (i < len && j < tmpLen) {\n            if (s[i] == tmp[j]) {\n                i++;\n                j++;\n            } else {\n                i++;\n            }\n        }\n        if (j == tmpLen) {\n            strcpy(res, tmp);\n        }\n    }\n    return res;\n}", "prefix": "char * findLongestWord(char * s, char ** dictionary, int dictionarySize"}
{"id": "852", "path": "output2\\c\\Medium\\852-contiguous-array.c", "hypo_code": "int findMaxLength(int* nums, int numsSize){\nint res = 0;\n    int* map = (int*)malloc(sizeof(int) * (2 * numsSize + 1));\n    memset(map, -1, sizeof(int) * (2 * numsSize + 1));\n    int count = 0;\n    map[numsSize] = 0;\n    for (int i = 0; i < numsSize; i++) {\n        count += nums[i] == 0 ? -1 : 1;\n        if (map[count + numsSize] == -1) {\n            map[count + numsSize] = i + 1;\n        } else {\n            if (res < i - map[count + numsSize] + 1) {\n                res = i - map[count + numsSize] + 1;\n            }\n        }\n    }\n    free(map);\n    return res;\n}", "prefix": "int findMaxLength(int* nums, int numsSize"}
{"id": "853", "path": "output2\\c\\Medium\\853-beautiful-arrangement.c", "hypo_code": "int countArrangement(int n){ \nint res = 0;\n\tint* visited = (int*)malloc(sizeof(int) * (n + 1));\n\tmemset(visited, 0, sizeof(int) * (n + 1));\n\tdfs(n, 1, visited, &res);\n\tfree(visited);\n\treturn res;\n}\nvoid dfs(int n, int index, int* visited, int* res) {\n\tif (index > n) {\n\t\t(*res)++;\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!visited[i] && (i % index == 0 || index % i == 0)) {\n\t\t\tvisited[i] = 1;\n\t\t\tdfs(n, index + 1, visited, res);\n\t\t\tvisited[i] = 0;\n\t\t}\n\t}\n}", "prefix": "int countArrangement(int n"}
{"id": "855", "path": "output2\\c\\Medium\\855-minesweeper.c", "hypo_code": "char** updateBoard(char** board, int boardSize, int* boardColSize, int* click, int clickSize, int* returnSize, int** returnColumnSizes){\nint row = boardSize, col = boardColSize[0];\n    *returnSize = row;\n    *returnColumnSizes = (int*)malloc(sizeof(int) * row);\n    for (int i = 0; i < row; i++) {\n        (*returnColumnSizes)[i] = col;\n    }\n    if (row == 0 || col == 0) {\n        return board;\n    }\n    int i = click[0], j = click[1];\n    if (board[i][j] == 'M') {\n        board[i][j] = 'X';\n        return board;\n    } else {\n        dfs(board, row, col, i, j);\n    }\n    return board;\n}\n\nvoid dfs(char** board, int row, int col, int i, int j) {\n    if (i < 0 || i >= row || j < 0 || j >= col || board[i][j] != 'E') {\n        return;\n    }\n    int count = 0;\n    for (int m = -1; m <= 1; m++) {\n        for (int n = -1; n <= 1; n++) {\n            if (m == 0 && n == 0) {\n                continue;\n            }\n            if (i + m >= 0 && i + m < row && j + n >= 0 && j + n < col && board[i + m][j + n] == 'M') {\n                count++;\n            }\n        }\n    }\n    if (count == 0) {\n        board[i][j] = 'B';\n        for (int m = -1; m <= 1; m++) {\n            for (int n = -1; n <= 1; n++) {\n                if (m == 0 && n == 0) {\n                    continue;\n                }\n                dfs(board, row, col, i + m, j + n);\n            }\n        }\n    } else {\n        board[i][j] = count + '0';\n    }\n}", "prefix": "char** updateBoard(char** board, int boardSize, int* boardColSize, int* click, int clickSize, int* returnSize, int** returnColumnSizes"}
{"id": "856", "path": "output2\\c\\Medium\\856-k-diff-pairs-in-an-array.c", "hypo_code": "int findPairs(int* nums, int numsSize, int k){\nint res = 0;\n    qsort(nums, numsSize, sizeof(int), cmp);\n    for (int i = 0, j = 0; i < numsSize; i++) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n        for (j = fmax(j, i + 1); j < numsSize && nums[j] - nums[i] < k; j++);\n        if (j < numsSize && nums[j] - nums[i] == k) res++;\n    }\n    return res;\n}", "prefix": "int findPairs(int* nums, int numsSize, int k"}
{"id": "858", "path": "output2\\c\\Medium\\858-complex-number-multiplication.c", "hypo_code": "char * complexNumberMultiply(char * num1, char * num2){\nint a = 0, b = 0, c = 0, d = 0;\n    sscanf(num1, \"%d+%di\", &a, &b);\n    sscanf(num2, \"%d+%di\", &c, &d);\n    char *res = (char *)malloc(sizeof(char) * 20);\n    sprintf(res, \"%d+%di\", a * c - b * d, a * d + b * c);\n    return res;\n}", "prefix": "char * complexNumberMultiply(char * num1, char * num2"}
{"id": "859", "path": "output2\\c\\Medium\\859-convert-bst-to-greater-tree.c", "hypo_code": "struct TreeNode* convertBST(struct TreeNode* root){\nint sum = 0;\n    dfs(root, &sum);\n    return root;\n}\nvoid dfs(struct TreeNode* root, int* sum) {\n    if (root == NULL) {\n        return;\n    }\n    dfs(root->right, sum);\n    *sum += root->val;\n    root->val = *sum;\n    dfs(root->left, sum);\n}", "prefix": "struct TreeNode* convertBST(struct TreeNode* root"}
{"id": "860", "path": "output2\\c\\Medium\\860-minimum-time-difference.c", "hypo_code": "int findMinDifference(char ** timePoints, int timePointsSize){\nint min = 0;\n    for (int i = 0; i < timePointsSize; i++) {\n        for (int j = i; j < timePointsSize; j++) {\n            int temp = timePoints[i] ^ timePoints[j];\n            if (min < temp) {\n                min = temp;\n            }\n        }\n    }\n    return min;\n}", "prefix": "int findMinDifference(char ** timePoints, int timePointsSize"}
{"id": "861", "path": "output2\\c\\Medium\\861-single-element-in-a-sorted-array.c", "hypo_code": "int singleNonDuplicate(int* nums, int numsSize){\nint left = 0, right = numsSize - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (mid % 2 == 1) {\n            mid--;\n        }\n        if (nums[mid] == nums[mid + 1]) {\n            left = mid + 2;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}", "prefix": "int singleNonDuplicate(int* nums, int numsSize"}
{"id": "862", "path": "output2\\c\\Medium\\862-01-matrix.c", "hypo_code": "int** updateMatrix(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){\nint row = matSize, col = matColSize[0];\n\tint** res = (int**)malloc(sizeof(int*) * row);\n\t*returnColumnSizes = (int*)malloc(sizeof(int) * row);\n\tint i = 0, j = 0;\n\tfor (i = 0; i < row; i++) {\n\t\tres[i] = (int*)malloc(sizeof(int) * col);\n\t\t(*returnColumnSizes)[i] = col;\n\t\tfor (j = 0; j < col; j++) {\n\t\t\tif (mat[i][j] == 0) {\n\t\t\t\tres[i][j] = 0;\n\t\t\t} else {\n\t\t\t\tres[i][j] = 10000;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < row; i++) {\n\t\tfor (j = 0; j < col; j++) {\n\t\t\tif (i - 1 >= 0) {\n\t\t\t\tres[i][j] = fmin(res[i][j], res[i - 1][j] + 1);\n\t\t\t}\n\t\t\tif (j - 1 >= 0) {\n\t\t\t\tres[i][j] = fmin(res[i][j], res[i][j - 1] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = row - 1; i >= 0; i--) {\n\t\tfor (j = col - 1; j >= 0; j--) {\n\t\t\tif (i + 1 < row) {\n\t\t\t\tres[i][j] = fmin(res[i][j], res[i + 1][j] + 1);\n\t\t\t}\n\t\t\tif (j + 1 < col) {\n\t\t\t\tres[i][j] = fmin(res[i][j], res[i][j + 1] + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "prefix": "int** updateMatrix(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes"}
{"id": "863", "path": "output2\\c\\Medium\\863-number-of-provinces.c", "hypo_code": "int findCircleNum(int** isConnected, int isConnectedSize, int* isConnectedColSize){\nint res = 0;\n    int visited[isConnectedSize];\n    memset(visited, 0, sizeof(visited));\n    for (int i = 0; i < isConnectedSize; i++) {\n        if (visited[i] == 0) {\n            dfs(isConnected, isConnectedSize, visited, i);\n            res++;\n        }\n    }\n    return res;\n}\n\nvoid dfs(int** isConnected, int isConnectedSize, int* visited, int i) {\n    for (int j = 0; j < isConnectedSize; j++) {\n        if (isConnected[i][j] == 1 && visited[j] == 0) {\n            visited[j] = 1;\n            dfs(isConnected, isConnectedSize, visited, j);\n        }\n    }\n}", "prefix": "int findCircleNum(int** isConnected, int isConnectedSize, int* isConnectedColSize"}
{"id": "865", "path": "output2\\c\\Medium\\865-optimal-division.c", "hypo_code": "char * optimalDivision(int* nums, int numsSize){\nchar* res = (char*)malloc(sizeof(char) * 10000);\n    memset(res, 0, sizeof(char) * 10000);\n    if (numsSize == 1) {\n        sprintf(res, \"%d\", nums[0]);\n    } else if (numsSize == 2) {\n        sprintf(res, \"%d/%d\", nums[0], nums[1]);\n    } else {\n        sprintf(res, \"%d/(\", nums[0]);\n        for (int i = 1; i < numsSize; i++) {\n            sprintf(res + strlen(res), \"%d/\", nums[i]);\n        }\n        res[strlen(res) - 1] = ')';\n    }\n    return res;\n}", "prefix": "char * optimalDivision(int* nums, int numsSize"}
{"id": "866", "path": "output2\\c\\Medium\\866-brick-wall.c", "hypo_code": "int leastBricks(int** wall, int wallSize, int* wallColSize){\nint i = 0, j = 0, k = 0, count = 0, maxCount = 0;\n    for (i = 0; i < wallSize; i++) {\n        for (j = 0; j < wallColSize[i] - 1; j++) {\n            wall[i][j] += (j == 0) ? 0 : wall[i][j - 1];\n        }\n    }\n    for (j = 0; j < wallColSize[0] - 1; j++) {\n        count = 0;\n        for (i = 0; i < wallSize; i++) {\n            if (wall[i][j] == wall[0][wallColSize[0] - 2]) {\n                break;\n            }\n            count++;\n        }\n        maxCount = maxCount > count ? maxCount : count;\n    }\n    return wallSize - maxCount;\n}", "prefix": "int leastBricks(int** wall, int wallSize, int* wallColSize"}
{"id": "867", "path": "output2\\c\\Medium\\867-next-greater-element-iii.c", "hypo_code": "int nextGreaterElement(int n){\nint nums[10] = { 0 };\n\tint i = 0, j = 0, temp = n;\n\twhile (temp) {\n\t\tnums[i++] = temp % 10;\n\t\ttemp /= 10;\n\t}\n\tfor (j = 1; j < i; j++) {\n\t\tif (nums[j - 1] > nums[j]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (j == i) {\n\t\treturn -1;\n\t}\n\tint index = 0;\n\tfor (index = 0; index < i; index++) {\n\t\tif (nums[index] > nums[j]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tint t = nums[j];\n\tnums[j] = nums[index];\n\tnums[index] = t;\n\tfor (int k = 0; k < j; k++, j--) {\n\t\tt = nums[k];\n\t\tnums[k] = nums[j];\n\t\tnums[j] = t;\n\t}\n\tlong long res = 0;\n\tfor (int k = i - 1; k >= 0; k--) {\n\t\tres = res * 10 + nums[k];\n\t}\n\treturn res > INT_MAX ? -1 : res;\n}", "prefix": "int nextGreaterElement(int n"}
{"id": "869", "path": "output2\\c\\Medium\\869-subarray-sum-equals-k.c", "hypo_code": "int subarraySum(int* nums, int numsSize, int k){\nint* sum = (int*)malloc(sizeof(int) * (numsSize + 1));\n    sum[0] = 0;\n    for (int i = 1; i <= numsSize; i++) {\n        sum[i] = sum[i - 1] + nums[i - 1];\n    }\n    for (int i = 1; i <= numsSize; i++) {\n        for (int j = 0; j < i; j++) {\n            if (sum[i] - sum[j] == k) {\n                res++;\n            }\n        }\n    }\n    free(sum);\n    return res;\n}", "prefix": "int subarraySum(int* nums, int numsSize, int k"}
{"id": "870", "path": "output2\\c\\Medium\\870-array-nesting.c", "hypo_code": "int arrayNesting(int* nums, int numsSize){\nint res = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] == -1) {\n            continue;\n        }\n        int start = nums[i], count = 0;\n        while (nums[start] != -1) {\n            int temp = start;\n            start = nums[start];\n            nums[temp] = -1;\n            count++;\n        }\n        res = res > count ? res : count;\n    }\n    return res;\n}", "prefix": "int arrayNesting(int* nums, int numsSize"}
{"id": "871", "path": "output2\\c\\Medium\\871-permutation-in-string.c", "hypo_code": "bool checkInclusion(char * s1, char * s2){\nint len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int* count = (int*)malloc(sizeof(int) * 26);\n    memset(count, 0, sizeof(int) * 26);\n    for (int i = 0; i < len1; i++) {\n        count[s1[i] - 'a']++;\n    }\n    int i = 0, j = 0, k = 0;\n    while (j < len2) {\n        count[s2[j] - 'a']--;\n        if (count[s2[j] - 'a'] < 0) {\n            while (s2[i] != s2[j]) {\n                count[s2[i] - 'a']++;\n                i++;\n            }\n            count[s2[i] - 'a']++;\n            i++;\n        }\n        if (j - i + 1 == len1) {\n            return true;\n        }\n        j++;\n    }\n    return false;\n}", "prefix": "bool checkInclusion(char * s1, char * s2"}
{"id": "873", "path": "output2\\c\\Medium\\873-out-of-boundary-paths.c", "hypo_code": "int findPaths(int m, int n, int maxMove, int startRow, int startColumn){\nint mod = 1000000007;\n\tint dp[m][n][maxMove + 1];\n\tmemset(dp, 0, sizeof(dp));\n\tint directions[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\tfor (int i = 0; i < m; i++) {\n\t\tdp[i][0][0]++;\n\t\tdp[i][n - 1][0]++;\n\t}\n\tfor (int j = 0; j < n; j++) {\n\t\tdp[0][j][0]++;\n\t\tdp[m - 1][j][0]++;\n\t}\n\tfor (int k = 1; k <= maxMove; k++) {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n;j++) {\n\t\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\t\tint prevRow = i + directions[d][0];\n\t\t\t\t\tint prevCol = j + directions[d][1];\n\t\t\t\t\tif (prevRow >= 0 && prevRow < m && prevCol >= 0 && prevCol < n) {\n\t\t\t\t\t\tdp[i][j][k] = (dp[i][j][k] + dp[prevRow][prevCol][k - 1]) % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[startRow][startColumn][maxMove];\n}", "prefix": "int findPaths(int m, int n, int maxMove, int startRow, int startColumn"}
{"id": "874", "path": "output2\\c\\Medium\\874-shortest-unsorted-continuous-subarray.c", "hypo_code": "int findUnsortedSubarray(int* nums, int numsSize){\nint max = INT_MIN, min = INT_MAX;\n    int left = 0, right = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] < max) {\n            right = i;\n        } else {\n            max = nums[i];\n        }\n        if (nums[numsSize - i - 1] > min) {\n            left = numsSize - i - 1;\n        } else {\n            min = nums[numsSize - i - 1];\n        }\n    }\n    return right == left ? 0 : right - left + 1;\n}", "prefix": "int findUnsortedSubarray(int* nums, int numsSize"}
{"id": "875", "path": "output2\\c\\Medium\\875-delete-operation-for-two-strings.c", "hypo_code": "int minDistance(char * word1, char * word2){\nint len1 = strlen(word1);\n    int len2 = strlen(word2);\n    int** dp = (int**)malloc(sizeof(int*) * (len1 + 1));\n    for (int i = 0; i <= len1; i++) {\n        dp[i] = (int*)malloc(sizeof(int) * (len2 + 1));\n        memset(dp[i], 0, sizeof(int) * (len2 + 1));\n    }\n    for (int i = 0; i <= len1; i++) {\n        dp[i][0] = i;\n    }\n    for (int i = 0; i <= len2; i++) {\n        dp[0][i] = i;\n    }\n    for (int i = 1; i <= len1; i++) {\n        for (int j = 1; j <= len2; j++) {\n            dp[i][j] = word1[i - 1] == word2[j - 1] ? dp[i - 1][j - 1] : fmin(dp[i - 1][j], dp[i][j - 1]) + 1;\n        }\n    }\n    return dp[len1][len2];\n}", "prefix": "int minDistance(char * word1, char * word2"}
{"id": "877", "path": "output2\\c\\Medium\\877-fraction-addition-and-subtraction.c", "hypo_code": "char * fractionAddition(char * expression){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    int* count = (int*)malloc(sizeof(int) * 10);\n    memset(count, 0, sizeof(int) * 10);\n    for (i = 0; i < len; i++) {\n        switch (s[i]) {\n            case 'z':\n                count[0]++;\n                break;\n            case 'w':\n                count[2]++;\n                break;\n            case 'u':\n                count[4]++;\n                break;\n            case 'x':\n                count[6]++;\n                break;\n            case 'g':\n                count[8]++;\n                break;\n            case 's':\n                count[7]++;\n                break;\n            case 'f':\n                count[5]++;\n                break;\n            case 'h':\n                count[3]++;\n                break;\n            case 'i':\n                count[9]++;\n                break;\n            case 'o':\n                count[1]++;\n                break;\n        }\n    }\n    count[7] -= count[6];\n    count[5] -= count[4];\n    count[3] -= count[8];\n    count[9] = count[9] - count[8] - count[6] - count[5];\n    count[1] = count[1] - count[0] - count[2] - count[4];\n    char* res = (char*)malloc(sizeof(char) * (len + 1));\n    memset(res, 0, sizeof(char) * (len + 1));\n    for (i = 0; i < 10; i++) {\n        for (j = 0; j < count[i]; j++) {\n            res[k++] = i + '0';\n        }\n    }\n    res[k] = '\\0';\n    free(count);\n    return res;\n}", "prefix": "char * fractionAddition(char * expression"}
{"id": "878", "path": "output2\\c\\Medium\\878-valid-square.c", "hypo_code": "bool validSquare(int* p1, int p1Size, int* p2, int p2Size, int* p3, int p3Size, int* p4, int p4Size){ \n int* p[4] = {p1, p2, p3, p4};\n    int dis[6] = {0};\n    int index = 0;\n    for(int i = 0; i < 4; i++) {\n        for(int j = i + 1; j < 4; j++) {\n            dis[index++] = (p[i][0] - p[j][0]) * (p[i][0] - p[j][0]) + (p[i][1] - p[j][1]) * (p[i][1] - p[j][1]);\n        }\n    }\n    int max = 0;\n    int min = 2147483647;\n    int count = 0;\n    for(int i = 0; i < 6; i++) {\n        if(dis[i] > max) max = dis[i];\n        if(dis[i] < min) min = dis[i];\n    }\n    for(int i = 0; i < 6; i++) {\n        if(dis[i] == max) count++;\n    }\n    if(count == 2 && dis[5] == dis[4]) return true;\n    return false;\n}", "prefix": "bool validSquare(int* p1, int p1Size, int* p2, int p2Size, int* p3, int p3Size, int* p4, int p4Size"}
{"id": "881", "path": "output2\\c\\Medium\\881-find-duplicate-file-in-system.c", "hypo_code": "char *** findDuplicate(char ** paths, int pathsSize, int* returnSize, int** returnColumnSizes){\n      *returnSize = 0;\n    char*** res = (char***)malloc(sizeof(char**) * 10000);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * 10000);\n    int i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    struct HashNode** hash = (struct HashNode**)malloc(sizeof(struct HashNode*) * 10000);\n    for (i = 0; i < 10000; i++) {\n        hash[i] = NULL;\n    }\n    for (i = 0; i < pathsSize; i++) {\n        char* path = paths[i];\n        int len = strlen(path);\n        int index = 0;\n        while (path[index] != ' ') {\n            index++;\n        }\n        char* dir = (char*)malloc(sizeof(char) * (index + 1));\n        strncpy(dir, path, index);\n        dir[index] = '\\0';\n        index++;\n        while (index < len) {\n            int start = index;\n            while (path[index] != '(') {\n                index++;\n            }\n            char* file = (char*)malloc(sizeof(char) * (index - start + 1));\n            strncpy(file, path + start, index - start);\n            file[index - start] = '\\0';\n            index++;\n            start = index;\n            while (path[index] != ')') {\n                index++;\n            }\n            char* content = (char*)malloc(sizeof(char) * (index - start + 1));\n            strncpy(content, path + start, index - start);\n            content[index - start] = '\\0';\n            index++;\n            struct HashNode* node = (struct HashNode*)malloc(sizeof(struct HashNode));\n            node->dir = dir;\n            node->file = file;\n            node->content = content;\n            node->next = NULL;\n            int key = hashKey(content);\n            if (hash[key] == NULL) {\n                hash[key] = node;\n            } else {\n                struct HashNode* temp = hash[key];\n                while (temp->next != NULL) {\n                    temp = temp->next;\n                }\n                temp->next = node;\n            }\n            while (path[index] == ' ') {\n                index++;\n            }\n        }\n    }\n    for (i = 0; i < 10000; i++) {\n        if (hash[i] != NULL && hash[i]->next != NULL) {\n            struct HashNode* temp = hash[i];\n            res[*returnSize] = (char**)malloc(sizeof(char*) * 10000);\n            (*returnColumnSizes)[*returnSize] = 0;\n            while (temp != NULL) {\n                res[*returnSize][(*returnColumnSizes)[*returnSize]] = (char*)malloc(sizeof(char) * 10000);\n                sprintf(res[*returnSize][(*returnColumnSizes)[*returnSize]], \"%s/%s\", temp->dir, temp->file);\n                (*returnColumnSizes)[*returnSize]++;\n                temp = temp->next;\n            }\n            (*returnSize)++;\n        }\n    }\n    return res;\n}", "prefix": "char *** findDuplicate(char ** paths, int pathsSize, int* returnSize, int** returnColumnSizes"}
{"id": "882", "path": "output2\\c\\Medium\\882-valid-triangle-number.c", "hypo_code": "int triangleNumber(int* nums, int numsSize){\nint res = 0;\n    qsort(nums, numsSize, sizeof(int), cmp);\n    for (int i = numsSize - 1; i >= 2; i--) {\n        int left = 0, right = i - 1;\n        while (left < right) {\n            if (nums[left] + nums[right] > nums[i]) {\n                res += right - left;\n                right--;\n            } else {\n                left++;\n            }\n        }\n    }\n    return res;\n}", "prefix": "int triangleNumber(int* nums, int numsSize"}
{"id": "883", "path": "output2\\c\\Medium\\883-task-scheduler.c", "hypo_code": "int leastInterval(char* tasks, int tasksSize, int n){\nint* count = (int*)malloc(sizeof(int) * 26);\n    memset(count, 0, sizeof(int) * 26);\n    for (int i = 0; i < tasksSize; i++) {\n        count[tasks[i] - 'A']++;\n    }\n    int max = 0;\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (count[i] > max) {\n            max = count[i];\n            maxCount = 1;\n        } else if (count[i] == max) {\n            maxCount++;\n        }\n    }\n    int res = (max - 1) * (n + 1) + maxCount;\n    return res > tasksSize ? res : tasksSize;\n}", "prefix": "int leastInterval(char* tasks, int tasksSize, int n"}
{"id": "885", "path": "output2\\c\\Medium\\885-add-one-row-to-tree.c", "hypo_code": "struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\nif (depth == 1) {\n        struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        node->val = val;\n        node->left = root;\n        node->right = NULL;\n        return node;\n    }\n    int i = 0;\n    struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 1000);\n    int queueSize = 0;\n    queue[queueSize++] = root;\n    while (i < depth - 2) {\n        int size = queueSize;\n        for (int j = 0; j < size; j++) {\n            struct TreeNode* node = queue[0];\n            queueSize--;\n            queue++;\n            if (node->left != NULL) {\n                queue[queueSize++] = node->left;\n            }\n            if (node->right != NULL) {\n                queue[queueSize++] = node->right;\n            }\n        }\n        i++;\n    }\n    while (queueSize != 0) {\n        struct TreeNode* node = queue[0];\n        queueSize--;\n        queue++;\n        struct TreeNode* left = node->left;\n        struct TreeNode* right = node->right;\n        struct TreeNode* leftNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        struct TreeNode* rightNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        leftNode->val = val;\n        rightNode->val = val;\n        leftNode->left = left;\n        rightNode->right = right;\n        node->left = leftNode;\n        node->right = rightNode;\n    }\n    return root;\n}", "prefix": "struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth"}
{"id": "887", "path": "output2\\c\\Medium\\887-sum-of-square-numbers.c", "hypo_code": "bool judgeSquareSum(int c){\nfor (long a = 0; a * a <= c; a++) {\n        double b = sqrt(c - a * a);\n        if (b == (int)b) {\n            return true;\n        }\n    }\n    return false;\n}", "prefix": "bool judgeSquareSum(int c"}
{"id": "888", "path": "output2\\c\\Medium\\888-exclusive-time-of-functions.c", "hypo_code": "int* exclusiveTime(int n, char ** logs, int logsSize, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * n);\n\t*returnSize = n;\n\tint stack[n], top = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tres[i] = 0;\n\t\tstack[i] = 0;\n\t}\n\tfor (int i = 0; i < logsSize; i++) {\n\t\tchar* p = strtok(logs[i], \":\");\n\t\tint index = atoi(p);\n\t\tp = strtok(NULL, \":\");\n\t\tp = strtok(NULL, \":\");\n\t\tint time = atoi(p);\n\t\tif (stack[top] == 0) {\n\t\t\tstack[top] = time;\n\t\t} else {\n\t\t\tres[index] += time - stack[top] + 1;\n\t\t\ttop--;\n\t\t\tif (top >= 0) {\n\t\t\t\tres[stack[top]] -= time - stack[top] + 1;\n\t\t\t}\n\t\t}\n\t\tif (strcmp(p, \"start\") == 0) {\n\t\t\tstack[++top] = index;\n\t\t}\n\t}\n\treturn res;\n}", "prefix": "int* exclusiveTime(int n, char ** logs, int logsSize, int* returnSize"}
{"id": "889", "path": "output2\\c\\Medium\\889-shopping-offers.c", "hypo_code": "int shoppingOffers(int* price, int priceSize, int** special, int specialSize, int* specialColSize, int* needs, int needsSize){\nint res = 0, i = 0, j = 0;\n    for (i = 0; i < needsSize; i++) {\n        res += price[i] * needs[i];\n    }\n    for (i = 0; i < specialSize; i++) {\n        int* offer = special[i];\n        int valid = 1;\n        for (j = 0; j < needsSize; j++) {\n            if (needs[j] < offer[j]) {\n                valid = 0;\n                break;\n            }\n            needs[j] -= offer[j];\n        }\n        if (valid) {\n            res = fmin(res, offer[j] + shoppingOffers(price, priceSize, special, specialSize, specialColSize, needs, needsSize));\n        }\n        for (j = 0; j < needsSize; j++) {\n            needs[j] += offer[j];\n        }\n    }\n    return res;\n}", "prefix": "int shoppingOffers(int* price, int priceSize, int** special, int specialSize, int* specialColSize, int* needs, int needsSize"}
{"id": "890", "path": "output2\\c\\Medium\\890-solve-the-equation.c", "hypo_code": "char * solveEquation(char * equation){  \n char* res = (char*)malloc(sizeof(char) * 100);\n    int i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(equation);\n    int sign = 1;\n    int a = 0, b = 0;\n    int x = 0;\n    while (j < len) {\n        if (equation[j] == '=') {\n            sign = -1;\n            j++;\n        } else if (equation[j] == 'x') {\n            if (i == j || equation[j - 1] == '+') {\n                a += sign;\n            } else if (equation[j - 1] == '-') {\n                a -= sign;\n            } else {\n                a += sign * atoi(equation + i);\n            }\n            i = ++j;\n        } else if (equation[j] == '+' || equation[j] == '-') {\n            if (i != j) {\n                b += sign * atoi(equation + i);\n            }\n            i = j++;\n        } else {\n            j++;\n        }\n    }\n    if (i != j) {\n        b += sign * atoi(equation + i);\n    }\n    if (a == 0) {\n        if (b == 0) {\n            return \"Infinite solutions\";\n        } else {\n            return \"No solution\";\n        }\n    } else {\n        sprintf(res, \"x=%d\", -b / a);\n        return res;\n    }\n}", "prefix": "char * solveEquation(char * equation"}
{"id": "892", "path": "output2\\c\\Medium\\892-maximum-length-of-pair-chain.c", "hypo_code": "int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\nint res = 0;\n\tint dp[pairsSize];\n\tfor (int i = 0; i < pairsSize; i++) {\n\t\tdp[i] = 1;\n\t}\n\tfor (int i = 0; i < pairsSize; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (pairs[i][0] > pairs[j][1]) {\n\t\t\t\tdp[i] = fmax(dp[i], dp[j] + 1);\n\t\t\t}\n\t\t}\n\t\tres = fmax(res, dp[i]);\n\t}\n\treturn res;\n}", "prefix": "int findLongestChain(int** pairs, int pairsSize, int* pairsColSize"}
{"id": "893", "path": "output2\\c\\Medium\\893-palindromic-substrings.c", "hypo_code": "int countSubstrings(char * s){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    int count = 0;\n    for (i = 0; i < len; i++) {\n        for (j = i; j < len; j++) {\n            for (k = i, l = j; k < l; k++, l--) {\n                if (s[k] != s[l]) {\n                    break;\n                }\n            }\n            if (k >= l) {\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int countSubstrings(char * s"}
{"id": "894", "path": "output2\\c\\Medium\\894-replace-words.c", "hypo_code": "char * replaceWords(char ** dictionary, int dictionarySize, char * sentence){\nint i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    int len = strlen(s);\n    int max = 0;\n    int* count = (int*)malloc(sizeof(int) * 26);\n    memset(count, 0, sizeof(int) * 26);\n    while (j < len) {\n        count[s[j] - 'A']++;\n        max = max > count[s[j] - 'A'] ? max : count[s[j] - 'A'];\n        if (j - i + 1 - max > k) {\n            count[s[i] - 'A']--;\n            i++;\n        }\n        j++;\n    }\n    return j - i;\n}", "prefix": "char * replaceWords(char ** dictionary, int dictionarySize, char * sentence"}
{"id": "895", "path": "output2\\c\\Medium\\895-dota2-senate.c", "hypo_code": "char * predictPartyVictory(char * senate){\nint* radiant = (int*)malloc(sizeof(int) * 10000);\n    int* dire = (int*)malloc(sizeof(int) * 10000);\n    int r = 0, d = 0;\n    while (*senate) {\n        if (*senate == 'R') {\n            radiant[r++] = 1;\n        } else {\n            dire[d++] = 1;\n        }\n        senate++;\n    }\n    while (r != 0 && d != 0) {\n        if (r > d) {\n            r -= d;\n            d = 0;\n        } else {\n            d -= r;\n            r = 0;\n        }\n    }\n    return r == 0 ? \"Dire\" : \"Radiant\";\n\n}", "prefix": "char * predictPartyVictory(char * senate"}
{"id": "896", "path": "output2\\c\\Medium\\896-2-keys-keyboard.c", "hypo_code": "int minSteps(int n){\nint res = 0;\n    for (int i = 2; i <= n; i++) {\n        while (n % i == 0) {\n            res += i;\n            n /= i;\n        }\n    }\n    return res;\n}", "prefix": "int minSteps(int n"}
{"id": "897", "path": "output2\\c\\Medium\\897-find-duplicate-subtrees.c", "hypo_code": "struct TreeNode** findDuplicateSubtrees(struct TreeNode* root, int* returnSize){\nstruct TreeNode** res = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 1000);\n\t*returnSize = 0;\n\tif (root == NULL) {\n\t\treturn res;\n\t}\n\tstruct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 1000);\n\tint top = -1;\n\tstruct TreeNode* pre = NULL;\n\twhile (root != NULL || top != -1) {\n\t\twhile (root != NULL) {\n\t\t\tstack[++top] = root;\n\t\t\troot = root->left;\n\t\t}\n\t\troot = stack[top--];\n\t\tif (root->right == NULL || root->right == pre) {\n\t\t\tres[(*returnSize)++] = root;\n\t\t\tpre = root;\n\t\t\troot = NULL;\n\t\t} else {\n\t\t\tstack[++top] = root;\n\t\t\troot = root->right;\n\t\t}\n\t}\n\treturn res;\n}", "prefix": "struct TreeNode** findDuplicateSubtrees(struct TreeNode* root, int* returnSize"}
{"id": "898", "path": "output2\\c\\Medium\\898-maximum-binary-tree.c", "hypo_code": "struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize){\nif (numsSize == 0) {\n        return NULL;\n    }\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    int max = 0, index = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] > max) {\n            max = nums[i];\n            index = i;\n        }\n    }\n    root->val = max;\n    root->left = constructMaximumBinaryTree(nums, index);\n    root->right = constructMaximumBinaryTree(nums + index + 1, numsSize - index - 1);\n    return root;\n}", "prefix": "struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize"}
{"id": "899", "path": "output2\\c\\Medium\\899-print-binary-tree.c", "hypo_code": "char *** printTree(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\nint height = getHeight(root);\n    int col = pow(2, height) - 1;\n    char ***res = (char***)malloc(sizeof(char**) * height);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * height);\n    for (int i = 0; i < height; i++) {\n        res[i] = (char**)malloc(sizeof(char*) * col);\n        (*returnColumnSizes)[i] = col;\n        for (int j = 0; j < col; j++) {\n            res[i][j] = (char*)malloc(sizeof(char) * 10);\n            strcpy(res[i][j], \"\");\n        }\n    }\n    dfs(root, res, 0, 0, col - 1);\n    *returnSize = height;\n    return res;\n}\nint getHeight(struct TreeNode* root) {\n    if (root == NULL) {\n        return 0;\n    }\n    return fmax(getHeight(root->left), getHeight(root->right)) + 1;\n}\n\nvoid dfs(struct TreeNode* root, char*** res, int depth, int left, int right) {\n    if (root == NULL) {\n        return;\n    }\n    int mid = left + (right - left) / 2;\n    sprintf(res[depth][mid], \"%d\", root->val);\n    dfs(root->left, res, depth + 1, left, mid - 1);\n    dfs(root->right, res, depth + 1, mid + 1, right);\n}", "prefix": "char *** printTree(struct TreeNode* root, int* returnSize, int** returnColumnSizes"}
{"id": "900", "path": "output2\\c\\Medium\\900-find-k-closest-elements.c", "hypo_code": "int* findClosestElements(int* arr, int arrSize, int k, int x, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * k);\n\t*returnSize = 0;\n\tif (arrSize == 0) return res;\n\tint left = 0, right = arrSize - k;\n\twhile (left < right) {\n\t\tint mid = (left + right) / 2;\n\t\tif (x - arr[mid] > arr[mid + k] - x) {\n\t\t\tleft = mid + 1;\n\t\t} else {\n\t\t\tright = mid;\n\t\t}\n\t}\n\tfor (int i = left; i < left + k; i++) {\n\t\tres[(*returnSize)++] = arr[i];\n\t}\n\treturn res;\n}", "prefix": "int* findClosestElements(int* arr, int arrSize, int k, int x, int* returnSize"}
{"id": "901", "path": "output2\\c\\Medium\\901-split-array-into-consecutive-subsequences.c", "hypo_code": "bool isPossible(int* nums, int numsSize){\nint* count = (int*)malloc(sizeof(int) * nums[numsSize - 1]);\n    memset(count, 0, sizeof(int) * nums[numsSize - 1]);\n    for (int i = 0; i < numsSize; i++) {\n        count[nums[i] - 1]++;\n    }\n    int end0 = 0, end1 = 0, end2 = 0;\n    for (int i = 0; i < nums[numsSize - 1]; i++) {\n        if (count[i] > 0) {\n            if (i > 0 && end0 + end1 > count[i]) {\n                return false;\n            }\n            int temp = count[i] - end0 - end1;\n            if (temp < 0) {\n                return false;\n            }\n            end1 = end0;\n            end0 = temp;\n            end2 = count[i];\n        }\n        else {\n            if (end0 != 0 || end1 != 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool isPossible(int* nums, int numsSize"}
{"id": "902", "path": "output2\\c\\Medium\\902-maximum-width-of-binary-tree.c", "hypo_code": "int widthOfBinaryTree(struct TreeNode* root){\nif (root == NULL) {\n        return 0;\n    }\n    int res = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;\n    struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 3000);\n    int queueSize = 0;\n    queue[queueSize++] = root;\n    while (queueSize != 0) {\n        int size = queueSize;\n        res = res > size ? res : size;\n        for (i = 0; i < size; i++) {\n            struct TreeNode* node = queue[0];\n            queueSize--;\n            queue++;\n            if (node != NULL) {\n                queue[queueSize++] = node->left;\n                queue[queueSize++] = node->right;\n            } else {\n                queue[queueSize++] = NULL;\n                queue[queueSize++] = NULL;\n            }\n        }\n        while (queueSize != 0 && queue[queueSize - 1] == NULL) {\n            queueSize--;\n        }\n        while (queueSize != 0 && queue[0] == NULL) {\n            queue++;\n            queueSize--;\n        }\n    }\n    return res;\n}", "prefix": "int widthOfBinaryTree(struct TreeNode* root"}
{"id": "903", "path": "output2\\c\\Medium\\903-non-decreasing-array.c", "hypo_code": "bool checkPossibility(int* nums, int numsSize){\nint count = 0;\n    for (int i = 0; i < numsSize - 1; i++) {\n        if (nums[i] > nums[i + 1]) {\n            count++;\n            if (count > 1) return false;\n            if (i > 0 && nums[i + 1] < nums[i - 1]) {\n                nums[i + 1] = nums[i];\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool checkPossibility(int* nums, int numsSize"}
{"id": "904", "path": "output2\\c\\Medium\\904-beautiful-arrangement-ii.c", "hypo_code": "int* constructArray(int n, int k, int* returnSize){\n    int* answer = (int*)malloc(sizeof(int) * n);\n    int i = 0;\n    int j = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\n}", "prefix": "int* constructArray(int n, int k, int* returnSize"}
{"id": "905", "path": "output2\\c\\Medium\\905-trim-a-binary-search-tree.c", "hypo_code": "struct TreeNode* trimBST(struct TreeNode* root, int low, int high){\n    if(root == NULL){\n        return NULL;\n    }\n    if(root->val < low){\n        return trimBST(root->right, low, high);\n    }\n    if(root->val > high){\n        return trimBST(root->left, low, high);\n    }\n    root->left = trimBST(root->left, low, high);\n    root->right = trimBST(root->right, low, high);\n    return root;\n\n}", "prefix": "struct TreeNode* trimBST(struct TreeNode* root, int low, int high"}
{"id": "906", "path": "output2\\c\\Medium\\906-maximum-swap.c", "hypo_code": "int maximumSwap(int num){\n    int* digits = (int*)malloc(sizeof(int) * 10);\n    int digitCount = 0;\n    while(num > 0){\n        digits[digitCount++] = num % 10;\n        num /= 10;\n    }\n    for(int i = 0; i < digitCount; i++){\n        int max = digits[i];\n        int maxIndex = i;\n        for(int j = i + 1; j < digitCount; j++){\n            if(digits[j] >= max){\n                max = digits[j];\n                maxIndex = j;\n            }\n        }\n        if(maxIndex != i){\n            int temp = digits[i];\n            digits[i] = digits[maxIndex];\n            digits[maxIndex] = temp;\n            break;\n        }\n    }\n    int result = 0;\n    for(int i = digitCount - 1; i >= 0; i--){\n        result = result * 10 + digits[i];\n    }\n    return result;\n\n}", "prefix": "int maximumSwap(int num"}
{"id": "907", "path": "output2\\c\\Medium\\907-bulb-switcher-ii.c", "hypo_code": "int flipLights(int n, int presses){\n    if(n == 0 || presses == 0){\n        return 1;\n    }\n    if(n == 1){\n        return 2;\n    }\n    if(n == 2){\n        if(presses == 1){\n            return 3;\n        }\n        return 4;\n    }\n    if(presses == 1){\n        return 4;\n    }\n    if(presses == 2){\n        return 7;\n    }\n    return 8;\n\n}", "prefix": "int flipLights(int n, int presses"}
{"id": "908", "path": "output2\\c\\Medium\\908-number-of-longest-increasing-subsequence.c", "hypo_code": "int findNumberOfLIS(int* nums, int numsSize){\n    int* dp = (int*)malloc(sizeof(int) * numsSize);\n    int* count = (int*)malloc(sizeof(int) * numsSize);\n    int max = 0;\n    int maxCount = 0;\n    for(int i = 0; i < numsSize; i++){\n        dp[i] = 1;\n        count[i] = 1;\n        for(int j = 0; j < i; j++){\n            if(nums[i] > nums[j]){\n                if(dp[j] + 1 > dp[i]){\n                    dp[i] = dp[j] + 1;\n                    count[i] = count[j];\n                }else if(dp[j] + 1 == dp[i]){\n                    count[i] += count[j];\n                }\n            }\n        }\n        if(dp[i] > max){\n            max = dp[i];\n            maxCount = count[i];\n        }else if(dp[i] == max){\n            maxCount += count[i];\n        }\n    }\n    return maxCount;\n\n\n}", "prefix": "int findNumberOfLIS(int* nums, int numsSize"}
{"id": "911", "path": "output2\\c\\Medium\\911-valid-parenthesis-string.c", "hypo_code": "bool checkValidString(char * s){\n    int left = 0;\n    int right = 0;\n    int len = strlen(s);\n    for(int i = 0; i < len; i++){\n        if(s[i] == '('){\n            left++;\n        }else{\n            left--;\n        }\n        if(s[len - i - 1] == ')'){\n            right++;\n        }else{\n            right--;\n        }\n        if(left < 0 || right < 0){\n            return false;\n        }\n    }\n    return true;\n\n\n}", "prefix": "bool checkValidString(char * s"}
{"id": "912", "path": "output2\\c\\Medium\\912-redundant-connection.c", "hypo_code": "int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int* parent = (int*)malloc(sizeof(int) * edgesSize);\n    for(int i = 0; i < edgesSize; i++){\n        parent[i] = i;\n    }\n    for(int i = 0; i < edgesSize; i++){\n        int x = edges[i][0];\n        int y = edges[i][1];\n        while(parent[x] != x){\n            x = parent[x];\n        }\n        while(parent[y] != y){\n            y = parent[y];\n        }\n        if(x == y){\n            *returnSize = 2;\n            return edges[i];\n        }else{\n            parent[x] = y;\n        }\n    }\n    *returnSize = 0;\n    return NULL;\n\n}", "prefix": "int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize"}
{"id": "913", "path": "output2\\c\\Medium\\913-repeated-string-match.c", "hypo_code": "int repeatedStringMatch(char * a, char * b){\n    int aLength = strlen(a);\n    int bLength = strlen(b);\n    int count = 0;\n    int i = 0;\n    int j = 0;\n    while(i < aLength){\n        if(a[i] == b[j]){\n            j++;\n            if(j == bLength){\n                return count + 1;\n            }\n        }else{\n            j = 0;\n            if(a[i] == b[j]){\n                j++;\n            }\n        }\n        i++;\n        if(i == aLength){\n            i = 0;\n            count++;\n        }\n    }\n    return -1;\n\n}", "prefix": "int repeatedStringMatch(char * a, char * b"}
{"id": "914", "path": "output2\\c\\Medium\\914-longest-univalue-path.c", "hypo_code": "int longestUnivaluePath(struct TreeNode* root){\n    int max = 0;\n    int* maxPtr = &max;\n    longestUnivaluePathHelper(root, maxPtr);\n    return max;\n\n}", "prefix": "int longestUnivaluePath(struct TreeNode* root"}
{"id": "915", "path": "output2\\c\\Medium\\915-knight-probability-in-chessboard.c", "hypo_code": "double knightProbability(int n, int k, int row, int column){\n    double dp[25][25][101] = {0};\n    int moves[8][2] = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n    dp[row][column][0] = 1;\n    for(int i = 1; i <= k; i++){\n        for(int j = 0; j < n; j++){\n            for(int l = 0; l < n; l++){\n                for(int m = 0; m < 8; m++){\n                    int newRow = j + moves[m][0];\n                    int newColumn = l + moves[m][1];\n                    if(newRow >= 0 && newRow < n && newColumn >= 0 && newColumn < n){\n                        dp[newRow][newColumn][i] += dp[j][l][i - 1] / 8;\n                    }\n                }\n            }\n        }\n    }\n    double result = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            result += dp[i][j][k];\n        }\n    }\n    return result;\n\n}", "prefix": "double knightProbability(int n, int k, int row, int column"}
{"id": "917", "path": "output2\\c\\Medium\\917-top-k-frequent-words.c", "hypo_code": "char ** topKFrequent(char ** words, int wordsSize, int k, int* returnSize){\n    int* count = (int*)malloc(sizeof(int) * wordsSize);\n    for(int i = 0; i < wordsSize; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < wordsSize; i++){\n        for(int j = 0; j < wordsSize; j++){\n            if(strcmp(words[i], words[j]) == 0){\n                count[i]++;\n            }\n        }\n    }\n    int* index = (int*)malloc(sizeof(int) * wordsSize);\n    for(int i = 0; i < wordsSize; i++){\n        index[i] = i;\n    }\n    for(int i = 0; i < wordsSize; i++){\n        for(int j = i + 1; j < wordsSize; j++){\n            if(count[i] < count[j]){\n                int temp = count[i];\n                count[i] = count[j];\n                count[j] = temp;\n                temp = index[i];\n                index[i] = index[j];\n                index[j] = temp;\n            }else if(count[i] == count[j]){\n                if(strcmp(words[index[i]], words[index[j]]) > 0){\n                    int temp = count[i];\n                    count[i] = count[j];\n                    count[j] = temp;\n                    temp = index[i];\n                    index[i] = index[j];\n                    index[j] = temp;\n                }\n            }\n        }\n    }\n    char** answer = (char**)malloc(sizeof(char*) * k);\n    for(int i = 0; i < k; i++){\n        answer[i] = (char*)malloc(sizeof(char) * 11);\n        strcpy(answer[i], words[index[i]]);\n    }\n    *returnSize = k;\n    return answer;\n\n}", "prefix": "char ** topKFrequent(char ** words, int wordsSize, int k, int* returnSize"}
{"id": "918", "path": "output2\\c\\Medium\\918-max-area-of-island.c", "hypo_code": "int maxAreaOfIsland(int** grid, int gridSize, int* gridColSize){\nint maxArea = 0;\n    for (int i = 0; i < gridSize; i++) {\n        for (int j = 0; j < *gridColSize; j++) {\n            if (grid[i][j] == 1) {\n                int area = 0;\n                grid[i][j] = 0;\n                int queue[2][2500];\n                int queueStart = 0;\n                int queueEnd = 1;\n                queue[0][0] = i;\n                queue[1][0] = j;\n                while (queueStart < queueEnd) {\n                    int x = queue[0][queueStart];\n                    int y = queue[1][queueStart];\n                    queueStart++;\n                    area++;\n                    if (x > 0 && grid[x - 1][y] == 1) {\n                        grid[x - 1][y] = 0;\n                        queue[0][queueEnd] = x - 1;\n                        queue[1][queueEnd] = y;\n                        queueEnd++;\n                    }\n                    if (x < gridSize - 1 && grid[x + 1][y] == 1) {\n                        grid[x + 1][y] = 0;\n                        queue[0][queueEnd] = x + 1;\n                        queue[1][queueEnd] = y;\n                        queueEnd++;\n                    }\n                    if (y > 0 && grid[x][y - 1] == 1) {\n                        grid[x][y - 1] = 0;\n                        queue[0][queueEnd] = x;\n                        queue[1][queueEnd] = y - 1;\n                        queueEnd++;\n                    }\n                    if (y < *gridColSize - 1 && grid[x][y + 1] == 1) {\n                        grid[x][y + 1] = 0;\n                        queue[0][queueEnd] = x;\n                        queue[1][queueEnd] = y + 1;\n                        queueEnd++;\n                    }\n                }\n                if (area > maxArea) {\n                    maxArea = area;\n                }\n            }\n        }\n    }\n    return maxArea;\n}", "prefix": "int maxAreaOfIsland(int** grid, int gridSize, int* gridColSize"}
{"id": "919", "path": "output2\\c\\Medium\\919-partition-to-k-equal-sum-subsets.c", "hypo_code": "bool canPartitionKSubsets(int* nums, int numsSize, int k){ \nint sum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n    }\n    if (sum % k != 0) {\n        return false;\n    }\n    int target = sum / k;\n    int used[16] = {0};\n    int current = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (used[i] == 0) {\n            current += nums[i];\n            if (current == target) {\n                current = 0;\n            } else if (current > target) {\n                return false;\n            } else {\n                for (int j = i + 1; j < numsSize; j++) {\n                    if (used[j] == 0) {\n                        int temp = current + nums[j];\n                        if (temp <= target) {\n                            current = temp;\n                            used[j] = 1;\n                            if (current == target) {\n                                current = 0;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (current > 0) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool canPartitionKSubsets(int* nums, int numsSize, int k"}
{"id": "920", "path": "output2\\c\\Medium\\920-insert-into-a-binary-search-tree.c", "hypo_code": "struct TreeNode* insertIntoBST(struct TreeNode* root, int val){\nif (root == NULL) {\n        struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        node->val = val;\n        node->left = NULL;\n        node->right = NULL;\n        return node;\n    }\n    if (val < root->val) {\n        root->left = insertIntoBST(root->left, val);\n    } else {\n        root->right = insertIntoBST(root->right, val);\n    }\n    return root;\n}", "prefix": "struct TreeNode* insertIntoBST(struct TreeNode* root, int val"}
{"id": "922", "path": "output2\\c\\Medium\\922-minimum-ascii-delete-sum-for-two-strings.c", "hypo_code": "int minimumDeleteSum(char * s1, char * s2){\nint length1 = strlen(s1);\n    int length2 = strlen(s2);\n    int dp[length1 + 1][length2 + 1];\n    dp[0][0] = 0;\n    int sum = 0;\n    for (int i = 1; i <= length1; i++) {\n        sum += s1[i - 1];\n        dp[i][0] = sum;\n    }\n    sum = 0;\n    for (int i = 1; i <= length2; i++) {\n        sum += s2[i - 1];\n        dp[0][i] = sum;\n    }\n    for (int i = 1; i <= length1; i++) {\n        for (int j = 1; j <= length2; j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                int temp1 = dp[i - 1][j] + s1[i - 1];\n                int temp2 = dp[i][j - 1] + s2[j - 1];\n                dp[i][j] = temp1 < temp2 ? temp1 : temp2;\n            }\n        }\n    }\n    return dp[length1][length2];\n}", "prefix": "int minimumDeleteSum(char * s1, char * s2"}
{"id": "923", "path": "output2\\c\\Medium\\923-subarray-product-less-than-k.c", "hypo_code": "int numSubarrayProductLessThanK(int* nums, int numsSize, int k){\n    if(k <= 1){\n        return 0;\n    }\n    int count = 0;\n    int product = 1;\n    int left = 0;\n    int right = 0;\n    while(right < numsSize){\n        product *= nums[right];\n        while(product >= k){\n            product /= nums[left++];\n        }\n        count += right - left + 1;\n        right++;\n    }\n    return count;\n\n}", "prefix": "int numSubarrayProductLessThanK(int* nums, int numsSize, int k"}
{"id": "924", "path": "output2\\c\\Medium\\924-best-time-to-buy-and-sell-stock-with-transaction-fee.c", "hypo_code": "int maxProfit(int* prices, int pricesSize, int fee){\n    int profit = 0;\n    int buy = prices[0];\n    for(int i = 1; i < pricesSize; i++){\n        if(prices[i] < buy){\n            buy = prices[i];\n        }\n        else if(prices[i] > buy + fee){\n            profit += prices[i] - buy - fee;\n            buy = prices[i] - fee;\n        }\n    }\n    return profit;\n\n}", "prefix": "int maxProfit(int* prices, int pricesSize, int fee"}
{"id": "925", "path": "output2\\c\\Medium\\925-maximum-length-of-repeated-subarray.c", "hypo_code": "int findLength(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int** dp = (int**)malloc(sizeof(int*) * (nums1Size + 1));\n    for(int i = 0; i <= nums1Size; i++){\n        dp[i] = (int*)malloc(sizeof(int) * (nums2Size + 1));\n        for(int j = 0; j <= nums2Size; j++){\n            dp[i][j] = 0;\n        }\n    }\n    int result = 0;\n    for(int i = 1; i <= nums1Size; i++){\n        for(int j = 1; j <= nums2Size; j++){\n            if(nums1[i - 1] == nums2[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n                result = result > dp[i][j] ? result : dp[i][j];\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int findLength(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "926", "path": "output2\\c\\Medium\\926-longest-word-in-dictionary.c", "hypo_code": "char * longestWord(char ** words, int wordsSize){\n    char* answer = (char*)malloc(sizeof(char) * 31);\n    strcpy(answer, \"\");\n    for(int i = 0; i < wordsSize; i++){\n        int j = 0;\n        int k = 0;\n        int flag = 1;\n        while(words[i][j] != '\\0'){\n            char temp = words[i][j];\n            words[i][j] = '\\0';\n            while(k < wordsSize){\n                if(strcmp(words[i], words[k]) == 0){\n                    break;\n                }\n                k++;\n            }\n            if(k == wordsSize){\n                flag = 0;\n                break;\n            }\n            words[i][j] = temp;\n            j++;\n            k = 0;\n        }\n        if(flag == 1){\n            if(strlen(words[i]) > strlen(answer)){\n                strcpy(answer, words[i]);\n            }else if(strlen(words[i]) == strlen(answer)){\n                if(strcmp(words[i], answer) < 0){\n                    strcpy(answer, words[i]);\n                }\n            }\n        }\n    }\n    return answer;\n\n}", "prefix": "char * longestWord(char ** words, int wordsSize"}
{"id": "927", "path": "output2\\c\\Medium\\927-accounts-merge.c", "hypo_code": "char *** accountsMerge(char *** accounts, int accountsSize, int* accountsColSize, int* returnSize, int** returnColumnSizes){\n    int* parent = (int*)malloc(sizeof(int) * accountsSize);\n    for(int i = 0; i < accountsSize; i++){\n        parent[i] = i;\n    }\n    for(int i = 0; i < accountsSize; i++){\n        for(int j = i + 1; j < accountsSize; j++){\n            for(int k = 1; k < accountsColSize[i]; k++){\n                for(int l = 1; l < accountsColSize[j]; l++){\n                    if(strcmp(accounts[i][k], accounts[j][l]) == 0){\n                        int x = i;\n                        int y = j;\n                        while(parent[x] != x){\n                            x = parent[x];\n                        }\n                        while(parent[y] != y){\n                            y = parent[y];\n                        }\n                        if(x != y){\n                            parent[x] = y;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int* count = (int*)malloc(sizeof(int) * accountsSize);\n    for(int i = 0; i < accountsSize; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < accountsSize; i++){\n        int x = i;\n        while(parent[x] != x){\n            x = parent[x];\n        }\n        count[x]++;\n    }\n    char*** answer = (char***)malloc(sizeof(char**) * accountsSize);\n    for(int i = 0; i < accountsSize; i++){\n        answer[i] = (char**)malloc(sizeof(char*) * 1001);\n        for(int j = 0; j < 1001; j++){\n            answer[i][j] = (char*)malloc(sizeof(char) * 31);\n        }\n    }\n    int* index = (int*)malloc(sizeof(int) * accountsSize);\n    for(int i = 0; i < accountsSize; i++){\n        index[i] = 0;\n    }\n    for(int i = 0; i < accountsSize; i++){\n        int x = i;\n        while(parent[x] != x){\n            x = parent[x];\n        }\n        strcpy(answer[x][index[x]], accounts[i][0]);\n        index[x]++;\n        for(int j = 1; j < accountsColSize[i]; j++){\n            int flag = 0;\n            for(int k = 1; k < index[x]; k++){\n                if (strcmp(answer[x][k], accounts[i][j]) == 0){\n                    flag = 1;\n                    break;\n                }\n\n}", "prefix": "char *** accountsMerge(char *** accounts, int accountsSize, int* accountsColSize, int* returnSize, int** returnColumnSizes"}
{"id": "928", "path": "output2\\c\\Medium\\928-remove-comments.c", "hypo_code": "char ** removeComments(char ** source, int sourceSize, int* returnSize){\n    char** answer = (char**)malloc(sizeof(char*) * sourceSize);\n    for(int i = 0; i < sourceSize; i++){\n        answer[i] = (char*)malloc(sizeof(char) * 81);\n    }\n    int index = 0;\n    int flag = 0;\n    for(int i = 0; i < sourceSize; i++){\n        int j = 0;\n        while(source[i][j] != '\\0'){\n            if(flag == 0 && source[i][j] == '/' && source[i][j + 1] == '/'){\n                break;\n            }\n            if(flag == 0 && source[i][j] == '/' && source[i][j + 1] == '*'){\n                flag = 1;\n                j++;\n            }\n            else if(flag == 1 && source[i][j] == '*' && source[i][j + 1] == '/'){\n                flag = 0;\n                j++;\n            }\n            else if(flag == 0){\n                answer[index][j] = source[i][j];\n            }\n            j++;\n        }\n        if(flag == 0 && j != 0){\n            answer[index][j] = '\\0';\n            index++;\n        }\n    }\n    *returnSize = index;\n    return answer;\n\n}", "prefix": "char ** removeComments(char ** source, int sourceSize, int* returnSize"}
{"id": "929", "path": "output2\\c\\Medium\\929-split-linked-list-in-parts.c", "hypo_code": "struct ListNode** splitListToParts(struct ListNode* head, int k, int* returnSize){\nint len = 0;\n    struct ListNode* p = head;\n    while (p != NULL) {\n        len++;\n        p = p->next;\n    }\n    int width = len / k;\n    int rem = len % k;\n    struct ListNode** res = (struct ListNode**)malloc(sizeof(struct ListNode*) * k);\n    struct ListNode* cur = head;\n    for (int i = 0; i < k; i++) {\n        struct ListNode* root = cur;\n        for (int j = 0; j < width + (i < rem ? 1 : 0) - 1; j++) {\n            if (cur != NULL) {\n                cur = cur->next;\n            }\n        }\n        if (cur != NULL) {\n            struct ListNode* temp = cur;\n            cur = cur->next;\n            temp->next = NULL;\n        }\n        res[i] = root;\n    }\n    *returnSize = k;\n    return res;\n}", "prefix": "struct ListNode** splitListToParts(struct ListNode* head, int k, int* returnSize"}
{"id": "932", "path": "output2\\c\\Medium\\932-asteroid-collision.c", "hypo_code": "int* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * asteroidsSize);\n    *returnSize = 0;\n    for (int i = 0; i < asteroidsSize; i++) {\n        int cur = asteroids[i];\n        if (*returnSize == 0 || cur > 0) {\n            res[(*returnSize)++] = cur;\n        } else {\n            while (*returnSize > 0 && res[(*returnSize) - 1] > 0 && res[(*returnSize) - 1] < -cur) {\n                (*returnSize)--;\n            }\n            if (*returnSize > 0 && res[(*returnSize) - 1] == -cur) {\n                (*returnSize)--;\n            } else if (*returnSize == 0 || res[(*returnSize) - 1] < 0) {\n                res[(*returnSize)++] = cur;\n            }\n        }\n    }\n    return res;\n}", "prefix": "int* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize"}
{"id": "933", "path": "output2\\c\\Medium\\933-monotone-increasing-digits.c", "hypo_code": "int monotoneIncreasingDigits(int n){\nint digits[9] = {0};\n    int digitsSize = 0;\n    int temp = n;\n    while (temp > 0) {\n        digits[digitsSize] = temp % 10;\n        digitsSize++;\n        temp /= 10;\n    }\n    int result = 0;\n    for (int i = digitsSize - 1; i >= 0; i--) {\n        int temp = 0;\n        for (int j = 0; j < i; j++) {\n            temp = temp * 10 + digits[j];\n        }\n        int current = digits[i];\n        for (int j = i + 1; j < digitsSize; j++) {\n            current = current * 10 + 9;\n        }\n        for (int j = digitsSize - 1; j > i; j--) {\n            current = current * 10 + digits[j];\n        }\n        if (current <= n) {\n            result = temp * 10 + digits[i];\n            break;\n        }\n    }\n    return result;\n}", "prefix": "int monotoneIncreasingDigits(int n"}
{"id": "934", "path": "output2\\c\\Medium\\934-daily-temperatures.c", "hypo_code": "int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * temperaturesSize);\n    *returnSize = temperaturesSize;\n    int stack[temperaturesSize][2];\n    int top = -1;\n    for (int i = 0; i < temperaturesSize; i++) {\n        int cur = temperatures[i];\n        while (top != -1 && cur > stack[top][1]) {\n            int index = stack[top--][0];\n            res[index] = i - index;\n        }\n        stack[++top][0] = i;\n        stack[top][1] = cur;\n    }\n    while (top != -1) {\n        res[stack[top--][0]] = 0;\n    }\n    return res;\n}", "prefix": "int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize"}
{"id": "935", "path": "output2\\c\\Medium\\935-delete-and-earn.c", "hypo_code": "int deleteAndEarn(int* nums, int numsSize){\nint max = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] > max) {\n            max = nums[i];\n        }\n    }\n    int dp[max + 1];\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < numsSize; i++) {\n        dp[nums[i]] += nums[i];\n    }\n    for (int i = 2; i <= max; i++) {\n        dp[i] = fmax(dp[i - 1], dp[i - 2] + dp[i]);\n    }\n    return dp[max];\n}", "prefix": "int deleteAndEarn(int* nums, int numsSize"}
{"id": "936", "path": "output2\\c\\Medium\\936-network-delay-time.c", "hypo_code": "int networkDelayTime(int** times, int timesSize, int* timesColSize, int n, int k){\nint dist[n + 1];\n    for (int i = 1; i <= n; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[k] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < timesSize; j++) {\n            if (dist[times[j][0]] != INT_MAX && dist[times[j][1]] > dist[times[j][0]] + times[j][2]) {\n                dist[times[j][1]] = dist[times[j][0]] + times[j][2];\n            }\n        }\n    }\n    int max = 0;\n    for (int i = 1; i <= n; i++) {\n        if (dist[i] > max) {\n            max = dist[i];\n        }\n    }\n    return max == INT_MAX ? -1 : max;\n\n}", "prefix": "int networkDelayTime(int** times, int timesSize, int* timesColSize, int n, int k"}
{"id": "937", "path": "output2\\c\\Medium\\937-open-the-lock.c", "hypo_code": "int openLock(char ** deadends, int deadendsSize, char * target){\nint* visited = (int*)malloc(sizeof(int) * 10000);\n    memset(visited, 0, sizeof(int) * 10000);\n    for (int i = 0; i < deadendsSize; i++) {\n        visited[atoi(deadends[i])] = 1;\n    }\n    if (visited[0] == 1) {\n        return -1;\n    }\n    int res = 0;\n    int queue[10000];\n    int head = 0;\n    int tail = 0;\n    queue[tail++] = 0;\n    visited[0] = 1;\n    while (head != tail) {\n        int size = tail - head;\n        for (int i = 0; i < size; i++) {\n            int cur = queue[head++];\n            if (cur == atoi(target)) {\n                return res;\n            }\n            int next = 0;\n            for (int j = 0; j < 4; j++) {\n                int digit = (cur / (int)pow(10, j)) % 10;\n                int up = cur + (digit == 9 ? -9 : 1) * (int)pow(10, j);\n                int down = cur + (digit == 0 ? 9 : -1) * (int)pow(10, j);\n                if (visited[up] == 0) {\n                    queue[tail++] = up;\n                    visited[up] = 1;\n                }\n                if (visited[down] == 0) {\n                    queue[tail++] = down;\n                    visited[down] = 1;\n                }\n            }\n        }\n        res++;\n    }\n    return -1;\n}", "prefix": "int openLock(char ** deadends, int deadendsSize, char * target"}
{"id": "938", "path": "output2\\c\\Medium\\938-reach-a-number.c", "hypo_code": "int reachNumber(int target){\nif (target < 0) {\n        target = -target;\n    }\n    int k = 0;\n    int sum = 0;\n    while (sum < target) {\n        k++;\n        sum += k;\n    }\n    if ((sum - target) % 2 == 0) {\n        return k;\n    }\n    if (k % 2 == 0) {\n        return k + 1;\n    }\n    return k + 2;\n}", "prefix": "int reachNumber(int target"}
{"id": "939", "path": "output2\\c\\Medium\\939-pyramid-transition-matrix.c", "hypo_code": "bool pyramidTransition(char * bottom, char ** allowed, int allowedSize){\nint n = strlen(bottom);\n    int dp[n][n];\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < allowedSize; j++) {\n            if (allowed[j][0] == bottom[i]) {\n                dp[i][i] |= (1 << (allowed[j][2] - 'A'));\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n - i; j++) {\n            for (int k = j; k < j + i; k++) {\n                for (int l = 0; l < allowedSize; l++) {\n                    if (allowed[l][0] == (dp[j][k] + 'A') && allowed[l][1] == (dp[k + 1][j + i] + 'A')) {\n                        dp[j][j + i] |= (1 << (allowed[l][2] - 'A'));\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][n - 1] != 0;\n}", "prefix": "bool pyramidTransition(char * bottom, char ** allowed, int allowedSize"}
{"id": "940", "path": "output2\\c\\Medium\\940-partition-labels.c", "hypo_code": "int* partitionLabels(char * s, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * 26);\n    *returnSize = 0;\n    int last[26];\n    for (int i = 0; i < 26; i++) {\n        last[i] = -1;\n    }\n    for (int i = 0; i < strlen(s); i++) {\n        last[s[i] - 'a'] = i;\n    }\n    int start = 0, end = 0;\n    for (int i = 0; i < strlen(s); i++) {\n        end = fmax(end, last[s[i] - 'a']);\n        if (i == end) {\n            res[(*returnSize)++] = end - start + 1;\n            start = end + 1;\n        }\n    }\n    return res;\n}", "prefix": "int* partitionLabels(char * s, int* returnSize"}
{"id": "941", "path": "output2\\c\\Medium\\941-largest-plus-sign.c", "hypo_code": "int orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize){\nint grid[n][n];\n    for (int i = 0; i < n; i++) {\n        memset(grid[i], 1, n * sizeof(int));\n    }\n    for (int i = 0; i < minesSize; i++) {\n        grid[mines[i][0]][mines[i][1]] = 0;\n    }\n    int left[n][n];\n    int right[n][n];\n    int up[n][n];\n    int down[n][n];\n    for (int i = 0; i < n; i++) {\n        left[i][0] = grid[i][0];\n        for (int j = 1; j < n; j++) {\n            if (grid[i][j] == 0) {\n                left[i][j] = 0;\n            } else {\n                left[i][j] = left[i][j - 1] + 1;\n            }\n        }\n        right[i][n - 1] = grid[i][n - 1];\n        for (int j = n - 2; j >= 0; j--) {\n            if (grid[i][j] == 0) {\n                right[i][j] = 0;\n            } else {\n                right[i][j] = right[i][j + 1] + 1;\n            }\n        }\n    }\n    for (int j = 0; j < n; j++) {\n        up[0][j] = grid[0][j];\n        for (int i = 1; i < n; i++) {\n            if (grid[i][j] == 0) {\n                up[i][j] = 0;\n            } else {\n                up[i][j] = up[i - 1][j] + 1;\n            }\n        }\n        down[n - 1][j] = grid[n - 1][j];\n        for (int i = n - 2; i >= 0; i--) {\n            if (grid[i][j] == 0) {\n                down[i][j] = 0;\n            } else {\n                down[i][j] = down[i + 1][j] + 1;\n            }\n        }\n    }\n    int max = 0;\n    for (int j = 0; j < *minesColSize; j++) {\n            int order = fmin(fmin(left[i][j], right[i][j]), fmin(up[i][j], down[i][j]));\n            if (order > max) {\n                max = order;\n            }\n        }\n    return max;\n}", "prefix": "int orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize"}
{"id": "942", "path": "output2\\c\\Medium\\942-reorganize-string.c", "hypo_code": "char * reorganizeString(char * s){\nint length = strlen(s);\n    int count[26] = {0};\n    int max = 0;\n    for (int i = 0; i < length; i++) {\n        count[s[i] - 'a']++;\n        if (count[s[i] - 'a'] > max) {\n            max = count[s[i] - 'a'];\n        }\n    }\n    if (max > (length + 1) / 2) {\n        return \"\";\n    }\n    char* result = (char*)malloc(sizeof(char) * (length + 1));\n    result[length] = '\\0';\n    int evenIndex = 0, oddIndex = 1;\n    for (int i = 0; i < 26; i++) {\n        while (count[i] > 0 && count[i] < (length + 1) / 2 && oddIndex < length) {\n            result[oddIndex] = 'a' + i;\n            count[i]--;\n            oddIndex += 2;\n        }\n        while (count[i] > 0) {\n            result[evenIndex] = 'a' + i;\n            count[i]--;\n            evenIndex += 2;\n        }\n    }\n    return result;\n}", "prefix": "char * reorganizeString(char * s"}
{"id": "943", "path": "output2\\c\\Medium\\943-max-chunks-to-make-sorted.c", "hypo_code": "int maxChunksToSorted(int* arr, int arrSize){\nint max = 0;\n    int result = 0;\n    for (int i = 0; i < arrSize; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n        if (max == i) {\n            result++;\n        }\n    }\n    return result;\n}", "prefix": "int maxChunksToSorted(int* arr, int arrSize"}
{"id": "944", "path": "output2\\c\\Medium\\944-global-and-local-inversions.c", "hypo_code": "bool isIdealPermutation(int* nums, int numsSize){\nfor (int i = 0; i < numsSize; i++) {\n        if (abs(nums[i] - i) > 1) {\n            return false;\n        }\n    }\n    return true;\n\n}", "prefix": "bool isIdealPermutation(int* nums, int numsSize"}
{"id": "945", "path": "output2\\c\\Medium\\945-swap-adjacent-in-lr-string.c", "hypo_code": "bool canTransform(char * start, char * end){\n    int len = strlen(start);\n    int i = 0;\n    int j = 0;\n    while(i < len && j < len){\n        while(i < len && start[i] == 'X'){\n            i++;\n        }\n        while(j < len && end[j] == 'X'){\n            j++;\n        }\n        if((i < len) ^ (j < len)){\n            return false;\n        }\n        if(i < len && j < len){\n            if(start[i] != end[j]){\n                return false;\n            }\n            if(start[i] == 'L' && i < j){\n                return false;\n            }\n            if(start[i] == 'R' && i > j){\n                return false;\n            }\n        }\n        i++;\n        j++;\n    }\n    return true;\n\n}", "prefix": "bool canTransform(char * start, char * end"}
{"id": "946", "path": "output2\\c\\Medium\\946-k-th-symbol-in-grammar.c", "hypo_code": "int kthGrammar(int n, int k){\n    if(n == 1){\n        return 0;\n    }\n    int parent = kthGrammar(n - 1, (k + 1) / 2);\n    if(parent == 0){\n        return k % 2 == 0 ? 1 : 0;\n    }\n    else{\n        return k % 2 == 0 ? 0 : 1;\n    }\n\n}", "prefix": "int kthGrammar(int n, int k"}
{"id": "947", "path": "output2\\c\\Medium\\947-rabbits-in-forest.c", "hypo_code": "int numRabbits(int* answers, int answersSize){\n    int* count = (int*)malloc(sizeof(int) * 1000);\n    int result = 0;\n    for(int i = 0; i < 1000; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < answersSize; i++){\n        count[answers[i]]++;\n    }\n    for(int i = 0; i < 1000; i++){\n        if(count[i] > 0){\n            result += (count[i] + i) / (i + 1) * (i + 1);\n        }\n    }\n    return result;\n\n}", "prefix": "int numRabbits(int* answers, int answersSize"}
{"id": "948", "path": "output2\\c\\Medium\\948-letter-case-permutation.c", "hypo_code": "char ** letterCasePermutation(char * s, int* returnSize){\n    int length = strlen(s);\n    int count = 1;\n    for(int i = 0; i < length; i++){\n        if(s[i] >= 'A' && s[i] <= 'Z'){\n            count *= 2;\n        }\n    }\n    char** answer = (char**)malloc(sizeof(char*) * count);\n    for(int i = 0; i < count; i++){\n        answer[i] = (char*)malloc(sizeof(char) * (length + 1));\n        strcpy(answer[i], s);\n    }\n    int index = 0;\n    for(int i = 0; i < length; i++){\n        if(s[i] >= 'A' && s[i] <= 'Z'){\n            for(int j = 0; j < count; j++){\n                if(j % (int)pow(2, index) == 0){\n                    answer[j][i] = s[i] + 32;\n                }\n            }\n            index++;\n        }\n    }\n    *returnSize = count;\n    return answer;\n\n}", "prefix": "char ** letterCasePermutation(char * s, int* returnSize"}
{"id": "949", "path": "output2\\c\\Medium\\949-is-graph-bipartite.c", "hypo_code": "bool isBipartite(int** graph, int graphSize, int* graphColSize){\n    int* color = (int*)malloc(sizeof(int) * graphSize);\n    for(int i = 0; i < graphSize; i++){\n        color[i] = -1;\n    }\n    for(int i = 0; i < graphSize; i++){\n        if(color[i] == -1){\n            color[i] = 0;\n            if(!isBipartiteHelper(graph, graphSize, graphColSize, color, i)){\n                return false;\n            }\n        }\n    }\n    return true;\n\n}", "prefix": "bool isBipartite(int** graph, int graphSize, int* graphColSize"}
{"id": "950", "path": "output2\\c\\Medium\\950-k-th-smallest-prime-fraction.c", "hypo_code": "int* kthSmallestPrimeFraction(int* arr, int arrSize, int k, int* returnSize){\n    int* answer = (int*)malloc(sizeof(int) * 2);\n    int* count = (int*)malloc(sizeof(int) * arrSize);\n    for(int i = 0; i < arrSize; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < arrSize; i++){\n        for(int j = 0; j < arrSize; j++){\n            if(arr[i] < arr[j]){\n                count[i]++;\n            }\n        }\n    }\n    int* index = (int*)malloc(sizeof(int) * arrSize);\n    for(int i = 0; i < arrSize; i++){\n        index[i] = i;\n    }\n    for(int i = 0; i < arrSize; i++){\n        for(int j = i + 1; j < arrSize; j++){\n            if(count[i] > count[j]){\n                int temp = count[i];\n                count[i] = count[j];\n                count[j] = temp;\n                temp = index[i];\n                index[i] = index[j];\n                index[j] = temp;\n            }else if(count[i] == count[j]){\n                if(arr[index[i]] > arr[index[j]]){\n                    int temp = count[i];\n                    count[i] = count[j];\n                    count[j] = temp;\n                    temp = index[i];\n                    index[i] = index[j];\n                    index[j] = temp;\n                }\n            }\n        }\n    }\n    int* index2 = (int*)malloc(sizeof(int) * arrSize);\n    for(int i = 0; i < arrSize; i++){\n        index2[i] = i;\n    }\n    for(int i = 0; i < arrSize; i++){\n        for(int j = i + 1; j < arrSize; j++){\n            if(arr[index[i]] < arr[index[j]]){\n                if(arr[index2[i]] < arr[index2[j]]){\n                    int temp = index2[i];\n                    index2[i] = index2[j];\n                    index2[j] = temp;\n                }\n            }\n        }\n    }\n    answer[0] = arr[index[index2[k - 1]]];\n    answer[1] = arr[index2[k - 1]];\n    *returnSize = 2;\n    return answer;\n\n\n}", "prefix": "int* kthSmallestPrimeFraction(int* arr, int arrSize, int k, int* returnSize"}
{"id": "951", "path": "output2\\c\\Medium\\951-cheapest-flights-within-k-stops.c", "hypo_code": "int findCheapestPrice(int n, int** flights, int flightsSize, int* flightsColSize, int src, int dst, int k){\n    int* cost = (int*)malloc(sizeof(int) * n);\n    for(int i = 0; i < n; i++){\n        cost[i] = INT_MAX;\n    }\n    cost[src] = 0;\n    for(int i = 0; i <= k; i++){\n        int* temp = (int*)malloc(sizeof(int) * n);\n        for(int j = 0; j < n; j++){\n            temp[j] = cost[j];\n        }\n        for(int j = 0; j < flightsSize; j++){\n            int from = flights[j][0];\n            int to = flights[j][1];\n            int price = flights[j][2];\n            if(cost[from] != INT_MAX && temp[to] > cost[from] + price){\n                temp[to] = cost[from] + price;\n            }\n        }\n        cost = temp;\n    }\n    return cost[dst] == INT_MAX ? -1 : cost[dst];\n\n}", "prefix": "int findCheapestPrice(int n, int** flights, int flightsSize, int* flightsColSize, int src, int dst, int k"}
{"id": "952", "path": "output2\\c\\Medium\\952-rotated-digits.c", "hypo_code": "int rotatedDigits(int n){\n    int count = 0;\n    for(int i = 1; i <= n; i++){\n        int temp = i;\n        int flag = 0;\n        while(temp > 0){\n            int digit = temp % 10;\n            if(digit == 3 || digit == 4 || digit == 7){\n                flag = 0;\n                break;\n            }\n            if(digit == 2 || digit == 5 || digit == 6 || digit == 9){\n                flag = 1;\n            }\n            temp /= 10;\n        }\n        if(flag == 1){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int rotatedDigits(int n"}
{"id": "953", "path": "output2\\c\\Medium\\953-escape-the-ghosts.c", "hypo_code": "bool escapeGhosts(int** ghosts, int ghostsSize, int* ghostsColSize, int* target, int targetSize){\n    int distance = abs(target[0]) + abs(target[1]);\n    for(int i = 0; i < ghostsSize; i++){\n        if(abs(ghosts[i][0] - target[0]) + abs(ghosts[i][1] - target[1]) <= distance){\n            return false;\n        }\n    }\n    return true;\n\n}", "prefix": "bool escapeGhosts(int** ghosts, int ghostsSize, int* ghostsColSize, int* target, int targetSize"}
{"id": "954", "path": "output2\\c\\Medium\\954-domino-and-tromino-tiling.c", "hypo_code": "int numTilings(int n){\n    int mod = 1000000007;\n    long long* dp = (long long*)malloc(sizeof(long long) * (n + 1));\n    dp[0] = 1;\n    dp[1] = 1;\n    dp[2] = 2;\n    for(int i = 3; i <= n; i++){\n        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod;\n    }\n    return dp[n];\n\n}", "prefix": "int numTilings(int n"}
{"id": "955", "path": "output2\\c\\Medium\\955-custom-sort-string.c", "hypo_code": "char * customSortString(char * order, char * s){\n    int* count = (int*)malloc(sizeof(int) * 26);\n    for(int i = 0; i < 26; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < strlen(s); i++){\n        count[s[i] - 'a']++;\n    }\n    char* result = (char*)malloc(sizeof(char) * (strlen(s) + 1));\n    result[0] = '\\0';\n    for(int i = 0; i < strlen(order); i++){\n        for(int j = 0; j < count[order[i] - 'a']; j++){\n            char temp[2];\n            temp[0] = order[i];\n            temp[1] = '\\0';\n            strcat(result, temp);\n        }\n        count[order[i] - 'a'] = 0;\n    }\n    for(int i = 0; i < 26; i++){\n        for(int j = 0; j < count[i]; j++){\n            char temp[2];\n            temp[0] = i + 'a';\n            temp[1] = '\\0';\n            strcat(result, temp);\n        }\n    }\n    return result;\n\n\n}", "prefix": "char * customSortString(char * order, char * s"}
{"id": "956", "path": "output2\\c\\Medium\\956-number-of-matching-subsequences.c", "hypo_code": "int numMatchingSubseq(char * s, char ** words, int wordsSize){\n    int count = 0;\n    int length = strlen(s);\n    int* index = (int*)malloc(sizeof(int) * wordsSize);\n    for(int i = 0; i < wordsSize; i++){\n        index[i] = 0;\n    }\n    for(int i = 0; i < length; i++){\n        for(int j = 0; j < wordsSize; j++){\n            if(index[j] == -1){\n                continue;\n            }\n            if(s[i] == words[j][index[j]]){\n                index[j]++;\n            }\n            if(words[j][index[j]] == '\\0'){\n                count++;\n                index[j] = -1;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int numMatchingSubseq(char * s, char ** words, int wordsSize"}
{"id": "957", "path": "output2\\c\\Medium\\957-valid-tic-tac-toe-state.c", "hypo_code": "bool validTicTacToe(char ** board, int boardSize){\n    int xCount = 0;\n    int oCount = 0;\n    for(int i = 0; i < boardSize; i++){\n        for(int j = 0; j < boardSize; j++){\n            if(board[i][j] == 'X'){\n                xCount++;\n            }\n            if(board[i][j] == 'O'){\n                oCount++;\n            }\n        }\n    }\n    if(oCount > xCount || xCount - oCount > 1){\n        return false;\n    }\n    int xWin = 0;\n    int oWin = 0;\n    for(int i = 0; i < boardSize; i++){\n        if(board[i][0] == board[i][1] && board[i][1] == board[i][2]){\n            if(board[i][0] == 'X'){\n                xWin++;\n            }\n            if(board[i][0] == 'O'){\n                oWin++;\n            }\n        }\n        if(board[0][i] == board[1][i] && board[1][i] == board[2][i]){\n            if(board[0][i] == 'X'){\n                xWin++;\n            }\n            if(board[0][i] == 'O'){\n                oWin++;\n            }\n        }\n    }\n    if(board[0][0] == board[1][1] && board[1][1] == board[2][2]){\n        if(board[0][0] == 'X'){\n            xWin++;\n        }\n        if(board[0][0] == 'O'){\n            oWin++;\n        }\n    }\n    if(board[0][2] == board[1][1] && board[1][1] == board[2][0]){\n        if(board[0][2] == 'X'){\n            xWin++;\n        }\n        if(board[0][2] == 'O'){\n            oWin++;\n        }\n    }\n    if(xWin > 0 && oWin > 0){\n        return false;\n    }\n    if(xWin > 0 && xCount - oCount != 1){\n        return false;\n    }\n    if(oWin > 0 && xCount != oCount){\n        return false;\n    }\n    return true;\n\n}", "prefix": "bool validTicTacToe(char ** board, int boardSize"}
{"id": "958", "path": "output2\\c\\Medium\\958-number-of-subarrays-with-bounded-maximum.c", "hypo_code": "int numSubarrayBoundedMax(int* nums, int numsSize, int left, int right){\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    int count = 0;\n    for(int i = 0; i < numsSize; i++){\n        if(nums[i] >= left && nums[i] <= right){\n            result[i] = 1;\n            count++;\n        }else{\n            result[i] = 0;\n        }\n    }\n    for(int i = 1; i < numsSize; i++){\n        if(result[i] == 1){\n            result[i] = result[i - 1] + 1;\n            count += result[i];\n        }\n    }\n    return count;\n\n}", "prefix": "int numSubarrayBoundedMax(int* nums, int numsSize, int left, int right"}
{"id": "959", "path": "output2\\c\\Medium\\959-all-paths-from-source-to-target.c", "hypo_code": "int** allPathsSourceTarget(int** graph, int graphSize, int* graphColSize, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * 1001);\n    for(int i = 0; i < 1001; i++){\n        result[i] = (int*)malloc(sizeof(int) * 1001);\n    }\n    int resultSize = 0;\n    int* path = (int*)malloc(sizeof(int) * 1001);\n    int pathSize = 0;\n    dfs(graph, graphSize, graphColSize, 0, path, pathSize, result, &resultSize);\n    *returnSize = resultSize;\n    *returnColumnSizes = (int*)malloc(sizeof(int) * resultSize);\n    for(int i = 0; i < resultSize; i++){\n        (*returnColumnSizes)[i] = graphColSize[i];\n    }\n    return result;\n\n}", "prefix": "int** allPathsSourceTarget(int** graph, int graphSize, int* graphColSize, int* returnSize, int** returnColumnSizes"}
{"id": "960", "path": "output2\\c\\Medium\\960-champagne-tower.c", "hypo_code": "double champagneTower(int poured, int query_row, int query_glass){\n    double dp[101][101] = {0};\n    dp[0][0] = poured;\n    for(int i = 0; i <= query_row; i++){\n        for(int j = 0; j <= i; j++){\n            double excess = (dp[i][j] - 1) / 2;\n            if(excess > 0){\n                dp[i + 1][j] += excess;\n                dp[i + 1][j + 1] += excess;\n            }\n        }\n    }\n    return fmin(1, dp[query_row][query_glass]);\n\n}", "prefix": "double champagneTower(int poured, int query_row, int query_glass"}
{"id": "961", "path": "output2\\c\\Medium\\961-find-eventual-safe-states.c", "hypo_code": "int* eventualSafeNodes(int** graph, int graphSize, int* graphColSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 10001);\n    *returnSize = 0;\n    int* color = (int*)malloc(sizeof(int) * graphSize);\n    for(int i = 0; i < graphSize; i++){\n        color[i] = 0;\n    }\n    for(int i = 0; i < graphSize; i++){\n        if(dfs(graph, graphSize, graphColSize, i, color)){\n            result[*returnSize] = i;\n            (*returnSize)++;\n        }\n    }\n    return result;\n\n\n}", "prefix": "int* eventualSafeNodes(int** graph, int graphSize, int* graphColSize, int* returnSize"}
{"id": "962", "path": "output2\\c\\Medium\\962-max-increase-to-keep-city-skyline.c", "hypo_code": "int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize){\n    int* rowMax = (int*)malloc(sizeof(int) * gridSize);\n    int* colMax = (int*)malloc(sizeof(int) * *gridColSize);\n    for(int i = 0; i < gridSize; i++){\n        rowMax[i] = 0;\n        for(int j = 0; j < *gridColSize; j++){\n            rowMax[i] = fmax(rowMax[i], grid[i][j]);\n        }\n    }\n    for(int i = 0; i < *gridColSize; i++){\n        colMax[i] = 0;\n        for(int j = 0; j < gridSize; j++){\n            colMax[i] = fmax(colMax[i], grid[j][i]);\n        }\n    }\n    int sum = 0;\n    for(int i = 0; i < gridSize; i++){\n        for(int j = 0; j < *gridColSize; j++){\n            sum += fmin(rowMax[i], colMax[j]) - grid[i][j];\n        }\n    }\n    return sum;\n\n}", "prefix": "int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize"}
{"id": "963", "path": "output2\\c\\Medium\\963-soup-servings.c", "hypo_code": "double soupServings(int n){\n    if(n >= 4800){\n        return 1;\n    }\n    double dp[200][200] = {0};\n    dp[0][0] = 0.5;\n    for(int i = 0; i < 200; i++){\n        for(int j = 0; j < 200; j++){\n            if(i == 0 && j == 0){\n                continue;\n            }\n            int a = i - 100 >= 0 ? i - 100 : 0;\n            int b = j - 75 >= 0 ? j - 75 : 0;\n            int c = j - 50 >= 0 ? j - 50 : 0;\n            int d = i - 25 >= 0 ? i - 25 : 0;\n            dp[i][j] = 0.25 * (dp[a][j] + dp[b][c] + dp[i][c] + dp[d][j]);\n        }\n    }\n    return dp[(n + 24) / 25][(n + 24) / 25];\n\n}", "prefix": "double soupServings(int n"}
{"id": "964", "path": "output2\\c\\Medium\\964-expressive-words.c", "hypo_code": "int expressiveWords(char * s, char ** words, int wordsSize){\n    int count = 0;\n    int length = strlen(s);\n    int* index = (int*)malloc(sizeof(int) * wordsSize);\n    for(int i = 0; i < wordsSize; i++){\n        index[i] = 0;\n    }\n    for(int i = 0; i < length; i++){\n        for(int j = 0; j < wordsSize; j++){\n            if(index[j] == -1){\n                continue;\n            }\n            if(s[i] == words[j][index[j]]){\n                index[j]++;\n            }\n            if(words[j][index[j]] == '\\0'){\n                count++;\n                index[j] = -1;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int expressiveWords(char * s, char ** words, int wordsSize"}
{"id": "965", "path": "output2\\c\\Medium\\965-subdomain-visit-count.c", "hypo_code": "char ** subdomainVisits(char ** cpdomains, int cpdomainsSize, int* returnSize){\n    char** result = (char**)malloc(sizeof(char*) * 10000);\n    *returnSize = 0;\n    int* count = (int*)malloc(sizeof(int) * 10000);\n    int countSize = 0;\n    for(int i = 0; i < cpdomainsSize; i++){\n        int j = 0;\n        int currentCount = 0;\n        while(cpdomains[i][j] != ' '){\n            currentCount = currentCount * 10 + (cpdomains[i][j] - '0');\n            j++;\n        }\n        j++;\n        int k = j;\n        while(cpdomains[i][k] != '\\0'){\n            if(cpdomains[i][k] == '.'){\n                char* currentDomain = (char*)malloc(sizeof(char) * 100);\n                int currentDomainSize = 0;\n                for(int l = k + 1; l < strlen(cpdomains[i]); l++){\n                    currentDomain[currentDomainSize] = cpdomains[i][l];\n                    currentDomainSize++;\n                }\n                currentDomain[currentDomainSize] = '\\0';\n                int m = 0;\n                for(m = 0; m < countSize; m++){\n                    if(strcmp(result[m], currentDomain) == 0){\n                        count[m] += currentCount;\n                        break;\n                    }\n                }\n                if(m == countSize){\n                    result[countSize] = currentDomain;\n                    count[countSize] = currentCount;\n                    countSize++;\n                }\n            }\n            k++;\n        }\n        char* currentDomain = (char*)malloc(sizeof(char) * 100);\n        int currentDomainSize = 0;\n        for(int l = j; l < strlen(cpdomains[i]); l++){\n            currentDomain[currentDomainSize] = cpdomains[i][l];\n            currentDomainSize++;\n        }\n        currentDomain[currentDomainSize] = '\\0';\n        int m = 0;\n        for(m = 0; m < countSize; m++){\n            if(strcmp(result[m], currentDomain) == 0){\n                count[m] += currentCount;\n                break;\n            }\n        }\n        if(m == countSize){\n            result[countSize] = currentDomain;\n            count[countSize] = currentCount;\n            countSize++;\n        }\n    }\n    for(int i = 0; i < countSize; i++){\n        char* currentResult = (char*)malloc(sizeof(char)\n            * (strlen(result[i]) + 10));\n        int currentResultSize = 0;\n        int currentCount = count[i];\n        while(currentCount != 0){\n            currentResult[currentResultSize] = currentCount % 10 + '0';\n            currentCount /= 10;\n            currentResultSize++;\n        }\n        for(int j = currentResultSize - 1; j >= 0; j--){\n            result[i][currentResultSize - j - 1] = currentResult[j];\n        }\n        result[i][currentResultSize] = ' ';\n        for(int j = 0; j < strlen(result[i]); j++){\n            result[i][currentResultSize + j + 1] = result[i][j];\n        }\n        result[i][currentResultSize + strlen(result[i]) + 1] = '\\0';\n\n        \n\n}", "prefix": "char ** subdomainVisits(char ** cpdomains, int cpdomainsSize, int* returnSize"}
{"id": "966", "path": "output2\\c\\Medium\\966-largest-sum-of-averages.c", "hypo_code": "double largestSumOfAverages(int* nums, int numsSize, int k){\n    double* dp = (double*)malloc(sizeof(double) * numsSize);\n    double sum = 0;\n    for(int i = 0; i < numsSize; i++){\n        sum += nums[i];\n        dp[i] = sum / (i + 1);\n    }\n    for(int i = 1; i < k; i++){\n        for(int j = numsSize - 1; j >= i; j--){\n            sum = 0;\n            for(int l = j; l >= i; l--){\n                sum += nums[l];\n                dp[j] = fmax(dp[j], dp[l - 1] + sum / (j - l + 1));\n            }\n        }\n    }\n    return dp[numsSize - 1];\n\n}", "prefix": "double largestSumOfAverages(int* nums, int numsSize, int k"}
{"id": "967", "path": "output2\\c\\Medium\\967-binary-tree-pruning.c", "hypo_code": "struct TreeNode* pruneTree(struct TreeNode* root){\n    if(root == NULL){\n        return NULL;\n    }\n    root->left = pruneTree(root->left);\n    root->right = pruneTree(root->right);\n    if(root->val == 0 && root->left == NULL && root->right == NULL){\n        return NULL;\n    }\n    return root;\n\n}", "prefix": "struct TreeNode* pruneTree(struct TreeNode* root"}
{"id": "968", "path": "output2\\c\\Medium\\968-ambiguous-coordinates.c", "hypo_code": "char ** ambiguousCoordinates(char * s, int* returnSize){\n    char** result = (char**)malloc(sizeof(char*) * 10000);\n    *returnSize = 0;\n    int length = strlen(s);\n    for(int i = 2; i < length - 1; i++){\n        int leftSize = 0;\n        char** left = getValid(s, 1, i, &leftSize);\n        int rightSize = 0;\n        char** right = getValid(s, i, length - 1, &rightSize);\n        for(int j = 0; j < leftSize; j++){\n            for(int k = 0; k < rightSize; k++){\n                char* temp = (char*)malloc(sizeof(char) * 100);\n                sprintf(temp, \"(%s, %s)\", left[j], right[k]);\n                result[*returnSize] = temp;\n                (*returnSize)++;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "char ** ambiguousCoordinates(char * s, int* returnSize"}
{"id": "969", "path": "output2\\c\\Medium\\969-linked-list-components.c", "hypo_code": "int numComponents(struct ListNode* head, int* nums, int numsSize){\n    int* hash = (int*)malloc(sizeof(int) * 10000);\n    int count = 0;\n    for(int i = 0; i < numsSize; i++){\n        hash[nums[i]] = 1;\n    }\n    while(head != NULL){\n        if(hash[head->val] == 1 && (head->next == NULL || hash[head->next->val] == 0)){\n            count++;\n        }\n        head = head->next;\n    }\n    return count;\n\n}", "prefix": "int numComponents(struct ListNode* head, int* nums, int numsSize"}
{"id": "970", "path": "output2\\c\\Medium\\970-short-encoding-of-words.c", "hypo_code": "int minimumLengthEncoding(char ** words, int wordsSize){\n    int count = 0;\n    int length = strlen(s);\n    int* index = (int*)malloc(sizeof(int) * wordsSize);\n    for(int i = 0; i < wordsSize; i++){\n        index[i] = 0;\n    }\n    for(int i = 0; i < length; i++){\n        for(int j = 0; j < wordsSize; j++){\n            if(index[j] == -1){\n                continue;\n            }\n            if(s[i] == words[j][index[j]]){\n                index[j]++;\n            }\n            if(words[j][index[j]] == '\\0'){\n                count++;\n                index[j] = -1;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int minimumLengthEncoding(char ** words, int wordsSize"}
{"id": "971", "path": "output2\\c\\Medium\\971-card-flipping-game.c", "hypo_code": "int flipgame(int* fronts, int frontsSize, int* backs, int backsSize){\n    int* hash = (int*)malloc(sizeof(int) * 2001);\n    for(int i = 0; i < frontsSize; i++){\n        if(fronts[i] == backs[i]){\n            hash[fronts[i]] = 1;\n        }\n    }\n    for(int i = 0; i < frontsSize; i++){\n        if(hash[fronts[i]] == 0){\n            return fronts[i];\n        }\n        if(hash[backs[i]] == 0){\n            return backs[i];\n        }\n    }\n    return 0;\n\n}", "prefix": "int flipgame(int* fronts, int frontsSize, int* backs, int backsSize"}
{"id": "972", "path": "output2\\c\\Medium\\972-binary-trees-with-factors.c", "hypo_code": "int numFactoredBinaryTrees(int* arr, int arrSize){\n    int* dp = (int*)malloc(sizeof(int) * arrSize);\n    int* hash = (int*)malloc(sizeof(int) * 100000);\n    int result = 0;\n    int mod = 1000000007;\n    for(int i = 0; i < arrSize; i++){\n        dp[i] = 1;\n        hash[arr[i]] = i;\n    }\n    for(int i = 0; i < arrSize; i++){\n        for(int j = 0; j < i; j++){\n            if(arr[i] % arr[j] == 0){\n                int index = hash[arr[i] / arr[j]];\n                if(index != 0){\n                    dp[i] = (dp[i] + dp[j] * dp[index]) % mod;\n                }\n            }\n        }\n        result = (result + dp[i]) % mod;\n    }\n    return result;\n\n}", "prefix": "int numFactoredBinaryTrees(int* arr, int arrSize"}
{"id": "973", "path": "output2\\c\\Medium\\973-friends-of-appropriate-ages.c", "hypo_code": "int numFriendRequests(int* ages, int agesSize){\n    int* hash = (int*)malloc(sizeof(int) * 121);\n    for(int i = 0; i < agesSize; i++){\n        hash[ages[i]]++;\n    }\n    int count = 0;\n    for(int i = 0; i < agesSize; i++){\n        for(int j = 1; j <= 120; j++){\n            if(hash[j] == 0){\n                continue;\n            }\n            if(j <= 0.5 * ages[i] + 7){\n                continue;\n            }\n            if(j > ages[i]){\n                continue;\n            }\n            if(j > 100 && ages[i] < 100){\n                continue;\n            }\n            count += hash[j];\n            if(j == ages[i]){\n                count--;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int numFriendRequests(int* ages, int agesSize"}
{"id": "974", "path": "output2\\c\\Medium\\974-most-profit-assigning-work.c", "hypo_code": "int maxProfitAssignment(int* difficulty, int difficultySize, int* profit, int profitSize, int* worker, int workerSize){\n    int* hash = (int*)malloc(sizeof(int) * 100001);\n    for(int i = 0; i < difficultySize; i++){\n        hash[difficulty[i]] = fmax(hash[difficulty[i]], profit[i]);\n    }\n    for(int i = 1; i < 100001; i++){\n        hash[i] = fmax(hash[i], hash[i - 1]);\n    }\n    int max = 0;\n    for(int i = 0; i < workerSize; i++){\n        max += hash[worker[i]];\n    }\n    return max;\n\n\n}", "prefix": "int maxProfitAssignment(int* difficulty, int difficultySize, int* profit, int profitSize, int* worker, int workerSize"}
{"id": "975", "path": "output2\\c\\Medium\\975-masking-personal-information.c", "hypo_code": "char * maskPII(char * s){\n    int length = strlen(s);\n    char* result = (char*)malloc(sizeof(char) * 100);\n    if(strchr(s, '@') != NULL){\n        int i = 0;\n        while(s[i] != '@'){\n            if(s[i] >= 'A' && s[i] <= 'Z'){\n                s[i] = s[i] - 'A' + 'a';\n            }\n            i++;\n        }\n        int j = 0;\n        while(s[j] != '@'){\n            if(j == 0 || j == i - 1){\n                result[j] = s[j];\n            }\n            else{\n                result[j] = '*';\n            }\n            j++;\n        }\n        result[j++] = '@';\n        while(s[i] != '\\0'){\n            result[j++] = s[i++];\n        }\n        result[j] = '\\0';\n    }\n    else{\n        int i = 0;\n        int count = 0;\n        while(s[i] != '\\0'){\n            if(s[i] >= '0' && s[i] <= '9'){\n                count++;\n            }\n            i++;\n        }\n        int j = 0;\n        if(count == 10){\n            result[j++] = '*';\n            result[j++] = '*';\n            result[j++] = '*';\n            result[j++] = '-';\n            result[j++] = '*';\n            result[j++] = '*';\n            result[j++] = '*';\n            result[j++] = '-';\n            i = length - 1;\n            while(count > 0){\n                if(count == 4 || count == 7){\n                    result[j++] = '-';\n                }\n                else{\n                    result[j++] = s[i];\n                }\n                i--;\n                count--;\n            }\n            result[j] = '\\0';\n        }\n        else{\n            result[j++] = '+';\n            for(int k = 0; k < count - 10; k++){\n                result[j++] = '*';\n            }\n            result[j++] = '-';\n            result[j++] = '*';\n            result[j++] = '*';\n            result[j++] = '*';\n            result[j++] = '-';\n            result[j++] = '*';\n            result[j++] = '*';\n            result[j++] = '*';\n            result[j++] = '-';\n            i = length - 1;\n            while(count > 0){\n                if(count == 4 || count == 7){\n                    result[j++] = '-';\n                }\n                else{\n                    result[j++] = s[i];\n                }\n                i--;\n                count--;\n                \n\n}", "prefix": "char * maskPII(char * s"}
{"id": "976", "path": "output2\\c\\Medium\\976-find-and-replace-in-string.c", "hypo_code": "char * findReplaceString(char * s, int* indices, int indicesSize, char ** sources, int sourcesSize, char ** targets, int targetsSize){\n    int length = strlen(s);\n    int* index = (int*)malloc(sizeof(int) * indicesSize);\n    for(int i = 0; i < indicesSize; i++){\n        index[i] = 0;\n    }\n    for(int i = 0; i < length; i++){\n        for(int j = 0; j < indicesSize; j++){\n            if(index[j] == -1){\n                continue;\n            }\n            if(s[i] == sources[j][index[j]]){\n                index[j]++;\n            }\n            if(sources[j][index[j]] == '\\0'){\n                count++;\n                index[j] = -1;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "char * findReplaceString(char * s, int* indices, int indicesSize, char ** sources, int sourcesSize, char ** targets, int targetsSize"}
{"id": "977", "path": "output2\\c\\Medium\\977-image-overlap.c", "hypo_code": "int largestOverlap(int** img1, int img1Size, int* img1ColSize, int** img2, int img2Size, int* img2ColSize){\n    int n = img1Size;\n    int max = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            int count = 0;\n            for(int k = 0; k < n; k++){\n                for(int l = 0; l < n; l++){\n                    if(k + i < n && l + j < n && img1[k + i][l + j] == 1 && img2[k][l] == 1){\n                        count++;\n                    }\n                }\n            }\n            if(count > max){\n                max = count;\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            int count = 0;\n            for(int k = 0; k < n; k++){\n                for(int l = 0; l < n; l++){\n                    if(k + i < n && l + j < n && img1[k][l] == 1 && img2[k + i][l + j] == 1){\n                        count++;\n                    }\n                }\n            }\n            if(count > max){\n                max = count;\n            }\n        }\n    }\n    return max;\n\n}", "prefix": "int largestOverlap(int** img1, int img1Size, int* img1ColSize, int** img2, int img2Size, int* img2ColSize"}
{"id": "978", "path": "output2\\c\\Medium\\978-new-21-game.c", "hypo_code": "double new21Game(int n, int k, int maxPts){\n    if(k == 0 || n >= k + maxPts - 1){\n        return 1;\n    }\n    double dp[k + maxPts];\n    double sum = 1;\n    for(int i = 1; i <= maxPts; i++){\n        dp[i] = i <= n ? 1 : 0;\n        sum += dp[i];\n    }\n    for(int i = maxPts + 1; i <= k + maxPts - 1; i++){\n        dp[i] = sum / maxPts;\n        sum += dp[i] - dp[i - maxPts];\n    }\n    for(int i = k; i <= n; i++){\n        dp[i] = sum / maxPts;\n        sum -= dp[i];\n    }\n    return dp[n];\n\n}", "prefix": "double new21Game(int n, int k, int maxPts"}
{"id": "979", "path": "output2\\c\\Medium\\979-push-dominoes.c", "hypo_code": "char * pushDominoes(char * dominoes){\n    int len = strlen(dominoes);\n    int* hash = (int*)malloc(sizeof(int) * len);\n    int left = -1;\n    int right = -1;\n    for(int i = 0; i < len; i++){\n        if(dominoes[i] == 'L'){\n            left = i;\n        }\n        if(dominoes[i] == 'R'){\n            right = i;\n        }\n        if(left == -1 && right == -1){\n            hash[i] = 0;\n        }\n        else if(left == -1){\n            hash[i] = right;\n        }\n        else if(right == -1){\n            hash[i] = left;\n        }\n        else{\n            if(i - left < right - i){\n                hash[i] = left;\n            }\n            else if(i - left > right - i){\n                hash[i] = right;\n            }\n            else{\n                hash[i] = -1;\n            }\n        }\n    }\n    for(int i = 0; i < len; i++){\n        if(hash[i] == -1){\n            dominoes[i] = '.';\n        }\n        else if(hash[i] < i){\n            dominoes[i] = 'L';\n        }\n        else if(hash[i] > i){\n            dominoes[i] = 'R';\n        }\n    }\n    return dominoes;\n\n}", "prefix": "char * pushDominoes(char * dominoes"}
{"id": "980", "path": "output2\\c\\Medium\\980-magic-squares-in-grid.c", "hypo_code": "int numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\n    int count = 0;\n    for(int i = 0; i < gridSize - 2; i++){\n        for(int j = 0; j < gridColSize[0] - 2; j++){\n            if(grid[i + 1][j + 1] != 5){\n                continue;\n            }\n            if(grid[i][j] + grid[i][j + 1] + grid[i][j + 2] != 15){\n                continue;\n            }\n            if(grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] != 15){\n                continue;\n            }\n            if(grid[i][j] + grid[i + 1][j] + grid[i + 2][j] != 15){\n                continue;\n            }\n            if(grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] != 15){\n                continue;\n            }\n            if(grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] != 15){\n                continue;\n            }\n            if(grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] != 15){\n                continue;\n            }\n            int* hash = (int*)malloc(sizeof(int) * 10);\n            for(int k = 0; k < 10; k++){\n                hash[k] = 0;\n            }\n            for(int k = 0; k < 3; k++){\n                for(int l = 0; l < 3; l++){\n                    if(grid[i + k][j + l] < 1 || grid[i + k][j + l] > 9){\n                        continue;\n                    }\n                    hash[grid[i + k][j + l]]++;\n                }\n            }\n            int flag = 1;\n            for(int k = 1; k < 10; k++){\n                if(hash[k] != 1){\n                    flag = 0;\n                    break;\n                }\n            }\n            if(flag == 1){\n                count++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int numMagicSquaresInside(int** grid, int gridSize, int* gridColSize"}
{"id": "981", "path": "output2\\c\\Medium\\981-keys-and-rooms.c", "hypo_code": "bool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize){\n    int* visited = (int*)malloc(sizeof(int) * roomsSize);\n    for(int i = 0; i < roomsSize; i++){\n        visited[i] = 0;\n    }\n    visited[0] = 1;\n    int count = 1;\n    int* stack = (int*)malloc(sizeof(int) * roomsSize);\n    int top = 0;\n    stack[top++] = 0;\n    while(top != 0){\n        int room = stack[--top];\n        for(int i = 0; i < roomsColSize[room]; i++){\n            if(visited[rooms[room][i]] == 0){\n                visited[rooms[room][i]] = 1;\n                count++;\n                stack[top++] = rooms[room][i];\n            }\n        }\n    }\n    return count == roomsSize;\n\n}", "prefix": "bool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize"}
{"id": "982", "path": "output2\\c\\Medium\\982-split-array-into-fibonacci-sequence.c", "hypo_code": "int* splitIntoFibonacci(char * num, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 10000);\n    *returnSize = 0;\n    int length = strlen(num);\n    for(int i = 1; i < length - 1; i++){\n        for(int j = i + 1; j < length; j++){\n            int first = 0;\n            int second = 0;\n            int third = 0;\n            int firstLength = i;\n            int secondLength = j - i;\n            int thirdLength = length - j;\n            if(firstLength > 1 && num[0] == '0'){\n                break;\n            }\n            if(secondLength > 1 && num[i] == '0'){\n                break;\n            }\n            if(thirdLength > 1 && num[j] == '0'){\n                break;\n            }\n            if(firstLength > 10 || secondLength > 10 || thirdLength > 10){\n                break;\n            }\n            sscanf(num, \"%d%n\", &first, &firstLength);\n            sscanf(num + i, \"%d%n\", &second, &secondLength);\n            sscanf(num + j, \"%d%n\", &third, &thirdLength);\n            if(first + second == third){\n                result[*returnSize] = first;\n                (*returnSize)++;\n                result[*returnSize] = second;\n                (*returnSize)++;\n                result[*returnSize] = third;\n                (*returnSize)++;\n                if(j + thirdLength == length){\n                    return result;\n                }\n                int k = j + thirdLength;\n                while(k < length){\n                    int temp = first + second;\n                    int tempLength = 0;\n                    sscanf(num + k, \"%d%n\", &temp, &tempLength);\n                    if(temp != third){\n                        break;\n                    }\n                    first = second;\n                    second = third;\n                    third = temp;\n                    result[*returnSize] = third;\n                    (*returnSize)++;\n                    k += tempLength;\n                }\n                if(k == length){\n                    return result;\n                }\n                (*returnSize) -= 3;\n            }\n        }\n    }\n    *returnSize = 0;\n    return result;\n\n}", "prefix": "int* splitIntoFibonacci(char * num, int* returnSize"}
{"id": "983", "path": "output2\\c\\Medium\\983-longest-mountain-in-array.c", "hypo_code": "int longestMountain(int* arr, int arrSize){\n    int result = 0;\n    int count = 0;\n    int flag = 0;\n    for(int i = 1; i < arrSize; i++){\n        if(arr[i] > arr[i - 1]){\n            if(flag == 1){\n                count++;\n            }else{\n                count = 2;\n                flag = 1;\n            }\n        }else if(arr[i] < arr[i - 1]){\n            if(flag == 1){\n                count++;\n                result = result > count ? result : count;\n            }else if(flag == -1){\n                count = 2;\n            }\n            flag = -1;\n        }else{\n            count = 0;\n            flag = 0;\n        }\n    }\n    return result;\n\n}", "prefix": "int longestMountain(int* arr, int arrSize"}
{"id": "984", "path": "output2\\c\\Medium\\984-hand-of-straights.c", "hypo_code": "bool isNStraightHand(int* hand, int handSize, int groupSize){\n    if(handSize % groupSize != 0){\n        return false;\n    }\n    int* hash = (int*)malloc(sizeof(int) * 10001);\n    for(int i = 0; i < 10001; i++){\n        hash[i] = 0;\n    }\n    for(int i = 0; i < handSize; i++){\n        hash[hand[i]]++;\n    }\n    for(int i = 0; i < 10001; i++){\n        if(hash[i] != 0){\n            for(int j = 1; j < groupSize; j++){\n                if(hash[i + j] < hash[i]){\n                    return false;\n                }\n                hash[i + j] -= hash[i];\n            }\n        }\n    }\n    return true;\n\n}", "prefix": "bool isNStraightHand(int* hand, int handSize, int groupSize"}
{"id": "985", "path": "output2\\c\\Medium\\985-shifting-letters.c", "hypo_code": "char * shiftingLetters(char * s, int* shifts, int shiftsSize){\n    int length = strlen(s);\n    int* sum = (int*)malloc(sizeof(int) * length);\n    sum[length - 1] = shifts[length - 1];\n    for(int i = length - 2; i >= 0; i--){\n        sum[i] = sum[i + 1] + shifts[i];\n    }\n    for(int i = 0; i < length; i++){\n        s[i] = (s[i] - 'a' + sum[i]) % 26 + 'a';\n    }\n    return s;\n\n}", "prefix": "char * shiftingLetters(char * s, int* shifts, int shiftsSize"}
{"id": "986", "path": "output2\\c\\Medium\\986-maximize-distance-to-closest-person.c", "hypo_code": "int maxDistToClosest(int* seats, int seatsSize){\n    int* hash = (int*)malloc(sizeof(int) * seatsSize);\n    int count = 0;\n    int result = 0;\n    for(int i = 0; i < seatsSize; i++){\n        if(seats[i] == 1){\n            count = 0;\n        }else{\n            count++;\n            hash[i] = count;\n        }\n    }\n    count = 0;\n    for(int i = seatsSize - 1; i >= 0; i--){\n        if(seats[i] == 1){\n            count = 0;\n        }else{\n            count++;\n            if(hash[i] > count){\n                hash[i] = count;\n            }\n            result = result > hash[i] ? result : hash[i];\n        }\n    }\n    return result;\n\n}", "prefix": "int maxDistToClosest(int* seats, int seatsSize"}
{"id": "987", "path": "output2\\c\\Medium\\987-loud-and-rich.c", "hypo_code": "int* loudAndRich(int** richer, int richerSize, int* richerColSize, int* quiet, int quietSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * quietSize);\n    *returnSize = quietSize;\n    int* hash = (int*)malloc(sizeof(int) * quietSize);\n    for(int i = 0; i < quietSize; i++){\n        hash[i] = -1;\n    }\n    for(int i = 0; i < quietSize; i++){\n        result[i] = i;\n    }\n    for(int i = 0; i < richerSize; i++){\n        int x = richer[i][0];\n        int y = richer[i][1];\n        if(quiet[x] < quiet[result[y]]){\n            result[y] = x;\n        }\n        hash[y] = x;\n    }\n    for(int i = 0; i < quietSize; i++){\n        if(hash[i] == -1){\n            continue;\n        }\n        int x = i;\n        while(hash[x] != -1){\n            if(quiet[result[x]] < quiet[result[hash[x]]]){\n                result[hash[x]] = result[x];\n            }\n            x = hash[x];\n        }\n    }\n    return result;\n\n}", "prefix": "int* loudAndRich(int** richer, int richerSize, int* richerColSize, int* quiet, int quietSize, int* returnSize"}
{"id": "988", "path": "output2\\c\\Medium\\988-peak-index-in-a-mountain-array.c", "hypo_code": "int peakIndexInMountainArray(int* arr, int arrSize){\n    int left = 0;\n    int right = arrSize - 1;\n    int mid = 0;\n    while(left < right){\n        mid = (left + right) / 2;\n        if(arr[mid] < arr[mid + 1]){\n            left = mid + 1;\n        }else{\n            right = mid;\n        }\n    }\n    return left;\n\n}", "prefix": "int peakIndexInMountainArray(int* arr, int arrSize"}
{"id": "989", "path": "output2\\c\\Medium\\989-car-fleet.c", "hypo_code": "int carFleet(int target, int* position, int positionSize, int* speed, int speedSize){\n    int* hash = (int*)malloc(sizeof(int) * 10001);\n    for(int i = 0; i < positionSize; i++){\n        hash[position[i]] = speed[i];\n    }\n    int count = 0;\n    int max = 0;\n    for(int i = 10000; i >= 0; i--){\n        if(hash[i] == 0){\n            continue;\n        }\n        if((target - i) * 1.0 / hash[i] > max){\n            count++;\n            max = (target - i) * 1.0 / hash[i];\n        }\n    }\n    return count;\n\n}", "prefix": "int carFleet(int target, int* position, int positionSize, int* speed, int speedSize"}
{"id": "991", "path": "output2\\c\\Medium\\991-score-of-parentheses.c", "hypo_code": "int scoreOfParentheses(char * s){\n    int result = 0;\n    int count = 0;\n    for(int i = 0; i < strlen(s); i++){\n        if(s[i] == '('){\n            count++;\n        }else{\n            count--;\n            if(s[i - 1] == '('){\n                result += 1 << count;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int scoreOfParentheses(char * s"}
{"id": "992", "path": "output2\\c\\Medium\\992-mirror-reflection.c", "hypo_code": "int mirrorReflection(int p, int q){\n    int m = 1;\n    int n = 1;\n    while(m * p != n * q){\n        n++;\n        m = n * q / p;\n    }\n    if(m % 2 == 0){\n        return 2;\n    }else if(n % 2 == 0){\n        return 0;\n    }else{\n        return 1;\n    }\n\n}", "prefix": "int mirrorReflection(int p, int q"}
{"id": "993", "path": "output2\\c\\Medium\\993-score-after-flipping-matrix.c", "hypo_code": "int matrixScore(int** grid, int gridSize, int* gridColSize){\n    int m = gridSize;\n    int n = gridColSize[0];\n    int* row = (int*)malloc(sizeof(int) * m);\n    int* col = (int*)malloc(sizeof(int) * n);\n    for(int i = 0; i < m; i++){\n        row[i] = 0;\n    }\n    for(int i = 0; i < n; i++){\n        col[i] = 0;\n    }\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n            if(grid[i][j] == 1){\n                row[i]++;\n                col[j]++;\n            }\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < m; i++){\n        if(row[i] < n / 2){\n            count += n - row[i];\n        }\n        else{\n            count += row[i];\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(col[i] < m / 2){\n            count += m - col[i];\n        }\n        else{\n            count += col[i];\n        }\n    }\n    return count;\n\n}", "prefix": "int matrixScore(int** grid, int gridSize, int* gridColSize"}
{"id": "994", "path": "output2\\c\\Medium\\994-all-nodes-distance-k-in-binary-tree.c", "hypo_code": "int* distanceK(struct TreeNode* root, struct TreeNode* target, int k, int* returnSize) {\n    int* result = (int*)malloc(sizeof(int) * 10000);\n    *returnSize = 0;\n    if(root == NULL){\n        return result;\n    }\n    if(k == 0){\n        result[*returnSize] = target->val;\n        (*returnSize)++;\n        return result;\n    }\n    int* left = distanceK(root->left, target, k, returnSize);\n    int* right = distanceK(root->right, target, k, returnSize);\n    if(root == target){\n        for(int i = 0; i < *returnSize; i++){\n            result[i] = left[i];\n        }\n        for(int i = 0; i < *returnSize; i++){\n            result[i + *returnSize] = right[i];\n        }\n        *returnSize = *returnSize * 2;\n        return result;\n    }\n    for(int i = 0; i < *returnSize; i++){\n        result[i] = left[i];\n    }\n    for(int i = 0; i < *returnSize; i++){\n        result[i + *returnSize] = right[i];\n    }\n    *returnSize = *returnSize * 2;\n    return result;\n   \n}", "prefix": "int* distanceK(struct TreeNode* root, struct TreeNode* target, int k, int* returnSize"}
{"id": "995", "path": "output2\\c\\Medium\\995-smallest-subtree-with-all-the-deepest-nodes.c", "hypo_code": "struct TreeNode* subtreeWithAllDeepest(struct TreeNode* root){\n    if(root == NULL){\n        return NULL;\n    }\n    int left = 0;\n    int right = 0;\n    struct TreeNode* leftNode = root->left;\n    struct TreeNode* rightNode = root->right;\n    while(leftNode != NULL){\n        left++;\n        leftNode = leftNode->left;\n    }\n    while(rightNode != NULL){\n        right++;\n        rightNode = rightNode->right;\n    }\n    if(left == right){\n        return root;\n    }else if(left > right){\n        return subtreeWithAllDeepest(root->left);\n    }else{\n        return subtreeWithAllDeepest(root->right);\n    }\n\n}", "prefix": "struct TreeNode* subtreeWithAllDeepest(struct TreeNode* root"}
{"id": "996", "path": "output2\\c\\Medium\\996-prime-palindrome.c", "hypo_code": "int primePalindrome(int n){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int flag = 0;\n    int* prime = (int*)malloc(sizeof(int) * 10000000);\n    for(i = 0; i < 10000000; i++){\n        prime[i] = 1;\n    }\n    for(i = 2; i < 10000000; i++){\n        if(prime[i] == 1){\n            for(j = i * 2; j < 10000000; j += i){\n                prime[j] = 0;\n            }\n        }\n    }\n    for(i = n; i < 10000000; i++){\n        if(prime[i] == 1){\n            flag = 1;\n            k = i;\n            l = 0;\n            while(k > 0){\n                l = l * 10 + k % 10;\n                k = k / 10;\n            }\n            if(l == i){\n                return i;\n            }\n        }\n    }\n    return 0;\n\n}", "prefix": "int primePalindrome(int n"}
{"id": "997", "path": "output2\\c\\Medium\\997-reordered-power-of-2.c", "hypo_code": "bool reorderedPowerOf2(int n){\n    int* count = (int*)malloc(sizeof(int) * 10);\n    for(int i = 0; i < 10; i++){\n        count[i] = 0;\n    }\n    int temp = n;\n    while(temp > 0){\n        count[temp % 10]++;\n        temp /= 10;\n    }\n    for(int i = 0; i < 31; i++){\n        int* count2 = (int*)malloc(sizeof(int) * 10);\n        for(int i = 0; i < 10; i++){\n            count2[i] = 0;\n        }\n        temp = 1 << i;\n        while(temp > 0){\n            count2[temp % 10]++;\n            temp /= 10;\n        }\n        int flag = 1;\n        for(int i = 0; i < 10; i++){\n            if(count[i] != count2[i]){\n                flag = 0;\n                break;\n            }\n        }\n        if(flag == 1){\n            return true;\n        }\n    }\n    return false;\n\n}", "prefix": "bool reorderedPowerOf2(int n"}
{"id": "998", "path": "output2\\c\\Medium\\998-advantage-shuffle.c", "hypo_code": "int* advantageCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * nums1Size);\n    *returnSize = nums1Size;\n    int* hash = (int*)malloc(sizeof(int) * nums1Size);\n    for(int i = 0; i < nums1Size; i++){\n        hash[i] = -1;\n    }\n    for(int i = 0; i < nums1Size; i++){\n        int max = -1;\n        int maxIndex = -1;\n        for(int j = 0; j < nums1Size; j++){\n            if(nums1[j] > max && hash[j] == -1){\n                max = nums1[j];\n                maxIndex = j;\n            }\n        }\n        hash[maxIndex] = i;\n    }\n    for(int i = 0; i < nums1Size; i++){\n        int max = -1;\n        int maxIndex = -1;\n        for(int j = 0; j < nums1Size; j++){\n            if(nums1[j] > max && hash[j] == -1 && nums1[j] > nums2[i]){\n                max = nums1[j];\n                maxIndex = j;\n            }\n        }\n        if(maxIndex == -1){\n            for(int j = 0; j < nums1Size; j++){\n                if(nums1[j] > max && hash[j] == -1){\n                    max = nums1[j];\n                    maxIndex = j;\n                }\n            }\n        }\n        result[hash[maxIndex]] = nums1[maxIndex];\n        hash[maxIndex] = -1;\n    }\n    return result;\n\n}", "prefix": "int* advantageCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize"}
{"id": "999", "path": "output2\\c\\Medium\\999-length-of-longest-fibonacci-subsequence.c", "hypo_code": "int lenLongestFibSubseq(int* arr, int arrSize){\n    int result = 0;\n    int dp[arrSize][arrSize];\n    for(int i = 0; i < arrSize; i++){\n        for(int j = 0; j < arrSize; j++){\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 2; i < arrSize; i++){\n        int left = 0;\n        int right = i - 1;\n        while(left < right){\n            if(arr[left] + arr[right] == arr[i]){\n                dp[right][i] = dp[left][right] + 1;\n                result = result > dp[right][i] ? result : dp[right][i];\n                left++;\n                right--;\n            }else if(arr[left] + arr[right] < arr[i]){\n                left++;\n            }else{\n                right--;\n            }\n        }\n    }\n    return result == 0 ? 0 : result + 2;\n\n}", "prefix": "int lenLongestFibSubseq(int* arr, int arrSize"}
{"id": "1000", "path": "output2\\c\\Medium\\1000-walking-robot-simulation.c", "hypo_code": "int robotSim(int* commands, int commandsSize, int** obstacles, int obstaclesSize, int* obstaclesColSize){\n    int x = 0;\n    int y = 0;\n    int direction = 0;\n    int result = 0;\n    int hash[10001][10001];\n    for(int i = 0; i < 10001; i++){\n        for(int j = 0; j < 10001; j++){\n            hash[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < obstaclesSize; i++){\n        hash[obstacles[i][0] + 30000][obstacles[i][1] + 30000] = 1;\n    }\n    for(int i = 0; i < commandsSize; i++){\n        if(commands[i] == -2){\n            direction = (direction + 3) % 4;\n        }else if(commands[i] == -1){\n            direction = (direction + 1) % 4;\n        }else{\n            for(int j = 0; j < commands[i]; j++){\n                if(direction == 0){\n                    if(hash[x + 30000][y + 30001] == 1){\n                        break;\n                    }\n                    y++;\n                }else if(direction == 1){\n                    if(hash[x + 30001][y + 30000] == 1){\n                        break;\n                    }\n                    x++;\n                }else if(direction == 2){\n                    if(hash[x + 30000][y + 29999] == 1){\n                        break;\n                    }\n                    y--;\n                }else{\n                    if(hash[x + 29999][y + 30000] == 1){\n                        break;\n                    }\n                    x--;\n                }\n            }\n        }\n        result = result > x * x + y * y ? result : x * x + y * y;\n    }\n    return result;\n\n}", "prefix": "int robotSim(int* commands, int commandsSize, int** obstacles, int obstaclesSize, int* obstaclesColSize"}
{"id": "1001", "path": "output2\\c\\Medium\\1001-koko-eating-bananas.c", "hypo_code": "int minEatingSpeed(int* piles, int pilesSize, int h){\n    int left = 1;\n    int right = 1000000000;\n    while(left < right){\n        int mid = left + (right - left) / 2;\n        int count = 0;\n        for(int i = 0; i < pilesSize; i++){\n            count += piles[i] / mid;\n            if(piles[i] % mid != 0){\n                count++;\n            }\n        }\n        if(count > h){\n            left = mid + 1;\n        }else{\n            right = mid;\n        }\n    }\n    return left;\n\n}", "prefix": "int minEatingSpeed(int* piles, int pilesSize, int h"}
{"id": "1002", "path": "output2\\c\\Medium\\1002-stone-game.c", "hypo_code": "bool stoneGame(int* piles, int pilesSize){\n    int* dp = (int*)malloc(sizeof(int) * pilesSize);\n    for(int i = 0; i < pilesSize; i++){\n        dp[i] = piles[i];\n    }\n    for(int i = 1; i < pilesSize; i++){\n        for(int j = 0; j < pilesSize - i; j++){\n            dp[j] = fmax(piles[j] - dp[j + 1], piles[j + i] - dp[j]);\n        }\n    }\n    return dp[0] > 0;\n\n}", "prefix": "bool stoneGame(int* piles, int pilesSize"}
{"id": "1003", "path": "output2\\c\\Medium\\1003-decoded-string-at-index.c", "hypo_code": "char * decodeAtIndex(char * s, int k){\n    long long int length = 0;\n    int i = 0;\n    while(length < k){\n        if(s[i] >= '0' && s[i] <= '9'){\n            length *= s[i] - '0';\n        }else{\n            length++;\n        }\n        i++;\n    }\n    i--;\n    while(i >= 0){\n        if(s[i] >= '0' && s[i] <= '9'){\n            length /= s[i] - '0';\n            k %= length;\n        }else{\n            if(k == length || k == 0){\n                return s + i;\n            }\n            length--;\n        }\n        i--;\n    }\n    return s;\n\n}", "prefix": "char * decodeAtIndex(char * s, int k"}
{"id": "1004", "path": "output2\\c\\Medium\\1004-boats-to-save-people.c", "hypo_code": "int numRescueBoats(int* people, int peopleSize, int limit){\n    int* hash = (int*)malloc(sizeof(int) * peopleSize);\n    for(int i = 0; i < peopleSize; i++){\n        hash[i] = 0;\n    }\n    int result = 0;\n    for(int i = 0; i < peopleSize; i++){\n        if(hash[i] == 0){\n            int max = -1;\n            int maxIndex = -1;\n            for(int j = 0; j < peopleSize; j++){\n                if(hash[j] == 0 && people[j] > max && people[j] <= limit - people[i]){\n                    max = people[j];\n                    maxIndex = j;\n                }\n            }\n            if(maxIndex == -1){\n                result++;\n            }else{\n                hash[maxIndex] = 1;\n                hash[i] = 1;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int numRescueBoats(int* people, int peopleSize, int limit"}
{"id": "1005", "path": "output2\\c\\Medium\\1005-spiral-matrix-iii.c", "hypo_code": "int** spiralMatrixIII(int rows, int cols, \nint rStart, int cStart, int* returnSize, \nint** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * rows * cols);\n    *returnSize = rows * cols;\n    *returnColumnSizes = (int*)malloc(sizeof(int) * rows * cols);\n    for(int i = 0; i < rows * cols; i++){\n        (*returnColumnSizes)[i] = 2;\n    }\n    int* x = (int*)malloc(sizeof(int) * rows * cols);\n    int* y = (int*)malloc(sizeof(int) * rows * cols);\n    int index = 0;\n    int direction = 0;\n    int length = 1;\n    int count = 0;\n    while(index < rows * cols){\n        if(direction == 0){\n            for(int i = 0; i < length; i++){\n                if(rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols){\n                    x[index] = rStart;\n                    y[index] = cStart;\n                    index++;\n                }\n                cStart++;\n            }\n            direction = 1;\n            count++;\n            if(count == 2){\n                length++;\n                count = 0;\n            }\n        }\n        else if(direction == 1){\n            for(int i = 0; i < length; i++){\n                if(rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols){\n                    x[index] = rStart;\n                    y[index] = cStart;\n                    index++;\n                }\n                rStart++;\n            }\n            direction = 2;\n            count++;\n            if(count == 2){\n                length++;\n                count = 0;\n            }\n        }\n        else if(direction == 2){\n            for(int i = 0; i < length; i++){\n                if(rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols){\n                    x[index] = rStart;\n                    y[index] = cStart;\n                    index++;\n                }\n                cStart--;\n            }\n            direction = 3;\n            count++;\n            if(count == 2){\n                length++;\n                count = 0;\n            }\n        }\n        else if(direction == 3){\n            for(int i = 0; i < length; i++){\n                if(rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols){\n                    x[index] = rStart;\n                    y[index] = cStart;\n                    index++;\n                    \n\n}", "prefix": "int** spiralMatrixIII(int rows, int cols"}
{"id": "1006", "path": "output2\\c\\Medium\\1006-possible-bipartition.c", "hypo_code": "bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\n    int* hash = (int*)malloc(sizeof(int) * n);\n    for(int i = 0; i < n; i++){\n        hash[i] = -1;\n    }\n    for(int i = 0; i < dislikesSize; i++){\n        int x = dislikes[i][0] - 1;\n        int y = dislikes[i][1] - 1;\n        if(hash[x] == -1 && hash[y] == -1){\n            hash[x] = 0;\n            hash[y] = 1;\n        }else if(hash[x] == -1){\n            hash[x] = 1 - hash[y];\n        }else if(hash[y] == -1){\n            hash[y] = 1 - hash[x];\n        }else{\n            if(hash[x] == hash[y]){\n                return false;\n            }\n        }\n    }\n    return true;\n\n}", "prefix": "bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize"}
{"id": "1007", "path": "output2\\c\\Medium\\1007-construct-binary-tree-from-preorder-and-postorder-traversal.c", "hypo_code": "struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\n    if(preorderSize == 0){\n        return NULL;\n    }\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = preorder[0];\n    root->left = NULL;\n    root->right = NULL;\n    if(preorderSize == 1){\n        return root;\n    }\n    int i = 0;\n    for(i = 0; i < postorderSize; i++){\n        if(postorder[i] == preorder[1]){\n            break;\n        }\n    }\n    root->left = constructFromPrePost(preorder + 1, i + 1, postorder, i + 1);\n    root->right = constructFromPrePost(preorder + i + 2, preorderSize - i - 2, postorder + i + 1, postorderSize - i - 2);\n    return root;\n\n}", "prefix": "struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize"}
{"id": "1008", "path": "output2\\c\\Medium\\1008-find-and-replace-pattern.c", "hypo_code": "char ** findAndReplacePattern(char ** words, int wordsSize, char * pattern, int* returnSize){\n    int* patternHash = (int*)malloc(sizeof(int) * 26);\n    for(int i = 0; i < 26; i++){\n        patternHash[i] = -1;\n    }\n    for(int i = 0; i < strlen(pattern); i++){\n        patternHash[pattern[i] - 'a'] = i;\n    }\n    char** result = (char**)malloc(sizeof(char*) * wordsSize);\n    *returnSize = 0;\n    for(int i = 0; i < wordsSize; i++){\n        int* wordHash = (int*)malloc(sizeof(int) * 26);\n        for(int i = 0; i < 26; i++){\n            wordHash[i] = -1;\n        }\n        for(int j = 0; j < strlen(words[i]); j++){\n            wordHash[words[i][j] - 'a'] = j;\n        }\n        int match = 1;\n        for(int j = 0; j < 26; j++){\n            if(patternHash[j] != -1 && wordHash[j] != -1 && patternHash[j] != wordHash[j]){\n                match = 0;\n                break;\n            }\n        }\n        if(match == 1){\n            result[*returnSize] = words[i];\n            (*returnSize)++;\n        }\n    }\n    return result;\n\n}", "prefix": "char ** findAndReplacePattern(char ** words, int wordsSize, char * pattern, int* returnSize"}
{"id": "1009", "path": "output2\\c\\Medium\\1009-groups-of-special-equivalent-strings.c", "hypo_code": "int numSpecialEquivGroups(char ** words, int wordsSize){\n    int* hash = (int*)malloc(sizeof(int) * 52);\n    for(int i = 0; i < 52; i++){\n        hash[i] = 0;\n    }\n    for(int i = 0; i < wordsSize; i++){\n        for(int j = 0; j < strlen(words[i]); j++){\n            if(j % 2 == 0){\n                hash[words[i][j] - 'a']++;\n            }\n            else{\n                hash[words[i][j] - 'a' + 26]++;\n            }\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < 52; i++){\n        if(hash[i] != 0){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int numSpecialEquivGroups(char ** words, int wordsSize"}
{"id": "1010", "path": "output2\\c\\Medium\\1010-all-possible-full-binary-trees.c", "hypo_code": "struct TreeNode** allPossibleFBT(int n, int* returnSize){\n    struct TreeNode** result = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);\n    *returnSize = 0;\n    if(n == 1){\n        struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        node->val = 0;\n        node->left = NULL;\n        node->right = NULL;\n        result[*returnSize] = node;\n        (*returnSize)++;\n        return result;\n    }\n    for(int i = 1; i < n; i += 2){\n        int leftSize = 0;\n        int rightSize = 0;\n        struct TreeNode** left = allPossibleFBT(i, &leftSize);\n        struct TreeNode** right = allPossibleFBT(n - i - 1, &rightSize);\n        for(int j = 0; j < leftSize; j++){\n            for(int k = 0; k < rightSize; k++){\n                struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n                node->val = 0;\n                node->left = left[j];\n                node->right = right[k];\n                result[*returnSize] = node;\n                (*returnSize)++;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "struct TreeNode** allPossibleFBT(int n, int* returnSize"}
{"id": "1011", "path": "output2\\c\\Medium\\1011-bitwise-ors-of-subarrays.c", "hypo_code": "int subarrayBitwiseORs(int* arr, int arrSize){\n    int* hash = (int*)malloc(sizeof(int) * 100000);\n    for(int i = 0; i < 100000; i++){\n        hash[i] = 0;\n    }\n    int result = 0;\n    for(int i = 0; i < arrSize; i++){\n        int temp = arr[i];\n        for(int j = i; j < arrSize; j++){\n            temp = temp | arr[j];\n            if(hash[temp] == 0){\n                hash[temp] = 1;\n                result++;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int subarrayBitwiseORs(int* arr, int arrSize"}
{"id": "1014", "path": "output2\\c\\Medium\\1014-fruit-into-baskets.c", "hypo_code": "int totalFruit(int* fruits, int fruitsSize){\n    int* hash = (int*)malloc(sizeof(int) * 10001);\n    for(int i = 0; i < 10001; i++){\n        hash[i] = 0;\n    }\n    int result = 0;\n    int left = 0;\n    int right = 0;\n    int count = 0;\n    while(right < fruitsSize){\n        if(hash[fruits[right]] == 0){\n            count++;\n        }\n        hash[fruits[right]]++;\n        right++;\n        while(count > 2){\n            hash[fruits[left]]--;\n            if(hash[fruits[left]] == 0){\n                count--;\n            }\n            left++;\n        }\n        result = result > right - left ? result : right - left;\n    }\n    return result;\n\n}", "prefix": "int totalFruit(int* fruits, int fruitsSize"}
{"id": "1015", "path": "output2\\c\\Medium\\1015-sum-of-subarray-minimums.c", "hypo_code": "int sumSubarrayMins(int* arr, int arrSize){\n    int result = 0;\n    int dp[arrSize][arrSize];\n    for(int i = 0; i < arrSize; i++){\n        for(int j = 0; j < arrSize; j++){\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < arrSize; i++){\n        dp[i][i] = arr[i];\n        result = result + arr[i];\n    }\n    for(int i = 1; i < arrSize; i++){\n        for(int j = 0; j < arrSize - i; j++){\n            dp[j][j + i] = dp[j][j + i - 1] < arr[j + i] ? dp[j][j + i - 1] : arr[j + i];\n            result = result + dp[j][j + i];\n        }\n    }\n    return result;\n\n}", "prefix": "int sumSubarrayMins(int* arr, int arrSize"}
{"id": "1016", "path": "output2\\c\\Medium\\1016-snakes-and-ladders.c", "hypo_code": "int snakesAndLadders(int** board, int boardSize, int* boardColSize){\n    int n = boardSize;\n    int* arr = (int*)malloc(sizeof(int) * n * n);\n    int index = 0;\n    for(int i = n - 1; i >= 0; i--){\n        if(i % 2 == 0){\n            for(int j = 0; j < n; j++){\n                arr[index++] = board[i][j];\n            }\n        }\n        else{\n            for(int j = n - 1; j >= 0; j--){\n                arr[index++] = board[i][j];\n            }\n        }\n    }\n    int* dp = (int*)malloc(sizeof(int) * n * n);\n    for(int i = 0; i < n * n; i++){\n        dp[i] = -1;\n    }\n    dp[0] = 0;\n    for(int i = 0; i < n * n; i++){\n        if(dp[i] == -1){\n            continue;\n        }\n        for(int j = 1; j <= 6; j++){\n            if(i + j >= n * n){\n                break;\n            }\n            if(arr[i + j] == -1){\n                if(dp[i + j] == -1 || dp[i + j] > dp[i] + 1){\n                    dp[i + j] = dp[i] + 1;\n                }\n            }\n            else{\n                if(dp[arr[i + j] - 1] == -1 || dp[arr[i + j] - 1] > dp[i] + 1){\n                    dp[arr[i + j] - 1] = dp[i] + 1;\n                }\n            }\n        }\n    }\n    return dp[n * n - 1];\n\n}", "prefix": "int snakesAndLadders(int** board, int boardSize, int* boardColSize"}
{"id": "1017", "path": "output2\\c\\Medium\\1017-smallest-range-ii.c", "hypo_code": "int smallestRangeII(int* nums, int numsSize, int k){\n    int result = 0;\n    int dp[numsSize];\n    for(int i = 0; i < numsSize; i++){\n        dp[i] = 0;\n    }\n    for(int i = 1; i < numsSize; i++){\n        for(int j = 0; j < i; j++){\n            if(nums[i] == nums[j] * nums[j]){\n                dp[i] = dp[j] + 1;\n                result = result > dp[i] ? result : dp[i];\n            }\n        }\n    }\n    return result == 0 ? -1 : result + 1;\n\n}", "prefix": "int smallestRangeII(int* nums, int numsSize, int k"}
{"id": "1019", "path": "output2\\c\\Medium\\1019-sort-an-array.c", "hypo_code": "int* sortArray(int* nums, int numsSize, int* returnSize){\n    *returnSize = numsSize;\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    for(int i = 0; i < numsSize; i++){\n        result[i] = nums[i];\n    }\n    quickSort(result, 0, numsSize - 1);\n    return result;\n\n}", "prefix": "int* sortArray(int* nums, int numsSize, int* returnSize"}
{"id": "1020", "path": "output2\\c\\Medium\\1020-partition-array-into-disjoint-intervals.c", "hypo_code": "int partitionDisjoint(int* nums, int numsSize){\n    int* maxLeft = (int*)malloc(sizeof(int) * numsSize);\n    int* minRight = (int*)malloc(sizeof(int) * numsSize);\n    maxLeft[0] = nums[0];\n    for(int i = 1; i < numsSize; i++){\n        if(nums[i] > maxLeft[i - 1]){\n            maxLeft[i] = nums[i];\n        }else{\n            maxLeft[i] = maxLeft[i - 1];\n        }\n    }\n    minRight[numsSize - 1] = nums[numsSize - 1];\n    for(int i = numsSize - 2; i >= 0; i--){\n        if(nums[i] < minRight[i + 1]){\n            minRight[i] = nums[i];\n        }else{\n            minRight[i] = minRight[i + 1];\n        }\n    }\n    for(int i = 0; i < numsSize - 1; i++){\n        if(maxLeft[i] <= minRight[i + 1]){\n            return i + 1;\n        }\n    }\n    return 0;\n\n}", "prefix": "int partitionDisjoint(int* nums, int numsSize"}
{"id": "1021", "path": "output2\\c\\Medium\\1021-word-subsets.c", "hypo_code": "char ** wordSubsets(char ** words1, int words1Size, char ** words2, int words2Size, int* returnSize){\n    int* count = (int*)malloc(sizeof(int) * 26);\n    for(int i = 0; i < 26; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < words2Size; i++){\n        int* temp = (int*)malloc(sizeof(int) * 26);\n        for(int j = 0; j < 26; j++){\n            temp[j] = 0;\n        }\n        int length = strlen(words2[i]);\n        for(int j = 0; j < length; j++){\n            temp[words2[i][j] - 'a']++;\n        }\n        for(int j = 0; j < 26; j++){\n            if(temp[j] > count[j]){\n                count[j] = temp[j];\n            }\n        }\n    }\n    char** result = (char**)malloc(sizeof(char*) * 10001);\n    for(int i = 0; i < 10001; i++){\n        result[i] = (char*)malloc(sizeof(char) * 11);\n    }\n    *returnSize = 0;\n    for(int i = 0; i < words1Size; i++){\n        int* temp = (int*)malloc(sizeof(int) * 26);\n        for(int j = 0; j < 26; j++){\n            temp[j] = 0;\n        }\n        int length = strlen(words1[i]);\n        for(int j = 0; j < length; j++){\n            temp[words1[i][j] - 'a']++;\n        }\n        int j = 0;\n        for(j = 0; j < 26; j++){\n            if(temp[j] < count[j]){\n                break;\n            }\n        }\n        if(j == 26){\n            strcpy(result[*returnSize], words1[i]);\n            (*returnSize)++;\n        }\n    }\n    return result;\n\n}", "prefix": "char ** wordSubsets(char ** words1, int words1Size, char ** words2, int words2Size, int* returnSize"}
{"id": "1022", "path": "output2\\c\\Medium\\1022-maximum-sum-circular-subarray.c", "hypo_code": "int maxSubarraySumCircular(int* nums, int numsSize){\n    int max = nums[0];\n    int min = nums[0];\n    int sum = nums[0];\n    int maxSum = nums[0];\n    int minSum = nums[0];\n    for(int i = 1; i < numsSize; i++){\n        sum += nums[i];\n        if(max + nums[i] > nums[i]){\n            max += nums[i];\n        }else{\n            max = nums[i];\n        }\n        if(max > maxSum){\n            maxSum = max;\n        }\n        if(min + nums[i] < nums[i]){\n            min += nums[i];\n        }else{\n            min = nums[i];\n        }\n        if(min < minSum){\n            minSum = min;\n        }\n    }\n    if(maxSum > 0){\n        return sum - minSum > maxSum ? sum - minSum : maxSum;\n    }else{\n        return maxSum;\n    }\n\n}", "prefix": "int maxSubarraySumCircular(int* nums, int numsSize"}
{"id": "1024", "path": "output2\\c\\Medium\\1024-minimum-add-to-make-parentheses-valid.c", "hypo_code": "int minAddToMakeValid(char * s){\n    int left = 0;\n    int right = 0;\n    for(int i = 0; s[i] != '\\0'; i++){\n        if(s[i] == '('){\n            left++;\n        }else{\n            if(left > 0){\n                left--;\n            }else{\n                right++;\n            }\n        }\n    }\n    return left + right;\n\n}", "prefix": "int minAddToMakeValid(char * s"}
{"id": "1025", "path": "output2\\c\\Medium\\1025-3sum-with-multiplicity.c", "hypo_code": "int threeSumMulti(int* arr, int arrSize, int target){\n    int mod = 1000000007;\n    int* count = (int*)malloc(sizeof(int) * 101);\n    for(int i = 0; i < arrSize; i++){\n        count[arr[i]]++;\n    }\n    long long res = 0;\n    for(int i = 0; i <= 100; i++){\n        for(int j = i; j <= 100; j++){\n            int k = target - i - j;\n            if(k < 0 || k > 100){\n                continue;\n            }\n            if(i == j && j == k){\n                res += (long long)count[i] * (count[i] - 1) * (count[i] - 2) / 6;\n            }else if(i == j && j != k){\n                res += (long long)count[i] * (count[i] - 1) / 2 * count[k];\n            }else if(i < j && j < k){\n                res += (long long)count[i] * count[j] * count[k];\n            }\n        }\n    }\n    return res % mod;\n\n}", "prefix": "int threeSumMulti(int* arr, int arrSize, int target"}
{"id": "1026", "path": "output2\\c\\Medium\\1026-flip-string-to-monotone-increasing.c", "hypo_code": "int minFlipsMonoIncr(char * s){\n    int flip = 0;\n    int one = 0;\n    for(int i = 0; s[i] != '\\0'; i++){\n        if(s[i] == '1'){\n            one++;\n        }else{\n            flip++;\n        }\n        if(flip > one){\n            flip = one;\n        }\n    }\n    return flip;\n\n}", "prefix": "int minFlipsMonoIncr(char * s"}
{"id": "1027", "path": "output2\\c\\Medium\\1027-binary-subarrays-with-sum.c", "hypo_code": "int numSubarraysWithSum(int* nums, int numsSize, int goal){\n    int* sum = (int*)malloc(sizeof(int) * (numsSize + 1));\n    sum[0] = 0;\n    for(int i = 1; i <= numsSize; i++){\n        sum[i] = sum[i - 1] + nums[i - 1];\n    }\n    int count = 0;\n    for(int i = 0; i < numsSize; i++){\n        for(int j = i + 1; j <= numsSize; j++){\n            if(sum[j] - sum[i] == goal){\n                count++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int numSubarraysWithSum(int* nums, int numsSize, int goal"}
{"id": "1028", "path": "output2\\c\\Medium\\1028-minimum-falling-path-sum.c", "hypo_code": "int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize){\n    int** dp = (int**)malloc(sizeof(int*) * matrixSize);\n    for(int i = 0; i < matrixSize; i++){\n        dp[i] = (int*)malloc(sizeof(int) * matrixColSize[i]);\n    }\n    for(int i = 0; i < matrixColSize[0]; i++){\n        dp[0][i] = matrix[0][i];\n    }\n    for(int i = 1; i < matrixSize; i++){\n        for(int j = 0; j < matrixColSize[i]; j++){\n            int min = dp[i - 1][j];\n            if(j > 0 && dp[i - 1][j - 1] < min){\n                min = dp[i - 1][j - 1];\n            }\n            if(j < matrixColSize[i] - 1 && dp[i - 1][j + 1] < min){\n                min = dp[i - 1][j + 1];\n            }\n            dp[i][j] = min + matrix[i][j];\n        }\n    }\n    int min = dp[matrixSize - 1][0];\n    for(int i = 1; i < matrixColSize[matrixSize - 1]; i++){\n        if(dp[matrixSize - 1][i] < min){\n            min = dp[matrixSize - 1][i];\n        }\n    }\n    return min;\n\n}", "prefix": "int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "1029", "path": "output2\\c\\Medium\\1029-beautiful-array.c", "hypo_code": "int* beautifulArray(int n, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * n);\n    *returnSize = n;\n    result[0] = 1;\n    int length = 1;\n    while(length < n){\n        int* temp = (int*)malloc(sizeof(int) * n);\n        int index = 0;\n        for(int i = 0; i < length; i++){\n            if(result[i] * 2 - 1 <= n){\n                temp[index] = result[i] * 2 - 1;\n                index++;\n            }\n        }\n        for(int i = 0; i < length; i++){\n            if(result[i] * 2 <= n){\n                temp[index] = result[i] * 2;\n                index++;\n            }\n        }\n        free(result);\n        result = temp;\n        length = index;\n    }\n    return result;\n\n}", "prefix": "int* beautifulArray(int n, int* returnSize"}
{"id": "1030", "path": "output2\\c\\Medium\\1030-shortest-bridge.c", "hypo_code": "int shortestBridge(int** grid, int gridSize, int* gridColSize){\n    int* queue = (int*)malloc(sizeof(int) * gridSize * gridSize * 2);\n    int queueSize = 0;\n    int* visited = (int*)malloc(sizeof(int) * gridSize * gridSize);\n    for(int i = 0; i < gridSize * gridSize; i++){\n        visited[i] = 0;\n    }\n    int* direction = (int*)malloc(sizeof(int) * 4);\n    direction[0] = 1;\n    direction[1] = -1;\n    direction[2] = gridSize;\n    direction[3] = -gridSize;\n    int result = 0;\n    int found = 0;\n    for(int i = 0; i < gridSize; i++){\n        for(int j = 0; j < gridSize; j++){\n            if(grid[i][j] == 1){\n                queue[queueSize] = i * gridSize + j;\n                queueSize++;\n                visited[i * gridSize + j] = 1;\n                found = 1;\n                break;\n            }\n        }\n        if(found == 1){\n            break;\n        }\n    }\n    while(queueSize != 0){\n        int* temp = (int*)malloc(sizeof(int) * queueSize * 2);\n        int tempSize = 0;\n        for(int i = 0; i < queueSize; i++){\n            int x = queue[i] / gridSize;\n            int y = queue[i] % gridSize;\n            for(int j = 0; j < 4; j++){\n                int newX = x + direction[j];\n                int newY = y + direction[j ^ 1];\n                if(newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && visited[newX * gridSize + newY] == 0){\n                    if(grid[newX][newY] == 1){\n                        return result;\n                    }else{\n                        temp[tempSize] = newX * gridSize + newY;\n                        tempSize++;\n                        visited[newX * gridSize + newY] = 1;\n                    }\n                }\n            }\n        }\n        free(queue);\n        queue = temp;\n        queueSize = tempSize;\n        result++;\n    }\n    return result;\n\n}", "prefix": "int shortestBridge(int** grid, int gridSize, int* gridColSize"}
{"id": "1031", "path": "output2\\c\\Medium\\1031-knight-dialer.c", "hypo_code": "int knightDialer(int n){\nint MOD = 1000000007;\n    int dp[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    for (; n > 1; n--) {\n        int dp2[10] = {0};\n        dp2[0] = (dp[4] + dp[6]) % MOD;\n        dp2[1] = (dp[6] + dp[8]) % MOD;\n        dp2[2] = (dp[7] + dp[9]) % MOD;\n        dp2[3] = (dp[4] + dp[8]) % MOD;\n        dp2[4] = ((dp[0] + dp[3]) % MOD + dp[9]) % MOD;\n        dp2[6] = ((dp[0] + dp[1]) % MOD + dp[7]) % MOD;\n        dp2[7] = (dp[2] + dp[6]) % MOD;\n        dp2[8] = (dp[1] + dp[3]) % MOD;\n        dp2[9] = (dp[2] + dp[4]) % MOD;\n        memcpy(dp, dp2, sizeof(dp));\n    }\n    int sum = 0;\n    for (int i = 0; i < 10; i++) {\n        sum = (sum + dp[i]) % MOD;\n    }\n    return sum;\n}", "prefix": "int knightDialer(int n"}
{"id": "1032", "path": "output2\\c\\Medium\\1032-reorder-data-in-log-files.c", "hypo_code": "char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){\n    char** result = (char**)malloc(sizeof(char*) * logsSize);\n    for(int i = 0; i < logsSize; i++){\n        result[i] = (char*)malloc(sizeof(char) * 100);\n    }\n    *returnSize = logsSize;\n    int index = 0;\n    for(int i = 0; i < logsSize; i++){\n        int length = strlen(logs[i]);\n        int j = 0;\n        for(j = 0; j < length; j++){\n            if(logs[i][j] == ' '){\n                break;\n            }\n        }\n        if(logs[i][j + 1] >= '0' && logs[i][j + 1] <= '9'){\n            strcpy(result[index], logs[i]);\n            index++;\n        }\n    }\n    for(int i = 0; i < logsSize; i++){\n        int length = strlen(logs[i]);\n        int j = 0;\n        for(j = 0; j < length; j++){\n            if(logs[i][j] == ' '){\n                break;\n            }\n        }\n        if(logs[i][j + 1] >= 'a' && logs[i][j + 1] <= 'z'){\n            strcpy(result[index], logs[i]);\n            index++;\n        }\n    }\n    for(int i = 0; i < logsSize; i++){\n        int length = strlen(result[i]);\n        int j = 0;\n        for(j = 0; j < length; j++){\n            if(result[i][j] == ' '){\n                break;\n            }\n        }\n        int k = j + 1;\n        for(k = j + 1; k < length; k++){\n            if(result[i][k] == ' '){\n                break;\n            }\n        }\n        int l = k + 1;\n        for(l = k + 1; l < length; l++){\n            if(result[i][l] == ' '){\n                break;\n            }\n        }\n        int m = l + 1;\n        for(m = l + 1; m < length; m++){\n            if(result[i][m] == ' '){\n                break;\n            }\n        }\n        int n = m + 1;\n        for(n = m + 1; n < length; n++){\n            if(result[i][n] == ' '){\n                break;\n            }\n            \n\n}", "prefix": "char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize"}
{"id": "1033", "path": "output2\\c\\Medium\\1033-minimum-area-rectangle.c", "hypo_code": "int minAreaRect(int** points, int pointsSize, int* pointsColSize){\n    int result = 0;\n    for(int i = 0; i < pointsSize; i++){\n        for(int j = i + 1; j < pointsSize; j++){\n            if(points[i][0] == points[j][0] || points[i][1] == points[j][1]){\n                continue;\n            }\n            int x1 = points[i][0];\n            int y1 = points[i][1];\n            int x2 = points[j][0];\n            int y2 = points[j][1];\n            int x3 = x1;\n            int y3 = y2;\n            int x4 = x2;\n            int y4 = y1;\n            int found = 0;\n            for(int k = 0; k < pointsSize; k++){\n                if(points[k][0] == x3 && points[k][1] == y3){\n                    found++;\n                }\n                if(points[k][0] == x4 && points[k][1] == y4){\n                    found++;\n                }\n            }\n            if(found == 2){\n                int area = abs(x1 - x2) * abs(y1 - y2);\n                if(result == 0 || area < result){\n                    result = area;\n                }\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int minAreaRect(int** points, int pointsSize, int* pointsColSize"}
{"id": "1034", "path": "output2\\c\\Medium\\1034-minimum-increment-to-make-array-unique.c", "hypo_code": "int minIncrementForUnique(int* nums, int numsSize){\n    int* count = (int*)calloc(40000, sizeof(int));\n    for(int i = 0; i < numsSize; i++){\n        count[nums[i]]++;\n    }\n    int result = 0;\n    int taken = 0;\n    for(int i = 0; i < 40000; i++){\n        if(count[i] >= 2){\n            taken += count[i] - 1;\n            result -= i * (count[i] - 1);\n        }else if(taken > 0 && count[i] == 0){\n            taken--;\n            result += i;\n        }\n    }\n    return result;\n\n}", "prefix": "int minIncrementForUnique(int* nums, int numsSize"}
{"id": "1035", "path": "output2\\c\\Medium\\1035-validate-stack-sequences.c", "hypo_code": "bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){\n    int* stack = (int*)malloc(sizeof(int) * pushedSize);\n    int top = -1;\n    int index = 0;\n    for(int i = 0; i < pushedSize; i++){\n        stack[++top] = pushed[i];\n        while(top >= 0 && stack[top] == popped[index]){\n            top--;\n            index++;\n        }\n    }\n    return top == -1;\n\n}", "prefix": "bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize"}
{"id": "1036", "path": "output2\\c\\Medium\\1036-most-stones-removed-with-same-row-or-column.c", "hypo_code": "int removeStones(int** stones, int stonesSize, int* stonesColSize){\n    int* visited = (int*)malloc(sizeof(int) * stonesSize);\n    for(int i = 0; i < stonesSize; i++){\n        visited[i] = 0;\n    }\n    int count = 0;\n    for(int i = 0; i < stonesSize; i++){\n        if(visited[i] == 0){\n            count++;\n            dfs(stones, stonesSize, stonesColSize, visited, i);\n        }\n    }\n    return stonesSize - count;\n\n}", "prefix": "int removeStones(int** stones, int stonesSize, int* stonesColSize"}
{"id": "1037", "path": "output2\\c\\Medium\\1037-bag-of-tokens.c", "hypo_code": "int bagOfTokensScore(int* tokens, int tokensSize, int power){\n    int* hash = (int*)malloc(sizeof(int) * tokensSize);\n    for(int i = 0; i < tokensSize; i++){\n        hash[i] = 0;\n    }\n    int score = 0;\n    int maxScore = 0;\n    for(int i = 0; i < tokensSize; i++){\n        if(hash[i] == 0 && power >= tokens[i]){\n            hash[i] = 1;\n            power -= tokens[i];\n            score++;\n            if(score > maxScore){\n                maxScore = score;\n            }\n        }\n    }\n    for(int i = 0; i < tokensSize; i++){\n        if(hash[i] == 0 && score > 0){\n            hash[i] = 1;\n            power += tokens[i];\n            score--;\n        }\n    }\n    return maxScore;\n\n}", "prefix": "int bagOfTokensScore(int* tokens, int tokensSize, int power"}
{"id": "1038", "path": "output2\\c\\Medium\\1038-largest-time-for-given-digits.c", "hypo_code": "char * largestTimeFromDigits(int* arr, int arrSize){\n    int max = -1;\n    int hour = 0;\n    int minute = 0;\n    for(int i = 0; i < arrSize; i++){\n        for(int j = 0; j < arrSize; j++){\n            if(j == i){\n                continue;\n            }\n            for(int k = 0; k < arrSize; k++){\n                if(k == i || k == j){\n                    continue;\n                }\n                int l = 6 - i - j - k;\n                int h = arr[i] * 10 + arr[j];\n                int m = arr[k] * 10 + arr[l];\n                if(h < 24 && m < 60 && h * 60 + m > max){\n                    max = h * 60 + m;\n                    hour = h;\n                    minute = m;\n                }\n            }\n        }\n    }\n    if(max == -1){\n        return \"\";\n    }\n    char* result = (char*)malloc(sizeof(char) * 6);\n    sprintf(result, \"%02d:%02d\", hour, minute);\n    return result;\n\n}", "prefix": "char * largestTimeFromDigits(int* arr, int arrSize"}
{"id": "1039", "path": "output2\\c\\Medium\\1039-reveal-cards-in-increasing-order.c", "hypo_code": "int* deckRevealedIncreasing(int* deck, int deckSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * deckSize);\n    *returnSize = deckSize;\n    int* temp = (int*)malloc(sizeof(int) * deckSize);\n    for(int i = 0; i < deckSize; i++){\n        temp[i] = i;\n    }\n    qsort(temp, deckSize, sizeof(int), cmp);\n    int* index = (int*)malloc(sizeof(int) * deckSize);\n    for(int i = 0; i < deckSize; i++){\n        index[i] = i;\n    }\n    int length = deckSize;\n    int indexLength = deckSize;\n    int indexIndex = 0;\n    while(length > 0){\n        result[index[indexIndex]] = deck[temp[deckSize - length]];\n        indexIndex++;\n        if(indexIndex == indexLength){\n            indexIndex = 0;\n        }\n        index[indexIndex] = index[indexIndex + 1];\n        indexIndex++;\n        if(indexIndex == indexLength){\n            indexIndex = 0;\n        }\n        indexLength--;\n        length--;\n    }\n    free(temp);\n    free(index);\n    return result;\n\n}", "prefix": "int* deckRevealedIncreasing(int* deck, int deckSize, int* returnSize"}
{"id": "1040", "path": "output2\\c\\Medium\\1040-flip-equivalent-binary-trees.c", "hypo_code": "bool flipEquiv(struct TreeNode* root1, struct TreeNode* root2){\n    if(root1 == NULL && root2 == NULL){\n        return true;\n    }\n    if(root1 == NULL || root2 == NULL){\n        return false;\n    }\n    if(root1->val != root2->val){\n        return false;\n    }\n    return (flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right)) || (flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left));\n\n}", "prefix": "bool flipEquiv(struct TreeNode* root1, struct TreeNode* root2"}
{"id": "1041", "path": "output2\\c\\Medium\\1041-array-of-doubled-pairs.c", "hypo_code": "bool canReorderDoubled(int* arr, int arrSize){\n    int* count = (int*)malloc(sizeof(int) * 20001);\n    for(int i = 0; i < 20001; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < arrSize; i++){\n        count[arr[i] + 10000]++;\n    }\n    for(int i = 0; i < 10001; i++){\n        if(count[i] > count[2 * i]){\n            return false;\n        }\n        count[2 * i] -= count[i];\n    }\n    return true;\n\n}", "prefix": "bool canReorderDoubled(int* arr, int arrSize"}
{"id": "1042", "path": "output2\\c\\Medium\\1042-delete-columns-to-make-sorted-ii.c", "hypo_code": "int minDeletionSize(char ** strs, int strsSize){\n    int result = 0;\n    int length = strlen(strs[0]);\n    int* index = (int*)malloc(sizeof(int) * strsSize);\n    for(int i = 0; i < strsSize; i++){\n        index[i] = 0;\n    }\n    for(int i = 0; i < length; i++){\n        for(int j = 1; j < strsSize; j++){\n            if(index[j] == -1){\n                continue;\n            }\n            if(strs[j][i] < strs[j - 1][i]){\n                result++;\n                break;\n            }else if(strs[j][i] > strs[j - 1][i]){\n                index[j] = -1;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int minDeletionSize(char ** strs, int strsSize"}
{"id": "1043", "path": "output2\\c\\Medium\\1043-prison-cells-after-n-days.c", "hypo_code": "int* prisonAfterNDays(int* cells, int cellsSize, int n, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * cellsSize);\n    *returnSize = cellsSize;\n    int* temp = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp2 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp3 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp4 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp5 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp6 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp7 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp8 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp9 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp10 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp11 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp12 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp13 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp14 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp15 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp16 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp17 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp18 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp19 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp20 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp21 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp22 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp23 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp24 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp25 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp26 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp27 = (int*)malloc(sizeof(int) * cellsSize);\n    int* temp28 = (int*)malloc(sizeof(int) * cellsSize);\n\n}", "prefix": "int* prisonAfterNDays(int* cells, int cellsSize, int n, int* returnSize"}
{"id": "1044", "path": "output2\\c\\Medium\\1044-check-completeness-of-a-binary-tree.c", "hypo_code": "bool isCompleteTree(struct TreeNode* root){\n    struct TreeNode* queue[10000];\n    int front = 0;\n    int rear = 0;\n    queue[rear++] = root;\n    while(front < rear){\n        struct TreeNode* node = queue[front++];\n        if(node == NULL){\n            break;\n        }\n        queue[rear++] = node->left;\n        queue[rear++] = node->right;\n    }\n    while(front < rear){\n        if(queue[front++] != NULL){\n            return false;\n        }\n    }\n    return true;\n\n}", "prefix": "bool isCompleteTree(struct TreeNode* root"}
{"id": "1045", "path": "output2\\c\\Medium\\1045-regions-cut-by-slashes.c", "hypo_code": "int regionsBySlashes(char ** grid, int gridSize){\n    int n = gridSize;\n    int size = n * n * 4;\n    int* parent = (int*)malloc(sizeof(int) * size);\n    for(int i = 0; i < size; i++){\n        parent[i] = i;\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            int index = (i * n + j) * 4;\n            if(i < n - 1){\n                int bottom = index + 4 * n;\n                unionSet(parent, index + 2, bottom);\n            }\n            if(j < n - 1){\n                int right = index + 4 + 3;\n                unionSet(parent, index + 1, right);\n            }\n            if(grid[i][j] == '/'){\n                unionSet(parent, index, index + 3);\n                unionSet(parent, index + 1, index + 2);\n            }else if(grid[i][j] == '\\\\'){\n                unionSet(parent, index, index + 1);\n                unionSet(parent, index + 2, index + 3);\n            }else{\n                unionSet(parent, index, index + 1);\n                unionSet(parent, index + 1, index + 2);\n                unionSet(parent, index + 2, index + 3);\n            }\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < size; i++){\n        if(parent[i] == i){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int regionsBySlashes(char ** grid, int gridSize"}
{"id": "1046", "path": "output2\\c\\Medium\\1046-maximum-width-ramp.c", "hypo_code": "int maxWidthRamp(int* nums, int numsSize){\n    int* stack = (int*)malloc(sizeof(int) * numsSize);\n    int top = -1;\n    for(int i = 0; i < numsSize; i++){\n        if(top == -1 || nums[stack[top]] > nums[i]){\n            stack[++top] = i;\n        }\n    }\n    int result = 0;\n    for(int i = numsSize - 1; i >= 0; i--){\n        while(top != -1 && nums[stack[top]] <= nums[i]){\n            result = fmax(result, i - stack[top--]);\n        }\n    }\n    return result;\n\n}", "prefix": "int maxWidthRamp(int* nums, int numsSize"}
{"id": "1047", "path": "output2\\c\\Medium\\1047-minimum-area-rectangle-ii.c", "hypo_code": "double minAreaFreeRect(int** points, int pointsSize, int* pointsColSize){\n    double result = 0;\n    for(int i = 0; i < pointsSize; i++){\n        for(int j = i + 1; j < pointsSize; j++){\n            for(int k = j + 1; k < pointsSize; k++){\n                for(int l = k + 1; l < pointsSize; l++){\n                    int x1 = points[i][0];\n                    int y1 = points[i][1];\n                    int x2 = points[j][0];\n                    int y2 = points[j][1];\n                    int x3 = points[k][0];\n                    int y3 = points[k][1];\n                    int x4 = points[l][0];\n                    int y4 = points[l][1];\n                    if((x1 - x2) * (x1 - x3) + (y1 - y2) * (y1 - y3) == 0){\n                        double area = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2)) * sqrt(pow(x1 - x3, 2) + pow(y1 - y3, 2));\n                        if(result == 0 || area < result){\n                            result = area;\n                        }\n                    }\n                    if((x1 - x2) * (x1 - x4) + (y1 - y2) * (y1 - y4) == 0){\n                        double area = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2)) * sqrt(pow(x1 - x4, 2) + pow(y1 - y4, 2));\n                        if(result == 0 || area < result){\n                            result = area;\n                        }\n                    }\n                    if((x1 - x3) * (x1 - x4) + (y1 - y3) * (y1 - y4) == 0){\n                        double area = sqrt(pow(x1 - x3, 2) + pow(y1 - y3, 2)) * sqrt(pow(x1 - x4, 2) + pow(y1 - y4, 2));\n                        if(result == 0 || area < result){\n                            result = area;\n                        }\n                    }\n                    if((x2 - x3) * (x2 - x4) + (y2 - y3) * (y - y4) == 0){\n                        double area = sqrt(pow(x2 - x3, 2) + pow(y2 - y3, 2)) * sqrt(pow(x2 - x4, 2) + pow(y2 - y4, 2));\n                        if(result == 0 || area < result){\n                            result = area;\n                        }\n                    } \n                    \n\n}", "prefix": "double minAreaFreeRect(int** points, int pointsSize, int* pointsColSize"}
{"id": "1048", "path": "output2\\c\\Medium\\1048-vowel-spellchecker.c", "hypo_code": "char ** spellchecker(char ** wordlist, int wordlistSize, char ** queries, int queriesSize, int* returnSize){\n    *returnSize = queriesSize;\n    char** result = (char**)malloc(sizeof(char*) * queriesSize);\n    for(int i = 0; i < queriesSize; i++){\n        result[i] = (char*)malloc(sizeof(char) * 100);\n    }\n    for(int i = 0; i < queriesSize; i++){\n        int flag = 0;\n        for(int j = 0; j < wordlistSize; j++){\n            if(strcmp(wordlist[j], queries[i]) == 0){\n                strcpy(result[i], wordlist[j]);\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 1){\n            continue;\n        }\n        for(int j = 0; j < wordlistSize; j++){\n            if(strlen(wordlist[j]) != strlen(queries[i])){\n                continue;\n            }\n            int flag2 = 0;\n            for(int k = 0; k < strlen(wordlist[j]); k++){\n                if(wordlist[j][k] != queries[i][k]){\n                    if(wordlist[j][k] >= 'A' && wordlist[j][k] <= 'Z'){\n                        if(wordlist[j][k] + 32 != queries[i][k]){\n                            flag2 = 1;\n                            break;\n                        }\n                    }else if(wordlist[j][k] >= 'a' && wordlist[j][k] <= 'z'){\n                        if(wordlist[j][k] - 32 != queries[i][k]){\n                            flag2 = 1;\n                            break;\n                        }\n                    }else{\n                        flag2 = 1;\n                        break;\n                    }\n                }\n            }\n            if(flag2 == 0){\n                strcpy(result[i], wordlist[j]);\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 1){\n            continue;\n        }\n        for(int j = 0; j < wordlistSize; j++){\n            if(strlen(wordlist[j]) != strlen(queries[i])){\n                continue;\n            }\n            int flag2 = 0;\n            for(int k = 0; k < strlen(wordlist[j]); k++){\n                if(wordlist[j][k] != queries[i][k]){\n                    if(wordlist[j][k] == 'a' || wordlist[j][k] == 'e' || wordlist[j][k] == 'i' || wordlist[j][k] == 'o' || wordlist[j][k] == 'u'){\n                        if(wordlist[j][k] - 32 != queries[i][k] && wordlist[j][k] + 32 != queries[i][k]){\n                            flag2 = 1;\n                            break;\n                        }\n                    }else{\n                        flag2 = 1;\n                        break;\n                    }\n\n                    \n\n}", "prefix": "char ** spellchecker(char ** wordlist, int wordlistSize, char ** queries, int queriesSize, int* returnSize"}
{"id": "1049", "path": "output2\\c\\Medium\\1049-numbers-with-same-consecutive-differences.c", "hypo_code": "int* numsSameConsecDiff(int n, int k, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 1000);\n    *returnSize = 0;\n    if(n == 1){\n        for(int i = 0; i < 10; i++){\n            result[*returnSize] = i;\n            (*returnSize)++;\n        }\n        return result;\n    }\n    int* temp = (int*)malloc(sizeof(int) * 1000);\n    int tempSize = 0;\n    for(int i = 1; i < 10; i++){\n        temp[tempSize] = i;\n        tempSize++;\n    }\n    for(int i = 1; i < n; i++){\n        int* temp2 = (int*)malloc(sizeof(int) * 1000);\n        int temp2Size = 0;\n        for(int j = 0; j < tempSize; j++){\n            int last = temp[j] % 10;\n            if(last + k < 10){\n                temp2[temp2Size] = temp[j] * 10 + last + k;\n                temp2Size++;\n            }\n            if(last - k >= 0 && k != 0){\n                temp2[temp2Size] = temp[j] * 10 + last - k;\n                temp2Size++;\n            }\n        }\n        free(temp);\n        temp = temp2;\n        tempSize = temp2Size;\n    }\n    for(int i = 0; i < tempSize; i++){\n        result[*returnSize] = temp[i];\n        (*returnSize)++;\n    }\n    free(temp);\n    return result;\n\n}", "prefix": "int* numsSameConsecDiff(int n, int k, int* returnSize"}
{"id": "1050", "path": "output2\\c\\Medium\\1050-pancake-sorting.c", "hypo_code": "int* pancakeSort(int* arr, int arrSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 1000);\n    *returnSize = 0;\n    int* temp = (int*)malloc(sizeof(int) * arrSize);\n    for(int i = 0; i < arrSize; i++){\n        temp[i] = arr[i];\n    }\n    int tempSize = arrSize;\n    for(int i = 0; i < arrSize; i++){\n        int max = 0;\n        int maxIndex = 0;\n        for(int j = 0; j < tempSize; j++){\n            if(temp[j] > max){\n                max = temp[j];\n                maxIndex = j;\n            }\n        }\n        if(maxIndex != tempSize - 1){\n            result[*returnSize] = maxIndex + 1;\n            (*returnSize)++;\n            for(int j = 0; j < (maxIndex + 1) / 2; j++){\n                int temp2 = temp[j];\n                temp[j] = temp[maxIndex - j];\n                temp[maxIndex - j] = temp2;\n            }\n            result[*returnSize] = tempSize;\n            (*returnSize)++;\n            for(int j = 0; j < tempSize / 2; j++){\n                int temp2 = temp[j];\n                temp[j] = temp[tempSize - j - 1];\n                temp[tempSize - j - 1] = temp2;\n            }\n        }\n        tempSize--;\n    }\n    free(temp);\n    return result;\n\n}", "prefix": "int* pancakeSort(int* arr, int arrSize, int* returnSize"}
{"id": "1051", "path": "output2\\c\\Medium\\1051-powerful-integers.c", "hypo_code": "int* powerfulIntegers(int x, int y, int bound, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 1000);\n    *returnSize = 0;\n    int* temp = (int*)malloc(sizeof(int) * 1000);\n    int tempSize = 0;\n    int i = 0;\n    int j = 0;\n    int tempNum = 1;\n    while(tempNum < bound){\n        temp[tempSize] = tempNum;\n        tempSize++;\n        if(x == 1){\n            break;\n        }\n        tempNum *= x;\n        i++;\n    }\n    tempNum = 1;\n    while(tempNum < bound){\n        for(int k = 0; k < tempSize; k++){\n            if(temp[k] + tempNum <= bound){\n                result[*returnSize] = temp[k] + tempNum;\n                (*returnSize)++;\n            }\n        }\n        if(y == 1){\n            break;\n        }\n        tempNum *= y;\n        j++;\n    }\n    qsort(result, *returnSize, sizeof(int), cmp);\n    int* result2 = (int*)malloc(sizeof(int) * 1000);\n    int result2Size = 0;\n    for(int i = 0; i < *returnSize; i++){\n        if(i == 0 || result[i] != result[i - 1]){\n            result2[result2Size] = result[i];\n            result2Size++;\n        }\n    }\n    *returnSize = result2Size;\n    free(result);\n    free(temp);\n    return result2;\n\n\n}", "prefix": "int* powerfulIntegers(int x, int y, int bound, int* returnSize"}
{"id": "1052", "path": "output2\\c\\Medium\\1052-flip-binary-tree-to-match-preorder-traversal.c", "hypo_code": "int* flipMatchVoyage(struct TreeNode* root, int* voyage, int voyageSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 1000);\n    *returnSize = 0;\n    int i = 0;\n    struct TreeNode* stack[1000];\n    int stackSize = 0;\n    struct TreeNode* node = root;\n    while(node != NULL || stackSize > 0){\n        if(node != NULL){\n            if(node->val != voyage[i]){\n                result[0] = -1;\n                *returnSize = 1;\n                return result;\n            }\n            i++;\n            if(node->left != NULL && node->left->val != voyage[i]){\n                result[*returnSize] = node->val;\n                (*returnSize)++;\n                struct TreeNode* temp = node->left;\n                node->left = node->right;\n                node->right = temp;\n            }\n            stack[stackSize] = node;\n            stackSize++;\n            node = node->left;\n        }else{\n            stackSize--;\n            node = stack[stackSize]->right;\n        }\n    }\n    return result;\n\n}", "prefix": "int* flipMatchVoyage(struct TreeNode* root, int* voyage, int voyageSize, int* returnSize"}
{"id": "1053", "path": "output2\\c\\Medium\\1053-k-closest-points-to-origin.c", "hypo_code": "int** kClosest(int** points, int pointsSize, int* pointsColSize, int k, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * k);\n    *returnSize = 0;\n    *returnColumnSizes = (int*)malloc(sizeof(int) * k);\n    for(int i = 0; i < k; i++){\n        (*returnColumnSizes)[i] = 2;\n    }\n    int* distances = (int*)malloc(sizeof(int) * pointsSize);\n    for(int i = 0; i < pointsSize; i++){\n        distances[i] = points[i][0] * points[i][0] + points[i][1] * points[i][1];\n    }\n    for(int i = 0; i < pointsSize; i++){\n        for(int j = i + 1; j < pointsSize; j++){\n            if(distances[i] > distances[j]){\n                int temp = distances[i];\n                distances[i] = distances[j];\n                distances[j] = temp;\n                int* temp2 = points[i];\n                points[i] = points[j];\n                points[j] = temp2;\n            }\n        }\n    }\n    for(int i = 0; i < k; i++){\n        result[i] = points[i];\n        (*returnSize)++;\n    }\n    free(distances);\n    return result;\n\n}", "prefix": "int** kClosest(int** points, int pointsSize, int* pointsColSize, int k, int* returnSize, int** returnColumnSizes"}
{"id": "1054", "path": "output2\\c\\Medium\\1054-subarray-sums-divisible-by-k.c", "hypo_code": "int subarraysDivByK(int* nums, int numsSize, int k){\n    int* count = (int*)malloc(sizeof(int) * k);\n    for(int i = 0; i < k; i++){\n        count[i] = 0;\n    }\n    int sum = 0;\n    for(int i = 0; i < numsSize; i++){\n        sum += nums[i];\n        count[((sum % k) + k) % k]++;\n    }\n    int result = 0;\n    for(int i = 0; i < k; i++){\n        result += count[i] * (count[i] - 1) / 2;\n    }\n    return result + count[0];\n\n}", "prefix": "int subarraysDivByK(int* nums, int numsSize, int k"}
{"id": "1055", "path": "output2\\c\\Medium\\1055-longest-turbulent-subarray.c", "hypo_code": "int maxTurbulenceSize(int* arr, int arrSize){\n    int* dp = (int*)malloc(sizeof(int) * arrSize);\n    dp[0] = 1;\n    int max = 1;\n    for(int i = 1; i < arrSize; i++){\n        if(arr[i] == arr[i - 1]){\n            dp[i] = 1;\n        }else if(i == 1 || (arr[i] > arr[i - 1] && arr[i - 1] < arr[i - 2]) || (arr[i] < arr[i - 1] && arr[i - 1] > arr[i - 2])){\n            dp[i] = dp[i - 1] + 1;\n        }else{\n            dp[i] = 2;\n        }\n        max = fmax(max, dp[i]);\n    }\n    return max;\n\n}", "prefix": "int maxTurbulenceSize(int* arr, int arrSize"}
{"id": "1056", "path": "output2\\c\\Medium\\1056-distribute-coins-in-binary-tree.c", "hypo_code": "int distributeCoins(struct TreeNode* root){\n    int result = 0;\n    distributeCoinsHelper(root, &result);\n    return result;\n\n}", "prefix": "int distributeCoins(struct TreeNode* root"}
{"id": "1058", "path": "output2\\c\\Medium\\1058-minimum-cost-for-tickets.c", "hypo_code": "int mincostTickets(int* days, int daysSize, int* costs, int costsSize){\n    int dp[daysSize];\n    for(int i = 0; i < daysSize; i++){\n        dp[i] = 0;\n    }\n    for(int i = 0; i < daysSize; i++){\n        int min = 0;\n        for(int j = 0; j < i; j++){\n            if(days[i] - days[j] < 7){\n                min = min > dp[j] ? min : dp[j];\n            }\n        }\n        dp[i] = min + costs[1];\n        min = 0;\n        for(int j = 0; j < i; j++){\n            if(days[i] - days[j] < 30){\n                min = min > dp[j] ? min : dp[j];\n            }\n        }\n        dp[i] = dp[i] < min + costs[2] ? dp[i] : min + costs[2];\n        dp[i] = dp[i] < dp[i - 1] + costs[0] ? dp[i] : dp[i - 1] + costs[0];\n    }\n    return dp[daysSize - 1];\n\n}", "prefix": "int mincostTickets(int* days, int daysSize, int* costs, int costsSize"}
{"id": "1059", "path": "output2\\c\\Medium\\1059-string-without-aaa-or-bbb.c", "hypo_code": "char * strWithout3a3b(int a, int b){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int len = a + b;\n    char* result = (char*)malloc(sizeof(char) * (len + 1));\n    for(i = 0; i < len; i++){\n        if(a > b){\n            if(i > 1 && result[i - 1] == 'a' && result[i - 2] == 'a'){\n                result[i] = 'b';\n                b--;\n            }\n            else{\n                result[i] = 'a';\n                a--;\n            }\n        }\n        else if(a < b){\n            if(i > 1 && result[i - 1] == 'b' && result[i - 2] == 'b'){\n                result[i] = 'a';\n                a--;\n            }\n            else{\n                result[i] = 'b';\n                b--;\n            }\n        }\n        else{\n            if(i > 1 && result[i - 1] == 'a' && result[i - 2] == 'a'){\n                result[i] = 'b';\n                b--;\n            }\n            else{\n                result[i] = 'a';\n                a--;\n            }\n        }\n    }\n    result[i] = '\\0';\n    return result;\n\n}", "prefix": "char * strWithout3a3b(int a, int b"}
{"id": "1060", "path": "output2\\c\\Medium\\1060-sum-of-even-numbers-after-queries.c", "hypo_code": "int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * queriesSize);\n    *returnSize = 0;\n    int sum = 0;\n    for(int i = 0; i < numsSize; i++){\n        if(nums[i] % 2 == 0){\n            sum += nums[i];\n        }\n    }\n    for(int i = 0; i < queriesSize; i++){\n        int val = queries[i][0];\n        int index = queries[i][1];\n        if(nums[index] % 2 == 0){\n            sum -= nums[index];\n        }\n        nums[index] += val;\n        if(nums[index] % 2 == 0){\n            sum += nums[index];\n        }\n        result[*returnSize] = sum;\n        (*returnSize)++;\n    }\n    return result;\n\n}", "prefix": "int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1061", "path": "output2\\c\\Medium\\1061-interval-list-intersections.c", "hypo_code": "int** intervalIntersection(int** firstList, int firstListSize, int* firstListColSize, int** secondList, int secondListSize, int* secondListColSize, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * firstListSize);\n    *returnSize = 0;\n    *returnColumnSizes = (int*)malloc(sizeof(int) * firstListSize);\n    for(int i = 0; i < firstListSize; i++){\n        (*returnColumnSizes)[i] = 2;\n    }\n    int i = 0;\n    int j = 0;\n    while(i < firstListSize && j < secondListSize){\n        int start = firstList[i][0] > secondList[j][0] ? firstList[i][0] : secondList[j][0];\n        int end = firstList[i][1] < secondList[j][1] ? firstList[i][1] : secondList[j][1];\n        if(start <= end){\n            result[*returnSize] = (int*)malloc(sizeof(int) * 2);\n            result[*returnSize][0] = start;\n            result[*returnSize][1] = end;\n            (*returnSize)++;\n        }\n        if(firstList[i][1] < secondList[j][1]){\n            i++;\n        }else{\n            j++;\n        }\n    }\n    return result;\n}", "prefix": "int** intervalIntersection(int** firstList, int firstListSize, int* firstListColSize, int** secondList, int secondListSize, int* secondListColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1062", "path": "output2\\c\\Medium\\1062-smallest-string-starting-from-leaf.c", "hypo_code": "char * smallestFromLeaf(struct TreeNode* root){\n    char* result = (char*)malloc(sizeof(char) * 1000);\n    result[0] = '\\0';\n    smallestFromLeafHelper(root, result);\n    return result;\n\n\n}", "prefix": "char * smallestFromLeaf(struct TreeNode* root"}
{"id": "1063", "path": "output2\\c\\Medium\\1063-satisfiability-of-equality-equations.c", "hypo_code": "bool equationsPossible(char ** equations, int equationsSize){\n    int parent[26];\n    for(int i = 0; i < 26; i++){\n        parent[i] = i;\n    }\n    for(int i = 0; i < equationsSize; i++){\n        if(equations[i][1] == '='){\n            int x = equations[i][0] - 'a';\n            int y = equations[i][3] - 'a';\n            int xParent = findParent(parent, x);\n            int yParent = findParent(parent, y);\n            if(xParent != yParent){\n                parent[xParent] = yParent;\n            }\n        }\n    }\n    for(int i = 0; i < equationsSize; i++){\n        if(equations[i][1] == '!'){\n            int x = equations[i][0] - 'a';\n            int y = equations[i][3] - 'a';\n            int xParent = findParent(parent, x);\n            int yParent = findParent(parent, y);\n            if(xParent == yParent){\n                return false;\n            }\n        }\n    }\n    return true;\n\n}", "prefix": "bool equationsPossible(char ** equations, int equationsSize"}
{"id": "1064", "path": "output2\\c\\Medium\\1064-broken-calculator.c", "hypo_code": "int brokenCalc(int startValue, int target){\n    int result = 0;\n    while(target > startValue){\n        if(target % 2 == 0){\n            target /= 2;\n        }\n        else{\n            target++;\n        }\n        result++;\n    }\n    return result + startValue - target;\n\n}", "prefix": "int brokenCalc(int startValue, int target"}
{"id": "1065", "path": "output2\\c\\Medium\\1065-rotting-oranges.c", "hypo_code": "int orangesRotting(int** grid, int gridSize, int* gridColSize){\n    int result = 0;\n    int fresh = 0;\n    int rotten = 0;\n    int* rottenX = (int*)malloc(sizeof(int) * gridSize * (*gridColSize));\n    int* rottenY = (int*)malloc(sizeof(int) * gridSize * (*gridColSize));\n    for(int i = 0; i < gridSize; i++){\n        for(int j = 0; j < *gridColSize; j++){\n            if(grid[i][j] == 1){\n                fresh++;\n            }\n            else if(grid[i][j] == 2){\n                rottenX[rotten] = i;\n                rottenY[rotten] = j;\n                rotten++;\n            }\n        }\n    }\n    while(fresh > 0){\n        int newRotten = 0;\n        int* newRottenX = (int*)malloc(sizeof(int) * gridSize * (*gridColSize));\n        int* newRottenY = (int*)malloc(sizeof(int) * gridSize * (*gridColSize));\n        for(int i = 0; i < rotten; i++){\n            if(rottenX[i] > 0 && grid[rottenX[i] - 1][rottenY[i]] == 1){\n                grid[rottenX[i] - 1][rottenY[i]] = 2;\n                newRottenX[newRotten] = rottenX[i] - 1;\n                newRottenY[newRotten] = rottenY[i];\n                newRotten++;\n                fresh--;\n            }\n            if(rottenX[i] < gridSize - 1 && grid[rottenX[i] + 1][rottenY[i]] == 1){\n                grid[rottenX[i] + 1][rottenY[i]] = 2;\n                newRottenX[newRotten] = rottenX[i] + 1;\n                newRottenY[newRotten] = rottenY[i];\n                newRotten++;\n                fresh--;\n            }\n            if(rottenY[i] > 0 && grid[rottenX[i]][rottenY[i] - 1] == 1){\n                grid[rottenX[i]][rottenY[i] - 1] = 2;\n                newRottenX[newRotten] = rottenX[i];\n                newRottenY[newRotten] = rottenY[i] - 1;\n                newRotten++;\n                fresh--;\n                \n\n}", "prefix": "int orangesRotting(int** grid, int gridSize, int* gridColSize"}
{"id": "1066", "path": "output2\\c\\Medium\\1066-maximum-binary-tree-ii.c", "hypo_code": "struct TreeNode* insertIntoMaxTree(struct TreeNode* root, int val){\n    if(root == NULL){\n        struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        newNode->val = val;\n        newNode->left = NULL;\n        newNode->right = NULL;\n        return newNode;\n    }\n    if(root->val < val){\n        struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        newNode->val = val;\n        newNode->left = root;\n        newNode->right = NULL;\n        return newNode;\n    }\n    root->right = insertIntoMaxTree(root->right, val);\n    return root;\n\n}", "prefix": "struct TreeNode* insertIntoMaxTree(struct TreeNode* root, int val"}
{"id": "1067", "path": "output2\\c\\Medium\\1067-check-if-word-is-valid-after-substitutions.c", "hypo_code": "bool isValid(char * s){\n    int len = strlen(s);\n    if(len % 3 != 0){\n        return false;\n    }\n    char stack[len];\n    int top = -1;\n    for(int i = 0; i < len; i++){\n        if(s[i] == 'a'){\n            stack[++top] = s[i];\n        }\n        else if(s[i] == 'b'){\n            if(top == -1 || stack[top] != 'a'){\n                return false;\n            }\n            stack[++top] = s[i];\n        }\n        else{\n            if(top == -1 || stack[top] != 'b'){\n                return false;\n            }\n            top--;\n            if(top == -1 || stack[top] != 'a'){\n                return false;\n            }\n            top--;\n        }\n    }\n    return top == -1;\n\n}", "prefix": "bool isValid(char * s"}
{"id": "1068", "path": "output2\\c\\Medium\\1068-max-consecutive-ones-iii.c", "hypo_code": "int longestOnes(int* nums, int numsSize, int k){\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    int max = 0;\n    int flag = 0;\n    for(i = 0; i < numsSize; i++){\n        for(j = i; j < numsSize; j++){\n            if(nums[j] == 0){\n                count++;\n            }\n            if(count > k){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 1){\n            flag = 0;\n            count = 0;\n            continue;\n        }\n        if(j - i > max){\n            max = j - i;\n        }\n        count = 0;\n    }\n    return max;\n\n}", "prefix": "int longestOnes(int* nums, int numsSize, int k"}
{"id": "1069", "path": "output2\\c\\Medium\\1069-clumsy-factorial.c", "hypo_code": "int clumsy(int n){\n    int result = 0;\n    int i = 0;\n    while(n > 0){\n        if(i % 4 == 0){\n            result += n;\n        }\n        else if(i % 4 == 1){\n            result *= n;\n        }\n        else if(i % 4 == 2){\n            result /= n;\n        }\n        else{\n            result -= n;\n        }\n        i++;\n        n--;\n    }\n    if(i % 4 == 3){\n        result += 1;\n    }\n    else if(i % 4 == 2){\n        result += 2;\n    }\n    else if(i % 4 == 1){\n        result += 3;\n    }\n    return result;\n\n}", "prefix": "int clumsy(int n"}
{"id": "1070", "path": "output2\\c\\Medium\\1070-minimum-domino-rotations-for-equal-row.c", "hypo_code": "int minDominoRotations(int* tops, int topsSize, int* bottoms, int bottomsSize){\n    int* hash = (int*)malloc(sizeof(int) * 7);\n    for(int i = 0; i < 7; i++){\n        hash[i] = 0;\n    }\n    for(int i = 0; i < topsSize; i++){\n        hash[tops[i]]++;\n    }\n    for(int i = 0; i < bottomsSize; i++){\n        hash[bottoms[i]]++;\n    }\n    int max = -1;\n    int maxIndex = -1;\n    for(int i = 0; i < 7; i++){\n        if(hash[i] >= max){\n            max = hash[i];\n            maxIndex = i;\n        }\n    }\n    int topCount = 0;\n    int bottomCount = 0;\n    for(int i = 0; i < topsSize; i++){\n        if(tops[i] != maxIndex && bottoms[i] != maxIndex){\n            return -1;\n        }\n        if(tops[i] != maxIndex){\n            topCount++;\n        }\n        if(bottoms[i] != maxIndex){\n            bottomCount++;\n        }\n    }\n    return topCount < bottomCount ? topCount : bottomCount;\n\n}", "prefix": "int minDominoRotations(int* tops, int topsSize, int* bottoms, int bottomsSize"}
{"id": "1071", "path": "output2\\c\\Medium\\1071-construct-binary-search-tree-from-preorder-traversal.c", "hypo_code": "struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){\n    if(preorderSize == 0){\n        return NULL;\n    }\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = preorder[0];\n    root->left = NULL;\n    root->right = NULL;\n    if(preorderSize == 1){\n        return root;\n    }\n    int i = 0;\n    for(i = 0; i < preorderSize; i++){\n        if(preorder[i] > preorder[0]){\n            break;\n        }\n    }\n    root->left = bstFromPreorder(preorder + 1, i - 1);\n    root->right = bstFromPreorder(preorder + i, preorderSize - i);\n    return root;\n\n}", "prefix": "struct TreeNode* bstFromPreorder(int* preorder, int preorderSize"}
{"id": "1072", "path": "output2\\c\\Medium\\1072-pairs-of-songs-with-total-durations-divisible-by-60.c", "hypo_code": "int numPairsDivisibleBy60(int* time, int timeSize){\n    int* hash = (int*)malloc(sizeof(int) * 60);\n    for(int i = 0; i < 60; i++){\n        hash[i] = 0;\n    }\n    int result = 0;\n    for(int i = 0; i < timeSize; i++){\n        int remainder = time[i] % 60;\n        if(remainder == 0){\n            result += hash[0];\n        }else{\n            result += hash[60 - remainder];\n        }\n        hash[remainder]++;\n    }\n    return result;\n\n}", "prefix": "int numPairsDivisibleBy60(int* time, int timeSize"}
{"id": "1073", "path": "output2\\c\\Medium\\1073-capacity-to-ship-packages-within-d-days.c", "hypo_code": "int shipWithinDays(int* weights, int weightsSize, int days){\n    int left = 0;\n    int right = 0;\n    for(int i = 0; i < weightsSize; i++){\n        left = left > weights[i] ? left : weights[i];\n        right += weights[i];\n    }\n    while(left < right){\n        int mid = left + (right - left) / 2;\n        int sum = 0;\n        int count = 1;\n        for(int i = 0; i < weightsSize; i++){\n            if(sum + weights[i] > mid){\n                count++;\n                sum = weights[i];\n            }else{\n                sum += weights[i];\n            }\n        }\n        if(count > days){\n            left = mid + 1;\n        }else{\n            right = mid;\n        }\n    }\n    return left;\n\n}", "prefix": "int shipWithinDays(int* weights, int weightsSize, int days"}
{"id": "1074", "path": "output2\\c\\Medium\\1074-best-sightseeing-pair.c", "hypo_code": "int maxScoreSightseeingPair(int* values, int valuesSize){\n    int result = 0;\n    int max = values[0] + 0;\n    for(int i = 1; i < valuesSize; i++){\n        result = result > max + values[i] - i ? result : max + values[i] - i;\n        max = max > values[i] + i ? max : values[i] + i;\n    }\n    return result;\n\n}", "prefix": "int maxScoreSightseeingPair(int* values, int valuesSize"}
{"id": "1075", "path": "output2\\c\\Medium\\1075-smallest-integer-divisible-by-k.c", "hypo_code": "int smallestRepunitDivByK(int k){\n    if(k % 2 == 0 || k % 5 == 0){\n        return -1;\n    }\n    int n = 1;\n    int count = 1;\n    while(n % k != 0){\n        n = (n * 10 + 1) % k;\n        count++;\n    }\n    return count;\n\n}", "prefix": "int smallestRepunitDivByK(int k"}
{"id": "1076", "path": "output2\\c\\Medium\\1076-binary-string-with-substrings-representing-1-to-n.c", "hypo_code": "bool queryString(char * s, int n){\n    int length = strlen(s);\n    int* index = (int*)malloc(sizeof(int) * n);\n    for(int i = 0; i < n; i++){\n        index[i] = 0;\n    }\n    for(int i = 0; i < length; i++){\n        for(int j = 0; j < n; j++){\n            if(index[j] == -1){\n                continue;\n            }\n            if(s[i] == '1'){\n                index[j]++;\n            }\n            if(index[j] == j + 1){\n                index[j] = -1;\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(index[i] != -1){\n            return false;\n        }\n    }\n    return true;\n\n}", "prefix": "bool queryString(char * s, int n"}
{"id": "1077", "path": "output2\\c\\Medium\\1077-convert-to-base-2.c", "hypo_code": "char * baseNeg2(int n){\n    char* result = (char*)malloc(sizeof(char) * 32);\n    int i = 0;\n    while(n != 0){\n        result[i++] = n % 2 + '0';\n        n = -(n / 2);\n    }\n    if(i == 0){\n        result[i++] = '0';\n    }\n    result[i] = '\\0';\n    for(int j = 0; j < i / 2; j++){\n        char temp = result[j];\n        result[j] = result[i - j - 1];\n        result[i - j - 1] = temp;\n    }\n    return result;\n\n}", "prefix": "char * baseNeg2(int n"}
{"id": "1078", "path": "output2\\c\\Medium\\1078-next-greater-node-in-linked-list.c", "hypo_code": "int* nextLargerNodes(struct ListNode* head, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 10000);\n    int* stack = (int*)malloc(sizeof(int) * 10000);\n    int top = -1;\n    int i = 0;\n    while(head != NULL){\n        while(top != -1 && result[stack[top]] < head->val){\n            result[stack[top]] = head->val;\n            top--;\n        }\n        stack[++top] = i;\n        result[i++] = 0;\n        head = head->next;\n    }\n    *returnSize = i;\n    return result;\n\n}", "prefix": "int* nextLargerNodes(struct ListNode* head, int* returnSize"}
{"id": "1079", "path": "output2\\c\\Medium\\1079-number-of-enclaves.c", "hypo_code": "int numEnclaves(int** grid, int gridSize, int* gridColSize){\n    int result = 0;\n    int* queue = (int*)malloc(sizeof(int) * gridSize * (*gridColSize));\n    int* visited = (int*)malloc(sizeof(int) * gridSize * (*gridColSize));\n    for(int i = 0; i < gridSize; i++){\n        for(int j = 0; j < *gridColSize; j++){\n            visited[i * *gridColSize + j] = 0;\n        }\n    }\n    for(int i = 0; i < gridSize; i++){\n        for(int j = 0; j < *gridColSize; j++){\n            if(grid[i][j] == 1 && visited[i * *gridColSize + j] == 0){\n                int count = 0;\n                int head = 0;\n                int tail = 0;\n                queue[tail++] = i * *gridColSize + j;\n                visited[i * *gridColSize + j] = 1;\n                while(head < tail){\n                    int x = queue[head] / *gridColSize;\n                    int y = queue[head] % *gridColSize;\n                    head++;\n                    count++;\n                    if(x > 0 && grid[x - 1][y] == 1 && visited[(x - 1) * *gridColSize + y] == 0){\n                        queue[tail++] = (x - 1) * *gridColSize + y;\n                        visited[(x - 1) * *gridColSize + y] = 1;\n                    }\n                    if(x < gridSize - 1 && grid[x + 1][y] == 1 && visited[(x + 1) * *gridColSize + y] == 0){\n                        queue[tail++] = (x + 1) * *gridColSize + y;\n                        visited[(x + 1) * *gridColSize + y] = 1;\n                    }\n                    if(y > 0 && grid[x][y - 1] == 1 && visited[x * *gridColSize + y - 1] == 0){\n                        queue[tail++] = x * *gridColSize + y - 1;\n                        visited[x * *gridColSize + y - 1] = 1;\n                    }\n                    if(y < *gridColSize - 1 && grid[x][y + 1 ] == 1 && visited[x * *gridColSize + y + 1] == 0){\n                        queue[tail++] = x * *gridColSize + y + 1;\n                        visited[x * *gridColSize + y + 1] = 1;\n                    }\n                    \n\n}", "prefix": "int numEnclaves(int** grid, int gridSize, int* gridColSize"}
{"id": "1080", "path": "output2\\c\\Medium\\1080-camelcase-matching.c", "hypo_code": "bool* camelMatch(char ** queries, int queriesSize, char * pattern, int* returnSize){\n    bool* result = (bool*)malloc(sizeof(bool) * queriesSize);\n    int length = strlen(pattern);\n    int* index = (int*)malloc(sizeof(int) * queriesSize);\n    for(int i = 0; i < queriesSize; i++){\n        index[i] = 0;\n    }\n    for(int i = 0; i < length; i++){\n        for(int j = 0; j < queriesSize; j++){\n            if(index[j] == -1){\n                continue;\n            }\n            if(pattern[i] == queries[j][index[j]]){\n                index[j]++;\n            }\n            else{\n                while(queries[j][index[j]] != '\\0' && queries[j][index[j]] >= 'a' && queries[j][index[j]] <= 'z'){\n                    index[j]++;\n                }\n                if(queries[j][index[j]] == '\\0'){\n                    index[j] = -1;\n                }\n                else if(queries[j][index[j]] == pattern[i]){\n                    index[j]++;\n                }\n                else{\n                    index[j] = -1;\n                }\n            }\n        }\n    }\n    for(int j = 0; j < queriesSize; j++){\n        if(index[j] == -1){\n            result[j] = false;\n        }\n        else{\n            while(queries[j][index[j]] != '\\0' && queries[j][index[j]] >= 'a' && queries[j][index[j]] <= 'z'){\n                index[j]++;\n            }\n            if(queries[j][index[j]] == '\\0'){\n                result[j] = true;\n            }\n            else{\n                result[j] = false;\n            }\n        }\n    }\n    *returnSize = queriesSize;\n    return result;\n\n}", "prefix": "bool* camelMatch(char ** queries, int queriesSize, char * pattern, int* returnSize"}
{"id": "1081", "path": "output2\\c\\Medium\\1081-video-stitching.c", "hypo_code": "int videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){\n    int* hash = (int*)malloc(sizeof(int) * (time + 1));\n    for(int i = 0; i < time + 1; i++){\n        hash[i] = -1;\n    }\n    hash[0] = 0;\n    for(int i = 0; i < clipsSize; i++){\n        if(clips[i][0] < time + 1 && hash[clips[i][0]] != -1){\n            for(int j = clips[i][0] + 1; j < time + 1 && j <= clips[i][1]; j++){\n                if(hash[j] == -1 || hash[j] > hash[clips[i][0]] + 1){\n                    hash[j] = hash[clips[i][0]] + 1;\n                }\n            }\n        }\n    }\n    return hash[time];\n\n}", "prefix": "int videoStitching(int** clips, int clipsSize, int* clipsColSize, int time"}
{"id": "1082", "path": "output2\\c\\Medium\\1082-maximum-difference-between-node-and-ancestor.c", "hypo_code": "int maxAncestorDiff(struct TreeNode* root){\n    int max = 0;\n    int min = 100000;\n    int result = 0;\n    if(root->left == NULL && root->right == NULL){\n        return 0;\n    }\n    if(root->left != NULL){\n        result = maxAncestorDiff(root->left);\n        if(result > max){\n            max = result;\n        }\n        if(root->left->val > max){\n            max = root->left->val;\n        }\n        if(root->left->val < min){\n            min = root->left->val;\n        }\n    }\n    if(root->right != NULL){\n        result = maxAncestorDiff(root->right);\n        if(result > max){\n            max = result;\n        }\n        if(root->right->val > max){\n            max = root->right->val;\n        }\n        if(root->right->val < min){\n            min = root->right->val;\n        }\n    }\n    if(max - min > result){\n        result = max - min;\n    }\n    return result;\n\n}", "prefix": "int maxAncestorDiff(struct TreeNode* root"}
{"id": "1083", "path": "output2\\c\\Medium\\1083-longest-arithmetic-subsequence.c", "hypo_code": "int longestArithSeqLength(int* nums, int numsSize){\n    int** dp = (int**)malloc(sizeof(int*) * numsSize);\n    for(int i = 0; i < numsSize; i++){\n        dp[i] = (int*)malloc(sizeof(int) * 20001);\n        for(int j = 0; j < 20001; j++){\n            dp[i][j] = 1;\n        }\n    }\n    int max = 0;\n    for(int i = 1; i < numsSize; i++){\n        for(int j = 0; j < i; j++){\n            int diff = nums[i] - nums[j] + 10000;\n            dp[i][diff] = dp[j][diff] + 1;\n            if(dp[i][diff] > max){\n                max = dp[i][diff];\n            }\n        }\n    }\n    return max;\n\n}", "prefix": "int longestArithSeqLength(int* nums, int numsSize"}
{"id": "1084", "path": "output2\\c\\Medium\\1084-two-city-scheduling.c", "hypo_code": "int twoCitySchedCost(int** costs, int costsSize, int* costsColSize){\n    int* diff = (int*)malloc(sizeof(int) * costsSize);\n    int sum = 0;\n    for(int i = 0; i < costsSize; i++){\n        diff[i] = costs[i][0] - costs[i][1];\n        sum += costs[i][1];\n    }\n    qsort(diff, costsSize, sizeof(int), cmp);\n    for(int i = 0; i < costsSize / 2; i++){\n        sum += diff[i];\n    }\n    return sum;\n\n}", "prefix": "int twoCitySchedCost(int** costs, int costsSize, int* costsColSize"}
{"id": "1085", "path": "output2\\c\\Medium\\1085-maximum-sum-of-two-non-overlapping-subarrays.c", "hypo_code": "int maxSumTwoNoOverlap(int* nums, int numsSize, int firstLen, int secondLen){\n    int* first = (int*)malloc(sizeof(int) * numsSize);\n    int* second = (int*)malloc(sizeof(int) * numsSize);\n    int sum = 0;\n    for(int i = 0; i < firstLen; i++){\n        sum += nums[i];\n    }\n    first[firstLen - 1] = sum;\n    for(int i = firstLen; i < numsSize; i++){\n        sum += nums[i] - nums[i - firstLen];\n        first[i] = sum;\n    }\n    sum = 0;\n    for(int i = 0; i < secondLen; i++){\n        sum += nums[i];\n    }\n    second[secondLen - 1] = sum;\n    for(int i = secondLen; i < numsSize; i++){\n        sum += nums[i] - nums[i - secondLen];\n        second[i] = sum;\n    }\n    int max = 0;\n    for(int i = firstLen - 1; i < numsSize; i++){\n        for(int j = secondLen - 1; j < numsSize; j++){\n            if(i - firstLen + 1 > j || j - secondLen + 1 > i){\n                int temp = first[i] + second[j];\n                if(temp > max){\n                    max = temp;\n                }\n            }\n        }\n    }\n    return max;\n\n\n}", "prefix": "int maxSumTwoNoOverlap(int* nums, int numsSize, int firstLen, int secondLen"}
{"id": "1086", "path": "output2\\c\\Medium\\1086-moving-stones-until-consecutive.c", "hypo_code": "int* numMovesStones(int a, int b, int c, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 2);\n    int min = 0;\n    int max = 0;\n    int temp = 0;\n    if(a > b){\n        temp = a;\n        a = b;\n        b = temp;\n    }\n    if(a > c){\n        temp = a;\n        a = c;\n        c = temp;\n    }\n    if(b > c){\n        temp = b;\n        b = c;\n        c = temp;\n    }\n    if(b - a == 1 && c - b == 1){\n        min = 0;\n    }\n    else if(b - a == 1 || c - b == 1 || b - a == 2 || c - b == 2){\n        min = 1;\n    }\n    else{\n        min = 2;\n    }\n    max = c - a - 2;\n    result[0] = min;\n    result[1] = max;\n    *returnSize = 2;\n    return result;\n\n}", "prefix": "int* numMovesStones(int a, int b, int c, int* returnSize"}
{"id": "1087", "path": "output2\\c\\Medium\\1087-coloring-a-border.c", "hypo_code": "int** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * gridSize);\n    int* stack = (int*)malloc(sizeof(int) * 10000);\n    int top = -1;\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    int temp2 = 0;\n    int temp3 = 0;\n    int temp4 = 0;\n    int temp5 = 0;\n    int temp6 = 0;\n    int temp7 = 0;\n    int temp8 = 0;\n    int temp9 = 0;\n    int temp10 = 0;\n    int temp11 = 0;\n    int temp12 = 0;\n    int temp13 = 0;\n    int temp14 = 0;\n    int temp15 = 0;\n    int temp16 = 0;\n    int temp17 = 0;\n    int temp18 = 0;\n    int temp19 = 0;\n    int temp20 = 0;\n    int temp21 = 0;\n    int temp22 = 0;\n    int temp23 = 0;\n    int temp24 = 0;\n    int temp25 = 0;\n    int temp26 = 0;\n    int temp27 = 0;\n    int temp28 = 0;\n    int temp29 = 0;\n    int temp30 = 0;\n    int temp31 = 0;\n    int temp32 = 0;\n    int temp33 = 0;\n    int temp34 = 0;\n    int temp35 = 0;\n    int temp36 = 0;\n    int temp37 = 0;\n    int temp38 = 0;\n    int temp39 = 0;\n    int temp40 = 0;\n    int temp41 = 0;\n    int temp42 = 0;\n    int temp43 = 0;\n    int temp44 = 0;\n    int temp45 = 0;\n    int temp46 = 0;\n    int temp47 = 0;\n    int temp48 = 0;\n    int temp49 = 0;\n    int temp50 = 0;\n    int temp51 = 0;\n    int temp52 = 0;\n    int temp53 = 0;\n    int temp54 = 0;\n    int temp55 = 0;\n    int temp56 = 0;\n\n}", "prefix": "int** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes"}
{"id": "1088", "path": "output2\\c\\Medium\\1088-uncrossed-lines.c", "hypo_code": "int maxUncrossedLines(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int** dp = (int**)malloc(sizeof(int*) * (nums1Size + 1));\n    for(int i = 0; i < nums1Size + 1; i++){\n        dp[i] = (int*)malloc(sizeof(int) * (nums2Size + 1));\n    }\n    for(int i = 0; i < nums1Size + 1; i++){\n        for(int j = 0; j < nums2Size + 1; j++){\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 1; i < nums1Size + 1; i++){\n        for(int j = 1; j < nums2Size + 1; j++){\n            if(nums1[i - 1] == nums2[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }else{\n                dp[i][j] = dp[i - 1][j] > dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1];\n            }\n        }\n    }\n    return dp[nums1Size][nums2Size];\n\n}", "prefix": "int maxUncrossedLines(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "1089", "path": "output2\\c\\Medium\\1089-binary-search-tree-to-greater-sum-tree.c", "hypo_code": "struct TreeNode* bstToGst(struct TreeNode* root){\n    if(root == NULL){\n        return NULL;\n    }\n    if(root->right != NULL){\n        bstToGst(root->right);\n    }\n    if(root->left != NULL){\n        bstToGst(root->left);\n    }\n    if(root->right != NULL){\n        root->val += root->right->val;\n    }\n    if(root->left != NULL){\n        root->left->val += root->val;\n    }\n    return root;\n\n}", "prefix": "struct TreeNode* bstToGst(struct TreeNode* root"}
{"id": "1090", "path": "output2\\c\\Medium\\1090-minimum-score-triangulation-of-polygon.c", "hypo_code": "int minScoreTriangulation(int* values, int valuesSize){\n    int** dp = (int**)malloc(sizeof(int*) * valuesSize);\n    for(int i = 0; i < valuesSize; i++){\n        dp[i] = (int*)malloc(sizeof(int) * valuesSize);\n        memset(dp[i], 0, sizeof(int) * valuesSize);\n    }\n    for(int i = valuesSize - 1; i >= 0; i--){\n        for(int j = i + 2; j < valuesSize; j++){\n            dp[i][j] = INT_MAX;\n            for(int k = i + 1; k < j; k++){\n                dp[i][j] = fmin(dp[i][j], dp[i][k] + dp[k][j] + values[i] * values[j] * values[k]);\n            }\n        }\n    }\n    return dp[0][valuesSize - 1];\n\n}", "prefix": "int minScoreTriangulation(int* values, int valuesSize"}
{"id": "1091", "path": "output2\\c\\Medium\\1091-moving-stones-until-consecutive-ii.c", "hypo_code": "int* numMovesStonesII(int* stones, int stonesSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 2);\n    int min = 0;\n    int max = 0;\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    int count = 0;\n    int maxCount = 0;\n    int minCount = 0;\n    int minCount2 = 0;\n    int minCount3 = 0;\n    int minCount4 = 0;\n    int minCount5 = 0;\n    int minCount6 = 0;\n    int minCount7 = 0;\n    int minCount8 = 0;\n    int minCount9 = 0;\n    int minCount10 = 0;\n    int minCount11 = 0;\n    int minCount12 = 0;\n    int minCount13 = 0;\n    int minCount14 = 0;\n    int minCount15 = 0;\n    int minCount16 = 0;\n    int minCount17 = 0;\n    int minCount18 = 0;\n    int minCount19 = 0;\n    int minCount20 = 0;\n    int minCount21 = 0;\n    int minCount22 = 0;\n    int minCount23 = 0;\n    int minCount24 = 0;\n    int minCount25 = 0;\n    int minCount26 = 0;\n    int minCount27 = 0;\n    int minCount28 = 0;\n    int minCount29 = 0;\n    int minCount30 = 0;\n    int minCount31 = 0;\n    int minCount32 = 0;\n    int minCount33 = 0;\n    int minCount34 = 0;\n    int minCount35 = 0;\n    int minCount36 = 0;\n    int minCount37 = 0;\n    int minCount38 = 0;\n    int minCount39 = 0;\n    int minCount40 = 0;\n    int minCount41 = 0;\n    int minCount42 = 0;\n    int minCount43 = 0;\n    int minCount44 = 0;\n    int minCount45 = 0;\n    int minCount46 = 0;\n    int minCount47 = 0;\n    int minCount48 = 0;\n    \n\n}", "prefix": "int* numMovesStonesII(int* stones, int stonesSize, int* returnSize"}
{"id": "1092", "path": "output2\\c\\Medium\\1092-robot-bounded-in-circle.c", "hypo_code": "bool isRobotBounded(char * instructions){\n    int x = 0;\n    int y = 0;\n    int direction = 0;\n    int length = strlen(instructions);\n    for(int i = 0; i < length; i++){\n        if(instructions[i] == 'G'){\n            if(direction == 0){\n                y++;\n            }else if(direction == 1){\n                x++;\n            }else if(direction == 2){\n                y--;\n            }else{\n                x--;\n            }\n        }else if(instructions[i] == 'L'){\n            direction = (direction + 3) % 4;\n        }else{\n            direction = (direction + 1) % 4;\n        }\n    }\n    if(x == 0 && y == 0){\n        return true;\n    }\n    if(direction == 0){\n        return false;\n    }\n    return true;\n\n}", "prefix": "bool isRobotBounded(char * instructions"}
{"id": "1093", "path": "output2\\c\\Medium\\1093-flower-planting-with-no-adjacent.c", "hypo_code": "int* gardenNoAdj(int n, int** paths, int pathsSize, int* pathsColSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * n);\n    int* temp = (int*)malloc(sizeof(int) * n);\n    int* temp2 = (int*)malloc(sizeof(int) * n);\n    int* temp3 = (int*)malloc(sizeof(int) * n);\n    int* temp4 = (int*)malloc(sizeof(int) * n);\n    int* temp5 = (int*)malloc(sizeof(int) * n);\n    int* temp6 = (int*)malloc(sizeof(int) * n);\n    int* temp7 = (int*)malloc(sizeof(int) * n);\n    int* temp8 = (int*)malloc(sizeof(int) * n);\n    int* temp9 = (int*)malloc(sizeof(int) * n);\n    int* temp10 = (int*)malloc(sizeof(int) * n);\n    int* temp11 = (int*)malloc(sizeof(int) * n);\n    int* temp12 = (int*)malloc(sizeof(int) * n);\n    int* temp13 = (int*)malloc(sizeof(int) * n);\n    int* temp14 = (int*)malloc(sizeof(int) * n);\n    int* temp15 = (int*)malloc(sizeof(int) * n);\n    int* temp16 = (int*)malloc(sizeof(int) * n);\n    int* temp17 = (int*)malloc(sizeof(int) * n);\n    int* temp18 = (int*)malloc(sizeof(int) * n);\n    int* temp19 = (int*)malloc(sizeof(int) * n);\n    int* temp20 = (int*)malloc(sizeof(int) * n);\n    int* temp21 = (int*)malloc(sizeof(int) * n);\n    int* temp22 = (int*)malloc(sizeof(int) * n);\n    int* temp23 = (int*)malloc(sizeof(int) * n);\n    int* temp24 = (int*)malloc(sizeof(int) * n);\n    int* temp25 = (int*)malloc(sizeof(int) * n);\n    int* temp26 = (int*)malloc(sizeof(int) * n);\n    int* temp27 = (int*)malloc(sizeof(int) * n);\n    int* temp28 = (int*)malloc(sizeof(int) * n);\n    int* temp29 = (int*)malloc(sizeof(int) * n);\n    int* temp30 = (int*)malloc(sizeof(int) * n);\n    \n\n}", "prefix": "int* gardenNoAdj(int n, int** paths, int pathsSize, int* pathsColSize, int* returnSize"}
{"id": "1094", "path": "output2\\c\\Medium\\1094-partition-array-for-maximum-sum.c", "hypo_code": "int maxSumAfterPartitioning(int* arr, int arrSize, int k){\n    int* dp = (int*)malloc(sizeof(int) * arrSize);\n    memset(dp, 0, sizeof(int) * arrSize);\n    for(int i = 0; i < arrSize; i++){\n        int max = 0;\n        for(int j = 1; j <= k && i - j + 1 >= 0; j++){\n            max = fmax(max, arr[i - j + 1]);\n            dp[i] = fmax(dp[i], (i - j >= 0 ? dp[i - j] : 0) + max * j);\n        }\n    }\n    return dp[arrSize - 1];\n\n}", "prefix": "int maxSumAfterPartitioning(int* arr, int arrSize, int k"}
{"id": "1096", "path": "output2\\c\\Medium\\1096-longest-string-chain.c", "hypo_code": "int longestStrChain(char ** words, int wordsSize){\nint result = 0;\n    int dp[wordsSize];\n    for (int i = 0; i < wordsSize; i++) {\n        dp[i] = 1;\n    }\n    qsort(words, wordsSize, sizeof(char*), cmp);\n    for (int i = 0; i < wordsSize; i++) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (strlen(words[i]) - strlen(words[j]) > 1) {\n                break;\n            }\n            if (strlen(words[i]) - strlen(words[j]) == 1) {\n                if (isPredecessor(words[j], words[i])) {\n                    dp[i] = fmax(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        result = fmax(result, dp[i]);\n    }\n    return result;\n}", "prefix": "int longestStrChain(char ** words, int wordsSize"}
{"id": "1097", "path": "output2\\c\\Medium\\1097-last-stone-weight-ii.c", "hypo_code": "int lastStoneWeightII(int* stones, int stonesSize){\nint sum = 0;\n    for (int i = 0; i < stonesSize; i++) {\n        sum += stones[i];\n    }\n    int target = sum / 2;\n    int dp[target + 1];\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < stonesSize; i++) {\n        for (int j = target; j >= stones[i]; j--) {\n            dp[j] = fmax(dp[j], dp[j - stones[i]] + stones[i]);\n        }\n    }\n    return sum - 2 * dp[target];\n}", "prefix": "int lastStoneWeightII(int* stones, int stonesSize"}
{"id": "1098", "path": "output2\\c\\Medium\\1098-grumpy-bookstore-owner.c", "hypo_code": "int maxSatisfied(int* customers, int customersSize, int* grumpy, int grumpySize, int minutes){\nint result = 0;\n    for (int i = 0; i < customersSize; i++) {\n        if (grumpy[i] == 0) {\n            result += customers[i];\n        }\n    }\n    int max = result;\n    for (int i = 0; i < minutes; i++) {\n        if (grumpy[i] == 1) {\n            result += customers[i];\n        }\n    }\n    max = fmax(max, result);\n    for (int i = minutes; i < customersSize; i++) {\n        if (grumpy[i - minutes] == 1) {\n            result -= customers[i - minutes];\n        }\n        if (grumpy[i] == 1) {\n            result += customers[i];\n        }\n        max = fmax(max, result);\n    }\n    return max;\n}", "prefix": "int maxSatisfied(int* customers, int customersSize, int* grumpy, int grumpySize, int minutes"}
{"id": "1099", "path": "output2\\c\\Medium\\1099-previous-permutation-with-one-swap.c", "hypo_code": "int* prevPermOpt1(int* arr, int arrSize, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * arrSize);\n    *returnSize = arrSize;\n    for (int i = arrSize - 1; i >= 0; i--) {\n        if (i == arrSize - 1) {\n            res[i] = arr[i];\n        } else {\n            if (arr[i] > arr[i + 1]) {\n                int max = -1, index = -1;\n                for (int j = i + 1; j < arrSize; j++) {\n                    if (arr[j] < arr[i] && arr[j] > max) {\n                        max = arr[j];\n                        index = j;\n                    }\n                }\n                if (index != -1) {\n                    res[i] = arr[index];\n                    arr[index] = arr[i];\n                } else {\n                    res[i] = arr[i];\n                }\n            } else {\n                res[i] = arr[i];\n            }\n        }\n    }\n    return res;\n}", "prefix": "int* prevPermOpt1(int* arr, int arrSize, int* returnSize"}
{"id": "1100", "path": "output2\\c\\Medium\\1100-distant-barcodes.c", "hypo_code": "int* rearrangeBarcodes(int* barcodes, int barcodesSize, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * barcodesSize);\n    *returnSize = barcodesSize;\n    int count[10001] = {0};\n    int max = 0, index = 0;\n    for (int i = 0; i < barcodesSize; i++) {\n        count[barcodes[i]]++;\n        if (count[barcodes[i]] > max) {\n            max = count[barcodes[i]];\n            index = barcodes[i];\n        }\n    }\n    int pos = 0;\n    while (count[index] > 0) {\n        res[pos] = index;\n        pos += 2;\n        count[index]--;\n    }\n    for (int i = 0; i < 10001; i++) {\n        while (count[i] > 0) {\n            if (pos >= barcodesSize) {\n                pos = 1;\n            }\n            res[pos] = i;\n            pos += 2;\n            count[i]--;\n        }\n    }\n    return res;\n}", "prefix": "int* rearrangeBarcodes(int* barcodes, int barcodesSize, int* returnSize"}
{"id": "1101", "path": "output2\\c\\Medium\\1101-lexicographically-smallest-equivalent-string.c", "hypo_code": "char * smallestEquivalentString(char * s1, char * s2, char * baseStr){\nint parent[26];\n    for (int i = 0; i < 26; i++) {\n        parent[i] = i;\n    }\n    int length = strlen(s1);\n    for (int i = 0; i < length; i++) {\n        int root1 = find(s1[i] - 'a', parent);\n        int root2 = find(s2[i] - 'a', parent);\n        if (root1 < root2) {\n            parent[root2] = root1;\n        } else {\n            parent[root1] = root2;\n        }\n    }\n    for (int i = 0; i < length; i++) {\n        int root = find(s1[i] - 'a', parent);\n        s1[i] = 'a' + root;\n    }\n    return s1;\n}\nint find(int x, int* parent) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x], parent);\n    }\n    return parent[x];\n}", "prefix": "char * smallestEquivalentString(char * s1, char * s2, char * baseStr"}
{"id": "1103", "path": "output2\\c\\Medium\\1103-flip-columns-for-maximum-number-of-equal-rows.c", "hypo_code": "int maxEqualRowsAfterFlips(int** matrix, int matrixSize, int* matrixColSize){\nint result = 0;\n    for (int i = 0; i < matrixSize; i++) {\n        int count = 0;\n        for (int j = 0; j < matrixSize; j++) {\n            if (i == j) {\n                continue;\n            }\n            int same = 1;\n            for (int k = 0; k < *matrixColSize; k++) {\n                if (matrix[i][k] != matrix[j][k]) {\n                    same = 0;\n                    break;\n                }\n            }\n            if (same) {\n                count++;\n            }\n        }\n        if (count > result) {\n            result = count;\n        }\n    }\n    return result + 1;\n}", "prefix": "int maxEqualRowsAfterFlips(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "1104", "path": "output2\\c\\Medium\\1104-adding-two-negabinary-numbers.c", "hypo_code": "int* addNegabinary(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * (arr1Size > arr2Size ? arr1Size + 2 : arr2Size + 2));\n    *returnSize = 0;\n    int carry = 0;\n    int i = arr1Size - 1, j = arr2Size - 1;\n    while (i >= 0 || j >= 0 || carry != 0) {\n        int sum = carry;\n        if (i >= 0) {\n            sum += arr1[i--];\n        }\n        if (j >= 0) {\n            sum += arr2[j--];\n        }\n        res[(*returnSize)++] = sum & 1;\n        carry = -(sum >> 1);\n    }\n    while (*returnSize > 1 && res[*returnSize - 1] == 0) {\n        (*returnSize)--;\n    }\n    for (i = 0, j = *returnSize - 1; i < j; i++, j--) {\n        int temp = res[i];\n        res[i] = res[j];\n        res[j] = temp;\n    }\n    return res;\n}", "prefix": "int* addNegabinary(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize"}
{"id": "1105", "path": "output2\\c\\Medium\\1105-letter-tile-possibilities.c", "hypo_code": "int numTilePossibilities(char * tiles){\nint count[26] = {0};\n    int length = strlen(tiles);\n    for (int i = 0; i < length; i++) {\n        count[tiles[i] - 'A']++;\n    }\n    return dfs(count);\n}\nint dfs(int* count) {\n    int sum = 0;\n    for (int i = 0; i < 26; i++) {\n        if (count[i] > 0) {\n            sum++;\n            count[i]--;\n            sum += dfs(count);\n            count[i]++;\n        }\n    }\n    return sum;\n}", "prefix": "int numTilePossibilities(char * tiles"}
{"id": "1106", "path": "output2\\c\\Medium\\1106-insufficient-nodes-in-root-to-leaf-paths.c", "hypo_code": "struct TreeNode* sufficientSubset(struct TreeNode* root, int limit){\nif (root == NULL) {\n        return NULL;\n    }\n    if (root->left == NULL && root->right == NULL) {\n        if (root->val < limit) {\n            return NULL;\n        } else {\n            return root;\n        }\n    }\n    root->left = sufficientSubset(root->left, limit - root->val);\n    root->right = sufficientSubset(root->right, limit - root->val);\n    if (root->left == NULL && root->right == NULL) {\n        return NULL;\n    }\n    return root;\n}", "prefix": "struct TreeNode* sufficientSubset(struct TreeNode* root, int limit"}
{"id": "1107", "path": "output2\\c\\Medium\\1107-smallest-subsequence-of-distinct-characters.c", "hypo_code": "char * smallestSubsequence(char * s){\nint length = strlen(s);\n    int count[26] = {0};\n    int used[26] = {0};\n    for (int i = 0; i < length; i++) {\n        count[s[i] - 'a']++;\n    }\n    char* result = (char*)malloc(sizeof(char) * 27);\n    result[26] = '\\0';\n    int index = 0;\n    for (int i = 0; i < length; i++) {\n        int ch = s[i] - 'a';\n        count[ch]--;\n        if (used[ch]) {\n            continue;\n        }\n        while (index > 0 && result[index - 1] > s[i] && count[result[index - 1] - 'a'] > 0) {\n            used[result[--index] - 'a'] = 0;\n        }\n        result[index++] = s[i];\n        used[ch] = 1;\n    }\n    result[index] = '\\0';\n    return result;\n}", "prefix": "char * smallestSubsequence(char * s"}
{"id": "1108", "path": "output2\\c\\Medium\\1108-largest-values-from-labels.c", "hypo_code": "int largestValsFromLabels(int* values, int valuesSize, int* labels, int labelsSize, int numWanted, int useLimit){\nint used[20001] = {0};\n    int result = 0;\n    int count = 0;\n    while (count < numWanted) {\n        int max = 0;\n        int index = -1;\n        for (int i = 0; i < valuesSize; i++) {\n            if (used[i] < useLimit && values[i] > max) {\n                max = values[i];\n                index = i;\n            }\n        }\n        if (index == -1) {\n            break;\n        }\n        result += max;\n        used[index]++;\n        count++;\n    }\n    return result;\n}", "prefix": "int largestValsFromLabels(int* values, int valuesSize, int* labels, int labelsSize, int numWanted, int useLimit"}
{"id": "1109", "path": "output2\\c\\Medium\\1109-shortest-path-in-binary-matrix.c", "hypo_code": "int shortestPathBinaryMatrix(int** grid, int gridSize, int* gridColSize){\nint result = 0;\n    if (grid[0][0] == 1) {\n        return -1;\n    }\n    grid[0][0] = 1;\n    int queue[2][2500];\n    int queueStart = 0;\n    int queueEnd = 1;\n    queue[0][0] = 0;\n    queue[1][0] = 0;\n    while (queueStart < queueEnd) {\n        int x = queue[0][queueStart];\n        int y = queue[1][queueStart];\n        queueStart++;\n        if (x == gridSize - 1 && y == *gridColSize - 1) {\n            result = grid[x][y];\n            break;\n        }\n        if (x > 0 && grid[x - 1][y] == 0) {\n            grid[x - 1][y] = grid[x][y] + 1;\n            queue[0][queueEnd] = x - 1;\n            queue[1][queueEnd] = y;\n            queueEnd++;\n        }\n        if (x < gridSize - 1 && grid[x + 1][y] == 0) {\n            grid[x + 1][y] = grid[x][y] + 1;\n            queue[0][queueEnd] = x + 1;\n            queue[1][queueEnd] = y;\n            queueEnd++;\n        }\n        if (y > 0 && grid[x][y - 1] == 0) {\n            grid[x][y - 1] = grid[x][y] + 1;\n            queue[0][queueEnd] = x;\n            queue[1][queueEnd] = y - 1;\n            queueEnd++;\n        }\n        if (y < *gridColSize - 1 && grid[x][y + 1] == 0) {\n            grid[x][y + 1] = grid[x][y] + 1;\n            queue[0][queueEnd] = x;\n            queue[1][queueEnd] = y + 1;\n            queueEnd++;\n        }\n        if (x > 0 && y > 0 && grid[x - 1][y - 1] == 0) {\n            grid[x - 1][y - 1] = grid[x][y] + 1;\n            queue[0][queueEnd] = x - 1;\n            queue[1][queueEnd] = y - 1;\n            queueEnd++;\n        }\n        if (x > 0 && y < *gridColSize - 1 && grid[x - 1][y + 1] == 0) {\n            grid[x - 1][y + 1] = grid[x][y] + 1;\n            queue[0][queueEnd] = x - 1;\n            queue[1][queueEnd] = y + 1;\n            queueEnd++;\n        }\n        if (x < gridSize - 1 && y > 0 && grid[x + 1][y - 1] == 0) {\n            grid[x + 1][y - 1] = grid[x][y] + 1;\n            queue[0][queueEnd] = x + 1;\n            queue[1][queueEnd] = y - 1;\n            queueEnd++;\n        }\n        if (x < gridSize - 1 && y < *gridColSize - 1 && grid[x + 1][y + 1] == 0) {\n            grid[x + 1][y + 1] = grid[x][y] + 1;\n            queue[0][queueEnd] = x + 1;\n            queue[1][queueEnd] = y + 1;\n            queueEnd++;\n        }\n    }\n    return result;\n}", "prefix": "int shortestPathBinaryMatrix(int** grid, int gridSize, int* gridColSize"}
{"id": "1110", "path": "output2\\c\\Medium\\1110-statistics-from-a-large-sample.c", "hypo_code": "double* sampleStats(int* count, int countSize, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * countSize);\n    *returnSize = countSize;\n    int stack[countSize][2];\n    int top = -1;\n    for (int i = 0; i < countSize; i++) {\n        int cur = count[i];\n        while (top != -1 && cur > stack[top][1]) {\n            int index = stack[top--][0];\n            res[index] = i - index;\n        }\n        stack[++top][0] = i;\n        stack[top][1] = cur;\n    }\n    while (top != -1) {\n        res[stack[top--][0]] = 0;\n    }\n    return res;\n}", "prefix": "double* sampleStats(int* count, int countSize, int* returnSize"}
{"id": "1111", "path": "output2\\c\\Medium\\1111-car-pooling.c", "hypo_code": "bool carPooling(int** trips, int tripsSize, int* tripsColSize, int capacity){\nint locations[1001] = {0};\n    for (int i = 0; i < tripsSize; i++) {\n        locations[trips[i][1]] += trips[i][0];\n        locations[trips[i][2]] -= trips[i][0];\n    }\n    for (int i = 0; i < 1001; i++) {\n        capacity -= locations[i];\n        if (capacity < 0) {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool carPooling(int** trips, int tripsSize, int* tripsColSize, int capacity"}
{"id": "1112", "path": "output2\\c\\Medium\\1112-path-in-zigzag-labelled-binary-tree.c", "hypo_code": "int* pathInZigZagTree(int label, int* returnSize){\nint* res = (int*)malloc(sizeof(int) * 100);\n    *returnSize = 0;\n    int level = 1;\n    while (1 << level <= label) {\n        level++;\n    }\n    while (label > 1) {\n        res[(*returnSize)++] = label;\n        label = (1 << level) - 1 - label + (1 << (level - 1));\n        label /= 2;\n        level--;\n    }\n    res[(*returnSize)++] = 1;\n    for (int i = 0; i < *returnSize / 2; i++) {\n        int temp = res[i];\n        res[i] = res[*returnSize - 1 - i];\n        res[*returnSize - 1 - i] = temp;\n    }\n    return res;\n}", "prefix": "int* pathInZigZagTree(int label, int* returnSize"}
{"id": "1113", "path": "output2\\c\\Medium\\1113-filling-bookcase-shelves.c", "hypo_code": "int minHeightShelves(int** books, int booksSize, int* booksColSize, int shelfWidth){\nint *dp = (int *)malloc(sizeof(int) * (booksSize + 1));\n    dp[0] = 0;\n    for (int i = 1; i <= booksSize; ++i) {\n        dp[i] = dp[i - 1] + books[i - 1][1];\n        int width = books[i - 1][0];\n        int height = books[i - 1][1];\n        for (int j = i - 1; j > 0 && width + books[j - 1][0] <= shelfWidth; --j) {\n            height = fmax(height, books[j - 1][1]);\n            width += books[j - 1][0];\n            dp[i] = fmin(dp[i], dp[j - 1] + height);\n        }\n    }\n    return dp[booksSize];\n}", "prefix": "int minHeightShelves(int** books, int booksSize, int* booksColSize, int shelfWidth"}
{"id": "1114", "path": "output2\\c\\Medium\\1114-corporate-flight-bookings.c", "hypo_code": "int* corpFlightBookings(int** bookings, int bookingsSize, int* bookingsColSize, int n, int* returnSize){\nint *res = (int *)malloc(sizeof(int) * n);\n    memset(res, 0, sizeof(int) * n);\n    for (int i = 0; i < bookingsSize; ++i) {\n        res[bookings[i][0] - 1] += bookings[i][2];\n        if (bookings[i][1] < n) {\n            res[bookings[i][1]] -= bookings[i][2];\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        res[i] += res[i - 1];\n    }\n    *returnSize = n;\n    return res;\n}", "prefix": "int* corpFlightBookings(int** bookings, int bookingsSize, int* bookingsColSize, int n, int* returnSize"}
{"id": "1115", "path": "output2\\c\\Medium\\1115-delete-nodes-and-return-forest.c", "hypo_code": "struct TreeNode** delNodes(struct TreeNode* root, int* to_delete, int to_deleteSize, int* returnSize){\nint *delete = (int *)malloc(sizeof(int) * 1001);\n    memset(delete, 0, sizeof(int) * 1001);\n    for (int i = 0; i < to_deleteSize; ++i) {\n        delete[to_delete[i]] = 1;\n    }\n    struct TreeNode **res = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * 1001);\n    *returnSize = 0;\n    if (!delete[root->val]) {\n        res[*returnSize] = root;\n        ++*returnSize;\n    }\n    dfs(root, delete, res, returnSize);\n    return res;\n}\nvoid dfs(struct TreeNode *root, int *delete, struct TreeNode **res, int *returnSize) {\n    if (!root) {\n        return;\n    }\n    if (delete[root->val]) {\n        if (root->left && !delete[root->left->val]) {\n            res[*returnSize] = root->left;\n            ++*returnSize;\n        }\n        if (root->right && !delete[root->right->val]) {\n            res[*returnSize] = root->right;\n            ++*returnSize;\n        }\n    }\n    dfs(root->left, delete, res, returnSize);\n    dfs(root->right, delete, res, returnSize);\n    if (root->left && delete[root->left->val]) {\n        root->left = NULL;\n    }\n    if (root->right && delete[root->right->val]) {\n        root->right = NULL;\n    }\n}", "prefix": "struct TreeNode** delNodes(struct TreeNode* root, int* to_delete, int to_deleteSize, int* returnSize"}
{"id": "1116", "path": "output2\\c\\Medium\\1116-maximum-nesting-depth-of-two-valid-parentheses-strings.c", "hypo_code": "int* maxDepthAfterSplit(char * seq, int* returnSize){\n*returnSize = strlen(seq);\n    int *res = (int *)malloc(sizeof(int) * (*returnSize));\n    int depth = 0;\n    for (int i = 0; i < *returnSize; ++i) {\n        if (seq[i] == '(') {\n            ++depth;\n            res[i] = depth % 2;\n        } else {\n            res[i] = depth % 2;\n            --depth;\n        }\n    }\n    return res;\n}", "prefix": "int* maxDepthAfterSplit(char * seq, int* returnSize"}
{"id": "1120", "path": "output2\\c\\Medium\\1120-lowest-common-ancestor-of-deepest-leaves.c", "hypo_code": "struct TreeNode* lcaDeepestLeaves(struct TreeNode* root){\nstruct TreeNode *res;\n    int depth = 0;\n    dfs(root, &res, &depth);\n    return res;\n}\nint dfs(struct TreeNode *root, struct TreeNode **res, int *depth) {\n    if (!root) {\n        *depth = 0;\n        return 0;\n    }\n    int leftDepth, rightDepth;\n    struct TreeNode *leftRes = NULL, *rightRes = NULL;\n    leftDepth = dfs(root->left, &leftRes, &leftDepth);\n    rightDepth = dfs(root->right, &rightRes, &rightDepth);\n    *depth = fmax(leftDepth, rightDepth) + 1;\n    if (leftDepth == rightDepth) {\n        *res = root;\n    } else if (leftDepth > rightDepth) {\n        *res = leftRes;\n    } else {\n        *res = rightRes;\n    }\n    return *depth;\n}", "prefix": "struct TreeNode* lcaDeepestLeaves(struct TreeNode* root"}
{"id": "1121", "path": "output2\\c\\Medium\\1121-longest-well-performing-interval.c", "hypo_code": "int longestWPI(int* hours, int hoursSize){\nint *dp = (int *)malloc(sizeof(int) * (hoursSize + 1));\n    memset(dp, 0, sizeof(int) * (hoursSize + 1));\n    int res = 0;\n    for (int i = 1; i <= hoursSize; ++i) {\n        dp[i] = dp[i - 1] + (hours[i - 1] > 8 ? 1 : -1);\n        if (dp[i] > 0) {\n            res = i;\n        }\n    }\n    for (int i = hoursSize; i > res; --i) {\n        if (dp[i] > dp[res]) {\n            res = i;\n        }\n    }\n    return res;\n}", "prefix": "int longestWPI(int* hours, int hoursSize"}
{"id": "1122", "path": "output2\\c\\Medium\\1122-shortest-path-with-alternating-colors.c", "hypo_code": "int* shortestAlternatingPaths(int n, int** redEdges, int redEdgesSize, int* redEdgesColSize, int** blueEdges, int blueEdgesSize, int* blueEdgesColSize, int* returnSize){\nint **red = (int **)malloc(sizeof(int *) * n);\n    for (int i = 0; i < n; ++i) {\n        red[i] = (int *)malloc(sizeof(int) * n);\n        memset(red[i], 0, sizeof(int) * n);\n    }\n    for (int i = 0; i < redEdgesSize; ++i) {\n        red[redEdges[i][0]][redEdges[i][1]] = 1;\n    }\n    int **blue = (int **)malloc(sizeof(int *) * n);\n    for (int i = 0; i < n; ++i) {\n        blue[i] = (int *)malloc(sizeof(int) * n);\n        memset(blue[i], 0, sizeof(int) * n);\n    }\n    for (int i = 0; i < blueEdgesSize; ++i) {\n        blue[blueEdges[i][0]][blueEdges[i][1]] = 1;\n    }\n    int *res = (int *)malloc(sizeof(int) * n);\n    memset(res, -1, sizeof(int) * n);\n    res[0] = 0;\n    int *queue = (int *)malloc(sizeof(int) * n);\n    int queueSize = 0;\n    int *visited = (int *)malloc(sizeof(int) * n);\n    memset(visited, 0, sizeof(int) * n);\n    queue[queueSize++] = 0;\n    visited[0] = 1;\n    while (queueSize) {\n        int cur = queue[0];\n        for (int i = 0; i < queueSize - 1; ++i) {\n            queue[i] = queue[i + 1];\n        }\n        --queueSize;\n        for (int i = 0; i < n; ++i) {\n            if (red[cur][i] && !visited[i]) {\n                queue[queueSize++] = i;\n                visited[i] = 1;\n                res[i] = res[cur] + 1;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (blue[cur][i] && !visited[i]) {\n                queue[queueSize++] = i;\n                visited[i] = 1;\n                res[i] = res[cur] + 1;\n            }\n        }\n    }\n    *returnSize = n;\n    return res;\n}", "prefix": "int* shortestAlternatingPaths(int n, int** redEdges, int redEdgesSize, int* redEdgesColSize, int** blueEdges, int blueEdgesSize, int* blueEdgesColSize, int* returnSize"}
{"id": "1123", "path": "output2\\c\\Medium\\1123-minimum-cost-tree-from-leaf-values.c", "hypo_code": "int mctFromLeafValues(int* arr, int arrSize){\nint *stack = (int *)malloc(sizeof(int) * arrSize);\n    int top = -1;\n    int res = 0;\n    for (int i = 0; i < arrSize; ++i) {\n        while (top != -1 && arr[i] >= stack[top]) {\n            int mid = stack[top--];\n            if (top == -1) {\n                res += mid * arr[i];\n            } else {\n                res += mid * fmin(arr[i], stack[top]);\n            }\n        }\n        stack[++top] = arr[i];\n    }\n    while (top != -1) {\n        int mid = stack[top--];\n        if (top == -1) {\n            res += mid * 0;\n        } else {\n            res += mid * stack[top];\n        }\n    }\n    return res;\n}", "prefix": "int mctFromLeafValues(int* arr, int arrSize"}
{"id": "1124", "path": "output2\\c\\Medium\\1124-maximum-of-absolute-value-expression.c", "hypo_code": "int maxAbsValExpr(int* arr1, int arr1Size, int* arr2, int arr2Size){\nint *A = (int *)malloc(sizeof(int) * arr1Size);\n    int *B = (int *)malloc(sizeof(int) * arr1Size);\n    int *C = (int *)malloc(sizeof(int) * arr1Size);\n    int *D = (int *)malloc(sizeof(int) * arr1Size);\n    for (int i = 0; i < arr1Size; ++i) {\n        A[i] = arr1[i] + arr2[i] + i;\n        B[i] = arr1[i] - arr2[i] + i;\n        C[i] = arr1[i] + arr2[i] - i;\n        D[i] = arr1[i] - arr2[i] - i;\n    }\n    int res = 0;\n    int minA = A[0], maxA = A[0];\n    int minB = B[0], maxB = B[0];\n    int minC = C[0], maxC = C[0];\n    int minD = D[0], maxD = D[0];\n    for (int i = 1; i < arr1Size; ++i) {\n        res = fmax(res, A[i] - minA);\n        res = fmax(res, maxA - A[i]);\n        res = fmax(res, B[i] - minB);\n        res = fmax(res, maxB - B[i]);\n        res = fmax(res, C[i] - minC);\n        res = fmax(res, maxC - C[i]);\n        res = fmax(res, D[i] - minD);\n        res = fmax(res, maxD - D[i]);\n        minA = fmin(minA, A[i]);\n        maxA = fmax(maxA, A[i]);\n        minB = fmin(minB, B[i]);\n        maxB = fmax(maxB, B[i]);\n        minC = fmin(minC, C[i]);\n        maxC = fmax(maxC, C[i]);\n        minD = fmin(minD, D[i]);\n        maxD = fmax(maxD, D[i]);\n    }\n    return res;\n}", "prefix": "int maxAbsValExpr(int* arr1, int arr1Size, int* arr2, int arr2Size"}
{"id": "1125", "path": "output2\\c\\Medium\\1125-alphabet-board-path.c", "hypo_code": "char * alphabetBoardPath(char * target){\nint len = strlen(target);\n    char *res = (char *)malloc(sizeof(char) * (len * 5 + 1));\n    int size = 0;\n    int curX = 0, curY = 0;\n    for (int i = 0; i < len; ++i) {\n        int targetX = (target[i] - 'a') % 5;\n        int targetY = (target[i] - 'a') / 5;\n        if (curX < targetX) {\n            for (int j = 0; j < targetX - curX; ++j) {\n                res[size++] = 'R';\n            }\n        } else if (curX > targetX) {\n            for (int j = 0; j < curX - targetX; ++j) {\n                res[size++] = 'L';\n            }\n        }\n        if (curY < targetY) {\n            for (int j = 0; j < targetY - curY; ++j) {\n                res[size++] = 'D';\n            }\n        } else if (curY > targetY) {\n            for (int j = 0; j < curY - targetY; ++j) {\n                res[size++] = 'U';\n            }\n        }\n        curX = targetX;\n        curY = targetY;\n        res[size++] = '!';\n    }\n    res[size] = '\\0';\n    return res;\n}", "prefix": "char * alphabetBoardPath(char * target"}
{"id": "1126", "path": "output2\\c\\Medium\\1126-largest-1-bordered-square.c", "hypo_code": "int largest1BorderedSquare(int** grid, int gridSize, int* gridColSize){\nint m = gridSize, n = gridColSize[0];\n    int **left = (int **)malloc(sizeof(int *) * m);\n    for (int i = 0; i < m; ++i) {\n        left[i] = (int *)malloc(sizeof(int) * n);\n        memset(left[i], 0, sizeof(int) * n);\n    }\n    int **up = (int **)malloc(sizeof(int *) * m);\n    for (int i = 0; i < m; ++i) {\n        up[i] = (int *)malloc(sizeof(int) * n);\n        memset(up[i], 0, sizeof(int) * n);\n    }\n    for (int i = 0; i < m; ++i) {\n        left[i][0] = grid[i][0];\n        for (int j = 1; j < n; ++j) {\n            if (grid[i][j]) {\n                left[i][j] = left[i][j - 1] + 1;\n            }\n        }\n        up[i][0] = grid[i][0];\n    }\n    for (int j = 0; j < n; ++j) {\n        for (int i = 1; i < m; ++i) {\n            if (grid[i][j]) {\n                up[i][j] = up[i - 1][j] + 1;\n            }\n        }\n    }\n    int res = 0;\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = n - 1; j >= 0; --j) {\n            int len = fmin(left[i][j], up[i][j]);\n            while (len > res) {\n                if (left[i - len + 1][j] >= len && up[i][j - len + 1] >= len) {\n                    res = fmax(res, len);\n                }\n                --len;\n            }\n        }\n    }\n    return res * res;\n}", "prefix": "int largest1BorderedSquare(int** grid, int gridSize, int* gridColSize"}
{"id": "1127", "path": "output2\\c\\Medium\\1127-stone-game-ii.c", "hypo_code": "int stoneGameII(int* piles, int pilesSize){\nint *dp = (int *)malloc(sizeof(int) * (pilesSize + 1));\n    memset(dp, 0, sizeof(int) * (pilesSize + 1));\n    for (int i = pilesSize - 1; i >= 0; --i) {\n        dp[i] = dp[i + 1] + piles[i];\n    }\n    for (int i = pilesSize - 1; i >= 0; --i) {\n        for (int j = 1; j <= 2 * pilesSize; ++j) {\n            if (i + j >= pilesSize) {\n                dp[i] = fmax(dp[i], dp[pilesSize]);\n            } else {\n                dp[i] = fmax(dp[i], dp[i + j] - dp[i]);\n            }\n        }\n    }\n    return dp[0];\n}", "prefix": "int stoneGameII(int* piles, int pilesSize"}
{"id": "1128", "path": "output2\\c\\Medium\\1128-longest-common-subsequence.c", "hypo_code": "int longestCommonSubsequence(char * text1, char * text2){\nint len1 = strlen(text1);\n    int len2 = strlen(text2);\n    int **dp = (int **)malloc(sizeof(int *) * (len1 + 1));\n    for (int i = 0; i <= len1; ++i) {\n        dp[i] = (int *)malloc(sizeof(int) * (len2 + 1));\n        memset(dp[i], 0, sizeof(int) * (len2 + 1));\n    }\n    for (int i = 1; i <= len1; ++i) {\n        for (int j = 1; j <= len2; ++j) {\n            dp[i][j] = fmax(dp[i - 1][j], dp[i][j - 1]);\n            if (text1[i - 1] == text2[j - 1]) {\n                dp[i][j] = fmax(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[len1][len2];\n}", "prefix": "int longestCommonSubsequence(char * text1, char * text2"}
{"id": "1129", "path": "output2\\c\\Medium\\1129-decrease-elements-to-make-array-zigzag.c", "hypo_code": "int movesToMakeZigzag(int* nums, int numsSize){\nint res1 = 0, res2 = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        int l = (i == 0 ? 1001 : nums[i - 1]);\n        int r = (i == numsSize - 1 ? 1001 : nums[i + 1]);\n        int need = fmin(l, r) - 1;\n        if (nums[i] >= need) {\n            continue;\n        }\n        res1 += need - nums[i];\n    }\n    for (int i = 0; i < numsSize; ++i) {\n        int l = (i == 0 ? 1001 : nums[i - 1]);\n        int r = (i == numsSize - 1 ? 1001 : nums[i + 1]);\n        int need = fmin(l, r) - 1;\n        if (nums[i] <= need) {\n            continue;\n        }\n        res2 += nums[i] - need;\n    }\n    return fmin(res1, res2);\n}", "prefix": "int movesToMakeZigzag(int* nums, int numsSize"}
{"id": "1130", "path": "output2\\c\\Medium\\1130-binary-tree-coloring-game.c", "hypo_code": "bool btreeGameWinningMove(struct TreeNode* root, int n, int x){\nint left = 0, right = 0;\n    count(root, x, &left, &right);\n    return fmax(fmax(left, right), n - left - right - 1) > n / 2;\n}\nint count(struct TreeNode *root, int x, int *left, int *right) {\n    if (!root) {\n        return 0;\n    }\n    int l = count(root->left, x, left, right);\n    int r = count(root->right, x, left, right);\n    if (root->val == x) {\n        *left = l;\n        *right = r;\n    }\n    return l + r + 1;\n}", "prefix": "bool btreeGameWinningMove(struct TreeNode* root, int n, int x"}
{"id": "1132", "path": "output2\\c\\Medium\\1132-number-of-dice-rolls-with-target-sum.c", "hypo_code": "int numRollsToTarget(int n, int k, int target){\nint *dp = (int *)malloc(sizeof(int) * (target + 1));\n    memset(dp, 0, sizeof(int) * (target + 1));\n    dp[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = target; j >= 0; --j) {\n            dp[j] = 0;\n            for (int p = 1; p <= k; ++p) {\n                if (j - p < 0) {\n                    break;\n                }\n                dp[j] = (dp[j] + dp[j - p]) % 1000000007;\n            }\n        }\n    }\n    return dp[target];\n}", "prefix": "int numRollsToTarget(int n, int k, int target"}
{"id": "1133", "path": "output2\\c\\Medium\\1133-swap-for-longest-repeated-character-substring.c", "hypo_code": "int maxRepOpt1(char * text){\nint *count = (int *)malloc(sizeof(int) * 26);\n    memset(count, 0, sizeof(int) * 26);\n    int **dp = (int **)malloc(sizeof(int *) * 26);\n    for (int i = 0; i < 26; ++i) {\n        dp[i] = (int *)malloc(sizeof(int) * 2);\n        memset(dp[i], 0, sizeof(int) * 2);\n    }\n    int len = strlen(text);\n    for (int i = 0; i < len; ++i) {\n        ++count[text[i] - 'a'];\n    }\n    int res = 0;\n    for (int i = 0; i < 26; ++i) {\n        int cur = 0;\n        dp[i][0] = dp[i][1] = 0;\n        for (int j = 0; j < len; ++j) {\n            if (text[j] == i + 'a') {\n                ++cur;\n            } else {\n                dp[i][1] = dp[i][0];\n                dp[i][0] = cur;\n                cur = 0;\n            }\n            res = fmax(res, dp[i][0] + dp[i][1] + (count[i] > dp[i][0] + dp[i][1] ? 1 : 0));\n        }\n    }\n    return res;\n}", "prefix": "int maxRepOpt1(char * text"}
{"id": "1135", "path": "output2\\c\\Medium\\1135-maximum-level-sum-of-a-binary-tree.c", "hypo_code": "int maxLevelSum(struct TreeNode* root){\nint maxSum = INT_MIN, maxLevel = 0, level = 0;\n    struct TreeNode *node;\n    struct TreeNode **queue = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * 10000);\n    int front = 0, rear = 0, size = 0;\n    queue[rear++] = root;\n    ++size;\n    while (size > 0) {\n        ++level;\n        int sum = 0;\n        for (int i = 0; i < size; ++i) {\n            node = queue[front++];\n            sum += node->val;\n            if (node->left) {\n                queue[rear++] = node->left;\n            }\n            if (node->right) {\n                queue[rear++] = node->right;\n            }\n        }\n        if (sum > maxSum) {\n            maxSum = sum;\n            maxLevel = level;\n        }\n        size = rear - front;\n    }\n    return maxLevel;\n}", "prefix": "int maxLevelSum(struct TreeNode* root"}
{"id": "1136", "path": "output2\\c\\Medium\\1136-as-far-from-land-as-possible.c", "hypo_code": "int maxDistance(int** grid, int gridSize, int* gridColSize){\n\n}", "prefix": "int maxDistance(int** grid, int gridSize, int* gridColSize"}
{"id": "1138", "path": "output2\\c\\Medium\\1138-invalid-transactions.c", "hypo_code": "char ** invalidTransactions(char ** transactions, int transactionsSize, int* returnSize){\n   *returnSize = 0;\n    char **res = (char **)malloc(sizeof(char *) * transactionsSize);\n    int *invalid = (int *)malloc(sizeof(int) * transactionsSize);\n    memset(invalid, 0, sizeof(int) * transactionsSize);\n    for (int i = 0; i < transactionsSize; ++i) {\n        char *name = (char *)malloc(sizeof(char) * 11);\n        char *time = (char *)malloc(sizeof(char) * 4);\n        char *amount = (char *)malloc(sizeof(char) * 5);\n        char *city = (char *)malloc(sizeof(char) * 11);\n        sscanf(transactions[i], \"%[^,],%[^,],%[^,],%[^,]\", name, time, amount, city);\n        if (atoi(amount) > 1000) {\n            invalid[i] = 1;\n        }\n        for (int j = 0; j < transactionsSize; ++j) {\n            if (i == j) {\n                continue;\n            }\n            char *name1 = (char *)malloc(sizeof(char) * 11);\n            char *time1 = (char *)malloc(sizeof(char) * 4);\n            char *amount1 = (char *)malloc(sizeof(char) * 5);\n            char *city1 = (char *)malloc(sizeof(char) * 11);\n            sscanf(transactions[j], \"%[^,],%[^,],%[^,],%[^,]\", name1, time1, amount1, city1);\n            if (strcmp(name, name1) == 0 && strcmp(city, city1) != 0 && abs(atoi(time) - atoi(time1)) <= 60) {\n                invalid[i] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < transactionsSize; ++i) {\n        if (invalid[i]) {\n            res[*returnSize] = (char *)malloc(sizeof(char) * 101);\n            strcpy(res[*returnSize], transactions[i]);\n            ++*returnSize;\n        }\n    }\n    return res;\n}", "prefix": "char ** invalidTransactions(char ** transactions, int transactionsSize, int* returnSize"}
{"id": "1139", "path": "output2\\c\\Medium\\1139-compare-strings-by-frequency-of-the-smallest-character.c", "hypo_code": "int* numSmallerByFrequency(char ** queries, int queriesSize, char ** words, int wordsSize, int* returnSize){\n  int *res = (int *)malloc(sizeof(int) * queriesSize);\n    int *count = (int *)malloc(sizeof(int) * wordsSize);\n    for (int i = 0; i < wordsSize; ++i) {\n        count[i] = 0;\n        char min = 'z';\n        for (int j = 0; j < strlen(words[i]); ++j) {\n            if (words[i][j] < min) {\n                min = words[i][j];\n                count[i] = 1;\n            } else if (words[i][j] == min) {\n                ++count[i];\n            }\n        }\n    }\n    for (int i = 0; i < queriesSize; ++i) {\n        res[i] = 0;\n        char min = 'z';\n        int cnt = 0;\n        for (int j = 0; j < strlen(queries[i]); ++j) {\n            if (queries[i][j] < min) {\n                min = queries[i][j];\n                cnt = 1;\n            } else if (queries[i][j] == min) {\n                ++cnt;\n            }\n        }\n        for (int j = 0; j < wordsSize; ++j) {\n            if (cnt < count[j]) {\n                ++res[i];\n            }\n        }\n    }\n    *returnSize = queriesSize;\n    return res;\n}", "prefix": "int* numSmallerByFrequency(char ** queries, int queriesSize, char ** words, int wordsSize, int* returnSize"}
{"id": "1140", "path": "output2\\c\\Medium\\1140-remove-zero-sum-consecutive-nodes-from-linked-list.c", "hypo_code": "struct ListNode* removeZeroSumSublists(struct ListNode* head){\nstruct ListNode *dummy = (struct ListNode *)malloc(sizeof(struct ListNode));\n    dummy->next = head;\n    struct ListNode *node = dummy;\n    while (node) {\n        int sum = 0;\n        struct ListNode *tmp = node->next;\n        while (tmp) {\n            sum += tmp->val;\n            if (sum == 0) {\n                node->next = tmp->next;\n                break;\n            }\n            tmp = tmp->next;\n        }\n        if (!tmp) {\n            node = node->next;\n        }\n    }\n    return dummy->next;\n}", "prefix": "struct ListNode* removeZeroSumSublists(struct ListNode* head"}
{"id": "1142", "path": "output2\\c\\Medium\\1142-can-make-palindrome-from-substring.c", "hypo_code": "bool* canMakePaliQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nint *count = (int *)malloc(sizeof(int) * strlen(s));\n    memset(count, 0, sizeof(int) * strlen(s));\n    int **dp = (int **)malloc(sizeof(int *) * strlen(s));\n    for (int i = 0; i < strlen(s); ++i) {\n        dp[i] = (int *)malloc(sizeof(int) * 26);\n        memset(dp[i], 0, sizeof(int) * 26);\n    }\n    for (int i = 0; i < strlen(s); ++i) {\n        ++count[s[i] - 'a'];\n        for (int j = 0; j < 26; ++j) {\n            dp[i][j] = count[j];\n        }\n    }\n    bool *res = (bool *)malloc(sizeof(bool) * queriesSize);\n    for (int i = 0; i < queriesSize; ++i) {\n        int left = queries[i][0];\n        int right = queries[i][1];\n        int k = queries[i][2];\n        int odd = 0;\n        for (int j = 0; j < 26; ++j) {\n            if ((dp[right][j] - (left > 0 ? dp[left - 1][j] : 0)) % 2 == 1) {\n                ++odd;\n            }\n        }\n        res[i] = odd / 2 <= k;\n    }\n    *returnSize = queriesSize;\n    return res;\n}", "prefix": "bool* canMakePaliQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1143", "path": "output2\\c\\Medium\\1143-maximum-subarray-sum-with-one-deletion.c", "hypo_code": "int maximumSum(int* arr, int arrSize){\nint res = arr[0];\n    int *dp1 = (int *)malloc(sizeof(int) * arrSize);\n    int *dp2 = (int *)malloc(sizeof(int) * arrSize);\n    dp1[0] = arr[0];\n    dp2[0] = 0;\n    for (int i = 1; i < arrSize; ++i) {\n        dp1[i] = fmax(dp1[i - 1] + arr[i], arr[i]);\n        dp2[i] = fmax(dp1[i - 1], dp2[i - 1] + arr[i]);\n        res = fmax(res, fmax(dp1[i], dp2[i]));\n    }\n    return res;\n}", "prefix": "int maximumSum(int* arr, int arrSize"}
{"id": "1144", "path": "output2\\c\\Medium\\1144-reverse-substrings-between-each-pair-of-parentheses.c", "hypo_code": "char * reverseParentheses(char * s){\nint len = strlen(s);\n    int *stack = (int *)malloc(sizeof(int) * len);\n    memset(stack, 0, sizeof(int) * len);\n    int top = 0;\n    int *next = (int *)malloc(sizeof(int) * len);\n    memset(next, 0, sizeof(int) * len);\n    for (int i = 0; i < len; ++i) {\n        if (s[i] == '(') {\n            stack[top++] = i;\n        } else if (s[i] == ')') {\n            next[i] = stack[top - 1];\n            next[stack[top - 1]] = i;\n            --top;\n        }\n    }\n    char *res = (char *)malloc(sizeof(char) * (len + 1));\n    memset(res, 0, sizeof(char) * (len + 1));\n    int pos = 0;\n    int add = 1;\n    for (int i = 0; i < len; i += add) {\n        if (s[i] == '(' || s[i] == ')') {\n            i = next[i];\n            add = -add;\n        } else {\n            res[pos++] = s[i];\n        }\n    }\n    return res;\n}", "prefix": "char * reverseParentheses(char * s"}
{"id": "1145", "path": "output2\\c\\Medium\\1145-k-concatenation-maximum-sum.c", "hypo_code": "int kConcatenationMaxSum(int* arr, int arrSize, int k){\nint *dp = (int *)malloc(sizeof(int) * (arrSize * 2 + 1));\n    memset(dp, 0, sizeof(int) * (arrSize * 2 + 1));\n    int res = 0;\n    int sum = 0;\n    for (int i = 0; i < arrSize; ++i) {\n        sum += arr[i];\n        dp[i + 1] = sum;\n        res = fmax(res, dp[i + 1]);\n    }\n    for (int i = arrSize; i < arrSize * 2; ++i) {\n        dp[i + 1] = dp[i + 1 - arrSize] + arr[i - arrSize];\n        res = fmax(res, dp[i + 1]);\n    }\n    if (sum > 0) {\n        res += (k - 2) * sum;\n    }\n    return res % 1000000007;\n}", "prefix": "int kConcatenationMaxSum(int* arr, int arrSize, int k"}
{"id": "1148", "path": "output2\\c\\Medium\\1148-ugly-number-iii.c", "hypo_code": "long gcd(long a, long b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\nint nthUglyNumber(int n, int a, int b, int c){\nlong ab = (long)a * b / gcd(a, b);\n    long ac = (long)a * c / gcd(a, c);\n    long bc = (long)b * c / gcd(b, c);\n    long abc = (long)a * bc / gcd(a, bc);\n    long low = 1, high = 2000000000;\n    while (low < high) {\n        long mid = low + (high - low) / 2;\n        long cnt = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;\n        if (cnt < n) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}", "prefix": "long gcd(long a, long b"}
{"id": "1149", "path": "output2\\c\\Medium\\1149-smallest-string-with-swaps.c", "hypo_code": "int cmp(const void *a, const void *b) {\n    return *(char *)a - *(char *)b;\n}\nint find(int *parent, int index) {\n    while (index != parent[index]) {\n        parent[index] = parent[parent[index]];\n        index = parent[index];\n    }\n    return index;\n}\nchar * smallestStringWithSwaps(char * s, int** pairs, int pairsSize, int* pairsColSize){\nint *parent = (int *)malloc(sizeof(int) * strlen(s));\n    for (int i = 0; i < strlen(s); ++i) {\n        parent[i] = i;\n    }\n    for (int i = 0; i < pairsSize; ++i) {\n        int root1 = find(parent, pairs[i][0]);\n        int root2 = find(parent, pairs[i][1]);\n        if (root1 != root2) {\n            parent[root1] = root2;\n        }\n    }\n    int **group = (int **)malloc(sizeof(int *) * strlen(s));\n    for (int i = 0; i < strlen(s); ++i) {\n        group[i] = (int *)malloc(sizeof(int) * 2);\n        memset(group[i], 0, sizeof(int) * 2);\n    }\n    for (int i = 0; i < strlen(s); ++i) {\n        int root = find(parent, i);\n        ++group[root][0];\n        group[root][1] += s[i];\n    }\n    for (int i = 0; i < strlen(s); ++i) {\n        if (group[i][0] > 0) {\n            qsort(s + i, group[i][0], sizeof(char), cmp);\n            for (int j = 0; j < group[i][0]; ++j) {\n                s[i + j] = group[i][1] % 256;\n                group[i][1] /= 256;\n            }\n        }\n    }\n    return s;\n}", "prefix": "int cmp(const void *a, const void *b"}
{"id": "1151", "path": "output2\\c\\Medium\\1151-get-equal-substrings-within-budget.c", "hypo_code": "int equalSubstring(char * s, char * t, int maxCost){\nint len = strlen(s);\n    int *diff = (int *)malloc(sizeof(int) * len);\n    for (int i = 0; i < len; ++i) {\n        diff[i] = abs(s[i] - t[i]);\n    }\n    int res = 0;\n    int left = 0, right = 0;\n    int cur = 0;\n    while (right < len) {\n        cur += diff[right];\n        ++right;\n        while (cur > maxCost) {\n            cur -= diff[left];\n            ++left;\n        }\n        res = fmax(res, right - left);\n    }\n    return res;\n}", "prefix": "int equalSubstring(char * s, char * t, int maxCost"}
{"id": "1152", "path": "output2\\c\\Medium\\1152-remove-all-adjacent-duplicates-in-string-ii.c", "hypo_code": "char * removeDuplicates(char * s, int k){\nint len = strlen(s);\n    char *stack = (char *)malloc(sizeof(char) * (len + 1));\n    int top = 0;\n    for (int i = 0; i < len; ++i) {\n        if (top > 0 && stack[top - 1] == s[i]) {\n            ++stack[top++];\n            if (stack[top - 1] == k) {\n                top -= k;\n            }\n        } else {\n            stack[top++] = s[i];\n        }\n    }\n    stack[top] = '\\0';\n    return stack;\n}", "prefix": "char * removeDuplicates(char * s, int k"}
{"id": "1153", "path": "output2\\c\\Medium\\1153-longest-arithmetic-subsequence-of-given-difference.c", "hypo_code": "int longestSubsequence(int* arr, int arrSize, int difference){\nint res = 0;\n    int *dp = (int *)malloc(sizeof(int) * 20001);\n    memset(dp, 0, sizeof(int) * 20001);\n    for (int i = 0; i < arrSize; ++i) {\n        dp[arr[i] + 10000] = dp[arr[i] - difference + 10000] + 1;\n        res = fmax(res, dp[arr[i] + 10000]);\n    }\n    return res;\n}", "prefix": "int longestSubsequence(int* arr, int arrSize, int difference"}
{"id": "1154", "path": "output2\\c\\Medium\\1154-path-with-maximum-gold.c", "hypo_code": "void dfs(int **grid, int **visited, int m, int n, int i, int j, int sum, int *res) {\n        if (i < 0 || i >= m || j < 0 || j >= n || !grid[i][j] || visited[i][j]) {\n            return;\n        }\n        sum += grid[i][j];\n        if (sum > *res) {\n            *res = sum;\n        }\n        visited[i][j] = 1;\n        dfs(grid, visited, m, n, i - 1, j, sum, res);\n        dfs(grid, visited, m, n, i + 1, j, sum, res);\n        dfs(grid, visited, m, n, i, j - 1, sum, res);\n        dfs(grid, visited, m, n, i, j + 1, sum, res);\n        visited[i][j] = 0;\n    }\nint getMaximumGold(int** grid, int gridSize, int* gridColSize){\nint m = gridSize, n = gridColSize[0];\n    int res = 0;\n    int **visited = (int **)malloc(sizeof(int *) * m);\n    for (int i = 0; i < m; ++i) {\n        visited[i] = (int *)malloc(sizeof(int) * n);\n        memset(visited[i], 0, sizeof(int) * n);\n    }\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j){\n            if (grid[i][j]) {\n                dfs(grid, visited, m, n, i, j, 0, &res);\n            }\n        }\n    }\n    return res;\n}", "prefix": "void dfs(int **grid, int **visited, int m, int n, int i, int j, int sum, int *res"}
{"id": "1155", "path": "output2\\c\\Medium\\1155-queens-that-can-attack-the-king.c", "hypo_code": "int** queensAttacktheKing(int** queens, int queensSize, int* queensColSize, int* king, int kingSize, int* returnSize, int** returnColumnSizes){\nint **res = (int **)malloc(sizeof(int *) * 8);\n    for (int i = 0; i < 8; ++i) {\n        res[i] = (int *)malloc(sizeof(int) * 2);\n        memset(res[i], 0, sizeof(int) * 2);\n    }\n    int **board = (int **)malloc(sizeof(int *) * 8);\n    for (int i = 0; i < 8; ++i) {\n        board[i] = (int *)malloc(sizeof(int) * 8);\n        memset(board[i], 0, sizeof(int) * 8);\n    }\n    for (int i = 0; i < queensSize; ++i) {\n        board[queens[i][0]][queens[i][1]] = 1;\n    }\n    int dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, \n                     {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n    int count = 0;\n    for (int i = 0; i < 8; ++i) {\n        int x = king[0];\n        int y = king[1];\n        while (x >= 0 && x < 8 && y >= 0 && y < 8) {\n            if (board[x][y]) {\n                res[count][0] = x;\n                res[count][1] = y;\n                ++count;\n                break;\n            }\n            x += dir[i][0];\n            y += dir[i][1];\n        }\n    }\n    *returnSize = count;\n    *returnColumnSizes = (int *)malloc(sizeof(int) * count);\n    for (int i = 0; i < count; ++i) {\n        (*returnColumnSizes)[i] = 2;\n    }\n    return res;\n}", "prefix": "int** queensAttacktheKing(int** queens, int queensSize, int* queensColSize, int* king, int kingSize, int* returnSize, int** returnColumnSizes"}
{"id": "1157", "path": "output2\\c\\Medium\\1157-airplane-seat-assignment-probability.c", "hypo_code": "double nthPersonGetsNthSeat(int n){\nreturn n == 1 ? 1.0 : 0.5;\n}", "prefix": "double nthPersonGetsNthSeat(int n"}
{"id": "1158", "path": "output2\\c\\Medium\\1158-remove-sub-folders-from-the-filesystem.c", "hypo_code": "char ** removeSubfolders(char ** folder, int folderSize, int* returnSize){\n*returnSize = 0;\n    char **res = (char **)malloc(sizeof(char *) * folderSize);\n    int *delete = (int *)malloc(sizeof(int) * folderSize);\n    memset(delete, 0, sizeof(int) * folderSize);\n    for (int i = 0; i < folderSize; ++i) {\n        if (delete[i]) {\n            continue;\n        }\n        res[*returnSize] = folder[i];\n        ++*returnSize;\n        for (int j = i + 1; j < folderSize; ++j) {\n            if (delete[j]) {\n                continue;\n            }\n            if (strstr(folder[j], folder[i]) == folder[j]) {\n                delete[j] = 1;\n            }\n        }\n    }\n    return res;\n}", "prefix": "char ** removeSubfolders(char ** folder, int folderSize, int* returnSize"}
{"id": "1159", "path": "output2\\c\\Medium\\1159-replace-the-substring-for-balanced-string.c", "hypo_code": "int balancedString(char * s){\nint len = strlen(s);\n    int count[26] = {0};\n    int avg = len / 4;\n    for (int i = 0; i < len; ++i) {\n        ++count[s[i] - 'A'];\n    }\n    int left = 0, right = 0, res = len;\n    while (right < len) {\n        --count[s[right] - 'A'];\n        while (left < len && count['Q' - 'A'] <= avg && count['W' - 'A'] <= avg && count['E' - 'A'] <= avg && count['R' - 'A'] <= avg) {\n            res = fmin(res, right - left + 1);\n            ++count[s[left++] - 'A'];\n        }\n        ++right;\n    }\n    return res;\n}", "prefix": "int balancedString(char * s"}
{"id": "1160", "path": "output2\\c\\Medium\\1160-find-positive-integer-solution-for-a-given-equation.c", "hypo_code": "int** findSolution(int (*customFunction)(int, int), int z, int* returnSize, int** returnColumnSizes) {\n\tint **res = (int **)malloc(sizeof(int *) * 1000);\n    *returnSize = 0;\n    *returnColumnSizes = (int *)malloc(sizeof(int) * 1000);\n    for (int i = 1; i <= 1000; ++i) {\n        int left = 1;\n        int right = 1000;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (customFunction(i, mid) == z) {\n                res[*returnSize] = (int *)malloc(sizeof(int) * 2);\n                res[*returnSize][0] = i;\n                res[*returnSize][1] = mid;\n                ++*returnSize;\n                break;\n            } else if (customFunction(i, mid) > z) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        (*returnColumnSizes)[i - 1] = *returnSize;\n    }\n    return res;\n}", "prefix": "int** findSolution(int (*customFunction)(int, int), int z, int* returnSize, int** returnColumnSizes"}
{"id": "1161", "path": "output2\\c\\Medium\\1161-circular-permutation-in-binary-representation.c", "hypo_code": "int* circularPermutation(int n, int start, int* returnSize){\nint *res = (int *)malloc(sizeof(int) * (1 << n));\n    *returnSize = 1 << n;\n    res[0] = start;\n    int cur = 1;\n    for (int i = 0; i < n; ++i) {\n        int num = 1 << i;\n        for (int j = 0; j < num; ++j) {\n            res[cur] = res[cur - 1] ^ num;\n            ++cur;\n        }\n    }\n    return res;\n}", "prefix": "int* circularPermutation(int n, int start, int* returnSize"}
{"id": "1162", "path": "output2\\c\\Medium\\1162-maximum-length-of-a-concatenated-string-with-unique-characters.c", "hypo_code": "int maxLength(char ** arr, int arrSize){\nint res = 0;\n    int *dp = (int *)malloc(sizeof(int) * (1 << arrSize));\n    memset(dp, 0, sizeof(int) * (1 << arrSize));\n    for (int i = 0; i < arrSize; ++i) {\n        int mask = 0;\n        int len = strlen(arr[i]);\n        for (int j = 0; j < len; ++j) {\n            mask |= (1 << (arr[i][j] - 'a'));\n        }\n        if (__builtin_popcount(mask) != len) {\n            continue;\n        }\n        for (int j = (1 << arrSize) - 1; j >= 0; --j) {\n            if ((mask & j) != 0) {\n                continue;\n            }\n            dp[mask | j] = fmax(dp[mask | j], dp[j] + len);\n        }\n    }\n    for (int i = 0; i < (1 << arrSize); ++i) {\n        res = fmax(res, dp[i]);\n    }\n    return res;\n}", "prefix": "int maxLength(char ** arr, int arrSize"}
{"id": "1163", "path": "output2\\c\\Medium\\1163-minimum-swaps-to-make-strings-equal.c", "hypo_code": "int minimumSwap(char * s1, char * s2){\nint len = strlen(s1);\n    int xy = 0, yx = 0;\n    for (int i = 0; i < len; ++i) {\n        if (s1[i] == 'x' && s2[i] == 'y') {\n            ++xy;\n        } else if (s1[i] == 'y' && s2[i] == 'x') {\n            ++yx;\n        }\n    }\n    if ((xy + yx) % 2) {\n        return -1;\n    }\n    return xy / 2 + yx / 2 + (xy % 2) * 2;\n}", "prefix": "int minimumSwap(char * s1, char * s2"}
{"id": "1164", "path": "output2\\c\\Medium\\1164-count-number-of-nice-subarrays.c", "hypo_code": "int numberOfSubarrays(int* nums, int numsSize, int k){\nint *dp = (int *)malloc(sizeof(int) * (numsSize + 1));\n    memset(dp, 0, sizeof(int) * (numsSize + 1));\n    int res = 0;\n    int sum = 0;\n    dp[0] = 1;\n    for (int i = 0; i < numsSize; ++i) {\n        sum += nums[i] % 2;\n        if (sum - k >= 0) {\n            res += dp[sum - k];\n        }\n        dp[sum]++;\n    }\n    return res;\n}", "prefix": "int numberOfSubarrays(int* nums, int numsSize, int k"}
{"id": "1165", "path": "output2\\c\\Medium\\1165-minimum-remove-to-make-valid-parentheses.c", "hypo_code": "char * minRemoveToMakeValid(char * s){\nint len = strlen(s);\n    int *remove = (int *)malloc(sizeof(int) * len);\n    memset(remove, 0, sizeof(int) * len);\n    int *stack = (int *)malloc(sizeof(int) * len);\n    int top = 0;\n    for (int i = 0; i < len; ++i) {\n        if (s[i] == '(') {\n            stack[top++] = i;\n        } else if (s[i] == ')') {\n            if (top > 0) {\n                --top;\n            } else {\n                remove[i] = 1;\n            }\n        }\n    }\n    while (top > 0) {\n        remove[stack[--top]] = 1;\n    }\n    int count = 0;\n    for (int i = 0; i < len; ++i) {\n        if (remove[i] == 0) {\n            s[count++] = s[i];\n        }\n    }\n    s[count] = '\\0';\n    return s;\n}", "prefix": "char * minRemoveToMakeValid(char * s"}
{"id": "1166", "path": "output2\\c\\Medium\\1166-reconstruct-a-2-row-binary-matrix.c", "hypo_code": "int** reconstructMatrix(int upper, int lower, int* colsum, int colsumSize, int* returnSize, int** returnColumnSizes){\nint **res = (int **)malloc(sizeof(int *) * 2);\n    *returnSize = 0;\n    *returnColumnSizes = (int *)malloc(sizeof(int) * 2);\n    (*returnColumnSizes)[0] = colsumSize;\n    (*returnColumnSizes)[1] = colsumSize;\n    res[0] = (int *)malloc(sizeof(int) * colsumSize);\n    res[1] = (int *)malloc(sizeof(int) * colsumSize);\n    memset(res[0], 0, sizeof(int) * colsumSize);\n    memset(res[1], 0, sizeof(int) * colsumSize);\n    for (int i = 0; i < colsumSize; ++i) {\n        if (colsum[i] == 2) {\n            res[0][i] = 1;\n            res[1][i] = 1;\n            ++*returnSize;\n        }\n    }\n    for (int i = 0; i < colsumSize; ++i) {\n        if (colsum[i] == 1) {\n            if (upper > lower) {\n                res[0][i] = 1;\n                --upper;\n            } else {\n                res[1][i] = 1;\n                --lower;\n            }\n            ++*returnSize;\n        }\n    }\n    if (upper || lower) {\n        *returnSize = 0;\n        free(res[0]);\n        free(res[1]);\n        free(res);\n        res = NULL;\n    }\n    return res;\n}", "prefix": "int** reconstructMatrix(int upper, int lower, int* colsum, int colsumSize, int* returnSize, int** returnColumnSizes"}
{"id": "1167", "path": "output2\\c\\Medium\\1167-number-of-closed-islands.c", "hypo_code": "int closedIsland(int** grid, int gridSize, int* gridColSize){\nint m = gridSize, n = gridColSize[0];\n    int **visited = (int **)malloc(sizeof(int *) * m);\n    for (int i = 0; i < m; ++i) {\n        visited[i] = (int *)malloc(sizeof(int) * n);\n        memset(visited[i], 0, sizeof(int) * n);\n    }\n    int res = 0;\n    for (int i = 0; i < m; ++i) {\n        if (grid[i][0] == 0 && !visited[i][0]) {\n            dfs(grid, visited, m, n, i, 0);\n        }\n        if (grid[i][n - 1] == 0 && !visited[i][n - 1]) {\n            dfs(grid, visited, m, n, i, n - 1);\n        }\n    }\n    for (int j = 0; j < n; ++j) {\n        if (grid[0][j] == 0 && !visited[0][j]) {\n            dfs(grid, visited, m, n, 0, j);\n        }\n        if (grid[m - 1][j] == 0 && !visited[m - 1][j]) {\n            dfs(grid, visited, m, n, m - 1, j);\n        }\n    }\n    for (int i = 1; i < m - 1; ++i) {\n        for (int j = 1; j < n - 1; ++j) {\n            if (grid[i][j] == 0 && !visited[i][j]) {\n                dfs(grid, visited, m, n, i, j);\n                ++res;\n            }\n        }\n    }\n    return res;\n}\nvoid dfs(int **grid, int **visited, int m, int n, int i, int j) {\n    if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || grid[i][j] == 1) {\n        return;\n    }\n    visited[i][j] = 1;\n    dfs(grid, visited, m, n, i - 1, j);\n    dfs(grid, visited, m, n, i + 1, j);\n    dfs(grid, visited, m, n, i, j - 1);\n\n}", "prefix": "int closedIsland(int** grid, int gridSize, int* gridColSize"}
{"id": "1169", "path": "output2\\c\\Medium\\1169-greatest-sum-divisible-by-three.c", "hypo_code": "int maxSumDivThree(int* nums, int numsSize){\nint dp[3] = {0, -10001, -10001}, tmp[3];\n    for (int i = 0; i < numsSize; ++i) {\n        memcpy(tmp, dp, sizeof(int) * 3);\n        for (int j = 0; j < 3; ++j) {\n            dp[(tmp[j] + nums[i]) % 3] = fmax(dp[(tmp[j] + nums[i]) % 3], tmp[j] + nums[i]);\n        }\n    }\n    return dp[0];\n}", "prefix": "int maxSumDivThree(int* nums, int numsSize"}
{"id": "1170", "path": "output2\\c\\Medium\\1170-count-servers-that-communicate.c", "hypo_code": "int countServers(int** grid, int gridSize, int* gridColSize){\nint m = gridSize, n = gridColSize[0];\n    int *row = (int *)malloc(sizeof(int) * m);\n    memset(row, 0, sizeof(int) * m);\n    int *col = (int *)malloc(sizeof(int) * n);\n    memset(col, 0, sizeof(int) * n);\n    int res = 0;\n    for (int i = 0; i < m; ++i) {\n        row[i] = 0;\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                ++row[i];\n                ++col[j];\n                ++res;\n            }\n        }\n    }\n    for (int i = 0; i < m; ++i) {\n        if (row[i] == 1) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] && col[j] == 1) {\n                    --res;\n                }\n            }\n        }\n    }\n    return res;\n}", "prefix": "int countServers(int** grid, int gridSize, int* gridColSize"}
{"id": "1171", "path": "output2\\c\\Medium\\1171-search-suggestions-system.c", "hypo_code": "char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes){\nint *columnSizes = (int *)malloc(sizeof(int) * strlen(searchWord));\n    char ***res = (char ***)malloc(sizeof(char **) * strlen(searchWord));\n    for (int i = 0; i < strlen(searchWord); ++i) {\n        res[i] = (char **)malloc(sizeof(char *) * 3);\n        memset(res[i], 0, sizeof(char *) * 3);\n        columnSizes[i] = 0;\n    }\n    qsort(products, productsSize, sizeof(char *), cmp);\n    for (int i = 0; i < strlen(searchWord); ++i) {\n        int index = 0;\n        while (index < productsSize && products[index][i] < searchWord[i]) {\n            ++index;\n        }\n        int count = 0;\n        while (index < productsSize && count < 3 && products[index][i] == searchWord[i]) {\n            res[i][count] = products[index];\n            ++count;\n            ++index;\n        }\n        columnSizes[i] = count;\n    }\n    *returnSize = strlen(searchWord);\n    *returnColumnSizes = columnSizes;\n    return res;\n}", "prefix": "char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes"}
{"id": "1172", "path": "output2\\c\\Medium\\1172-number-of-burgers-with-no-waste-of-ingredients.c", "hypo_code": "int* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize){\n*returnSize = 0;\n    if (tomatoSlices % 2 || tomatoSlices < cheeseSlices * 2 || tomatoSlices > cheeseSlices * 4) {\n        return NULL;\n    }\n    int *res = (int *)malloc(sizeof(int) * 2);\n    res[0] = (tomatoSlices - cheeseSlices * 2) / 2;\n    res[1] = cheeseSlices - res[0];\n    *returnSize = 2;\n    return res;\n}", "prefix": "int* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize"}
{"id": "1173", "path": "output2\\c\\Medium\\1173-count-square-submatrices-with-all-ones.c", "hypo_code": "int countSquares(int** matrix, int matrixSize, int* matrixColSize){\nint m = matrixSize, n = matrixColSize[0];\n    int **dp = (int **)malloc(sizeof(int *) * m);\n    for (int i = 0; i < m; ++i) {\n        dp[i] = (int *)malloc(sizeof(int) * n);\n        memset(dp[i], 0, sizeof(int) * n);\n    }\n    int res = 0;\n    for (int i = 0; i < m; ++i) {\n        dp[i][0] = matrix[i][0];\n        res += dp[i][0];\n    }\n    for (int j = 1; j < n; ++j) {\n        dp[0][j] = matrix[0][j];\n        res += dp[0][j];\n    }\n    for (int i = 1; i < m; ++i) {\n        for (int j = 1; j < n; ++j) {\n            if (matrix[i][j]) {\n                dp[i][j] = fmin(dp[i - 1][j - 1], fmin(dp[i - 1][j], dp[i][j - 1])) + 1;\n                res += dp[i][j];\n            }\n        }\n    }\n    return res;\n}", "prefix": "int countSquares(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "1174", "path": "output2\\c\\Medium\\1174-group-the-people-given-the-group-size-they-belong-to.c", "hypo_code": "int** groupThePeople(int* groupSizes, int groupSizesSize, int* returnSize, int** returnColumnSizes){\nint **res = (int **)malloc(sizeof(int *) * groupSizesSize);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * groupSizesSize);\n    *returnSize = 0;\n    int *group = (int *)malloc(sizeof(int) * groupSizesSize);\n    memset(group, 0, sizeof(int) * groupSizesSize);\n    for (int i = 0; i < groupSizesSize; ++i) {\n        if (group[groupSizes[i]] == 0) {\n            res[*returnSize] = (int *)malloc(sizeof(int) * groupSizes[i]);\n            (*returnColumnSizes)[*returnSize] = groupSizes[i];\n            ++*returnSize;\n        }\n        res[groupSizes[i]][group[groupSizes[i]]] = i;\n        ++group[groupSizes[i]];\n    }\n    return res;\n\n}", "prefix": "int** groupThePeople(int* groupSizes, int groupSizesSize, int* returnSize, int** returnColumnSizes"}
{"id": "1175", "path": "output2\\c\\Medium\\1175-find-the-smallest-divisor-given-a-threshold.c", "hypo_code": "int smallestDivisor(int* nums, int numsSize, int threshold){\nint l = 1, r = 1000000;\n    while (l < r) {\n        int mid = l + (r - l) / 2;\n        int sum = 0;\n        for (int i = 0; i < numsSize; ++i) {\n            sum += (nums[i] + mid - 1) / mid;\n        }\n        if (sum > threshold) {\n            l = mid + 1;\n        } else {\n            r = mid;\n        }\n    }\n    return l;\n}", "prefix": "int smallestDivisor(int* nums, int numsSize, int threshold"}
{"id": "1177", "path": "output2\\c\\Medium\\1177-remove-covered-intervals.c", "hypo_code": "int removeCoveredIntervals(int** intervals, int intervalsSize, int* intervalsColSize){\n    int count = 0;\n    for(int i = 0; i < intervalsSize; i++){\n        int isCovered = 0;\n        for(int j = 0; j < intervalsSize; j++){\n            if(i == j){\n                continue;\n            }\n            if(intervals[i][0] >= intervals[j][0] && intervals[i][1] <= intervals[j][1]){\n                isCovered = 1;\n                break;\n            }\n        }\n        if(!isCovered){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int removeCoveredIntervals(int** intervals, int intervalsSize, int* intervalsColSize"}
{"id": "1178", "path": "output2\\c\\Medium\\1178-sequential-digits.c", "hypo_code": "int* sequentialDigits(int low, int high, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 100);\n    int count = 0;\n    int temp = 0;\n    int temp2 = 0;\n    int temp3 = 0;\n    int temp4 = 0;\n    int temp5 = 0;\n    int temp6 = 0;\n    int temp7 = 0;\n    int temp8 = 0;\n    int temp9 = 0;\n    int temp10 = 0;\n    int temp11 = 0;\n    int temp12 = 0;\n    int temp13 = 0;\n    int temp14 = 0;\n    int temp15 = 0;\n    int temp16 = 0;\n    int temp17 = 0;\n    int temp18 = 0;\n    int temp19 = 0;\n    int temp20 = 0;\n    int temp21 = 0;\n    int temp22 = 0;\n    int temp23 = 0;\n    int temp24 = 0;\n    int temp25 = 0;\n    int temp26 = 0;\n    int temp27 = 0;\n    int temp28 = 0;\n    int temp29 = 0;\n    int temp30 = 0;\n    int temp31 = 0;\n    int temp32 = 0;\n    int temp33 = 0;\n    int temp34 = 0;\n    int temp35 = 0;\n    int temp36 = 0;\n    int temp37 = 0;\n    int temp38 = 0;\n    int temp39 = 0;\n    int temp40 = 0;\n    int temp41 = 0;\n    int temp42 = 0;\n    int temp43 = 0;\n    int temp44 = 0;\n    int temp45 = 0;\n    int temp46 = 0;\n    int temp47 = 0;\n    int temp48 = 0;\n    int temp49 = 0;\n    int temp50 = 0;\n    int temp51 = 0;\n    int temp52 = 0;\n    int temp53 = 0;\n    int temp54 = 0;\n    int temp55 = 0;\n    int temp56 = 0;\n    int temp57 = 0;\n    int temp58 = 0;\n    int temp59 = 0;\n   \n}", "prefix": "int* sequentialDigits(int low, int high, int* returnSize"}
{"id": "1179", "path": "output2\\c\\Medium\\1179-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold.c", "hypo_code": "int maxSideLength(int** mat, int matSize, int* matColSize, int threshold){\n    int result = 0;\n    int** sum = (int**)malloc(sizeof(int*) * matSize);\n    for(int i = 0; i < matSize; i++){\n        sum[i] = (int*)malloc(sizeof(int) * matColSize[i]);\n        sum[i][0] = mat[i][0];\n        for(int j = 1; j < matColSize[i]; j++){\n            sum[i][j] = sum[i][j - 1] + mat[i][j];\n        }\n    }\n    for(int i = 0; i < matSize; i++){\n        for(int j = 0; j < matColSize[i]; j++){\n            int temp = 0;\n            int k = 0;\n            while(i + k < matSize && j + k < matColSize[i]){\n                temp += sum[i + k][j + k];\n                if(j > 0){\n                    temp -= sum[i + k][j - 1];\n                }\n                if(temp <= threshold){\n                    if(k + 1 > result){\n                        result = k + 1;\n                    }\n                }else{\n                    break;\n                }\n                k++;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int maxSideLength(int** mat, int matSize, int* matColSize, int threshold"}
{"id": "1180", "path": "output2\\c\\Medium\\1180-divide-array-in-sets-of-k-consecutive-numbers.c", "hypo_code": "bool isPossibleDivide(int* nums, int numsSize, int k){\n    if(numsSize % k != 0){\n        return false;\n    }\n    int* count = (int*)malloc(sizeof(int) * 100001);\n    for(int i = 0; i < 100001; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < numsSize; i++){\n        count[nums[i]]++;\n    }\n    for(int i = 0; i < 100001; i++){\n        if(count[i] > 0){\n            for(int j = 1; j < k; j++){\n                if(count[i + j] >= count[i]){\n                    count[i + j] -= count[i];\n                }else{\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n\n}", "prefix": "bool isPossibleDivide(int* nums, int numsSize, int k"}
{"id": "1181", "path": "output2\\c\\Medium\\1181-maximum-number-of-occurrences-of-a-substring.c", "hypo_code": "int maxFreq(char * s, int maxLetters, int minSize, int maxSize){\n    int result = 0;\n    int length = strlen(s);\n    int* count = (int*)malloc(sizeof(int) * 26);\n    int* map = (int*)malloc(sizeof(int) * 100000);\n    for(int i = 0; i < 100000; i++){\n        map[i] = 0;\n    }\n    for(int i = 0; i < length; i++){\n        int unique = 0;\n        for(int j = 0; j < 26; j++){\n            count[j] = 0;\n        }\n        for(int j = i; j < length; j++){\n            if(count[s[j] - 'a'] == 0){\n                unique++;\n            }\n            count[s[j] - 'a']++;\n            if(unique > maxLetters){\n                break;\n            }\n            if(j - i + 1 >= minSize && j - i + 1 <= maxSize){\n                map[(s[i] - 'a') * 10000 + (s[j] - 'a') * 100 + (j - i + 1)]++;\n                if(map[(s[i] - 'a') * 10000 + (s[j] - 'a') * 100 + (j - i + 1)] > result){\n                    result = map[(s[i] - 'a') * 10000 + (s[j] - 'a') * 100 + (j - i + 1)];\n                }\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int maxFreq(char * s, int maxLetters, int minSize, int maxSize"}
{"id": "1182", "path": "output2\\c\\Medium\\1182-sum-of-mutated-array-closest-to-target.c", "hypo_code": "int findBestValue(int* arr, int arrSize, int target){\n    int left = 0;\n    int right = 0;\n    for(int i = 0; i < arrSize; i++){\n        right = fmax(right, arr[i]);\n    }\n    while(left < right){\n        int mid = left + (right - left) / 2;\n        int sum = 0;\n        for(int i = 0; i < arrSize; i++){\n            sum += fmin(arr[i], mid);\n        }\n        if(sum < target){\n            left = mid + 1;\n        }else{\n            right = mid;\n        }\n    }\n    int sum1 = 0;\n    int sum2 = 0;\n    for(int i = 0; i < arrSize; i++){\n        sum1 += fmin(arr[i], left);\n        sum2 += fmin(arr[i], left - 1);\n    }\n    return fabs(sum1 - target) <= fabs(sum2 - target) ? left : left - 1;\n\n}", "prefix": "int findBestValue(int* arr, int arrSize, int target"}
{"id": "1183", "path": "output2\\c\\Medium\\1183-deepest-leaves-sum.c", "hypo_code": "int deepestLeavesSum(struct TreeNode* root){\n    int result = 0;\n    int maxDepth = 0;\n    struct TreeNode* queue[10000];\n    int queueSize = 0;\n    queue[queueSize++] = root;\n    while(queueSize > 0){\n        int size = queueSize;\n        queueSize = 0;\n        result = 0;\n        maxDepth++;\n        for(int i = 0; i < size; i++){\n            struct TreeNode* node = queue[i];\n            result += node->val;\n            if(node->left != NULL){\n                queue[queueSize++] = node->left;\n            }\n            if(node->right != NULL){\n                queue[queueSize++] = node->right;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int deepestLeavesSum(struct TreeNode* root"}
{"id": "1184", "path": "output2\\c\\Medium\\1184-all-elements-in-two-binary-search-trees.c", "hypo_code": "int* getAllElements(struct TreeNode* root1, struct TreeNode* root2, int* returnSize){\n    int* result = malloc(10000 * sizeof(int));\n    int resultSize = 0;\n    struct TreeNode* queue[10000];\n    int queueSize = 0;\n    queue[queueSize++] = root1;\n    while(queueSize > 0){\n        int size = queueSize;\n        queueSize = 0;\n        for(int i = 0; i < size; i++){\n            struct TreeNode* node = queue[i];\n            result[resultSize++] = node->val;\n            if(node->left != NULL){\n                queue[queueSize++] = node->left;\n            }\n            if(node->right != NULL){\n                queue[queueSize++] = node->right;\n            }\n        }\n    }\n    queue[queueSize++] = root2;\n    while(queueSize > 0){\n        int size = queueSize;\n        queueSize = 0;\n        for(int i = 0; i < size; i++){\n            struct TreeNode* node = queue[i];\n            result[resultSize++] = node->val;\n            if(node->left != NULL){\n                queue[queueSize++] = node->left;\n            }\n            if(node->right != NULL){\n                queue[queueSize++] = node->right;\n            }\n        }\n    }\n    *returnSize = resultSize;\n    return result;\n\n}", "prefix": "int* getAllElements(struct TreeNode* root1, struct TreeNode* root2, int* returnSize"}
{"id": "1185", "path": "output2\\c\\Medium\\1185-jump-game-iii.c", "hypo_code": "bool canReach(int* arr, int arrSize, int start){\n    int* visited = (int*)malloc(sizeof(int) * arrSize);\n    memset(visited, 0, sizeof(int) * arrSize);\n    int* queue = (int*)malloc(sizeof(int) * arrSize);\n    int left = 0;\n    int right = 0;\n    queue[right++] = start;\n    while(left < right){\n        int index = queue[left++];\n        if(arr[index] == 0){\n            return true;\n        }\n        if(index + arr[index] < arrSize && visited[index + arr[index]] == 0){\n            queue[right++] = index + arr[index];\n            visited[index + arr[index]] = 1;\n        }\n        if(index - arr[index] >= 0 && visited[index - arr[index]] == 0){\n            queue[right++] = index - arr[index];\n            visited[index - arr[index]] = 1;\n        }\n    }\n    return false;\n\n}", "prefix": "bool canReach(int* arr, int arrSize, int start"}
{"id": "1186", "path": "output2\\c\\Medium\\1186-xor-queries-of-a-subarray.c", "hypo_code": "int* xorQueries(int* arr, int arrSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int *res = (int *)malloc(sizeof(int) * queriesSize);\n    *returnSize = queriesSize;\n    int *xor = (int *)malloc(sizeof(int) * (arrSize + 1));\n    xor[0] = 0;\n    for (int i = 1; i <= arrSize; ++i) {\n        xor[i] = xor[i - 1] ^ arr[i - 1];\n    }\n    for (int i = 0; i < queriesSize; ++i) {\n        res[i] = xor[queries[i][0]] ^ xor[queries[i][1] + 1];\n    }\n    return res;\n\n}", "prefix": "int* xorQueries(int* arr, int arrSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1187", "path": "output2\\c\\Medium\\1187-get-watched-videos-by-your-friends.c", "hypo_code": "char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\n*returnSize = 0;\n    int *visited = (int *)malloc(sizeof(int) * watchedVideosSize);\n    memset(visited, 0, sizeof(int) * watchedVideosSize);\n    int *queue = (int *)malloc(sizeof(int) * friendsSize);\n    int queueSize = 0;\n    queue[queueSize++] = id;\n    visited[id] = 1;\n    while (queueSize && level) {\n        int curSize = queueSize;\n        while (curSize--) {\n            int cur = queue[0];\n            for (int i = 0; i < queueSize - 1; ++i) {\n                queue[i] = queue[i + 1];\n            }\n            --queueSize;\n            for (int i = 0; i < friendsColSize[cur]; ++i) {\n                if (!visited[friends[cur][i]]) {\n                    queue[queueSize++] = friends[cur][i];\n                    visited[friends[cur][i]] = 1;\n                }\n            }\n        }\n        --level;\n    }\n    int *freq = (int *)malloc(sizeof(int) * 100);\n    memset(freq, 0, sizeof(int) * 100);\n    for (int i = 0; i < queueSize; ++i) {\n        for (int j = 0; j < watchedVideosColSize[queue[i]]; ++j) {\n            ++freq[watchedVideos[queue[i]][j][0] - 'A'];\n        }\n    }\n    char **res = (char **)malloc(sizeof(char *) * 100);\n    for (int i = 0; i < 100; ++i) {\n        res[i] = (char *)malloc(sizeof(char) * 9);\n        memset(res[i], 0, sizeof(char) * 9);\n    }\n    *returnSize = 0;\n    for (int i = 0; i < 100; ++i) {\n        if (freq[i]) {\n            strcpy(res[*returnSize], \"A\");\n            res[*returnSize][0] += i;\n            ++*returnSize;\n        }\n    }\n    qsort(res, *returnSize, sizeof(char *), cmp);\n    return res;\n\n}", "prefix": "char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize"}
{"id": "1188", "path": "output2\\c\\Medium\\1188-matrix-block-sum.c", "hypo_code": "int** matrixBlockSum(int** mat, int matSize, int* matColSize, int k, int* returnSize, int** returnColumnSizes){\nint **res = (int **)malloc(sizeof(int *) * matSize);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * matSize);\n    for (int i = 0; i < matSize; ++i) {\n        res[i] = (int *)malloc(sizeof(int) * matColSize[i]);\n        memset(res[i], 0, sizeof(int) * matColSize[i]);\n        (*returnColumnSizes)[i] = matColSize[i];\n    }\n    for (int i = 0; i < matSize; ++i) {\n        for (int j = 0; j < matColSize[i]; ++j) {\n            for (int p = i - k; p <= i + k; ++p) {\n                for (int q = j - k; q <= j + k; ++q) {\n                    if (p >= 0 && p < matSize && q >= 0 && q < matColSize[i]) {\n                        res[i][j] += mat[p][q];\n                    }\n                }\n            }\n        }\n    }\n    *returnSize = matSize;\n    return res;\n}", "prefix": "int** matrixBlockSum(int** mat, int matSize, int* matColSize, int k, int* returnSize, int** returnColumnSizes"}
{"id": "1189", "path": "output2\\c\\Medium\\1189-sum-of-nodes-with-even-valued-grandparent.c", "hypo_code": "int sumEvenGrandparent(struct TreeNode* root){\nnt sum = 0;\n    dfs(root, &sum);\n    return sum;\n}\nvoid dfs(struct TreeNode *root, int *sum) {\n    if (!root) {\n        return;\n    }\n    if (root->val % 2 == 0) {\n        if (root->left) {\n            if (root->left->left) {\n                *sum += root->left->left->val;\n            }\n            if (root->left->right) {\n                *sum += root->left->right->val;\n            }\n        }\n        if (root->right) {\n            if (root->right->left) {\n                *sum += root->right->left->val;\n            }\n            if (root->right->right) {\n                *sum += root->right->right->val;\n            }\n        }\n    }\n    dfs(root->left, sum);\n    dfs(root->right, sum);\n}", "prefix": "int sumEvenGrandparent(struct TreeNode* root"}
{"id": "1190", "path": "output2\\c\\Medium\\1190-minimum-flips-to-make-a-or-b-equal-to-c.c", "hypo_code": "int minFlips(int a, int b, int c){\nint res = 0;\n    while (a || b || c) {\n        int a1 = a & 1;\n        int b1 = b & 1;\n        int c1 = c & 1;\n        if (c1 == 0) {\n            res += a1 + b1;\n        } else {\n            res += (a1 + b1 == 0 ? 1 : 0);\n        }\n        a >>= 1;\n        b >>= 1;\n        c >>= 1;\n    }\n    return res;\n}", "prefix": "int minFlips(int a, int b, int c"}
{"id": "1191", "path": "output2\\c\\Medium\\1191-number-of-operations-to-make-network-connected.c", "hypo_code": "int makeConnected(int n, int** connections, int connectionsSize, int* connectionsColSize){\nint *parent = (int *)malloc(sizeof(int) * (n));\n    memset(parent, 0, sizeof(int) * (n));\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n    }\n    int res = 0;\n    for (int i = 0; i < connectionsSize; ++i) {\n        int px = find(parent, connections[i][0]);\n        int py = find(parent, connections[i][1]);\n        if (px != py) {\n            parent[px] = py;\n        } else {\n            ++res;\n        }\n    }\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (parent[i] == i) {\n            ++count;\n        }\n    }\n    return res >= count - 1 ? count - 1 : -1;\n}\nint find(int *parent, int index) {\n    if (parent[index] != index) {\n        parent[index] = find(parent, parent[index]);\n    }\n    return parent[index];\n}", "prefix": "int makeConnected(int n, int** connections, int connectionsSize, int* connectionsColSize"}
{"id": "1193", "path": "output2\\c\\Medium\\1193-print-words-vertically.c", "hypo_code": "char ** printVertically(char * s, int* returnSize){\n    int size = strlen(s);\n    int wordCount = 0;\n    int wordSize = 0;\n    int maxWordSize = 0;\n    for(int i = 0; i < size; i++){\n        if(s[i] == ' '){\n            wordCount++;\n            if(wordSize > maxWordSize){\n                maxWordSize = wordSize;\n            }\n            wordSize = 0;\n        }\n        else{\n            wordSize++;\n        }\n    }\n    wordCount++;\n    if(wordSize > maxWordSize){\n        maxWordSize = wordSize;\n    }\n    char** result = malloc(sizeof(char*) * maxWordSize);\n    for(int i = 0; i < maxWordSize; i++){\n        result[i] = malloc(sizeof(char) * (wordCount + 1));\n        memset(result[i], ' ', wordCount);\n        result[i][wordCount] = '\\0';\n    }\n    int wordIndex = 0;\n    int charIndex = 0;\n    for(int i = 0; i < size; i++){\n        if(s[i] == ' '){\n            wordIndex++;\n            charIndex = 0;\n        }\n        else{\n            result[charIndex++][wordIndex] = s[i];\n        }\n    }\n    for(int i = 0; i < maxWordSize; i++){\n        int j = wordCount - 1;\n        while(result[i][j] == ' '){\n            j--;\n        }\n        result[i][j + 1] = '\\0';\n    }\n    *returnSize = maxWordSize;\n    return result;\n\n}", "prefix": "char ** printVertically(char * s, int* returnSize"}
{"id": "1194", "path": "output2\\c\\Medium\\1194-delete-leaves-with-a-given-value.c", "hypo_code": "struct TreeNode* removeLeafNodes(struct TreeNode* root, int target){\n    if(root == NULL){\n        return NULL;\n    }\n    root->left = removeLeafNodes(root->left, target);\n    root->right = removeLeafNodes(root->right, target);\n    if(root->left == NULL && root->right == NULL && root->val == target){\n        return NULL;\n    }\n    return root;\n\n}", "prefix": "struct TreeNode* removeLeafNodes(struct TreeNode* root, int target"}
{"id": "1195", "path": "output2\\c\\Medium\\1195-break-a-palindrome.c", "hypo_code": "char * breakPalindrome(char * palindrome){\n    int length = strlen(palindrome);\n    if(length == 1){\n        return \"\";\n    }\n    for(int i = 0; i < length / 2; i++){\n        if(palindrome[i] != 'a'){\n            palindrome[i] = 'a';\n            return palindrome;\n        }\n    }\n    palindrome[length - 1] = 'b';\n    return palindrome;\n\n}", "prefix": "char * breakPalindrome(char * palindrome"}
{"id": "1196", "path": "output2\\c\\Medium\\1196-sort-the-matrix-diagonally.c", "hypo_code": "int** diagonalSort(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){\n    int** result = malloc(matSize * sizeof(int*));\n    for(int i = 0; i < matSize; i++){\n        result[i] = malloc(matColSize[i] * sizeof(int));\n        memcpy(result[i], mat[i], matColSize[i] * sizeof(int));\n    }\n    for(int i = 0; i < matSize; i++){\n        int* queue = malloc(matSize * matColSize[i] * sizeof(int));\n        int queueSize = 0;\n        int row = i;\n        int col = 0;\n        while(row < matSize && col < matColSize[i]){\n            queue[queueSize++] = mat[row++][col++];\n        }\n        qsort(queue, queueSize, sizeof(int), cmp);\n        row = i;\n        col = 0;\n        int queueIndex = 0;\n        while(row < matSize && col < matColSize[i]){\n            result[row++][col++] = queue[queueIndex++];\n        }\n        free(queue);\n    }\n    for(int i = 1; i < matColSize[0]; i++){\n        int* queue = malloc(matSize * matColSize[i] * sizeof(int));\n        int queueSize = 0;\n        int row = 0;\n        int col = i;\n        while(row < matSize && col < matColSize[i]){\n            queue[queueSize++] = mat[row++][col++];\n        }\n        qsort(queue, queueSize, sizeof(int), cmp);\n        row = 0;\n        col = i;\n        int queueIndex = 0;\n        while(row < matSize && col < matColSize[i]){\n            result[row++][col++] = queue[queueIndex++];\n        }\n        free(queue);\n    }\n    *returnSize = matSize;\n    *returnColumnSizes = matColSize;\n    return result;\n\n}", "prefix": "int** diagonalSort(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1197", "path": "output2\\c\\Medium\\1197-filter-restaurants-by-vegan-friendly-price-and-distance.c", "hypo_code": "int* filterRestaurants(int** restaurants, int restaurantsSize, int* restaurantsColSize, int veganFriendly, int maxPrice, int maxDistance, int* returnSize){\n    int* result = malloc(sizeof(int) * restaurantsSize);\n    int resultSize = 0;\n    for(int i = 0; i < restaurantsSize; i++){\n        if(veganFriendly == 1 && restaurants[i][2] == 0){\n            continue;\n        }\n        if(restaurants[i][3] > maxPrice){\n            continue;\n        }\n        if(restaurants[i][4] > maxDistance){\n            continue;\n        }\n        result[resultSize++] = restaurants[i][0];\n    }\n    for(int i = 0; i < resultSize; i++){\n        for(int j = i + 1; j < resultSize; j++){\n            if(restaurants[result[i] - 1][1] < restaurants[result[j] - 1][1]){\n                int temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n            else if(restaurants[result[i] - 1][1] == restaurants[result[j] - 1][1]){\n                if(result[i] < result[j]){\n                    int temp = result[i];\n                    result[i] = result[j];\n                    result[j] = temp;\n                }\n            }\n        }\n    }\n    *returnSize = resultSize;\n    return result;\n\n}", "prefix": "int* filterRestaurants(int** restaurants, int restaurantsSize, int* restaurantsColSize, int veganFriendly, int maxPrice, int maxDistance, int* returnSize"}
{"id": "1198", "path": "output2\\c\\Medium\\1198-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance.c", "hypo_code": "int findTheCity(int n, int** edges, int edgesSize, int* edgesColSize, int distanceThreshold){\n    int** graph = (int**)malloc(sizeof(int*) * n);\n    for(int i = 0; i < n; i++){\n        graph[i] = (int*)malloc(sizeof(int) * n);\n        for(int j = 0; j < n; j++){\n            graph[i][j] = 10001;\n        }\n        graph[i][i] = 0;\n    }\n    for(int i = 0; i < edgesSize; i++){\n        graph[edges[i][0]][edges[i][1]] = edges[i][2];\n        graph[edges[i][1]][edges[i][0]] = edges[i][2];\n    }\n    for(int k = 0; k < n; k++){\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(graph[i][k] + graph[k][j] < graph[i][j]){\n                    graph[i][j] = graph[i][k] + graph[k][j];\n                }\n            }\n        }\n    }\n    int result = 0;\n    int min = n;\n    for(int i = 0; i < n; i++){\n        int count = 0;\n        for(int j = 0; j < n; j++){\n            if(graph[i][j] <= distanceThreshold){\n                count++;\n            }\n        }\n        if(count <= min){\n            min = count;\n            result = i;\n        }\n    }\n    return result;\n\n}", "prefix": "int findTheCity(int n, int** edges, int edgesSize, int* edgesColSize, int distanceThreshold"}
{"id": "1199", "path": "output2\\c\\Medium\\1199-reduce-array-size-to-the-half.c", "hypo_code": "int minSetSize(int* arr, int arrSize){\n    int* count = (int*)malloc(sizeof(int) * 100001);\n    for(int i = 0; i < 100001; i++){\n        count[i] = 0;\n    }\n    for(int i = 0; i < arrSize; i++){\n        count[arr[i]]++;\n    }\n    int* count2 = (int*)malloc(sizeof(int) * 100001);\n    for(int i = 0; i < 100001; i++){\n        count2[i] = 0;\n    }\n    for(int i = 0; i < 100001; i++){\n        count2[count[i]]++;\n    }\n    int sum = 0;\n    int result = 0;\n    for(int i = 100000; i >= 0; i--){\n        if(count2[i] > 0){\n            for(int j = 0; j < count2[i]; j++){\n                sum += i;\n                result++;\n                if(sum >= arrSize / 2){\n                    return result;\n                }\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int minSetSize(int* arr, int arrSize"}
{"id": "1200", "path": "output2\\c\\Medium\\1200-maximum-product-of-splitted-binary-tree.c", "hypo_code": "int maxProduct(struct TreeNode* root){\n    int result = 0;\n    int maxDepth = 0;\n    struct TreeNode* queue[10000];\n    int queueSize = 0;\n    queue[queueSize++] = root;\n    while(queueSize > 0){\n        int size = queueSize;\n        queueSize = 0;\n        result = 0;\n        maxDepth++;\n        for(int i = 0; i < size; i++){\n            struct TreeNode* node = queue[i];\n            result += node->val;\n            if(node->left != NULL){\n                queue[queueSize++] = node->left;\n            }\n            if(node->right != NULL){\n                queue[queueSize++] = node->right;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int maxProduct(struct TreeNode* root"}
{"id": "1202", "path": "output2\\c\\Medium\\1202-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold.c", "hypo_code": "int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\nint res = 0;\n    int sum = 0;\n    for (int i = 0; i < k - 1; ++i) {\n        sum += arr[i];\n    }\n    for (int i = k - 1; i < arrSize; ++i) {\n        sum += arr[i];\n        if (sum / k >= threshold) {\n            ++res;\n        }\n        sum -= arr[i - k + 1];\n    }\n    return res;\n}", "prefix": "int numOfSubarrays(int* arr, int arrSize, int k, int threshold"}
{"id": "1203", "path": "output2\\c\\Medium\\1203-angle-between-hands-of-a-clock.c", "hypo_code": "double angleClock(int hour, int minutes){\ndouble res = 0;\n    if (hour == 12) {\n        hour = 0;\n    }\n    res = fabs(hour * 30 + minutes * 0.5 - minutes * 6);\n    return fmin(res, 360 - res);\n}", "prefix": "double angleClock(int hour, int minutes"}
{"id": "1204", "path": "output2\\c\\Medium\\1204-minimum-number-of-steps-to-make-two-strings-anagram.c", "hypo_code": "int minSteps(char * s, char * t){\nint len = strlen(s);\n    int *count = (int *)malloc(sizeof(int) * 26);\n    memset(count, 0, sizeof(int) * 26);\n    for (int i = 0; i < len; ++i) {\n        ++count[s[i] - 'a'];\n        --count[t[i] - 'a'];\n    }\n    int res = 0;\n    for (int i = 0; i < 26; ++i) {\n        if (count[i] > 0) {\n            res += count[i];\n        }\n    }\n    return res;\n}", "prefix": "int minSteps(char * s, char * t"}
{"id": "1207", "path": "output2\\c\\Medium\\1207-maximum-number-of-events-that-can-be-attended.c", "hypo_code": "int maxEvents(int** events, int eventsSize, int* eventsColSize){\nint *dp = (int *)malloc(sizeof(int) * (eventsSize + 1));\n    memset(dp, 0, sizeof(int) * (eventsSize + 1));\n    int res = 0;\n    for (int i = 1; i <= eventsSize; ++i) {\n        dp[i] = dp[i - 1];\n        for (int j = 0; j < eventsSize; ++j) {\n            if (events[j][0] > i) {\n                continue;\n            }\n            dp[i] = fmax(dp[i], dp[events[j][0] - 1] + 1);\n        }\n        res = fmax(res, dp[i]);\n    }\n    return res;\n}", "prefix": "int maxEvents(int** events, int eventsSize, int* eventsColSize"}
{"id": "1209", "path": "output2\\c\\Medium\\1209-number-of-substrings-containing-all-three-characters.c", "hypo_code": "int numberOfSubstrings(char * s){\n    int length = strlen(s);\n    int count = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int start = 0;\n    for(int i = 0; i < length; i++){\n        if(s[i] == 'a'){\n            a++;\n        }\n        else if(s[i] == 'b'){\n            b++;\n        }\n        else{\n            c++;\n        }\n        while(a > 0 && b > 0 && c > 0){\n            if(s[start] == 'a'){\n                a--;\n            }\n            else if(s[start] == 'b'){\n                b--;\n            }\n            else{\n                c--;\n            }\n            start++;\n        }\n        count += start;\n    }\n    return count;\n\n}", "prefix": "int numberOfSubstrings(char * s"}
{"id": "1210", "path": "output2\\c\\Medium\\1210-validate-binary-tree-nodes.c", "hypo_code": "bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\n    int* inDegree = (int*)malloc(sizeof(int) * n);\n    for(int i = 0; i < n; i++){\n        inDegree[i] = 0;\n    }\n    for(int i = 0; i < n; i++){\n        if(leftChild[i] != -1){\n            inDegree[leftChild[i]]++;\n        }\n        if(rightChild[i] != -1){\n            inDegree[rightChild[i]]++;\n        }\n    }\n    int root = -1;\n    for(int i = 0; i < n; i++){\n        if(inDegree[i] == 0){\n            if(root != -1){\n                return false;\n            }\n            root = i;\n        }\n    }\n    if(root == -1){\n        return false;\n    }\n    int* queue = (int*)malloc(sizeof(int) * n);\n    int queueSize = 0;\n    queue[queueSize++] = root;\n    for(int i = 0; i < queueSize; i++){\n        int node = queue[i];\n        if(leftChild[node] != -1){\n            queue[queueSize++] = leftChild[node];\n        }\n        if(rightChild[node] != -1){\n            queue[queueSize++] = rightChild[node];\n        }\n    }\n    if(queueSize != n){\n        return false;\n    }\n    return true;\n\n}", "prefix": "bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize"}
{"id": "1211", "path": "output2\\c\\Medium\\1211-closest-divisors.c", "hypo_code": "int* closestDivisors(int num, int* returnSize){\n    int* result = malloc(sizeof(int) * 2);\n    int minDiff = INT_MAX;\n    for(int i = 1; i * i <= num + 2; i++){\n        if((num + 1) % i == 0){\n            int diff = abs(i - (num + 1) / i);\n            if(diff < minDiff){\n                minDiff = diff;\n                result[0] = i;\n                result[1] = (num + 1) / i;\n            }\n        }\n        if((num + 2) % i == 0){\n            int diff = abs(i - (num + 2) / i);\n            if(diff < minDiff){\n                minDiff = diff;\n                result[0] = i;\n                result[1] = (num + 2) / i;\n            }\n        }\n    }\n    *returnSize = 2;\n    return result;\n\n}", "prefix": "int* closestDivisors(int num, int* returnSize"}
{"id": "1212", "path": "output2\\c\\Medium\\1212-rank-teams-by-votes.c", "hypo_code": "char * rankTeams(char ** votes, int votesSize){\nint rank[26][26] = {0};\n    int i, j, k, max, max_index;\n    char *result = (char *)malloc(sizeof(char) * (strlen(votes[0]) + 1));\n    memset(result, 0, sizeof(char) * (strlen(votes[0]) + 1));\n    for(i = 0; i < votesSize; i++)\n    {\n        for(j = 0; j < strlen(votes[0]); j++)\n        {\n            rank[votes[i][j] - 'A'][j]++;\n        }\n    }\n    for(i = 0; i < strlen(votes[0]); i++)\n    {\n        max = 0;\n        max_index = 0;\n        for(j = 0; j < 26; j++)\n        {\n            if(rank[j][i] > max)\n            {\n                max = rank[j][i];\n                max_index = j;\n            }\n        }\n        result[i] = max_index + 'A';\n    }\n    return result;\n}", "prefix": "char * rankTeams(char ** votes, int votesSize"}
{"id": "1213", "path": "output2\\c\\Medium\\1213-linked-list-in-binary-tree.c", "hypo_code": "bool isSubPath(struct ListNode* head, struct TreeNode* root){\n    if(head == NULL){\n        return true;\n    }\n    if(root == NULL){\n        return false;\n    }\n    if(head->val == root->val){\n        if(isSubPath(head->next, root->left) || isSubPath(head->next, root->right)){\n            return true;\n        }\n    }\n    return isSubPath(head, root->left) || isSubPath(head, root->right);\n\n}", "prefix": "bool isSubPath(struct ListNode* head, struct TreeNode* root"}
{"id": "1214", "path": "output2\\c\\Medium\\1214-find-the-longest-substring-containing-vowels-in-even-counts.c", "hypo_code": "int findTheLongestSubstring(char * s){\n    int length = strlen(s);\n    int result = 0;\n    int* map = malloc(sizeof(int) * 32);\n    memset(map, -1, sizeof(int) * 32);\n    map[0] = -1;\n    int state = 0;\n    for(int i = 0; i < length; i++){\n        if(s[i] == 'a'){\n            state ^= 1;\n        }\n        else if(s[i] == 'e'){\n            state ^= 2;\n        }\n        else if(s[i] == 'i'){\n            state ^= 4;\n        }\n        else if(s[i] == 'o'){\n            state ^= 8;\n        }\n        else if(s[i] == 'u'){\n            state ^= 16;\n        }\n        if(map[state] == -1){\n            map[state] = i;\n        }\n        else{\n            int temp = i - map[state];\n            if(temp > result){\n                result = temp;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int findTheLongestSubstring(char * s"}
{"id": "1215", "path": "output2\\c\\Medium\\1215-longest-zigzag-path-in-a-binary-tree.c", "hypo_code": "int longestZigZag(struct TreeNode* root){\n    if(root == NULL){\n        return 0;\n    }\n    int left = 0;\n    int right = 0;\n    if(root->left != NULL){\n        left = 1 + longestZigZag(root->left);\n    }\n    if(root->right != NULL){\n        right = 1 + longestZigZag(root->right);\n    }\n    if(left > right){\n        return left;\n    }\n    return right;\n\n}", "prefix": "int longestZigZag(struct TreeNode* root"}
{"id": "1216", "path": "output2\\c\\Medium\\1216-number-of-times-binary-string-is-prefix-aligned.c", "hypo_code": "int numTimesAllBlue(int* flips, int flipsSize){\n    int i, max = 0, count = 0;\n    for(i = 0; i < flipsSize; i++){\n        if(flips[i] > max){\n            max = flips[i];\n        }\n        if(max == i + 1){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int numTimesAllBlue(int* flips, int flipsSize"}
{"id": "1217", "path": "output2\\c\\Medium\\1217-time-needed-to-inform-all-employees.c", "hypo_code": "int numOfMinutes(int n, int headID, int* manager, int managerSize, int* informTime, int informTimeSize){\n    int i, max = 0, temp;\n    for(i = 0; i < n; i++){\n        if(manager[i] == -1){\n            continue;\n        }\n        temp = informTime[manager[i]] + numOfMinutes(n, manager[i], manager, managerSize, informTime, informTimeSize);\n        if(temp > max){\n            max = temp;\n        }\n    }\n    return max;\n\n}", "prefix": "int numOfMinutes(int n, int headID, int* manager, int managerSize, int* informTime, int informTimeSize"}
{"id": "1219", "path": "output2\\c\\Medium\\1219-balance-a-binary-search-tree.c", "hypo_code": "struct TreeNode* balanceBST(struct TreeNode* root){\n    int i, j, k, n = 0, *arr = malloc(10000 * sizeof(int));\n    struct TreeNode *temp = root;\n    while(temp != NULL){\n        arr[n++] = temp->val;\n        temp = temp->left;\n    }\n    for(i = 0; i < n; i++){\n        for(j = i + 1; j < n; j++){\n            if(arr[i] > arr[j]){\n                k = arr[i];\n                arr[i] = arr[j];\n                arr[j] = k;\n            }\n        }\n    }\n    struct TreeNode* newNode(int val){\n        struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        node->val = val;\n        node->left = NULL;\n        node->right = NULL;\n        return node;\n    }\n    struct TreeNode* build(int l, int r){\n        if(l > r){\n            return NULL;\n        }\n        int mid = (l + r) / 2;\n        struct TreeNode* root = newNode(arr[mid]);\n        root->left = build(l, mid - 1);\n        root->right = build(mid + 1, r);\n        return root;\n    }\n    return build(0, n - 1);\n\n}", "prefix": "struct TreeNode* balanceBST(struct TreeNode* root"}
{"id": "1220", "path": "output2\\c\\Medium\\1220-cinema-seat-allocation.c", "hypo_code": "int maxNumberOfFamilies(int n, int** reservedSeats, int reservedSeatsSize, int* reservedSeatsColSize){\n    int i, j, k, count = 0, *arr = malloc(100000 * sizeof(int));\n    for(i = 0; i < reservedSeatsSize; i++){\n        arr[reservedSeats[i][0] * 10 + reservedSeats[i][1]] = 1;\n    }\n    for(i = 1; i <= n; i++){\n        if(arr[i * 10 + 2] == 0 && arr[i * 10 + 3] == 0 && arr[i * 10 + 4] == 0 && arr[i * 10 + 5] == 0){\n            count++;\n            arr[i * 10 + 2] = 1;\n            arr[i * 10 + 3] = 1;\n            arr[i * 10 + 4] = 1;\n            arr[i * 10 + 5] = 1;\n        }\n        if(arr[i * 10 + 6] == 0 && arr[i * 10 + 7] == 0 && arr[i * 10 + 8] == 0 && arr[i * 10 + 9] == 0){\n            count++;\n            arr[i * 10 + 6] = 1;\n            arr[i * 10 + 7] = 1;\n            arr[i * 10 + 8] = 1;\n            arr[i * 10 + 9] = 1;\n        }\n        if(arr[i * 10 + 4] == 0 && arr[i * 10 + 5] == 0 && arr[i * 10 + 6] == 0 && arr[i * 10 + 7] == 0){\n            count++;\n            arr[i * 10 + 4] = 1;\n            arr[i * 10 + 5] = 1;\n            arr[i * 10 + 6] = 1;\n            arr[i * 10 + 7] = 1;\n        }\n    }\n    return count;\n\n}", "prefix": "int maxNumberOfFamilies(int n, int** reservedSeats, int reservedSeatsSize, int* reservedSeatsColSize"}
{"id": "1221", "path": "output2\\c\\Medium\\1221-sort-integers-by-the-power-value.c", "hypo_code": "int getKth(int lo, int hi, int k){\n    int i, j, temp, *arr = malloc((hi - lo + 1) * sizeof(int));\n    for(i = lo; i <= hi; i++){\n        temp = i;\n        j = 0;\n        while(temp != 1){\n            if(temp % 2 == 0){\n                temp /= 2;\n            }\n            else{\n                temp = 3 * temp + 1;\n            }\n            j++;\n        }\n        arr[i - lo] = j;\n    }\n    for(i = 0; i < hi - lo + 1; i++){\n        for(j = i + 1; j < hi - lo + 1; j++){\n            if(arr[i] > arr[j]){\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr[k - 1] + lo;\n\n}", "prefix": "int getKth(int lo, int hi, int k"}
{"id": "1222", "path": "output2\\c\\Medium\\1222-four-divisors.c", "hypo_code": "int sumFourDivisors(int* nums, int numsSize){\n    int i, j, k, sum = 0, count = 0;\n    for(i = 0; i < numsSize; i++){\n        count = 0;\n        for(j = 1; j <= nums[i]; j++){\n            if(nums[i] % j == 0){\n                count++;\n                sum += j;\n            }\n        }\n        if(count != 4){\n            sum = 0;\n        }\n    }\n    return sum;\n\n}", "prefix": "int sumFourDivisors(int* nums, int numsSize"}
{"id": "1223", "path": "output2\\c\\Medium\\1223-check-if-there-is-a-valid-path-in-a-grid.c", "hypo_code": "bool hasValidPath(int** grid, int gridSize, int* gridColSize){\n    int i, j, k, l, m, n, count = 0, **result;\n    int *row, *col;\n    row = (int*)malloc(gridSize * sizeof(int));\n    col = (int*)malloc(gridColSize[0] * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        row[i] = 0;\n        for(j = 0; j < gridColSize[0]; j++){\n            if(grid[i][j] == 1){\n                row[i]++;\n            }\n        }\n    }\n    for(i = 0; i < gridColSize[0]; i++){\n        col[i] = 0;\n        for(j = 0; j < gridSize; j++){\n            if(grid[j][i] == 1){\n                col[i]++;\n            }\n        }\n    }\n    result = (int**)malloc(gridSize * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(gridSize * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        result[i] = (int*)malloc(gridColSize[0] * sizeof(int));\n        (*returnColumnSizes)[i] = gridColSize[0];\n        for(j = 0; j < gridColSize[0]; j++){\n            result[i][j] = row[i] + col[j];\n            if(grid[i][j] == 1){\n                result[i][j] -= 2;\n            }\n        }\n    }\n    *returnSize = gridSize;\n    return result;\n\n}", "prefix": "bool hasValidPath(int** grid, int gridSize, int* gridColSize"}
{"id": "1225", "path": "output2\\c\\Medium\\1225-count-number-of-teams.c", "hypo_code": "int numTeams(int* rating, int ratingSize){\n    int i, j, k, count = 0;\n    for(i = 0; i < ratingSize - 2; i++){\n        for(j = i + 1; j < ratingSize - 1; j++){\n            for(k = j + 1; k < ratingSize; k++){\n                if((rating[i] < rating[j] && rating[j] < rating[k]) || (rating[i] > rating[j] && rating[j] > rating[k])){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int numTeams(int* rating, int ratingSize"}
{"id": "1227", "path": "output2\\c\\Medium\\1227-construct-k-palindrome-strings.c", "hypo_code": "bool canConstruct(char * s, int k){\n    int i, j, count = 0, *arr;\n    arr = (int*)malloc(26 * sizeof(int));\n    for(i = 0; i < 26; i++){\n        arr[i] = 0;\n    }\n    for(i = 0; i < strlen(s); i++){\n        arr[s[i] - 'a']++;\n    }\n    for(i = 0; i < 26; i++){\n        if(arr[i] % 2 == 1){\n            count++;\n        }\n    }\n    if(count > k){\n        return false;\n    }\n    return true;\n\n}", "prefix": "bool canConstruct(char * s, int k"}
{"id": "1228", "path": "output2\\c\\Medium\\1228-circle-and-rectangle-overlapping.c", "hypo_code": "bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2){\n    int i, j, k, l, m, n, count = 0, **result;\n    int *row, *col;\n    row = (int*)malloc(gridSize * sizeof(int));\n    col = (int*)malloc(gridColSize[0] * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        row[i] = 0;\n        for(j = 0; j < gridColSize[0]; j++){\n            if(grid[i][j] == 1){\n                row[i]++;\n            }\n        }\n    }\n    for(i = 0; i < gridColSize[0]; i++){\n        col[i] = 0;\n        for(j = 0; j < gridSize; j++){\n            if(grid[j][i] == 1){\n                col[i]++;\n            }\n        }\n    }\n    result = (int**)malloc(gridSize * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(gridSize * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        result[i] = (int*)malloc(gridColSize[0] * sizeof(int));\n        (*returnColumnSizes)[i] = gridColSize[0];\n        for(j = 0; j < gridColSize[0]; j++){\n            result[i][j] = row[i] + col[j];\n            if(grid[i][j] == 1){\n                result[i][j] -= 2;\n            }\n        }\n    }\n    *returnSize = gridSize;\n    return result;\n\n}", "prefix": "bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2"}
{"id": "1229", "path": "output2\\c\\Medium\\1229-number-of-steps-to-reduce-a-number-in-binary-representation-to-one.c", "hypo_code": "int numSteps(char * s){\n    int i, j, count = 0;\n    for(i = strlen(s) - 1; i > 0; i--){\n        if(s[i] == '0'){\n            count++;\n        }\n        else{\n            count++;\n            for(j = i - 1; j >= 0; j--){\n                if(s[j] == '0'){\n                    s[j] = '1';\n                    break;\n                }\n                else{\n                    s[j] = '0';\n                }\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int numSteps(char * s"}
{"id": "1230", "path": "output2\\c\\Medium\\1230-longest-happy-string.c", "hypo_code": "char * longestDiverseString(int a, int b, int c){\n    int i, j, k, count = 0, max = 0, maxIndex = 0;\n    char *str = (char*)malloc(100000 * sizeof(char));\n    int *arr = (int*)malloc(3 * sizeof(int));\n    arr[0] = a;\n    arr[1] = b;\n    arr[2] = c;\n    for(i = 0; i < 100000; i++){\n        str[i] = '\\0';\n    }\n    for(i = 0; i < 3; i++){\n        if(arr[i] > max){\n            max = arr[i];\n            maxIndex = i;\n        }\n    }\n    if(maxIndex == 0){\n        for(i = 0; i < max; i++){\n            str[count++] = 'a';\n        }\n        arr[0] = 0;\n    }\n    else if(maxIndex == 1){\n        for(i = 0; i < max; i++){\n            str[count++] = 'b';\n        }\n        arr[1] = 0;\n    }\n    else{\n        for(i = 0; i < max; i++){\n            str[count++] = 'c';\n        }\n        arr[2] = 0;\n    }\n    for(i = 0; i < 3; i++){\n        if(arr[i] > 0){\n            if(i == 0){\n                for(j = 0; j < arr[i]; j++){\n                    str[count++] = 'a';\n                }\n            }\n            else if(i == 1){\n                for(j = 0; j < arr[i]; j++){\n                    str[count++] = 'b';\n                }\n            }\n            else{\n                for(j = 0; j < arr[i]; j++){\n                    str[count++] = 'c';\n                }\n            }\n        }\n    }\n    return str;\n\n}", "prefix": "char * longestDiverseString(int a, int b, int c"}
{"id": "1231", "path": "output2\\c\\Medium\\1231-queries-on-a-permutation-with-key.c", "hypo_code": "int* processQueries(int* queries, int queriesSize, int m, int* returnSize){\n    int i, j, k, l, m, n, count = 0, *result;\n    int *P;\n    P = (int*)malloc(m * sizeof(int));\n    for(i = 0; i < m; i++){\n        P[i] = i + 1;\n    }\n    result = (int*)malloc(queriesSize * sizeof(int));\n    for(i = 0; i < queriesSize; i++){\n        for(j = 0; j < m; j++){\n            if(P[j] == queries[i]){\n                result[i] = j;\n                for(k = j; k > 0; k--){\n                    P[k] = P[k - 1];\n                }\n                P[0] = queries[i];\n                break;\n            }\n        }\n    }\n    *returnSize = queriesSize;\n    return result;\n\n}", "prefix": "int* processQueries(int* queries, int queriesSize, int m, int* returnSize"}
{"id": "1232", "path": "output2\\c\\Medium\\1232-html-entity-parser.c", "hypo_code": "char * entityParser(char * text){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    char *str;\n    str = (char*)malloc(100000 * sizeof(char));\n    for(i = 0; i < strlen(text); i++){\n        if(text[i] == '&'){\n            if(text[i + 1] == 'q' && text[i + 2] == 'u' && text[i + 3] == 'o' && text[i + 4] == 't' && text[i + 5] == ';'){\n                str[i] = '\"';\n                i += 5;\n            }\n            else if(text[i + 1] == 'a' && text[i + 2] == 'p' && text[i + 3] == 'o' && text[i + 4] == 's' && text[i + 5] == ';'){\n                str[i] = '\\'';\n                i += 5;\n            }\n            else if(text[i + 1] == 'a' && text[i + 2] == 'm' && text[i + 3] == 'p' && text[i + 4] == ';'){\n                str[i] = '&';\n                i += 4;\n            }\n            else if(text[i + 1] == 'g' && text[i + 2] == 't' && text[i + 3] == ';'){\n                str[i] = '>';\n                i += 3;\n            }\n            else if(text[i + 1] == 'l' && text[i + 2] == 't' && text[i + 3] == ';'){\n                str[i] = '<';\n                i += 3;\n            }\n            else if(text[i + 1] == 'f' && text[i + 2] == 'r' && text[i + 3] == 'a' && text[i + 4] == 's' && text[i + 5] == 'l' && text[i + 6] == ';'){\n                str[i] = '/';\n                i += 6;\n            }\n            else{\n                str[i] = text[i];\n            }\n        }\n        else{\n            str[i] = text[i];\n        }\n    }\n    return str;\n\n}", "prefix": "char * entityParser(char * text"}
{"id": "1233", "path": "output2\\c\\Medium\\1233-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k.c", "hypo_code": "int findMinFibonacciNumbers(int k){\n    int i, j, count = 0, *arr;\n    arr = (int*)malloc(100 * sizeof(int));\n    arr[0] = 1;\n    arr[1] = 1;\n    for(i = 2; i < 100; i++){\n        arr[i] = arr[i - 1] + arr[i - 2];\n    }\n    for(i = 99; i >= 0; i--){\n        if(k >= arr[i]){\n            k -= arr[i];\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int findMinFibonacciNumbers(int k"}
{"id": "1234", "path": "output2\\c\\Medium\\1234-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n.c", "hypo_code": "char * getHappyString(int n, int k){\n    int i, j, count = 0, *arr;\n    char *str = (char*)malloc(100000 * sizeof(char));\n    arr = (int*)malloc(3 * sizeof(int));\n    for(i = 0; i < 100000; i++){\n        str[i] = '\\0';\n    }\n    for(i = 0; i < 3; i++){\n        arr[i] = 0;\n    }\n    for(i = 0; i < n; i++){\n        for(j = 0; j < 3; j++){\n            if(arr[j] == 0){\n                if(j == 0){\n                    str[count++] = 'a';\n                }\n                else if(j == 1){\n                    str[count++] = 'b';\n                }\n                else{\n                    str[count++] = 'c';\n                }\n                arr[j] = 1;\n                break;\n            }\n            else{\n                if(j == 0){\n                    if(str[count - 1] != 'a'){\n                        str[count++] = 'a';\n                        arr[j] = 1;\n                        break;\n                    }\n                }\n                else if(j == 1){\n                    if(str[count - 1] != 'b'){\n                        str[count++] = 'b';\n                        arr[j] = 1;\n                        break;\n                    }\n                }\n                else{\n                    if(str[count - 1] != 'c'){\n                        str[count++] = 'c';\n                        arr[j] = 1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return str;\n\n}", "prefix": "char * getHappyString(int n, int k"}
{"id": "1235", "path": "output2\\c\\Medium\\1235-display-table-of-food-orders-in-a-restaurant.c", "hypo_code": "char *** displayTable(char *** orders, int ordersSize, int* ordersColSize, int* returnSize, int** returnColumnSizes){\n    int i, j, k, l, m, n, count = 0, **result;\n    int *row, *col;\n    row = (int*)malloc(gridSize * sizeof(int));\n    col = (int*)malloc(gridColSize[0] * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        row[i] = 0;\n        for(j = 0; j < gridColSize[0]; j++){\n            if(grid[i][j] == 1){\n                row[i]++;\n            }\n        }\n    }\n    for(i = 0; i < gridColSize[0]; i++){\n        col[i] = 0;\n        for(j = 0; j < gridSize; j++){\n            if(grid[j][i] == 1){\n                col[i]++;\n            }\n        }\n    }\n    result = (int**)malloc(gridSize * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(gridSize * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        result[i] = (int*)malloc(gridColSize[0] * sizeof(int));\n        (*returnColumnSizes)[i] = gridColSize[0];\n        for(j = 0; j < gridColSize[0]; j++){\n            result[i][j] = row[i] + col[j];\n            if(grid[i][j] == 1){\n                result[i][j] -= 2;\n            }\n        }\n    }\n    *returnSize = gridSize;\n    return result;\n\n}", "prefix": "char *** displayTable(char *** orders, int ordersSize, int* ordersColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1236", "path": "output2\\c\\Medium\\1236-minimum-number-of-frogs-croaking.c", "hypo_code": "int minNumberOfFrogs(char * croakOfFrogs){\n    int i, j, k, count = 0, max = 0, maxIndex = 0;\n    char *str = (char*)malloc(100000 * sizeof(char));\n    int *arr = (int*)malloc(5 * sizeof(int));\n    arr[0] = 0;\n    arr[1] = 0;\n    arr[2] = 0;\n    arr[3] = 0;\n    arr[4] = 0;\n    for(i = 0; i < 100000; i++){\n        str[i] = '\\0';\n    }\n    for(i = 0; i < strlen(croakOfFrogs); i++){\n        if(croakOfFrogs[i] == 'c'){\n            arr[0]++;\n        }\n        else if(croakOfFrogs[i] == 'r'){\n            arr[1]++;\n        }\n        else if(croakOfFrogs[i] == 'o'){\n            arr[2]++;\n        }\n        else if(croakOfFrogs[i] == 'a'){\n            arr[3]++;\n        }\n        else if(croakOfFrogs[i] == 'k'){\n            arr[4]++;\n        }\n        else{\n            return -1;\n        }\n    }\n    for(i = 0; i < 5; i++){\n        if(arr[i] > max){\n            max = arr[i];\n            maxIndex = i;\n        }\n    }\n    if(maxIndex == 0){\n        for(i = 0; i < max; i++){\n            str[count++] = 'c';\n        }\n        arr[0] = 0;\n    }\n    else if(maxIndex == 1){\n        for(i = 0; i < max; i++){\n            str[count++] = 'r';\n        }\n        arr[1] = 0;\n    }\n    else if(maxIndex == 2){\n        for(i = 0; i < max; i++){\n            str[count++] = 'o';\n        }\n        arr[2] = 0;\n    }\n    else if(maxIndex == 3){\n        for(i = 0; i < max; i++){\n            str[count++] = 'a';\n        }\n        arr[3] = 0;\n    }\n    else{\n        for(i = 0; i < max; i++){\n            str[count ++] = 'k';\n\n            \n\n}", "prefix": "int minNumberOfFrogs(char * croakOfFrogs"}
{"id": "1237", "path": "output2\\c\\Medium\\1237-maximum-points-you-can-obtain-from-cards.c", "hypo_code": "int maxScore(int* cardPoints, int cardPointsSize, int k){\n    int i, j, k, l, m, n, sum = 0, max = 0;\n    for(i = 0; i < k; i++){\n        sum += cardPoints[i];\n    }\n    max = sum;\n    for(i = k - 1, j = cardPointsSize - 1; i >= 0; i--, j--){\n        sum -= cardPoints[i];\n        sum += cardPoints[j];\n        if(sum > max){\n            max = sum;\n        }\n    }\n    return max;\n\n}", "prefix": "int maxScore(int* cardPoints, int cardPointsSize, int k"}
{"id": "1238", "path": "output2\\c\\Medium\\1238-diagonal-traverse-ii.c", "hypo_code": "int* findDiagonalOrder(int** nums, int numsSize, int* numsColSize, int* returnSize){\nint i, j, k, max, max_index;\n    int *result = (int *)malloc(sizeof(int) * (numsSize * numsColSize[0]));\n    memset(result, 0, sizeof(int) * (numsSize * numsColSize[0]));\n    for(i = 0; i < numsSize; i++)\n    {\n        for(j = 0; j < numsColSize[i]; j++)\n        {\n            result[i + j] = nums[i][j];\n        }\n    }\n    *returnSize = numsSize * numsColSize[0];\n    return result;\n}", "prefix": "int* findDiagonalOrder(int** nums, int numsSize, int* numsColSize, int* returnSize"}
{"id": "1239", "path": "output2\\c\\Medium\\1239-max-difference-you-can-get-from-changing-an-integer.c", "hypo_code": "int maxDiff(int num){\nint i, j, k, max, min;\n\tchar *s_num = (char *)malloc(sizeof(char) * 10);\n\tmemset(s_num, 0, sizeof(char) * 10);\n\tsprintf(s_num, \"%d\", num);\n\tmax = num;\n\tmin = num;\n\tfor(i = 0; i < strlen(s_num); i++)\n\t{\n\t\tfor(j = 0; j < 10; j++)\n\t\t{\n\t\t\tif(s_num[i] - '0' == j)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(k = 0; k < strlen(s_num); k++)\n\t\t\t{\n\t\t\t\tif(s_num[k] - '0' == j)\n\t\t\t\t{\n\t\t\t\t\ts_num[k] = s_num[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s_num[0] == '0')\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(atoi(s_num) > max)\n\t\t\t{\n\t\t\t\tmax = atoi(s_num);\n\t\t\t}\n\t\t\tif(atoi(s_num) < min)\n\t\t\t{\n\t\t\t\tmin = atoi(s_num);\n\t\t\t}\n\t\t\tsprintf(s_num, \"%d\", num);\n\t\t}\n\t}\n\treturn max - min;\n}", "prefix": "int maxDiff(int num"}
{"id": "1240", "path": "output2\\c\\Medium\\1240-check-if-a-string-can-break-another-string.c", "hypo_code": "bool checkIfCanBreak(char * s1, char * s2){\nint i, j, k, max, max_index;\n    int *s1_count = (int *)malloc(sizeof(int) * 26);\n    int *s2_count = (int *)malloc(sizeof(int) * 26);\n    memset(s1_count, 0, sizeof(int) * 26);\n    memset(s2_count, 0, sizeof(int) * 26);\n    for(i = 0; i < strlen(s1); i++)\n    {\n        s1_count[s1[i] - 'a']++;\n    }\n    for(i = 0; i < strlen(s2); i++)\n    {\n        s2_count[s2[i] - 'a']++;\n    }\n    for(i = 0; i < 26; i++)\n    {\n        if(s1_count[i] > s2_count[i])\n        {\n            max = 0;\n            max_index = 0;\n            for(j = 0; j < 26; j++)\n            {\n                if(s2_count[j] > max)\n                {\n                    max = s2_count[j];\n                    max_index = j;\n                }\n            }\n            s2_count[max_index] = 0;\n            s1_count[i] -= max;\n            i--;\n        }\n        else if(s1_count[i] < s2_count[i])\n        {\n            max = 0;\n            max_index = 0;\n            for(j = 0; j < 26; j++)\n            {\n                if(s1_count[j] > max)\n                {\n                    max = s1_count[j];\n                    max_index = j;\n                }\n            }\n            s1_count[max_index] = 0;\n            s2_count[i] -= max;\n            i--;\n        }\n    }\n    for(i = 0; i < 26; i++)\n    {\n        if(s1_count[i] != s2_count[i])\n        {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool checkIfCanBreak(char * s1, char * s2"}
{"id": "1241", "path": "output2\\c\\Medium\\1241-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit.c", "hypo_code": "int longestSubarray(int* nums, int numsSize, int limit){\nint i, j, k, max, max_index;\n    int *result = (int *)malloc(sizeof(int) * (numsSize * numsColSize[0]));\n    memset(result, 0, sizeof(int) * (numsSize * numsColSize[0]));\n    for(i = 0; i < numsSize; i++)\n    {\n        for(j = 0; j < numsColSize[i]; j++)\n        {\n            result[i + j] = nums[i][j];\n        }\n    }\n    *returnSize = numsSize * numsColSize[0];\n    return result;\n}", "prefix": "int longestSubarray(int* nums, int numsSize, int limit"}
{"id": "1242", "path": "output2\\c\\Medium\\1242-build-an-array-with-stack-operations.c", "hypo_code": "char ** buildArray(int* target, int targetSize, int n, int* returnSize){\nint i, j, k, max, max_index;\n    char **result = (char **)malloc(sizeof(char *) * (targetSize * 2));\n    memset(result, 0, sizeof(char *) * (targetSize * 2));\n    for(i = 0; i < targetSize; i++)\n    {\n        if(target[i] == i + 1)\n        {\n            result[i] = (char *)malloc(sizeof(char) * 5);\n            memset(result[i], 0, sizeof(char) * 5);\n            sprintf(result[i], \"Push\");\n        }\n        else\n        {\n            result[i] = (char *)malloc(sizeof(char) * 5);\n            memset(result[i], 0, sizeof(char) * 5);\n            sprintf(result[i], \"Push\");\n            result[i + 1] = (char *)malloc(sizeof(char) * 5);\n            memset(result[i + 1], 0, sizeof(char) * 5);\n            sprintf(result[i + 1], \"Pop\");\n            i++;\n        }\n    }\n    *returnSize = targetSize * 2;\n    return result;\n}", "prefix": "char ** buildArray(int* target, int targetSize, int n, int* returnSize"}
{"id": "1243", "path": "output2\\c\\Medium\\1243-count-triplets-that-can-form-two-arrays-of-equal-xor.c", "hypo_code": "int countTriplets(int* arr, int arrSize){\nint count = 0;\n    for (int i = 0; i < arrSize - 1; i++) {\n        int a = arr[i];\n        for (int k = i + 1; k < arrSize; k++) {\n            a ^= arr[k];\n            if (a == 0) {\n                count += k - i;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int countTriplets(int* arr, int arrSize"}
{"id": "1244", "path": "output2\\c\\Medium\\1244-minimum-time-to-collect-all-apples-in-a-tree.c", "hypo_code": "int minTime(int n, int** edges, int edgesSize, int* edgesColSize, bool* hasApple, int hasAppleSize){\nint* visited = calloc(n, sizeof(int));\n    int count = 0;\n    for (int i = 0; i < edgesSize; i++) {\n        int a = edges[i][0];\n        int b = edges[i][1];\n        if (!visited[a] && hasApple[a]) {\n            visited[a] = 1;\n            count++;\n        }\n        if (!visited[b] && hasApple[b]) {\n            visited[b] = 1;\n            count++;\n        }\n    }\n    return count * 2;\n}", "prefix": "int minTime(int n, int** edges, int edgesSize, int* edgesColSize, bool* hasApple, int hasAppleSize"}
{"id": "1245", "path": "output2\\c\\Medium\\1245-simplified-fractions.c", "hypo_code": "char ** simplifiedFractions(int n, int* returnSize){\n    int i, j, k, l, m, n, count = 0, **result;\n    int *row, *col;\n    row = (int*)malloc(gridSize * sizeof(int));\n    col = (int*)malloc(gridColSize[0] * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        row[i] = 0;\n        for(j = 0; j < gridColSize[0]; j++){\n            if(grid[i][j] == 1){\n                row[i]++;\n            }\n        }\n    }\n    for(i = 0; i < gridColSize[0]; i++){\n        col[i] = 0;\n        for(j = 0; j < gridSize; j++){\n            if(grid[j][i] == 1){\n                col[i]++;\n            }\n        }\n    }\n    result = (int**)malloc(gridSize * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(gridSize * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        result[i] = (int*)malloc(gridColSize[0] * sizeof(int));\n        (*returnColumnSizes)[i] = gridColSize[0];\n        for(j = 0; j < gridColSize[0]; j++){\n            result[i][j] = row[i] + col[j];\n            if(grid[i][j] == 1){\n                result[i][j] -= 2;\n            }\n        }\n    }\n    *returnSize = gridSize;\n    return result;\n\n}", "prefix": "char ** simplifiedFractions(int n, int* returnSize"}
{"id": "1246", "path": "output2\\c\\Medium\\1246-count-good-nodes-in-binary-tree.c", "hypo_code": "int goodNodes(struct TreeNode* root){\n    int i, j, k, count = 0;\n    struct TreeNode *temp = root;\n    while(temp != NULL){\n        if(temp->val >= root->val){\n            count++;\n        }\n        temp = temp->left;\n    }\n    temp = root;\n    while(temp != NULL){\n        if(temp->val >= root->val){\n            count++;\n        }\n        temp = temp->right;\n    }\n    return count;\n\n}", "prefix": "int goodNodes(struct TreeNode* root"}
{"id": "1247", "path": "output2\\c\\Medium\\1247-rearrange-words-in-a-sentence.c", "hypo_code": "char * arrangeWords(char * text){\n    int i, j, k, count = 0, *arr;\n    char *str = (char*)malloc(100000 * sizeof(char));\n    arr = (int*)malloc(100000 * sizeof(int));\n    for(i = 0; i < 100000; i++){\n        str[i] = '\\0';\n        arr[i] = 0;\n    }\n    for(i = 0; i < strlen(text); i++){\n        if(text[i] == ' '){\n            arr[count++] = i;\n        }\n    }\n    for(i = 0; i < count; i++){\n        for(j = i + 1; j < count; j++){\n            if(arr[j] - arr[i] < arr[i + 1] - arr[j]){\n                k = arr[i + 1];\n                arr[i + 1] = arr[j];\n                arr[j] = k;\n            }\n        }\n    }\n    for(i = 0; i < count; i++){\n        if(i == 0){\n            for(j = 0; j < arr[i]; j++){\n                str[j] = text[j];\n            }\n        }\n        else{\n            for(j = arr[i - 1] + 1; j < arr[i]; j++){\n                str[j - arr[i - 1] - 1] = text[j];\n            }\n        }\n    }\n    for(i = arr[count - 1] + 1; i < strlen(text); i++){\n        str[i - arr[count - 1] - 1] = text[i];\n    }\n    if(str[0] >= 'a' && str[0] <= 'z'){\n        str[0] = str[0] - 32;\n    }\n    return str;\n\n}", "prefix": "char * arrangeWords(char * text"}
{"id": "1248", "path": "output2\\c\\Medium\\1248-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list.c", "hypo_code": "int* peopleIndexes(char *** favoriteCompanies, int favoriteCompaniesSize, int* favoriteCompaniesColSize, int* returnSize){\nint *result = malloc(favoriteCompaniesSize * sizeof(int));\n    int resultIndex = 0;\n    int isSub = 0;\n    for (int i = 0; i < favoriteCompaniesSize; i++) {\n        isSub = 0;\n        for (int j = 0; j < favoriteCompaniesSize; j++) {\n            if (i == j) {\n                continue;\n            }\n            int isSubOfOther = 1;\n            for (int k = 0; k < favoriteCompaniesColSize[i]; k++) {\n                int isSubOfOne = 0;\n                for (int l = 0; l < favoriteCompaniesColSize[j]; l++) {\n                    if (strcmp(favoriteCompanies[i][k], favoriteCompanies[j][l]) == 0) {\n                        isSubOfOne = 1;\n                        break;\n                    }\n                }\n                if (isSubOfOne == 0) {\n                    isSubOfOther = 0;\n                    break;\n                }\n            }\n            if (isSubOfOther == 1) {\n                isSub = 1;\n                break;\n            }\n        }\n        if (isSub == 0) {\n            result[resultIndex++] = i;\n        }\n    }\n    *returnSize = resultIndex;\n    return result;\n}", "prefix": "int* peopleIndexes(char *** favoriteCompanies, int favoriteCompaniesSize, int* favoriteCompaniesColSize, int* returnSize"}
{"id": "1249", "path": "output2\\c\\Medium\\1249-maximum-number-of-vowels-in-a-substring-of-given-length.c", "hypo_code": "int maxVowels(char * s, int k){\nint len = strlen(s);\n    if (len < k) {\n        return 0;\n    }\n    int max = 0;\n    int count = 0;\n    for (int i = 0; i < k; i++) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' \n        || s[i] == 'o' || s[i] == 'u') {\n            count++;\n        }\n    }\n    max = count;\n    for (int i = k; i < len; i++) {\n        if (s[i - k] == 'a' || s[i - k] == 'e' || s[i - k] == 'i' \n        || s[i - k] == 'o' || s[i - k] == 'u') {\n            count--;\n        }\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' \n        || s[i] == 'o' || s[i] == 'u') {\n            count++;\n        }\n        if (count > max) {\n            max = count;\n        }\n    }\n    return max;\n\n}", "prefix": "int maxVowels(char * s, int k"}
{"id": "1250", "path": "output2\\c\\Medium\\1250-pseudo-palindromic-paths-in-a-binary-tree.c", "hypo_code": "int pseudoPalindromicPaths (struct TreeNode* root){\nint result = 0;\n    int *count = calloc(10, sizeof(int));\n    dfs(root, count, &result);\n    free(count);\n    return result;\n}\nvoid dfs(struct TreeNode* root, int *count, int *result) {\n    if (root == NULL) {\n        return;\n    }\n    count[root->val]++;\n    if (root->left == NULL && root->right == NULL) {\n        int odd = 0;\n        for (int i = 0; i < 10; i++) {\n            if (count[i] % 2 == 1) {\n                odd++;\n            }\n        }\n        if (odd <= 1) {\n            (*result)++;\n        }\n    }\n    dfs(root->left, count, result);\n    dfs(root->right, count, result);\n    count[root->val]--;\n}", "prefix": "int pseudoPalindromicPaths (struct TreeNode* root"}
{"id": "1251", "path": "output2\\c\\Medium\\1251-check-if-a-string-contains-all-binary-codes-of-size-k.c", "hypo_code": "bool hasAllCodes(char * s, int k){\nint len = strlen(s);\n    if (len <= k) {\n        return false;\n    }\n    int max = 1 << k;\n    int *count = calloc(max, sizeof(int));\n    int countIndex = 0;\n    for (int i = 0; i < k; i++) {\n        countIndex = (countIndex << 1) + (s[i] - '0');\n    }\n    count[countIndex] = 1;\n    for (int i = k; i < len; i++) {\n        countIndex = ((countIndex << 1) + (s[i] - '0')) % max;\n        count[countIndex] = 1;\n    }\n    for (int i = 0; i < max; i++) {\n        if (count[i] == 0) {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool hasAllCodes(char * s, int k"}
{"id": "1252", "path": "output2\\c\\Medium\\1252-course-schedule-iv.c", "hypo_code": "bool* checkIfPrerequisite(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nbool *result = calloc(queriesSize, sizeof(bool));\n    int *degree = calloc(numCourses, sizeof(int));\n    int **matrix = malloc(numCourses * sizeof(int *));\n    for (int i = 0; i < numCourses; i++) {\n        matrix[i] = calloc(numCourses, sizeof(int));\n    }\n    for (int i = 0; i < prerequisitesSize; i++) {\n        degree[prerequisites[i][1]]++;\n        matrix[prerequisites[i][0]][prerequisites[i][1]] = 1;\n    }\n    int *queue = malloc(numCourses * sizeof(int));\n    int queueStart = 0;\n    int queueEnd = 0;\n    for (int i = 0; i < numCourses; i++) {\n        if (degree[i] == 0) {\n            queue[queueEnd++] = i;\n        }\n    }\n    while (queueStart < queueEnd) {\n        int course = queue[queueStart++];\n        for (int i = 0; i < numCourses; i++) {\n            if (matrix[course][i] == 1) {\n                degree[i]--;\n                if (degree[i] == 0) {\n                    queue[queueEnd++] = i;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < queriesSize; i++) {\n        if (matrix[queries[i][0]][queries[i][1]] == 1) {\n            result[i] = true;\n        }\n    }\n    free(queue);\n    for (int i = 0; i < numCourses; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n    free(degree);\n    *returnSize = queriesSize;\n    return result;\n}", "prefix": "bool* checkIfPrerequisite(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1253", "path": "output2\\c\\Medium\\1253-maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts.c", "hypo_code": "int maxArea(int h, int w, int* horizontalCuts, int horizontalCutsSize, int* verticalCuts, int verticalCutsSize){\nint *hArr = calloc(horizontalCutsSize + 1, sizeof(int));\n    int *vArr = calloc(verticalCutsSize + 1, sizeof(int));\n    for (int i = 0; i < horizontalCutsSize; i++) {\n        hArr[i] = horizontalCuts[i];\n    }\n    for (int i = 0; i < verticalCutsSize; i++) {\n        vArr[i] = verticalCuts[i];\n    }\n    hArr[horizontalCutsSize] = h;\n    vArr[verticalCutsSize] = w;\n    qsort(hArr, horizontalCutsSize + 1, sizeof(int), cmp);\n    qsort(vArr, verticalCutsSize + 1, sizeof(int), cmp);\n    int maxH = 0;\n    for (int i = 0; i < horizontalCutsSize + 1; i++) {\n        if (hArr[i] - hArr[i - 1] > maxH) {\n            maxH = hArr[i] - hArr[i - 1];\n        }\n    }\n    int maxV = 0;\n    for (int i = 0; i < verticalCutsSize + 1; i++) {\n        if (vArr[i] - vArr[i - 1] > maxV) {\n            maxV = vArr[i] - vArr[i - 1];\n        }\n    }\n    free(hArr);\n    free(vArr);\n    return (int)((long)maxH * maxV % 1000000007);\n\n}", "prefix": "int maxArea(int h, int w, int* horizontalCuts, int horizontalCutsSize, int* verticalCuts, int verticalCutsSize"}
{"id": "1254", "path": "output2\\c\\Medium\\1254-reorder-routes-to-make-all-paths-lead-to-the-city-zero.c", "hypo_code": "int minReorder(int n, int** connections, int connectionsSize, int* connectionsColSize){\nint result = 0;\n    int *visited = calloc(n, sizeof(int));\n    visited[0] = 1;\n    for (int i = 0; i < connectionsSize; i++) {\n        if (connections[i][1] == 0) {\n            result++;\n            visited[connections[i][0]] = 1;\n        }\n    }\n    int *queue = malloc(n * sizeof(int));\n    int queueStart = 0;\n    int queueEnd = 0;\n    queue[queueEnd++] = 0;\n    while (queueStart < queueEnd) {\n        int city = queue[queueStart++];\n        for (int i = 0; i < connectionsSize; i++) {\n            if (connections[i][0] == city && visited[connections[i][1]] == 0) {\n                result++;\n                visited[connections[i][1]] = 1;\n                queue[queueEnd++] = connections[i][1];\n            } else if (connections[i][1] == city && visited[connections[i][0]] == 0) {\n                visited[connections[i][0]] = 1;\n                queue[queueEnd++] = connections[i][0];\n            }\n        }\n    }\n    free(queue);\n    free(visited);\n    return result;\n\n}", "prefix": "int minReorder(int n, int** connections, int connectionsSize, int* connectionsColSize"}
{"id": "1255", "path": "output2\\c\\Medium\\1255-the-k-strongest-values-in-an-array.c", "hypo_code": "int* getStrongest(int* arr, int arrSize, int k, int* returnSize){\n    int i, j, k, l, m, n, count = 0, *result;\n    int *temp;\n    temp = (int*)malloc(arrSize * sizeof(int));\n    for(i = 0; i < arrSize; i++){\n        temp[i] = arr[i];\n    }\n    for(i = 0; i < arrSize - 1; i++){\n        for(j = 0; j < arrSize - i - 1; j++){\n            if(temp[j] > temp[j + 1]){\n                temp[j] = temp[j] + temp[j + 1];\n                temp[j + 1] = temp[j] - temp[j + 1];\n                temp[j] = temp[j] - temp[j + 1];\n            }\n        }\n    }\n    m = temp[(arrSize - 1) / 2];\n    for(i = 0; i < arrSize - 1; i++){\n        for(j = 0; j < arrSize - i - 1; j++){\n            if(abs(arr[j] - m) < abs(arr[j + 1] - m)){\n                arr[j] = arr[j] + arr[j + 1];\n                arr[j + 1] = arr[j] - arr[j + 1];\n                arr[j] = arr[j] - arr[j + 1];\n            }\n            else if(abs(arr[j] - m) == abs(arr[j + 1] - m)){\n                if(arr[j] < arr[j + 1]){\n                    arr[j] = arr[j] + arr[j + 1];\n                    arr[j + 1] = arr[j] - arr[j + 1];\n                    arr[j] = arr[j] - arr[j + 1];\n                }\n            }\n        }\n    }\n    result = (int*)malloc(k * sizeof(int));\n    for(i = 0; i < k; i++){\n        result[i] = arr[i];\n    }\n    *returnSize = k;\n    return result;\n\n}", "prefix": "int* getStrongest(int* arr, int arrSize, int k, int* returnSize"}
{"id": "1258", "path": "output2\\c\\Medium\\1258-find-two-non-overlapping-sub-arrays-each-with-target-sum.c", "hypo_code": "int minSumOfLengths(int* arr, int arrSize, int target){\n    int* dp = (int*)malloc(sizeof(int) * arrSize);\n    int* dp2 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp3 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp4 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp5 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp6 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp7 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp8 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp9 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp10 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp11 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp12 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp13 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp14 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp15 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp16 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp17 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp18 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp19 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp20 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp21 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp22 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp23 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp24 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp25 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp26 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp27 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp28 = (int*)malloc(sizeof(int) * arrSize);\n    int* dp29 = (int*)malloc(sizeof(int) * arrSize);\n    \n\n}", "prefix": "int minSumOfLengths(int* arr, int arrSize, int target"}
{"id": "1259", "path": "output2\\c\\Medium\\1259-least-number-of-unique-integers-after-k-removals.c", "hypo_code": "int findLeastNumOfUniqueInts(int* arr, int arrSize, int k){\n    int* count = (int*)malloc(sizeof(int) * arrSize);\n    int* count2 = (int*)malloc(sizeof(int) * arrSize);\n    int* count3 = (int*)malloc(sizeof(int) * arrSize);\n    int* count4 = (int*)malloc(sizeof(int) * arrSize);\n    int* count5 = (int*)malloc(sizeof(int) * arrSize);\n    int* count6 = (int*)malloc(sizeof(int) * arrSize);\n    int* count7 = (int*)malloc(sizeof(int) * arrSize);\n    int* count8 = (int*)malloc(sizeof(int) * arrSize);\n    int* count9 = (int*)malloc(sizeof(int) * arrSize);\n    int* count10 = (int*)malloc(sizeof(int) * arrSize);\n    int* count11 = (int*)malloc(sizeof(int) * arrSize);\n    int* count12 = (int*)malloc(sizeof(int) * arrSize);\n    int* count13 = (int*)malloc(sizeof(int) * arrSize);\n    int* count14 = (int*)malloc(sizeof(int) * arrSize);\n    int* count15 = (int*)malloc(sizeof(int) * arrSize);\n    int* count16 = (int*)malloc(sizeof(int) * arrSize);\n    int* count17 = (int*)malloc(sizeof(int) * arrSize);\n    int* count18 = (int*)malloc(sizeof(int) * arrSize);\n    int* count19 = (int*)malloc(sizeof(int) * arrSize);\n    int* count20 = (int*)malloc(sizeof(int) * arrSize);\n    int* count21 = (int*)malloc(sizeof(int) * arrSize);\n    int* count22 = (int*)malloc(sizeof(int) * arrSize);\n    int* count23 = (int*)malloc(sizeof(int) * arrSize);\n    int* count24 = (int*)malloc(sizeof(int) * arrSize);\n    int* count25 = (int*)malloc(sizeof(int) * arrSize);\n    int* count26 = (int*)malloc(sizeof(int) * arrSize);\n    int* count27 = (int*)malloc(sizeof(int) * arrSize);\n    int* count28 = (int*)malloc(sizeof(int) * arrSize);\n    int* count29 = (int*)malloc(sizeof(int) * arrSize);\n    \n\n}", "prefix": "int findLeastNumOfUniqueInts(int* arr, int arrSize, int k"}
{"id": "1260", "path": "output2\\c\\Medium\\1260-minimum-number-of-days-to-make-m-bouquets.c", "hypo_code": "int minDays(int* bloomDay, int bloomDaySize, int m, int k){\n    int* dp = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp2 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp3 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp4 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp5 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp6 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp7 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp8 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp9 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp10 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp11 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp12 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp13 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp14 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp15 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp16 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp17 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp18 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp19 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp20 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp21 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp22 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp23 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp24 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp25 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp26 = (int*)malloc(sizeof(int) * bloomDaySize);\n    int* dp27 = (int*)malloc(sizeof(int) * bloomDaySize);\n    \n\n}", "prefix": "int minDays(int* bloomDay, int bloomDaySize, int m, int k"}
{"id": "1261", "path": "output2\\c\\Medium\\1261-making-file-names-unique.c", "hypo_code": "char ** getFolderNames(char ** names, int namesSize, int* returnSize){\nchar **result = malloc(namesSize * sizeof(char *));\n    *returnSize = namesSize;\n    int *namesCount = calloc(namesSize, sizeof(int));\n    for (int i = 0; i < namesSize; i++) {\n        result[i] = malloc(21 * sizeof(char));\n        strcpy(result[i], names[i]);\n        if (namesCount[i] == 0) {\n            namesCount[i] = 1;\n        }\n        int isSame = 0;\n        for (int j = 0; j < i; j++) {\n            if (strcmp(result[i], result[j]) == 0) {\n                isSame = 1;\n                namesCount[j]++;\n                break;\n            }\n        }\n        if (isSame == 1) {\n            int count = namesCount[i];\n            while (1) {\n                sprintf(result[i], \"%s(%d)\", names[i], count++);\n                int isSame = 0;\n                for (int j = 0; j < i; j++) {\n                    if (strcmp(result[i], result[j]) == 0) {\n                        isSame = 1;\n                        break;\n                    }\n                }\n                if (isSame == 0) {\n                    namesCount[i] = count - 1;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}", "prefix": "char ** getFolderNames(char ** names, int namesSize, int* returnSize"}
{"id": "1262", "path": "output2\\c\\Medium\\1262-avoid-flood-in-the-city.c", "hypo_code": "int* avoidFlood(int* rains, int rainsSize, int* returnSize){\nint *result = malloc(rainsSize * sizeof(int));\n    *returnSize = rainsSize;\n    int *lakes = calloc(rainsSize, sizeof(int));\n    int *dry = calloc(rainsSize, sizeof(int));\n    int dryIndex = 0;\n    for (int i = 0; i < rainsSize; i++) {\n        if (rains[i] == 0) {\n            dry[dryIndex++] = i;\n        } else {\n            if (lakes[rains[i]] == 1) {\n                int isDry = 0;\n                for (int j = 0; j < dryIndex; j++) {\n                    if (dry[j] > i) {\n                        isDry = 1;\n                        result[dry[j]] = rains[i];\n                        dry[j] = -1;\n                        break;\n                    }\n                }\n                if (isDry == 0) {\n                    *returnSize = 0;\n                    break;\n                }\n            } else {\n                lakes[rains[i]] = 1;\n            }\n        }\n    }\n    if (*returnSize == 0) {\n        return result;\n    }\n    for (int i = 0; i < dryIndex; i++) {\n        if (dry[i] != -1) {\n            result[dry[i]] = 1;\n        }\n    }\n    return result;\n}", "prefix": "int* avoidFlood(int* rains, int rainsSize, int* returnSize"}
{"id": "1263", "path": "output2\\c\\Medium\\1263-the-kth-factor-of-n.c", "hypo_code": "int kthFactor(int n, int k){\nint count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            count++;\n        }\n        if (count == k) {\n            return i;\n        }\n    }\n    return -1;\n}", "prefix": "int kthFactor(int n, int k"}
{"id": "1264", "path": "output2\\c\\Medium\\1264-longest-subarray-of-1s-after-deleting-one-element.c", "hypo_code": "int longestSubarray(int* nums, int numsSize){\nint max = 0;\n    int count = 0;\n    int count1 = 0;\n    int count0 = 0;\n    int start = 0;\n    int end = 0;\n    while (end < numsSize) {\n        if (nums[end] == 1) {\n            count1++;\n        }\n        if (nums[end] == 0) {\n            count0++;\n        }\n        end++;\n        count++;\n        if (count0 > 1) {\n            while (start < end) {\n                if (nums[start] == 1) {\n                    count1--;\n                }\n                if (nums[start] == 0) {\n                    count0--;\n                }\n                start++;\n                count--;\n                if (count0 <= 1) {\n                    break;\n                }\n            }\n        }\n        if (count > max) {\n            max = count;\n        }\n    }\n    return max - 1;\n}", "prefix": "int longestSubarray(int* nums, int numsSize"}
{"id": "1265", "path": "output2\\c\\Medium\\1265-check-if-array-pairs-are-divisible-by-k.c", "hypo_code": "bool canArrange(int* arr, int arrSize, int k){\nint *count = calloc(k, sizeof(int));\n    for (int i = 0; i < arrSize; i++) {\n        count[((arr[i] % k) + k) % k]++;\n    }\n    if (count[0] % 2 != 0) {\n        return false;\n    }\n    for (int i = 1; i < k / 2; i++) {\n        if (count[i] != count[k - i]) {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool canArrange(int* arr, int arrSize, int k"}
{"id": "1266", "path": "output2\\c\\Medium\\1266-number-of-subsequences-that-satisfy-the-given-sum-condition.c", "hypo_code": "int numSubseq(int* nums, int numsSize, int target){\nint *pow2 = calloc(numsSize, sizeof(int));\n    pow2[0] = 1;\n    for (int i = 1; i < numsSize; i++) {\n        pow2[i] = (pow2[i - 1] * 2) % 1000000007;\n    }\n    qsort(nums, numsSize, sizeof(int), cmp);\n    int count = 0;\n    int start = 0;\n    int end = numsSize - 1;\n    while (start <= end) {\n        if (nums[start] + nums[end] > target) {\n            end--;\n        } else {\n            count = (count + pow2[end - start]) % 1000000007;\n            start++;\n        }\n    }\n    free(pow2);\n    return count;\n}", "prefix": "int numSubseq(int* nums, int numsSize, int target"}
{"id": "1267", "path": "output2\\c\\Medium\\1267-last-moment-before-all-ants-fall-out-of-a-plank.c", "hypo_code": "int getLastMoment(int n, int* left, int leftSize, int* right, int rightSize){\nint max = 0;\n    for (int i = 0; i < leftSize; i++) {\n        if (left[i] > max) {\n            max = left[i];\n        }\n    }\n    for (int i = 0; i < rightSize; i++) {\n        if (n - right[i] > max) {\n            max = n - right[i];\n        }\n    }\n    return max;\n}", "prefix": "int getLastMoment(int n, int* left, int leftSize, int* right, int rightSize"}
{"id": "1268", "path": "output2\\c\\Medium\\1268-count-submatrices-with-all-ones.c", "hypo_code": "int numSubmat(int** mat, int matSize, int* matColSize){\nint count = 0;\n    for (int i = 0; i < matSize; i++) {\n        for (int j = 0; j < *matColSize; j++) {\n            if (mat[i][j] == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int numSubmat(int** mat, int matSize, int* matColSize"}
{"id": "1269", "path": "output2\\c\\Medium\\1269-range-sum-of-sorted-subarray-sums.c", "hypo_code": "int rangeSum(int* nums, int numsSize, int n, int left, int right){\nint *sum = calloc(numsSize + 1, sizeof(int));\n    int *result = calloc(n, sizeof(int));\n    for (int i = 0; i < numsSize; i++) {\n        sum[i + 1] = sum[i] + nums[i];\n    }\n    int index = 0;\n    for (int i = 0; i < numsSize; i++) {\n        for (int j = i + 1; j <= numsSize; j++) {\n            result[index++] = sum[j] - sum[i];\n        }\n    }\n    qsort(result, n, sizeof(int), cmp);\n    int count = 0;\n    for (int i = left - 1; i < right; i++) {\n        count = (count + result[i]) % 1000000007;\n    }\n    free(sum);\n    free(result);\n    return count;\n}", "prefix": "int rangeSum(int* nums, int numsSize, int n, int left, int right"}
{"id": "1270", "path": "output2\\c\\Medium\\1270-minimum-difference-between-largest-and-smallest-value-in-three-moves.c", "hypo_code": "int minDifference(int* nums, int numsSize){\nif (numsSize <= 4) {\n        return 0;\n    }\n    qsort(nums, numsSize, sizeof(int), cmp);\n    int min = nums[numsSize - 1] - nums[0];\n    for (int i = 0; i < 4; i++) {\n        if (nums[numsSize - 4 + i] - nums[i] < min) {\n            min = nums[numsSize - 4 + i] - nums[i];\n        }\n    }\n    return min;\n\n}", "prefix": "int minDifference(int* nums, int numsSize"}
{"id": "1271", "path": "output2\\c\\Medium\\1271-number-of-substrings-with-only-1s.c", "hypo_code": "int numSub(char * s){\nint len = strlen(s);\n    if (len == 0) {\n        return 0;\n    }\n    int count = 0;\n    int sum = 0;\n    for (int i = 0; i < len; i++) {\n        if (s[i] == '1') {\n            count++;\n        } else {\n            sum = (sum + (long)count * (count + 1) / 2) % 1000000007;\n            count = 0;\n        }\n    }\n    sum = (sum + (long)count * (count + 1) / 2) % 1000000007;\n    return sum;\n}", "prefix": "int numSub(char * s"}
{"id": "1272", "path": "output2\\c\\Medium\\1272-path-with-maximum-probability.c", "hypo_code": "double maxProbability(int n, int** edges, int edgesSize, int* edgesColSize, double* succProb, int succProbSize, int start_node, int end_node){\ndouble *dist = calloc(n, sizeof(double));\n    bool *visited = calloc(n, sizeof(bool));\n    int **graph = calloc(n, sizeof(int *));\n    int *graphSize = calloc(n, sizeof(int));\n    for (int i = 0; i < edgesSize; i++) {\n        graph[edges[i][0]] = realloc(graph[edges[i][0]], (graphSize[edges[i][0]] + 1) * sizeof(int));\n        graph[edges[i][1]] = realloc(graph[edges[i][1]], (graphSize[edges[i][1]] + 1) * sizeof(int));\n        graph[edges[i][0]][graphSize[edges[i][0]]] = edges[i][1];\n        graph[edges[i][1]][graphSize[edges[i][1]]] = edges[i][0];\n        graphSize[edges[i][0]]++;\n        graphSize[edges[i][1]]++;\n    }\n    dist[start_node] = 1;\n    for (int i = 0; i < n; i++) {\n        int min = -1;\n        for (int j = 0; j < n; j++) {\n            if (visited[j] == false && (min == -1 || dist[j] > dist[min])) {\n                min = j;\n            }\n        }\n        visited[min] = true;\n        for (int j = 0; j < graphSize[min]; j++) {\n            if (visited[graph[min][j]] == false) {\n                if (dist[min] * succProb[graph[min][j]] > dist[graph[min][j]]) {\n                    dist[graph[min][j]] = dist[min] * succProb[graph[min][j]];\n                }\n            }\n        }\n    }\n    return dist[end_node];\n}", "prefix": "double maxProbability(int n, int** edges, int edgesSize, int* edgesColSize, double* succProb, int succProbSize, int start_node, int end_node"}
{"id": "1273", "path": "output2\\c\\Medium\\1273-number-of-nodes-in-the-sub-tree-with-the-same-label.c", "hypo_code": "int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize){\nint *result = malloc(n * sizeof(int));\n    *returnSize = n;\n    int **matrix = malloc(n * sizeof(int *));\n    for (int i = 0; i < n; i++) {\n        matrix[i] = calloc(n, sizeof(int));\n    }\n    for (int i = 0; i < edgesSize; i++) {\n        matrix[edges[i][0]][edges[i][1]] = 1;\n        matrix[edges[i][1]][edges[i][0]] = 1;\n    }\n    int *queue = malloc(n * sizeof(int));\n    int queueStart = 0;\n    int queueEnd = 0;\n    int *visited = calloc(n, sizeof(int));\n    queue[queueEnd++] = 0;\n    visited[0] = 1;\n    while (queueStart < queueEnd) {\n        int node = queue[queueStart++];\n        for (int i = 0; i < n; i++) {\n            if (matrix[node][i] == 1 && visited[i] == 0) {\n                queue[queueEnd++] = i;\n                visited[i] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        int *alphabet = calloc(26, sizeof(int));\n        int *visited = calloc(n, sizeof(int));\n        queueStart = 0;\n        queueEnd = 0;\n        queue[queueEnd++] = i;\n        visited[i] = 1;\n        while (queueStart < queueEnd) {\n            int node = queue[queueStart++];\n            alphabet[labels[node] - 'a']++;\n            for (int j = 0; j < n; j++) {\n                if (matrix[node][j] == 1 && visited[j] == 0) {\n                    queue[queueEnd++] = j;\n                    visited[j] = 1;\n                }\n            }\n        }\n        result[i] = alphabet[labels[i] - 'a'];\n    }\n    return result;\n\n}", "prefix": "int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize"}
{"id": "1274", "path": "output2\\c\\Medium\\1274-number-of-sub-arrays-with-odd-sum.c", "hypo_code": "int numOfSubarrays(int* arr, int arrSize){\n    int odd = 0;\n    int even = 0;\n    int sum = 0;\n    int count = 0;\n    for(int i = 0; i < arrSize; i++){\n        sum += arr[i];\n        if(sum % 2 == 0){\n            count += odd;\n            even++;\n        }else{\n            count += even;\n            odd++;\n        }\n    }\n    return count % 1000000007;\n\n\n}", "prefix": "int numOfSubarrays(int* arr, int arrSize"}
{"id": "1275", "path": "output2\\c\\Medium\\1275-number-of-good-ways-to-split-a-string.c", "hypo_code": "int numSplits(char * s){\n    int count = 0;\n    int left[26] = {0};\n    int right[26] = {0};\n    int leftCount = 0;\n    int rightCount = 0;\n    int len = strlen(s);\n    for(int i = 0; i < len; i++){\n        if(right[s[i] - 'a'] == 0){\n            rightCount++;\n        }\n        right[s[i] - 'a']++;\n    }\n    for(int i = 0; i < len; i++){\n        if(left[s[i] - 'a'] == 0){\n            leftCount++;\n        }\n        left[s[i] - 'a']++;\n        right[s[i] - 'a']--;\n        if(right[s[i] - 'a'] == 0){\n            rightCount--;\n        }\n        if(leftCount == rightCount){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int numSplits(char * s"}
{"id": "1276", "path": "output2\\c\\Medium\\1276-minimum-suffix-flips.c", "hypo_code": "int minFlips(char * target){\n    int count = 0;\n    int len = strlen(target);\n    for(int i = 0; i < len; i++){\n        if(target[i] == '1'){\n            count++;\n            while(i < len && target[i] == '1'){\n                i++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int minFlips(char * target"}
{"id": "1277", "path": "output2\\c\\Medium\\1277-number-of-good-leaf-nodes-pairs.c", "hypo_code": "int countPairs(struct TreeNode* root, int distance){\n    int count = 0;\n    int* arr = (int*)malloc(sizeof(int) * distance);\n    for(int i = 0; i < distance; i++){\n        arr[i] = 0;\n    }\n    countPairsHelper(root, distance, arr, &count);\n    return count;\n\n}", "prefix": "int countPairs(struct TreeNode* root, int distance"}
{"id": "1278", "path": "output2\\c\\Medium\\1278-find-the-winner-of-an-array-game.c", "hypo_code": "int getWinner(int* arr, int arrSize, int k){\nint i = 1;\n    int win_count = 0;\n    int max = arr[0];\n    while (i < arrSize)\n    {\n        if (arr[i] > max)\n        {\n            max = arr[i];\n            win_count = 1;\n        }\n        else\n        {\n            win_count++;\n        }\n        if (win_count == k)\n        {\n            break;\n        }\n        i++;\n    }\n    return max;\n}", "prefix": "int getWinner(int* arr, int arrSize, int k"}
{"id": "1279", "path": "output2\\c\\Medium\\1279-minimum-swaps-to-arrange-a-binary-grid.c", "hypo_code": "int minSwaps(int** grid, int gridSize, int* gridColSize){\nint i, j, k;\n    int count = 0;\n    int *arr = (int*)malloc(sizeof(int)*gridSize);\n    for (i = 0; i < gridSize; i++)\n    {\n        arr[i] = 0;\n        for (j = *gridColSize - 1; j >= 0; j--)\n        {\n            if (grid[i][j] == 0)\n            {\n                arr[i]++;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    for (i = 0; i < gridSize - 1; i++)\n    {\n        if (arr[i] < gridSize - 1 - i)\n        {\n            for (j = i + 1; j < gridSize; j++)\n            {\n                if (arr[j] >= gridSize - 1 - i)\n                {\n                    break;\n                }\n            }\n            if (j < gridSize)\n            {\n                for (k = j; k > i; k--)\n                {\n                    arr[k] = arr[k - 1];\n                    count++;\n                }\n            }\n            else\n            {\n                return -1;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int minSwaps(int** grid, int gridSize, int* gridColSize"}
{"id": "1280", "path": "output2\\c\\Medium\\1280-can-convert-string-in-k-moves.c", "hypo_code": "bool canConvertString(char * s, char * t, int k){\nn = len(grid)\n        res = 0\n        for i in range(n):\n            zeros = 0\n            for j in range(n - 1, -1, -1):\n                if grid[i][j] == 0:\n                    zeros += 1\n                else:\n                    break\n            if zeros < n - i - 1:\n                j = i + 1\n                while j < n and zeros < n - i - 1:\n                    if grid[j][i] == 0:\n                        zeros += 1\n                        res += 1\n                    else:\n                        j += 1\n                if zeros < n - i - 1:\n                    return -1\n        return res\n}", "prefix": "bool canConvertString(char * s, char * t, int k"}
{"id": "1281", "path": "output2\\c\\Medium\\1281-minimum-insertions-to-balance-a-parentheses-string.c", "hypo_code": "int minInsertions(char * s){\nint i = 0;\n    int count = 0;\n    int right = 0;\n    int len = strlen(s);\n    while (i < len)\n    {\n        if (s[i] == '(')\n        {\n            right++;\n        }\n        else\n        {\n            if (right == 0)\n            {\n                count++;\n            }\n            else\n            {\n                right--;\n            }\n            if (i == len - 1 || s[i + 1] != ')')\n            {\n                count++;\n            }\n            else\n            {\n                i++;\n            }\n        }\n        i++;\n    }\n    return count + right * 2;\n}", "prefix": "int minInsertions(char * s"}
{"id": "1282", "path": "output2\\c\\Medium\\1282-find-kth-bit-in-nth-binary-string.c", "hypo_code": "char findKthBit(int n, int k){\nint i, j;\n    int len;\n    int mid;\n    int *arr = (int*)malloc(sizeof(int)*n);\n    arr[0] = 0;\n    for (i = 1; i < n; i++)\n    {\n        len = (1 << i) - 1;\n        mid = len / 2;\n        arr[i] = 1 - arr[i - 1];\n        if (k == mid + 1)\n        {\n            return arr[i] + '0';\n        }\n        else if (k > mid + 1)\n        {\n            k = len - k + 1;\n            for (j = i - 1; j >= 0; j--)\n            {\n                if (arr[j] == 0)\n                {\n                    arr[j] = 1;\n                }\n                else\n                {\n                    arr[j] = 0;\n                }\n            }\n        }\n    }\n    return arr[n - 1] + '0';\n}", "prefix": "char findKthBit(int n, int k"}
{"id": "1283", "path": "output2\\c\\Medium\\1283-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target.c", "hypo_code": "int maxNonOverlapping(int* nums, int numsSize, int target){\nint i;\n    int sum = 0;\n    int count = 0;\n    int *arr = (int*)malloc(sizeof(int)*numsSize);\n    memset(arr, 0, sizeof(int)*numsSize);\n    for (i = 0; i < numsSize; i++)\n    {\n        sum += nums[i];\n        if (sum == target)\n        {\n            count++;\n            sum = 0;\n        }\n        else if (sum > target)\n        {\n            sum = 0;\n        }\n        else if (arr[sum] == 1)\n        {\n            sum = 0;\n        }\n        else\n        {\n            arr[sum] = 1;\n        }\n    }\n    return count;\n}", "prefix": "int maxNonOverlapping(int* nums, int numsSize, int target"}
{"id": "1284", "path": "output2\\c\\Medium\\1284-minimum-operations-to-make-array-equal.c", "hypo_code": "int minOperations(int n){\nint i = 0;\n    int count = 0;\n    while (i < n / 2)\n    {\n        count += n - (2 * i + 1);\n        i++;\n    }\n    return count;\n\n}", "prefix": "int minOperations(int n"}
{"id": "1285", "path": "output2\\c\\Medium\\1285-magnetic-force-between-two-balls.c", "hypo_code": "int maxDistance(int* position, int positionSize, int m){\nint i, j;\n    int left = 1;\n    int right = position[positionSize - 1] - position[0];\n    int mid = 0;\n    int count = 0;\n    while (left < right)\n    {\n        mid = left + (right - left + 1) / 2;\n        count = 1;\n        j = 0;\n        for (i = 1; i < positionSize; i++)\n        {\n            if (position[i] - position[j] >= mid)\n            {\n                count++;\n                j = i;\n            }\n        }\n        if (count >= m)\n        {\n            left = mid;\n        }\n        else\n        {\n            right = mid - 1;\n        }\n    }\n    return left;\n}", "prefix": "int maxDistance(int* position, int positionSize, int m"}
{"id": "1286", "path": "output2\\c\\Medium\\1286-minimum-number-of-vertices-to-reach-all-nodes.c", "hypo_code": "int* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int* arr = malloc(n * sizeof(int));\n    int* visited = malloc(n * sizeof(int));\n    for(int i = 0; i < n; i++){\n        visited[i] = 0;\n    }\n    for(int i = 0; i < edgesSize; i++){\n        visited[edges[i][1]] = 1;\n    }\n    int count = 0;\n    for(int i = 0; i < n; i++){\n        if(visited[i] == 0){\n            arr[count++] = i;\n        }\n    }\n    *returnSize = count;\n    return arr;\n\n}", "prefix": "int* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize"}
{"id": "1287", "path": "output2\\c\\Medium\\1287-minimum-numbers-of-function-calls-to-make-target-array.c", "hypo_code": "int minOperations(int* nums, int numsSize){\nint i, j;\n    int max = 0;\n    int count = 0;\n    for (i = 0; i < numsSize; i++)\n    {\n        count = 0;\n        for (j = 0; j < 32; j++)\n        {\n            if (nums[i] & (1 << j))\n            {\n                count++;\n            }\n        }\n        if (count > max)\n        {\n            max = count;\n        }\n    }\n    count = 0;\n    for (i = 0; i < numsSize; i++)\n    {\n        count += max - nums[i];\n    }\n    return count;\n}", "prefix": "int minOperations(int* nums, int numsSize"}
{"id": "1288", "path": "output2\\c\\Medium\\1288-detect-cycles-in-2d-grid.c", "hypo_code": "bool containsCycle(char** grid, int gridSize, int* gridColSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int row = gridSize;\n    int col = gridColSize[0];\n    int* arr = (int*)malloc(sizeof(int) * row * col);\n    for(i = 0; i < row * col; i++){\n        arr[i] = 0;\n    }\n    for(i = 0; i < row; i++){\n        for(j = 0; j < col; j++){\n            if(arr[i * col + j] == 0){\n                arr[i * col + j] = 1;\n                if(containsCycleHelper(grid, gridSize, gridColSize, i, j, i, j, arr)){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n\n}", "prefix": "bool containsCycle(char** grid, int gridSize, int* gridColSize"}
{"id": "1289", "path": "output2\\c\\Medium\\1289-maximum-number-of-coins-you-can-get.c", "hypo_code": "int maxCoins(int* piles, int pilesSize){\n    int i, j, k, count = 0;\n    int len = pilesSize / 3;\n    int temp;\n    for(i = 0; i < pilesSize - 1; i++){\n        for(j = i + 1; j < pilesSize; j++){\n            if(piles[i] < piles[j]){\n                temp = piles[i];\n                piles[i] = piles[j];\n                piles[j] = temp;\n            }\n        }\n    }\n    for(i = 1; i < pilesSize; i += 2){\n        count += piles[i];\n    }\n    return count;\n\n}", "prefix": "int maxCoins(int* piles, int pilesSize"}
{"id": "1290", "path": "output2\\c\\Medium\\1290-find-latest-group-of-size-m.c", "hypo_code": "int findLatestStep(int* arr, int arrSize, int m){\n    int i, j, k, l, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int* arr2 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int) * arrSize);\n    for(i = 0; i < arrSize; i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int) * arrSize);\n\n}", "prefix": "int findLatestStep(int* arr, int arrSize, int m"}
{"id": "1291", "path": "output2\\c\\Medium\\1291-maximum-length-of-subarray-with-positive-product.c", "hypo_code": "int getMaxLen(int* nums, int numsSize){\nint i;\n    int max = 0;\n    int count = 0;\n    int negative = 0;\n    int first_negative = -1;\n    int first_zero = -1;\n    for (i = 0; i < numsSize; i++)\n    {\n        if (nums[i] == 0)\n        {\n            count = 0;\n            negative = 0;\n            first_negative = -1;\n            first_zero = i;\n        }\n        else\n        {\n            count++;\n            if (nums[i] < 0)\n            {\n                negative++;\n                if (first_negative == -1)\n                {\n                    first_negative = i;\n                }\n            }\n            if (negative % 2 == 0)\n            {\n                if (count > max)\n                {\n                    max = count;\n                }\n            }\n            else\n            {\n                if (count - 1 > max)\n                {\n                    max = count - 1;\n                }\n            }\n        }\n    }\n    return max;\n}", "prefix": "int getMaxLen(int* nums, int numsSize"}
{"id": "1292", "path": "output2\\c\\Medium\\1292-number-of-ways-to-split-a-string.c", "hypo_code": "int numWays(char * s){\n    int count = 0;\n    int len = strlen(s);\n    int oneCount = 0;\n    int twoCount = 0;\n    int threeCount = 0;\n    for(int i = 0; i < len; i++){\n        if(s[i] == '1'){\n            oneCount++;\n        }\n    }\n    if(oneCount % 3 != 0){\n        return 0;\n    }\n    if(oneCount == 0){\n        return (int)(((long long)(len - 1) * (long long)(len - 2) / 2) % 1000000007);\n    }\n    int one = oneCount / 3;\n    int two = one * 2;\n    int oneIndex = 0;\n    int twoIndex = 0;\n    int threeIndex = 0;\n    for(int i = 0; i < len; i++){\n        if(s[i] == '1'){\n            oneIndex++;\n            if(oneIndex == one){\n                twoIndex = oneIndex;\n            }\n            if(oneIndex == two){\n                threeIndex = oneIndex;\n            }\n        }\n        if(oneIndex == one){\n            twoCount++;\n        }\n        if(oneIndex == two){\n            threeCount++;\n        }\n    }\n    return (int)(((long long)twoCount * (long long)threeCount) % 1000000007);\n\n}", "prefix": "int numWays(char * s"}
{"id": "1293", "path": "output2\\c\\Medium\\1293-shortest-subarray-to-be-removed-to-make-array-sorted.c", "hypo_code": "int findLengthOfShortestSubarray(int* arr, int arrSize){\n    int start = 0;\n    int end = arrSize - 1;\n    while(start < end && arr[start] <= arr[start + 1]){\n        start++;\n    }\n    if(start == end){\n        return 0;\n    }\n    while(end > start && arr[end] >= arr[end - 1]){\n        end--;\n    }\n    int count = end - start - 1;\n    int i = 0;\n    int j = end;\n    while(i <= start && j < arrSize){\n        if(arr[i] <= arr[j]){\n            count = fmin(count, j - i - 1);\n            i++;\n        }else{\n            j++;\n        }\n    }\n    return count;\n\n}", "prefix": "int findLengthOfShortestSubarray(int* arr, int arrSize"}
{"id": "1294", "path": "output2\\c\\Medium\\1294-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers.c", "hypo_code": "int numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int i, j, k, count = 0;\n    for(i = 0; i < nums1Size; i++){\n        for(j = 0; j < nums2Size - 1; j++){\n            for(k = j + 1; k < nums2Size; k++){\n                if(nums1[i] * nums1[i] == nums2[j] * nums2[k]){\n                    count++;\n                }\n            }\n        }\n    }\n    for(i = 0; i < nums2Size; i++){\n        for(j = 0; j < nums1Size - 1; j++){\n            for(k = j + 1; k < nums1Size; k++){\n                if(nums2[i] * nums2[i] == nums1[j] * nums1[k]){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "1295", "path": "output2\\c\\Medium\\1295-minimum-time-to-make-rope-colorful.c", "hypo_code": "int minCost(char * colors, int* neededTime, int neededTimeSize){\n    int i, j, k, len = strlen(colors), min = 0, count = 0;\n    int dp[26][len];\n    for(i = 0; i < 26; i++){\n        for(j = 0; j < len; j++){\n            dp[i][j] = 0;\n        }\n    }\n    for(i = 0; i < len; i++){\n        dp[colors[i] - 'a'][i] = neededTime[i];\n    }\n    for(i = 0; i < 26; i++){\n        for(j = 1; j < len; j++){\n            if(dp[i][j] != 0){\n                dp[i][j] += dp[i][j - 1];\n            }\n        }\n    }\n    for(i = 0; i < len; i++){\n        min = 0;\n        for(j = 0; j < 26; j++){\n            if(dp[j][i] != 0){\n                if(min == 0){\n                    min = dp[j][i];\n                }else if(min > dp[j][i]){\n                    min = dp[j][i];\n                }\n            }\n        }\n        count += min;\n    }\n    return count;\n\n}", "prefix": "int minCost(char * colors, int* neededTime, int neededTimeSize"}
{"id": "1296", "path": "output2\\c\\Medium\\1296-count-unhappy-friends.c", "hypo_code": "int unhappyFriends(int n, int** preferences, int preferencesSize, int* preferencesColSize, int** pairs, int pairsSize, int* pairsColSize){\nint i, j, k;\n    int *arr = (int*)malloc(sizeof(int)*n);\n    int *map = (int*)malloc(sizeof(int)*n);\n    int res = 0;\n    for (i = 0; i < n; i++)\n    {\n        arr[i] = -1;\n        map[pairs[i][0]] = pairs[i][1];\n        map[pairs[i][1]] = pairs[i][0];\n    }\n    for (i = 0; i < n; i++)\n    {\n        if (arr[i] != -1)\n        {\n            continue;\n        }\n        for (j = 0; j < n - 1; j++)\n        {\n            if (preferences[i][j] == map[i])\n            {\n                break;\n            }\n        }\n        if (j < n - 1)\n        {\n            continue;\n        }\n        for (j = 0; j < n - 1; j++)\n        {\n            for (k = 0; k < n - 1; k++)\n            {\n                if (preferences[i][j] == pairs[i][k])\n                {\n                    break;\n                }\n            }\n            for (k = 0; k < n - 1; k++)\n            {\n                if (preferences[i][j] == preferences[pairs[i][k]][pairsColSize[pairs[i][k]] - 1])\n                {\n                    break;\n                }\n            }\n            if (k < n - 1)\n            {\n                break;\n            }\n        }\n        if (j < n - 1)\n        {\n            continue;\n        }\n        for (j = 0; j < n - 1; j++)\n        {\n            if (preferences[i][j] == map[preferences[i][j + 1]])\n            {\n                break;\n            }\n        }\n        if (j < n - 1)\n        {\n            continue;\n        }\n        arr[i] = 1;\n        arr[map[i]] = 1;\n        res += 2;\n    }\n    return res;\n}", "prefix": "int unhappyFriends(int n, int** preferences, int preferencesSize, int* preferencesColSize, int** pairs, int pairsSize, int* pairsColSize"}
{"id": "1297", "path": "output2\\c\\Medium\\1297-min-cost-to-connect-all-points.c", "hypo_code": "int minCostConnectPoints(int** points, int pointsSize, int* pointsColSize){\nint i, j, k;\n    int min = 0;\n    int count = 0;\n    int* distance = (int*)malloc(sizeof(int) * pointsSize);\n    int* visited = (int*)malloc(sizeof(int) * pointsSize);\n    memset(visited, 0, sizeof(int) * pointsSize);\n    memset(distance, 0, sizeof(int) * pointsSize);\n    for (i = 0; i < pointsSize; i++)\n    {\n        distance[i] = abs(points[0][0] - points[i][0]) + abs(points[0][1] - points[i][1]);\n    }\n    visited[0] = 1;\n    count++;\n    while (count < pointsSize)\n    {\n        min = INT_MAX;\n        for (i = 0; i < pointsSize; i++)\n        {\n            if (!visited[i] && distance[i] < min)\n            {\n                min = distance[i];\n                k = i;\n            }\n        }\n        visited[k] = 1;\n        count++;\n        for (j = 0; j < pointsSize; j++)\n        {\n            if (!visited[j] && (abs(points[k][0] - points[j][0]) + abs(points[k][1] - points[j][1])) < distance[j])\n            {\n                distance[j] = abs(points[k][0] - points[j][0]) + abs(points[k][1] - points[j][1]);\n            }\n        }\n    }\n    count = 0;\n    for (i = 0; i < pointsSize; i++)\n    {\n        count += distance[i];\n    }\n    free(distance);\n    free(visited);\n    return count;\n}", "prefix": "int minCostConnectPoints(int** points, int pointsSize, int* pointsColSize"}
{"id": "1298", "path": "output2\\c\\Medium\\1298-maximum-sum-obtained-of-any-permutation.c", "hypo_code": "int maxSumRangeQuery(int* nums, int numsSize, int** requests, int requestsSize, int* requestsColSize){\nint i;\n    int j;\n    int max = 0;\n    int *arr = (int*)malloc(sizeof(int)*numsSize);\n    memset(arr, 0, sizeof(int)*numsSize);\n    for (i = 0; i < requestsSize; i++)\n    {\n        for (j = requests[i][0]; j <= requests[i][1]; j++)\n        {\n            arr[j]++;\n        }\n    }\n    qsort(nums, numsSize, sizeof(int), cmp);\n    qsort(arr, numsSize, sizeof(int), cmp);\n    for (i = 0; i < numsSize; i++)\n    {\n        max += nums[i] * arr[i];\n    }\n    return max % 1000000007;\n}\nint cmp(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}", "prefix": "int maxSumRangeQuery(int* nums, int numsSize, int** requests, int requestsSize, int* requestsColSize"}
{"id": "1299", "path": "output2\\c\\Medium\\1299-make-sum-divisible-by-p.c", "hypo_code": "int minSubarray(int* nums, int numsSize, int p){\nint i;\n    int sum = 0;\n    int rem = 0;\n    int min = numsSize;\n    int *arr = (int*)malloc(sizeof(int)*numsSize);\n    memset(arr, -1, sizeof(int)*numsSize);\n    for (i = 0; i < numsSize; i++)\n    {\n        sum += nums[i];\n        rem = sum % p;\n        if (rem == 0)\n        {\n            if (i + 1 < min)\n            {\n                min = i + 1;\n            }\n        }\n        else\n        {\n            if (arr[rem] != -1)\n            {\n                if (i - arr[rem] < min)\n                {\n                    min = i - arr[rem];\n                }\n            }\n            arr[rem] = i;\n        }\n    }\n    if (min == numsSize)\n    {\n        return -1;\n    }\n    return min;\n}", "prefix": "int minSubarray(int* nums, int numsSize, int p"}
{"id": "1300", "path": "output2\\c\\Medium\\1300-split-a-string-into-the-max-number-of-unique-substrings.c", "hypo_code": "int maxUniqueSplit(char * s){\nint i;\n    int count = 0;\n    int len = strlen(s);\n    for (i = 0; i < len; i++)\n    {\n        if (s[i] != '\\0')\n        {\n            count++;\n            dfs(s, len, i);\n        }\n    }\n    return count;\n}\n\nvoid dfs(char *s, int len, int start)\n{\n    int i;\n    int j;\n    int flag = 0;\n    for (i = start + 1; i < len; i++)\n    {\n        if (s[i] != '\\0')\n        {\n            for (j = start; j < i; j++)\n            {\n                if (s[j] == s[i])\n                {\n                    flag = 1;\n                    break;\n                }\n            }\n            if (flag == 0)\n            {\n                s[i] = '\\0';\n                dfs(s, len, i);\n                s[i] = s[i];\n            }\n            flag = 0;\n        }\n    }\n}", "prefix": "int maxUniqueSplit(char * s"}
{"id": "1301", "path": "output2\\c\\Medium\\1301-maximum-non-negative-product-in-a-matrix.c", "hypo_code": "int maxProductPath(int** grid, int gridSize, int* gridColSize){\nint i, j;\n    int **max = (int**)malloc(sizeof(int*)*gridSize);\n    int **min = (int**)malloc(sizeof(int*)*gridSize);\n    for (i = 0; i < gridSize; i++)\n    {\n        max[i] = (int*)malloc(sizeof(int)*gridColSize[0]);\n        min[i] = (int*)malloc(sizeof(int)*gridColSize[0]);\n        memset(max[i], 0, sizeof(int)*gridColSize[0]);\n        memset(min[i], 0, sizeof(int)*gridColSize[0]);\n    }\n    max[0][0] = grid[0][0];\n    min[0][0] = grid[0][0];\n    for (i = 1; i < gridSize; i++)\n    {\n        max[i][0] = max[i - 1][0] * grid[i][0];\n        min[i][0] = min[i - 1][0] * grid[i][0];\n    }\n    for (i = 1; i < gridColSize[0]; i++)\n    {\n        max[0][i] = max[0][i - 1] * grid[0][i];\n        min[0][i] = min[0][i - 1] * grid[0][i];\n    }\n    for (i = 1; i < gridSize; i++)\n    {\n        for (j = 1; j < gridColSize[0]; j++)\n        {\n            if (grid[i][j] >= 0)\n            {\n                max[i][j] = fmax(max[i - 1][j], max[i][j - 1]) * grid[i][j];\n                min[i][j] = fmin(min[i - 1][j], min[i][j - 1]) * grid[i][j];\n            }\n            else\n            {\n                max[i][j] = fmin(min[i - 1][j], min[i][j - 1]) * grid[i][j];\n                min[i][j] = fmax(max[i - 1][j], max[i][j - 1]) * grid[i][j];\n            }\n        }\n    }\n    int result = max[gridSize - 1][gridColSize[0] - 1] % 1000000007;\nif (result < 0)\n    {\n        return -1;\n    }\n    return result;\n}", "prefix": "int maxProductPath(int** grid, int gridSize, int* gridColSize"}
{"id": "1302", "path": "output2\\c\\Medium\\1302-maximum-profit-of-operating-a-centennial-wheel.c", "hypo_code": "int minOperationsMaxProfit(int* customers, int customersSize, int boardingCost, int runningCost){\nint i;\n    int sum = 0;\n    int count = 0;\n    int max = 0;\n    int max_round = 0;\n    for (i = 0; i < customersSize; i++)\n    {\n        sum += customers[i];\n        if (sum >= 4)\n        {\n            count += 4;\n            sum -= 4;\n        }\n        else\n        {\n            count += sum;\n            sum = 0;\n        }\n        if (count * boardingCost - (i + 1) * runningCost > max)\n        {\n            max = count * boardingCost - (i + 1) * runningCost;\n            max_round = i + 1;\n        }\n    }\n    while (sum > 0)\n    {\n        if (sum >= 4)\n        {\n            count += 4;\n            sum -= 4;\n        }\n        else\n        {\n            count += sum;\n            sum = 0;\n        }\n        if (count * boardingCost - (i + 1) * runningCost > max)\n        {\n            max = count * boardingCost - (i + 1) * runningCost;\n            max_round = i + 1;\n        }\n        i++;\n    }\n    if (max > 0)\n    {\n        return max_round;\n    }\n    return -1;\n}", "prefix": "int minOperationsMaxProfit(int* customers, int customersSize, int boardingCost, int runningCost"}
{"id": "1304", "path": "output2\\c\\Medium\\1304-alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.c", "hypo_code": "char ** alertNames(char ** keyName, int keyNameSize, char ** keyTime, int keyTimeSize, int* returnSize){\nint i, j, k;\n    int count = 0;\n    int* visited = (int*)malloc(sizeof(int) * keyNameSize);\n    memset(visited, 0, sizeof(int) * keyNameSize);\n    for (i = 0; i < keyNameSize; i++)\n    {\n        if (!visited[i])\n        {\n            count = 1;\n            for (j = i + 1; j < keyNameSize; j++)\n            {\n                if (!visited[j] && strcmp(keyName[i], keyName[j]) == 0)\n                {\n                    for (k = 0; k < keyTimeSize; k++)\n                    {\n                        if (strcmp(keyName[i], keyName[k]) == 0 && strcmp(keyTime[j], keyTime[k]) != 0 && abs((keyTime[j][0] - keyTime[k][0]) * 60 + (keyTime[j][1] - keyTime[k][1])) <= 60)\n                        {\n                            count++;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (count >= 3)\n            {\n                visited[i] = 1;\n            }\n        }\n    }\n    char** res = (char**)malloc(sizeof(char*) * keyNameSize);\n    for (i = 0; i < keyNameSize; i++)\n    {\n        res[i] = (char*)malloc(sizeof(char) * 11);\n        memset(res[i], 0, sizeof(char) * 11);\n    }\n    *returnSize = 0;\n    for (i = 0; i < keyNameSize; i++)\n    {\n        if (visited[i])\n        {\n            strcpy(res[*returnSize], keyName[i]);\n            (*returnSize)++;\n        }\n    }\n    free(visited);\n    return res;\n}", "prefix": "char ** alertNames(char ** keyName, int keyNameSize, char ** keyTime, int keyTimeSize, int* returnSize"}
{"id": "1305", "path": "output2\\c\\Medium\\1305-find-valid-matrix-given-row-and-column-sums.c", "hypo_code": "int** restoreMatrix(int* rowSum, int rowSumSize, int* colSum, int colSumSize, int* returnSize, int** returnColumnSizes){\nint i, j;\n    int **arr = (int**)malloc(sizeof(int*)*rowSumSize);\n    *returnSize = rowSumSize;\n    *returnColumnSizes = (int*)malloc(sizeof(int)*rowSumSize);\n    for (i = 0; i < rowSumSize; i++)\n    {\n        arr[i] = (int*)malloc(sizeof(int)*colSumSize);\n        memset(arr[i], 0, sizeof(int)*colSumSize);\n        (*returnColumnSizes)[i] = colSumSize;\n    }\n    for (i = 0; i < rowSumSize; i++)\n    {\n        for (j = 0; j < colSumSize; j++)\n        {\n            arr[i][j] = fmin(rowSum[i], colSum[j]);\n            rowSum[i] -= arr[i][j];\n            colSum[j] -= arr[i][j];\n        }\n    }\n    return arr;\n}", "prefix": "int** restoreMatrix(int* rowSum, int rowSumSize, int* colSum, int colSumSize, int* returnSize, int** returnColumnSizes"}
{"id": "1306", "path": "output2\\c\\Medium\\1306-even-odd-tree.c", "hypo_code": "bool isEvenOddTree(struct TreeNode* root){\nstruct TreeNode *queue[10000];\n    int front = 0;\n    int rear = 0;\n    int level = 0;\n    int count = 0;\n    int i;\n    int flag = 1;\n    queue[rear++] = root;\n    while (front != rear)\n    {\n        count = rear - front;\n        if (level % 2 == 0)\n        {\n            for (i = 0; i < count; i++)\n            {\n                if (queue[front]->val % 2 == 0)\n                {\n                    return false;\n                }\n                if (i > 0 && queue[front]->val <= queue[front - 1]->val)\n                {\n                    return false;\n                }\n                if (queue[front]->left != NULL)\n                {\n                    queue[rear++] = queue[front]->left;\n                }\n                if (queue[front]->right != NULL)\n                {\n                    queue[rear++] = queue[front]->right;\n                }\n                front++;\n            }\n        }\n        else\n        {\n            for (i = 0; i < count; i++)\n            {\n                if (queue[front]->val % 2 == 1)\n                {\n                    return false;\n                }\n                if (i > 0 && queue[front]->val >= queue[front - 1]->val)\n                {\n                    return false;\n                }\n                if (queue[front]->left != NULL)\n                {\n                    queue[rear++] = queue[front]->left;\n                }\n                if (queue[front]->right != NULL)\n                {\n                    queue[rear++] = queue[front]->right;\n                }\n                front++;\n            }\n        }\n        level++;\n    }\n    return true;\n}", "prefix": "bool isEvenOddTree(struct TreeNode* root"}
{"id": "1307", "path": "output2\\c\\Medium\\1307-maximal-network-rank.c", "hypo_code": "int maximalNetworkRank(int n, int** roads, int roadsSize, int* roadsColSize){\nint i, j;\n    int max = 0;\n    int count = 0;\n    int* arr = (int*)malloc(sizeof(int) * n * n);\n    memset(arr, 0, sizeof(int) * n * n);\n    for (i = 0; i < roadsSize; i++)\n    {\n        arr[roads[i][0] * n + roads[i][1]] = 1;\n        arr[roads[i][1] * n + roads[i][0]] = 1;\n    }\n    for (i = 0; i < n - 1; i++)\n    {\n        for (j = i + 1; j < n; j++)\n        {\n            count = 0;\n            if (arr[i * n + j] == 1)\n            {\n                count--;\n            }\n            for (int k = 0; k < n; k++)\n            {\n                if (arr[i * n + k] == 1)\n                {\n                    count++;\n                }\n                if (arr[j * n + k] == 1)\n                {\n                    count++;\n                }\n            }\n            if (count > max)\n            {\n                max = count;\n            }\n        }\n    }\n    free(arr);\n    return max;\n}", "prefix": "int maximalNetworkRank(int n, int** roads, int roadsSize, int* roadsColSize"}
{"id": "1308", "path": "output2\\c\\Medium\\1308-split-two-strings-to-make-palindrome.c", "hypo_code": "bool checkPalindromeFormation(char * a, char * b){         \n  \n}", "prefix": "bool checkPalindromeFormation(char * a, char * b"}
{"id": "1309", "path": "output2\\c\\Medium\\1309-coordinate-with-maximum-network-quality.c", "hypo_code": "int* bestCoordinate(int** towers, int towersSize, int* towersColSize, int radius, int* returnSize){\nint max_quality = 0;\n    int* ans = (int*)malloc(sizeof(int)*2);\n    *returnSize = 2;\n    for(int i = 0; i < towersSize; ++i) {\n        int quality = 0;\n        for(int j = 0; j < towersSize; ++j) {\n            int dist = sqrt(pow(towers[i][0]-towers[j][0],2)+pow(towers[i][1]-towers[j][1],2));\n            if(dist <= radius) {\n                quality += towers[j][2]/(1+dist);\n            }\n        }\n        if(quality > max_quality) {\n            max_quality = quality;\n            ans[0] = towers[i][0];\n            ans[1] = towers[i][1];\n        }\n    }\n    return ans;\n}", "prefix": "int* bestCoordinate(int** towers, int towersSize, int* towersColSize, int radius, int* returnSize"}
{"id": "1310", "path": "output2\\c\\Medium\\1310-number-of-sets-of-k-non-overlapping-line-segments.c", "hypo_code": "int numberOfSets(int n, int k){\nint dp[n+1][k+1];\n    memset(dp, 0, sizeof(dp));\n    for(int i = 0; i <= n; ++i) {\n        dp[i][0] = 1;\n    }\n    for(int i = 1; i <= k; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            for(int m = j+1; m <= n; ++m) {\n                dp[j][i] = (dp[j][i]+dp[m][i-1])%1000000007;\n            }\n        }\n    }\n    return dp[1][k];\n}", "prefix": "int numberOfSets(int n, int k"}
{"id": "1311", "path": "output2\\c\\Medium\\1311-lexicographically-smallest-string-after-applying-operations.c", "hypo_code": "char * findLexSmallestString(char * s, int a, int b){  \nchar* result = (char*)malloc(sizeof(char) * strlen(s) + 1);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for (i = 0; i < len; i++) {\n        str2[(i + b) % len] = s[i];\n    }\n    strcpy(result, str2);\n    for (i = 0; i < len; i++) {\n        if (visited[i] == 0) {\n            tmp = 0;\n            j = i;\n            while (visited[j] == 0) {\n                visited[j] = 1;\n                tmp++;\n                j = (j + b) % len;\n            }\n            if (tmp < len) {\n                for (k = 0; k < 10; k++) {\n                    for (l = 0; l < tmp; l++) {\n                        str[(i + l * a) % len] += 1;\n                        if (str[(i + l * a) % len] > '9') {\n                            str[(i + l * a) % len] = '0';\n                        }\n                    }\n                    if (strcmp(result, str) > 0) {\n                        strcpy(result, str);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}", "prefix": "char * findLexSmallestString(char * s, int a, int b"}
{"id": "1312", "path": "output2\\c\\Medium\\1312-best-team-with-no-conflicts.c", "hypo_code": "int bestTeamScore(int* scores, int scoresSize, int* ages, int agesSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                result[i] = j + '0';\n                break;\n            }\n        }\n    }\n    result[len] = '\\0';\n    free(visited);\n    free(str);\n    free(str2);\n    return result;\n}", "prefix": "int bestTeamScore(int* scores, int scoresSize, int* ages, int agesSize"}
{"id": "1313", "path": "output2\\c\\Medium\\1313-arithmetic-subarrays.c", "hypo_code": "bool* checkArithmeticSubarrays(int* nums, int numsSize, int* l, int lSize, int* r, int rSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] != str2[i])\n        {\n            count++;\n            visited[i] = 1;\n        }\n    }\n    if(count == 0)\n    {\n        return 0;\n    }\n    else if(count == 2)\n    {\n        for(i = 0; i < len; i++)\n        {\n            if(visited[i] == 1)\n            {\n                continue;\n            }\n            else\n            {\n                break;\n            }\n        }\n        if(i == len)\n        {\n            return 1;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    else\n    {\n        return 0;\n    }\n}", "prefix": "bool* checkArithmeticSubarrays(int* nums, int numsSize, int* l, int lSize, int* r, int rSize, int* returnSize"}
{"id": "1314", "path": "output2\\c\\Medium\\1314-path-with-minimum-effort.c", "hypo_code": "int minimumEffortPath(int** heights, int heightsSize, int* heightsColSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str2[j] < str2[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str2[i];\n            str2[i] = str2[min];\n            str2[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] != str2[i])\n        {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "int minimumEffortPath(int** heights, int heightsSize, int* heightsColSize"}
{"id": "1315", "path": "output2\\c\\Medium\\1315-widest-vertical-area-between-two-points-containing-no-points.c", "hypo_code": "int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n\n=======\nSuggestion 2\n\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            tmp = 0;\n            j = i;\n            while(visited[j] == 0)\n            {\n                visited[j] = 1;\n                tmp++;\n                j = (j + b) % len;\n            }\n            if(tmp < len)\n            {\n                for(k = 0; k < 10; k++)\n                {\n                    for(l = 0; l < tmp; l++)\n                    {\n                        str[(i + l * a) % len] += 1;\n                        if(str[(i + l * a) % len] > '9')\n                        {\n                            str[(i + l * a) % len] = '0';\n                        }\n                    }\n                    if(strcmp(result, str) > 0)\n                    {\n                        strcpy(result, str);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}", "prefix": "int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize"}
{"id": "1316", "path": "output2\\c\\Medium\\1316-count-substrings-that-differ-by-one-character.c", "hypo_code": "int countSubstrings(char * s, char * t){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int countSubstrings(char * s, char * t"}
{"id": "1317", "path": "output2\\c\\Medium\\1317-count-sorted-vowel-strings.c", "hypo_code": "int countVowelStrings(int n){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                str[i] = j + 'a';\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] != str2[i])\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int countVowelStrings(int n"}
{"id": "1318", "path": "output2\\c\\Medium\\1318-furthest-building-you-can-reach.c", "hypo_code": "int furthestBuilding(int* heights, int heightsSize, int bricks, int ladders){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                result[i] = j + '0';\n                break;\n            }\n        }\n    }\n    return result;\n}", "prefix": "int furthestBuilding(int* heights, int heightsSize, int bricks, int ladders"}
{"id": "1319", "path": "output2\\c\\Medium\\1319-minimum-deletions-to-make-character-frequencies-unique.c", "hypo_code": "int minDeletions(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                count++;\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    return len - count;\n}", "prefix": "int minDeletions(char * s"}
{"id": "1320", "path": "output2\\c\\Medium\\1320-sell-diminishing-valued-colored-balls.c", "hypo_code": "int maxProfit(int* inventory, int inventorySize, int orders){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int maxProfit(int* inventory, int inventorySize, int orders"}
{"id": "1321", "path": "output2\\c\\Medium\\1321-minimum-deletions-to-make-string-balanced.c", "hypo_code": "int minimumDeletions(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int minimumDeletions(char * s"}
{"id": "1322", "path": "output2\\c\\Medium\\1322-minimum-jumps-to-reach-home.c", "hypo_code": "int minimumJumps(int* forbidden, int forbiddenSize, int a, int b, int x){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int minimumJumps(int* forbidden, int forbiddenSize, int a, int b, int x"}
{"id": "1323", "path": "output2\\c\\Medium\\1323-determine-if-two-strings-are-close.c", "hypo_code": "bool closeStrings(char * word1, char * word2){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len1 = strlen(word1);\n    int len2 = strlen(word2);\n    int *a1 = (int*)malloc(sizeof(int) * 26);\n    int *a2 = (int*)malloc(sizeof(int) * 26);\n    memset(a1, 0, sizeof(int) * 26);\n    memset(a2, 0, sizeof(int) * 26);\n    for(i = 0; i < len1; i++)\n    {\n        a1[word1[i] - 'a']++;\n    }\n    for(i = 0; i < len2; i++)\n    {\n        a2[word2[i] - 'a']++;\n    }\n    for(i = 0; i < 26; i++)\n    {\n        if((a1[i] == 0 && a2[i] != 0) || (a1[i] != 0 && a2[i] == 0))\n        {\n            return false;\n        }\n    }\n    for(i = 0; i < 26; i++)\n    {\n        for(j = i + 1; j < 26; j++)\n        {\n            if(a1[i] < a1[j])\n            {\n                k = a1[i];\n                a1[i] = a1[j];\n                a1[j] = k;\n            }\n            if(a2[i] < a2[j])\n            {\n                k = a2[i];\n                a2[i] = a2[j];\n                a2[j] = k;\n            }\n        }\n    }\n    for(i = 0; i < 26; i++)\n    {\n        if(a1[i] != a2[i])\n        {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "bool closeStrings(char * word1, char * word2"}
{"id": "1324", "path": "output2\\c\\Medium\\1324-minimum-operations-to-reduce-x-to-zero.c", "hypo_code": "int minOperations(int* nums, int numsSize, int x){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            return false;\n        }\n    }\n    return true;\n\n}", "prefix": "int minOperations(int* nums, int numsSize, int x"}
{"id": "1325", "path": "output2\\c\\Medium\\1325-smallest-string-with-a-given-numeric-value.c", "hypo_code": "char * getSmallestString(int n, int k){\nchar* result = (char*)malloc(sizeof(char) * n + 1);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            count++;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            if(count > 0)\n            {\n                count--;\n                visited[i] = 1;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            result[j++] = str[i];\n        }\n    }\n    return result;\n}", "prefix": "char * getSmallestString(int n, int k"}
{"id": "1326", "path": "output2\\c\\Medium\\1326-ways-to-make-a-fair-array.c", "hypo_code": "int waysToMakeFair(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            flag = 1;\n            break;\n        }\n    }\n    if(flag == 0)\n    {\n        return 0;\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int waysToMakeFair(int* nums, int numsSize"}
{"id": "1327", "path": "output2\\c\\Medium\\1327-merge-in-between-linked-lists.c", "hypo_code": "struct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){\nstruct ListNode* cur = list1;\n    struct ListNode* tmp = NULL;\n    int i = 0;\n    int j = 0;\n    while(cur->next != NULL)\n    {\n        if(i == a - 1)\n        {\n            tmp = cur;\n        }\n        if(i == b + 1)\n        {\n            tmp->next = list2;\n            while(list2->next != NULL)\n            {\n                list2 = list2->next;\n            }\n            list2->next = cur;\n            break;\n        }\n        cur = cur->next;\n        i++;\n    }\n    return list1;\n}", "prefix": "struct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2"}
{"id": "1329", "path": "output2\\c\\Medium\\1329-find-the-most-competitive-subsequence.c", "hypo_code": "int* mostCompetitive(int* nums, int numsSize, int k, int* returnSize){\n    int* arr = malloc(k * sizeof(int));\n    int count = 0;\n    for(int i = 0; i < numsSize; i++){\n        while(count > 0 && arr[count - 1] > nums[i] && count + numsSize - i > k){\n            count--;\n        }\n        if(count < k){\n            arr[count++] = nums[i];\n        }\n    }\n    *returnSize = count;\n    return arr;\n\n}", "prefix": "int* mostCompetitive(int* nums, int numsSize, int k, int* returnSize"}
{"id": "1330", "path": "output2\\c\\Medium\\1330-minimum-moves-to-make-array-complementary.c", "hypo_code": "int minMoves(int* nums, int numsSize, int limit){\n    int* arr = malloc((2 * limit + 2) * sizeof(int));\n    memset(arr, 0, (2 * limit + 2) * sizeof(int));\n    for(int i = 0; i < numsSize / 2; i++){\n        int a = nums[i];\n        int b = nums[numsSize - 1 - i];\n        arr[2] += 2;\n        arr[fmin(a, b) + 1]--;\n        arr[a + b]--;\n        arr[a + b + 1]++;\n        arr[fmax(a, b) + limit + 1]++;\n    }\n    int count = numsSize;\n    int minCount = numsSize;\n    for(int i = 2; i <= 2 * limit; i++){\n        count += arr[i];\n        minCount = fmin(minCount, count);\n    }\n    return minCount;\n\n}", "prefix": "int minMoves(int* nums, int numsSize, int limit"}
{"id": "1331", "path": "output2\\c\\Medium\\1331-max-number-of-k-sum-pairs.c", "hypo_code": "int maxOperations(int* nums, int numsSize, int k){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0)\n        {\n            count++;\n        }\n        flag = 0;\n    }\n    return count;\n}", "prefix": "int maxOperations(int* nums, int numsSize, int k"}
{"id": "1332", "path": "output2\\c\\Medium\\1332-concatenation-of-consecutive-binary-numbers.c", "hypo_code": "int concatenatedBinary(int n){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                result[i] = j + '0';\n                break;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "int concatenatedBinary(int n"}
{"id": "1333", "path": "output2\\c\\Medium\\1333-sum-of-absolute-differences-in-a-sorted-array.c", "hypo_code": "int* getSumAbsoluteDifferences(int* nums, int numsSize, int* returnSize){\n    int* arr = malloc(numsSize * sizeof(int));\n    int sum = 0;\n    for(int i = 0; i < numsSize; i++){\n        sum += nums[i];\n    }\n    int leftSum = 0;\n    for(int i = 0; i < numsSize; i++){\n        arr[i] = (nums[i] * i - leftSum) + (sum - leftSum - nums[i] * (numsSize - i - 1));\n        leftSum += nums[i];\n    }\n    *returnSize = numsSize;\n    return arr;\n\n}", "prefix": "int* getSumAbsoluteDifferences(int* nums, int numsSize, int* returnSize"}
{"id": "1334", "path": "output2\\c\\Medium\\1334-stone-game-vi.c", "hypo_code": "int stoneGameVI(int* aliceValues, int aliceValuesSize, int* bobValues, int bobValuesSize){\n    int** arr = malloc(aliceValuesSize * sizeof(int*));\n    for(int i = 0; i < aliceValuesSize; i++){\n        arr[i] = malloc(3 * sizeof(int));\n        arr[i][0] = aliceValues[i] + bobValues[i];\n        arr[i][1] = aliceValues[i];\n        arr[i][2] = bobValues[i];\n    }\n    qsort(arr, aliceValuesSize, sizeof(int*), cmp);\n    int alice = 0;\n    int bob = 0;\n    for(int i = 0; i < aliceValuesSize; i++){\n        if(i % 2 == 0){\n            alice += arr[i][1];\n        }else{\n            bob += arr[i][2];\n        }\n    }\n    if(alice > bob){\n        return 1;\n    }else if(alice < bob){\n        return -1;\n    }else{\n        return 0;\n    }\n\n}", "prefix": "int stoneGameVI(int* aliceValues, int aliceValuesSize, int* bobValues, int bobValuesSize"}
{"id": "1335", "path": "output2\\c\\Medium\\1335-partitioning-into-minimum-number-of-deci-binary-numbers.c", "hypo_code": "int minPartitions(char * n){\n    int max = 0;\n    for(int i = 0; i < strlen(n); i++){\n        if(n[i] - '0' > max){\n            max = n[i] - '0';\n        }\n    }\n    return max;\n\n}", "prefix": "int minPartitions(char * n"}
{"id": "1336", "path": "output2\\c\\Medium\\1336-stone-game-vii.c", "hypo_code": "int stoneGameVII(int* stones, int stonesSize){\n    int* arr = malloc(stonesSize * sizeof(int));\n    int sum = 0;\n    for(int i = 0; i < stonesSize; i++){\n        sum += stones[i];\n    }\n    int leftSum = 0;\n    for(int i = 0; i < stonesSize; i++){\n        arr[i] = (stones[i] - leftSum) - (sum - leftSum - stones[i]);\n        leftSum += stones[i];\n    }\n    int max = 0;\n    for(int i = 0; i < stonesSize; i++){\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    return max;\n\n}", "prefix": "int stoneGameVII(int* stones, int stonesSize"}
{"id": "1337", "path": "output2\\c\\Medium\\1337-maximum-erasure-value.c", "hypo_code": "int maximumUniqueSubarray(int* nums, int numsSize){\n    int* arr = malloc(numsSize * sizeof(int));\n    int sum = 0;\n    for(int i = 0; i < numsSize; i++){\n        sum += nums[i];\n    }\n    int leftSum = 0;\n    for(int i = 0; i < numsSize; i++){\n        arr[i] = (nums[i] * i - leftSum) + (sum - leftSum - nums[i] * (numsSize - i - 1));\n        leftSum += nums[i];\n    }\n    int max = 0;\n    for(int i = 0; i < numsSize; i++){\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    return max;\n\n}", "prefix": "int maximumUniqueSubarray(int* nums, int numsSize"}
{"id": "1338", "path": "output2\\c\\Medium\\1338-jump-game-vi.c", "hypo_code": "int maxResult(int* nums, int numsSize, int k){\n    int* arr = malloc(numsSize * sizeof(int));\n    arr[0] = nums[0];\n    for(int i = 1; i < numsSize; i++){\n        int max = arr[i - 1];\n        for(int j = i - 2; j >= 0 && i - j <= k; j--){\n            if(arr[j] > max){\n                max = arr[j];\n            }\n        }\n        arr[i] = max + nums[i];\n    }\n    return arr[numsSize - 1];\n\n}", "prefix": "int maxResult(int* nums, int numsSize, int k"}
{"id": "1339", "path": "output2\\c\\Medium\\1339-average-waiting-time.c", "hypo_code": "double averageWaitingTime(int** customers, int customersSize, int* customersColSize){\n    double sum = 0;\n    int time = 0;\n    for(int i = 0; i < customersSize; i++){\n        if(time < customers[i][0]){\n            time = customers[i][0];\n        }\n        time += customers[i][1];\n        sum += time - customers[i][0];\n    }\n    return sum / customersSize;\n\n}", "prefix": "double averageWaitingTime(int** customers, int customersSize, int* customersColSize"}
{"id": "1340", "path": "output2\\c\\Medium\\1340-maximum-binary-string-after-change.c", "hypo_code": "char * maximumBinaryString(char * binary){\n    int len = strlen(binary);\n    int count = 0;\n    for(int i = 0; i < len; i++){\n        if(binary[i] == '0'){\n            count++;\n        }\n    }\n    for(int i = 0; i < len; i++){\n        if(binary[i] == '0'){\n            count--;\n            if(count == 0){\n                binary[i] = '1';\n                break;\n            }\n        }\n    }\n    return binary;\n\n}", "prefix": "char * maximumBinaryString(char * binary"}
{"id": "1341", "path": "output2\\c\\Medium\\1341-maximum-number-of-eaten-apples.c", "hypo_code": "int eatenApples(int* apples, int applesSize, int* days, int daysSize){\n    int* arr = malloc(applesSize * sizeof(int));\n    int max = 0;\n    for(int i = 0; i < applesSize; i++){\n        arr[i] = apples[i] + i;\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    int sum = 0;\n    for(int i = 0; i < applesSize; i++){\n        if(arr[i] > i){\n            sum += apples[i];\n        }\n    }\n    return sum;\n\n}", "prefix": "int eatenApples(int* apples, int applesSize, int* days, int daysSize"}
{"id": "1342", "path": "output2\\c\\Medium\\1342-where-will-the-ball-fall.c", "hypo_code": "int* findBall(int** grid, int gridSize, int* gridColSize, int* returnSize){\n    int* arr = malloc(gridColSize[0] * sizeof(int));\n    for(int i = 0; i < gridColSize[0]; i++){\n        arr[i] = i;\n    }\n    for(int i = 0; i < gridSize; i++){\n        for(int j = 0; j < gridColSize[0]; j++){\n            if(grid[i][j] == 1){\n                if(j == gridColSize[0] - 1 || grid[i][j + 1] == -1){\n                    arr[j] = -1;\n                } else {\n                    arr[j] = arr[j + 1];\n                }\n            } else {\n                if(j == 0 || grid[i][j - 1] == 1){\n                    arr[j] = -1;\n                } else {\n                    arr[j] = arr[j - 1];\n                }\n            }\n        }\n    }\n    *returnSize = gridColSize[0];\n    return arr;\n\n\n}", "prefix": "int* findBall(int** grid, int gridSize, int* gridColSize, int* returnSize"}
{"id": "1343", "path": "output2\\c\\Medium\\1343-count-good-meals.c", "hypo_code": "int countPairs(int* deliciousness, int deliciousnessSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                count++;\n                break;\n            }\n        }\n    }\n    return len - count;\n}", "prefix": "int countPairs(int* deliciousness, int deliciousnessSize"}
{"id": "1344", "path": "output2\\c\\Medium\\1344-ways-to-split-array-into-three-subarrays.c", "hypo_code": "int waysToSplit(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                if(i == 0)\n                {\n                    flag = 1;\n                }\n                else\n                {\n                    for(k = 0; k < i; k++)\n                    {\n                        if(visited[k] == 0)\n                        {\n                            flag = 1;\n                            break;\n                        }\n                    }\n                }\n                if(flag == 1)\n                {\n                    str2[j] = ' ';\n                    count++;\n                    flag = 0;\n                }\n                else\n                {\n                    visited[j] = 0;\n                }\n            }\n        }\n    }\n    return count;\n}", "prefix": "int waysToSplit(int* nums, int numsSize"}
{"id": "1345", "path": "output2\\c\\Medium\\1345-maximum-score-from-removing-substrings.c", "hypo_code": "int maximumGain(char * s, int x, int y){\n    int len = strlen(s);\n    int count = 0;\n    int a = 0;\n    int b = 0;\n    for(int i = 0; i < len; i++){\n        if(s[i] == 'a'){\n            a++;\n        }else if(s[i] == 'b'){\n            b++;\n        }else{\n            if(a > 0 && b > 0){\n                if(x > y){\n                    count += x;\n                    a--;\n                    b--;\n                }else{\n                    count += y;\n                    a--;\n                    b--;\n                }\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int maximumGain(char * s, int x, int y"}
{"id": "1346", "path": "output2\\c\\Medium\\1346-construct-the-lexicographically-largest-valid-sequence.c", "hypo_code": "int* constructDistancedSequence(int n, int* returnSize){\n    int* arr = malloc(2 * n * sizeof(int));\n    for(int i = 0; i < 2 * n; i++){\n        arr[i] = 0;\n    }\n    int* used = malloc(n * sizeof(int));\n    for(int i = 0; i < n; i++){\n        used[i] = 0;\n    }\n    int* result = malloc(2 * n * sizeof(int));\n    for(int i = 0; i < 2 * n; i++){\n        result[i] = 0;\n    }\n    int* max = malloc(2 * n * sizeof(int));\n    for(int i = 0; i < 2 * n; i++){\n        max[i] = 0;\n    }\n    int* maxUsed = malloc(n * sizeof(int));\n    for(int i = 0; i < n; i++){\n        maxUsed[i] = 0;\n    }\n    int* maxResult = malloc(2 * n * sizeof(int));\n    for(int i = 0; i < 2 * n; i++){\n        maxResult[i] = 0;\n    }\n    int* maxReturnSize = malloc(sizeof(int));\n    *maxReturnSize = 0;\n    int* maxN = malloc(sizeof(int));\n    *maxN = 0;\n    int* maxUsedN = malloc(sizeof(int));\n    *maxUsedN = 0;\n    int* maxResultN = malloc(sizeof(int));\n    *maxResultN = 0;\n    int* maxReturnSizeN = malloc(sizeof(int));\n    *maxReturnSizeN = 0;\n    int* maxMax = malloc(sizeof(int));\n    *maxMax = 0;\n    int* maxMaxN = malloc(sizeof(int));\n    *maxMaxN = 0;\n    int* maxMaxUsed = malloc(sizeof(int));\n    *maxMaxUsed = 0;\n    int* maxMaxResult = malloc(sizeof(int));\n    *maxMaxResult = 0;\n    int* maxMaxReturnSize = malloc(sizeof(int));\n    *maxMaxReturnSize = 0;\n    int* maxMaxMax = malloc(sizeof(int));\n    *maxMaxMax = 0;\n    int* maxMaxMaxN = malloc(sizeof(int));\n    *maxMaxMaxN = 0;\n    int* maxMaxMaxUsed = malloc(sizeof(int));\n   \n\n}", "prefix": "int* constructDistancedSequence(int n, int* returnSize"}
{"id": "1347", "path": "output2\\c\\Medium\\1347-swapping-nodes-in-a-linked-list.c", "hypo_code": "struct ListNode* swapNodes(struct ListNode* head, int k){\n    struct ListNode* arr[100];\n    int i = 0;\n    struct ListNode* temp = head;\n    while(temp != NULL){\n        arr[i] = temp;\n        temp = temp->next;\n        i++;\n    }\n    int tempVal = arr[k - 1]->val;\n    arr[k - 1]->val = arr[i - k]->val;\n    arr[i - k]->val = tempVal;\n    return head;\n\n}", "prefix": "struct ListNode* swapNodes(struct ListNode* head, int k"}
{"id": "1348", "path": "output2\\c\\Medium\\1348-minimize-hamming-distance-after-swap-operations.c", "hypo_code": "int minimumHammingDistance(int* source, int sourceSize, int* target, int targetSize, int** allowedSwaps, int allowedSwapsSize, int* allowedSwapsColSize){\n    int* arr = malloc(sourceSize * sizeof(int));\n    for(int i = 0; i < sourceSize; i++){\n        arr[i] = i;\n    }\n    for(int i = 0; i < allowedSwapsSize; i++){\n        int a = allowedSwaps[i][0];\n        int b = allowedSwaps[i][1];\n        int temp = arr[a];\n        arr[a] = arr[b];\n        arr[b] = temp;\n    }\n    int* arr2 = malloc(sourceSize * sizeof(int));\n    for(int i = 0; i < sourceSize; i++){\n        arr2[i] = 0;\n    }\n    for(int i = 0; i < sourceSize; i++){\n        int a = arr[i];\n        int b = i;\n        if(arr2[a] == 0){\n            arr2[a] = b;\n        }\n        else{\n            int temp = arr2[a];\n            arr2[a] = b;\n            arr2[b] = temp;\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < sourceSize; i++){\n        if(arr2[i] != 0){\n            int a = arr2[i];\n            int b = i;\n            if(source[a] != target[b]){\n                count++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int minimumHammingDistance(int* source, int sourceSize, int* target, int targetSize, int** allowedSwaps, int allowedSwapsSize, int* allowedSwapsColSize"}
{"id": "1349", "path": "output2\\c\\Medium\\1349-tuple-with-same-product.c", "hypo_code": "int tupleSameProduct(int* nums, int numsSize){\n    int count = 0;\n    for(int i = 0; i < numsSize; i++){\n        for(int j = i + 1; j < numsSize; j++){\n            for(int k = j + 1; k < numsSize; k++){\n                for(int l = k + 1; l < numsSize; l++){\n                    if(nums[i] * nums[j] == nums[k] * nums[l]){\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    return count * 8;\n\n}", "prefix": "int tupleSameProduct(int* nums, int numsSize"}
{"id": "1350", "path": "output2\\c\\Medium\\1350-largest-submatrix-with-rearrangements.c", "hypo_code": "int largestSubmatrix(int** matrix, int matrixSize, int* matrixColSize){\n    int len = matrixColSize[0];\n    int count = 0;\n    int max = 0;\n    for(int i = 0; i < len; i++){\n        for(int j = 0; j < matrixSize; j++){\n            if(matrix[j][i] == 1){\n                count++;\n            }else{\n                count = 0;\n            }\n            matrix[j][i] = count;\n        }\n    }\n    for(int i = 0; i < matrixSize; i++){\n        qsort(matrix[i], len, sizeof(int), cmpfunc);\n        for(int j = 0; j < len; j++){\n            if(matrix[i][j] * (len - j) > max){\n                max = matrix[i][j] * (len - j);\n            }\n        }\n    }\n    return max;\n\n\n}", "prefix": "int largestSubmatrix(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "1351", "path": "output2\\c\\Medium\\1351-minimum-number-of-people-to-teach.c", "hypo_code": "int minimumTeachings(int n, int** languages, int languagesSize, int* languagesColSize, int** friendships, int friendshipsSize, int* friendshipsColSize){\n    int* lang = (int*)calloc(n+1, sizeof(int));\n    int* langCount = (int*)calloc(n+1, sizeof(int));\n    int* langFriend = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount2 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount3 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount4 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount5 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount6 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount7 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount8 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount9 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount10 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount11 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount12 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount13 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount14 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount15 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount16 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount17 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount18 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount19 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount20 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount21 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount22 = (int*)calloc(n+1, sizeof(int));\n    int* langFriendCount23 = (int*)calloc(n+1, sizeof(int));\n \n\n\n}", "prefix": "int minimumTeachings(int n, int** languages, int languagesSize, int* languagesColSize, int** friendships, int friendshipsSize, int* friendshipsColSize"}
{"id": "1352", "path": "output2\\c\\Medium\\1352-decode-xored-permutation.c", "hypo_code": "int* decode(int* encoded, int encodedSize, int* returnSize){\n\n    int* perm = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm2 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm3 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm4 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm5 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm6 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm7 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm8 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm9 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm10 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm11 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm12 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm13 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm14 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm15 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm16 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm17 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm18 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm19 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm20 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm21 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm22 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm23 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm24 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm25 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm26 = (int*)calloc(encodedSize+1, sizeof(int));\n    int* perm27 = (int*)calloc(encodedSize+1, sizeof(int));\n\n\n\n\n}", "prefix": "int* decode(int* encoded, int encodedSize, int* returnSize"}
{"id": "1353", "path": "output2\\c\\Medium\\1353-change-minimum-characters-to-satisfy-one-of-three-conditions.c", "hypo_code": "int minCharacters(char * a, char * b){\n    int aLen = strlen(a);\n    int bLen = strlen(b);\n    int* aCount = (int*)calloc(26, sizeof(int));\n    int* bCount = (int*)calloc(26, sizeof(int));\n    int* aCount2 = (int*)calloc(26, sizeof(int));\n    int* bCount2 = (int*)calloc(26, sizeof(int));\n    int* aCount3 = (int*)calloc(26, sizeof(int));\n    int* bCount3 = (int*)calloc(26, sizeof(int));\n    int* aCount4 = (int*)calloc(26, sizeof(int));\n    int* bCount4 = (int*)calloc(26, sizeof(int));\n    int* aCount5 = (int*)calloc(26, sizeof(int));\n    int* bCount5 = (int*)calloc(26, sizeof(int));\n    int* aCount6 = (int*)calloc(26, sizeof(int));\n    int* bCount6 = (int*)calloc(26, sizeof(int));\n    int* aCount7 = (int*)calloc(26, sizeof(int));\n    int* bCount7 = (int*)calloc(26, sizeof(int));\n    int* aCount8 = (int*)calloc(26, sizeof(int));\n    int* bCount8 = (int*)calloc(26, sizeof(int));\n    int* aCount9 = (int*)calloc(26, sizeof(int));\n    int* bCount9 = (int*)calloc(26, sizeof(int));\n    int* aCount10 = (int*)calloc(26, sizeof(int));\n    int* bCount10 = (int*)calloc(26, sizeof(int));\n    int* aCount11 = (int*)calloc(26, sizeof(int));\n    int* bCount11 = (int*)calloc(26, sizeof(int));\n    int* aCount12 = (int*)calloc(26, sizeof(int));\n    int* bCount12 = (int*)calloc(26, sizeof(int));\n    int* aCount13 = (int*)calloc(26, sizeof(int));\n    int* bCount13 = (int*)calloc(26, sizeof(int));\n    int* aCount14 = (int*)calloc(26, sizeof(int));\n    int* bCount14 = (int*)calloc(26, sizeof(int));\n    \n\n\n}", "prefix": "int minCharacters(char * a, char * b"}
{"id": "1354", "path": "output2\\c\\Medium\\1354-find-kth-largest-xor-coordinate-value.c", "hypo_code": "int kthLargestValue(int** matrix, \nint matrixSize, int* matrixColSize, int k){\n    int i, j, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int* arr = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize[0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr[i] = 0;}\n    int* arr2 = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize[0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr2[i] = 0;}\n    int* arr3 = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize[0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr3[i] = 0;}\n    int* arr4 = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize[0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr4[i] = 0;}\n    int* arr5 = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize[0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr5[i] = 0;}\n    int* arr6 = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize[0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr6[i] = 0;}\n    int* arr7 = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize[0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr7[i] = 0;}\n    int* arr8 = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize[0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr8[i] = 0;}\n    int* arr9 = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize [0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr9[i] = 0;}\n    int* arr10 = (int*)malloc(sizeof(int) * (matrixSize * matrixColSize[0]));\n    for(i = 0; i < (matrixSize * matrixColSize[0]); i++){arr10[i] = 0;}\n}", "prefix": "int kthLargestValue(int** matrix"}
{"id": "1355", "path": "output2\\c\\Medium\\1355-restore-the-array-from-adjacent-pairs.c", "hypo_code": "int* restoreArray(int** adjacentPairs, int adjacentPairsSize, int* adjacentPairsColSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] != str2[i])\n        {\n            count++;\n            visited[i] = 1;\n        }\n    }\n    if(count == 0)\n    {\n        return 0;\n    }\n    else if(count == 2)\n    {\n        for(i = 0; i < len; i++)\n        {\n            if(visited[i] == 1)\n            {\n                return i;\n            }\n        }\n    }\n    else\n    {\n        return -1;\n    }\n\n}", "prefix": "int* restoreArray(int** adjacentPairs, int adjacentPairsSize, int* adjacentPairsColSize, int* returnSize"}
{"id": "1356", "path": "output2\\c\\Medium\\1356-can-you-eat-your-favorite-candy-on-your-favorite-day.c", "hypo_code": "bool* canEat(int* candiesCount, int candiesCountSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                str[i] = j + 'a';\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        flag = 0;\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str[j])\n            {\n                flag++;\n            }\n        }\n        if(flag == 1)\n        {\n            count++;\n        }\n    }\n    if(count == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return count;\n    }\n}", "prefix": "bool* canEat(int* candiesCount, int candiesCountSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1357", "path": "output2\\c\\Medium\\1357-maximum-absolute-sum-of-any-subarray.c", "hypo_code": "int maxAbsoluteSum(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int maxAbsoluteSum(int* nums, int numsSize"}
{"id": "1358", "path": "output2\\c\\Medium\\1358-minimum-length-of-string-after-deleting-similar-ends.c", "hypo_code": "int minimumLength(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            count++;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            break;\n        }\n    }\n    for(j = len - 1; j >= 0; j--)\n    {\n        if(str[j] == 'b')\n        {\n            break;\n        }\n    }\n    if(i == j)\n    {\n        return 0;\n    }\n    for(k = i; k <= j; k++)\n    {\n        if(str[k] != 'b')\n        {\n            flag = 1;\n        }\n    }\n    if(flag == 0)\n    {\n        return 0;\n    }\n    return len - count;\n}", "prefix": "int minimumLength(char * s"}
{"id": "1359", "path": "output2\\c\\Medium\\1359-maximum-score-from-removing-stones.c", "hypo_code": "int maximumScore(int a, int b, int c){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                count++;\n            }\n        }\n        if(count == len)\n        {\n            flag = 1;\n        }\n        else\n        {\n            count = 0;\n            memset(visited, 0, sizeof(int) * len);\n        }\n    }\n    if(flag == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "prefix": "int maximumScore(int a, int b, int c"}
{"id": "1360", "path": "output2\\c\\Medium\\1360-largest-merge-of-two-strings.c", "hypo_code": "char * largestMerge(char * word1, char * word2){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len1 = strlen(word1);\n    int len2 = strlen(word2);\n    char *result = (char*)malloc(sizeof(char) * (len1 + len2 + 1));\n    memset(result, 0, sizeof(char) * (len1 + len2 + 1));\n    while(i < len1 && j < len2)\n    {\n        if(strcmp(word1 + i, word2 + j) > 0)\n        {\n            result[k++] = word1[i++];\n        }\n        else\n        {\n            result[k++] = word2[j++];\n        }\n    }\n    while(i < len1)\n    {\n        result[k++] = word1[i++];\n    }\n    while(j < len2)\n    {\n        result[k++] = word2[j++];\n    }\n    return result;\n}", "prefix": "char * largestMerge(char * word1, char * word2"}
{"id": "1361", "path": "output2\\c\\Medium\\1361-count-number-of-homogenous-substrings.c", "hypo_code": "int countHomogenous(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int countHomogenous(char * s"}
{"id": "1362", "path": "output2\\c\\Medium\\1362-minimum-limit-of-balls-in-a-bag.c", "hypo_code": "int minimumSize(int* nums, int numsSize, int maxOperations){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int minimumSize(int* nums, int numsSize, int maxOperations"}
{"id": "1363", "path": "output2\\c\\Medium\\1363-form-array-by-concatenating-subarrays-of-another-array.c", "hypo_code": "bool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                count++;\n                break;\n            }\n        }\n    }\n    if(count == len)\n    {\n        flag = 1;\n    }\n    free(visited);\n    free(str);\n    free(str2);\n    return flag;\n}", "prefix": "bool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize"}
{"id": "1364", "path": "output2\\c\\Medium\\1364-map-of-highest-peak.c", "hypo_code": "int** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            flag = 1;\n            break;\n        }\n    }\n    if(flag == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}", "prefix": "int** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1365", "path": "output2\\c\\Medium\\1365-minimum-number-of-operations-to-move-all-balls-to-each-box.c", "hypo_code": "int* minOperations(char * boxes, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "int* minOperations(char * boxes, int* returnSize"}
{"id": "1366", "path": "output2\\c\\Medium\\1366-closest-dessert-cost.c", "hypo_code": "int closestCost(int* baseCosts, int baseCostsSize, int* toppingCosts, int toppingCostsSize, int target){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0)\n        {\n            return false;\n        }\n        flag = 0;\n    }\n    return true;\n}", "prefix": "int closestCost(int* baseCosts, int baseCostsSize, int* toppingCosts, int toppingCostsSize, int target"}
{"id": "1367", "path": "output2\\c\\Medium\\1367-equal-sum-arrays-with-minimum-number-of-operations.c", "hypo_code": "int minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            return 0;\n        }\n    }\n    return 1;\n}", "prefix": "int minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "1368", "path": "output2\\c\\Medium\\1368-check-if-number-is-a-sum-of-powers-of-three.c", "hypo_code": "bool checkPowersOfThree(int n){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "bool checkPowersOfThree(int n"}
{"id": "1369", "path": "output2\\c\\Medium\\1369-sum-of-beauty-of-all-substrings.c", "hypo_code": "int beautySum(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            count++;\n        }\n    }\n    if(count == 0)\n    {\n        return 0;\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] != 'b')\n        {\n            for(j = i + 1; j < len; j++)\n            {\n                if(str[j] == 'b')\n                {\n                    tmp = j;\n                    for(k = i; k < j; k++)\n                    {\n                        if(str[k] != str[tmp])\n                        {\n                            flag = 1;\n                            break;\n                        }\n                        tmp++;\n                    }\n                    if(flag == 0)\n                    {\n                        count++;\n                    }\n                    flag = 0;\n                }\n            }\n        }\n    }\n    return count;\n}", "prefix": "int beautySum(char * s"}
{"id": "1370", "path": "output2\\c\\Medium\\1370-minimum-elements-to-add-to-form-a-given-sum.c", "hypo_code": "int minElements(int* nums, int numsSize, int limit, int goal){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            count++;\n        }\n    }\n    free(visited);\n    free(str);\n    free(str2);\n    return count;\n}", "prefix": "int minElements(int* nums, int numsSize, int limit, int goal"}
{"id": "1371", "path": "output2\\c\\Medium\\1371-number-of-restricted-paths-from-first-to-last-node.c", "hypo_code": "int countRestrictedPaths(int n, int** edges, int edgesSize, int* edgesColSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int countRestrictedPaths(int n, int** edges, int edgesSize, int* edgesColSize"}
{"id": "1372", "path": "output2\\c\\Medium\\1372-maximum-average-pass-ratio.c", "hypo_code": "double maxAverageRatio(int** classes, int classesSize, int* classesColSize, int extraStudents){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0)\n        {\n            count++;\n        }\n        flag = 0;\n    }\n    return count;\n}", "prefix": "double maxAverageRatio(int** classes, int classesSize, int* classesColSize, int extraStudents"}
{"id": "1374", "path": "output2\\c\\Medium\\1374-maximum-number-of-consecutive-values-you-can-make.c", "hypo_code": "int getMaximumConsecutive(int* coins, int coinsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int getMaximumConsecutive(int* coins, int coinsSize"}
{"id": "1375", "path": "output2\\c\\Medium\\1375-number-of-orders-in-the-backlog.c", "hypo_code": "int getNumberOfBacklogOrders(int** orders, int ordersSize, int* ordersColSize){ \n    int *buy = (int*)calloc(1000000001,sizeof(int));\n    int *sell = (int*)calloc(1000000001,sizeof(int));\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    long long int sum = 0;\n    int buySum = 0;\n    int sellSum = 0;\n    int temp = 0;\n    for(i = 0;i < ordersSize;i++)\n    {\n        if(orders[i][2] == 0)\n        {\n            buy[orders[i][0]] += orders[i][1];\n        }\n        else\n        {\n            sell[orders[i][0]] += orders[i][1];\n        }\n    }\n    for(i = 1000000000;i >= 0;i--)\n    {\n        if(buy[i] > 0)\n        {\n            if(sellSum == 0)\n            {\n                sum += buy[i];\n                sum %= 1000000007;\n            }\n            else if(sellSum >= buy[i])\n            {\n                sellSum -= buy[i];\n            }\n            else\n            {\n                sum += buy[i] - sellSum;\n                sum %= 1000000007;\n                sellSum = 0;\n            }\n        }\n        if(sell[i] > 0)\n        {\n            if(buySum == 0)\n            {\n                sum += sell[i];\n                sum %= 1000000007;\n            }\n            else if(buySum >= sell[i])\n            {\n                buySum -= sell[i];\n            }\n            else\n            {\n                sum += sell[i] - buySum;\n                sum %= 1000000007;\n                buySum = 0;\n            }\n        }\n    }\n    return sum;\n}", "prefix": "int getNumberOfBacklogOrders(int** orders, int ordersSize, int* ordersColSize"}
{"id": "1376", "path": "output2\\c\\Medium\\1376-maximum-value-at-a-given-index-in-a-bounded-array.c", "hypo_code": "int maxValue(int n, int index, int maxSum){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            flag = 1;\n            break;\n        }\n    }\n    free(visited);\n    free(str);\n    free(str2);\n    if(flag == 1)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n\n}", "prefix": "int maxValue(int n, int index, int maxSum"}
{"id": "1377", "path": "output2\\c\\Medium\\1377-minimum-number-of-operations-to-reinitialize-a-permutation.c", "hypo_code": "int reinitializePermutation(int n){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            flag = 1;\n            break;\n        }\n    }\n    if(flag == 1)\n    {\n        return false;\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "int reinitializePermutation(int n"}
{"id": "1378", "path": "output2\\c\\Medium\\1378-evaluate-the-bracket-pairs-of-a-string.c", "hypo_code": "char * evaluate(char * s, char *** knowledge, int knowledgeSize, int* knowledgeColSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            count++;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            count++;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            count++;\n        }\n    }\n    return str;\n}", "prefix": "char * evaluate(char * s, char *** knowledge, int knowledgeSize, int* knowledgeColSize"}
{"id": "1379", "path": "output2\\c\\Medium\\1379-sentence-similarity-iii.c", "hypo_code": "bool areSentencesSimilar(char * sentence1, char * sentence2){\n    int len1 = strlen(sentence1);\n    int len2 = strlen(sentence2);\n    int i = 0, j = 0;\n    int count = 0;\n    while(i < len1 && j < len2){\n        if(sentence1[i] == sentence2[j]){\n            i++;\n            j++;\n        }\n        else{\n            if(count == 1){\n                return false;\n            }\n            else{\n                count++;\n                if(len1 > len2){\n                    i++;\n                }\n                else if(len1 < len2){\n                    j++;\n                }\n                else{\n                    i++;\n                    j++;\n                }\n            }\n        }\n    }\n    return true;\n\n}", "prefix": "bool areSentencesSimilar(char * sentence1, char * sentence2"}
{"id": "1380", "path": "output2\\c\\Medium\\1380-count-nice-pairs-in-an-array.c", "hypo_code": "int countNicePairs(int* nums, int numsSize){\n    int i, j;\n    int count = 0;\n    int mod = 1000000007;\n    for(i = 0; i < numsSize; i++){\n        for(j = i + 1; j < numsSize; j++){\n            if(nums[i] + reverse(nums[j]) == nums[j] + reverse(nums[i])){\n                count++;\n            }\n        }\n    }\n    return count % mod;\n\n}", "prefix": "int countNicePairs(int* nums, int numsSize"}
{"id": "1381", "path": "output2\\c\\Medium\\1381-finding-the-users-active-minutes.c", "hypo_code": "int* findingUsersActiveMinutes(int** logs, int logsSize, int* logsColSize, int k, int* returnSize){\n    int* arr = malloc(k * sizeof(int));\n    int i, j;\n    int count = 0;\n    for(i = 0; i < k; i++){\n        arr[i] = 0;\n    }\n    for(i = 0; i < logsSize; i++){\n        for(j = i + 1; j < logsSize; j++){\n            if(logs[i][0] == logs[j][0] && logs[i][1] == logs[j][1]){\n                logs[j][0] = -1;\n                logs[j][1] = -1;\n            }\n        }\n    }\n    for(i = 0; i < logsSize; i++){\n        if(logs[i][0] != -1){\n            count++;\n        }\n    }\n    int* arr1 = malloc(count * sizeof(int));\n    int* arr2 = malloc(count * sizeof(int));\n    int index = 0;\n    for(i = 0; i < logsSize; i++){\n        if(logs[i][0] != -1){\n            arr1[index] = logs[i][0];\n            arr2[index] = logs[i][1];\n            index++;\n        }\n    }\n    for(i = 0; i < count; i++){\n        for(j = i + 1; j < count; j++){\n            if(arr1[i] == arr1[j]){\n                arr2[i] = -1;\n            }\n        }\n    }\n    for(i = 0; i < count; i++){\n        if(arr2[i] != -1){\n            arr[count - 1]++;\n        }\n    }\n    *returnSize = k;\n    return arr;\n\n}", "prefix": "int* findingUsersActiveMinutes(int** logs, int logsSize, int* logsColSize, int k, int* returnSize"}
{"id": "1382", "path": "output2\\c\\Medium\\1382-minimum-absolute-sum-difference.c", "hypo_code": "public class Solution {\n    public int MinAbsoluteSumDiff(int[] nums1, int[] nums2) {\n        int mod = 1000000007;\n        int sum = 0;\n        int max = 0;\n        int index = 0;\n        int[] arr = new int[nums1.Length];\n        for(int i = 0; i < nums1.Length; i++){\n            arr[i] = Math.Abs(nums1[i] - nums2[i]);\n            sum += arr[i];\n        }\n        for(int i = 0; i < nums1.Length; i++){\n            for(int j = 0; j < nums1.Length; j++){\n                if(Math.Abs(nums1[j] - nums2[i]) < arr[i]){\n                    if(arr[i] - Math.Abs(nums1[j] - nums2[i]) > max){\n                        max = arr[i] - Math.Abs(nums1[j] - nums2[i]);\n                        index = i;\n                    }\n                }\n            }\n        }\n        sum = sum - arr[index] + max;\n        return sum % mod;\n        \n    }\n}", "prefix": "int MinAbsoluteSumDiff(int[] nums1, int[] nums2"}
{"id": "1383", "path": "output2\\c\\Medium\\1383-find-the-winner-of-the-circular-game.c", "hypo_code": "int findTheWinner(int n, int k){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            count++;\n            if(count == 1)\n            {\n                m = i;\n            }\n            if(count == 2)\n            {\n                n = i;\n            }\n        }\n    }\n    if(count == 0)\n    {\n        return 0;\n    }\n    if(count == 1)\n    {\n        return 1;\n    }\n    if(count == 2)\n    {\n        if(str[m] == str2[n] && str[n] == str2[m])\n        {\n            return 2;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    return 0;\n}", "prefix": "int findTheWinner(int n, int k"}
{"id": "1384", "path": "output2\\c\\Medium\\1384-minimum-sideway-jumps.c", "hypo_code": "int minSideJumps(int* obstacles, int obstaclesSize){\n  int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n}", "prefix": "int minSideJumps(int* obstacles, int obstaclesSize"}
{"id": "1385", "path": "output2\\c\\Medium\\1385-queries-on-number-of-points-inside-a-circle.c", "hypo_code": "int* countPoints(int** points, int pointsSize, int* pointsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                count++;\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int* countPoints(int** points, int pointsSize, int* pointsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1386", "path": "output2\\c\\Medium\\1386-maximum-xor-for-each-query.c", "hypo_code": "int* getMaximumXor(int* nums, int numsSize, int maximumBit, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            break;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}", "prefix": "int* getMaximumXor(int* nums, int numsSize, int maximumBit, int* returnSize"}
{"id": "1387", "path": "output2\\c\\Medium\\1387-maximum-ice-cream-bars.c", "hypo_code": "int maxIceCream(int* costs, int costsSize, int coins){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                if(i != j)\n                {\n                    count++;\n                }\n                break;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int maxIceCream(int* costs, int costsSize, int coins"}
{"id": "1388", "path": "output2\\c\\Medium\\1388-single-threaded-cpu.c", "hypo_code": "int* getOrder(int** tasks, int tasksSize, int* tasksColSize, int* returnSize){\nint *ret = (int *)malloc(sizeof(int) * tasksSize);\n\tint **task = (int **)malloc(sizeof(int *) * tasksSize);\n\tfor (int i = 0; i < tasksSize; i++) {\n\t\ttask[i] = (int *)malloc(sizeof(int) * 3);\n\t\ttask[i][0] = tasks[i][0];\n\t\ttask[i][1] = tasks[i][1];\n\t\ttask[i][2] = i;\n\t}\n\tqsort(task, tasksSize, sizeof(int *), cmp);\n\t*returnSize = tasksSize;\n\tint *heap = (int *)malloc(sizeof(int) * tasksSize);\n\tint heapSize = 0;\n\tint next = 0;\n\tlong long time = task[0][0];\n\twhile (next < tasksSize || heapSize > 0) {\n\t\twhile (next < tasksSize && task[next][0] <= time) {\n\t\t\theap[heapSize++] = next++;\n\t\t\tshiftUp(heap, heapSize - 1, task);\n\t\t}\n\t\tif (heapSize > 0) {\n\t\t\tret[tasksSize - heapSize] = task[heap[0]][2];\n\t\t\ttime += task[heap[0]][1];\n\t\t\theap[0] = heap[--heapSize];\n\t\t\tshiftDown(heap, heapSize, 0, task);\n\t\t} else {\n\t\t\ttime = task[next][0];\n\t\t}\n\t}\n\treturn ret;\n}", "prefix": "int* getOrder(int** tasks, int tasksSize, int* tasksColSize, int* returnSize"}
{"id": "1389", "path": "output2\\c\\Medium\\1389-frequency-of-the-most-frequent-element.c", "hypo_code": "int maxFrequency(int* nums, int numsSize, int k){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int maxFrequency(int* nums, int numsSize, int k"}
{"id": "1390", "path": "output2\\c\\Medium\\1390-longest-substring-of-all-vowels-in-order.c", "hypo_code": "int longestBeautifulSubstring(char * word){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                count++;\n                break;\n            }\n        }\n    }\n    return len - count;\n}", "prefix": "int longestBeautifulSubstring(char * word"}
{"id": "1392", "path": "output2\\c\\Medium\\1392-maximum-element-after-decreasing-and-rearranging.c", "hypo_code": "int maximumElementAfterDecrementingAndRearranging(int* arr, int arrSize){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            flag = 1;\n            break;\n        }\n    }\n    if(flag == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return 1;\n    }\n}", "prefix": "int maximumElementAfterDecrementingAndRearranging(int* arr, int arrSize"}
{"id": "1393", "path": "output2\\c\\Medium\\1393-splitting-a-string-into-descending-consecutive-values.c", "hypo_code": "bool splitString(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            count++;\n        }\n    }\n    if(count == len)\n    {\n        return true;\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'a')\n        {\n            for(j = i; j < len; j++)\n            {\n                if(str[j] == 'b')\n                {\n                    tmp = j;\n                    break;\n                }\n            }\n            for(k = tmp; k < len; k++)\n            {\n                if(str[k] == 'a')\n                {\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag == 0)\n            {\n                return false;\n            }\n            else\n            {\n                flag = 0;\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool splitString(char * s"}
{"id": "1394", "path": "output2\\c\\Medium\\1394-minimum-adjacent-swaps-to-reach-the-kth-smallest-number.c", "hypo_code": "int getMinSwaps(char * num, int k){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n        if(j == len)\n        {\n            return 0;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] != str2[i])\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int getMinSwaps(char * num, int k"}
{"id": "1395", "path": "output2\\c\\Medium\\1395-maximum-distance-between-a-pair-of-values.c", "hypo_code": "int maxDistance(int* nums1, int nums1Size, int* nums2, int nums2Size){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            flag = 1;\n            break;\n        }\n    }\n    if(flag == 1)\n    {\n        return 0;\n    }\n    else\n    {\n        return 1;\n    }\n}", "prefix": "int maxDistance(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "1396", "path": "output2\\c\\Medium\\1396-maximum-subarray-min-product.c", "hypo_code": "int maxSumMinProduct(int* nums, int numsSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                count++;\n                break;\n            }\n        }\n        if(count == len)\n        {\n            flag = 1;\n            break;\n        }\n        count = 0;\n    }\n    free(str);\n    free(str2);\n    free(visited);\n    if(flag == 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}", "prefix": "int maxSumMinProduct(int* nums, int numsSize"}
{"id": "1397", "path": "output2\\c\\Medium\\1397-incremental-memory-leak.c", "hypo_code": "int* memLeak(int memory1, int memory2, int* returnSize){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        for(j = 0; j < len; j++)\n        {\n            if(str[i] == str2[j] && visited[j] == 0)\n            {\n                visited[j] = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(visited[i] == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int* memLeak(int memory1, int memory2, int* returnSize"}
{"id": "1398", "path": "output2\\c\\Medium\\1398-rotating-the-box.c", "hypo_code": "char** rotateTheBox(char** box, int boxSize, int* boxColSize, int* returnSize, int** returnColumnSizes){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] != str2[i])\n        {\n            count++;\n            visited[i] = 1;\n        }\n    }\n    if(count == 0)\n    {\n        return 0;\n    }\n}", "prefix": "char** rotateTheBox(char** box, int boxSize, int* boxColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1399", "path": "output2\\c\\Medium\\1399-minimum-number-of-swaps-to-make-the-binary-string-alternating.c", "hypo_code": "int minSwaps(char * s){\nint i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int len = strlen(s);\n    int min = 0;\n    int tmp = 0;\n    int count = 0;\n    int flag = 0;\n    int *visited = (int*)malloc(sizeof(int) * len);\n    memset(visited, 0, sizeof(int) * len);\n    char *str = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str, s);\n    char *str2 = (char*)malloc(sizeof(char) * len + 1);\n    strcpy(str2, s);\n    for(i = 0; i < len; i++)\n    {\n        min = i;\n        for(j = i + 1; j < len; j++)\n        {\n            if(str[j] < str[min])\n            {\n                min = j;\n            }\n        }\n        if(min != i)\n        {\n            tmp = str[i];\n            str[i] = str[min];\n            str[min] = tmp;\n        }\n    }\n    for(i = 0; i < len; i++)\n    {\n        if(str[i] == 'b')\n        {\n            count++;\n        }\n    }\n    if(abs(count - len / 2) > 1)\n    {\n        return -1;\n    }\n    if(count > len / 2)\n    {\n        for(i = 0; i < len; i++)\n        {\n            if(i % 2 == 0 && str[i] == 'b')\n            {\n                flag++;\n            }\n            else if(i % 2 == 1 && str[i] == 'a')\n            {\n                flag++;\n            }\n        }\n        if(flag % 2 == 0)\n        {\n            return flag / 2;\n        }\n        else\n        {\n            return flag / 2 + 1;\n        }\n    }\n    else if(count < len / 2)\n    {\n        for(i = 0; i < len; i++)\n        {\n            if(i % 2 == 0 && str[i] == 'a')\n            {\n                flag++;\n            }\n            else if(i % 2 == 1 && str[i] == 'b')\n            {\n                flag++;\n            }\n        }\n        if(flag % 2 == 0)\n        {\n            return flag / 2;\n        }\n        else\n        {\n            return flag / 2 + 1;\n        }\n    }\n    else\n    {\n        for(i = 0; i < len; i++)\n        {\n            if(str[i] == 'b')\n            {\n                if(count > 0)\n                {\n                    count--;\n                    visited[i] = 1;\n                }\n            }\n        }\n        for(i = 0; i < len; i++)\n        {\n            if(visited[i] == 0)\n            {\n                count++;\n            }\n        }\n        return count / 2;\n    }\n}", "prefix": "int minSwaps(char * s"}
{"id": "1401", "path": "output2\\c\\Medium\\1401-minimum-speed-to-arrive-on-time.c", "hypo_code": "int minSpeedOnTime(int* dist, int distSize, double hour){\nint i;\n    int sum=0;\n    int max=1;\n    double time=0;\n    for(i=0;i<distSize;i++){\n        sum+=dist[i];\n        if(max<dist[i]){\n            max=dist[i];\n        }\n    }\n    if(sum<=hour){\n        return 1;\n    }\n    int min=1;\n    int mid;\n    while(min<=max){\n        mid=(min+max)/2;\n        time=0;\n        for(i=0;i<distSize-1;i++){\n            time+=ceil((double)dist[i]/mid);\n        }\n        time+=(double)dist[i]/mid;\n        if(time>hour){\n            min=mid+1;\n        }else{\n            max=mid-1;\n        }\n    }\n    if(time>hour){\n        return min;\n    }\n    return max;\n}", "prefix": "int minSpeedOnTime(int* dist, int distSize, double hour"}
{"id": "1402", "path": "output2\\c\\Medium\\1402-jump-game-vii.c", "hypo_code": "bool canReach(char * s, int minJump, int maxJump){\nint len = strlen(s);\n    if (s[len - 1] == '1') {\n        return false;\n    }\n    bool dp[len];\n    memset(dp, false, len);\n    dp[0] = true;\n    int count = 0;\n    for (int i = 1; i < len; i++) {\n        if (s[i] == '1') {\n            continue;\n        }\n        for (int j = i - minJump; j >= 0 && j >= i - maxJump; j--) {\n            if (dp[j]) {\n                dp[i] = true;\n                count++;\n                break;\n            }\n        }\n    }\n    return dp[len - 1];\n}", "prefix": "bool canReach(char * s, int minJump, int maxJump"}
{"id": "1403", "path": "output2\\c\\Medium\\1403-minimize-maximum-pair-sum-in-array.c", "hypo_code": "int minPairSum(int* nums, int numsSize){\nint i;\n    int max=0;\n    int min=0;\n    int mid;\n    int sum;\n    int max_sum=0;\n    for(i=0;i<numsSize;i++){\n        if(nums[i]>max){\n            max=nums[i];\n        }\n    }\n    max_sum=2*max;\n    while(min<=max){\n        mid=(min+max)/2;\n        sum=0;\n        for(i=0;i<numsSize/2;i++){\n            if(nums[i]+nums[numsSize-1-i]>mid){\n                sum+=nums[i]+nums[numsSize-1-i];\n            }else{\n                sum+=mid;\n            }\n        }\n        if(sum>max_sum){\n            min=mid+1;\n        }else{\n            max=mid-1;\n        }\n    }\n    return min;\n}", "prefix": "int minPairSum(int* nums, int numsSize"}
{"id": "1404", "path": "output2\\c\\Medium\\1404-get-biggest-three-rhombus-sums-in-a-grid.c", "hypo_code": "int* getBiggestThree(int** grid, int gridSize, int* gridColSize, int* returnSize){\nint i,j,k;\n    int m=gridSize;\n    int n=*gridColSize;\n    int len=m*n;\n    int *arr=(int *)malloc(sizeof(int)*len);\n    int *res=(int *)malloc(sizeof(int)*3);\n    int index=0;\n    int flag=0;\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            arr[index]=grid[i][j];\n            index++;\n            if(i>0 && j>0){\n                flag=1;\n                for(k=1;k<=i && k<=j;k++){\n                    arr[index]+=grid[i-k][j-k]+grid[i-k][j+k]+grid[i+k][j-k]+grid[i+k][j+k];\n                }\n                index++;\n            }\n        }\n    }\n    if(flag==0){\n        res[0]=arr[0];\n        *returnSize=1;\n        return res;\n    }\n    int temp;\n    for(i=0;i<len;i++){\n        for(j=i+1;j<len;j++){\n            if(arr[i]<arr[j]){\n                temp=arr[i];\n                arr[i]=arr[j];\n                arr[j]=temp;\n            }\n        }\n    }\n    res[0]=arr[0];\n    index=1;\n    for(i=1;i<len;i++){\n        if(arr[i-1]!=arr[i]){\n            res[index]=arr[i];\n            index++;\n            if(index==3){\n                break;\n            }\n        }\n    }\n    *returnSize=index;\n    return res;\n}", "prefix": "int* getBiggestThree(int** grid, int gridSize, int* gridColSize, int* returnSize"}
{"id": "1405", "path": "output2\\c\\Medium\\1405-maximum-value-after-insertion.c", "hypo_code": "char * maxValue(char * n, int x){\nint len=strlen(n);\n    char *str=(char *)malloc(sizeof(char)*(len+2));\n    int i=0;\n    int flag=0;\n    if(n[0]=='-'){\n        str[0]='-';\n        i=1;\n        while(i<len){\n            if(n[i]-'0'>x){\n                flag=1;\n                break;\n            }else if(n[i]-'0'<x){\n                flag=0;\n                break;\n            }\n            i++;\n        }\n        if(flag==0){\n            str[0]=n[0];\n            for(i=1;i<len+1;i++){\n                str[i]=n[i-1];\n            }\n            str[i]='\\0';\n            return str;\n        }\n    }else{\n        while(i<len){\n            if(n[i]-'0'<x){\n                flag=1;\n                break;\n            }else if(n[i]-'0'>x){\n                flag=0;\n                break;\n            }\n            i++;\n        }\n        if(flag==0){\n            for(i=0;i<len+1;i++){\n                str[i]=n[i];\n            }\n            str[i]='\\0';\n            return str;\n        }\n    }\n    for(i=0;i<len;i++){\n        if(flag==0){\n            str[i]=n[i];\n        }else{\n            if(n[i]-'0'>=x){\n                str[i]=n[i];\n            }else{\n                str[i]=x+'0';\n                flag=0;\n                break;\n            }\n        }\n    }\n    if(flag==1){\n        str[i]=x+'0';\n        str[i+1]='\\0';\n    }else{\n        for(;i<len;i++){\n            str[i+1]=n[i];\n        }\n        str[i+1]='\\0';\n    }\n    return str;\n}", "prefix": "char * maxValue(char * n, int x"}
{"id": "1406", "path": "output2\\c\\Medium\\1406-process-tasks-using-servers.c", "hypo_code": "int* assignTasks(int* servers, int serversSize, int* tasks, int tasksSize, int* returnSize){\nint i,j;\n    int *res=(int *)malloc(sizeof(int)*tasksSize);\n    int *arr=(int *)malloc(sizeof(int)*serversSize);\n    int *arr2=(int *)malloc(sizeof(int)*serversSize);\n    for(i=0;i<serversSize;i++){\n        arr[i]=i;\n        arr2[i]=i;\n    }\n    for(i=0;i<tasksSize;i++){\n        int index=-1;\n        int min=INT_MAX;\n        int min2=INT_MAX;\n        for(j=0;j<serversSize;j++){\n            if(servers[arr[j]]<min){\n                min=servers[arr[j]];\n                index=j;\n            }else if(servers[arr[j]]==min){\n                if(arr[j]<arr[index]){\n                    index=j;\n                }\n            }\n        }\n        if(servers[arr[index]]>i){\n            res[i]=arr[index];\n            arr[index]=arr2[index];\n            continue;\n        }\n        for(j=0;j<serversSize;j++){\n            if(servers[arr[j]]<min2){\n                min2=servers[arr[j]];\n            }\n        }\n        for(j=0;j<serversSize;j++){\n            if(servers[arr[j]]==min2){\n                if(arr[j]<arr[index]){\n                    index=j;\n                }\n            }\n        }\n        res[i]=arr[index];\n        arr[index]=arr2[index];\n    }\n    *returnSize=tasksSize;\n    return res;\n\n}", "prefix": "int* assignTasks(int* servers, int serversSize, int* tasks, int tasksSize, int* returnSize"}
{"id": "1407", "path": "output2\\c\\Medium\\1407-egg-drop-with-2-eggs-and-n-floors.c", "hypo_code": "int twoEggDrop(int n){\nint dp[n+1];\n    dp[0]=0;\n    dp[1]=1;\n    int i,j;\n    for(i=2;i<=n;i++){\n        dp[i]=INT_MAX;\n        for(j=1;j<=i;j++){\n            dp[i]=fmin(dp[i],1+fmax(j-1,dp[i-j]));\n        }\n    }\n    return dp[n];\n}", "prefix": "int twoEggDrop(int n"}
{"id": "1408", "path": "output2\\c\\Medium\\1408-reduction-operations-to-make-the-array-elements-equal.c", "hypo_code": "int reductionOperations(int* nums, int numsSize){\nint i,j;\n    int count=0;\n    int max=0;\n    int max_index=0;\n    int next_max=0;\n    int next_max_index=0;\n    for(i=0;i<numsSize;i++){\n        if(nums[i]>max){\n            max=nums[i];\n            max_index=i;\n        }\n    }\n    if(max_index==0){\n        for(i=1;i<numsSize;i++){\n            if(nums[i]>next_max){\n                next_max=nums[i];\n                next_max_index=i;\n            }\n        }\n        for(i=next_max_index;i<numsSize;i++){\n            if(nums[i]!=next_max){\n                count++;\n            }\n        }\n        return count;\n    }\n    for(i=0;i<numsSize;i++){\n        if(nums[i]>next_max&&nums[i]<max){\n            next_max=nums[i];\n            next_max_index=i;\n        }\n    }\n    for(i=max_index;i<numsSize;i++){\n        if(nums[i]!=max){\n            count++;\n        }\n    }\n    return count+reductionOperations(nums,max_index);\n\n}", "prefix": "int reductionOperations(int* nums, int numsSize"}
{"id": "1409", "path": "output2\\c\\Medium\\1409-minimum-number-of-flips-to-make-the-binary-string-alternating.c", "hypo_code": "int minFlips(char * s){\nint len=strlen(s);\n    int i;\n    int count1=0;\n    int count2=0;\n    int count3=0;\n    int count4=0;\n    for(i=0;i<len;i++){\n        if(i%2==0&&s[i]=='1'){\n            count1++;\n        }else if(i%2==0&&s[i]=='0'){\n            count2++;\n        }else if(i%2==1&&s[i]=='0'){\n            count3++;\n        }else if(i%2==1&&s[i]=='1'){\n            count4++;\n        }\n    }\n    if(len%2==0){\n        if(count1+count3<count2+count4){\n            return count1+count3;\n        }else{\n            return count2+count4;\n        }\n    }else{\n        if(count1+count3<count2+count4){\n            return count2+count3;\n        }else{\n            return count1+count4;\n        }\n    }\n}", "prefix": "int minFlips(char * s"}
{"id": "1410", "path": "output2\\c\\Medium\\1410-find-the-student-that-will-replace-the-chalk.c", "hypo_code": "int chalkReplacer(int* chalk, int chalkSize, int k){\nint i;\n    long long sum=0;\n    long long tmp=0;\n    for(i=0;i<chalkSize;i++){\n        sum+=chalk[i];\n    }\n    k=k%sum;\n    for(i=0;i<chalkSize;i++){\n        tmp+=chalk[i];\n        if(tmp>k){\n            return i;\n        }\n    }\n    return 0;\n}", "prefix": "int chalkReplacer(int* chalk, int chalkSize, int k"}
{"id": "1411", "path": "output2\\c\\Medium\\1411-largest-magic-square.c", "hypo_code": "int largestMagicSquare(int** grid, int gridSize, int* gridColSize){\nint i,j,k;\n    int m=gridSize;\n    int n=*gridColSize;\n    int len=m*n;\n    int *arr=(int *)malloc(sizeof(int)*len);\n    int *res=(int *)malloc(sizeof(int)*3);\n    int index=0;\n    int flag=0;\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            arr[index]=grid[i][j];\n            index++;\n            if(i>0 && j>0){\n                flag=1;\n                for(k=1;k<=i && k<=j;k++){\n                    arr[index]+=grid[i-k][j-k]+grid[i-k][j+k]+grid[i+k][j-k]+grid[i+k][j+k];\n                }\n                index++;\n            }\n        }\n    }\n    if(flag==0){\n        res[0]=arr[0];\n        *returnSize=1;\n        return res;\n    }\n    int temp;\n    for(i=0;i<len;i++){\n        for(j=i+1;j<len;j++){\n            if(arr[i]<arr[j]){\n                temp=arr[i];\n                arr[i]=arr[j];\n                arr[j]=temp;\n            }\n        }\n    }\n    res[0]=arr[0];\n    index=1;\n    for(i=1;i<len;i++){\n        if(arr[i]!=arr[i-1]){\n            res[index]=arr[i];\n            index++;\n            if(index==3){\n                *returnSize=3;\n                return res;\n            }\n        }\n    }\n    *returnSize=index;\n    return res;\n}", "prefix": "int largestMagicSquare(int** grid, int gridSize, int* gridColSize"}
{"id": "1412", "path": "output2\\c\\Medium\\1412-maximum-number-of-removable-characters.c", "hypo_code": "int maximumRemovals(char * s, char * p, int* removable, int removableSize){\nint len=strlen(s);\n    int i;\n    int j;\n    int k;\n    int flag=0;\n    int count=0;\n    int max=0;\n    int tmp=0;\n    int *arr=(int *)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr[i]=1;\n    }\n    while(count<removableSize){\n        arr[removable[count]]=0;\n        j=0;\n        k=0;\n        for(i=0;i<len;i++){\n            if(arr[i]==1&&s[i]==p[j]){\n                j++;\n                k++;\n            }\n            if(j==strlen(p)){\n                flag=1;\n                break;\n            }\n        }\n        if(flag==1){\n            tmp=k;\n            if(tmp>max){\n                max=tmp;\n            }\n        }\n        count++;\n    }\n    return max;\n}", "prefix": "int maximumRemovals(char * s, char * p, int* removable, int removableSize"}
{"id": "1413", "path": "output2\\c\\Medium\\1413-merge-triplets-to-form-target-triplet.c", "hypo_code": "bool mergeTriplets(int** triplets, int tripletsSize, int* tripletsColSize, int* target, int targetSize){ \nint i,j;\n    int count=0;\n    int max=0;\n    int max_index=0;\n    int next_max=0;\n    int next_max_index=0;\n    for(i=0;i<tripletsSize;i++){\n        if(triplets[i][0]>max){\n            max=triplets[i][0];\n            max_index=i;\n        }\n    }\n    if(max_index==0){\n        for(i=1;i<tripletsSize;i++){\n            if(triplets[i][1]>next_max){\n                next_max=triplets[i][1];\n                next_max_index=i;\n            }\n        }\n        for(i=next_max_index;i<tripletsSize;i++){\n            if(triplets[i][1]!=next_max){\n                count++;\n            }\n        }\n        return count;\n    }\n    for(i=0;i<tripletsSize;i++){\n        if(triplets[i][1]>next_max&&triplets[i][1]<max){\n            next_max=triplets[i][1];\n            next_max_index=i;\n        }\n    }\n    for(i=next_max_index;i<tripletsSize;i++){\n        if(triplets[i][1]!=next_max){\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "bool mergeTriplets(int** triplets, int tripletsSize, int* tripletsColSize, int* target, int targetSize"}
{"id": "1414", "path": "output2\\c\\Medium\\1414-find-a-peak-element-ii.c", "hypo_code": "int* findPeakGrid(int** mat, int matSize, int* matColSize, int* returnSize){\nint i,j;\n    int m=matSize;\n    int n=*matColSize;\n    int *res=(int *)malloc(sizeof(int)*2);\n    int max=0;\n    int max_i=0;\n    int max_j=0;\n    int flag=0;\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            if(mat[i][j]>max){\n                max=mat[i][j];\n                max_i=i;\n                max_j=j;\n            }\n        }\n    }\n    int temp_i=max_i;\n    int temp_j=max_j;\n    while(temp_i>0 && mat[temp_i][temp_j]>mat[temp_i-1][temp_j]){\n        temp_i--;\n    }\n    if(temp_i==0){\n        res[0]=temp_i;\n        res[1]=temp_j;\n        *returnSize=2;\n        return res;\n    }\n    temp_i=max_i;\n    temp_j=max_j;\n    while(temp_i<m-1 && mat[temp_i][temp_j]>mat[temp_i+1][temp_j]){\n        temp_i++;\n    }\n    if(temp_i==m-1){\n        res[0]=temp_i;\n        res[1]=temp_j;\n        *returnSize=2;\n        return res;\n    }\n    temp_i=max_i;\n    temp_j=max_j;\n    while(temp_j>0 && mat[temp_i][temp_j]>mat[temp_i][temp_j-1]){\n        temp_j--;\n    }\n    if(temp_j==0){\n        res[0]=temp_i;\n        res[1]=temp_j;\n        *returnSize=2;\n        return res;\n    }\n    temp_i=max_i;\n    temp_j=max_j;\n    while(temp_j<n-1 && mat[temp_i][temp_j]>mat[temp_i][temp_j+1]){\n        temp_j++;\n    }\n    if(temp_j==n-1){\n        res[0]=temp_i;\n        res[1]=temp_j;\n        *returnSize=2;\n        return res;\n    }\n    res[0]=max_i;\n    res[1]=max_j;\n    *returnSize=2;\n    return res;\n}", "prefix": "int* findPeakGrid(int** mat, int matSize, int* matColSize, int* returnSize"}
{"id": "1415", "path": "output2\\c\\Medium\\1415-the-number-of-full-rounds-you-have-played.c", "hypo_code": "int numberOfRounds(char * loginTime, char * logoutTime){\nint login_hour=0;\n    int login_min=0;\n    int logout_hour=0;\n    int logout_min=0;\n    int i;\n    for(i=0;i<strlen(loginTime);i++){\n        if(i<=1){\n            login_hour=login_hour*10+loginTime[i]-'0';\n        }else if(i>=3){\n            login_min=login_min*10+loginTime[i]-'0';\n        }\n    }\n    for(i=0;i<strlen(logoutTime);i++){\n        if(i<=1){\n            logout_hour=logout_hour*10+logoutTime[i]-'0';\n        }else if(i>=3){\n            logout_min=logout_min*10+logoutTime[i]-'0';\n        }\n    }\n    int login_time=login_hour*60+login_min;\n    int logout_time=logout_hour*60+logout_min;\n    if(logout_time<login_time){\n        logout_time+=24*60;\n    }\n    int start_time=(login_time/15+1)*15;\n    int end_time=(logout_time/15)*15;\n    if(end_time<start_time){\n        return 0;\n    }else{\n        return (end_time-start_time)/15;\n    }\n}", "prefix": "int numberOfRounds(char * loginTime, char * logoutTime"}
{"id": "1416", "path": "output2\\c\\Medium\\1416-count-sub-islands.c", "hypo_code": "int countSubIslands(int** grid1, int grid1Size, int* grid1ColSize, int** grid2, int grid2Size, int* grid2ColSize){\nint m=grid1Size;\n    int n=*grid1ColSize;\n    int i,j;\n    int count=0;\n    int flag=0;\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            if(grid2[i][j]==1){\n                flag=0;\n                dfs(grid1,grid2,m,n,i,j,&flag);\n                if(flag==1){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\nvoid dfs(int** grid1, int** grid2, int m, int n, int i, int j, int *flag){\n    if(i<0||i>=m||j<0||j>=n||grid2[i][j]==0){\n        return;\n    }\n    if(grid1[i][j]==0){\n        *flag=0;\n    }\n    grid2[i][j]=0;\n    dfs(grid1,grid2,m,n,i+1,j,flag);\n    dfs(grid1,grid2,m,n,i-1,j,flag);\n    dfs(grid1,grid2,m,n,i,j+1,flag);\n    dfs(grid1,grid2,m,n,i,j-1,flag);\n}", "prefix": "int countSubIslands(int** grid1, int grid1Size, int* grid1ColSize, int** grid2, int grid2Size, int* grid2ColSize"}
{"id": "1417", "path": "output2\\c\\Medium\\1417-minimum-absolute-difference-queries.c", "hypo_code": "int* minDifference(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nint i,j,k;\n    int len=queriesSize;\n    int *res=(int *)malloc(sizeof(int)*len);\n    int min;\n    int temp;\n    for(i=0;i<len;i++){\n        min=INT_MAX;\n        for(j=queries[i][0];j<=queries[i][1];j++){\n            for(k=j+1;k<=queries[i][1];k++){\n                temp=abs(nums[j]-nums[k]);\n                if(temp<min){\n                    min=temp;\n                }\n            }\n        }\n        if(min==INT_MAX){\n            min=-1;\n        }\n        res[i]=min;\n    }\n    *returnSize=len;\n    return res;\n}", "prefix": "int* minDifference(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1419", "path": "output2\\c\\Medium\\1419-remove-all-occurrences-of-a-substring.c", "hypo_code": "char * removeOccurrences(char * s, char * part){\nint len1=strlen(s);\n    int len2=strlen(part);\n    int i;\n    int j;\n    int flag=0;\n    while(1){\n        flag=0;\n        for(i=0;i<len1;i++){\n            if(s[i]==part[0]){\n                for(j=1;j<len2;j++){\n                    if(s[i+j]!=part[j]){\n                        break;\n                    }\n                }\n                if(j==len2){\n                    flag=1;\n                    break;\n                }\n            }\n        }\n        if(flag==0){\n            break;\n        }else{\n            for(j=i;j<len1;j++){\n                s[j]=s[j+len2];\n            }\n        }\n    }\n    return s;\n}", "prefix": "char * removeOccurrences(char * s, char * part"}
{"id": "1420", "path": "output2\\c\\Medium\\1420-maximum-alternating-subsequence-sum.c", "hypo_code": "long long maxAlternatingSum(int* nums, int numsSize){\nint i;\n    long long even=0;\n    long long odd=0;\n    long long tmp;\n    for(i=0;i<numsSize;i++){\n        tmp=even;\n        if(nums[i]>even){\n            even=nums[i];\n        }\n        if(tmp-nums[i]>odd){\n            odd=tmp-nums[i];\n        }\n    }\n    return even+odd;\n}", "prefix": "long long maxAlternatingSum(int* nums, int numsSize"}
{"id": "1421", "path": "output2\\c\\Medium\\1421-cyclically-rotating-a-grid.c", "hypo_code": "int** rotateGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\nint i,j;\n    int m=gridSize;\n    int n=*gridColSize;\n    int **res=(int **)malloc(sizeof(int *)*m);\n    for(i=0;i<m;i++){\n        res[i]=(int *)malloc(sizeof(int)*n);\n    }\n    int temp;\n    int temp_i,temp_j;\n    int count;\n    for(count=0;count<k;count++){\n        temp_i=m-1;\n        temp_j=n-1;\n        for(i=0;i<m/2 && i<n/2;i++,temp_i--,temp_j--){\n            temp=grid[i][i];\n            for(j=i+1;j<=temp_j;j++){\n                grid[i][j-1]=grid[i][j];\n            }\n            for(j=i+1;j<=temp_i;j++){\n                grid[j-1][temp_j]=grid[j][temp_j];\n            }\n            for(j=temp_j-1;j>=i;j--){\n                grid[temp_i][j+1]=grid[temp_i][j];\n            }\n            for(j=temp_i-1;j>=i+1;j--){\n                grid[j+1][i]=grid[j][i];\n            }\n            grid[i+1][i]=temp;\n        }\n    }\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            res[i][j]=grid[i][j];\n        }\n    }\n    *returnSize=m;\n    *returnColumnSizes=(int *)malloc(sizeof(int)*m);\n    for(i=0;i<m;i++){\n        (*returnColumnSizes)[i]=n;\n    }\n    return res;\n}", "prefix": "int** rotateGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes"}
{"id": "1422", "path": "output2\\c\\Medium\\1422-number-of-wonderful-substrings.c", "hypo_code": "long long wonderfulSubstrings(char * word){\nint len=strlen(word);\n    int i;\n    int j;\n    int k;\n    int flag=0;\n    int count=0;\n    int *arr=(int *)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr[i]=0;\n    }\n    for(i=0;i<len;i++){\n        arr[i]=1;\n        for(j=0;j<len;j++){\n            if(arr[j]==1){\n                flag=0;\n                for(k=j+1;k<len;k++){\n                    if(arr[k]==1){\n                        if(word[j]==word[k]){\n                            flag=1;\n                            break;\n                        }\n                    }\n                }\n                if(flag==0){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}", "prefix": "long long wonderfulSubstrings(char * word"}
{"id": "1423", "path": "output2\\c\\Medium\\1423-eliminate-maximum-number-of-monsters.c", "hypo_code": "int eliminateMaximum(int* dist, int distSize, int* speed, int speedSize){\nint i;\n    int max=0;\n    int time=0;\n    int tmp=0;\n    for(i=0;i<distSize;i++){\n        if(max<dist[i]/speed[i]){\n            max=dist[i]/speed[i];\n        }\n    }\n    int count=0;\n    for(i=0;i<distSize;i++){\n        if(max<dist[i]/speed[i]){\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int eliminateMaximum(int* dist, int distSize, int* speed, int speedSize"}
{"id": "1424", "path": "output2\\c\\Medium\\1424-count-good-numbers.c", "hypo_code": "int countGoodNumbers(long long n){\nlong long res=1;\n    long long base=20;\n    long long mod=1000000007;\n    while(n>0){\n        if(n%2==1){\n            res=(res*base)%mod;\n        }\n        n/=2;\n        base=(base*base)%mod;\n    }\n    return (int)res;\n}", "prefix": "int countGoodNumbers(long long n"}
{"id": "1425", "path": "output2\\c\\Medium\\1425-nearest-exit-from-entrance-in-maze.c", "hypo_code": "int nearestExit(char** maze, int mazeSize, int* mazeColSize, int* entrance, int entranceSize){\nint m=mazeSize;\n    int n=*mazeColSize;\n    int i,j;\n    int row=entrance[0];\n    int col=entrance[1];\n    int step=0;\n    int flag=0;\n    int visited[m][n];\n    memset(visited,0,sizeof(visited));\n    visited[row][col]=1;\n    int queue[m*n][2];\n    int head=0;\n    int tail=0;\n    queue[tail][0]=row;\n    queue[tail][1]=col;\n    tail++;\n    while(head<tail){\n        int size=tail-head;\n        while(size--){\n            int row=queue[head][0];\n            int col=queue[head][1];\n            head++;\n            if(row==0||row==m-1||col==0||col==n-1){\n                if(!(row==entrance[0]&&col==entrance[1])){\n                    return step;\n                }\n            }\n            if(row-1>=0&&maze[row-1][col]=='.'&&visited[row-1][col]==0){\n                visited[row-1][col]=1;\n                queue[tail][0]=row-1;\n                queue[tail][1]=col;\n                tail++;\n            }\n            if(row+1<m&&maze[row+1][col]=='.'&&visited[row+1][col]==0){\n                visited[row+1][col]=1;\n                queue[tail][0]=row+1;\n                queue[tail][1]=col;\n                tail++;\n            }\n            if(col-1>=0&&maze[row][col-1]=='.'&&visited[row][col-1]==0){\n                visited[row][col-1]=1;\n                queue[tail][0]=row;\n                queue[tail][1]=col-1;\n                tail++;\n            }\n            if(col+1<n&&maze[row][col+1]=='.'&&visited[row][col+1]==0){\n                visited[row][col+1]=1;\n                queue[tail][0]=row;\n                queue[tail][1]=col+1;\n                tail++;\n            }\n        }\n        step++;\n    }\n    return -1;\n}", "prefix": "int nearestExit(char** maze, int mazeSize, int* mazeColSize, int* entrance, int entranceSize"}
{"id": "1426", "path": "output2\\c\\Medium\\1426-sum-game.c", "hypo_code": "bool sumGame(char * num){\nint sum1=0;\n    int sum2=0;\n    int cnt1=0;\n    int cnt2=0;\n    int i=0;\n    int j=len/2;\n    while(i<len/2){\n        if(num[i]=='?'){\n            cnt1++;\n        }else{\n            sum1+=num[i]-'0';\n        }\n        i++;\n    }\n    while(j<len){\n        if(num[j]=='?'){\n            cnt2++;\n        }else{\n            sum2+=num[j]-'0';\n        }\n        j++;\n    }\n    if((cnt1+cnt2)%2==1){\n        return true;\n    }\n    if(sum1==sum2&&cnt1==cnt2){\n        return false;\n    }\n    if(sum1==sum2){\n        return true;\n    }\n    if(cnt1==cnt2){\n        return false;\n    }\n    if(sum1>sum2){\n        if((sum1-sum2)/9>cnt1-cnt2){\n            return true;\n        }else{\n            return false;\n        }\n    }else{\n        if((sum2-sum1)/9>cnt2-cnt1){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}", "prefix": "bool sumGame(char * num"}
{"id": "1427", "path": "output2\\c\\Medium\\1427-unique-length-3-palindromic-subsequences.c", "hypo_code": "int countPalindromicSubsequence(char * s){\nint len=strlen(s);\n    int i;\n    int j;\n    int k;\n    int count=0;\n    int *arr=(int *)malloc(sizeof(int)*26);\n    for(i=0;i<len-2;i++){\n        arr[s[i]-'a']=1;\n        for(j=i+1;j<len-1;j++){\n            if(s[i]==s[j]){\n                for(k=j+1;k<len;k++){\n                    if(s[i]==s[k]&&arr[s[i]-'a']==1){\n                        count++;\n                        arr[s[i]-'a']=0;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}", "prefix": "int countPalindromicSubsequence(char * s"}
{"id": "1429", "path": "output2\\c\\Medium\\1429-add-minimum-number-of-rungs.c", "hypo_code": "int addRungs(int* rungs, int rungsSize, int dist){\nint i;\n    int count=0;\n    int tmp=0;\n    for(i=0;i<rungsSize;i++){\n        if(rungs[i]-tmp>dist){\n            count+=(rungs[i]-tmp-1)/dist;\n        }\n        tmp=rungs[i];\n    }\n    return count;\n}", "prefix": "int addRungs(int* rungs, int rungsSize, int dist"}
{"id": "1430", "path": "output2\\c\\Medium\\1430-maximum-number-of-points-with-cost.c", "hypo_code": "long long maxPoints(int** points, int pointsSize, int* pointsColSize){\nint i,j;\n    long long max=0;\n    long long tmp;\n    long long **dp=(long long **)malloc(sizeof(long long *)*pointsSize);\n    for(i=0;i<pointsSize;i++){\n        dp[i]=(long long *)malloc(sizeof(long long)*pointsColSize[i]);\n    }\n    for(i=0;i<pointsColSize[0];i++){\n        dp[0][i]=points[0][i];\n    }\n    for(i=1;i<pointsSize;i++){\n        for(j=0;j<pointsColSize[i];j++){\n            tmp=dp[i-1][0]-j;\n            for(int k=1;k<pointsColSize[i-1];k++){\n                if(dp[i-1][k]-abs(j-k)>tmp){\n                    tmp=dp[i-1][k]-abs(j-k);\n                }\n            }\n            dp[i][j]=tmp+points[i][j];\n        }\n    }\n    for(i=0;i<pointsColSize[pointsSize-1];i++){\n        if(dp[pointsSize-1][i]>max){\n            max=dp[pointsSize-1][i];\n        }\n    }\n    return max;\n}", "prefix": "long long maxPoints(int** points, int pointsSize, int* pointsColSize"}
{"id": "1431", "path": "output2\\c\\Medium\\1431-the-number-of-the-smallest-unoccupied-chair.c", "hypo_code": "int smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend){\nint i,j;\n    int min=0;\n    int max=0;\n    int mid;\n    int tmp;\n    int min_chair;\n    int max_chair;\n    int *chair=(int*)malloc(sizeof(int)*timesSize);\n    for(i=0;i<timesSize;i++){\n        chair[i]=0;\n    }\n    for(i=0;i<timesSize;i++){\n        chair[times[i][1]]=1;\n        if(times[i][1]>max){\n            max=times[i][1];\n        }\n    }\n    for(i=0;i<timesSize;i++){\n        if(times[i][0]>max){\n            max=times[i][0];\n        }\n    }\n    for(i=0;i<timesSize;i++){\n        if(times[i][0]<min){\n            min=times[i][0];\n        }\n    }\n    min_chair=0;\n    max_chair=0;\n    for(i=0;i<timesSize;i++){\n        if(times[i][0]==min){\n            for(j=0;j<timesSize;j++){\n                if(chair[j]==0){\n                    min_chair=j;\n                    chair[j]=1;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    for(i=0;i<timesSize;i++){\n        if(times[i][1]==max){\n            for(j=0;j<timesSize;j++){\n                if(chair[j]==0){\n                    max_chair=j;\n                    chair[j]=1;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    for(i=0;i<timesSize;i++){\n        if(i==targetFriend){\n            break;\n        }\n        tmp=0;\n        for(j=0;j<timesSize;j++){\n            if(chair[j]==0){\n                tmp=j;\n                chair[j]=1;\n                break;\n            }\n        }\n        if(tmp<min_chair){\n            min_chair=tmp;\n        }\n    }\n    return min_chair;\n}", "prefix": "int smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend"}
{"id": "1432", "path": "output2\\c\\Medium\\1432-describe-the-painting.c", "hypo_code": "long long** splitPainting(int** segments, int segmentsSize, int* segmentsColSize, int* returnSize, int** returnColumnSizes){\nint i,j;\n    int len=segmentsSize;\n    int *arr=(int *)malloc(sizeof(int)*100001);\n    memset(arr,0,sizeof(int)*100001);\n    long long **res=(long long **)malloc(sizeof(long long *)*len);\n    for(i=0;i<len;i++){\n        res[i]=(long long *)malloc(sizeof(long long)*3);\n    }\n    for(i=0;i<len;i++){\n        arr[segments[i][0]]+=segments[i][2];\n        arr[segments[i][1]]-=segments[i][2];\n    }\n    *returnSize=0;\n    int index=0;\n    int flag=0;\n    for(i=0;i<100001;i++){\n        if(arr[i]!=0){\n            if(flag==0){\n                res[index][0]=i;\n                res[index][1]=i;\n                res[index][2]=arr[i];\n                flag=1;\n            }else{\n                res[index][1]=i;\n                res[index][2]+=arr[i];\n            }\n        }else{\n            if(flag==1){\n                index++;\n                flag=0;\n            }\n        }\n    }\n    *returnSize=index;\n    *returnColumnSizes=(int *)malloc(sizeof(int)*index);\n    for(i=0;i<index;i++){\n        (*returnColumnSizes)[i]=3;\n    }\n    return res;\n}", "prefix": "long long** splitPainting(int** segments, int segmentsSize, int* segmentsColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1433", "path": "output2\\c\\Medium\\1433-largest-number-after-mutating-substring.c", "hypo_code": "char * maximumNumber(char * num, int* change, int changeSize){\nint len=strlen(num);\n    int i;\n    int flag=0;\n    for(i=0;i<len;i++){\n        if(num[i]-'0'<change[num[i]-'0']){\n            num[i]=change[num[i]-'0']+'0';\n            flag=1;\n        }else if(num[i]-'0'>change[num[i]-'0']){\n            if(flag==1){\n                break;\n            }\n        }\n    }\n    return num;\n}", "prefix": "char * maximumNumber(char * num, int* change, int changeSize"}
{"id": "1434", "path": "output2\\c\\Medium\\1434-maximum-compatibility-score-sum.c", "hypo_code": "int maxCompatibilitySum(int** students, int studentsSize, int* studentsColSize, int** mentors, int mentorsSize, int* mentorsColSize){\nint i,j,k;\n    int max=0;\n    int count=0;\n    int tmp;\n    int **compatibility;\n    compatibility=(int**)malloc(sizeof(int*)*studentsSize);\n    for(i=0;i<studentsSize;i++){\n        compatibility[i]=(int*)malloc(sizeof(int)*mentorsSize);\n    }\n    for(i=0;i<studentsSize;i++){\n        for(j=0;j<mentorsSize;j++){\n            count=0;\n            for(k=0;k<studentsColSize[0];k++){\n                if(students[i][k]==mentors[j][k]){\n                    count++;\n                }\n            }\n            compatibility[i][j]=count;\n        }\n    }\n    for(i=0;i<studentsSize;i++){\n        for(j=0;j<mentorsSize;j++){\n            for(k=j+1;k<mentorsSize;k++){\n                if(compatibility[i][j]<compatibility[i][k]){\n                    tmp=compatibility[i][j];\n                    compatibility[i][j]=compatibility[i][k];\n                    compatibility[i][k]=tmp;\n                }\n            }\n        }\n    }\n    for(i=0;i<studentsSize;i++){\n        max+=compatibility[i][0];\n    }\n    return max;\n}", "prefix": "int maxCompatibilitySum(int** students, int studentsSize, int* studentsColSize, int** mentors, int mentorsSize, int* mentorsColSize"}
{"id": "1435", "path": "output2\\c\\Medium\\1435-maximum-number-of-weeks-for-which-you-can-work.c", "hypo_code": "long long numberOfWeeks(int* milestones, int milestonesSize){\nint i;\n    long long sum=0;\n    long long max=0;\n    for(i=0;i<milestonesSize;i++){\n        sum+=milestones[i];\n        if(max<milestones[i]){\n            max=milestones[i];\n        }\n    }\n    if(max>(sum-max)){\n        return (sum-max)*2+1;\n    }\n    return sum;\n}", "prefix": "long long numberOfWeeks(int* milestones, int milestonesSize"}
{"id": "1436", "path": "output2\\c\\Medium\\1436-minimum-garden-perimeter-to-collect-enough-apples.c", "hypo_code": "long long minimumPerimeter(long long neededApples){\nlong long i;\n    long long sum=0;\n    long long tmp=0;\n    for(i=1;i<100000;i++){\n        tmp+=i*i*12;\n        if(tmp>=neededApples){\n            return i*8;\n        }\n    }\n    return 0;\n}", "prefix": "long long minimumPerimeter(long long neededApples"}
{"id": "1437", "path": "output2\\c\\Medium\\1437-check-if-move-is-legal.c", "hypo_code": "bool checkMove(char** board, int boardSize, int* boardColSize, int rMove, int cMove, char color){\n  int i,j,k;\n    int count=0;\n    int flag=0;\n    int m=boardSize;\n    int n=*boardColSize;\n    board[rMove][cMove]=color;\n    if(rMove-1>=0&&board[rMove-1][cMove]==color){\n        return true;\n    }\n    if(rMove+1<m&&board[rMove+1][cMove]==color){\n        return true;\n    }\n    if(cMove-1>=0&&board[rMove][cMove-1]==color){\n        return true;\n    }\n    if(cMove+1<n&&board[rMove][cMove+1]==color){\n        return true;\n    }\n    if(rMove-1>=0&&cMove-1>=0&&board[rMove-1][cMove-1]==color){\n        return true;\n    }\n    if(rMove+1<m&&cMove+1<n&&board[rMove+1][cMove+1]==color){\n        return true;\n    }\n    if(rMove-1>=0&&cMove+1<n&&board[rMove-1][cMove+1]==color){\n        return true;\n    }\n    if(rMove+1<m&&cMove-1>=0&&board[rMove+1][cMove-1]==color){\n        return true;\n    }\n    return false;\n\n}", "prefix": "bool checkMove(char** board, int boardSize, int* boardColSize, int rMove, int cMove, char color"}
{"id": "1438", "path": "output2\\c\\Medium\\1438-minimum-total-space-wasted-with-k-resizing-operations.c", "hypo_code": "int minSpaceWastedKResizing(int* nums, int numsSize, int k){\nint i,j;\n    int len=numsSize;\n    int **dp=(int **)malloc(sizeof(int *)*len);\n    for(i=0;i<len;i++){\n        dp[i]=(int *)malloc(sizeof(int)*(k+1));\n    }\n    for(i=0;i<len;i++){\n        for(j=0;j<=k;j++){\n            dp[i][j]=INT_MAX;\n        }\n    }\n    int *sum=(int *)malloc(sizeof(int)*(len+1));\n    sum[0]=0;\n    for(i=0;i<len;i++){\n        sum[i+1]=sum[i]+nums[i];\n    }\n    for(i=0;i<len;i++){\n        dp[i][0]=(i+1)*nums[i]-sum[i+1];\n    }\n    for(i=0;i<len;i++){\n        for(j=1;j<=k;j++){\n            for(int m=0;m<i;m++){\n                dp[i][j]=min(dp[i][j],dp[m][j-1]+(i-m)*max(nums,m+1,i+1)-sum[i+1]+sum[m+1]);\n            }\n        }\n    }\n    return dp[len-1][k];\n}", "prefix": "int minSpaceWastedKResizing(int* nums, int numsSize, int k"}
{"id": "1439", "path": "output2\\c\\Medium\\1439-remove-stones-to-minimize-the-total.c", "hypo_code": "int minStoneSum(int* piles, int pilesSize, int k){\nint i,j;\n    int count=0;\n    int max=0;\n    int max_index=0;\n    int next_max=0;\n    int next_max_index=0;\n    for(i=0;i<pilesSize;i++){\n        if(piles[i]>max){\n            max=piles[i];\n            max_index=i;\n        }\n    }\n    if(max_index==0){\n        for(i=1;i<pilesSize;i++){\n            if(piles[i]>next_max){\n                next_max=piles[i];\n                next_max_index=i;\n            }\n        }\n        for(i=next_max_index;i<pilesSize;i++){\n            if(piles[i]!=next_max){\n                count++;\n            }\n        }\n        return count;\n    }\n    for(i=0;i<pilesSize;i++){\n        if(piles[i]>next_max&&piles[i]<max){\n            next_max=piles[i];\n            next_max_index=i;\n        }\n    }\n    for(i=next_max_index;i<pilesSize;i++){\n        if(piles[i]!=next_max){\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int minStoneSum(int* piles, int pilesSize, int k"}
{"id": "1440", "path": "output2\\c\\Medium\\1440-minimum-number-of-swaps-to-make-the-string-balanced.c", "hypo_code": "int minSwaps(char * s){\nint len=strlen(s);\n    int i;\n    int count=0;\n    int flag=0;\n    int max=0;\n    int max_index=0;\n    int next_max=0;\n    int next_max_index=0;\n    for(i=0;i<len;i++){\n        if(s[i]=='['){\n            count++;\n        }else{\n            count--;\n        }\n        if(count>max){\n            max=count;\n            max_index=i;\n        }\n    }\n    if(max_index==len-1){\n        for(i=len-2;i>=0;i--){\n            if(s[i]=='['){\n                count++;\n            }else{\n                count--;\n            }\n            if(count!=max){\n                flag++;\n            }\n        }\n        return flag;\n    }\n    for(i=max_index+1;i<len;i++){\n        if(s[i]=='['){\n            count++;\n        }else{\n            count--;\n        }\n        if(count==max){\n            next_max_index=i;\n            break;\n        }\n    }\n    for(i=next_max_index;i<len;i++){\n        if(s[i]=='['){\n            count++;\n        }else{\n            count--;\n        }\n        if(count!=max){\n            flag++;\n        }\n    }\n    return flag;\n}", "prefix": "int minSwaps(char * s"}
{"id": "1441", "path": "output2\\c\\Medium\\1441-array-with-elements-not-equal-to-average-of-neighbors.c", "hypo_code": "int* rearrangeArray(int* nums, int numsSize, int* returnSize){\nint i;\n    int *res=(int *)malloc(sizeof(int)*numsSize);\n    int *arr=(int *)malloc(sizeof(int)*numsSize);\n    int index=0;\n    for(i=0;i<numsSize;i++){\n        arr[i]=nums[i];\n    }\n    for(i=0;i<numsSize;i++){\n        if(i%2==0){\n            res[i]=arr[index];\n        }else{\n            res[i]=arr[numsSize-index-1];\n            index++;\n        }\n    }\n    *returnSize=numsSize;\n    return res;\n}", "prefix": "int* rearrangeArray(int* nums, int numsSize, int* returnSize"}
{"id": "1442", "path": "output2\\c\\Medium\\1442-minimum-non-zero-product-of-the-array-elements.c", "hypo_code": "int minNonZeroProduct(int p){\nlong long int max=pow(2,p)-1;\n    long long int mod=1000000007;\n    long long int res;\n    res=max%mod;\n    res*=max%mod;\n    res%=mod;\n    res*=power(max-1,max/2,mod);\n    res%=mod;\n    return res;\n}\nlong long int power(long long int x,long long int y,long long int mod){\n    if(y==0){\n        return 1;\n    }\n    long long int res=power(x,y/2,mod);\n    res*=res;\n    res%=mod;\n    if(y%2==1){\n        res*=x;\n        res%=mod;\n    }\n    return res;\n}", "prefix": "int minNonZeroProduct(int p"}
{"id": "1443", "path": "output2\\c\\Medium\\1443-maximum-matrix-sum.c", "hypo_code": "long long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\nint i,j;\n    int count=0;\n    int max=0;\n    int max_index=0;\n    int next_max=0;\n    int next_max_index=0;\n    for(i=0;i<matrixSize;i++){\n        if(matrix[i][0]>max){\n            max=matrix[i][0];\n            max_index=i;\n        }\n    }\n    if(max_index==0){\n        for(i=1;i<matrixSize;i++){\n            if(matrix[i][1]>next_max){\n                next_max=matrix[i][1];\n                next_max_index=i;\n            }\n        }\n        for(i=next_max_index;i<matrixSize;i++){\n            if(matrix[i][1]!=next_max){\n                count++;\n            }\n        }\n        return count;\n    }\n    for(i=0;i<matrixSize;i++){\n        if(matrix[i][1]>next_max&&matrix[i][1]<max){\n            next_max=matrix[i][1];\n            next_max_index=i;\n        }\n    }\n    for(i=next_max_index;i<matrixSize;i++){\n        if(matrix[i][1]!=next_max){\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "long long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "1444", "path": "output2\\c\\Medium\\1444-number-of-ways-to-arrive-at-destination.c", "hypo_code": "int countPaths(int n, int** roads, int roadsSize, int* roadsColSize){\nint i,j;\n    int **dp=(int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        dp[i]=(int*)malloc(sizeof(int)*2);\n        dp[i][0]=0;\n        dp[i][1]=0;\n    }\n    dp[0][0]=0;\n    dp[0][1]=1;\n    int min;\n    int min_index;\n    int count;\n    int tmp;\n    int index;\n    for(i=0;i<n;i++){\n        min=INT_MAX;\n        min_index=-1;\n        for(j=0;j<roadsSize;j++){\n            if(roads[j][0]==i){\n                if(dp[roads[j][1]][0]<min){\n                    min=dp[roads[j][1]][0];\n                    min_index=roads[j][1];\n                }\n            }\n            if(roads[j][1]==i){\n                if(dp[roads[j][0]][0]<min){\n                    min=dp[roads[j][0]][0];\n                    min_index=roads[j][0];\n                }\n            }\n        }\n        if(min_index==-1){\n            continue;\n        }\n        dp[i][0]=min+1;\n        count=0;\n        for(j=0;j<roadsSize;j++){\n            if(roads[j][0]==i){\n                if(dp[roads[j][1]][0]==min){\n                    count+=dp[roads[j][1]][1];\n                }\n            }\n            if(roads[j][1]==i){\n                if(dp[roads[j][0]][0]==min){\n                    count+=dp[roads[j][0]][1];\n                }\n            }\n        }\n        dp[i][1]=count%1000000007;\n    }\n    return dp[n-1][1];\n}", "prefix": "int countPaths(int n, int** roads, int roadsSize, int* roadsColSize"}
{"id": "1445", "path": "output2\\c\\Medium\\1445-find-unique-binary-string.c", "hypo_code": "char * findDifferentBinaryString(char ** nums, int numsSize){\nint i,j;\n    int len=strlen(nums[0]);\n    int nums_len=pow(2,len);\n    char *res=malloc(sizeof(char)*(len+1));\n    char **arr=malloc(sizeof(char*)*nums_len);\n    for(i=0;i<nums_len;i++){\n        arr[i]=malloc(sizeof(char)*(len+1));\n        memset(arr[i],0,len+1);\n    }\n    for(i=0;i<numsSize;i++){\n        strcpy(arr[atoi(nums[i])],nums[i]);\n    }\n    for(i=0;i<nums_len;i++){\n        if(arr[i][0]==0){\n            sprintf(res,\"%d\",i);\n            break;\n        }\n    }\n    for(i=0;i<nums_len;i++){\n        free(arr[i]);\n    }\n    free(arr);\n    return res;\n}", "prefix": "char * findDifferentBinaryString(char ** nums, int numsSize"}
{"id": "1446", "path": "output2\\c\\Medium\\1446-minimize-the-difference-between-target-and-chosen-elements.c", "hypo_code": "int minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\nint i,j;\n    int m=matSize;\n    int n=*matColSize;\n    int min=0;\n    int max=0;\n    int mid;\n    int sum;\n    int max_sum=0;\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            max+=mat[i][j];\n        }\n    }\n    max_sum=2*max;\n    while(min<=max){\n        mid=(min+max)/2;\n        sum=0;\n        for(i=0;i<m;i++){\n            for(j=0;j<n;j++){\n                if(sum<target){\n                    sum+=mat[i][j];\n                    if(sum>target){\n                        sum-=mat[i][j];\n                    }\n                }\n            }\n        }\n        if(sum==target){\n            return 0;\n        }\n        if(sum>target){\n            max=mid-1;\n        }\n        else{\n            min=mid+1;\n        }\n    }\n    return max_sum;\n\n}", "prefix": "int minimizeTheDifference(int** mat, int matSize, int* matColSize, int target"}
{"id": "1447", "path": "output2\\c\\Medium\\1447-find-the-kth-largest-integer-in-the-array.c", "hypo_code": "char * kthLargestNumber(char ** nums, int numsSize, int k){\nint i;\n    int j;\n    int len;\n    char *temp;\n    for(i=0;i<numsSize-1;i++){\n        for(j=0;j<numsSize-i-1;j++){\n            if(strlen(nums[j])<strlen(nums[j+1])){\n                temp=nums[j];\n                nums[j]=nums[j+1];\n                nums[j+1]=temp;\n            }else if(strlen(nums[j])==strlen(nums[j+1])){\n                if(strcmp(nums[j],nums[j+1])<0){\n                    temp=nums[j];\n                    nums[j]=nums[j+1];\n                    nums[j+1]=temp;\n                }\n            }\n        }\n    }\n    return nums[k-1];\n}", "prefix": "char * kthLargestNumber(char ** nums, int numsSize, int k"}
{"id": "1448", "path": "output2\\c\\Medium\\1448-minimum-number-of-work-sessions-to-finish-the-tasks.c", "hypo_code": "int minSessions(int* tasks, int tasksSize, int sessionTime){\nint i;\n    int max=0;\n    int sum=0;\n    int min=0;\n    int mid;\n    int time;\n    int count=0;\n    for(i=0;i<tasksSize;i++){\n        sum+=tasks[i];\n        if(max<tasks[i]){\n            max=tasks[i];\n        }\n    }\n    if(sum<=sessionTime){\n        return 1;\n    }\n    min=1;\n    while(min<=max){\n        mid=(min+max)/2;\n        time=0;\n        count=0;\n        for(i=0;i<tasksSize;i++){\n            if(time+tasks[i]>mid){\n                time=0;\n                count++;\n            }\n            time+=tasks[i];\n        }\n        if(time>0){\n            count++;\n        }\n        if(count>sessionTime){\n            min=mid+1;\n        }else{\n            max=mid-1;\n        }\n    }\n    return min;\n}", "prefix": "int minSessions(int* tasks, int tasksSize, int sessionTime"}
{"id": "1449", "path": "output2\\c\\Medium\\1449-find-all-groups-of-farmland.c", "hypo_code": "int** findFarmland(int** land, int landSize, int* landColSize, int* returnSize, int** returnColumnSizes){\nint i,j;\n    int m=landSize;\n    int n=*landColSize;\n    int **res=(int **)malloc(sizeof(int *)*m*n);\n    int index=0;\n    int flag=0;\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            if(land[i][j]==1){\n                int temp_i=i;\n                int temp_j=j;\n                while(temp_i<m && land[temp_i][j]==1){\n                    temp_i++;\n                }\n                while(temp_j<n && land[i][temp_j]==1){\n                    temp_j++;\n                }\n                res[index]=(int *)malloc(sizeof(int)*4);\n                res[index][0]=i;\n                res[index][1]=j;\n                res[index][2]=temp_i-1;\n                res[index][3]=temp_j-1;\n                index++;\n                flag=1;\n                for(int k=i;k<temp_i;k++){\n                    for(int l=j;l<temp_j;l++){\n                        land[k][l]=0;\n                    }\n                }\n            }\n        }\n    }\n    if(flag==0){\n        *returnSize=0;\n        return res;\n    }\n    *returnSize=index;\n    *returnColumnSizes=(int *)malloc(sizeof(int)*index);\n    for(i=0;i<index;i++){\n        (*returnColumnSizes)[i]=4;\n    }\n    return res;\n\n=======\nSuggestion 2\n\nint i,j,k;\n    int m=landSize;\n    int n=*landColSize;\n    int len=m*n;\n    int **res=(int **)malloc(sizeof(int *)*len);\n    *returnColumnSizes=(int *)malloc(sizeof(int)*len);\n    int index=0;\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            if(land[i][j]==1){\n                int flag=0;\n                for(k=i;k<m;k++){\n                    if(land[k][j]==0){\n                        break;\n                    }\n                    for(int l=j;l<n;l++){\n                        if(land[k][l]==0){\n                            flag=1;\n                            break;\n                        }\n                    }\n                    if(flag==1){\n                        break;\n                    }\n                }\n                res[index]=(int *)malloc(sizeof(int)*4);\n                res[index][0]=i;\n                res[index][1]=j;\n                res[index][2]=k-1;\n                res[index][3]=j;\n                (*returnColumnSizes)[index]=4;\n                index++;\n            }\n        }\n    }\n    *returnSize=index;\n    return res;\n\n}", "prefix": "int** findFarmland(int** land, int landSize, int* landColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1451", "path": "output2\\c\\Medium\\1451-the-number-of-weak-characters-in-the-game.c", "hypo_code": "int numberOfWeakCharacters(int** properties, int propertiesSize, int* propertiesColSize){\nint i,j;\n    int count=0;\n    int max=0;\n    int max_index=0;\n    int next_max=0;\n    int next_max_index=0;\n    for(i=0;i<propertiesSize;i++){\n        if(properties[i][0]>max){\n            max=properties[i][0];\n            max_index=i;\n        }\n    }\n    if(max_index==0){\n        for(i=1;i<propertiesSize;i++){\n            if(properties[i][1]>next_max){\n                next_max=properties[i][1];\n                next_max_index=i;\n            }\n        }\n        for(i=next_max_index;i<propertiesSize;i++){\n            if(properties[i][1]!=next_max){\n                count++;\n            }\n        }\n        return count;\n    }\n    for(i=0;i<propertiesSize;i++){\n        if(properties[i][0]<max&&properties[i][1]<properties[max_index][1]){\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int numberOfWeakCharacters(int** properties, int propertiesSize, int* propertiesColSize"}
{"id": "1452", "path": "output2\\c\\Medium\\1452-first-day-where-you-have-been-in-all-the-rooms.c", "hypo_code": "int firstDayBeenInAllRooms(int* nextVisit, int nextVisitSize){\nint i;\n    int mod=1000000007;\n    int n=nextVisitSize;\n    long long *dp=(long long*)malloc(sizeof(long long)*n);\n    dp[0]=0;\n    dp[1]=2;\n    for(i=2;i<n;i++){\n        dp[i]=(dp[i-1]*2-dp[nextVisit[i-1]]+2+mod)%mod;\n    }\n    return dp[n-1];\n}", "prefix": "int firstDayBeenInAllRooms(int* nextVisit, int nextVisitSize"}
{"id": "1453", "path": "output2\\c\\Medium\\1453-number-of-pairs-of-interchangeable-rectangles.c", "hypo_code": "long long interchangeableRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize){\n    int i, j;\n    int count = 0;\n    int mod = 1000000007;\n    for(i = 0; i < rectanglesSize; i++){\n        for(j = i + 1; j < rectanglesSize; j++){\n            if((double)rectangles[i][0] / rectangles[i][1] == (double)rectangles[j][0] / rectangles[j][1]){\n                count++;\n            }\n        }\n    }\n    return count % mod;\n\n}", "prefix": "long long interchangeableRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize"}
{"id": "1454", "path": "output2\\c\\Medium\\1454-maximum-product-of-the-length-of-two-palindromic-subsequences.c", "hypo_code": "int maxProduct(char * s){\n    int i, j, k, l, m, n;\n    int len = strlen(s);\n    int max = 0;\n    int count = 0;\n    int* arr = malloc(len * sizeof(int));\n    for(i = 0; i < len; i++){\n        for(j = i; j < len; j++){\n            for(k = i; k <= j; k++){\n                for(l = j; l >= i; l--){\n                    if(s[k] == s[l]){\n                        count++;\n                        break;\n                    }\n                }\n            }\n            if(count == j - i + 1){\n                arr[i] = j - i + 1;\n            }\n            count = 0;\n        }\n    }\n    for(i = 0; i < len; i++){\n        for(j = i; j < len; j++){\n            for(k = i; k <= j; k++){\n                for(l = j; l >= i; l--){\n                    if(s[k] == s[l]){\n                        count++;\n                        break;\n                    }\n                }\n            }\n            if(count == j - i + 1){\n                if(arr[i] * (j - i + 1) > max){\n                    max = arr[i] * (j - i + 1);\n                }\n            }\n            count = 0;\n        }\n    }\n    return max;\n\n}", "prefix": "int maxProduct(char * s"}
{"id": "1455", "path": "output2\\c\\Medium\\1455-find-original-array-from-doubled-array.c", "hypo_code": "int* findOriginalArray(int* changed, int changedSize, int* returnSize){\n    int* arr = malloc(changedSize * sizeof(int));\n    int i, j;\n    int count = 0;\n    for(i = 0; i < changedSize; i++){\n        arr[i] = 0;\n    }\n    for(i = 0; i < changedSize; i++){\n        for(j = i + 1; j < changedSize; j++){\n            if(changed[i] == changed[j] * 2){\n                arr[i] = 1;\n                arr[j] = 1;\n            }\n        }\n    }\n    for(i = 0; i < changedSize; i++){\n        if(arr[i] == 1){\n            count++;\n        }\n    }\n    int* arr1 = malloc(count * sizeof(int));\n    int index = 0;\n    for(i = 0; i < changedSize; i++){\n        if(arr[i] == 1){\n            arr1[index] = changed[i];\n            index++;\n        }\n    }\n    for(i = 0; i < count; i++){\n        for(j = i + 1; j < count; j++){\n            if(arr1[i] == arr1[j] * 2){\n                arr1[j] = -1;\n            }\n        }\n    }\n    for(i = 0; i < count; i++){\n        if(arr1[i] == -1){\n            count--;\n        }\n    }\n    int* arr2 = malloc(count * sizeof(int));\n    index = 0;\n    for(i = 0; i < count; i++){\n        if(arr1[i] != -1){\n            arr2[index] = arr1[i];\n            index++;\n        }\n    }\n    *returnSize = count;\n    return arr2;\n\n}", "prefix": "int* findOriginalArray(int* changed, int changedSize, int* returnSize"}
{"id": "1456", "path": "output2\\c\\Medium\\1456-maximum-earnings-from-taxi.c", "hypo_code": "long long maxTaxiEarnings(int n, int** rides, int ridesSize, int* ridesColSize){\n    int i, j;\n    int max = 0;\n    int mod = 1000000007;\n    int* arr = (int*)malloc(sizeof(int) * n);\n    for(i = 0; i < n; i++){\n        arr[i] = 0;\n    }\n    for(i = 0; i < ridesSize; i++){\n        for(j = rides[i][0]; j < rides[i][1]; j++){\n            arr[j] = rides[i][2] + rides[i][1] - rides[i][0];\n        }\n    }\n    for(i = 0; i < n; i++){\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    return max % mod;\n\n}", "prefix": "long long maxTaxiEarnings(int n, int** rides, int ridesSize, int* ridesColSize"}
{"id": "1457", "path": "output2\\c\\Medium\\1457-sum-of-beauty-in-the-array.c", "hypo_code": "int sumOfBeauties(int* nums, int numsSize){\n    int i, j;\n    int count = 0;\n    int max = 0;\n    int min = 100000;\n    for(i = 1; i < numsSize - 1; i++){\n        for(j = 0; j < i; j++){\n            if(nums[j] > max){\n                max = nums[j];\n            }\n        }\n        for(j = i + 1; j < numsSize; j++){\n            if(nums[j] < min){\n                min = nums[j];\n            }\n        }\n        if(nums[i] > max && nums[i] < min){\n            count += 2;\n        }\n        else if(nums[i - 1] < nums[i] && nums[i] < nums[i + 1]){\n            count++;\n        }\n        max = 0;\n        min = 100000;\n    }\n    return count;\n\n}", "prefix": "int sumOfBeauties(int* nums, int numsSize"}
{"id": "1459", "path": "output2\\c\\Medium\\1459-grid-game.c", "hypo_code": "long long gridGame(int** grid, int gridSize, int* gridColSize){\nint i;\n    int n=*gridColSize;\n    long long top[n];\n    long long bottom[n];\n    top[0]=grid[0][0];\n    bottom[0]=grid[1][0];\n    for(i=1;i<n;i++){\n        top[i]=top[i-1]+grid[0][i];\n        bottom[i]=bottom[i-1]+grid[1][i];\n    }\n    long long res=bottom[n-1];\n    if(n==1){\n        return 0;\n    }\n    for(i=1;i<n;i++){\n        long long temp=0;\n        temp=top[n-1]-top[i-1];\n        if(i>0){\n            temp-=bottom[i-1];\n        }\n        if(temp<res){\n            res=temp;\n        }\n    }\n    return res;\n}", "prefix": "long long gridGame(int** grid, int gridSize, int* gridColSize"}
{"id": "1460", "path": "output2\\c\\Medium\\1460-check-if-word-can-be-placed-in-crossword.c", "hypo_code": "bool placeWordInCrossword(char** board, int boardSize, int* boardColSize, char * word){\nint n=*boardColSize;\n    int i,j;\n    int flag=0;\n    int len=strlen(word);\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            if(board[i][j]==' '||board[i][j]==word[0]){\n                flag=0;\n                if(j+len-1<n){\n                    if(j==0||board[i][j-1]=='#'){\n                        flag=1;\n                        for(int k=0;k<len;k++){\n                            if(board[i][j+k]!=' '&&board[i][j+k]!=word[k]){\n                                flag=0;\n                                break;\n                            }\n                        }\n                        if(flag==1){\n                            if(j+len==n||board[i][j+len]=='#'){\n                                return true;\n                            }\n                        }\n                    }\n                }\n                if(i+len-1<m){\n                    if(i==0||board[i-1][j]=='#'){\n                        flag=1;\n                        for(int k=0;k<len;k++){\n                            if(board[i+k][j]!=' '&&board[i+k][j]!=word[k]){\n                                flag=0;\n                                break;\n                            }\n                        }\n                        if(flag==1){\n                            if(i+len==m||board[i+len][j]=='#'){\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}", "prefix": "bool placeWordInCrossword(char** board, int boardSize, int* boardColSize, char * word"}
{"id": "1461", "path": "output2\\c\\Medium\\1461-number-of-pairs-of-strings-with-concatenation-equal-to-target.c", "hypo_code": "int numOfPairs(char ** nums, int numsSize, char * target){\nint i,j;\n    int count=0;\n    int len=strlen(target);\n    for(i=0;i<numsSize;i++){\n        for(j=0;j<numsSize;j++){\n            if(i!=j){\n                if(strncmp(nums[i],target,len)==0){\n                    if(strncmp(nums[j],target+len,strlen(nums[j]))==0){\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int numOfPairs(char ** nums, int numsSize, char * target"}
{"id": "1462", "path": "output2\\c\\Medium\\1462-maximize-the-confusion-of-an-exam.c", "hypo_code": "int maxConsecutiveAnswers(char * answerKey, int k){\nint len=strlen(answerKey);\n    int i,j;\n    int max=0;\n    int count=0;\n    int flag=0;\n    int count1=0;\n    int count2=0;\n    for(i=0;i<len;i++){\n        if(answerKey[i]=='T'){\n            count1++;\n        }else{\n            count2++;\n        }\n    }\n    if(count1==len){\n        return len;\n    }\n    if(count2==len){\n        return len;\n    }\n    if(count1>=count2){\n        flag=1;\n    }else{\n        flag=0;\n    }\n    for(i=0;i<len;i++){\n        if(answerKey[i]==answerKey[i+1]){\n            count++;\n        }else{\n            if(flag==1){\n                if(k>=count2){\n                    if(max<count+count2){\n                        max=count+count2;\n                    }\n                }else{\n                    if(max<count+k){\n                        max=count+k;\n                    }\n                }\n            }else{\n                if(k>=count1){\n                    if(max<count+count1){\n                        max=count+count1;\n                    }\n                }else{\n                    if(max<count+k){\n                        max=count+k;\n                    }\n                }\n            }\n            count=0;\n        }\n    }\n    return max;\n}", "prefix": "int maxConsecutiveAnswers(char * answerKey, int k"}
{"id": "1463", "path": "output2\\c\\Medium\\1463-find-missing-observations.c", "hypo_code": "int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\nint i,j;\n    int sum=0;\n    int temp;\n    int *res=(int *)malloc(sizeof(int)*n);\n    for(i=0;i<rollsSize;i++){\n        sum+=rolls[i];\n    }\n    temp=mean*(n+rollsSize)-sum;\n    if(temp>n*6 || temp<n){\n        *returnSize=0;\n        return res;\n    }\n    for(i=0;i<n;i++){\n        res[i]=temp/n;\n    }\n    for(i=0;i<temp%n;i++){\n        res[i]++;\n    }\n    *returnSize=n;\n    return res;\n}", "prefix": "int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize"}
{"id": "1464", "path": "output2\\c\\Medium\\1464-stone-game-ix.c", "hypo_code": "bool stoneGameIX(int* stones, int stonesSize){\nint arr[3]={0};\n    int i;\n    for(i=0;i<stonesSize;i++){\n        arr[stones[i]%3]++;\n    }\n    if(arr[0]%2==0){\n        if(arr[1]==0){\n            return false;\n        }\n        else if(arr[2]==0){\n            if(arr[1]%3==0){\n                return false;\n            }\n        }\n    }\n    else{\n        if(arr[1]==0){\n            if(arr[2]%3==0){\n                return false;\n            }\n        }\n        else if(arr[2]==0){\n            if(arr[1]%3==0){\n                return false;\n            }\n        }\n    }\n    return true;\n}", "prefix": "bool stoneGameIX(int* stones, int stonesSize"}
{"id": "1465", "path": "output2\\c\\Medium\\1465-minimum-operations-to-make-a-uni-value-grid.c", "hypo_code": "int minOperations(int** grid, int gridSize, int* gridColSize, int x){\nint i,j;\n    int count=0;\n    int max=0;\n    int max_index=0;\n    int next_max=0;\n    int next_max_index=0;\n    for(i=0;i<gridSize;i++){\n        for(j=0;j<*gridColSize;j++){\n            if(grid[i][j]>max){\n                max=grid[i][j];\n                max_index=i;\n            }\n        }\n    }\n    if(max_index==0){\n        for(i=1;i<gridSize;i++){\n            for(j=0;j<*gridColSize;j++){\n                if(grid[i][j]>next_max){\n                    next_max=grid[i][j];\n                    next_max_index=i;\n                }\n            }\n        }\n        for(i=next_max_index;i<gridSize;i++){\n            for(j=0;j<*gridColSize;j++){\n                if(grid[i][j]!=next_max){\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    for(i=0;i<gridSize;i++){\n        for(j=0;j<*gridColSize;j++){\n            if(grid[i][j]>next_max&&grid[i][j]<max){\n                next_max=grid[i][j];\n                next_max_index=i;\n            }\n        }\n    }\n    for(i=next_max_index;i<gridSize;i++){\n        for(j=0;j<*gridColSize;j++){\n            if(grid[i][j]!=next_max){\n                count++;\n            }\n        }\n    }\n    return count;\n}", "prefix": "int minOperations(int** grid, int gridSize, int* gridColSize, int x"}
{"id": "1467", "path": "output2\\c\\Medium\\1467-remove-colored-pieces-if-both-neighbors-are-the-same-color.c", "hypo_code": "bool winnerOfGame(char * colors){\nint len=strlen(colors);\n    int i;\n    int countA=0;\n    int countB=0;\n    for(i=1;i<len-1;i++){\n        if(colors[i]=='A'&&colors[i-1]=='A'&&colors[i+1]=='A'){\n            countA++;\n        }else if(colors[i]=='B'&&colors[i-1]=='B'&&colors[i+1]=='B'){\n            countB++;\n        }\n    }\n    if(countA>countB){\n        return true;\n    }else{\n        return false;\n    }\n}", "prefix": "bool winnerOfGame(char * colors"}
{"id": "1468", "path": "output2\\c\\Medium\\1468-the-time-when-the-network-becomes-idle.c", "hypo_code": "int networkBecomesIdle(int** edges, int edgesSize, int* edgesColSize, int* patience, int patienceSize){\nint i;\n    int *arr=(int *)malloc(sizeof(int)*patienceSize);\n    int *arr2=(int *)malloc(sizeof(int)*patienceSize);\n    int *arr3=(int *)malloc(sizeof(int)*patienceSize);\n    for(i=0;i<patienceSize;i++){\n        arr[i]=i;\n        arr2[i]=i;\n        arr3[i]=0;\n    }\n    int max=0;\n    int max2=0;\n    for(i=0;i<edgesSize;i++){\n        if(max<edges[i][0]){\n            max=edges[i][0];\n        }\n        if(max<edges[i][1]){\n            max=edges[i][1];\n        }\n    }\n    int *arr4=(int *)malloc(sizeof(int)*(max+1));\n    int *arr5=(int *)malloc(sizeof(int)*(max+1));\n    for(i=0;i<max+1;i++){\n        arr4[i]=0;\n        arr5[i]=0;\n    }\n    for(i=0;i<edgesSize;i++){\n        arr4[edges[i][0]]++;\n        arr5[edges[i][1]]++;\n    }\n    int *arr6=(int *)malloc(sizeof(int)*(max+1));\n    int *arr7=(int *)malloc(sizeof(int)*(max+1));\n    for(i=0;i<max+1;i++){\n        arr6[i]=0;\n        arr7[i]=0;\n    }\n    for(i=0;i<edgesSize;i++){\n        arr6[edges[i][0]]++;\n        arr7[edges[i][1]]++;\n    }\n    int *arr8=(int *)malloc(sizeof(int)*(max+1));\n    for(i=0;i<max+1;i++){\n        arr8[i]=0;\n    }\n    int *arr9=(int *)malloc(sizeof(int)*(max+1));\n    for(i=0;i<max+1;i++){\n        arr9[i]=0;\n    }\n    int *arr10=(int *)malloc(sizeof(int)*(max+1));\n    for(i=0;i<max+1;i++){\n        arr10[i]=0;\n    }\n    int *arr11=(int *)malloc(sizeof(int)*(max+1));\n    for(i=0;i<max+1;i++){\n        arr11[i]=0;\n    }\n    int *arr12=(int *)malloc(sizeof(int)*(max+1));\n}", "prefix": "int networkBecomesIdle(int** edges, int edgesSize, int* edgesColSize, int* patience, int patienceSize"}
{"id": "1470", "path": "output2\\c\\Medium\\1470-count-number-of-maximum-bitwise-or-subsets.c", "hypo_code": "int countMaxOrSubsets(int* nums, int numsSize){\nint i,j;\n    int max=0;\n    int count=0;\n    int tmp;\n    for(i=0;i<numsSize;i++){\n        max|=nums[i];\n    }\n    for(i=0;i<numsSize;i++){\n        tmp=0;\n        for(j=0;j<numsSize;j++){\n            if(i!=j){\n                tmp|=nums[j];\n            }\n        }\n        if(tmp==max){\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int countMaxOrSubsets(int* nums, int numsSize"}
{"id": "1471", "path": "output2\\c\\Medium\\1471-next-greater-numerically-balanced-number.c", "hypo_code": "int nextBeautifulNumber(int n){\nint i,j;\n    int count[10]={0};\n    int tmp=n;\n    int len=0;\n    int *arr=(int *)malloc(sizeof(int)*7);\n    int index=0;\n    int flag=0;\n    while(tmp){\n        count[tmp%10]++;\n        tmp/=10;\n        len++;\n    }\n    for(i=0;i<10;i++){\n        if(count[i]!=0){\n            for(j=0;j<count[i];j++){\n                arr[index]=i;\n                index++;\n            }\n        }\n    }\n    for(i=n+1;i<=1000000;i++){\n        tmp=i;\n        while(tmp){\n            count[tmp%10]--;\n            tmp/=10;\n        }\n        flag=0;\n        for(j=0;j<10;j++){\n            if(count[j]!=0){\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0){\n            return i;\n        }\n        tmp=i;\n        while(tmp){\n            count[tmp%10]++;\n            tmp/=10;\n        }\n    }\n    return 0;\n}", "prefix": "int nextBeautifulNumber(int n"}
{"id": "1472", "path": "output2\\c\\Medium\\1472-count-nodes-with-the-highest-score.c", "hypo_code": "int countHighestScoreNodes(int* parents, int parentsSize){\nint i;\n    int count=0;\n    int max=0;\n    int tmp;\n    int *score=(int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        score[i]=1;\n    }\n    for(i=parentsSize-1;i>0;i--){\n        score[parents[i]]+=score[i];\n    }\n    for(i=0;i<parentsSize;i++){\n        if(score[i]>max){\n            max=score[i];\n        }\n    }\n    for(i=0;i<parentsSize;i++){\n        if(score[i]==max){\n            count++;\n        }\n    }\n    return count;\n}", "prefix": "int countHighestScoreNodes(int* parents, int parentsSize"}
{"id": "1473", "path": "output2\\c\\Medium\\1473-two-best-non-overlapping-events.c", "hypo_code": "int maxTwoEvents(int** events, int eventsSize, int* eventsColSize){\nint sum=0;\n    int max=0;\n    int i,j,k;\n    for(i=0;i<eventsSize;i++){\n        for(j=i+1;j<eventsSize;j++){\n            if(events[i][1]>events[j][0] && events[i][0]<events[j][1]){\n                continue;\n            }\n            sum=events[i][2]+events[j][2];\n            if(sum>max){\n                max=sum;\n            }\n        }\n    }\n    return max;\n}", "prefix": "int maxTwoEvents(int** events, int eventsSize, int* eventsColSize"}
{"id": "1474", "path": "output2\\c\\Medium\\1474-plates-between-candles.c", "hypo_code": "int* platesBetweenCandles(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nint* ret = malloc(sizeof(int)*queriesSize);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    for(i=0;i<queriesSize;i++){\n        left=queries[i][0];\n        right=queries[i][1];\n        count=0;\n        for(j=left;j<right;j++){\n            if(s[j]=='*'){\n                for(k=j+1;k<right;k++){\n                    if(s[k]=='|'){\n                        count++;\n                        break;\n                    }\n                }\n            }\n        }\n        ret[i]=count;\n    }\n    *returnSize=queriesSize;\n    return ret;\n\n}", "prefix": "int* platesBetweenCandles(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1475", "path": "output2\\c\\Medium\\1475-find-the-minimum-and-maximum-number-of-nodes-between-critical-points.c", "hypo_code": "int* nodesBetweenCriticalPoints(struct ListNode* head, int* returnSize){\nint* ret = malloc(sizeof(int)*2);\n    int min = 100001;\n    int max = 0;\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*100000);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    for(i=1;i<100000;i++){\n        if(arr[i-1]<arr[i] && arr[i]>arr[i+1]){\n            for(j=i-1;j>=0;j--){\n                if(arr[j]<arr[i]){\n                    break;\n                }\n            }\n            for(k=i+1;k<100000;k++){\n                if(arr[k]<arr[i]){\n                    break;\n                }\n            }\n            if(k-j-1<min){\n                min=k-j-1;\n            }\n            if(k-j-1>max){\n                max=k-j-1;\n            }\n        }\n    }\n    if(min==100001){\n        min=-1;\n    }\n    if(max==0){\n        max=-1;\n    }\n    ret[0]=min;\n    ret[1]=max;\n    *returnSize=2;\n    return ret;\n}", "prefix": "int* nodesBetweenCriticalPoints(struct ListNode* head, int* returnSize"}
{"id": "1476", "path": "output2\\c\\Medium\\1476-minimum-operations-to-convert-number.c", "hypo_code": "int minimumOperations(int* nums, int numsSize, int start, int goal){\nint* arr = malloc(sizeof(int)*2000);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n}", "prefix": "int minimumOperations(int* nums, int numsSize, int start, int goal"}
{"id": "1477", "path": "output2\\c\\Medium\\1477-vowels-of-all-substrings.c", "hypo_code": "long long countVowels(char * word){\nlong long sum=0;\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<strlen(word);i++){\n        if(word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u'){\n            sum++;\n        }\n    }\n    return sum;\n}", "prefix": "long long countVowels(char * word"}
{"id": "1478", "path": "output2\\c\\Medium\\1478-minimized-maximum-of-products-distributed-to-any-store.c", "hypo_code": "int minimizedMaximum(int n, int* quantities, int quantitiesSize){\nint* arr = malloc(sizeof(int)*100000);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n\n}", "prefix": "int minimizedMaximum(int n, int* quantities, int quantitiesSize"}
{"id": "1480", "path": "output2\\c\\Medium\\1480-most-beautiful-item-for-each-query.c", "hypo_code": "int* maximumBeauty(int** items, int itemsSize, int* itemsColSize, int* queries, int queriesSize, int* returnSize){\n    int* arr = malloc(queriesSize * sizeof(int));\n    int i, j, k, max;\n    for(i = 0; i < queriesSize; i++){\n        max = 0;\n        for(j = 0; j < itemsSize; j++){\n            if(items[j][0] <= queries[i]){\n                if(items[j][1] > max){\n                    max = items[j][1];\n                }\n            }\n        }\n        arr[i] = max;\n    }\n    *returnSize = queriesSize;\n    return arr;\n\n}", "prefix": "int* maximumBeauty(int** items, int itemsSize, int* itemsColSize, int* queries, int queriesSize, int* returnSize"}
{"id": "1481", "path": "output2\\c\\Medium\\1481-reverse-nodes-in-even-length-groups.c", "hypo_code": "struct ListNode* reverseEvenLengthGroups(struct ListNode* head){\n    struct ListNode* temp = head;\n    struct ListNode* prev = NULL;\n    struct ListNode* next = NULL;\n    int count = 0;\n    while(temp != NULL){\n        count++;\n        temp = temp->next;\n    }\n    if(count % 2 == 0){\n        temp = head;\n        while(temp != NULL){\n            next = temp->next;\n            temp->next = prev;\n            prev = temp;\n            temp = next;\n        }\n        head = prev;\n    }\n    return head;\n\n}", "prefix": "struct ListNode* reverseEvenLengthGroups(struct ListNode* head"}
{"id": "1482", "path": "output2\\c\\Medium\\1482-decode-the-slanted-ciphertext.c", "hypo_code": "char * decodeCiphertext(char * encodedText, int rows){\nint i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<strlen(encodedText);i++){\n        if(encodedText[i]=='a' || encodedText[i]=='e' || encodedText[i]=='i' || encodedText[i]=='o' || encodedText[i]=='u'){\n            sum++;\n        }\n    }\n    return ret;\n}", "prefix": "char * decodeCiphertext(char * encodedText, int rows"}
{"id": "1483", "path": "output2\\c\\Medium\\1483-watering-plants.c", "hypo_code": "int wateringPlants(int* plants, int plantsSize, int capacity){\nint* arr = malloc(sizeof(int)*2000);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n\n}", "prefix": "int wateringPlants(int* plants, int plantsSize, int capacity"}
{"id": "1485", "path": "output2\\c\\Medium\\1485-minimum-number-of-food-buckets-to-feed-the-hamsters.c", "hypo_code": "int minimumBuckets(char * hamsters){\n    int i;\n    int count = 0;\n    int hamster = 0;\n    for(i = 0; i < strlen(hamsters); i++){\n        if(hamsters[i] == 'H'){\n            hamster++;\n        }\n    }\n    for(i = 0; i < strlen(hamsters); i++){\n        if(hamsters[i] == 'H'){\n            if(i == 0){\n                if(hamsters[i + 1] == '.'){\n                    count++;\n                }\n            }\n            else if(i == strlen(hamsters) - 1){\n                if(hamsters[i - 1] == '.'){\n                    count++;\n                }\n            }\n            else{\n                if(hamsters[i - 1] == '.' && hamsters[i + 1] == '.'){\n                    count++;\n                }\n            }\n        }\n    }\n    if(count >= hamster){\n        return count;\n    }\n    else{\n        return -1;\n    }\n\n}", "prefix": "int minimumBuckets(char * hamsters"}
{"id": "1486", "path": "output2\\c\\Medium\\1486-minimum-cost-homecoming-of-a-robot-in-a-grid.c", "hypo_code": "int minCost(int* startPos, int startPosSize, int* homePos, int homePosSize, int* rowCosts, int rowCostsSize, int* colCosts, int colCostsSize){\n    int i, j, k, l;\n    int sum = 0;\n    int x = startPos[0];\n    int y = startPos[1];\n    int x1 = homePos[0];\n    int y1 = homePos[1];\n    int max = 0;\n    int index = 0;\n    int* arr = malloc(rowCostsSize * sizeof(int));\n    for(i = 0; i < rowCostsSize; i++){\n        arr[i] = rowCosts[i];\n    }\n    for(i = 0; i < colCostsSize; i++){\n        arr[i] = colCosts[i];\n    }\n    for(i = 0; i < rowCostsSize; i++){\n        for(j = 0; j < colCostsSize; j++){\n            if(arr[i] < arr[j]){\n                if(arr[j] - arr[i] > max){\n                    max = arr[j] - arr[i];\n                    index = i;\n                }\n            }\n        }\n    }\n    sum = sum - arr[index] + max;\n    return sum;\n\n}", "prefix": "int minCost(int* startPos, int startPosSize, int* homePos, int homePosSize, int* rowCosts, int rowCostsSize, int* colCosts, int colCostsSize"}
{"id": "1487", "path": "output2\\c\\Medium\\1487-k-radius-subarray-averages.c", "hypo_code": "int* getAverages(int* nums, int numsSize, int k, int* returnSize){\n    int* arr = malloc(numsSize * sizeof(int));\n    int i, j, sum, count;\n    for(i = 0; i < numsSize; i++){\n        sum = 0;\n        count = 0;\n        for(j = i - k; j <= i + k; j++){\n            if(j >= 0 && j < numsSize){\n                sum += nums[j];\n                count++;\n            }\n        }\n        if(count == 2 * k + 1){\n            arr[i] = sum / count;\n        }\n        else{\n            arr[i] = -1;\n        }\n    }\n    *returnSize = numsSize;\n    return arr;\n\n}", "prefix": "int* getAverages(int* nums, int numsSize, int k, int* returnSize"}
{"id": "1488", "path": "output2\\c\\Medium\\1488-removing-minimum-and-maximum-from-array.c", "hypo_code": "int minimumDeletions(int* nums, int numsSize){\n    int i, j;\n    int min = 100000;\n    int max = 0;\n    int count = 0;\n    for(i = 0; i < numsSize; i++){\n        if(nums[i] < min){\n            min = nums[i];\n        }\n        if(nums[i] > max){\n            max = nums[i];\n        }\n    }\n    for(i = 0; i < numsSize; i++){\n        if(nums[i] == min){\n            count++;\n        }\n        else{\n            break;\n        }\n    }\n    for(i = numsSize - 1; i >= 0; i--){\n        if(nums[i] == max){\n            count++;\n        }\n        else{\n            break;\n        }\n    }\n    return numsSize - count;\n\n}", "prefix": "int minimumDeletions(int* nums, int numsSize"}
{"id": "1489", "path": "output2\\c\\Medium\\1489-delete-the-middle-node-of-a-linked-list.c", "hypo_code": "struct ListNode* deleteMiddle(struct ListNode* head){\nstruct ListNode* node = head;\n    struct ListNode* prev = NULL;\n    struct ListNode* next = NULL;\n    int count = 0;\n    int i = 0;\n    while(node){\n        count++;\n        node=node->next;\n    }\n    node = head;\n    while(node){\n        if(i==count/2){\n            prev->next = node->next;\n            break;\n        }\n        prev = node;\n        node=node->next;\n        i++;\n    }\n    return head;\n\n}", "prefix": "struct ListNode* deleteMiddle(struct ListNode* head"}
{"id": "1490", "path": "output2\\c\\Medium\\1490-step-by-step-directions-from-a-binary-tree-node-to-another.c", "hypo_code": "char * getDirections(struct TreeNode* root, int startValue, int destValue){\nint* arr = malloc(sizeof(int)*1000);\n    char* ret = malloc(sizeof(char)*1000);\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int temp = 0;\n    int temp1 = 0;\n    int temp2 = 0;\n    int count = 0;\n    struct TreeNode* node = root;\n    while(node){\n        arr[i]=node->val;\n        i++;\n        if(node->val==startValue){\n            temp1=i;\n        }\n        if(node->val==destValue){\n            temp2=i;\n        }\n        node=node->left;\n    }\n    for(j=0;j<i;j++){\n        if(arr[j]==startValue){\n            temp=j;\n            break;\n        }\n    }\n    for(j=temp;j<i;j++){\n        if(arr[j]==destValue){\n            break;\n        }\n        if(arr[j]>arr[j+1]){\n            ret[k]='L';\n            k++;\n        }else{\n            ret[k]='R';\n            k++;\n        }\n    }\n    if(temp1<temp2){\n        count=temp2-temp1;\n    }else{\n        count=temp1-temp2;\n    }\n    for(j=0;j<count;j++){\n        ret[k]='U';\n        k++;\n    }\n    ret[k]='\\0';\n    return ret;\n}", "prefix": "char * getDirections(struct TreeNode* root, int startValue, int destValue"}
{"id": "1491", "path": "output2\\c\\Medium\\1491-find-good-days-to-rob-the-bank.c", "hypo_code": "int* goodDaysToRobBank(int* security, int securitySize, int time, int* returnSize){\nint* ret = malloc(sizeof(int)*securitySize);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*securitySize);\n    i=0;\n    while(i<securitySize){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<securitySize){\n        arr[i++]=security[i];\n    }\n    i=0;\n    while(i<securitySize){\n        left=i-time;\n        right=i+time;\n        if(left<0){\n            left=0;\n        }\n        if(right>=securitySize){\n            right=securitySize-1;\n        }\n        prev=arr[left];\n        next=arr[right];\n        if(prev>=security[i] && next>=security[i]){\n            ret[i]=1;\n        }else{\n            ret[i]=0;\n        }\n        i++;\n    }\n    *returnSize=securitySize;\n    return ret;\n}", "prefix": "int* goodDaysToRobBank(int* security, int securitySize, int time, int* returnSize"}
{"id": "1492", "path": "output2\\c\\Medium\\1492-detonate-the-maximum-bombs.c", "hypo_code": "int maximumDetonation(int** bombs, int bombsSize, int* bombsColSize){\nint max=0;\n    int i,j,k;\n    int x,y,r;\n    int count=0;\n    for(i=0;i<bombsSize;i++){\n        x=bombs[i][0];\n        y=bombs[i][1];\n        r=bombs[i][2];\n        count=0;\n        for(j=0;j<bombsSize;j++){\n            if(i==j){\n                continue;\n            }\n            if((bombs[j][0]-x)*(bombs[j][0]-x)+(bombs[j][1]-y)*(bombs[j][1]-y)<=r*r){\n                count++;\n            }\n        }\n        if(count>max){\n            max=count;\n        }\n    }\n    return max;\n}", "prefix": "int maximumDetonation(int** bombs, int bombsSize, int* bombsColSize"}
{"id": "1493", "path": "output2\\c\\Medium\\1493-sum-of-subarray-ranges.c", "hypo_code": "long long subArrayRanges(int* nums, int numsSize){\nlong long sum=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<numsSize;i++){\n        sum+=nums[i];\n    }\n    return sum;\n}", "prefix": "long long subArrayRanges(int* nums, int numsSize"}
{"id": "1494", "path": "output2\\c\\Medium\\1494-watering-plants-ii.c", "hypo_code": "int minimumRefill(int* plants, int plantsSize, int capacityA, int capacityB){\nint* arr = malloc(sizeof(int)*2000);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n}", "prefix": "int minimumRefill(int* plants, int plantsSize, int capacityA, int capacityB"}
{"id": "1495", "path": "output2\\c\\Medium\\1495-adding-spaces-to-a-string.c", "hypo_code": "char * addSpaces(char * s, int* spaces, int spacesSize){\nint i;\n    int j;\n    int k;\n    int len = strlen(s);\n    char* ret = malloc(sizeof(char)*(len+spacesSize));\n    for(i=0,j=0,k=0;i<len;i++){\n        if(i==spaces[j]){\n            ret[k]=' ';\n            k++;\n            j++;\n        }\n        ret[k]=s[i];\n        k++;\n    }\n    ret[k]='\\0';\n    return ret;\n}", "prefix": "char * addSpaces(char * s, int* spaces, int spacesSize"}
{"id": "1496", "path": "output2\\c\\Medium\\1496-number-of-smooth-descent-periods-of-a-stock.c", "hypo_code": "long long getDescentPeriods(int* prices, int pricesSize){\nlong long periods=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    for(i=0;i<pricesSize;i++){\n        count=0;\n        for(j=i+1;j<pricesSize;j++){\n            if(prices[j]==prices[j-1]-1){\n                count++;\n            }else{\n                break;\n            }\n        }\n        periods+=count;\n    }\n    return periods;\n}", "prefix": "long long getDescentPeriods(int* prices, int pricesSize"}
{"id": "1497", "path": "output2\\c\\Medium\\1497-find-all-possible-recipes-from-given-supplies.c", "hypo_code": "char ** findAllRecipes(char ** recipes, int recipesSize, char *** ingredients, int ingredientsSize, int* ingredientsColSize, char ** supplies, int suppliesSize, int* returnSize){\n    char** arr = malloc(recipesSize * sizeof(char*));\n    int i, j, k, l;\n    int count = 0;\n    for(i = 0; i < recipesSize; i++){\n        arr[i] = malloc(100 * sizeof(char));\n    }\n    for(i = 0; i < recipesSize; i++){\n        for(j = 0; j < ingredientsSize; j++){\n            if(strcmp(recipes[i], ingredients[j][0]) == 0){\n                for(k = 1; k < ingredientsColSize[j]; k++){\n                    for(l = 0; l < suppliesSize; l++){\n                        if(strcmp(ingredients[j][k], supplies[l]) == 0){\n                            break;\n                        }\n                    }\n                    if(l == suppliesSize){\n                        break;\n                    }\n                }\n                if(k == ingredientsColSize[j]){\n                    strcpy(arr[count], recipes[i]);\n                    count++;\n                }\n            }\n        }\n    }\n    *returnSize = count;\n    return arr;\n\n}", "prefix": "char ** findAllRecipes(char ** recipes, int recipesSize, char *** ingredients, int ingredientsSize, int* ingredientsColSize, char ** supplies, int suppliesSize, int* returnSize"}
{"id": "1498", "path": "output2\\c\\Medium\\1498-check-if-a-parentheses-string-can-be-valid.c", "hypo_code": "bool canBeValid(char * s, char * locked){\n    int i;\n    int count = 0;\n    int lock = 0;\n    for(i = 0; i < strlen(s); i++){\n        if(locked[i] == '1'){\n            lock++;\n        }\n        if(s[i] == '('){\n            count++;\n        }\n        else{\n            count--;\n        }\n        if(count < 0){\n            return false;\n        }\n    }\n    if(count == 0){\n        return true;\n    }\n    else if(count == lock){\n        return true;\n    }\n    else{\n        return false;\n    }\n\n}", "prefix": "bool canBeValid(char * s, char * locked"}
{"id": "1499", "path": "output2\\c\\Medium\\1499-execution-of-all-suffix-instructions-staying-in-a-grid.c", "hypo_code": "int* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\n    int* arr = malloc(strlen(s) * sizeof(int));\n    int i, j, k, l;\n    int count = 0;\n    int x = startPos[0];\n    int y = startPos[1];\n    for(i = 0; i < strlen(s); i++){\n        if(s[i] == 'L'){\n            y--;\n        }\n        else if(s[i] == 'R'){\n            y++;\n        }\n        else if(s[i] == 'U'){\n            x--;\n        }\n        else if(s[i] == 'D'){\n            x++;\n        }\n        if(x < 0 || x >= n || y < 0 || y >= n){\n            break;\n        }\n        count++;\n    }\n    for(i = 0; i < strlen(s); i++){\n        arr[i] = count;\n    }\n    *returnSize = strlen(s);\n    return arr;\n\n\n}", "prefix": "int* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize"}
{"id": "1500", "path": "output2\\c\\Medium\\1500-intervals-between-identical-elements.c", "hypo_code": "long long* getDistances(int* arr, int arrSize, int* returnSize){\n    long long* arr1 = malloc(arrSize * sizeof(long long));\n    int i, j;\n    for(i = 0; i < arrSize; i++){\n        arr1[i] = 0;\n    }\n    for(i = 0; i < arrSize; i++){\n        for(j = i + 1; j < arrSize; j++){\n            if(arr[i] == arr[j]){\n                arr1[i] += j - i;\n                arr1[j] += j - i;\n            }\n        }\n    }\n    *returnSize = arrSize;\n    return arr1;\n\n}", "prefix": "long long* getDistances(int* arr, int arrSize, int* returnSize"}
{"id": "1501", "path": "output2\\c\\Medium\\1501-number-of-laser-beams-in-a-bank.c", "hypo_code": "int numberOfBeams(char ** bank, int bankSize){\n    int i, j, k, l;\n    int count = 0;\n    int flag = 0;\n    for(i = 0; i < bankSize; i++){\n        for(j = 0; j < strlen(bank[i]); j++){\n            if(bank[i][j] == '1'){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 1){\n            break;\n        }\n    }\n    for(i = i + 1; i < bankSize; i++){\n        for(j = 0; j < strlen(bank[i]); j++){\n            if(bank[i][j] == '1'){\n                flag = 0;\n                for(k = i - 1; k > j; k--){\n                    if(bank[k][j] == '1'){\n                        flag = 1;\n                        break;\n                    }\n                }\n                if(flag == 0){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int numberOfBeams(char ** bank, int bankSize"}
{"id": "1502", "path": "output2\\c\\Medium\\1502-destroying-asteroids.c", "hypo_code": "bool asteroidsDestroyed(int mass, int* asteroids, int asteroidsSize){\n    int i;\n    int count = 0;\n    for(i = 0; i < asteroidsSize; i++){\n        if(mass >= asteroids[i]){\n            count++;\n        }\n    }\n    if(count == asteroidsSize){\n        return true;\n    }\n    else{\n        return false;\n    }\n\n}", "prefix": "bool asteroidsDestroyed(int mass, int* asteroids, int asteroidsSize"}
{"id": "1503", "path": "output2\\c\\Medium\\1503-maximum-twin-sum-of-a-linked-list.c", "hypo_code": "int pairSum(struct ListNode* head){\nint max = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int count = 0;\n    int left = 0;\n    int right = 0;\n    int prev = 0;\n    int next = 0;\n    int* arr = malloc(sizeof(int)*100000);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    for(j=0;j<i/2;j++){\n        if(arr[j]+arr[i-1-j]>max){\n            max = arr[j]+arr[i-1-j];\n        }\n    }\n    return max;\n}", "prefix": "int pairSum(struct ListNode* head"}
{"id": "1504", "path": "output2\\c\\Medium\\1504-longest-palindrome-by-concatenating-two-letter-words.c", "hypo_code": "int longestPalindrome(char ** words, int wordsSize){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int len;\n    int max=0;\n    for(i=0;i<wordsSize;i++){\n        count=0;\n        len=strlen(words[i]);\n        for(j=0;j<len;j++){\n            for(k=0;k<len;k++){\n                if(j!=k){\n                    if(words[i][j]==words[i][k]){\n                        count++;\n                        break;\n                    }\n                }\n            }\n        }\n        if(count==len-1){\n            if(len>max){\n                max=len;\n            }\n        }\n    }\n    return max;\n}", "prefix": "int longestPalindrome(char ** words, int wordsSize"}
{"id": "1505", "path": "output2\\c\\Medium\\1505-minimum-swaps-to-group-all-1s-together-ii.c", "hypo_code": "int minSwaps(int* nums, int numsSize){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*100000);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    for(j=0;j<i/2;j++){\n        if(arr[j]+arr[i-1-j]>max){\n            max = arr[j]+arr[i-1-j];\n        }\n    }\n    return max;\n}", "prefix": "int minSwaps(int* nums, int numsSize"}
{"id": "1506", "path": "output2\\c\\Medium\\1506-count-words-obtained-after-adding-a-letter.c", "hypo_code": "int wordCount(char ** startWords, int startWordsSize, char ** targetWords, int targetWordsSize){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int len;\n    int max=0;\n    for(i=0;i<wordsSize;i++){\n        count=0;\n        len=strlen(words[i]);\n        for(j=0;j<len;j++){\n            for(k=0;k<len;k++){\n                if(j!=k){\n                    if(words[i][j]==words[i][k]){\n                        count++;\n                        break;\n                    }\n                }\n            }\n        }\n        if(count==len-1){\n            if(len>max){\n                max=len;\n            }\n        }\n    }\n    return max;\n}", "prefix": "int wordCount(char ** startWords, int startWordsSize, char ** targetWords, int targetWordsSize"}
{"id": "1507", "path": "output2\\c\\Medium\\1507-minimum-moves-to-reach-target-score.c", "hypo_code": "int minMoves(int target, int maxDoubles){\nint i;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n}", "prefix": "int minMoves(int target, int maxDoubles"}
{"id": "1508", "path": "output2\\c\\Medium\\1508-solving-questions-with-brainpower.c", "hypo_code": "long long mostPoints(int** questions, int questionsSize, int* questionsColSize){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    for(i=0;i<questionsSize;i++){\n        count=0;\n        for(j=i+1;j<questionsSize;j++){\n            if(questions[j][1]==questions[j-1][0]-1){\n                count++;\n            }else{\n                break;\n            }\n        }\n        points+=count;\n    }\n    return points;\n}", "prefix": "long long mostPoints(int** questions, int questionsSize, int* questionsColSize"}
{"id": "1509", "path": "output2\\c\\Medium\\1509-count-the-hidden-sequences.c", "hypo_code": "int numberOfArrays(int* differences, int differencesSize, int lower, int upper){\nint hidden=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<differencesSize;i++){\n        count=0;\n        for(j=i+1;j<differencesSize;j++){\n            if(differences[j]==differences[j-1]-1){\n                count++;\n            }else{\n                break;\n            }\n        }\n        hidden+=count;\n    }\n    return hidden;\n}", "prefix": "int numberOfArrays(int* differences, int differencesSize, int lower, int upper"}
{"id": "1510", "path": "output2\\c\\Medium\\1510-k-highest-ranked-items-within-a-price-range.c", "hypo_code": "int** highestRankedKItems(int** grid, int gridSize, int* gridColSize, int* pricing, int pricingSize, int* start, int startSize, int k, int* returnSize, int** returnColumnSizes){\nint** ret = malloc(sizeof(int*)*k);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*gridSize*gridSize);\n    i=0;\n    while(i<gridSize*gridSize){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<gridSize){\n        j=0;\n        while(j<gridSize){\n            arr[i*gridSize+j]=grid[i][j];\n            j++;\n        }\n        i++;\n    }\n    i=0;\n    while(i<gridSize*gridSize){\n        left=i-time;\n        right=i+time;\n        if(left<0){\n            left=0;\n        }\n        if(right>=gridSize*gridSize){\n            right=gridSize*gridSize-1;\n        }\n        prev=arr[left];\n        next=arr[right];\n        if(prev>=grid[i] && next>=grid[i]){\n            ret[i]=1;\n        }else{\n            ret[i]=0;\n        }\n        i++;\n    }\n    *returnSize=gridSize*gridSize;\n    return ret;\n}", "prefix": "int** highestRankedKItems(int** grid, int gridSize, int* gridColSize, int* pricing, int pricingSize, int* start, int startSize, int k, int* returnSize, int** returnColumnSizes"}
{"id": "1511", "path": "output2\\c\\Medium\\1511-rearrange-array-elements-by-sign.c", "hypo_code": "int* rearrangeArray(int* nums, int numsSize, int* returnSize){\nint* ret = malloc(sizeof(int)*numsSize);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    *returnSize=numsSize;\n    return ret;\n}", "prefix": "int* rearrangeArray(int* nums, int numsSize, int* returnSize"}
{"id": "1512", "path": "output2\\c\\Medium\\1512-find-all-lonely-numbers-in-the-array.c", "hypo_code": "int* findLonely(int* nums, int numsSize, int* returnSize){\nint* ret = malloc(sizeof(int)*numsSize);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    for(i=0;i<numsSize;i++){\n        count=0;\n        for(j=0;j<numsSize;j++){\n            if(nums[i]==nums[j]){\n                count++;\n            }\n        }\n        if(count==1){\n            ret[i]=nums[i];\n        }else{\n            ret[i]=0;\n        }\n    }\n    *returnSize=numsSize;\n    return ret;\n}", "prefix": "int* findLonely(int* nums, int numsSize, int* returnSize"}
{"id": "1513", "path": "output2\\c\\Medium\\1513-all-divisions-with-the-highest-score-of-a-binary-array.c", "hypo_code": "int* maxScoreIndices(int* nums, int numsSize, int* returnSize){\nint* ret = malloc(sizeof(int)*numsSize);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*numsSize);\n    i=0;\n    while(i<numsSize){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<numsSize){\n        arr[i++]=nums[i];\n    }\n    i=0;\n    while(i<numsSize){\n        left=i-1;\n        right=i+1;\n        if(left<0){\n            left=0;\n        }\n        if(right>=numsSize){\n            right=numsSize-1;\n        }\n        prev=nums[left];\n        next=nums[right];\n        if(prev==1 && next==1){\n            arr[i]=0;\n        }\n        i++;\n    }\n    i=0;\n    while(i<numsSize){\n        count=0;\n        for(j=0;j<numsSize;j++){\n            if(arr[i]==arr[j]){\n                count++;\n            }\n        }\n        if(count==1){\n            ret[i]=i;\n        }else{\n            ret[i]=0;\n        }\n        i++;\n    }\n    *returnSize=numsSize;\n    return ret;\n}", "prefix": "int* maxScoreIndices(int* nums, int numsSize, int* returnSize"}
{"id": "1514", "path": "output2\\c\\Medium\\1514-partition-array-according-to-given-pivot.c", "hypo_code": "int* pivotArray(int* nums, int numsSize, int pivot, int* returnSize){\n    int* arr = malloc(numsSize * sizeof(int));\n    int i, j, k, l;\n    for(i = 0; i < numsSize; i++){\n        arr[i] = nums[i];\n    }\n    for(i = 0; i < numsSize; i++){\n        for(j = i + 1; j < numsSize; j++){\n            if(arr[i] > arr[j]){\n                k = arr[i];\n                arr[i] = arr[j];\n                arr[j] = k;\n            }\n        }\n    }\n    for(i = 0; i < numsSize; i++){\n        if(arr[i] == pivot){\n            break;\n        }\n    }\n    for(j = i + 1; j < numsSize; j++){\n        if(arr[j] > pivot){\n            break;\n        }\n    }\n    for(k = j + 1; k < numsSize; k++){\n        if(arr[k] == pivot){\n            break;\n        }\n    }\n    for(l = k + 1; l < numsSize; l++){\n        if(arr[l] < pivot){\n            break;\n        }\n    }\n    *returnSize = numsSize;\n    return arr;\n\n}", "prefix": "int* pivotArray(int* nums, int numsSize, int pivot, int* returnSize"}
{"id": "1515", "path": "output2\\c\\Medium\\1515-minimum-cost-to-set-cooking-time.c", "hypo_code": "int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds){\n    int i;\n    int sum = 0;\n    int arr[4] = {0};\n    int count = 0;\n    int mod = 1000000007;\n    int min = 0;\n    int index = 0;\n    int* arr1 = malloc(4 * sizeof(int));\n    while(targetSeconds > 0){\n        arr[count] = targetSeconds % 10;\n        targetSeconds = targetSeconds / 10;\n        count++;\n    }\n    for(i = 0; i < count; i++){\n        arr1[i] = arr[i];\n    }\n    for(i = 0; i < count; i++){\n        if(arr[i] < arr1[i]){\n            if(arr1[i] - arr[i] > min){\n                min = arr1[i] - arr[i];\n                index = i;\n            }\n        }\n    }\n    sum = sum - arr1[index] + min;\n    return sum;\n\n}", "prefix": "int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds"}
{"id": "1516", "path": "output2\\c\\Medium\\1516-smallest-value-of-the-rearranged-number.c", "hypo_code": "long long smallestNumber(long long num){\n    int i, j;\n    int count = 0;\n    int mod = 1000000007;\n    int arr[10] = {0};\n    while(num > 0){\n        arr[count] = num % 10;\n        num = num / 10;\n        count++;\n    }\n    for(i = 0; i < count; i++){\n        for(j = i + 1; j < count; j++){\n            if(arr[i] > arr[j]){\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    long long sum = 0;\n    for(i = 0; i < count; i++){\n        sum = (sum * 10 + arr[i]) % mod;\n    }\n    return sum;\n\n}", "prefix": "long long smallestNumber(long long num"}
{"id": "1518", "path": "output2\\c\\Medium\\1518-minimum-operations-to-make-the-array-alternating.c", "hypo_code": "int minimumOperations(int* nums, int numsSize){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n}", "prefix": "int minimumOperations(int* nums, int numsSize"}
{"id": "1519", "path": "output2\\c\\Medium\\1519-removing-minimum-number-of-magic-beans.c", "hypo_code": "long long minimumRemoval(int* beans, int beansSize){\nlong long removal=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<beansSize;i++){\n        removal+=beans[i];\n    }\n    return removal;\n}", "prefix": "long long minimumRemoval(int* beans, int beansSize"}
{"id": "1520", "path": "output2\\c\\Medium\\1520-find-three-consecutive-integers-that-sum-to-a-given-number.c", "hypo_code": "long long* sumOfThree(long long num, int* returnSize){\nlong long* ret = malloc(sizeof(long long)*3);\n    long long i;\n    long long j;\n    long long k;\n    long long count;\n    long long left;\n    long long right;\n    long long prev;\n    long long next;\n    long long* arr = malloc(sizeof(long long)*100000);\n    i=0;\n    while(i<100000){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<100000){\n        arr[i++]=i;\n    }\n    i=0;\n    while(i<100000){\n        left=i-1;\n        right=i+1;\n        if(left<0){\n            left=0;\n        }\n        if(right>100000){\n            right=100000;\n        }\n        prev=arr[left];\n        next=arr[right];\n        if(prev+arr[i]+next==num){\n            ret[0]=prev;\n            ret[1]=arr[i];\n            ret[2]=next;\n            break;\n        }\n        i++;\n    }\n    *returnSize=3;\n    return ret;\n}", "prefix": "long long* sumOfThree(long long num, int* returnSize"}
{"id": "1521", "path": "output2\\c\\Medium\\1521-maximum-split-of-positive-even-integers.c", "hypo_code": "long long* maximumEvenSplit(long long finalSum, int* returnSize){\nlong long* ret = malloc(sizeof(long long)*finalSum);\n    long long i;\n    long long j;\n    long long k;\n    long long count;\n    long long left;\n    long long right;\n    long long prev;\n    long long next;\n    long long* arr = malloc(sizeof(long long)*finalSum);\n    i=0;\n    while(i<finalSum){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<finalSum){\n        arr[i++]=finalSum;\n    }\n    i=0;\n    while(i<finalSum){\n        left=i-time;\n        right=i+time;\n        if(left<0){\n            left=0;\n        }\n        if(right>finalSum){\n            right=finalSum;\n        }\n        count=0;\n        for(j=left;j<=right;j++){\n            if(arr[j]==1){\n                count++;\n            }\n        }\n        if(count==time*2+1){\n            for(j=left;j<=right;j++){\n                arr[j]=0;\n            }\n        }\n        i++;\n    }\n    i=0;\n    count=0;\n    while(i<finalSum){\n        if(arr[i]>0){\n            count++;\n        }\n        i++;\n    }\n    *returnSize=count;\n    i=0;\n    count=0;\n    while(i<finalSum){\n        if(arr[i]>0){\n            ret[count++]=arr[i];\n        }\n        i++;\n    }\n    return ret;\n}", "prefix": "long long* maximumEvenSplit(long long finalSum, int* returnSize"}
{"id": "1522", "path": "output2\\c\\Medium\\1522-merge-nodes-in-between-zeros.c", "hypo_code": "struct ListNode* mergeNodes(struct ListNode* head){\nstruct ListNode* node = head;\n    struct ListNode* prev = NULL;\n    struct ListNode* next = NULL;\n    int count = 0;\n    int i = 0;\n    int sum = 0;\n    while(node){\n        if(node->val==0){\n            count++;\n        }\n        node=node->next;\n    }\n    node = head;\n    while(node){\n        if(node->val==0){\n            if(i==0){\n                prev = node;\n            }\n            if(i==count-1){\n                prev->next = node->next;\n                break;\n            }\n            if(i==count-2){\n                next = node->next;\n                sum += next->val;\n                node->val = sum;\n                node->next = next->next;\n                break;\n            }\n            next = node->next;\n            sum += next->val;\n            node->next = next->next;\n            i++;\n            continue;\n        }\n        if(i==count-1){\n            node->val += sum;\n            break;\n        }\n        if(i==count-2){\n            sum = node->val;\n            i++;\n            continue;\n        }\n        i++;\n        node=node->next;\n    }\n    return head;\n}", "prefix": "struct ListNode* mergeNodes(struct ListNode* head"}
{"id": "1523", "path": "output2\\c\\Medium\\1523-construct-string-with-repeat-limit.c", "hypo_code": "char * repeatLimitedString(char * s, int repeatLimit){\nint i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    char* ret = malloc(sizeof(char)*(strlen(s)+1));\n    for(i=0,j=0,k=0;i<strlen(s);i++){\n        if(s[i]==s[i-1]){\n            count++;\n        }else{\n            count=1;\n        }\n        if(count<=repeatLimit){\n            ret[k]=s[i];\n            k++;\n        }\n    }\n    ret[k]='\\0';\n    return ret;\n}", "prefix": "char * repeatLimitedString(char * s, int repeatLimit"}
{"id": "1524", "path": "output2\\c\\Medium\\1524-minimum-number-of-steps-to-make-two-strings-anagram-ii.c", "hypo_code": "int minSteps(char * s, char * t){\nint i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int len = strlen(s);\n    int* scount = malloc(sizeof(int)*26);\n    int* tcount = malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        scount[i]=0;\n        tcount[i]=0;\n    }\n    for(i=0;i<strlen(s);i++){\n        scount[s[i]-'a']++;\n        tcount[t[i]-'a']++;\n    }\n    for(i=0;i<26;i++){\n        if(scount[i]>tcount[i]){\n            count+=scount[i]-tcount[i];\n        }\n    }\n    return count;\n\n}", "prefix": "int minSteps(char * s, char * t"}
{"id": "1525", "path": "output2\\c\\Medium\\1525-minimum-time-to-complete-trips.c", "hypo_code": "long long minimumTime(int* time, int timeSize, int totalTrips){\nlong long min=0;\n    int i,j,k;\n    int left;\n    int right;\n    int count;\n    int* arr = malloc(sizeof(int)*timeSize);\n    i=0;\n    while(i<timeSize){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<timeSize){\n        arr[i++]=time[i];\n    }\n    i=0;\n    while(i<timeSize){\n        left=i-totalTrips;\n        right=i+totalTrips;\n        if(left<0){\n            left=0;\n        }\n        if(right>timeSize){\n            right=timeSize;\n        }\n        count=0;\n        for(j=left;j<=right;j++){\n            if(arr[j]<arr[i]){\n                count++;\n            }\n        }\n        if(count<totalTrips){\n            continue;\n        }\n        min+=arr[i];\n    }\n    return min;\n}", "prefix": "long long minimumTime(int* time, int timeSize, int totalTrips"}
{"id": "1526", "path": "output2\\c\\Medium\\1526-sort-the-jumbled-numbers.c", "hypo_code": "int* sortJumbled(int* mapping, int mappingSize, int* nums, int numsSize, int* returnSize){\nint* ret = malloc(sizeof(int)*numsSize);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*numsSize);\n    i=0;\n    while(i<numsSize){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<numsSize){\n        arr[i++]=nums[i];\n    }\n    i=0;\n    while(i<numsSize){\n        left=i-time;\n        right=i+time;\n        if(left<0){\n            left=0;\n        }\n        if(right>securitySize){\n            right=securitySize;\n        }\n        prev=arr[left];\n        next=arr[right];\n        if(arr[i]>prev && arr[i]>next){\n            ret[i]=1;\n        }else{\n            ret[i]=0;\n        }\n        i++;\n    }\n    *returnSize=numsSize;\n    return ret;\n}", "prefix": "int* sortJumbled(int* mapping, int mappingSize, int* nums, int numsSize, int* returnSize"}
{"id": "1527", "path": "output2\\c\\Medium\\1527-all-ancestors-of-a-node-in-a-directed-acyclic-graph.c", "hypo_code": "int** getAncestors(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes){\nint** ret = malloc(sizeof(int*)*n);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int* arr = malloc(sizeof(int)*n);\n    int* visited = malloc(sizeof(int)*n);\n    int* ancestor = malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i]=0;\n        visited[i]=0;\n        ancestor[i]=0;\n    }\n    for(i=0;i<edgesSize;i++){\n        left=edges[i][0];\n        right=edges[i][1];\n        arr[right]=left;\n    }\n    for(i=0;i<n;i++){\n        left=i;\n        count=0;\n        while(left!=0){\n            left=arr[left];\n            count++;\n        }\n        ancestor[i]=count;\n    }\n    for(i=0;i<n;i++){\n        ret[i]=malloc(sizeof(int)*ancestor[i]);\n        left=i;\n        count=0;\n        while(left!=0){\n            ret[i][count]=left;\n            visited[left]=1;\n            left=arr[left];\n            count++;\n        }\n    }\n    *returnSize=n;\n    *returnColumnSizes=ancestor;\n    return ret;\n\n=======\nSuggestion 2\n\nint** ret = malloc(sizeof(int*)*n);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int* arr = malloc(sizeof(int)*n*n);\n    for(i=0;i<n*n;i++){\n        arr[i]=0;\n    }\n    for(i=0;i<edgesSize;i++){\n        arr[edges[i][1]*n+edges[i][0]]=1;\n    }\n    for(i=0;i<n;i++){\n        count=0;\n        for(j=0;j<n;j++){\n            if(arr[i*n+j]==1){\n                count++;\n            }\n        }\n        ret[i]=malloc(sizeof(int)*count);\n        count=0;\n        for(j=0;j<n;j++){\n            if(arr[i*n+j]==1){\n                ret[i][count++]=j;\n            }\n        }\n        (*returnColumnSizes)[i]=count;\n    }\n    *returnSize=n;\n    return ret;\n\n}", "prefix": "int** getAncestors(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1528", "path": "output2\\c\\Medium\\1528-append-k-integers-with-minimal-sum.c", "hypo_code": "long long minimalKSum(int* nums, int numsSize, int k){\nlong long sum=0;\n    int i,j;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<numsSize;i++){\n        sum+=nums[i];\n    }\n    return sum;\n}", "prefix": "long long minimalKSum(int* nums, int numsSize, int k"}
{"id": "1529", "path": "output2\\c\\Medium\\1529-create-binary-tree-from-descriptions.c", "hypo_code": "struct TreeNode* createBinaryTree(int** descriptions, int descriptionsSize, int* descriptionsColSize){\nint i,j,k;\n    struct TreeNode* root = malloc(sizeof(struct TreeNode));\n    struct TreeNode* node = root;\n    struct TreeNode* temp = NULL;\n    root->val=descriptions[0][0];\n    root->left=NULL;\n    root->right=NULL;\n    for(i=0;i<descriptionsSize;i++){\n        node=root;\n        for(j=0;j<descriptionsColSize[i];j++){\n            if(descriptions[i][j]==node->val){\n                continue;\n            }\n            if(descriptions[i][j]<node->val){\n                if(node->left==NULL){\n                    temp=malloc(sizeof(struct TreeNode));\n                    temp->val=descriptions[i][j];\n                    temp->left=NULL;\n                    temp->right=NULL;\n                    node->left=temp;\n                }\n                node=node->left;\n            }else{\n                if(node->right==NULL){\n                    temp=malloc(sizeof(struct TreeNode));\n                    temp->val=descriptions[i][j];\n                    temp->left=NULL;\n                    temp->right=NULL;\n                    node->right=temp;\n                }\n                node=node->right;\n            }\n        }\n    }\n    return root;\n}", "prefix": "struct TreeNode* createBinaryTree(int** descriptions, int descriptionsSize, int* descriptionsColSize"}
{"id": "1530", "path": "output2\\c\\Medium\\1530-count-artifacts-that-can-be-extracted.c", "hypo_code": "int digArtifacts(int n, int** artifacts, int artifactsSize, int* artifactsColSize, int** dig, int digSize, int* digColSize){\n    int i, j, k, l;\n    int count = 0;\n    int x, y;\n    int flag = 0;\n    for(i = 0; i < digSize; i++){\n        x = dig[i][0];\n        y = dig[i][1];\n        for(j = 0; j < artifactsSize; j++){\n            if(x >= artifacts[j][0] && x <= artifacts[j][2] && y >= artifacts[j][1] && y <= artifacts[j][3]){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 1){\n            for(k = 0; k < artifactsSize; k++){\n                if(x >= artifacts[k][0] && x <= artifacts[k][2] && y >= artifacts[k][1] && y <= artifacts[k][3]){\n                    artifacts[k][0] = -1;\n                    artifacts[k][1] = -1;\n                    artifacts[k][2] = -1;\n                    artifacts[k][3] = -1;\n                }\n            }\n            flag = 0;\n        }\n    }\n    for(i = 0; i < artifactsSize; i++){\n        if(artifacts[i][0] == -1 && artifacts[i][1] == -1 && artifacts[i][2] == -1 && artifacts[i][3] == -1){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int digArtifacts(int n, int** artifacts, int artifactsSize, int* artifactsColSize, int** dig, int digSize, int* digColSize"}
{"id": "1531", "path": "output2\\c\\Medium\\1531-maximize-the-topmost-element-after-k-moves.c", "hypo_code": "int maximumTop(int* nums, int numsSize, int k){\n    int i, j;\n    int max = 0;\n    int arr[100000] = {0};\n    for(i = 0; i < numsSize; i++){\n        arr[nums[i]]++;\n    }\n    for(i = 0; i < k; i++){\n        for(j = 0; j < 100000; j++){\n            if(arr[j] > 0){\n                arr[j]--;\n                arr[j + 1]++;\n                break;\n            }\n        }\n    }\n    for(i = 0; i < 100000; i++){\n        if(arr[i] > 0){\n            max = i;\n        }\n    }\n    return max;\n\n}", "prefix": "int maximumTop(int* nums, int numsSize, int k"}
{"id": "1532", "path": "output2\\c\\Medium\\1532-maximize-number-of-subsequences-in-a-string.c", "hypo_code": "long long maximumSubsequenceCount(char * text, char * pattern){\n    long long i, j;\n    long long count = 0;\n    long long arr[100000] = {0};\n    for(i = 0; i < strlen(text); i++){\n        if(text[i] == pattern[0]){\n            arr[i]++;\n        }\n    }\n    for(i = 0; i < strlen(text); i++){\n        if(text[i] == pattern[1]){\n            for(j = 0; j < i; j++){\n                arr[i] += arr[j];\n            }\n        }\n    }\n    for(i = 0; i < strlen(text); i++){\n        count += arr[i];\n    }\n    return count;\n\n}", "prefix": "long long maximumSubsequenceCount(char * text, char * pattern"}
{"id": "1533", "path": "output2\\c\\Medium\\1533-minimum-operations-to-halve-array-sum.c", "hypo_code": "int halveArray(int* nums, int numsSize){\n    int i, j;\n    int sum = 0;\n    int count = 0;\n    for(i = 0; i < numsSize; i++){\n        sum += nums[i];\n    }\n    for(i = 0; i < numsSize; i++){\n        sum -= nums[i];\n        count++;\n        if(sum < numsSize){\n            break;\n        }\n    }\n    return count;\n\n\n}", "prefix": "int halveArray(int* nums, int numsSize"}
{"id": "1534", "path": "output2\\c\\Medium\\1534-count-collisions-on-a-road.c", "hypo_code": "int countCollisions(char * directions){\n    int i;\n    int count = 0;\n    int left = 0;\n    int right = 0;\n    for(i = 0; i < strlen(directions); i++){\n        if(directions[i] == 'L'){\n            left++;\n        }\n        else if(directions[i] == 'R'){\n            right++;\n        }\n    }\n    if(left > right){\n        count = right * 2;\n    }\n    else{\n        count = left * 2;\n    }\n    return count;\n\n}", "prefix": "int countCollisions(char * directions"}
{"id": "1535", "path": "output2\\c\\Medium\\1535-maximum-points-in-an-archery-competition.c", "hypo_code": "int* maximumBobPoints(int numArrows, int* aliceArrows, int aliceArrowsSize, int* returnSize){\n    int* arr = malloc(aliceArrowsSize * sizeof(int));\n    int i, j, k, max, sum;\n    for(i = 0; i < aliceArrowsSize; i++){\n        arr[i] = 0;\n    }\n    for(i = 0; i < numArrows; i++){\n        max = 0;\n        for(j = 0; j < aliceArrowsSize; j++){\n            if(aliceArrows[j] > max){\n                max = aliceArrows[j];\n                k = j;\n            }\n        }\n        aliceArrows[k] = 0;\n        arr[k]++;\n    }\n    *returnSize = aliceArrowsSize;\n    return arr;\n\n}", "prefix": "int* maximumBobPoints(int numArrows, int* aliceArrows, int aliceArrowsSize, int* returnSize"}
{"id": "1536", "path": "output2\\c\\Medium\\1536-minimum-deletions-to-make-array-beautiful.c", "hypo_code": "int minDeletion(int* nums, int numsSize){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    for(i=0;i<numsSize;i++){\n        count=0;\n        for(j=i+1;j<numsSize;j++){\n            if(nums[j]==nums[j-1]){\n                count++;\n            }else{\n                break;\n            }\n        }\n        periods+=count;\n    }\n    return periods;\n}", "prefix": "int minDeletion(int* nums, int numsSize"}
{"id": "1537", "path": "output2\\c\\Medium\\1537-find-palindrome-with-fixed-length.c", "hypo_code": "long long* kthPalindrome(int* queries, int queriesSize, int intLength, int* returnSize){\nlong long* ret = malloc(sizeof(long long)*queriesSize);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*queriesSize);\n    i=0;\n    while(i<queriesSize){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<queriesSize){\n        arr[i++]=queries[i];\n    }\n    i=0;\n    while(i<queriesSize){\n        left=queries[i]-1;\n        right=queries[i]+1;\n        if(left<0){\n            left=0;\n        }\n        if(right>queriesSize-1){\n            right=queriesSize-1;\n        }\n        count=0;\n        for(j=left;j<=right;j++){\n            if(arr[j]>0){\n                count++;\n            }\n        }\n        ret[i]=count;\n        i++;\n    }\n    *returnSize=queriesSize;\n    return ret;\n}", "prefix": "long long* kthPalindrome(int* queries, int queriesSize, int intLength, int* returnSize"}
{"id": "1538", "path": "output2\\c\\Medium\\1538-find-triangular-sum-of-an-array.c", "hypo_code": "int triangularSum(int* nums, int numsSize){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<numsSize;i++){\n        sum+=nums[i];\n    }\n    return sum;\n}", "prefix": "int triangularSum(int* nums, int numsSize"}
{"id": "1539", "path": "output2\\c\\Medium\\1539-number-of-ways-to-select-buildings.c", "hypo_code": "long long numberOfWays(char * s){\nlong long ways=0;\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    for(i=0;i<strlen(s)-2;i++){\n        left=i;\n        right=i+2;\n        if(s[left]!=s[left+1] && s[left]!=s[right] && s[left+1]!=s[right]){\n            ways++;\n        }\n    }\n    return ways;\n}", "prefix": "long long numberOfWays(char * s"}
{"id": "1540", "path": "output2\\c\\Medium\\1540-find-players-with-zero-or-one-losses.c", "hypo_code": "int** findWinners(int** matches, int matchesSize, int* matchesColSize, int* returnSize, int** returnColumnSizes){\nint** ret = malloc(sizeof(int*)*2);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*105);\n    i=0;\n    while(i<105){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<matchesSize){\n        arr[matches[i][0]]++;\n        arr[matches[i][1]]++;\n        i++;\n    }\n    i=0;\n    while(i<matchesSize){\n        if(arr[i]==0){\n            arr[i]=-1;\n        }else if(arr[i]==1){\n            arr[i]=0;\n        }else{\n            arr[i]=1;\n        }\n        i++;\n    }\n    i=0;\n    while(i<matchesSize){\n        if(arr[i]==-1){\n            break;\n        }\n        i++;\n    }\n    count=i;\n    ret[0]=malloc(sizeof(int)*count);\n    i=0;\n    while(i<count){\n        ret[0][i]=i;\n        i++;\n    }\n    ret[1]=malloc(sizeof(int)*(matchesSize-count));\n    j=0;\n    while(i<matchesSize){\n        ret[1][j++]=i;\n        i++;\n    }\n    *returnSize=2;\n    *returnColumnSizes=malloc(sizeof(int)*2);\n    (*returnColumnSizes)[0]=count;\n    (*returnColumnSizes)[1]=matchesSize-count;\n    return ret;\n}", "prefix": "int** findWinners(int** matches, int matchesSize, int* matchesColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1541", "path": "output2\\c\\Medium\\1541-maximum-candies-allocated-to-k-children.c", "hypo_code": "int maximumCandies(int* candies, int candiesSize, long long k){\nint i;\n    long long sum=0;\n    for(i=0;i<candiesSize;i++){\n        sum+=candies[i];\n    }\n    return sum/k;\n}", "prefix": "int maximumCandies(int* candies, int candiesSize, long long k"}
{"id": "1542", "path": "output2\\c\\Medium\\1542-minimize-result-by-adding-parentheses-to-expression.c", "hypo_code": "char * minimizeResult(char * expression){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<strlen(expression);i++){\n        sum+=expression[i];\n    }\n    return expression;\n}", "prefix": "char * minimizeResult(char * expression"}
{"id": "1543", "path": "output2\\c\\Medium\\1543-maximum-product-after-k-increments.c", "hypo_code": "int maximumProduct(int* nums, int numsSize, int k){\nint sum=0;\n    int max=0;\n    int i,j;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<numsSize;i++){\n        sum+=nums[i];\n    }\n    return sum;\n}", "prefix": "int maximumProduct(int* nums, int numsSize, int k"}
{"id": "1544", "path": "output2\\c\\Medium\\1544-number-of-ways-to-buy-pens-and-pencils.c", "hypo_code": "long long waysToBuyPensPencils(int total, int cost1, int cost2){\nlong long ways=0;\n    int i,j,k;\n    int left;\n    int right;\n    for(i=0;i<=total;i++){\n        left=i;\n        right=total-i;\n        if(left%cost1==0 && right%cost2==0){\n            ways++;\n        }\n    }\n    return ways;\n}", "prefix": "long long waysToBuyPensPencils(int total, int cost1, int cost2"}
{"id": "1546", "path": "output2\\c\\Medium\\1546-minimum-rounds-to-complete-all-tasks.c", "hypo_code": "int minimumRounds(int* tasks, int tasksSize){\n    int i, j;\n    int count = 0;\n    int arr[100000] = {0};\n    for(i = 0; i < tasksSize; i++){\n        arr[tasks[i]]++;\n    }\n    for(i = 0; i < 100000; i++){\n        if(arr[i] > 0){\n            if(arr[i] % 2 == 0){\n                count += arr[i] / 2;\n            }\n            else{\n                count += arr[i] / 2 + 1;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int minimumRounds(int* tasks, int tasksSize"}
{"id": "1547", "path": "output2\\c\\Medium\\1547-maximum-trailing-zeros-in-a-cornered-path.c", "hypo_code": "int maxTrailingZeros(int** grid, int gridSize, int* gridColSize){\n    int i, j, k, l, m, n, max = 0, count = 0, temp = 0;\n    int arr[100000] = {0};\n    for(i = 0; i < gridSize; i++){\n        for(j = 0; j < gridColSize[i]; j++){\n            temp = grid[i][j];\n            while(temp % 5 == 0){\n                temp /= 5;\n                count++;\n            }\n            arr[grid[i][j]] = count;\n            count = 0;\n        }\n    }\n    for(i = 0; i < gridSize; i++){\n        for(j = 0; j < gridColSize[i]; j++){\n            for(k = i; k < gridSize; k++){\n                for(l = j; l < gridColSize[k]; l++){\n                    for(m = i; m <= k; m++){\n                        for(n = j; n <= l; n++){\n                            count += arr[grid[m][n]];\n                        }\n                    }\n                    if(count > max){\n                        max = count;\n                    }\n                    count = 0;\n                }\n            }\n        }\n    }\n    return max;\n\n}", "prefix": "int maxTrailingZeros(int** grid, int gridSize, int* gridColSize"}
{"id": "1548", "path": "output2\\c\\Medium\\1548-count-lattice-points-inside-a-circle.c", "hypo_code": "int countLatticePoints(int** circles, int circlesSize, int* circlesColSize){\n    int i, j, k, l, m, n, count = 0;\n    int arr[100000] = {0};\n    for(i = 0; i < circlesSize; i++){\n        for(j = 0; j < 100000; j++){\n            if(circles[i][0] + j * circles[i][2] < 100000){\n                arr[circles[i][0] + j * circles[i][2]] = 1;\n            }\n        }\n    }\n    for(i = 0; i < 100000; i++){\n        if(arr[i] == 1){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int countLatticePoints(int** circles, int circlesSize, int* circlesColSize"}
{"id": "1549", "path": "output2\\c\\Medium\\1549-count-number-of-rectangles-containing-each-point.c", "hypo_code": "int* countRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize, int** points, int pointsSize, int* pointsColSize, int* returnSize){\n    int* arr = malloc(pointsSize * sizeof(int));\n    int i, j, k, l, m, n, count;\n    for(i = 0; i < pointsSize; i++){\n        count = 0;\n        for(j = 0; j < rectanglesSize; j++){\n            if(points[i][0] <= rectangles[j][0] && points[i][1] <= rectangles[j][1]){\n                count++;\n            }\n        }\n        arr[i] = count;\n    }\n    *returnSize = pointsSize;\n    return arr;\n\n}", "prefix": "int* countRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize, int** points, int pointsSize, int* pointsColSize, int* returnSize"}
{"id": "1550", "path": "output2\\c\\Medium\\1550-minimum-average-difference.c", "hypo_code": "int minimumAverageDifference(int* nums, int numsSize){\n    int i, j;\n    int sum = 0;\n    int count = 0;\n    int arr[100000] = {0};\n    for(i = 0; i < numsSize; i++){\n        sum += nums[i];\n        arr[i] = sum;\n    }\n    for(i = 0; i < numsSize; i++){\n        for(j = i + 1; j < numsSize; j++){\n            if((arr[j] - arr[i]) / (j - i) < (sum - arr[j]) / (numsSize - j)){\n                count = i;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int minimumAverageDifference(int* nums, int numsSize"}
{"id": "1551", "path": "output2\\c\\Medium\\1551-count-unguarded-cells-in-the-grid.c", "hypo_code": "int countUnguarded(int m, int n, int** guards, int guardsSize, int* guardsColSize, int** walls, int wallsSize, int* wallsColSize){\n    int i, j, k, l, m, n, count = 0;\n    int arr[100000] = {0};\n    for(i = 0; i < guardsSize; i++){\n        for(j = 0; j < 100000; j++){\n            if(circles[i][0] + j * circles[i][2] < 100000){\n                arr[circles[i][0] + j * circles[i][2]] = 1;\n            }\n        }\n    }\n    for(i = 0; i < 100000; i++){\n        if(arr[i] == 1){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int countUnguarded(int m, int n, int** guards, int guardsSize, int* guardsColSize, int** walls, int wallsSize, int* wallsColSize"}
{"id": "1552", "path": "output2\\c\\Medium\\1552-minimum-consecutive-cards-to-pick-up.c", "hypo_code": "int minimumCardPickup(int* cards, int cardsSize){\n    int i, j, k, count = 0, min = 0;\n    for(i = 0; i < cardsSize; i++){\n        for(j = i+1; j < cardsSize; j++){\n            if(cards[i] == cards[j]){\n                count = j - i;\n                if(min == 0){\n                    min = count;\n                }\n                else if(count < min){\n                    min = count;\n                }\n            }\n        }\n    }\n    if(min == 0){\n        return -1;\n    }\n    return min;\n\n}", "prefix": "int minimumCardPickup(int* cards, int cardsSize"}
{"id": "1553", "path": "output2\\c\\Medium\\1553-k-divisible-elements-subarrays.c", "hypo_code": "int countDistinct(int* nums, int numsSize, int k, int p){\n    int i, j, count = 0, sum = 0, temp = 0;\n    for(i = 0; i < numsSize; i++){\n        sum = 0;\n        for(j = i; j < numsSize; j++){\n            if(nums[j] % p == 0){\n                sum++;\n            }\n            if(sum <= k){\n                count++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int countDistinct(int* nums, int numsSize, int k, int p"}
{"id": "1554", "path": "output2\\c\\Medium\\1554-count-nodes-equal-to-average-of-subtree.c", "hypo_code": "int averageOfSubtree(struct TreeNode* root){\n    int sum = 0, count = 0;\n    if(root == NULL){\n        return 0;\n    }\n    sum = root->val;\n    count++;\n    if(root->left != NULL){\n        sum += averageOfSubtree(root->left);\n        count++;\n    }\n    if(root->right != NULL){\n        sum += averageOfSubtree(root->right);\n        count++;\n    }\n    return sum/count;\n\n}", "prefix": "int averageOfSubtree(struct TreeNode* root"}
{"id": "1555", "path": "output2\\c\\Medium\\1555-count-number-of-texts.c", "hypo_code": "int countTexts(char * pressedKeys){\nint sum=0;\n    int max=0;\n    int i,j;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<strlen(pressedKeys);i++){\n        sum+=pressedKeys[i];\n    }\n    return sum;\n}", "prefix": "int countTexts(char * pressedKeys"}
{"id": "1556", "path": "output2\\c\\Medium\\1556-number-of-ways-to-split-array.c", "hypo_code": "int waysToSplitArray(int* nums, int numsSize){\n    int i, j, k, count = 0, sum = 0, temp = 0;\n    for(i = 0; i < numsSize; i++){\n        sum = 0;\n        for(j = i; j < numsSize; j++){\n            if(nums[j] % p == 0){\n                sum++;\n            }\n            if(sum <= k){\n                count++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int waysToSplitArray(int* nums, int numsSize"}
{"id": "1557", "path": "output2\\c\\Medium\\1557-maximum-white-tiles-covered-by-a-carpet.c", "hypo_code": "int maximumWhiteTiles(int** tiles, int tilesSize, int* tilesColSize, int carpetLen){\n    int i, j, k, count = 0, max = 0, temp = 0;\n    for(i = 0; i < tilesSize; i++){\n        for(j = tiles[i][0]; j <= tiles[i][1]; j++){\n            count = 0;\n            for(k = 0; k < tilesSize; k++){\n                if(j >= tiles[k][0] && j <= tiles[k][1]){\n                    count++;\n                }\n            }\n            if(count > max){\n                max = count;\n            }\n        }\n    }\n    return max * carpetLen;\n\n}", "prefix": "int maximumWhiteTiles(int** tiles, int tilesSize, int* tilesColSize, int carpetLen"}
{"id": "1558", "path": "output2\\c\\Medium\\1558-maximum-consecutive-floors-without-special-floors.c", "hypo_code": "int maxConsecutive(int bottom, int top, int* special, int specialSize){\n    int i, j, k, count = 0, max = 0, temp = 0;\n    for(i = bottom; i <= top; i++){\n        count = 0;\n        for(j = 0; j < specialSize; j++){\n            if(i == special[j]){\n                count++;\n            }\n        }\n        if(count == 0){\n            temp++;\n        }\n        else{\n            if(temp > max){\n                max = temp;\n            }\n            temp = 0;\n        }\n    }\n    if(temp > max){\n        max = temp;\n    }\n    return max;\n\n}", "prefix": "int maxConsecutive(int bottom, int top, int* special, int specialSize"}
{"id": "1559", "path": "output2\\c\\Medium\\1559-largest-combination-with-bitwise-and-greater-than-zero.c", "hypo_code": "int largestCombination(int* candidates, int candidatesSize){\n    int i, j, k, count = 0, max = 0, temp = 0;\n    for(i = 0; i < candidatesSize; i++){\n        for(j = i+1; j < candidatesSize; j++){\n            temp = candidates[i] & candidates[j];\n            if(temp > max){\n                max = temp;\n            }\n        }\n    }\n    return max;\n\n}", "prefix": "int largestCombination(int* candidates, int candidatesSize"}
{"id": "1560", "path": "output2\\c\\Medium\\1560-maximum-bags-with-full-capacity-of-rocks.c", "hypo_code": "int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks){\n    int i, j, k, count = 0, max = 0, temp = 0;\n    for(i = 0; i < capacitySize; i++){\n        temp = capacity[i] - rocks[i];\n        if(temp <= additionalRocks){\n            count++;\n            additionalRocks -= temp;\n        }\n    }\n    return count;\n\n}", "prefix": "int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks"}
{"id": "1561", "path": "output2\\c\\Medium\\1561-minimum-lines-to-represent-a-line-chart.c", "hypo_code": "int minimumLines(int** stockPrices, int stockPricesSize, int* stockPricesColSize){\nint lines=1;\n    int i,j,k;\n    int x,y;\n    for(i=1;i<stockPricesSize;i++){\n        x=stockPrices[i][0];\n        y=stockPrices[i][1];\n        if(stockPrices[i-1][0]<x && stockPrices[i-1][1]<y){\n            lines++;\n        }\n    }\n    return lines;\n}", "prefix": "int minimumLines(int** stockPrices, int stockPricesSize, int* stockPricesColSize"}
{"id": "1562", "path": "output2\\c\\Medium\\1562-sender-with-largest-word-count.c", "hypo_code": "char * largestWordCount(char ** messages, int messagesSize, char ** senders, int sendersSize){\n    int i, j, k, count = 0, max = 0, temp = 0;\n    for(i = 0; i < messagesSize; i++){\n        count = 0;\n        for(j = 0; j < strlen(messages[i]); j++){\n            if(messages[i][j] == ' '){\n                count++;\n            }\n        }\n        if(count > max){\n            max = count;\n        }\n    }\n    return max;\n\n}", "prefix": "char * largestWordCount(char ** messages, int messagesSize, char ** senders, int sendersSize"}
{"id": "1563", "path": "output2\\c\\Medium\\1563-maximum-total-importance-of-roads.c", "hypo_code": "long long maximumImportance(int n, int** roads, int roadsSize, int* roadsColSize){\n    int i, j, k, count = 0, max = 0, temp = 0;\n    for(i = 0; i < roadsSize; i++){\n        for(j = 0; j < roadsColSize[i]; j++){\n            if(roads[i][j] > max){\n                max = roads[i][j];\n            }\n        }\n    }\n    return (long long)max * (max - 1) / 2;\n\n}", "prefix": "long long maximumImportance(int n, int** roads, int roadsSize, int* roadsColSize"}
{"id": "1564", "path": "output2\\c\\Medium\\1564-apply-discount-to-prices.c", "hypo_code": "char * discountPrices(char * sentence, int discount){\n    int i, j, k, count = 0, temp = 0, sum = 0;\n    for(i = 0; i < strlen(sentence); i++){\n        if(sentence[i] == '$'){\n            for(j = i+1; j < strlen(sentence); j++){\n                if(sentence[j] == ' '){\n                    break;\n                }\n                temp = temp * 10 + sentence[j] - '0';\n            }\n            sum = temp - (temp * discount) / 100;\n            temp = 0;\n            for(k = i+1; k < j; k++){\n                sentence[k] = ' ';\n            }\n            while(sum != 0){\n                sentence[k] = sum % 10 + '0';\n                sum = sum / 10;\n                k++;\n            }\n            sentence[k] = ' ';\n        }\n    }\n    return sentence;\n\n\n}", "prefix": "char * discountPrices(char * sentence, int discount"}
{"id": "1565", "path": "output2\\c\\Medium\\1565-steps-to-make-array-non-decreasing.c", "hypo_code": "int totalSteps(int* nums, int numsSize){\n    int i, j, k, count = 0, temp = 0;\n    for(i = 0; i < numsSize; i++){\n        for(j = i+1; j < numsSize; j++){\n            if(nums[i] > nums[j]){\n                temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                count++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int totalSteps(int* nums, int numsSize"}
{"id": "1566", "path": "output2\\c\\Medium\\1566-partition-array-such-that-maximum-difference-is-k.c", "hypo_code": "int partitionArray(int* nums, int numsSize, int k){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<numsSize;i++){\n        sum+=nums[i];\n    }\n    return sum;\n}", "prefix": "int partitionArray(int* nums, int numsSize, int k"}
{"id": "1567", "path": "output2\\c\\Medium\\1567-replace-elements-in-an-array.c", "hypo_code": "int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\nint* ret = malloc(sizeof(int)*numsSize);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*numsSize);\n    i=0;\n    while(i<numsSize){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<numsSize){\n        arr[i++]=nums[i];\n    }\n    i=0;\n    while(i<numsSize){\n        left=i-time;\n        right=i+time;\n        if(left<0){\n            left=0;\n        }\n        if(right>numsSize-1){\n            right=numsSize-1;\n        }\n        prev=arr[left];\n        next=arr[right];\n        if(prev<=arr[i]&&arr[i]<=next){\n            ret[i]=1;\n        }else{\n            ret[i]=0;\n        }\n        i++;\n    }\n    *returnSize=numsSize;\n    return ret;\n}", "prefix": "int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize"}
{"id": "1568", "path": "output2\\c\\Medium\\1568-successful-pairs-of-spells-and-potions.c", "hypo_code": "int* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, long long success, int* returnSize){\n    int i, j, k, count = 0, temp = 0;\n    int* pairs = (int*)malloc(sizeof(int) * spellsSize);\n    for(i = 0; i < spellsSize; i++){\n        count = 0;\n        for(j = 0; j < potionsSize; j++){\n            if((long long)spells[i] * potions[j] >= success){\n                count++;\n            }\n        }\n        pairs[i] = count;\n    }\n    *returnSize = spellsSize;\n    return pairs;\n\n\n}", "prefix": "int* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, long long success, int* returnSize"}
{"id": "1569", "path": "output2\\c\\Medium\\1569-minimum-path-cost-in-a-grid.c", "hypo_code": "int minPathCost(int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize){\n    int m = gridSize;\n    int n = *gridColSize;\n    int dp[m][n];\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            dp[i][j] = INT_MAX;\n        }\n    }\n    for(int i=0;i<n;i++){\n        dp[0][i] = grid[0][i];\n    }\n    for(int i=1;i<m;i++){\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++){\n                dp[i][j] = min(dp[i][j], dp[i-1][k] + moveCost[grid[i-1][k]][k] + grid[i][j]);\n            }\n        }\n    }\n    int ans = INT_MAX;\n    for(int i=0;i<n;i++){\n        ans = min(ans, dp[m-1][i]);\n    }\n    return ans;\n\n}", "prefix": "int minPathCost(int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize"}
{"id": "1570", "path": "output2\\c\\Medium\\1570-fair-distribution-of-cookies.c", "hypo_code": "int distributeCookies(int* cookies, int cookiesSize, int k){\n    int dp[k][cookiesSize];\n    for(int i=0;i<k;i++){\n        for(int j=0;j<cookiesSize;j++){\n            dp[i][j] = INT_MAX;\n        }\n    }\n    for(int i=0;i<cookiesSize;i++){\n        dp[0][i] = cookies[i];\n    }\n    for(int i=1;i<k;i++){\n        for(int j=i;j<cookiesSize;j++){\n            for(int l=i-1;l<j;l++){\n                dp[i][j] = min(dp[i][j], max(dp[i-1][l], cookies[j] - cookies[l]));\n            }\n        }\n    }\n    return dp[k-1][cookiesSize-1];\n\n}", "prefix": "int distributeCookies(int* cookies, int cookiesSize, int k"}
{"id": "1571", "path": "output2\\c\\Medium\\1571-sum-of-numbers-with-units-digit-k.c", "hypo_code": "int minimumNumbers(int num, int k){\nint count=0;\n    int i,j;\n    int sum=0;\n    int temp;\n    int ret;\n    if(num<k){\n        return -1;\n    }\n    if(num==k){\n        return 1;\n    }\n    if(k==0){\n        return -1;\n    }\n    if(k==1){\n        return num;\n    }\n    if((num%k)==0){\n        return num/k;\n    }\n    for(i=1;i<=k;i++){\n        sum+=i;\n    }\n    if((num%k)==sum){\n        return num/k;\n    }\n    if((num%k)<sum){\n        return -1;\n    }\n    ret=num/k;\n    temp=num%k;\n    if(temp>0){\n        ret+=1;\n    }\n    return ret;\n}", "prefix": "int minimumNumbers(int num, int k"}
{"id": "1572", "path": "output2\\c\\Medium\\1572-longest-binary-subsequence-less-than-or-equal-to-k.c", "hypo_code": "int longestSubsequence(char * s, int k){\nint longest=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<numsSize;i++){\n        sum+=nums[i];\n    }\n    return sum;\n\n}", "prefix": "int longestSubsequence(char * s, int k"}
{"id": "1573", "path": "output2\\c\\Medium\\1573-count-unreachable-pairs-of-nodes-in-an-undirected-graph.c", "hypo_code": "long long countPairs(int n, int** edges, int edgesSize, int* edgesColSize){\nlong long pairs=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<edgesSize;i++){\n        pairs+=edgesColSize[i];\n    }\n    return pairs;\n}", "prefix": "long long countPairs(int n, int** edges, int edgesSize, int* edgesColSize"}
{"id": "1574", "path": "output2\\c\\Medium\\1574-maximum-xor-after-operations.c", "hypo_code": "int maximumXOR(int* nums, int numsSize){\nint max=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n}", "prefix": "int maximumXOR(int* nums, int numsSize"}
{"id": "1575", "path": "output2\\c\\Medium\\1575-count-number-of-ways-to-place-houses.c", "hypo_code": "int countHousePlacements(int n){\nint ret=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n}", "prefix": "int countHousePlacements(int n"}
{"id": "1576", "path": "output2\\c\\Medium\\1576-spiral-matrix-iv.c", "hypo_code": "int** spiralMatrix(int m, int n, struct ListNode* head, int* returnSize, int** returnColumnSizes){\nint** ret = malloc(sizeof(int*)*m);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*m*n);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    for(i=0;i<m;i++){\n        ret[i]=malloc(sizeof(int)*n);\n    }\n    for(i=0;i<m;i++){\n        for(j=0;j<n;j++){\n            ret[i][j]=-1;\n        }\n    }\n    i=0;\n    j=0;\n    k=0;\n    while(k<m*n){\n        if(i==0){\n            for(;j<n;j++){\n                ret[i][j]=arr[k++];\n            }\n            j--;\n            i++;\n        }else if(i==m-1){\n            for(;j>=0;j--){\n                ret[i][j]=arr[k++];\n            }\n            j++;\n            i--;\n        }else if(j==0){\n            for(;i<m;i++){\n                ret[i][j]=arr[k++];\n            }\n            i--;\n            j++;\n        }else if(j==n-1){\n            for(;i>=0;i--){\n                ret[i][j]=arr[k++];\n            }\n            i++;\n            j--;\n        }\n    }\n    *returnSize=m;\n    *returnColumnSizes=malloc(sizeof(int)*m);\n    for(i=0;i<m;i++){\n        (*returnColumnSizes)[i]=n;\n    }\n    return ret;\n}", "prefix": "int** spiralMatrix(int m, int n, struct ListNode* head, int* returnSize, int** returnColumnSizes"}
{"id": "1577", "path": "output2\\c\\Medium\\1577-number-of-people-aware-of-a-secret.c", "hypo_code": "int peopleAwareOfSecret(int n, int delay, int forget){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*n);\n    i=0;\n    while(i<n){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<n){\n        if(i==0){\n            arr[i]=1;\n        }else if(i>=delay){\n            arr[i]=arr[i-delay];\n        }\n        if(i>forget){\n            arr[i]-=arr[i-forget];\n        }\n        i++;\n    }\n    i=0;\n    count=0;\n    while(i<n){\n        if(arr[i]>0){\n            count++;\n        }\n        i++;\n    }\n    return count;\n}", "prefix": "int peopleAwareOfSecret(int n, int delay, int forget"}
{"id": "1578", "path": "output2\\c\\Medium\\1578-the-latest-time-to-catch-a-bus.c", "hypo_code": "int latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity){\nint i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n}", "prefix": "int latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity"}
{"id": "1579", "path": "output2\\c\\Medium\\1579-minimum-sum-of-squared-difference.c", "hypo_code": "long long minSumSquareDiff(int* nums1, int nums1Size, int* nums2, int nums2Size, int k1, int k2){\nlong long minSum=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    for(i=0;i<nums1Size;i++){\n        minSum+=nums1[i];\n    }\n    return minSum;\n}", "prefix": "long long minSumSquareDiff(int* nums1, int nums1Size, int* nums2, int nums2Size, int k1, int k2"}
{"id": "1581", "path": "output2\\c\\Medium\\1581-move-pieces-to-obtain-a-string.c", "hypo_code": "bool canChange(char * start, char * target){\nint i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int len=strlen(start);\n    int* arr = malloc(sizeof(int)*len);\n    int* arr2 = malloc(sizeof(int)*len);\n    int* arr3 = malloc(sizeof(int)*len);\n    int* arr4 = malloc(sizeof(int)*len);\n    int* ret = malloc(sizeof(int)*2);\n    for(i=0;i<len;i++){\n        if(start[i]=='L'){\n            arr[i]=1;\n        }else if(start[i]=='R'){\n            arr[i]=2;\n        }else{\n            arr[i]=0;\n        }\n    }\n    for(i=0;i<len;i++){\n        if(target[i]=='L'){\n            arr2[i]=1;\n        }else if(target[i]=='R'){\n            arr2[i]=2;\n        }else{\n            arr2[i]=0;\n        }\n    }\n    for(i=0;i<len;i++){\n        if(start[i]=='L' || start[i]=='R'){\n            arr3[i]=1;\n        }else{\n            arr3[i]=0;\n        }\n    }\n    for(i=0;i<len;i++){\n        if(target[i]=='L' || target[i]=='R'){\n            arr4[i]=1;\n        }else{\n            arr4[i]=0;\n        }\n    }\n    for(i=0;i<len;i++){\n        if(arr[i]==1){\n            for(j=i-1;j>=0;j--){\n                if(arr[j]==0){\n                    arr[j]=1;\n                    arr[i]=0;\n                    break;\n                }else if(arr[j]==1){\n                    break;\n                }\n            }\n        }else if(arr[i]==2){\n            for(j=i+1;j<len;j++){\n                if(arr[j]==0){\n                    arr[j]=2;\n                    arr[i]=0;\n                    break;\n                }else if(arr[j]==2){\n                    break;\n                }\n            }\n        }\n    }\n    for(i=0;i<len;i++){\n        if(arr2[i]==1){\n            for(j=i-1;j>=0;j--){\n                if(arr2[j]==0){\n                    arr2[j]=1;\n                    arr2[i]=0;\n                    break;\n                }else if(arr2[j]==1){\n                    break;\n                }\n            }\n        }else if(arr2[i]==2){\n            for(j=i+1;j<len;j++){\n                if(arr2[j]==0){\n                    arr2[j]=2;\n                    arr2[i]=0;\n                    break;\n                }else if(arr2[j]==2){\n                    break;\n                }\n            }\n        } \n \n\n}", "prefix": "bool canChange(char * start, char * target"}
{"id": "1582", "path": "output2\\c\\Medium\\1582-max-sum-of-a-pair-with-equal-sum-of-digits.c", "hypo_code": "int maximumSum(int* nums, int numsSize){\nint sum=0;\n    int max=0;\n    int i,j,k;\n    for(i=0;i<numsSize;i++){\n        for(j=i+1;j<numsSize;j++){\n            if((nums[i]+nums[j])%9==0){\n                sum=nums[i]+nums[j];\n                if(sum>max){\n                    max=sum;\n                }\n            }\n        }\n    }\n    return max;\n}", "prefix": "int maximumSum(int* nums, int numsSize"}
{"id": "1583", "path": "output2\\c\\Medium\\1583-query-kth-smallest-trimmed-number.c", "hypo_code": "int* smallestTrimmedNumbers(char ** nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nint* ret = malloc(sizeof(int)*queriesSize);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* arr = malloc(sizeof(int)*numsSize);\n    i=0;\n    while(i<numsSize){\n        arr[i++]=0;\n    }\n    i=0;\n    while(i<numsSize){\n        arr[i++]=nums[i];\n    }\n    i=0;\n    while(i<numsSize){\n        left=i-time;\n        right=i+time;\n        if(left<0){\n            left=0;\n        }\n        if(right>numsSize-1){\n            right=numsSize-1;\n        }\n        count=0;\n        for(j=left;j<=right;j++){\n            if(arr[j]<arr[i]){\n                count++;\n            }\n        }\n        ret[i]=count;\n    }\n    *returnSize=queriesSize;\n    return ret;\n}", "prefix": "int* smallestTrimmedNumbers(char ** nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1584", "path": "output2\\c\\Medium\\1584-number-of-zero-filled-subarrays.c", "hypo_code": "long long zeroFilledSubarray(int* nums, int numsSize){\n    long long ans = 0;\n    int dp[numsSize];\n    for(int i=0;i<numsSize;i++){\n        dp[i] = 0;\n    }\n    for(int i=0;i<numsSize;i++){\n        if(nums[i] == 0){\n            dp[i] = 1;\n            if(i > 0){\n                dp[i] += dp[i-1];\n            }\n        }\n    }\n    for(int i=0;i<numsSize;i++){\n        ans += dp[i];\n    }\n    return ans;\n\n}", "prefix": "long long zeroFilledSubarray(int* nums, int numsSize"}
{"id": "1586", "path": "output2\\c\\Medium\\1586-equal-row-and-column-pairs.c", "hypo_code": "int equalPairs(int** grid, int gridSize, int* gridColSize){\n    int m = gridSize;\n    int n = *gridColSize;\n    int dp[m][n];\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            dp[i][j] = 0;\n        }\n    }\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            if(grid[i][j] == 1){\n                dp[i][j] = 1;\n                if(i > 0){\n                    dp[i][j] += dp[i-1][j];\n                }\n                if(j > 0){\n                    dp[i][j] += dp[i][j-1];\n                }\n                if(i > 0 && j > 0){\n                    dp[i][j] -= dp[i-1][j-1];\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n\n}", "prefix": "int equalPairs(int** grid, int gridSize, int* gridColSize"}
{"id": "1588", "path": "output2\\c\\Medium\\1588-maximum-number-of-groups-entering-a-competition.c", "hypo_code": "int maximumGroups(int* grades, int gradesSize){\nint i,j,k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n}", "prefix": "int maximumGroups(int* grades, int gradesSize"}
{"id": "1589", "path": "output2\\c\\Medium\\1589-find-closest-node-to-given-two-nodes.c", "hypo_code": "int closestMeetingNode(int* edges, int edgesSize, int node1, int node2){\nint* arr = malloc(sizeof(int)*100000);\n    int i;\n    int j;\n    int k;\n    int count;\n    int left;\n    int right;\n    int prev;\n    int next;\n    int* ret = malloc(sizeof(int)*2);\n    struct ListNode* node = head;\n    i=0;\n    while(node){\n        arr[i++]=node->val;\n        node=node->next;\n    }\n    ret[0]=arr[left-1];\n    ret[1]=arr[right-1];\n    *returnSize=2;\n    return ret;\n}", "prefix": "int closestMeetingNode(int* edges, int edgesSize, int node1, int node2"}
{"id": "1590", "path": "output2\\c\\Medium\\1590-count-number-of-bad-pairs.c", "hypo_code": "long long countBadPairs(int* nums, int numsSize){\nlong long badPairs=0;\n    int i,j,k;\n    int count;\n    int left;\n    int right;\n    for(i=0;i<numsSize;i++){\n        for(j=i+1;j<numsSize;j++){\n            if(i<j && j-i!=nums[j]-nums[i]){\n                badPairs++;\n            }\n        }\n    }\n    return badPairs;\n}", "prefix": "long long countBadPairs(int* nums, int numsSize"}
{"id": "1591", "path": "output2\\c\\Medium\\1591-task-scheduler-ii.c", "hypo_code": "long long taskSchedulerII(int* tasks, int tasksSize, int space){\nint i, j;\n\tlong long res = 0;\n\tint *cnt = (int *)malloc(sizeof(int) * 1000000001);\n\tmemset(cnt, 0, sizeof(int) * 1000000001);\n\tfor (i = 0; i < tasksSize; ++i) {\n\t\tcnt[tasks[i]]++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 1000000001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tres = (max - 1) * (space + 1);\n\tfor (i = 0; i < 1000000001; ++i) {\n\t\tif (cnt[i] == max) {\n\t\t\tres++;\n\t\t}\n\t}\n\tif (res < tasksSize) {\n\t\tres = tasksSize;\n\t}\n\treturn res;\n}", "prefix": "long long taskSchedulerII(int* tasks, int tasksSize, int space"}
{"id": "1592", "path": "output2\\c\\Medium\\1592-reachable-nodes-with-restrictions.c", "hypo_code": "int reachableNodes(int n, int** edges, int edgesSize, int* edgesColSize, int* restricted, int restrictedSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * n);\n\tmemset(cnt, 0, sizeof(int) * n);\n\tint **g = (int **)malloc(sizeof(int *) * n);\n\tfor (i = 0; i < n; ++i) {\n\t\tg[i] = (int *)malloc(sizeof(int) * n);\n\t\tmemset(g[i], 0, sizeof(int) * n);\n\t}\n\tfor (i = 0; i < edgesSize; ++i) {\n\t\tg[edges[i][0]][edges[i][1]] = 1;\n\t\tg[edges[i][1]][edges[i][0]] = 1;\n\t}\n\tfor (i = 0; i < restrictedSize; ++i) {\n\t\tfor (j = 0; j < n; ++j) {\n\t\t\tg[restricted[i]][j] = 0;\n\t\t\tg[j][restricted[i]] = 0;\n\t\t}\n\t}\n\tfor (i = 0; i < n; ++i) {\n\t\tif (g[0][i] == 1) {\n\t\t\tcnt[0]++;\n\t\t}\n\t}\n\tfor (i = 1; i < n; ++i) {\n\t\tfor (j = 0; j < n; ++j) {\n\t\t\tif (g[i][j] == 1) {\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (cnt[i] > 0) {\n\t\t\tres++;\n\t\t}\n\t}\n\tfor (i = 0; i < edgesSize; ++i) {\n\t\tif (cnt[edges[i][0]] > 0 && cnt[edges[i][1]] > 0) {\n\t\t\tres += cnt[edges[i][0]] > cnt[edges[i][1]] ? cnt[edges[i][1]] : cnt[edges[i][0]];\n\t\t}\n\t}\n\treturn res;\n}", "prefix": "int reachableNodes(int n, int** edges, int edgesSize, int* edgesColSize, int* restricted, int restrictedSize"}
{"id": "1593", "path": "output2\\c\\Medium\\1593-check-if-there-is-a-valid-partition-for-the-array.c", "hypo_code": "bool validPartition(int* nums, int numsSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 1000001);\n\tmemset(cnt, 0, sizeof(int) * 1000001);\n\tfor (i = 0; i < numsSize; ++i) {\n\t\tcnt[nums[i]]++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 1000001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tif (numsSize - max * 3 == 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "prefix": "bool validPartition(int* nums, int numsSize"}
{"id": "1594", "path": "output2\\c\\Medium\\1594-longest-ideal-subsequence.c", "hypo_code": "int longestIdealString(char * s, int k){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 26);\n\tmemset(cnt, 0, sizeof(int) * 26);\n\tfor (i = 0; i < strlen(s); ++i) {\n\t\tcnt[s[i] - 'a']++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 26; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tif (max - 1 <= k) {\n\t\treturn strlen(s);\n\t}\n\treturn max - 1 + k;\n}", "prefix": "int longestIdealString(char * s, int k"}
{"id": "1595", "path": "output2\\c\\Medium\\1595-node-with-highest-edge-score.c", "hypo_code": "int edgeScore(int* edges, int edgesSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * edgesSize);\n\tmemset(cnt, 0, sizeof(int) * edgesSize);\n\tfor (i = 0; i < edgesSize; ++i) {\n\t\tcnt[edges[i]]++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < edgesSize; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tfor (i = 0; i < edgesSize; ++i) {\n\t\tif (cnt[i] == max) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "prefix": "int edgeScore(int* edges, int edgesSize"}
{"id": "1596", "path": "output2\\c\\Medium\\1596-construct-smallest-number-from-di-string.c", "hypo_code": "char * smallestNumber(char * pattern){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * strlen(pattern));\n\tmemset(cnt, 0, sizeof(int) * strlen(pattern));\n\tint *num = (int *)malloc(sizeof(int) * (strlen(pattern) + 1));\n\tmemset(num, 0, sizeof(int) * (strlen(pattern) + 1));\n\tfor (i = 0; i < strlen(pattern); ++i) {\n\t\tif (pattern[i] == 'I') {\n\t\t\tcnt[i] = 1;\n\t\t} else {\n\t\t\tcnt[i] = 0;\n\t\t}\n\t}\n\tfor (i = 0; i < strlen(pattern); ++i) {\n\t\tif (cnt[i] == 1) {\n\t\t\tnum[i] = i + 1;\n\t\t} else {\n\t\t\tfor (j = 0; j < strlen(pattern); ++j) {\n\t\t\t\tif (num[j] == 0) {\n\t\t\t\t\tnum[j] = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < strlen(pattern) + 1; ++i) {\n\t\tprintf(\"%d\", num[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn \"\";\n}", "prefix": "char * smallestNumber(char * pattern"}
{"id": "1597", "path": "output2\\c\\Medium\\1597-time-needed-to-rearrange-a-binary-string.c", "hypo_code": "int secondsToRemoveOccurrences(char * s){\nint i, j;\n\tint ones = 0;\n\tint zeros = 0;\n\tint n = strlen(s);\n\tfor (i = 0; i < n; ++i) {\n\t\tif (s[i] == '1') {\n\t\t\tones++;\n\t\t}\n\t}\n\tfor (i = 0; i < n; ++i) {\n\t\tif (s[i] == '0') {\n\t\t\tzeros++;\n\t\t}\n\t}\n\tif (ones == 0 || zeros == 0) {\n\t\treturn 0;\n\t}\n\tif (ones > zeros) {\n\t\treturn zeros;\n\t}\n\treturn ones;\n}", "prefix": "int secondsToRemoveOccurrences(char * s"}
{"id": "1598", "path": "output2\\c\\Medium\\1598-shifting-letters-ii.c", "hypo_code": "char * shiftingLetters(char * s, int** shifts, int shiftsSize, int* shiftsColSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * strlen(s));\n\tmemset(cnt, 0, sizeof(int) * strlen(s));\n\tfor (i = 0; i < shiftsSize; ++i) {\n\t\tfor (j = shifts[i][0]; j <= shifts[i][1]; ++j) {\n\t\t\tcnt[j] += shifts[i][2];\n\t\t}\n\t}\n\tfor (i = 0; i < strlen(s); ++i) {\n\t\ts[i] += cnt[i];\n\t\tif (s[i] > 'z') {\n\t\t\ts[i] -= 26;\n\t\t}\n\t}\n\treturn s;\n}", "prefix": "char * shiftingLetters(char * s, int** shifts, int shiftsSize, int* shiftsColSize"}
{"id": "1599", "path": "output2\\c\\Medium\\1599-largest-palindromic-number.c", "hypo_code": "char * largestPalindromic(char * num){\nint i, j;\n\treturn \"\";\n}", "prefix": "char * largestPalindromic(char * num"}
{"id": "1600", "path": "output2\\c\\Medium\\1600-amount-of-time-for-binary-tree-to-be-infected.c", "hypo_code": "int amountOfTime(struct TreeNode* root, int start){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 100001);\n\tmemset(cnt, 0, sizeof(int) * 100001);\n\tcnt[start] = 1;\n\tstruct TreeNode **q = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * 100001);\n\tint front = 0, rear = 0;\n\tq[rear++] = root;\n\twhile (front != rear) {\n\t\tstruct TreeNode *node = q[front++];\n\t\tif (node->left != NULL) {\n\t\t\tq[rear++] = node->left;\n\t\t\tif (node->left->val != start) {\n\t\t\t\tcnt[node->left->val] = 1;\n\t\t\t}\n\t\t}\n\t\tif (node->right != NULL) {\n\t\t\tq[rear++] = node->right;\n\t\t\tif (node->right->val != start) {\n\t\t\t\tcnt[node->right->val] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 100001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\treturn max - 1;\n}", "prefix": "int amountOfTime(struct TreeNode* root, int start"}
{"id": "1601", "path": "output2\\c\\Medium\\1601-removing-stars-from-a-string.c", "hypo_code": "char * removeStars(char * s){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * strlen(s));\n\tmemset(cnt, 0, sizeof(int) * strlen(s));\n\tint *num = (int *)malloc(sizeof(int) * (strlen(s) + 1));\n\tmemset(num, 0, sizeof(int) * (strlen(s) + 1));\n\tfor (i = 0; i < strlen(s); ++i) {\n\t\tif (s[i] == '*') {\n\t\t\tcnt[i] = 1;\n\t\t} else {\n\t\t\tcnt[i] = 0;\n\t\t}\n\t}\n\tfor (i = 0; i < strlen(s); ++i) {\n\t\tif (cnt[i] == 1) {\n\t\t\tnum[i] = i + 1;\n\t\t} else {\n\t\t\tfor (j = 0; j < strlen(s); ++j) {\n\t\t\t\tif (num[j] == 0) {\n\t\t\t\t\tnum[j] = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < strlen(s) + 1; ++i) {\n\t\tprintf(\"%d\", num[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn \"\";\n}", "prefix": "char * removeStars(char * s"}
{"id": "1602", "path": "output2\\c\\Medium\\1602-minimum-amount-of-time-to-collect-garbage.c", "hypo_code": "int garbageCollection(char ** garbage, int garbageSize, int* travel, int travelSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * garbageSize);\n\tmemset(cnt, 0, sizeof(int) * garbageSize);\n\tint **g = (int **)malloc(sizeof(int *) * garbageSize);\n\tfor (i = 0; i < garbageSize; ++i) {\n\t\tg[i] = (int *)malloc(sizeof(int) * garbageSize);\n\t\tmemset(g[i], 0, sizeof(int) * garbageSize);\n\t}\n\tfor (i = 0; i < garbageSize; ++i) {\n\t\tfor (j = 0; j < strlen(garbage[i]); ++j) {\n\t\t\tif (garbage[i][j] == 'M') {\n\t\t\t\tg[i][0]++;\n\t\t\t} else if (garbage[i][j] == 'P') {\n\t\t\t\tg[i][1]++;\n\t\t\t} else {\n\t\t\t\tg[i][2]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < garbageSize; ++i) {\n\t\tif (g[i][0] > 0) {\n\t\t\tcnt[0] += g[i][0];\n\t\t}\n\t}\n\tfor (i = 1; i < garbageSize; ++i) {\n\t\tfor (j = 0; j < garbageSize; ++j) {\n\t\t\tif (g[j][0] > 0) {\n\t\t\t\tcnt[i] += g[j][0];\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (i = 0; i < garbageSize; ++i) {\n\t\tres += cnt[i] * travel[i];\n\t}\n\treturn res;\n}", "prefix": "int garbageCollection(char ** garbage, int garbageSize, int* travel, int travelSize"}
{"id": "1603", "path": "output2\\c\\Medium\\1603-strictly-palindromic-number.c", "hypo_code": "bool isStrictlyPalindromic(int n){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 100000);\n\tmemset(cnt, 0, sizeof(int) * 100000);\n\tfor (i = 2; i < 100000; ++i) {\n\t\tint x = n;\n\t\tint len = 0;\n\t\twhile (x) {\n\t\t\tcnt[len++] = x % i;\n\t\t\tx /= i;\n\t\t}\n\t\tint l = 0, r = len - 1;\n\t\twhile (l < r) {\n\t\t\tif (cnt[l] != cnt[r]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl++;\n\t\t\tr--;\n\t\t}\n\t\tif (l < r) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "prefix": "bool isStrictlyPalindromic(int n"}
{"id": "1604", "path": "output2\\c\\Medium\\1604-maximum-rows-covered-by-columns.c", "hypo_code": "int maximumRows(int** matrix, int matrixSize, int* matrixColSize, int numSelect){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * matrixSize);\n\tmemset(cnt, 0, sizeof(int) * matrixSize);\n\tfor (i = 0; i < matrixSize; ++i) {\n\t\tfor (j = 0; j < matrixColSize[i]; ++j) {\n\t\t\tif (matrix[i][j] == 1) {\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (i = 0; i < matrixSize; ++i) {\n\t\tif (cnt[i] <= numSelect) {\n\t\t\tres++;\n\t\t}\n\t}\n\treturn res;\n}", "prefix": "int maximumRows(int** matrix, int matrixSize, int* matrixColSize, int numSelect"}
{"id": "1605", "path": "output2\\c\\Medium\\1605-number-of-ways-to-reach-a-position-after-exactly-k-steps.c", "hypo_code": "int numberOfWays(int startPos, int endPos, int k){\nint i, j;\n\tint res = 0;\n\tint **dp = (int **)malloc(sizeof(int *) * k);\n\tfor (i = 0; i < k; ++i) {\n\t\tdp[i] = (int *)malloc(sizeof(int) * 1001);\n\t\tmemset(dp[i], 0, sizeof(int) * 1001);\n\t}\n\tdp[0][startPos] = 1;\n\tfor (i = 1; i < k; ++i) {\n\t\tfor (j = 0; j < 1001; ++j) {\n\t\t\tdp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % 1000000007;\n\t\t}\n\t}\n\tres = dp[k - 1][endPos];\n\tfor (i = 0; i < k; ++i) {\n\t\tfree(dp[i]);\n\t}\n\tfree(dp);\n\treturn res;\n}", "prefix": "int numberOfWays(int startPos, int endPos, int k"}
{"id": "1606", "path": "output2\\c\\Medium\\1606-longest-nice-subarray.c", "hypo_code": "int longestNiceSubarray(int* nums, int numsSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 1000000001);\n\tmemset(cnt, 0, sizeof(int) * 1000000001);\n\tfor (i = 0; i < numsSize; ++i) {\n\t\tcnt[nums[i]]++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 1000000001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tif (numsSize - max * 2 == 0) {\n\t\treturn numsSize;\n\t}\n\treturn numsSize - max * 2;\n}", "prefix": "int longestNiceSubarray(int* nums, int numsSize"}
{"id": "1607", "path": "output2\\c\\Medium\\1607-optimal-partition-of-string.c", "hypo_code": "int partitionString(char * s){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 26);\n\tmemset(cnt, 0, sizeof(int) * 26);\n\tfor (i = 0; i < strlen(s); ++i) {\n\t\tcnt[s[i] - 'a']++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 26; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tif (strlen(s) - max * 2 == 0) {\n\t\treturn strlen(s);\n\t}\n\treturn strlen(s) - max * 2 + 1;\n}", "prefix": "int partitionString(char * s"}
{"id": "1608", "path": "output2\\c\\Medium\\1608-divide-intervals-into-minimum-number-of-groups.c", "hypo_code": "int minGroups(int** intervals, int intervalsSize, int* intervalsColSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 10000001);\n\tmemset(cnt, 0, sizeof(int) * 10000001);\n\tfor (i = 0; i < intervalsSize; ++i) {\n\t\tfor (j = intervals[i][0]; j <= intervals[i][1]; ++j) {\n\t\t\tcnt[j]++;\n\t\t}\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 10000001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int minGroups(int** intervals, int intervalsSize, int* intervalsColSize"}
{"id": "1609", "path": "output2\\c\\Medium\\1609-maximum-matching-of-players-with-trainers.c", "hypo_code": "int matchPlayersAndTrainers(int* players, int playersSize, int* trainers, int trainersSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 1000000001);\n\tmemset(cnt, 0, sizeof(int) * 1000000001);\n\tfor (i = 0; i < playersSize; ++i) {\n\t\tcnt[players[i]]++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 1000000001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int matchPlayersAndTrainers(int* players, int playersSize, int* trainers, int trainersSize"}
{"id": "1610", "path": "output2\\c\\Medium\\1610-smallest-subarrays-with-maximum-bitwise-or.c", "hypo_code": "int* smallestSubarrays(int* nums, int numsSize, int* returnSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 1000000001);\n\tmemset(cnt, 0, sizeof(int) * 1000000001);\n\tfor (i = 0; i < numsSize; ++i) {\n\t\tcnt[nums[i]]++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 1000000001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tif (numsSize - max * 2 == 0) {\n\t\t*returnSize = numsSize;\n\t\treturn nums;\n\t}\n\t*returnSize = numsSize - max * 2;\n\tint *ret = (int *)malloc(sizeof(int) * (*returnSize));\n\tint idx = 0;\n\tfor (i = 0; i < numsSize; ++i) {\n\t\tif (cnt[nums[i]] == max) {\n\t\t\tret[idx++] = nums[i];\n\t\t}\n\t}\n\treturn ret;\n}", "prefix": "int* smallestSubarrays(int* nums, int numsSize, int* returnSize"}
{"id": "1611", "path": "output2\\c\\Medium\\1611-length-of-the-longest-alphabetical-continuous-substring.c", "hypo_code": "int longestContinuousSubstring(char * s){\nint i, j;\n\tint max = 0;\n\tint cnt = 1;\n\tfor (i = 1; i < strlen(s); ++i) {\n\t\tif (s[i] - s[i - 1] == 1) {\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tif (cnt > max) {\n\t\t\t\tmax = cnt;\n\t\t\t}\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tif (cnt > max) {\n\t\tmax = cnt;\n\t}\n\treturn max;\n}", "prefix": "int longestContinuousSubstring(char * s"}
{"id": "1612", "path": "output2\\c\\Medium\\1612-reverse-odd-levels-of-binary-tree.c", "hypo_code": "struct TreeNode* reverseOddLevels(struct TreeNode* root){ \nint i, j;\n\tstruct TreeNode **q = (struct TreeNode **)malloc(sizeof(struct TreeNode *) * 100001);\n\tint front = 0, rear = 0;\n\tq[rear++] = root;\n\twhile (front != rear) {\n\t\tint cnt = rear - front;\n\t\tint *arr = (int *)malloc(sizeof(int) * cnt);\n\t\tfor (i = 0; i < cnt; ++i) {\n\t\t\tstruct TreeNode *node = q[front++];\n\t\t\tarr[i] = node->val;\n\t\t\tif (node->left != NULL) {\n\t\t\t\tq[rear++] = node->left;\n\t\t\t}\n\t\t\tif (node->right != NULL) {\n\t\t\t\tq[rear++] = node->right;\n\t\t\t}\n\t\t}\n\t\tif (rear != 1) {\n\t\t\tfor (i = 0; i < cnt; ++i) {\n\t\t\t\tq[rear - 1 - i]->val = arr[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn root;\n}", "prefix": "struct TreeNode* reverseOddLevels(struct TreeNode* root"}
{"id": "1613", "path": "output2\\c\\Medium\\1613-longest-subarray-with-maximum-bitwise-and.c", "hypo_code": "int longestSubarray(int* nums, int numsSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 1000000001);\n\tmemset(cnt, 0, sizeof(int) * 1000000001);\n\tfor (i = 0; i < numsSize; ++i) {\n\t\tcnt[nums[i]]++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 1000000001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tif (numsSize - max * 2 == 0) {\n\t\treturn numsSize;\n\t}\n\treturn numsSize - max * 2;\n\n}", "prefix": "int longestSubarray(int* nums, int numsSize"}
{"id": "1614", "path": "output2\\c\\Medium\\1614-find-all-good-indices.c", "hypo_code": "int* goodIndices(int* nums, int numsSize, int k, int* returnSize){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 1000001);\n\tmemset(cnt, 0, sizeof(int) * 1000001);\n\tfor (i = 0; i < numsSize; ++i) {\n\t\tcnt[nums[i]]++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 1000001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tif (numsSize - max * 2 == 0) {\n\t\t*returnSize = numsSize;\n\t\treturn nums;\n\t}\n\t*returnSize = numsSize - max * 2;\n\tint *ret = (int *)malloc(sizeof(int) * (*returnSize));\n\tint idx = 0;\n\tfor (i = 0; i < numsSize; ++i) {\n\t\tif (cnt[nums[i]] == max) {\n\t\t\tret[idx++] = nums[i];\n\t\t}\n\t}\n\treturn ret;\n}", "prefix": "int* goodIndices(int* nums, int numsSize, int k, int* returnSize"}
{"id": "1616", "path": "output2\\c\\Medium\\1616-bitwise-xor-of-all-pairings.c", "hypo_code": "int xorAllNums(int* nums1, int nums1Size, int* nums2, int nums2Size){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 1000000001);\n\tmemset(cnt, 0, sizeof(int) * 1000000001);\n\tfor (i = 0; i < nums1Size; ++i) {\n\t\tcnt[nums1[i]]++;\n\t}\n\tfor (i = 0; i < nums2Size; ++i) {\n\t\tcnt[nums2[i]]++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 1000000001; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tif (nums1Size + nums2Size - max * 2 == 0) {\n\t\treturn nums1Size + nums2Size;\n\t}\n\treturn nums1Size + nums2Size - max * 2;\n}", "prefix": "int xorAllNums(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "1617", "path": "output2\\c\\Medium\\1617-maximum-sum-of-an-hourglass.c", "hypo_code": "int maxSum(int** grid, int gridSize, int* gridColSize){\nint i, j;\n\tint res = 0;\n\tfor (i = 0; i < gridSize - 2; ++i) {\n\t\tfor (j = 0; j < *gridColSize - 2; ++j) {\n\t\t\tint sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] \n\t\t\t\t+ grid[i + 1][j + 1] \n\t\t\t\t+ grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2];\n\t\t\tif (sum > res) {\n\t\t\t\tres = sum;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "prefix": "int maxSum(int** grid, int gridSize, int* gridColSize"}
{"id": "1618", "path": "output2\\c\\Medium\\1618-minimize-xor.c", "hypo_code": "int minimizeXor(int num1, int num2){\nint i, j;\n\tint n = num2;\n\tint cnt = 0;\n\twhile (n) {\n\t\tcnt += n & 1;\n\t\tn >>= 1;\n\t}\n\tint res = num2;\n\tfor (i = 0; i < 32; ++i) {\n\t\tif ((num1 & (1 << i)) == 0 && (num2 & (1 << i)) != 0) {\n\t\t\tif (cnt > 0) {\n\t\t\t\tcnt--;\n\t\t\t\tres |= 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "prefix": "int minimizeXor(int num1, int num2"}
{"id": "1619", "path": "output2\\c\\Medium\\1619-find-the-original-array-of-prefix-xor.c", "hypo_code": "int* findArray(int* pref, int prefSize, int* returnSize){\nint i, j;\n\t*returnSize = 0;\n\tint *res = (int *)malloc(sizeof(int) * prefSize);\n\tmemset(res, 0, sizeof(int) * prefSize);\n\tfor (i = 0; i < prefSize; ++i) {\n\t\tif (i == 0) {\n\t\t\tres[i] = pref[i];\n\t\t}\n\t\telse {\n\t\t\tres[i] = pref[i] ^ pref[i - 1];\n\t\t}\n\t}\n\tfor (i = 0; i < prefSize; ++i) {\n\t\t(*returnSize)++;\n\t}\n\treturn res;\n}", "prefix": "int* findArray(int* pref, int prefSize, int* returnSize"}
{"id": "1620", "path": "output2\\c\\Medium\\1620-using-a-robot-to-print-the-lexicographically-smallest-string.c", "hypo_code": "char * robotWithString(char * s){\nint i, j;\n\tint *cnt = (int *)malloc(sizeof(int) * 26);\n\tmemset(cnt, 0, sizeof(int) * 26);\n\tfor (i = 0; i < strlen(s); ++i) {\n\t\tcnt[s[i] - 'a']++;\n\t}\n\tint max = 0;\n\tfor (i = 0; i < 26; ++i) {\n\t\tif (cnt[i] > max) {\n\t\t\tmax = cnt[i];\n\t\t}\n\t}\n\tif (max - 1 <= k) {\n\t\treturn strlen(s);\n\t}\n\treturn max - 1 + k;\n}", "prefix": "char * robotWithString(char * s"}
{"id": "1621", "path": "output2\\c\\Medium\\1621-range-product-queries-of-powers.c", "hypo_code": "int* productQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nint i, j;\n\tint *res = (int *)malloc(sizeof(int) * queriesSize);\n\tfor (i = 0; i < queriesSize; ++i) {\n\t\tres[i] = 1;\n\t}\n\t*returnSize = queriesSize;\n\treturn res;\n}", "prefix": "int* productQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1622", "path": "output2\\c\\Medium\\1622-minimize-maximum-of-array.c", "hypo_code": "int minimizeArrayValue(int* nums, int numsSize){\n    int dp[numsSize];\n    for(int i=0;i<numsSize;i++){\n        dp[i] = 0;\n    }\n    for(int i=0;i<numsSize;i++){\n        if(nums[i] > 0){\n            dp[i] = nums[i];\n            if(i > 0){\n                dp[i] += dp[i-1];\n            }\n        }\n    }\n    int ans = INT_MAX;\n    for(int i=0;i<numsSize;i++){\n        ans = min(ans, dp[i]);\n    }\n    return ans;\n\n}", "prefix": "int minimizeArrayValue(int* nums, int numsSize"}
{"id": "1623", "path": "output2\\c\\Medium\\1623-count-number-of-distinct-integers-after-reverse-operations.c", "hypo_code": "int countDistinctIntegers(int* nums, int numsSize){\n    int i, j, k, count = 0, temp = 0, sum = 0;\n    for(i = 0; i < numsSize; i++){\n        sum = 0;\n        for(j = i; j < numsSize; j++){\n            temp = nums[j];\n            while(temp != 0){\n                sum = sum * 10 + temp % 10;\n                temp = temp / 10;\n            }\n            nums[j] = sum;\n            sum = 0;\n        }\n    }\n    for(i = 0; i < numsSize; i++){\n        for(j = i+1; j < numsSize; j++){\n            if(nums[i] == nums[j]){\n                count++;\n                break;\n            }\n        }\n    }\n    return numsSize - count;\n\n}", "prefix": "int countDistinctIntegers(int* nums, int numsSize"}
{"id": "1624", "path": "output2\\c\\Medium\\1624-sum-of-number-and-its-reverse.c", "hypo_code": "bool sumOfNumberAndReverse(int num){\n    int i, j, k, sum = 0, reverse = 0, temp = 0;\n    for(i = 0; i < num; i++){\n        temp = i;\n        reverse = 0;\n        while(temp != 0){\n            reverse = reverse * 10 + temp % 10;\n            temp = temp / 10;\n        }\n        sum = i + reverse;\n        if(sum == num){\n            return true;\n        }\n    }\n    return false;\n\n}", "prefix": "bool sumOfNumberAndReverse(int num"}
{"id": "1625", "path": "output2\\c\\Medium\\1625-number-of-subarrays-with-gcd-equal-to-k.c", "hypo_code": "int subarrayGCD(int* nums, int numsSize, int k){\n    int i, j, l, m, n, count = 0;\n    int arr[100000] = {0};\n    for(i = 0; i < numsSize; i++){\n        for(j = 0; j < 100000; j++){\n            if(nums[i] + j * k < 100000){\n                arr[nums[i] + j * k] = 1;\n            }\n        }\n    }\n    for(i = 0; i < 100000; i++){\n        if(arr[i] == 1){\n            count++;\n        }\n    }\n    return count;\n\n\n}", "prefix": "int subarrayGCD(int* nums, int numsSize, int k"}
{"id": "1626", "path": "output2\\c\\Medium\\1626-words-within-two-edits-of-dictionary.c", "hypo_code": "char ** twoEditWords(char ** queries, int queriesSize, char ** dictionary, int dictionarySize, int* returnSize){\n    char** arr = malloc(queriesSize * sizeof(char*));\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, count, count1, count2, count3, count4, count5, count6, count7, count8, count9, count10, count11, count12, count13, count14, count15, count16, count17, count18, count19, count20, count21, count22, count23, count24, count25, count26, count27, count28, count29, count30, count31, count32, count33, count34, count35, count36, count37, count38, count39, count40, count41, count42, count43, count44, count45, count46, count47, count48, count49, count50, count51, count52, count53, count54, count55, count56, count57, count58, count59, count60, count61, count62, count63, count64, count65, count66, count67, count68, count69, count70, count71, count72, count73, count74, count75, count76, count77, count78, count79, count80, count81, count82, count83, count84, count85, count86, count87, count88, count89, count90, count91, count92, count93, count94, count95, count96, count97, count98, count99, count100, count101, count102, count103, count104, count105, count106, count107, count108, count109, count110, count111, count112, count113, count114, count115, count116, count117, count118, count119, count120, count121, count122, count123, count124, count125, count126, count127, count128, count129, count130, count131, count132, count133, count134, count135, count136, count137, count138, count139, count140, count141, count142, count143, count144, count145, count146, count147, count148, count\n\n\n\n\n\n}", "prefix": "char ** twoEditWords(char ** queries, int queriesSize, char ** dictionary, int dictionarySize, int* returnSize"}
{"id": "1627", "path": "output2\\c\\Medium\\1627-destroy-sequential-targets.c", "hypo_code": "int destroyTargets(int* nums, int numsSize, int space){\n    int i, j;\n    int count = 0;\n    int max = 0;\n    int arr[100000] = {0};\n    for(i = 0; i < numsSize; i++){\n        for(j = 0; j < 100000; j++){\n            if(nums[i] + j * space < 100000){\n                arr[nums[i] + j * space] = 1;\n            }\n        }\n    }\n    for(i = 0; i < 100000; i++){\n        if(arr[i] == 1){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int destroyTargets(int* nums, int numsSize, int space"}
{"id": "1628", "path": "output2\\c\\Medium\\1628-most-popular-video-creator.c", "hypo_code": "char *** mostPopularCreator(char ** creators, int creatorsSize, char ** ids, int idsSize, int* views, int viewsSize, int* returnSize, int** returnColumnSizes){\n    char*** arr = malloc(creatorsSize * sizeof(char**));\n    int i, j, k, l;\n    int count = 0;\n    for(i = 0; i < creatorsSize; i++){\n        arr[i] = malloc(2 * sizeof(char*));\n        for(j = 0; j < 2; j++){\n            arr[i][j] = malloc(100 * sizeof(char));\n        }\n    }\n    for(i = 0; i < creatorsSize; i++){\n        for(j = i + 1; j < creatorsSize; j++){\n            if(strcmp(creators[i], creators[j]) == 0){\n                views[i] += views[j];\n                views[j] = 0;\n            }\n        }\n    }\n    for(i = 0; i < creatorsSize; i++){\n        for(j = i + 1; j < creatorsSize; j++){\n            if(views[i] < views[j]){\n                int temp = views[i];\n                views[i] = views[j];\n                views[j] = temp;\n                char* temp1 = creators[i];\n                creators[i] = creators[j];\n                creators[j] = temp1;\n                char* temp2 = ids[i];\n                ids[i] = ids[j];\n                ids[j] = temp2;\n            }\n        }\n    }\n    for(i = 0; i < creatorsSize; i++){\n        if(views[i] == 0){\n            break;\n        }\n        for(j = i + 1; j < creatorsSize; j++){\n            if(views[i] == views[j]){\n                for(k = 0; k < 100; k++){\n                    if(ids[i][k] < ids[j][k]){\n                        break;\n                    }\n                    else if(ids[i][k] > ids[j][k]){\n                        char* temp = ids[i];\n                        ids[i] = ids[j];\n                        ids[j] = temp;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for(i = 0; i < creatorsSize; i++){\n        if(views[i] == 0){\n            break;\n        }\n        for(j = i + 1; j < creatorsSize; j++){\n            if(views[i] == views[j]){\n                for(k = 0; k < 100; k++){\n                    if(creators[i][k] < creators[j][k]){\n                        break ;\n\n        \n        \n\n}", "prefix": "char *** mostPopularCreator(char ** creators, int creatorsSize, char ** ids, int idsSize, int* views, int viewsSize, int* returnSize, int** returnColumnSizes"}
{"id": "1629", "path": "output2\\c\\Medium\\1629-minimum-addition-to-make-integer-beautiful.c", "hypo_code": "long long makeIntegerBeautiful(long long n, int target){\n    int i;\n    int sum = 0;\n    int mod = 1000000007;\n    int count = 0;\n    int arr[10] = {0};\n    while(n > 0){\n        arr[count] = n % 10;\n        n = n / 10;\n        count++;\n    }\n    for(i = 0; i < count; i++){\n        sum += arr[i];\n    }\n    if(sum > target){\n        return 0;\n    }\n    else{\n        return target - sum;\n    }\n\n}", "prefix": "long long makeIntegerBeautiful(long long n, int target"}
{"id": "1630", "path": "output2\\c\\Medium\\1630-maximum-sum-of-distinct-subarrays-with-length-k.c", "hypo_code": "long long maximumSubarraySum(int* nums, int numsSize, int k){\n    long long sum = 0;\n    for(int i = 0; i < k; i++){\n        sum += nums[i];\n    }\n    long long maxSum = sum;\n    for(int i = k; i < numsSize; i++){\n        sum += nums[i] - nums[i - k];\n        maxSum = fmax(maxSum, sum);\n    }\n    return maxSum;\n\n}", "prefix": "long long maximumSubarraySum(int* nums, int numsSize, int k"}
{"id": "1631", "path": "output2\\c\\Medium\\1631-total-cost-to-hire-k-workers.c", "hypo_code": "long long totalCost(int* costs, int costsSize, int k, int candidates){\n    long long int i, j, k, count = 0;\n    int temp;\n    for(i = 0; i < costsSize - 1; i++){\n        for(j = i + 1; j < costsSize; j++){\n            if(costs[i] > costs[j]){\n                temp = costs[i];\n                costs[i] = costs[j];\n                costs[j] = temp;\n            }\n        }\n    }\n    for(i = 0; i < k; i++){\n        count += costs[i];\n    }\n    return count;\n\n}", "prefix": "long long totalCost(int* costs, int costsSize, int k, int candidates"}
{"id": "1632", "path": "output2\\c\\Medium\\1632-count-ways-to-build-good-strings.c", "hypo_code": "int countGoodStrings(int low, int high, int zero, int one){\n    int count = 0;\n    int* arr = (int*)malloc(sizeof(int) * high);\n    for(int i = 0; i < high; i++){\n        arr[i] = 0;\n    }\n    countGoodStringsHelper(low, high, zero, one, arr, &count);\n    return count;\n\n\n}", "prefix": "int countGoodStrings(int low, int high, int zero, int one"}
{"id": "1633", "path": "output2\\c\\Medium\\1633-most-profitable-path-in-a-tree.c", "hypo_code": "int mostProfitablePath(int** edges, int edgesSize, int* edgesColSize, int bob, int* amount, int amountSize){\n    int* dp = (int*)malloc(sizeof(int) * amountSize);\n    int* dp2 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp3 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp4 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp5 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp6 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp7 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp8 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp9 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp10 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp11 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp12 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp13 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp14 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp15 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp16 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp17 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp18 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp19 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp20 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp21 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp22 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp23 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp24 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp25 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp26 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp27 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp28 = (int*)malloc(sizeof(int) * amountSize);\n    int* dp29 = (int*)malloc(sizeof(int) * amountSize);\n    \n\n}", "prefix": "int mostProfitablePath(int** edges, int edgesSize, int* edgesColSize, int bob, int* amount, int amountSize"}
{"id": "1634", "path": "output2\\c\\Medium\\1634-number-of-subarrays-with-lcm-equal-to-k.c", "hypo_code": "int subarrayLCM(int* nums, int numsSize, int k){\n    int count = 0;\n    int start = 0;\n    int end = 0;\n    int lcm = 1;\n    while(end < numsSize){\n        lcm = lcm * nums[end] / gcd(lcm, nums[end]);\n        while(lcm > k){\n            lcm = lcm / nums[start];\n            start++;\n        }\n        if(lcm == k){\n            count++;\n        }\n        end++;\n    }\n    return count;\n\n}", "prefix": "int subarrayLCM(int* nums, int numsSize, int k"}
{"id": "1635", "path": "output2\\c\\Medium\\1635-minimum-number-of-operations-to-sort-a-binary-tree-by-level.c", "hypo_code": "int minimumOperations(struct TreeNode* root){\n    int i, j, k, n = 0, *arr = malloc(10000 * sizeof(int));\n    struct TreeNode *temp = root;\n    while(temp != NULL){\n        arr[n++] = temp->val;\n        temp = temp->left;\n    }\n    for(i = 0; i < n; i++){\n        for(j = i + 1; j < n; j++){\n            if(arr[i] > arr[j]){\n                k = arr[i];\n                arr[i] = arr[j];\n                arr[j] = k;\n            }\n        }\n    }\n    struct TreeNode* newNode(int val){\n        struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        node->val = val;\n        node->left = NULL;\n        node->right = NULL;\n        return node;\n    }\n    struct TreeNode* build(int l, int r){\n        if(l > r){\n            return NULL;\n        }\n        int mid = (l + r) / 2;\n        struct TreeNode* root = newNode(arr[mid]);\n        root->left = build(l, mid - 1);\n        root->right = build(mid + 1, r);\n        return root;\n    }\n    return build(0, n - 1);\n\n}", "prefix": "int minimumOperations(struct TreeNode* root"}
{"id": "1636", "path": "output2\\c\\Medium\\1636-closest-nodes-queries-in-a-binary-search-tree.c", "hypo_code": "int** closestNodes(struct TreeNode* root, int* queries, int queriesSize, int* returnSize, int** returnColumnSizes){\n    int i, j, k, l, m, n, count = 0, **result;\n    int *row, *col;\n    row = (int*)malloc(gridSize * sizeof(int));\n    col = (int*)malloc(gridColSize[0] * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        row[i] = 0;\n        for(j = 0; j < gridColSize[0]; j++){\n            if(grid[i][j] == 1){\n                row[i]++;\n            }\n        }\n    }\n    for(i = 0; i < gridColSize[0]; i++){\n        col[i] = 0;\n        for(j = 0; j < gridSize; j++){\n            if(grid[j][i] == 1){\n                col[i]++;\n            }\n        }\n    }\n    result = (int**)malloc(gridSize * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(gridSize * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        result[i] = (int*)malloc(gridColSize[0] * sizeof(int));\n        (*returnColumnSizes)[i] = gridColSize[0];\n        for(j = 0; j < gridColSize[0]; j++){\n            result[i][j] = row[i] + col[j];\n            if(grid[i][j] == 1){\n                result[i][j] -= 2;\n            }\n        }\n    }\n    *returnSize = gridSize;\n    return result;\n\n}", "prefix": "int** closestNodes(struct TreeNode* root, int* queries, int queriesSize, int* returnSize, int** returnColumnSizes"}
{"id": "1637", "path": "output2\\c\\Medium\\1637-minimum-fuel-cost-to-report-to-the-capital.c", "hypo_code": "long long minimumFuelCost(int** roads, int roadsSize, int* roadsColSize, int seats){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    long long min = 0;\n    return min;\n\n}", "prefix": "long long minimumFuelCost(int** roads, int roadsSize, int* roadsColSize, int seats"}
{"id": "1638", "path": "output2\\c\\Medium\\1638-difference-between-ones-and-zeros-in-row-and-column.c", "hypo_code": "int** onesMinusZeros(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){\n    int i, j, k, l, m, n, count = 0, **result;\n    int *row, *col;\n    row = (int*)malloc(gridSize * sizeof(int));\n    col = (int*)malloc(gridColSize[0] * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        row[i] = 0;\n        for(j = 0; j < gridColSize[0]; j++){\n            if(grid[i][j] == 1){\n                row[i]++;\n            }\n        }\n    }\n    for(i = 0; i < gridColSize[0]; i++){\n        col[i] = 0;\n        for(j = 0; j < gridSize; j++){\n            if(grid[j][i] == 1){\n                col[i]++;\n            }\n        }\n    }\n    result = (int**)malloc(gridSize * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(gridSize * sizeof(int));\n    for(i = 0; i < gridSize; i++){\n        result[i] = (int*)malloc(gridColSize[0] * sizeof(int));\n        (*returnColumnSizes)[i] = gridColSize[0];\n        for(j = 0; j < gridColSize[0]; j++){\n            result[i][j] = row[i] + col[j];\n            if(grid[i][j] == 1){\n                result[i][j] -= 2;\n            }\n        }\n    }\n    *returnSize = gridSize;\n    return result;\n\n}", "prefix": "int** onesMinusZeros(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1639", "path": "output2\\c\\Medium\\1639-minimum-penalty-for-a-shop.c", "hypo_code": "int bestClosingTime(char * customers){\n    int length = strlen(customers);\n    int penalty = 0;\n    int minPenalty = 0;\n    int minPenaltyHour = 0;\n    for(int i = 0; i < length; i++){\n        if(customers[i] == 'N'){\n            penalty++;\n        }else{\n            penalty--;\n        }\n        if(penalty < minPenalty){\n            minPenalty = penalty;\n            minPenaltyHour = i + 1;\n        }\n    }\n    return minPenaltyHour;\n\n}", "prefix": "int bestClosingTime(char * customers"}
{"id": "1640", "path": "output2\\c\\Medium\\1640-append-characters-to-string-to-make-subsequence.c", "hypo_code": "int appendCharacters(char * s, char * t){\n    int length = strlen(t);\n    int index = 0;\n    for(int i = 0; i < length; i++){\n        while(s[index] != '\\0' && s[index] != t[i]){\n            index++;\n        }\n        if(s[index] == '\\0'){\n            return -1;\n        }\n        index++;\n    }\n    return index - length - 1;\n\n}", "prefix": "int appendCharacters(char * s, char * t"}
{"id": "1641", "path": "output2\\c\\Medium\\1641-remove-nodes-from-linked-list.c", "hypo_code": "struct ListNode* removeNodes(struct ListNode* head){\n    struct ListNode* result = NULL;\n    struct ListNode* resultTail = NULL;\n    struct ListNode* node = head;\n    while(node != NULL){\n        if(node->next == NULL || node->next->val <= node->val){\n            if(result == NULL){\n                result = node;\n                resultTail = node;\n            }else{\n                resultTail->next = node;\n                resultTail = node;\n            }\n        }\n        node = node->next;\n    }\n    if(resultTail != NULL){\n        resultTail->next = NULL;\n    }\n    return result;\n\n}", "prefix": "struct ListNode* removeNodes(struct ListNode* head"}
{"id": "1642", "path": "output2\\c\\Medium\\1642-divide-players-into-teams-of-equal-skill.c", "hypo_code": "long long dividePlayers(int* skill, int skillSize){\n    long long sum = 0;\n    for(int i = 0; i < skillSize; i++){\n        sum += skill[i];\n    }\n    if(sum % skillSize != 0){\n        return -1;\n    }\n    long long target = sum / skillSize;\n    long long result = 0;\n    for(int i = 0; i < skillSize; i++){\n        if(skill[i] < target){\n            result += target - skill[i];\n        }\n    }\n    return result;\n\n}", "prefix": "long long dividePlayers(int* skill, int skillSize"}
{"id": "1643", "path": "output2\\c\\Medium\\1643-minimum-score-of-a-path-between-two-cities.c", "hypo_code": "int minScore(int n, int** roads, int roadsSize, int* roadsColSize){\n    int** dp = (int**)malloc(sizeof(int*) * n);\n    for(int i = 0; i < n; i++){\n        dp[i] = (int*)malloc(sizeof(int) * n);\n        for(int j = 0; j < n; j++){\n            dp[i][j] = 1000000;\n        }\n    }\n    for(int i = 0; i < roadsSize; i++){\n        dp[roads[i][0] - 1][roads[i][1] - 1] = roads[i][2];\n        dp[roads[i][1] - 1][roads[i][0] - 1] = roads[i][2];\n    }\n    for(int i = 0; i < n; i++){\n        dp[i][i] = 0;\n    }\n    for(int k = 0; k < n; k++){\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(dp[i][j] > fmin(dp[i][k], dp[k][j])){\n                    dp[i][j] = fmin(dp[i][k], dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n - 1];\n\n}", "prefix": "int minScore(int n, int** roads, int roadsSize, int* roadsColSize"}
{"id": "1644", "path": "output2\\c\\Medium\\1644-maximum-star-sum-of-a-graph.c", "hypo_code": "int maxStarSum(int* vals, int valsSize, int** edges, int edgesSize, int* edgesColSize, int k){\n    int result = 0;\n    int dp[valsSize];\n    for(int i = 0; i < valsSize; i++){\n        dp[i] = 0;\n    }\n    for(int i = 1; i < valsSize; i++){\n        for(int j = 0; j < i; j++){\n            if(vals[i] == vals[j] * vals[j]){\n                dp[i] = dp[j] + 1;\n                result = result > dp[i] ? result : dp[i];\n            }\n        }\n    }\n    return result == 0 ? -1 : result + 1;\n\n}", "prefix": "int maxStarSum(int* vals, int valsSize, int** edges, int edgesSize, int* edgesColSize, int k"}
{"id": "1645", "path": "output2\\c\\Medium\\1645-frog-jump-ii.c", "hypo_code": "int maxJump(int* stones, int stonesSize){\n    int result = 0;\n    for(int i = 1; i < stonesSize; i++){\n        result = result > stones[i] - stones[i - 1] ? result : stones[i] - stones[i - 1];\n    }\n    return result;\n\n}", "prefix": "int maxJump(int* stones, int stonesSize"}
{"id": "1646", "path": "output2\\c\\Medium\\1646-longest-square-streak-in-an-array.c", "hypo_code": "int longestSquareStreak(int* nums, int numsSize){\n    int result = 0;\n    int dp[numsSize];\n    for(int i = 0; i < numsSize; i++){\n        dp[i] = 0;\n    }\n    for(int i = 1; i < numsSize; i++){\n        for(int j = 0; j < i; j++){\n            if(nums[i] == nums[j] * nums[j]){\n                dp[i] = dp[j] + 1;\n                result = result > dp[i] ? result : dp[i];\n            }\n        }\n    }\n    return result == 0 ? -1 : result + 1;\n\n}", "prefix": "int longestSquareStreak(int* nums, int numsSize"}
{"id": "1648", "path": "output2\\c\\Medium\\1648-smallest-value-after-replacing-with-sum-of-prime-factors.c", "hypo_code": "int smallestValue(int n){\n    int* prime = (int*)malloc(sizeof(int) * n);\n    for(int i = 0; i < n; i++){\n        prime[i] = 1;\n    }\n    for(int i = 2; i < n; i++){\n        if(prime[i] == 1){\n            for(int j = i * 2; j < n; j += i){\n                prime[j] = 0;\n            }\n        }\n    }\n    int* sum = (int*)malloc(sizeof(int) * n);\n    for(int i = 0; i < n; i++){\n        sum[i] = 0;\n    }\n    for(int i = 2; i < n; i++){\n        if(prime[i] == 1){\n            for(int j = i; j < n; j += i){\n                sum[j] += i;\n            }\n        }\n    }\n    return sum[n - 1];\n\n}", "prefix": "int smallestValue(int n"}
{"id": "1649", "path": "output2\\c\\Medium\\1649-reward-top-k-students.c", "hypo_code": "int* topStudents(char ** positive_feedback, int positive_feedbackSize, char ** negative_feedback, int negative_feedbackSize, char ** report, int reportSize, int* student_id, int student_idSize, int k, int* returnSize){\n    int* answer = (int*)malloc(sizeof(int) * k);\n    int i = 0;\n    int j = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n}", "prefix": "int* topStudents(char ** positive_feedback, int positive_feedbackSize, char ** negative_feedback, int negative_feedbackSize, char ** report, int reportSize, int* student_id, int student_idSize, int k, int* returnSize"}
{"id": "1650", "path": "output2\\c\\Medium\\1650-minimize-the-maximum-of-two-arrays.c", "hypo_code": "int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2){\n    int result = 0;\n    int count1 = 0;\n    int count2 = 0;\n    int i = 1;\n    while(count1 < uniqueCnt1 || count2 < uniqueCnt2){\n        if(i % divisor1 != 0 && i % divisor2 != 0){\n            if(count1 < uniqueCnt1 && count2 < uniqueCnt2){\n                if(divisor1 < divisor2){\n                    result = i;\n                    count1++;\n                }\n                else{\n                    result = i;\n                    count2++;\n                }\n            }\n            else if(count1 < uniqueCnt1){\n                result = i;\n                count1++;\n            }\n            else{\n                result = i;\n                count2++;\n            }\n        }\n        i++;\n    }\n    return result;\n\n}", "prefix": "int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2"}
{"id": "1651", "path": "output2\\c\\Medium\\1651-take-k-of-each-character-from-left-and-right.c", "hypo_code": "int takeCharacters(char * s, int k){\n    int aCount = 0;\n    int bCount = 0;\n    int cCount = 0;\n    int left = 0;\n    int right = strlen(s) - 1;\n    while(left <= right){\n        if(s[left] == 'a'){\n            aCount++;\n        }else if(s[left] == 'b'){\n            bCount++;\n        }else{\n            cCount++;\n        }\n        if(s[right] == 'a'){\n            aCount++;\n        }else if(s[right] == 'b'){\n            bCount++;\n        }else{\n            cCount++;\n        }\n        if(aCount >= k && bCount >= k && cCount >= k){\n            return left + 1;\n        }\n        left++;\n        right--;\n    }\n    return -1;\n\n}", "prefix": "int takeCharacters(char * s, int k"}
{"id": "1652", "path": "output2\\c\\Medium\\1652-maximum-tastiness-of-candy-basket.c", "hypo_code": "int maximumTastiness(int* price, int priceSize, int k){\n    int** dp = (int**)malloc(sizeof(int*) * (k + 1));\n    for(int i = 0; i <= k; i++){\n        dp[i] = (int*)malloc(sizeof(int) * (priceSize + 1));\n        for(int j = 0; j <= priceSize; j++){\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 1; i <= k; i++){\n        for(int j = i; j <= priceSize; j++){\n            dp[i][j] = fmax(dp[i][j - 1], dp[i - 1][j - 1] + price[j - 1]);\n            for(int l = j - 2; l >= i - 1; l--){\n                dp[i][j] = fmax(dp[i][j], dp[i - 1][l] + price[j - 1] - price[l]);\n            }\n        }\n    }\n    return dp[k][priceSize];\n\n}", "prefix": "int maximumTastiness(int* price, int priceSize, int k"}
{"id": "1653", "path": "output2\\c\\Medium\\1653-distinct-prime-factors-of-product-of-array.c", "hypo_code": "int distinctPrimeFactors(int* nums, int numsSize){\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    int resultSize = 0;\n    for(int i = 0; i < numsSize; i++){\n        int num = nums[i];\n        for(int j = 2; j <= num; j++){\n            if(num % j == 0){\n                result[resultSize++] = j;\n                while(num % j == 0){\n                    num /= j;\n                }\n            }\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < resultSize; i++){\n        int j = 0;\n        for(; j < i; j++){\n            if(result[j] == result[i]){\n                break;\n            }\n        }\n        if(j == i){\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int distinctPrimeFactors(int* nums, int numsSize"}
{"id": "1654", "path": "output2\\c\\Medium\\1654-partition-string-into-substrings-with-values-at-most-k.c", "hypo_code": "int minimumPartition(char * s, int k){\n    int* result = (int*)malloc(sizeof(int) * (strlen(s) + 1));\n    result[0] = 0;\n    for(int i = 1; i <= strlen(s); i++){\n        result[i] = result[i - 1] + (s[i - 1] - '0');\n    }\n    int count = 0;\n    for(int i = 0; i < strlen(s); i++){\n        for(int j = i + 1; j <= strlen(s); j++){\n            if(result[j] - result[i] <= k){\n                count++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int minimumPartition(char * s, int k"}
{"id": "1655", "path": "output2\\c\\Medium\\1655-closest-prime-numbers-in-range.c", "hypo_code": "int* closestPrimes(int left, int right, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 2);\n    int resultSize = 0;\n    int minDiff = INT_MAX;\n    int minDiffNum1 = -1;\n    int minDiffNum2 = -1;\n    for(int i = left; i <= right; i++){\n        if(isPrime(i)){\n            for(int j = i + 1; j <= right; j++){\n                if(isPrime(j)){\n                    if(j - i < minDiff){\n                        minDiff = j - i;\n                        minDiffNum1 = i;\n                        minDiffNum2 = j;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    result[0] = minDiffNum1;\n    result[1] = minDiffNum2;\n    *returnSize = 2;\n    return result;\n\n}", "prefix": "int* closestPrimes(int left, int right, int* returnSize"}
{"id": "1657", "path": "output2\\c\\Medium\\1657-find-xor-beauty-of-array.c", "hypo_code": "int xorBeauty(int* nums, int numsSize){\n    int result = 0;\n    for(int i = 0; i < numsSize; i++){\n        for(int j = 0; j < numsSize; j++){\n            for(int k = 0; k < numsSize; k++){\n                result ^= (nums[i] | nums[j]) & nums[k];\n            }\n        }\n    }\n    return result;\n\n\n}", "prefix": "int xorBeauty(int* nums, int numsSize"}
{"id": "1658", "path": "output2\\c\\Medium\\1658-maximal-score-after-applying-k-operations.c", "hypo_code": "long long maxKelements(int* nums, int numsSize, int k){\n    long long result = 0;\n    for(int i = 0; i < k; i++){\n        result += nums[i];\n    }\n    long long sum = result;\n    for(int i = k; i < numsSize; i++){\n        sum += nums[i];\n        sum -= nums[i - k];\n        if(sum > result){\n            result = sum;\n        }\n    }\n    return result;\n\n}", "prefix": "long long maxKelements(int* nums, int numsSize, int k"}
{"id": "1659", "path": "output2\\c\\Medium\\1659-make-number-of-distinct-characters-equal.c", "hypo_code": "bool isItPossible(char * word1, char * word2){\n    int* hash1 = (int*)calloc(26, sizeof(int));\n    int* hash2 = (int*)calloc(26, sizeof(int));\n    for(int i = 0; i < strlen(word1); i++){\n        hash1[word1[i] - 'a']++;\n    }\n    for(int i = 0; i < strlen(word2); i++){\n        hash2[word2[i] - 'a']++;\n    }\n    int count1 = 0;\n    int count2 = 0;\n    for(int i = 0; i < 26; i++){\n        if(hash1[i] > 0){\n            count1++;\n        }\n        if(hash2[i] > 0){\n            count2++;\n        }\n    }\n    if(count1 == count2){\n        return true;\n    }\n    if(count1 > count2){\n        for(int i = 0; i < 26; i++){\n            if(hash1[i] > 0 && hash2[i] == 0){\n                return true;\n            }\n        }\n    }\n    if(count1 < count2){\n        for(int i = 0; i < 26; i++){\n            if(hash2[i] > 0 && hash1[i] == 0){\n                return true;\n            }\n        }\n    }\n    return false;\n\n}", "prefix": "bool isItPossible(char * word1, char * word2"}
{"id": "1660", "path": "output2\\c\\Medium\\1660-increment-submatrices-by-one.c", "hypo_code": "int** rangeAddQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * n);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * n);\n    for(int i = 0; i < n; i++){\n        result[i] = (int*)malloc(sizeof(int) * n);\n        (*returnColumnSizes)[i] = n;\n        for(int j = 0; j < n; j++){\n            result[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < queriesSize; i++){\n        for(int j = queries[i][0]; j <= queries[i][2]; j++){\n            for(int k = queries[i][1]; k <= queries[i][3]; k++){\n                result[j][k]++;\n            }\n        }\n    }\n    *returnSize = n;\n    return result;\n\n\n}", "prefix": "int** rangeAddQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1661", "path": "output2\\c\\Medium\\1661-count-the-number-of-good-subarrays.c", "hypo_code": "long long countGood(int* nums, int numsSize, int k){\n    int* result = (int*)malloc(sizeof(int) * (numsSize + 1));\n    result[0] = 0;\n    for(int i = 1; i <= numsSize; i++){\n        result[i] = result[i - 1] + (nums[i - 1] % 2);\n    }\n    long long count = 0;\n    for(int i = 0; i < numsSize; i++){\n        for(int j = i + 1; j <= numsSize; j++){\n            if(result[j] - result[i] >= k){\n                count++;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "long long countGood(int* nums, int numsSize, int k"}
{"id": "1662", "path": "output2\\c\\Medium\\1662-minimum-operations-to-make-array-equal-ii.c", "hypo_code": "long long minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size, int k){\n    long long sum1 = 0;\n    long long sum2 = 0;\n    for(int i = 0; i < nums1Size; i++){\n        sum1 += nums1[i];\n    }\n    for(int i = 0; i < nums2Size; i++){\n        sum2 += nums2[i];\n    }\n    if(sum1 == sum2){\n        return 0;\n    }\n    if(sum1 > sum2){\n        int* temp = nums1;\n        nums1 = nums2;\n        nums2 = temp;\n        int tempSize = nums1Size;\n        nums1Size = nums2Size;\n        nums2Size = tempSize;\n        long long tempSum = sum1;\n        sum1 = sum2;\n        sum2 = tempSum;\n    }\n    long long diff = sum2 - sum1;\n    if(diff > k * 5){\n        return -1;\n    }\n    int* nums1Count = (int*)malloc(sizeof(int) * 6);\n    int* nums2Count = (int*)malloc(sizeof(int) * 6);\n    for(int i = 0; i < 6; i++){\n        nums1Count[i] = 0;\n        nums2Count[i] = 0;\n    }\n    for(int i = 0; i < nums1Size; i++){\n        nums1Count[nums1[i] - 1]++;\n    }\n    for(int i = 0; i < nums2Size; i++){\n        nums2Count[nums2[i] - 1]++;\n    }\n    int* nums1CountSum = (int*)malloc(sizeof(int) * 6);\n    int* nums2CountSum = (int*)malloc(sizeof(int) * 6);\n    nums1CountSum[0] = nums1Count[0];\n    nums2CountSum[0] = nums2Count[0];\n    for(int i = 1; i < 6; i++){\n        nums1CountSum[i] = nums1CountSum[i - 1] + nums1Count[i];\n        nums2CountSum[i] = nums2CountSum[i - 1] + nums2Count[i];\n    }\n    int* nums1CountSumReverse = (int*)malloc(sizeof(int) * 6);\n    int* nums2CountSumReverse = (int*)malloc(sizeof(int) * 6);\n\n}", "prefix": "long long minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size, int k"}
{"id": "1663", "path": "output2\\c\\Medium\\1663-maximum-subsequence-score.c", "hypo_code": "long long maxScore(int* nums1, int nums1Size, int* nums2, int nums2Size, int k){\n    long long result = 0;\n    for(int i = 0; i <= k; i++){\n        if(i <= nums1Size && k - i <= nums2Size){\n            long long sum1 = 0;\n            long long sum2 = 0;\n            for(int j = 0; j < i; j++){\n                sum1 += nums1[j];\n            }\n            for(int j = 0; j < k - i; j++){\n                sum2 += nums2[j];\n            }\n            long long min = sum2;\n            for(int j = k - i; j < nums2Size; j++){\n                sum2 += nums2[j];\n                sum2 -= nums2[j - k + i];\n                if(sum2 < min){\n                    min = sum2;\n                }\n            }\n            if(sum1 * min > result){\n                result = sum1 * min;\n            }\n        }\n    }\n    return result;\n\n}", "prefix": "long long maxScore(int* nums1, int nums1Size, int* nums2, int nums2Size, int k"}
{"id": "1664", "path": "output2\\c\\Medium\\1664-sort-the-students-by-their-kth-score.c", "hypo_code": "int** sortTheStudents(int** score, int scoreSize, int* scoreColSize, int k, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n\n}", "prefix": "int** sortTheStudents(int** score, int scoreSize, int* scoreColSize, int k, int* returnSize, int** returnColumnSizes"}
{"id": "1665", "path": "output2\\c\\Medium\\1665-apply-bitwise-operations-to-make-strings-equal.c", "hypo_code": "bool makeStringsEqual(char * s, char * target){\n    int sLength = strlen(s);\n    int targetLength = strlen(target);\n    if(sLength != targetLength){\n        return false;\n    }\n    int sCount = 0;\n    int targetCount = 0;\n    for(int i = 0; i < sLength; i++){\n        sCount += s[i] - '0';\n        targetCount += target[i] - '0';\n    }\n    return sCount == targetCount;\n\n}", "prefix": "bool makeStringsEqual(char * s, char * target"}
{"id": "1666", "path": "output2\\c\\Medium\\1666-count-collisions-of-monkeys-on-a-polygon.c", "hypo_code": "int monkeyMove(int n){\n    int* result = (int*)malloc(sizeof(int) * n);\n    result[0] = 1;\n    result[1] = 1;\n    for(int i = 2; i < n; i++){\n        result[i] = (result[i-1] + result[i-2]) % 1000000007;\n    }\n    return result[n-1];\n\n}", "prefix": "int monkeyMove(int n"}
{"id": "1667", "path": "output2\\c\\Medium\\1667-maximum-number-of-integers-to-choose-from-a-range-i.c", "hypo_code": "int maxCount(int* banned, int bannedSize, int n, int maxSum){\n    int* count = (int*)calloc(n + 1, sizeof(int));\n    for(int i = 0; i < bannedSize; i++){\n        count[banned[i]] = -1;\n    }\n    count[0] = 0;\n    for(int i = 1; i <= n; i++){\n        if(count[i] == -1){\n            continue;\n        }\n        for(int j = 0; j < i; j++){\n            if(count[j] != -1 && count[j] + i <= maxSum){\n                if(count[i] == -1 || count[i] > count[j] + 1){\n                    count[i] = count[j] + 1;\n                }\n            }\n        }\n    }\n    return count[n];\n\n}", "prefix": "int maxCount(int* banned, int bannedSize, int n, int maxSum"}
{"id": "1668", "path": "output2\\c\\Medium\\1668-maximize-win-from-two-segments.c", "hypo_code": "int maximizeWin(int* prizePositions, int prizePositionsSize, int k){\n    int result = 0;\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < prizePositionsSize){\n        while(j < prizePositionsSize && prizePositions[j] - prizePositions[i] + 1 <= k){\n            j++;\n        }\n        count = j - i;\n        i++;\n        while(i < prizePositionsSize && prizePositions[i] == prizePositions[i - 1]){\n            i++;\n        }\n        count += j - i;\n        if(count > result){\n            result = count;\n        }\n    }\n    return result;\n\n}", "prefix": "int maximizeWin(int* prizePositions, int prizePositionsSize, int k"}
{"id": "1669", "path": "output2\\c\\Medium\\1669-disconnect-path-in-a-binary-matrix-by-at-most-one-flip.c", "hypo_code": "bool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize){\n    int* visited = (int*)calloc(gridSize * *gridColSize, sizeof(int));\n    int* queue = (int*)malloc(sizeof(int) * gridSize * *gridColSize);\n    int front = 0;\n    int rear = 0;\n    queue[rear++] = 0;\n    visited[0] = 1;\n    while(front != rear){\n        int x = queue[front] / *gridColSize;\n        int y = queue[front] % *gridColSize;\n        front++;\n        if(x == gridSize - 1 && y == *gridColSize - 1){\n            return false;\n        }\n        if(x + 1 < gridSize && grid[x + 1][y] == 1 && visited[(x + 1) * *gridColSize + y] == 0){\n            queue[rear++] = (x + 1) * *gridColSize + y;\n            visited[(x + 1) * *gridColSize + y] = 1;\n        }\n        if(y + 1 < *gridColSize && grid[x][y + 1] == 1 && visited[x * *gridColSize + y + 1] == 0){\n            queue[rear++] = x * *gridColSize + y + 1;\n            visited[x * *gridColSize + y + 1] = 1;\n        }\n    }\n    return true;\n\n}", "prefix": "bool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize"}
{"id": "1670", "path": "output2\\c\\Medium\\1670-count-vowel-strings-in-ranges.c", "hypo_code": "int* vowelStrings(char ** words, int wordsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int* ans = (int*)calloc(queriesSize, sizeof(int));\n    int* hash = (int*)calloc(wordsSize, sizeof(int));\n    for(int i = 0; i < queriesSize; i++){\n        int count = 0;\n        for(int j = queries[i][0]; j <= queries[i][1]; j++){\n            if(hash[j] == 0){\n                if(words[j][0] == 'a' || words[j][0] == 'e' || words[j][0] == 'i' || words[j][0] == 'o' || words[j][0] == 'u'){\n                    if(words[j][strlen(words[j]) - 1] == 'a' || words[j][strlen(words[j]) - 1] == 'e' || words[j][strlen(words[j]) - 1] == 'i' || words[j][strlen(words[j]) - 1] == 'o' || words[j][strlen(words[j]) - 1] == 'u'){\n                        count++;\n                        hash[j] = 1;\n                    }\n                }\n            }\n        }\n        ans[i] = count;\n    }\n    *returnSize = queriesSize;\n    return ans;\n\n}", "prefix": "int* vowelStrings(char ** words, int wordsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1671", "path": "output2\\c\\Medium\\1671-house-robber-iv.c", "hypo_code": "int minCapability(int* nums, int numsSize, int k){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int** result = NULL;\n    int* temp = NULL;\n    int* temp2 = NULL;\n    int* temp3 = NULL;\n    int* temp4 = NULL;\n    int* temp5 = NULL;\n    int* temp6 = NULL;\n    int* temp7 = NULL;\n    int* temp8 = NULL;\n    int* temp9 = NULL;\n    int* temp10 = NULL;\n    int* temp11 = NULL;\n    int* temp12 = NULL;\n    int* temp13 = NULL;\n    int* temp14 = NULL;\n    int* temp15 = NULL;\n    int* temp16 = NULL;\n    int* temp17 = NULL;\n    int* temp18 = NULL;\n    int* temp19 = NULL;\n    int* temp20 = NULL;\n    int* temp21 = NULL;\n    int* temp22 = NULL;\n    int* temp23 = NULL;\n    int* temp24 = NULL;\n    int* temp25 = NULL;\n    int* temp26 = NULL;\n    int* temp27 = NULL;\n    int* temp28 = NULL;\n    int* temp29 = NULL;\n    int* temp30 = NULL;\n    int* temp31 = NULL;\n    int* temp32 = NULL;\n    int* temp33 = NULL;\n    int* temp34 = NULL;\n    int* temp35 = NULL;\n    int* temp36 = NULL;\n    int* temp37 = NULL;\n    int* temp38 = NULL;\n    int* temp39 = NULL\n\n}", "prefix": "int minCapability(int* nums, int numsSize, int k"}
{"id": "1672", "path": "output2\\c\\Medium\\1672-count-the-number-of-fair-pairs.c", "hypo_code": "long long countFairPairs(int* nums, int numsSize, int lower, int upper){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] >= lower && dp[i] + dp[j] <= upper) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "long long countFairPairs(int* nums, int numsSize, int lower, int upper"}
{"id": "1673", "path": "output2\\c\\Medium\\1673-substring-xor-queries.c", "hypo_code": "int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){\nint i, j;\n\t*returnSize = queriesSize;\n\tint** result = (int**)malloc(sizeof(int*) * queriesSize);\n\t*returnColumnSizes = (int*)malloc(sizeof(int) * queriesSize);\n\tfor (i = 0; i < queriesSize; i++) {\n\t\t(*returnColumnSizes)[i] = 2;\n\t\tresult[i] = (int*)malloc(sizeof(int) * 2);\n\t\tresult[i][0] = -1;\n\t\tresult[i][1] = -1;\n\t}\n\tint* dp = (int*)malloc(sizeof(int) * (strlen(s) + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tdp[i + 1] = dp[i] ^ (s[i] - '0');\n\t}\n\tint len;\n\tfor (i = 0; i < queriesSize; i++) {\n\t\tfor (j = 0; j <= strlen(s); j++) {\n\t\t\tif (dp[j] == queries[i][1] ^ queries[i][0]) {\n\t\t\t\tif (result[i][0] == -1) {\n\t\t\t\t\tresult[i][0] = j;\n\t\t\t\t\tresult[i][1] = j;\n\t\t\t\t} else {\n\t\t\t\t\tresult[i][1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1674", "path": "output2\\c\\Medium\\1674-minimum-score-by-changing-two-elements.c", "hypo_code": "int minimizeSum(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (abs(dp[i] - dp[j]) < min) {\n\t\t\t\tmin = abs(dp[i] - dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minimizeSum(int* nums, int numsSize"}
{"id": "1675", "path": "output2\\c\\Medium\\1675-minimum-impossible-or.c", "hypo_code": "int minImpossibleOR(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] | dp[j] < min) {\n\t\t\t\tmin = dp[i] | dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minImpossibleOR(int* nums, int numsSize"}
{"id": "1676", "path": "output2\\c\\Medium\\1676-minimum-operations-to-reduce-an-integer-to-0.c", "hypo_code": "int minOperations(int n){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * n);\n\tfor (i = 0; i < n; i++) {\n\t\tdp[i] = n;\n\t}\n\tint min = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (dp[i] + dp[j] < min) {\n\t\t\t\tmin = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minOperations(int n"}
{"id": "1677", "path": "output2\\c\\Medium\\1677-count-the-number-of-square-free-subsets.c", "hypo_code": "int squareFreeSubsets(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] * dp[j] != 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int squareFreeSubsets(int* nums, int numsSize"}
{"id": "1678", "path": "output2\\c\\Medium\\1678-find-the-divisibility-array-of-a-string.c", "hypo_code": "int* divisibilityArray(char * word, int m, int* returnSize){\nint i, j;\n\t*returnSize = strlen(word);\n\tint* result = (int*)malloc(sizeof(int) * strlen(word));\n\tfor (i = 0; i < strlen(word); i++) {\n\t\tresult[i] = 0;\n\t}\n\tint* dp = (int*)malloc(sizeof(int) * (strlen(word) + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < strlen(word); i++) {\n\t\tdp[i + 1] = (dp[i] * 10 + (word[i] - '0')) % m;\n\t}\n\tfor (i = 0; i < strlen(word); i++) {\n\t\tif (dp[i + 1] == 0) {\n\t\t\tresult[i] = 1;\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int* divisibilityArray(char * word, int m, int* returnSize"}
{"id": "1679", "path": "output2\\c\\Medium\\1679-find-the-maximum-number-of-marked-indices.c", "hypo_code": "int maxNumOfMarkedIndices(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] <= dp[j]) {\n\t\t\t\tdp[j] = dp[i] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < numsSize; i++) {\n\t\tif (dp[i] > max) {\n\t\t\tmax = dp[i];\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int maxNumOfMarkedIndices(int* nums, int numsSize"}
{"id": "1680", "path": "output2\\c\\Medium\\1680-count-total-number-of-colored-cells.c", "hypo_code": "long long coloredCells(int n){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * n);\n\tfor (i = 0; i < n; i++) {\n\t\tdp[i] = n;\n\t}\n\tint count = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (dp[i] == 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "long long coloredCells(int n"}
{"id": "1681", "path": "output2\\c\\Medium\\1681-count-ways-to-group-overlapping-ranges.c", "hypo_code": "int countWays(int** ranges, int rangesSize, int* rangesColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * rangesSize);\n\tfor (i = 0; i < rangesSize; i++) {\n\t\tdp[i] = ranges[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < rangesSize; i++) {\n\t\tfor (j = i + 1; j < rangesSize; j++) {\n\t\t\tif (dp[i] * dp[j] != 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int countWays(int** ranges, int rangesSize, int* rangesColSize"}
{"id": "1682", "path": "output2\\c\\Medium\\1682-kth-largest-sum-in-a-binary-tree.c", "hypo_code": "long long kthLargestLevelSum(struct TreeNode* root, int k){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * rootSize);\n\tfor (i = 0; i < rootSize; i++) {\n\t\tdp[i] = root[i];\n\t}\n\tint sum = 0;\n\tfor (i = 0; i < rootSize; i++) {\n\t\tfor (j = i + 1; j < rootSize; j++) {\n\t\t\tif (dp[i] + dp[j] >= lower && dp[i] + dp[j] <= upper) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "prefix": "long long kthLargestLevelSum(struct TreeNode* root, int k"}
{"id": "1683", "path": "output2\\c\\Medium\\1683-rearrange-array-to-maximize-prefix-score.c", "hypo_code": "int maxScore(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] > max) {\n\t\t\t\tmax = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n\n}", "prefix": "int maxScore(int* nums, int numsSize"}
{"id": "1684", "path": "output2\\c\\Medium\\1684-count-the-number-of-beautiful-subarrays.c", "hypo_code": "long long beautifulSubarrays(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "long long beautifulSubarrays(int* nums, int numsSize"}
{"id": "1685", "path": "output2\\c\\Medium\\1685-maximize-greatness-of-an-array.c", "hypo_code": "int maximizeGreatness(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] > dp[j]) {\n\t\t\t\tmax = dp[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int maximizeGreatness(int* nums, int numsSize"}
{"id": "1686", "path": "output2\\c\\Medium\\1686-find-score-of-an-array-after-marking-all-elements.c", "hypo_code": "long long findScore(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "long long findScore(int* nums, int numsSize"}
{"id": "1687", "path": "output2\\c\\Medium\\1687-minimum-time-to-repair-cars.c", "hypo_code": "long long repairCars(int* ranks, int ranksSize, int cars){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * ranksSize);\n\tfor (i = 0; i < ranksSize; i++) {\n\t\tdp[i] = ranks[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < ranksSize; i++) {\n\t\tfor (j = i + 1; j < ranksSize; j++) {\n\t\t\tif (dp[i] * dp[j] < min) {\n\t\t\t\tmin = dp[i] * dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "long long repairCars(int* ranks, int ranksSize, int cars"}
{"id": "1688", "path": "output2\\c\\Medium\\1688-check-knight-tour-configuration.c", "hypo_code": "bool checkValidGrid(int** grid, int gridSize, int* gridColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * gridSize);\n\tfor (i = 0; i < gridSize; i++) {\n\t\tdp[i] = grid[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < gridSize; i++) {\n\t\tfor (j = i + 1; j < gridSize; j++) {\n\t\t\tif (dp[i] + dp[j] >= lower && dp[i] + dp[j] <= upper) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "bool checkValidGrid(int** grid, int gridSize, int* gridColSize"}
{"id": "1689", "path": "output2\\c\\Medium\\1689-the-number-of-beautiful-subsets.c", "hypo_code": "int beautifulSubsets(int* nums, int numsSize, int k){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] - dp[j] == k) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int beautifulSubsets(int* nums, int numsSize, int k"}
{"id": "1690", "path": "output2\\c\\Medium\\1690-smallest-missing-non-negative-integer-after-operations.c", "hypo_code": "int findSmallestInteger(int* nums, int numsSize, int value){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tmin = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int findSmallestInteger(int* nums, int numsSize, int value"}
{"id": "1691", "path": "output2\\c\\Medium\\1691-prime-subtraction-operation.c", "hypo_code": "bool primeSubOperation(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "bool primeSubOperation(int* nums, int numsSize"}
{"id": "1692", "path": "output2\\c\\Medium\\1692-minimum-operations-to-make-all-array-elements-equal.c", "hypo_code": "long long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\nint i, j;\n\t*returnSize = queriesSize;\n\tlong long* result = (long long*)malloc(sizeof(long long) * queriesSize);\n\tfor (i = 0; i < queriesSize; i++) {\n\t\tresult[i] = 0;\n\t}\n\tint* dp = (int*)malloc(sizeof(int) * (numsSize + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i + 1] = dp[i] + nums[i];\n\t}\n\tfor (i = 0; i < queriesSize; i++) {\n\t\tfor (j = 0; j < numsSize; j++) {\n\t\t\tif (nums[j] < queries[i]) {\n\t\t\t\tresult[i] += queries[i] - nums[j];\n\t\t\t} else {\n\t\t\t\tresult[i] += (long long)(nums[j] - queries[i]) * (j + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "long long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize"}
{"id": "1693", "path": "output2\\c\\Medium\\1693-find-the-substring-with-maximum-cost.c", "hypo_code": "int maximumCostSubstring(char * s, char * chars, int* vals, int valsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * valsSize);\n\tfor (i = 0; i < valsSize; i++) {\n\t\tdp[i] = vals[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < valsSize; i++) {\n\t\tfor (j = i + 1; j < valsSize; j++) {\n\t\t\tif (dp[i] + dp[j] > max) {\n\t\t\t\tmax = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int maximumCostSubstring(char * s, char * chars, int* vals, int valsSize"}
{"id": "1694", "path": "output2\\c\\Medium\\1694-make-k-subarray-sums-equal.c", "hypo_code": "long long makeSubKSumEqual(int* arr, int arrSize, int k){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * arrSize);\n\tfor (i = 0; i < arrSize; i++) {\n\t\tdp[i] = arr[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < arrSize; i++) {\n\t\tfor (j = i + 1; j < arrSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "long long makeSubKSumEqual(int* arr, int arrSize, int k"}
{"id": "1695", "path": "output2\\c\\Medium\\1695-convert-an-array-into-a-2d-array-with-conditions.c", "hypo_code": "int** findMatrix(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\nint i, j;\n\t*returnSize = 0;\n\tint** result = (int**)malloc(sizeof(int*));\n\t*returnColumnSizes = (int*)malloc(sizeof(int));\n\tint* dp = (int*)malloc(sizeof(int) * (numsSize + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i + 1] = dp[i] ^ nums[i];\n\t}\n\tint len;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j <= numsSize; j++) {\n\t\t\tif (dp[i] == dp[j]) {\n\t\t\t\tlen = j - i;\n\t\t\t\tresult[*returnSize] = (int*)malloc(sizeof(int) * len);\n\t\t\t\t(*returnColumnSizes)[*returnSize] = len;\n\t\t\t\tfor (int k = 0; k < len; k++) {\n\t\t\t\t\tresult[*returnSize][k] = nums[i + k];\n\t\t\t\t}\n\t\t\t\t(*returnSize)++;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int** findMatrix(int* nums, int numsSize, int* returnSize, int** returnColumnSizes"}
{"id": "1696", "path": "output2\\c\\Medium\\1696-mice-and-cheese.c", "hypo_code": "int miceAndCheese(int* reward1, int reward1Size, int* reward2, int reward2Size, int k){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * reward1Size);\n\tfor (i = 0; i < reward1Size; i++) {\n\t\tdp[i] = reward1[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < reward1Size; i++) {\n\t\tfor (j = i + 1; j < reward1Size; j++) {\n\t\t\tif (dp[i] + dp[j] > max) {\n\t\t\t\tmax = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int miceAndCheese(int* reward1, int reward1Size, int* reward2, int reward2Size, int k"}
{"id": "1697", "path": "output2\\c\\Medium\\1697-sum-of-distances.c", "hypo_code": "long long* distance(int* nums, int numsSize, int* returnSize){\nint i, j;\n\t*returnSize = numsSize;\n\tlong long* result = (long long*)malloc(sizeof(long long) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tresult[i] = 0;\n\t}\n\tint* dp = (int*)malloc(sizeof(int) * (numsSize + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i + 1] = (dp[i] * 10 + (nums[i] - '0')) % m;\n\t}\n\tfor (i = 0; i < numsSize; i++) {\n\t\tif (dp[i + 1] == 0) {\n\t\t\tresult[i] = 1;\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "long long* distance(int* nums, int numsSize, int* returnSize"}
{"id": "1698", "path": "output2\\c\\Medium\\1698-minimize-the-maximum-difference-of-pairs.c", "hypo_code": "int minimizeMax(int* nums, int numsSize, int p){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (abs(dp[i] - dp[j]) < min) {\n\t\t\t\tmin = abs(dp[i] - dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minimizeMax(int* nums, int numsSize, int p"}
{"id": "1707", "path": "output2\\c\\Medium\\1707-find-the-score-of-all-prefixes-of-an-array.c", "hypo_code": "long long* findPrefixScore(int* nums, int numsSize, int* returnSize){\nint i, j;\n\t*returnSize = numsSize;\n\tlong long* result = (long long*)malloc(sizeof(long long) * numsSize);\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tfor (i = 0; i < numsSize; i++) {\n\t\tresult[i] = 0;\n\t}\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = 0; j <= i; j++) {\n\t\t\tif (dp[j] > result[i]) {\n\t\t\t\tresult[i] = dp[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < numsSize; i++) {\n\t\tresult[i] += dp[i];\n\t}\n\treturn result;\n}", "prefix": "long long* findPrefixScore(int* nums, int numsSize, int* returnSize"}
{"id": "1708", "path": "output2\\c\\Medium\\1708-cousins-in-binary-tree-ii.c", "hypo_code": "struct TreeNode* replaceValueInTree(struct TreeNode* root){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * rootSize);\n\tfor (i = 0; i < rootSize; i++) {\n\t\tdp[i] = root[i];\n\t}\n\tint sum = 0;\n\tfor (i = 0; i < rootSize; i++) {\n\t\tfor (j = i + 1; j < rootSize; j++) {\n\t\t\tif (dp[i] + dp[j] >= lower && dp[i] + dp[j] <= upper) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "prefix": "struct TreeNode* replaceValueInTree(struct TreeNode* root"}
{"id": "1709", "path": "output2\\c\\Medium\\1709-minimum-additions-to-make-valid-string.c", "hypo_code": "int addMinimum(char * word){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * strlen(word));\n\tfor (i = 0; i < strlen(word); i++) {\n\t\tdp[i] = word[i] - 'a';\n\t}\n\tint count = 0;\n\tfor (i = 0; i < strlen(word); i++) {\n\t\tif (dp[i] == 0) {\n\t\t\tcount++;\n\t\t}\n\t\tif (dp[i] == 1) {\n\t\t\tcount++;\n\t\t}\n\t\tif (dp[i] == 2) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int addMinimum(char * word"}
{"id": "1711", "path": "output2\\c\\Medium\\1711-sliding-subarray-beauty.c", "hypo_code": "int* getSubarrayBeauty(int* nums, int numsSize, int k, int x, int* returnSize){\nint i, j;\n\t*returnSize = numsSize - k + 1;\n\tint* result = (int*)malloc(sizeof(int) * (*returnSize));\n\tfor (i = 0; i < *returnSize; i++) {\n\t\tresult[i] = 0;\n\t}\n\tint* dp = (int*)malloc(sizeof(int) * (numsSize + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i + 1] = dp[i] + nums[i];\n\t}\n\tfor (i = 0; i < *returnSize; i++) {\n\t\tfor (j = i + 1; j < i + k + 1; j++) {\n\t\t\tif (dp[j] - dp[i] <= x) {\n\t\t\t\tresult[i]++;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int* getSubarrayBeauty(int* nums, int numsSize, int k, int x, int* returnSize"}
{"id": "1712", "path": "output2\\c\\Medium\\1712-minimum-number-of-operations-to-make-all-array-elements-equal-to-1.c", "hypo_code": "int minOperations(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] < min) {\n\t\t\t\tmin = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minOperations(int* nums, int numsSize"}
{"id": "1713", "path": "output2\\c\\Medium\\1713-find-the-prefix-common-array-of-two-arrays.c", "hypo_code": "int* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\nint i, j;\n\t*returnSize = ASize;\n\tint* result = (int*)malloc(sizeof(int) * ASize);\n\tfor (i = 0; i < ASize; i++) {\n\t\tresult[i] = 0;\n\t}\n\tint* dp = (int*)malloc(sizeof(int) * (ASize + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < ASize; i++) {\n\t\tdp[i + 1] = (dp[i] * 10 + (word[i] - '0')) % m;\n\t}\n\tfor (i = 0; i < ASize; i++) {\n\t\tif (dp[i + 1] == 0) {\n\t\t\tresult[i] = 1;\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize"}
{"id": "1714", "path": "output2\\c\\Medium\\1714-maximum-number-of-fish-in-a-grid.c", "hypo_code": "int findMaxFish(int** grid, int gridSize, int* gridColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * gridSize);\n\tfor (i = 0; i < gridSize; i++) {\n\t\tdp[i] = grid[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < gridSize; i++) {\n\t\tfor (j = i + 1; j < gridSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int findMaxFish(int** grid, int gridSize, int* gridColSize"}
{"id": "1715", "path": "output2\\c\\Medium\\1715-first-completely-painted-row-or-column.c", "hypo_code": "int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * arrSize);\n\tfor (i = 0; i < arrSize; i++) {\n\t\tdp[i] = arr[i];\n\t}\n\tint index = 0;\n\tfor (i = 0; i < arrSize; i++) {\n\t\tfor (j = i + 1; j < arrSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn index;\n}", "prefix": "int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize"}
{"id": "1716", "path": "output2\\c\\Medium\\1716-minimum-cost-of-a-path-with-special-roads.c", "hypo_code": "int minimumCost(int* start, int startSize, int* target, int targetSize, int** specialRoads, int specialRoadsSize, int* specialRoadsColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * startSize);\n\tfor (i = 0; i < startSize; i++) {\n\t\tdp[i] = start[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < startSize; i++) {\n\t\tfor (j = i + 1; j < startSize; j++) {\n\t\t\tif (dp[i] + dp[j] < min) {\n\t\t\t\tmin = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minimumCost(int* start, int startSize, int* target, int targetSize, int** specialRoads, int specialRoadsSize, int* specialRoadsColSize"}
{"id": "1718", "path": "output2\\c\\Medium\\1718-number-of-adjacent-elements-with-the-same-color.c", "hypo_code": "int* colorTheArray(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nint i, j;\n\t*returnSize = queriesSize;\n\tint* result = (int*)malloc(sizeof(int) * queriesSize);\n\tfor (i = 0; i < queriesSize; i++) {\n\t\tresult[i] = 0;\n\t}\n\tint* dp = (int*)malloc(sizeof(int) * n);\n\tfor (i = 0; i < n; i++) {\n\t\tdp[i] = 0;\n\t}\n\tfor (i = 0; i < queriesSize; i++) {\n\t\tdp[queries[i][0]] = queries[i][1];\n\t\tfor (j = 0; j < n - 1; j++) {\n\t\t\tif (dp[j] == dp[j + 1] && dp[j] != 0) {\n\t\t\t\tresult[i]++;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n\n}", "prefix": "int* colorTheArray(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1719", "path": "output2\\c\\Medium\\1719-make-costs-of-paths-equal-in-a-binary-tree.c", "hypo_code": "int minIncrements(int n, int* cost, int costSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * costSize);\n\tfor (i = 0; i < costSize; i++) {\n\t\tdp[i] = cost[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < costSize; i++) {\n\t\tfor (j = i + 1; j < costSize; j++) {\n\t\t\tif (dp[i] + dp[j] < min) {\n\t\t\t\tmin = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minIncrements(int n, int* cost, int costSize"}
{"id": "1720", "path": "output2\\c\\Medium\\1720-sum-in-a-matrix.c", "hypo_code": "int matrixSum(int** nums, int numsSize, int* numsColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint sum = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tsum = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "prefix": "int matrixSum(int** nums, int numsSize, int* numsColSize"}
{"id": "1721", "path": "output2\\c\\Medium\\1721-maximum-or.c", "hypo_code": "long long maximumOr(int* nums, int numsSize, int k){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] | dp[j] > max) {\n\t\t\t\tmax = dp[i] | dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "long long maximumOr(int* nums, int numsSize, int k"}
{"id": "1722", "path": "output2\\c\\Medium\\1722-neighboring-bitwise-xor.c", "hypo_code": "bool doesValidArrayExist(int* derived, int derivedSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * derivedSize);\n\tfor (i = 0; i < derivedSize; i++) {\n\t\tdp[i] = derived[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < derivedSize; i++) {\n\t\tfor (j = i + 1; j < derivedSize; j++) {\n\t\t\tif (dp[i] ^ dp[j] == 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tif (count == derivedSize - 1) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "prefix": "bool doesValidArrayExist(int* derived, int derivedSize"}
{"id": "1723", "path": "output2\\c\\Medium\\1723-maximum-number-of-moves-in-a-grid.c", "hypo_code": "int maxMoves(int** grid, int gridSize, int* gridColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * gridSize);\n\tfor (i = 0; i < gridSize; i++) {\n\t\tdp[i] = grid[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < gridSize; i++) {\n\t\tfor (j = i + 1; j < gridSize; j++) {\n\t\t\tif (dp[i] + dp[j] >= lower && dp[i] + dp[j] <= upper) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int maxMoves(int** grid, int gridSize, int* gridColSize"}
{"id": "1724", "path": "output2\\c\\Medium\\1724-count-the-number-of-complete-components.c", "hypo_code": "int countCompleteComponents(int n, int** edges, int edgesSize, int* edgesColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * n);\n\tfor (i = 0; i < n; i++) {\n\t\tdp[i] = n;\n\t}\n\tint count = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (dp[i] == 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int countCompleteComponents(int n, int** edges, int edgesSize, int* edgesColSize"}
{"id": "1727", "path": "output2\\c\\Medium\\1727-find-the-punishment-number-of-an-integer.c", "hypo_code": "int punishmentNumber(int n){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * n);\n\tfor (i = 0; i < n; i++) {\n\t\tdp[i] = n;\n\t}\n\tint sum = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (dp[i] + dp[j] >= lower && dp[i] + dp[j] <= upper) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "prefix": "int punishmentNumber(int n"}
{"id": "1729", "path": "output2\\c\\Medium\\1729-extra-characters-in-a-string.c", "hypo_code": "int minExtraChar(char * s, char ** dictionary, int dictionarySize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * dictionarySize);\n\tfor (i = 0; i < dictionarySize; i++) {\n\t\tdp[i] = dictionary[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < dictionarySize; i++) {\n\t\tfor (j = i + 1; j < dictionarySize; j++) {\n\t\t\tif (dp[i] | dp[j] < min) {\n\t\t\t\tmin = dp[i] | dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n\n}", "prefix": "int minExtraChar(char * s, char ** dictionary, int dictionarySize"}
{"id": "1730", "path": "output2\\c\\Medium\\1730-maximum-strength-of-a-group.c", "hypo_code": "long long maxStrength(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] > dp[j]) {\n\t\t\t\tmax = dp[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "long long maxStrength(int* nums, int numsSize"}
{"id": "1731", "path": "output2\\c\\Medium\\1731-difference-of-number-of-distinct-values-on-diagonals.c", "hypo_code": "int** differenceOfDistinctValues(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){\nint i, j;\n\t*returnSize = gridSize;\n\t*returnColumnSizes = (int*)malloc(sizeof(int) * gridSize);\n\tfor (i = 0; i < gridSize; i++) {\n\t\t(*returnColumnSizes)[i] = gridColSize[i];\n\t}\n\tint** result = (int**)malloc(sizeof(int*) * gridSize);\n\tfor (i = 0; i < gridSize; i++) {\n\t\tresult[i] = (int*)malloc(sizeof(int) * gridColSize[i]);\n\t}\n\tint len;\n\tfor (i = 0; i < gridSize; i++) {\n\t\tfor (j = 0; j < gridColSize[i]; j++) {\n\t\t\tif (i == 0 || j == 0) {\n\t\t\t\tresult[i][j] = grid[i][j];\n\t\t\t} else {\n\t\t\t\tresult[i][j] = grid[i][j] - grid[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int** differenceOfDistinctValues(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1732", "path": "output2\\c\\Medium\\1732-minimum-cost-to-make-all-characters-equal.c", "hypo_code": "long long minimumCost(char * s){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * sSize);\n\tfor (i = 0; i < sSize; i++) {\n\t\tdp[i] = s[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < sSize; i++) {\n\t\tfor (j = i + 1; j < sSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tmin = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "long long minimumCost(char * s"}
{"id": "1733", "path": "output2\\c\\Medium\\1733-sum-of-matrix-after-queries.c", "hypo_code": "long long matrixSumQueries(int n, int** queries, int queriesSize, int* queriesColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * n);\n\tfor (i = 0; i < n; i++) {\n\t\tdp[i] = 0;\n\t}\n\tint sum = 0;\n\tfor (i = 0; i < queriesSize; i++) {\n\t\tif (queries[i][0] == 0) {\n\t\t\tfor (j = 0; j < queriesColSize[i]; j++) {\n\t\t\t\tdp[queries[i][j]] = queries[i][j];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (j = 0; j < queriesColSize[i]; j++) {\n\t\t\t\tdp[queries[i][j]] = queries[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tsum += dp[i];\n\t}\n\treturn sum;\n}", "prefix": "long long matrixSumQueries(int n, int** queries, int queriesSize, int* queriesColSize"}
{"id": "1736", "path": "output2\\c\\Medium\\1736-find-the-longest-semi-repetitive-substring.c", "hypo_code": "int longestSemiRepetitiveSubstring(char * s){\nint i, j;\n\tint len = strlen(s);\n\tint max = 0;\n\tint* dp = (int*)malloc(sizeof(int) * (strlen(s) + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tdp[i + 1] = dp[i] ^ (s[i] - '0');\n\t}\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tfor (j = i + 1; j < strlen(s); j++) {\n\t\t\tif (dp[j] == dp[i]) {\n\t\t\t\tif (j - i + 1 > max) {\n\t\t\t\t\tmax = j - i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int longestSemiRepetitiveSubstring(char * s"}
{"id": "1737", "path": "output2\\c\\Medium\\1737-movement-of-robots.c", "hypo_code": "int sumDistance(int* nums, int numsSize, char * s, int d){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint sum = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] >= lower && dp[i] + dp[j] <= upper) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "prefix": "int sumDistance(int* nums, int numsSize, char * s, int d"}
{"id": "1738", "path": "output2\\c\\Medium\\1738-lexicographically-smallest-string-after-substring-operation.c", "hypo_code": "char * smallestString(char * s){\nint i, j;\n\tchar* dp = (char*)malloc(sizeof(char) * (strlen(s) + 1));\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tdp[i] = s[i];\n\t}\n\tchar* result = (char*)malloc(sizeof(char) * (strlen(s) + 1));\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tresult[i] = s[i];\n\t}\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tfor (j = i + 1; j < strlen(s); j++) {\n\t\t\tif (dp[i] > dp[j]) {\n\t\t\t\tdp[i] = dp[j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tif (result[i] > dp[i]) {\n\t\t\tresult[i] = dp[i];\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "char * smallestString(char * s"}
{"id": "1739", "path": "output2\\c\\Medium\\1739-collecting-chocolates.c", "hypo_code": "long long minCost(int* nums, int numsSize, int x){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] < min) {\n\t\t\t\tmin = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "long long minCost(int* nums, int numsSize, int x"}
{"id": "1740", "path": "output2\\c\\Medium\\1740-find-the-value-of-the-partition.c", "hypo_code": "int findValueOfPartition(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (abs(dp[i] - dp[j]) < min) {\n\t\t\t\tmin = abs(dp[i] - dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int findValueOfPartition(int* nums, int numsSize"}
{"id": "1741", "path": "output2\\c\\Medium\\1741-special-permutations.c", "hypo_code": "int specialPerm(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] % dp[j] == 0 || dp[j] % dp[i] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int specialPerm(int* nums, int numsSize"}
{"id": "1742", "path": "output2\\c\\Medium\\1742-construct-the-longest-new-string.c", "hypo_code": "int longestString(int x, int y, int z){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * 3);\n\tdp[0] = x;\n\tdp[1] = y;\n\tdp[2] = z;\n\tint max = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tfor (j = i + 1; j < 3; j++) {\n\t\t\tif (dp[i] + dp[j] > max) {\n\t\t\t\tmax = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n\n}", "prefix": "int longestString(int x, int y, int z"}
{"id": "1743", "path": "output2\\c\\Medium\\1743-decremental-string-concatenation.c", "hypo_code": "int minimizeConcatenatedLength(char ** words, int wordsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * wordsSize);\n\tfor (i = 0; i < wordsSize; i++) {\n\t\tdp[i] = words[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < wordsSize; i++) {\n\t\tfor (j = i + 1; j < wordsSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tmin = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minimizeConcatenatedLength(char ** words, int wordsSize"}
{"id": "1744", "path": "output2\\c\\Medium\\1744-count-zero-request-servers.c", "hypo_code": "int* countServers(int n, int** logs, int logsSize, int* logsColSize, int x, int* queries, int queriesSize, int* returnSize){\nint i, j;\n\t*returnSize = queriesSize;\n\tint* result = (int*)malloc(sizeof(int) * queriesSize);\n\tfor (i = 0; i < queriesSize; i++) {\n\t\tresult[i] = 0;\n\t}\n\tint* dp = (int*)malloc(sizeof(int) * (n + 1));\n\tfor (i = 0; i < n; i++) {\n\t\tdp[i] = 0;\n\t}\n\tfor (i = 0; i < logsSize; i++) {\n\t\tif (logs[i][1] >= x) {\n\t\t\tdp[logs[i][0] - 1] = 1;\n\t\t}\n\t}\n\tfor (i = 0; i < queriesSize; i++) {\n\t\tfor (j = queries[i] - x; j <= queries[i]; j++) {\n\t\t\tif (dp[j - 1] == 0) {\n\t\t\t\tresult[i]++;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int* countServers(int n, int** logs, int logsSize, int* logsColSize, int x, int* queries, int queriesSize, int* returnSize"}
{"id": "1745", "path": "output2\\c\\Medium\\1745-minimum-operations-to-make-the-integer-zero.c", "hypo_code": "int makeTheIntegerZero(int num1, int num2){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * num1);\n\tfor (i = 0; i < num1; i++) {\n\t\tdp[i] = num1;\n\t}\n\tint min = 0;\n\tfor (i = 0; i < num1; i++) {\n\t\tfor (j = i + 1; j < num1; j++) {\n\t\t\tif (dp[i] + dp[j] < min) {\n\t\t\t\tmin = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int makeTheIntegerZero(int num1, int num2"}
{"id": "1746", "path": "output2\\c\\Medium\\1746-ways-to-split-array-into-good-subarrays.c", "hypo_code": "int numberOfGoodSubarraySplits(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int numberOfGoodSubarraySplits(int* nums, int numsSize"}
{"id": "1747", "path": "output2\\c\\Medium\\1747-prime-pairs-with-target-sum.c", "hypo_code": "int** findPrimePairs(int n, int* returnSize, int** returnColumnSizes){\nint i, j;\n\t*returnSize = 0;\n\tint** result = (int**)malloc(sizeof(int*) * n);\n\t*returnColumnSizes = (int*)malloc(sizeof(int) * n);\n\tfor (i = 0; i < n; i++) {\n\t\t(*returnColumnSizes)[i] = 2;\n\t\tresult[i] = (int*)malloc(sizeof(int) * 2);\n\t}\n\tint* primes = (int*)malloc(sizeof(int) * (n + 1));\n\tfor (i = 0; i <= n; i++) {\n\t\tprimes[i] = 0;\n\t}\n\tfor (i = 2; i <= n; i++) {\n\t\tif (primes[i] == 0) {\n\t\t\tfor (j = i * 2; j <= n; j += i) {\n\t\t\t\tprimes[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 2; i <= n; i++) {\n\t\tif (primes[i] == 0 && primes[n - i] == 0) {\n\t\t\tresult[*returnSize][0] = i;\n\t\t\tresult[*returnSize][1] = n - i;\n\t\t\t(*returnSize)++;\n\t\t}\n\t}\n\t*returnSize = (*returnSize) / 2;\n\treturn result;\n}", "prefix": "int** findPrimePairs(int n, int* returnSize, int** returnColumnSizes"}
{"id": "1748", "path": "output2\\c\\Medium\\1748-continuous-subarrays.c", "hypo_code": "long long continuousSubarrays(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "long long continuousSubarrays(int* nums, int numsSize"}
{"id": "1749", "path": "output2\\c\\Medium\\1749-relocate-marbles.c", "hypo_code": "int* relocateMarbles(int* nums, int numsSize, int* moveFrom, int moveFromSize, int* moveTo, int moveToSize, int* returnSize){\nint i, j;\n\t*returnSize = numsSize;\n\tint* result = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tresult[i] = nums[i];\n\t}\n\tint* dp = (int*)malloc(sizeof(int) * (numsSize + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i + 1] = dp[i] + nums[i];\n\t}\n\tfor (i = 0; i < moveFromSize; i++) {\n\t\tresult[moveTo[i]] += result[moveFrom[i]];\n\t\tresult[moveFrom[i]] = 0;\n\t}\n\treturn result;\n}", "prefix": "int* relocateMarbles(int* nums, int numsSize, int* moveFrom, int moveFromSize, int* moveTo, int moveToSize, int* returnSize"}
{"id": "1750", "path": "output2\\c\\Medium\\1750-partition-string-into-minimum-beautiful-substrings.c", "hypo_code": "int minimumBeautifulSubstrings(char * s){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * strlen(s));\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tdp[i] = s[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tfor (j = i + 1; j < strlen(s); j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int minimumBeautifulSubstrings(char * s"}
{"id": "1751", "path": "output2\\c\\Medium\\1751-number-of-black-blocks.c", "hypo_code": "long long* countBlackBlocks(int m, int n, int** coordinates, int coordinatesSize, int* coordinatesColSize, int* returnSize){\nint i, j;\n\t*returnSize = 5;\n\tlong long* result = (long long*)malloc(sizeof(long long) * 5);\n\tfor (i = 0; i < 5; i++) {\n\t\tresult[i] = 0;\n\t}\n\tlong long* dp = (long long*)malloc(sizeof(long long) * (coordinatesSize + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < coordinatesSize; i++) {\n\t\tdp[i + 1] = (dp[i] * 10 + (coordinates[i] - '0')) % m;\n\t}\n\tfor (i = 0; i < coordinatesSize; i++) {\n\t\tif (dp[i + 1] == 0) {\n\t\t\tresult[i] = 1;\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "long long* countBlackBlocks(int m, int n, int** coordinates, int coordinatesSize, int* coordinatesColSize, int* returnSize"}
{"id": "1752", "path": "output2\\c\\Medium\\1752-maximum-number-of-jumps-to-reach-the-last-index.c", "hypo_code": "int maximumJumps(int* nums, int numsSize, int target){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] > dp[j]) {\n\t\t\t\tmax = dp[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int maximumJumps(int* nums, int numsSize, int target"}
{"id": "1753", "path": "output2\\c\\Medium\\1753-longest-non-decreasing-subarray-from-two-arrays.c", "hypo_code": "int maxNonDecreasingLength(int* nums1, int nums1Size, int* nums2, int nums2Size){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * nums1Size);\n\tfor (i = 0; i < nums1Size; i++) {\n\t\tdp[i] = nums1[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < nums1Size; i++) {\n\t\tfor (j = i + 1; j < nums1Size; j++) {\n\t\t\tif (dp[i] > dp[j]) {\n\t\t\t\tmax = dp[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int maxNonDecreasingLength(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "1754", "path": "output2\\c\\Medium\\1754-apply-operations-to-make-all-array-elements-equal-to-zero.c", "hypo_code": "bool checkArray(int* nums, int numsSize, int k){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "bool checkArray(int* nums, int numsSize, int k"}
{"id": "1755", "path": "output2\\c\\Medium\\1755-maximum-beauty-of-an-array-after-applying-operation.c", "hypo_code": "int maximumBeauty(int* nums, int numsSize, int k){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] > max) {\n\t\t\t\tmax = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int maximumBeauty(int* nums, int numsSize, int k"}
{"id": "1756", "path": "output2\\c\\Medium\\1756-minimum-index-of-a-valid-split.c", "hypo_code": "int minimumIndex(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] * 2 > numsSize && dp[j] * 2 > numsSize) {\n\t\t\t\tmin = dp[i] * 2 > numsSize && dp[j] * 2 > numsSize;\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minimumIndex(int* nums, int numsSize"}
{"id": "1757", "path": "output2\\c\\Medium\\1757-sort-vowels-in-a-string.c", "hypo_code": "char * sortVowels(char * s){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * strlen(s));\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tdp[i] = s[i];\n\t}\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tfor (j = i + 1; j < strlen(s); j++) {\n\t\t\tif (dp[i] > dp[j]) {\n\t\t\t\tint temp = dp[i];\n\t\t\t\tdp[i] = dp[j];\n\t\t\t\tdp[j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tchar* result = (char*)malloc(sizeof(char) * strlen(s));\n\tfor (i = 0; i < strlen(s); i++) {\n\t\tresult[i] = dp[i];\n\t}\n\treturn result;\n}", "prefix": "char * sortVowels(char * s"}
{"id": "1758", "path": "output2\\c\\Medium\\1758-visit-array-positions-to-maximize-score.c", "hypo_code": "long long maxScore(int* nums, int numsSize, int x){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] > max) {\n\t\t\t\tmax = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "long long maxScore(int* nums, int numsSize, int x"}
{"id": "1759", "path": "output2\\c\\Medium\\1759-ways-to-express-an-integer-as-sum-of-powers.c", "hypo_code": "int numberOfWays(int n, int x){\n\n}", "prefix": "int numberOfWays(int n, int x"}
{"id": "1760", "path": "output2\\c\\Medium\\1760-largest-element-in-an-array-after-merge-operations.c", "hypo_code": "long long maxArrayValue(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] > max) {\n\t\t\t\tmax = dp[i] + dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "long long maxArrayValue(int* nums, int numsSize"}
{"id": "1761", "path": "output2\\c\\Medium\\1761-count-complete-subarrays-in-an-array.c", "hypo_code": "int countCompleteSubarrays(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] * dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "int countCompleteSubarrays(int* nums, int numsSize"}
{"id": "1762", "path": "output2\\c\\Medium\\1762-shortest-string-that-contains-three-strings.c", "hypo_code": "char * minimumString(char * a, char * b, char * c){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * (strlen(a) + strlen(b) + strlen(c) + 1));\n\tdp[0] = 0;\n\tfor (i = 0; i < strlen(a); i++) {\n\t\tdp[i + 1] = dp[i] ^ (a[i] - '0');\n\t}\n\tfor (i = strlen(a); i < strlen(a) + strlen(b); i++) {\n\t\tdp[i + 1] = dp[i] ^ (b[i - strlen(a)] - '0');\n\t}\n\tfor (i = strlen(a) + strlen(b); i < strlen(a) + strlen(b) + strlen(c); i++) {\n\t\tdp[i + 1] = dp[i] ^ (c[i - strlen(a) - strlen(b)] - '0');\n\t}\n\tint len;\n\tfor (i = 0; i < strlen(a) + strlen(b) + strlen(c); i++) {\n\t\tfor (j = i + 1; j <= strlen(a) + strlen(b) + strlen(c); j++) {\n\t\t\tif (dp[i] == dp[j]) {\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tlen = j - i;\n\t\t\t\t} else {\n\t\t\t\t\tif (j - i < len) {\n\t\t\t\t\t\tlen = j - i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tchar* result = (char*)malloc(sizeof(char) * (len + 1));\n\tfor (i = 0; i < len; i++) {\n\t\tresult[i] = dp[i] + '0';\n\t}\n\tresult[len] = '\\0';\n\treturn result;\n}", "prefix": "char * minimumString(char * a, char * b, char * c"}
{"id": "1763", "path": "output2\\c\\Medium\\1763-insert-greatest-common-divisors-in-linked-list.c", "hypo_code": "struct ListNode* insertGreatestCommonDivisors(struct ListNode* head){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * headSize);\n\tfor (i = 0; i < headSize; i++) {\n\t\tdp[i] = head[i];\n\t}\n\tint sum = 0;\n\tfor (i = 0; i < headSize; i++) {\n\t\tfor (j = i + 1; j < headSize; j++) {\n\t\t\tif (dp[i] + dp[j] >= lower && dp[i] + dp[j] <= upper) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n\n}", "prefix": "struct ListNode* insertGreatestCommonDivisors(struct ListNode* head"}
{"id": "1764", "path": "output2\\c\\Medium\\1764-minimum-seconds-to-equalize-a-circular-array.c", "hypo_code": "int minimumSeconds(int* nums, int numsSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] | dp[j] < min) {\n\t\t\t\tmin = dp[i] | dp[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minimumSeconds(int* nums, int numsSize"}
{"id": "1765", "path": "output2\\c\\Medium\\1765-check-if-it-is-possible-to-split-array.c", "hypo_code": "bool canSplitArray(int* nums, int numsSize, int m){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint count = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (dp[i] + dp[j] == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "prefix": "bool canSplitArray(int* nums, int numsSize, int m"}
{"id": "1766", "path": "output2\\c\\Medium\\1766-find-the-safest-path-in-a-grid.c", "hypo_code": "int maximumSafenessFactor(int** grid, int gridSize, int* gridColSize){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * gridSize);\n\tfor (i = 0; i < gridSize; i++) {\n\t\tdp[i] = grid[i];\n\t}\n\tint max = 0;\n\tfor (i = 0; i < gridSize; i++) {\n\t\tfor (j = i + 1; j < gridSize; j++) {\n\t\t\tif (abs(dp[i] - dp[j]) > max) {\n\t\t\t\tmax = abs(dp[i] - dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "prefix": "int maximumSafenessFactor(int** grid, int gridSize, int* gridColSize"}
{"id": "1767", "path": "output2\\c\\Medium\\1767-double-a-number-represented-as-a-linked-list.c", "hypo_code": "struct ListNode* doubleIt(struct ListNode* head){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * headSize);\n\tfor (i = 0; i < headSize; i++) {\n\t\tdp[i] = head[i];\n\t}\n\tint sum = 0;\n\tfor (i = 0; i < headSize; i++) {\n\t\tfor (j = i + 1; j < headSize; j++) {\n\t\t\tif (dp[i] + dp[j] >= lower && dp[i] + dp[j] <= upper) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "prefix": "struct ListNode* doubleIt(struct ListNode* head"}
{"id": "1768", "path": "output2\\c\\Medium\\1768-minimum-absolute-difference-between-elements-with-constraint.c", "hypo_code": "int minAbsoluteDifference(int* nums, int numsSize, int x){\nint i, j;\n\tint* dp = (int*)malloc(sizeof(int) * numsSize);\n\tfor (i = 0; i < numsSize; i++) {\n\t\tdp[i] = nums[i];\n\t}\n\tint min = 0;\n\tfor (i = 0; i < numsSize; i++) {\n\t\tfor (j = i + 1; j < numsSize; j++) {\n\t\t\tif (abs(dp[i] - dp[j]) < min) {\n\t\t\t\tmin = abs(dp[i] - dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn min;\n}", "prefix": "int minAbsoluteDifference(int* nums, int numsSize, int x"}
{"id": "1769", "path": "output2\\c\\Hard\\1769-median-of-two-sorted-arrays.c", "hypo_code": "double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int i = 0, j = 0, k = 0;\n    int *arr = (int *)malloc((nums1Size + nums2Size) * sizeof(int));\n    while(i < nums1Size && j < nums2Size){\n        if(nums1[i] < nums2[j]){\n            arr[k++] = nums1[i++];\n        }else{\n            arr[k++] = nums2[j++];\n        }\n    }\n    while(i < nums1Size){\n        arr[k++] = nums1[i++];\n    }\n    while(j < nums2Size){\n        arr[k++] = nums2[j++];\n    }\n    if((nums1Size + nums2Size) % 2 == 0){\n        return (arr[(nums1Size + nums2Size) / 2] + arr[(nums1Size + nums2Size) / 2 - 1]) / 2.0;\n    }else{\n        return arr[(nums1Size + nums2Size) / 2];\n    }\n\n}", "prefix": "double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "1770", "path": "output2\\c\\Hard\\1770-regular-expression-matching.c", "hypo_code": "bool isMatch(char * s, char * p){\n    int i = 0, j = 0;\n    int sLen = strlen(s);\n    int pLen = strlen(p);\n    int **dp = (int **)malloc((sLen + 1) * sizeof(int *));\n    for(i = 0; i <= sLen; i++){\n        dp[i] = (int *)malloc((pLen + 1) * sizeof(int));\n    }\n    dp[0][0] = 1;\n    for(i = 1; i <= sLen; i++){\n        dp[i][0] = 0;\n    }\n    for(j = 1; j <= pLen; j++){\n        if(p[j - 1] == '*'){\n            dp[0][j] = dp[0][j - 2];\n        }else{\n            dp[0][j] = 0;\n        }\n    }\n    for(i = 1; i <= sLen; i++){\n        for(j = 1; j <= pLen; j++){\n            if(p[j - 1] == '*'){\n                if(p[j - 2] == s[i - 1] || p[j - 2] == '.'){\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 2];\n                }else{\n                    dp[i][j] = dp[i][j - 2];\n                }\n            }else if(p[j - 1] == s[i - 1] || p[j - 1] == '.'){\n                dp[i][j] = dp[i - 1][j - 1];\n            }else{\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return dp[sLen][pLen];\n\n}", "prefix": "bool isMatch(char * s, char * p"}
{"id": "1771", "path": "output2\\c\\Hard\\1771-merge-k-sorted-lists.c", "hypo_code": "struct ListNode* mergeKLists(struct ListNode** lists, int listsSize){\n    struct ListNode *head = NULL;\n    struct ListNode *tail = NULL;\n    int i = 0;\n    int minIndex = -1;\n    int minVal = 0;\n    int flag = 0;\n    while(1){\n        minIndex = -1;\n        minVal = 0;\n        flag = 0;\n        for(i = 0; i < listsSize; i++){\n            if(lists[i] != NULL){\n                if(flag == 0){\n                    minIndex = i;\n                    minVal = lists[i]->val;\n                    flag = 1;\n                }else{\n                    if(lists[i]->val < minVal){\n                        minIndex = i;\n                        minVal = lists[i]->val;\n                    }\n                }\n            }\n        }\n        if(minIndex == -1){\n            break;\n        }\n        if(head == NULL){\n            head = lists[minIndex];\n            tail = head;\n        }else{\n            tail->next = lists[minIndex];\n            tail = tail->next;\n        }\n        lists[minIndex] = lists[minIndex]->next;\n    }\n    return head;\n\n}", "prefix": "struct ListNode* mergeKLists(struct ListNode** lists, int listsSize"}
{"id": "1772", "path": "output2\\c\\Hard\\1772-reverse-nodes-in-k-group.c", "hypo_code": "struct ListNode* reverseKGroup(struct ListNode* head, int k){\n    struct ListNode *p = head;\n    struct ListNode *q = NULL;\n    struct ListNode *r = NULL;\n    struct ListNode *s = NULL;\n    struct ListNode *t = NULL;\n    struct ListNode *u = NULL;\n    int i = 0;\n    int j = 0;\n    int flag = 0;\n    int len = 0;\n    while(p != NULL){\n        len++;\n        p = p->next;\n    }\n    if(len < k){\n        return head;\n    }\n    p = head;\n    q = head;\n    r = head;\n    s = head;\n    t = head;\n    u = head;\n    for(i = 0; i < len / k; i++){\n        for(j = 0; j < k - 1; j++){\n            q = q->next;\n        }\n        r = q->next;\n        q->next = NULL;\n        s = p;\n        t = p->next;\n        while(t != NULL){\n            u = t->next;\n            t->next = s;\n            s = t;\n            t = u;\n        }\n        if(flag == 0){\n            head = s;\n            flag = 1;\n        }else{\n            p->next = s;\n        }\n        p = r;\n        q = r;\n    }\n    p->next = r;\n    return head;\n\n}", "prefix": "struct ListNode* reverseKGroup(struct ListNode* head, int k"}
{"id": "1773", "path": "output2\\c\\Hard\\1773-substring-with-concatenation-of-all-words.c", "hypo_code": "int* findSubstring(char * s, char ** words, int wordsSize, int* returnSize){\n    int i = 0, j = 0, k = 0;\n    int sLen = strlen(s);\n    int wLen = strlen(words[0]);\n    int *ret = (int *)malloc(sLen * sizeof(int));\n    int *flag = (int *)malloc(wordsSize * sizeof(int));\n    int *flag2 = (int *)malloc(wordsSize * sizeof(int));\n    int flag3 = 0;\n    int flag4 = 0;\n    int flag5 = 0;\n    int flag6 = 0;\n    int flag7 = 0;\n    int flag8 = 0;\n    int flag9 = 0;\n    int flag10 = 0;\n    int flag11 = 0;\n    int flag12 = 0;\n    int flag13 = 0;\n    int flag14 = 0;\n    int flag15 = 0;\n    int flag16 = 0;\n    int flag17 = 0;\n    int flag18 = 0;\n    int flag19 = 0;\n    int flag20 = 0;\n    int flag21 = 0;\n    int flag22 = 0;\n    int flag23 = 0;\n    int flag24 = 0;\n    int flag25 = 0;\n    int flag26 = 0;\n    int flag27 = 0;\n    int flag28 = 0;\n    int flag29 = 0;\n    int flag30 = 0;\n    int flag31 = 0;\n    int flag32 = 0;\n    int flag33 = 0;\n    int flag34 = 0;\n    int flag35 = 0;\n    int flag36 = 0;\n    int flag37 = 0;\n    int flag38 = 0;\n    int flag39 = 0;\n    int flag40 = 0;\n    int flag41 = 0;\n    int flag42 = 0;\n    int flag43 = 0;\n    int flag44 = 0;\n    int flag45 = 0;\n    int flag46 = 0;\n    int flag47 = 0;\n    int flag48 = 0;\n    int flag49 = 0;\n    int flag50 = 0;\n    int flag51 = 0;\n    int flag52 = 0;\n    int flag53 = 0;\n    int flag54 = 0;\n   \n\n}", "prefix": "int* findSubstring(char * s, char ** words, int wordsSize, int* returnSize"}
{"id": "1774", "path": "output2\\c\\Hard\\1774-longest-valid-parentheses.c", "hypo_code": "int longestValidParentheses(char * s){\n    int i = 0;\n    int j = 0;\n    int len = 0;\n    int maxLen = 0;\n    int *dp = (int *)malloc((strlen(s) + 1) * sizeof(int));\n    for(i = 0; i <= strlen(s); i++){\n        dp[i] = 0;\n    }\n    for(i = 1; i <= strlen(s); i++){\n        if(s[i - 1] == '('){\n            dp[i] = 0;\n        }else{\n            if(i - 2 >= 0 && s[i - 2] == '('){\n                dp[i] = dp[i - 2] + 2;\n            }else if(i - 2 >= 0 && s[i - 2] == ')'){\n                if(i - dp[i - 1] - 2 >= 0 && s[i - dp[i - 1] - 2] == '('){\n                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2];\n                }\n            }\n        }\n        if(dp[i] > maxLen){\n            maxLen = dp[i];\n        }\n    }\n    return maxLen;\n\n}", "prefix": "int longestValidParentheses(char * s"}
{"id": "1775", "path": "output2\\c\\Hard\\1775-sudoku-solver.c", "hypo_code": "void solveSudoku(char** board, int boardSize, int* boardColSize){\n    int i = 0, j = 0;\n    int **row = (int **)malloc(9 * sizeof(int *));\n    int **col = (int **)malloc(9 * sizeof(int *));\n    int **box = (int **)malloc(9 * sizeof(int *));\n    for(i = 0; i < 9; i++){\n        row[i] = (int *)malloc(9 * sizeof(int));\n        col[i] = (int *)malloc(9 * sizeof(int));\n        box[i] = (int *)malloc(9 * sizeof(int));\n    }\n    for(i = 0; i < 9; i++){\n        for(j = 0; j < 9; j++){\n            row[i][j] = 0;\n            col[i][j] = 0;\n            box[i][j] = 0;\n        }\n    }\n    for(i = 0; i < 9; i++){\n        for(j = 0; j < 9; j++){\n            if(board[i][j] != '.'){\n                row[i][board[i][j] - '1'] = 1;\n                col[j][board[i][j] - '1'] = 1;\n                box[i / 3 * 3 + j / 3][board[i][j] - '1'] = 1;\n            }\n        }\n    }\n    solveSudokuHelper(board, boardSize, boardColSize, row, col, box, 0, 0);\n\n}", "prefix": "void solveSudoku(char** board, int boardSize, int* boardColSize"}
{"id": "1776", "path": "output2\\c\\Hard\\1776-first-missing-positive.c", "hypo_code": "int firstMissingPositive(int* nums, int numsSize){\n    int i = 0;\n    int j = 0;\n    int temp = 0;\n    for(i = 0; i < numsSize; i++){\n        if(nums[i] <= 0){\n            nums[i] = numsSize + 1;\n        }\n    }\n    for(i = 0; i < numsSize; i++){\n        if(nums[i] > 0 && nums[i] <= numsSize){\n            temp = nums[i];\n            nums[i] = 0;\n            while(temp > 0 && temp <= numsSize && nums[temp - 1] != temp){\n                j = temp;\n                temp = nums[temp - 1];\n                nums[j - 1] = j;\n            }\n        }\n    }\n    for(i = 0; i < numsSize; i++){\n        if(nums[i] == 0){\n            return i + 1;\n        }\n    }\n    return numsSize + 1;\n\n}", "prefix": "int firstMissingPositive(int* nums, int numsSize"}
{"id": "1777", "path": "output2\\c\\Hard\\1777-trapping-rain-water.c", "hypo_code": "int trap(int* height, int heightSize){\n    int i = 0;\n    int j = 0;\n    int maxLeft = 0;\n    int maxRight = 0;\n    int sum = 0;\n    for(i = 1; i < heightSize - 1; i++){\n        maxLeft = 0;\n        maxRight = 0;\n        for(j = i; j >= 0; j--){\n            if(height[j] > maxLeft){\n                maxLeft = height[j];\n            }\n        }\n        for(j = i; j < heightSize; j++){\n            if(height[j] > maxRight){\n                maxRight = height[j];\n            }\n        }\n        if(maxLeft > height[i] && maxRight > height[i]){\n            sum += (maxLeft < maxRight ? maxLeft : maxRight) - height[i];\n        }\n    }\n    return sum;\n\n}", "prefix": "int trap(int* height, int heightSize"}
{"id": "1778", "path": "output2\\c\\Hard\\1778-wildcard-matching.c", "hypo_code": "bool isMatch(char * s, char * p){\n    int i = 0, j = 0;\n    int sLen = strlen(s);\n    int pLen = strlen(p);\n    int **dp = (int **)malloc((sLen + 1) * sizeof(int *));\n    for(i = 0; i <= sLen; i++){\n        dp[i] = (int *)malloc((pLen + 1) * sizeof(int));\n    }\n    dp[0][0] = 1;\n    for(i = 1; i <= sLen; i++){\n        dp[i][0] = 0;\n    }\n    for(j = 1; j <= pLen; j++){\n        if(p[j - 1] == '*'){\n            dp[0][j] = dp[0][j - 1];\n        }else{\n            dp[0][j] = 0;\n        }\n    }\n    for(i = 1; i <= sLen; i++){\n        for(j = 1; j <= pLen; j++){\n            if(p[j - 1] == '*'){\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n            }else if(p[j - 1] == s[i - 1] || p[j - 1] == '?'){\n                dp[i][j] = dp[i - 1][j - 1];\n            }else{\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return dp[sLen][pLen];\n\n}", "prefix": "bool isMatch(char * s, char * p"}
{"id": "1779", "path": "output2\\c\\Hard\\1779-n-queens.c", "hypo_code": "char *** solveNQueens(int n, int* returnSize, int** returnColumnSizes){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int flag = 0;\n    int flag2 = 0;\n    int flag3 = 0;\n    int flag4 = 0;\n    int flag5 = 0;\n    int flag6 = 0;\n    int flag7 = 0;\n    int flag8 = 0;\n    int flag9 = 0;\n    int flag10 = 0;\n    int flag11 = 0;\n    int flag12 = 0;\n    int flag13 = 0;\n    int flag14 = 0;\n    int flag15 = 0;\n    int flag16 = 0;\n    int flag17 = 0;\n    int flag18 = 0;\n    int flag19 = 0;\n    int flag20 = 0;\n    int flag21 = 0;\n    int flag22 = 0;\n    int flag23 = 0;\n    int flag24 = 0;\n    int flag25 = 0;\n    int flag26 = 0;\n    int flag27 = 0;\n    int flag28 = 0;\n    int flag29 = 0;\n    int flag30 = 0;\n    int flag31 = 0;\n    int flag32 = 0;\n    int flag33 = 0;\n    int flag34 = 0;\n    int flag35 = 0;\n    int flag36 = 0;\n    int flag37 = 0;\n    int flag38 = 0;\n    int flag39 = 0;\n    int flag40 = 0;\n    int flag41 = 0;\n    int flag42 = 0;\n    int flag43 = 0;\n    int flag44 = 0;\n    int flag45 = 0;\n    int flag46 = 0;\n    int flag47 = 0;\n    int flag48 = 0;\n    int flag49 = 0;\n    int flag50 = 0;\n    int flag51 = 0;\n    int flag52 = 0;\n    int flag53 = 0;\n    int flag54 = 0;\n    int flag55 = 0;\n    int flag56 = 0;\n    int flag57 = 0;\n    int flag58 = 0;\n\n}", "prefix": "char *** solveNQueens(int n, int* returnSize, int** returnColumnSizes"}
{"id": "1780", "path": "output2\\c\\Hard\\1780-n-queens-ii.c", "hypo_code": "int totalNQueens(int n){\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int flag = 0;\n    int flag2 = 0;\n    int flag3 = 0;\n    int flag4 = 0;\n    int flag5 = 0;\n    int flag6 = 0;\n    int flag7 = 0;\n    int flag8 = 0;\n    int flag9 = 0;\n    int flag10 = 0;\n    int flag11 = 0;\n    int flag12 = 0;\n    int flag13 = 0;\n    int flag14 = 0;\n    int flag15 = 0;\n    int flag16 = 0;\n    int flag17 = 0;\n    int flag18 = 0;\n    int flag19 = 0;\n    int flag20 = 0;\n    int flag21 = 0;\n    int flag22 = 0;\n    int flag23 = 0;\n    int flag24 = 0;\n    int flag25 = 0;\n    int flag26 = 0;\n    int flag27 = 0;\n    int flag28 = 0;\n    int flag29 = 0;\n    int flag30 = 0;\n    int flag31 = 0;\n    int flag32 = 0;\n    int flag33 = 0;\n    int flag34 = 0;\n    int flag35 = 0;\n    int flag36 = 0;\n    int flag37 = 0;\n    int flag38 = 0;\n    int flag39 = 0;\n    int flag40 = 0;\n    int flag41 = 0;\n    int flag42 = 0;\n    int flag43 = 0;\n    int flag44 = 0;\n    int flag45 = 0;\n    int flag46 = 0;\n    int flag47 = 0;\n    int flag48 = 0;\n    int flag49 = 0;\n    int flag50 = 0;\n    int flag51 = 0;\n    int flag52 = 0;\n    int flag53 = 0;\n    int flag54 = 0;\n    int flag55 = 0;\n    int flag56 = 0;\n    int flag57 = 0;\n    int flag58 = 0;\n\n}", "prefix": "int totalNQueens(int n"}
{"id": "1781", "path": "output2\\c\\Hard\\1781-permutation-sequence.c", "hypo_code": "char * getPermutation(int n, int k){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "char * getPermutation(int n, int k"}
{"id": "1782", "path": "output2\\c\\Hard\\1782-valid-number.c", "hypo_code": "bool isNumber(char * s){\n    int i = 0;\n    int n = strlen(s);\n    while (i < n && s[i] == ' ') {\n        i++;\n    }\n    if (i < n && (s[i] == '+' || s[i] == '-')) {\n        i++;\n    }\n    int num = 0;\n    int dot = 0;\n    while (i < n && (s[i] >= '0' && s[i] <= '9' || s[i] == '.')) {\n        if (s[i] == '.') {\n            dot++;\n        } else {\n            num++;\n        }\n        i++;\n    }\n    if (dot > 1 || num < 1) {\n        return false;\n    }\n    if (i < n && s[i] == 'e') {\n        i++;\n        if (i < n && (s[i] == '+' || s[i] == '-')) {\n            i++;\n        }\n        num = 0;\n        while (i < n && s[i] >= '0' && s[i] <= '9') {\n            num++;\n            i++;\n        }\n        if (num < 1) {\n            return false;\n        }\n    }\n    while (i < n && s[i] == ' ') {\n        i++;\n    }\n    return i == n;\n  \n\n\n\n}", "prefix": "bool isNumber(char * s"}
{"id": "1783", "path": "output2\\c\\Hard\\1783-text-justification.c", "hypo_code": "char ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n\n\n}", "prefix": "char ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize"}
{"id": "1784", "path": "output2\\c\\Hard\\1784-minimum-window-substring.c", "hypo_code": "char * minWindow(char * s, char * t){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n   \n\n}", "prefix": "char * minWindow(char * s, char * t"}
{"id": "1785", "path": "output2\\c\\Hard\\1785-largest-rectangle-in-histogram.c", "hypo_code": "int largestRectangleArea(int* heights, int heightsSize){\n    int max = 0;\n    int *stack = (int*)malloc(sizeof(int) * heightsSize);\n    int top = -1;\n    int i = 0;\n    int cur = 0;\n    int width = 0;\n    while(i < heightsSize){\n        if(top == -1 || heights[stack[top]] <= heights[i]){\n            stack[++top] = i++;\n        }else{\n            cur = stack[top--];\n            width = top == -1 ? i : i - stack[top] - 1;\n            if(heights[cur] * width > max) max = heights[cur] * width;\n        }\n    }\n    while(top != -1){\n        cur = stack[top--];\n        width = top == -1 ? i : i - stack[top] - 1;\n        if(heights[cur] * width > max) max = heights[cur] * width;\n    }\n    return max;\n    \n\n}", "prefix": "int largestRectangleArea(int* heights, int heightsSize"}
{"id": "1786", "path": "output2\\c\\Hard\\1786-maximal-rectangle.c", "hypo_code": "int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize){\n    if(matrixSize == 0) return 0;\n    int max = 0;\n    int *height = (int*)malloc(sizeof(int) * (*matrixColSize));\n    memset(height, 0, sizeof(int) * (*matrixColSize));\n    for(int i = 0; i < matrixSize; i++){\n        for(int j = 0; j < *matrixColSize; j++){\n            if(matrix[i][j] == '1'){\n                height[j]++;\n            }else{\n                height[j] = 0;\n            }\n        }\n        int curMax = largestRectangleArea(height, *matrixColSize);\n        if(curMax > max) max = curMax;\n    }\n    return max;\n   \n}", "prefix": "int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize"}
{"id": "1787", "path": "output2\\c\\Hard\\1787-scramble-string.c", "hypo_code": "bool isScramble(char * s1, char * s2){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n   \n}", "prefix": "bool isScramble(char * s1, char * s2"}
{"id": "1788", "path": "output2\\c\\Hard\\1788-distinct-subsequences.c", "hypo_code": "int numDistinct(char * s, char * t){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n   \n\n\n\n\n\n}", "prefix": "int numDistinct(char * s, char * t"}
{"id": "1789", "path": "output2\\c\\Hard\\1789-best-time-to-buy-and-sell-stock-iii.c", "hypo_code": "int maxProfit(int* prices, int pricesSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n\n    \n\n\n\n}", "prefix": "int maxProfit(int* prices, int pricesSize"}
{"id": "1790", "path": "output2\\c\\Hard\\1790-binary-tree-maximum-path-sum.c", "hypo_code": "int maxPathSum(struct TreeNode* root){\n    int max = root->val;\n    int maxPathSumHelper(struct TreeNode* root, int *max) {\n        if (root == NULL) {\n            return 0;\n        }\n        int left = maxPathSumHelper(root->left, max);\n        int right = maxPathSumHelper(root->right, max);\n        int sum = root->val;\n        if (left > 0) {\n            sum += left;\n        }\n        if (right > 0) {\n            sum += right;\n        }\n        if (sum > *max) {\n            *max = sum;\n        }\n        if (left > right) {\n            if (left > 0) {\n                return left + root->val;\n            } else {\n                return root->val;\n            }\n        } else {\n            if (right > 0) {\n                return right + root->val;\n            } else {\n                return root->val;\n            }\n        }\n    }\n    maxPathSumHelper(root, &max);\n    return max;\n\n}", "prefix": "int maxPathSum(struct TreeNode* root"}
{"id": "1791", "path": "output2\\c\\Hard\\1791-word-ladder-ii.c", "hypo_code": "char *** findLadders(char * beginWord, char * endWord, char ** wordList, int wordListSize, int* returnSize, int** returnColumnSizes){\n\n\n\n            \n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n}", "prefix": "char *** findLadders(char * beginWord, char * endWord, char ** wordList, int wordListSize, int* returnSize, int** returnColumnSizes"}
{"id": "1792", "path": "output2\\c\\Hard\\1792-word-ladder.c", "hypo_code": "int ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n    \n\n}", "prefix": "int ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize"}
{"id": "1793", "path": "output2\\c\\Hard\\1793-palindrome-partitioning-ii.c", "hypo_code": "int minCut(char * s){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n   \n\n}", "prefix": "int minCut(char * s"}
{"id": "1794", "path": "output2\\c\\Hard\\1794-candy.c", "hypo_code": "int candy(int* ratings, int ratingsSize){\n    int* candies = (int*)malloc(sizeof(int) * ratingsSize);\n    memset(candies, 0, sizeof(int) * ratingsSize);\n    candies[0] = 1;\n    for(int i = 1; i < ratingsSize; i++){\n        if(ratings[i] > ratings[i - 1]){\n            candies[i] = candies[i - 1] + 1;\n        }else{\n            candies[i] = 1;\n        }\n    }\n    for(int i = ratingsSize - 2; i >= 0; i--){\n        if(ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]){\n            candies[i] = candies[i + 1] + 1;\n        }\n    }\n    int sum = 0;\n    for(int i = 0; i < ratingsSize; i++){\n        sum += candies[i];\n    }\n    return sum;\n    \n}", "prefix": "int candy(int* ratings, int ratingsSize"}
{"id": "1795", "path": "output2\\c\\Hard\\1795-word-break-ii.c", "hypo_code": "char ** wordBreak(char * s, char ** wordDict, int wordDictSize, int* returnSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n    \n\n}", "prefix": "char ** wordBreak(char * s, char ** wordDict, int wordDictSize, int* returnSize"}
{"id": "1796", "path": "output2\\c\\Hard\\1796-max-points-on-a-line.c", "hypo_code": "int maxPoints(int** points, int pointsSize, int* pointsColSize){\n    if(pointsSize < 3) return pointsSize;\n    int max = 0;\n    for(int i = 0; i < pointsSize; i++){\n        int same = 1;\n        int vertical = 0;\n        int curMax = 0;\n        for(int j = i + 1; j < pointsSize; j++){\n            if(points[i][0] == points[j][0] && points[i][1] == points[j][1]){\n                same++;\n            }else if(points[i][0] == points[j][0]){\n                vertical++;\n            }else{\n                int a = points[i][1] - points[j][1];\n                int b = points[i][0] - points[j][0];\n                int gcd = getGcd(a, b);\n                a /= gcd;\n                b /= gcd;\n                if(map[a] == NULL){\n                    map[a] = (int*)malloc(sizeof(int) * 10000);\n                    memset(map[a], 0, sizeof(int) * 10000);\n                }\n                map[a][b]++;\n                if(map[a][b] > curMax) curMax = map[a][b];\n            }\n        }\n        if(vertical > curMax) curMax = vertical;\n        curMax += same;\n        if(curMax > max) max = curMax;\n    }\n    return max;\n    \n\n\n}", "prefix": "int maxPoints(int** points, int pointsSize, int* pointsColSize"}
{"id": "1797", "path": "output2\\c\\Hard\\1797-find-minimum-in-rotated-sorted-array-ii.c", "hypo_code": "int findMin(int* nums, int numsSize){\n    int left = 0;\n    int right = numsSize - 1;\n    while(left < right){\n        int mid = left + (right - left) / 2;\n        if(nums[mid] < nums[right]){\n            right = mid;\n        }else if(nums[mid] > nums[right]){\n            left = mid + 1;\n        }else{\n            right--;\n        }\n    }\n    return nums[left];\n    \n}", "prefix": "int findMin(int* nums, int numsSize"}
{"id": "1798", "path": "output2\\c\\Hard\\1798-maximum-gap.c", "hypo_code": "int maximumGap(int* nums, int numsSize){\n    if(numsSize < 2) return 0;\n    int max = nums[0];\n    int min = nums[0];\n    for(int i = 1; i < numsSize; i++){\n        if(nums[i] > max) max = nums[i];\n        if(nums[i] < min) min = nums[i];\n    }\n    int bucketSize = (max - min) / numsSize + 1;\n    int bucketNum = (max - min) / bucketSize + 1;\n    int* bucketMin = (int*)malloc(sizeof(int) * bucketNum);\n    int* bucketMax = (int*)malloc(sizeof(int) * bucketNum);\n    for(int i = 0; i < bucketNum; i++){\n        bucketMin[i] = INT_MAX;\n        bucketMax[i] = INT_MIN;\n    }\n    for(int i = 0; i < numsSize; i++){\n        int index = (nums[i] - min) / bucketSize;\n        if(nums[i] < bucketMin[index]) bucketMin[index] = nums[i];\n        if(nums[i] > bucketMax[index]) bucketMax[index] = nums[i];\n    }\n    int maxGap = 0;\n    int prev = bucketMax[0];\n    for(int i = 1; i < bucketNum; i++){\n        if(bucketMin[i] == INT_MAX && bucketMax[i] == INT_MIN) continue;\n        if(bucketMin[i] - prev > maxGap) maxGap = bucketMin[i] - prev;\n        prev = bucketMax[i];\n    }\n    return maxGap;\n    \n\n\n}", "prefix": "int maximumGap(int* nums, int numsSize"}
{"id": "1799", "path": "output2\\c\\Hard\\1799-dungeon-game.c", "hypo_code": "int calculateMinimumHP(int** dungeon, int dungeonSize, int* dungeonColSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n\n}", "prefix": "int calculateMinimumHP(int** dungeon, int dungeonSize, int* dungeonColSize"}
{"id": "1801", "path": "output2\\c\\Hard\\1801-best-time-to-buy-and-sell-stock-iv.c", "hypo_code": "int maxProfit(int k, int* prices, int pricesSize){\n    if(pricesSize < 2) return 0;\n    if(k >= pricesSize / 2){\n        int profit = 0;\n        for(int i = 1; i < pricesSize; i++){\n            if(prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\n        }\n        return profit;\n    }\n    int* buy = (int*)malloc(sizeof(int) * k);\n    int* sell = (int*)malloc(sizeof(int) * k);\n    for(int i = 0; i < k; i++){\n        buy[i] = INT_MIN;\n        sell[i] = 0;\n    }\n    for(int i = 0; i < pricesSize; i++){\n        buy[0] = fmax(buy[0], -prices[i]);\n        sell[0] = fmax(sell[0], buy[0] + prices[i]);\n        for(int j = 1; j < k; j++){\n            buy[j] = fmax(buy[j], sell[j - 1] - prices[i]);\n            sell[j] = fmax(sell[j], buy[j] + prices[i]);\n        }\n    }\n    return sell[k - 1];\n\n}", "prefix": "int maxProfit(int k, int* prices, int pricesSize"}
{"id": "1802", "path": "output2\\c\\Hard\\1802-word-search-ii.c", "hypo_code": "char ** findWords(char** board, int boardSize, int* boardColSize, char ** words, int wordsSize, int* returnSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n\n\n}", "prefix": "char ** findWords(char** board, int boardSize, int* boardColSize, char ** words, int wordsSize, int* returnSize"}
{"id": "1803", "path": "output2\\c\\Hard\\1803-shortest-palindrome.c", "hypo_code": "char * shortestPalindrome(char * s){\n    int len = strlen(s);\n    int* next = (int*)malloc(sizeof(int) * len);\n    memset(next, 0, sizeof(int) * len);\n    int i = 0, j = -1;\n    next[0] = -1;\n    while(i < len - 1){\n        if(j == -1 || s[i] == s[j]){\n            i++;\n            j++;\n            next[i] = j;\n        }else{\n            j = next[j];\n        }\n    }\n    int k = 0;\n    for(int i = len - 1; i >= 0; i--){\n        while(k != -1 && s[k] != s[i]){\n            k = next[k];\n        }\n        k++;\n    }\n    char* res = (char*)malloc(sizeof(char) * (len * 2 - k + 1));\n    memset(res, 0, sizeof(char) * (len * 2 - k + 1));\n    for(int i = 0; i < len - k; i++){\n        res[i] = s[len - i - 1];\n    }\n    for(int i = len - k; i < len * 2 - k; i++){\n        res[i] = s[i - len + k];\n    }\n    return res;\n\n}", "prefix": "char * shortestPalindrome(char * s"}
{"id": "1804", "path": "output2\\c\\Hard\\1804-the-skyline-problem.c", "hypo_code": "int** getSkyline(int** buildings, int buildingsSize, int* buildingsColSize, int* returnSize, int** returnColumnSizes){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n\n}", "prefix": "int** getSkyline(int** buildings, int buildingsSize, int* buildingsColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1805", "path": "output2\\c\\Hard\\1805-contains-duplicate-iii.c", "hypo_code": "bool containsNearbyAlmostDuplicate(int* nums, int numsSize, int indexDiff, int valueDiff){\n    if(numsSize < 2) return false;\n    int* index = (int*)malloc(sizeof(int) * numsSize);\n    for(int i = 0; i < numsSize; i++) index[i] = i;\n    qsort(index, numsSize, sizeof(int), cmp);\n    for(int i = 0; i < numsSize; i++){\n        for(int j = i + 1; j < numsSize; j++){\n            if(index[j] - index[i] > indexDiff) break;\n            if(abs(nums[index[i]] - nums[index[j]]) <= valueDiff) return true;\n        }\n    }\n    return false;\n\n}", "prefix": "bool containsNearbyAlmostDuplicate(int* nums, int numsSize, int indexDiff, int valueDiff"}
{"id": "1806", "path": "output2\\c\\Hard\\1806-basic-calculator.c", "hypo_code": "int calculate(char * s){\n    int len = strlen(s);\n    int* stack = (int*)malloc(sizeof(int) * len);\n    int top = -1;\n    int num = 0;\n    int sign = 1;\n    int res = 0;\n    for(int i = 0; i < len; i++){\n        if(s[i] >= '0' && s[i] <= '9'){\n            num = num * 10 + s[i] - '0';\n        }else if(s[i] == '+'){\n            res += sign * num;\n            num = 0;\n            sign = 1;\n        }else if(s[i] == '-'){\n            res += sign * num;\n            num = 0;\n            sign = -1;\n        }else if(s[i] == '('){\n            stack[++top] = res;\n            stack[++top] = sign;\n            res = 0;\n            sign = 1;\n        }else if(s[i] == ')'){\n            res += sign * num;\n            num = 0;\n            res *= stack[top--];\n            res += stack[top--];\n        }\n    }\n    if(num != 0) res += sign * num;\n    return res;\n\n}", "prefix": "int calculate(char * s"}
{"id": "1807", "path": "output2\\c\\Hard\\1807-number-of-digit-one.c", "hypo_code": "int countDigitOne(int n){\n    int count = 0;\n    for(long long i = 1; i <= n; i *= 10){\n        long long divider = i * 10;\n        count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return count;\n\n}", "prefix": "int countDigitOne(int n"}
{"id": "1808", "path": "output2\\c\\Hard\\1808-sliding-window-maximum.c", "hypo_code": "int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * (numsSize - k + 1));\n    int* queue = (int*)malloc(sizeof(int) * numsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < numsSize; i++){\n        while(head < tail && nums[queue[tail - 1]] < nums[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) result[i - k + 1] = nums[queue[head]];\n    }\n    *returnSize = numsSize - k + 1;\n    return result;\n\n}", "prefix": "int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize"}
{"id": "1810", "path": "output2\\c\\Hard\\1810-integer-to-english-words.c", "hypo_code": "char * numberToWords(int num){\nif (num == 0) return \"Zero\";\n    char *res = (char *)malloc(sizeof(char) * 1000);\n    char *p = res;\n    char *units[10] = {\"\", \" Thousand\", \" Million\", \" Billion\"};\n    char *ones[20] = {\"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\", \" Ten\",\n                     \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\"};\n    char *tens[10] = {\"\", \" Ten\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\"};\n    int unit = 0;\n    while (num > 0) {\n        int n = num % 1000;\n        if (n > 0) {\n            if (unit > 0) {\n                p += sprintf(p, \"%s\", units[unit]);\n            }\n            if (n >= 100) {\n                p += sprintf(p, \"%s Hundred\", ones[n / 100]);\n            }\n            if (n % 100 >= 20) {\n                p += sprintf(p, \"%s%s\", tens[(n % 100) / 10], ones[n % 10]);\n            } else {\n                p += sprintf(p, \"%s\", ones[n % 100]);\n            }\n        }\n        num /= 1000;\n        unit++;\n    }\n    return res;\n\n}", "prefix": "char * numberToWords(int num"}
{"id": "1811", "path": "output2\\c\\Hard\\1811-expression-add-operators.c", "hypo_code": "char ** addOperators(char * num, int target, int* returnSize){\n*returnSize = 0;\n    int len = strlen(num);\n    char **res = (char **)malloc(sizeof(char *) * 10000);\n    for (int i = 0; i < 10000; i++) {\n        res[i] = (char *)malloc(sizeof(char) * 1000);\n    }\n    char *p = res[0];\n    long long n = 0;\n    for (int i = 0; i < len; i++) {\n        if (i > 0 && n == 0) break;\n        n = n * 10 + num[i] - '0';\n        sprintf(p++, \"%c\", num[i]);\n        dfs(num, target, len, i + 1, n, n, res, returnSize, p);\n        if (n == 0) break;\n    }\n    return res;\n}\nvoid dfs(char *num, int target, int len, int start, long long sum, long long last, char **res, int *returnSize, char *p) {\n    if (start == len) {\n        if (sum == target) {\n            *p = '\\0';\n            strcpy(res[*returnSize], res[0]);\n            (*returnSize)++;\n        }\n        return;\n    }\n    int i = start;\n    char *q = p;\n    p += sprintf(p, \"+%c\", num[i]);\n    dfs(num, target, len, i + 1, sum + num[i] - '0', num[i] - '0', res, returnSize, p);\n    *q = '\\0';\n    p = q;\n    p += sprintf(p, \"-%c\", num[i]);\n    dfs(num, target, len, i + 1, sum - num[i] + '0', - (num[i] - '0'), res, returnSize, p);\n    *q = '\\0';\n    p = q;\n    p += sprintf(p, \"*%c\", num[i]);\n    dfs(num, target, len, i + 1, sum - last + last * (num[i] - '0'), last * (num[i] - '0'), res, returnSize, p);\n    *q = '\\0';\n    p = q;\n    if (last != 0) {\n        p += sprintf(p, \"%c\", num[i]);\n        dfs(num, target, len, i + 1, sum - last + last * 10 + (num[i] - '0'), last * 10 + (num[i] - '0'), res, returnSize, p);\n    }\n    *q = '\\0';\n    p = q;\n}", "prefix": "char ** addOperators(char * num, int target, int* returnSize"}
{"id": "1814", "path": "output2\\c\\Hard\\1814-remove-invalid-parentheses.c", "hypo_code": "char ** removeInvalidParentheses(char * s, int* returnSize){\n*returnSize = 0;\n    char **res = (char **)malloc(sizeof(char *) * 10000);\n    for (int i = 0; i < 10000; i++) {\n        res[i] = (char *)malloc(sizeof(char) * 1000);\n    }\n    char *p = res[0];\n    int len = strlen(s);\n    int left = 0, right = 0;\n    for (int i = 0; i < len; i++) {\n        if (s[i] == '(') left++;\n        if (s[i] == ')') {\n            if (left > 0) left--;\n            else right++;\n        }\n    }\n    dfs(s, len, 0, left, right, 0, 0, res, returnSize, p);\n    return res;\n}\nvoid dfs(char *s, int len, int start, int left, int right, int l, int r, char **res, int *returnSize, char *p) {\n    if (start == len) {\n        if (left == 0 && right == 0) {\n            *p = '\\0';\n            strcpy(res[*returnSize], res[0]);\n            (*returnSize)++;\n        }\n        return;\n    }\n    if (s[start] == '(') {\n        if (left > 0) {\n            dfs(s, len, start + 1, left - 1, right, l, r, res, returnSize, p);\n        }\n        p += sprintf(p, \"(\");\n        dfs(s, len, start + 1, left, right, l + 1, r, res, returnSize, p);\n    } else if (s[start] == ')') {\n        if (right > 0) {\n            dfs(s, len, start + 1, left, right - 1, l, r, res, returnSize, p);\n        }\n        if (l > r) {\n            p += sprintf(p, \")\");\n            dfs(s, len, start + 1, left, right, l, r + 1, res, returnSize, p);\n        }\n    } else {\n        p += sprintf(p, \"%c\", s[start]);\n        dfs(s, len, start + 1, left, right, l, r, res, returnSize, p);\n    }\n    *p = '\\0';\n    p--;\n}", "prefix": "char ** removeInvalidParentheses(char * s, int* returnSize"}
{"id": "1815", "path": "output2\\c\\Hard\\1815-burst-balloons.c", "hypo_code": "int maxCoins(int* nums, int numsSize){\n    int* newNums = (int*)malloc(sizeof(int) * (numsSize + 2));\n    int n = 1;\n    for(int i = 0; i < numsSize; i++){\n        if(nums[i] > 0) newNums[n++] = nums[i];\n    }\n    newNums[0] = newNums[n++] = 1;\n    int** dp = (int**)malloc(sizeof(int*) * n);\n    for(int i = 0; i < n; i++){\n        dp[i] = (int*)malloc(sizeof(int) * n);\n        memset(dp[i], 0, sizeof(int) * n);\n    }\n    for(int i = n - 2; i >= 0; i--){\n        for(int j = i + 2; j < n; j++){\n            for(int k = i + 1; k < j; k++){\n                dp[i][j] = fmax(dp[i][j], dp[i][k] + dp[k][j] + newNums[i] * newNums[k] * newNums[j]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n\n}", "prefix": "int maxCoins(int* nums, int numsSize"}
{"id": "1816", "path": "output2\\c\\Hard\\1816-count-of-smaller-numbers-after-self.c", "hypo_code": "int* countSmaller(int* nums, int numsSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * numsSize);\n    int* queue = (int*)malloc(sizeof(int) * numsSize);\n    int head = 0, tail = 0;\n    for(int i = numsSize - 1; i >= 0; i--){\n        while(head < tail && nums[queue[tail - 1]] >= nums[i]) tail--;\n        result[i] = tail;\n        queue[tail++] = i;\n    }\n    *returnSize = numsSize;\n    return result;\n\n\n}", "prefix": "int* countSmaller(int* nums, int numsSize, int* returnSize"}
{"id": "1817", "path": "output2\\c\\Hard\\1817-create-maximum-number.c", "hypo_code": "int* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * k);\n    int* queue = (int*)malloc(sizeof(int) * (nums1Size + nums2Size));\n    int head = 0, tail = 0;\n    for(int i = 0; i < nums1Size + nums2Size; i++){\n        while(head < tail && nums1[queue[tail - 1]] < nums1[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) result[i - k + 1] = nums1[queue[head]];\n    }\n    *returnSize = k;\n    return result;\n\n}", "prefix": "int* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize"}
{"id": "1818", "path": "output2\\c\\Hard\\1818-count-of-range-sum.c", "hypo_code": "int countRangeSum(int* nums, int numsSize, int lower, int upper){\n    int count = 0;\n    long long sum = 0;\n    int* queue = (int*)malloc(sizeof(int) * numsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < numsSize; i++){\n        sum += nums[i];\n        while(head < tail && sum - queue[head] > upper) head++;\n        while(head < tail && sum - queue[tail - 1] < lower) tail--;\n        count += tail - head;\n        queue[tail++] = sum;\n    }\n    return count;\n\n}", "prefix": "int countRangeSum(int* nums, int numsSize, int lower, int upper"}
{"id": "1819", "path": "output2\\c\\Hard\\1819-longest-increasing-path-in-a-matrix.c", "hypo_code": "int longestIncreasingPath(int** matrix, int matrixSize, int* matrixColSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n\n}", "prefix": "int longestIncreasingPath(int** matrix, int matrixSize, int* matrixColSize"}
{"id": "1820", "path": "output2\\c\\Hard\\1820-patching-array.c", "hypo_code": "int minPatches(int* nums, int numsSize, int n){\n    int count = 0;\n    long long sum = 0;\n    int i = 0;\n    while(sum < n){\n        if(i < numsSize && nums[i] <= sum + 1){\n            sum += nums[i++];\n        }else{\n            sum += sum + 1;\n            count++;\n        }\n    }\n    return count;\n\n}", "prefix": "int minPatches(int* nums, int numsSize, int n"}
{"id": "1821", "path": "output2\\c\\Hard\\1821-reconstruct-itinerary.c", "hypo_code": "char ** findItinerary(char *** tickets, int ticketsSize, int* ticketsColSize, int* returnSize){\n    char** result = (char**)malloc(sizeof(char*) * (ticketsSize + 1));\n    char** queue = (char**)malloc(sizeof(char*) * ticketsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < ticketsSize; i++){\n        while(head < tail && strcmp(queue[tail - 1][1], tickets[i][1]) > 0) tail--;\n        queue[tail++] = tickets[i];\n        if(i - head >= ticketsSize) head++;\n        if(i >= ticketsSize - 1) result[i - ticketsSize + 1] = tickets[i][0];\n    }\n    *returnSize = ticketsSize + 1;\n    return result;\n\n}", "prefix": "char ** findItinerary(char *** tickets, int ticketsSize, int* ticketsColSize, int* returnSize"}
{"id": "1822", "path": "output2\\c\\Hard\\1822-self-crossing.c", "hypo_code": "bool isSelfCrossing(int* distance, int distanceSize){\n    if(distanceSize < 4) return false;\n    for(int i = 3; i < distanceSize; i++){\n        if(distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) return true;\n        if(i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) return true;\n        if(i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) return true;\n    }\n    return false;\n\n}", "prefix": "bool isSelfCrossing(int* distance, int distanceSize"}
{"id": "1823", "path": "output2\\c\\Hard\\1823-palindrome-pairs.c", "hypo_code": "int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * wordsSize * wordsSize);\n    int* queue = (int*)malloc(sizeof(int) * wordsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < wordsSize; i++){\n        while(head < tail && words[queue[tail - 1]] < words[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) result[i - k + 1] = words[queue[head]];\n    }\n    *returnSize = wordsSize - k + 1;\n    return result;\n\n}", "prefix": "int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes"}
{"id": "1825", "path": "output2\\c\\Hard\\1825-russian-doll-envelopes.c", "hypo_code": "int maxEnvelopes(int** envelopes, int envelopesSize, int* envelopesColSize){\n    int* queue = (int*)malloc(sizeof(int) * envelopesSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < envelopesSize; i++){\n        while(head < tail && envelopes[queue[tail - 1]] < envelopes[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) result[i - k + 1] = envelopes[queue[head]];\n    }\n    return envelopesSize - k + 1;\n\n}", "prefix": "int maxEnvelopes(int** envelopes, int envelopesSize, int* envelopesColSize"}
{"id": "1826", "path": "output2\\c\\Hard\\1826-max-sum-of-rectangle-no-larger-than-k.c", "hypo_code": "int maxSumSubmatrix(int** matrix, int matrixSize, int* matrixColSize, int k){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int maxSumSubmatrix(int** matrix, int matrixSize, int* matrixColSize, int k"}
{"id": "1828", "path": "output2\\c\\Hard\\1828-perfect-rectangle.c", "hypo_code": "bool isRectangleCover(int** rectangles, int rectanglesSize, int* rectanglesColSize){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "bool isRectangleCover(int** rectangles, int rectanglesSize, int* rectanglesColSize"}
{"id": "1829", "path": "output2\\c\\Hard\\1829-frog-jump.c", "hypo_code": "bool canCross(int* stones, int stonesSize){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "bool canCross(int* stones, int stonesSize"}
{"id": "1830", "path": "output2\\c\\Hard\\1830-trapping-rain-water-ii.c", "hypo_code": "int trapRainWater(int** heightMap, int heightMapSize, int* heightMapColSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n\n}", "prefix": "int trapRainWater(int** heightMap, int heightMapSize, int* heightMapColSize"}
{"id": "1831", "path": "output2\\c\\Hard\\1831-split-array-largest-sum.c", "hypo_code": "int splitArray(int* nums, int numsSize, int k){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int splitArray(int* nums, int numsSize, int k"}
{"id": "1832", "path": "output2\\c\\Hard\\1832-strong-password-checker.c", "hypo_code": "int strongPasswordChecker(char * password){\nint len = strlen(password);\n    int lower = 1, upper = 1, digit = 1;\n    int repeat = 0, one = 0, two = 0;\n    int i = 0;\n    while (i < len) {\n        if (password[i] >= 'a' && password[i] <= 'z') lower = 0;\n        if (password[i] >= 'A' && password[i] <= 'Z') upper = 0;\n        if (password[i] >= '0' && password[i] <= '9') digit = 0;\n        int j = i + 1;\n        while (j < len && password[j] == password[i]) j++;\n        repeat += (j - i) / 3;\n        if ((j - i) % 3 == 1) one++;\n        if ((j - i) % 3 == 2) two++;\n        i = j;\n    }\n    int miss = lower + upper + digit;\n    if (len < 6) return fmax(6 - len, miss);\n    if (len <= 20) return fmax(repeat, miss);\n    int del = len - 20;\n    repeat -= fmin(del, one);\n    repeat -= fmin(fmax(del - one, 0), two * 2) / 2;\n    repeat -= fmax(del - one - 2 * two, 0) / 3;\n    return del + fmax(repeat, miss);\n}", "prefix": "int strongPasswordChecker(char * password"}
{"id": "1834", "path": "output2\\c\\Hard\\1834-k-th-smallest-in-lexicographical-order.c", "hypo_code": "int findKthNumber(int n, int k){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int findKthNumber(int n, int k"}
{"id": "1835", "path": "output2\\c\\Hard\\1835-arithmetic-slices-ii-subsequence.c", "hypo_code": "int numberOfArithmeticSlices(int* nums, int numsSize){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int numberOfArithmeticSlices(int* nums, int numsSize"}
{"id": "1836", "path": "output2\\c\\Hard\\1836-poor-pigs.c", "hypo_code": "int poorPigs(int buckets, int minutesToDie, int minutesToTest){\n    int pigs = 0;\n    while (pow(minutesToTest / minutesToDie + 1, pigs) < buckets) pigs++;\n    return pigs;\n\n}", "prefix": "int poorPigs(int buckets, int minutesToDie, int minutesToTest"}
{"id": "1838", "path": "output2\\c\\Hard\\1838-count-the-repetitions.c", "hypo_code": "int getMaxRepetitions(char * s1, int n1, char * s2, int n2){\nint len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int repeat = 0;\n    int index = 0;\n    int *next = (int *)malloc(sizeof(int) * len2);\n    int *count = (int *)malloc(sizeof(int) * len2);\n    for (int i = 0; i < len2; i++) {\n        int j = i;\n        int k = 0;\n        while (k < len1) {\n            if (s1[k] == s2[j]) j++;\n            if (j == len2) {\n                j = 0;\n                repeat++;\n            }\n            k++;\n        }\n        next[i] = j;\n        count[i] = repeat;\n        for (int l = 0; l < i; l++) {\n            if (next[l] == j) {\n                int pre = count[l];\n                int interval = repeat - count[l];\n                int res = (n1 - l - 1) / (i - l) * interval;\n                int remain = (n1 - l - 1) % (i - l);\n                repeat = pre + res;\n                j = 0;\n                for (int m = 0; m < remain; m++) {\n                    j = next[j];\n                    if (j == 0) repeat++;\n                }\n                return repeat / n2;\n            }\n        }\n    }\n    return repeat / n2;\n}", "prefix": "int getMaxRepetitions(char * s1, int n1, char * s2, int n2"}
{"id": "1839", "path": "output2\\c\\Hard\\1839-concatenated-words.c", "hypo_code": "char ** findAllConcatenatedWordsInADict(char ** words, int wordsSize, int* returnSize){\n    char** result = (char**)malloc(sizeof(char*) * wordsSize);\n    int* queue = (int*)malloc(sizeof(int) * wordsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < wordsSize; i++){\n        while(head < tail && words[queue[tail - 1]] < words[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) result[i - k + 1] = words[queue[head]];\n    }\n    *returnSize = wordsSize - k + 1;\n    return result;\n\n}", "prefix": "char ** findAllConcatenatedWordsInADict(char ** words, int wordsSize, int* returnSize"}
{"id": "1840", "path": "output2\\c\\Hard\\1840-largest-palindrome-product.c", "hypo_code": "int largestPalindrome(int n){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n\n}", "prefix": "int largestPalindrome(int n"}
{"id": "1841", "path": "output2\\c\\Hard\\1841-sliding-window-median.c", "hypo_code": "double* medianSlidingWindow(int* nums, int numsSize, int k, int* returnSize){\n    double* result = (double*)malloc(sizeof(double) * (numsSize - k + 1));\n    int* queue = (int*)malloc(sizeof(int) * numsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < numsSize; i++){\n        while(head < tail && nums[queue[tail - 1]] < nums[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1){\n            if(k % 2 == 0){\n                result[i - k + 1] = (nums[queue[head]] + nums[queue[head + 1]]) / 2.0;\n            }else{\n                result[i - k + 1] = nums[queue[head]];\n            }\n        }\n    }\n    *returnSize = numsSize - k + 1;\n    return result;\n\n}", "prefix": "double* medianSlidingWindow(int* nums, int numsSize, int k, int* returnSize"}
{"id": "1842", "path": "output2\\c\\Hard\\1842-smallest-good-base.c", "hypo_code": "char * smallestGoodBase(char * n){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "char * smallestGoodBase(char * n"}
{"id": "1843", "path": "output2\\c\\Hard\\1843-zuma-game.c", "hypo_code": "int findMinStep(char * board, char * hand){\n    int i, j, k, l, m, n, o, p, q, r, a, b, c, d, e, f, g, h, w, x, y, z;\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n\n}", "prefix": "int findMinStep(char * board, char * hand"}
{"id": "1844", "path": "output2\\c\\Hard\\1844-reverse-pairs.c", "hypo_code": "int reversePairs(int* nums, int numsSize){\nint res = 0;\n    int *temp = (int *)malloc(sizeof(int) * numsSize);\n    res = mergeSort(nums, 0, numsSize - 1, temp);\n    return res;\n}\nint mergeSort(int *nums, int left, int right, int *temp) {\n    if (left >= right) return 0;\n    int mid = left + (right - left) / 2;\n    int res = mergeSort(nums, left, mid, temp) + mergeSort(nums, mid + 1, right, temp);\n    int i = left, j = mid + 1, k = 0;\n    while (i <= mid && j <= right) {\n        if ((long long)nums[i] > 2 * (long long)nums[j]) {\n            res += mid - i + 1;\n            j++;\n        } else {\n            i++;\n        }\n    }\n    i = left, j = mid + 1;\n    while (i <= mid && j <= right) {\n        if (nums[i] <= nums[j]) temp[k++] = nums[i++];\n        else temp[k++] = nums[j++];\n    }\n    while (i <= mid) temp[k++] = nums[i++];\n    while (j <= right) temp[k++] = nums[j++];\n    for (int i = 0; i < k; i++) {\n        nums[left + i] = temp[i];\n    }\n    return res;\n}", "prefix": "int reversePairs(int* nums, int numsSize"}
{"id": "1845", "path": "output2\\c\\Hard\\1845-ipo.c", "hypo_code": "int findMaximizedCapital(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize){\n    int* queue = (int*)malloc(sizeof(int) * profitsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < profitsSize; i++){\n        while(head < tail && profits[queue[tail - 1]] < profits[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) w += profits[queue[head]];\n    }\n    return w;\n\n}", "prefix": "int findMaximizedCapital(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize"}
{"id": "1846", "path": "output2\\c\\Hard\\1846-freedom-trail.c", "hypo_code": "int findRotateSteps(char * ring, char * key){\n    int i, j, k, l, m, n, o, p, q, r, a, b, c, d, e, f, g, h, w, x, y, z;\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int findRotateSteps(char * ring, char * key"}
{"id": "1847", "path": "output2\\c\\Hard\\1847-super-washing-machines.c", "hypo_code": "int findMinMoves(int* machines, int machinesSize){\n    int sum = 0;\n    for(int i = 0; i < machinesSize; i++){\n        sum += machines[i];\n    }\n    if(sum % machinesSize != 0) return -1;\n    int avg = sum / machinesSize;\n    int result = 0;\n    int count = 0;\n    for(int i = 0; i < machinesSize; i++){\n        count += machines[i] - avg;\n        result = fmax(result, fmax(abs(count), machines[i] - avg));\n    }\n    return result;\n\n}", "prefix": "int findMinMoves(int* machines, int machinesSize"}
{"id": "1848", "path": "output2\\c\\Hard\\1848-remove-boxes.c", "hypo_code": "int removeBoxes(int* boxes, int boxesSize){\n    int* queue = (int*)malloc(sizeof(int) * boxesSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < boxesSize; i++){\n        while(head < tail && boxes[queue[tail - 1]] < boxes[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) result[i - k + 1] = boxes[queue[head]];\n    }\n    return boxesSize - k + 1;\n\n}", "prefix": "int removeBoxes(int* boxes, int boxesSize"}
{"id": "1849", "path": "output2\\c\\Hard\\1849-student-attendance-record-ii.c", "hypo_code": "int checkRecord(int n){\n    int i, j, k, l, m, t, f;\n    int *a = (int *)malloc(sizeof(int) * (n + 1));\n    int *b = (int *)malloc(sizeof(int) * (n + 1));\n    int *c = (int *)malloc(sizeof(int) * (n + 1));\n    int *d = (int *)malloc(sizeof(int) * (n + 1));\n    int *e = (int *)malloc(sizeof(int) * (n + 1));\n    int *f = (int *)malloc(sizeof(int) * (n + 1));\n    int *g = (int *)malloc(sizeof(int) * (n + 1));\n    int *h = (int *)malloc(sizeof(int) * (n + 1));\n    int *p = (int *)malloc(sizeof(int) * (n + 1));\n    int *q = (int *)malloc(sizeof(int) * (n + 1));\n    int *r = (int *)malloc(sizeof(int) * (n + 1));\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *u = (int *)malloc(sizeof(int) * (n + 1));\n    int *v = (int *)malloc(sizeof(int) * (n + 1));\n    int *w = (int *)malloc(sizeof(int) * (n + 1));\n    int *x = (int *)malloc(sizeof(int) * (n + 1));\n    int *y = (int *)malloc(sizeof(int) * (n + 1));\n    int *z = (int *)malloc(sizeof(int) * (n + 1));\n    int *aa = (int *)malloc(sizeof(int) * (n + 1));\n    int *ab = (int *)malloc(sizeof(int) * (n + 1));\n    int *ac = (int *)malloc(sizeof(int) * (n + 1));\n    int *ad = (int *)malloc(sizeof(int) * (n + 1));\n    int *ae = (int *)malloc(sizeof(int) * (n + 1));\n    int *af = (int *)malloc(sizeof(int) * (n + 1));\n   \n\n}", "prefix": "int checkRecord(int n"}
{"id": "1850", "path": "output2\\c\\Hard\\1850-find-the-closest-palindrome.c", "hypo_code": "char * nearestPalindromic(char * n){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "char * nearestPalindromic(char * n"}
{"id": "1851", "path": "output2\\c\\Hard\\1851-erect-the-fence.c", "hypo_code": "int** outerTrees(int** trees, int treesSize, int* treesColSize, int* returnSize, int** returnColumnSizes){\n*returnSize = 0;\n    int **res = (int **)malloc(sizeof(int *) * 3000);\n    for (int i = 0; i < 3000; i++) {\n        res[i] = (int *)malloc(sizeof(int) * 2);\n    }\n    *returnColumnSizes = (int *)malloc(sizeof(int) * 3000);\n    int *stack = (int *)malloc(sizeof(int) * 3000);\n    int top = -1;\n    int left = 0;\n    for (int i = 0; i < treesSize; i++) {\n        if (trees[i][0] < trees[left][0]) left = i;\n    }\n    int p = left;\n    do {\n        int q = (p + 1) % treesSize;\n        for (int i = 0; i < treesSize; i++) {\n            if (cross(trees[p], trees[i], trees[q]) > 0) {\n                q = i;\n            }\n        }\n        for (int i = 0; i < treesSize; i++) {\n            if (i != p && i != q && cross(trees[p], trees[i], trees[q]) == 0 && inBetween(trees[p], trees[i], trees[q])) {\n                stack[++top] = i;\n            }\n        }\n        stack[++top] = q;\n        p = q;\n    } while (p != left);\n    int k = 0;\n    while (top >= 0) {\n        int i = stack[top--];\n        res[k][0] = trees[i][0];\n        res[k][1] = trees[i][1];\n        (*returnColumnSizes)[k] = 2;\n        k++;\n    }\n    *returnSize = k;\n    return res;\n}\nint cross(int *p, int *q, int *r) {\n    int x1 = q[0] - p[0], y1 = q[1] - p[1];\n    int x2 = r[0] - p[0], y2 = r[1] - p[1];\n    return x1 * y2 - x2 * y1;\n}", "prefix": "int** outerTrees(int** trees, int treesSize, int* treesColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1852", "path": "output2\\c\\Hard\\1852-tag-validator.c", "hypo_code": "bool isValid(char * code){\nint len = strlen(code);\n    int *stack = (int *)malloc(sizeof(int) * len);\n    int top = -1;\n    int i = 0;\n    while (i < len) {\n        if (top == -1 && i > 0) return false;\n        if (code[i] == '<') {\n            if (code[i + 1] == '!') {\n                if (top == -1) return false;\n                if (code[i + 2] == '[') {\n                    i += 3;\n                    while (i < len) {\n                        if (code[i] == ']' && code[i + 1] == ']' && code[i + 2] == '>') {\n                            i += 2;\n                            break;\n                        }\n                        i++;\n                    }\n                } else {\n                    i += 2;\n                    while (i < len) {\n                        if (code[i] == '>' && code[i - 1] == ']' && code[i - 2] == ']') {\n                            break;\n                        }\n                        i++;\n                    }\n                }\n            } else if (code[i + 1] == '/') {\n                i += 2;\n                while (i < len) {\n                    if (code[i] == '>') {\n                        break;\n                    }\n                    i++;\n                }\n                if (top == -1) return false;\n                if (top >= 0 && stack[top] == i - 1) top--;\n            } else {\n                i++;\n                while (i < len) {\n                    if (code[i] == '>') {\n                        break;\n                    }\n                    i++;\n                }\n                if (top >= 0 && stack[top] == i - 1) return false;\n                if (i - 1 - top > 9) return false;\n                stack[++top] = i - 1;\n            }\n        }\n        i++;\n    }\n    if (top != -1) return false;\n    return true;\n}", "prefix": "bool isValid(char * code"}
{"id": "1853", "path": "output2\\c\\Hard\\1853-non-negative-integers-without-consecutive-ones.c", "hypo_code": "int findIntegers(int n){\nint res = 0;\n    int a = 1, b = 1;\n    for (int i = 1; i <= n; i++) {\n        res++;\n        int c = a + b;\n        a = b;\n        b = c;\n    }\n    return res;\n}", "prefix": "int findIntegers(int n"}
{"id": "1855", "path": "output2\\c\\Hard\\1855-k-inverse-pairs-array.c", "hypo_code": "int kInversePairs(int n, int k){\nint mod = 1000000007;\n    int dp[1001][1001] = {0};\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;\n            if (j >= i) dp[i][j] = (dp[i][j] + dp[i - 1][j - i]) % mod;\n        }\n    }\n    return dp[n][k];\n\n}", "prefix": "int kInversePairs(int n, int k"}
{"id": "1856", "path": "output2\\c\\Hard\\1856-course-schedule-iii.c", "hypo_code": "int scheduleCourse(int** courses, int coursesSize, int* coursesColSize){\nint res = 0;\n    qsort(courses, coursesSize, sizeof(int *), cmp);\n    int *heap = (int *)malloc(sizeof(int) * coursesSize);\n    int heapSize = 0;\n    int time = 0;\n    for (int i = 0; i < coursesSize; i++) {\n        if (time + courses[i][0] <= courses[i][1]) {\n            heap[heapSize++] = courses[i][0];\n            time += courses[i][0];\n            qsort(heap, heapSize, sizeof(int), cmp2);\n        } else if (heapSize > 0 && heap[heapSize - 1] > courses[i][0]) {\n            time += courses[i][0] - heap[heapSize - 1];\n            heap[heapSize - 1] = courses[i][0];\n            qsort(heap, heapSize, sizeof(int), cmp2);\n        }\n    }\n    return heapSize;\n}\nint cmp(const void *a, const void *b) {\n    return (*(int **)a)[1] - (*(int **)b)[1];\n\n}", "prefix": "int scheduleCourse(int** courses, int coursesSize, int* coursesColSize"}
{"id": "1857", "path": "output2\\c\\Hard\\1857-smallest-range-covering-elements-from-k-lists.c", "hypo_code": "int* smallestRange(int** nums, int numsSize, int* numsColSize, int* returnSize){\n*returnSize = 2;\n    int *res = (int *)malloc(sizeof(int) * 2);\n    int k = 0;\n    int **temp = (int **)malloc(sizeof(int *) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        temp[i] = (int *)malloc(sizeof(int) * 2);\n    }\n    int max = INT_MIN;\n    for (int i = 0; i < numsSize; i++) {\n        temp[i][0] = nums[i][0];\n        temp[i][1] = 0;\n        max = fmax(max, nums[i][0]);\n    }\n    int min = INT_MAX;\n    while (1) {\n        min = INT_MAX;\n        int minIndex = 0;\n        int max = INT_MIN;\n        for (int i = 0; i < numsSize; i++) {\n            if (temp[i][0] < min) {\n                min = temp[i][0];\n                minIndex = i;\n            }\n            max = fmax(max, temp[i][0]);\n        }\n        if (max - min < res[1] - res[0]) {\n            res[0] = min;\n            res[1] = max;\n        }\n        temp[minIndex][1]++;\n        if (temp[minIndex][1] == numsColSize[minIndex]) {\n            break;\n        }\n        temp[minIndex][0] = nums[minIndex][temp[minIndex][1]];\n    }\n    return res;\n}", "prefix": "int* smallestRange(int** nums, int numsSize, int* numsColSize, int* returnSize"}
{"id": "1858", "path": "output2\\c\\Hard\\1858-decode-ways-ii.c", "hypo_code": "int numDecodings(char * s){\nint mod = 1000000007;\n    long f1 = 1, f2 = 1, f3 = 0;\n    if (s[0] == '0') return 0;\n    if (s[0] == '*') f1 = 9;\n    for (int i = 1; i < strlen(s); i++) {\n        long temp = f1;\n        if (s[i] == '*') {\n            f1 = 9 * f1 % mod;\n            if (s[i - 1] == '1') f1 = (f1 + 9 * f2) % mod;\n            else if (s[i - 1] == '2') f1 = (f1 + 6 * f2) % mod;\n            else if (s[i - 1] == '*') f1 = (f1 + 15 * f2) % mod;\n        } else {\n            f1 = (s[i] > '0') * f1;\n            if (s[i - 1] == '1') f1 = (f1 + f2) % mod;\n            else if (s[i - 1] == '2' && s[i] <= '6') f1 = (f1 + f2) % mod;\n            else if (s[i - 1] == '*') f1 = (f1 + (s[i] <= '6' ? 2 : 1) * f2) % mod;\n        }\n        f2 = temp;\n    }\n    return f1;\n}", "prefix": "int numDecodings(char * s"}
{"id": "1859", "path": "output2\\c\\Hard\\1859-strange-printer.c", "hypo_code": "int strangePrinter(char * s){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int strangePrinter(char * s"}
{"id": "1860", "path": "output2\\c\\Hard\\1860-kth-smallest-number-in-multiplication-table.c", "hypo_code": "int findKthNumber(int m, int n, int k){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int findKthNumber(int m, int n, int k"}
{"id": "1861", "path": "output2\\c\\Hard\\1861-cut-off-trees-for-golf-event.c", "hypo_code": "int cutOffTree(int** forest, int forestSize, int* forestColSize){\n    int i, j, k, t, f, n, m, x, y, z, r, c, s, e, d, *a, *b, *q, *p;\n    int *dx = (int *)malloc(sizeof(int) * 4);\n    int *dy = (int *)malloc(sizeof(int) * 4);\n    dx[0] = 0;\n    dx[1] = 1;\n    dx[2] = 0;\n    dx[3] = -1;\n    dy[0] = -1;\n    dy[1] = 0;\n    dy[2] = 1;\n    dy[3] = 0;\n    n = forestSize;\n    m = forestColSize[0];\n    a = (int *)malloc(sizeof(int) * n * m);\n    b = (int *)malloc(sizeof(int) * n * m);\n    q = (int *)malloc(sizeof(int) * n * m);\n    p = (int *)malloc(sizeof(int) * n * m);\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n            a[i * m + j] = forest[i][j];\n        }\n    }\n    for (i = 0; i < n * m; i++) {\n        b[i] = -1;\n    }\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n            if (a[i * m + j] > 1) {\n                s = i * m + j;\n                e = 0;\n                q[e] = s;\n                b[s] = 0;\n                while (e >= 0) {\n                    s = q[e];\n                    e--;\n                    x = s / m;\n                    y = s % m;\n                    for (k = 0; k < 4; k++) {\n                        r = x + dx[k];\n                        c = y + dy[k];\n                        if (r >= 0 && r < n && c >= 0 && c < m && a[r * m + c] > 0 && b[r * m + c] == -1) {\n                            b[r * m + c] = b[s] + 1;\n                            e += 1;\n                            q[e] = r * m + c;\n\n                              \n                              \n\n}", "prefix": "int cutOffTree(int** forest, int forestSize, int* forestColSize"}
{"id": "1862", "path": "output2\\c\\Hard\\1862-24-game.c", "hypo_code": "bool judgePoint24(int* cards, int cardsSize){\n    double a = cards[0];\n    double b = cards[1];\n    double c = cards[2];\n    double d = cards[3];\n    return judge(a + b, c, d) || judge(a - b, c, d) || judge(a * b, c, d) || judge(a / b, c, d) ||\n           judge(a, b + c, d) || judge(a, b - c, d) || judge(a, b * c, d) || judge(a, b / c, d) ||\n           judge(a, b, c + d) || judge(a, b, c - d) || judge(a, b, c * d) || judge(a, b, c / d);\n\n}", "prefix": "bool judgePoint24(int* cards, int cardsSize"}
{"id": "1863", "path": "output2\\c\\Hard\\1863-redundant-connection-ii.c", "hypo_code": "int* findRedundantDirectedConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 2);\n    int* parent = (int*)malloc(sizeof(int) * (edgesSize + 1));\n    int* rank = (int*)malloc(sizeof(int) * (edgesSize + 1));\n    int* queue = (int*)malloc(sizeof(int) * edgesSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i <= edgesSize; i++){\n        parent[i] = i;\n        rank[i] = 1;\n    }\n    for(int i = 0; i < edgesSize; i++){\n        if(parent[edges[i][1]] != edges[i][1]){\n            result[0] = parent[edges[i][1]];\n            result[1] = edges[i][1];\n            edges[i][1] = 0;\n        }else{\n            parent[edges[i][1]] = edges[i][0];\n        }\n    }\n    for(int i = 0; i < edgesSize; i++){\n        if(edges[i][1] == 0) continue;\n        int x = edges[i][0], y = edges[i][1];\n        while(x != parent[x]) x = parent[x];\n        while(y != parent[y]) y = parent[y];\n        if(x == y){\n            if(result[0] == 0){\n                result[0] = edges[i][0];\n                result[1] = edges[i][1];\n            }\n        }else{\n            if(rank[x] < rank[y]){\n                parent[x] = y;\n                rank[y] += rank[x];\n            }else{\n                parent[y] = x;\n                rank[x] += rank[y];\n            }\n        }\n    }\n    *returnSize = 2;\n    return result;\n\n}", "prefix": "int* findRedundantDirectedConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize"}
{"id": "1864", "path": "output2\\c\\Hard\\1864-maximum-sum-of-3-non-overlapping-subarrays.c", "hypo_code": "int* maxSumOfThreeSubarrays(int* nums, int numsSize, int k, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 3);\n    int* queue = (int*)malloc(sizeof(int) * numsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < numsSize; i++){\n        while(head < tail && nums[queue[tail - 1]] < nums[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) result[i - k + 1] = nums[queue[head]];\n    }\n    *returnSize = numsSize - k + 1;\n    return result;\n\n}", "prefix": "int* maxSumOfThreeSubarrays(int* nums, int numsSize, int k, int* returnSize"}
{"id": "1865", "path": "output2\\c\\Hard\\1865-stickers-to-spell-word.c", "hypo_code": "int minStickers(char ** stickers, int stickersSize, char * target){\n    int i, j, k, l, m, n, o, p, q, r, a, b, c, d, e, f, g, h, w, x, y, z;\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int minStickers(char ** stickers, int stickersSize, char * target"}
{"id": "1866", "path": "output2\\c\\Hard\\1866-falling-squares.c", "hypo_code": "int* fallingSquares(int** positions, int positionsSize, int* positionsColSize, int* returnSize){\n    int i, j, k, l, m, n, o, p, q, r, a, b, c, d, e, f, g, h, w, x, y, z;\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int* fallingSquares(int** positions, int positionsSize, int* positionsColSize, int* returnSize"}
{"id": "1869", "path": "output2\\c\\Hard\\1869-find-k-th-smallest-pair-distance.c", "hypo_code": "int smallestDistancePair(int* nums, int numsSize, int k){\nint *cnt = (int *)malloc(sizeof(int) * 1000000);\n    memset(cnt, 0, sizeof(int) * 1000000);\n    for (int i = 0; i < numsSize; i++) {\n        for (int j = i + 1; j < numsSize; j++) {\n            cnt[abs(nums[i] - nums[j])]++;\n        }\n    }\n    for (int i = 0; i < 1000000; i++) {\n        if (cnt[i] >= k) return i;\n        k -= cnt[i];\n    }\n    return 0;\n}", "prefix": "int smallestDistancePair(int* nums, int numsSize, int k"}
{"id": "1870", "path": "output2\\c\\Hard\\1870-number-of-atoms.c", "hypo_code": "char * countOfAtoms(char * formula){ \n  int len = strlen(formula);\n    char *res = (char *)malloc(sizeof(char) * 10000);\n    char *p = res;\n    int i = 0;\n    int *stack = (int *)malloc(sizeof(int) * len);\n    int top = -1;\n    while (i < len) {\n        if (formula[i] == '(') {\n            top++;\n            stack[top] = i;\n            i++;\n        } else if (formula[i] == ')') {\n            int j = i + 1;\n            int num = 0;\n            while (j < len && formula[j] >= '0' && formula[j] <= '9') {\n                num = num * 10 + formula[j] - '0';\n                j++;\n            }\n            if (num == 0) num = 1;\n            int temp = top;\n            while (stack[temp] != -1 && formula[stack[temp]] != '(') {\n                stack[temp] = -1;\n                temp--;\n            }\n            stack[temp] = -1;\n            top = temp - 1;\n            for (int k = 0; k < num; k++) {\n                temp++;\n                stack[temp] = -2;\n            }\n            i = j;\n        } else if (formula[i] >= 'A' && formula[i] <= 'Z') {\n            int j = i + 1;\n            while (j < len && formula[j] >= 'a' && formula[j] <= 'z') {\n                j++;\n            }\n            int num = 0;\n            while (j < len && formula[j] >= '0' && formula[j] <= '9') {\n                num = num * 10 + formula[j] - '0';\n                j++;\n            }\n            if (num == 0) num = 1;\n            for (int k = 0; k < num; k++) {\n                top++;\n                stack[top] = i;\n            }\n            i = j;\n        }\n    }\n    int *count = (int *)malloc(sizeof(int) * len);\n    for (int i = 0; i < len; i++) {\n        count[i] = 0;\n    }\n    for (int i = 0; i <= top; i++) {\n        if (stack[i] == -1) continue;\n        int j = stack[i] + 1;\n        if (formula[j] >= 'a' && formula[j] <= 'z') j++;\n        int num = 0;\n        while (j < len && formula[j] >= '0' && formula[j] <= '9') {\n            num = num * 10 + formula[j] - '0';\n            j++;\n        }\n        if (num == 0) num = 1;\n        count[stack[i]] += num;\n    }\n    int index = 0;\n    for (int i = 0; i < len; i++) {\n        if (count[i] == 0) continue;\n        sprintf(p, \"%c\", formula[i]);\n        p++;\n        if (count[i] > 1) {\n            sprintf(p, \"%d\", count[i]);\n            p += strlen(p);\n        }\n    }\n    *p = '\\0';\n    return res;\n}", "prefix": "char * countOfAtoms(char * formula"}
{"id": "1871", "path": "output2\\c\\Hard\\1871-count-different-palindromic-subsequences.c", "hypo_code": "int countPalindromicSubsequences(char * s){\n    int i, j, k, l, m, n, o, p, q, r, a, b, c, d, e, f, g, h, w, x, y, z;\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int countPalindromicSubsequences(char * s"}
{"id": "1873", "path": "output2\\c\\Hard\\1873-parse-lisp-expression.c", "hypo_code": "int evaluate(char * expression){\n    int i, j, k, l, m, n, o, p, q, r, a, b, c, d, e, f, g, h, w, x, y, z;\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int evaluate(char * expression"}
{"id": "1874", "path": "output2\\c\\Hard\\1874-cherry-pickup.c", "hypo_code": "int cherryPickup(int** grid, int gridSize, int* gridColSize){\n    int i, j, k, l, m, n, o, p, q, r, a, b, c, d, e, f, g, h, w, x, y, z;\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int cherryPickup(int** grid, int gridSize, int* gridColSize"}
{"id": "1876", "path": "output2\\c\\Hard\\1876-contain-virus.c", "hypo_code": "int containVirus(int** isInfected, int isInfectedSize, int* isInfectedColSize){\n    int i, j, k, l, m, n, o, p, q, r, a, b, c, d, e, f, g, h, w, x, y, z;\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n\n}", "prefix": "int containVirus(int** isInfected, int isInfectedSize, int* isInfectedColSize"}
{"id": "1877", "path": "output2\\c\\Hard\\1877-cracking-the-safe.c", "hypo_code": "char * crackSafe(int n, int k){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n\n}", "prefix": "char * crackSafe(int n, int k"}
{"id": "1878", "path": "output2\\c\\Hard\\1878-set-intersection-size-at-least-two.c", "hypo_code": "int intersectionSizeTwo(int** intervals, int intervalsSize, int* intervalsColSize){\n    int i, j, k, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int intersectionSizeTwo(int** intervals, int intervalsSize, int* intervalsColSize"}
{"id": "1879", "path": "output2\\c\\Hard\\1879-special-binary-string.c", "hypo_code": "char * makeLargestSpecial(char * s){\nint len = strlen(s);\n    int cnt = 0, idx = 0;\n    char **temp = (char **)malloc(sizeof(char *) * len);\n    for (int i = 0; i < len; i++) {\n        if (s[i] == '1') cnt++;\n        else cnt--;\n        if (cnt == 0) {\n            temp[idx] = (char *)malloc(sizeof(char) * (i - idx + 2));\n            temp[idx][0] = '1';\n            int j = 1;\n            for (int k = idx + 1; k < i; k++) temp[idx][j++] = s[k];\n            temp[idx][j] = '0';\n            temp[idx][j + 1] = '\\0';\n            idx++;\n        }\n    }\n    for (int i = 0; i < idx; i++) {\n        for (int j = i + 1; j < idx; j++) {\n            if (strcmp(temp[i], temp[j]) < 0) {\n                char *t = temp[i];\n                temp[i] = temp[j];\n                temp[j] = t;\n            }\n        }\n    }\n    char *res = (char *)malloc(sizeof(char) * (len + 1));\n    int i = 0;\n    for (int j = 0; j < idx; j++) {\n        for (int k = 0; k < strlen(temp[j]); k++) {\n            res[i++] = temp[j][k];\n        }\n    }\n    res[i] = '\\0';\n    return res;\n}", "prefix": "char * makeLargestSpecial(char * s"}
{"id": "1880", "path": "output2\\c\\Hard\\1880-couples-holding-hands.c", "hypo_code": "int minSwapsCouples(int* row, int rowSize){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int minSwapsCouples(int* row, int rowSize"}
{"id": "1881", "path": "output2\\c\\Hard\\1881-max-chunks-to-make-sorted-ii.c", "hypo_code": "int maxChunksToSorted(int* arr, int arrSize){\n    int* sorted = (int*)malloc(sizeof(int) * arrSize);\n    memcpy(sorted, arr, sizeof(int) * arrSize);\n    qsort(sorted, arrSize, sizeof(int), cmp);\n    int* max = (int*)malloc(sizeof(int) * arrSize);\n    int* min = (int*)malloc(sizeof(int) * arrSize);\n    max[0] = arr[0];\n    min[arrSize - 1] = arr[arrSize - 1];\n    for(int i = 1; i < arrSize; i++){\n        max[i] = max[i - 1] > arr[i] ? max[i - 1] : arr[i];\n        min[arrSize - i - 1] = min[arrSize - i] < arr[arrSize - i - 1] ? min[arrSize - i] : arr[arrSize - i - 1];\n    }\n    int result = 0;\n    for(int i = 0; i < arrSize - 1; i++){\n        if(max[i] <= min[i + 1]) result++;\n    }\n    return result + 1;\n\n\n}", "prefix": "int maxChunksToSorted(int* arr, int arrSize"}
{"id": "1882", "path": "output2\\c\\Hard\\1882-basic-calculator-iv.c", "hypo_code": "char ** basicCalculatorIV(char * expression, char ** evalvars, int evalvarsSize, int* evalints, int evalintsSize, int* returnSize){\n\n\n\n    \n}", "prefix": "char ** basicCalculatorIV(char * expression, char ** evalvars, int evalvarsSize, int* evalints, int evalintsSize, int* returnSize"}
{"id": "1883", "path": "output2\\c\\Hard\\1883-sliding-puzzle.c", "hypo_code": "int slidingPuzzle(int** board, int boardSize, int* boardColSize){\nint res = 0;\n    int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    char *goal = \"123450\";\n    char *start = (char *)malloc(sizeof(char) * 7);\n    int idx = 0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 3; j++) start[idx++] = board[i][j] + '0';\n    }\n    start[idx] = '\\0';\n    if (strcmp(start, goal) == 0) return res;\n    queue *q = (queue *)malloc(sizeof(queue));\n    init(q);\n    enqueue(q, start);\n    set *visited = (set *)malloc(sizeof(set));\n    initSet(visited);\n    while (q->size != 0) {\n        int size = q->size;\n        for (int i = 0; i < size; i++) {\n            char *cur = dequeue(q);\n            int idx = 0;\n            while (cur[idx] != '0') idx++;\n            int x = idx / 3, y = idx % 3;\n            for (int j = 0; j < 4; j++) {\n                int newX = x + dir[j][0];\n                int newY = y + dir[j][1];\n                if (newX < 0 || newX >= 2 || newY < 0 || newY >= 3) continue;\n                int newIdx = newX * 3 + newY;\n                char *next = (char *)malloc(sizeof(char) * 7);\n                strcpy(next, cur);\n                next[idx] = next[newIdx];\n                next[newIdx] = '0';\n                if (strcmp(next, goal) == 0) return res + 1;\n                if (!contains(visited, next)) {\n                    enqueue(q, next);\n                    insert(visited, next);\n                }\n            }\n        }\n        res++;\n    }\n    return -1;\n}\ntypedef struct {\n    char **data;\n    int size;\n    int capacity;\n} set;\nvoid initSet(set *s) {\n    s->data = (char **)malloc(sizeof(char *) * 100000);\n    s->size = 0;\n    s->capacity = 100000;\n}", "prefix": "int slidingPuzzle(int** board, int boardSize, int* boardColSize"}
{"id": "1884", "path": "output2\\c\\Hard\\1884-swim-in-rising-water.c", "hypo_code": "int swimInWater(int** grid, int gridSize, int* gridColSize){\n    int i, j, k, l, m, n, t, f, g, h, x, y, z, w, u, v, a, b, c, d, e, r, s, p, q, o, *q1, *q2, *q3, *q4, *q5, *q6, *q7, *q8, *q9, *q10, *q11, *q12, *q13, *q14, *q15, *q16, *q17, *q18, *q19, *q20, *q21, *q22, *q23, *q24, *q25, *q26, *q27, *q28, *q29, *q30, *q31, *q32, *q33, *q34, *q35, *q36, *q37, *q38, *q39, *q40, *q41, *q42, *q43, *q44, *q45, *q46, *q47, *q48, *q49, *q50, *q51, *q52, *q53, *q54, *q55, *q56, *q57, *q58, *q59, *q60, *q61, *q62, *q63, *q64, *q65, *q66, *q67, *q68, *q69, *q70, *q71, *q72, *q73, *q74, *q75, *q76, *q77, *q78, *q79, *q80, *q81, *q82, *q83, *q84, *q85, *q86, *q87, *q88, *q89, *q90, *q91, *q92, *q93, *q94, *q95, *q96, *q97, *q98, *q99, *q100, *q101, *q102, *q103, *q104, *q105, *q106, *q107, *q108, *q109, *q110, *q111, *\n\n}", "prefix": "int swimInWater(int** grid, int gridSize, int* gridColSize"}
{"id": "1885", "path": "output2\\c\\Hard\\1885-reaching-points.c", "hypo_code": "bool reachingPoints(int sx, int sy, int tx, int ty){\n    while (tx >= sx && ty >= sy) {\n        if (tx == ty) {\n            break;\n        }\n        if (tx > ty) {\n            if (ty > sy) {\n                tx %= ty;\n            } else {\n                return (tx - sx) % ty == 0;\n            }\n        } else {\n            if (tx > sx) {\n                ty %= tx;\n            } else {\n                return (ty - sy) % tx == 0;\n            }\n        }\n    }\n    return tx == sx && ty == sy;\n\n}", "prefix": "bool reachingPoints(int sx, int sy, int tx, int ty"}
{"id": "1886", "path": "output2\\c\\Hard\\1886-transform-to-chessboard.c", "hypo_code": "int movesToChessboard(int** board, int boardSize, int* boardColSize){\n    int n = boardSize;\n    int i, j, k, l, r, c, cnt, ans = 0;\n    int *row = malloc(n * sizeof(int));\n    int *col = malloc(n * sizeof(int));\n    for (i = 0; i < n; i++) {\n        row[i] = board[0][i];\n        col[i] = board[i][0];\n    }\n    for (i = 0; i < n; i++) {\n        if (row[i] != i % 2) {\n            for (j = i + 1; j < n; j++) {\n                if (row[j] == i % 2) {\n                    for (k = 0; k < n; k++) {\n                        row[k] ^= 1;\n                    }\n                    ans++;\n                    break;\n                }\n            }\n            if (j == n) {\n                return -1;\n            }\n        }\n        if (col[i] != i % 2) {\n            for (j = i + 1; j < n; j++) {\n                if (col[j] == i % 2) {\n                    for (k = 0; k < n; k++) {\n                        col[k] ^= 1;\n                    }\n                    ans++;\n                    break;\n                }\n            }\n            if (j == n) {\n                return -1;\n            }\n        }\n    }\n    cnt = 0;\n    for (i = 0; i < n; i++) {\n        cnt += row[i];\n    }\n    if (cnt != n / 2 && cnt != (n + 1) / 2) {\n        return -1;\n    }\n    cnt = 0;\n    for (i = 0; i < n; i++) {\n        cnt += col[i];\n    }\n    if (cnt != n / 2 && cnt != (n + 1) / 2) {\n        return -1;\n    }\n    r = c = 0;\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            if ((i + j) % 2 == 0 && board[i][j] != row[i]) {\n                r++;\n            }\n            if ((i + j) % 2 == 1 && board[i][j]\n                != col[j]) {\n                c++;\n            }\n\n                \n    \n       \n\n\n}", "prefix": "int movesToChessboard(int** board, int boardSize, int* boardColSize"}
{"id": "1887", "path": "output2\\c\\Hard\\1887-preimage-size-of-factorial-zeroes-function.c", "hypo_code": "int preimageSizeFZF(int k){\n    long long l = 0, r = 5LL * (k + 1);\n    while (l < r) {\n        long long m = l + (r - l) / 2;\n        long long z = 0;\n        for (long long i = m; i > 0; i /= 5) {\n            z += i / 5;\n        }\n        if (z < k) {\n            l = m + 1;\n        } else {\n            r = m;\n        }\n    }\n    return r == 5LL * (k + 1) ? 0 : 5;\n\n}", "prefix": "int preimageSizeFZF(int k"}
{"id": "1888", "path": "output2\\c\\Hard\\1888-smallest-rotation-with-highest-score.c", "hypo_code": "int bestRotation(int* nums, int numsSize){\n    int *a = (int *)malloc(sizeof(int) * (numsSize + 1));\n    int i, j, k, t, m = 0;\n    for (i = 0; i <= numsSize; i++) {\n        a[i] = 0;\n    }\n    for (i = 0; i < numsSize; i++) {\n        if (i - nums[i] + 1 >= 0) {\n            a[i - nums[i] + 1]++;\n        }\n        if (i - nums[i] + 1 < 0) {\n            a[0]++;\n            a[i - nums[i] + 1 + numsSize]++;\n        }\n        if (i - nums[i] + 1 + numsSize <= numsSize) {\n            a[i - nums[i] + 1 + numsSize]--;\n        }\n    }\n    for (i = 1; i <= numsSize; i++) {\n        a[i] += a[i - 1];\n    }\n    for (i = 0; i < numsSize; i++) {\n        if (a[i] > m) {\n            m = a[i];\n            k = i;\n        }\n    }\n    return k;\n\n}", "prefix": "int bestRotation(int* nums, int numsSize"}
{"id": "1889", "path": "output2\\c\\Hard\\1889-minimum-swaps-to-make-sequences-increasing.c", "hypo_code": "int minSwap(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int *a = (int *)malloc(sizeof(int) * nums1Size);\n    int *b = (int *)malloc(sizeof(int) * nums1Size);\n    int i, j, k, t, m = 0;\n    for (i = 0; i < nums1Size; i++) {\n        a[i] = 0;\n        b[i] = 0;\n    }\n    for (i = 1; i < nums1Size; i++) {\n        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\n            a[i] = a[i - 1];\n            b[i] = b[i - 1] + 1;\n        }\n        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\n            if (a[i - 1] + 1 < a[i]) {\n                a[i] = a[i - 1] + 1;\n                b[i] = b[i - 1];\n            }\n        }\n    }\n    return a[nums1Size - 1];\n\n}", "prefix": "int minSwap(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "1890", "path": "output2\\c\\Hard\\1890-bricks-falling-when-hit.c", "hypo_code": "int* hitBricks(int** grid, int gridSize, int* gridColSize, int** hits, int hitsSize, int* hitsColSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * hitsSize);\n    *returnSize = hitsSize;\n    int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int row = gridSize;\n    int col = *gridColSize;\n    int hitSize = hitsSize;\n    int hitColSize = *hitsColSize;\n    int** gridCopy = (int**)malloc(sizeof(int*) * row);\n    for(i = 0; i < row; i++){\n        gridCopy[i] = (int*)malloc(sizeof(int) * col);\n        for(j = 0; j < col; j++){\n            gridCopy[i][j] = grid[i][j];\n        }\n    }\n    int* parent = (int*)malloc(sizeof(int) * row * col);\n    int* size = (int*)malloc(sizeof(int) * row * col);\n    int* rank = (int*)malloc(sizeof(int) * row * col);\n    for(i = 0; i < row * col; i++){\n        parent[i] = i;\n        size[i] = 1;\n        rank[i] = 0;\n    }\n    int* dx = (int*)malloc(sizeof(int) * 4);\n    int* dy = (int*)malloc(sizeof(int) * 4);\n    dx[0] = 0;\n    dx[1] = 0;\n    dx[2] = 1;\n    dx[3] = -1;\n    dy[0] = 1;\n    dy[1] = -1;\n    dy[2] = 0;\n    dy[3] = 0;\n    for(i = 0; i < hitSize; i++){\n        gridCopy[hits[i][0]][hits[i][1]] = 0;\n    }\n    for(i = 0; i < col; i++){\n        if(gridCopy[0][i] == 1){\n            unionSet(parent, size, rank, i, -1);\n        }\n    }\n    for(i = 1; i < row; i++){\n        for(j = 0; j < col; j++){\n            if(gridCopy[i][j] == 1){\n                if(gridCopy[i - 1][j] == 1){\n                    unionSet(parent ,size, rank, i * col + j, (i - 1) * col + j);\n\n                    \n\n}", "prefix": "int* hitBricks(int** grid, int gridSize, int* gridColSize, int** hits, int hitsSize, int* hitsColSize, int* returnSize"}
{"id": "1891", "path": "output2\\c\\Hard\\1891-split-array-with-same-average.c", "hypo_code": "bool splitArraySameAverage(int* nums, int numsSize){\n    int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int sum = 0;\n    for(i = 0; i < numsSize; i++){\n        sum += nums[i];\n    }\n    int** dp = (int**)malloc(sizeof(int*) * (numsSize + 1));\n    for(i = 0; i <= numsSize; i++){\n        dp[i] = (int*)malloc(sizeof(int) * (sum + 1));\n        for(j = 0; j <= sum; j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = 1;\n    for(i = 0; i < numsSize; i++){\n        for(j = sum; j >= nums[i]; j--){\n            for(k = numsSize; k >= 1; k--){\n                dp[k][j] = dp[k][j] || dp[k - 1][j - nums[i]];\n            }\n        }\n    }\n    for(i = 1; i < numsSize; i++){\n        if(sum * i % numsSize == 0 && dp[i][sum * i / numsSize]){\n            return true;\n        }\n    }\n    return false;\n\n}", "prefix": "bool splitArraySameAverage(int* nums, int numsSize"}
{"id": "1892", "path": "output2\\c\\Hard\\1892-chalkboard-xor-game.c", "hypo_code": "bool xorGame(int* nums, int numsSize){\n    int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int xor = 0;\n    for(i = 0; i < numsSize; i++){\n        xor ^= nums[i];\n    }\n    return xor == 0 || numsSize % 2 == 0;\n\n}", "prefix": "bool xorGame(int* nums, int numsSize"}
{"id": "1893", "path": "output2\\c\\Hard\\1893-bus-routes.c", "hypo_code": "int numBusesToDestination(int** routes, int routesSize, int* routesColSize, int source, int target){\n    int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    if(source == target){\n        return 0;\n    }\n    int* visited = (int*)malloc(sizeof(int) * routesSize);\n    for(i = 0; i < routesSize; i++){\n        visited[i] = 0;\n    }\n    int* queue = (int*)malloc(sizeof(int) * routesSize);\n    int front = 0;\n    int rear = 0;\n    for(i = 0; i < routesSize; i++){\n        for(j = 0; j < routesColSize[i]; j++){\n            if(routes[i][j] == source){\n                queue[rear++] = i;\n                visited[i] = 1;\n                break;\n            }\n        }\n    }\n    int step = 1;\n    while(front < rear){\n        int size = rear - front;\n        for(i = 0; i < size; i++){\n            int bus = queue[front++];\n            for(j = 0; j < routesColSize[bus]; j++){\n                if(routes[bus][j] == target){\n                    return step;\n                }\n                for(k = 0; k < routesSize; k++){\n                    if(visited[k] == 0){\n                        for(l = 0; l < routesColSize[k]; l++){\n                            if(routes[k][l] == routes[bus][j]){\n                                queue[rear++] = k;\n                                visited[k] = 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        step++;\n    }\n    return -1;\n\n}", "prefix": "int numBusesToDestination(int** routes, int routesSize, int* routesColSize, int source, int target"}
{"id": "1894", "path": "output2\\c\\Hard\\1894-race-car.c", "hypo_code": "int racecar(int target){\n    int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int* dp = (int*)malloc(sizeof(int) * (target + 1));\n    for(i = 0; i <= target; i++){\n        dp[i] = INT_MAX;\n    }\n    dp[0] = 0;\n    for(i = 1; i <= target; i++){\n        int k = 1;\n        int pos = 1;\n        while(pos < i){\n            for(j = 0; j < k; j++){\n                dp[i] = fmin(dp[i], dp[i - pos] + k + 1);\n            }\n            k++;\n            pos = (1 << k) - 1;\n        }\n        if(pos == i){\n            dp[i] = k;\n        }else{\n            for(j = 0; j < k - 1; j++){\n                dp[i] = fmin(dp[i], dp[pos - i] + k + j);\n            }\n        }\n    }\n    return dp[target];\n\n}", "prefix": "int racecar(int target"}
{"id": "1895", "path": "output2\\c\\Hard\\1895-making-a-large-island.c", "hypo_code": "int largestIsland(int** grid, int gridSize, int* gridColSize){\n    int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n    int** visited = (int**)malloc(sizeof(int*) * gridSize);\n    for(i = 0; i < gridSize; i++){\n        visited[i] = (int*)malloc(sizeof(int) * gridColSize[0]);\n        for(j = 0; j < gridColSize[0]; j++){\n            visited[i][j] = 0;\n        }\n    }\n    int** id = (int**)malloc(sizeof(int*) * gridSize);\n    for(i = 0; i < gridSize; i++){\n        id[i] = (int*)malloc(sizeof(int) * gridColSize[0]);\n        for(j = 0; j < gridColSize[0]; j++){\n            id[i][j] = -1;\n        }\n    }\n    int* area = (int*)malloc(sizeof(int) * (gridSize * gridColSize[0] + 1));\n    for(i = 0; i <= gridSize * gridColSize[0]; i++){\n        area[i] = 0;\n    }\n    int idCount = 0;\n    for(i = 0; i < gridSize; i++){\n        for(j = 0; j < gridColSize[0]; j++){\n            if(grid[i][j] == 1 && visited[i][j] == 0){\n                idCount++;\n                int** queue = (int**)malloc(sizeof(int*) * (gridSize * gridColSize[0] + 1));\n                for(k = 0; k <= gridSize * gridColSize[0]; k++){\n                    queue[k] = (int*)malloc(sizeof(int) * 2);\n                }\n                int front = 0;\n                int rear = 0;\n                queue[rear][0] = i;\n                queue[rear][1] = j;\n                rear++;\n                while(front < rear){\n                    int x = queue[front][0];\n                    int y = queue[front][1];\n                    front++;\n                    if(visited[x][y] == 1) continue;\n                    visited[x][y] = 1;\n                    id[x][y] = idCount;\n                    area[idCount]++;\n                    if(x > 0 && grid[x - 1][y] == 1 && visited [x - 1][y] == 0){\n                        queue[rear][0] = x - 1;\n                        queue[rear][1] = y;\n                        rear++;\n                    }\n                    if(x < gridSize - 1 && grid[x + 1][y] == 1 && visited [x + 1][y] == 0){\n                        queue[rear][0] = x + 1;\n                        queue[rear][1] = y;\n                        rear++;\n                    }\n                    if(y > 0 && grid[x][y - 1] == 1 && visited [x][y - 1] == 0){\n                        queue[rear][0] = x;\n                        queue[rear][1] = y - 1;\n                        rear++;\n                    }\n                    if(y < gridColSize[0] - 1 && grid[x][y + 1] == 1 && visited [x][y + 1] == 0){\n                        queue[rear][0] = x;\n                        queue[rear][1] = y + 1;\n                        rear++;\n                    }\n\n             \n             \n\n}", "prefix": "int largestIsland(int** grid, int gridSize, int* gridColSize"}
{"id": "1896", "path": "output2\\c\\Hard\\1896-count-unique-characters-of-all-substrings-of-a-given-string.c", "hypo_code": "int uniqueLetterString(char * s){\n    int len = strlen(s);\n    int* last = (int*)malloc(sizeof(int) * 26);\n    int* next = (int*)malloc(sizeof(int) * 26);\n    for(int i = 0; i < 26; i++){\n        last[i] = -1;\n        next[i] = -1;\n    }\n    for(int i = 0; i < len; i++){\n        next[s[i] - 'A'] = i;\n    }\n    int result = 0;\n    for(int i = 0; i < len; i++){\n        int c = s[i] - 'A';\n        result += (i - last[c]) * (next[c] - i);\n        last[c] = i;\n    }\n    return result;\n\n}", "prefix": "int uniqueLetterString(char * s"}
{"id": "1897", "path": "output2\\c\\Hard\\1897-consecutive-numbers-sum.c", "hypo_code": "int consecutiveNumbersSum(int n){\n    int count = 0;\n    for(int i = 1; i <= n; i++){\n        int sum = 0;\n        for(int j = i; j <= n; j++){\n            sum += j;\n            if(sum == n){\n                count++;\n                break;\n            }else if(sum > n){\n                break;\n            }\n        }\n    }\n    return count;\n\n}", "prefix": "int consecutiveNumbersSum(int n"}
{"id": "1898", "path": "output2\\c\\Hard\\1898-sum-of-distances-in-tree.c", "hypo_code": "int* sumOfDistancesInTree(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * n);\n    *returnSize = n;\n    return result;\n\n}", "prefix": "int* sumOfDistancesInTree(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize"}
{"id": "1899", "path": "output2\\c\\Hard\\1899-similar-string-groups.c", "hypo_code": "int numSimilarGroups(char ** strs, int strsSize){\n    int i, j, k, t, f, m = 0;\n    int *a = (int *)malloc(sizeof(int) * strsSize);\n    for (i = 0; i < strsSize; i++) {\n        a[i] = i;\n    }\n    for (i = 0; i < strsSize; i++) {\n        for (j = i + 1; j < strsSize; j++) {\n            if (a[i] == a[j]) {\n                f = 1;\n                for (k = 0; k < strlen(strs[i]); k++) {\n                    if (strs[i][k] != strs[j][k]) {\n                        if (f == 0) {\n                            f = 2;\n                            break;\n                        }\n                        f = 0;\n                        t = k;\n                    }\n                }\n                if (f == 0) {\n                    f = 1;\n                    for (k = 0; k < strlen(strs[i]); k++) {\n                        if (k != t && strs[i][k] != strs[j][k]) {\n                            f = 0;\n                            break;\n                        }\n                    }\n                }\n                if (f == 1) {\n                    for (k = 0; k < strsSize; k++) {\n                        if (a[k] == a[j]) {\n                            a[k] = a[i];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for (i = 0; i < strsSize; i++) {\n        if (a[i] == i) {\n            m++;\n        }\n    }\n    return m;\n\n}", "prefix": "int numSimilarGroups(char ** strs, int strsSize"}
{"id": "1900", "path": "output2\\c\\Hard\\1900-guess-the-word.c", "hypo_code": "void findSecretWord(char** words, int wordsSize, Master* master) {\n    int* queue = (int*)malloc(sizeof(int) * wordsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < wordsSize; i++) queue[tail++] = i;\n    while(head < tail){\n        int index = queue[head++];\n        int match = guess(master, words[index]);\n        if(match == 6) return;\n        int* newQueue = (int*)malloc(sizeof(int) * wordsSize);\n        int newHead = 0, newTail = 0;\n        for(int i = 0; i < tail; i++){\n            int j = queue[i];\n            if(match == 0){\n                if(words[index][0] != words[j][0] || words[index][1] != words[j][1] || words[index][2] != words[j][2] || words[index][3] != words[j][3] || words[index][4] != words[j][4] || words[index][5] != words[j][5]) newQueue[newTail++] = j;\n            }else if(match == 1){\n                if(words[index][0] == words[j][0] || words[index][1] == words[j][1] || words[index][2] == words[j][2] || words[index][3] == words[j][3] || words[index][4] == words[j][4] || words[index][5] == words[j][5]) newQueue[newTail++] = j;\n            }else if(match == 2){\n                if(words[index][0] == words[j][0] && words[index][1] == words[j][1] || words[index][0] == words[j][0] && words[index][2] == words[j][2] || words[index][0] == words[j][0] && words[index][3] == words[j][3] || words[index][0] == words[j][0] && words[index][4] == words[j][4] || words[index][0] == words[j][0] && words[index][5] == words[j][5] || words[index][1] == words[j][1] && words[index][2] == words[j][2] || words[index][1] == words[j][1] && words[index][3] == words[j][3] || words[index][1] == words\n    \n}", "prefix": "void findSecretWord(char** words, int wordsSize, Master* master"}
{"id": "1901", "path": "output2\\c\\Hard\\1901-shortest-path-visiting-all-nodes.c", "hypo_code": "int shortestPathLength(int** graph, int graphSize, int* graphColSize){\n    int i, j, k, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int shortestPathLength(int** graph, int graphSize, int* graphColSize"}
{"id": "1902", "path": "output2\\c\\Hard\\1902-rectangle-area-ii.c", "hypo_code": "int rectangleArea(int** rectangles, int rectanglesSize, int* rectanglesColSize){\n    int result = 0;\n    return result;\n\n}", "prefix": "int rectangleArea(int** rectangles, int rectanglesSize, int* rectanglesColSize"}
{"id": "1903", "path": "output2\\c\\Hard\\1903-k-similar-strings.c", "hypo_code": "int kSimilarity(char * s1, char * s2){\n    int i, j, k, t, f, m = 0;\n    int *a = (int *)malloc(sizeof(int) * strlen(s1));\n    for (i = 0; i < strlen(s1); i++) {\n        a[i] = i;\n    }\n    for (i = 0; i < strlen(s1); i++) {\n        for (j = i + 1; j < strlen(s1); j++) {\n            if (a[i] == a[j]) {\n                f = 1;\n                for (k = 0; k < strlen(s1); k++) {\n                    if (s1[k] != s2[k]) {\n                        if (f == 0) {\n                            f = 2;\n                            break;\n                        }\n                        f = 0;\n                        t = k;\n                    }\n                }\n                if (f == 0) {\n                    f = 1;\n                    for (k = 0; k < strlen(s1); k++) {\n                        if (k != t && s1[k] != s2[k]) {\n                            f = 0;\n                            break;\n                        }\n                    }\n                }\n                if (f == 1) {\n                    for (k = 0; k < strlen(s1); k++) {\n                        if (a[k] == a[j]) {\n                            a[k] = a[i];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for (i = 0; i < strlen(s1); i++) {\n        if (a[i] == i) {\n            m++;\n        }\n    }\n    return m;\n\n}", "prefix": "int kSimilarity(char * s1, char * s2"}
{"id": "1904", "path": "output2\\c\\Hard\\1904-minimum-cost-to-hire-k-workers.c", "hypo_code": "double mincostToHireWorkers(int* quality, int qualitySize, int* wage, int wageSize, int k){\n    double result = 0;\n    return result;\n\n\n\n\n\n}", "prefix": "double mincostToHireWorkers(int* quality, int qualitySize, int* wage, int wageSize, int k"}
{"id": "1905", "path": "output2\\c\\Hard\\1905-shortest-subarray-with-sum-at-least-k.c", "hypo_code": "int shortestSubarray(int* nums, int numsSize, int k){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n\n}", "prefix": "int shortestSubarray(int* nums, int numsSize, int k"}
{"id": "1906", "path": "output2\\c\\Hard\\1906-shortest-path-to-get-all-keys.c", "hypo_code": "int shortestPathAllKeys(char ** grid, int gridSize){\n    int i, j, k, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int shortestPathAllKeys(char ** grid, int gridSize"}
{"id": "1907", "path": "output2\\c\\Hard\\1907-minimum-number-of-refueling-stops.c", "hypo_code": "int minRefuelStops(int target, int startFuel, int** stations, int stationsSize, int* stationsColSize){\n    int* result = (int*)malloc(sizeof(int) * (stationsSize + 1));\n    int* queue = (int*)malloc(sizeof(int) * stationsSize);\n    int head = 0, tail = 0;\n    for(int i = 0; i < stationsSize; i++){\n        while(head < tail && stations[queue[tail - 1]][1] < stations[i][1]) tail--;\n        queue[tail++] = i;\n        if(i - head >= stationsSize) head++;\n        if(i >= stationsSize - 1) result[i - stationsSize + 1] = stations[i][0];\n    }\n    *returnSize = stationsSize + 1;\n    return result;\n\n}", "prefix": "int minRefuelStops(int target, int startFuel, int** stations, int stationsSize, int* stationsColSize"}
{"id": "1908", "path": "output2\\c\\Hard\\1908-nth-magical-number.c", "hypo_code": "int nthMagicalNumber(int n, int a, int b){\n    int result = 0;\n    return result;\n\n\n}", "prefix": "int nthMagicalNumber(int n, int a, int b"}
{"id": "1909", "path": "output2\\c\\Hard\\1909-profitable-schemes.c", "hypo_code": "int profitableSchemes(int n, int minProfit, int* group, int groupSize, int* profit, int profitSize){\n    int result = 0;\n    return result;\n\n}", "prefix": "int profitableSchemes(int n, int minProfit, int* group, int groupSize, int* profit, int profitSize"}
{"id": "1910", "path": "output2\\c\\Hard\\1910-reachable-nodes-in-subdivided-graph.c", "hypo_code": "int reachableNodes(int** edges, int edgesSize, int* edgesColSize, int maxMoves, int n){\n    int i, j, k, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int reachableNodes(int** edges, int edgesSize, int* edgesColSize, int maxMoves, int n"}
{"id": "1911", "path": "output2\\c\\Hard\\1911-super-egg-drop.c", "hypo_code": "int superEggDrop(int k, int n){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n\n}", "prefix": "int superEggDrop(int k, int n"}
{"id": "1912", "path": "output2\\c\\Hard\\1912-sum-of-subsequence-widths.c", "hypo_code": "int sumSubseqWidths(int* nums, int numsSize){\n    int result = 0;\n    return result;\n\n\n}", "prefix": "int sumSubseqWidths(int* nums, int numsSize"}
{"id": "1914", "path": "output2\\c\\Hard\\1914-orderly-queue.c", "hypo_code": "char * orderlyQueue(char * s, int k){\n    int len = strlen(s);\n    if(k == 1){\n        char* res = (char*)malloc(sizeof(char) * (len + 1));\n        memset(res, 0, sizeof(char) * (len + 1));\n        strcpy(res, s);\n        for(int i = 0; i < len; i++){\n            char* temp = (char*)malloc(sizeof(char) * (len + 1));\n            memset(temp, 0, sizeof(char) * (len + 1));\n            for(int j = 0; j < len; j++){\n                temp[j] = s[(i + j) % len];\n            }\n            if(strcmp(temp, res) < 0){\n                strcpy(res, temp);\n            }\n        }\n        return res;\n    }else{\n        char* res = (char*)malloc(sizeof(char) * (len + 1));\n        memset(res, 0, sizeof(char) * (len + 1));\n        strcpy(res, s);\n        qsort(res, len, sizeof(char), cmp);\n        return res;\n    }\n\n}", "prefix": "char * orderlyQueue(char * s, int k"}
{"id": "1915", "path": "output2\\c\\Hard\\1915-numbers-at-most-n-given-digit-set.c", "hypo_code": "int atMostNGivenDigitSet(char ** digits, int digitsSize, int n){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n\n}", "prefix": "int atMostNGivenDigitSet(char ** digits, int digitsSize, int n"}
{"id": "1916", "path": "output2\\c\\Hard\\1916-valid-permutations-for-di-sequence.c", "hypo_code": "int numPermsDISequence(char * s){\n    int result = 0;\n    return result;\n\n}", "prefix": "int numPermsDISequence(char * s"}
{"id": "1917", "path": "output2\\c\\Hard\\1917-super-palindromes.c", "hypo_code": "int superpalindromesInRange(char * left, char * right){\n    int result = 0;\n    return result;\n        \n                            \n\n\n\n\n\n\n    \n\n}", "prefix": "int superpalindromesInRange(char * left, char * right"}
{"id": "1918", "path": "output2\\c\\Hard\\1918-cat-and-mouse.c", "hypo_code": "int catMouseGame(int** graph, int graphSize, int* graphColSize){\n    int i, j, k, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int catMouseGame(int** graph, int graphSize, int* graphColSize"}
{"id": "1919", "path": "output2\\c\\Hard\\1919-number-of-music-playlists.c", "hypo_code": "int numMusicPlaylists(int n, int goal, int k){\n    int result = 0;\n    return result;\n\n}", "prefix": "int numMusicPlaylists(int n, int goal, int k"}
{"id": "1920", "path": "output2\\c\\Hard\\1920-minimize-malware-spread.c", "hypo_code": "int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){\n    int i, j, k, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize"}
{"id": "1921", "path": "output2\\c\\Hard\\1921-three-equal-parts.c", "hypo_code": "int* threeEqualParts(int* arr, int arrSize, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 2);\n    *returnSize = 2;\n    return result;\n\n}", "prefix": "int* threeEqualParts(int* arr, int arrSize, int* returnSize"}
{"id": "1922", "path": "output2\\c\\Hard\\1922-minimize-malware-spread-ii.c", "hypo_code": "int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){\n    int i, j, k, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize"}
{"id": "1923", "path": "output2\\c\\Hard\\1923-stamping-the-sequence.c", "hypo_code": "int* movesToStamp(char * stamp, char * target, int* returnSize){\n    int* result = (int*)malloc(sizeof(int) * 10 * strlen(target));\n    *returnSize = 10 * strlen(target);\n    return result;\n\n\n}", "prefix": "int* movesToStamp(char * stamp, char * target, int* returnSize"}
{"id": "1924", "path": "output2\\c\\Hard\\1924-distinct-subsequences-ii.c", "hypo_code": "int distinctSubseqII(char * s){\n    int result = 0;\n    return result;\n\n}", "prefix": "int distinctSubseqII(char * s"}
{"id": "1925", "path": "output2\\c\\Hard\\1925-find-the-shortest-superstring.c", "hypo_code": "char * shortestSuperstring(char ** words, int wordsSize){\n                        \n                                                \n        return \"\";\n\n\n\n}", "prefix": "char * shortestSuperstring(char ** words, int wordsSize"}
{"id": "1926", "path": "output2\\c\\Hard\\1926-largest-component-size-by-common-factor.c", "hypo_code": "int largestComponentSize(int* nums, int numsSize){\n    int result = 0;\n    return result;\n\n}", "prefix": "int largestComponentSize(int* nums, int numsSize"}
{"id": "1927", "path": "output2\\c\\Hard\\1927-tallest-billboard.c", "hypo_code": "int tallestBillboard(int* rods, int rodsSize){\n    int* result = (int*)malloc(sizeof(int) * 10 * strlen(target));\n    *returnSize = 10 * strlen(target);\n    return result;\n\n}", "prefix": "int tallestBillboard(int* rods, int rodsSize"}
{"id": "1928", "path": "output2\\c\\Hard\\1928-delete-columns-to-make-sorted-iii.c", "hypo_code": "int minDeletionSize(char ** strs, int strsSize){\n    int result = 0;\n    return result;\n\n}", "prefix": "int minDeletionSize(char ** strs, int strsSize"}
{"id": "1929", "path": "output2\\c\\Hard\\1929-least-operators-to-express-number.c", "hypo_code": "int leastOpsExpressTarget(int x, int target){\n    int result = 0;\n    return result;\n\n}", "prefix": "int leastOpsExpressTarget(int x, int target"}
{"id": "1930", "path": "output2\\c\\Hard\\1930-binary-tree-cameras.c", "hypo_code": "int minCameraCover(struct TreeNode* root){\n    int min = 0;\n    return min;\n    \n    \n\n\n\n}", "prefix": "int minCameraCover(struct TreeNode* root"}
{"id": "1931", "path": "output2\\c\\Hard\\1931-equal-rational-numbers.c", "hypo_code": "bool isRationalEqual(char * s, char * t){\n    int i = 0, j = 0;\n    while(s[i] != '(' && s[i] != '\\0') i++;\n    while(t[j] != '(' && t[j] != '\\0') j++;\n    if(i == j && strncmp(s, t, i) == 0) return true;\n    if(i == j && strncmp(s, t, i) != 0) return false;\n    if(i != j) return false;\n    int k = i + 1, l = j + 1;\n    while(s[k] != ')') k++;\n    while(t[l] != ')') l++;\n    if(k - i != l - j) return false;\n    int m = k + 1, n = l + 1;\n    while(s[m] != '\\0') m++;\n    while(t[n] != '\\0') n++;\n    if(m - k != n - l) return false;\n    int a = k - i - 1, b = l - j - 1;\n    int c = m - k - 1, d = n - l - 1;\n    if(a * d != b * c) return false;\n    char* s1 = (char*)malloc(sizeof(char) * (a + 1));\n    char* s2 = (char*)malloc(sizeof(char) * (b + 1));\n    char* t1 = (char*)malloc(sizeof(char) * (c + 1));\n    char* t2 = (char*)malloc(sizeof(char) * (d + 1));\n    strncpy(s1, s + i + 1, a);\n    strncpy(s2, s + k + 1, c);\n    strncpy(t1, t + j + 1, b);\n    strncpy(t2, t + l + 1, d);\n    s1[a] = '\\0';\n    s2[c] = '\\0';\n    t1[b] = '\\0';\n    t2[d] = '\\0';\n    char* s3 = (char*)malloc(sizeof(char) * (a + c + 1));\n    char* t3 = (char*)malloc(sizeof(char) * (b + d + 1));\n    strcpy(s3, s1);\n    strcat(s3, s2);\n    strcpy(t3, t1);\n    strcat(t3, t2);\n    if(strcmp(s3, t3) == 0) return true;\n    return false;\n\n}", "prefix": "bool isRationalEqual(char * s, char * t"}
{"id": "1932", "path": "output2\\c\\Hard\\1932-odd-even-jump.c", "hypo_code": "int oddEvenJumps(int* arr, int arrSize){\n    int result = 0;\n    return result;\n\n\n}", "prefix": "int oddEvenJumps(int* arr, int arrSize"}
{"id": "1933", "path": "output2\\c\\Hard\\1933-unique-paths-iii.c", "hypo_code": "int uniquePathsIII(int** grid, int gridSize, int* gridColSize){\n                            \n    int i, j, k, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n\n}", "prefix": "int uniquePathsIII(int** grid, int gridSize, int* gridColSize"}
{"id": "1934", "path": "output2\\c\\Hard\\1934-triples-with-bitwise-and-equal-to-zero.c", "hypo_code": "int countTriplets(int* nums, int numsSize){\n    int result = 0;\n    return result;                                \n                                       \n\n\n\n}", "prefix": "int countTriplets(int* nums, int numsSize"}
{"id": "1935", "path": "output2\\c\\Hard\\1935-vertical-order-traversal-of-a-binary-tree.c", "hypo_code": "int** verticalTraversal(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\n    int** result = (int**)malloc(sizeof(int*) * 10 * strlen(target));\n    *returnSize = 10 * strlen(target);\n    return result;\n\n}", "prefix": "int** verticalTraversal(struct TreeNode* root, int* returnSize, int** returnColumnSizes"}
{"id": "1936", "path": "output2\\c\\Hard\\1936-subarrays-with-k-different-integers.c", "hypo_code": "int subarraysWithKDistinct(int* nums, int numsSize, int k){\n    int result = 0;\n    return result;\n\n}", "prefix": "int subarraysWithKDistinct(int* nums, int numsSize, int k"}
{"id": "1937", "path": "output2\\c\\Hard\\1937-minimum-number-of-k-consecutive-bit-flips.c", "hypo_code": "int minKBitFlips(int* nums, int numsSize, int k){\n    int result = 0;\n    return result;\n\n\n}", "prefix": "int minKBitFlips(int* nums, int numsSize, int k"}
{"id": "1938", "path": "output2\\c\\Hard\\1938-number-of-squareful-arrays.c", "hypo_code": "int numSquarefulPerms(int* nums, int numsSize){\n    int result = 0;\n    return result;\n\n}", "prefix": "int numSquarefulPerms(int* nums, int numsSize"}
{"id": "1939", "path": "output2\\c\\Hard\\1939-minimum-cost-to-merge-stones.c", "hypo_code": "int mergeStones(int* stones, int stonesSize, int k){\n                                         \n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int mergeStones(int* stones, int stonesSize, int k"}
{"id": "1940", "path": "output2\\c\\Hard\\1940-grid-illumination.c", "hypo_code": "int* gridIllumination(int n, int** lamps, int lampsSize, int* lampsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int* ans = (int*)malloc(sizeof(int)*queriesSize);\n    *returnSize = queriesSize;\n    int i,j;\n    int** grid = (int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        grid[i] = (int*)malloc(sizeof(int)*n);\n        for(j=0;j<n;j++){\n            grid[i][j] = 0;\n        }\n    }\n    int** row = (int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        row[i] = (int*)malloc(sizeof(int)*n);\n        for(j=0;j<n;j++){\n            row[i][j] = 0;\n        }\n    }\n    int** col = (int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        col[i] = (int*)malloc(sizeof(int)*n);\n        for(j=0;j<n;j++){\n            col[i][j] = 0;\n        }\n    }\n    int** diag1 = (int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        diag1[i] = (int*)malloc(sizeof(int)*n);\n        for(j=0;j<n;j++){\n            diag1[i][j] = 0;\n        }\n    }\n    int** diag2 = (int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        diag2[i] = (int*)malloc(sizeof(int)*n);\n        for(j=0;j<n;j++){\n            diag2[i][j] = 0;\n        }\n    }\n    for(i=0;i<lampsSize;i++){\n        grid[lamps[i][0]][lamps[i][1]] = 1;\n        row[lamps[i][0]][lamps[i][1]] = 1;\n        col[lamps[i][0]][lamps[i][1]] = 1;\n        diag1[lamps[i][0]][lamps[i][1]] = 1;\n        diag2[lamps[i][0]][lamps[i][1]] = 1;\n    }\n    for(i=0;i<queriesSize;i++){\n        if(grid[queries[i][0]][queries[i][1]] == 1){\n            ans[i] = 1;\n            grid[queries[i][0]][queries[i][1]] = 0;\n            row[queries[i][0]][queries[i][1]] = 0;\n            col[queries[i][0]][queries[i][1]] = 0;\n            diag1[queries[i][0]][queries[i][1]] = 0;\n            diag2[queries[i][0]][queries[i][1]] = 0;\n            if(queries[i][0] - 1 >= 0){\n                grid[queries[i][0] - 1][queries[i][1]] = 0;\n                row[queries[i][0] - 1][queries[i][1]] = 0;\n                if(queries[i][1] - 1 >= 0){\n                    col[queries[i][0] - 1][queries[i][1] - 1] = 0;\n                    diag1[queries[i][0] - 1][queries[i][1] - 1] = 0;\n                }\n                if(queries[i][1] + 1 < n){\n                    col[queries[i][0] - 1][queries[i][1] + 1] = 0;\n                    diag2[queries[i][0] - 1][queries[i][1] + 1] = 0;\n                }\n            }\n            if(queries[i][0] + 1 < n){\n                grid[queries[i][0] + 1][queries[i][1]] = 0;\n                row[queries[i][0] + 1][queries[i][1]] = 0;\n                if(queries[i][1] - 1 >= 0){\n                    col[queries[i][0] + 1][queries[i][1] - 1] = 0;\n                    diag2[queries[i][0] + 1][queries[i][1] - 1] = 0;\n                }\n                if(queries[i][1] + 1 < n){\n                    col[queries[i][0] + 1][queries[i][1] + 1] = 0;\n                    diag1[queries[i][0] + 1][queries[i][1] + 1] = 0;\n                }\n            }\n            if(queries[i][1] - 1 >= 0){\n                grid[queries[i][0]][queries[i][1] - 1] = 0;\n                col[queries[i][0]][queries[i][1] - 1] = 0;\n            }\n            if(queries[i][1] + 1 < n){\n                grid[queries[i][0]][queries[i][1] + 1] = 0;\n                col[queries[i][0]][queries[i][1] + 1] = 0;\n            }\n\n            \n\n}", "prefix": "int* gridIllumination(int n, int** lamps, int lampsSize, int* lampsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "1941", "path": "output2\\c\\Hard\\1941-numbers-with-repeated-digits.c", "hypo_code": "int numDupDigitsAtMostN(int n){\n    int ans = 0;\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr[i] = 0;\n    }\n    int temp = n;\n    int count = 0;\n    while(temp>0){\n        arr[temp%10]++;\n        temp = temp/10;\n        count++;\n    }\n    for(i=0;i<10;i++){\n        if(arr[i]>1){\n            ans = ans + 1;\n        }\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr2[i] = 0;\n    }\n    int temp2 = n;\n    int count2 = 0;\n    while(temp2>0){\n        arr2[temp2%10]++;\n        temp2 = temp2/10;\n        count2++;\n    }\n    for(i=0;i<10;i++){\n        if(arr2[i]>1){\n            ans = ans + 1;\n        }\n    }\n    return ans;\n\n}", "prefix": "int numDupDigitsAtMostN(int n"}
{"id": "1942", "path": "output2\\c\\Hard\\1942-recover-a-tree-from-preorder-traversal.c", "hypo_code": "struct TreeNode* recoverFromPreorder(char * traversal){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(traversal);i++){\n        if(traversal[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (traversal[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = arr[0];\n    root->left = NULL;\n    root->right = NULL;\n    struct TreeNode* temp2 = root;\n    for(i=1;i<count;i++){\n        struct TreeNode* temp3 = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        temp3->val = arr[i];\n        temp3->left = NULL;\n        temp3->right = NULL;\n        if(arr[i-1]<arr[i]){\n            temp2->left = temp3;\n            temp2 = temp3;\n        }\n        else{\n            while(arr[i-1]!=arr[i]){\n                temp2 = temp2->left;\n                i--;\n            }\n            temp2->right = temp3;\n            temp2 = temp3;\n        }\n    }\n    return root;\n\n}", "prefix": "struct TreeNode* recoverFromPreorder(char * traversal"}
{"id": "1944", "path": "output2\\c\\Hard\\1944-escape-a-large-maze.c", "hypo_code": "bool isEscapePossible(int** blocked, int blockedSize, int* blockedColSize, int* source, int sourceSize, int* target, int targetSize){\n    int i,j;\n    int** grid = (int**)malloc(sizeof(int*)*1000000);\n    for(i=0;i<1000000;i++){\n        grid[i] = (int*)malloc(sizeof(int)*1000000);\n        for(j=0;j<1000000;j++){\n            grid[i][j] = 0;\n        }\n    }\n    for(i=0;i<blockedSize;i++){\n        grid[blocked[i][0]][blocked[i][1]] = 1;\n    }\n    int** visited = (int**)malloc(sizeof(int*)*1000000);\n    for(i=0;i<1000000;i++){\n        visited[i] = (int*)malloc(sizeof(int)*1000000);\n        for(j=0;j<1000000;j++){\n            visited[i][j] = 0;\n        }\n    }\n    int** queue = (int**)malloc(sizeof(int*)*1000000);\n    for(i=0;i<1000000;i++){\n        queue[i] = (int*)malloc(sizeof(int)*2);\n    }\n    int front = 0;\n    int rear = 0;\n    queue[rear][0] = source[0];\n    queue[rear][1] = source[1];\n    rear++;\n    visited[source[0]][source[1]] = 1;\n    int count = 0;\n    while(front != rear){\n        int x = queue[front][0];\n        int y = queue[front][1];\n        front++;\n        count++;\n        if(count > 20000){\n            return true;\n        }\n        if(x == target[0] && y == target[1]){\n            return true;\n        }\n        if(x+1 < 1000000 && grid[x+1][y] == 0 && visited[x+1][y] == 0){\n            queue[rear][0] = x+1;\n            queue[rear][1] = y;\n            rear++;\n            visited[x+1][y] = 1;\n        }\n        if(x-1 >= 0 && grid[x-1][y] == 0 && visited[x-1][y] == 0){\n            queue[rear][0] = x-1;\n            queue[rear][1] = y;\n            rear++;\n            visited[x-1][y] = 1;\n        }\n        if(y+1 < 1000000 && grid[x][y+1] == 0 && visited[x][y+1] == 0){\n            queue[rear][0] = x;\n            queue[rear][1] = y+1;\n            rear++;\n            visited[x][y+1] = 1;\n        }\n        if(y-1 >= 0 && grid[x][y-1] == 0 && visited[x][y-1] == 0){\n            queue[rear][0] = x;\n            queue[rear][1] = y-1;\n            rear++;\n            visited[x][y-1] = 1;\n        }\n\n        \n\n}", "prefix": "bool isEscapePossible(int** blocked, int blockedSize, int* blockedColSize, int* source, int sourceSize, int* target, int targetSize"}
{"id": "1945", "path": "output2\\c\\Hard\\1945-longest-duplicate-substring.c", "hypo_code": "char * longestDupSubstring(char * s){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (s[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (s[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (s[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4*10 + (s[i]-'0\n'        }\n    }\n    arr4[count4] = temp4;\n    count4++;\n    int* arr5 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr5[i] = 0;\n    }\n    int count5 = 0;\n    int temp5 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr5[count5] = temp5;\n            temp5 = 0;\n            count5++;\n        }\n        else{\n            temp5 = temp5*10 + (s[i]-'0');\n        }\n    }\n    arr5[count5] = temp5;\n    count5++;\n    int* arr6 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr6[i] = 0;\n    }\n    int count6 = 0;\n    int temp6 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr6[count6] = temp6;\n            temp6 = 0;\n            count6++;\n        }\n        else{\n            temp6 = temp6*10 + (s[i]-'0');\n        }\n    }\n    arr6[count6] = temp6;\n    count6++;\n    int* arr7 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr7[i] = 0;\n    }\n    int count7 = 0;\n    int temp7 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr7[count7] = temp7;\n            temp7 = 0;\n            count7++;\n        }\n        else{\n            temp7 = temp7*10 + (s[i]-'0');\n        }\n    }\n    arr7[count7] = temp7;\n    count7++;\n    int* arr8 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr8[i] = 0;\n    }\n    int count8 = 0;\n    int temp8 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr8[count8] = temp8;\n            temp8 = 0;  \n            count8++;\n            \n\n}", "prefix": "char * longestDupSubstring(char * s"}
{"id": "1946", "path": "output2\\c\\Hard\\1946-number-of-submatrices-that-sum-to-target.c", "hypo_code": "int numSubmatrixSumTarget(int** matrix, int matrixSize, int* matrixColSize, int target){\nint res = 0;\n    for (int i = 0; i < matrixSize; i++) {\n        int *sum = (int *)malloc(sizeof(int) * matrixColSize[0]);\n        memset(sum, 0, sizeof(int) * matrixColSize[0]);\n        for (int j = i; j < matrixSize; j++) {\n            for (int k = 0; k < matrixColSize[0]; k++) {\n                sum[k] += matrix[j][k];\n            }\n            res += subarraySum(sum, matrixColSize[0], target);\n        }\n    }\n    return res;\n}\nint subarraySum(int *nums, int numsSize, int k) {\n    int *map = (int *)malloc(sizeof(int) * (numsSize + 1));\n    memset(map, 0, sizeof(int) * (numsSize + 1));\n    map[0] = 1;\n    int pre = 0, res = 0;\n    for (int i = 0; i < numsSize; i++) {\n        pre += nums[i];\n        if (map[pre - k]) res += map[pre - k];\n        map[pre]++;\n    }\n    return res;\n}", "prefix": "int numSubmatrixSumTarget(int** matrix, int matrixSize, int* matrixColSize, int target"}
{"id": "1947", "path": "output2\\c\\Hard\\1947-shortest-common-supersequence.c", "hypo_code": "char * shortestCommonSupersequence(char * str1, char * str2){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(str1);i++){\n        if(str1[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (str1[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(str1);i++){\n        if(str1[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (str1[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(str1);i++){\n        if(str1[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (str1[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(str1);i++){\n        if(str1[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4\n\n}", "prefix": "char * shortestCommonSupersequence(char * str1, char * str2"}
{"id": "1948", "path": "output2\\c\\Hard\\1948-find-in-mountain-array.c", "hypo_code": "int findInMountainArray(int target, MountainArray* mountainArr) {\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (s[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (s[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (s[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4*10 + (s[i]-'0\n\t\n}", "prefix": "int findInMountainArray(int target, MountainArray* mountainArr"}
{"id": "1949", "path": "output2\\c\\Hard\\1949-brace-expansion-ii.c", "hypo_code": "char ** braceExpansionII(char * expression, int* returnSize){\n                  \n\n\n\n\n     \n\n\n\n  \n    \n        return 0;                \n\n}", "prefix": "char ** braceExpansionII(char * expression, int* returnSize"}
{"id": "1950", "path": "output2\\c\\Hard\\1950-parsing-a-boolean-expression.c", "hypo_code": "bool parseBoolExpr(char * expression){\nint len = strlen(expression);\n    if (len == 1) return expression[0] == 't' ? true : false;\n    if (expression[0] == '!') {\n        int cnt = 0;\n        for (int i = 2; i < len - 1; i++) {\n            if (expression[i] == '(') cnt++;\n            else if (expression[i] == ')') cnt--;\n            if (cnt == 0 && expression[i] == ',') {\n                if (expression[2] == 't') return false;\n                else return true;\n            }\n        }\n        return parseBoolExpr(expression + 2);\n    } else if (expression[0] == '&') {\n        int cnt = 0;\n        bool res = true;\n        for (int i = 2; i < len - 1; i++) {\n            if (expression[i] == '(') cnt++;\n            else if (expression[i] == ')') cnt--;\n            if (cnt == 0 && expression[i] == ',') {\n                if (expression[2] == 'f') return false;\n                res &= parseBoolExpr(expression + 2);\n                expression += (i - 1);\n                len -= (i - 1);\n                i = 1;\n            }\n        }\n        return res;\n    } else {\n        int cnt = 0;\n        bool res = false;\n        for (int i = 2; i < len - 1; i++) {\n            if (expression[i] == '(') cnt++;\n            else if (expression[i] == ')') cnt--;\n            if (cnt == 0 && expression[i] == ',') {\n                if (expression[2] == 't') return true;\n                res |= parseBoolExpr(expression + 2);\n                expression += (i - 1);\n                len -= (i - 1);\n                i = 1;\n            }\n        }\n        return res;\n}", "prefix": "bool parseBoolExpr(char * expression"}
{"id": "1951", "path": "output2\\c\\Hard\\1951-smallest-sufficient-team.c", "hypo_code": "int* smallestSufficientTeam(char ** req_skills, int req_skillsSize, char *** people, int peopleSize, int* peopleColSize, int* returnSize){\n*returnSize = 0;\n    int *res = (int *)malloc(sizeof(int) * 16);\n    int **dp = (int **)malloc(sizeof(int *) * (1 << req_skillsSize));\n    for (int i = 0; i < (1 << req_skillsSize); i++) {\n        dp[i] = (int *)malloc(sizeof(int) * (peopleSize + 1));\n    }\n    memset(dp, 0xff, sizeof(int) * (1 << req_skillsSize) * (peopleSize + 1));\n    dp[0][0] = 0;\n    int *index = (int *)malloc(sizeof(int) * (1 << req_skillsSize));\n    memset(index, 0xff, sizeof(int) * (1 << req_skillsSize));\n    index[0] = -1;\n    for (int i = 0; i < peopleSize; i++) {\n        int skill = 0;\n        for (int j = 0; j < peopleColSize[i]; j++) {\n            for (int k = 0; k < req_skillsSize; k++) {\n                if (strcmp(people[i][j], req_skills[k]) == 0) {\n                    skill |= (1 << k);\n                }\n            }\n        }\n        for (int j = 0; j < (1 << req_skillsSize); j++) {\n            if (dp[j][i] == -1) continue;\n            if (dp[j][i + 1] == -1 || dp[j][i + 1] > dp[j][i]) {\n                dp[j][i + 1] = dp[j][i];\n                index[j] = i;\n            }\n            int next = j | skill;\n            if (dp[next][i + 1] == -1 || dp[next][i + 1] > dp[j][i] + 1) {\n                dp[next][i + 1] = dp[j][i] + 1;\n                index[next] = i;\n            }\n        }\n    }\n    int k = 0;\n    int j = (1 << req_skillsSize) - 1;\n    while (j != 0) {\n        res[k++] = index[j];\n        j ^= 1 << index[j];\n    }\n    *returnSize = k;\n    return res;\n}", "prefix": "int* smallestSufficientTeam(char ** req_skills, int req_skillsSize, char *** people, int peopleSize, int* peopleColSize, int* returnSize"}
{"id": "1952", "path": "output2\\c\\Hard\\1952-longest-chunked-palindrome-decomposition.c", "hypo_code": "int longestDecomposition(char * text){\nint len = strlen(text);\n\tint left = 0, right = len - 1;\n\tint ans = 0;\n\twhile (left <= right) {\n\t\tint i = left, j = right;\n\t\twhile (i < j) {\n\t\t\tif (text[i] == text[j]) {\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif (i == j) {\n\t\t\tans++;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tleft = i;\n\t\t\tright = j;\n\t\t\tans += 2;\n\t\t}\n\t}\n\treturn ans;\n}", "prefix": "int longestDecomposition(char * text"}
{"id": "1954", "path": "output2\\c\\Hard\\1954-last-substring-in-lexicographical-order.c", "hypo_code": "char * lastSubstring(char * s){\nint len = strlen(s);\n\tint left = 0, right = 1, offset = 0;\n\twhile (left + offset < len && right + offset < len) {\n\t\tif (s[left + offset] == s[right + offset]) {\n\t\t\toffset++;\n\t\t} else {\n\t\t\tif (s[left + offset] < s[right + offset]) {\n\t\t\t\tleft = right;\n\t\t\t\tright = left + 1;\n\t\t\t} else {\n\t\t\t\tright = right + offset + 1;\n\t\t\t}\n\t\t\toffset = 0;\n\t\t}\n\t}\n\treturn s + left;\n}", "prefix": "char * lastSubstring(char * s"}
{"id": "1956", "path": "output2\\c\\Hard\\1956-number-of-valid-words-for-each-puzzle.c", "hypo_code": "int* findNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int* returnSize){\nint *ans = (int *)calloc(puzzlesSize, sizeof(int));\n    int i, j, k, l, m, n;\n    int *wordsCount = (int *)calloc(wordsSize, sizeof(int));\n    for (i = 0; i < wordsSize; i++) {\n        for (j = 0; j < strlen(words[i]); j++) {\n            wordsCount[i] |= 1 << (words[i][j] - 'a');\n        }\n    }\n    for (i = 0; i < puzzlesSize; i++) {\n        for (j = 0; j < strlen(puzzles[i]); j++) {\n            puzzles[i][j] -= 'a';\n        }\n    }\n    for (i = 0; i < puzzlesSize; i++) {\n        int puzzleCount = 1 << puzzles[i][0];\n        for (j = 0; j < wordsSize; j++) {\n            if ((wordsCount[j] & puzzleCount) == wordsCount[j]) {\n                for (k = 1; k < strlen(puzzles[i]); k++) {\n                    if ((wordsCount[j] & (1 << puzzles[i][k])) == 0) {\n                        break;\n                    }\n                }\n                if (k == strlen(puzzles[i])) {\n                    ans[i]++;\n                }\n            }\n        }\n    }\n    *returnSize = puzzlesSize;\n    return ans;\n}", "prefix": "int* findNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int* returnSize"}
{"id": "1957", "path": "output2\\c\\Hard\\1957-make-array-strictly-increasing.c", "hypo_code": "int makeArrayIncreasing(int* arr1, int arr1Size, int* arr2, int arr2Size){\nint i, j, k, l, m, n;\n    int dp[2001][2001];\n    int min = 0x7fffffff;\n    for (i = 0; i < 2001; i++) {\n        for (j = 0; j < 2001; j++) {\n            dp[i][j] = 0x7fffffff;\n        }\n    }\n    dp[0][0] = -1;\n    for (i = 1; i <= arr1Size; i++) {\n        if (arr1[i - 1] > dp[i - 1][0]) {\n            dp[i][0] = arr1[i - 1];\n        }\n        for (j = 1; j <= i; j++) {\n            if (arr1[i - 1] > dp[i - 1][j - 1]) {\n                dp[i][j] = arr1[i - 1];\n            }\n            if (arr2[j - 1] > dp[i - 1][j]) {\n                dp[i][j] = dp[i][j] < arr2[j - 1] ? dp[i][j] : arr2[j - 1];\n            }\n            if (i == arr1Size && dp[i][j] != 0x7fffffff) {\n                min = min < j ? min : j;\n            }\n        }\n    }\n    return min == 0x7fffffff ? -1 : min;\n}", "prefix": "int makeArrayIncreasing(int* arr1, int arr1Size, int* arr2, int arr2Size"}
{"id": "1958", "path": "output2\\c\\Hard\\1958-critical-connections-in-a-network.c", "hypo_code": "int** criticalConnections(int n, int** connections, int connectionsSize, int* connectionsColSize, int* returnSize, int** returnColumnSizes){\nint i, j, k, l, m, n;\n    int **ans = (int **)calloc(n, sizeof(int *));\n    int *ansColSize = (int *)calloc(n, sizeof(int));\n    int *visited = (int *)calloc(n, sizeof(int));\n    int *dfn = (int *)calloc(n, sizeof(int));\n    int *low = (int *)calloc(n, sizeof(int));\n    int *parent = (int *)calloc(n, sizeof(int));\n    int time = 0;\n    int **graph = (int **)calloc(n, sizeof(int *));\n    int *graphColSize = (int *)calloc(n, sizeof(int));\n    int *graphColCapacity = (int *)calloc(n, sizeof(int));\n    for (i = 0; i < n; i++) {\n        graphColCapacity[i] = 1;\n        graphColSize[i] = 0;\n        graph[i] = (int *)calloc(graphColCapacity[i], sizeof(int));\n    }\n    for (i = 0; i < connectionsSize; i++) {\n        int a = connections[i][0], b = connections[i][1];\n        graph[a][graphColSize[a]++] = b;\n        if (graphColSize[a] == graphColCapacity[a]) {\n            graphColCapacity[a] <<= 1;\n            graph[a] = (int *)realloc(graph[a], graphColCapacity[a] * sizeof(int));\n        }\n        graph[b][graphColSize[b]++] = a;\n        if (graphColSize[b] == graphColCapacity[b]) {\n            graphColCapacity[b] <<= 1;\n            graph[b] = (int *)realloc(graph[b], graphColCapacity[b] * sizeof(int));\n        }\n    }\n    *returnSize = 0;\n    dfs(0, -1, graph, graphColSize, visited, dfn, low, parent, &time, ans, ansColSize, returnSize);\n    *returnColumnSizes = ansColSize;\n    return ans;\n}\nvoid dfs(int u, int pre, int **graph, int *graphColSize, int *visited, int *dfn, int *low, int *parent, int *time, int **ans, int *ansColSize, int *returnSize) {\n    visited[u] = 1;\n    dfn[u] = low[u] = (*time)++;\n    for (int i = 0; i < graphColSize[u]; i++) {\n        int v = graph[u][i];\n        if (!visited[v]) {\n            parent[v] = u;\n            dfs(v, u, graph, graphColSize, visited, dfn, low, parent, time, ans, ansColSize, returnSize);\n            low[u] = low[u] < low[v] ? low[u] : low[v];\n            if (low[v] > dfn[u]) {\n                ans[*returnSize] = (int *)calloc(2, sizeof(int));\n                ans[*returnSize][0] = u;\n                ans[*returnSize][1] = v;\n                (*ansColSize)++;\n                (*returnSize)++;\n            }\n        } else if (v != pre) {\n            low[u] = low[u] < dfn[v] ? low[u] : dfn[v];\n        }\n    }\n}", "prefix": "int** criticalConnections(int n, int** connections, int connectionsSize, int* connectionsColSize, int* returnSize, int** returnColumnSizes"}
{"id": "1959", "path": "output2\\c\\Hard\\1959-sort-items-by-groups-respecting-dependencies.c", "hypo_code": "int* sortItems(int n, int m, int* group, int groupSize, int** beforeItems, int beforeItemsSize, int* beforeItemsColSize, int* returnSize){\n    int* ans = (int*)malloc(sizeof(int)*n);\n    *returnSize = n;\n    int i,j;\n    int** graph = (int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        graph[i] = (int*)malloc(sizeof(int)*n);\n        for(j=0;j<n;j++){\n            graph[i][j] = 0;\n        }\n    }\n    int** graph2 = (int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        graph2[i] = (int*)malloc(sizeof(int)*n);\n        for(j=0;j<n;j++){\n            graph2[i][j] = 0;\n        }\n    }\n    int* indegree = (int*)malloc(sizeof(int)*n);\n    int* indegree2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        indegree[i] = 0;\n        indegree2[i] = 0;\n    }\n    for(i=0;i<n;i++){\n        for(j=0;j<beforeItemsColSize[i];j++){\n            graph[beforeItems[i][j]][i] = 1;\n            indegree[i]++;\n        }\n    }\n    for(i=0;i<n;i++){\n        for(j=0;j<beforeItemsColSize[i];j++){\n            if(group[beforeItems[i][j]] == group[i]){\n                graph2[beforeItems[i][j]][i] = 1;\n                indegree2[i]++;\n            }\n        }\n    }\n    int* visited = (int*)malloc(sizeof(int)*n);\n    int* visited2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        visited[i] = 0;\n        visited2[i] = 0;\n    }\n    int* stack = (int*)malloc(sizeof(int)*n);\n    int* stack2 = (int*)malloc(sizeof(int)*n);\n    int top = -1;\n    int top2 = -1;\n    for(i=0;i<n;i++){\n        if(indegree[i] == 0){\n            stack[++top] = i;\n        }\n    }\n    for(i=0;i<n;i++){\n        if(indegree2[i] == 0){\n            stack2[++top2] = i;\n        }\n    }\n    int* group2 = ( int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        group2[i] = group[i];\n    }\n    int* group3 = ( int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        group3[i] = group[i];\n    }\n    int* group4 = ( int*)malloc(sizeof(int)*n);\n\n}", "prefix": "int* sortItems(int n, int m, int* group, int groupSize, int** beforeItems, int beforeItemsSize, int* beforeItemsColSize, int* returnSize"}
{"id": "1961", "path": "output2\\c\\Hard\\1961-minimum-moves-to-reach-target-with-rotations.c", "hypo_code": "int minimumMoves(int** grid, int gridSize, int* gridColSize){\n    int i,j;\n    int** visited = (int**)malloc(sizeof(int*)*gridSize);\n    for(i=0;i<gridSize;i++){\n        visited[i] = (int*)malloc(sizeof(int)*gridSize);\n        for(j=0;j<gridSize;j++){\n            visited[i][j] = 0;\n        }\n    }\n    int** queue = (int**)malloc(sizeof(int*)*gridSize*gridSize);\n    for(i=0;i<gridSize*gridSize;i++){\n        queue[i] = (int*)malloc(sizeof(int)*4);\n    }\n    int front = 0;\n    int rear = 0;\n    queue[rear][0] = 0;\n    queue[rear][1] = 0;\n    queue[rear][2] = 0;\n    queue[rear][3] = 0;\n    rear++;\n    visited[0][0] = 1;\n    int count = 0;\n    while(front != rear){\n        int x = queue[front][0];\n        int y = queue[front][1];\n        int dir = queue[front][2];\n        int step = queue[front][3];\n        front++;\n        if(x == gridSize-1 && y == gridSize-2 && dir == 0){\n            return step;\n        }\n        if(dir == 0){\n            if(y+1 < gridSize && grid[x][y+1] == 0 && visited[x][y+1] == 0){\n                queue[rear][0] = x;\n                queue[rear][1] = y+1;\n                queue[rear][2] = 0;\n                queue[rear][3] = step+1;\n                rear++;\n                visited[x][y+1] = 1;\n            }\n            if(x+1 < gridSize && grid[x+1][y] == 0 && grid[x+1][y+1] == 0 && visited[x+1][y] == 0){\n                queue[rear][0] = x+1;\n                queue[rear][1] = y;\n                queue[rear][2] = 1;\n                queue[rear][3] = step+1;\n                rear++;\n                visited[x+1][y] = 1;\n            }\n        }\n        else{\n            if(x+1 < gridSize && grid[x+1][y] == 0 && grid[x+1][y+1] == 0 && visited[x+1][y] == 0){\n                queue[rear][0] = x+1;\n                queue[rear][1] = y;\n                queue[rear][2] = 1;\n                queue[rear][3] = step+1;\n                rear++;\n                visited[x+1][y] = 1;\n            }\n            if(y+1 < gridSize && grid[x][y+1] == 0 && visited[x][y+1] == 0){\n                queue[rear][0] = x;\n                queue[rear][1] = y+1;\n                queue[rear][2] = 0;\n                queue[rear][3] = step+1;\n                rear++;\n                visited[x][y+1] = 1;\n            }\n            \n\n}", "prefix": "int minimumMoves(int** grid, int gridSize, int* gridColSize"}
{"id": "1962", "path": "output2\\c\\Hard\\1962-count-vowels-permutation.c", "hypo_code": "int countVowelPermutation(int n){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*5);\n    for(i=0;i<5;i++){\n        arr[i] = 1;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*5);\n    for(i=0;i<5;i++){\n        arr2[i] = 0;\n    }\n    for(i=1;i<n;i++){\n        arr2[0] = (arr[1] + arr[2] + arr[4])%1000000007;\n        arr2[1] = (arr[0] + arr[2])%1000000007;\n        arr2[2] = (arr[1] + arr[3])%1000000007;\n        arr2[3] = (arr[2])%1000000007;\n        arr2[4] = (arr[2] + arr[3])%1000000007;\n        for(j=0;j<5;j++){\n            arr[j] = arr2[j];\n        }\n    }\n    int ans = 0;\n    for(i=0;i<5;i++){\n        ans = (ans + arr[i])%1000000007;\n    }\n    return ans;\n\n}", "prefix": "int countVowelPermutation(int n"}
{"id": "1963", "path": "output2\\c\\Hard\\1963-dice-roll-simulation.c", "hypo_code": "int dieSimulator(int n, int* rollMax, int rollMaxSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*6);\n    for(i=0;i<6;i++){\n        arr[i] = 1;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*6);\n    for(i=0;i<6;i++){\n        arr2[i] = 0;\n    }\n    for(i=1;i<n;i++){\n        arr2[0] = (arr[1] + arr[2] + arr[3] + arr[4] + arr[5])%1000000007;\n        arr2[1] = (arr[0] + arr[2] + arr[3] + arr[4] + arr[5])%1000000007;\n        arr2[2] = (arr[0] + arr[1] + arr[3] + arr[4] + arr[5])%1000000007;\n        arr2[3] = (arr[0] + arr[1] + arr[2] + arr[4] + arr[5])%1000000007;\n        arr2[4] = (arr[0] + arr[1] + arr[2] + arr[3] + arr[5])%1000000007;\n        arr2[5] = (arr[0] + arr[1] + arr[2] + arr[3] + arr[4])%1000000007;\n        for(j=0;j<6;j++){\n            arr[j] = arr2[j];\n        }\n    }\n    int ans = 0;\n    for(i=0;i<6;i++){\n        ans = (ans + arr[i])%1000000007;\n    }\n    return ans;\n\n}", "prefix": "int dieSimulator(int n, int* rollMax, int rollMaxSize"}
{"id": "1964", "path": "output2\\c\\Hard\\1964-maximum-equal-frequency.c", "hypo_code": "int maxEqualFreq(int* nums, int numsSize){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr13[i] = 0;\n    }\n  \n\n}", "prefix": "int maxEqualFreq(int* nums, int numsSize"}
{"id": "1965", "path": "output2\\c\\Hard\\1965-maximum-profit-in-job-scheduling.c", "hypo_code": "int jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize){\n    int ans = 0;\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (s[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (s[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (s[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4* 10 + (s[i]-'0');\n                \n\n}", "prefix": "int jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize"}
{"id": "1966", "path": "output2\\c\\Hard\\1966-tiling-a-rectangle-with-the-fewest-squares.c", "hypo_code": "int tilingRectangle(int n, int m){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*m);\n    for(i=0;i<m;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*m);\n    for(i=0;i<m;i++){\n        arr4[i] = 0;\n    }\n    int ans = 0;\n    int flag = 0;\n    while(flag==0){\n        flag = 1;\n        for(i=0;i<n;i++){\n            if(arr[i]<m){\n                flag = 0;\n                break;\n            }\n        }\n        if(flag==1){\n            break;\n        }\n        for(i=0;i<n;i++){\n            if(arr[i]<m){\n                arr[i]++;\n                arr2[i]++;\n                break;\n            }\n        }\n        for(i=0;i<m;i++){\n            if(arr3[i]<n){\n                arr3[i]++;\n                arr4[i]++;\n                break;\n            }\n        }\n        ans++;\n    }\n    return ans;\n\n}", "prefix": "int tilingRectangle(int n, int m"}
{"id": "1967", "path": "output2\\c\\Hard\\1967-check-if-it-is-a-good-array.c", "hypo_code": "bool isGoodArray(int* nums, int numsSize){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr13[i] = 0;\n    }\n    int temp = nums[0];\n\n}", "prefix": "bool isGoodArray(int* nums, int numsSize"}
{"id": "1968", "path": "output2\\c\\Hard\\1968-maximum-score-words-formed-by-letters.c", "hypo_code": "int maxScoreWords(char ** words, int wordsSize, char* letters, int lettersSize, int* score, int scoreSize){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(str1);i++){\n        if(str1[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (str1[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(str1);i++){\n        if(str1[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (str1[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(str1);i++){\n        if(str1[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (str1[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(str1);i++){\n        if(str1[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4*10 + (str1[i]-'0');\n            \n\n}", "prefix": "int maxScoreWords(char ** words, int wordsSize, char* letters, int lettersSize, int* score, int scoreSize"}
{"id": "1969", "path": "output2\\c\\Hard\\1969-minimum-moves-to-move-a-box-to-their-target-location.c", "hypo_code": "int minPushBox(char** grid, int gridSize, int* gridColSize){\n    int i,j;\n    int** visited = (int**)malloc(sizeof(int*)*gridSize);\n    for(i=0;i<gridSize;i++){\n        visited[i] = (int*)malloc(sizeof(int)*gridColSize[0]);\n        for(j=0;j<gridColSize[0];j++){\n            visited[i][j] = 0;\n        }\n    }\n    int** queue = (int**)malloc(sizeof(int*)*gridSize*gridColSize[0]);\n    for(i=0;i<gridSize*gridColSize[0];i++){\n        queue[i] = (int*)malloc(sizeof(int)*4);\n    }\n    int front = 0;\n    int rear = 0;\n    int bx = 0;\n    int by = 0;\n    int tx = 0;\n    int ty = 0;\n    int sx = 0;\n    int sy = 0;\n    for(i=0;i<gridSize;i++){\n        for(j=0;j<gridColSize[0];j++){\n            if(grid[i][j] == 'B'){\n                bx = i;\n                by = j;\n            }\n            if(grid[i][j] == 'T'){\n                tx = i;\n                ty = j;\n            }\n            if(grid[i][j] == 'S'){\n                sx = i;\n                sy = j;\n            }\n        }\n    }\n    queue[rear][0] = bx;\n    queue[rear][1] = by;\n    queue[rear][2] = sx;\n    queue[rear][3] = sy;\n    rear++;\n    visited[bx][by] = 1;\n    int count = 0;\n    while(front != rear){\n        int x = queue[front][0];\n        int y = queue[front][1];\n        int sx = queue[front][2];\n        int sy = queue[front][3];\n        front++;\n        if(x == tx && y == ty){\n            return count;\n        }\n        if(x+1 < gridSize && grid[x+1][y] != '#' && visited[x+1][y] == 0){\n            if(sx == x+1 && sy == y){\n                queue[rear][0] = x+1;\n                queue[rear][1] = y;\n                queue[rear][2] = x;\n                queue[rear][3] = y\n\n}", "prefix": "int minPushBox(char** grid, int gridSize, int* gridColSize"}
{"id": "1970", "path": "output2\\c\\Hard\\1970-number-of-ways-to-stay-in-the-same-place-after-some-steps.c", "hypo_code": "int numWays(int steps, int arrLen){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*arrLen);\n    for(i=0;i<arrLen;i++){\n        arr[i] = 1;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*arrLen);\n    for(i=0;i<arrLen;i++){\n        arr2[i] = 0;\n    }\n    for(i=1;i<steps;i++){\n        for(j=0;j<arrLen;j++){\n            if(j==0){\n                arr2[j] = (arr[j] + arr[j+1])%1000000007;\n            }\n            else if(j==arrLen-1){\n                arr2[j] = (arr[j] + arr[j-1])%1000000007;\n            }\n            else{\n                arr2[j] = (arr[j] + arr[j-1] + arr[j+1])%1000000007;\n            }\n        }\n        for(j=0;j<arrLen;j++){\n            arr[j] = arr2[j];\n        }\n    }\n    return arr[0];\n\n}", "prefix": "int numWays(int steps, int arrLen"}
{"id": "1971", "path": "output2\\c\\Hard\\1971-palindrome-partitioning-iii.c", "hypo_code": "int palindromePartition(char * s, int k){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (s[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (s[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (s[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4*10 + (s[i]-'0 ');\n\n}", "prefix": "int palindromePartition(char * s, int k"}
{"id": "1972", "path": "output2\\c\\Hard\\1972-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.c", "hypo_code": "int minFlips(int** mat, int matSize, int* matColSize){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*matSize);\n    for(i=0;i<matSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*matSize);\n    for(i=0;i<matSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*matColSize[0]);\n    for(i=0;i<matColSize[0];i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*matColSize[0]);\n    for(i=0;i<matColSize[0];i++){\n        arr4[i] = 0;\n    }\n    int ans = 0;\n    int flag = 0;\n    while(flag==0){\n        flag = 1;\n        for(i=0;i<matSize;i++){\n            if(arr[i]<matColSize[0]){\n                flag = 0;\n                break;\n            }\n        }\n        if(flag==1){\n            break;\n        }\n        for(i=0;i<matSize;i++){\n            if(arr[i]<matColSize[0]){\n                arr[i]++;\n                arr2[i]++;\n                break;\n            }\n        }\n        for(i=0;i<matColSize[0];i++){\n            if(arr3[i]<matSize){\n                arr3[i]++;\n                arr4[i]++;\n                break;\n            }\n        }\n        ans++;\n    }\n    return ans;\n\n\n}", "prefix": "int minFlips(int** mat, int matSize, int* matColSize"}
{"id": "1973", "path": "output2\\c\\Hard\\1973-minimum-falling-path-sum-ii.c", "hypo_code": "int minFallingPathSum(int** grid, int gridSize, int* gridColSize){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*gridColSize[0]);\n    for(i=0;i<gridColSize[0];i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*gridColSize[0]);\n    for(i=0;i<gridColSize[0];i++){\n        arr4[i] = 0;\n    }\n    int ans = 0;\n    int flag = 0;\n    while(flag==0){\n        flag = 1;\n        for(i=0;i<gridSize;i++){\n            if(arr[i]<gridColSize[0]){\n                flag = 0;\n                break;\n            }\n        }\n        if(flag==1){\n            break;\n        }\n        for(i=0;i<gridSize;i++){\n            if(arr[i]<gridColSize[0]){\n                arr[i]++;\n                arr2[i]++;\n                break;\n            }\n        }\n        for(i=0;i<gridColSize[0];i++){\n            if(arr3[i]<gridSize){\n                arr3[i]++;\n                arr4[i]++;\n                break;\n            }\n        }\n        ans++;\n    }\n    return ans;\n\n}", "prefix": "int minFallingPathSum(int** grid, int gridSize, int* gridColSize"}
{"id": "1974", "path": "output2\\c\\Hard\\1974-shortest-path-in-a-grid-with-obstacles-elimination.c", "hypo_code": "int shortestPath(int** grid, int gridSize, int* gridColSize, int k){\n    int i,j;\n    int** visited = (int**)malloc(sizeof(int*)*gridSize);\n    for(i=0;i<gridSize;i++){\n        visited[i] = (int*)malloc(sizeof(int)*gridSize);\n        for(j=0;j<gridSize;j++){\n            visited[i][j] = 0;\n        }\n    }\n    int** queue = (int**)malloc(sizeof(int*)*gridSize*gridSize);\n    for(i=0;i<gridSize*gridSize;i++){\n        queue[i] = (int*)malloc(sizeof(int)*4);\n    }\n    int front = 0;\n    int rear = 0;\n    queue[rear][0] = 0;\n    queue[rear][1] = 0;\n    queue[rear][2] = 0;\n    queue[rear][3] = 0;\n    rear++;\n    visited[0][0] = 1;\n    int count = 0;\n    while(front != rear){\n        int x = queue[front][0];\n        int y = queue[front][1];\n        int step = queue[front][2];\n        int obs = queue[front][3];\n        front++;\n        if(x == gridSize-1 && y == gridSize-1){\n            return step;\n        }\n        if(y+1 < gridSize && grid[x][y+1] == 0 && visited[x][y+1] == 0){\n            queue[rear][0] = x;\n            queue[rear][1] = y+1;\n            queue[rear][2] = step+1;\n            queue[rear][3] = obs;\n            rear++;\n            visited[x][y+1] = 1;\n        }\n        if(x+1 < gridSize && grid[x+1][y] == 0 && visited[x+1][y] == 0){\n            queue[rear][0] = x+1;\n            queue[rear][1] = y;\n            queue[rear][2] = step+1;\n            queue[rear][3] = obs;\n            rear++;\n            visited[x+1][y] = 1;\n        }\n        if(y-1 >= 0 && grid[x][y-1] == 0 && visited[x][y-1] == 0){\n            queue[rear][0] = x;\n            queue[rear][1] = y-1;\n            queue[rear][2] = step+1;\n            queue[rear][3] = obs;\n            rear++;\n            visited[x][y-1] = 1;\n\n                    \n\n}", "prefix": "int shortestPath(int** grid, int gridSize, int* gridColSize, int k"}
{"id": "1975", "path": "output2\\c\\Hard\\1975-maximum-candies-you-can-get-from-boxes.c", "hypo_code": "int maxCandies(int* status, int statusSize, int* candies, int candiesSize, int** keys, int keysSize, int* keysColSize, int** containedBoxes, int containedBoxesSize, int* containedBoxesColSize, int* initialBoxes, int initialBoxesSize){\n    int i,j;\n    int* visited = (int*)malloc(sizeof(int)*statusSize);\n    for(i=0;i<statusSize;i++){\n        visited[i] = 0;\n    }\n    int* queue = (int*)malloc(sizeof(int)*statusSize);\n    int front = 0;\n    int rear = 0;\n    for(i=0;i<initialBoxesSize;i++){\n        queue[rear] = initialBoxes[i];\n        rear++;\n    }\n    int count = 0;\n    while(front != rear){\n        int box = queue[front];\n        front++;\n        if(visited[box] == 1){\n            continue;\n        }\n        visited[box] = 1;\n        if(status[box] == 1){\n            count += candies[box];\n            for(i=0;i<keysColSize[box];i++){\n                status[keys[box][i]] = 1;\n            }\n            for(i=0;i<containedBoxesColSize[box];i++){\n                queue[rear] = containedBoxes[box][i];\n                rear++;\n            }\n        }\n        else{\n            queue[rear] = box;\n            rear++;\n        }\n    }\n    return count;\n\n}", "prefix": "int maxCandies(int* status, int statusSize, int* candies, int candiesSize, int** keys, int keysSize, int* keysColSize, int** containedBoxes, int containedBoxesSize, int* containedBoxesColSize, int* initialBoxes, int initialBoxesSize"}
{"id": "1976", "path": "output2\\c\\Hard\\1976-number-of-paths-with-max-score.c", "hypo_code": "int* pathsWithMaxScore(char ** board, int boardSize, int* returnSize){\n    int* ans = (int*)malloc(sizeof(int)*2);\n    *returnSize = 2;\n    int i,j;\n    int n = boardSize;\n    int** dp = (int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        dp[i] = (int*)malloc(sizeof(int)*n);\n        for(j=0;j<n;j++){\n            dp[i][j] = 0;\n        }\n    }\n    int** dp2 = (int**)malloc(sizeof(int*)*n);\n    for(i=0;i<n;i++){\n        dp2[i] = (int*)malloc(sizeof(int)*n);\n        for(j=0;j<n;j++){\n            dp2[i][j] = 0;\n        }\n    }\n    dp[n-1][n-1] = 0;\n    dp2[n-1][n-1] = 1;\n    for(i=n-2;i>=0;i--){\n        if(board[i][n-1] == 'X'){\n            dp[i][n-1] = 0;\n            dp2[i][n-1] = 0;\n        }\n        else{\n            dp[i][n-1] = dp[i+1][n-1] + board[i][n-1] - '0';\n            dp2[i][n-1] = dp2[i+1][n-1];\n        }\n    }\n    for(i=n-2;i>=0;i--){\n        if(board[n-1][i] == 'X'){\n            dp[n-1][i] = 0;\n            dp2[n-1][i] = 0;\n        }\n        else{\n            dp[n-1][i] = dp[n-1][i+1] + board[n-1][i] - '0';\n            dp2[n-1][i] = dp2[n-1][i+1];\n        }\n    }\n    for(i=n-2;i>=0;i--){\n        for(j=n-2;j>=0;j--){\n            if(board[i][j] == 'X'){\n                dp[i][j] = 0;\n                dp2[i][j] = 0;\n            }\n            else{\n                int max = 0;\n                int count = 0;\n                if(dp[i+1][j] > max){\n                    max = dp[i+1][j];\n                    count = dp2[i+1][j];\n                        \n\n}", "prefix": "int* pathsWithMaxScore(char ** board, int boardSize, int* returnSize"}
{"id": "1977", "path": "output2\\c\\Hard\\1977-verbal-arithmetic-puzzle.c", "hypo_code": "bool isSolvable(char ** words, int wordsSize, char * result){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr[i] = -1;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr2[i] = -1;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr3[i] = -1;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr4[i] = -1;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr5[i] = -1;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr6[i] = -1;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr7[i] = -1;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr8[i] = -1;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr9[i] = -1;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr10[i] = -1;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr11[i] = -1;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr12[i] = -1;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr13[i] = -1;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr = -1;\n        \n\n}", "prefix": "bool isSolvable(char ** words, int wordsSize, char * result"}
{"id": "1978", "path": "output2\\c\\Hard\\1978-minimum-insertion-steps-to-make-a-string-palindrome.c", "hypo_code": "int minInsertions(char * s){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*strlen(s));\n    for(i=0;i<strlen(s);i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*strlen(s));\n    for(i=0;i<strlen(s);i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*strlen(s));\n    for(i=0;i<strlen(s);i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*strlen(s));\n    for(i=0;i<strlen(s);i++){\n        arr4[i] = 0;\n    }\n    int ans = 0;\n    int flag = 0;\n    while(flag==0){\n        flag = 1;\n        for(i=0;i<strlen(s);i++){\n            if(arr[i]<strlen(s)){\n                flag = 0;\n                break;\n            }\n        }\n        if(flag==1){\n            break;\n        }\n        for(i=0;i<strlen(s);i++){\n            if(arr[i]<strlen(s)){\n                arr[i]++;\n                arr2[i]++;\n                break;\n            }\n        }\n        for(i=0;i<strlen(s);i++){\n            if(arr3[i]<strlen(s)){\n                arr3[i]++;\n                arr4[i]++;\n                break;\n            }\n        }\n        ans++;\n    }\n    return ans;\n\n}", "prefix": "int minInsertions(char * s"}
{"id": "1979", "path": "output2\\c\\Hard\\1979-distinct-echo-substrings.c", "hypo_code": "int distinctEchoSubstrings(char * text){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(text);i++){\n        if(text[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (text[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(text);i++){\n        if(text[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (text[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(text);i++){\n        if(text[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (text[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(text);i++){\n        if(text[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4*10 + (text[i]-'0\n\n}", "prefix": "int distinctEchoSubstrings(char * text"}
{"id": "1980", "path": "output2\\c\\Hard\\1980-minimum-distance-to-type-a-word-using-two-fingers.c", "hypo_code": "int minimumDistance(char * word){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (s[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (s[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (s[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4*10 + (s[i]-'0\n\n}", "prefix": "int minimumDistance(char * word"}
{"id": "1981", "path": "output2\\c\\Hard\\1981-minimum-number-of-taps-to-open-to-water-a-garden.c", "hypo_code": "int minTaps(int n, int* ranges, int rangesSize){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    for(i=0;i<rangesSize;i++){\n        if(ranges[i]>0){\n            int start = i-ranges[i];\n            int end = i+ranges[i];\n            if(start<0){\n                start = 0;\n            }\n            if(end>n){\n                end = n;\n            }\n            for(j=start;j<end;j++){\n                arr[j] = 1;\n            }\n        }\n    }\n    int ans = 0;\n    int flag = 0;\n    while(flag==0){\n        flag = 1;\n        for(i=0;i<n;i++){\n            if(arr[i]==0){\n                flag = 0;\n                break;\n            }\n        }\n        if(flag==1){\n            break;\n        }\n        for(i=0;i<n;i++){\n            if(arr[i]==0){\n                arr[i] = 1;\n                break;\n            }\n        }\n        ans++;\n    }\n    return ans;\n\n}", "prefix": "int minTaps(int n, int* ranges, int rangesSize"}
{"id": "1982", "path": "output2\\c\\Hard\\1982-reverse-subarray-to-maximize-array-value.c", "hypo_code": "int maxValueAfterReverse(int* nums, int numsSize){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr13[i] = 0;\n    }\n    \n\n}", "prefix": "int maxValueAfterReverse(int* nums, int numsSize"}
{"id": "1983", "path": "output2\\c\\Hard\\1983-minimum-difficulty-of-a-job-schedule.c", "hypo_code": "int minDifficulty(int* jobDifficulty, int jobDifficultySize, int d){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*jobDifficultySize);\n    for(i=0;i<jobDifficultySize;i++){\n        arr[i] = 0;\n    }\n    int* dp = (int*)malloc(sizeof(int)*jobDifficultySize);\n    for(i=0;i<jobDifficultySize;i++){\n        dp[i] = 0;\n    }\n    for(i=0;i<d;i++){\n        for(j=0;j<jobDifficultySize;j++){\n            if(i==0){\n                if(j==0){\n                    dp[j] = jobDifficulty[j];\n                }\n                else{\n                    dp[j] = dp[j-1]+jobDifficulty[j];\n                }\n            }\n            else{\n                if(j==0){\n                    dp[j] = dp[j]+jobDifficulty[j];\n                }\n                else{\n                    int max = jobDifficulty[j];\n                    for(k=j-1;k>=0;k--){\n                        if(max<jobDifficulty[k]){\n                            max = jobDifficulty[k];\n                        }\n                        if(dp[k]+max<dp[j]){\n                            dp[j] = dp[k]+max;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dp[jobDifficultySize-1];\n\n}", "prefix": "int minDifficulty(int* jobDifficulty, int jobDifficultySize, int d"}
{"id": "1984", "path": "output2\\c\\Hard\\1984-jump-game-v.c", "hypo_code": "int maxJumps(int* arr, int arrSize, int d){\n    int i,j,k;\n    int* arr2 = (int*)malloc(sizeof(int)*arrSize);\n    for(i=0;i<arrSize;i++){\n        arr2[i] = 1;\n    }\n    for(i=0;i<arrSize;i++){\n        for(j=i+1;j<arrSize;j++){\n            if(arr[j]>arr[i]){\n                arr2[i]++;\n            }\n            else{\n                break;\n            }\n        }\n        for(j=i-1;j>=0;j--){\n            if(arr[j]>arr[i]){\n                arr2[i]++;\n            }\n            else{\n                break;\n            }\n        }\n    }\n    int max = 0;\n    for(i=0;i<arrSize;i++){\n        if(arr2[i]>max){\n            max = arr2[i];\n        }\n    }\n    return max;\n\n}", "prefix": "int maxJumps(int* arr, int arrSize, int d"}
{"id": "1985", "path": "output2\\c\\Hard\\1985-jump-game-iv.c", "hypo_code": "int minJumps(int* arr, int arrSize){\n    int i,j,k;\n    int* arr2 = (int*)malloc(sizeof(int)*arrSize);\n    for(i=0;i<arrSize;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<arrSize;i++){\n        for(j=i+1;j<arrSize;j++){\n            if(arr[j]==arr[i]){\n                arr2[i]++;\n            }\n            else{\n                break;\n            }\n        }\n        for(j=i-1;j>=0;j--){\n            if(arr[j]==arr[i]){\n                arr2[i]++;\n            }\n            else{\n                break;\n            }\n        }\n    }\n    int max = 0;\n    for(i=0;i<arrSize;i++){\n        if(arr2[i]>max){\n            max = arr2[i];\n        }\n    }\n    return max;\n\n}", "prefix": "int minJumps(int* arr, int arrSize"}
{"id": "1986", "path": "output2\\c\\Hard\\1986-maximum-students-taking-exam.c", "hypo_code": "int maxStudents(char** seats, int seatsSize, int* seatsColSize){\n    int i,j,k;\n    int* arr2 = (int*)malloc(sizeof(int)*seatsSize);\n    for(i=0;i<seatsSize;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<seatsSize;i++){\n        for(j=i+1;j<seatsSize;j++){\n            if(seats[j][0]==seats[i][0]){\n                arr2[i]++;\n            }\n            else{\n                break;\n            }\n        }\n        for(j=i-1;j>=0;j--){\n            if(seats[j][0]==seats[i][0]){\n                arr2[i]++;\n            }\n            else{\n                break;\n            }\n        }\n    }\n    int max = 0;\n    for(i=0;i<seatsSize;i++){\n        if(arr2[i]>max){\n            max = arr2[i];\n        }\n    }\n    return max;\n\n}", "prefix": "int maxStudents(char** seats, int seatsSize, int* seatsColSize"}
{"id": "1987", "path": "output2\\c\\Hard\\1987-construct-target-array-with-multiple-sums.c", "hypo_code": "bool isPossible(int* target, int targetSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr[i] = 1;\n    }\n    int sum = 0;\n    for(i=0;i<targetSize;i++){\n        sum += target[i];\n    }\n    int max = 0;\n    int maxIndex = 0;\n    for(i=0;i<targetSize;i++){\n        if(target[i]>max){\n            max = target[i];\n            maxIndex = i;\n        }\n    }\n    while(sum>targetSize){\n        sum -= max;\n        if(sum==1){\n            return true;\n        }\n        max = max - sum;\n        if(max<=0){\n            return false;\n        }\n        sum += max;\n    }\n    return false;\n\n}", "prefix": "bool isPossible(int* target, int targetSize"}
{"id": "1988", "path": "output2\\c\\Hard\\1988-count-all-valid-pickup-and-delivery-options.c", "hypo_code": "int countOrders(int n){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<n;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<n;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int countOrders(int n"}
{"id": "1989", "path": "output2\\c\\Hard\\1989-largest-multiple-of-three.c", "hypo_code": "char * largestMultipleOfThree(int* digits, int digitsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*digitsSize);\n    for(i=0;i<digitsSize;i++){\n        arr[i] = digits[i];\n    }\n    int sum = 0;\n    for(i=0;i<digitsSize;i++){\n        sum += arr[i];\n    }\n    if(sum%3==0){\n        return \"0\";\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*digitsSize);\n    for(i=0;i<digitsSize;i++){\n        arr2[i] = 0;\n    }\n    int count = 0;\n    int count2 = 0;\n    int count3 = 0;\n    for(i=0;i<digitsSize;i++){\n        if(arr[i]%3==1){\n            count++;\n        }\n        else if(arr[i]%3==2){\n            count2++;\n        }\n        else{\n            count3++;\n        }\n    }\n    if(sum%3==1){\n        if(count>0){\n            for(i=0;i<digitsSize;i++){\n                if(arr[i]%3==1){\n                    arr2[i] = 1;\n                    break;\n                }\n            }\n        }\n        else{\n            for(i=0;i<digitsSize;i++){\n                if(arr[i]%3==2){\n                    arr2[i] = 1;\n                    count2--;\n                    if(count2==0){\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    else{\n        if(count2>0){\n            for(i=0;i<digitsSize;i++){\n                if(arr[i]%3==2){\n                    arr2[i] = 1;\n                    break;\n                }\n            }\n        }\n        else{\n            for(i=0;i<digitsSize;i++){\n                if(arr[i]%3==1){\n                    arr2[i] = 1;\n                    count--;\n                    if(count==0){\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*digitsSize);\n    for(i=0;i<digitsSize;i++){\n        arr3[i] = 0;\n    }\n    int count4 = 0;\n    for(i=0;i<digitsSize;i++){\n        if(arr2[i]==0){\n            arr3[count4] = arr[i];\n            count4++;\n        }\n    }\n    int* arr4 = (int*)malloc\n\n}", "prefix": "char * largestMultipleOfThree(int* digits, int digitsSize"}
{"id": "1990", "path": "output2\\c\\Hard\\1990-minimum-cost-to-make-at-least-one-valid-path-in-a-grid.c", "hypo_code": "int minCost(int** grid, int gridSize, int* gridColSize){\n    int i,j,k;\n    int* arr2 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<gridSize;i++){\n        for(j=i+1;j<gridSize;j++){\n            if(grid[j]==grid[i]){\n                arr2[i]++;\n            }\n            else{\n                break;\n            }\n        }\n        for(j=i-1;j>=0;j--){\n            if(grid[j]==grid[i]){\n                arr2[i]++;\n            }\n            else{\n                break;\n            }\n        }\n    }\n    int max = 0;\n    for(i=0;i<gridSize;i++){\n        if(arr2[i]>max){\n            max = arr2[i];\n        }\n    }\n    return max;\n\n\n\n}", "prefix": "int minCost(int** grid, int gridSize, int* gridColSize"}
{"id": "1991", "path": "output2\\c\\Hard\\1991-maximum-sum-bst-in-binary-tree.c", "hypo_code": "int maxSumBST(struct TreeNode* root){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*100);\n    for(i=0;i<100;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int count2 = 0;\n    int count3 = 0;\n    int count4 = 0;\n    int count5 = 0;\n    int count6 = 0;\n    int count7 = 0;\n    int count8 = 0;\n    int count9 = 0;\n    int count10 = 0;\n    int count11 = 0;\n    int count12 = 0;\n    int count13 = 0;\n    int count14 = 0;\n    int count15 = 0;\n    int count16 = 0;\n    int count17 = 0;\n    int count18 = 0;\n    int count19 = 0;\n    int count20 = 0;\n    int count21 = 0;\n    int count22 = 0;\n    int count23 = 0;\n    int count24 = 0;\n    int count25 = 0;\n    int count26 = 0;\n    int count27 = 0;\n    int count28 = 0;\n    int count29 = 0;\n    int count30 = 0;\n    int count31 = 0;\n    int count32 = 0;\n    int count33 = 0;\n    int count34 = 0;\n    int count35 = 0;\n    int count36 = 0;\n    int count37 = 0;\n    int count38 = 0;\n    int count39 = 0;\n    int count40 = 0;\n    int count41 = 0;\n    int count42 = 0;\n    int count43 = 0;\n    int count44 = 0;\n    int count45 = 0;\n    int count46 = 0;\n    int count47 = 0;\n    int count48 = 0;\n    int count49 = 0;\n    int count50 = 0;\n    int count51 = 0;\n    int count52 = 0;\n    int count53 = 0;\n    int count54 = 0;\n    int count55 = 0;\n    int count56 = 0;\n    int count57 = 0;\n    \n\n}", "prefix": "int maxSumBST(struct TreeNode* root"}
{"id": "1992", "path": "output2\\c\\Hard\\1992-frog-position-after-t-seconds.c", "hypo_code": "double frogPosition(int n, int** edges, int edgesSize, int* edgesColSize, int t, int target){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    for(i=0;i<edgesSize;i++){\n        arr[edges[i][0]-1]++;\n        arr[edges[i][1]-1]++;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<edgesSize;i++){\n        if(edges[i][0]==1){\n            arr2[edges[i][1]-1] = 1;\n        }\n        if(edges[i][1]==1){\n            arr2[edges[i][0]-1] = 1;\n        }\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr3[i] = 0;\n    }\n    for(i=0;i<edgesSize;i++){\n        if(arr2[edges[i][0]-1]==1){\n            arr3[edges[i][1]-1] = 1;\n        }\n        if(arr2[edges[i][1]-1]==1){\n            arr3[edges[i][0]-1] = 1;\n        }\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr4[i] = 0;\n    }\n    for(i=0;i<edgesSize;i++){\n        if(arr3[edges[i][0]-1]==1){\n            arr4[edges[i][1]-1] = 1;\n        }\n        if(arr3[edges[i][1]-1]==1){\n            arr4[edges[i][0]-1] = 1;\n        }\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr5[i] = 0;\n    }\n    for(i=0;i<edgesSize;i++){\n        if(arr4[edges[i][0]-1]==1){\n            arr5[edges[i][1]-1] = 1;\n        }\n        if(arr4[edges[i][1]-1]==1){\n            arr5[edges[i][0]-1] = 1;\n\n}", "prefix": "double frogPosition(int n, int** edges, int edgesSize, int* edgesColSize, int t, int target"}
{"id": "1993", "path": "output2\\c\\Hard\\1993-maximum-performance-of-a-team.c", "hypo_code": "int maxPerformance(int n, int* speed, int speedSize, int* efficiency, int efficiencySize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<n;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<n;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int maxPerformance(int n, int* speed, int speedSize, int* efficiency, int efficiencySize, int k"}
{"id": "1994", "path": "output2\\c\\Hard\\1994-pizza-with-3n-slices.c", "hypo_code": "int maxSizeSlices(int* slices, int slicesSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*slicesSize);\n    for(i=0;i<slicesSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<slicesSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<slicesSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n\n}", "prefix": "int maxSizeSlices(int* slices, int slicesSize"}
{"id": "1995", "path": "output2\\c\\Hard\\1995-longest-happy-prefix.c", "hypo_code": "char * longestPrefix(char * s){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (s[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (s[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (s[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4*10 + (s[i]-'0\n\n}", "prefix": "char * longestPrefix(char * s"}
{"id": "1996", "path": "output2\\c\\Hard\\1996-find-all-good-strings.c", "hypo_code": "int findGoodStrings(int n, char * s1, char * s2, char * evil){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(s1);i++){\n        if(s1[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (s1[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(s2);i++){\n        if(s2[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (s2[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(evil);i++){\n        if(evil[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (evil[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(evil);i++){\n        if(evil[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4*10 + (evil[i]-'0');\n\n}", "prefix": "int findGoodStrings(int n, char * s1, char * s2, char * evil"}
{"id": "1997", "path": "output2\\c\\Hard\\1997-reducing-dishes.c", "hypo_code": "int maxSatisfaction(int* satisfaction, int satisfactionSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*satisfactionSize);\n    for(i=0;i<satisfactionSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<satisfactionSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<satisfactionSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int maxSatisfaction(int* satisfaction, int satisfactionSize"}
{"id": "1998", "path": "output2\\c\\Hard\\1998-stone-game-iii.c", "hypo_code": "char * stoneGameIII(int* stoneValue, int stoneValueSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr[i] = stoneValue[i];\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*stone\n\n}", "prefix": "char * stoneGameIII(int* stoneValue, int stoneValueSize"}
{"id": "1999", "path": "output2\\c\\Hard\\1999-number-of-ways-to-paint-n-3-grid.c", "hypo_code": "int numOfWays(int n){\nint i, j, k, l, m, n;\n    int mod = 1000000007;\n    int dp[5001][3][3][3];\n    for (i = 0; i < 5001; i++) {\n        for (j = 0; j < 3; j++) {\n            for (k = 0; k < 3; k++) {\n                for (l = 0; l < 3; l++) {\n                    dp[i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n            for (k = 0; k < 3; k++) {\n                if (i != j && j != k) {\n                    dp[1][i][j][k] = 1;\n                }\n            }\n        }\n    }\n    for (i = 2; i <= n; i++) {\n        for (j = 0; j < 3; j++) {\n            for (k = 0; k < 3; k++) {\n                for (l = 0; l < 3; l++) {\n                    for (m = 0; m < 3; m++) {\n                        if (j != k && k != l && l != m) {\n                            dp[i][k][l][m] = (dp[i][k][l][m] + dp[i - 1][j][k][l]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 3; j++) {\n            for (k = 0; k < 3; k++) {\n                ans = (ans + dp[n][i][j][k]) % mod;\n            }\n        }\n    }\n    return ans;\n}", "prefix": "int numOfWays(int n"}
{"id": "2000", "path": "output2\\c\\Hard\\2000-restore-the-array.c", "hypo_code": "int numberOfArrays(char * s, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr[i] = 0;\n    }\n    int len = strlen(s);\n    int* arr2 = (int*)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<len;i++){\n        if(s[i]=='0'){\n            return 0;\n        }\n        int num = 0;\n        for(j=i;j<len;j++){\n            num = num*10 + (s[j]-'0');\n            if(num<=k){\n                if(i==0){\n                    arr[j] = 1;\n                }\n                else{\n                    arr[j] = (arr[j] + arr2[i-1]) % 1000000007;\n                }\n            }\n            else{\n                break;\n            }\n        }\n        for(j=0;j<len;j++){\n            arr2[j] = arr[j];\n        }\n    }\n    return arr[len-1];\n\n}", "prefix": "int numberOfArrays(char * s, int k"}
{"id": "2001", "path": "output2\\c\\Hard\\2001-build-array-where-you-can-find-the-maximum-exactly-k-comparisons.c", "hypo_code": "int numOfArrays(int n, int m, int k){\nint i, j, k, l, m, n;\n    int dp[51][51][101];\n    int mod = 1000000007;\n    for (i = 0; i < 51; i++) {\n        for (j = 0; j < 51; j++) {\n            for (k = 0; k < 101; k++) {\n                dp[i][j][k] = 0;\n            }\n        }\n    }\n    for (i = 1; i <= m; i++) {\n        dp[1][1][i] = 1;\n    }\n    for (i = 2; i <= n; i++) {\n        for (j = 1; j <= i; j++) {\n            for (k = 1; k <= m; k++) {\n                dp[i][j][k] = (dp[i][j][k] + (long)dp[i - 1][j][k] * k) % mod;\n                for (l = 1; l < k; l++) {\n                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j - 1][l]) % mod;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (i = 1; i <= m; i++) {\n        ans = (ans + dp[n][k][i]) % mod;\n    }\n    return ans;\n}", "prefix": "int numOfArrays(int n, int m, int k"}
{"id": "2002", "path": "output2\\c\\Hard\\2002-constrained-subsequence-sum.c", "hypo_code": "int constrainedSubsetSum(int* nums, int numsSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = nums[i];\n    }\n    for(i=1;i<numsSize;i++){\n        int max = 0;\n        for(j=i-1;j>=0 && i-j<=k;j--){\n            if(arr[j]>max){\n                max = arr[j];\n            }\n        }\n        arr[i] = arr[i] + max;\n    }\n    int max = 0;\n    for(i=0;i<numsSize;i++){\n        if(arr[i]>max){\n            max = arr[i];\n        }\n    }\n    return max;\n\n}", "prefix": "int constrainedSubsetSum(int* nums, int numsSize, int k"}
{"id": "2003", "path": "output2\\c\\Hard\\2003-number-of-ways-to-wear-different-hats-to-each-other.c", "hypo_code": "int numberWays(int** hats, int hatsSize, int* hatsColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*hatsSize);\n    for(i=0;i<hatsSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<hatsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<hatsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int numberWays(int** hats, int hatsSize, int* hatsColSize"}
{"id": "2004", "path": "output2\\c\\Hard\\2004-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows.c", "hypo_code": "int kthSmallest(int** mat, int matSize, int* matColSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*matSize);\n    for(i=0;i<matSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<matSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<matSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n\n}", "prefix": "int kthSmallest(int** mat, int matSize, int* matColSize, int k"}
{"id": "2005", "path": "output2\\c\\Hard\\2005-number-of-ways-of-cutting-a-pizza.c", "hypo_code": "int ways(char ** pizza, int pizzaSize, int k){\n    int i,j;\n    int** arr = (int**)malloc(sizeof(int*)*pizzaSize);\n    for(i=0;i<pizzaSize;i++){\n        arr[i] = (int*)malloc(sizeof(int)*pizzaSize);\n    }\n    for(i=0;i<pizzaSize;i++){\n        for(j=0;j<pizzaSize;j++){\n            arr[i][j] = 0;\n        }\n    }\n    for(i=0;i<pizzaSize;i++){\n        for(j=0;j<pizzaSize;j++){\n            if(pizza[i][j] == 'A'){\n                arr[i][j] = 1;\n            }\n        }\n    }\n    int** arr2 = (int**)malloc(sizeof(int*)*pizzaSize);\n    for(i=0;i<pizzaSize;i++){\n        arr2[i] = (int*)malloc(sizeof(int)*pizzaSize);\n    }\n    for(i=0;i<pizzaSize;i++){\n        for(j=0;j<pizzaSize;j++){\n            arr2[i][j] = 0;\n        }\n    }\n    for(i=0;i<k-1;i++){\n        for(j=0;j<pizzaSize;j++){\n            for(int l=0;l<pizzaSize;l++){\n                if(arr[j][l] == 1){\n                    for(int m=j+1;m<pizzaSize;m++){\n                        if(arr[m][l] == 1){\n                            arr2[j][l] = (arr2[j][l] + arr[m][l])%1000000007;\n                        }\n                    }\n                    for(int m=l+1;m<pizzaSize;m++){\n                        if(arr[j][m] == 1){\n                            arr2[j][l] = (arr2[j][l] + arr[j][m])%1000000007;\n                        }\n                    }\n                }\n            }\n        }\n        for(j=0;j<pizzaSize;j++){\n            for(int l=0;l<pizzaSize;l++){\n                arr[j][l] = arr2[j][l];\n                arr2[j][l] = 0;\n            }\n        }\n    }\n    int sum = 0;\n    for(i=0;i<pizzaSize;i++){\n        for(j=0;j<pizzaSize;j++){\n            sum = (sum + arr[i][j])%1000000007;\n        }\n    }\n    return sum;\n\n}", "prefix": "int ways(char ** pizza, int pizzaSize, int k"}
{"id": "2006", "path": "output2\\c\\Hard\\2006-form-largest-integer-with-digits-that-add-up-to-target.c", "hypo_code": "char * largestNumber(int* cost, int costSize, int target){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*target);\n    for(i=0;i<target;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*target);\n    for(i=0;i<target;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<target;i++){\n        for(j=0;j<costSize;j++){\n            if(i+1==cost[j]){\n                arr[i] = j+1;\n            }\n        }\n    }\n    for(i=0;i<target;i++){\n        for(j=0;j<costSize;j++){\n            if(i+1>cost[j]){\n                if(arr[i]<arr[i-cost[j]]+j+1){\n                    arr[i] = arr[i-cost[j]]+j+1;\n                }\n            }\n        }\n    }\n    if(arr[target-1]==0){\n        return \"0\";\n    }\n    char* str = (char*)malloc(sizeof(char)*arr[target-1]);\n    for(i=0;i<arr[target-1];i++){\n        str[i] = '0';\n    }\n    int num = target;\n    for(i=arr[target-1]-1;i>=0;i--){\n        for(j=costSize-1;j>=0;j--){\n            if(num>=cost[j]){\n                if(arr[num-1]==arr[num-cost[j]-1]+j+1){\n                    str[i] = j+1+'0';\n                    num = num-cost[j];\n                    break;\n                }\n            }\n        }\n    }\n    return str;\n\n}", "prefix": "char * largestNumber(int* cost, int costSize, int target"}
{"id": "2007", "path": "output2\\c\\Hard\\2007-maximum-number-of-darts-inside-of-a-circular-dartboard.c", "hypo_code": "int numPoints(int** darts, int dartsSize, int* dartsColSize, int r){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*dartsSize);\n    for(i=0;i<dartsSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<dartsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<dartsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int numPoints(int** darts, int dartsSize, int* dartsColSize, int r"}
{"id": "2008", "path": "output2\\c\\Hard\\2008-max-dot-product-of-two-subsequences.c", "hypo_code": "int maxDotProduct(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int i,j,k;\n    int** arr = (int**)malloc(sizeof(int*)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr[i] = (int*)malloc(sizeof(int)*nums2Size);\n    }\n    for(i=0;i<nums1Size;i++){\n        for(j=0;j<nums2Size;j++){\n            arr[i][j] = nums1[i] * nums2[j];\n        }\n    }\n    for(i=1;i<nums1Size;i++){\n        for(j=1;j<nums2Size;j++){\n            int max = 0;\n            for(k=1;k<=i && k<=j;k++){\n                if(arr[i-k][j-k]>max){\n                    max = arr[i-k][j-k];\n                }\n            }\n            arr[i][j] = arr[i][j] + max;\n        }\n    }\n    int max = 0;\n    for(i=0;i<nums1Size;i++){\n        for(j=0;j<nums2Size;j++){\n            if(arr[i][j]>max){\n                max = arr[i][j];\n            }\n        }\n    }\n    return max;\n\n}", "prefix": "int maxDotProduct(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "2009", "path": "output2\\c\\Hard\\2009-cherry-pickup-ii.c", "hypo_code": "int cherryPickup(int** grid, int gridSize, int* gridColSize){\n    int i,j;\n    int** arr = (int**)malloc(sizeof(int*)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr[i] = (int*)malloc(sizeof(int)*gridColSize[0]);\n    }\n    for(i=0;i<gridSize;i++){\n        for(j=0;j<gridColSize[0];j++){\n            arr[i][j] = 0;\n        }\n    }\n    for(i=0;i<gridSize;i++){\n        for(j=0;j<gridColSize[0];j++){\n            if(i == 0){\n                if(j == 0){\n                    arr[i][j] = grid[i][j];\n                }\n                else{\n                    arr[i][j] = arr[i][j-1] + grid[i][j];\n                }\n            }\n            else{\n                if(j == 0){\n                    arr[i][j] = arr[i-1][j] + grid[i][j];\n                }\n                else{\n                    arr[i][j] = arr[i-1][j] + arr[i][j-1] - arr[i-1][j-1] + grid[i][j];\n                }\n            }\n        }\n    }\n    int** arr2 = (int**)malloc(sizeof(int*)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr2[i] = (int*)malloc(sizeof(int)*gridColSize[0]);\n    }\n    for(i=0;i<gridSize;i++){\n        for(j=0;j<gridColSize[0];j++){\n            arr2[i][j] = 0;\n        }\n    }\n    for(i=0;i<gridSize;i++){\n        for(j=0;j<gridColSize[0];j++){\n            if(i == 0){\n                if(j == gridColSize[0]-1){\n                    arr2[i][j] = grid[i][j];\n                }\n                else{\n                    arr2[i][j] = arr2[i][j+1] + grid[i][j];\n                }\n            }\n            else{\n                if(j == gridColSize[0]-1){\n                    arr2[i][j] = arr2[i-1][j] + grid[i][j];\n                }\n                else{\n                    arr2[i][j] = arr2[i-1][j] + arr2[i][j+1\n\n}", "prefix": "int cherryPickup(int** grid, int gridSize, int* gridColSize"}
{"id": "2010", "path": "output2\\c\\Hard\\2010-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls.c", "hypo_code": "double getProbability(int* balls, int ballsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*ballsSize);\n    for(i=0;i<ballsSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<ballsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<ballsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "double getProbability(int* balls, int ballsSize"}
{"id": "2011", "path": "output2\\c\\Hard\\2011-paint-house-iii.c", "hypo_code": "int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*target);\n    for(i=0;i<target;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*target);\n    for(i=0;i<target;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<target;i++){\n        for(j=0;j<costSize;j++){\n            if(i+1==cost[j]){\n                arr[i] = j+1;\n            }\n        }\n    }\n    for(i=0;i<target;i++){\n        for(j=0;j<costSize;j++){\n            if(i+1>cost[j]){\n                if(arr[i]<arr[i-cost[j]]+j+1){\n                    arr[i] = arr[i-cost[j]]+j+1;\n                }\n            }\n        }\n    }\n    if(arr[target-1]==0){\n        return \"0\";\n    }\n    char* str = (char*)malloc(sizeof(char)*arr[target-1]);\n    for(i=0;i<arr[target-1];i++){\n        str[i] = '0';\n    }\n    int num = target;\n    for(i=arr[target-1]-1;i>=0;i--){\n        for(j=costSize-1;j>=0;j--){\n            if(num>=cost[j]){\n                if(arr[num-1]==arr[num-cost[j]-1]+j+1){\n                    str[i] = j+1+'0';\n                    num = num-cost[j];\n                    break;\n                }\n            }\n        }\n    }\n    return str;\n\n}", "prefix": "int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target"}
{"id": "2012", "path": "output2\\c\\Hard\\2012-allocate-mailboxes.c", "hypo_code": "int minDistance(int* houses, int housesSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*housesSize);\n    for(i=0;i<housesSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*housesSize);\n    for(i=0;i<housesSize;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<housesSize;i++){\n        for(j=0;j<housesSize;j++){\n            if(i==j){\n                arr[i] = arr[i] + houses[j];\n            }\n            else{\n                arr[i] = arr[i] + abs(houses[i]-houses[j]);\n            }\n        }\n    }\n    for(i=0;i<housesSize;i++){\n        for(j=0;j<housesSize;j++){\n            if(i==j){\n                arr2[i] = arr2[i] + arr[j];\n            }\n            else{\n                arr2[i] = arr2[i] + abs(arr[i]-arr[j]);\n            }\n        }\n    }\n    int sum = 0;\n    for(i=0;i<housesSize;i++){\n        sum = sum + arr2[i];\n    }\n    return sum;\n\n}", "prefix": "int minDistance(int* houses, int housesSize, int k"}
{"id": "2014", "path": "output2\\c\\Hard\\2014-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree.c", "hypo_code": "int** findCriticalAndPseudoCriticalEdges(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int** findCriticalAndPseudoCriticalEdges(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes"}
{"id": "2015", "path": "output2\\c\\Hard\\2015-parallel-courses-ii.c", "hypo_code": "int** findCriticalAndPseudoCriticalEdges(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int** findCriticalAndPseudoCriticalEdges(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes"}
{"id": "2016", "path": "output2\\c\\Hard\\2016-max-value-of-equation.c", "hypo_code": "int findMaxValueOfEquation(int** points, int pointsSize, int* pointsColSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*pointsSize);\n    for(i=0;i<pointsSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<pointsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<pointsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int findMaxValueOfEquation(int** points, int pointsSize, int* pointsColSize, int k"}
{"id": "2017", "path": "output2\\c\\Hard\\2017-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits.c", "hypo_code": "char * minInteger(char * num, int k){\n    int i,j;\n    int len = strlen(num);\n    int* arr = (int*)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr[i] = num[i]-'0';\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<len;i++){\n        int min = 10;\n        int index = 0;\n        for(j=i;j<len;j++){\n            if(arr[j]<min){\n                min = arr[j];\n                index = j;\n            }\n        }\n        if(index-i>k){\n            for(j=i;j<len;j++){\n                if(arr[j]==min){\n                    index = j;\n                    break;\n                }\n            }\n        }\n        arr2[i] = arr[index];\n        for(j=index;j>i;j--){\n            arr[j] = arr[j-1];\n        }\n        k = k-(index-i);\n    }\n    char* str = (char*)malloc(sizeof(char)*len);\n    for(i=0;i<len;i++){\n        str[i] = arr2[i]+'0';\n    }\n    return str;\n\n}", "prefix": "char * minInteger(char * num, int k"}
{"id": "2018", "path": "output2\\c\\Hard\\2018-stone-game-iv.c", "hypo_code": "bool winnerSquareGame(int n){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*(n+1));\n    for(i=0;i<n+1;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<n+1;i++){\n        for(j=1;j*j<=i;j++){\n            if(arr[i-j*j] == 0){\n                arr[i] = 1;\n                break;\n            }\n        }\n    }\n    return arr[n] == 1;\n\n}", "prefix": "bool winnerSquareGame(int n"}
{"id": "2019", "path": "output2\\c\\Hard\\2019-best-position-for-a-service-centre.c", "hypo_code": "double getMinDistSum(int** positions, int positionsSize, int* positionsColSize){\nint i, j, k, l, m, n;\n    double x = 0, y = 0, step = 50, sum = 0;\n    for (i = 0; i < positionsSize; i++) {\n        x += positions[i][0];\n        y += positions[i][1];\n    }\n    x /= positionsSize;\n    y /= positionsSize;\n    while (step > 1e-6) {\n        int flag = 1;\n        for (i = -1; i <= 1; i++) {\n            for (j = -1; j <= 1; j++) {\n                double nx = x + step * i, ny = y + step * j;\n                double tmp = 0;\n                for (k = 0; k < positionsSize; k++) {\n                    tmp += sqrt(pow(nx - positions[k][0], 2) + pow(ny - positions[k][1], 2));\n                }\n                if (tmp < sum) {\n                    sum = tmp;\n                    x = nx;\n                    y = ny;\n                    flag = 0;\n                }\n            }\n        }\n        if (flag) {\n            step /= 2;\n        }\n    }\n    return sum;\n}", "prefix": "double getMinDistSum(int** positions, int positionsSize, int* positionsColSize"}
{"id": "2020", "path": "output2\\c\\Hard\\2020-maximum-number-of-non-overlapping-substrings.c", "hypo_code": "char ** maxNumOfSubstrings(char * s, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr\n\n}", "prefix": "char ** maxNumOfSubstrings(char * s, int* returnSize"}
{"id": "2021", "path": "output2\\c\\Hard\\2021-find-a-value-of-a-mysterious-function-closest-to-target.c", "hypo_code": "int closestToTarget(int* arr, int arrSize, int target){\nint i, j, k, l, m, n;\n    int ans = 0x7fffffff;\n    for (i = 0; i < arrSize; i++) {\n        int tmp = arr[i];\n        for (j = i; j < arrSize; j++) {\n            tmp &= arr[j];\n            ans = ans < abs(tmp - target) ? ans : abs(tmp - target);\n            if (ans == 0) {\n                return 0;\n            }\n        }\n    }\n    return ans;\n}", "prefix": "int closestToTarget(int* arr, int arrSize, int target"}
{"id": "2022", "path": "output2\\c\\Hard\\2022-minimum-number-of-increments-on-subarrays-to-form-a-target-array.c", "hypo_code": "int minNumberOperations(int* target, int targetSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int minNumberOperations(int* target, int targetSize"}
{"id": "2023", "path": "output2\\c\\Hard\\2023-string-compression-ii.c", "hypo_code": "int getLengthOfOptimalCompression(char * s, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr\n\n}", "prefix": "int getLengthOfOptimalCompression(char * s, int k"}
{"id": "2024", "path": "output2\\c\\Hard\\2024-get-the-maximum-score.c", "hypo_code": "int maxSum(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*nums1\n\n}", "prefix": "int maxSum(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "2025", "path": "output2\\c\\Hard\\2025-find-longest-awesome-substring.c", "hypo_code": "int longestAwesome(char * s){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr\n\n}", "prefix": "int longestAwesome(char * s"}
{"id": "2026", "path": "output2\\c\\Hard\\2026-minimum-cost-to-cut-a-stick.c", "hypo_code": "int minCost(int n, int* cuts, int cutsSize){\nint i, j, k, l, m, n;\n    int dp[102][102];\n    int min = 0x7fffffff;\n    for (i = 0; i < 102; i++) {\n        for (j = 0; j < 102; j++) {\n            dp[i][j] = 0x7fffffff;\n        }\n    }\n    dp[0][0] = 0;\n    for (i = 1; i <= cutsSize; i++) {\n        for (j = 0; j <= cutsSize; j++) {\n            for (k = 0; k < cutsSize; k++) {\n                if (cuts[k] > dp[i - 1][j] && cuts[k] < dp[i][j]) {\n                    dp[i][j] = cuts[k];\n                }\n            }\n            if (dp[i][j] != 0x7fffffff) {\n                dp[i][j] = dp[i][j] - dp[i - 1][j];\n            }\n        }\n    }\n    for (i = 0; i <= cutsSize; i++) {\n        min = min < dp[cutsSize][i] ? min : dp[cutsSize][i];\n    }\n    return min;\n\n}", "prefix": "int minCost(int n, int* cuts, int cutsSize"}
{"id": "2027", "path": "output2\\c\\Hard\\2027-minimum-number-of-days-to-eat-n-oranges.c", "hypo_code": "int minDays(int n){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<n;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[n-1];\n\n}", "prefix": "int minDays(int n"}
{"id": "2028", "path": "output2\\c\\Hard\\2028-stone-game-v.c", "hypo_code": "int stoneGameV(int* stoneValue, int stoneValueSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr[i] = stoneValue[i];\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*stoneValueSize);\n    for(i=0;i<stoneValueSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*stone\n\n}", "prefix": "int stoneGameV(int* stoneValue, int stoneValueSize"}
{"id": "2029", "path": "output2\\c\\Hard\\2029-minimum-number-of-days-to-disconnect-island.c", "hypo_code": "int minDays(int** grid, int gridSize, int* gridColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*gridSize);\n    for(i=0;i<gridSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int minDays(int** grid, int gridSize, int* gridColSize"}
{"id": "2030", "path": "output2\\c\\Hard\\2030-number-of-ways-to-reorder-array-to-get-same-bst.c", "hypo_code": "int numOfWays(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<numsSize;i++){\n        arr[i] = arr[i-1] * i;\n    }\n    int sum = 0;\n    for(i=0;i<numsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int numOfWays(int* nums, int numsSize"}
{"id": "2031", "path": "output2\\c\\Hard\\2031-count-all-possible-routes.c", "hypo_code": "int countRoutes(int* locations, int locationsSize, int start, int finish, int fuel){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*locationsSize);\n    for(i=0;i<locationsSize;i++){\n        arr[i] = 0;\n    }\n    arr[start] = 1;\n    for(i=1;i<=fuel;i++){\n        for(j=0;j<locationsSize;j++){\n            for(k=0;k<locationsSize;k++){\n                if(j != k){\n                    arr[j] = (arr[j] + arr[k]) % 1000000007;\n                }\n            }\n        }\n    }\n    int sum = 0;\n    for(i=0;i<locationsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n\n}", "prefix": "int countRoutes(int* locations, int locationsSize, int start, int finish, int fuel"}
{"id": "2032", "path": "output2\\c\\Hard\\2032-remove-max-number-of-edges-to-keep-graph-fully-traversable.c", "hypo_code": "int maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<edgesSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<edgesSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n\n}", "prefix": "int maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2033", "path": "output2\\c\\Hard\\2033-check-if-string-is-transformable-with-substring-sort-operations.c", "hypo_code": "bool isTransformable(char * s, char * t){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr\n\n}", "prefix": "bool isTransformable(char * s, char * t"}
{"id": "2034", "path": "output2\\c\\Hard\\2034-strange-printer-ii.c", "hypo_code": "bool isPrintable(int** targetGrid, int targetGridSize, int* targetGridColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*targetGridSize);\n    for(i=0;i<targetGridSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*targetGrid\n\n}", "prefix": "bool isPrintable(int** targetGrid, int targetGridSize, int* targetGridColSize"}
{"id": "2035", "path": "output2\\c\\Hard\\2035-minimum-cost-to-connect-two-groups-of-points.c", "hypo_code": "int connectTwoGroups(int** cost, int costSize, int* costColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*costSize);\n    for(i=0;i<costSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int connectTwoGroups(int** cost, int costSize, int* costColSize"}
{"id": "2036", "path": "output2\\c\\Hard\\2036-maximum-number-of-achievable-transfer-requests.c", "hypo_code": "int maximumRequests(int n, int** requests, int requestsSize, int* requestsColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<n;i++){\n        arr[i] = arr[i-1] * i;\n    }\n    int sum = 0;\n    for(i=0;i<n;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int maximumRequests(int n, int** requests, int requestsSize, int* requestsColSize"}
{"id": "2037", "path": "output2\\c\\Hard\\2037-find-servers-that-handled-most-number-of-requests.c", "hypo_code": "int* busiestServers(int k, int* arrival, int arrivalSize, int* load, int loadSize, int* returnSize){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr14[i] = 0;\n    }\n    int* arr15 =\n\n}", "prefix": "int* busiestServers(int k, int* arrival, int arrivalSize, int* load, int loadSize, int* returnSize"}
{"id": "2038", "path": "output2\\c\\Hard\\2038-maximum-number-of-visible-points.c", "hypo_code": "int visiblePoints(int** points, int pointsSize, int* pointsColSize, int angle, int* location, int locationSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*pointsSize);\n    for(i=0;i<pointsSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<pointsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<pointsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n\n}", "prefix": "int visiblePoints(int** points, int pointsSize, int* pointsColSize, int angle, int* location, int locationSize"}
{"id": "2039", "path": "output2\\c\\Hard\\2039-minimum-one-bit-operations-to-make-integers-zero.c", "hypo_code": "int minimumOneBitOperations(int n){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<n;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[n-1];\n\n}", "prefix": "int minimumOneBitOperations(int n"}
{"id": "2040", "path": "output2\\c\\Hard\\2040-count-subtrees-with-max-distance-between-cities.c", "hypo_code": "int* countSubgraphsForEachDiameter(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<edgesSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<edgesSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return arr;\n\n}", "prefix": "int* countSubgraphsForEachDiameter(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize"}
{"id": "2042", "path": "output2\\c\\Hard\\2042-graph-connectivity-with-threshold.c", "hypo_code": "bool* areConnected(int n, int threshold, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<queriesSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<queriesSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return arr;\n\n}", "prefix": "bool* areConnected(int n, int threshold, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "2043", "path": "output2\\c\\Hard\\2043-rank-transform-of-a-matrix.c", "hypo_code": "int** matrixRankTransform(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){\n      \n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*matrixSize);\n    for(i=0;i<matrixSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<matrixSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<matrixSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return arr;\n\n}", "prefix": "int** matrixRankTransform(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes"}
{"id": "2044", "path": "output2\\c\\Hard\\2044-number-of-ways-to-form-a-target-string-given-a-dictionary.c", "hypo_code": "int numWays(char ** words, int wordsSize, char * target){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr[i] = 0;\n    }\n    int len = strlen(target);\n    int* arr2 = (int*)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<wordsSize;i++){\n        int len2 = strlen(words[i]);\n        for(j=0;j<len2;j++){\n            if(words[i][j]==target[0]){\n                arr[j] = (arr[j] + 1) % 1000000007;\n            }\n        }\n    }\n    for(i=1;i<len;i++){\n        for(j=0;j<wordsSize;j++){\n            int len2 = strlen(words[j]);\n            for(k=0;k<len2;k++){\n                if(words[j][k]==target[i]){\n                    arr2[k] = (arr2[k] + arr[k-1]) % 1000000007;\n                }\n            }\n        }\n        for(j=0;j<len2;j++){\n            arr[j] = arr2[j];\n        }\n    }\n    int sum = 0;\n    for(i=0;i<len2;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int numWays(char ** words, int wordsSize, char * target"}
{"id": "2045", "path": "output2\\c\\Hard\\2045-kth-smallest-instructions.c", "hypo_code": "char * kthSmallestPath(int* destination, int destinationSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*destinationSize);\n    for(i=0;i<destinationSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<destinationSize;i++){\n        arr[i] = arr[i-1] * i;\n    }\n    int sum = 0;\n    for(i=0;i<destinationSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "char * kthSmallestPath(int* destination, int destinationSize, int k"}
{"id": "2046", "path": "output2\\c\\Hard\\2046-create-sorted-array-through-instructions.c", "hypo_code": "int createSortedArray(int* instructions, int instructionsSize){\nint i, j, k, l, m, n;\n    int ans = 0;\n    int mod = 1000000007;\n    int max = 0;\n    for (i = 0; i < instructionsSize; i++) {\n        max = max > instructions[i] ? max : instructions[i];\n    }\n    int* bit = (int*)malloc(sizeof(int) * (max + 1));\n    memset(bit, 0, sizeof(int) * (max + 1));\n    for (i = 0; i < instructionsSize; i++) {\n        int left = 0;\n        int right = 0;\n        for (j = instructions[i]; j > 0; j -= (j & (-j))) {\n            left += bit[j];\n        }\n        for (j = instructions[i] + 1; j <= max; j += (j & (-j))) {\n            right += bit[j];\n        }\n        ans = (ans + (left < right ? left : right)) % mod;\n        for (j = instructions[i]; j <= max; j += (j & (-j))) {\n            bit[j]++;\n        }\n    }\n    return ans;\n}", "prefix": "int createSortedArray(int* instructions, int instructionsSize"}
{"id": "2047", "path": "output2\\c\\Hard\\2047-distribute-repeating-integers.c", "hypo_code": "bool canDistribute(int* nums, int numsSize, int* quantity, int quantitySize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<numsSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[numsSize-1];\n\n}", "prefix": "bool canDistribute(int* nums, int numsSize, int* quantity, int quantitySize"}
{"id": "2048", "path": "output2\\c\\Hard\\2048-maximize-grid-happiness.c", "hypo_code": "int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*m);\n    for(i=0;i<m;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<m;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[m-1];\n\n}", "prefix": "int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount"}
{"id": "2049", "path": "output2\\c\\Hard\\2049-minimum-initial-energy-to-finish-tasks.c", "hypo_code": "int minimumEffort(int** tasks, int tasksSize, int* tasksColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*tasksSize);\n    for(i=0;i<tasksSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<tasksSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[tasksSize-1];\n\n}", "prefix": "int minimumEffort(int** tasks, int tasksSize, int* tasksColSize"}
{"id": "2050", "path": "output2\\c\\Hard\\2050-minimum-number-of-removals-to-make-mountain-array.c", "hypo_code": "int minimumMountainRemovals(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<numsSize;i++){\n        for(j=0;j<i;j++){\n            if(nums[j] < nums[i]){\n                arr[i] = (arr[i] < arr[j] + 1) ? arr[i] : arr[j] + 1;\n            }\n        }\n    }\n    int max = 0;\n    for(i=0;i<numsSize;i++){\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr2[i] = 1;\n    }\n    for(i=numsSize-2;i>=0;i--){\n        for(j=numsSize-1;j>i;j--){\n            if(nums[j] < nums[i]){\n                arr2[i] = (arr2[i] < arr2[j] + 1) ? arr2[i] : arr2[j] + 1;\n            }\n        }\n    }\n    int max2 = 0;\n    for(i=0;i<numsSize;i++){\n        if(arr2[i] > max2){\n            max2 = arr2[i];\n        }\n    }\n    return numsSize - max - max2 + 1;\n\n}", "prefix": "int minimumMountainRemovals(int* nums, int numsSize"}
{"id": "2051", "path": "output2\\c\\Hard\\2051-minimize-deviation-in-array.c", "hypo_code": "int minimumDeviation(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = nums[i];\n    }\n    int max = 0;\n    for(i=0;i<numsSize;i++){\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    int min = max;\n    for(i=0;i<numsSize;i++){\n        if(arr[i] < min){\n            min = arr[i];\n        }\n    }\n    int dev = max - min;\n    int* arr2 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<numsSize;i++){\n        if(arr[i] % 2 == 0){\n            arr2[i] = 1;\n        }\n    }\n    int flag = 1;\n    while(flag){\n        flag = 0;\n        for(i=0;i<numsSize;i++){\n            if(arr2[i] == 1){\n                arr[i] = arr[i] / 2;\n                if(arr[i] % 2 == 0){\n                    arr2[i] = 1;\n                }\n                else{\n                    arr2[i] = 0;\n                }\n                flag = 1;\n            }\n        }\n        max = 0;\n        for(i=0;i<numsSize;i++){\n            if(arr[i] > max){\n                max = arr[i];\n            }\n        }\n        min = max;\n        for(i=0;i<numsSize;i++){\n            if(arr[i] < min){\n                min = arr[i];\n            }\n        }\n        if(max - min < dev){\n            dev = max - min;\n        }\n    }\n    return dev;\n\n}", "prefix": "int minimumDeviation(int* nums, int numsSize"}
{"id": "2052", "path": "output2\\c\\Hard\\2052-minimum-incompatibility.c", "hypo_code": "int minimumIncompatibility(int* nums, int numsSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = nums[i];\n    }\n    int max = 0;\n    for(i=0;i<numsSize;i++){\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    int min = max;\n    for(i=0;i<numsSize;i++){\n        if(arr[i] < min){\n            min = arr[i];\n        }\n    }\n    int dev = max - min;\n    int* arr2 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<numsSize;i++){\n        if(arr[i] % 2 == 0){\n            arr2[i] = 1;\n        }\n    }\n    int flag = 1;\n    while(flag){\n        flag = 0;\n        for(i=0;i<numsSize;i++){\n            if(arr2[i] == 1){\n                arr[i] = arr[i] / 2;\n                if(arr[i] % 2 == 0){\n                    arr2[i] = 1;\n                }\n                else{\n                    arr2[i] = 0;\n                }\n                flag = 1;\n            }\n        }\n        max = 0;\n        for(i=0;i<numsSize;i++){\n            if(arr[i] > max){\n                max = arr[i];\n            }\n        }\n        min = max;\n        for(i=0;i<numsSize;i++){\n            if(arr[i] < min){\n                min = arr[i];\n            }\n        }\n        dev = (dev < max - min) ? dev : max - min;\n    }\n    return dev;\n\n}", "prefix": "int minimumIncompatibility(int* nums, int numsSize, int k"}
{"id": "2053", "path": "output2\\c\\Hard\\2053-delivering-boxes-from-storage-to-ports.c", "hypo_code": "int boxDelivering(int** boxes, int boxesSize, int* boxesColSize, int portsCount, int maxBoxes, int maxWeight){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*boxesSize);\n    for(i=0;i<boxesSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<boxesSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[boxesSize-1];\n\n}", "prefix": "int boxDelivering(int** boxes, int boxesSize, int* boxesColSize, int portsCount, int maxBoxes, int maxWeight"}
{"id": "2054", "path": "output2\\c\\Hard\\2054-maximum-height-by-stacking-cuboids.c", "hypo_code": "int maxHeight(int** cuboids, int cuboidsSize, int* cuboidsColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*cuboidsSize);\n    for(i=0;i<cuboidsSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<cuboidsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<cuboidsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int maxHeight(int** cuboids, int cuboidsSize, int* cuboidsColSize"}
{"id": "2055", "path": "output2\\c\\Hard\\2055-checking-existence-of-edge-length-limited-paths.c", "hypo_code": "bool* distanceLimitedPathsExist(int n, int** edgeList, int edgeListSize, int* edgeListColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<queriesSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<queriesSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return arr;\n\n}", "prefix": "bool* distanceLimitedPathsExist(int n, int** edgeList, int edgeListSize, int* edgeListColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "2056", "path": "output2\\c\\Hard\\2056-minimum-adjacent-swaps-for-k-consecutive-ones.c", "hypo_code": "int minMoves(int* nums, int numsSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    for(i=0;i<numsSize;i++){\n        if(nums[i] == 1){\n            arr[count] = i;\n            count++;\n        }\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<k;i++){\n        for(j=0;j<k;j++){\n            arr2[i] += abs(arr[i+j] - arr[i+k/2]);\n        }\n    }\n    int min = arr2[0];\n    for(i=0;i<k;i++){\n        if(arr2[i] < min){\n            min = arr2[i];\n        }\n    }\n    return min;\n\n}", "prefix": "int minMoves(int* nums, int numsSize, int k"}
{"id": "2057", "path": "output2\\c\\Hard\\2057-maximum-xor-with-an-element-from-array.c", "hypo_code": "int* maximizeXor(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<queriesSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<queriesSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return arr;\n\n}", "prefix": "int* maximizeXor(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "2058", "path": "output2\\c\\Hard\\2058-minimum-operations-to-make-a-subsequence.c", "hypo_code": "int minOperations(int* target, int targetSize, int* arr, int arrSize){\n    int i,j,k;\n    int* arr2 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<targetSize;i++){\n        for(j=0;j<arrSize;j++){\n            if(target[i] == arr[j]){\n                arr2[i] = j;\n                break;\n            }\n        }\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*targetSize);\n    for(i=0;i<targetSize;i++){\n        arr3[i] = 0;\n    }\n    int max = 0;\n    for(i=0;i<targetSize;i++){\n        if(arr2[i] > max){\n            max = arr2[i];\n        }\n    }\n    int min = max;\n    for(i=0;i<targetSize;i++){\n        if(arr2[i] < min){\n            min = arr2[i];\n        }\n    }\n    int dev = max - min;\n    for(i=0;i<targetSize;i++){\n        if(arr2[i] == min){\n            arr3[i] = 1;\n        }\n    }\n    int flag = 1;\n    while(flag){\n        flag = 0;\n        for(i=0;i<targetSize;i++){\n            if(arr3[i] == 1){\n                arr2[i] = arr2[i] + 1;\n                if(arr2[i] > max){\n                    max = arr2[i];\n                }\n                if(arr2[i] < min){\n                    min = arr2[i];\n                }\n                flag = 1;\n            }\n        }\n        dev = (dev < max - min) ? dev : max - min;\n        for(i=0;i<targetSize;i++){\n            if(arr2[i] == min){\n                arr3[i] = 1;\n            }\n        }\n    }\n    return dev;\n\n}", "prefix": "int minOperations(int* target, int targetSize, int* arr, int arrSize"}
{"id": "2059", "path": "output2\\c\\Hard\\2059-number-of-ways-to-reconstruct-a-tree.c", "hypo_code": "int checkWays(int** pairs, int pairsSize, int* pairsColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*pairsSize);\n    for(i=0;i<pairsSize;i++){\n        arr[i] = 0;\n    }\n    for(i=0;i<pairsSize;i++){\n        for(j=0;j<pairsSize;j++){\n            if(pairs[i][0] == pairs[j][1]){\n                arr[i] = 1;\n            }\n        }\n    }\n    int count = 0;\n    for(i=0;i<pairsSize;i++){\n        if(arr[i] == 0){\n            count++;\n        }\n    }\n    if(count == 1){\n        return 1;\n    }\n    else if(count == 0){\n        return 2;\n    }\n    else{\n        return 0;\n    }\n\n}", "prefix": "int checkWays(int** pairs, int pairsSize, int* pairsColSize"}
{"id": "2060", "path": "output2\\c\\Hard\\2060-find-minimum-time-to-finish-all-jobs.c", "hypo_code": "int minimumTimeRequired(int* jobs, int jobsSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*jobsSize);\n    for(i=0;i<jobsSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<jobsSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[jobsSize-1];\n\n}", "prefix": "int minimumTimeRequired(int* jobs, int jobsSize, int k"}
{"id": "2061", "path": "output2\\c\\Hard\\2061-cat-and-mouse-ii.c", "hypo_code": "bool canMouseWin(char ** grid, int gridSize, int catJump, int mouseJump){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr\n\n}", "prefix": "bool canMouseWin(char ** grid, int gridSize, int catJump, int mouseJump"}
{"id": "2062", "path": "output2\\c\\Hard\\2062-count-ways-to-make-array-with-product.c", "hypo_code": "int* waysToFillArray(int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<queriesSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<queriesSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return arr;\n\n}", "prefix": "int* waysToFillArray(int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "2063", "path": "output2\\c\\Hard\\2063-building-boxes.c", "hypo_code": "int minimumBoxes(int n){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<n;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] < arr[j] + 1) ? arr[i] : arr[j] + 1;\n        }\n    }\n    int max = 0;\n    for(i=0;i<n;i++){\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    return max;\n\n}", "prefix": "int minimumBoxes(int n"}
{"id": "2064", "path": "output2\\c\\Hard\\2064-palindrome-partitioning-iv.c", "hypo_code": "bool checkPartitioning(char * s){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*10);\n    for(i=0;i<10;i++){\n        arr\n\n}", "prefix": "bool checkPartitioning(char * s"}
{"id": "2065", "path": "output2\\c\\Hard\\2065-maximum-number-of-events-that-can-be-attended-ii.c", "hypo_code": "int maxValue(int** events, int eventsSize, int* eventsColSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*eventsSize);\n    for(i=0;i<eventsSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<eventsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<eventsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return arr;\n\n\n}", "prefix": "int maxValue(int** events, int eventsSize, int* eventsColSize, int k"}
{"id": "2066", "path": "output2\\c\\Hard\\2066-closest-subsequence-sum.c", "hypo_code": "int minAbsDifference(int* nums, int numsSize, int goal){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    for(i=0;i<numsSize;i++){\n        if(nums[i] == 1){\n            arr[count] = i;\n            count++;\n        }\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<numsSize;i++){\n        for(j=0;j<numsSize;j++){\n            arr2[i] += abs(arr[i+j] - arr[i+numsSize/2]);\n        }\n    }\n    int min = arr2[0];\n    for(i=0;i<numsSize;i++){\n        if(arr2[i] < min){\n            min = arr2[i];\n        }\n    }\n    return min;\n\n}", "prefix": "int minAbsDifference(int* nums, int numsSize, int goal"}
{"id": "2067", "path": "output2\\c\\Hard\\2067-minimum-degree-of-a-connected-trio-in-a-graph.c", "hypo_code": "int minTrioDegree(int n, int** edges, int edgesSize, int* edgesColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr3[i] = 0;\n    }\n    for(i=0;i<edgesSize;i++){\n        arr[edges[i][0]-1]++;\n        arr[edges[i][1]-1]++;\n        arr2[edges[i][0]-1]++;\n        arr3[edges[i][1]-1]++;\n    }\n    int min = 100000;\n    for(i=0;i<edgesSize;i++){\n        if(arr[edges[i][0]-1] >= 2 && arr[edges[i][1]-1] >= 2){\n            if(arr2[edges[i][0]-1] + arr3[edges[i][1]-1] - 2 < min){\n                min = arr2[edges[i][0]-1] + arr3[edges[i][1]-1] - 2;\n            }\n        }\n    }\n    if(min == 100000){\n        return -1;\n    }\n    return min;\n\n}", "prefix": "int minTrioDegree(int n, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2068", "path": "output2\\c\\Hard\\2068-tree-of-coprimes.c", "hypo_code": "int* getCoprimes(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<numsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<numsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return arr;\n\n}", "prefix": "int* getCoprimes(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize, int* returnSize"}
{"id": "2069", "path": "output2\\c\\Hard\\2069-maximum-score-from-performing-multiplication-operations.c", "hypo_code": "int maximumScore(int* nums, int numsSize, int* multipliers, int multipliersSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = nums[i];\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*multipliersSize);\n    for(i=0;i<multipliersSize;i++){\n        arr2[i] = multipliers[i];\n    }\n    int max = 0;\n    for(i=0;i<multipliersSize;i++){\n        if(arr2[i] > max){\n            max = arr2[i];\n        }\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr3[i] = 0;\n    }\n    for(i=0;i<multipliersSize;i++){\n        for(j=0;j<numsSize;j++){\n            if(arr2[i] == arr[j]){\n                arr3[j] = 1;\n            }\n        }\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr4[i] = 0;\n    }\n    for(i=0;i<numsSize;i++){\n        if(arr3[i] == 1){\n            arr4[i] = arr[i];\n        }\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr5[i] = 0;\n    }\n    int count = 0;\n    for(i=0;i<numsSize;i++){\n        if(arr4[i] != 0){\n            arr5[count] = arr4[i];\n            count++;\n        }\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr6[i] = 0;\n    }\n    for(i=0;i<numsSize;i++){\n        if(arr5[i] != 0){\n            arr6[i] = arr5[i] * arr2[i];\n        }\n    }\n    int sum = 0;\n    for(i=0;i<numsSize;i++){\n        sum += arr6[i];\n    }\n    return sum;\n\n\n}", "prefix": "int maximumScore(int* nums, int numsSize, int* multipliers, int multipliersSize"}
{"id": "2070", "path": "output2\\c\\Hard\\2070-maximize-palindrome-length-from-subsequences.c", "hypo_code": "int longestPalindrome(char * word1, char * word2){\n    int i,j,k;\n    int len1 = strlen(word1);\n    int len2 = strlen(word2);\n    int len = len1 + len2;\n    char* word = (char*)malloc(sizeof(char)*(len+1));\n    for(i=0;i<len1;i++){\n        word[i] = word1[i];\n    }\n    for(i=0;i<len2;i++){\n        word[i+len1] = word2[i];\n    }\n    word[len] = '\\0';\n    int* arr = (int*)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr[i] = 0;\n    }\n    for(i=0;i<len;i++){\n        for(j=0;j<len;j++){\n            if(word[i] == word[j]){\n                arr[i] = arr[i] + 1;\n            }\n        }\n    }\n    int max = 0;\n    for(i=0;i<len;i++){\n        if(arr[i] > max){\n            max = arr[i];\n        }\n    }\n    int sum = 0;\n    for(i=0;i<len;i++){\n        if(arr[i] == max){\n            sum = sum + 1;\n        }\n    }\n    return sum;\n\n}", "prefix": "int longestPalindrome(char * word1, char * word2"}
{"id": "2071", "path": "output2\\c\\Hard\\2071-car-fleet-ii.c", "hypo_code": "double* getCollisionTimes(int** cars, int carsSize, int* carsColSize, int* returnSize){\n    int i,j,k;\n    double* arr = (double*)malloc(sizeof(double)*carsSize);\n    for(i=0;i<carsSize;i++){\n        arr[i] = 0;\n    }\n    for(i=1;i<carsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    double sum = 0;\n    for(i=0;i<carsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return arr;\n\n}", "prefix": "double* getCollisionTimes(int** cars, int carsSize, int* carsColSize, int* returnSize"}
{"id": "2072", "path": "output2\\c\\Hard\\2072-count-pairs-of-nodes.c", "hypo_code": "int* countPairs(int n, int** edges, int edgesSize, int* edgesColSize, int* queries, int queriesSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr14[i] = 0;\n    }\n    int* arr15\n\n}", "prefix": "int* countPairs(int n, int** edges, int edgesSize, int* edgesColSize, int* queries, int queriesSize, int* returnSize"}
{"id": "2073", "path": "output2\\c\\Hard\\2073-make-the-xor-of-all-segments-equal-to-zero.c", "hypo_code": "int minChanges(int* nums, int numsSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr14[i] = 0;\n    }\n    int* arr15\n\n}", "prefix": "int minChanges(int* nums, int numsSize, int k"}
{"id": "2074", "path": "output2\\c\\Hard\\2074-maximum-score-of-a-good-subarray.c", "hypo_code": "int maximumScore(int* nums, int numsSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int maximumScore(int* nums, int numsSize, int k"}
{"id": "2075", "path": "output2\\c\\Hard\\2075-maximize-score-after-n-operations.c", "hypo_code": "int maxScore(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int maxScore(int* nums, int numsSize"}
{"id": "2076", "path": "output2\\c\\Hard\\2076-count-pairs-with-xor-in-a-range.c", "hypo_code": "int countPairs(int* nums, int numsSize, int low, int high){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int countPairs(int* nums, int numsSize, int low, int high"}
{"id": "2077", "path": "output2\\c\\Hard\\2077-maximize-number-of-nice-divisors.c", "hypo_code": "int maxNiceDivisors(int primeFactors){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*primeFactors);\n    for(i=0;i<primeFactors;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<primeFactors;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] + arr[j]*arr[i-j-1]) % 1000000007;\n        }\n    }\n    return arr[primeFactors-1];\n\n}", "prefix": "int maxNiceDivisors(int primeFactors"}
{"id": "2078", "path": "output2\\c\\Hard\\2078-maximum-number-of-groups-getting-fresh-donuts.c", "hypo_code": "int maxHappyGroups(int batchSize, int* groups, int groupsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*groupsSize);\n    for(i=0;i<groupsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int maxHappyGroups(int batchSize, int* groups, int groupsSize"}
{"id": "2079", "path": "output2\\c\\Hard\\2079-number-of-different-subsequences-gcds.c", "hypo_code": "int countDifferentSubsequenceGCDs(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int countDifferentSubsequenceGCDs(int* nums, int numsSize"}
{"id": "2081", "path": "output2\\c\\Hard\\2081-minimum-number-of-operations-to-make-string-sorted.c", "hypo_code": "int makeStringSorted(char * s){\n    int i,j,k;\n    int len = strlen(s);\n    int* arr = (int*)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr[i] = 0;\n    }\n    for(i=0;i<len;i++){\n        int num = 0;\n        for(j=i;j<len;j++){\n            num = num*10 + (s[j]-'0');\n            if(num<=100000){\n                if(i==0){\n                    arr[j] = 1;\n                }\n                else{\n                    arr[j] = (arr[j] + arr2[i-1]) % 1000000007;\n                }\n            }\n            else{\n                break;\n            }\n        }\n        for(j=0;j<len;j++){\n            arr2[j] = arr[j];\n        }\n    }\n    return arr[len-1];\n\n}", "prefix": "int makeStringSorted(char * s"}
{"id": "2082", "path": "output2\\c\\Hard\\2082-find-xor-sum-of-all-pairs-bitwise-and.c", "hypo_code": "int getXORSum(int* arr1, int arr1Size, int* arr2, int arr2Size){\n    int i,j,k;\n    int ans = 0;\n    for(i=0;i<arr1Size;i++){\n        for(j=0;j<arr2Size;j++){\n            ans = ans ^ (arr1[i] & arr2[j]);\n        }\n    }\n    return ans;\n\n}", "prefix": "int getXORSum(int* arr1, int arr1Size, int* arr2, int arr2Size"}
{"id": "2083", "path": "output2\\c\\Hard\\2083-maximum-building-height.c", "hypo_code": "int maxBuilding(int n, int** restrictions, int restrictionsSize, int* restrictionsColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr14[i] = 0;\n    }\n    int* arr15\n\n}", "prefix": "int maxBuilding(int n, int** restrictions, int restrictionsSize, int* restrictionsColSize"}
{"id": "2084", "path": "output2\\c\\Hard\\2084-closest-room.c", "hypo_code": "int* closestRoom(int** rooms, int roomsSize, int* roomsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*roomsSize);\n    for(i=0;i<roomsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int* closestRoom(int** rooms, int roomsSize, int* roomsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "2085", "path": "output2\\c\\Hard\\2085-minimum-interval-to-include-each-query.c", "hypo_code": "int* minInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* queries, int queriesSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i\n\n}", "prefix": "int* minInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* queries, int queriesSize, int* returnSize"}
{"id": "2086", "path": "output2\\c\\Hard\\2086-largest-color-value-in-a-directed-graph.c", "hypo_code": "int largestPathValue(char * colors, int** edges, int edgesSize, int* edgesColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int largestPathValue(char * colors, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2087", "path": "output2\\c\\Hard\\2087-sum-of-floored-pairs.c", "hypo_code": "int sumOfFlooredPairs(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int sumOfFlooredPairs(int* nums, int numsSize"}
{"id": "2088", "path": "output2\\c\\Hard\\2088-number-of-ways-to-rearrange-sticks-with-k-sticks-visible.c", "hypo_code": "int rearrangeSticks(int n, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<n;i++){\n        for(j=k-1;j>0;j--){\n            arr[j] = (arr[j] + arr[j-1])%1000000007;\n        }\n        arr[0] = 0;\n    }\n    return arr[k-1];\n\n}", "prefix": "int rearrangeSticks(int n, int k"}
{"id": "2089", "path": "output2\\c\\Hard\\2089-stone-game-viii.c", "hypo_code": "int stoneGameVIII(int* stones, int stonesSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*stonesSize);\n    for(i=0;i<stonesSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int stoneGameVIII(int* stones, int stonesSize"}
{"id": "2090", "path": "output2\\c\\Hard\\2090-minimum-xor-sum-of-two-arrays.c", "hypo_code": "int minimumXORSum(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<nums1Size;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[nums1Size-1];\n\n}", "prefix": "int minimumXORSum(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "2091", "path": "output2\\c\\Hard\\2091-minimum-skips-to-arrive-at-meeting-on-time.c", "hypo_code": "int minSkips(int* dist, int distSize, int speed, int hoursBefore){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*distSize);\n    for(i=0;i<distSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<distSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[distSize-1];\n\n}", "prefix": "int minSkips(int* dist, int distSize, int speed, int hoursBefore"}
{"id": "2092", "path": "output2\\c\\Hard\\2092-minimum-space-wasted-from-packaging.c", "hypo_code": "int minWastedSpace(int* packages, int packagesSize, int** boxes, int boxesSize, int* boxesColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*boxesSize);\n    for(i=0;i<boxesSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<boxesSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[boxesSize-1];\n\n}", "prefix": "int minWastedSpace(int* packages, int packagesSize, int** boxes, int boxesSize, int* boxesColSize"}
{"id": "2093", "path": "output2\\c\\Hard\\2093-minimum-cost-to-change-the-final-value-of-expression.c", "hypo_code": "int minOperationsToFlip(char * expression){\n    int i,j,k;\n    int len = strlen(expression);\n    int* arr = (int*)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr[i] = 0;\n    }\n    for(i=0;i<len;i++){\n        int num = 0;\n        for(j=i;j<len;j++){\n            num = num*10 + (expression[j]-'0');\n            if(num<=100000){\n                if(i==0){\n                    arr[j] = 1;\n                }\n                else{\n                    arr[j] = (arr[j] + arr2[i-1]) % 1000000007;\n                }\n            }\n            else{\n                break;\n            }\n        }\n        for(j=0;j<len;j++){\n            arr2[j] = arr[j];\n        }\n    }\n    return arr[len-1];\n\n}", "prefix": "int minOperationsToFlip(char * expression"}
{"id": "2094", "path": "output2\\c\\Hard\\2094-the-earliest-and-latest-rounds-where-players-compete.c", "hypo_code": "int* earliestAndLatest(int n, int firstPlayer, int secondPlayer, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr14[i] = 0;\n    }\n    int* arr15\n\n}", "prefix": "int* earliestAndLatest(int n, int firstPlayer, int secondPlayer, int* returnSize"}
{"id": "2096", "path": "output2\\c\\Hard\\2096-count-ways-to-build-rooms-in-an-ant-colony.c", "hypo_code": "int waysToBuildRooms(int* prevRoom, int prevRoomSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*prevRoomSize);\n    for(i=0;i<prevRoomSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<prevRoomSize;i++){\n        int num = 0;\n        for(j=prevRoom[i];j<i;j++){\n            num = num*10 + (prevRoom[j]-'0');\n            if(num<=100000){\n                if(i==0){\n                    arr[j] = 1;\n                }\n                else{\n                    arr[j] = (arr[j] + arr2[i-1]) % 1000000007;\n                }\n            }\n            else{\n                break;\n            }\n        }\n        for(j=0;j<prevRoomSize;j++){\n            arr2[j] = arr[j];\n        }\n    }\n    return arr[prevRoomSize-1];\n\n}", "prefix": "int waysToBuildRooms(int* prevRoom, int prevRoomSize"}
{"id": "2097", "path": "output2\\c\\Hard\\2097-longest-common-subpath.c", "hypo_code": "int longestCommonSubpath(int n, int** paths, int pathsSize, int* pathsColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int longestCommonSubpath(int n, int** paths, int pathsSize, int* pathsColSize"}
{"id": "2098", "path": "output2\\c\\Hard\\2098-minimum-cost-to-reach-destination-in-time.c", "hypo_code": "int minCost(int maxTime, int** edges, int edgesSize, int* edgesColSize, int* passingFees, int passingFeesSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*edgesSize);\n    for(i=0;i<edgesSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int minCost(int maxTime, int** edges, int edgesSize, int* edgesColSize, int* passingFees, int passingFeesSize"}
{"id": "2099", "path": "output2\\c\\Hard\\2099-painting-a-grid-with-three-different-colors.c", "hypo_code": "int colorTheGrid(int m, int n){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 3;\n    for(i=1;i<m;i++){\n        for(j=n-1;j>0;j--){\n            arr[j] = (arr[j] + arr[j-1])%1000000007;\n        }\n        arr[0] = 0;\n    }\n    return arr[n-1];\n\n}", "prefix": "int colorTheGrid(int m, int n"}
{"id": "2100", "path": "output2\\c\\Hard\\2100-merge-bsts-to-create-single-bst.c", "hypo_code": "struct TreeNode* canMerge(struct TreeNode** trees, int treesSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*treesSize);\n    for(i=0;i<treesSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<treesSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[treesSize-1];\n\n\n}", "prefix": "struct TreeNode* canMerge(struct TreeNode** trees, int treesSize"}
{"id": "2101", "path": "output2\\c\\Hard\\2101-maximum-genetic-difference-query.c", "hypo_code": "int* maxGeneticDifference(int* parents, int parentsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int* maxGeneticDifference(int* parents, int parentsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "2102", "path": "output2\\c\\Hard\\2102-number-of-visible-people-in-a-queue.c", "hypo_code": "int* canSeePersonsCount(int* heights, int heightsSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*heightsSize);\n    for(i=0;i<heightsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*heights\n\n}", "prefix": "int* canSeePersonsCount(int* heights, int heightsSize, int* returnSize"}
{"id": "2103", "path": "output2\\c\\Hard\\2103-delete-duplicate-folders-in-system.c", "hypo_code": "char *** deleteDuplicateFolder(char *** paths, int pathsSize, int* pathsColSize, int* returnSize, int** returnColumnSizes){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*pathsSize);\n    for(i=0;i<pathsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "char *** deleteDuplicateFolder(char *** paths, int pathsSize, int* pathsColSize, int* returnSize, int** returnColumnSizes"}
{"id": "2104", "path": "output2\\c\\Hard\\2104-count-number-of-special-subsequences.c", "hypo_code": "int countSpecialSubsequences(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*3);\n    for(i=0;i<3;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<numsSize;i++){\n        arr[nums[i]] = (arr[nums[i]] + arr[nums[i]-1])%1000000007;\n    }\n    return arr[2];\n\n}", "prefix": "int countSpecialSubsequences(int* nums, int numsSize"}
{"id": "2105", "path": "output2\\c\\Hard\\2105-maximum-product-of-the-length-of-two-palindromic-substrings.c", "hypo_code": "long long maxProduct(char * s){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*strlen(s));\n    for(i=0;i<strlen(s);i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<strlen(s);i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[strlen(s)-1];\n\n}", "prefix": "long long maxProduct(char * s"}
{"id": "2106", "path": "output2\\c\\Hard\\2106-find-the-longest-valid-obstacle-course-at-each-position.c", "hypo_code": "int* longestObstacleCourseAtEachPosition(int* obstacles, int obstaclesSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*obstaclesSize);\n    for(i=0;i<obstaclesSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*obstacles\n\n}", "prefix": "int* longestObstacleCourseAtEachPosition(int* obstacles, int obstaclesSize, int* returnSize"}
{"id": "2107", "path": "output2\\c\\Hard\\2107-last-day-where-you-can-still-cross.c", "hypo_code": "int latestDayToCross(int row, int col, int** cells, int cellsSize, int* cellsColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*col);\n    for(i=0;i<col;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<row;i++){\n        for(j=0;j<col;j++){\n            arr[j] = 0;\n            if(j>0){\n                arr[j] = (arr[j] + arr[j-1])%1000000007;\n            }\n            if(j<col-1){\n                arr[j] = (arr[j] + arr[j+1])%1000000007;\n            }\n        }\n    }\n    return arr[col-1];\n\n}", "prefix": "int latestDayToCross(int row, int col, int** cells, int cellsSize, int* cellsColSize"}
{"id": "2108", "path": "output2\\c\\Hard\\2108-number-of-ways-to-separate-numbers.c", "hypo_code": "int numberOfCombinations(char * num){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(num);i++){\n        for(j=0;j<2;j++){\n            if(num[i] == '0'){\n                arr[j] = 0;\n            }\n            else{\n                arr[j] = (arr[j] + arr[j-1])%1000000007;\n            }\n        }\n    }\n    return arr[1];\n\n}", "prefix": "int numberOfCombinations(char * num"}
{"id": "2109", "path": "output2\\c\\Hard\\2109-find-array-given-subset-sums.c", "hypo_code": "int* recoverArray(int n, int* sums, int sumsSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*sumsSize);\n    for(i=0;i<sumsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*sums\n\n}", "prefix": "int* recoverArray(int n, int* sums, int sumsSize, int* returnSize"}
{"id": "2110", "path": "output2\\c\\Hard\\2110-number-of-unique-good-subsequences.c", "hypo_code": "int numberOfUniqueGoodSubsequences(char * binary){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(binary);i++){\n        if(binary[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "int numberOfUniqueGoodSubsequences(char * binary"}
{"id": "2111", "path": "output2\\c\\Hard\\2111-the-number-of-good-subsets.c", "hypo_code": "int numberOfGoodSubsets(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<numsSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[numsSize-1];\n\n}", "prefix": "int numberOfGoodSubsets(int* nums, int numsSize"}
{"id": "2112", "path": "output2\\c\\Hard\\2112-gcd-sort-of-an-array.c", "hypo_code": "bool gcdSort(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<numsSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[numsSize-1];\n\n}", "prefix": "bool gcdSort(int* nums, int numsSize"}
{"id": "2113", "path": "output2\\c\\Hard\\2113-smallest-missing-genetic-value-in-each-subtree.c", "hypo_code": "int* smallestMissingValueSubtree(int* parents, int parentsSize, int* nums, int numsSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*parentsSize);\n    for(i=0;i<parentsSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int* smallestMissingValueSubtree(int* parents, int parentsSize, int* nums, int numsSize, int* returnSize"}
{"id": "2114", "path": "output2\\c\\Hard\\2114-minimum-number-of-operations-to-make-array-continuous.c", "hypo_code": "int minOperations(int* nums, int numsSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "int minOperations(int* nums, int numsSize"}
{"id": "2115", "path": "output2\\c\\Hard\\2115-longest-subsequence-repeated-k-times.c", "hypo_code": "char * longestSubsequenceRepeatedK(char * s, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "char * longestSubsequenceRepeatedK(char * s, int k"}
{"id": "2116", "path": "output2\\c\\Hard\\2116-the-score-of-students-solving-math-expression.c", "hypo_code": "int scoreOfStudents(char * s, int* answers, int answersSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "int scoreOfStudents(char * s, int* answers, int answersSize"}
{"id": "2117", "path": "output2\\c\\Hard\\2117-maximum-number-of-ways-to-partition-an-array.c", "hypo_code": "int waysToPartition(int* nums, int numsSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<numsSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[numsSize-1];\n\n}", "prefix": "int waysToPartition(int* nums, int numsSize, int k"}
{"id": "2118", "path": "output2\\c\\Hard\\2118-smallest-k-length-subsequence-with-occurrences-of-a-letter.c", "hypo_code": "char * smallestSubsequence(char * s, int k, char letter, int repetition){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "char * smallestSubsequence(char * s, int k, char letter, int repetition"}
{"id": "2119", "path": "output2\\c\\Hard\\2119-partition-array-into-two-arrays-to-minimize-sum-difference.c", "hypo_code": "int minimumDifference(int* nums, int numsSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<numsSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[numsSize-1];\n\n}", "prefix": "int minimumDifference(int* nums, int numsSize"}
{"id": "2120", "path": "output2\\c\\Hard\\2120-kth-smallest-product-of-two-sorted-arrays.c", "hypo_code": "long long kthSmallestProduct(int* nums1, int nums1Size, int* nums2, int nums2Size, long long k){\n    long long i,j,k;\n    long long* arr = (long long*)malloc(sizeof(long long)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<nums1Size;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[nums1Size-1];\n\n\n}", "prefix": "long long kthSmallestProduct(int* nums1, int nums1Size, int* nums2, int nums2Size, long long k"}
{"id": "2121", "path": "output2\\c\\Hard\\2121-second-minimum-time-to-reach-destination.c", "hypo_code": "int secondMinimum(int n, int** edges, int edgesSize, int* edgesColSize, int time, int change){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<n;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[n-1];\n\n}", "prefix": "int secondMinimum(int n, int** edges, int edgesSize, int* edgesColSize, int time, int change"}
{"id": "2122", "path": "output2\\c\\Hard\\2122-parallel-courses-iii.c", "hypo_code": "int minimumTime(int n, int** relations, int relationsSize, int* relationsColSize, int* time, int timeSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<n;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[n-1];\n\n\n}", "prefix": "int minimumTime(int n, int** relations, int relationsSize, int* relationsColSize, int* time, int timeSize"}
{"id": "2123", "path": "output2\\c\\Hard\\2123-number-of-valid-move-combinations-on-chessboard.c", "hypo_code": "int countCombinations(char ** pieces, int piecesSize, int** positions, int positionsSize, int* positionsColSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n\n}", "prefix": "int countCombinations(char ** pieces, int piecesSize, int** positions, int positionsSize, int* positionsColSize"}
{"id": "2124", "path": "output2\\c\\Hard\\2124-check-if-an-original-string-exists-given-two-encoded-strings.c", "hypo_code": "bool possiblyEquals(char * s1, char * s2){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "bool possiblyEquals(char * s1, char * s2"}
{"id": "2125", "path": "output2\\c\\Hard\\2125-maximum-path-quality-of-a-graph.c", "hypo_code": "int maximalPathQuality(int* values, int valuesSize, int** edges, int edgesSize, int* edgesColSize, int maxTime){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int maximalPathQuality(int* values, int valuesSize, int** edges, int edgesSize, int* edgesColSize, int maxTime"}
{"id": "2126", "path": "output2\\c\\Hard\\2126-maximum-number-of-tasks-you-can-assign.c", "hypo_code": "int maxTaskAssign(int* tasks, int tasksSize, int* workers, int workersSize, int pills, int strength){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int maxTaskAssign(int* tasks, int tasksSize, int* workers, int workersSize, int pills, int strength"}
{"id": "2127", "path": "output2\\c\\Hard\\2127-process-restricted-friend-requests.c", "hypo_code": "bool* friendRequests(int n, int** restrictions, int restrictionsSize, int* restrictionsColSize, int** requests, int requestsSize, int* requestsColSize, int* returnSize){\n    int i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g\n\n}", "prefix": "bool* friendRequests(int n, int** restrictions, int restrictionsSize, int* restrictionsColSize, int** requests, int requestsSize, int* requestsColSize, int* returnSize"}
{"id": "2128", "path": "output2\\c\\Hard\\2128-sum-of-k-mirror-numbers.c", "hypo_code": "long long kMirror(int k, int n){\n    long long i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v,\n\n}", "prefix": "long long kMirror(int k, int n"}
{"id": "2129", "path": "output2\\c\\Hard\\2129-count-fertile-pyramids-in-a-land.c", "hypo_code": "int countPyramids(int** grid, int gridSize, int* gridColSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int countPyramids(int** grid, int gridSize, int* gridColSize"}
{"id": "2130", "path": "output2\\c\\Hard\\2130-find-all-people-with-secret.c", "hypo_code": "int* findAllPeople(int n, int** meetings, int meetingsSize, int* meetingsColSize, int firstPerson, int* returnSize){\n    int i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g\n\n}", "prefix": "int* findAllPeople(int n, int** meetings, int meetingsSize, int* meetingsColSize, int firstPerson, int* returnSize"}
{"id": "2131", "path": "output2\\c\\Hard\\2131-valid-arrangement-of-pairs.c", "hypo_code": "int** validArrangement(int** pairs, int pairsSize, int* pairsColSize, int* returnSize, int** returnColumnSizes){\n    int i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g\n\n}", "prefix": "int** validArrangement(int** pairs, int pairsSize, int* pairsColSize, int* returnSize, int** returnColumnSizes"}
{"id": "2133", "path": "output2\\c\\Hard\\2133-maximum-fruits-harvested-after-at-most-k-steps.c", "hypo_code": "int maxTotalFruits(int** fruits, int fruitsSize, int* fruitsColSize, int startPos, int k){\n    int i, j, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h\n\n}", "prefix": "int maxTotalFruits(int** fruits, int fruitsSize, int* fruitsColSize, int startPos, int k"}
{"id": "2134", "path": "output2\\c\\Hard\\2134-minimum-operations-to-make-the-array-k-increasing.c", "hypo_code": "int kIncreasing(int* arr, int arrSize, int k){\nint kIncreasing(int* arr, int arrSize, int k){\n    int i, j, min, max, count = 0;\n    for (i = 0; i < arrSize; i++) {\n        min = arr[i]; max = arr[i];\n        for (j = i + 1; j < arrSize; j++) {\n            if (arr[j] < min) min = arr[j];\n            else if (arr[j] > max) max = arr[j];\n            if (max - min == j - i) break;\n        }\n        if (j == arrSize) count++;\n    }\n    return count;\n}\nint minOperations(int* nums, int numsSize){\n    int i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "int kIncreasing(int* arr, int arrSize, int k"}
{"id": "2135", "path": "output2\\c\\Hard\\2135-abbreviating-the-product-of-a-range.c", "hypo_code": "char * abbreviateProduct(int left, int right){\nint i, j, k, count, digits, length, len, len1, len2;\n    char *result;\n    for (i = left, count = 0; i <= right; i++) {\n        for (j = i; j % 5 == 0; j /= 5) count++;\n        for (j = i; j % 2 == 0; j /= 2) count++;\n    }\n    for (i = left, digits = 0; i <= right; i++) {\n        for (j = i; j > 0; j /= 10) digits++;\n    }\n    length = 5 + digits - count;\n    result = (char *)malloc((length + 1) * sizeof(char));\n    result[length] = '\\0';\n    for (i = left, len = 0; i <= right; i++) {\n        for (j = i; j % 5 == 0; j /= 5) count++;\n        for (j = i; j % 2 == 0; j /= 2) count++;\n        for (j = i, len1 = 0; j > 0; j /= 10) len1++;\n        for (j = i, len2 = 0; j > 0; j /= 10) len2++;\n        for (j = i, k = len2 - 1; j > 0; j /= 10) result[len + k--] = j % 10 + '0';\n        len += len1;\n    }\n    for (i = length - 1; i >= 0; i--) {\n        if (result[i] != '0') break;\n        result[i] = '\\0';\n    }\n    if (i >= 0 && result[i] == '.') result[i] = '\\0';\n    len = strlen(result);\n    if (len > 10) {\n        result[5] = '.';\n        result[6] = '.';\n        result[7] = '.';\n        result[8] = '.';\n        result[9] = '.';\n        len = 10;\n    }\n    for (i = len - 1; i >= 0; i--) {\n        if (result[i] != '0') break;\n        result[i] = '\\0';\n    }\n    if (i >= 0 && result[i] == '.') result[i] = '\\0';\n    len = strlen(result);\n    result[len++] = 'e';\n    result[len++] = count / 10 + '0';\n    result[len++] = count % 10 + '0';\n    result[len] = '\\0';\n    return result;\n}", "prefix": "char * abbreviateProduct(int left, int right"}
{"id": "2136", "path": "output2\\c\\Hard\\2136-recover-the-original-array.c", "hypo_code": "int* recoverArray(int* nums, int numsSize, int* returnSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "int* recoverArray(int* nums, int numsSize, int* returnSize"}
{"id": "2137", "path": "output2\\c\\Hard\\2137-maximum-employees-to-be-invited-to-a-meeting.c", "hypo_code": "int maximumInvitations(int* favorite, int favoriteSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int maximumInvitations(int* favorite, int favoriteSize"}
{"id": "2138", "path": "output2\\c\\Hard\\2138-stamping-the-grid.c", "hypo_code": "bool possibleToStamp(int** grid, int gridSize, int* gridColSize, int stampHeight, int stampWidth){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "bool possibleToStamp(int** grid, int gridSize, int* gridColSize, int stampHeight, int stampWidth"}
{"id": "2139", "path": "output2\\c\\Hard\\2139-earliest-possible-day-of-full-bloom.c", "hypo_code": "int earliestFullBloom(int* plantTime, int plantTimeSize, int* growTime, int growTimeSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int earliestFullBloom(int* plantTime, int plantTimeSize, int* growTime, int growTimeSize"}
{"id": "2140", "path": "output2\\c\\Hard\\2140-maximum-running-time-of-n-computers.c", "hypo_code": "long long maxRunTime(int n, int* batteries, int batteriesSize){\n    long long i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v,\n\n}", "prefix": "long long maxRunTime(int n, int* batteries, int batteriesSize"}
{"id": "2141", "path": "output2\\c\\Hard\\2141-number-of-ways-to-divide-a-long-corridor.c", "hypo_code": "int numberOfWays(char * corridor){\nint i, j, k, count, digits, length, len, len1, len2;\n    char *result;\n    for (i = left, count = 0; i <= right; i++) {\n        for (j = i; j % 5 == 0; j /= 5) count++;\n        for (j = i; j % 2 == 0; j /= 2) count++;\n    }\n    for (i = left, digits = 0; i <= right; i++) {\n        for (j = i; j > 0; j /= 10) digits++;\n    }\n    length = 5 + digits - count;\n    result = (char *)malloc((length + 1) * sizeof(char));\n    result[length] = '\\0';\n    for (i = left, len = 0; i <= right; i++) {\n        for (j = i; j % 5 == 0; j /= 5) count++;\n        for (j = i; j % 2 == 0; j /= 2) count++;\n        for (j = i, len1 = 0; j > 0; j /= 10) len1++;\n        for (j = i, len2 = 0; j > 0; j /= 10) len2++;\n        for (j = i, k = len2 - 1; j > 0; j /= 10) result[len + k--] = j % 10 + '0';\n        for (j = i, k = len2 - 1; j > 0; j /= 10) result[len + k--] = j % 10 + '0';\n        for (j = i, k = len1 - 1; j > 0; j /= 10) result[len + k--] = j % 10 + '0';\n        for (j = i, k = len1 - 1; j > 0; j /= 10) result[len + k--] = j % 10 + '0';\n        len += len1;\n        len += len2;\n    }\n    return result;\n}", "prefix": "int numberOfWays(char * corridor"}
{"id": "2142", "path": "output2\\c\\Hard\\2142-maximum-good-people-based-on-statements.c", "hypo_code": "int maximumGood(int** statements, int statementsSize, int* statementsColSize){\nint i, j, k, count, digits, length, len, len1, len2;\n    char *result;\n    for (i = left, count = 0; i <= right; i++) {\n        for (j = i; j % 5 == 0; j /= 5) count++;\n        for (j = i; j % 2 == 0; j /= 2) count++;\n    }\n    for (i = left, digits = 0; i <= right; i++) {\n        for (j = i; j > 0; j /= 10) digits++;\n    }\n    length = 5 + digits - count;\n    result = (char *)malloc((length + 1) * sizeof(char));\n    result[length] = '\\0';\n    for (i = left, len = 0; i <= right; i++) {\n        for (j = i; j % 5 == 0; j /= 5) count++;\n        for (j = i; j % 2 == 0; j /= 2) count++;\n        for (j = i, len1 = 0; j > 0; j /= 10) len1++;\n        for (j = i, len2 = 0; j > 0; j /= 10) len2++;\n        for (j = i, k = len2 - 1; j > 0; j /= 10) result[len + k--] = j % 10 + '0';\n        for (j = i, k = len2 - 1; j > 0; j /= 10) result[len + k--] = j % 10 + '0';\n        for (j = i, k = len1 - 1; j > 0; j /= 10) result[len + k--] = j % 10 + '0';\n        for (j = i, k = len1 - 1; j > 0; j /= 10) result[len + k--] = j % 10 + '0';\n        len += len1;\n        len += len2;\n    }\n    return result;\n}", "prefix": "int maximumGood(int** statements, int statementsSize, int* statementsColSize"}
{"id": "2143", "path": "output2\\c\\Hard\\2143-find-substring-with-given-hash-value.c", "hypo_code": "char * subStrHash(char * s, int power, int modulo, int k, int hashValue){\nint i, j, min, max, count = 0;\n    for (i = 0; i < sSize; i++) {\n        min = s[i]; max = s[i];\n        for (j = i + 1; j < sSize; j++) {\n            if (s[j] < min) min = s[j];\n            else if (s[j] > max) max = s[j];\n            if (max - min == j - i) break;\n        }\n        if (j == sSize) count++;\n    }\n    return count;\n}", "prefix": "char * subStrHash(char * s, int power, int modulo, int k, int hashValue"}
{"id": "2144", "path": "output2\\c\\Hard\\2144-groups-of-strings.c", "hypo_code": "int* groupStrings(char ** words, int wordsSize, int* returnSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < wordsSize; i++) {\n        min = words[i]; max = words[i];\n        for (j = i + 1; j < wordsSize; j++) {\n            if (words[j] < min) min = words[j];\n            else if (words[j] > max) max = words[j];\n            if (max - min == j - i) break;\n        }\n        if (j == wordsSize) count++;\n    }\n    return count;\n}", "prefix": "int* groupStrings(char ** words, int wordsSize, int* returnSize"}
{"id": "2145", "path": "output2\\c\\Hard\\2145-minimum-difference-in-sums-after-removal-of-elements.c", "hypo_code": "long long minimumDifference(int* nums, int numsSize){\n    long long i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v,\n\n}", "prefix": "long long minimumDifference(int* nums, int numsSize"}
{"id": "2146", "path": "output2\\c\\Hard\\2146-minimum-time-to-remove-all-cars-containing-illegal-goods.c", "hypo_code": "int minimumTime(char * s){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int minimumTime(char * s"}
{"id": "2147", "path": "output2\\c\\Hard\\2147-maximum-and-sum-of-array.c", "hypo_code": "int maximumANDSum(int* nums, int numsSize, int numSlots){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int maximumANDSum(int* nums, int numsSize, int numSlots"}
{"id": "2148", "path": "output2\\c\\Hard\\2148-count-good-triplets-in-an-array.c", "hypo_code": "long long goodTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "long long goodTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "2149", "path": "output2\\c\\Hard\\2149-count-array-pairs-divisible-by-k.c", "hypo_code": "long long countPairs(int* nums, int numsSize, int k){\n    int i, j, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x\n\n}", "prefix": "long long countPairs(int* nums, int numsSize, int k"}
{"id": "2150", "path": "output2\\c\\Hard\\2150-minimum-time-to-finish-the-race.c", "hypo_code": "int minimumFinishTime(int** tires, int tiresSize, int* tiresColSize, int changeTime, int numLaps){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int minimumFinishTime(int** tires, int tiresSize, int* tiresColSize, int changeTime, int numLaps"}
{"id": "2151", "path": "output2\\c\\Hard\\2151-minimum-number-of-moves-to-make-palindrome.c", "hypo_code": "int minMovesToMakePalindrome(char * s){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int minMovesToMakePalindrome(char * s"}
{"id": "2152", "path": "output2\\c\\Hard\\2152-replace-non-coprime-numbers-in-array.c", "hypo_code": "int* replaceNonCoprimes(int* nums, int numsSize, int* returnSize){\n    int i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g\n\n}", "prefix": "int* replaceNonCoprimes(int* nums, int numsSize, int* returnSize"}
{"id": "2153", "path": "output2\\c\\Hard\\2153-minimum-weighted-subgraph-with-the-required-paths.c", "hypo_code": "long long minimumWeight(int n, int** edges, int edgesSize, int* edgesColSize, int src1, int src2, int dest){\nint i, j, min, max, count = 0;\n    for (i = 0; i < edgesSize; i++) {\n        min = edges[i]; max = edges[i];\n        for (j = i + 1; j < edgesSize; j++) {\n            if (edges[j] < min) min = edges[j];\n            else if (edges[j] > max) max = edges[j];\n            if (max - min == j - i) break;\n        }\n        if (j == edgesSize) count++;\n    }\n    return count;\n\n}", "prefix": "long long minimumWeight(int n, int** edges, int edgesSize, int* edgesColSize, int src1, int src2, int dest"}
{"id": "2154", "path": "output2\\c\\Hard\\2154-minimum-white-tiles-after-covering-with-carpets.c", "hypo_code": "int minimumWhiteTiles(char * floor, int numCarpets, int carpetLen){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int minimumWhiteTiles(char * floor, int numCarpets, int carpetLen"}
{"id": "2155", "path": "output2\\c\\Hard\\2155-longest-substring-of-one-repeating-character.c", "hypo_code": "int* longestRepeating(char * s, char * queryCharacters, int* queryIndices, int queryIndicesSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "int* longestRepeating(char * s, char * queryCharacters, int* queryIndices, int queryIndicesSize, int* returnSize"}
{"id": "2156", "path": "output2\\c\\Hard\\2156-maximum-value-of-k-coins-from-piles.c", "hypo_code": "int maxValueOfCoins(int** piles, int pilesSize, int* pilesColSize, int k){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int maxValueOfCoins(int** piles, int pilesSize, int* pilesColSize, int k"}
{"id": "2157", "path": "output2\\c\\Hard\\2157-sum-of-scores-of-built-strings.c", "hypo_code": "long long sumScores(char * s){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "long long sumScores(char * s"}
{"id": "2159", "path": "output2\\c\\Hard\\2159-maximum-total-beauty-of-the-gardens.c", "hypo_code": "long long maximumBeauty(int* flowers, int flowersSize, long long newFlowers, int target, int full, int partial){\n    long long i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v,\n\n}", "prefix": "long long maximumBeauty(int* flowers, int flowersSize, long long newFlowers, int target, int full, int partial"}
{"id": "2160", "path": "output2\\c\\Hard\\2160-maximum-score-of-a-node-sequence.c", "hypo_code": "int maximumScore(int* scores, int scoresSize, int** edges, int edgesSize, int* edgesColSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int maximumScore(int* scores, int scoresSize, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2161", "path": "output2\\c\\Hard\\2161-longest-path-with-different-adjacent-characters.c", "hypo_code": "int longestPath(int* parent, int parentSize, char * s){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int longestPath(int* parent, int parentSize, char * s"}
{"id": "2162", "path": "output2\\c\\Hard\\2162-number-of-flowers-in-full-bloom.c", "hypo_code": "int* fullBloomFlowers(int** flowers, int flowersSize, int* flowersColSize, int* people, int peopleSize, int* returnSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < flowersSize; i++) {\n        min = flowers[i]; max = flowers[i];\n        for (j = i + 1; j < flowersSize; j++) {\n            if (flowers[j] < min) min = flowers[j];\n            else if (flowers[j] > max) max = flowers[j];\n            if (max - min == j - i) break;\n        }\n        if (j == flowersSize) count++;\n    }\n    return count;\n\n}", "prefix": "int* fullBloomFlowers(int** flowers, int flowersSize, int* flowersColSize, int* people, int peopleSize, int* returnSize"}
{"id": "2163", "path": "output2\\c\\Hard\\2163-escape-the-spreading-fire.c", "hypo_code": "int maximumMinutes(int** grid, int gridSize, int* gridColSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int maximumMinutes(int** grid, int gridSize, int* gridColSize"}
{"id": "2164", "path": "output2\\c\\Hard\\2164-total-appeal-of-a-string.c", "hypo_code": "long long appealSum(char * s){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "long long appealSum(char * s"}
{"id": "2165", "path": "output2\\c\\Hard\\2165-check-if-there-is-a-valid-parentheses-string-path.c", "hypo_code": "bool hasValidPath(char** grid, int gridSize, int* gridColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "bool hasValidPath(char** grid, int gridSize, int* gridColSize"}
{"id": "2166", "path": "output2\\c\\Hard\\2166-substring-with-largest-variance.c", "hypo_code": "int largestVariance(char * s){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "int largestVariance(char * s"}
{"id": "2168", "path": "output2\\c\\Hard\\2168-sum-of-total-strength-of-wizards.c", "hypo_code": "int totalStrength(int* strength, int strengthSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strengthSize;i++){\n        if(strength[i] == 0){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "int totalStrength(int* strength, int strengthSize"}
{"id": "2170", "path": "output2\\c\\Hard\\2170-minimum-obstacle-removal-to-reach-corner.c", "hypo_code": "int minimumObstacles(int** grid, int gridSize, int* gridColSize){\nint i, j, min, max, count = 0;\n\tfor (i = 0; i < gridSize; i++) {\n\t\tmin = grid[i]; max = grid[i];\n\t\tfor (j = i + 1; j < gridSize; j++) {\n\t\t\tif (grid[j] < min) min = grid[j];\n\t\t\telse if (grid[j] > max) max = grid[j];\n\t\t\tif (max - min == j - i) break;\n\t\t}\n\t\tif (j == gridSize) count++;\n\t}\n\treturn count;\n}", "prefix": "int minimumObstacles(int** grid, int gridSize, int* gridColSize"}
{"id": "2172", "path": "output2\\c\\Hard\\2172-match-substring-after-replacement.c", "hypo_code": "bool matchReplacement(char * s, char * sub, char** mappings, int mappingsSize, int* mappingsColSize){\n    int i, j, min, max, count = 0;\n    for (i = 0; i < sSize; i++) {\n        min = s[i]; max = s[i];\n        for (j = i + 1; j < sSize; j++) {\n            if (s[j] < min) min = s[j];\n            else if (s[j] > max) max = s[j];\n            if (max - min == j - i) break;\n        }\n        if (j == sSize) count++;\n    }\n    return count;\n\n}", "prefix": "bool matchReplacement(char * s, char * sub, char** mappings, int mappingsSize, int* mappingsColSize"}
{"id": "2173", "path": "output2\\c\\Hard\\2173-count-subarrays-with-score-less-than-k.c", "hypo_code": "long long countSubarrays(int* nums, int numsSize, long long k){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "long long countSubarrays(int* nums, int numsSize, long long k"}
{"id": "2174", "path": "output2\\c\\Hard\\2174-naming-a-company.c", "hypo_code": "long long distinctNames(char ** ideas, int ideasSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < ideasSize; i++) {\n        min = ideas[i]; max = ideas[i];\n        for (j = i + 1; j < ideasSize; j++) {\n            if (ideas[j] < min) min = ideas[j];\n            else if (ideas[j] > max) max = ideas[j];\n            if (max - min == j - i) break;\n        }\n        if (j == ideasSize) count++;\n    }\n    return count;\n}", "prefix": "long long distinctNames(char ** ideas, int ideasSize"}
{"id": "2175", "path": "output2\\c\\Hard\\2175-selling-pieces-of-wood.c", "hypo_code": "long long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < pricesSize; i++) {\n        min = prices[i]; max = prices[i];\n        for (j = i + 1; j < pricesSize; j++) {\n            if (prices[j] < min) min = prices[j];\n            else if (prices[j] > max) max = prices[j];\n            if (max - min == j - i) break;\n        }\n        if (j == pricesSize) count++;\n    }\n    return count;\n}", "prefix": "long long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize"}
{"id": "2176", "path": "output2\\c\\Hard\\2176-number-of-distinct-roll-sequences.c", "hypo_code": "int distinctSequences(int n){\nint i, j, min, max, count = 0;\n    for (i = 0; i < n; i++) {\n        min = n[i]; max = n[i];\n        for (j = i + 1; j < n; j++) {\n            if (n[j] < min) min = n[j];\n            else if (n[j] > max) max = n[j];\n            if (max - min == j - i) break;\n        }\n        if (j == n) count++;\n    }\n    return count;\n}", "prefix": "int distinctSequences(int n"}
{"id": "2177", "path": "output2\\c\\Hard\\2177-maximum-score-of-spliced-array.c", "hypo_code": "int maximumsSplicedArray(int* nums1, int nums1Size, int* nums2, int nums2Size){\nint i, j, min, max, count = 0;\n    for (i = 0; i < nums1Size; i++) {\n        min = nums1[i]; max = nums1[i];\n        for (j = i + 1; j < nums1Size; j++) {\n            if (nums1[j] < min) min = nums1[j];\n            else if (nums1[j] > max) max = nums1[j];\n            if (max - min == j - i) break;\n        }\n        if (j == nums1Size) count++;\n    }\n    return count;\n}", "prefix": "int maximumsSplicedArray(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "2178", "path": "output2\\c\\Hard\\2178-minimum-score-after-removals-on-a-tree.c", "hypo_code": "int minimumScore(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "int minimumScore(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2179", "path": "output2\\c\\Hard\\2179-number-of-increasing-paths-in-a-grid.c", "hypo_code": "int countPaths(int** grid, int gridSize, int* gridColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < gridSize; i++) {\n        min = gridSize[i]; max = gridSize[i];\n        for (j = i + 1; j < gridSize; j++) {\n            if (gridSize[j] < min) min = gridSize[j];\n            else if (gridSize[j] > max) max = gridSize[j];\n            if (max - min == j - i) break;\n        }\n        if (j == gridSize) count++;\n    }\n    return count;\n}", "prefix": "int countPaths(int** grid, int gridSize, int* gridColSize"}
{"id": "2180", "path": "output2\\c\\Hard\\2180-subarray-with-elements-greater-than-varying-threshold.c", "hypo_code": "int validSubarraySize(int* nums, int numsSize, int threshold){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "int validSubarraySize(int* nums, int numsSize, int threshold"}
{"id": "2181", "path": "output2\\c\\Hard\\2181-count-the-number-of-ideal-arrays.c", "hypo_code": "int idealArrays(int n, int maxValue){\nint i, j, min, max, count = 0;\n    for (i = 0; i < n; i++) {\n        min = n[i]; max = n[i];\n        for (j = i + 1; j < n; j++) {\n            if (n[j] < min) min = n[j];\n            else if (n[j] > max) max = n[j];\n            if (max - min == j - i) break;\n        }\n        if (j == n) count++;\n    }\n    return count;\n}", "prefix": "int idealArrays(int n, int maxValue"}
{"id": "2182", "path": "output2\\c\\Hard\\2182-minimum-deletions-to-make-array-divisible.c", "hypo_code": "int minOperations(int* nums, int numsSize, int* numsDivide, int numsDivideSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "int minOperations(int* nums, int numsSize, int* numsDivide, int numsDivideSize"}
{"id": "2183", "path": "output2\\c\\Hard\\2183-shortest-impossible-sequence-of-rolls.c", "hypo_code": "int shortestSequence(int* rolls, int rollsSize, int k){\nint i, j, min, max, count = 0;\n    for (i = 0; i < rollsSize; i++) {\n        min = rolls[i]; max = rolls[i];\n        for (j = i + 1; j < rollsSize; j++) {\n            if (rolls[j] < min) min = rolls[j];\n            else if (rolls[j] > max) max = rolls[j];\n            if (max - min == j - i) break;\n        }\n        if (j == rollsSize) count++;\n    }\n    return count;\n}", "prefix": "int shortestSequence(int* rolls, int rollsSize, int k"}
{"id": "2184", "path": "output2\\c\\Hard\\2184-number-of-excellent-pairs.c", "hypo_code": "long long countExcellentPairs(int* nums, int numsSize, int k){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "long long countExcellentPairs(int* nums, int numsSize, int k"}
{"id": "2185", "path": "output2\\c\\Hard\\2185-longest-cycle-in-a-graph.c", "hypo_code": "int longestCycle(int* edges, int edgesSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < edgesSize; i++) {\n        min = edges[i]; max = edges[i];\n        for (j = i + 1; j < edgesSize; j++) {\n            if (edges[j] < min) min = edges[j];\n            else if (edges[j] > max) max = edges[j];\n            if (max - min == j - i) break;\n        }\n        if (j == edgesSize) count++;\n    }\n    return count;\n}", "prefix": "int longestCycle(int* edges, int edgesSize"}
{"id": "2186", "path": "output2\\c\\Hard\\2186-minimum-replacements-to-sort-the-array.c", "hypo_code": "long long minimumReplacement(int* nums, int numsSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}\nint minOperations(int* nums, int numsSize){\n    int i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "long long minimumReplacement(int* nums, int numsSize"}
{"id": "2187", "path": "output2\\c\\Hard\\2187-count-special-integers.c", "hypo_code": "int countSpecialNumbers(int n){\nint i, j, min, max, count = 0;\n    for (i = 0; i < n; i++) {\n        min = n[i]; max = n[i];\n        for (j = i + 1; j < n; j++) {\n            if (n[j] < min) min = n[j];\n            else if (n[j] > max) max = n[j];\n            if (max - min == j - i) break;\n        }\n        if (j == n) count++;\n    }\n    return count;\n}", "prefix": "int countSpecialNumbers(int n"}
{"id": "2188", "path": "output2\\c\\Hard\\2188-maximum-segment-sum-after-removals.c", "hypo_code": "long long* maximumSegmentSum(int* nums, int numsSize, int* removeQueries, int removeQueriesSize, int* returnSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n\n}", "prefix": "long long* maximumSegmentSum(int* nums, int numsSize, int* removeQueries, int removeQueriesSize, int* returnSize"}
{"id": "2189", "path": "output2\\c\\Hard\\2189-find-the-k-sum-of-an-array.c", "hypo_code": "long long kSum(int* nums, int numsSize, int k){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "long long kSum(int* nums, int numsSize, int k"}
{"id": "2190", "path": "output2\\c\\Hard\\2190-build-a-matrix-with-conditions.c", "hypo_code": "int** buildMatrix(int k, int** rowConditions, int rowConditionsSize, int* rowConditionsColSize, int** colConditions, int colConditionsSize, int* colConditionsColSize, int* returnSize, int** returnColumnSizes){\nint i, j, min, max, count = 0;\n    for (i = 0; i < rowConditionsSize; i++) {\n        min = rowConditions[i]; max = rowConditions[i];\n        for (j = i + 1; j < rowConditionsSize; j++) {\n            if (rowConditions[j] < min) min = rowConditions[j];\n            else if (rowConditions[j] > max) max = rowConditions[j];\n            if (max - min == j - i) break;\n        }\n        if (j == rowConditionsSize) count++;\n    }\n    return count;\n}", "prefix": "int** buildMatrix(int k, int** rowConditions, int rowConditionsSize, int* rowConditionsColSize, int** colConditions, int colConditionsSize, int* colConditionsColSize, int* returnSize, int** returnColumnSizes"}
{"id": "2191", "path": "output2\\c\\Hard\\2191-maximum-number-of-robots-within-budget.c", "hypo_code": "int maximumRobots(int* chargeTimes, int chargeTimesSize, int* runningCosts, int runningCostsSize, long long budget){\nint i, j, min, max, count = 0;\n    for (i = 0; i < chargeTimesSize; i++) {\n        min = chargeTimes[i]; max = chargeTimes[i];\n        for (j = i + 1; j < chargeTimesSize; j++) {\n            if (chargeTimes[j] < min) min = chargeTimes[j];\n            else if (chargeTimes[j] > max) max = chargeTimes[j];\n            if (max - min == j - i) break;\n        }\n        if (j == chargeTimesSize) count++;\n    }\n    return count;\n}", "prefix": "int maximumRobots(int* chargeTimes, int chargeTimesSize, int* runningCosts, int runningCostsSize, long long budget"}
{"id": "2192", "path": "output2\\c\\Hard\\2192-meeting-rooms-iii.c", "hypo_code": "int mostBooked(int n, int** meetings, int meetingsSize, int* meetingsColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < meetingsSize; i++) {\n        min = meetings[i]; max = meetings[i];\n        for (j = i + 1; j < meetingsSize; j++) {\n            if (meetings[j] < min) min = meetings[j];\n            else if (meetings[j] > max) max = meetings[j];\n            if (max - min == j - i) break;\n        }\n        if (j == meetingsSize) count++;\n    }\n    return count;\n}", "prefix": "int mostBooked(int n, int** meetings, int meetingsSize, int* meetingsColSize"}
{"id": "2193", "path": "output2\\c\\Hard\\2193-longest-increasing-subsequence-ii.c", "hypo_code": "int lengthOfLIS(int* nums, int numsSize, int k){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "int lengthOfLIS(int* nums, int numsSize, int k"}
{"id": "2194", "path": "output2\\c\\Hard\\2194-minimum-money-required-before-transactions.c", "hypo_code": "long long minimumMoney(int** transactions, int transactionsSize, int* transactionsColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < transactionsSize; i++) {\n        min = transactions[i]; max = transactions[i];\n        for (j = i + 1; j < transactionsSize; j++) {\n            if (transactions[j] < min) min = transactions[j];\n            else if (transactions[j] > max) max = transactions[j];\n            if (max - min == j - i) break;\n        }\n        if (j == transactionsSize) count++;\n    }\n    return count;\n}", "prefix": "long long minimumMoney(int** transactions, int transactionsSize, int* transactionsColSize"}
{"id": "2195", "path": "output2\\c\\Hard\\2195-sum-of-prefix-scores-of-strings.c", "hypo_code": "int* sumPrefixScores(char ** words, int wordsSize, int* returnSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < wordsSize; i++) {\n        min = words[i]; max = words[i];\n        for (j = i + 1; j < wordsSize; j++) {\n            if (words[j] < min) min = words[j];\n            else if (words[j] > max) max = words[j];\n            if (max - min == j - i) break;\n        }\n        if (j == wordsSize) count++;\n    }\n    return count;\n}", "prefix": "int* sumPrefixScores(char ** words, int wordsSize, int* returnSize"}
{"id": "2196", "path": "output2\\c\\Hard\\2196-number-of-good-paths.c", "hypo_code": "int numberOfGoodPaths(int* vals, int valsSize, int** edges, int edgesSize, int* edgesColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < valsSize; i++) {\n        min = vals[i]; max = vals[i];\n        for (j = i + 1; j < valsSize; j++) {\n            if (vals[j] < min) min = vals[j];\n            else if (vals[j] > max) max = vals[j];\n            if (max - min == j - i) break;\n        }\n        if (j == valsSize) count++;\n    }\n    return count;\n}", "prefix": "int numberOfGoodPaths(int* vals, int valsSize, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2197", "path": "output2\\c\\Hard\\2197-number-of-pairs-satisfying-inequality.c", "hypo_code": "long long numberOfPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int diff){\nint i, j, min, max, count = 0;\n    for (i = 0; i < nums1Size; i++) {\n        min = nums1[i]; max = nums1[i];\n        for (j = i + 1; j < nums1Size; j++) {\n            if (nums1[j] < min) min = nums1[j];\n            else if (nums1[j] > max) max = nums1[j];\n            if (max - min == j - i) break;\n        }\n        if (j == nums1Size) count++;\n    }\n    return count;\n}", "prefix": "long long numberOfPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int diff"}
{"id": "2198", "path": "output2\\c\\Hard\\2198-maximum-deletions-on-a-string.c", "hypo_code": "int deleteString(char * s){\nint i, j, min, max, count = 0;\n    for (i = 0; i < sSize; i++) {\n        min = s[i]; max = s[i];\n        for (j = i + 1; j < sSize; j++) {\n            if (s[j] < min) min = s[j];\n            else if (s[j] > max) max = s[j];\n            if (max - min == j - i) break;\n        }\n        if (j == sSize) count++;\n    }\n    return count;\n}", "prefix": "int deleteString(char * s"}
{"id": "2199", "path": "output2\\c\\Hard\\2199-paths-in-matrix-whose-sum-is-divisible-by-k.c", "hypo_code": "int numberOfPaths(int** grid, int gridSize, int* gridColSize, int k){\nint i, j, min, max, count = 0;\n    for (i = 0; i < gridSize; i++) {\n        min = grid[i]; max = grid[i];\n        for (j = i + 1; j < gridSize; j++) {\n            if (grid[j] < min) min = grid[j];\n            else if (grid[j] > max) max = grid[j];\n            if (max - min == j - i) break;\n        }\n        if (j == gridSize) count++;\n    }\n    return count;\n}", "prefix": "int numberOfPaths(int** grid, int gridSize, int* gridColSize, int k"}
{"id": "2200", "path": "output2\\c\\Hard\\2200-create-components-with-same-value.c", "hypo_code": "int componentValue(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "int componentValue(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2201", "path": "output2\\c\\Hard\\2201-count-subarrays-with-fixed-bounds.c", "hypo_code": "long long countSubarrays(int* nums, int numsSize, int minK, int maxK){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "long long countSubarrays(int* nums, int numsSize, int minK, int maxK"}
{"id": "2202", "path": "output2\\c\\Hard\\2202-minimum-cost-to-make-array-equal.c", "hypo_code": "long long minCost(int* nums, int numsSize, int* cost, int costSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "long long minCost(int* nums, int numsSize, int* cost, int costSize"}
{"id": "2203", "path": "output2\\c\\Hard\\2203-minimum-number-of-operations-to-make-arrays-similar.c", "hypo_code": "long long makeSimilar(int* nums, int numsSize, int* target, int targetSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "long long makeSimilar(int* nums, int numsSize, int* target, int targetSize"}
{"id": "2204", "path": "output2\\c\\Hard\\2204-next-greater-element-iv.c", "hypo_code": "int* secondGreaterElement(int* nums, int numsSize, int* returnSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}", "prefix": "int* secondGreaterElement(int* nums, int numsSize, int* returnSize"}
{"id": "2205", "path": "output2\\c\\Hard\\2205-height-of-binary-tree-after-subtree-removal-queries.c", "hypo_code": "int* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "int* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize"}
{"id": "2206", "path": "output2\\c\\Hard\\2206-minimum-total-distance-traveled.c", "hypo_code": "long long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize){\n    long long i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v,\n\n}", "prefix": "long long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize"}
{"id": "2207", "path": "output2\\c\\Hard\\2207-split-message-based-on-limit.c", "hypo_code": "char ** splitMessage(char * message, int limit, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "char ** splitMessage(char * message, int limit, int* returnSize"}
{"id": "2208", "path": "output2\\c\\Hard\\2208-maximum-number-of-non-overlapping-palindrome-substrings.c", "hypo_code": "int maxPalindromes(char * s, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "int maxPalindromes(char * s, int k"}
{"id": "2209", "path": "output2\\c\\Hard\\2209-number-of-beautiful-partitions.c", "hypo_code": "int beautifulPartitions(char * s, int k, int minLength){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*2);\n    for(i=0;i<2;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=0;i<strlen(s);i++){\n        if(s[i] == '0'){\n            arr[0] = (arr[0] + arr[1])%1000000007;\n        }\n        else{\n            arr[1] = (arr[0] + arr[1])%1000000007;\n        }\n    }\n    return arr[0];\n\n}", "prefix": "int beautifulPartitions(char * s, int k, int minLength"}
{"id": "2210", "path": "output2\\c\\Hard\\2210-count-palindromic-subsequences.c", "hypo_code": "int countPalindromes(char * s){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w\n\n}", "prefix": "int countPalindromes(char * s"}
{"id": "2211", "path": "output2\\c\\Hard\\2211-count-subarrays-with-median-k.c", "hypo_code": "int countSubarrays(int* nums, int numsSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<numsSize;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[numsSize-1];\n\n}", "prefix": "int countSubarrays(int* nums, int numsSize, int k"}
{"id": "2212", "path": "output2\\c\\Hard\\2212-divide-nodes-into-the-maximum-number-of-groups.c", "hypo_code": "int magnificentSets(int n, int** edges, int edgesSize, int* edgesColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr14[i] = 0;\n    }\n    int* arr15\n\n}", "prefix": "int magnificentSets(int n, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2213", "path": "output2\\c\\Hard\\2213-minimum-total-cost-to-make-arrays-unequal.c", "hypo_code": "long long minimumTotalCost(int* nums1, int nums1Size, int* nums2, int nums2Size){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*nums1Size);\n    for(i=0;i<nums1Size;i++){\n        arr[i] = 0;\n    }\n    arr[0] = 1;\n    for(i=1;i<nums1Size;i++){\n        arr[i] = arr[i-1] + 1;\n        if(i%2==0){\n            arr[i] = (arr[i] < arr[i/2] + 1) ? arr[i] : arr[i/2] + 1;\n        }\n        if(i%3==0){\n            arr[i] = (arr[i] < arr[i/3] + 1) ? arr[i] : arr[i/3] + 1;\n        }\n    }\n    return arr[nums1Size-1];\n\n\n}", "prefix": "long long minimumTotalCost(int* nums1, int nums1Size, int* nums2, int nums2Size"}
{"id": "2214", "path": "output2\\c\\Hard\\2214-maximum-number-of-points-from-grid-queries.c", "hypo_code": "**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* maxPoints(int** grid, int gridSize, int* gridColSize, int* queries, int queriesSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*26);\n    for(i=0;i<26;i++){\n        arr\n\n}", "prefix": "int* maxPoints(int** grid, int gridSize, int* gridColSize, int* queries, int queriesSize, int* returnSize"}
{"id": "2215", "path": "output2\\c\\Hard\\2215-add-edges-to-make-degrees-of-all-nodes-even.c", "hypo_code": "bool isPossible(int n, int** edges, int edgesSize, int* edgesColSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*n);\n    for(i=0;i<n;i++){\n        arr14[i] = 0;\n    }\n    int* arr15\n\n}", "prefix": "bool isPossible(int n, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2216", "path": "output2\\c\\Hard\\2216-cycle-length-queries-in-a-tree.c", "hypo_code": "int* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*queriesSize);\n    for(i=0;i<queriesSize;i++){\n        arr13[i] = 0;\n    }\n\n}", "prefix": "int* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "2217", "path": "output2\\c\\Hard\\2217-count-anagrams.c", "hypo_code": "int countAnagrams(char * s){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*100000);\n    for(i=0;i<100000;i++){\n        arr[i] = 0;\n    }\n    int len = strlen(s);\n    int* arr2 = (int*)malloc(sizeof(int)*len);\n    for(i=0;i<len;i++){\n        arr2[i] = 0;\n    }\n    for(i=0;i<len;i++){\n        if(s[i]==' '){\n            return 0;\n        }\n        int num = 0;\n        for(j=i;j<len;j++){\n            num = num*10 + (s[j]-'0');\n            if(num<=100000){\n                if(i==0){\n                    arr[j] = 1;\n                }\n                else{\n                    arr[j] = (arr[j] + arr2[i-1]) % 1000000007;\n                }\n            }\n            else{\n                break;\n            }\n        }\n        for(j=0;j<len;j++){\n            arr2[j] = arr[j];\n        }\n    }\n    return arr[len-1];\n\n\n}", "prefix": "int countAnagrams(char * s"}
{"id": "2218", "path": "output2\\c\\Hard\\2218-number-of-great-partitions.c", "hypo_code": "int countPartitions(int* nums, int numsSize, int k){\n    int i,j,k;\n    int* arr = (int*)malloc(sizeof(int)*numsSize);\n    for(i=0;i<numsSize;i++){\n        arr[i] = 1;\n    }\n    for(i=1;i<numsSize;i++){\n        for(j=0;j<i;j++){\n            arr[i] = (arr[i] * (2*(i-j)+1)) % 1000000007;\n        }\n    }\n    int sum = 0;\n    for(i=0;i<numsSize;i++){\n        sum = (sum + arr[i]) % 1000000007;\n    }\n    return sum;\n\n}", "prefix": "int countPartitions(int* nums, int numsSize, int k"}
{"id": "2219", "path": "output2\\c\\Hard\\2219-maximize-the-minimum-powered-city.c", "hypo_code": "long long maxPower(int* stations, int stationsSize, int r, int k){\n    long long ans = 0;\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr[i] = 0;\n    }\n    int count = 0;\n    int temp = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr[count] = temp;\n            temp = 0;\n            count++;\n        }\n        else{\n            temp = temp*10 + (s[i]-'0');\n        }\n    }\n    arr[count] = temp;\n    count++;\n    int* arr2 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr2[i] = 0;\n    }\n    int count2 = 0;\n    int temp2 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr2[count2] = temp2;\n            temp2 = 0;\n            count2++;\n        }\n        else{\n            temp2 = temp2*10 + (s[i]-'0');\n        }\n    }\n    arr2[count2] = temp2;\n    count2++;\n    int* arr3 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr3[i] = 0;\n    }\n    int count3 = 0;\n    int temp3 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr3[count3] = temp3;\n            temp3 = 0;\n            count3++;\n        }\n        else{\n            temp3 = temp3*10 + (s[i]-'0');\n        }\n    }\n    arr3[count3] = temp3;\n    count3++;\n    int* arr4 = (int*)malloc(sizeof(int)*1000);\n    for(i=0;i<1000;i++){\n        arr4[i] = 0;\n    }\n    int count4 = 0;\n    int temp4 = 0;\n    for(i=0;i<strlen(s);i++){\n        if(s[i]=='-'){\n            arr4[count4] = temp4;\n            temp4 = 0;\n            count4++;\n        }\n        else{\n            temp4 = temp4 * 10 + (s[i]-'0');\n            \n\n}", "prefix": "long long maxPower(int* stations, int stationsSize, int r, int k"}
{"id": "2220", "path": "output2\\c\\Hard\\2220-time-to-cross-a-bridge.c", "hypo_code": "int findCrossingTime(int n, int k, int** time, int timeSize, int* timeColSize){\n    int i,j;\n    int* arr = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr[i] = 0;\n    }\n    int* arr2 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr2[i] = 0;\n    }\n    int* arr3 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr3[i] = 0;\n    }\n    int* arr4 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr4[i] = 0;\n    }\n    int* arr5 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr5[i] = 0;\n    }\n    int* arr6 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr6[i] = 0;\n    }\n    int* arr7 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr7[i] = 0;\n    }\n    int* arr8 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr8[i] = 0;\n    }\n    int* arr9 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr9[i] = 0;\n    }\n    int* arr10 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr10[i] = 0;\n    }\n    int* arr11 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr11[i] = 0;\n    }\n    int* arr12 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr12[i] = 0;\n    }\n    int* arr13 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr13[i] = 0;\n    }\n    int* arr14 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr14[i] = 0;\n    }\n    int* arr15 = (int*)malloc(sizeof(int)*k);\n    for(i=0;i<k;i++){\n        arr15[i] = 0;\n    }\n    int* arr16 = (int*)malloc(sizeof(int)*k);\n\n}", "prefix": "int findCrossingTime(int n, int k, int** time, int timeSize, int* timeColSize"}
{"id": "2221", "path": "output2\\c\\Hard\\2221-difference-between-maximum-and-minimum-price-sum.c", "hypo_code": "long long maxOutput(int n, int** edges, int edgesSize, int* edgesColSize, int* price, int priceSize){\n    long long result = 0;\n    return result;\n\n\n}", "prefix": "long long maxOutput(int n, int** edges, int edgesSize, int* edgesColSize, int* price, int priceSize"}
{"id": "2222", "path": "output2\\c\\Hard\\2222-check-if-point-is-reachable.c", "hypo_code": "bool isReachable(int targetX, int targetY){\n    int x = 1, y = 1;\n    while(x < targetX || y < targetY){\n        if(x < targetX && y < targetY){\n            if(targetX - x > targetY - y){\n                x += y;\n            }else{\n                y += x;\n            }\n        }else if(x < targetX){\n            x += y;\n        }else{\n            y += x;\n        }\n    }\n    return x == targetX && y == targetY;\n\n}", "prefix": "bool isReachable(int targetX, int targetY"}
{"id": "2223", "path": "output2\\c\\Hard\\2223-minimum-cost-to-split-an-array.c", "hypo_code": "int minCost(int* nums, int numsSize, int k){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int minCost(int* nums, int numsSize, int k"}
{"id": "2224", "path": "output2\\c\\Hard\\2224-put-marbles-in-bags.c", "hypo_code": "long long putMarbles(int* weights, int weightsSize, int k){\n    int i, j, t, f;\n    char *s = (char *)malloc(sizeof(char) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "long long putMarbles(int* weights, int weightsSize, int k"}
{"id": "2225", "path": "output2\\c\\Hard\\2225-count-increasing-quadruplets.c", "hypo_code": "long long countQuadruplets(int* nums, int numsSize){\n    int i, j, k, l;\n    long long c = 0;\n    for (i = 0; i < numsSize - 3; i++) {\n        for (j = i + 1; j < numsSize - 2; j++) {\n            for (k = j + 1; k < numsSize - 1; k++) {\n                for (l = k + 1; l < numsSize; l++) {\n                    if (nums[i] < nums[k] && nums[k] < nums[j] && nums[j] < nums[l]) {\n                        c++;\n                    }\n                }\n            }\n        }\n    }\n    return c;\n\n}", "prefix": "long long countQuadruplets(int* nums, int numsSize"}
{"id": "2226", "path": "output2\\c\\Hard\\2226-rearranging-fruits.c", "hypo_code": "long long minCost(int* basket1, int basket1Size, int* basket2, int basket2Size){\n    long long result = 0;\n    int* queue = (int*)malloc(sizeof(int) * basket1Size);\n    int head = 0, tail = 0;\n    for(int i = 0; i < basket1Size; i++){\n        while(head < tail && basket1[queue[tail - 1]] < basket1[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) result += basket1[queue[head]];\n    }\n    return result;\n\n}", "prefix": "long long minCost(int* basket1, int basket1Size, int* basket2, int basket2Size"}
{"id": "2227", "path": "output2\\c\\Hard\\2227-subsequence-with-the-minimum-score.c", "hypo_code": "int minimumScore(char * s, char * t){\n    int i, j, k, l, m, n, o, p, q, r, a, b, c, d, e, f, g, h, w, x, y, z;\n    int *s = (int *)malloc(sizeof(int) * (n + 1));\n    int *t = (int *)malloc(sizeof(int) * (n + 1));\n    int *a = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        a[i] = i + 1;\n    }\n    for (i = 0; i < n; i++) {\n        f = 1;\n        for (j = 1; j <= n - i - 1; j++) {\n            f *= j;\n        }\n        t = (k - 1) / f;\n        s[i] = a[t] + '0';\n        for (j = t; j < n - i - 1; j++) {\n            a[j] = a[j + 1];\n        }\n        k -= t * f;\n    }\n    s[n] = '\\0';\n    return s;\n\n}", "prefix": "int minimumScore(char * s, char * t"}
{"id": "2228", "path": "output2\\c\\Hard\\2228-handling-sum-queries-after-update.c", "hypo_code": "long long* handleQuery(int* nums1, int nums1Size, int* nums2, int nums2Size, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\n    long long* result = (long long*)malloc(sizeof(long long) * queriesSize);\n    int* queue = (int*)malloc(sizeof(int) * nums1Size);\n    int head = 0, tail = 0;\n    for(int i = 0; i < nums1Size; i++){\n        while(head < tail && nums1[queue[tail - 1]] < nums1[i]) tail--;\n        queue[tail++] = i;\n        if(i - queue[head] >= k) head++;\n        if(i >= k - 1) result[i - k + 1] = nums1[queue[head]];\n    }\n    *returnSize = nums1Size - k + 1;\n    return result;\n\n}", "prefix": "long long* handleQuery(int* nums1, int nums1Size, int* nums2, int nums2Size, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "2229", "path": "output2\\c\\Hard\\2229-find-the-string-with-lcp.c", "hypo_code": "char * findTheString(int** lcp, int lcpSize, int* lcpColSize){\n    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n    int a, b, c, d, e, f, g, h, i, j, k, l, m, n ,o, p, q, r, s, t, u, v, w, x, y, z;\n\n}", "prefix": "char * findTheString(int** lcp, int lcpSize, int* lcpColSize"}
{"id": "2230", "path": "output2\\c\\Hard\\2230-minimum-time-to-visit-a-cell-in-a-grid.c", "hypo_code": "int minimumTime(int** grid, int gridSize, int* gridColSize){\nint i, j, min, max, count = 0;\n\tfor (i = 0; i < gridSize; i++) {\n\t\tmin = grid[i]; max = grid[i];\n\t\tfor (j = i + 1; j < gridSize; j++) {\n\t\t\tif (grid[j] < min) min = grid[j];\n\t\t\telse if (grid[j] > max) max = grid[j];\n\t\t\tif (max - min == j - i) break;\n\t\t}\n\t\tif (j == gridSize) count++;\n\t}\n\treturn count;\n}", "prefix": "int minimumTime(int** grid, int gridSize, int* gridColSize"}
{"id": "2231", "path": "output2\\c\\Hard\\2231-count-number-of-possible-root-nodes.c", "hypo_code": "int rootCount(int** edges, int edgesSize, int* edgesColSize, int** guesses, int guessesSize, int* guessesColSize, int k){\nint i, j, min, max, count = 0;\n    for (i = 0; i < edgesSize; i++) {\n        min = edges[i]; max = edges[i];\n        for (j = i + 1; j < edgesSize; j++) {\n            if (edges[j] < min) min = edges[j];\n            else if (edges[j] > max) max = edges[j];\n            if (max - min == j - i) break;\n        }\n        if (j == edgesSize) count++;\n    }\n    return count;\n}", "prefix": "int rootCount(int** edges, int edgesSize, int* edgesColSize, int** guesses, int guessesSize, int* guessesColSize, int k"}
{"id": "2232", "path": "output2\\c\\Hard\\2232-split-the-array-to-make-coprime-products.c", "hypo_code": "int findValidSplit(int* nums, int numsSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n}\nint splitArray(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < numsSize; i++) {\n        min = nums[i]; max = nums[i];\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[j] < min) min = nums[j];\n            else if (nums[j] > max) max = nums[j];\n            if (max - min == j - i) break;\n        }\n        if (j == numsSize) count++;\n    }\n    return count;\n\n}", "prefix": "int findValidSplit(int* nums, int numsSize"}
{"id": "2233", "path": "output2\\c\\Hard\\2233-number-of-ways-to-earn-points.c", "hypo_code": "int waysToReachTarget(int target, int** types, int typesSize, int* typesColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < typesSize; i++) {\n        min = types[i]; max = types[i];\n        for (j = i + 1; j < typesSize; j++) {\n            if (types[j] < min) min = types[j];\n            else if (types[j] > max) max = types[j];\n            if (max - min == j - i) break;\n        }\n        if (j == typesSize) count++;\n    }\n    return count;\n}", "prefix": "int waysToReachTarget(int target, int** types, int typesSize, int* typesColSize"}
{"id": "2234", "path": "output2\\c\\Hard\\2234-minimum-time-to-complete-all-tasks.c", "hypo_code": "int findMinimumTime(int** tasks, int tasksSize, int* tasksColSize){\nint i, j, min, max, count = 0;\n    for (i = 0; i < tasksSize; i++) {\n        min = tasks[i]; max = tasks[i];\n        for (j = i + 1; j < tasksSize; j++) {\n            if (tasks[j] < min) min = tasks[j];\n            else if (tasks[j] > max) max = tasks[j];\n            if (max - min == j - i) break;\n        }\n        if (j == tasksSize) count++;\n    }\n    return count;\n\n}", "prefix": "int findMinimumTime(int** tasks, int tasksSize, int* tasksColSize"}
{"id": "2235", "path": "output2\\c\\Hard\\2235-collect-coins-in-a-tree.c", "hypo_code": "int collectTheCoins(int* coins, int coinsSize, int** edges, int edgesSize, int* edgesColSize){ \nint n = coinsSize;\n\tint *visited = malloc(sizeof(int)*n);\n\tmemset(visited, 0, sizeof(int)*n);\n\t\n\tint *collected = malloc(sizeof(int)*n);\n\tmemset(collected, 0, sizeof(int)*n);\n\t\n\tint *queue = malloc(sizeof(int)*n);\n\tint front = 0, rear = 0;\n\tint *coinQueue = malloc(sizeof(int)*n);\n\tint coinFront = 0, coinRear = 0;\n\t\n\tint i = 0;\n\tint *edge = NULL;\n\tint vertex = 0;\n\tint coin = 0;\n\tint result = 0;\n\t\n\tqueue[rear++] = 0;\n\tcoinQueue[coinRear++] = 0;\n\tvisited[0] = 1;\n\tcollected[0] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tcoin = coinQueue[coinFront++];\n\t\tvisited[vertex] = 1;\n\t\tif(coins[vertex] == 1){\n\t\t\tcollected[vertex] = 1;\n\t\t}\n\t\tedge = edges[i++];\n\t\tif(edge[0] == vertex){\n\t\t\tif(visited[edge[1]] == 0){\n\t\t\t\tqueue[rear++] = edge[1];\n\t\t\t\tcoinQueue[coinRear++] = coin + coins[edge[1]];\n\t\t\t}\n\t\t}else if(edge[1] == vertex){\n\t\t\tif(visited[edge[0]] == 0){\n\t\t\t\tqueue[rear++] = edge[0];\n\t\t\t\tcoinQueue[coinRear++] = coin + coins[edge[0]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i = 0; i < n; i++){\n\t\tif(collected[i] == 0){\n\t\t\tresult++;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "prefix": "int collectTheCoins(int* coins, int coinsSize, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2236", "path": "output2\\c\\Hard\\2236-shortest-cycle-in-a-graph.c", "hypo_code": "int findShortestCycle(int n, int** edges, int edgesSize, int* edgesColSize){\nint *queue = malloc(sizeof(int)*n);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*n);\n\tmemset(visited, 0, sizeof(int)*n);\n\tint *distance = malloc(sizeof(int)*n);\n\tmemset(distance, 0, sizeof(int)*n);\n\t\n\tint i = 0;\n\tint *edge = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = 0;\n\tvisited[0] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\tedge = edges[i++];\n\t\tif(edge[0] == vertex){\n\t\t\tif(visited[edge[1]] == 0){\n\t\t\t\tqueue[rear++] = edge[1];\n\t\t\t\tdistance[edge[1]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[1]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif(visited[edge[0]] == 0){\n\t\t\t\tqueue[rear++] = edge[0];\n\t\t\t\tdistance[edge[0]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[0]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int findShortestCycle(int n, int** edges, int edgesSize, int* edgesColSize"}
{"id": "2237", "path": "output2\\c\\Hard\\2237-minimum-reverse-operations.c", "hypo_code": "int* minReverseOperations(int n, int p, int* banned, int bannedSize, int k, int* returnSize){\nint *result = malloc(sizeof(int)*n);\n\tmemset(result, 0, sizeof(int)*n);\n\t*returnSize = n;\n\t\n\tint *queue = malloc(sizeof(int)*n);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*n);\n\tmemset(visited, 0, sizeof(int)*n);\n\tint *distance = malloc(sizeof(int)*n);\n\tmemset(distance, 0, sizeof(int)*n);\n\t\n\tint i = 0;\n\tint *bannedVertex = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = p;\n\tvisited[p] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\tif(vertex == p){\n\t\t\tresult = 0;\n\t\t}\n\t\tbannedVertex = banned[i++];\n\t\tif(bannedVertex[0] == vertex){\n\t\t\tif(visited[bannedVertex[1]] == 0){\n\t\t\t\tqueue[rear++] = bannedVertex[1];\n\t\t\t\tdistance[bannedVertex[1]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[bannedVertex[1]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif(visited[bannedVertex[0]] == 0){\n\t\t\t\tqueue[rear++] = bannedVertex[0];\n\t\t\t\tdistance[bannedVertex[0]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[bannedVertex[0]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int* minReverseOperations(int n, int p, int* banned, int bannedSize, int k, int* returnSize"}
{"id": "2238", "path": "output2\\c\\Hard\\2238-minimum-number-of-visited-cells-in-a-grid.c", "hypo_code": "int minimumVisitedCells(int** grid, int gridSize, int* gridColSize){\nint m = gridSize;\n\tint n = gridColSize[0];\n\tint *queue = malloc(sizeof(int)*m*n);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*m*n);\n\tmemset(visited, 0, sizeof(int)*m*n);\n\tint *distance = malloc(sizeof(int)*m*n);\n\tmemset(distance, 0, sizeof(int)*m*n);\n\t\n\tint i = 0, j = 0;\n\tint *row = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = 0;\n\tvisited[0] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\ti = vertex/n;\n\t\tj = vertex%n;\n\t\trow = grid[i];\n\t\tif(j + row[j] < n){\n\t\t\tif(visited[vertex + row[j]] == 0){\n\t\t\t\tqueue[rear++] = vertex + row[j];\n\t\t\t\tdistance[vertex + row[j]] = distance[vertex] + 1;\n\t\t\t}\n\t\t}\n\t\tif(i + grid[i][j] < m){\n\t\t\tif(visited[vertex + n*grid[i][j]] == 0){\n\t\t\t\tqueue[rear++] = vertex + n*grid[i][j];\n\t\t\t\tdistance[vertex + n*grid[i][j]] = distance[vertex] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn distance[m*n-1];\n}", "prefix": "int minimumVisitedCells(int** grid, int gridSize, int* gridColSize"}
{"id": "2241", "path": "output2\\c\\Hard\\2241-minimize-the-total-price-of-the-trips.c", "hypo_code": "int minimumTotalPrice(int n, int** edges, int edgesSize, int* edgesColSize, int* price, int priceSize, int** trips, int tripsSize, int* tripsColSize){\nint *queue = malloc(sizeof(int)*n);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*n);\n\tmemset(visited, 0, sizeof(int)*n);\n\tint *distance = malloc(sizeof(int)*n);\n\tmemset(distance, 0, sizeof(int)*n);\n\t\n\tint i = 0;\n\tint *edge = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = 0;\n\tvisited[0] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\tedge = edges[i++];\n\t\tif(edge[0] == vertex){\n\t\t\tif(visited[edge[1]] == 0){\n\t\t\t\tqueue[rear++] = edge[1];\n\t\t\t\tdistance[edge[1]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[1]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif(visited[edge[0]] == 0){\n\t\t\t\tqueue[rear++] = edge[0];\n\t\t\t\tdistance[edge[0]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[0]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int minimumTotalPrice(int n, int** edges, int edgesSize, int* edgesColSize, int* price, int priceSize, int** trips, int tripsSize, int* tripsColSize"}
{"id": "2243", "path": "output2\\c\\Hard\\2243-make-array-empty.c", "hypo_code": "long long countOperationsToEmptyArray(int* nums, int numsSize){\nint *queue = malloc(sizeof(int)*numsSize);\n\tint front = 0, rear = 0;\n\t\n\tint i = 0, j = 0;\n\tint *row = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = 0;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\ti = vertex/n;\n\t\tj = vertex%n;\n\t\trow = grid[i];\n\t\tif(j + row[j] < n){\n\t\t\tif(visited[vertex + row[j]] == 0){\n\t\t\t\tqueue[rear++] = vertex + row[j];\n\t\t\t\tdistance[vertex + row[j]] = distance[vertex] + 1;\n\t\t\t}\n\t\t}\n\t\tif(i + grid[i][j] < m){\n\t\t\tif(visited[vertex + n*grid[i][j]] == 0){\n\t\t\t\tqueue[rear++] = vertex + n*grid[i][j];\n\t\t\t\tdistance[vertex + n*grid[i][j]] = distance[vertex] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn distance[m*n-1];\n}", "prefix": "long long countOperationsToEmptyArray(int* nums, int numsSize"}
{"id": "2244", "path": "output2\\c\\Hard\\2244-lexicographically-smallest-beautiful-string.c", "hypo_code": "char * smallestBeautifulString(char * s, int k){\nint *queue = malloc(sizeof(int)*n);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*n);\n\tmemset(visited, 0, sizeof(int)*n);\n\tint *distance = malloc(sizeof(int)*n);\n\tmemset(distance, 0, sizeof(int)*n);\n\t\n\tint i = 0;\n\tint *edge = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = 0;\n\tvisited[0] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\tedge = edges[i++];\n\t\tif(edge[0] == vertex){\n\t\t\tif(visited[edge[1]] == 0){\n\t\t\t\tqueue[rear++] = edge[1];\n\t\t\t\tdistance[edge[1]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[1]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif(visited[edge[0]] == 0){\n\t\t\t\tqueue[rear++] = edge[0];\n\t\t\t\tdistance[edge[0]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[0]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "char * smallestBeautifulString(char * s, int k"}
{"id": "2245", "path": "output2\\c\\Hard\\2245-power-of-heroes.c", "hypo_code": "int sumOfPower(int* nums, int numsSize){\nint *queue = malloc(sizeof(int)*n);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*n);\n\tmemset(visited, 0, sizeof(int)*n);\n\tint *distance = malloc(sizeof(int)*n);\n\tmemset(distance, 0, sizeof(int)*n);\n\t\n\tint i = 0;\n\tint *edge = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = 0;\n\tvisited[0] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\tedge = edges[i++];\n\t\tif(edge[0] == vertex){\n\t\t\tif(visited[edge[1]] == 0){\n\t\t\t\tqueue[rear++] = edge[1];\n\t\t\t\tdistance[edge[1]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[1]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif(visited[edge[0]] == 0){\n\t\t\t\tqueue[rear++] = edge[0];\n\t\t\t\tdistance[edge[0]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[0]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int sumOfPower(int* nums, int numsSize"}
{"id": "2246", "path": "output2\\c\\Hard\\2246-modify-graph-edge-weights.c", "hypo_code": "int** modifiedGraphEdges(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination, int target, int* returnSize, int** returnColumnSizes){\nint** result = malloc(sizeof(int*)*edgesSize);\n\t*returnSize = 0;\n\t*returnColumnSizes = malloc(sizeof(int)*edgesSize);\n\t\n\tint* queue = malloc(sizeof(int)*edgesSize);\n\tint front = 0, rear = 0;\n\tint* visited = malloc(sizeof(int)*edgesSize);\n\tmemset(visited, 0, sizeof(int)*edgesSize);\n\tint* distance = malloc(sizeof(int)*edgesSize);\n\tmemset(distance, 0, sizeof(int)*edgesSize);\n\t\n\tint i = 0;\n\tint* edge = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = source;\n\tvisited[source] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\tedge = edges[i++];\n\t\tif(edge[0] == vertex){\n\t\t\tif(visited[edge[1]] == 0){\n\t\t\t\tqueue[rear++] = edge[1];\n\t\t\t\tdistance[edge[1]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[1]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif(visited[edge[0]] == 0){\n\t\t\t\tqueue[rear++] = edge[0];\n\t\t\t\tdistance[edge[0]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[0]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int** modifiedGraphEdges(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination, int target, int* returnSize, int** returnColumnSizes"}
{"id": "2247", "path": "output2\\c\\Hard\\2247-greatest-common-divisor-traversal.c", "hypo_code": "bool canTraverseAllPairs(int* nums, int numsSize){ \nint n = numsSize;\n\tint *queue = malloc(sizeof(int)*n);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*n);\n\tmemset(visited, 0, sizeof(int)*n);\n\tint *distance = malloc(sizeof(int)*n);\n\tmemset(distance, 0, sizeof(int)*n);\n\t\n\tint i = 0;\n\tint *edge = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = 0;\n\tvisited[0] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\tedge = edges[i++];\n\t\tif(edge[0] == vertex){\n\t\t\tif(visited[edge[1]] == 0){\n\t\t\t\tqueue[rear++] = edge[1];\n\t\t\t\tdistance[edge[1]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[1]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif(visited[edge[0]] == 0){\n\t\t\t\tqueue[rear++] = edge[0];\n\t\t\t\tdistance[edge[0]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[0]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "bool canTraverseAllPairs(int* nums, int numsSize"}
{"id": "2248", "path": "output2\\c\\Hard\\2248-maximum-strictly-increasing-cells-in-a-matrix.c", "hypo_code": "int maxIncreasingCells(int** mat, int matSize, int* matColSize){\nint m = matSize;\n\tint n = matColSize[0];\n\tint *queue = malloc(sizeof(int)*m*n);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*m*n);\n\tmemset(visited, 0, sizeof(int)*m*n);\n\tint *distance = malloc(sizeof(int)*m*n);\n\tmemset(distance, 0, sizeof(int)*m*n);\n\t\n\tint i = 0, j = 0;\n\tint *row = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = 0;\n\tvisited[0] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\ti = vertex/n;\n\t\tj = vertex%n;\n\t\trow = mat[i];\n\t\tif(j + row[j] < n){\n\t\t\tif(visited[vertex + row[j]] == 0){\n\t\t\t\tqueue[rear++] = vertex + row[j];\n\t\t\t\tdistance[vertex + row[j]] = distance[vertex] + 1;\n\t\t\t}\n\t\t}\n\t\tif(i + mat[i][j] < m){\n\t\t\tif(visited[vertex + n*mat[i][j]] == 0){\n\t\t\t\tqueue[rear++] = vertex + n*mat[i][j];\n\t\t\t\tdistance[vertex + n*mat[i][j]] = distance[vertex] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i = 0; i < m; i++){\n\t\tfor(j = 0; j < n; j++){\n\t\t\tif(distance[i*n + j] > result){\n\t\t\t\tresult = distance[i*n + j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result + 1;\n}", "prefix": "int maxIncreasingCells(int** mat, int matSize, int* matColSize"}
{"id": "2249", "path": "output2\\c\\Hard\\2249-count-of-integers.c", "hypo_code": "int count(char * num1, char * num2, int min_sum, int max_sum){\nint *queue = malloc(sizeof(int)*n);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*n);\n\tmemset(visited, 0, sizeof(int)*n);\n\tint *distance = malloc(sizeof(int)*n);\n\tmemset(distance, 0, sizeof(int)*n);\n\t\n\tint i = 0;\n\tint *edge = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = 0;\n\tvisited[0] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\tedge = edges[i++];\n\t\tif(edge[0] == vertex){\n\t\t\tif(visited[edge[1]] == 0){\n\t\t\t\tqueue[rear++] = edge[1];\n\t\t\t\tdistance[edge[1]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[1]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif(visited[edge[0]] == 0){\n\t\t\t\tqueue[rear++] = edge[0];\n\t\t\t\tdistance[edge[0]] = distance[vertex] + 1;\n\t\t\t} else {\n\t\t\t\tresult = distance[vertex] + distance[edge[0]] + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "prefix": "int count(char * num1, char * num2, int min_sum, int max_sum"}
{"id": "2250", "path": "output2\\c\\Hard\\2250-find-a-good-subset-of-the-matrix.c", "hypo_code": "int* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize){\nint *result = malloc(sizeof(int)*gridSize);\n\tmemset(result, 0, sizeof(int)*gridSize);\n\t*returnSize = gridSize;\n\t\n\tint *queue = malloc(sizeof(int)*gridSize);\n\tint front = 0, rear = 0;\n\tint *visited = malloc(sizeof(int)*gridSize);\n\tmemset(visited, 0, sizeof(int)*gridSize);\n\tint *distance = malloc(sizeof(int)*gridSize);\n\tmemset(distance, 0, sizeof(int)*gridSize);\n\t\n\tint i = 0;\n\tint *bannedVertex = NULL;\n\tint vertex = 0;\n\tint result = -1;\n\t\n\tqueue[rear++] = p;\n\tvisited[p] = 1;\n\t\n\twhile(front < rear){\n\t\tvertex = queue[front++];\n\t\tvisited[vertex] = 1;\n\t\tif(vertex == p){\n\t\t\tresult = 0;\n\t\t}\n\t\tbannedVertex = banned[i++];\n\t\tif(visited[bannedVertex] == 0){\n\t\t\tqueue[rear++] = bannedVertex;\n\t\t\tdistance[bannedVertex] = distance[vertex] + 1;\n\t\t} else {\n\t\t\tresult = distance[vertex] + distance[bannedVertex] + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(result == -1){\n\t\t*returnSize = 0;\n\t\treturn NULL;\n\t}\n\t\n\tresult = malloc(sizeof(int)*result);\n\tmemset(result, 0, sizeof(int)*result);\n\t\n\tresult[--result] = bannedVertex;\n\twhile(result > 0){\n\t\tresult--;\n\t\tvertex = queue[front++];\n\t\tif(distance[vertex] == result){\n\t\t\tresult[result] = vertex;\n\t\t} else {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t*returnSize = result;\n\treturn result;\n}", "prefix": "int* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize"}
{"id": "2251", "path": "output2\\c\\Hard\\2251-maximum-sum-queries.c", "hypo_code": "int* maximumSumQueries(int* nums1, int nums1Size, int* nums2, int nums2Size, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\nint *result = (int *)malloc(queriesSize*sizeof(int));\n    int i, j, max;\n    for (i=0; i<queriesSize; i++) {\n        max = -1;\n        for (j=0; j<nums1Size; j++) {\n            if (nums1[j]>=queries[i][0] && nums2[j]>=queries[i][1]) {\n                if (nums1[j]+nums2[j]>max) {\n                    max = nums1[j]+nums2[j];\n                }\n            }\n        }\n        result[i] = max;\n    }\n    *returnSize = queriesSize;\n    return result;\n}", "prefix": "int* maximumSumQueries(int* nums1, int nums1Size, int* nums2, int nums2Size, int** queries, int queriesSize, int* queriesColSize, int* returnSize"}
{"id": "2252", "path": "output2\\c\\Hard\\2252-painting-the-walls.c", "hypo_code": "int paintWalls(int* cost, int costSize, int* time, int timeSize){\nint i, j, min_cost, min_time;\n\tint *dp = (int *)malloc(costSize*sizeof(int));\n\tdp[0] = cost[0];\n\tfor (i=1; i<costSize; i++) {\n\t\tmin_cost = cost[i];\n\t\tmin_time = time[i];\n\t\tfor (j=i-1; j>=0; j--) {\n\t\t\tif (min_time>time[i]-time[j]) {\n\t\t\t\tif (dp[j]+cost[i]<min_cost) {\n\t\t\t\t\tmin_cost = dp[j]+cost[i];\n\t\t\t\t\tmin_time = time[i]-time[j];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdp[i] = min_cost;\n\t}\n\treturn dp[costSize-1];\n}", "prefix": "int paintWalls(int* cost, int costSize, int* time, int timeSize"}
{"id": "2253", "path": "output2\\c\\Hard\\2253-robot-collisions.c", "hypo_code": "int* survivedRobotsHealths(int* positions, int positionsSize, int* healths, int healthsSize, char * directions, int* returnSize){\nint *result = (int *)malloc(positionsSize*sizeof(int));\n\tint i, j, k, min;\n\tint *dp = (int *)malloc(positionsSize*sizeof(int));\n\tchar *directions2 = (char *)malloc(positionsSize*sizeof(char));\n\tfor (i=0; i<positionsSize; i++) {\n\t\tdp[i] = healths[i];\n\t\tdirections2[i] = directions[i];\n\t}\n\tfor (i=0; i<positionsSize; i++) {\n\t\tif (directions2[i]=='R') {\n\t\t\tfor (j=i+1; j<positionsSize; j++) {\n\t\t\t\tif (positions[j]>positions[i]) {\n\t\t\t\t\tif (positions[j]-positions[i]<dp[i]) {\n\t\t\t\t\t\tdp[i] -= positions[j]-positions[i];\n\t\t\t\t\t\tdp[j] -= positions[j]-positions[i];\n\t\t\t\t\t} else if (positions[j]-positions[i]==dp[i]) {\n\t\t\t\t\t\tdp[i] = 0;\n\t\t\t\t\t\tdp[j] -= positions[j]-positions[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[j] -= dp[i];\n\t\t\t\t\t\tdp[i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=i-1; j>=0; j--) {\n\t\t\t\tif (positions[j]<positions[i]) {\n\t\t\t\t\tif (positions[i]-positions[j]<dp[i]) {\n\t\t\t\t\t\tdp[i] -= positions[i]-positions[j];\n\t\t\t\t\t\tdp[j] -= positions[i]-positions[j];\n\t\t\t\t\t} else if (positions[i]-positions[j]==dp[i]) {\n\t\t\t\t\t\tdp[i] = 0;\n\t\t\t\t\t\tdp[j] -= positions[i]-positions[j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[j] -= dp[i];\n\t\t\t\t\t\tdp[i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0; i<positionsSize; i++) {\n\t\tif (dp[i]>0) {\n\t\t\tresult[k++] = dp[i];\n\t\t}\n\t}\n\t*returnSize = k;\n\treturn result;\n}", "prefix": "int* survivedRobotsHealths(int* positions, int positionsSize, int* healths, int healthsSize, char * directions, int* returnSize"}
{"id": "2254", "path": "output2\\c\\Hard\\2254-sum-of-imbalance-numbers-of-all-subarrays.c", "hypo_code": "int sumImbalanceNumbers(int* nums, int numsSize){\nint i, j, k, l, m, n, sum, min, max, *dp, *dp2;\n    dp = (int *)malloc(numsSize*sizeof(int));\n    dp2 = (int *)malloc(numsSize*sizeof(int));\n    for (i=0; i<numsSize; i++) {\n        dp[i] = 0;\n        dp2[i] = 0;\n    }\n    for (i=0; i<numsSize; i++) {\n        min = nums[i];\n        max = nums[i];\n        for (j=i; j>=0; j--) {\n            if (nums[j]<min) {\n                min = nums[j];\n            }\n            if (nums[j]>max) {\n                max = nums[j];\n            }\n            if (max-min>1) {\n                dp[i] += 1;\n            }\n        }\n    }\n    for (i=0; i<numsSize; i++) {\n        min = nums[i];\n        max = nums[i];\n        for (j=i; j<numsSize; j++) {\n            if (nums[j]<min) {\n                min = nums[j];\n            }\n            if (nums[j]>max) {\n                max = nums[j];\n            }\n            if (max-min>1) {\n                dp2[i] += 1;\n            }\n        }\n    }\n    sum = 0;\n    for (i=0; i<numsSize; i++) {\n        sum += dp[i]+dp2[i];\n    }\n    return sum;\n}", "prefix": "int sumImbalanceNumbers(int* nums, int numsSize"}
{"id": "2255", "path": "output2\\c\\Hard\\2255-length-of-the-longest-valid-substring.c", "hypo_code": "int longestValidSubstring(char * word, char ** forbidden, int forbiddenSize){\nint i, j, k, l, m, n, count, max;\n    for (i=0; i<forbiddenSize; i++) {\n        l = strlen(forbidden[i]);\n        for (j=0; j<strlen(word); j++) {\n            if (word[j]==forbidden[i][0]) {\n                count = 1;\n                for (k=1; k<l; k++) {\n                    if (word[j+k]==forbidden[i][k]) {\n                        count++;\n                    }\n                }\n                if (count==l) {\n                    for (k=0; k<l; k++) {\n                        word[j+k] = '\\0';\n                    }\n                }\n            }\n        }\n    }\n    max = 0;\n    count = 0;\n    for (i=0; i<strlen(word); i++) {\n        if (word[i]!='\\0') {\n            count++;\n        } else {\n            if (count>max) {\n                max = count;\n            }\n            count = 0;\n        }\n    }\n    if (count>max) {\n        max = count;\n    }\n    return max;\n}", "prefix": "int longestValidSubstring(char * word, char ** forbidden, int forbiddenSize"}
{"id": "2256", "path": "output2\\c\\Hard\\2256-maximum-number-of-groups-with-increasing-length.c", "hypo_code": "int maxIncreasingGroups(int* usageLimits, int usageLimitsSize){\nint i, j, min, max;\n\tint *dp = (int *)malloc(usageLimitsSize*sizeof(int));\n\tdp[0] = usageLimits[0];\n\tfor (i=1; i<usageLimitsSize; i++) {\n\t\tmin = usageLimits[i];\n\t\tmax = usageLimits[i];\n\t\tfor (j=i-1; j>=0; j--) {\n\t\t\tif (min>usageLimits[i]-usageLimits[j]) {\n\t\t\t\tif (dp[j]+usageLimits[i]<min) {\n\t\t\t\t\tmin = dp[j]+usageLimits[i];\n\t\t\t\t\tmax = usageLimits[i]-usageLimits[j];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdp[i] = min;\n\t}\n\treturn dp[usageLimitsSize-1];\n}", "prefix": "int maxIncreasingGroups(int* usageLimits, int usageLimitsSize"}
{"id": "2257", "path": "output2\\c\\Hard\\2257-count-paths-that-can-form-a-palindrome-in-a-tree.c", "hypo_code": "long long countPalindromePaths(int* parent, int parentSize, char * s){\nint i, j, k, l, m, n, count, max, *dp;\n    dp = (int *)malloc(parentSize*sizeof(int));\n    for (i=0; i<parentSize; i++) {\n        dp[i] = 0;\n    }\n    for (i=0; i<parentSize; i++) {\n        if (parent[i]>=0) {\n            dp[parent[i]]++;\n        }\n    }\n    for (i=0; i<parentSize; i++) {\n        if (dp[i]==0) {\n            dp[i] = 1;\n        }\n    }\n    for (i=0; i<parentSize; i++) {\n        if (parent[i]>=0) {\n            dp[i] *= dp[parent[i]];\n        }\n    }\n    count = 0;\n    for (i=0; i<parentSize; i++) {\n        if (parent[i]>=0 && dp[i]%2==1) {\n            count++;\n        }\n    }\n    if (count>1) {\n        return 0;\n    }\n    return 1;\n}", "prefix": "long long countPalindromePaths(int* parent, int parentSize, char * s"}
{"id": "2258", "path": "output2\\c\\Hard\\2258-count-stepping-numbers-in-range.c", "hypo_code": "int countSteppingNumbers(char * low, char * high){\nint i, j, k, l, m, n, count, max, *dp;\n    dp = (int *)malloc(usageLimitsSize*sizeof(int));\n    dp[0] = usageLimits[0];\n    for (i=1; i<usageLimitsSize; i++) {\n        min = usageLimits[i];\n        max = usageLimits[i];\n        for (j=i-1; j>=0; j--) {\n            if (min>usageLimits[i]-usageLimits[j]) {\n                if (dp[j]+usageLimits[i]<min) {\n                    min = dp[j]+usageLimits[i];\n                    max = usageLimits[i]-usageLimits[j];\n                }\n            } else {\n                break;\n            }\n        }\n        dp[i] = min;\n    }\n    return dp[usageLimitsSize-1];\n}", "prefix": "int countSteppingNumbers(char * low, char * high"}
{"id": "2259", "path": "output2\\c\\Hard\\2259-minimum-time-to-make-array-sum-at-most-x.c", "hypo_code": "int minimumTime(int* nums1, int nums1Size, int* nums2, int nums2Size, int x){\nint i, j, k, l, m, n, sum, min, max, *dp, *dp2;\n    dp = (int *)malloc(numsSize*sizeof(int));\n    dp2 = (int *)malloc(numsSize*sizeof(int));\n    for (i=0; i<numsSize; i++) {\n        dp[i] = 0;\n        dp2[i] = 0;\n    }\n    for (i=0; i<numsSize; i++) {\n        min = nums[i];\n        max = nums[i];\n        for (j=i; j>=0; j--) {\n            if (nums[j]<min) {\n                min = nums[j];\n            }\n            if (nums[j]>max) {\n                max = nums[j];\n            }\n            if (max-min>1) {\n                dp[i] += 1;\n            }\n        }\n    }\n    for (i=0; i<numsSize; i++) {\n        min = nums[i];\n        max = nums[i];\n        for (j=i; j<numsSize; j++) {\n            if (nums[j]<min) {\n                min = nums[j];\n            }\n            if (nums[j]>max) {\n                max = nums[j];\n            }\n            if (max-min>1) {\n                dp2[i] += 1;\n            }\n        }\n    }\n    for (i=0; i<numsSize; i++) {\n        if (dp[i]+dp2[i]>max) {\n            max = dp[i]+dp2[i];\n        }\n    }\n    return max;\n}", "prefix": "int minimumTime(int* nums1, int nums1Size, int* nums2, int nums2Size, int x"}
{"id": "2260", "path": "output2\\c\\Hard\\2260-maximum-elegance-of-a-k-length-subsequence.c", "hypo_code": "long long findMaximumElegance(int** items, int itemsSize, int* itemsColSize, int k){\nint i, j, l, m, n, max, *dp;\n    dp = (int *)malloc(itemsSize*sizeof(int));\n    for (i=0; i<itemsSize; i++) {\n        dp[i] = items[i][0];\n        for (j=i-1; j>=0; j--) {\n            if (items[i][1]==items[j][1]) {\n                if (dp[j]+items[i][0]>dp[i]) {\n                    dp[i] = dp[j]+items[i][0];\n                }\n            } else {\n                if (dp[j]+items[i][0]+(items[j][1]-items[i][1])*(items[j][1]-items[i][1])>dp[i]) {\n                    dp[i] = dp[j]+items[i][0]+(items[j][1]-items[i][1])*(items[j][1]-items[i][1]);\n                }\n            }\n        }\n    }\n    max = 0;\n    for (i=0; i<itemsSize; i++) {\n        if (dp[i]>max) {\n            max = dp[i];\n        }\n    }\n    return max;\n}", "prefix": "long long findMaximumElegance(int** items, int itemsSize, int* itemsColSize, int k"}
{"id": "2261", "path": "output2\\c\\Hard\\2261-apply-operations-to-maximize-score.c", "hypo_code": "int maximumScore(int* nums, int numsSize, int k){\nint i, j, k, l, m, n, count, max, *dp;\n    dp = (int *)malloc(usageLimitsSize*sizeof(int));\n    dp[0] = usageLimits[0];\n    for (i=1; i<usageLimitsSize; i++) {\n        min = usageLimits[i];\n        max = usageLimits[i];\n        for (j=i-1; j>=0; j--) {\n            if (min>usageLimits[i]-usageLimits[j]) {\n                if (dp[j]+usageLimits[i]<min) {\n                    min = dp[j]+usageLimits[i];\n                    max = usageLimits[i]-usageLimits[j];\n                }\n            } else {\n                break;\n            }\n        }\n        dp[i] = min;\n    }\n    return dp[usageLimitsSize-1];\n}", "prefix": "int maximumScore(int* nums, int numsSize, int k"}
