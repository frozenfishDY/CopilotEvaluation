{"id": "1", "path": "output2\\java\\Easy\\1-two-sum.java", "hypo_code": "class TwoSum {\n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        for(int i = 0; i < nums.length; i++){\n            for(int j = i + 1; j < nums.length; j++){\n                if(nums[i] + nums[j] == target){\n                    result[0] = i;\n                    result[1] = j;\n                    return result;\n                }\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "2", "path": "output2\\java\\Easy\\2-palindrome-number.java", "hypo_code": "class PalindromeNumber {\n    public boolean isPalindrome(int x) {\n        if(x < 0){\n            return false;\n        }\n        int reverse = 0;\n        int original = x;\n        while(x != 0){\n            reverse = reverse * 10 + x % 10;\n            x = x / 10;\n        }\n        return reverse == original;\n        \n        \n    }\n}"}
{"id": "3", "path": "output2\\java\\Easy\\3-roman-to-integer.java", "hypo_code": "class RomanToInteger {\n    public int romanToInt(String s) {\n        int result = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == 'I'){\n                if(i + 1 < s.length() && s.charAt(i + 1) == 'V'){\n                    result += 4;\n                    i++;\n                }else if(i + 1 < s.length() && s.charAt(i + 1) == 'X'){\n                    result += 9;\n                    i++;\n                }else{\n                    result += 1;\n                }\n            }else if(s.charAt(i) == 'V'){\n                result += 5;\n            }else if(s.charAt(i) == 'X'){\n                if(i + 1 < s.length() && s.charAt(i + 1) == 'L'){\n                    result += 40;\n                    i++;\n                }else if(i + 1 < s.length() && s.charAt(i + 1) == 'C'){\n                    result += 90;\n                    i++;\n                }else{\n                    result += 10;\n                }\n            }else if(s.charAt(i) == 'L'){\n                result += 50;\n            }else if(s.charAt(i) == 'C'){\n                if(i + 1 < s.length() && s.charAt(i + 1) == 'D'){\n                    result += 400;\n                    i++;\n                }else if(i + 1 < s.length() && s.charAt(i + 1) == 'M'){\n                    result += 900;\n                    i++;\n                }else{\n                    result += 100;\n                }\n            }else if(s.charAt(i) == 'D'){\n                result += 500;\n            }else if(s.charAt(i) == 'M'){\n                result += 1000;\n            }\n        }\n        return result;\n        \n       \n        \n    }\n}"}
{"id": "4", "path": "output2\\java\\Easy\\4-longest-common-prefix.java", "hypo_code": "class LongestCommonPrefix {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs.length == 0){\n            return \"\";\n        }\n        String prefix = strs[0];\n        for(int i = 1; i < strs.length; i++){\n            while(strs[i].indexOf(prefix) != 0){\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if(prefix.isEmpty()){\n                    return \"\";\n                }\n            }\n        }\n        return prefix;\n        \n    }\n}"}
{"id": "5", "path": "output2\\java\\Easy\\5-valid-parentheses.java", "hypo_code": "class ValidParentheses {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if(c == '(' || c == '{' || c == '['){\n                stack.push(c);\n            }else{\n                if(stack.isEmpty()){\n                    return false;\n                }\n                char top = stack.pop();\n                if(c == ')' && top != '('){\n                    return false;\n                }\n                if(c == '}' && top != '{'){\n                    return false;\n                }\n                if(c == ']' && top != '['){\n                    return false;\n                }\n            }\n        }\n        return stack.isEmpty();\n        \n        \n    }\n}"}
{"id": "6", "path": "output2\\java\\Easy\\6-merge-two-sorted-lists.java", "hypo_code": "class MergeTwoSortedLists {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode head = new ListNode(0);\n        ListNode current = head;\n        while(list1 != null && list2 != null){\n            if(list1.val < list2.val){\n                current.next = list1;\n                list1 = list1.next;\n            }else{\n                current.next = list2;\n                list2 = list2.next;\n            }\n            current = current.next;\n        }\n        if(list1 != null){\n            current.next = list1;\n        }\n        if(list2 != null){\n            current.next = list2;\n        }\n        return head.next;\n       \n        \n    }\n}"}
{"id": "7", "path": "output2\\java\\Easy\\7-remove-duplicates-from-sorted-array.java", "hypo_code": "class RemoveDuplicatesFromSortedArray {\n    public int removeDuplicates(int[] nums) {\n        int i = 0;\n        for(int j = 1; j < nums.length; j++){\n            if(nums[j] != nums[i]){\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i + 1;\n        \n    }\n}"}
{"id": "8", "path": "output2\\java\\Easy\\8-remove-element.java", "hypo_code": "class RemoveElement {\n    public int removeElement(int[] nums, int val) {\n        int i = 0;\n        for(int j = 0; j < nums.length; j++){\n            if(nums[j] != val){\n                nums[i] = nums[j];\n                i++;\n            }\n        }\n        return i;\n        \n    }\n}"}
{"id": "9", "path": "output2\\java\\Easy\\9-find-the-index-of-the-first-occurrence-in-a-string.java", "hypo_code": "class Solution {\n    public int strStr(String haystack, String needle) { \n        if (needle.length() == 0) return 0;\n        if (haystack.length() == 0) return -1;\n        int index = -1;\n        for (int i = 0; i < haystack.length(); i++) {\n            if (haystack.charAt(i) == needle.charAt(0) && haystack.length() - i >= needle.length()) {\n                index = i;\n                for (int j = 0; j < needle.length(); j++) {\n                    if (haystack.charAt(i + j) != needle.charAt(j)) {\n                        index = -1;\n                        break;\n                    }\n                }\n                if (index != -1) return index;\n            }\n        }\n        return index;\n\n    }\n}"}
{"id": "10", "path": "output2\\java\\Easy\\10-search-insert-position.java", "hypo_code": "class SearchInsertPosition {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            else if(nums[mid] < target){\n                left = mid + 1;\n            }\n            else{\n                right = mid - 1;\n            }\n        }\n        return left;\n        \n    }\n}"}
{"id": "11", "path": "output2\\java\\Easy\\11-length-of-last-word.java", "hypo_code": "class LengthOfLastWord {\n    public int lengthOfLastWord(String s) {\n        int count = 0;\n        for(int i = s.length() - 1; i >= 0; i--){\n            if(s.charAt(i) == ' '){\n                if(count == 0){\n                    continue;\n                }else{\n                    break;\n                }\n            }\n            count++;\n        }\n        return count;\n        \n    }\n}"}
{"id": "12", "path": "output2\\java\\Easy\\12-plus-one.java", "hypo_code": "class PlusOne {\n    public int[] plusOne(int[] digits) {\n        int carry = 1;\n        for(int i = digits.length - 1; i >= 0; i--){\n            int sum = digits[i] + carry;\n            digits[i] = sum % 10;\n            carry = sum / 10;\n        }\n        if(carry == 1){\n            int[] result = new int[digits.length + 1];\n            result[0] = 1;\n            for(int i = 1; i < result.length; i++){\n                result[i] = digits[i - 1];\n            }\n            return result;\n        }\n        return digits;\n        \n    }\n}"}
{"id": "13", "path": "output2\\java\\Easy\\13-add-binary.java", "hypo_code": "class AddBinary {\n    public String addBinary(String a, String b) {\n        int carry = 0;\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n        StringBuilder sb = new StringBuilder();\n        while(i >= 0 || j >= 0){\n            int sum = carry;\n            if(i >= 0){\n                sum += a.charAt(i) - '0';\n                i--;\n            }\n            if(j >= 0){\n                sum += b.charAt(j) - '0';\n                j--;\n            }\n            sb.append(sum % 2);\n            carry = sum / 2;\n        }\n        if(carry == 1){\n            sb.append(1);\n        }\n        return sb.reverse().toString();\n        \n    }\n}"}
{"id": "14", "path": "output2\\java\\Easy\\14-sqrtx.java", "hypo_code": "class Sqrtx {\n    public int mySqrt(int x) {\n        if(x == 0){\n            return 0;\n        }\n        int left = 1;\n        int right = x;\n        while(left < right){\n            int mid = left + (right - left) / 2;\n            if(mid > x / mid){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left - 1;\n        \n    }\n}"}
{"id": "15", "path": "output2\\java\\Easy\\15-climbing-stairs.java", "hypo_code": "class ClimbingStairs {\n    public int climbStairs(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i = 2; i <= n; i++){\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n        \n    }\n}"}
{"id": "16", "path": "output2\\java\\Easy\\16-remove-duplicates-from-sorted-list.java", "hypo_code": "class RemoveDuplicatesFromSortedList {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head;\n        while(cur != null && cur.next != null){\n            if(cur.val == cur.next.val){\n                cur.next = cur.next.next;\n            }else{\n                cur = cur.next;\n            }\n        }\n        return head;\n        \n    }\n}"}
{"id": "17", "path": "output2\\java\\Easy\\17-merge-sorted-array.java", "hypo_code": "class MergeSortedArray {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n        while(i >= 0 && j >= 0){\n            if(nums1[i] > nums2[j]){\n                nums1[k] = nums1[i];\n                i--;\n            }else{\n                nums1[k] = nums2[j];\n                j--;\n            }\n            k--;\n        }\n        while(j >= 0){\n            nums1[k] = nums2[j];\n            j--;\n            k--;\n        }\n        \n        \n    }\n}"}
{"id": "18", "path": "output2\\java\\Easy\\18-binary-tree-inorder-traversal.java", "hypo_code": "class BinaryTreeInorderTraversal {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode cur = root;\n        while(cur != null || !stack.isEmpty()){\n            while(cur != null){\n                stack.push(cur);\n                cur = cur.left;\n            }\n            cur = stack.pop();\n            res.add(cur.val);\n            cur = cur.right;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "19", "path": "output2\\java\\Easy\\19-same-tree.java", "hypo_code": "class SameTree {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null){\n            return true;\n        }\n        if(p == null || q == null){\n            return false;\n        }\n        if(p.val != q.val){\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        \n    }\n}"}
{"id": "20", "path": "output2\\java\\Easy\\20-symmetric-tree.java", "hypo_code": "class SymmetricTree {\n    public boolean isSymmetric(TreeNode root) {\n        return isMirror(root, root);\n        \n    }\n}"}
{"id": "21", "path": "output2\\java\\Easy\\21-maximum-depth-of-binary-tree.java", "hypo_code": "class MaximumDepthOfBinaryTree {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n        \n        \n    }\n}"}
{"id": "22", "path": "output2\\java\\Easy\\22-convert-sorted-array-to-binary-search-tree.java", "hypo_code": "class ConvertSortedArrayToBinarySearchTree {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return helper(nums, 0, nums.length - 1);\n        \n\n    }\n}"}
{"id": "23", "path": "output2\\java\\Easy\\23-balanced-binary-tree.java", "hypo_code": "class BalancedBinaryTree {\n    public boolean isBalanced(TreeNode root) {\n        return helper(root) != -1;\n        \n        \n    }\n}"}
{"id": "24", "path": "output2\\java\\Easy\\24-minimum-depth-of-binary-tree.java", "hypo_code": "class MinimumDepthOfBinaryTree {\n    public int minDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        if(root.left == null && root.right == null){\n            return 1;\n        }\n        int min_depth = Integer.MAX_VALUE;\n        if(root.left != null){\n            min_depth = Math.min(minDepth(root.left), min_depth);\n        }\n        if(root.right != null){\n            min_depth = Math.min(minDepth(root.right), min_depth);\n        }\n        return min_depth + 1;\n    }\n}"}
{"id": "25", "path": "output2\\java\\Easy\\25-path-sum.java", "hypo_code": "class PathSum {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if(root == null){\n            return false;\n        }\n        if(root.left == null && root.right == null){\n            return targetSum == root.val;\n        }\n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n        \n        \n    }\n}"}
{"id": "26", "path": "output2\\java\\Easy\\26-pascals-triangle.java", "hypo_code": "class PascalsTriangle {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> res = new ArrayList<>();\n        for(int i = 0; i < numRows; i++){\n            List<Integer> row = new ArrayList<>();\n            for(int j = 0; j <= i; j++){\n                if(j == 0 || j == i){\n                    row.add(1);\n                }else{\n                    row.add(res.get(i - 1).get(j - 1) + res.get(i - 1).get(j));\n                }\n            }\n            res.add(row);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "27", "path": "output2\\java\\Easy\\27-pascals-triangle-ii.java", "hypo_code": "class PascalsTriangleIi {\n    public List<Integer> getRow(int rowIndex) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = 0; i <= rowIndex; i++){\n            res.add(0, 1);\n            for(int j = 1; j < res.size() - 1; j++){\n                res.set(j, res.get(j) + res.get(j + 1));\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "28", "path": "output2\\java\\Easy\\28-best-time-to-buy-and-sell-stock.java", "hypo_code": "class BestTimeToBuyAndSellStock {\n    public int maxProfit(int[] prices) {\n        int min = Integer.MAX_VALUE;\n        int max = 0;\n        for(int i = 0; i < prices.length; i++){\n            if(prices[i] < min){\n                min = prices[i];\n            }else if(prices[i] - min > max){\n                max = prices[i] - min;\n            }\n        }\n        return max;\n        \n    }\n}"}
{"id": "29", "path": "output2\\java\\Easy\\29-valid-palindrome.java", "hypo_code": "class ValidPalindrome {\n    public boolean isPalindrome(String s) {\n        int i = 0;\n        int j = s.length() - 1;\n        while(i < j){\n            char c1 = s.charAt(i);\n            char c2 = s.charAt(j);\n            if(!Character.isLetterOrDigit(c1)){\n                i++;\n                continue;\n            }\n            if(!Character.isLetterOrDigit(c2)){\n                j--;\n                continue;\n            }\n            if(Character.toLowerCase(c1) != Character.toLowerCase(c2)){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n        \n    }\n}"}
{"id": "30", "path": "output2\\java\\Easy\\30-single-number.java", "hypo_code": "class SingleNumber {\n    public int singleNumber(int[] nums) {\n        int res = 0;\n        for(int i = 0; i < nums.length; i++){\n            res ^= nums[i];\n        }\n        return res;\n        \n    }\n}"}
{"id": "31", "path": "output2\\java\\Easy\\31-linked-list-cycle.java", "hypo_code": "public class LinkedListCycle {\n    public boolean hasCycle(ListNode head) {\n        if(head == null || head.next == null) return false;\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while(slow != fast){\n            if(fast == null || fast.next == null) return false;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n        \n    }\n}"}
{"id": "32", "path": "output2\\java\\Easy\\32-binary-tree-preorder-traversal.java", "hypo_code": "class BinaryTreePreorderTraversal {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) return res;\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        while(!stack.isEmpty()){\n            TreeNode node = stack.pop();\n            res.add(node.val);\n            if(node.right != null) stack.push(node.right);\n            if(node.left != null) stack.push(node.left);\n        }\n        return res;\n        \n    }\n}"}
{"id": "33", "path": "output2\\java\\Easy\\33-binary-tree-postorder-traversal.java", "hypo_code": "class BinaryTreePostorderTraversal {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) return res;\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        while(!stack.isEmpty()){\n            TreeNode node = stack.pop();\n            res.add(node.val);\n            if(node.left != null) stack.push(node.left);\n            if(node.right != null) stack.push(node.right);\n        }\n        Collections.reverse(res);\n        return res;\n        \n        \n    }\n}"}
{"id": "34", "path": "output2\\java\\Easy\\34-intersection-of-two-linked-lists.java", "hypo_code": "public class IntersectionOfTwoLinkedLists {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b){\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n        \n        \n    }\n}"}
{"id": "35", "path": "output2\\java\\Easy\\35-excel-sheet-column-title.java", "hypo_code": "class Solution {\n    public String convertToTitle(int columnNumber) {\n        String result = \"\";\n        while (columnNumber > 0) {\n            int remainder = columnNumber % 26;\n            if (remainder == 0) {\n                result = \"Z\" + result;\n                columnNumber = columnNumber / 26 - 1;\n            } else {\n                result = (char) (remainder + 64) + result;\n                columnNumber = columnNumber / 26;\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "36", "path": "output2\\java\\Easy\\36-majority-element.java", "hypo_code": "class Solution {\n    public int majorityElement(int[] nums) {\n        int count = 0;\n        int candidate = 0;\n        for (int num : nums) {\n            if (count == 0) candidate = num;\n            if (num == candidate) count++;\n            else count--;\n        }\n        return candidate;\n        \n    }\n}"}
{"id": "37", "path": "output2\\java\\Easy\\37-excel-sheet-column-number.java", "hypo_code": "class Solution {\n    public int titleToNumber(String columnTitle) {\n        int result = 0;\n        for (int i = 0; i < columnTitle.length(); i++) {\n            result = result * 26 + (columnTitle.charAt(i) - 64);\n        }\n        return result;\n        \n    }\n}"}
{"id": "42", "path": "output2\\java\\Easy\\42-reverse-bits.java", "hypo_code": "public class Solution {\n    \n    public int reverseBits(int n) {\n        int result = 0; \n        for (int i = 0; i < 32; i++) {\n            result = (result << 1) | (n & 1);\n            n = n >> 1;\n        }\n        return result;\n\n\n        \n    }\n}"}
{"id": "43", "path": "output2\\java\\Easy\\43-number-of-1-bits.java", "hypo_code": "public class Solution {\n    \n    public int hammingWeight(int n) {\n        int result = 0; \n        while (n != 0) {\n            result += n & 1;\n            n = n >>> 1;\n        }\n        return result;\n        \n    }\n}"}
{"id": "48", "path": "output2\\java\\Easy\\48-happy-number.java", "hypo_code": "class Solution {\n    public boolean isHappy(int n) {\n        int slow = n;\n        int fast = n;\n        do {\n            slow = squareSum(slow);\n            fast = squareSum(fast);\n            fast = squareSum(fast);\n        } while (slow != fast);\n        return slow == 1;\n    }\n    private int squareSum(int n) {\n        int result = 0;\n        while (n > 0) {\n            int remainder = n % 10;\n            result += remainder * remainder;\n            n /= 10;\n        }\n        return result;\n\n\n        \n    }\n}"}
{"id": "49", "path": "output2\\java\\Easy\\49-remove-linked-list-elements.java", "hypo_code": "class RemoveLinkedListElements {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy;\n        while(cur.next != null){\n            if(cur.next.val == val){\n                cur.next = cur.next.next;\n            }else{\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n        \n    }\n}"}
{"id": "50", "path": "output2\\java\\Easy\\50-isomorphic-strings.java", "hypo_code": "class IsomorphicStrings {\n    public boolean isIsomorphic(String s, String t) {\n        if(s.length() != t.length()) return false;\n        Map<Character, Character> map = new HashMap<>();\n        for(int i = 0; i < s.length(); i++){\n            char c1 = s.charAt(i);\n            char c2 = t.charAt(i);\n            if(map.containsKey(c1)){\n                if(map.get(c1) != c2) return false;\n            }else{\n                if(map.containsValue(c2)) return false;\n                map.put(c1, c2);\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "51", "path": "output2\\java\\Easy\\51-reverse-linked-list.java", "hypo_code": "class ReverseLinkedList {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode cur = head;\n        while(cur != null){\n            ListNode next = cur.next;\n            cur.next = prev;\n            prev = cur;\n            cur = next;\n        }\n        return prev;\n        \n        \n    }\n}"}
{"id": "52", "path": "output2\\java\\Easy\\52-contains-duplicate.java", "hypo_code": "class ContainsDuplicate {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for(int i = 0; i < nums.length; i++){\n            if(set.contains(nums[i])) return true;\n            set.add(nums[i]);\n        }\n        return false;\n        \n    }\n}"}
{"id": "53", "path": "output2\\java\\Easy\\53-contains-duplicate-ii.java", "hypo_code": "class ContainsDuplicateIi {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if(map.containsKey(nums[i])){\n                if(i - map.get(nums[i]) <= k) return true;\n            }\n            map.put(nums[i], i);\n        }\n        return false;\n        \n        \n    }\n}"}
{"id": "54", "path": "output2\\java\\Easy\\54-count-complete-tree-nodes.java", "hypo_code": "class Solution {\n    public int countNodes(TreeNode root) { \n        if (root == null) return 0;\n        int leftHeight = 0;\n        int rightHeight = 0;\n        TreeNode left = root.left;\n        TreeNode right = root.right;\n        while (left != null) {\n            leftHeight++;\n            left = left.left;\n        }\n        while (right != null) {\n            rightHeight++;\n            right = right.right;\n        }\n        if (leftHeight == rightHeight) return (int) Math.pow(2, leftHeight + 1) - 1;\n        return countNodes(root.left) + countNodes(root.right) + 1;\n\n         \n    }\n}"}
{"id": "56", "path": "output2\\java\\Easy\\56-invert-binary-tree.java", "hypo_code": "class InvertBinaryTree {\n    public TreeNode invertTree(TreeNode root) {\n        if(root == null) return null;\n        TreeNode left = invertTree(root.left);\n        TreeNode right = invertTree(root.right);\n        root.left = right;\n        root.right = left;\n        return root;\n        \n    }\n}"}
{"id": "57", "path": "output2\\java\\Easy\\57-summary-ranges.java", "hypo_code": "class SummaryRanges {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> result = new ArrayList<>();\n        if(nums.length == 0) return result;\n        int start = nums[0];\n        int end = nums[0];\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] == end + 1){\n                end = nums[i];\n            }else{\n                if(start == end){\n                    result.add(String.valueOf(start));\n                }else{\n                    result.add(start + \"->\" + end);\n                }\n                start = nums[i];\n                end = nums[i];\n            }\n        }\n        if(start == end){\n            result.add(String.valueOf(start));\n        }else{\n            result.add(start + \"->\" + end);\n        }\n        return result;\n        \n    }\n}"}
{"id": "58", "path": "output2\\java\\Easy\\58-power-of-two.java", "hypo_code": "class PowerOfTwo {\n    public boolean isPowerOfTwo(int n) {\n        if(n == 0) return false;\n        while(n % 2 == 0){\n            n /= 2;\n        }\n        return n == 1;\n        \n    }\n}"}
{"id": "60", "path": "output2\\java\\Easy\\60-palindrome-linked-list.java", "hypo_code": "class PalindromeLinkedList {\n    public boolean isPalindrome(ListNode head) {\n        if(head == null || head.next == null) return true;\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode prev = null;\n        ListNode curr = slow;\n        while(curr != null){\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        ListNode p1 = head;\n        ListNode p2 = prev;\n        while(p1 != null && p2 != null){\n            if(p1.val != p2.val){\n                return false;\n            }\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return true;\n        \n        \n    }\n}"}
{"id": "61", "path": "output2\\java\\Easy\\61-valid-anagram.java", "hypo_code": "class ValidAnagram {\n    public boolean isAnagram(String s, String t) {\n        if(s.length() != t.length()) return false;\n        int[] count = new int[26];\n        for(int i = 0; i < s.length(); i++){\n            count[s.charAt(i) - 'a']++;\n            count[t.charAt(i) - 'a']--;\n        }\n        for(int i = 0; i < 26; i++){\n            if(count[i] != 0) return false;\n        }\n        return true;\n        \n    }\n}"}
{"id": "62", "path": "output2\\java\\Easy\\62-binary-tree-paths.java", "hypo_code": "class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n\t\tif (root == null) return result;\n\t\tif (root.left == null && root.right == null) {\n\t\t\tresult.add(String.valueOf(root.val));\n\t\t\treturn result;\n\t\t}\n\t\tfor (String path : binaryTreePaths(root.left)) {\n\t\t\tresult.add(root.val + \"->\" + path);\n\t\t}\n\t\tfor (String path : binaryTreePaths(root.right)) {\n\t\t\tresult.add(root.val + \"->\" + path);\n\t\t}\n\t\treturn result;\n        \n    }\n}"}
{"id": "63", "path": "output2\\java\\Easy\\63-add-digits.java", "hypo_code": "class Solution {\n    public int addDigits(int num) {\n        if (num == 0) return 0;\n          return num % 9 == 0 ? 9 : num % 9;\n    }\n}"}
{"id": "64", "path": "output2\\java\\Easy\\64-ugly-number.java", "hypo_code": "class Solution {\n    public boolean isUgly(int n) {    \n        if (n <= 0) return false;\n        while (n != 1) {\n            if (n % 5 == 0) {\n                n /= 5;\n            }\n            else if (n % 3 == 0) {\n                n /= 3;\n            }\n            else if (n % 2 == 0) {\n                n /= 2;\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "65", "path": "output2\\java\\Easy\\65-missing-number.java", "hypo_code": "class Solution {\n    public int missingNumber(int[] nums) {\n        int sum = 0;\n        for (int num : nums) {\n            sum += num; \n        }\n        int n = nums.length;\n        return n * (n + 1) / 2 - sum;\n    }\n}"}
{"id": "66", "path": "output2\\java\\Easy\\66-first-bad-version.java", "hypo_code": "public class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1;\n\t\tint right = n;\n\t\twhile (left < right) {\n\t\t\tint middle = left + (right - left) / 2;\n\t\t\tif (isBadVersion(middle)) {\n\t\t\t\tright = middle;\n\t\t\t} else {\n\t\t\t\tleft = middle + 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n        \n    }\n}"}
{"id": "67", "path": "output2\\java\\Easy\\67-move-zeroes.java", "hypo_code": "class Solution {\n    public void moveZeroes(int[] nums) {\n        int n = nums.length;\n        int left = 0;\n        int right = 0;\n        while (right < n) {\n            if (nums[right] != 0) {\n                int tmp = nums[right];\n                nums[right] = nums[left];\n                nums[left] = tmp;\n                left++;\n            }\n            right++;\n        }\n        \n    }\n}"}
{"id": "68", "path": "output2\\java\\Easy\\68-word-pattern.java", "hypo_code": "class Solution {\n    public boolean wordPattern(String pattern, String s) {\n         String[] words = s.split(\" \");\n        if (words.length != pattern.length()) return false;\n        Map<Character, String> map = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            char c = pattern.charAt(i);\n            String word = words[i];\n            if (map.containsKey(c)) {\n                if (!map.get(c).equals(word)) return false;\n            } else {\n                if (map.containsValue(word)) return false;\n                map.put(c, word);\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "69", "path": "output2\\java\\Easy\\69-nim-game.java", "hypo_code": "class Solution {\n    public boolean canWinNim(int n) {\n         return n % 4 != 0;\n    }\n}"}
{"id": "71", "path": "output2\\java\\Easy\\71-power-of-three.java", "hypo_code": "class Solution {\n    public boolean isPowerOfThree(int n) {\n        if (n == 1) return true;\n        if (n <= 0 || n % 3 != 0) return false;\n        return isPowerOfThree(n / 3);\n        \n    }\n}"}
{"id": "72", "path": "output2\\java\\Easy\\72-counting-bits.java", "hypo_code": "class Solution {\n    public int[] countBits(int n) {\n        int[] ans = new int[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            ans[i] = count(i);\n        }\n        return ans;\n    }\n     private int count(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        if (n % 2 == 0) return count(n / 2);\n        return count(n / 2) + 1;\n    }\n}"}
{"id": "73", "path": "output2\\java\\Easy\\73-power-of-four.java", "hypo_code": "class Solution {\n    public boolean isPowerOfFour(int n) {\n         if (n == 1) return true;\n        if (n <= 0 || n % 4 != 0) return false;\n        return isPowerOfFour(n / 4);\n    }\n}"}
{"id": "74", "path": "output2\\java\\Easy\\74-reverse-string.java", "hypo_code": "class Solution {\n    public void reverseString(char[] s) {\n         int n = s.length;\n        for (int i = 0; i < n / 2; ++i) {\n            char temp = s[i];\n            s[i] = s[n - i - 1];\n            s[n - i - 1] = temp; \n        }\n    }\n}"}
{"id": "75", "path": "output2\\java\\Easy\\75-reverse-vowels-of-a-string.java", "hypo_code": "class Solution {\n    public String reverseVowels(String s) {\n        char[] chars = s.toCharArray();\n        int n = s.length();\n        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n            if (!isVowel(chars[i])) {\n                ++i;\n                continue;\n            }\n            if (!isVowel(chars[j])) {\n                --j;\n                continue;\n            }\n            char temp = chars[i];\n            chars[i] = chars[j];\n            chars[j] = temp;\n            ++i;\n            --j;\n        }\n        return new String(chars);\n    }\n    private boolean isVowel(char c) {\n        if (c == 'a' || c == 'e' || c == 'i' || \n            c == 'o' || c == 'u' || c == 'A' || \n            c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            return true;\n        }\n        return false;\n    }\n}"}
{"id": "76", "path": "output2\\java\\Easy\\76-intersection-of-two-arrays.java", "hypo_code": "class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> s = new HashSet<>();\n        Set<Integer> ans = new HashSet<>();\n        for (int i : nums1) s.add(i);\n        for (int i : nums2) {\n            if (s.contains(i)) ans.add(i);\n        }\n        int[] res = new int[ans.size()];\n        int i = 0;\n        for (int x : ans) res[i++] = x;\n        return res;\n    }\n}"}
{"id": "77", "path": "output2\\java\\Easy\\77-intersection-of-two-arrays-ii.java", "hypo_code": "class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        \n    }\n}"}
{"id": "78", "path": "output2\\java\\Easy\\78-valid-perfect-square.java", "hypo_code": "class ValidPerfectSquare {\n    public boolean isPerfectSquare(int num) {\n        if(num == 1) return true;\n        int left = 1;\n        int right = num;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(mid == num / mid && num % mid == 0){\n                return true;\n            }else if(mid < num / mid){\n                left = mid + 1;\n            }else{\n                right = mid - 1;\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "79", "path": "output2\\java\\Easy\\79-guess-number-higher-or-lower.java", "hypo_code": "public class GuessNumberHigherOrLower extends GuessGame {\n    public int guessNumber(int n) {\n        int left = 1;\n        int right = n;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            int result = guess(mid);\n            if(result == 0){\n                return mid;\n            }else if(result == -1){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return -1;\n        \n        \n    }\n}"}
{"id": "80", "path": "output2\\java\\Easy\\80-ransom-note.java", "hypo_code": "class RansomNote {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[] count = new int[26];\n        for(int i = 0; i < magazine.length(); i++){\n            count[magazine.charAt(i) - 'a']++;\n        }\n        for(int i = 0; i < ransomNote.length(); i++){\n            count[ransomNote.charAt(i) - 'a']--;\n            if(count[ransomNote.charAt(i) - 'a'] < 0) return false;\n        }\n        return true;\n        \n    }\n}"}
{"id": "81", "path": "output2\\java\\Easy\\81-first-unique-character-in-a-string.java", "hypo_code": "class FirstUniqueCharacterInAString {\n    public int firstUniqChar(String s) {\n        int[] count = new int[26];\n        for(int i = 0; i < s.length(); i++){\n            count[s.charAt(i) - 'a']++;\n        }\n        for(int i = 0; i < s.length(); i++){\n            if(count[s.charAt(i) - 'a'] == 1){\n                return i;\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "82", "path": "output2\\java\\Easy\\82-find-the-difference.java", "hypo_code": "class FindTheDifference {\n    public char findTheDifference(String s, String t) {\n        int[] count = new int[26];\n        for(int i = 0; i < s.length(); i++){\n            count[s.charAt(i) - 'a']++;\n        }\n        for(int i = 0; i < t.length(); i++){\n            count[t.charAt(i) - 'a']--;\n            if(count[t.charAt(i) - 'a'] < 0) return t.charAt(i);\n        }\n        return ' ';\n        \n    }\n}"}
{"id": "83", "path": "output2\\java\\Easy\\83-is-subsequence.java", "hypo_code": "class IsSubsequence {\n    public boolean isSubsequence(String s, String t) {\n        int i = 0;\n        int j = 0;\n        while(i < s.length() && j < t.length()){\n            if(s.charAt(i) == t.charAt(j)){\n                i++;\n            }\n            j++;\n        }\n        return i == s.length();\n        \n    }\n}"}
{"id": "84", "path": "output2\\java\\Easy\\84-binary-watch.java", "hypo_code": "class BinaryWatch {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> result = new ArrayList<>();\n        for(int i = 0; i < 12; i++){\n            for(int j = 0; j < 60; j++){\n                if(Integer.bitCount(i) + Integer.bitCount(j) == turnedOn){\n                    result.add(i + \":\" + (j < 10 ? \"0\" + j : j));\n                }\n            }\n        }\n        return result;\n        \n        \n    }\n}"}
{"id": "85", "path": "output2\\java\\Easy\\85-sum-of-left-leaves.java", "hypo_code": "class SumOfLeftLeaves {\n    public int sumOfLeftLeaves(TreeNode root) {\n        if(root == null) return 0;\n        int sum = 0;\n        if(root.left != null && root.left.left == null && root.left.right == null){\n            sum += root.left.val;\n        }\n        sum += sumOfLeftLeaves(root.left);\n        sum += sumOfLeftLeaves(root.right);\n        return sum;\n        \n    }\n}"}
{"id": "86", "path": "output2\\java\\Easy\\86-convert-a-number-to-hexadecimal.java", "hypo_code": "class ConvertANumberToHexadecimal {\n    public String toHex(int num) {\n        if(num == 0) return \"0\";\n        char[] hex = new char[8];\n        int index = 7;\n        while(num != 0){\n            int digit = num & 15;\n            if(digit < 10){\n                hex[index--] = (char)(digit + '0');\n            }else{\n                hex[index--] = (char)(digit - 10 + 'a');\n            }\n            num = num >>> 4;\n        }\n        return new String(hex, index + 1, 8 - index - 1);\n        \n    }\n}"}
{"id": "87", "path": "output2\\java\\Easy\\87-longest-palindrome.java", "hypo_code": "class LongestPalindrome {\n    public int longestPalindrome(String s) {\n        int[] count = new int[128];\n        for(int i = 0; i < s.length(); i++){\n            count[s.charAt(i)]++;\n        }\n        int result = 0;\n        for(int i = 0; i < count.length; i++){\n            result += count[i] / 2 * 2;\n            if(result % 2 == 0 && count[i] % 2 == 1){\n                result++;\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "88", "path": "output2\\java\\Easy\\88-fizz-buzz.java", "hypo_code": "class FizzBuzz {\n    public List<String> fizzBuzz(int n) {\n        List<String> result = new ArrayList<>();\n        for(int i = 1; i <= n; i++){\n            if(i % 3 == 0 && i % 5 == 0){\n                result.add(\"FizzBuzz\");\n            }else if(i % 3 == 0){\n                result.add(\"Fizz\");\n            }else if(i % 5 == 0){\n                result.add(\"Buzz\");\n            }else{\n                result.add(String.valueOf(i));\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "89", "path": "output2\\java\\Easy\\89-third-maximum-number.java", "hypo_code": "class ThirdMaximumNumber {\n    public int thirdMax(int[] nums) {\n        Integer max1 = null;\n        Integer max2 = null;\n        Integer max3 = null;\n        for(Integer num : nums){\n            if(num.equals(max1) || num.equals(max2) || num.equals(max3)){\n                continue;\n            }\n            if(max1 == null || num > max1){\n                max3 = max2;\n                max2 = max1;\n                max1 = num;\n            }else if(max2 == null || num > max2){\n                max3 = max2;\n                max2 = num;\n            }else if(max3 == null || num > max3){\n                max3 = num;\n            }\n        }\n        return max3 == null ? max1 : max3;\n        \n        \n    }\n}"}
{"id": "90", "path": "output2\\java\\Easy\\90-add-strings.java", "hypo_code": "class AddStrings {\n    public String addStrings(String num1, String num2) {\n        int i = num1.length() - 1;\n        int j = num2.length() - 1;\n        int carry = 0;\n        StringBuilder sb = new StringBuilder();\n        while(i >= 0 || j >= 0){\n            int sum = carry;\n            if(i >= 0) sum += num1.charAt(i--) - '0';\n            if(j >= 0) sum += num2.charAt(j--) - '0';\n            sb.append(sum % 10);\n            carry = sum / 10;\n        }\n        if(carry != 0) sb.append(carry);\n        return sb.reverse().toString();\n        \n        \n    }\n}"}
{"id": "91", "path": "output2\\java\\Easy\\91-number-of-segments-in-a-string.java", "hypo_code": "class NumberOfSegmentsInAString {\n    public int countSegments(String s) {\n        int count = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) != ' ' && (i == 0 || s.charAt(i - 1) == ' ')){\n                count++;\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "92", "path": "output2\\java\\Easy\\92-arranging-coins.java", "hypo_code": "class ArrangingCoins {\n    public int arrangeCoins(int n) {\n        int i = 1;\n        while(n >= i){\n            n -= i;\n            i++;\n        }\n        return i - 1;\n        \n    }\n}"}
{"id": "93", "path": "output2\\java\\Easy\\93-find-all-numbers-disappeared-in-an-array.java", "hypo_code": "class FindAllNumbersDisappearedInAnArray {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        for(int i = 0; i < nums.length; i++){\n            int index = Math.abs(nums[i]) - 1;\n            if(nums[index] > 0){\n                nums[index] *= -1;\n            }\n        }\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] > 0){\n                result.add(i + 1);\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "94", "path": "output2\\java\\Easy\\94-assign-cookies.java", "hypo_code": "class AssignCookies {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i = 0;\n        int j = 0;\n        while(i < g.length && j < s.length){\n            if(g[i] <= s[j]){\n                i++;\n            }\n            j++;\n        }\n        return i;\n        \n        \n    }\n}"}
{"id": "95", "path": "output2\\java\\Easy\\95-repeated-substring-pattern.java", "hypo_code": "class RepeatedSubstringPattern {\n    public boolean repeatedSubstringPattern(String s) {\n        int n = s.length();\n        for(int i = n / 2; i >= 1; i--){\n            if(n % i == 0){\n                int m = n / i;\n                String sub = s.substring(0, i);\n                StringBuilder sb = new StringBuilder();\n                for(int j = 0; j < m; j++){\n                    sb.append(sub);\n                }\n                if(sb.toString().equals(s)) return true;\n            }\n        }\n        return false;\n        \n        \n    }\n}"}
{"id": "96", "path": "output2\\java\\Easy\\96-hamming-distance.java", "hypo_code": "class HammingDistance {\n    public int hammingDistance(int x, int y) {\n        int xor = x ^ y;\n        int count = 0;\n        while(xor != 0){\n            count += xor & 1;\n            xor >>= 1;\n        }\n        return count;\n        \n        \n    }\n}"}
{"id": "97", "path": "output2\\java\\Easy\\97-island-perimeter.java", "hypo_code": "class IslandPerimeter {\n    public int islandPerimeter(int[][] grid) {\n        int perimeter = 0;\n        for(int i = 0; i < grid.length; i++){\n            for(int j = 0; j < grid[0].length; j++){\n                if(grid[i][j] == 1){\n                    perimeter += 4;\n                    if(i > 0 && grid[i - 1][j] == 1) perimeter -= 2;\n                    if(j > 0 && grid[i][j - 1] == 1) perimeter -= 2;\n                }\n            }\n        }\n        return perimeter;\n        \n    }\n}"}
{"id": "98", "path": "output2\\java\\Easy\\98-number-complement.java", "hypo_code": "class NumberComplement {\n    public int findComplement(int num) {\n        int mask = (Integer.highestOneBit(num) << 1) - 1;\n        return num ^ mask;\n        \n    }\n}"}
{"id": "99", "path": "output2\\java\\Easy\\99-license-key-formatting.java", "hypo_code": "class LicenseKeyFormatting {\n    public String licenseKeyFormatting(String s, int k) {\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n        for(int i = s.length() - 1; i >= 0; i--){\n            if(s.charAt(i) == '-') continue;\n            if(count == k){\n                sb.append('-');\n                count = 0;\n            }\n            sb.append(Character.toUpperCase(s.charAt(i)));\n            count++;\n        }\n        return sb.reverse().toString();\n        \n        \n    }\n}"}
{"id": "100", "path": "output2\\java\\Easy\\100-max-consecutive-ones.java", "hypo_code": "class MaxConsecutiveOnes {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int max = 0;\n        int count = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == 1){\n                count++;\n            }else{\n                max = Math.max(max, count);\n                count = 0;\n            }\n        }\n        return Math.max(max, count);\n        \n    }\n}"}
{"id": "101", "path": "output2\\java\\Easy\\101-construct-the-rectangle.java", "hypo_code": "class ConstructTheRectangle {\n    public int[] constructRectangle(int area) {\n        int[] result = new int[2];\n        int w = (int)Math.sqrt(area);\n        while(area % w != 0){\n            w--;\n        }\n        result[0] = area / w;\n        result[1] = w;\n        return result;\n        \n    }\n}"}
{"id": "102", "path": "output2\\java\\Easy\\102-teemo-attacking.java", "hypo_code": "class TeemoAttacking {\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\n        int total = 0;\n        for(int i = 0; i < timeSeries.length; i++){\n            if(i == timeSeries.length - 1){\n                total += duration;\n            }else{\n                total += Math.min(duration, timeSeries[i + 1] - timeSeries[i]);\n            }\n        }\n        return total;\n        \n    }\n}"}
{"id": "103", "path": "output2\\java\\Easy\\103-next-greater-element-i.java", "hypo_code": "class NextGreaterElementI {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        int[] ans = new int[nums1.length];\n        for(int i = 0; i < nums1.length; i++){\n            int j = 0;\n            while(nums2[j] != nums1[i]){\n                j++;\n            }\n            while(j < nums2.length && nums2[j] <= nums1[i]){\n                j++;\n            }\n            if(j == nums2.length){\n                ans[i] = -1;\n            }else{\n                ans[i] = nums2[j];\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "104", "path": "output2\\java\\Easy\\104-keyboard-row.java", "hypo_code": "class KeyboardRow {\n    public String[] findWords(String[] words) {\n        String[] rows = {\"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\"};\n        List<String> ans = new ArrayList<>();\n        for(String word : words){\n            int row = 0;\n            for(int i = 0; i < rows.length; i++){\n                if(rows[i].indexOf(Character.toLowerCase(word.charAt(0))) != -1){\n                    row = i;\n                    break;\n                }\n            }\n            boolean flag = true;\n            for(int i = 1; i < word.length(); i++){\n                if(rows[row].indexOf(Character.toLowerCase(word.charAt(i))) == -1){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(word);\n            }\n        }\n        return ans.toArray(new String[ans.size()]);\n        \n        \n    }\n}"}
{"id": "105", "path": "output2\\java\\Easy\\105-find-mode-in-binary-search-tree.java", "hypo_code": "class FindModeInBinarySearchTree {\n    public int[] findMode(TreeNode root) {\n        if(root == null) return new int[0];\n        Map<Integer, Integer> map = new HashMap<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            TreeNode node = queue.poll();\n            map.put(node.val, map.getOrDefault(node.val, 0) + 1);\n            if(node.left != null) queue.offer(node.left);\n            if(node.right != null) queue.offer(node.right);\n        }\n        int max = 0;\n        for(int key : map.keySet()){\n            max = Math.max(max, map.get(key));\n        }\n        List<Integer> list = new ArrayList<>();\n        for(int key : map.keySet()){\n            if(map.get(key) == max){\n                list.add(key);\n            }\n        }\n        int[] ans = new int[list.size()];\n        for(int i = 0; i < list.size(); i++){\n            ans[i] = list.get(i);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "106", "path": "output2\\java\\Easy\\106-base-7.java", "hypo_code": "class Base7 {\n    public String convertToBase7(int num) {\n        if(num == 0) return \"0\";\n        StringBuilder sb = new StringBuilder();\n        boolean flag = false;\n        if(num < 0){\n            flag = true;\n            num = -num;\n        }\n        while(num > 0){\n            sb.append(num % 7);\n            num /= 7;\n        }\n        if(flag) sb.append(\"-\");\n        return sb.reverse().toString();\n        \n    }\n}"}
{"id": "107", "path": "output2\\java\\Easy\\107-relative-ranks.java", "hypo_code": "class RelativeRanks {\n    public String[] findRelativeRanks(int[] score) {\n        int n = score.length;\n        String[] ans = new String[n];\n        int[] index = new int[n];\n        for(int i = 0; i < n; i++){\n            index[i] = i;\n        }\n        Arrays.sort(index, (a, b) -> score[b] - score[a]);\n        for(int i = 0; i < n; i++){\n            if(i == 0){\n                ans[index[i]] = \"Gold Medal\";\n            }else if(i == 1){\n                ans[index[i]] = \"Silver Medal\";\n            }else if(i == 2){\n                ans[index[i]] = \"Bronze Medal\";\n            }else{\n                ans[index[i]] = String.valueOf(i + 1);\n            }\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "108", "path": "output2\\java\\Easy\\108-perfect-number.java", "hypo_code": "class PerfectNumber {\n    public boolean checkPerfectNumber(int num) {\n        if(num == 1) return false;\n        int sum = 1;\n        for(int i = 2; i <= Math.sqrt(num); i++){\n            if(num % i == 0){\n                sum += i;\n                if(i != num / i){\n                    sum += num / i;\n                }\n            }\n        }\n        return sum == num;\n        \n    }\n}"}
{"id": "109", "path": "output2\\java\\Easy\\109-fibonacci-number.java", "hypo_code": "class FibonacciNumber {\n    public int fib(int n) {\n        if(n == 0) return 0;\n        if(n == 1) return 1;\n        int a = 0;\n        int b = 1;\n        int c = 0;\n        for(int i = 2; i <= n; i++){\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return c;\n        \n        \n    }\n}"}
{"id": "111", "path": "output2\\java\\Easy\\111-detect-capital.java", "hypo_code": "class DetectCapital {\n    public boolean detectCapitalUse(String word) {\n        if(word.length() == 1) return true;\n        boolean flag = false;\n        if(word.charAt(0) >= 'A' && word.charAt(0) <= 'Z'){\n            flag = true;\n        }\n        if(flag){\n            if(word.charAt(1) >= 'A' && word.charAt(1) <= 'Z'){\n                for(int i = 2; i < word.length(); i++){\n                    if(word.charAt(i) >= 'a' && word.charAt(i) <= 'z'){\n                        return false;\n                    }\n                }\n            }else{\n                for(int i = 2; i < word.length(); i++){\n                    if(word.charAt(i) >= 'A' && word.charAt(i) <= 'Z'){\n                        return false;\n                    }\n                }\n            }\n        }else{\n            for(int i = 1; i < word.length(); i++){\n                if(word.charAt(i) >= 'A' && word.charAt(i) <= 'Z'){\n                    return false;\n                }\n            }\n        }\n        return true;\n        \n        \n    }\n}"}
{"id": "112", "path": "output2\\java\\Easy\\112-longest-uncommon-subsequence-i.java", "hypo_code": "class LongestUncommonSubsequenceI {\n    public int findLUSlength(String a, String b) {\n        if(a.equals(b)) return -1;\n        return Math.max(a.length(), b.length());\n        \n    }\n}"}
{"id": "113", "path": "output2\\java\\Easy\\113-minimum-absolute-difference-in-bst.java", "hypo_code": "class MinimumAbsoluteDifferenceInBst {\n    public int getMinimumDifference(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n        inorder(root, list);\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < list.size() - 1; i++){\n            min = Math.min(min, list.get(i + 1) - list.get(i));\n        }\n        return min;\n        \n        \n    }\n}"}
{"id": "114", "path": "output2\\java\\Easy\\114-reverse-string-ii.java", "hypo_code": "class ReverseStringIi {\n    public String reverseStr(String s, int k) {\n        char[] arr = s.toCharArray();\n        for(int i = 0; i < arr.length; i += 2 * k){\n            int left = i;\n            int right = Math.min(i + k - 1, arr.length - 1);\n            while(left < right){\n                char temp = arr[left];\n                arr[left] = arr[right];\n                arr[right] = temp;\n                left++;\n                right--;\n            }\n        }\n        return new String(arr);\n        \n    }\n}"}
{"id": "115", "path": "output2\\java\\Easy\\115-diameter-of-binary-tree.java", "hypo_code": "class DiameterOfBinaryTree {\n    public int diameterOfBinaryTree(TreeNode root) {\n        if(root == null) return 0;\n        int[] ans = new int[1];\n        dfs(root, ans);\n        return ans[0];\n        \n    }\n}"}
{"id": "116", "path": "output2\\java\\Easy\\116-student-attendance-record-i.java", "hypo_code": "class StudentAttendanceRecordI {\n    public boolean checkRecord(String s) {\n        int countA = 0;\n        int countL = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == 'A'){\n                countA++;\n                countL = 0;\n            }else if(s.charAt(i) == 'L'){\n                countL++;\n            }else{\n                countL = 0;\n            }\n            if(countA >= 2 || countL >= 3){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "117", "path": "output2\\java\\Easy\\117-reverse-words-in-a-string-iii.java", "hypo_code": "class ReverseWordsInAStringIii {\n    public String reverseWords(String s) {\n        String[] arr = s.split(\" \");\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < arr.length; i++){\n            sb.append(new StringBuilder(arr[i]).reverse().toString());\n            if(i != arr.length - 1) sb.append(\" \");\n        }\n        return sb.toString();\n        \n    }\n}"}
{"id": "118", "path": "output2\\java\\Easy\\118-maximum-depth-of-n-ary-tree.java", "hypo_code": "class MaximumDepthOfNAryTree {\n    public int maxDepth(Node root) {\n        if(root == null){\n            return 0;\n        }\n        int max = 0;\n        for(Node child : root.children){\n            max = Math.max(max, maxDepth(child));\n        }\n        return max + 1;\n        \n    }\n}"}
{"id": "119", "path": "output2\\java\\Easy\\119-array-partition.java", "hypo_code": "class ArrayPartition {\n    public int arrayPairSum(int[] nums) {\n        int[] count = new int[20001];\n        for(int i = 0; i < nums.length; i++){\n            count[nums[i] + 10000]++;\n        }\n        int sum = 0;\n        boolean flag = true;\n        for(int i = 0; i < count.length; i++){\n            while(count[i] > 0){\n                if(flag){\n                    sum += i - 10000;\n                }\n                flag = !flag;\n                count[i]--;\n            }\n        }\n        return sum;\n        \n        \n    }\n}"}
{"id": "120", "path": "output2\\java\\Easy\\120-binary-tree-tilt.java", "hypo_code": "class BinaryTreeTilt {\n    public int findTilt(TreeNode root) {\n        if(root == null) return 0;\n        int[] ans = new int[1];\n        dfs(root, ans);\n        return ans[0];\n        \n        \n    }\n}"}
{"id": "121", "path": "output2\\java\\Easy\\121-reshape-the-matrix.java", "hypo_code": "class ReshapeTheMatrix {\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\n        int m = mat.length;\n        int n = mat[0].length;\n        if(m * n != r * c) return mat;\n        int[][] ans = new int[r][c];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                int index = i * n + j;\n                ans[index / c][index % c] = mat[i][j];\n            }\n        }\n        return ans;\n        \n        \n        \n    }\n}"}
{"id": "122", "path": "output2\\java\\Easy\\122-subtree-of-another-tree.java", "hypo_code": "class SubtreeOfAnotherTree {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if(root == null) return false;\n        if(isSameTree(root, subRoot)) return true;\n        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n        \n        \n    }\n}"}
{"id": "123", "path": "output2\\java\\Easy\\123-distribute-candies.java", "hypo_code": "class DistributeCandies {\n    public int distributeCandies(int[] candyType) {\n        Set<Integer> set = new HashSet<>();\n        for(int i = 0; i < candyType.length; i++){\n            set.add(candyType[i]);\n        }\n        return Math.min(set.size(), candyType.length / 2);\n        \n    }\n}"}
{"id": "127", "path": "output2\\java\\Easy\\127-n-ary-tree-preorder-traversal.java", "hypo_code": "class NAryTreePreorderTraversal {\n    public List<Integer> preorder(Node root) {\n        List<Integer> res = new ArrayList<>();\n        if(root == null) return res;\n        Stack<Node> stack = new Stack<>();\n        stack.push(root);\n        while(!stack.isEmpty()){\n            Node node = stack.pop();\n            res.add(node.val);\n            for(int i = node.children.size() - 1; i >= 0; i--){\n                stack.push(node.children.get(i));\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "128", "path": "output2\\java\\Easy\\128-n-ary-tree-postorder-traversal.java", "hypo_code": "class Solution {\n    public List<Integer> postorder(Node root) {\n        if (root == null) return new ArrayList<>();\n        List<Integer> ans = new ArrayList<>();\n        for (Node n : root.children) {\n            ans.addAll(postorder(n));\n        }\n        ans.add(root.val);\n        return ans;\n        \n    }\n}"}
{"id": "129", "path": "output2\\java\\Easy\\129-longest-harmonious-subsequence.java", "hypo_code": "class LongestHarmoniousSubsequence {\n    public int findLHS(int[] nums) {\n        int max = 0;\n        for(int i = 0; i < nums.length; i++){\n            int count = 0;\n            for(int j = 0; j < nums.length; j++){\n                if(nums[i] == nums[j] || nums[i] == nums[j] + 1){\n                    count++;\n                }\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n        \n    }\n}"}
{"id": "132", "path": "output2\\java\\Easy\\132-range-addition-ii.java", "hypo_code": "class Solution {\n    public int maxCount(int m, int n, int[][] ops) {\n        if (ops.length == 0) return m * n;\n        int minX = ops[0][0], minY = ops[0][1];\n        for (int i = 1; i < ops.length; ++i) {\n            minX = Math.min(minX, ops[i][0]);\n            minY = Math.min(minY, ops[i][1]);\n        }\n        return minX * minY;\n    }\n}"}
{"id": "133", "path": "output2\\java\\Easy\\133-minimum-index-sum-of-two-lists.java", "hypo_code": "class Solution {\n    public String[] findRestaurant(String[] list1, String[] list2) {\n        Map<String, Integer> map1 = new HashMap<>(), map2 = new HashMap<>();\n        for (int i = 0; i < list1.length; ++i) map1.put(list1[i], i);\n        for (int i = 0; i < list2.length; ++i) map2.put(list2[i], i);\n        int min = Integer.MAX_VALUE;\n        List<String> l = new ArrayList<>();\n        for (Map.Entry<String, Integer> entry : map1.entrySet()) {\n            if (map2.containsKey(entry.getKey())) {\n                int sum = entry.getValue() + map2.get(entry.getKey());\n                if (sum < min) {\n                    min = sum;\n                    l.clear();\n                    l.add(entry.getKey());\n                } else if (sum == min) {\n                    l.add(entry.getKey());\n                }\n            }\n        }\n        return l.toArray(new String[l.size()]);\n\n        \n    }\n}"}
{"id": "134", "path": "output2\\java\\Easy\\134-can-place-flowers.java", "hypo_code": "class Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        int i = 0, count = 0;\n        while (i < flowerbed.length) {\n            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] != 1) &&\n                (i == flowerbed.length - 1 || flowerbed[i + 1] != 1)) {\n                flowerbed[i] = 1;\n                ++count;\n            }\n            ++i;\n        }\n        return count >= n;\n        \n    }\n}"}
{"id": "135", "path": "output2\\java\\Easy\\135-construct-string-from-binary-tree.java", "hypo_code": "class Solution {\n    public String tree2str(TreeNode root) {\n        if (root == null) return \"\";\n         String left = tree2str(root.left);\n         String right = tree2str(root.right);\n         if (right.length() == 0 && left.length() == 0) return root.val + \"\";\n         if (right.length() == 0) return root.val + \"(\" + left + \")\";\n         return root.val + \"(\" + left + \")\" + \"(\" + right + \")\";\n\n    }\n}"}
{"id": "138", "path": "output2\\java\\Easy\\138-merge-two-binary-trees.java", "hypo_code": "class Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n        if (root1 == null && root2 == null) return null;\n        if (root1 == null) return root2;\n        else if (root2 == null) return root1;\n        else {\n            TreeNode root = new TreeNode(root1.val + root2.val);\n            root.left = mergeTrees(root1.left, root2.left);\n            root.right = mergeTrees(root1.right, root2.right);\n            return root;\n    }\n}\n}"}
{"id": "142", "path": "output2\\java\\Easy\\142-maximum-product-of-three-numbers.java", "hypo_code": "class MaximumProductOfThreeNumbers {\n    public int maximumProduct(int[] nums) {\n        int max1 = Integer.MIN_VALUE;\n        int max2 = Integer.MIN_VALUE;\n        int max3 = Integer.MIN_VALUE;\n        int min1 = Integer.MAX_VALUE;\n        int min2 = Integer.MAX_VALUE;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] > max1){\n                max3 = max2;\n                max2 = max1;\n                max1 = nums[i];\n            }else if(nums[i] > max2){\n                max3 = max2;\n                max2 = nums[i];\n            }else if(nums[i] > max3){\n                max3 = nums[i];\n            }\n            if(nums[i] < min1){\n                min2 = min1;\n                min1 = nums[i];\n            }else if(nums[i] < min2){\n                min2 = nums[i];\n            }\n        }\n        return Math.max(max1 * max2 * max3, max1 * min1 * min2);\n        \n        \n        \n    }\n}"}
{"id": "143", "path": "output2\\java\\Easy\\143-average-of-levels-in-binary-tree.java", "hypo_code": "class AverageOfLevelsInBinaryTree {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> res = new ArrayList<>();\n        if(root == null) return res;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            double sum = 0;\n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                sum += node.val;\n                if(node.left != null) queue.offer(node.left);\n                if(node.right != null) queue.offer(node.right);\n            }\n            res.add(sum / size);\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "144", "path": "output2\\java\\Easy\\144-maximum-average-subarray-i.java", "hypo_code": "class MaximumAverageSubarrayI {\n    public double findMaxAverage(int[] nums, int k) {\n        double max = Integer.MIN_VALUE;\n        double sum = 0;\n        for(int i = 0; i < k; i++){\n            sum += nums[i];\n        }\n        max = Math.max(max, sum);\n        for(int i = k; i < nums.length; i++){\n            sum += nums[i] - nums[i - k];\n            max = Math.max(max, sum);\n        }\n        return max / k;\n        \n        \n    }\n}"}
{"id": "145", "path": "output2\\java\\Easy\\145-set-mismatch.java", "hypo_code": "class SetMismatch {\n    public int[] findErrorNums(int[] nums) {\n        int[] res = new int[2];\n        int[] count = new int[nums.length + 1];\n        for(int i = 0; i < nums.length; i++){\n            count[nums[i]]++;\n        }\n        for(int i = 1; i < count.length; i++){\n            if(count[i] == 2){\n                res[0] = i;\n            }\n            if(count[i] == 0){\n                res[1] = i;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "146", "path": "output2\\java\\Easy\\146-two-sum-iv-input-is-a-bst.java", "hypo_code": "class TwoSumIvInputIsABst {\n    public boolean findTarget(TreeNode root, int k) {\n        if(root == null) return false;\n        Set<Integer> set = new HashSet<>();\n        return dfs(root, k, set);\n        \n        \n        \n    }\n}"}
{"id": "147", "path": "output2\\java\\Easy\\147-robot-return-to-origin.java", "hypo_code": "class RobotReturnToOrigin {\n    public boolean judgeCircle(String moves) {\n        int x = 0;\n        int y = 0;\n        for(int i = 0; i < moves.length(); i++){\n            if(moves.charAt(i) == 'R'){\n                x++;\n            }\n            else if(moves.charAt(i) == 'L'){\n                x--;\n            }\n            else if(moves.charAt(i) == 'U'){\n                y++;\n            }\n            else if(moves.charAt(i) == 'D'){\n                y--;\n            }\n        }\n        if(x == 0 && y == 0) return true;\n        return false;\n        \n    }\n}"}
{"id": "148", "path": "output2\\java\\Easy\\148-image-smoother.java", "hypo_code": "class ImageSmoother {\n    public int[][] imageSmoother(int[][] img) {\n        int[][] res = new int[img.length][img[0].length];\n        for(int i = 0; i < img.length; i++){\n            for(int j = 0; j < img[0].length; j++){\n                int count = 0;\n                for(int k = i - 1; k <= i + 1; k++){\n                    for(int l = j - 1; l <= j + 1; l++){\n                        if(k >= 0 && k < img.length && l >= 0 && l < img[0].length){\n                            res[i][j] += img[k][l];\n                            count++;\n                        }\n                    }\n                }\n                res[i][j] /= count;\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "149", "path": "output2\\java\\Easy\\149-second-minimum-node-in-a-binary-tree.java", "hypo_code": "class SecondMinimumNodeInABinaryTree {\n    public int findSecondMinimumValue(TreeNode root) {\n        if(root == null) return -1;\n        int min = root.val;\n        int res = Integer.MAX_VALUE;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            TreeNode node = queue.poll();\n            if(node.val > min){\n                res = Math.min(res, node.val);\n            }\n            if(node.left != null){\n                queue.offer(node.left);\n                queue.offer(node.right);\n            }\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n        \n    }\n}"}
{"id": "150", "path": "output2\\java\\Easy\\150-longest-continuous-increasing-subsequence.java", "hypo_code": "class LongestContinuousIncreasingSubsequence {\n    public int findLengthOfLCIS(int[] nums) {\n        int max = 0;\n        int count = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(i == 0 || nums[i] > nums[i - 1]){\n                count++;\n            }else{\n                count = 1;\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n        \n    }\n}"}
{"id": "151", "path": "output2\\java\\Easy\\151-valid-palindrome-ii.java", "hypo_code": "class ValidPalindromeIi {\n    public boolean validPalindrome(String s) {\n        int i = 0;\n        int j = s.length() - 1;\n        while(i < j){\n            if(s.charAt(i) != s.charAt(j)){\n                return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\n            }\n            i++;\n            j--;\n        }\n        return true;\n        \n        \n    }\n}"}
{"id": "152", "path": "output2\\java\\Easy\\152-baseball-game.java", "hypo_code": "class BaseballGame {\n    public int calPoints(String[] operations) {\n        int[] scores = new int[operations.length];\n        int count = 0;\n        for(int i = 0; i < operations.length; i++){\n            if(operations[i].equals(\"+\")){\n                scores[count] = scores[count - 1] + scores[count - 2];\n                count++;\n            }else if(operations[i].equals(\"D\")){\n                scores[count] = scores[count - 1] * 2;\n                count++;\n            }else if(operations[i].equals(\"C\")){\n                scores[count - 1] = 0;\n                count--;\n            }else{\n                scores[count] = Integer.parseInt(operations[i]);\n                count++;\n            }\n        }\n        int sum = 0;\n        for(int i = 0; i < count; i++){\n            sum += scores[i];\n        }\n        return sum;\n        \n        \n    }\n}"}
{"id": "153", "path": "output2\\java\\Easy\\153-binary-number-with-alternating-bits.java", "hypo_code": "class BinaryNumberWithAlternatingBits {\n    public boolean hasAlternatingBits(int n) {\n        int prev = n & 1;\n        n >>= 1;\n        while(n > 0){\n            int curr = n & 1;\n            if(curr == prev) return false;\n            prev = curr;\n            n >>= 1;\n        }\n        return true;\n        \n    }\n}"}
{"id": "154", "path": "output2\\java\\Easy\\154-count-binary-substrings.java", "hypo_code": "class CountBinarySubstrings {\n    public int countBinarySubstrings(String s) {\n        int prev = 0;\n        int curr = 1;\n        int count = 0;\n        for(int i = 1; i < s.length(); i++){\n            if(s.charAt(i) == s.charAt(i - 1)){\n                curr++;\n            }else{\n                prev = curr;\n                curr = 1;\n            }\n            if(prev >= curr){\n                count++;\n            }\n        }\n        return count;\n        \n        \n    }\n}"}
{"id": "155", "path": "output2\\java\\Easy\\155-degree-of-an-array.java", "hypo_code": "class DegreeOfAnArray {\n    public int findShortestSubArray(int[] nums) {\n        int max = 0;\n        int min = Integer.MAX_VALUE;\n        int[] count = new int[50000];\n        int[] first = new int[50000];\n        for(int i = 0; i < nums.length; i++){\n            if(count[nums[i]] == 0){\n                first[nums[i]] = i;\n            }\n            count[nums[i]]++;\n            max = Math.max(max, count[nums[i]]);\n        }\n        for(int i = 0; i < nums.length; i++){\n            if(count[nums[i]] == max){\n                min = Math.min(min, i - first[nums[i]] + 1);\n            }\n        }\n        return min;\n        \n        \n    }\n}"}
{"id": "156", "path": "output2\\java\\Easy\\156-search-in-a-binary-search-tree.java", "hypo_code": "class SearchInABinarySearchTree {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null) return null;\n        if(root.val == val) return root;\n        if(root.val > val) return searchBST(root.left, val);\n        return searchBST(root.right, val);\n        \n        \n    }\n}"}
{"id": "158", "path": "output2\\java\\Easy\\158-binary-search.java", "hypo_code": "class BinarySearch {\n    public int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] < target){\n                left = mid + 1;\n            }else{\n                right = mid - 1;\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "161", "path": "output2\\java\\Easy\\161-to-lower-case.java", "hypo_code": "class ToLowerCase {\n    public String toLowerCase(String s) {\n        StringBuilder sb = new StringBuilder();\n        for(char c : s.toCharArray()){\n            if(c >= 'A' && c <= 'Z'){\n                sb.append((char)(c + 32));\n            }else{\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n        \n    }\n}"}
{"id": "162", "path": "output2\\java\\Easy\\162-1-bit-and-2-bit-characters.java", "hypo_code": "class Solution {\n    public boolean isOneBitCharacter(int[] bits) {\n        int i = 0;\n        while (i < bits.length - 1) {\n            if (bits[i] == 0) ++i;\n            else i += 2;\n        }\n        return i == bits.length - 1;\n    }\n}"}
{"id": "163", "path": "output2\\java\\Easy\\163-find-pivot-index.java", "hypo_code": "class Solution {\n    public int pivotIndex(int[] nums) {\n        int sum = 0, leftSum = 0;\n        for (int i : nums) sum += i;\n        for (int i = 0; i < nums.length; ++i) {\n            if (leftSum == sum - leftSum - nums[i]) return i;\n            leftSum += nums[i];\n        }\n        return -1;\n    }\n}"}
{"id": "164", "path": "output2\\java\\Easy\\164-self-dividing-numbers.java", "hypo_code": "class Solution {\n    public List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> ans = new ArrayList<>();\n        for (int x = left; x <= right; ++x) {\n            int y = x;\n            while (y > 0) {\n                if (y % 10 == 0 || x % (y % 10) != 0) break;\n                y /= 10;\n            }\n            if (y == 0) ans.add(x);\n        }\n        return ans;\n    }\n}"}
{"id": "165", "path": "output2\\java\\Easy\\165-flood-fill.java", "hypo_code": "class Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\n        int m = image.length, n = image[0].length, oldColor = image[sr][sc];\n        if (oldColor == color) return image;\n        image[sr][sc] = color;\n        if (sr - 1 >= 0 && image[sr - 1][sc] == oldColor) floodFill(image, sr - 1, sc, color);\n        if (sr + 1 < m && image[sr + 1][sc] == oldColor) floodFill(image, sr + 1, sc, color);\n        if (sc - 1 >= 0 && image[sr][sc - 1] == oldColor) floodFill(image, sr, sc - 1, color);\n        if (sc + 1 < n && image[sr][sc + 1] == oldColor) floodFill(image, sr, sc + 1, color);\n        return image;\n    }\n}"}
{"id": "166", "path": "output2\\java\\Easy\\166-find-smallest-letter-greater-than-target.java", "hypo_code": "class Solution {\n    public char nextGreatestLetter(char[] letters, char target) {\n        int left = 0, right = letters.length;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (letters[mid] <= target) left = mid + 1;\n            else right = mid;\n        }\n        return letters[left % letters.length];\n        \n    }\n}"}
{"id": "167", "path": "output2\\java\\Easy\\167-min-cost-climbing-stairs.java", "hypo_code": "class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int[] dp = new int[3];\n        for (int i = 2; i <= cost.length; ++i) {\n            dp[i % 3] = Math.min(dp[(i - 1) % 3] + cost[i - 1], dp[(i - 2) % 3] + cost[i - 2]);\n        }\n        return dp[cost.length % 3];\n    }\n}"}
{"id": "168", "path": "output2\\java\\Easy\\168-largest-number-at-least-twice-of-others.java", "hypo_code": "class Solution {\n    public int dominantIndex(int[] nums) {\n        int maxIndex = 0;\n        for (int i = 1; i < nums.length; ++i) {\n            if (nums[i] > nums[maxIndex]) {\n                maxIndex = i;\n            }\n        }\n        for (int i = 0; i < nums.length; ++i) {\n            if (maxIndex != i && nums[maxIndex] < 2 * nums[i]) {\n                return -1;\n            }\n        }\n        return maxIndex;\n    }\n}"}
{"id": "169", "path": "output2\\java\\Easy\\169-shortest-completing-word.java", "hypo_code": "class Solution {\n    public String shortestCompletingWord(String licensePlate, String[] words) {\n        int[] charCount = new int[26];\n        for (char c : licensePlate.toCharArray()) {\n            if (Character.isLetter(c)) {\n                charCount[Character.toLowerCase(c) - 'a']++;\n            }\n        }\n        String res = \"\";\n        for (String word : words) {\n            if ((res.length() == 0 || word.length() < res.length()) && match(word, charCount)) {\n                res = word;\n            }\n        }\n        return res;\n    }\n    private boolean match(String word, int[] charCount) {\n        int[] wordCount = new int[26];\n        for (char c : word.toCharArray()) {\n            wordCount[c - 'a']++;\n        }\n        for (int i = 0; i < 26; ++i) {\n            if (wordCount[i] < charCount[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "170", "path": "output2\\java\\Easy\\170-prime-number-of-set-bits-in-binary-representation.java", "hypo_code": "class Solution {\n    public int countPrimeSetBits(int left, int right) {\n         int[] primes = new int[]{2,3,5,7,11,13,17,19};\n        int res = 0;\n        for (int i = left; i <= right; ++i) {\n            if (isPrime(i, primes)) {\n                res++;\n            }\n        }\n        return res;\n    }\n    private boolean isPrime(int x, int[] primes) {\n        int count = 0;\n        while (x != 0) {\n            count += x & 1;\n            x >>= 1;\n        }\n        for (int p : primes) {\n            if (p == count) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}
{"id": "171", "path": "output2\\java\\Easy\\171-toeplitz-matrix.java", "hypo_code": "class Solution {\n    public boolean isToeplitzMatrix(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[] arr = new int[m + n - 1];\n        for (int i = 0; i < m + n - 1; ++i) {\n            arr[i] = Integer.MAX_VALUE;\n        }\n        for (int i = 0; i < m; ++i) {\n            int[] temp = new int[n + 1];\n            temp[0] = Integer.MAX_VALUE;\n            for (int j = 0; j < n; ++j) {\n                temp[j + 1] = matrix[i][j];\n            }\n            for (int j = 0; j < n; ++j) {\n                arr[i - j + n - 1] = Math.min(arr[i - j + n - 1], temp[j]);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            int[] temp = new int[m + 1];\n            temp[0] = Integer.MAX_VALUE;\n            for (int j = 0; j < m; ++j) {\n                temp[j + 1] = matrix[j][i];\n            }\n            for (int j = 0; j < m; ++j) {\n                arr[m - j + i - 1] = Math.min(arr[m - j + i - 1], temp[j]);\n            }\n        }\n        for (int i = 0; i < m + n - 1; ++i) {\n            if (arr[i] != Integer.MAX_VALUE) {\n                for (int j = i + 1; j < m + n - 1; ++j) {\n                    if (arr[j] != Integer.MAX_VALUE && arr[i] != arr[j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}"}
{"id": "172", "path": "output2\\java\\Easy\\172-jewels-and-stones.java", "hypo_code": "class Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int[] map = new int[128];\n        for (char c : jewels.toCharArray()) {\n            map[c] = 1;\n        }\n        int res = 0;\n        for (char c : stones.toCharArray()) {\n            res += map[c];\n        }\n        return res;\n    }\n}"}
{"id": "173", "path": "output2\\java\\Easy\\173-minimum-distance-between-bst-nodes.java", "hypo_code": "class Solution {\n    public int minDiffInBST(TreeNode root) {\n        int[] prev = new int[]{Integer.MIN_VALUE};\n\t\tint[] min = new int[]{Integer.MAX_VALUE};\n\t\tdfs(root, prev, min);\n\t\treturn min[0];\n    }\n    private void dfs(TreeNode root, int[] prev, int[] min) {\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t}\n\t\tdfs(root.left, prev, min);\n\t\tmin[0] = Math.min(min[0], root.val - prev[0]);\n\t\tprev[0] = root.val;\n\t\tdfs(root.right, prev, min);\n    }\n}"}
{"id": "174", "path": "output2\\java\\Easy\\174-rotate-string.java", "hypo_code": "class Solution {\n    public boolean rotateString(String s, String goal) {\n         return s.length() == goal.length() && (s + s).contains(goal);\n\n    }\n}"}
{"id": "175", "path": "output2\\java\\Easy\\175-unique-morse-code-words.java", "hypo_code": "class Solution {\n    public int uniqueMorseRepresentations(String[] words) {\n        String[] morse = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\n                          \"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\n                          \"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\n                          \"-.--\",\"--..\"};\n        HashSet<String> seen = new HashSet<String>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray()) {\n                code.append(morse[c - 'a']);\n            }\n            seen.add(code.toString());\n        }\n        return seen.size();\n    }\n}"}
{"id": "176", "path": "output2\\java\\Easy\\176-number-of-lines-to-write-string.java", "hypo_code": "class Solution {\n    public int[] numberOfLines(int[] widths, String s) {\n        int[] result = new int[2];\n        int currentLine = 1, currentWidth = 0;\n        for (char c : s.toCharArray()) {\n            int width = widths[c - 'a'];\n            if (currentWidth + width > 100) {\n                ++currentLine;\n                currentWidth = 0;\n            }\n            currentWidth += width;\n        }\n        result[0] = currentLine;\n        result[1] = currentWidth;\n        return result;\n    }\n}"}
{"id": "177", "path": "output2\\java\\Easy\\177-largest-triangle-area.java", "hypo_code": "class Solution {\n    public double largestTriangleArea(int[][] points) {\n        double res = 0;\n        for (int[] i : points) {\n            for (int[] j : points) {\n                for (int[] k : points) {\n                    res = Math.max(res, 0.5 * Math.abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1] \n                        - i[1] * j[0] - j[1] * k[0] - k[1] * i[0]));\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "178", "path": "output2\\java\\Easy\\178-most-common-word.java", "hypo_code": "class Solution {\n    public String mostCommonWord(String paragraph, String[] banned) {\n        Set<String> bannedSet = new HashSet<>(Arrays.asList(banned));\n        Map<String, Integer> count = new HashMap<>();\n        String[] words = paragraph.replaceAll(\"\\\\W+\", \" \").toLowerCase().split(\"\\\\s+\");\n        String res = \"\";\n        int maxCount = 0;\n        for (String word : words) {\n            if (!bannedSet.contains(word)) {\n                int cnt = count.getOrDefault(word, 0) + 1;\n                count.put(word, cnt);\n                if (cnt > maxCount) {\n                    maxCount = cnt;\n                    res = word;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "179", "path": "output2\\java\\Easy\\179-shortest-distance-to-a-character.java", "hypo_code": "class Solution {\n    public int[] shortestToChar(String s, char c) {\n         int n = s.length();\n        int[] res = new int[n];\n        int prev = -n;\n        for (int i = 0; i < n; ++i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = i - prev;\n        }\n        prev = 2 * n;\n        for (int i = n - 1; i >= 0; --i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = Math.min(res[i], prev - i);\n        }\n        return res;\n    }\n}"}
{"id": "180", "path": "output2\\java\\Easy\\180-goat-latin.java", "hypo_code": "class Solution {\n    public String toGoatLatin(String sentence) {\n        StringBuilder sb = new StringBuilder();\n        String[] words = sentence.split(\" \");\n        HashSet<Character> vowels = new HashSet<Character>(Arrays.asList('a', 'e', 'i', 'o', 'u'));\n        for (int i = 0; i < words.length; ++i) {\n            if (vowels.contains(Character.toLowerCase(words[i].charAt(0)))) {\n                sb.append(words[i]);\n            }\n            else {\n                sb.append(words[i].substring(1));\n                sb.append(words[i].charAt(0));\n            }\n            sb.append(\"ma\");\n            for (int j = 0; j <= i; ++j) {\n                sb.append('a');\n            }\n            if (i != words.length - 1) {\n                sb.append(' ');\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "181", "path": "output2\\java\\Easy\\181-positions-of-large-groups.java", "hypo_code": "class Solution {\n    public List<List<Integer>> largeGroupPositions(String s) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n        int i = 0, j = 0;\n        while (i < s.length()) {\n            while (j < s.length() && s.charAt(i) == s.charAt(j)) {\n                ++j;\n            }\n            if (j - i >= 3) {\n                result.add(Arrays.asList(i, j - 1));\n            }\n            i = j;\n        }\n        return result;\n    }\n}"}
{"id": "182", "path": "output2\\java\\Easy\\182-flipping-an-image.java", "hypo_code": "class Solution {\n    public int[][] flipAndInvertImage(int[][] image) {\n        int[][] result = new int[image.length][image[0].length];\n        for(int i = 0; i < image.length; i++){\n            for(int j = 0; j < image[i].length; j++){\n                result[i][j] = image[i][image[i].length - 1 - j] == 0 ? 1 : 0;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "183", "path": "output2\\java\\Easy\\183-rectangle-overlap.java", "hypo_code": "class Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n         return !(rec1[0] >= rec2[2] ||\n                 rec1[2] <= rec2[0] ||\n                 rec1[1] >= rec2[3] ||\n                 rec1[3] <= rec2[1]);\n    }\n}"}
{"id": "184", "path": "output2\\java\\Easy\\184-backspace-string-compare.java", "hypo_code": "class Solution {\n    public boolean backspaceCompare(String s, String t) {\n        int i = s.length() - 1, j = t.length() - 1, count1 = 0, count2 = 0;\n        while (i >= 0 || j >= 0) {\n            while (i >= 0 && (count1 > 0 || s.charAt(i) == '#')) {\n                count1 += s.charAt(i) == '#' ? 1 : -1;\n                --i;\n            }\n            while (j >= 0 && (count2 > 0 || t.charAt(j) == '#')) {\n                count2 += t.charAt(j) == '#' ? 1 : -1;\n                --j;\n            }\n            if (i >= 0 && j >= 0 && s.charAt(i) != t.charAt(j)) {\n                return false;\n            }\n            if ((i >= 0) != (j >= 0)) {\n                return false;\n            }\n            --i;\n            --j;\n        }\n        return true;\n    }\n}"}
{"id": "185", "path": "output2\\java\\Easy\\185-buddy-strings.java", "hypo_code": "class Solution {\n    public boolean buddyStrings(String s, String goal) {\n        if (s.length() != goal.length()) {\n            return false;\n        }\n        if (s.equals(goal)) {\n            Set<Character> set = new HashSet<Character>();\n            for (char c : s.toCharArray()) {\n                set.add(c);\n            }\n            return set.size() < s.length();\n        }\n        List<Integer> list = new ArrayList<Integer>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) != goal.charAt(i)) {\n                list.add(i);\n            }\n        }\n        return list.size() == 2 && s.charAt(list.get(0)) == goal.charAt(list.get(1)) && s.charAt(list.get(1)) == goal.charAt(list.get(0));\n\n    }\n}"}
{"id": "186", "path": "output2\\java\\Easy\\186-lemonade-change.java", "hypo_code": "class Solution {\n    public boolean lemonadeChange(int[] bills) {\n        int[] arr = new int[3];\n        for (int bill : bills) {\n            switch (bill) {\n                case 5:\n                    arr[0]++;\n                    break;\n                case 10:\n                    arr[1]++;\n                    if (arr[0] > 0) {\n                        arr[0]--;\n                    } else {\n                        return false;\n                    }\n                    break;\n                case 20:\n                    arr[2]++;\n                    if (arr[1] > 0 && arr[0] > 0) {\n                        arr[1]--;\n                        arr[0]--;\n                    } else if (arr[0] > 2) {\n                        arr[0] -= 3;\n                    } else {\n                        return false;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "187", "path": "output2\\java\\Easy\\187-transpose-matrix.java", "hypo_code": "class Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] result = new int[matrix[0].length][matrix.length];\n        for(int i = 0; i < matrix.length; i++){\n            for(int j = 0; j < matrix[0].length;j++){\n                result[j][i] = matrix[i][j];\n            }\n        }\n        return result;\n    }\n}"}
{"id": "188", "path": "output2\\java\\Easy\\188-binary-gap.java", "hypo_code": "class Solution {\n    public int binaryGap(int n) {\n        int max = 0;\n        int count = 0;\n        boolean start = false;\n        while(n > 0){\n            if((n & 1) == 1){\n                start = true;\n                max = Math.max(max, count);\n                count = 1;\n            }else if(start){\n                count++;\n            }\n            n >>= 1;\n        }\n        return max;\n        \n    }\n}"}
{"id": "189", "path": "output2\\java\\Easy\\189-leaf-similar-trees.java", "hypo_code": "class Solution {\n    public boolean leafSimilar(TreeNode root1, TreeNode root2) {\n        List<Integer> list1 = new ArrayList<>();\n    \tList<Integer> list2 = new ArrayList<>();\n    \tdfs(root1, list1);\n    \tdfs(root2, list2);\n    \treturn list1.equals(list2);\n    }\n    private void dfs(TreeNode root, List<Integer> list){\n    \tif(root == null){\n    \t\treturn;\n    \t}\n    \tdfs(root.left, list);\n    \tif(root.left == null && root.right == null){\n    \t\tlist.add(root.val);\n    \t}\n    \tdfs(root.right, list);\n    }\n}"}
{"id": "190", "path": "output2\\java\\Easy\\190-middle-of-the-linked-list.java", "hypo_code": "class Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while(fast != null && fast.next != null){\n        \tslow = slow.next;\n        \tfast = fast.next.next;\n        }\n        return slow;\n    }\n}"}
{"id": "191", "path": "output2\\java\\Easy\\191-projection-area-of-3d-shapes.java", "hypo_code": "class Solution {\n    public int projectionArea(int[][] grid) {\n        int n = grid.length, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int bestRow = 0, bestCol = 0;\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] > 0) ans++;\n                bestRow = Math.max(bestRow, grid[i][j]);\n                bestCol = Math.max(bestCol, grid[j][i]);\n            }\n            ans += bestRow + bestCol;\n        }\n        return ans;\n    }\n}"}
{"id": "192", "path": "output2\\java\\Easy\\192-uncommon-words-from-two-sentences.java", "hypo_code": "class Solution {\n    public String[] uncommonFromSentences(String s1, String s2) {\n        HashMap<String, Integer> map = new HashMap<>();\n        for (String s : s1.split(\" \")) {\n            map.put(s, map.getOrDefault(s, 0) + 1);\n        }\n        for (String s : s2.split(\" \")) {\n            map.put(s, map.getOrDefault(s, 0) + 1);\n        }\n        List<String> list = new ArrayList<>();\n        for (String s : map.keySet()) {\n            if (map.get(s) == 1) {\n                list.add(s);\n            }\n        }\n        return list.toArray(new String[0]);\n    }\n}"}
{"id": "193", "path": "output2\\java\\Easy\\193-fair-candy-swap.java", "hypo_code": "class Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int[] result = new int[2];\n        int aliceTotal = 0;\n        int bobTotal = 0;\n        for(int i = 0; i < aliceSizes.length; i++){\n            aliceTotal += aliceSizes[i];\n        }\n        for(int i = 0; i < bobSizes.length; i++){\n            bobTotal += bobSizes[i];\n        }\n        int diff = (aliceTotal - bobTotal) / 2;\n        for(int i = 0; i < aliceSizes.length; i++){\n            for(int j = 0; j < bobSizes.length; j++){\n                if(aliceSizes[i] - bobSizes[j] == diff){\n                    result[0] = aliceSizes[i];\n                    result[1] = bobSizes[j];\n                    return result;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "194", "path": "output2\\java\\Easy\\194-surface-area-of-3d-shapes.java", "hypo_code": "class Solution {\n    public int surfaceArea(int[][] grid) {\n        int n = grid.length, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            int bestRow = 0, bestCol = 0;\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] > 0) ans += 2;\n                if (i == 0) ans += grid[i][j];\n                if (j == 0) ans += grid[i][j];\n                if (i == n - 1) ans += grid[i][j];\n                if (j == n - 1) ans += grid[i][j];\n                bestRow = Math.max(bestRow, grid[i][j]);\n                bestCol = Math.max(bestCol, grid[j][i]);\n            }\n            ans += bestRow + bestCol;\n        }\n        return ans;\n    }\n}"}
{"id": "195", "path": "output2\\java\\Easy\\195-monotonic-array.java", "hypo_code": "class Solution {\n    public boolean isMonotonic(int[] nums) {\n        boolean inc = true;\n        boolean dec = true;\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] > nums[i-1]) dec = false;\n            if(nums[i] < nums[i-1]) inc = false;\n        }\n        return inc || dec;\n    }\n}"}
{"id": "196", "path": "output2\\java\\Easy\\196-increasing-order-search-tree.java", "hypo_code": "class Solution {\n    public TreeNode increasingBST(TreeNode root) {\n        TreeNode dummy = new TreeNode();\n    \tTreeNode cur = dummy;\n    \tStack<TreeNode> stack = new Stack<>();\n    \twhile(root != null || !stack.isEmpty()){\n    \t\twhile(root != null){\n    \t\t\tstack.push(root);\n    \t\t\troot = root.left;\n    \t\t}\n    \t\troot = stack.pop();\n    \t\tcur.right = root;\n    \t\tcur.left = null;\n    \t\tcur = cur.right;\n    \t\troot = root.right;\n    \t}\n    \treturn dummy.right;\n    }\n}"}
{"id": "197", "path": "output2\\java\\Easy\\197-sort-array-by-parity.java", "hypo_code": "class Solution {\n    public int[] sortArrayByParity(int[] nums) {\n        int[] result = new int[nums.length];\n        int j = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] % 2 == 0){\n                result[j] = nums[i];\n                j++;\n            }\n        }\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] % 2 != 0){\n                result[j] = nums[i];\n                j++;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "198", "path": "output2\\java\\Easy\\198-smallest-range-i.java", "hypo_code": "class Solution {\n    public int smallestRangeI(int[] nums, int k) {\n        int min = nums[0];\n        int max = nums[0];\n        for(int num : nums){\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n        int result = max - min - 2 * k;\n        return result > 0 ? result : 0;\n    }\n}"}
{"id": "199", "path": "output2\\java\\Easy\\199-x-of-a-kind-in-a-deck-of-cards.java", "hypo_code": "class Solution {\n    public boolean hasGroupsSizeX(int[] deck) {\n        int[] arr = new int[10000];\n        for(int i = 0; i < deck.length; i++){\n            arr[deck[i]]++;\n        }\n        int x = arr[deck[0]];\n        for(int i = 0; i < arr.length; i++){\n            if(arr[i] != 0){\n                x = gcd(x, arr[i]);\n            }\n        }\n        return x > 1;\n    }\n public int gcd(int a, int b){\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}"}
{"id": "200", "path": "output2\\java\\Easy\\200-reverse-only-letters.java", "hypo_code": "class Solution {\n    public String reverseOnlyLetters(String s) {\n        int i = 0, j = s.length() - 1;\n        char[] arr = s.toCharArray();\n        while (i < j) {\n            while (i < j && !Character.isLetter(arr[i])) {\n                i++;\n            }\n            while (i < j && !Character.isLetter(arr[j])) {\n                j--;\n            }\n            char temp = arr[i];\n            arr[i++] = arr[j];\n            arr[j--] = temp;\n        }\n        return new String(arr);\n    }\n}"}
{"id": "201", "path": "output2\\java\\Easy\\201-sort-array-by-parity-ii.java", "hypo_code": "class Solution {\n    public int[] sortArrayByParityII(int[] nums) {\n        int len = nums.length;\n        int[] res = new int[len];\n        int even = 0;\n        int odd = 1;\n        for(int i = 0; i < len; i++){\n            if(nums[i] % 2 == 0){\n                res[even] = nums[i];\n                even += 2;\n            }else{\n                res[odd] = nums[i];\n                odd += 2;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "202", "path": "output2\\java\\Easy\\202-long-pressed-name.java", "hypo_code": "class Solution {\n    public boolean isLongPressedName(String name, String typed) {\n        int i = 0;\n        int j = 0;\n        int len1 = name.length();\n        int len2 = typed.length();\n        while (i < len1 && j < len2) {\n            if (name.charAt(i) == typed.charAt(j)) {\n                i++;\n                j++;\n            } else {\n                if (j == 0) {\n                    return false;\n                }\n                if (typed.charAt(j) == typed.charAt(j - 1)) {\n                    j++;\n                } else {\n                    return false;\n                }\n            }\n        }\n        while (j < len2) {\n            if (typed.charAt(j) == typed.charAt(j - 1)) {\n                j++;\n            } else {\n                return false;\n            }\n        }\n        return i == len1;\n    }\n}"}
{"id": "203", "path": "output2\\java\\Easy\\203-unique-email-addresses.java", "hypo_code": "class Solution {\n    public int numUniqueEmails(String[] emails) {\n        HashSet<String> set = new HashSet<>();\n        for (String email : emails) {\n            StringBuilder sb = new StringBuilder();\n            int index = email.indexOf(\"@\");\n            String local = email.substring(0, index);\n            String domain = email.substring(index);\n            for (char c : local.toCharArray()) {\n                if (c == '+') {\n                    break;\n                } else if (c != '.') {\n                    sb.append(c);\n                }\n            }\n            sb.append(domain);\n            set.add(sb.toString());\n        }\n        return set.size();\n    }\n}"}
{"id": "205", "path": "output2\\java\\Easy\\205-range-sum-of-bst.java", "hypo_code": "class Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null) return 0;\n\t\tif(root.val < low) return rangeSumBST(root.right, low, high);\n\t\tif(root.val > high) return rangeSumBST(root.left, low, high);\n\t\treturn root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\n\n    }\n}"}
{"id": "206", "path": "output2\\java\\Easy\\206-valid-mountain-array.java", "hypo_code": "class Solution {\n    public boolean validMountainArray(int[] arr) {\n        int len = arr.length;\n        if(len < 3) return false;\n        int i = 0;\n        while(i < len - 1 && arr[i] < arr[i + 1]){\n            i++;\n        }\n        if(i == 0 || i == len - 1) return false;\n        while(i < len - 1 && arr[i] > arr[i + 1]){\n            i++;\n        }\n        return i == len - 1;\n    }\n}"}
{"id": "207", "path": "output2\\java\\Easy\\207-di-string-match.java", "hypo_code": "class Solution {\n    public int[] diStringMatch(String s) {\n        int len = s.length();\n        int[] res = new int[len + 1];\n        int lo = 0;\n        int hi = len;\n        for(int i = 0; i < len; i++){\n            if(s.charAt(i) == 'I'){\n                res[i] = lo++;\n            }else{\n                res[i] = hi--;\n            }\n        }\n        res[len] = lo;\n        return res;\n    }\n}"}
{"id": "208", "path": "output2\\java\\Easy\\208-delete-columns-to-make-sorted.java", "hypo_code": "class Solution {\n    public int minDeletionSize(String[] strs) {\n        int len = strs.length;\n        int res = 0;\n        for(int i = 0; i < strs[0].length(); i++){\n            for(int j = 0; j < len - 1; j++){\n                if(strs[j].charAt(i) > strs[j + 1].charAt(i)){\n                    res++;\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "209", "path": "output2\\java\\Easy\\209-verifying-an-alien-dictionary.java", "hypo_code": "class Solution {\n    public boolean isAlienSorted(String[] words, String order) {\n        int[] index = new int[26];\n        int len = words.length;\n        for(int i = 0; i < order.length(); i++){\n            index[order.charAt(i) - 'a'] = i;\n        }\n        for(int i = 0; i < len - 1; i++){\n            if(!compare(words[i], words[i + 1], index)){\n                return false;\n            }\n        }\n        return true;\n    }\n    private boolean compare(String s1, String s2, int[] index){\n        int len1 = s1.length();\n        int len2 = s2.length();\n        int min = Math.min(len1, len2);\n        for(int i = 0; i < min; i++){\n            char c1 = s1.charAt(i);\n            char c2 = s2.charAt(i);\n            if(c1 != c2){\n                return index[c1 - 'a'] < index[c2 - 'a'];\n            }\n        }\n        return len1 <= len2;\n    }\n}"}
{"id": "210", "path": "output2\\java\\Easy\\210-n-repeated-element-in-size-2n-array.java", "hypo_code": "class Solution {\n    public int repeatedNTimes(int[] nums) {\n        int len = nums.length;\n        int[] arr = new int[10000];\n        for(int i = 0; i < len; i++){\n            arr[nums[i]]++;\n            if(arr[nums[i]] == len / 2){\n                return nums[i];\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "211", "path": "output2\\java\\Easy\\211-univalued-binary-tree.java", "hypo_code": "class Solution {\n    public boolean isUnivalTree(TreeNode root) {\n        if(root == null) return true;\n        if(root.left != null && root.val != root.left.val) return false;\n        if(root.right != null && root.val != root.right.val) return false;\n        return isUnivalTree(root.left) && isUnivalTree(root.right);\n\n    }\n}"}
{"id": "212", "path": "output2\\java\\Easy\\212-largest-perimeter-triangle.java", "hypo_code": "class Solution {\n    public int largestPerimeter(int[] nums) {\n        Arrays.sort(nums);\n        int len = nums.length;\n        for(int i = len - 1; i >= 2; i--){\n            if(nums[i] < nums[i - 1] + nums[i - 2]){\n                return nums[i] + nums[i - 1] + nums[i - 2];\n            }\n        }\n        return 0;\n    }\n}"}
{"id": "213", "path": "output2\\java\\Easy\\213-squares-of-a-sorted-array.java", "hypo_code": "class Solution {\n    public int[] sortedSquares(int[] nums) {\n        int len = nums.length;\n        int[] res = new int[len];\n        int left = 0;\n        int right = len - 1;\n        int i = len - 1;\n        while(left <= right){\n            if(nums[left] * nums[left] < nums[right] * nums[right]){\n                res[i--] = nums[right] * nums[right];\n                right--;\n            }else{\n                res[i--] = nums[left] * nums[left];\n                left++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "214", "path": "output2\\java\\Easy\\214-add-to-array-form-of-integer.java", "hypo_code": "class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int len = num.length;\n        int i = len - 1;\n        int carry = 0;\n        while(i >= 0 || k != 0){\n            int a = i >= 0 ? num[i--] : 0;\n            int b = k % 10;\n            k /= 10;\n            int sum = a + b + carry;\n            res.add(sum % 10);\n            carry = sum / 10;\n        }\n        if(carry != 0){\n            res.add(carry);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}"}
{"id": "215", "path": "output2\\java\\Easy\\215-cousins-in-binary-tree.java", "hypo_code": "class Solution {\n    public boolean isCousins(TreeNode root, int x, int y) {\n        Queue<TreeNode> q = new LinkedList<>();\n\t\tq.add(root);\n\t\twhile(!q.isEmpty()) {\n\t\t\tint size = q.size();\n\t\t\tboolean foundX = false;\n\t\t\tboolean foundY = false;\n\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\tTreeNode cur = q.poll();\n\t\t\t\tif(cur.val == x) foundX = true;\n\t\t\t\tif(cur.val == y) foundY = true;\n\t\t\t\tif(cur.left != null && cur.right != null) {\n\t\t\t\t\tif(cur.left.val == x && cur.right.val == y) return false;\n\t\t\t\t\tif(cur.left.val == y && cur.right.val == x) return false;\n\t\t\t\t}\n\t\t\t\tif(cur.left != null) q.add(cur.left);\n\t\t\t\tif(cur.right != null) q.add(cur.right);\n\t\t\t}\n\t\t\tif(foundX && foundY) return true;\n\t\t}\n\t\treturn false;\n    }\n}"}
{"id": "216", "path": "output2\\java\\Easy\\216-find-the-town-judge.java", "hypo_code": "class Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] arr = new int[n + 1];\n        for(int[] t : trust){\n            arr[t[0]]--;\n            arr[t[1]]++;\n        }\n        for(int i = 1; i <= n; i++){\n            if(arr[i] == n - 1){\n                return i;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "217", "path": "output2\\java\\Easy\\217-available-captures-for-rook.java", "hypo_code": "class Solution {\n    public int numRookCaptures(char[][] board) {\n         int res = 0;\n        int[] dr = {0, 1, 0, -1};\n        int[] dc = {1, 0, -1, 0};\n        int row = board.length;\n        int col = board[0].length;\n        int r = 0;\n        int c = 0;\n        for(int i = 0; i < row; i++){\n            for(int j = 0; j < col; j++){\n                if(board[i][j] == 'R'){\n                    r = i;\n                    c = j;\n                }\n            }\n        }\n        for(int i = 0; i < 4; i++){\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            while(nr >= 0 && nr < row && nc >= 0 && nc < col){\n                if(board[nr][nc] == 'p'){\n                    res++;\n                    break;\n                }else if(board[nr][nc] == 'B'){\n                    break;\n                }\n                nr += dr[i];\n                nc += dc[i];\n            }\n        }\n        return res;\n    }\n}"}
{"id": "218", "path": "output2\\java\\Easy\\218-find-common-characters.java", "hypo_code": "class Solution {\n    public List<String> commonChars(String[] words) {\n        int[] minFreq = new int[26];\n        Arrays.fill(minFreq, Integer.MAX_VALUE);\n        for(String word : words){\n            int[] freq = new int[26];\n            int len = word.length();\n            for(int i = 0; i < len; i++){\n                char ch = word.charAt(i);\n                freq[ch - 'a']++;\n            }\n            for(int i = 0; i < 26; i++){\n                minFreq[i] = Math.min(minFreq[i], freq[i]);\n            }\n        }\n        List<String> res = new ArrayList<>();\n        for(int i = 0; i < 26; i++){\n            for(int j = 0; j < minFreq[i]; j++){\n                res.add(String.valueOf((char)(i + 'a')));\n            }\n        }\n        return res;\n    }\n}"}
{"id": "219", "path": "output2\\java\\Easy\\219-maximize-sum-of-array-after-k-negations.java", "hypo_code": "class Solution {\n    public int largestSumAfterKNegations(int[] nums, int k) {\n        int len = nums.length;\n        Arrays.sort(nums);\n        int i = 0;\n        while(i < len && k > 0){\n            if(nums[i] < 0){\n                nums[i] = -nums[i];\n                k--;\n            }else{\n                break;\n            }\n            i++;\n        }\n        Arrays.sort(nums);\n        if(k > 0 && k % 2 == 1){\n            nums[0] = -nums[0];\n        }\n        int sum = 0;\n        for(int j = 0; j < len; j++){\n            sum += nums[j];\n        }\n        return sum;\n    }\n}"}
{"id": "220", "path": "output2\\java\\Easy\\220-complement-of-base-10-integer.java", "hypo_code": "class Solution {\n    public int bitwiseComplement(int n) {\n        int i = 0;\n        int j = 0;\n        while(i < n){\n            i += Math.pow(2, j);\n            j++;\n        }\n        return i - n;\n    }\n}"}
{"id": "221", "path": "output2\\java\\Easy\\221-partition-array-into-three-parts-with-equal-sum.java", "hypo_code": "class Solution {\n    public boolean canThreePartsEqualSum(int[] arr) {\n         int len = arr.length;\n        int sum = 0;\n        for(int i = 0; i < len; i++){\n            sum += arr[i];\n        }\n        if(sum % 3 != 0) return false;\n        int curSum = 0;\n        int count = 0;\n        for(int i = 0; i < len; i++){\n            curSum += arr[i];\n            if(curSum == sum / 3){\n                count++;\n                curSum = 0;\n            }\n        }\n        return count >= 3;\n    }\n}"}
{"id": "222", "path": "output2\\java\\Easy\\222-binary-prefix-divisible-by-5.java", "hypo_code": "class Solution {\n    public List<Boolean> prefixesDivBy5(int[] nums) {\n        List<Boolean> res = new ArrayList<>();\n        int len = nums.length;\n        int num = 0;\n        for(int i = 0; i < len; i++){\n            num = ((num << 1) + nums[i]) % 5;\n            res.add(num == 0);\n        }\n        return res;\n    }\n}"}
{"id": "223", "path": "output2\\java\\Easy\\223-remove-outermost-parentheses.java", "hypo_code": "class Solution {\n    public String removeOuterParentheses(String s) {\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n        for(char c : s.toCharArray()){\n            if(c == '(' && count++ > 0) sb.append(c);\n            if(c == ')' && count-- > 1) sb.append(c);\n        }\n        return sb.toString();\n    }\n}"}
{"id": "224", "path": "output2\\java\\Easy\\224-sum-of-root-to-leaf-binary-numbers.java", "hypo_code": "class Solution {\n    public int sumRootToLeaf(TreeNode root) {\n       return sumRootToLeaf(root, 0);\n    }\n    public int sumRootToLeaf(TreeNode root, int sum) {\n\t\tif(root == null) return 0;\n\t\tsum = sum * 2 + root.val;\n\t\tif(root.left == null && root.right == null) return sum;\n\t\treturn sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\n\t}\n\n}"}
{"id": "225", "path": "output2\\java\\Easy\\225-divisor-game.java", "hypo_code": "class Solution {\n    public boolean divisorGame(int n) {\n        return n % 2 == 0;\n    }\n}"}
{"id": "226", "path": "output2\\java\\Easy\\226-matrix-cells-in-distance-order.java", "hypo_code": "class Solution {\n    public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {\n        int[][] res = new int[rows * cols][];\n        int index = 0;\n        int maxDist = Math.max(rCenter, rows - 1 - rCenter) + Math.max(cCenter, cols - 1 - cCenter);\n        for(int i = 0; i <= maxDist; i++){\n            for(int j = 0; j <= i; j++){\n                if(i - j == 0){\n                    if(rCenter - j >= 0){\n                        res[index++] = new int[]{rCenter - j, cCenter};\n                    }\n                    if(rCenter + j < rows){\n                        res[index++] = new int[]{rCenter + j, cCenter};\n                    }\n                }else{\n                    if(rCenter - j >= 0){\n                        if(cCenter - i + j >= 0){\n                            res[index++] = new int[]{rCenter - j, cCenter - i + j};\n                        }\n                        if(cCenter + i - j < cols){\n                            res[index++] = new int[]{rCenter - j, cCenter + i - j};\n                        }\n                    }\n                    if(rCenter + j < rows){\n                        if(cCenter - i + j >= 0){\n                            res[index++] = new int[]{rCenter + j, cCenter - i + j};\n                        }\n                        if(cCenter + i - j < cols){\n                            res[index++] = new int[]{rCenter + j, cCenter + i - j};\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "227", "path": "output2\\java\\Easy\\227-valid-boomerang.java", "hypo_code": "class Solution {\n    public boolean isBoomerang(int[][] points) {\n         return (points[0][1] - points[1][1]) * (points[1][0] - points[2][0]) != \n            (points[1][1] - points[2][1]) * (points[0][0] - points[1][0]);\n\n    }\n}"}
{"id": "228", "path": "output2\\java\\Easy\\228-last-stone-weight.java", "hypo_code": "class Solution {\n    public int lastStoneWeight(int[] stones) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        for(int stone : stones){\n            pq.offer(stone);\n        }\n        while(pq.size() > 1){\n            int x = pq.poll();\n            int y = pq.poll();\n            if(x != y){\n                pq.offer(x - y);\n            }\n        }\n        return pq.isEmpty() ? 0 : pq.poll();\n    }\n}"}
{"id": "229", "path": "output2\\java\\Easy\\229-remove-all-adjacent-duplicates-in-string.java", "hypo_code": "class Solution {\n    public String removeDuplicates(String s) {\n         Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (!stack.empty() && stack.peek() == c) {\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        while (!stack.empty()) {\n            sb.append(stack.pop());\n        }\n        return sb.reverse().toString();\n    }\n}"}
{"id": "231", "path": "output2\\java\\Easy\\231-height-checker.java", "hypo_code": "class Solution {\n    public int heightChecker(int[] heights) {\n        int len = heights.length;\n        int[] arr = new int[101];\n        for(int i = 0; i < len; i++){\n            arr[heights[i]]++;\n        }\n        int res = 0;\n        int j = 0;\n        for(int i = 1; i <= 100; i++){\n            while(arr[i] > 0){\n                if(heights[j] != i){\n                    res++;\n                }\n                j++;\n                arr[i]--;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "233", "path": "output2\\java\\Easy\\233-greatest-common-divisor-of-strings.java", "hypo_code": "class Solution {\n    public String gcdOfStrings(String str1, String str2) {\n        if(!(str1 + str2).equals(str2 + str1)) return \"\";\n        int len1 = str1.length();\n        int len2 = str2.length();\n        int len = gcd(len1, len2);\n        return str1.substring(0, len);\n\n    }\n    private int gcd(int a, int b){\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n}"}
{"id": "235", "path": "output2\\java\\Easy\\235-occurrences-after-bigram.java", "hypo_code": "class Solution {\n    public String[] findOcurrences(String text, String first, String second) {\n        List<String> list = new ArrayList<>();\n        String[] words = text.split(\" \");\n        for(int i = 2; i < words.length; i++){\n            if(words[i - 2].equals(first) && words[i - 1].equals(second)){\n                list.add(words[i]);\n            }\n        }\n        return list.toArray(new String[0]);\n\n    }\n}"}
{"id": "237", "path": "output2\\java\\Easy\\237-duplicate-zeros.java", "hypo_code": "class Solution {\n    public void duplicateZeros(int[] arr) {\n        int len = arr.length;\n        int[] res = new int[len];\n        int i = 0, j = 0;\n        while(i < len && j < len){\n            res[j++] = arr[i];\n            if(arr[i++] == 0){\n                res[j++] = 0;\n            }\n        }\n        for(int k = 0; k < len; k++){\n            arr[k] = res[k];\n        }\n    }\n}"}
{"id": "238", "path": "output2\\java\\Easy\\238-distribute-candies-to-people.java", "hypo_code": "class Solution {\n    public int[] distributeCandies(int candies, int num_people) {\n        int[] res = new int[num_people];\n        int i = 0;\n        while(candies > 0){\n            res[i % num_people] += Math.min(candies, i + 1);\n            candies -= i + 1;\n            i++;\n        }\n        return res;\n    }\n}"}
{"id": "239", "path": "output2\\java\\Easy\\239-defanging-an-ip-address.java", "hypo_code": "class Solution {\n    public String defangIPaddr(String address) {\n        return address.replace(\".\", \"[.]\");\n    }\n}"}
{"id": "241", "path": "output2\\java\\Easy\\241-relative-sort-array.java", "hypo_code": "class Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int len1 = arr1.length;\n        int[] res = new int[len1];\n        int[] count = new int[1001];\n        for(int i = 0; i < len1; i++){\n            count[arr1[i]]++;\n        }\n        int index = 0;\n        for(int i = 0; i < arr2.length; i++){\n            while(count[arr2[i]] > 0){\n                res[index++] = arr2[i];\n                count[arr2[i]]--;\n            }\n        }\n        for(int i = 0; i < 1001; i++){\n            while(count[i] > 0){\n                res[index++] = i;\n                count[i]--;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "242", "path": "output2\\java\\Easy\\242-number-of-equivalent-domino-pairs.java", "hypo_code": "class Solution {\n    public int numEquivDominoPairs(int[][] dominoes) {\n        int res = 0;\n        int[] arr = new int[100];\n        for(int[] dominoe : dominoes){\n            int val = dominoe[0] < dominoe[1] ? dominoe[0] * 10 + dominoe[1] : dominoe[1] * 10 + dominoe[0];\n            res += arr[val];\n            arr[val]++;\n        }\n        return res;\n    }\n}"}
{"id": "243", "path": "output2\\java\\Easy\\243-n-th-tribonacci-number.java", "hypo_code": "class Solution {\n    public int tribonacci(int n) {\n        int[] dp = new int[38];\n        dp[0] = 0;\n        dp[1] = 1;\n        dp[2] = 1;\n        for(int i  = 3; i <= n; i++){\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i -3];\n        }\n        return dp[n];\n    }\n}"}
{"id": "246", "path": "output2\\java\\Easy\\246-day-of-the-year.java", "hypo_code": "class Solution {\n    public int dayOfYear(String date) {\n        int[] days = new int[]{0,31,28,31,30,31,30,31,31,30,31,30,31};\n        int year = Integer.parseInt(date.substring(0, 4));\n        int month = Integer.parseInt(date.substring(5, 7));\n        int res = Integer.parseInt(date.substring(8));\n        if(year % 4 == 0 && year % 100 != 0 || year % 400 == 0){\n            days[2] = 29;\n        }\n        for(int i = 1; i < month; i++){\n            res += days[i];\n        }\n        return res;\n    }\n}"}
{"id": "247", "path": "output2\\java\\Easy\\247-find-words-that-can-be-formed-by-characters.java", "hypo_code": "class Solution {\n    public int countCharacters(String[] words, String chars) {\n        int[] charCount = new int[26];\n        for (char c : chars.toCharArray()) {\n            charCount[c - 'a']++;\n        }\n        int res = 0;\n        for (String word : words) {\n            int[] tmp = Arrays.copyOf(charCount, 26);\n            boolean flag = true;\n            for (char c : word.toCharArray()) {\n                if (tmp[c - 'a'] == 0) {\n                    flag = false;\n                    break;\n                }\n                tmp[c - 'a']--;\n            }\n            if (flag) {\n                res += word.length();\n            }\n        }\n        return res;\n    }\n}"}
{"id": "249", "path": "output2\\java\\Easy\\249-prime-arrangements.java", "hypo_code": "class Solution {\n    public int numPrimeArrangements(int n) {\n        int mod = 1000000007;\n        int prime = 0;\n        for(int i = 1; i <= n; i++){\n            if(isPrime(i)){\n                prime++;\n            }\n        }\n        long res = 1;\n        for(int i = 1; i <= prime; i++){\n            res = (res * i) % mod;\n        }\n        for(int i = 1; i <= n - prime; i++){\n            res = (res * i) % mod;\n        }\n        return (int)res;\n    }\n    private boolean isPrime(int n){\n        for(int i = 2; i <= Math.sqrt(n); i++){\n            if(n % i == 0) return false;\n        }\n        return true;\n    }\n}"}
{"id": "251", "path": "output2\\java\\Easy\\251-distance-between-bus-stops.java", "hypo_code": "class Solution {\n    public int distanceBetweenBusStops(int[] distance, int start, int destination) {\n        int len = distance.length;\n        int sum = 0;\n        int res = 0;\n        if(start > destination){\n            int temp = start;\n            start = destination;\n            destination = temp;\n        }\n        for(int i = 0; i < len; i++){\n            sum += distance[i];\n            if(i >= start && i < destination){\n                res += distance[i];\n            }\n        }\n        return Math.min(res, sum - res);\n    }\n}"}
{"id": "252", "path": "output2\\java\\Easy\\252-day-of-the-week.java", "hypo_code": "class Solution {\n    public String dayOfTheWeek(int day, int month, int year) {\n        String[] week = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\t    int[] daysOfMonth = {31,28,31,30,31,30,31,31,30,31,30,31};\n\t    int res = 4;\n\t    for(int i = 1971; i < year; i++){\n\t        res += isLeap(i) ? 366 : 365;\n\t    }\n\t    for(int i = 0; i < month - 1; i++){\n\t        res += daysOfMonth[i];\n\t    }\n\t    res += day;\n\t    if(isLeap(year) && month > 2) res++;\n\t    return week[res % 7];\n    }\n    public boolean isLeap(int year){\n\t    if(year % 100 == 0) return year % 400 == 0;\n\t    return year % 4 == 0;\n\t}\n}"}
{"id": "253", "path": "output2\\java\\Easy\\253-maximum-number-of-balloons.java", "hypo_code": "class Solution {\n    public int maxNumberOfBalloons(String text) {\n        int[] arr = new int[26];\n        for(char ch : text.toCharArray()){\n            arr[ch - 'a']++;\n        }\n        int res = Integer.MAX_VALUE;\n        res = Math.min(res, arr['b' - 'a']);\n        res = Math.min(res, arr['a' - 'a']);\n        res = Math.min(res, arr['l' - 'a'] / 2);\n        res = Math.min(res, arr['o' - 'a'] / 2);\n        res = Math.min(res, arr['n' - 'a']);\n        return res;\n    }\n}"}
{"id": "254", "path": "output2\\java\\Easy\\254-minimum-absolute-difference.java", "hypo_code": "class Solution {\n    public List<List<Integer>> minimumAbsDifference(int[] arr) {\n        List<List<Integer>> res = new ArrayList<>();\n        int len = arr.length;\n        Arrays.sort(arr);\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < len - 1; i++){\n            min = Math.min(min, arr[i + 1] - arr[i]);\n        }\n        for(int i = 0; i < len - 1; i++){\n            if(arr[i + 1] - arr[i] == min){\n                List<Integer> temp = new ArrayList<>();\n                temp.add(arr[i]);\n                temp.add(arr[i + 1]);\n                res.add(temp);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "255", "path": "output2\\java\\Easy\\255-unique-number-of-occurrences.java", "hypo_code": "class Solution {\n    public boolean uniqueOccurrences(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        for (int i: arr) {\n            count.put(i, count.getOrDefault(i, 0) + 1);\n        }\n        return count.size() == new HashSet<Integer>(count.values()).size();\n\n    }\n}"}
{"id": "257", "path": "output2\\java\\Easy\\257-minimum-cost-to-move-chips-to-the-same-position.java", "hypo_code": "class Solution {\n    public int minCostToMoveChips(int[] position) {\n        int len = position.length;\n        int odd = 0, even = 0;\n        for(int i = 0; i < len; i++){\n            if(position[i] % 2 == 0){\n                even++;\n            }else{\n                odd++;\n            }\n        }\n        return Math.min(even, odd);\n    }\n}"}
{"id": "258", "path": "output2\\java\\Easy\\258-split-a-string-in-balanced-strings.java", "hypo_code": "class Solution {\n    public int balancedStringSplit(String s) {\n        int res = 0;\n        int l = 0;\n        int r = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == 'L'){\n                l++;\n            }else{\n                r++;\n            }\n            if(l == r){\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "259", "path": "output2\\java\\Easy\\259-check-if-it-is-a-straight-line.java", "hypo_code": "class Solution {\n    public boolean checkStraightLine(int[][] coordinates) {\n        int len = coordinates.length;\n        if(len < 3) return true;\n        int x0 = coordinates[0][0];\n        int y0 = coordinates[0][1];\n        int x1 = coordinates[1][0];\n        int y1 = coordinates[1][1];\n        for(int i = 2; i < len; i++){\n            int x = coordinates[i][0];\n            int y = coordinates[i][1];\n            if((y1 - y0) * (x - x0) != (y - y0) * (x1 - x0)){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "261", "path": "output2\\java\\Easy\\261-cells-with-odd-values-in-a-matrix.java", "hypo_code": "class Solution {\n    public int oddCells(int m, int n, int[][] indices) {\n        int[][] matrix = new int[m][n];\n        int len = indices.length;\n        for(int i = 0; i < len; i++){\n            for(int j = 0; j < n; j++){\n                matrix[indices[i][0]][j]++;\n            }\n            for(int k = 0; k < m; k++){\n                matrix[k][indices[i][1]]++;\n            }\n        }\n        int count = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n ; j++){\n                if(matrix[i][j] % 2 == 1){\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}"}
{"id": "262", "path": "output2\\java\\Easy\\262-shift-2d-grid.java", "hypo_code": "class Solution {\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\n        int m = grid.length;\n        int n = grid[0].length;\n        k %= m * n;\n        int[] arr = new int[m * n];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                arr[(i * n + j + k) % (m * n)] = grid[i][j];\n            }\n        }\n        List<List<Integer>> res = new ArrayList<>();\n        for(int i = 0; i < m; i++){\n            List<Integer> tmp = new ArrayList<>();\n            for(int j = 0; j < n; j++){\n                tmp.add(arr[i * n + j]);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}"}
{"id": "263", "path": "output2\\java\\Easy\\263-minimum-time-visiting-all-points.java", "hypo_code": "class Solution {\n    public int minTimeToVisitAllPoints(int[][] points) {\n        int len = points.length;\n        int res = 0;\n        for(int i = 1; i < len; i++){\n            int x = Math.abs(points[i][0] - points[i - 1][0]);\n            int y = Math.abs(points[i][1] - points[i - 1][1]);\n            res += Math.min(x, y) + Math.abs(x - y);\n        }\n        return res;\n    }\n}"}
{"id": "264", "path": "output2\\java\\Easy\\264-find-winner-on-a-tic-tac-toe-game.java", "hypo_code": "class Solution {\n    public String tictactoe(int[][] moves) {\n        int[][] board = new int[3][3];\n        int len = moves.length;\n        for(int i = 0; i < len; i++){\n            if(i % 2 == 0){\n                board[moves[i][0]][moves[i][1]] = 1;\n            }else{\n                board[moves[i][0]][moves[i][1]] = 2;\n            }\n        }\n        if(board[0][0] == board[1][1] && board[1][1] == board[2][2]){\n            if(board[0][0] == 1) return \"A\";\n            if(board[0][0] == 2) return \"B\";\n        }\n        if(board[0][2] == board[1][1] && board[1][1] == board[2][0]){\n            if(board[0][2] == 1) return \"A\";\n            if(board[0][2] == 2) return \"B\";\n        }\n        for(int i = 0; i < 3; i++){\n            if(board[i][0] == board[i][1] && board[i][1] == board[i][2]){\n                if(board[i][0] == 1) return \"A\";\n                if(board[i][0] == 2) return \"B\";\n            }\n            if(board[0][i] == board[1][i] && board[1][i] == board[2][i]){\n                if(board[0][i] == 1) return \"A\";\n                if(board[0][i] == 2) return \"B\";\n            }\n        }\n        if(len == 9) return \"Draw\";\n        else return \"Pending\";\n    }\n}"}
{"id": "266", "path": "output2\\java\\Easy\\266-subtract-the-product-and-sum-of-digits-of-an-integer.java", "hypo_code": "class Solution {\n    public int subtractProductAndSum(int n) {\n        int product = 1;\n        int sum = 0;\n        while(n > 0){\n            int cur = n % 10;\n            product *= cur;\n            sum += cur;\n            n /= 10;\n        }\n        return product - sum;\n    }\n}"}
{"id": "267", "path": "output2\\java\\Easy\\267-element-appearing-more-than-25-in-sorted-array.java", "hypo_code": "class Solution {\n    public int findSpecialInteger(int[] arr) {\n        int len = arr.length;\n        int i = 0;\n        while(i < len){\n            int j = i + 1;\n            while(j < len && arr[j] == arr[i]){\n                j++;\n            }\n            if(j - i > len / 4){\n                return arr[i];\n            }\n            i = j;\n        }\n        return -1;\n    }\n}"}
{"id": "268", "path": "output2\\java\\Easy\\268-convert-binary-number-in-a-linked-list-to-integer.java", "hypo_code": "class Solution {\n    public int getDecimalValue(ListNode head) {\n        int result = 0;\n\t\twhile(head != null){\n\t\t\tresult = result * 2 + head.val;\n\t\t\thead = head.next;\n\t\t}\n\t\treturn result;\n\n    }\n}"}
{"id": "269", "path": "output2\\java\\Easy\\269-find-numbers-with-even-number-of-digits.java", "hypo_code": "class Solution {\n    public int findNumbers(int[] nums) {\n        int len = nums.length;\n        int res = 0;\n        for(int i = 0; i < len; i++){\n            if(String.valueOf(nums[i]).length() % 2 == 0){\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "270", "path": "output2\\java\\Easy\\270-replace-elements-with-greatest-element-on-right-side.java", "hypo_code": "class Solution {\n    public int[] replaceElements(int[] arr) {\n        int len = arr.length;\n        int[] res = new int[len];\n        res[len - 1] = -1;\n        for(int i = len - 2; i >= 0; i--){\n            res[i] = Math.max(res[i + 1], arr[i + 1]);\n        }\n        return res;\n    }\n}"}
{"id": "271", "path": "output2\\java\\Easy\\271-find-n-unique-integers-sum-up-to-zero.java", "hypo_code": "class Solution {\n    public int[] sumZero(int n) {\n        int[] res = new int[n];\n        if(n % 2 == 0){\n            for(int i = 0; i < n / 2; i++){\n                res[i] = i + 1;\n                res[n - i - 1] = -i - 1;\n            }\n        }else{\n            res[0] = 0;\n            for(int i = 1; i <= n / 2; i++){\n                res[i] = i;\n                res[n - i] = -i;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "272", "path": "output2\\java\\Easy\\272-decrypt-string-from-alphabet-to-integer-mapping.java", "hypo_code": "class Solution {\n    public String freqAlphabets(String s) {\n        StringBuilder res = new StringBuilder();\n        int len = s.length();\n        for(int i = 0; i < len; i++){\n            if(i + 2 < len && s.charAt(i + 2) == '#'){\n                res.append((char)(Integer.parseInt(s.substring(i, i + 2)) + 'a' - 1));\n                i += 2;\n            }else{\n                res.append((char)(s.charAt(i) - '1' + 'a'));\n            }\n        }\n        return res.toString();\n    }\n}"}
{"id": "273", "path": "output2\\java\\Easy\\273-decompress-run-length-encoded-list.java", "hypo_code": "class Solution {\n    public int[] decompressRLElist(int[] nums) {\n        int len = nums.length;\n        int sum = 0;\n        for(int i = 0; i < len; i += 2){\n            sum += nums[i];\n        }\n        int[] res = new int[sum];\n        int index = 0;\n        for(int i = 0; i < len; i += 2){\n            for(int j = 0; j < nums[i]; j++){\n                res[index++] = nums[i + 1];\n            }\n        }\n        return res;\n    }\n}"}
{"id": "274", "path": "output2\\java\\Easy\\274-convert-integer-to-the-sum-of-two-no-zero-integers.java", "hypo_code": "class Solution {\n    public int[] getNoZeroIntegers(int n) {\n        int[] res = new int[2];\n        for(int i = 1; i < n; i++){\n            int a = i;\n            int b = n - i;\n            if(!containsZero(a) && !containsZero(b)){\n                res[0] = a;\n                res[1] = b;\n                break;\n            }\n        }\n        return res;\n    }\n    private boolean containsZero(int n){\n        while(n != 0){\n            if(n % 10 == 0) return true;\n            n /= 10;\n        }\n        return false;\n    }\n}"}
{"id": "275", "path": "output2\\java\\Easy\\275-maximum-69-number.java", "hypo_code": "class Solution {\n    public int maximum69Number (int num) {\n        int max = num;\n        int n = 1;\n        while(n <= num){\n            int temp = num / n % 10 == 6 ? num + 3 * n : num - 3 * n;\n            max = temp > max ? temp : max;\n            n *= 10;\n        }\n        return max;\n    }\n}"}
{"id": "277", "path": "output2\\java\\Easy\\277-rank-transform-of-an-array.java", "hypo_code": "class Solution {\n    public int[] arrayRankTransform(int[] arr) {\n        int len = arr.length;\n        int[] arrCopy = Arrays.copyOf(arr, len);\n        Arrays.sort(arrCopy);\n        Map<Integer, Integer> map = new HashMap<>();\n        int rank = 1;\n        for(int i = 0; i < len; i++){\n            if(!map.containsKey(arrCopy[i])){\n                map.put(arrCopy[i], rank++);\n            }\n        }\n        for(int i = 0; i < len; i++){\n            arr[i] = map.get(arr[i]);\n        }\n        return arr;\n    }\n}"}
{"id": "278", "path": "output2\\java\\Easy\\278-remove-palindromic-subsequences.java", "hypo_code": "class Solution {\n    public int removePalindromeSub(String s) {\n        if(s.length() == 0){\n            return 0;\n        }\n        if(isPalindromic(s)){\n            return 1;\n        }\n        return 2;\n    }\n    public boolean isPalindromic(String s){\n        int len = s.length();\n        for(int i = 0; i < len / 2; i++){\n            if(s.charAt(i) != s.charAt(len - 1 - i)){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "279", "path": "output2\\java\\Easy\\279-the-k-weakest-rows-in-a-matrix.java", "hypo_code": "class Solution {\n    public int[] kWeakestRows(int[][] mat, int k) {\n        int[] arr = new int[mat.length];\n        for(int i = 0; i < mat.length; i++){\n            int count = 0;\n            for(int j = 0; j < mat[0].length; j++){\n                if(mat[i][j] == 1){\n                    count++;\n                }\n            }\n            arr[i] = count * 100 + i;\n        }\n        Arrays.sort(arr);\n        int[] ans = new int[k];\n        for(int i = 0; i < k; i++){\n            ans[i] = arr[i] % 100;\n        }\n        return ans;\n\n    }\n}"}
{"id": "280", "path": "output2\\java\\Easy\\280-number-of-steps-to-reduce-a-number-to-zero.java", "hypo_code": "class Solution {\n    public int numberOfSteps(int num) {\n        int res = 0;\n        while(num > 0){\n            if(num % 2 == 0){\n                num /= 2;\n            }else{\n                num--;\n            }\n            res++;\n        }\n        return res;\n    }\n}"}
{"id": "281", "path": "output2\\java\\Easy\\281-check-if-n-and-its-double-exist.java", "hypo_code": "class Solution {\n    public boolean checkIfExist(int[] arr) {\n        for(int i = 0; i < arr.length; i++){\n            for(int j = 0; j < arr.length && i != j; j++){\n                if(arr[i] == 2 * arr[j]){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}"}
{"id": "282", "path": "output2\\java\\Easy\\282-count-negative-numbers-in-a-sorted-matrix.java", "hypo_code": "class Solution {\n    public int countNegatives(int[][] grid) {\n        int res = 0;\n        for(int i = 0; i < grid.length; i++){\n            for(int j = grid[i].length - 1; j >= 0; j--){\n                if(grid[i][j] >= 0){\n                    break;\n                }\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "283", "path": "output2\\java\\Easy\\283-sort-integers-by-the-number-of-1-bits.java", "hypo_code": "class Solution {\n    public int[] sortByBits(int[] arr) {\n        int[] res = new int[arr.length];\n        for(int i = 0; i < arr.length; i++){\n            int count = 0;\n            int n = arr[i];\n            while(n > 0){\n                if(n % 2 == 1){\n                    count++;\n                }\n                n /= 2;\n            }\n            res[i] = count * 100000 + arr[i];\n        }\n        Arrays.sort(res);\n        for(int i = 0; i < res.length; i++){\n            res[i] = res[i] % 100000;\n        }\n        return res;\n    }\n}"}
{"id": "284", "path": "output2\\java\\Easy\\284-number-of-days-between-two-dates.java", "hypo_code": "class Solution {\n    public int daysBetweenDates(String date1, String date2) {\n        int[] days = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};\n        int[] daysLeap = new int[]{31,29,31,30,31,30,31,31,30,31,30,31};\n        int res = 0;\n        String[] date1Array = date1.split(\"-\");\n        String[] date2Array = date2.split(\"-\");\n        int year1 = Integer.valueOf(date1Array[0]);\n        int year2 = Integer.valueOf(date2Array[0]);\n        int month1 = Integer.valueOf(date1Array[1]);\n        int month2 = Integer.valueOf(date2Array[1]);\n        int day1 = Integer.valueOf(date1Array[2]);\n        int day2 = Integer.valueOf(date2Array[2]);\n        for(int i = year1; i < year2; i++){\n            if(isLeap(i)){\n                res += 366;\n            }else{\n                res += 365;\n            }\n        }\n        if(isLeap(year1)){\n            for(int i = 0; i < month1 - 1; i++){\n                res -= daysLeap[i];\n            }\n            res -= day1;\n        }else{\n            for(int i = 0; i < month1 - 1; i++){\n                res -= days[i];\n            }\n            res -= day1;\n        }\n        if(isLeap(year2)){\n            for(int i = 0; i < month2 - 1; i++){\n                res += daysLeap[i];\n            }\n            res += day2;\n        }else{\n            for(int i = 0; i < month2 - 1; i++){\n                res += days[i];\n            }\n            res += day2;\n        }\n        return Math.abs(res);\n    }\n    private boolean isLeap(int year){\n        if(year % 400 == 0){\n            return true;\n        }else if(year % 100 == 0){\n            return false;\n        }else if(year % 4 == 0){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}"}
{"id": "285", "path": "output2\\java\\Easy\\285-how-many-numbers-are-smaller-than-the-current-number.java", "hypo_code": "class Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] res = new int[nums.length];\n        for(int i = 0; i < nums.length; i++){\n            int count = 0;\n            int n = nums[i];\n            for(int j = 0; j < nums.length; j++){\n                if(n > nums[j]){\n                    count++;\n                }\n            }\n            res[i] = count;\n        }\n        return res;\n    }\n}"}
{"id": "286", "path": "output2\\java\\Easy\\286-increasing-decreasing-string.java", "hypo_code": "class Solution {\n    public String sortString(String s) {\n        int[] count = new int[26];\n        for(char c : s.toCharArray()){\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while(sb.length() < s.length()){\n            for(int i = 0; i < 26; i++){\n                if(count[i] > 0){\n                    sb.append((char) (i + 'a'));\n                    count[i]--;\n                }\n            }\n            for(int i = 25; i >= 0; i--){\n                if(count[i] > 0){\n                    sb.append((char) (i + 'a'));\n                    count[i]--;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "287", "path": "output2\\java\\Easy\\287-generate-a-string-with-characters-that-have-odd-counts.java", "hypo_code": "class Solution {\n    public String generateTheString(int n) {\n        StringBuilder sb = new StringBuilder();\n        if(n % 2 == 0){\n            sb.append(\"a\");\n            n--;\n        }\n        for(int i = 0; i < n; i++){\n            sb.append(\"b\");\n        }\n        return sb.toString();\n    }\n}"}
{"id": "290", "path": "output2\\java\\Easy\\290-lucky-numbers-in-a-matrix.java", "hypo_code": "class Solution {\n    public List<Integer> luckyNumbers (int[][] matrix) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = 0; i < matrix.length; i++){\n            int min = Integer.MAX_VALUE;\n            int index = 0;\n            for(int j = 0; j < matrix[i].length; j++){\n                if(matrix[i][j] < min){\n                    min = matrix[i][j];\n                    index = j;\n                }\n            }\n            boolean flag = true;\n            for(int j = 0; j < matrix.length; j++){\n                if(matrix[j][index] > min){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                res.add(min);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "291", "path": "output2\\java\\Easy\\291-find-the-distance-value-between-two-arrays.java", "hypo_code": "class Solution {\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\n        int res = 0;\n        boolean flag = true;\n        for(int i = 0; i < arr1.length; i++){\n            flag = true;\n            for(int j = 0; j < arr2.length; j++){\n                if(Math.abs(arr1[i] - arr2[j]) <= d){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                res++;\n            }\n        }\n        return res;\n\n    }\n}"}
{"id": "292", "path": "output2\\java\\Easy\\292-create-target-array-in-the-given-order.java", "hypo_code": "class Solution {\n    public int[] createTargetArray(int[] nums, int[] index) {\n        int[] res = new int[nums.length];\n        List<Integer> list = new ArrayList<Integer>();\n        for(int i = 0; i < nums.length; i++){\n            list.add(index[i], nums[i]);\n        }\n        for(int i = 0; i < nums.length; i++){\n            res[i] = list.get(i);\n        }\n        return res;\n    }\n}"}
{"id": "293", "path": "output2\\java\\Easy\\293-find-lucky-integer-in-an-array.java", "hypo_code": "class Solution {\n    public int findLucky(int[] arr) {\n        int[] count = new int[501];\n        for(int i = 0; i < arr.length; i++){\n            count[arr[i]]++;\n        }\n        for(int i = count.length - 1; i >= 1; i--){\n            if(count[i] == i){\n                return i;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "294", "path": "output2\\java\\Easy\\294-count-largest-group.java", "hypo_code": "class Solution {\n    public int countLargestGroup(int n) {\n        int[] count = new int[37];\n        for(int i = 1; i <= n; i++){\n            int sum = 0;\n            int m = i;\n            while(m > 0){\n                sum += m % 10;\n                m /= 10;\n            }\n            count[sum]++;\n        }\n        int max = 0;\n        int res = 0;\n        for(int i = 0; i < count.length; i++){\n            if(count[i] > max){\n                max = count[i];\n                res = 1;\n            }else if(count[i] == max){\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "295", "path": "output2\\java\\Easy\\295-minimum-subsequence-in-non-increasing-order.java", "hypo_code": "class Solution {\n    public List<Integer> minSubsequence(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        Arrays.sort(nums);\n        int sum = 0;\n        for(int n : nums){\n            sum += n;\n        }\n        int temp = 0;\n        for(int i = nums.length - 1; i >= 0; i--){\n            temp += nums[i];\n            res.add(nums[i]);\n            if(temp > sum - temp){\n                break;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "297", "path": "output2\\java\\Easy\\297-string-matching-in-an-array.java", "hypo_code": "class Solution {\n    public List<String> stringMatching(String[] words) {\n        List<String> res = new ArrayList<String>();\n        for(int i = 0; i < words.length; i++){\n            String s = words[i];\n            for(int j = 0; j < words.length; j++){\n                if(i != j){\n                    if(words[j].contains(s)){\n                        res.add(s);\n                        break;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "298", "path": "output2\\java\\Easy\\298-minimum-value-to-get-positive-step-by-step-sum.java", "hypo_code": "class Solution {\n    public int minStartValue(int[] nums) {\n        int res = 0;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            sum += nums[i];\n            res = Math.min(res, sum);\n        }\n        return 1 - res;\n    }\n}"}
{"id": "299", "path": "output2\\java\\Easy\\299-reformat-the-string.java", "hypo_code": "class Solution {\n    public String reformat(String s) {\n        StringBuilder sb = new StringBuilder();\n        StringBuilder sb2 = new StringBuilder();\n        for(char c : s.toCharArray()){\n            if(Character.isDigit(c)){\n                sb.append(c);\n            } else {\n                sb2.append(c);\n            }\n        }\n        String s1 = sb.toString();\n        String s2 = sb2.toString();\n        if(s1.length() - s2.length() >= 2 || s2.length() - s1.length() >= 2){\n            return \"\";\n        }\n        int i = 0;\n        int j = 0;\n        sb = new StringBuilder();\n        while(i < s1.length() || j < s2.length()){\n            if(i < s1.length()){\n                sb.append(s1.charAt(i));\n                i++;\n            }\n            if(j < s2.length()){\n                sb.append(s2.charAt(j));\n                j++;\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "300", "path": "output2\\java\\Easy\\300-maximum-score-after-splitting-a-string.java", "hypo_code": "class Solution {\n    public int maxScore(String s) {\n        int res = 0;\n        int[] zero = new int[s.length()];\n        int[] one = new int[s.length()];\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == '0'){\n                if(i == 0){\n                    zero[i] = 1;\n                }else{\n                    zero[i] = zero[i - 1] + 1;\n                }\n            }else{\n                if(i == 0){\n                    zero[i] = 0;\n                }else{\n                    zero[i] = zero[i - 1];\n                }\n            }\n        }\n        for(int i = s.length() - 1; i >= 0; i--){\n            if(s.charAt(i) == '1'){\n                if(i == s.length() - 1){\n                    one[i] = 1;\n                }else{\n                    one[i] = one[i + 1] + 1;\n                }\n            }else{\n                if(i == s.length() - 1){\n                    one[i] = 0;\n                }else{\n                    one[i] = one[i + 1];\n                }\n            }\n        }\n        for(int i = 0; i < s.length() - 1; i++){\n            res = Math.max(res, zero[i] + one[i + 1]);\n        }\n        return res;\n    }\n}"}
{"id": "301", "path": "output2\\java\\Easy\\301-kids-with-the-greatest-number-of-candies.java", "hypo_code": "class Solution {\n    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {\n        List<Boolean> res = new LinkedList<>();\n        int max = 0;\n        for(int i = 0; i < candies.length; i++){\n            if(candies[i] > max){\n                max = candies[i];\n            }\n        }\n        for(int i = 0; i < candies.length; i++){\n            if(candies[i] + extraCandies >= max){\n                res.add(true);\n            }else{\n                res.add(false);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "302", "path": "output2\\java\\Easy\\302-destination-city.java", "hypo_code": "class Solution {\n    public String destCity(List<List<String>> paths) {\n         String res = \"\";\n        Map<String, String> map = new HashMap<String, String>();\n        for(List<String> list : paths){\n            map.put(list.get(0), list.get(1));\n        }\n        for(String s : map.keySet()){\n            if(!map.containsKey(map.get(s))){\n                res = map.get(s);\n                break;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "303", "path": "output2\\java\\Easy\\303-check-if-all-1s-are-at-least-length-k-places-away.java", "hypo_code": "class Solution {\n    public boolean kLengthApart(int[] nums, int k) {\n        int count = 0;\n        boolean flag = false;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == 1 && !flag){\n                flag = true;\n            }else if(nums[i] == 1 && flag){\n                if(count < k){\n                    return false;\n                }\n                count = 0;\n            }else if(nums[i] == 0 && flag){\n                count++;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "304", "path": "output2\\java\\Easy\\304-consecutive-characters.java", "hypo_code": "class Solution {\n    public int maxPower(String s) {\n        int res = 1;\n        int count = 1;\n        for(int i = 1; i < s.length(); i++){\n            if(s.charAt(i) == s.charAt(i - 1)){\n                count++;\n            }else{\n                count = 1;\n            }\n            res = Math.max(res, count);\n        }\n        return res;\n    }\n}"}
{"id": "305", "path": "output2\\java\\Easy\\305-number-of-students-doing-homework-at-a-given-time.java", "hypo_code": "class Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int res = 0;\n        for(int i = 0; i < startTime.length; i++){\n            if(endTime[i] >= queryTime && startTime[i] <= queryTime){\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "306", "path": "output2\\java\\Easy\\306-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence.java", "hypo_code": "class Solution {\n    public int isPrefixOfWord(String sentence, String searchWord) {\n        String[] words = sentence.split(\" \");\n        for(int i = 0; i < words.length; i++){\n            String s = words[i];\n            if(s.length() >= searchWord.length()){\n                if(s.substring(0, searchWord.length()).equals(searchWord)){\n                    return i + 1;\n                }\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "307", "path": "output2\\java\\Easy\\307-make-two-arrays-equal-by-reversing-subarrays.java", "hypo_code": "class Solution {\n    public boolean canBeEqual(int[] target, int[] arr) {\n          int[] count = new int[1001];\n        for(int i = 0; i < target.length; i++){\n            count[target[i]]++;\n            count[arr[i]]--;\n        }\n        for(int i = 0; i < count.length; i++){\n            if(count[i] != 0){\n                return false;\n            }\n        }\n        return true;              \n\n\n    }\n}"}
{"id": "308", "path": "output2\\java\\Easy\\308-maximum-product-of-two-elements-in-an-array.java", "hypo_code": "class Solution {\n    public int maxProduct(int[] nums) {\n        int max1 = 0;\n        int max2 = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] > max1){\n                max2 = max1;\n                max1 = nums[i];\n            }\n            else if(nums[i] > max2){\n                max2 = nums[i];\n            }\n        }\n        return (max1 - 1) * (max2 - 1);\n    }\n}"}
{"id": "309", "path": "output2\\java\\Easy\\309-shuffle-the-array.java", "hypo_code": "class Solution {\n    public int[] shuffle(int[] nums, int n) {\n        int[] res = new int[nums.length];\n        int j = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(i % 2 == 0){\n                res[i] = nums[j];\n            }else{\n                res[i] = nums[n + j];\n                j++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "310", "path": "output2\\java\\Easy\\310-final-prices-with-a-special-discount-in-a-shop.java", "hypo_code": "class Solution {\n    public int[] finalPrices(int[] prices) {\n        int[] res = new int[prices.length];\n        for(int i = 0; i < prices.length; i++){\n            int n = prices[i];\n            res[i] = n;\n            for(int j = i + 1; j < prices.length; j++){\n                if(n >= prices[j]){\n                    res[i] = n - prices[j];\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "311", "path": "output2\\java\\Easy\\311-running-sum-of-1d-array.java", "hypo_code": "class Solution {\n    public int[] runningSum(int[] nums) {\n        int[] res = new int[nums.length];\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            sum += nums[i];\n            res[i] = sum;\n        }\n        return res;\n    }\n}"}
{"id": "313", "path": "output2\\java\\Easy\\313-xor-operation-in-an-array.java", "hypo_code": "class Solution {\n    public int xorOperation(int n, int start) {\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            int m = start + 2 * i;\n            res = res ^ m;\n        }\n        return res;\n    }\n}"}
{"id": "314", "path": "output2\\java\\Easy\\314-average-salary-excluding-the-minimum-and-maximum-salary.java", "hypo_code": "class Solution {\n    public double average(int[] salary) {\n        Arrays.sort(salary);\n        double sum = 0;\n        for(int i = 1; i < salary.length - 1; i++){\n            sum += salary[i];\n        }\n        return sum / (salary.length - 2);\n    }\n}"}
{"id": "315", "path": "output2\\java\\Easy\\315-path-crossing.java", "hypo_code": "class Solution {\n    public boolean isPathCrossing(String path) {\n        Set<String> set = new HashSet<>();\n        set.add(\"0,0\");\n        int x = 0;\n        int y = 0;\n        for(int i = 0; i < path.length(); i++){\n            char c = path.charAt(i);\n            if(c == 'N'){\n                y++;\n            }else if(c == 'S'){\n                y--;\n            }else if(c == 'E'){\n                x++;\n            }else if(c == 'W'){\n                x--;\n            }\n            String s = x + \",\" + y;\n            if(set.contains(s)){\n                return true;\n            }\n            set.add(s);\n        }\n        return false;\n    }\n}"}
{"id": "316", "path": "output2\\java\\Easy\\316-can-make-arithmetic-progression-from-sequence.java", "hypo_code": "class Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        if(arr.length == 2){\n            return true;\n        }\n        Arrays.sort(arr);\n        int diff = arr[1] - arr[0];\n        for(int i = 2; i < arr.length; i++){\n            if(arr[i] - arr[i - 1] != diff){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "317", "path": "output2\\java\\Easy\\317-reformat-date.java", "hypo_code": "class Solution {\n    public String reformatDate(String date) {\n        String[] dateArray = date.split(\" \");\n        String day = dateArray[0];\n        String month = dateArray[1];\n        String year = dateArray[2];\n        String res = year + \"-\";\n        switch(month){\n            case \"Jan\":\n                res += \"01-\";\n                break;\n            case \"Feb\":\n                res += \"02-\";\n                break;\n            case \"Mar\":\n                res += \"03-\";\n                break;\n            case \"Apr\":\n                res += \"04-\";\n                break;\n            case \"May\":\n                res += \"05-\";\n                break;\n            case \"Jun\":\n                res += \"06-\";\n                break;\n            case \"Jul\":\n                res += \"07-\";\n                break;\n            case \"Aug\":\n                res += \"08-\";\n                break;\n            case \"Sep\":\n                res += \"09-\";\n                break;\n            case \"Oct\":\n                res += \"10-\";\n                break;\n            case \"Nov\":\n                res += \"11-\";\n                break;\n            case \"Dec\":\n                res += \"12-\";\n                break;\n        }\n        if(day.length() == 3){\n            res += \"0\";\n        }\n        res += day.substring(0, day.length() - 2);\n        return res;\n    }\n}"}
{"id": "318", "path": "output2\\java\\Easy\\318-number-of-good-pairs.java", "hypo_code": "class Solution {\n    public int numIdenticalPairs(int[] nums) {\n        int res = 0;\n        for(int i = 0; i < nums.length; i++){\n            int n = nums[i];\n            for(int j = 0; j < nums.length && j != i; j++){\n                if(n == nums[j]){\n                    res++;\n                }\n            }\n        }\n        return res / 2;\n    }\n}"}
{"id": "320", "path": "output2\\java\\Easy\\320-water-bottles.java", "hypo_code": "class Solution {\n    public int numWaterBottles(int numBottles, int numExchange) {\n        int res = 0;\n        int empty = 0;\n        while(numBottles > 0){\n            res += numBottles;\n            empty += numBottles;\n            numBottles = empty / numExchange;\n            empty = empty % numExchange;\n        }\n        return res;\n    }\n}"}
{"id": "321", "path": "output2\\java\\Easy\\321-count-odd-numbers-in-an-interval-range.java", "hypo_code": "class Solution {\n    public int countOdds(int low, int high) {\n        int count = 0;\n        if(low % 2 == 0){\n            low++;\n        }\n        if(high % 2 == 0){\n            high--;\n        }\n        return (high - low) / 2 + 1;\n    }\n}"}
{"id": "323", "path": "output2\\java\\Easy\\323-shuffle-string.java", "hypo_code": "class Solution {\n    public String restoreString(String s, int[] indices) {\n        char[] chars = new char[indices.length];\n        for(int i = 0; i < indices.length; i++){\n            chars[indices[i]] = s.charAt(i);\n        }\n        return new String(chars);\n    }\n}"}
{"id": "324", "path": "output2\\java\\Easy\\324-count-good-triplets.java", "hypo_code": "class Solution {\n    public int countGoodTriplets(int[] arr, int a, int b, int c) {\n        int count = 0;\n        boolean flag = false;\n        for(int i = 0; i < arr.length - 2; i++){\n            for(int j = i + 1; j < arr.length - 1; j++){\n                flag = false;\n                if(Math.abs(arr[i] - arr[j]) <= a){\n                    for(int k = j + 1; k < arr.length; k++){\n                        if(Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c){\n                            flag = true;\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}"}
{"id": "325", "path": "output2\\java\\Easy\\325-kth-missing-positive-number.java", "hypo_code": "class Solution {\n    public int findKthPositive(int[] arr, int k) {\n        int res = 0;\n        int i = 1;\n        int j = 0;\n        while(j < arr.length){\n            if(arr[j] == i){\n                j++;\n            }else{\n                k--;\n            }\n            if(k == 0){\n                res = i;\n                break;\n            }\n            i++;\n        }\n        if(k > 0){\n            res = arr[arr.length - 1] + k;\n        }\n        return res;\n    }\n}"}
{"id": "326", "path": "output2\\java\\Easy\\326-make-the-string-great.java", "hypo_code": "class Solution {\n    public String makeGood(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(!stack.isEmpty() && Math.abs(stack.peek() - c) == 32){\n                stack.pop();\n            } else {\n                stack.push(c);\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()){\n            sb.append(stack.pop());\n        }\n        return sb.reverse().toString();\n    }\n}"}
{"id": "327", "path": "output2\\java\\Easy\\327-three-consecutive-odds.java", "hypo_code": "class Solution {\n    public boolean threeConsecutiveOdds(int[] arr) {\n        int count = 0;\n        for(int i = 0; i < arr.length; i++){\n            if(arr[i] % 2 != 0){\n                count++;\n                if(count == 3){\n                    return true;\n                }\n            }else{\n                count = 0;\n            }\n        }\n        return false;\n    }\n}"}
{"id": "328", "path": "output2\\java\\Easy\\328-thousand-separator.java", "hypo_code": "class Solution {\n    public String thousandSeparator(int n) {\n        String s = Integer.toString(n);\n        StringBuilder res = new StringBuilder();\n        int count = 0;\n        for(int i = s.length() - 1; i >= 0; i--){\n            if(count == 3){\n                res.append('.');\n                count = 0;\n            }\n            res.append(s.charAt(i));\n            count++;\n        }\n        return res.reverse().toString();\n    }\n}"}
{"id": "329", "path": "output2\\java\\Easy\\329-most-visited-sector-in-a-circular-track.java", "hypo_code": "class Solution {\n    public List<Integer> mostVisited(int n, int[] rounds) {\n        List<Integer> res = new ArrayList<>();\n        int[] count = new int[n + 1];\n        for(int i = 0; i < rounds.length - 1; i++){\n            int start = rounds[i];\n            int end = rounds[i + 1];\n            if(start == end){\n                count[start]++;\n            }else if(start < end){\n                for(int j = start; j < end; j++){\n                    count[j]++;\n                }\n            }else{\n                for(int j = start; j <= n; j++){\n                    count[j]++;\n                }\n                for(int j = 1; j < end; j++){\n                    count[j]++;\n                }\n            }\n        }\n        count[rounds[rounds.length - 1]]++;\n        int max = 0;\n        for(int i = 0; i < count.length; i++){\n            max = Math.max(max, count[i]);\n        }\n        for(int i = 0; i < count.length; i++){\n            if(count[i] == max){\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "330", "path": "output2\\java\\Easy\\330-detect-pattern-of-length-m-repeated-k-or-more-times.java", "hypo_code": "class Solution {\n    public boolean containsPattern(int[] arr, int m, int k) {\n        for(int i = 0; i <= arr.length - m * k; i++){\n            int count = 1;\n            for(int j = i; j < arr.length - m; j += m){\n                if(arr[j] != arr[j + m]){\n                    break;\n                }\n                else{\n                    count++;\n                }\n            }\n            if(count == k){\n                return true;\n            }\n        }\n        return false;\n    }\n}"}
{"id": "331", "path": "output2\\java\\Easy\\331-matrix-diagonal-sum.java", "hypo_code": "class Solution {\n    public int diagonalSum(int[][] mat) {\n        int res = 0;\n        for(int i = 0; i < mat.length; i++){\n            res += mat[i][i];\n            res += mat[i][mat.length - 1 - i];\n        }\n        if(mat.length % 2 == 1){\n            res -= mat[mat.length / 2][mat.length / 2];\n        }\n        return res;\n    }\n}"}
{"id": "332", "path": "output2\\java\\Easy\\332-replace-all-s-to-avoid-consecutive-repeating-characters.java", "hypo_code": "class Solution {\n    public String modifyString(String s) {\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == '?'){\n                char c = 'a';\n                while(i > 0 && sb.charAt(i - 1) == c || i < s.length() - 1 && s.charAt(i + 1) == c){\n                    c++;\n                }\n                sb.append(c);\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "334", "path": "output2\\java\\Easy\\334-special-positions-in-a-binary-matrix.java", "hypo_code": "class Solution {\n    public int numSpecial(int[][] mat) {\n        int res = 0;\n        int[] row = new int[mat.length];\n        int[] col = new int[mat[0].length];\n        for(int i = 0; i < mat.length; i++){\n            int count = 0;\n            for(int j = 0; j < mat[i].length; j++){\n                if(mat[i][j] == 1){\n                    count++;\n                }\n            }\n            row[i] = count;\n        }\n        for(int j = 0; j < mat[0].length; j++){\n            int count = 0;\n            for(int i = 0; i < mat.length; i++){\n                if(mat[i][j] == 1){\n                    count++;\n                }\n            }\n            col[j] = count;\n        }\n        for(int i = 0; i < mat.length; i++){\n            if(row[i] == 1){\n                for(int j = 0; j < mat[i].length; j++){\n                    if(mat[i][j] == 1 && col[j] == 1){\n                        res++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "336", "path": "output2\\java\\Easy\\336-sum-of-all-odd-length-subarrays.java", "hypo_code": "class Solution {\n    public int sumOddLengthSubarrays(int[] arr) {\n        int res = 0;\n        for(int i = 0; i < arr.length; i++){\n            int left = i + 1;\n            int right = arr.length - i;\n            int left_even = (left + 1) / 2;\n            int right_even = (right + 1) / 2;\n            int left_odd = left / 2;\n            int right_odd = right / 2;\n            res += arr[i] * (left_even * right_even + left_odd * right_odd);\n        }\n        return res;\n    }\n}"}
{"id": "337", "path": "output2\\java\\Easy\\337-rearrange-spaces-between-words.java", "hypo_code": "class Solution {\n    public String reorderSpaces(String text) {\n        int spaces = 0;\n        for(char c : text.toCharArray()){\n            if(c == ' '){\n                spaces++;\n            }\n        }\n        String[] words = text.trim().split(\"\\\\s+\");\n        if(words.length == 1){\n            return words[0] + \" \".repeat(spaces);\n        }\n        int each = spaces / (words.length - 1);\n        int extra = spaces % (words.length - 1);\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < words.length; i++){\n            sb.append(words[i]);\n            if(i < words.length - 1){\n                sb.append(\" \".repeat(each));\n            }\n        }\n        sb.append(\" \".repeat(extra));\n        return sb.toString();\n    }\n}"}
{"id": "338", "path": "output2\\java\\Easy\\338-crawler-log-folder.java", "hypo_code": "class Solution {\n    public int minOperations(String[] logs) {\n        int res = 0;\n        for(int i = 0; i < logs.length; i++){\n            if(logs[i].equals(\"../\")){\n                if(res > 0){\n                    res--;\n                }\n            }else if(logs[i].equals(\"./\")){\n                continue;\n            }else{\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "340", "path": "output2\\java\\Easy\\340-special-array-with-x-elements-greater-than-or-equal-x.java", "hypo_code": "class Solution {\n    public int specialArray(int[] nums) {\n        int[] count = new int[1001];\n        for(int i = 0; i < nums.length; i++){\n            count[nums[i]]++;\n        }\n        for(int i = count.length - 1; i >= 0; i--){\n            if(i == nums.length - count[i]){\n                return i;\n            }\n            if(i < nums.length - count[i]){\n                return -1;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "341", "path": "output2\\java\\Easy\\341-maximum-nesting-depth-of-the-parentheses.java", "hypo_code": "class Solution {\n    public int maxDepth(String s) {\n        int res = 0;\n        int count = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == '('){\n                count++;\n            }else if(s.charAt(i) == ')'){\n                count--;\n            }\n            res = Math.max(res, count);\n        }\n        return res;\n    }\n}"}
{"id": "342", "path": "output2\\java\\Easy\\342-mean-of-array-after-removing-some-elements.java", "hypo_code": "class Solution {\n    public double trimMean(int[] arr) {\n        Arrays.sort(arr);\n        int start = (int)(arr.length * 0.05);\n        int end = arr.length - start;\n        int sum = 0;\n        for(int i = start; i < end; i++){\n            sum += arr[i];\n        }\n        return sum / (double)(end - start);\n    }\n}"}
{"id": "343", "path": "output2\\java\\Easy\\343-largest-substring-between-two-equal-characters.java", "hypo_code": "class Solution {\n    public int maxLengthBetweenEqualCharacters(String s) {\n        int res = -1;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = s.length() - 1; j >= i; j--){\n                if(s.charAt(i) == s.charAt(j)){\n                    res = Math.max(res, j - i - 1);\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "344", "path": "output2\\java\\Easy\\344-slowest-key.java", "hypo_code": "class Solution {\n    public char slowestKey(int[] releaseTimes, String keysPressed) {\n        int[] time = new int[26];\n        time[keysPressed.charAt(0) - 'a'] = releaseTimes[0];\n        for(int i = 1; i < releaseTimes.length; i++){\n            int idx = keysPressed.charAt(i) - 'a';\n            time[idx] = Math.max(time[idx], releaseTimes[i] - releaseTimes[i - 1]);\n        }\n        int max = 0;\n        char res = 'a';\n        for(int i = 0; i < time.length; i++){\n            if(time[i] >= max){\n                max = time[i];\n                res = (char)('a' + i);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "346", "path": "output2\\java\\Easy\\346-sort-array-by-increasing-frequency.java", "hypo_code": "class Solution {\n    public int[] frequencySort(int[] nums) {\n        int[] count = new int[201];\n        for(int i = 0; i < nums.length; i++){\n            count[nums[i] + 100]++;\n        }\n        int[] res = new int[nums.length];\n        int index = 0;\n        for(int i = 0; i < 201; i++){\n            if(count[i] == 0){\n                continue;\n            }\n            for(int j = 0; j < count[i]; j++){\n                res[index++] = i - 100;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "347", "path": "output2\\java\\Easy\\347-check-array-formation-through-concatenation.java", "hypo_code": "class Solution {\n    public boolean canFormArray(int[] arr, int[][] pieces) {\n        Map<Integer, int[]> map = new HashMap<>();\n        for(int[] piece : pieces){\n            map.put(piece[0], piece);\n        }\n        for(int i = 0; i < arr.length; i++){\n            if(map.containsKey(arr[i])){\n                int[] piece = map.get(arr[i]);\n                for(int j = 0; j < piece.length; j++){\n                    if(piece[j] != arr[i++]){\n                        return false;\n                    }\n                }\n                i--;\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "348", "path": "output2\\java\\Easy\\348-get-maximum-in-generated-array.java", "hypo_code": "class Solution {\n    public int getMaximumGenerated(int n) {\n        if(n < 2){\n            return n;\n        }\n        int[] nums = new int[n + 1];\n        nums[1] = 1;\n        int max = 1;\n        for(int i = 2; i <= n; i++){\n            nums[i] = nums[i / 2] + (i % 2) * nums[i / 2 + 1];\n            max = Math.max(max, nums[i]);\n        }\n        return max;\n    }\n}"}
{"id": "349", "path": "output2\\java\\Easy\\349-defuse-the-bomb.java", "hypo_code": "class Solution {\n    public int[] decrypt(int[] code, int k) {\n        int[] res = new int[code.length];\n        if(k == 0){\n            return res;\n        }\n        if(k > 0){\n            for(int i = 0; i < code.length; i++){\n                int sum = 0;\n                for(int j = 1; j <= k; j++){\n                    sum += code[(i + j) % code.length];\n                }\n                res[i] = sum;\n            }\n        }else{\n            for(int i = 0; i < code.length; i++){\n                int sum = 0;\n                for(int j = 1; j <= -k; j++){\n                    sum += code[(code.length + (i - j)) % code.length];\n                }\n                res[i] = sum;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "352", "path": "output2\\java\\Easy\\352-check-if-two-string-arrays-are-equivalent.java", "hypo_code": "class Solution {\n    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {\n        String s1 = \"\", s2 = \"\";\n        for (String s : word1) {\n            s1 += s;\n        }\n        for (String s : word2) {\n            s2 += s;\n        }\n        return s1.equals(s2);\n    }\n}"}
{"id": "354", "path": "output2\\java\\Easy\\354-maximum-repeating-substring.java", "hypo_code": "class Solution {\n    public int maxRepeating(String sequence, String word) {\n        int count = 0;\n        String s = word;\n        while (sequence.contains(s)) {\n            s += word;\n            count++;\n        }\n        return count;\n    }\n}"}
{"id": "355", "path": "output2\\java\\Easy\\355-richest-customer-wealth.java", "hypo_code": "class Solution {\n    public int maximumWealth(int[][] accounts) {\n        int max = 0;\n        for (int[] a : accounts) {\n            int sum = 0;\n            for (int i : a) {\n                sum += i;\n            }\n            max = Math.max(max, sum);\n        }\n        return max;\n    }\n}"}
{"id": "356", "path": "output2\\java\\Easy\\356-goal-parser-interpretation.java", "hypo_code": "class Solution {\n    public String interpret(String command) {\n        String s = \"\";\n        for (int i = 0; i < command.length(); i++) {\n            if (command.charAt(i) == 'G') {\n                s += \"G\";\n            } else if (command.charAt(i) == '(') {\n                if (command.charAt(i + 1) == ')') {\n                    s += \"o\";\n                    i++;\n                } else {\n                    s += \"al\";\n                    i += 3;\n                }\n            }\n        }\n        return s;\n    }\n}"}
{"id": "358", "path": "output2\\java\\Easy\\358-count-the-number-of-consistent-strings.java", "hypo_code": "class Solution {\n    public int countConsistentStrings(String allowed, String[] words) {\n        int count = 0;\n        for (String s : words) {\n            int i = 0;\n            for (; i < s.length(); i++) {\n                if (!allowed.contains(String.valueOf(s.charAt(i)))) {\n                    break;\n                }\n            }\n            if (i == s.length()) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "359", "path": "output2\\java\\Easy\\359-count-of-matches-in-tournament.java", "hypo_code": "class Solution {\n    public int numberOfMatches(int n) {\n        int count = 0;\n        while (n > 1) {\n            count += n / 2;\n            n = n % 2 == 0 ? n / 2 : n / 2 + 1;\n        }\n        return count;\n    }\n}"}
{"id": "361", "path": "output2\\java\\Easy\\361-reformat-phone-number.java", "hypo_code": "class Solution {\n    public String reformatNumber(String number) {\n        number = number.replace(\" \", \"\").replace(\"-\", \"\");\n        int n = number.length();\n        int i = 0;\n        StringBuilder sb = new StringBuilder();\n        while (n - i > 4) {\n            sb.append(number.substring(i, i + 3)).append(\"-\");\n            i += 3;\n        }\n        if (n - i == 4) {\n            sb.append(number.substring(i, i + 2)).append(\"-\").append(number.substring(i + 2));\n        } else {\n            sb.append(number.substring(i));\n        }\n        return sb.toString();\n    }\n}"}
{"id": "362", "path": "output2\\java\\Easy\\362-number-of-students-unable-to-eat-lunch.java", "hypo_code": "class Solution {\n    public int countStudents(int[] students, int[] sandwiches) {\n        int[] count = new int[2];\n        for (int i : students) {\n            count[i]++;\n        }\n        for (int i : sandwiches) {\n            if (count[i] == 0) {\n                break;\n            }\n            count[i]--;\n        }\n        return count[0] + count[1];\n    }\n}"}
{"id": "363", "path": "output2\\java\\Easy\\363-determine-if-string-halves-are-alike.java", "hypo_code": "class Solution {\n    public boolean halvesAreAlike(String s) {\n        String s1 = s.substring(0, s.length() / 2), s2 = s.substring(s.length() / 2);\n        return countVowels(s1) == countVowels(s2);\n    }\n    public int countVowels(String s) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            switch (c) {\n                case 'a' : case 'e' : case 'i' : case 'o' : case 'u' :\n                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\n                    count++;\n                    break;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "364", "path": "output2\\java\\Easy\\364-maximum-units-on-a-truck.java", "hypo_code": "class Solution {\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\n        int[] count = new int[1001];\n        for (int[] b : boxTypes) {\n            count[b[1]] += b[0];\n        }\n        int sum = 0;\n        for (int i = 1000; i >= 0; i--) {\n            if (count[i] == 0) {\n                continue;\n            }\n            if (count[i] <= truckSize) {\n                sum += count[i] * i;\n                truckSize -= count[i];\n                continue;\n            }\n            sum += truckSize * i;\n            break;\n        }\n        return sum;\n    }\n}"}
{"id": "365", "path": "output2\\java\\Easy\\365-calculate-money-in-leetcode-bank.java", "hypo_code": "class Solution {\n    public int totalMoney(int n) {\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += (i / 7 + 1) + i % 7;\n        }\n        return sum;\n    }\n}"}
{"id": "366", "path": "output2\\java\\Easy\\366-decode-xored-array.java", "hypo_code": "class Solution {\n    public int[] decode(int[] encoded, int first) {\n        int[] arr = new int[encoded.length + 1];\n        arr[0] = first;\n        for (int i = 1; i < arr.length; i++) {\n            arr[i] = encoded[i - 1] ^ arr[i - 1];\n        }\n        return arr;\n    }\n}"}
{"id": "367", "path": "output2\\java\\Easy\\367-number-of-rectangles-that-can-form-the-largest-square.java", "hypo_code": "class Solution {\n    public int countGoodRectangles(int[][] rectangles) {\n        int max = 0;\n        int count = 0;\n        for (int[] r : rectangles) {\n            int min = Math.min(r[0], r[1]);\n            if (min > max) {\n                max = min;\n                count = 1;\n                continue;\n            }\n            if (min == max) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "370", "path": "output2\\java\\Easy\\370-find-the-highest-altitude.java", "hypo_code": "class Solution {\n    public int largestAltitude(int[] gain) {\n        int max = 0;\n        int sum = 0;\n        for (int i : gain) {\n            sum += i;\n            max = Math.max(max, sum);\n        }\n        return max;\n    }\n}"}
{"id": "371", "path": "output2\\java\\Easy\\371-latest-time-by-replacing-hidden-digits.java", "hypo_code": "class Solution {\n    public String maximumTime(String time) {\n        String[] s = time.split(\":\");\n        String hour = s[0];\n        String minute = s[1];\n        if (hour.charAt(0) == '?') {\n            if (hour.charAt(1) == '?') {\n                hour = \"23\";\n            } else {\n                if (hour.charAt(1) >= '4') {\n                    hour = \"1\" + hour.charAt(1);\n                } else {\n                    hour = \"2\" + hour.charAt(1);\n                }\n            }\n        } else {\n            if (hour.charAt(1) == '?') {\n                if (hour.charAt(0) == '2') {\n                    hour = \"23\";\n                } else {\n                    hour = hour.charAt(0) + \"9\";\n                }\n            }\n        }\n        if (minute.charAt(0) == '?') {\n            if (minute.charAt(1) == '?') {\n                minute = \"59\";\n            } else {\n                minute = \"5\" + minute.charAt(1);\n            }\n        } else {\n            if (minute.charAt(1) == '?') {\n                minute = minute.charAt(0) + \"9\";\n            }\n        }\n        return hour + \":\" + minute;\n\n    }\n}"}
{"id": "373", "path": "output2\\java\\Easy\\373-maximum-number-of-balls-in-a-box.java", "hypo_code": "class Solution {\n    public int countBalls(int lowLimit, int highLimit) {\n        int[] arr = new int[46];\n        int max = 0;\n        for(int i = lowLimit; i <= highLimit; i++){\n            int sum = 0;\n            int num = i;\n            while(num > 0){\n                sum += num % 10;\n                num /= 10;\n            }\n            arr[sum]++;\n            max = Math.max(max, arr[sum]);\n        }\n        return max;\n    }\n}"}
{"id": "374", "path": "output2\\java\\Easy\\374-sum-of-unique-elements.java", "hypo_code": "class Solution {\n    public int sumOfUnique(int[] nums) {\n        int[] arr = new int[101];\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            arr[nums[i]]++;\n        }\n        for(int i = 0; i < arr.length; i++){\n            if(arr[i] == 1){\n                sum += i;\n            }\n        }\n        return sum;\n    }\n}"}
{"id": "375", "path": "output2\\java\\Easy\\375-check-if-array-is-sorted-and-rotated.java", "hypo_code": "class Solution {\n    public boolean check(int[] nums) {\n        int count = 0;\n        for(int i = 0; i < nums.length - 1; i++){\n            if(nums[i] > nums[i + 1]){\n                count++;\n            }\n        }\n        if(nums[nums.length - 1] > nums[0]){\n            count++;\n        }\n        return count <= 1;\n    }\n}"}
{"id": "377", "path": "output2\\java\\Easy\\377-minimum-changes-to-make-alternating-binary-string.java", "hypo_code": "class Solution {\n    public int minOperations(String s) {\n        int count1 = 0;\n        int count2 = 0;\n        int n = s.length();\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) - '0' != i % 2){\n                count1++;\n            }else{\n                count2++;\n            }\n        }\n        return Math.min(count1, count2);\n    }\n}"}
{"id": "378", "path": "output2\\java\\Easy\\378-longest-nice-substring.java", "hypo_code": "class Solution {\n    public String longestNiceSubstring(String s) {\n        String res = \"\";\n        for(int i = 0; i < s.length(); i++){\n            for(int j = i + 1; j <= s.length(); j++){\n                String str = s.substring(i, j);\n                if(isNice(str) && str.length() > res.length()){\n                    res = str;\n                }\n            }\n        }\n        return res;\n    }\n    public boolean isNice(String s){\n        for(int i = 0; i < s.length(); i++){\n            if(!s.contains(String.valueOf(s.charAt(i)).toUpperCase()) || !s.contains(String.valueOf(s.charAt(i)).toLowerCase())){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "379", "path": "output2\\java\\Easy\\379-merge-strings-alternately.java", "hypo_code": "class Solution {\n    public String mergeAlternately(String word1, String word2) {\n        StringBuilder sb = new StringBuilder();\n        int i = 0;\n        int j = 0;\n        while(i < word1.length() || j < word2.length()){\n            if(i < word1.length()){\n                sb.append(word1.charAt(i));\n                i++;\n            }\n            if(j < word2.length()){\n                sb.append(word2.charAt(j));\n                j++;\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "380", "path": "output2\\java\\Easy\\380-count-items-matching-a-rule.java", "hypo_code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        int index = 0;\n        if(ruleKey.equals(\"color\")){\n            index = 1;\n        }else if(ruleKey.equals(\"name\")){\n            index = 2;\n        }\n        for(int i = 0; i < items.size(); i++){\n            if(items.get(i).get(index).equals(ruleValue)){\n                count++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "381", "path": "output2\\java\\Easy\\381-find-nearest-point-that-has-the-same-x-or-y-coordinate.java", "hypo_code": "class Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n        int min = Integer.MAX_VALUE;\n        int index = -1;\n        for(int i = 0; i < points.length; i++){\n            if(points[i][0] == x || points[i][1] == y){\n                int temp = Math.abs(points[i][0] - x) + Math.abs(points[i][1] - y);\n                if(temp < min){\n                    min = temp;\n                    index = i;\n                }\n            }\n        }\n        return index;\n    }\n}"}
{"id": "382", "path": "output2\\java\\Easy\\382-check-if-binary-string-has-at-most-one-segment-of-ones.java", "hypo_code": "class Solution {\n    public boolean checkOnesSegment(String s) {\n        boolean zero = false;\n        for(int i = 1; i < s.length(); i++){\n            if(s.charAt(i) == '0'){\n                zero = true;\n            }else if(s.charAt(i) == '1' && zero){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "384", "path": "output2\\java\\Easy\\384-check-if-one-string-swap-can-make-strings-equal.java", "hypo_code": "class Solution {\n    public boolean areAlmostEqual(String s1, String s2) {\n        int n = s1.length();\n        if(n == 1){\n            return s1.equals(s2);\n        }\n        int count = 0;\n        int[] arr = new int[26];\n        for(int i = 0; i < n; i++){\n            if(s1.charAt(i) != s2.charAt(i)){\n                count++;\n                arr[s1.charAt(i) - 'a']++;\n                arr[s2.charAt(i) - 'a']--;\n            }\n        }\n        if(count == 0){\n            return true;\n        }\n        if(count == 2){\n            for(int i = 0; i < 26; i++){\n                if(arr[i] != 0){\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n}"}
{"id": "385", "path": "output2\\java\\Easy\\385-find-center-of-star-graph.java", "hypo_code": "class FindCenterOfStarGraph {\n    public int findCenter(int[][] edges) {\n        int[] count = new int[edges.length + 1];\n        for(int[] edge : edges){\n            count[edge[0]]++;\n            count[edge[1]]++;\n        }\n        for(int i = 1; i < count.length; i++){\n            if(count[i] == edges.length){\n                return i;\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "387", "path": "output2\\java\\Easy\\387-second-largest-digit-in-a-string.java", "hypo_code": "class Solution {\n    public int secondHighest(String s) {\n        int first = -1;\n        int second = -1;\n        for(int i = 0; i < s.length(); i++){\n            if(Character.isDigit(s.charAt(i))){\n                int number = Character.getNumericValue(s.charAt(i));\n                if(number > first){\n                    second = first;\n                    first = number;\n                }else if(number < first && number > second){\n                    second = number;\n                }\n            }\n        }\n        return second;\n    }\n}"}
{"id": "388", "path": "output2\\java\\Easy\\388-maximum-ascending-subarray-sum.java", "hypo_code": "class Solution {\n    public int maxAscendingSum(int[] nums) {\n        int sum = nums[0];\n        int max = nums[0];\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] > nums[i - 1]){\n                sum += nums[i];\n            }else{\n                max = Math.max(max, sum);\n                sum = nums[i];\n            }\n        }\n        max = Math.max(max, sum);\n        return max;\n    }\n}"}
{"id": "389", "path": "output2\\java\\Easy\\389-number-of-different-integers-in-a-string.java", "hypo_code": "class Solution {\n    public int numDifferentIntegers(String word) {\n        Set<String> set = new HashSet<>();\n        int n = word.length();\n        int index = 0;\n        while(index < n){\n            if(Character.isDigit(word.charAt(index))){\n                int end = index;\n                while(end < n && Character.isDigit(word.charAt(end))){\n                    end++;\n                }\n                String number = word.substring(index, end);\n                int i = 0;\n                while(i < number.length() && number.charAt(i) == '0'){\n                    i++;\n                }\n                if(i == number.length()){\n                    set.add(\"0\");\n                }else{\n                    set.add(number.substring(i));\n                }\n                index = end;\n            }else{\n                index++;\n            }\n        }\n        return set.size();\n    }\n}"}
{"id": "390", "path": "output2\\java\\Easy\\390-determine-color-of-a-chessboard-square.java", "hypo_code": "class Solution {\n    public boolean squareIsWhite(String coordinates) {\n        int a = coordinates.charAt(0) - 'a';\n        int b = coordinates.charAt(1) - '1';\n        return (a + b) % 2 != 0;\n    }\n}"}
{"id": "391", "path": "output2\\java\\Easy\\391-truncate-sentence.java", "hypo_code": "class Solution {\n    public String truncateSentence(String s, int k) {\n        int count = 0;\n        int index = 0;\n        while(index < s.length()){\n            if(s.charAt(index) == ' '){\n                count++;\n            }\n            if(count == k){\n                break;\n            }\n            index++;\n        }\n        return s.substring(0, index);\n    }\n}"}
{"id": "392", "path": "output2\\java\\Easy\\392-sign-of-the-product-of-an-array.java", "hypo_code": "class Solution {\n    public int arraySign(int[] nums) {\n        int count = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == 0){\n                return 0;\n            }else if(nums[i] < 0){\n                count++;\n            }\n        }\n        if(count % 2 == 0){\n            return 1;\n        }else{\n            return -1;\n        }\n    }\n}"}
{"id": "393", "path": "output2\\java\\Easy\\393-minimum-operations-to-make-the-array-increasing.java", "hypo_code": "class Solution {\n    public int minOperations(int[] nums) {\n        int count = 0;\n        for(int i = 0; i < nums.length - 1; i++){\n            if(nums[i] >= nums[i + 1]){\n                count += nums[i] - nums[i + 1] + 1;\n                nums[i + 1] = nums[i] + 1;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "394", "path": "output2\\java\\Easy\\394-check-if-the-sentence-is-pangram.java", "hypo_code": "class Solution {\n    public boolean checkIfPangram(String sentence) {\n        int[] arr = new int[26];\n        for(int i = 0; i < sentence.length(); i++){\n            arr[sentence.charAt(i) - 'a']++;\n        }\n        for(int i = 0; i < 26; i++){\n            if(arr[i] == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "395", "path": "output2\\java\\Easy\\395-sum-of-digits-in-base-k.java", "hypo_code": "class Solution {\n    public int sumBase(int n, int k) {\n        int sum = 0;\n        while(n > 0){\n            sum += n % k;\n            n /= k;\n        }\n        return sum;\n    }\n}"}
{"id": "396", "path": "output2\\java\\Easy\\396-replace-all-digits-with-characters.java", "hypo_code": "class Solution {\n    public String replaceDigits(String s) {\n        char[] arr = s.toCharArray();\n        for(int i = 1; i < arr.length; i += 2){\n            arr[i] = (char)(arr[i - 1] + (arr[i] - '0'));\n        }\n        return new String(arr);\n    }\n}"}
{"id": "397", "path": "output2\\java\\Easy\\397-minimum-distance-to-the-target-element.java", "hypo_code": "class Solution {\n    public int getMinDistance(int[] nums, int target, int start) {\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == target){\n                int temp = Math.abs(i - start);\n                if(temp < min){\n                    min = temp;\n                }\n            }\n        }\n        return min;\n    }\n}"}
{"id": "398", "path": "output2\\java\\Easy\\398-maximum-population-year.java", "hypo_code": "class Solution {\n    public int maximumPopulation(int[][] logs) {\n        int[] arr = new int[101];\n        for(int i = 0; i < logs.length; i++){\n            for(int j = logs[i][0]; j < logs[i][1]; j++){\n                arr[j - 1950]++;\n            }\n        }\n        int max = 0;\n        int year = 0;\n        for(int i = 0; i < arr.length; i++){\n            if(arr[i] > max){\n                max = arr[i];\n                year = i;\n            }\n        }\n        return 1950 + year;\n    }\n}"}
{"id": "399", "path": "output2\\java\\Easy\\399-sorting-the-sentence.java", "hypo_code": "class Solution {\n    public String sortSentence(String s) {\n        String[] arr = s.split(\" \");\n        String[] res = new String[arr.length];\n        for(int i = 0; i < arr.length; i++){\n            int index = Integer.parseInt(arr[i].substring(arr[i].length() - 1));\n            res[index - 1] = arr[i].substring(0, arr[i].length() - 1);\n        }\n        return String.join(\" \", res);\n    }\n}"}
{"id": "400", "path": "output2\\java\\Easy\\400-sum-of-all-subset-xor-totals.java", "hypo_code": "class Solution {\n    public int subsetXORSum(int[] nums) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            sum += nums[i];\n        }\n        return sum * (int)Math.pow(2, nums.length - 1);\n\n    }\n}"}
{"id": "401", "path": "output2\\java\\Easy\\401-longer-contiguous-segments-of-ones-than-zeros.java", "hypo_code": "class Solution {\n    public boolean checkZeroOnes(String s) {\n        int one = 0, zero = 0, maxOne = 0, maxZero = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == '1'){\n                one++;\n                zero = 0;\n            }else{\n                one = 0;\n                zero++;\n            }\n            maxOne = Math.max(maxOne, one);\n            maxZero = Math.max(maxZero, zero);\n        }\n        return maxOne > maxZero;\n    }\n}"}
{"id": "403", "path": "output2\\java\\Easy\\403-substrings-of-size-three-with-distinct-characters.java", "hypo_code": "class Solution {\n    public int countGoodSubstrings(String s) {\n        int res = 0;\n        for(int i = 0; i < s.length() - 2; i++){\n            if(isGood(s.substring(i, i + 3))){\n                res++;\n            }\n        }\n        return res;\n    }\n    public boolean isGood(String s){\n        int[] arr = new int[26];\n        for(int i = 0; i < s.length(); i++){\n            arr[s.charAt(i) - 'a']++;\n        }\n        for(int i = 0; i < 26; i++){\n            if(arr[i] > 1){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "404", "path": "output2\\java\\Easy\\404-check-if-word-equals-summation-of-two-words.java", "hypo_code": "class Solution {\n    public boolean isSumEqual(String firstWord, String secondWord, String targetWord) {\n        int first = 0;\n        for(int i = 0; i < firstWord.length(); i++){\n            first = first * 10 + (firstWord.charAt(i) - 'a');\n        }\n        int second = 0;\n        for(int i = 0; i < secondWord.length(); i++){\n            second = second * 10 + (secondWord.charAt(i) - 'a');\n        }\n        int target = 0;\n        for(int i = 0; i < targetWord.length(); i++){\n            target = target * 10 + (targetWord.charAt(i) - 'a');\n        }\n        return first + second == target;\n    }\n}"}
{"id": "405", "path": "output2\\java\\Easy\\405-determine-whether-matrix-can-be-obtained-by-rotation.java", "hypo_code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        int n = mat.length;\n        if(n == 1){\n            return mat[0][0] == target[0][0];\n        }\n        boolean flag = true;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n - i; j++){\n                if(mat[i][j] != target[j][n - 1 - i]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(!flag){\n                break;\n            }\n        }\n        if(flag){\n            return flag;\n        }\n        flag = true;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n - i; j++){\n                if(mat[i][j] != target[n - 1 - j][i]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(!flag){\n                break;\n            }\n        }\n        if(flag){\n            return flag;\n        }\n        flag = true;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n - i; j++){\n                if(mat[i][j] != target[n - 1 - i][n - 1 - j]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(!flag){\n                break;\n            }\n        }\n        if(flag){\n            return flag;\n        }\n        flag = true;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n - i; j++){\n                if(mat[i][j] != target[n - 1 - j][n - 1 - i]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(!flag){\n                break;\n            }\n        }\n        if(flag){\n            return flag;\n        }\n        flag = true;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n - i; j++){\n                if(mat[i][j] != target[i][n - 1 - j]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(!flag){\n                break;\n            }\n        }\n        return flag;\n    }\n}"}
{"id": "407", "path": "output2\\java\\Easy\\407-check-if-all-the-integers-in-a-range-are-covered.java", "hypo_code": "class Solution {\n    public boolean isCovered(int[][] ranges, int left, int right) {\n        int[] arr = new int[51];\n        for(int i = 0; i < ranges.length; i++){\n            for(int j = ranges[i][0]; j <= ranges[i][1]; j++){\n                arr[j]++;\n            }\n        }\n        for(int i = left; i <= right; i++){\n            if(arr[i] == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "408", "path": "output2\\java\\Easy\\408-redistribute-characters-to-make-all-strings-equal.java", "hypo_code": "class Solution {\n    public boolean makeEqual(String[] words) {\n        int[] arr = new int[26];\n        int n = words.length;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < words[i].length(); j++){\n                arr[words[i].charAt(j) - 'a']++;\n            }\n        }\n        for(int i = 0; i < 26; i++){\n            if(arr[i] % n != 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "409", "path": "output2\\java\\Easy\\409-largest-odd-number-in-string.java", "hypo_code": "class Solution {\n    public String largestOddNumber(String num) {\n        int index = num.length() - 1;\n        while(index >= 0){\n            if(Character.getNumericValue(num.charAt(index)) % 2 == 1){\n                return num.substring(0, index + 1);\n            }\n            index--;\n        }\n        return \"\";\n    }\n}"}
{"id": "410", "path": "output2\\java\\Easy\\410-remove-one-element-to-make-the-array-strictly-increasing.java", "hypo_code": "class Solution {\n    public boolean canBeIncreasing(int[] nums) {\n        int count = 0;\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] <= nums[i - 1]){\n                count++;\n                if(count > 1){\n                    return false;\n                }\n                if(i > 1 && nums[i] <= nums[i - 2]){\n                    nums[i] = nums[i - 1];\n                }\n            }\n        }\n        return true;\n    }\n}"}
{"id": "411", "path": "output2\\java\\Easy\\411-maximum-product-difference-between-two-pairs.java", "hypo_code": "class Solution {\n    public int maxProductDifference(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length - 1] * nums[nums.length - 2] - nums[0] * nums[1];\n\n    }\n}"}
{"id": "412", "path": "output2\\java\\Easy\\412-build-array-from-permutation.java", "hypo_code": "class Solution {\n    public int[] buildArray(int[] nums) {\n        int[] ans = new int[nums.length];\n        for(int i = 0; i < ans.length; i++){\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"}
{"id": "413", "path": "output2\\java\\Easy\\413-count-square-sum-triples.java", "hypo_code": "class Solution {\n    public int countTriples(int n) {\n        int count = 0;\n        for(int i = 1; i <= n; i++){\n            for(int j = i; j <= n; j++){\n                int sum = i * i + j * j;\n                double sqrt = Math.sqrt(sum);\n                if(sqrt == Math.floor(sqrt) && sqrt <= n){\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}"}
{"id": "414", "path": "output2\\java\\Easy\\414-concatenation-of-array.java", "hypo_code": "class Solution {\n    public int[] getConcatenation(int[] nums) {\n        int[] arr = new int[nums.length * 2];\n        for(int i = 0; i < nums.length; i++){\n            arr[i] = nums[i];\n        }\n        for(int i = nums.length; i < arr.length; i++){\n            arr[i] = nums[i - nums.length];\n        }\n        return arr;\n    }\n}"}
{"id": "415", "path": "output2\\java\\Easy\\415-maximum-number-of-words-you-can-type.java", "hypo_code": "class Solution {\n    public int canBeTypedWords(String text, String brokenLetters) {\n        int count = 0;\n        String[] words = text.split(\" \");\n        for(int i = 0; i < words.length; i++){\n            boolean flag = false;\n            for(int j = 0; j < brokenLetters.length(); j++){\n                if(words[i].contains(String.valueOf(brokenLetters.charAt(j)))){\n                    flag = true;\n                    break;\n                }\n            }\n            if(!flag){\n                count++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "416", "path": "output2\\java\\Easy\\416-check-if-all-characters-have-equal-number-of-occurrences.java", "hypo_code": "class Solution {\n    public boolean areOccurrencesEqual(String s) {\n        int[] arr = new int[26];\n        for(int i = 0; i < s.length(); i++){\n            arr[s.charAt(i) - 'a']++;\n        }\n        int count = arr[s.charAt(0) - 'a'];\n        for(int i = 0; i < 26; i++){\n            if(arr[i] != 0 && arr[i] != count){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "417", "path": "output2\\java\\Easy\\417-sum-of-digits-of-string-after-convert.java", "hypo_code": "class Solution {\n    public int getLucky(String s, int k) {\n        int n = s.length();\n        int sum = 0;\n        for(int i = 0; i < n; i++){\n            int number = s.charAt(i) - 'a' + 1;\n            if(number >= 10){\n                sum += number / 10;\n                sum += number % 10;\n            }else{\n                sum += number;\n            }\n        }\n        while(k > 1){\n            int temp = 0;\n            while(sum > 0){\n                temp += sum % 10;\n                sum /= 10;\n            }\n            sum = temp;\n            k--;\n        }\n        return sum;\n    }\n}"}
{"id": "418", "path": "output2\\java\\Easy\\418-three-divisors.java", "hypo_code": "class Solution {\n    public boolean isThree(int n) {\n        int count = 0;\n        for(int i = 1; i <= n; i++){\n            if(n % i == 0){\n                count++;\n            }\n        }\n        return count == 3;\n    }\n}"}
{"id": "419", "path": "output2\\java\\Easy\\419-delete-characters-to-make-fancy-string.java", "hypo_code": "class Solution {\n    public String makeFancyString(String s) {\n        int n = s.length();\n        if(n <= 2){\n            return s;\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(s.charAt(0));\n        sb.append(s.charAt(1));\n        for(int i = 2; i < n; i++){\n            if(s.charAt(i) != s.charAt(i - 1) || s.charAt(i) != s.charAt(i - 2)){\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "420", "path": "output2\\java\\Easy\\420-check-if-string-is-a-prefix-of-array.java", "hypo_code": "class Solution {\n    public boolean isPrefixString(String s, String[] words) {\n        int n = s.length();\n        int index = 0;\n        for(int i = 0; i < words.length; i++){\n            for(int j = 0; j < words[i].length(); j++){\n                if(index == n){\n                    return true;\n                }\n                if(s.charAt(index) != words[i].charAt(j)){\n                    return false;\n                }\n                index++;\n            }\n        }\n        return index == n;\n    }\n}"}
{"id": "422", "path": "output2\\java\\Easy\\422-number-of-strings-that-appear-as-substrings-in-word.java", "hypo_code": "class Solution {\n    public int numOfStrings(String[] patterns, String word) {\n        int res = 0;\n        for(String pattern : patterns){\n            if(word.contains(pattern)){\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "423", "path": "output2\\java\\Easy\\423-find-if-path-exists-in-graph.java", "hypo_code": "class Solution {\n    public boolean validPath(int n, int[][] edges, int source, int destination) {\n        if(source == destination){\n            return true;\n        }\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            graph.add(new ArrayList<>());\n        }\n        for(int[] edge : edges){\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        boolean[] visited = new boolean[n];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(source);\n        visited[source] = true;\n        while(!queue.isEmpty()){\n            int current = queue.poll();\n            if(current == destination){\n                return true;\n            }\n            for(int neighbor : graph.get(current)){\n                if(!visited[neighbor]){\n                    visited[neighbor] = true;\n                    queue.add(neighbor);\n                }\n            }\n        }\n        return false;\n    }\n}"}
{"id": "424", "path": "output2\\java\\Easy\\424-minimum-time-to-type-word-using-special-typewriter.java", "hypo_code": "class Solution {\n    public int minTimeToType(String word) {\n        int res = 0;\n        int cur = 0;\n        for(int i = 0; i < word.length(); i++){\n            int next = word.charAt(i) - 'a';\n            int diff = Math.abs(cur - next);\n            res += Math.min(diff, 26 - diff);\n            res++;\n            cur = next;\n        }\n        return res;\n    }\n}"}
{"id": "426", "path": "output2\\java\\Easy\\426-find-greatest-common-divisor-of-array.java", "hypo_code": "class Solution {\n    public int findGCD(int[] nums) {\n        int min = nums[0];\n        int max = nums[0];\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] < min){\n                min = nums[i];\n            }else if(nums[i] > max){\n                max = nums[i];\n            }\n        }\n        return gcd(min, max);\n    }\n    public int gcd(int a, int b){\n        if(a == 0){\n            return b;\n        }\n        return gcd(b % a, a);\n    }\n}"}
{"id": "427", "path": "output2\\java\\Easy\\427-minimum-difference-between-highest-and-lowest-of-k-scores.java", "hypo_code": "class Solution {\n    public int minimumDifference(int[] nums, int k) {\n        Arrays.sort(nums);\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < nums.length - k + 1; i++){\n            int temp = nums[i + k - 1] - nums[i];\n            if(temp < min){\n                min = temp;\n            }\n        }\n        return min;\n    }\n}"}
{"id": "428", "path": "output2\\java\\Easy\\428-find-the-middle-index-in-array.java", "hypo_code": "class Solution {\n    public int findMiddleIndex(int[] nums) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            sum += nums[i];\n        }\n        int left = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(left == sum - left - nums[i]){\n                return i;\n            }\n            left += nums[i];\n        }\n        return -1;\n    }\n}"}
{"id": "429", "path": "output2\\java\\Easy\\429-count-special-quadruplets.java", "hypo_code": "class Solution {\n    public int countQuadruplets(int[] nums) {\n        int count = 0;\n        for(int i = 0; i < nums.length - 3; i++){\n            for(int j = i + 1; j < nums.length - 2; j++){\n                for(int k = j + 1; k < nums.length - 1; k++){\n                    for(int l = k + 1; l < nums.length; l++){\n                        if(nums[i] + nums[j] + nums[k] == nums[l]){\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}"}
{"id": "430", "path": "output2\\java\\Easy\\430-reverse-prefix-of-word.java", "hypo_code": "class Solution {\n    public String reversePrefix(String word, char ch) {\n        int index = word.indexOf(ch);\n        if(index == -1){\n            return word;\n        }\n        String res = \"\";\n        for(int i = index; i >= 0; i--){\n            res += word.charAt(i);\n        }\n        return res + word.substring(index + 1);\n    }\n}"}
{"id": "431", "path": "output2\\java\\Easy\\431-count-number-of-pairs-with-absolute-difference-k.java", "hypo_code": "class Solution {\n    public int countKDifference(int[] nums, int k) {\n        int count = 0;\n        for(int i = 0; i < nums.length - 1; i++){\n            for(int j = 1; j < nums.length; j++){\n                if(i < j && Math.abs(nums[i] - nums[j]) == k){\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}"}
{"id": "432", "path": "output2\\java\\Easy\\432-final-value-of-variable-after-performing-operations.java", "hypo_code": "class Solution {\n    public int finalValueAfterOperations(String[] operations) {\n        int result = 0;\n        for (String operation : operations) {\n            if (operation.charAt(0) == '+' || operation.charAt(2) == '+') {\n                result++;\n            } else {\n                result--;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "433", "path": "output2\\java\\Easy\\433-maximum-difference-between-increasing-elements.java", "hypo_code": "class Solution {\n    public int maximumDifference(int[] nums) {\n        int result = -1;\n        int min = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] <= min) {\n                min = nums[i];\n            } else {\n                result = Math.max(result, nums[i] - min);\n            }\n        }\n        return result;\n    }\n}"}
{"id": "434", "path": "output2\\java\\Easy\\434-convert-1d-array-into-2d-array.java", "hypo_code": "class Solution {\n    public int[][] construct2DArray(int[] original, int m, int n) {\n        if (original.length != m * n) {\n            return new int[0][0];\n        }\n        int[][] res = new int[m][n];\n        int index = 0;\n        for (int i = 0; i < original.length; i++) {\n            int row = i / n;\n            int col = i % n;\n            res[row][col] = original[i];\n        }\n        return res;\n    }\n}"}
{"id": "435", "path": "output2\\java\\Easy\\435-minimum-moves-to-convert-string.java", "hypo_code": "class Solution {\n    public int minimumMoves(String s) {\n        int res = 0;\n        int i = 0;\n        while (i < s.length()) {\n            if (s.charAt(i) == 'X') {\n                i += 3;\n                res++;\n            } else {\n                i++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "436", "path": "output2\\java\\Easy\\436-two-out-of-three.java", "hypo_code": "class Solution {\n    public List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\n        int[] res = new int[101];\n        for (int i = 0; i < nums1.length; i++) {\n            res[nums1[i]] |= 1;\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            res[nums2[i]] |= 2;\n        }\n        for (int i = 0; i < nums3.length; i++) {\n            res[nums3[i]] |= 4;\n        }\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < res.length; i++) {\n            if (res[i] == 3 || res[i] == 5 || res[i] == 6) {\n                list.add(i);\n            }\n        }\n        return list;\n    }\n}"}
{"id": "437", "path": "output2\\java\\Easy\\437-minimum-number-of-moves-to-seat-everyone.java", "hypo_code": "class Solution {\n    public int minMovesToSeat(int[] seats, int[] students) {\n        Arrays.sort(seats);\n        Arrays.sort(students);\n        int res = 0;\n        for (int i = 0; i < seats.length; i++) {\n            res += Math.abs(seats[i] - students[i]);\n        }\n        return res;\n    }\n}"}
{"id": "438", "path": "output2\\java\\Easy\\438-check-if-numbers-are-ascending-in-a-sentence.java", "hypo_code": "class Solution {\n    public boolean areNumbersAscending(String s) {\n        int prev = -1;\n        int index = 0;\n        while (index < s.length()) {\n            if (Character.isDigit(s.charAt(index))) {\n                int num = 0;\n                while (index < s.length() && Character.isDigit(s.charAt(index))) {\n                    num = num * 10 + s.charAt(index) - '0';\n                    index++;\n                }\n                if (prev >= num) {\n                    return false;\n                }\n                prev = num;\n            } else {\n                index++;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "439", "path": "output2\\java\\Easy\\439-number-of-valid-words-in-a-sentence.java", "hypo_code": "class Solution {\n    public int countValidWords(String sentence) {\n        int count = 0;\n        int index = 0;\n        while (index < sentence.length()) {\n            if (Character.isLetter(sentence.charAt(index))) {\n                while (index < sentence.length() && Character.isLetter(sentence.charAt(index))) {\n                    index++;\n                }\n                count++;\n            } else if (Character.isDigit(sentence.charAt(index))) {\n                while (index < sentence.length() && Character.isDigit(sentence.charAt(index))) {\n                    index++;\n                }\n            } else {\n                index++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "440", "path": "output2\\java\\Easy\\440-kth-distinct-string-in-an-array.java", "hypo_code": "class Solution {\n    public String kthDistinct(String[] arr, int k) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < arr.length; i++) {\n            map.merge(arr[i], 1, Integer::sum);\n        }\n        int index = 0;\n        for (String key : map.keySet()) {\n            if (map.get(key) == 1) {\n                index++;\n                if (index == k) {\n                    return key;\n                }\n            }\n        }\n        return \"\";\n    }\n}"}
{"id": "441", "path": "output2\\java\\Easy\\441-smallest-index-with-equal-value.java", "hypo_code": "class Solution {\n    public int smallestEqual(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            if (i % 10 == nums[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "442", "path": "output2\\java\\Easy\\442-count-vowel-substrings-of-a-string.java", "hypo_code": "class Solution {\n    public int countVowelSubstrings(String word) {\n        int count = 0;\n        for (int i = 0; i < word.length(); i++) {\n            char ch = word.charAt(i);\n            if (ch == 'a') {\n                count++;\n            } else if (ch == 'e') {\n                count++;\n            } else if (ch == 'i') {\n                count++;\n            } else if (ch == 'o') {\n                count++;\n            } else if (ch == 'u') {\n                count++;\n            }\n            for (int j = i + 1; j < word.length(); j++) {\n                ch = word.charAt(j);\n                if (ch == 'a') {\n                    count++;\n                } else if (ch == 'e') {\n                    count++;\n                } else if (ch == 'i') {\n                    count++;\n                } else if (ch == 'o') {\n                    count++;\n                } else if (ch == 'u') {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}"}
{"id": "443", "path": "output2\\java\\Easy\\443-check-whether-two-strings-are-almost-equivalent.java", "hypo_code": "class Solution {\n    public boolean checkAlmostEquivalent(String word1, String word2) {\n        int[] freq1 = new int[26];\n        int[] freq2 = new int[26];\n        for (int i = 0; i < word1.length(); i++) {\n            freq1[word1.charAt(i) - 'a']++;\n        }\n        for (int i = 0; i < word2.length(); i++) {\n            freq2[word2.charAt(i) - 'a']++;\n        }\n        int count = 0;\n        for (int i = 0; i < 26; i++) {\n            if (Math.abs(freq1[i] - freq2[i]) > 3) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "444", "path": "output2\\java\\Easy\\444-time-needed-to-buy-tickets.java", "hypo_code": "class Solution {\n    public int timeRequiredToBuy(int[] tickets, int k) {\n        int res = 0;\n        int[] count = new int[101];\n        for (int i = 0; i < tickets.length; i++) {\n            count[tickets[i]]++;\n        }\n        int i = 1;\n        while (k > 0) {\n            if (count[i] > 0) {\n                res += i;\n                count[i]--;\n                k--;\n            } else {\n                i++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "445", "path": "output2\\java\\Easy\\445-two-furthest-houses-with-different-colors.java", "hypo_code": "class Solution {\n    public int maxDistance(int[] colors) {\n        int[] left = new int[colors.length];\n        int[] right = new int[colors.length];\n        int[] count = new int[101];\n        Arrays.fill(left, Integer.MAX_VALUE);\n        Arrays.fill(right, Integer.MAX_VALUE);\n        for (int i = 0; i < colors.length; i++) {\n            count[colors[i]]++;\n            left[i] = count[colors[i]];\n        }\n        Arrays.fill(count, 0);\n        for (int i = colors.length - 1; i >= 0; i--) {\n            count[colors[i]]++;\n            right[i] = count[colors[i]];\n        }\n        int res = 0;\n        for (int i = 0; i < colors.length; i++) {\n            if (left[i] != 1 && right[i] != 1) {\n                res = Math.max(res, Math.min(left[i], right[i]));\n            }\n        }\n        return res == 0 ? -1 : res;\n    }\n}"}
{"id": "447", "path": "output2\\java\\Easy\\447-count-common-words-with-one-occurrence.java", "hypo_code": "class Solution {\n    public int countWords(String[] words1, String[] words2) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < words1.length; i++) {\n            map.merge(words1[i], 1, Integer::sum);\n        }\n        for (int i = 0; i < words2.length; i++) {\n            map.merge(words2[i], 1, Integer::sum);\n        }\n        int count = 0;\n        for (String key : map.keySet()) {\n            if (map.get(key) == 1) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "448", "path": "output2\\java\\Easy\\448-find-target-indices-after-sorting-array.java", "hypo_code": "class Solution {\n    public List<Integer> targetIndices(int[] nums, int target) {\n        int[] sorted = nums.clone();\n        Arrays.sort(sorted);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (sorted[i] == target) {\n                list.add(i);\n            }\n        }\n        return list;\n\n    }\n}"}
{"id": "449", "path": "output2\\java\\Easy\\449-finding-3-digit-even-numbers.java", "hypo_code": "class Solution {\n    public int[] findEvenNumbers(int[] digits) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < digits.length; i++) {\n            for (int j = i + 1; j < digits.length; j++) {\n                for (int k = j + 1; k < digits.length; k++) {\n                    int num = digits[i] * 100 + digits[j] * 10 + digits[k];\n                    if (num % 2 == 0) {\n                        set.add(num);\n                    }\n                }\n            }\n        }\n        int[] res = new int[set.size()];\n        int index = 0;\n        for (int num : set) {\n            res[index++] = num;\n        }\n        Arrays.sort(res);\n        return res;\n\n    }\n}"}
{"id": "450", "path": "output2\\java\\Easy\\450-find-subsequence-of-length-k-with-the-largest-sum.java", "hypo_code": "class Solution {\n    public int[] maxSubsequence(int[] nums, int k) {\n        int[] res = new int[k];\n        int index = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > nums[index]) {\n                index = i;\n            }\n        }\n        res[0] = nums[index];\n        int j = 1;\n        for (int i = index + 1; i < nums.length; i++) {\n            if (nums[i] > res[j - 1]) {\n                res[j++] = nums[i];\n            }\n        }\n        return res;\n    }\n}"}
{"id": "451", "path": "output2\\java\\Easy\\451-rings-and-rods.java", "hypo_code": "class Solution {\n    public int countPoints(String rings) {\n        int res = 0;\n        int[] count = new int[10];\n        for (int i = 0; i < rings.length(); i += 2) {\n            char color = rings.charAt(i);\n            int pos = rings.charAt(i + 1) - '0';\n            count[pos] |= 1 << (color - 'A');\n        }\n        for (int i = 0; i < 10; i++) {\n            if (count[i] == 7) {\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "452", "path": "output2\\java\\Easy\\452-find-first-palindromic-string-in-the-array.java", "hypo_code": "class Solution {\n    public String firstPalindrome(String[] words) {\n        for (int i = 0; i < words.length; i++) {\n            String word = words[i];\n            int left = 0;\n            int right = word.length() - 1;\n            while (left < right) {\n                if (word.charAt(left) == word.charAt(right)) {\n                    left++;\n                    right--;\n                } else {\n                    break;\n                }\n            }\n            if (left >= right) {\n                return word;\n            }\n        }\n        return \"\";\n    }\n}"}
{"id": "453", "path": "output2\\java\\Easy\\453-maximum-number-of-words-found-in-sentences.java", "hypo_code": "class Solution {\n    public int mostWordsFound(String[] sentences) {\n        int max = 0;\n        for (int i = 0; i < sentences.length; i++) {\n            String sentence = sentences[i];\n            int count = 1;\n            for (int j = 0; j < sentence.length(); j++) {\n                if (sentence.charAt(j) == ' ') {\n                    count++;\n                }\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n    }\n}"}
{"id": "454", "path": "output2\\java\\Easy\\454-a-number-after-a-double-reversal.java", "hypo_code": "class Solution {\n    public boolean isSameAfterReversals(int num) {\n        String s = String.valueOf(num);\n        String rs = new StringBuilder(s).reverse().toString();\n        String rrs = new StringBuilder(rs).reverse().toString();\n        return s.equals(rrs);\n    }\n}"}
{"id": "455", "path": "output2\\java\\Easy\\455-check-if-all-as-appears-before-all-bs.java", "hypo_code": "class Solution {\n    public boolean checkString(String s) {\n        int countA = 0;\n        int countB = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (countA > 0 && countB > 0 && ch == 'a') {\n                return false;\n            } else if (ch == 'a') {\n                countA++;\n            } else if (ch == 'b') {\n                countB++;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "456", "path": "output2\\java\\Easy\\456-capitalize-the-title.java", "hypo_code": "class Solution {\n    public String capitalizeTitle(String title) {\n        String[] words = title.split(\" \");\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < words.length; i++) {\n            String word = words[i];\n            if (word.length() <= 2) {\n                sb.append(word.toLowerCase());\n            } else {\n                sb.append(Character.toUpperCase(word.charAt(0)));\n                sb.append(word.substring(1).toLowerCase());\n            }\n            if (i != words.length - 1) {\n                sb.append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "457", "path": "output2\\java\\Easy\\457-check-if-every-row-and-column-contains-all-numbers.java", "hypo_code": "class Solution {\n    public boolean checkValid(int[][] matrix) {\n        int n = matrix.length;\n        int[] row = new int[n];\n        int[] col = new int[n];\n        for (int i = 0; i < n; i++) {\n            int temp = 0;\n            for (int j = 0; j < n; j++) {\n                temp |= 1 << (matrix[i][j] - 1);\n            }\n            row[i] = temp;\n        }\n        for (int i = 0; i < n; i++) {\n            int temp = 0;\n            for (int j = 0; j < n; j++) {\n                temp |= 1 << (matrix[j][i] - 1);\n            }\n            col[i] = temp;\n        }\n        for (int i = 0; i < n; i++) {\n            if (row[i] != (1 << n) - 1 || col[i] != (1 << n) - 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "458", "path": "output2\\java\\Easy\\458-divide-a-string-into-groups-of-size-k.java", "hypo_code": "class Solution {\n    public String[] divideString(String s, int k, char fill) {\n        int count = s.length() / k;\n        if (s.length() % k != 0) {\n            count++;\n        }\n        String[] res = new String[count];\n        int index = 0;\n        int i = 0;\n        while (i < s.length()) {\n            String str = \"\";\n            int j = 0;\n            while (j < k && i < s.length()) {\n                str += s.charAt(i);\n                i++;\n                j++;\n            }\n            if (j < k) {\n                while (j < k) {\n                    str += fill;\n                    j++;\n                }\n            }\n            res[index] = str;\n            index++;\n        }\n        return res;\n    }\n}"}
{"id": "459", "path": "output2\\java\\Easy\\459-minimum-cost-of-buying-candies-with-discount.java", "hypo_code": "class Solution {\n    public int minimumCost(int[] cost) {\n        int res = 0;\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        for (int i = 0; i < cost.length; i++) {\n            pq.offer(cost[i]);\n        }\n        while (pq.size() > 1) {\n            int a = pq.poll();\n            int b = pq.poll();\n            res += a + b;\n            pq.offer(a - b);\n        }\n        return res;\n    }\n}"}
{"id": "460", "path": "output2\\java\\Easy\\460-count-elements-with-strictly-smaller-and-greater-elements.java", "hypo_code": "class Solution {\n    public int countElements(int[] nums) {\n        int[] sorted = nums.clone();\n        Arrays.sort(sorted);\n        int count = 0;\n        for (int i = 1; i < nums.length - 1; i++) {\n            if (sorted[i] != sorted[i - 1] && sorted[i] != sorted[i + 1]) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "461", "path": "output2\\java\\Easy\\461-keep-multiplying-found-values-by-two.java", "hypo_code": "class Solution {\n    public int findFinalValue(int[] nums, int original) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == original) {\n                original *= 2;\n            }\n        }\n        return original;\n    }\n}"}
{"id": "462", "path": "output2\\java\\Easy\\462-minimum-sum-of-four-digit-number-after-splitting-digits.java", "hypo_code": "class Solution {\n    public int minimumSum(int num) {\n        int[] digits = new int[4];\n        int index = 0;\n        while (num > 0) {\n            digits[index++] = num % 10;\n            num /= 10;\n        }\n        Arrays.sort(digits);\n        int res = 0;\n        for (int i = 0; i < 2; i++) {\n            res += digits[i] * Math.pow(10, i);\n        }\n        for (int i = 2; i < 4; i++) {\n            res -= digits[i] * Math.pow(10, i - 2);\n        }\n        return res;\n    }\n}"}
{"id": "463", "path": "output2\\java\\Easy\\463-sort-even-and-odd-indices-independently.java", "hypo_code": "class Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        int[] odd = new int[51];\n        int[] even = new int[51];\n        int i = 0;\n        for (int j = 0; j < nums.length; j++) {\n            if (j % 2 == 0) {\n                even[nums[j]]++;\n            } else {\n                odd[nums[j]]++;\n            }\n        }\n        int index = 0;\n        for (int j = 50; j >= 0; j--) {\n            while (even[j] > 0) {\n                nums[index++] = j;\n                even[j]--;\n            }\n        }\n        for (int j = 0; j <= 50; j++) {\n            while (odd[j] > 0) {\n                nums[index++] = j;\n                odd[j]--;\n            }\n        }\n        return nums;\n    }\n}"}
{"id": "464", "path": "output2\\java\\Easy\\464-count-operations-to-obtain-zero.java", "hypo_code": "class Solution {\n    public int countOperations(int num1, int num2) {\n        int res = 0;\n        while (num1 > 0 && num2 > 0) {\n            if (num1 >= num2) {\n                num1 -= num2;\n            } else {\n                num2 -= num1;\n            }\n            res++;\n        }\n        return res;\n    }\n}"}
{"id": "465", "path": "output2\\java\\Easy\\465-count-equal-and-divisible-pairs-in-an-array.java", "hypo_code": "class Solution {\n    public int countPairs(int[] nums, int k) {\n        int[] res = new int[k];\n        for (int i = 0; i < nums.length; i++) {\n            res[nums[i] % k]++;\n        }\n        int count = 0;\n        for (int i = 0; i < k; i++) {\n            if (res[i] > 1) {\n                count += res[i] * (res[i] - 1) / 2;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "466", "path": "output2\\java\\Easy\\466-count-integers-with-even-digit-sum.java", "hypo_code": "class Solution {\n    public int countEven(int num) {\n        int count = 0;\n        for (int i = 1; i <= num; i++) {\n            int sum = 0;\n            int n = i;\n            while (n > 0) {\n                sum += n % 10;\n                n /= 10;\n            }\n            if (sum % 2 == 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "467", "path": "output2\\java\\Easy\\467-counting-words-with-a-given-prefix.java", "hypo_code": "class Solution {\n    public int prefixCount(String[] words, String pref) {\n        int count = 0;\n        for (int i = 0; i < words.length; i++) {\n            String word = words[i];\n            if (word.length() >= pref.length()) {\n                int j = 0;\n                while (j < pref.length()) {\n                    if (word.charAt(j) != pref.charAt(j)) {\n                        break;\n                    }\n                    j++;\n                }\n                if (j >= pref.length()) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}"}
{"id": "468", "path": "output2\\java\\Easy\\468-most-frequent-number-following-key-in-an-array.java", "hypo_code": "class Solution {\n    public int mostFrequent(int[] nums, int key) {\n        int[] count = new int[1001];\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i] == key) {\n                count[nums[i + 1]]++;\n            }\n        }\n        int max = Integer.MIN_VALUE;\n        int res = -1;\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] > max) {\n                max = count[i];\n                res = i;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "469", "path": "output2\\java\\Easy\\469-cells-in-a-range-on-an-excel-sheet.java", "hypo_code": "class Solution {\n    public List<String> cellsInRange(String s) {\n        List<String> list = new ArrayList<>();\n        int col1 = s.charAt(0) - 'A';\n        int row1 = s.charAt(1) - '1';\n        int col2 = s.charAt(3) - 'A';\n        int row2 = s.charAt(4) - '1';\n        for (int i = col1; i <= col2; i++) {\n            for (int j = row1; j <= row2; j++) {\n                list.add(\"\" + (char) ('A' + i) + (char) ('1' + j));\n            }\n        }\n        return list;\n    }\n}"}
{"id": "470", "path": "output2\\java\\Easy\\470-find-all-k-distant-indices-in-an-array.java", "hypo_code": "class Solution {\n    public List<Integer> findKDistantIndices(int[] nums, int key, int k) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == key) {\n                list.add(i);\n            }\n        }\n        return list;\n    }\n}"}
{"id": "471", "path": "output2\\java\\Easy\\471-divide-array-into-equal-pairs.java", "hypo_code": "class Solution {\n    public boolean divideArray(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        for (int i = 0; i < n / 2; i++) {\n            if (nums[i] != nums[i + n / 2]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "472", "path": "output2\\java\\Easy\\472-count-hills-and-valleys-in-an-array.java", "hypo_code": "class Solution {\n    public int countHillValley(int[] nums) {\n        int n = nums.length;\n        if (n <= 2) {\n            return 0;\n        }\n        int count = 0;\n        for (int i = 1; i < n - 1; i++) {\n            if (nums[i] != nums[i - 1] && nums[i] != nums[i + 1]) {\n                if ((nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) || (nums[i] < nums[i - 1] && nums[i] < nums[i + 1])) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}"}
{"id": "473", "path": "output2\\java\\Easy\\473-find-the-difference-of-two-arrays.java", "hypo_code": "class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\n        List<List<Integer>> ans = new ArrayList<>();\n        int n1 = nums1.length, n2 = nums2.length;\n        Map<Integer, Integer> map1 = new HashMap<>(), map2 = new HashMap<>();\n        for (int num : nums1) {\n            map1.put(num, map1.getOrDefault(num, 0) + 1);\n        }\n        for (int num : nums2) {\n            map2.put(num, map2.getOrDefault(num, 0) + 1);\n        }\n        List<Integer> list1 = new ArrayList<>(), list2 = new ArrayList<>();\n        for (int num : nums1) {\n            if (!map2.containsKey(num)) {\n                list1.add(num);\n            }\n        }\n        for (int num : nums2) {\n            if (!map1.containsKey(num)) {\n                list2.add(num);\n            }\n        }\n        ans.add(list1);\n        ans.add(list2);\n        return ans;\n    }\n}"}
{"id": "474", "path": "output2\\java\\Easy\\474-minimum-bit-flips-to-convert-number.java", "hypo_code": "class Solution {\n    public int minBitFlips(int start, int goal) {\n        int ans = 0;\n        while (start != 0 || goal != 0) {\n            if ((start & 1) != (goal & 1)) {\n                ans++;\n            }\n            start >>= 1;\n            goal >>= 1;\n        }\n        return ans;\n    }\n}"}
{"id": "475", "path": "output2\\java\\Easy\\475-minimum-number-of-operations-to-convert-time.java", "hypo_code": "class Solution {\n    public int convertTime(String current, String correct) {\n        int ans = 0;\n        int cur = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3));\n        int cor = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3));\n        while (cur != cor) {\n            if (cur + 60 <= cor) {\n                cur += 60;\n            } else if (cur + 15 <= cor) {\n                cur += 15;\n            } else if (cur + 5 <= cor) {\n                cur += 5;\n            } else {\n                cur++;\n            }\n            ans++;\n        }\n        return ans;\n    }\n}"}
{"id": "476", "path": "output2\\java\\Easy\\476-largest-number-after-digit-swaps-by-parity.java", "hypo_code": "class Solution {\n    public int largestInteger(int num) {\n        char[] arr = String.valueOf(num).toCharArray();\n        int n = arr.length;\n        int[] map = new int[10];\n        for (int i = 0; i < n; i++) {\n            map[arr[i] - '0'] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 9; j > arr[i] - '0'; j--) {\n                if (i < map[j]) {\n                    char temp = arr[i];\n                    arr[i] = arr[map[j]];\n                    arr[map[j]] = temp;\n                    return Integer.parseInt(new String(arr));\n                }\n            }\n        }\n        return num;\n    }\n}"}
{"id": "477", "path": "output2\\java\\Easy\\477-add-two-integers.java", "hypo_code": "class Solution {\n    public int sum(int num1, int num2) {\n        return num1 + num2;\n    }\n}"}
{"id": "478", "path": "output2\\java\\Easy\\478-root-equals-sum-of-children.java", "hypo_code": "class Solution {\n    public boolean checkTree(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        return root.val == sum(root.left) + sum(root.right);\n    }\n    private int sum(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return root.val + sum(root.left) + sum(root.right);\n\n    }\n}"}
{"id": "479", "path": "output2\\java\\Easy\\479-find-closest-number-to-zero.java", "hypo_code": "class Solution {\n    public int findClosestNumber(int[] nums) {\n        int n = nums.length;\n        int ans = nums[0];\n        for (int i = 1; i < n; i++) {\n            if (Math.abs(ans) > Math.abs(nums[i]) || (Math.abs(ans) == Math.abs(nums[i]) && ans < nums[i])) {\n                ans = nums[i];\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "480", "path": "output2\\java\\Easy\\480-calculate-digit-sum-of-a-string.java", "hypo_code": "class Solution {\n    public String digitSum(String s, int k) {\n        while (s.length() > k) {\n            int sum = 0;\n            for (int i = 0; i < s.length(); i++) {\n                sum += s.charAt(i) - '0';\n            }\n            s = String.valueOf(sum);\n        }\n        return s;\n    }\n}"}
{"id": "481", "path": "output2\\java\\Easy\\481-intersection-of-multiple-arrays.java", "hypo_code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        List<Integer> res = new ArrayList<>();\n        if (nums.length == 0) return res;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] num : nums) {\n            Set<Integer> set = new HashSet<>();\n            for (int n : num) {\n                if (map.containsKey(n) && map.get(n) == nums.length - 1) {\n                    set.add(n);\n                } else if (map.containsKey(n)) {\n                    map.put(n, map.get(n) + 1);\n                } else {\n                    map.put(n, 1);\n                }\n            }\n            map.keySet().removeIf(key -> !set.contains(key));\n        }\n        res.addAll(map.keySet());\n        return res;\n    }\n}"}
{"id": "482", "path": "output2\\java\\Easy\\482-count-prefixes-of-a-given-string.java", "hypo_code": "class Solution {\n    public int countPrefixes(String[] words, String s) {\n        int res = 0;\n        for (String word : words) {\n            if (s.startsWith(word)) res++;\n        }\n        return res;\n    }\n}"}
{"id": "483", "path": "output2\\java\\Easy\\483-remove-digit-from-number-to-maximize-result.java", "hypo_code": "class Solution {\n    public String removeDigit(String number, char digit) {\n        int n = number.length();\n        for (int i = 0; i < n; i++) {\n            if (number.charAt(i) == digit) {\n                return number.substring(0, i) + number.substring(i + 1);\n            }\n        }\n        return number;\n    }\n}"}
{"id": "484", "path": "output2\\java\\Easy\\484-largest-3-same-digit-number-in-string.java", "hypo_code": "class Solution {\n    public String largestGoodInteger(String num) {\n        int n = num.length();\n        for (int i = n - 3; i >= 0; i--) {\n            String s = num.substring(i, i + 3);\n            if (isGood(s)) return s;\n        }\n        return \"\";\n    }\n    private boolean isGood(String s) {\n        Set<Character> set = new HashSet<>();\n        for (int i = 0; i < 3; i++) {\n            set.add(s.charAt(i));\n        }\n        return set.size() == 1;\n    }\n}"}
{"id": "485", "path": "output2\\java\\Easy\\485-find-the-k-beauty-of-a-number.java", "hypo_code": "class Solution {\n    public int divisorSubstrings(int num, int k) {\n        String s = String.valueOf(num);\n        int n = s.length();\n        int res = 0;\n        for (int i = 0; i <= n - k; i++) {\n            String sub = s.substring(i, i + k);\n            if (isDivisor(num, sub)) res++;\n        }\n        return res;\n    }\n    private boolean isDivisor(int num, String sub) {\n        int n = Integer.parseInt(sub);\n        return n != 0 && num % n == 0;\n    }\n}"}
{"id": "486", "path": "output2\\java\\Easy\\486-find-resultant-array-after-removing-anagrams.java", "hypo_code": "class Solution {\n    public List<String> removeAnagrams(String[] words) {\n        List<String> res = new ArrayList<>();\n        Set<String> set = new HashSet<>();\n        for (String word : words) {\n            String key = getKey(word);\n            if (!set.contains(key)) {\n                res.add(word);\n                set.add(key);\n            }\n        }\n        return res;\n    }\n    private String getKey(String word) {\n        int[] count = new int[26];\n        for (char c : word.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) {\n                sb.append((char)(i + 'a'));\n                sb.append(count[i]);\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "487", "path": "output2\\java\\Easy\\487-percentage-of-letter-in-string.java", "hypo_code": "class Solution {\n    public int percentageLetter(String s, char letter) {\n        int n = s.length();\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == letter) count++;\n        }\n        return (int) (count * 100.0 / n);\n    }\n}"}
{"id": "488", "path": "output2\\java\\Easy\\488-check-if-number-has-equal-digit-count-and-digit-value.java", "hypo_code": "class Solution {\n    public boolean digitCount(String num) {\n        int n = num.length();\n        int[] count = new int[10];\n        for (int i = 0; i < n; i++) {\n            count[num.charAt(i) - '0']++;\n        }\n        for (int i = 0; i < n; i++) {\n            if (count[i] != num.charAt(i) - '0') return false;\n        }\n        return true;\n    }\n}"}
{"id": "489", "path": "output2\\java\\Easy\\489-rearrange-characters-to-make-target-string.java", "hypo_code": "class Solution {\n    public int rearrangeCharacters(String s, String target) {\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        int res = 0;\n        while (true) {\n            for (char c : target.toCharArray()) {\n                if (count[c - 'a'] == 0) return res;\n                count[c - 'a']--;\n            }\n            res++;\n        }\n    }\n}"}
{"id": "490", "path": "output2\\java\\Easy\\490-min-max-game.java", "hypo_code": "class Solution {\n    public int minMaxGame(int[] nums) {\n        int n = nums.length;\n        while (n > 1) {\n            int[] newNums = new int[n / 2];\n            for (int i = 0; i < n / 2; i++) {\n                newNums[i] = i % 2 == 0 ? Math.min(nums[2 * i], nums[2 * i + 1]) : Math.max(nums[2 * i], nums[2 * i + 1]);\n            }\n            nums = newNums;\n            n /= 2;\n        }\n        return nums[0];\n    }\n}"}
{"id": "491", "path": "output2\\java\\Easy\\491-strong-password-checker-ii.java", "hypo_code": "class Solution {\n    public boolean strongPasswordCheckerII(String password) {\n        int n = password.length();\n        if (n < 8) return false;\n        boolean hasLower = false;\n        boolean hasUpper = false;\n        boolean hasDigit = false;\n        boolean hasSpecial = false;\n        for (int i = 0; i < n; i++) {\n            char c = password.charAt(i);\n            if (Character.isLowerCase(c)) hasLower = true;\n            else if (Character.isUpperCase(c)) hasUpper = true;\n            else if (Character.isDigit(c)) hasDigit = true;\n            else hasSpecial = true;\n        }\n        if (!hasLower || !hasUpper || !hasDigit || !hasSpecial) return false;\n        for (int i = 0; i < n - 1; i++) {\n            if (password.charAt(i) == password.charAt(i + 1)) return false;\n        }\n        return true;\n    }\n}"}
{"id": "492", "path": "output2\\java\\Easy\\492-calculate-amount-paid-in-taxes.java", "hypo_code": "class Solution {\n    public double calculateTax(int[][] brackets, int income) {\n        double res = 0;\n        int n = brackets.length;\n        int i = 0;\n        while (income > 0) {\n            int upper = brackets[i][0];\n            int percent = brackets[i][1];\n            int cur = Math.min(income, upper);\n            res += cur * percent / 100.0;\n            income -= cur;\n            i++;\n        }\n        return res;\n    }\n}"}
{"id": "493", "path": "output2\\java\\Easy\\493-greatest-english-letter-in-upper-and-lower-case.java", "hypo_code": "class Solution {\n    public String greatestLetter(String s) {\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'A']++;\n        }\n        for (int i = 25; i >= 0; i--) {\n            if (count[i] > 0 && count[i + 32] > 0) {\n                return (char) (i + 'A') + \"\";\n            }\n        }\n        return \"\";\n    }\n}"}
{"id": "494", "path": "output2\\java\\Easy\\494-count-asterisks.java", "hypo_code": "class Solution {\n    public int countAsterisks(String s) {\n        int n = s.length();\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '*' && (i == 0 || s.charAt(i - 1) != '|') && (i == n - 1 || s.charAt(i + 1) != '|')) {\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "495", "path": "output2\\java\\Easy\\495-check-if-matrix-is-x-matrix.java", "hypo_code": "class Solution {\n    public boolean checkXMatrix(int[][] grid) {\n        int n = grid.length;\n        for (int i = 0; i < n; i++) {\n            if (grid[i][i] == 0) return false;\n        }\n        for (int i = 0; i < n; i++) {\n            if (grid[i][n - i - 1] == 0) return false;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (grid[i][j] != 0) return false;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n - i - 1; j++) {\n                if (grid[i][j] != 0) return false;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = n - i; j < n; j++) {\n                if (grid[i][j] != 0) return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "496", "path": "output2\\java\\Easy\\496-decode-the-message.java", "hypo_code": "class Solution {\n    public String decodeMessage(String key, String message) {\n        Map<Character, Character> map = new HashMap<>();\n        int n = key.length();\n        int m = message.length();\n        for (int i = 0; i < n; i++) {\n            char c = key.charAt(i);\n            if (c == ' ') continue;\n            map.put(c, (char)('a' + i));\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < m; i++) {\n            char c = message.charAt(i);\n            if (c == ' ') {\n                sb.append(' ');\n            } else {\n                sb.append(map.get(c));\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "497", "path": "output2\\java\\Easy\\497-evaluate-boolean-binary-tree.java", "hypo_code": "class Solution {\n    public boolean evaluateTree(TreeNode root) {\n        if (root.left == null && root.right == null) return root.val == 1;\n        if (root.val == 2) return evaluateTree(root.left) || evaluateTree(root.right);\n        return evaluateTree(root.left) && evaluateTree(root.right);\n\n    }\n}"}
{"id": "498", "path": "output2\\java\\Easy\\498-minimum-amount-of-time-to-fill-cups.java", "hypo_code": "class Solution {\n    public int fillCups(int[] amount) {\n        int res = 0;\n        while (true) {\n            int min = Math.min(amount[0], Math.min(amount[1], amount[2]));\n            if (min == 0) return res;\n            for (int i = 0; i < 3; i++) {\n                amount[i] -= min;\n            }\n            res += min;\n            if (amount[0] == 0 && amount[1] == 0 && amount[2] == 0) return res;\n            if (amount[0] == 0) {\n                amount[0] = amount[1] / 2 + amount[2] / 2;\n                amount[1] = amount[1] % 2;\n                amount[2] = amount[2] % 2;\n            } else if (amount[1] == 0) {\n                amount[1] = amount[0] / 2 + amount[2] / 2;\n                amount[0] = amount[0] % 2;\n                amount[2] = amount[2] % 2;\n            } else if (amount[2] == 0) {\n                amount[2] = amount[0] / 2 + amount[1] / 2;\n                amount[0] = amount[0] % 2;\n                amount[1] = amount[1] % 2;\n            }\n            res++;\n        }\n    }\n}"}
{"id": "499", "path": "output2\\java\\Easy\\499-maximum-number-of-pairs-in-array.java", "hypo_code": "class Solution {\n    public int[] numberOfPairs(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);\n        int pairs = 0, left = 0;\n        for (int key : map.keySet()) {\n            pairs += map.get(key) / 2;\n            left += map.get(key) % 2;\n        }\n        return new int[] {pairs, left};\n    }\n}"}
{"id": "500", "path": "output2\\java\\Easy\\500-best-poker-hand.java", "hypo_code": "class Solution {\n    public String bestHand(int[] ranks, char[] suits) {\n        int[] count = new int[14];\n        for (int rank : ranks) {\n            count[rank]++;\n        }\n        int maxCount = 0;\n        for (int i = 1; i <= 13; i++) {\n            maxCount = Math.max(maxCount, count[i]);\n        }\n        if (maxCount == 5) return \"Flush\";\n        if (maxCount == 4) return \"Three of a Kind\";\n        if (maxCount == 3) return \"Pair\";\n        return \"High Card\";\n    }\n}"}
{"id": "501", "path": "output2\\java\\Easy\\501-first-letter-to-appear-twice.java", "hypo_code": "class Solution {\n    public char repeatedCharacter(String s) {\n        int[] count = new int[26];\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            count[c - 'a']++;\n            if (count[c - 'a'] == 2) return c;\n        }\n        return ' ';\n    }\n}"}
{"id": "503", "path": "output2\\java\\Easy\\503-make-array-zero-by-subtracting-equal-amounts.java", "hypo_code": "class Solution {\n    public int minimumOperations(int[] nums) {\n        int res = 0;\n        while (true) {\n            int min = Integer.MAX_VALUE;\n            for (int num : nums) {\n                if (num != 0) min = Math.min(min, num);\n            }\n            if (min == Integer.MAX_VALUE) return res;\n            for (int i = 0; i < nums.length; i++) {\n                if (nums[i] != 0) nums[i] -= min;\n            }\n            res++;\n        }\n    }\n}"}
{"id": "504", "path": "output2\\java\\Easy\\504-merge-similar-items.java", "hypo_code": "class Solution {\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\n        List<List<Integer>> res = new ArrayList<>();\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] item : items1) {\n            map.put(item[0], map.getOrDefault(item[0], 0) + item[1]);\n        }\n        for (int[] item : items2) {\n            map.put(item[0], map.getOrDefault(item[0], 0) + item[1]);\n        }\n        for (int key : map.keySet()) {\n            List<Integer> item = new ArrayList<>();\n            item.add(key);\n            item.add(map.get(key));\n            res.add(item);\n        }\n        res.sort((a, b) -> a.get(0) - b.get(0));\n        return res;\n    }\n}"}
{"id": "505", "path": "output2\\java\\Easy\\505-number-of-arithmetic-triplets.java", "hypo_code": "class Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int j = nums[i] - diff;\n            int k = nums[i] + diff;\n            if (map.containsKey(j)) {\n                res += map.get(j);\n            }\n            if (map.containsKey(k)) {\n                res += map.get(k);\n            }\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n        }\n        return res;\n    }\n}"}
{"id": "506", "path": "output2\\java\\Easy\\506-largest-local-values-in-a-matrix.java", "hypo_code": "class Solution {\n    public int[][] largestLocal(int[][] grid) {\n        int n = grid.length;\n        int[][] maxLocal = new int[n - 2][n - 2];\n        for (int i = 0; i < n - 2; i++) {\n            int max = Integer.MIN_VALUE;\n            for (int j = 0; j < n - 2; j++) {\n                max = Math.max(max, grid[i][j]);\n            }\n            maxLocal[i][0] = max;\n        }\n        for (int j = 0; j < n - 2; j++) {\n            int max = Integer.MIN_VALUE;\n            for (int i = 0; i < n - 2; i++) {\n                max = Math.max(max, grid[i][j]);\n            }\n            maxLocal[0][j] = max;\n        }\n        return maxLocal;\n    }\n}"}
{"id": "507", "path": "output2\\java\\Easy\\507-minimum-recolors-to-get-k-consecutive-black-blocks.java", "hypo_code": "class Solution {\n    public int minimumRecolors(String blocks, int k) {\n        int n = blocks.length();\n        int res = n;\n        for (int i = 0; i < n; i++) {\n            int cur = 0;\n            int j = i;\n            while (j < n && blocks.charAt(j) == 'B') {\n                cur++;\n                j++;\n            }\n            if (cur >= k) {\n                res = Math.min(res, j - i - k);\n            }\n            i = j;\n        }\n        return res;\n    }\n}"}
{"id": "508", "path": "output2\\java\\Easy\\508-minimum-hours-of-training-to-win-a-competition.java", "hypo_code": "class Solution {\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\n        int n = energy.length;\n        int[][] dp = new int[n][initialEnergy + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= initialEnergy; j++) {\n                if (j >= energy[i] && dp[i][j - energy[i]] >= experience[i]) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i][j - energy[i]] + experience[i]);\n                }\n                if (i > 0) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n                }\n            }\n        }\n        int res = 0;\n        while (dp[n - 1][initialEnergy] < initialExperience) {\n            res++;\n            initialEnergy++;\n        }\n        return res;\n    }\n}"}
{"id": "509", "path": "output2\\java\\Easy\\509-longest-subsequence-with-limited-sum.java", "hypo_code": "class Solution {\n    public int[] answerQueries(int[] nums, int[] queries) {\n        int n = nums.length, m = queries.length;\n        int[] res = new int[m];\n        int[] sum = new int[n + 1];\n        for (int i = 1; i < n + 1; i++) {\n            sum[i] = sum[i - 1] + nums[i - 1];\n        }\n        for (int i = 0; i < m; i++) {\n            res[i] = binarySearch(sum, queries[i]);\n        }\n        return res;\n    }\n    \n    private int binarySearch(int[] sum, int target) {\n        int l = 0, r = sum.length - 1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (sum[mid] <= target) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return l - 1;\n    }\n}"}
{"id": "510", "path": "output2\\java\\Easy\\510-find-subarrays-with-equal-sum.java", "hypo_code": "class Solution {\n    public boolean findSubarrays(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = prefix[i] + nums[i];\n        }\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i <= n; i++) {\n            map.putIfAbsent(prefix[i], new ArrayList<>());\n            map.get(prefix[i]).add(i);\n        }\n        for (int val : map.keySet()) {\n            List<Integer> list = map.get(val);\n            if (list.size() < 2) continue;\n            for (int i = 0; i < list.size() - 1; i++) {\n                if (list.get(i + 1) - list.get(i) > 1) return true;\n            }\n        }\n        return false;\n    }\n}"}
{"id": "511", "path": "output2\\java\\Easy\\511-check-distances-between-same-letters.java", "hypo_code": "class Solution {\n    public boolean checkDistances(String s, int[] distance) {\n        int[] pos = new int[26];\n        for (int i = 0; i < 26; i++) {\n            pos[i] = -1;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            int index = s.charAt(i) - 'a';\n            if (pos[index] == -1) {\n                pos[index] = i;\n            } else {\n                if (i - pos[index] - 1 != distance[index]) {\n                    return false;\n                }\n                pos[index] = i;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "512", "path": "output2\\java\\Easy\\512-most-frequent-even-element.java", "hypo_code": "class Solution {\n    public int mostFrequentEven(int[] nums) {\n        int[] freq = new int[100001];\n        for (int num : nums) {\n            freq[num]++;\n        }\n        int max = 0;\n        for (int i = 0; i <= 100000; i += 2) {\n            max = Math.max(max, freq[i]);\n        }\n        if (max == 0) return -1;\n        for (int i = 0; i <= 100000; i += 2) {\n            if (freq[i] == max) return i;\n        }\n        return -1;\n    }\n}"}
{"id": "513", "path": "output2\\java\\Easy\\513-count-days-spent-together.java", "hypo_code": "class Solution {\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\n        int[] days = new int[]{31, 28, 31, 30, 31, 30, 31, 31 ,30, 31, 30, 31};\n        int[] first = new int[2];\n        int[] second = new int[2];\n        first[0] = Integer.parseInt(arriveAlice.substring(0, 2));\n        first[1] = Integer.parseInt(arriveAlice.substring(3, 5));\n        second[0] = Integer.parseInt(arriveBob.substring(0, 2));\n        second[1] = Integer.parseInt(arriveBob.substring(3, 5));\n        int res = 0;\n        while (true) {\n            if (first[0] == second[0] && first[1] == second[1]) {\n                res++;\n            }\n            if (first[0] == Integer.parseInt(leaveAlice.substring(0, 2)) && first[1] == Integer.parseInt(leaveAlice.substring(3, 5))) {\n                break;\n            }\n            if (second[0] == Integer.parseInt(leaveBob.substring(0, 2)) && second[1] == Integer.parseInt(leaveBob.substring(3, 5))) {\n                break;\n            }\n            first[1]++;\n            if (first[1] > days[first[0] - 1]) {\n                first[1] = 1;\n                first[0]++;\n            }\n            if (first[0] > 12) {\n                first[0] = 1;\n            }\n            second[1]++;\n            if (second[1] > days[second[0] - 1]) {\n                second[1] = 1;\n                second[0]++;\n            }\n            if (second[0] > 12) {\n                second[0] = 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "514", "path": "output2\\java\\Easy\\514-smallest-even-multiple.java", "hypo_code": "class Solution {\n    public int smallestEvenMultiple(int n) {\n        int res = 1;\n        for (int i = 1; i <= n; i++) {\n            if (res % i != 0) {\n                res *= i / gcd(res, i);\n            }\n        }\n        return res;\n    }\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}"}
{"id": "515", "path": "output2\\java\\Easy\\515-sort-the-people.java", "hypo_code": "class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n = names.length;\n        int[][] people = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            people[i][0] = heights[i];\n            people[i][1] = i;\n        }\n        Arrays.sort(people, (a, b) -> b[0] - a[0]);\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = names[people[i][1]];\n        }\n        return res;\n    }\n}"}
{"id": "516", "path": "output2\\java\\Easy\\516-remove-letter-to-equalize-frequency.java", "hypo_code": "class Solution {\n    public boolean equalFrequency(String word) {\n        int[] count = new int[26];\n        for (char c : word.toCharArray()) {\n            count[c - 'a']++;\n        }\n        Arrays.sort(count);\n        int i = 0;\n        while (i < 26 && count[i] == 0) {\n            i++;\n        }\n        int min = count[i];\n        int max = count[25];\n        if (min == max) {\n            return true;\n        } else if (max - min == 1) {\n            return max > count[24];\n        } else {\n            return min == count[i + 1];\n        }\n    }\n}"}
{"id": "517", "path": "output2\\java\\Easy\\517-number-of-common-factors.java", "hypo_code": "class Solution {\n    public int commonFactors(int a, int b) {\n        int res = 0;\n        int n = gcd(a, b);\n        for (int i = 1; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                res += 2;\n                if (i == n / i) {\n                    res--;\n                }\n            }\n        }\n        return res;\n    }\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}"}
{"id": "518", "path": "output2\\java\\Easy\\518-the-employee-that-worked-on-the-longest-task.java", "hypo_code": "class Solution {\n    public int hardestWorker(int n, int[][] logs) {\n        int[] work = new int[n];\n        int max = 0;\n        for (int[] log : logs) {\n            int id = log[0];\n            int time = log[1];\n            work[id] += time;\n            max = Math.max(max, work[id]);\n        }\n        for (int i = 0; i < n; i++) {\n            if (work[i] == max) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "519", "path": "output2\\java\\Easy\\519-number-of-valid-clock-times.java", "hypo_code": "class Solution {\n    public int countTime(String time) {\n        char[] c = time.toCharArray();\n        int res = 0;\n        for (int i = 0; i < 5; i++) {\n            if (c[i] == '?') {\n                if (i == 0) {\n                    if (c[1] == '?' || c[1] <= '3') {\n                        res += 2;\n                    }\n                } else if (i == 1) {\n                    if (c[0] == '2' || c[0] == '?') {\n                        res += 3;\n                    } else {\n                        res += 9;\n                    }\n                } else if (i == 3) {\n                    res += 6;\n                } else {\n                    res += 10;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "520", "path": "output2\\java\\Easy\\520-largest-positive-integer-that-exists-with-its-negative.java", "hypo_code": "class Solution {\n    public int findMaxK(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            set.add(num);\n        }\n        int res = -1;\n        for (int num : nums) {\n            if (num > 0 && set.contains(-num)) {\n                res = Math.max(res, num);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "521", "path": "output2\\java\\Easy\\521-determine-if-two-events-have-conflict.java", "hypo_code": "class Solution {\n    public boolean haveConflict(String[] event1, String[] event2) {\n        String[] start1 = event1[0].split(\":\");\n        String[] end1 = event1[1].split(\":\");\n        String[] start2 = event2[0].split(\":\");\n        String[] end2 = event2[1].split(\":\");\n        int start1Hour = Integer.parseInt(start1[0]);\n        int start1Min = Integer.parseInt(start1[1]);\n        int end1Hour = Integer.parseInt(end1[0]);\n        int end1Min = Integer.parseInt(end1[1]);\n        int start2Hour = Integer.parseInt(start2[0]);\n        int start2Min = Integer.parseInt(start2[1]);\n        int end2Hour = Integer.parseInt(end2[0]);\n        int end2Min = Integer.parseInt(end2[1]);\n        if (start1Hour > end2Hour || start2Hour > end1Hour) {\n            return false;\n        }\n        if (start1Hour == end2Hour && start1Min >= end2Min) {\n            return false;\n        }\n        if (start2Hour == end1Hour && start2Min >= end1Min) {\n            return false;\n        }\n        return true;\n    }\n}"}
{"id": "522", "path": "output2\\java\\Easy\\522-odd-string-difference.java", "hypo_code": "class Solution {\n    public String oddString(String[] words) {\n        int n = words.length;\n        int m = words[0].length();\n        int[][] diff = new int[n][m - 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m - 1; j++) {\n                diff[i][j] = words[i].charAt(j + 1) - words[i].charAt(j);\n            }\n        }\n        int[] count = new int[26];\n        for (int i = 0; i < m - 1; i++) {\n            count[diff[0][i] - diff[1][i] + 25]++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) {\n                for (int j = 0; j < n; j++) {\n                    if (diff[j][0] - diff[0][0] == i - 25) {\n                        return words[j];\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}"}
{"id": "523", "path": "output2\\java\\Easy\\523-average-value-of-even-numbers-that-are-divisible-by-three.java", "hypo_code": "class Solution {\n    public int averageValue(int[] nums) {\n        int sum = 0, cnt = 0;\n        for (int num : nums) {\n            if (num % 3 == 0 && num % 2 == 0) {\n                sum += num;\n                cnt++;\n            }\n        }\n        return cnt == 0 ? 0 : sum / cnt;\n    }\n}"}
{"id": "524", "path": "output2\\java\\Easy\\524-apply-operations-to-an-array.java", "hypo_code": "class Solution {\n    public int[] applyOperations(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n - 1; i++) {\n            if (nums[i] == nums[i + 1]) {\n                nums[i] *= 2;\n                nums[i + 1] = 0;\n            }\n        }\n        int[] res = new int[n];\n        int idx = 0;\n        for (int num : nums) {\n            if (num != 0) res[idx++] = num;\n        }\n        return res;\n    }\n}"}
{"id": "525", "path": "output2\\java\\Easy\\525-number-of-distinct-averages.java", "hypo_code": "class Solution {\n    public int distinctAverages(int[] nums) {\n        int n = nums.length;\n        Set<Double> set = new HashSet<>();\n        Arrays.sort(nums);\n        for (int i = 0, j = n - 1; i < j; i++, j--) {\n            set.add((nums[i] + nums[j]) / 2.0);\n        }\n        return set.size();\n    }\n}"}
{"id": "526", "path": "output2\\java\\Easy\\526-convert-the-temperature.java", "hypo_code": "class Solution {\n    public double[] convertTemperature(double celsius) {\n        double[] res = new double[2];\n        res[0] = celsius + 273.15;\n        res[1] = celsius * 1.80 + 32.00;\n        return res;\n    }\n}"}
{"id": "527", "path": "output2\\java\\Easy\\527-number-of-unequal-triplets-in-array.java", "hypo_code": "class Solution {\n    public int unequalTriplets(int[] nums) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int res = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (nums[i] == nums[i + 1]) continue;\n            for (int j = i + 1; j < n - 1; j++) {\n                if (nums[j] == nums[j + 1]) continue;\n                for (int k = j + 1; k < n; k++) {\n                    if (nums[k] == nums[k - 1]) continue;\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "528", "path": "output2\\java\\Easy\\528-minimum-cuts-to-divide-a-circle.java", "hypo_code": "class Solution {\n    public int numberOfCuts(int n) {\n        return n == 1 ? 0 : n - 1;\n    }\n}"}
{"id": "529", "path": "output2\\java\\Easy\\529-find-the-pivot-integer.java", "hypo_code": "class Solution {\n    public int pivotInteger(int n) {\n        int sum = n * (n + 1) / 2;\n        int left = 0, right = n;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int leftSum = mid * (mid + 1) / 2;\n            int rightSum = sum - leftSum;\n            if (leftSum == rightSum) {\n                return mid;\n            } else if (leftSum < rightSum) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "530", "path": "output2\\java\\Easy\\530-circular-sentence.java", "hypo_code": "class CircularSentence {\n    public boolean isCircularSentence(String sentence) {\n        String[] words = sentence.split(\" \");\n        for(int i = 0; i < words.length - 1; i++){\n            if(words[i].charAt(words[i].length() - 1) != words[i + 1].charAt(0)) return false;\n        }\n        if(words[words.length - 1].charAt(words[words.length - 1].length() - 1) != words[0].charAt(0)) return false;\n        return true;\n        \n    }\n}"}
{"id": "531", "path": "output2\\java\\Easy\\531-maximum-value-of-a-string-in-an-array.java", "hypo_code": "class MaximumValueOfAStringInAnArray {\n    public int maximumValue(String[] strs) {\n        int max = 0;\n        for(String s : strs){\n            int val = 0;\n            for(char c : s.toCharArray()){\n                if(Character.isDigit(c)){\n                    val = val * 10 + (c - '0');\n                }else{\n                    val++;\n                }\n            }\n            max = Math.max(max, val);\n        }\n        return max;\n        \n        \n    }\n}"}
{"id": "532", "path": "output2\\java\\Easy\\532-delete-greatest-value-in-each-row.java", "hypo_code": "class DeleteGreatestValueInEachRow {\n    public int deleteGreatestValue(int[][] grid) {\n        int sum = 0;\n        while(grid.length > 0){\n            int max = Integer.MIN_VALUE;\n            int maxIndex = 0;\n            for(int i = 0; i < grid.length; i++){\n                for(int j = 0; j < grid[i].length; j++){\n                    if(grid[i][j] > max){\n                        max = grid[i][j];\n                        maxIndex = i;\n                    }\n                }\n            }\n            sum += max;\n            int[][] newGrid = new int[grid.length - 1][grid[0].length - 1];\n            int count = 0;\n            for(int i = 0; i < grid.length; i++){\n                if(i == maxIndex) continue;\n                for(int j = 0; j < grid[i].length; j++){\n                    if(j == maxIndex) continue;\n                    newGrid[count][j] = grid[i][j];\n                }\n                count++;\n            }\n            grid = newGrid;\n        }\n        return sum;\n        \n        \n\n        \n    }\n}"}
{"id": "533", "path": "output2\\java\\Easy\\533-count-pairs-of-similar-strings.java", "hypo_code": "class CountPairsOfSimilarStrings {\n    public int similarPairs(String[] words) {\n        int count = 0;\n        for(int i = 0; i < words.length; i++){\n            for(int j = i + 1; j < words.length; j++){\n                if(isSimilar(words[i], words[j])){\n                    count++;\n                }\n            }\n        }\n        return count; \n    }\n}"}
{"id": "534", "path": "output2\\java\\Easy\\534-maximum-enemy-forts-that-can-be-captured.java", "hypo_code": "class MaximumEnemyFortsThatCanBeCaptured {\n    public int captureForts(int[] forts) {\n        int max = 0;\n        int count = 0;\n        for(int i = 0; i < forts.length; i++){\n            if(forts[i] == 1){\n                count++;\n            }\n        }\n        if(count == 0) return 0;\n        for(int i = 0; i < forts.length; i++){\n            if(forts[i] == 1){\n                int j = i;\n                int k = i;\n                int temp = 0;\n                while(j >= 0 && forts[j] != -1){\n                    if(forts[j] == 0){\n                        temp++;\n                    }\n                    j--;\n                }\n                while(k < forts.length && forts[k] != -1){\n                    if(forts[k] == 0){\n                        temp++;\n                    }\n                    k++;\n                }\n                max = Math.max(max, temp);\n            }\n        }\n        return max;\n        \n        \n        \n    }\n}"}
{"id": "535", "path": "output2\\java\\Easy\\535-shortest-distance-to-target-string-in-a-circular-array.java", "hypo_code": "class ShortestDistanceToTargetStringInACircularArray {\n    public int closetTarget(String[] words, String target, int startIndex) {\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < words.length; i++){\n            if(words[i].equals(target)){\n                min = Math.min(min, Math.abs(i - startIndex));\n            }\n        }\n        return min == Integer.MAX_VALUE ? -1 : min;\n        \n    }\n}"}
{"id": "536", "path": "output2\\java\\Easy\\536-count-the-digits-that-divide-a-number.java", "hypo_code": "class CountTheDigitsThatDivideANumber {\n    public int countDigits(int num) {\n        int count = 0;\n        int temp = num;\n        while(temp > 0){\n            int digit = temp % 10;\n            if(digit != 0 && num % digit == 0){\n                count++;\n            }\n            temp /= 10;\n        }\n        return count;\n        \n        \n        \n    }\n}"}
{"id": "537", "path": "output2\\java\\Easy\\537-categorize-box-according-to-criteria.java", "hypo_code": "class CategorizeBoxAccordingToCriteria {\n    public String categorizeBox(int length, int width, int height, int mass) {\n        if(length >= 10000 || width >= 10000 || height >= 10000 || length * width * height >= 1000000000){\n            if(mass >= 100){\n                return \"Both\";\n            }else{\n                return \"Bulky\";\n            }\n        }else{\n            if(mass >= 100){\n                return \"Heavy\";\n            }else{\n                return \"Neither\";\n            }\n        }\n        \n        \n    }\n}"}
{"id": "538", "path": "output2\\java\\Easy\\538-maximum-count-of-positive-integer-and-negative-integer.java", "hypo_code": "class MaximumCountOfPositiveIntegerAndNegativeInteger {\n    public int maximumCount(int[] nums) {\n        int pos = 0;\n        int neg = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] > 0){\n                pos++;\n            }else if(nums[i] < 0){\n                neg++;\n            }\n        }\n        return Math.max(pos, neg);\n        \n        \n        \n    }\n}"}
{"id": "539", "path": "output2\\java\\Easy\\539-difference-between-element-sum-and-digit-sum-of-an-array.java", "hypo_code": "class DifferenceBetweenElementSumAndDigitSumOfAnArray {\n    public int differenceOfSum(int[] nums) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            sum += nums[i];\n        }\n        int digitSum = 0;\n        for(int i = 0; i < nums.length; i++){\n            while(nums[i] > 0){\n                digitSum += nums[i] % 10;\n                nums[i] /= 10;\n            }\n        }\n        return Math.abs(sum - digitSum);\n        \n        \n        \n    }\n}"}
{"id": "540", "path": "output2\\java\\Easy\\540-minimum-common-value.java", "hypo_code": "class MinimumCommonValue {\n    public int getCommon(int[] nums1, int[] nums2) {\n        int i = 0;\n        int j = 0;\n        while(i < nums1.length && j < nums2.length){\n            if(nums1[i] == nums2[j]){\n                return nums1[i];\n            }else if(nums1[i] < nums2[j]){\n                i++;\n            }else{\n                j++;\n            }\n        }\n        return -1;\n        \n        \n    }\n}"}
{"id": "541", "path": "output2\\java\\Easy\\541-alternating-digit-sum.java", "hypo_code": "class AlternatingDigitSum {\n    public int alternateDigitSum(int n) {\n        int sum = 0;\n        int sign = 1;\n        while(n > 0){\n            sum += sign * (n % 10);\n            sign *= -1;\n            n /= 10;\n        }\n        return sum;\n        \n        \n    }\n}"}
{"id": "542", "path": "output2\\java\\Easy\\542-count-distinct-numbers-on-board.java", "hypo_code": "class Solution {\n    public int distinctIntegers(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 1) res++;\n        }\n        return res;\n    }\n}"}
{"id": "543", "path": "output2\\java\\Easy\\543-separate-the-digits-in-an-array.java", "hypo_code": "class Solution {\n    public int[] separateDigits(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n * 7];\n        int idx = 0;\n        for (int num : nums) {\n            while (num > 0) {\n                res[idx++] = num % 10;\n                num /= 10;\n            }\n        }\n        int[] ans = new int[idx];\n        for (int i = 0; i < idx; i++) {\n            ans[i] = res[idx - 1 - i];\n        }\n        return ans;\n    }\n}"}
{"id": "544", "path": "output2\\java\\Easy\\544-take-gifts-from-the-richest-pile.java", "hypo_code": "class Solution {\n    public long pickGifts(int[] gifts, int k) {\n        int n = gifts.length;\n        Arrays.sort(gifts);\n        long sum = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            if (gifts[i] <= 1) break;\n            sum += Math.sqrt(gifts[i]);\n            gifts[i] = (int) Math.sqrt(gifts[i]);\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            res += gifts[i];\n        }\n        return res - sum * k;\n    }\n}"}
{"id": "545", "path": "output2\\java\\Easy\\545-find-the-array-concatenation-value.java", "hypo_code": "class Solution {\n    public long findTheArrayConcVal(int[] nums) {\n        int n = nums.length;\n        long res = 0;\n        for (int i = 0, j = n - 1; i <= j; i++, j--) {\n            if (i == j) {\n                res += nums[i];\n            } else {\n                res += nums[i] * Math.pow(10, Integer.toString(nums[j]).length()) + nums[j];\n            }\n        }\n        return res;\n    }\n}"}
{"id": "546", "path": "output2\\java\\Easy\\546-maximum-difference-by-remapping-a-digit.java", "hypo_code": "class Solution {\n    public int minMaxDifference(int num) {\n        int[] cnt = new int[10];\n        char[] c = String.valueOf(num).toCharArray();\n        for (char ch : c) {\n            cnt[ch - '0']++;\n        }\n        int min = 0, max = 0;\n        for (int i = 0; i < 10; i++) {\n            if (i == 0) {\n                if (cnt[i] > 0) {\n                    min = i;\n                    break;\n                }\n            } else if (cnt[i] > 0) {\n                min = i;\n                break;\n            }\n        }\n        for (int i = 0; i < 10; i++) {\n            if (cnt[i] > 0) {\n                max = i;\n            }\n        }\n        int res = max - min;\n        if (cnt[min] == 1) {\n            for (int i = min + 1; i < 10; i++) {\n                if (cnt[i] > 0) {\n                    res = Math.min(res, i - min);\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "547", "path": "output2\\java\\Easy\\547-merge-two-2d-arrays-by-summing-values.java", "hypo_code": "class Solution {\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] num : nums1) {\n            map.put(num[0], num[1]);\n        }\n        for (int[] num : nums2) {\n            map.put(num[0], map.getOrDefault(num[0], 0) + num[1]);\n        }\n        int[][] res = new int[map.size()][2];\n        int idx = 0;\n        for (int id : map.keySet()) {\n            res[idx][0] = id;\n            res[idx][1] = map.get(id);\n            idx++;\n        }\n        Arrays.sort(res, (a, b) -> a[0] - b[0]);\n        return res;\n    }\n}"}
{"id": "548", "path": "output2\\java\\Easy\\548-left-and-right-sum-differences.java", "hypo_code": "class Solution {\n    public int[] leftRightDifference(int[] nums) {\n        int n = nums.length;\n        int[] leftSum = new int[n], rightSum = new int[n];\n        for (int i = 0; i < n; i++) {\n            leftSum[i] = nums[i] + (i == 0 ? 0 : leftSum[i - 1]);\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            rightSum[i] = nums[i] + (i == n - 1 ? 0 : rightSum[i + 1]);\n        }\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = Math.abs(leftSum[i] - rightSum[i]);\n        }\n        return res;\n    }\n}"}
{"id": "549", "path": "output2\\java\\Easy\\549-split-with-minimum-sum.java", "hypo_code": "class Solution {\n    public int splitNum(int num) {\n        int[] cnt = new int[10];\n        String s = String.valueOf(num);\n        for (char c : s.toCharArray()) {\n            cnt[c - '0']++;\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 1; i < 1000000000; i++) {\n            int[] cnt1 = new int[10];\n            int[] cnt2 = new int[10];\n            String s1 = String.valueOf(i);\n            String s2 = String.valueOf(num - i);\n            if (s1.length() + s2.length() == s.length()) {\n                for (char c : s1.toCharArray()) {\n                    cnt1[c - '0']++;\n                }\n                for (char c : s2.toCharArray()) {\n                    cnt2[c - '0']++;\n                }\n                boolean isValid = true;\n                for (int j = 0; j < 10; j++) {\n                    if (cnt[j] != cnt1[j] + cnt2[j]) {\n                        isValid = false;\n                        break;\n                    }\n                }\n                if (isValid) {\n                    res = Math.min(res, Integer.parseInt(s1) + Integer.parseInt(s2));\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "550", "path": "output2\\java\\Easy\\550-pass-the-pillow.java", "hypo_code": "class Solution {\n    public int passThePillow(int n, int time) {\n        int res = 0;\n        for (int i = 1; i <= time; i++) {\n            res = i % n;\n        }\n        return res;\n    }\n}"}
{"id": "551", "path": "output2\\java\\Easy\\551-count-the-number-of-vowel-strings-in-range.java", "hypo_code": "class Solution {\n    public int vowelStrings(String[] words, int left, int right) {\n        int res = 0;\n        for (int i = left; i <= right; i++) {\n            String word = words[i];\n            int n = word.length();\n            int count = 1;\n            for (int j = 0; j < n; j++) {\n                char c = word.charAt(j);\n                if (c == 'a') {\n                    count *= 1;\n                } else if (c == 'e') {\n                    count *= 2;\n                } else if (c == 'i') {\n                    count *= 4;\n                } else if (c == 'o') {\n                    count *= 8;\n                } else {\n                    count *= 16;\n                }\n            }\n            res += count;\n        }\n        return res;\n    }\n}"}
{"id": "552", "path": "output2\\java\\Easy\\552-distribute-money-to-maximum-children.java", "hypo_code": "class Solution {\n    public int distMoney(int money, int children) {\n        if (money < children) return -1;\n        if (money == children) return 1;\n        int res = 0;\n        if (money % children == 0) {\n            res = 1;\n        } else {\n            res = 2;\n        }\n        return res;\n    }\n}"}
{"id": "553", "path": "output2\\java\\Easy\\553-number-of-even-and-odd-bits.java", "hypo_code": "class Solution {\n    public int[] evenOddBit(int n) {\n        int odd = 0, even = 0;\n        while (n > 0) {\n            if (n % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n            n /= 2;\n        }\n        return new int[]{even, odd};\n    }\n}"}
{"id": "554", "path": "output2\\java\\Easy\\554-k-items-with-the-maximum-sum.java", "hypo_code": "class Solution {\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\n        int sum = 0;\n        if (k <= numOnes) {\n            sum += k;\n            numOnes -= k;\n            k = 0;\n        } else {\n            sum += numOnes;\n            k -= numOnes;\n            numOnes = 0;\n        }\n        if (k <= numZeros) {\n            sum += 0;\n            numZeros -= k;\n            k = 0;\n        } else {\n            sum += numZeros;\n            k -= numZeros;\n            numZeros = 0;\n        }\n        if (k <= numNegOnes) {\n            sum += -k;\n            numNegOnes -= k;\n            k = 0;\n        } else {\n            sum += -numNegOnes;\n            k -= numNegOnes;\n            numNegOnes = 0;\n        }\n        if (k <= numOnes) {\n            sum += k;\n            numOnes -= k;\n            k = 0;\n        } else {\n            sum += numOnes;\n            k -= numOnes;\n            numOnes = 0;\n        }\n        if (k <= numZeros) {\n            sum += 0;\n            numZeros -= k;\n            k = 0;\n        } else {\n            sum += numZeros;\n            k -= numZeros;\n            numZeros = 0;\n        }\n        if (k <= numNegOnes) {\n            sum += -k;\n            numNegOnes -= k;\n            k = 0;\n        } else {\n            sum += -numNegOnes;\n            k -= numNegOnes;\n            numNegOnes = 0;\n        }\n        return sum;\n    }\n}"}
{"id": "555", "path": "output2\\java\\Easy\\555-form-smallest-number-from-two-digit-arrays.java", "hypo_code": "class Solution {\n    public int minNumber(int[] nums1, int[] nums2) {\n        boolean[] cnt = new boolean[10];\n        for (int num : nums1) {\n            cnt[num] = true;\n        }\n        for (int num : nums2) {\n            cnt[num] = true;\n        }\n        int res = 0;\n        for (int i = 1; i < 10; i++) {\n            if (cnt[i]) {\n                res = i;\n                break;\n            }\n        }\n        for (int i = 0; i < 10; i++) {\n            if (cnt[i]) {\n                res = res * 10 + i;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "556", "path": "output2\\java\\Easy\\556-find-the-longest-balanced-substring-of-a-binary-string.java", "hypo_code": "class Solution {\n    public int findTheLongestBalancedSubstring(String s) {\n     int res = 0;\n        int n = s.length();\n        int[] prefix = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = prefix[i] + (s.charAt(i) == '0' ? 1 : -1);\n        }\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i <= n; i++) {\n            if (map.containsKey(prefix[i])) {\n                res = Math.max(res, i - map.get(prefix[i]));\n            } else {\n                map.put(prefix[i], i);\n            }\n        }\n        return res;   \n    }\n}"}
{"id": "557", "path": "output2\\java\\Easy\\557-prime-in-diagonal.java", "hypo_code": "class Solution {\n    public int diagonalPrime(int[][] nums) {\n        int n = nums.length, res = 0;\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < n; i++) {\n            if (isPrime(nums[i][i])) set.add(nums[i][i]);\n            if (isPrime(nums[i][n - i - 1])) set.add(nums[i][n - i - 1]);\n        }\n        for (int num : set) {\n            res = Math.max(res, num);\n        }\n        return res;\n    }\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n}"}
{"id": "565", "path": "output2\\java\\Easy\\565-find-the-width-of-columns-of-a-grid.java", "hypo_code": "class Solution {\n    public int[] findColumnWidth(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[] res = new int[n];\n        for (int j = 0; j < n; j++) {\n            int max = 0;\n            for (int[] row : grid) {\n                int len = (int) Math.log10(Math.abs(row[j])) + 1;\n                max = Math.max(max, len);\n            }\n            res[j] = max;\n        }\n        return res;\n    }\n}"}
{"id": "566", "path": "output2\\java\\Easy\\566-row-with-maximum-ones.java", "hypo_code": "class Solution {\n    public int[] rowAndMaximumOnes(int[][] mat) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int[] res = new int[2];\n        int max = 0;\n        for (int i = 0; i < m; i++) {\n            int count = 0;\n            for (int j = 0; j < n && mat[i][j] == 1; j++) {\n                count++;\n            }\n            if (count > max) {\n                max = count;\n                res[0] = i;\n                res[1] = count;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "567", "path": "output2\\java\\Easy\\567-find-the-maximum-divisibility-score.java", "hypo_code": "class Solution {\n    public int maxDivScore(int[] nums, int[] divisors) {\n        int[] cnt = new int[1001];\n        for (int num : nums) {\n            cnt[num]++;\n        }\n        int res = -1;\n        for (int divisor : divisors) {\n            int cur = 0;\n            for (int i = divisor; i <= 1000; i += divisor) {\n                cur += cnt[i];\n            }\n            if (cur > res) {\n                res = cur;\n            }\n        }\n        for (int divisor : divisors) {\n            int cur = 0;\n            for (int i = divisor; i <= 1000; i += divisor) {\n                cur += cnt[i];\n            }\n            if (cur == res) {\n                return divisor;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "569", "path": "output2\\java\\Easy\\569-calculate-delayed-arrival-time.java", "hypo_code": "class Solution {\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n        return (arrivalTime + delayedTime) % 24;\n\n    }\n}"}
{"id": "570", "path": "output2\\java\\Easy\\570-sum-multiples.java", "hypo_code": "class Solution {\n    public int sumOfMultiples(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 || i % 5 ==0 || i % 7 == 0) {\n                res += i;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "571", "path": "output2\\java\\Easy\\571-maximum-sum-with-exactly-k-elements.java", "hypo_code": "class Solution {\n    public int maximizeSum(int[] nums, int k) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int[] prefixSum = new int[n + 1];\n        for (int i = 1; i <= n; i++) prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\n        int res = 0;\n        for (int i = 0; i <= k; i++) {\n            int sum = prefixSum[n] - prefixSum[i];\n            int cnt = n - i;\n            if (sum >= cnt) {\n                int add = sum / cnt;\n                res = Math.max(res, prefixSum[i] + cnt * (add + add + cnt - 1) / 2);\n                if (sum % cnt == 0) {\n                    res = Math.max(res, prefixSum[i] + cnt * (add + add - 1) / 2);\n                } else {\n                    res = Math.max(res, prefixSum[i] + cnt * (add + add + cnt - 1) / 2 + (sum % cnt) * add);\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "572", "path": "output2\\java\\Easy\\572-determine-the-winner-of-a-bowling-game.java", "hypo_code": "class Solution {\n    public int isWinner(int[] player1, int[] player2) {\n        int n = player1.length;\n        int[] dp1 = new int[n];\n        int[] dp2 = new int[n];\n        dp1[0] = player1[0];\n        dp2[0] = player2[0];\n        for (int i = 1; i < n; i++) {\n            if (i >= 2 && player1[i - 1] + player1[i - 2] == 10) {\n                dp1[i] = dp1[i - 1] + 2 * player1[i];\n            } else {\n                dp1[i] = dp1[i - 1] + player1[i];\n            }\n            if (i >= 2 && player2[i - 1] + player2[i - 2] == 10) {\n                dp2[i] = dp2[i - 1] + 2 * player2[i];\n            } else {\n                dp2[i] = dp2[i - 1] + player2[i];\n            }\n        }\n        if (dp1[n - 1] > dp2[n - 1]) {\n            return 1;\n        } else if (dp1[n - 1] < dp2[n - 1]) {\n            return 2;\n        } else {\n            return 0;\n        }\n    }\n}"}
{"id": "576", "path": "output2\\java\\Easy\\576-find-the-distinct-difference-array.java", "hypo_code": "class Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        int[] prefix = new int[51];\n        for (int num : nums) {\n            prefix[num]++;\n        }\n        int[] suffix = new int[51];\n        for (int i = n - 1; i >= 0; i--) {\n            suffix[nums[i]]++;\n            res[i] = count(prefix) - count(suffix);\n        }\n        return res;\n    }\n    private int count(int[] arr) {\n        int res = 0;\n        for (int val : arr) {\n            if (val != 0) res++;\n        }\n        return res;\n    }\n}"}
{"id": "578", "path": "output2\\java\\Easy\\578-number-of-senior-citizens.java", "hypo_code": "class Solution {\n    public int countSeniors(String[] details) {\n        int res = 0;\n        for (String detail : details) {\n            if (Integer.parseInt(detail.substring(10, 12)) > 59) res++;\n        }\n        return res;\n    }\n}"}
{"id": "579", "path": "output2\\java\\Easy\\579-find-the-losers-of-the-circular-game.java", "hypo_code": "class Solution {\n    public int[] circularGameLosers(int n, int k) {\n        List<Integer> res = new ArrayList<>();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = i + 1;\n        }\n        int idx = 0;\n        int count = 0;\n        while (count < n - 1) {\n            int i = idx;\n            int j = 0;\n            while (j < k) {\n                if (arr[i] != 0) {\n                    j++;\n                }\n                i = (i + 1) % n;\n            }\n            res.add(arr[i]);\n            arr[i] = 0;\n            count++;\n            while (arr[idx] == 0) {\n                idx = (idx + 1) % n;\n            }\n        }\n        int[] ans = new int[res.size()];\n        for (int i = 0; i < res.size(); i++) {\n            ans[i] = res.get(i);\n        }\n        return ans;\n    }\n}"}
{"id": "581", "path": "output2\\java\\Easy\\581-minimum-string-length-after-removing-substrings.java", "hypo_code": "class Solution {\n    public int minLength(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (stack.isEmpty()) {\n                stack.push(c);\n            } else {\n                if (c == 'B' && stack.peek() == 'A') {\n                    stack.pop();\n                } else if (c == 'D' && stack.peek() == 'C') {\n                    stack.pop();\n                } else {\n                    stack.push(c);\n                }\n            }\n        }\n        return stack.size();\n    }\n}"}
{"id": "582", "path": "output2\\java\\Easy\\582-lexicographically-smallest-palindrome.java", "hypo_code": "class Solution {\n    public String makeSmallestPalindrome(String s) {\n        int n = s.length();\n        char[] arr = s.toCharArray();\n        for (int i = 0; i < n / 2; i++) {\n            if (arr[i] != arr[n - 1 - i]) {\n                arr[n - 1 - i] = arr[i];\n                break;\n            }\n        }\n        return new String(arr);\n    }\n}"}
{"id": "585", "path": "output2\\java\\Easy\\585-buy-two-chocolates.java", "hypo_code": "class Solution {\n    public int buyChoco(int[] prices, int money) {\n        int n = prices.length;\n        Arrays.sort(prices);\n        int res = money;\n        for (int i = 0; i < n - 1; i++) {\n            if (prices[i] >= money) continue;\n            for (int j = i + 1; j < n; j++) {\n                if (prices[i] + prices[j] > money) break;\n                res = Math.min(res, money - prices[i] - prices[j]);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "586", "path": "output2\\java\\Easy\\586-remove-trailing-zeros-from-a-string.java", "hypo_code": "class Solution {\n    public String removeTrailingZeros(String num) {\n        int i = num.length() - 1;\n        while (i >= 0 && num.charAt(i) == '0') {\n            i--;\n        }\n        return num.substring(0, i + 1);\n    }\n}"}
{"id": "588", "path": "output2\\java\\Easy\\588-minimize-string-length.java", "hypo_code": "class Solution {\n    public int minimizedStringLength(String s) {\n        int n = s.length();\n        int res = n;\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            int left = i - 1;\n            int right = i + 1;\n            while (left >= 0 && right < n) {\n                if (s.charAt(left) == c) {\n                    break;\n                } else if (s.charAt(right) == c) {\n                    break;\n                } else {\n                    left--;\n                    right++;\n                }\n            }\n            if (left >= 0 && s.charAt(left) == c) {\n                res = Math.min(res, right - left - 1);\n            } else if (right < n && s.charAt(right) == c) {\n                res = Math.min(res, right - left - 1);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "589", "path": "output2\\java\\Easy\\589-semi-ordered-permutation.java", "hypo_code": "class Solution {\n    public int semiOrderedPermutation(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        if (nums[0] != 1) res++;\n        if (nums[n - 1] != n) res++;\n        for (int i = 1; i < n; i++) {\n            if (nums[i] != nums[i - 1] + 1) res++;\n        }\n        return res;\n    }\n}"}
{"id": "595", "path": "output2\\java\\Easy\\595-check-if-the-number-is-fascinating.java", "hypo_code": "class Solution {\n    public boolean isFascinating(int n) {\n        String str = \"\" + n + n * 2 + n * 3;\n        int[] count = new int[10];\n        for (char c : str.toCharArray()) {\n            count[c - '0']++;\n        }\n        for (int i = 1; i < 10; i++) {\n            if (count[i] != 1) return false;\n        }\n        return true;\n    }\n}"}
{"id": "596", "path": "output2\\java\\Easy\\596-neither-minimum-nor-maximum.java", "hypo_code": "class Solution {\n    public int findNonMinOrMax(int[] nums) {\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n        for (int num : nums) {\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n        for (int num : nums) {\n            if (num != min && num != max) {\n                return num;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "597", "path": "output2\\java\\Easy\\597-total-distance-traveled.java", "hypo_code": "class Solution {\n    public int distanceTraveled(int mainTank, int additionalTank) {\n        int res = 0;\n        while (mainTank > 0) {\n            res += mainTank * 10;\n            if (mainTank == 1) {\n                break;\n            }\n            if (mainTank % 5 == 0) {\n                mainTank += additionalTank;\n            }\n            mainTank--;\n        }\n        return res;\n    }\n}"}
{"id": "598", "path": "output2\\java\\Easy\\598-find-maximum-number-of-string-pairs.java", "hypo_code": "class Solution {\n    public int maximumNumberOfStringPairs(String[] words) {\n        int[] count = new int[26];\n        for (String word : words) {\n            count[word.charAt(0) - 'a']++;\n        }\n        int res = 0;\n        for (int i = 0; i < 26; i++) {\n            res += count[i] / 2;\n        }\n        return res;\n    }\n}"}
{"id": "599", "path": "output2\\java\\Easy\\599-number-of-beautiful-pairs.java", "hypo_code": "class Solution {\n    public int countBeautifulPairs(int[] nums) {\n        int res = 0;\n        int[] cnt = new int[10001];\n        for (int num : nums) {\n            cnt[num]++;\n        }\n        for (int num : nums) {\n            if (cnt[num] > 0) {\n                res++;\n                cnt[num]--;\n            }\n        }\n        return res < nums.length ? res + 1 : res - 1;\n\n    }\n}"}
{"id": "600", "path": "output2\\java\\Easy\\600-longest-even-odd-subarray-with-threshold.java", "hypo_code": "class Solution {\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\n        int n = nums.length;\n        int res = 0;\n        for (int i = 0, j = 0; j < n; j++) {\n            if (Math.abs(nums[j] - nums[i]) > threshold) {\n                i = j;\n            }\n            res = Math.max(res, j - i + 1);\n        }\n        return res;\n    }\n}"}
{"id": "601", "path": "output2\\java\\Easy\\601-longest-alternating-subarray.java", "hypo_code": "class Solution {\n    public int alternatingSubarray(int[] nums) {\n        int n = nums.length;\n        int res = 0, len = 1;\n        for (int i = 0; i < n - 1; i++) {\n            if (nums[i + 1] - nums[i] < 0) {\n                len++;\n            } else {\n                len = 1;\n            }\n            res = Math.max(res, len);\n        }\n        len = 1;\n        for (int i = 0; i < n - 1; i++) {\n            if (nums[i + 1] - nums[i] > 0) {\n                len++;\n            } else {\n                len = 1;\n            }\n            res = Math.max(res, len);\n        }\n        return res;\n    }\n}"}
{"id": "602", "path": "output2\\java\\Easy\\602-find-the-maximum-achievable-number.java", "hypo_code": "class Solution {\n    public int theMaximumAchievableX(int num, int t) {\n        if (num == 0) return t;\n        int res = 0;\n        int[] dp = new int[t + 1];\n        for (int i = 0; i <= t; i++) {\n            dp[i] = num + i;\n        }\n        for (int i = 0; i <= t; i++) {\n            res = Math.max(res, dp[i]);\n            for (int j = i + 1; j <= t; j++) {\n                dp[j] = Math.max(dp[j], dp[i] + (j - i));\n            }\n        }\n        return res;\n    }\n}"}
{"id": "603", "path": "output2\\java\\Easy\\603-sum-of-squares-of-special-elements.java", "hypo_code": "class Solution {\n    public int sumOfSquares(int[] nums) {\n        int n = nums.length;\n        int[] freq = new int[n + 1];\n        for (int num : nums) {\n            freq[num]++;\n        }\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                res += freq[i] * i * i;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "604", "path": "output2\\java\\Easy\\604-check-if-array-is-good.java", "hypo_code": "class Solution {\n    public boolean isGood(int[] nums) {\n        int n = nums.length;\n        int max = 0;\n        for (int num : nums) {\n            max = Math.max(max, num);\n        }\n        int[] freq = new int[max + 1];\n        for (int num : nums) {\n            freq[num]++;\n        }\n        for (int i = 1; i <= max; i++) {\n            if (freq[i] != 1 && freq[i] != 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "605", "path": "output2\\java\\Easy\\605-split-strings-by-separator.java", "hypo_code": "class Solution {\n    public List<String> splitWordsBySeparator(List<String> words, char separator) {\n        List<String> res = new ArrayList<>();\n        for (String word : words) {\n            for (String sub : word.split(String.valueOf(separator))) {\n                if (!sub.isEmpty()) {\n                    res.add(sub);\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "606", "path": "output2\\java\\Easy\\606-number-of-employees-who-met-the-target.java", "hypo_code": "class Solution {\n    public int numberOfEmployeesWhoMetTarget(int[] hours, int target) {\n        int n = hours.length;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = i; j < n && sum < target; j++) {\n                sum += hours[j];\n                if (sum >= target) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "607", "path": "output2\\java\\Easy\\607-account-balance-after-rounded-purchase.java", "hypo_code": "class Solution {\n    public int accountBalanceAfterPurchase(int purchaseAmount) {\n        int res = 100;\n        if (purchaseAmount < 5) return res;\n        int roundedAmount = purchaseAmount;\n        if (purchaseAmount % 10 >= 5) {\n            roundedAmount = (purchaseAmount / 10 + 1) * 10;\n        } else {\n            roundedAmount = (purchaseAmount / 10) * 10;\n        }\n        return res - roundedAmount;\n    }\n}"}
{"id": "608", "path": "output2\\java\\Easy\\608-faulty-keyboard.java", "hypo_code": "class Solution {\n    public String finalString(String s) {\n        int n = s.length();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == 'i') {\n                sb.reverse();\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "609", "path": "output2\\java\\Easy\\609-max-pair-sum-in-an-array.java", "hypo_code": "class Solution {\n    public int maxSum(int[] nums) {\n        int n = nums.length;\n        int[] max = new int[10];\n        for (int num : nums) {\n            int digit = num % 10;\n            max[digit] = Math.max(max[digit], num);\n        }\n        int res = -1;\n        for (int i = 0; i < n; i++) {\n            int digit = nums[i] % 10;\n            for (int j = 0; j < 10; j++) {\n                if (max[j] != 0 && digit != j) {\n                    res = Math.max(res, nums[i] + max[j]);\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "610", "path": "output2\\java\\Medium\\610-add-two-numbers.java", "hypo_code": "class AddTwoNumbers {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head = new ListNode();\n        ListNode current = head;\n        int carry = 0;\n        while(l1 != null || l2 != null){\n            int sum = carry;\n            if(l1 != null){\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null){\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            carry = sum / 10;\n            current.next = new ListNode(sum % 10);\n            current = current.next;\n        }\n        if(carry > 0){\n            current.next = new ListNode(carry);\n        }\n        return head.next;\n        \n    }\n}"}
{"id": "611", "path": "output2\\java\\Medium\\611-longest-substring-without-repeating-characters.java", "hypo_code": "class LongestSubstringWithoutRepeatingCharacters {\n    public int lengthOfLongestSubstring(String s) {\n        int[] map = new int[128];\n        int left = 0;\n        int right = 0;\n        int max = 0;\n        while(right < s.length()){\n            char c = s.charAt(right);\n            map[c]++;\n            while(map[c] > 1){\n                map[s.charAt(left)]--;\n                left++;\n            }\n            max = Math.max(max, right - left + 1);\n            right++;\n        }\n        return max;\n        \n    }\n}"}
{"id": "612", "path": "output2\\java\\Medium\\612-longest-palindromic-substring.java", "hypo_code": "class LongestPalindromicSubstring {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int max = 0;\n        String res = \"\";\n        for(int i = n - 1; i >= 0; i--){\n            for(int j = i; j < n; j++){\n                if(s.charAt(i) == s.charAt(j) && (j - i < 2 || dp[i + 1][j - 1])){\n                    dp[i][j] = true;\n                    if(j - i + 1 > max){\n                        max = j - i + 1;\n                        res = s.substring(i, j + 1);\n                    }\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "613", "path": "output2\\java\\Medium\\613-zigzag-conversion.java", "hypo_code": "class ZigzagConversion {\n    public String convert(String s, int numRows) {\n        if(numRows == 1){\n            return s;\n        }\n        StringBuilder[] sb = new StringBuilder[numRows];\n        for(int i = 0; i < numRows; i++){\n            sb[i] = new StringBuilder();\n        }\n        int i = 0;\n        while(i < s.length()){\n            for(int j = 0; j < numRows && i < s.length(); j++){\n                sb[j].append(s.charAt(i++));\n            }\n            for(int j = numRows - 2; j >= 1 && i < s.length(); j--){\n                sb[j].append(s.charAt(i++));\n            }\n        }\n        for(int j = 1; j < numRows; j++){\n            sb[0].append(sb[j]);\n        }\n        return sb[0].toString();\n        \n        \n    }\n}"}
{"id": "614", "path": "output2\\java\\Medium\\614-reverse-integer.java", "hypo_code": "class ReverseInteger {\n    public int reverse(int x) {\n        int res = 0;\n        while(x != 0){\n            int digit = x % 10;\n            if(res > Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 && digit > 7)){\n                return 0;\n            }\n            if(res < Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 && digit < -8)){\n                return 0;\n            }\n            res = res * 10 + digit;\n            x /= 10;\n        }\n        return res;\n        \n    }\n}"}
{"id": "615", "path": "output2\\java\\Medium\\615-string-to-integer-atoi.java", "hypo_code": "class StringToIntegerAtoi {\n    public int myAtoi(String s) {\n        int res = 0;\n        int sign = 1;\n        int i = 0;\n        while(i < s.length() && s.charAt(i) == ' '){\n            i++;\n        }\n        if(i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')){\n            sign = s.charAt(i) == '-' ? -1 : 1;\n            i++;\n        }\n        while(i < s.length() && Character.isDigit(s.charAt(i))){\n            int digit = s.charAt(i) - '0';\n            if(res > Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 && digit > 7)){\n                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n            }\n            res = res * 10 + digit;\n            i++;\n        }\n        return res * sign;\n        \n        \n    }\n}"}
{"id": "616", "path": "output2\\java\\Medium\\616-container-with-most-water.java", "hypo_code": "class ContainerWithMostWater {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int i = 0;\n        int j = height.length - 1;\n        while(i < j){\n            int area = Math.min(height[i], height[j]) * (j - i);\n            max = Math.max(max, area);\n            if(height[i] < height[j]){\n                i++;\n            }else{\n                j--;\n            }\n        }\n        return max;\n        \n    }\n}"}
{"id": "617", "path": "output2\\java\\Medium\\617-integer-to-roman.java", "hypo_code": "class IntegerToRoman {\n    public String intToRoman(int num) {\n        String[] thousands = {\"\", \"M\", \"MM\", \"MMM\"};\n        String[] hundreds = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n        String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n        String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n        return thousands[num / 1000] + hundreds[num % 1000 / 100] + tens[num % 100 / 10] + ones[num % 10];\n        \n        \n    }\n}"}
{"id": "618", "path": "output2\\java\\Medium\\618-3sum.java", "hypo_code": "class ThreeSum {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        for(int i = 0; i < nums.length - 2; i++){\n            if(i == 0 || nums[i] != nums[i - 1]){\n                int j = i + 1;\n                int k = nums.length - 1;\n                while(j < k){\n                    int sum = nums[i] + nums[j] + nums[k];\n                    if(sum == 0){\n                        res.add(Arrays.asList(nums[i], nums[j], nums[k]));\n                        while(j < k && nums[j] == nums[j + 1]){\n                            j++;\n                        }\n                        while(j < k && nums[k] == nums[k - 1]){\n                            k--;\n                        }\n                        j++;\n                        k--;\n                    }else if(sum < 0){\n                        j++;\n                    }else{\n                        k--;\n                    }\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "619", "path": "output2\\java\\Medium\\619-3sum-closest.java", "hypo_code": "class ThreeSumClosest {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int res = nums[0] + nums[1] + nums[2];\n        for(int i = 0; i < nums.length - 2; i++){\n            int j = i + 1;\n            int k = nums.length - 1;\n            while(j < k){\n                int sum = nums[i] + nums[j] + nums[k];\n                if(sum == target){\n                    return sum;\n                }else if(sum < target){\n                    j++;\n                }else{\n                    k--;\n                }\n                if(Math.abs(sum - target) < Math.abs(res - target)){\n                    res = sum;\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "620", "path": "output2\\java\\Medium\\620-letter-combinations-of-a-phone-number.java", "hypo_code": "class LetterCombinationsOfAPhoneNumber {\n    public List<String> letterCombinations(String digits) {\n        List<String> res = new ArrayList<>();\n        if(digits.length() == 0){\n            return res;\n        }\n        String[] map = new String[]{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        dfs(digits, 0, \"\", res, map);\n        return res;\n        \n        \n    }\n}"}
{"id": "621", "path": "output2\\java\\Medium\\621-4sum.java", "hypo_code": "class FourSum {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums.length < 4){\n            return res;\n        }\n        Arrays.sort(nums);\n        for(int i = 0; i < nums.length - 3; i++){\n            if(i > 0 && nums[i] == nums[i - 1]){\n                continue;\n            }\n            for(int j = i + 1; j < nums.length - 2; j++){\n                if(j > i + 1 && nums[j] == nums[j - 1]){\n                    continue;\n                }\n                int left = j + 1;\n                int right = nums.length - 1;\n                while(left < right){\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                    if(sum == target){\n                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        left++;\n                        right--;\n                        while(left < right && nums[left] == nums[left - 1]){\n                            left++;\n                        }\n                        while(left < right && nums[right] == nums[right + 1]){\n                            right--;\n                        }\n                    }else if(sum < target){\n                        left++;\n                    }else{\n                        right--;\n                    }\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "622", "path": "output2\\java\\Medium\\622-remove-nth-node-from-end-of-list.java", "hypo_code": "class RemoveNthNodeFromEndOfList {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode first = dummy;\n        ListNode second = dummy;\n        for(int i = 1; i <= n + 1; i++){\n            first = first.next;\n        }\n        while(first != null){\n            first = first.next;\n            second = second.next;\n        }\n        second.next = second.next.next;\n        return dummy.next;\n        \n    }\n}"}
{"id": "623", "path": "output2\\java\\Medium\\623-generate-parentheses.java", "hypo_code": "class GenerateParentheses {\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        dfs(n, n, \"\", res);\n        return res;\n        \n    }\n}"}
{"id": "624", "path": "output2\\java\\Medium\\624-swap-nodes-in-pairs.java", "hypo_code": "class SwapNodesInPairs {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy;\n        while(cur.next != null && cur.next.next != null){\n            ListNode first = cur.next;\n            ListNode second = cur.next.next;\n            first.next = second.next;\n            cur.next = second;\n            cur.next.next = first;\n            cur = cur.next.next;\n        }\n        return dummy.next;\n        \n        \n    }\n}"}
{"id": "625", "path": "output2\\java\\Medium\\625-divide-two-integers.java", "hypo_code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\n            return Integer.MAX_VALUE;\n        boolean isNegative = (dividend ^ divisor) < 0;\n        long dividendL = Math.abs((long) dividend);\n        long divisorL = Math.abs((long) divisor);\n        int result = 0;\n        for (int i = 31; i >= 0; i--) {\n            if ((dividendL >> i) >= divisorL) {\n                result += 1 << i;\n                dividendL -= divisorL << i;\n            }\n        }\n        return isNegative ? -result : result;\n    }\n}"}
{"id": "626", "path": "output2\\java\\Medium\\626-next-permutation.java", "hypo_code": "class NextPermutation {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while(i >= 0 && nums[i] >= nums[i + 1]){\n            i--;\n        }\n        if(i >= 0){\n            int j = nums.length - 1;\n            while(j >= 0 && nums[j] <= nums[i]){\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n        \n    }\n}"}
{"id": "627", "path": "output2\\java\\Medium\\627-search-in-rotated-sorted-array.java", "hypo_code": "class SearchInRotatedSortedArray {\n    public int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            if(nums[left] <= nums[mid]){\n                if(nums[left] <= target && target < nums[mid]){\n                    right = mid - 1;\n                }else{\n                    left = mid + 1;\n                }\n            }else{\n                if(nums[mid] < target && target <= nums[right]){\n                    left = mid + 1;\n                }else{\n                    right = mid - 1;\n                }\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "628", "path": "output2\\java\\Medium\\628-find-first-and-last-position-of-element-in-sorted-array.java", "hypo_code": "class FindFirstAndLastPositionOfElementInSortedArray {\n    public int[] searchRange(int[] nums, int target) {\n        int[] res = new int[2];\n        res[0] = findFirst(nums, target);\n        res[1] = findLast(nums, target);\n        return res;\n        \n    }\n}"}
{"id": "629", "path": "output2\\java\\Medium\\629-valid-sudoku.java", "hypo_code": "class ValidSudoku {\n    public boolean isValidSudoku(char[][] board) {\n        for(int i = 0; i < 9; i++){\n            Set<Character> row = new HashSet<>();\n            Set<Character> col = new HashSet<>();\n            Set<Character> cube = new HashSet<>();\n            for(int j = 0; j < 9; j++){\n                if(board[i][j] != '.' && !row.add(board[i][j])){\n                    return false;\n                }\n                if(board[j][i] != '.' && !col.add(board[j][i])){\n                    return false;\n                }\n                int rowIndex = 3 * (i / 3);\n                int colIndex = 3 * (i % 3);\n                if(board[rowIndex + j / 3][colIndex + j % 3] != '.' && !cube.add(board[rowIndex + j / 3][colIndex + j % 3])){\n                    return false;\n                }\n            }\n        }\n        return true;\n        \n        \n    }\n}"}
{"id": "630", "path": "output2\\java\\Medium\\630-count-and-say.java", "hypo_code": "class CountAndSay {\n    public String countAndSay(int n) {\n        String res = \"1\";\n        for(int i = 1; i < n; i++){\n            res = helper(res);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "631", "path": "output2\\java\\Medium\\631-combination-sum.java", "hypo_code": "class CombinationSum {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(candidates.length == 0){\n            return res;\n        }\n        Arrays.sort(candidates);\n        helper(candidates, target, 0, new ArrayList<>(), res);\n        return res;\n        \n        \n    }\n}"}
{"id": "632", "path": "output2\\java\\Medium\\632-combination-sum-ii.java", "hypo_code": "class CombinationSumIi {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(candidates.length == 0){\n            return res;\n        }\n        Arrays.sort(candidates);\n        helper(candidates, target, 0, new ArrayList<>(), res);\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "633", "path": "output2\\java\\Medium\\633-multiply-strings.java", "hypo_code": "class MultiplyStrings {\n    public String multiply(String num1, String num2) {\n        int m = num1.length();\n        int n = num2.length();\n        int[] pos = new int[m + n];\n        for(int i = m - 1; i >= 0; i--){\n            for(int j = n - 1; j >= 0; j--){\n                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n                int p1 = i + j;\n                int p2 = i + j + 1;\n                int sum = mul + pos[p2];\n                pos[p1] += sum / 10;\n                pos[p2] = sum % 10;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int p : pos){\n            if(!(sb.length() == 0 && p == 0)){\n                sb.append(p);\n            }\n        }\n        return sb.length() == 0 ? \"0\" : sb.toString();\n        \n        \n    }\n}"}
{"id": "634", "path": "output2\\java\\Medium\\634-jump-game-ii.java", "hypo_code": "class JumpGameIi {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 1; j <= nums[i]; j++){\n                if(i + j < n){\n                    dp[i + j] = Math.min(dp[i + j], dp[i] + 1);\n                }\n            }\n        }\n        return dp[n - 1];\n        \n    }\n}"}
{"id": "635", "path": "output2\\java\\Medium\\635-permutations.java", "hypo_code": "class Permutations {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums.length == 0){\n            return res;\n        }\n        helper(nums, new ArrayList<>(), res);\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "636", "path": "output2\\java\\Medium\\636-permutations-ii.java", "hypo_code": "class PermutationsIi {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums.length == 0){\n            return res;\n        }\n        Arrays.sort(nums);\n        helper(nums, new boolean[nums.length], new ArrayList<>(), res);\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "637", "path": "output2\\java\\Medium\\637-rotate-image.java", "hypo_code": "class RotateImage {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for(int i = 0; i < n / 2; i++){\n            for(int j = i; j < n - i - 1; j++){\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[n - j - 1][i];\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n                matrix[j][n - i - 1] = temp;\n            }\n        }\n        \n    }\n}"}
{"id": "638", "path": "output2\\java\\Medium\\638-group-anagrams.java", "hypo_code": "class GroupAnagrams {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>> res = new ArrayList<>();\n        if(strs.length == 0){\n            return res;\n        }\n        Map<String, List<String>> map = new HashMap<>();\n        for(String s : strs){\n            char[] chars = s.toCharArray();\n            Arrays.sort(chars);\n            String key = String.valueOf(chars);\n            if(!map.containsKey(key)){\n                map.put(key, new ArrayList<>());\n            }\n            map.get(key).add(s);\n        }\n        for(String key : map.keySet()){\n            res.add(map.get(key));\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "639", "path": "output2\\java\\Medium\\639-powx-n.java", "hypo_code": "class PowxN {\n    public double myPow(double x, int n) {\n        if(n == 0){\n            return 1;\n        }\n        if(n < 0){\n            return 1 / myPow(x, -n);\n        }\n        if(n % 2 == 0){\n            return myPow(x * x, n / 2);\n        }\n        return x * myPow(x, n - 1);\n        \n    }\n}"}
{"id": "640", "path": "output2\\java\\Medium\\640-maximum-subarray.java", "hypo_code": "class MaximumSubarray {\n    public int maxSubArray(int[] nums) {\n        int max = nums[0];\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            sum += nums[i];\n            max = Math.max(max, sum);\n            if(sum < 0){\n                sum = 0;\n            }\n        }\n        return max;\n        \n        \n    }\n}"}
{"id": "641", "path": "output2\\java\\Medium\\641-spiral-matrix.java", "hypo_code": "class SpiralMatrix {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList<>();\n        if(matrix.length == 0){\n            return res;\n        }\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int left = 0;\n        int right = n - 1;\n        int top = 0;\n        int bottom = m - 1;\n        while(left <= right && top <= bottom){\n            for(int i = left; i <= right; i++){\n                res.add(matrix[top][i]);\n            }\n            top++;\n            for(int i = top; i <= bottom; i++){\n                res.add(matrix[i][right]);\n            }\n            right--;\n            if(top <= bottom){\n                for(int i = right; i >= left; i--){\n                    res.add(matrix[bottom][i]);\n                }\n                bottom--;\n            }\n            if(left <= right){\n                for(int i = bottom; i >= top; i--){\n                    res.add(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "642", "path": "output2\\java\\Medium\\642-jump-game.java", "hypo_code": "class JumpGame {\n    public boolean canJump(int[] nums) {\n        int n = nums.length;\n        boolean[] dp = new boolean[n];\n        dp[0] = true;\n        for(int i = 0; i < n; i++){\n            for(int j = 1; j <= nums[i]; j++){\n                if(i + j < n){\n                    dp[i + j] = dp[i + j] || dp[i];\n                }\n            }\n        }\n        return dp[n - 1];\n        \n    }\n}"}
{"id": "643", "path": "output2\\java\\Medium\\643-merge-intervals.java", "hypo_code": "class MergeIntervals {\n    public int[][] merge(int[][] intervals) {\n        if(intervals.length == 0){\n            return new int[0][0];\n        }\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        List<int[]> res = new ArrayList<>();\n        int[] cur = intervals[0];\n        for(int i = 1; i < intervals.length; i++){\n            if(intervals[i][0] <= cur[1]){\n                cur[1] = Math.max(cur[1], intervals[i][1]);\n            }else{\n                res.add(cur);\n                cur = intervals[i];\n            }\n        }\n        res.add(cur);\n        return res.toArray(new int[res.size()][]);\n        \n    }\n}"}
{"id": "644", "path": "output2\\java\\Medium\\644-insert-interval.java", "hypo_code": "class InsertInterval {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> res = new ArrayList<>();\n        int i = 0;\n        while(i < intervals.length && intervals[i][1] < newInterval[0]){\n            res.add(intervals[i]);\n            i++;\n        }\n        while(i < intervals.length && intervals[i][0] <= newInterval[1]){\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        res.add(newInterval);\n        while(i < intervals.length){\n            res.add(intervals[i]);\n            i++;\n        }\n        return res.toArray(new int[res.size()][]);\n        \n        \n    }\n}"}
{"id": "645", "path": "output2\\java\\Medium\\645-spiral-matrix-ii.java", "hypo_code": "class SpiralMatrixIi {\n    public int[][] generateMatrix(int n) {\n        int[][] res = new int[n][n];\n        int left = 0;\n        int right = n - 1;\n        int top = 0;\n        int bottom = n - 1;\n        int num = 1;\n        while(left <= right && top <= bottom){\n            for(int i = left; i <= right; i++){\n                res[top][i] = num++;\n            }\n            top++;\n            for(int i = top; i <= bottom; i++){\n                res[i][right] = num++;\n            }\n            right--;\n            if(top <= bottom){\n                for(int i = right; i >= left; i--){\n                    res[bottom][i] = num++;\n                }\n                bottom--;\n            }\n            if(left <= right){\n                for(int i = bottom; i >= top; i--){\n                    res[i][left] = num++;\n                }\n                left++;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "646", "path": "output2\\java\\Medium\\646-rotate-list.java", "hypo_code": "class RotateList {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        int i;\n        for(i = 0; fast.next != null; i++){\n            fast = fast.next;\n        }\n        for(int j = i - k % i; j > 0; j--){\n            slow = slow.next;\n        }\n        fast.next = dummy.next;\n        dummy.next = slow.next;\n        slow.next = null;\n        return dummy.next;\n        \n    }\n}"}
{"id": "647", "path": "output2\\java\\Medium\\647-unique-paths.java", "hypo_code": "class UniquePaths {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < m; i++){\n            dp[i][0] = 1;\n        }\n        for(int i = 0; i < n; i++){\n            dp[0][i] = 1;\n        }\n        for(int i = 1; i < m; i++){\n            for(int j = 1; j < n; j++){\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];\n        \n    }\n}"}
{"id": "648", "path": "output2\\java\\Medium\\648-unique-paths-ii.java", "hypo_code": "class UniquePathsIi {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length;\n        int n = obstacleGrid[0].length;\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < m; i++){\n            if(obstacleGrid[i][0] == 1){\n                break;\n            }\n            dp[i][0] = 1;\n        }\n        for(int i = 0; i < n; i++){\n            if(obstacleGrid[0][i] == 1){\n                break;\n            }\n            dp[0][i] = 1;\n        }\n        for(int i = 1; i < m; i++){\n            for(int j = 1; j < n; j++){\n                if(obstacleGrid[i][j] == 1){\n                    dp[i][j] = 0;\n                }else{\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n        \n    }\n}"}
{"id": "649", "path": "output2\\java\\Medium\\649-minimum-path-sum.java", "hypo_code": "class MinimumPathSum {\n    public int minPathSum(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dp = new int[m][n];\n        dp[0][0] = grid[0][0];\n        for(int i = 1; i < m; i++){\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        for(int i = 1; i < n; i++){\n            dp[0][i] = dp[0][i - 1] + grid[0][i];\n        }\n        for(int i = 1; i < m; i++){\n            for(int j = 1; j < n; j++){\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n        \n    }\n}"}
{"id": "650", "path": "output2\\java\\Medium\\650-simplify-path.java", "hypo_code": "class SimplifyPath {\n    public String simplifyPath(String path) {\n        String[] paths = path.split(\"/\");\n        Stack<String> stack = new Stack<>();\n        for(String p : paths){\n            if(p.equals(\"..\")){\n                if(!stack.isEmpty()){\n                    stack.pop();\n                }\n            }else if(!p.equals(\".\") && !p.equals(\"\")){\n                stack.push(p);\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for(String p : stack){\n            sb.append(\"/\" + p);\n        }\n        return sb.length() == 0 ? \"/\" : sb.toString();\n        \n    }\n}"}
{"id": "651", "path": "output2\\java\\Medium\\651-edit-distance.java", "hypo_code": "class Solution {\n    public int minDistance(String word1, String word2) {\n        int l1 = word1.length(), l2 = word2.length(), i, j;\n        int[][] dp = new int[l1 + 1][l2 + 1];\n        for (i = 0; i <= l1; i++)\n            dp[i][0] = i;\n        for (j = 0; j <= l2; j++)\n            dp[0][j] = j;\n        for (i = 1; i <= l1; i++)\n            for (j = 1; j <= l2; j++)\n                dp[i][j] = word1.charAt(i - 1) == word2.charAt(j - 1) ? \n                    dp[i - 1][j - 1] : Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),\n                    dp[i - 1][j - 1]) + 1;\n        return dp[l1][l2];\n    }\n}"}
{"id": "652", "path": "output2\\java\\Medium\\652-set-matrix-zeroes.java", "hypo_code": "class SetMatrixZeroes {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        boolean row = false;\n        boolean col = false;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(matrix[i][j] == 0){\n                    if(i == 0){\n                        row = true;\n                    }\n                    if(j == 0){\n                        col = true;\n                    }\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for(int i = 1; i < m; i++){\n            for(int j = 1; j < n; j++){\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if(row){\n            for(int i = 0; i < n; i++){\n                matrix[0][i] = 0;\n            }\n        }\n        if(col){\n            for(int i = 0; i < m; i++){\n                matrix[i][0] = 0;\n            }\n        }\n        \n    }\n}"}
{"id": "653", "path": "output2\\java\\Medium\\653-search-a-2d-matrix.java", "hypo_code": "class SearchA2DMatrix {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int left = 0;\n        int right = m * n - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            int row = mid / n;\n            int col = mid % n;\n            if(matrix[row][col] == target){\n                return true;\n            }\n            if(matrix[row][col] < target){\n                left = mid + 1;\n            }else{\n                right = mid - 1;\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "654", "path": "output2\\java\\Medium\\654-sort-colors.java", "hypo_code": "class SortColors {\n    public void sortColors(int[] nums) {\n        int n = nums.length;\n        int p0 = 0;\n        int p2 = n - 1;\n        int curr = 0;\n        while(curr <= p2){\n            if(nums[curr] == 0){\n                swap(nums, curr, p0);\n                curr++;\n                p0++;\n            }else if(nums[curr] == 2){\n                swap(nums, curr, p2);\n                p2--;\n            }else{\n                curr++;\n            }\n        }\n        \n        \n    }\n}"}
{"id": "655", "path": "output2\\java\\Medium\\655-combinations.java", "hypo_code": "class Combinations {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(n == 0 || k == 0){\n            return res;\n        }\n        helper(n, k, 1, new ArrayList<>(), res);\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "656", "path": "output2\\java\\Medium\\656-subsets.java", "hypo_code": "class Subsets {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums.length == 0){\n            return res;\n        }\n        helper(nums, 0, new ArrayList<>(), res);\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "657", "path": "output2\\java\\Medium\\657-word-search.java", "hypo_code": "class WordSearch {\n    public boolean exist(char[][] board, String word) {\n        int m = board.length;\n        int n = board[0].length;\n        boolean[][] visited = new boolean[m][n];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(dfs(board, word, 0, i, j, visited)){\n                    return true;\n                }\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "658", "path": "output2\\java\\Medium\\658-remove-duplicates-from-sorted-array-ii.java", "hypo_code": "class RemoveDuplicatesFromSortedArrayIi {\n    public int removeDuplicates(int[] nums) {\n        int i = 0;\n        for(int n : nums){\n            if(i < 2 || n > nums[i - 2]){\n                nums[i++] = n;\n            }\n        }\n        return i;\n        \n    }\n}"}
{"id": "659", "path": "output2\\java\\Medium\\659-search-in-rotated-sorted-array-ii.java", "hypo_code": "class SearchInRotatedSortedArrayIi {\n    public boolean search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target){\n                return true;\n            }\n            if(nums[left] < nums[mid]){\n                if(nums[left] <= target && target < nums[mid]){\n                    right = mid - 1;\n                }else{\n                    left = mid + 1;\n                }\n            }else if(nums[left] > nums[mid]){\n                if(nums[mid] < target && target <= nums[right]){\n                    left = mid + 1;\n                }else{\n                    right = mid - 1;\n                }\n            }else{\n                left++;\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "660", "path": "output2\\java\\Medium\\660-remove-duplicates-from-sorted-list-ii.java", "hypo_code": "class RemoveDuplicatesFromSortedListIi {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy;\n        while(cur.next != null && cur.next.next != null){\n            if(cur.next.val == cur.next.next.val){\n                int val = cur.next.val;\n                while(cur.next != null && cur.next.val == val){\n                    cur.next = cur.next.next;\n                }\n            }else{\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n        \n        \n        \n        \n        \n    }\n}"}
{"id": "661", "path": "output2\\java\\Medium\\661-partition-list.java", "hypo_code": "class PartitionList {\n    public ListNode partition(ListNode head, int x) {\n        ListNode dummy1 = new ListNode(0);\n        ListNode dummy2 = new ListNode(0);\n        ListNode cur1 = dummy1;\n        ListNode cur2 = dummy2;\n        while(head != null){\n            if(head.val < x){\n                cur1.next = head;\n                cur1 = cur1.next;\n            }else{\n                cur2.next = head;\n                cur2 = cur2.next;\n            }\n            head = head.next;\n        }\n        cur2.next = null;\n        cur1.next = dummy2.next;\n        return dummy1.next;\n        \n    }\n}"}
{"id": "662", "path": "output2\\java\\Medium\\662-gray-code.java", "hypo_code": "class GrayCode {\n    public List<Integer> grayCode(int n) {\n        List<Integer> res = new ArrayList<>();\n        res.add(0);\n        for(int i = 0; i < n; i++){\n            int size = res.size();\n            for(int j = size - 1; j >= 0; j--){\n                res.add(res.get(j) | 1 << i);\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "663", "path": "output2\\java\\Medium\\663-subsets-ii.java", "hypo_code": "class SubsetsIi {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums.length == 0){\n            return res;\n        }\n        Arrays.sort(nums);\n        helper(nums, 0, new ArrayList<>(), res);\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "664", "path": "output2\\java\\Medium\\664-decode-ways.java", "hypo_code": "class DecodeWays {\n    public int numDecodings(String s) {\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = s.charAt(0) == '0' ? 0 : 1;\n        for(int i = 2; i <= n; i++){\n            int first = Integer.valueOf(s.substring(i - 1, i));\n            int second = Integer.valueOf(s.substring(i - 2, i));\n            if(first >= 1 && first <= 9){\n                dp[i] += dp[i - 1];\n            }\n            if(second >= 10 && second <= 26){\n                dp[i] += dp[i - 2];\n            }\n        }\n        return dp[n];\n        \n    }\n}"}
{"id": "665", "path": "output2\\java\\Medium\\665-reverse-linked-list-ii.java", "hypo_code": "class ReverseLinkedListIi {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        for(int i = 0; i < left - 1; i++){\n            pre = pre.next;\n        }\n        ListNode cur = pre.next;\n        for(int i = 0; i < right - left; i++){\n            ListNode next = cur.next;\n            cur.next = next.next;\n            next.next = pre.next;\n            pre.next = next;\n        }\n        return dummy.next;\n        \n    }\n}"}
{"id": "666", "path": "output2\\java\\Medium\\666-restore-ip-addresses.java", "hypo_code": "class RestoreIpAddresses {\n    public List<String> restoreIpAddresses(String s) {\n        List<String> res = new ArrayList<>();\n        if(s.length() < 4 || s.length() > 12){\n            return res;\n        }\n        dfs(s, 0, 0, \"\", res);\n        return res;\n        \n        \n    }\n}"}
{"id": "667", "path": "output2\\java\\Medium\\667-unique-binary-search-trees-ii.java", "hypo_code": "class UniqueBinarySearchTreesIi {\n    public List<TreeNode> generateTrees(int n) {\n        if(n == 0){\n            return new ArrayList<>();\n        }\n        return helper(1, n);\n        \n    }\n}"}
{"id": "668", "path": "output2\\java\\Medium\\668-unique-binary-search-trees.java", "hypo_code": "class UniqueBinarySearchTrees {\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i = 2; i <= n; i++){\n            for(int j = 1; j <= i; j++){\n                dp[i] += dp[j - 1] * dp[i - j];\n            }\n        }\n        return dp[n];\n        \n    }\n}"}
{"id": "669", "path": "output2\\java\\Medium\\669-interleaving-string.java", "hypo_code": "class InterleavingString {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length() + s2.length() != s3.length()){\n            return false;\n        }\n        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];\n        dp[0][0] = true;\n        for(int i = 1; i <= s1.length(); i++){\n            dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n        }\n        for(int i = 1; i <= s2.length(); i++){\n            dp[0][i] = dp[0][i - 1] && s2.charAt(i - 1) == s3.charAt(i - 1);\n        }\n        for(int i = 1; i <= s1.length(); i++){\n            for(int j = 1; j <= s2.length(); j++){\n                dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n            }\n        }\n        return dp[s1.length()][s2.length()];\n        \n    }\n}"}
{"id": "670", "path": "output2\\java\\Medium\\670-validate-binary-search-tree.java", "hypo_code": "class ValidateBinarySearchTree {\n    public boolean isValidBST(TreeNode root) {\n        return helper(root, null, null);\n        \n         \n        \n    }\n}"}
{"id": "671", "path": "output2\\java\\Medium\\671-recover-binary-search-tree.java", "hypo_code": "class RecoverBinarySearchTree {\n    public void recoverTree(TreeNode root) {\n        TreeNode[] nodes = new TreeNode[2];\n        TreeNode[] prev = new TreeNode[1];\n        helper(root, nodes, prev);\n        int temp = nodes[0].val;\n        nodes[0].val = nodes[1].val;\n        nodes[1].val = temp;\n        \n        \n    }\n}"}
{"id": "672", "path": "output2\\java\\Medium\\672-binary-tree-level-order-traversal.java", "hypo_code": "class BinaryTreeLevelOrderTraversal {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null){\n            return result;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                level.add(node.val);\n                if(node.left != null){\n                    queue.add(node.left);\n                }\n                if(node.right != null){\n                    queue.add(node.right);\n                }\n            }\n            result.add(level);\n        }\n        return result;\n        \n        \n    }\n}"}
{"id": "673", "path": "output2\\java\\Medium\\673-binary-tree-zigzag-level-order-traversal.java", "hypo_code": "class BinaryTreeZigzagLevelOrderTraversal {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null){\n            return result;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        boolean leftToRight = true;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                if(leftToRight){\n                    level.add(node.val);\n                }else{\n                    level.add(0, node.val);\n                }\n                if(node.left != null){\n                    queue.add(node.left);\n                }\n                if(node.right != null){\n                    queue.add(node.right);\n                }\n            }\n            result.add(level);\n            leftToRight = !leftToRight;\n        }\n        return result;\n        \n        \n        \n    }\n}"}
{"id": "674", "path": "output2\\java\\Medium\\674-construct-binary-tree-from-preorder-and-inorder-traversal.java", "hypo_code": "class ConstructBinaryTreeFromPreorderAndInorderTraversal {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if(preorder.length == 0){\n            return null;\n        }\n        return helper(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);\n        \n       \n     \n    }\n}"}
{"id": "675", "path": "output2\\java\\Medium\\675-construct-binary-tree-from-inorder-and-postorder-traversal.java", "hypo_code": "class ConstructBinaryTreeFromInorderAndPostorderTraversal {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if(inorder.length == 0){\n            return null;\n        }\n        return helper(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);\n        \n        \n    }\n}"}
{"id": "676", "path": "output2\\java\\Medium\\676-binary-tree-level-order-traversal-ii.java", "hypo_code": "class BinaryTreeLevelOrderTraversalIi {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null){\n            return result;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                level.add(node.val);\n                if(node.left != null){\n                    queue.add(node.left);\n                }\n                if(node.right != null){\n                    queue.add(node.right);\n                }\n            }\n            result.add(0, level);\n        }\n        return result;\n        \n        \n        \n    }\n}"}
{"id": "677", "path": "output2\\java\\Medium\\677-convert-sorted-list-to-binary-search-tree.java", "hypo_code": "class ConvertSortedListToBinarySearchTree {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        return helper(head, null);\n        \n        \n    }\n}"}
{"id": "678", "path": "output2\\java\\Medium\\678-path-sum-ii.java", "hypo_code": "class PathSumIi {\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null){\n            return result;\n        }\n        helper(root, targetSum, new ArrayList<>(), result);\n        return result;\n        \n    }\n}"}
{"id": "679", "path": "output2\\java\\Medium\\679-flatten-binary-tree-to-linked-list.java", "hypo_code": "class FlattenBinaryTreeToLinkedList {\n    public void flatten(TreeNode root) {\n        if(root == null){\n            return;\n        }\n        helper(root);\n        \n        \n    }\n}"}
{"id": "680", "path": "output2\\java\\Medium\\680-populating-next-right-pointers-in-each-node.java", "hypo_code": "class PopulatingNextRightPointersInEachNode {\n    public Node connect(Node root) {\n        if(root == null){\n            return null;\n        }\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        while(!q.isEmpty()){\n            int size = q.size();\n            Node prev = null;\n            for(int i = 0; i < size; i++){\n                Node curr = q.poll();\n                if(prev != null){\n                    prev.next = curr;\n                }\n                prev = curr;\n                if(curr.left != null){\n                    q.add(curr.left);\n                }\n                if(curr.right != null){\n                    q.add(curr.right);\n                }\n            }\n        }\n        return root;\n        \n    }\n}"}
{"id": "681", "path": "output2\\java\\Medium\\681-populating-next-right-pointers-in-each-node-ii.java", "hypo_code": "class PopulatingNextRightPointersInEachNodeIi {\n    public Node connect(Node root) {\n        if(root == null){\n            return null;\n        }\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        while(!q.isEmpty()){\n            int size = q.size();\n            Node prev = null;\n            for(int i = 0; i < size; i++){\n                Node curr = q.poll();\n                if(prev != null){\n                    prev.next = curr;\n                }\n                prev = curr;\n                if(curr.left != null){\n                    q.add(curr.left);\n                }\n                if(curr.right != null){\n                    q.add(curr.right);\n                }\n            }\n        }\n        return root;\n        \n    }\n}"}
{"id": "682", "path": "output2\\java\\Medium\\682-triangle.java", "hypo_code": "class Triangle {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        int n = triangle.size();\n        int[] dp = new int[n + 1];\n        for(int i = n - 1; i >= 0; i--){\n            for(int j = 0; j < triangle.get(i).size(); j++){\n                dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);\n            }\n        }\n        return dp[0];\n        \n    }\n}"}
{"id": "683", "path": "output2\\java\\Medium\\683-best-time-to-buy-and-sell-stock-ii.java", "hypo_code": "class BestTimeToBuyAndSellStockIi {\n    public int maxProfit(int[] prices) {\n        int res = 0;\n        for(int i = 1; i < prices.length; i++){\n            if(prices[i] > prices[i - 1]){\n                res += prices[i] - prices[i - 1];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "684", "path": "output2\\java\\Medium\\684-longest-consecutive-sequence.java", "hypo_code": "class LongestConsecutiveSequence {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for(int num : nums){\n            set.add(num);\n        }\n        int max = 0;\n        for(int num : nums){\n            if(!set.contains(num - 1)){\n                int cur = num;\n                int count = 1;\n                while(set.contains(cur + 1)){\n                    cur++;\n                    count++;\n                }\n                max = Math.max(max, count);\n            }\n        }\n        return max;\n        \n    }\n}"}
{"id": "685", "path": "output2\\java\\Medium\\685-sum-root-to-leaf-numbers.java", "hypo_code": "class SumRootToLeafNumbers {\n    public int sumNumbers(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        return helper(root, 0);\n        \n        \n    }\n}"}
{"id": "686", "path": "output2\\java\\Medium\\686-surrounded-regions.java", "hypo_code": "class SurroundedRegions {\n    public void solve(char[][] board) {\n        if(board == null || board.length == 0 || board[0].length == 0){\n            return;\n        }\n        int m = board.length;\n        int n = board[0].length;\n        for(int i = 0; i < m; i++){\n            if(board[i][0] == 'O'){\n                dfs(board, i, 0);\n            }\n            if(board[i][n - 1] == 'O'){\n                dfs(board, i, n - 1);\n            }\n        }\n        for(int j = 0; j < n; j++){\n            if(board[0][j] == 'O'){\n                dfs(board, 0, j);\n            }\n            if(board[m - 1][j] == 'O'){\n                dfs(board, m - 1, j);\n            }\n        }\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(board[i][j] == 'O'){\n                    board[i][j] = 'X';\n                }\n                if(board[i][j] == 'A'){\n                    board[i][j] = 'O';\n                }\n            }\n        }\n        \n    }\n}"}
{"id": "687", "path": "output2\\java\\Medium\\687-palindrome-partitioning.java", "hypo_code": "class PalindromePartitioning {\n    public List<List<String>> partition(String s) {\n        List<List<String>> res = new ArrayList<>();\n        if(s.length() == 0){\n            return res;\n        }\n        helper(s, 0, new ArrayList<>(), res);\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "688", "path": "output2\\java\\Medium\\688-clone-graph.java", "hypo_code": "class CloneGraph {\n    public Node cloneGraph(Node node) {\n        if(node == null){\n            return null;\n        }\n        Map<Node, Node> map = new HashMap<>();\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(node);\n        map.put(node, new Node(node.val));\n        while(!queue.isEmpty()){\n            Node curr = queue.poll();\n            for(Node neighbor : curr.neighbors){\n                if(!map.containsKey(neighbor)){\n                    map.put(neighbor, new Node(neighbor.val));\n                    queue.add(neighbor);\n                }\n                map.get(curr).neighbors.add(map.get(neighbor));\n            }\n        }\n        return map.get(node);\n        \n    }\n}"}
{"id": "689", "path": "output2\\java\\Medium\\689-gas-station.java", "hypo_code": "class GasStation {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int n = gas.length;\n        int[] dp = new int[n + 1];\n        for(int i = n - 1; i >= 0; i--){\n            dp[i] = dp[i + 1] + gas[i] - cost[i];\n        }\n        int min = Integer.MAX_VALUE;\n        int res = -1;\n        for(int i = 0; i < n; i++){\n            if(dp[i] < min){\n                min = dp[i];\n                res = i;\n            }\n        }\n        return res == n ? -1 : res;\n        \n        \n    }\n}"}
{"id": "690", "path": "output2\\java\\Medium\\690-single-number-ii.java", "hypo_code": "class SingleNumberIi {\n    public int singleNumber(int[] nums) {\n        int res = 0;\n        for(int i = 0; i < 32; i++){\n            int sum = 0;\n            for(int num : nums){\n                sum += (num >> i) & 1;\n            }\n            res |= (sum % 3) << i;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "691", "path": "output2\\java\\Medium\\691-copy-list-with-random-pointer.java", "hypo_code": "class CopyListWithRandomPointer {\n    public Node copyRandomList(Node head) {\n        if(head == null){\n            return null;\n        }\n        Map<Node, Node> map = new HashMap<>();\n        Node curr = head;\n        while(curr != null){\n            map.put(curr, new Node(curr.val));\n            curr = curr.next;\n        }\n        curr = head;\n        while(curr != null){\n            map.get(curr).next = map.get(curr.next);\n            map.get(curr).random = map.get(curr.random);\n            curr = curr.next;\n        }\n        return map.get(head);\n        \n    }\n}"}
{"id": "692", "path": "output2\\java\\Medium\\692-word-break.java", "hypo_code": "class WordBreak {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> set = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        for(int i = 1; i <= s.length(); i++){\n            for(int j = 0; j < i; j++){\n                if(dp[j] && set.contains(s.substring(j, i))){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.length()];\n        \n    }\n}"}
{"id": "693", "path": "output2\\java\\Medium\\693-linked-list-cycle-ii.java", "hypo_code": "public class LinkedListCycleIi {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null){\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                break;\n            }\n        }\n        if(fast == null || fast.next == null){\n            return null;\n        }\n        slow = head;\n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n        \n    }\n}"}
{"id": "694", "path": "output2\\java\\Medium\\694-reorder-list.java", "hypo_code": "class ReorderList {\n    public void reorderList(ListNode head) {\n        if(head == null || head.next == null){\n            return;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode head2 = slow.next;\n        slow.next = null;\n        head2 = reverse(head2);\n        merge(head, head2);\n        \n    }\n}"}
{"id": "696", "path": "output2\\java\\Medium\\696-insertion-sort-list.java", "hypo_code": "class InsertionSortList {\n    public ListNode insertionSortList(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = head;\n        while(cur != null && cur.next != null){\n            if(cur.val <= cur.next.val){\n                cur = cur.next;\n            }else{\n                ListNode temp = cur.next;\n                cur.next = temp.next;\n                ListNode pre = dummy;\n                while(pre.next.val < temp.val){\n                    pre = pre.next;\n                }\n                temp.next = pre.next;\n                pre.next = temp;\n            }\n        }\n        return dummy.next;\n        \n        \n    }\n}"}
{"id": "697", "path": "output2\\java\\Medium\\697-sort-list.java", "hypo_code": "class SortList {\n    public ListNode sortList(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = null;\n        while(fast != null && fast.next != null){\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        pre.next = null;\n        ListNode l1 = sortList(head);\n        ListNode l2 = sortList(slow);\n        return merge(l1, l2);\n        \n        \n    }\n}"}
{"id": "698", "path": "output2\\java\\Medium\\698-evaluate-reverse-polish-notation.java", "hypo_code": "class EvaluateReversePolishNotation {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        for(String s : tokens){\n            if(s.equals(\"+\")){\n                int a = stack.pop();\n                int b = stack.pop();\n                stack.push(a + b);\n            }else if(s.equals(\"-\")){\n                int a = stack.pop();\n                int b = stack.pop();\n                stack.push(b - a);\n            }else if(s.equals(\"*\")){\n                int a = stack.pop();\n                int b = stack.pop();\n                stack.push(a * b);\n            }else if(s.equals(\"/\")){\n                int a = stack.pop();\n                int b = stack.pop();\n                stack.push(b / a);\n            }else{\n                stack.push(Integer.parseInt(s));\n            }\n        }\n        return stack.pop();\n        \n        \n        \n    }\n}"}
{"id": "699", "path": "output2\\java\\Medium\\699-reverse-words-in-a-string.java", "hypo_code": "class ReverseWordsInAString {\n    public String reverseWords(String s) {\n        String[] words = s.trim().split(\" +\");\n        Collections.reverse(Arrays.asList(words));\n        return String.join(\" \", words);\n        \n    }\n}"}
{"id": "700", "path": "output2\\java\\Medium\\700-maximum-product-subarray.java", "hypo_code": "class MaximumProductSubarray {\n    public int maxProduct(int[] nums) {\n        int max = nums[0];\n        int min = nums[0];\n        int res = nums[0];\n        for(int i = 1; i < nums.length; i++){\n            int temp = max;\n            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);\n            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);\n            res = Math.max(max, res);\n        }\n        return res;\n        \n    }\n}"}
{"id": "701", "path": "output2\\java\\Medium\\701-find-minimum-in-rotated-sorted-array.java", "hypo_code": "class FindMinimumInRotatedSortedArray {\n    public int findMin(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left < right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] < nums[right]){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return nums[left];\n        \n    }\n}"}
{"id": "703", "path": "output2\\java\\Medium\\703-find-peak-element.java", "hypo_code": "class Solution {\n    public int findPeakElement(int[] nums) {\n        int l = 0, r = nums.length - 1, mid;\n        while (l < r) {\n            mid = l + (r - l) / 2;\n            if (nums[mid] < nums[mid + 1])\n                l = mid + 1;\n            else\n                r = mid;\n        }\n        return l;\n    }\n}"}
{"id": "704", "path": "output2\\java\\Medium\\704-compare-version-numbers.java", "hypo_code": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        String[] vs1 = version1.split(\"\\\\.\"), vs2 = version2.split(\"\\\\.\");\n        int l1 = vs1.length, l2 = vs2.length, i = 0;\n        while (i < l1 || i < l2) {\n            int v1 = i < l1 ? Integer.parseInt(vs1[i]) : 0;\n            int v2 = i < l2 ? Integer.parseInt(vs2[i]) : 0;\n            if (v1 != v2)\n                return v1 > v2 ? 1 : -1;\n            i++;\n        }\n        return 0;\n    }\n}"}
{"id": "705", "path": "output2\\java\\Medium\\705-fraction-to-recurring-decimal.java", "hypo_code": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        long n = numerator, d = denominator;\n        if (n % d == 0)\n            return String.valueOf(n / d);\n        StringBuilder sb = new StringBuilder();\n        if (n < 0 ^ d < 0)\n            sb.append('-');\n        n = Math.abs(n);\n        d = Math.abs(d);\n        sb.append(n / d).append('.');\n        n %= d;\n        Map<Long, Integer> map = new HashMap<>();\n        while (n > 0) {\n            map.put(n, sb.length());\n            n *= 10;\n            sb.append(n / d);\n            n %= d;\n            if (map.containsKey(n)) {\n                int index = map.get(n);\n                sb.insert(index, '(');\n                sb.append(')');\n                break;\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "706", "path": "output2\\java\\Medium\\706-two-sum-ii-input-array-is-sorted.java", "hypo_code": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int l = 0, r = numbers.length - 1, sum;\n        while (l < r) {\n            sum = numbers[l] + numbers[r];\n            if (sum == target)\n                return new int[]{l + 1, r + 1};\n            else if (sum < target)\n                l++;\n            else\n                r--;\n        }\n        return new int[]{};\n    }\n}"}
{"id": "707", "path": "output2\\java\\Medium\\707-factorial-trailing-zeroes.java", "hypo_code": "class Solution {\n    public int trailingZeroes(int n) {\n        int res = 0;\n        while (n > 0)\n            res += n /= 5;\n        return res;\n    }\n}"}
{"id": "712", "path": "output2\\java\\Medium\\712-largest-number.java", "hypo_code": "class Solution {\n    public String largestNumber(int[] nums) {\n        String[] s = new String[nums.length];\n        for (int i = 0; i < nums.length; i++)\n            s[i] = String.valueOf(nums[i]);\n        Arrays.sort(s, (a, b) -> (b + a).compareTo(a + b));\n        StringBuilder sb = new StringBuilder();\n        for (String str : s)\n            sb.append(str);\n        String res = sb.toString();\n        return res.charAt(0) == '0' ? \"0\" : res;\n    }\n}"}
{"id": "715", "path": "output2\\java\\Medium\\715-repeated-dna-sequences.java", "hypo_code": "class RepeatedDnaSequences {\n    public List<String> findRepeatedDnaSequences(String s) {\n        Set<String> seen = new HashSet<>();\n        Set<String> res = new HashSet<>();\n        for(int i = 0; i + 10 <= s.length(); i++){\n            String sub = s.substring(i, i + 10);\n            if(seen.contains(sub)){\n                res.add(sub);\n            }\n            seen.add(sub);\n        }\n        return new ArrayList<>(res);\n        \n    }\n}"}
{"id": "716", "path": "output2\\java\\Medium\\716-rotate-array.java", "hypo_code": "class RotateArray {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n        \n        \n    }\n}"}
{"id": "719", "path": "output2\\java\\Medium\\719-house-robber.java", "hypo_code": "class HouseRobber {\n    public int rob(int[] nums) {\n        int[] dp = new int[nums.length + 1];\n        dp[0] = 0;\n        dp[1] = nums[0];\n        for(int i = 2; i <= nums.length; i++){\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n        }\n        return dp[nums.length];\n        \n    }\n}"}
{"id": "720", "path": "output2\\java\\Medium\\720-binary-tree-right-side-view.java", "hypo_code": "class BinaryTreeRightSideView {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if(root == null){\n            return result;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                if(i == size - 1){\n                    result.add(node.val);\n                }\n                if(node.left != null){\n                    queue.add(node.left);\n                }\n                if(node.right != null){\n                    queue.add(node.right);\n                }\n            }\n        }\n        return result;\n        \n        \n        \n    }\n}"}
{"id": "721", "path": "output2\\java\\Medium\\721-number-of-islands.java", "hypo_code": "class NumberOfIslands {\n    public int numIslands(char[][] grid) {\n        int count = 0;\n        for(int i = 0; i < grid.length; i++){\n            for(int j = 0; j < grid[0].length; j++){\n                if(grid[i][j] == '1'){\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n        \n        \n    }\n}"}
{"id": "722", "path": "output2\\java\\Medium\\722-bitwise-and-of-numbers-range.java", "hypo_code": "class BitwiseAndOfNumbersRange {\n    public int rangeBitwiseAnd(int left, int right) {\n        int shift = 0;\n        while(left != right){\n            left >>= 1;\n            right >>= 1;\n            shift++;\n        }\n        return left << shift;\n        \n    }\n}"}
{"id": "723", "path": "output2\\java\\Medium\\723-count-primes.java", "hypo_code": "class CountPrimes {\n    public int countPrimes(int n) {\n        boolean[] notPrime = new boolean[n];\n        int count = 0;\n        for(int i = 2; i < n; i++){\n            if(notPrime[i] == false){\n                count++;\n                for(int j = 2; i * j < n; j++){\n                    notPrime[i * j] = true;\n                }\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "724", "path": "output2\\java\\Medium\\724-course-schedule.java", "hypo_code": "class CourseSchedule {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        for(int[] pre : prerequisites){\n            indegree[pre[0]]++;\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        for(int i = 0; i < numCourses; i++){\n            if(indegree[i] == 0){\n                queue.offer(i);\n            }\n        }\n        while(!queue.isEmpty()){\n            int course = queue.poll();\n            numCourses--;\n            for(int[] pre : prerequisites){\n                if(pre[1] == course){\n                    indegree[pre[0]]--;\n                    if(indegree[pre[0]] == 0){\n                        queue.offer(pre[0]);\n                    }\n                }\n            }\n        }\n        return numCourses == 0;\n        \n        \n    }\n}"}
{"id": "726", "path": "output2\\java\\Medium\\726-minimum-size-subarray-sum.java", "hypo_code": "class MinimumSizeSubarraySum {\n    public int minSubArrayLen(int target, int[] nums) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int res = Integer.MAX_VALUE;\n        while(right < nums.length){\n            sum += nums[right];\n            while(sum >= target){\n                res = Math.min(res, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n            right++;\n        }\n        return res == Integer.MAX_VALUE ? 0 : res;\n        \n    }\n}"}
{"id": "727", "path": "output2\\java\\Medium\\727-course-schedule-ii.java", "hypo_code": "class CourseScheduleIi {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        for(int[] pre : prerequisites){\n            indegree[pre[0]]++;\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        for(int i = 0; i < numCourses; i++){\n            if(indegree[i] == 0){\n                queue.offer(i);\n            }\n        }\n        int[] res = new int[numCourses];\n        int index = 0;\n        while(!queue.isEmpty()){\n            int course = queue.poll();\n            res[index++] = course;\n            for(int[] pre : prerequisites){\n                if(pre[1] == course){\n                    indegree[pre[0]]--;\n                    if(indegree[pre[0]] == 0){\n                        queue.offer(pre[0]);\n                    }\n                }\n            }\n        }\n        return index == numCourses ? res : new int[0];\n        \n    }\n}"}
{"id": "729", "path": "output2\\java\\Medium\\729-house-robber-ii.java", "hypo_code": "class HouseRobberIi {\n    public int rob(int[] nums) {\n        if(nums.length == 1){\n            return nums[0];\n        }\n        return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));\n        \n        \n    }\n}"}
{"id": "730", "path": "output2\\java\\Medium\\730-kth-largest-element-in-an-array.java", "hypo_code": "class KthLargestElementInAnArray {\n    public int findKthLargest(int[] nums, int k) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for(int i = 0; i < nums.length; i++){\n            pq.add(nums[i]);\n            if(pq.size() > k){\n                pq.poll();\n            }\n        }\n        return pq.peek();\n        \n        \n    }\n}"}
{"id": "731", "path": "output2\\java\\Medium\\731-combination-sum-iii.java", "hypo_code": "class CombinationSumIii {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> result = new ArrayList<>();\n        helper(k, n, 1, new ArrayList<>(), result);\n        return result;\n        \n        \n    }\n}"}
{"id": "732", "path": "output2\\java\\Medium\\732-maximal-square.java", "hypo_code": "class MaximalSquare {\n    public int maximalSquare(char[][] matrix) {\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\n            return 0;\n        }\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        int res = 0;\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                if(matrix[i - 1][j - 1] == '1'){\n                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n                    res = Math.max(res, dp[i][j]);\n                }\n            }\n        }\n        return res * res;\n        \n        \n    }\n}"}
{"id": "733", "path": "output2\\java\\Medium\\733-rectangle-area.java", "hypo_code": "class RectangleArea {\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n        int area1 = (ax2 - ax1) * (ay2 - ay1);\n        int area2 = (bx2 - bx1) * (by2 - by1);\n        int overlap = 0;\n        if(ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1){\n            int x1 = Math.max(ax1, bx1);\n            int x2 = Math.min(ax2, bx2);\n            int y1 = Math.max(ay1, by1);\n            int y2 = Math.min(ay2, by2);\n            overlap = (x2 - x1) * (y2 - y1);\n        }\n        return area1 + area2 - overlap;\n        \n        \n    }\n}"}
{"id": "734", "path": "output2\\java\\Medium\\734-basic-calculator-ii.java", "hypo_code": "class BasicCalculatorIi {\n    public int calculate(String s) {\n        Stack<Integer> stack = new Stack<>();\n        int num = 0;\n        char sign = '+';\n        for(int i = 0; i < s.length(); i++){\n            if(Character.isDigit(s.charAt(i))){\n                num = num * 10 + s.charAt(i) - '0';\n            }\n            if((!Character.isDigit(s.charAt(i)) && s.charAt(i) != ' ') || i == s.length() - 1){\n                if(sign == '+'){\n                    stack.push(num);\n                }else if(sign == '-'){\n                    stack.push(-num);\n                }else if(sign == '*'){\n                    stack.push(stack.pop() * num);\n                }else if(sign == '/'){\n                    stack.push(stack.pop() / num);\n                }\n                sign = s.charAt(i);\n                num = 0;\n            }\n        }\n        int res = 0;\n        for(int i : stack){\n            res += i;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "735", "path": "output2\\java\\Medium\\735-majority-element-ii.java", "hypo_code": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        int num1 = 0, num2 = 0, cnt1 = 0, cnt2 = 0;\n        for (int num : nums) {\n            if (num == num1)\n                cnt1++;\n            else if (num == num2)\n                cnt2++;\n            else if (cnt1 == 0) {\n                num1 = num;\n                cnt1 = 1;\n            } else if (cnt2 == 0) {\n                num2 = num;\n                cnt2 = 1;\n            } else {\n                cnt1--;\n                cnt2--;\n            }\n        }\n        cnt1 = 0;\n        cnt2 = 0;\n        for (int num : nums) {\n            if (num == num1)\n                cnt1++;\n            else if (num == num2)\n                cnt2++;\n        }\n        if (cnt1 > nums.length / 3)\n            res.add(num1);\n        if (cnt2 > nums.length / 3)\n            res.add(num2);\n        return res;\n\n    }\n}"}
{"id": "736", "path": "output2\\java\\Medium\\736-kth-smallest-element-in-a-bst.java", "hypo_code": "class KthSmallestElementInABst {\n    public int kthSmallest(TreeNode root, int k) {\n        int left = countNodes(root.left);\n        if(left == k - 1){\n            return root.val;\n        }else if(left > k - 1){\n            return kthSmallest(root.left, k);\n        }else{\n            return kthSmallest(root.right, k - left - 1);\n        }\n        \n        \n    }\n}"}
{"id": "737", "path": "output2\\java\\Medium\\737-lowest-common-ancestor-of-a-binary-search-tree.java", "hypo_code": "class LowestCommonAncestorOfABinarySearchTree {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null){\n            return null;\n        }\n        if(root.val > p.val && root.val > q.val){\n            return lowestCommonAncestor(root.left, p, q);\n        }else if(root.val < p.val && root.val < q.val){\n            return lowestCommonAncestor(root.right, p, q);\n        }else{\n            return root;\n        }\n        \n    }\n}"}
{"id": "738", "path": "output2\\java\\Medium\\738-lowest-common-ancestor-of-a-binary-tree.java", "hypo_code": "class LowestCommonAncestorOfABinaryTree {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null){\n            return null;\n        }\n        if(root == p || root == q){\n            return root;\n        }\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if(left != null && right != null){\n            return root;\n        }else if(left != null){\n            return left;\n        }else{\n            return right;\n        }\n        \n    }\n}"}
{"id": "739", "path": "output2\\java\\Medium\\739-delete-node-in-a-linked-list.java", "hypo_code": "class DeleteNodeInALinkedList {\n    public void deleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n        \n    }\n}"}
{"id": "740", "path": "output2\\java\\Medium\\740-product-of-array-except-self.java", "hypo_code": "class ProductOfArrayExceptSelf {\n    public int[] productExceptSelf(int[] nums) {\n        int[] res = new int[nums.length];\n        int left = 1;\n        int right = 1;\n        for(int i = 0; i < nums.length; i++){\n            res[i] = left;\n            left *= nums[i];\n        }\n        for(int i = nums.length - 1; i >= 0; i--){\n            res[i] *= right;\n            right *= nums[i];\n        }\n        return res;\n        \n    }\n}"}
{"id": "741", "path": "output2\\java\\Medium\\741-search-a-2d-matrix-ii.java", "hypo_code": "class SearchA2DMatrixIi {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int i = 0;\n        int j = n - 1;\n        while(i < m && j >= 0){\n            if(matrix[i][j] == target){\n                return true;\n            }else if(matrix[i][j] > target){\n                j--;\n            }else{\n                i++;\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "742", "path": "output2\\java\\Medium\\742-different-ways-to-add-parentheses.java", "hypo_code": "class DifferentWaysToAddParentheses {\n    public List<Integer> diffWaysToCompute(String expression) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = 0; i < expression.length(); i++){\n            char c = expression.charAt(i);\n            if(c == '+' || c == '-' || c == '*'){\n                List<Integer> left = diffWaysToCompute(expression.substring(0, i));\n                List<Integer> right = diffWaysToCompute(expression.substring(i + 1));\n                for(int l : left){\n                    for(int r : right){\n                        if(c == '+'){\n                            res.add(l + r);\n                        }else if(c == '-'){\n                            res.add(l - r);\n                        }else{\n                            res.add(l * r);\n                        }\n                    }\n                }\n            }\n        }\n        if(res.size() == 0){\n            res.add(Integer.parseInt(expression));\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "743", "path": "output2\\java\\Medium\\743-single-number-iii.java", "hypo_code": "class Solution {\n    public int[] singleNumber(int[] nums) {\n        int xor = 0;\n        for (int num : nums)\n            xor ^= num;\n        int mask = xor & (-xor);\n        int[] res = new int[2];\n        for (int num : nums) {\n            if ((num & mask) == 0)\n                res[0] ^= num;\n            else\n                res[1] ^= num;\n        }\n        return res;\n    }\n}"}
{"id": "744", "path": "output2\\java\\Medium\\744-ugly-number-ii.java", "hypo_code": "class Solution {\n    public int nthUglyNumber(int n) {\n        int[] ugly = new int[n];\n        ugly[0] = 1; \n        int index2 = 0, index3 = 0, index5 = 0;\n        for(int i = 1; i < n; i++) {\n            int min = Math.min(ugly[index2] * 2, Math.min(ugly[index3] * 3, ugly[index5] * 5));\n            ugly[i] = min;\n            if(min == ugly[index2] * 2) index2++;\n            if(min == ugly[index3] * 3) index3++;\n            if(min == ugly[index5] * 5) index5++;\n        }\n        return ugly[n - 1];\n    }\n}"}
{"id": "745", "path": "output2\\java\\Medium\\745-h-index.java", "hypo_code": "class Solution {\n    public int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        int len = citations.length;\n        int h = 0;\n        for(int i = len - 1; i >= 0 && citations[i] > h; i--) {\n            h++;\n        }\n        return h;\n    }\n}"}
{"id": "746", "path": "output2\\java\\Medium\\746-h-index-ii.java", "hypo_code": "class Solution {\n    public int hIndex(int[] citations) {\n        int len = citations.length;\n        int l = 0, r = len - 1;\n        while(l <= r) {\n            int mid = (l + r) / 2;\n            if(citations[mid] == len - mid) return len - mid;\n            else if(citations[mid] > len - mid) r = mid - 1;\n            else l = mid + 1;\n        }\n        return len - l;\n    }\n}"}
{"id": "747", "path": "output2\\java\\Medium\\747-perfect-squares.java", "hypo_code": "class Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n + 1];\n        for(int i = 1; i <= n; i++) {\n            int min = Integer.MAX_VALUE;\n            for(int j = 1; j * j <= i; j++) {\n                min = Math.min(min, dp[i - j * j]);\n            }\n            dp[i] = min + 1;\n        }\n        return dp[n];\n    }\n}"}
{"id": "749", "path": "output2\\java\\Medium\\749-find-the-duplicate-number.java", "hypo_code": "class Solution {\n    public int findDuplicate(int[] nums) {\n        int len = nums.length;\n        int l = 1, r = len - 1;\n        while(l < r) {\n            int mid = (l + r) / 2;\n            int count = 0;\n            for(int num : nums) {\n                if(num <= mid) count++;\n            }\n            if(count > mid) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n}"}
{"id": "750", "path": "output2\\java\\Medium\\750-game-of-life.java", "hypo_code": "class Solution {\n    public void gameOfLife(int[][] board) {\n        int row = board.length, col = board[0].length;\n        int[][] dirs = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};\n        for(int i = 0; i < row; i++) {\n            for(int j = 0; j < col; j++) {\n                int live = 0;\n                for(int[] dir : dirs) {\n                    int x = dir[0] + i, y = dir[1] + j;\n                    if(x < 0 || x >= row || y < 0 || y >= col) continue;\n                    if(board[x][y] == 1 || board[x][y] == -1) live++;\n                }\n                if(board[i][j] == 1 && (live < 2 || live > 3)) board[i][j] = -1;\n                if(board[i][j] == 0 && live == 3) board[i][j] = 2;\n            }\n        }\n        for(int i = 0; i < row; i++) {\n            for(int j = 0; j < col; j++) {\n                board[i][j] %= 2;\n            }\n        }\n    }\n}"}
{"id": "751", "path": "output2\\java\\Medium\\751-bulls-and-cows.java", "hypo_code": "class BullsAndCows {\n    public String getHint(String secret, String guess) {\n        int[] count = new int[10];\n        int bulls = 0;\n        int cows = 0;\n        for(int i = 0; i < secret.length(); i++){\n            if(secret.charAt(i) == guess.charAt(i)){\n                bulls++;\n            }else{\n                if(count[secret.charAt(i) - '0']++ < 0){\n                    cows++;\n                }\n                if(count[guess.charAt(i) - '0']-- > 0){\n                    cows++;\n                }\n            }\n        }\n        return bulls + \"A\" + cows + \"B\";\n        \n    }\n}"}
{"id": "752", "path": "output2\\java\\Medium\\752-longest-increasing-subsequence.java", "hypo_code": "class LongestIncreasingSubsequence {\n    public int lengthOfLIS(int[] nums) {\n        int[] dp = new int[nums.length];\n        int res = 0;\n        for(int i = 0; i < nums.length; i++){\n            int left = 0;\n            int right = res;\n            while(left < right){\n                int mid = left + (right - left) / 2;\n                if(dp[mid] < nums[i]){\n                    left = mid + 1;\n                }else{\n                    right = mid;\n                }\n            }\n            dp[left] = nums[i];\n            if(left == res){\n                res++;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "754", "path": "output2\\java\\Medium\\754-additive-number.java", "hypo_code": "class AdditiveNumber {\n    public boolean isAdditiveNumber(String num) {\n        int n = num.length();\n        for(int i = 1; i <= n / 2; i++){\n            for(int j = 1; Math.max(i, j) <= n - i - j; j++){\n                if(isValid(i, j, num)){\n                    return true;\n                }\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "756", "path": "output2\\java\\Medium\\756-best-time-to-buy-and-sell-stock-with-cooldown.java", "hypo_code": "class BestTimeToBuyAndSellStockWithCooldown {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int[] buy = new int[n];\n        int[] sell = new int[n];\n        buy[0] = -prices[0];\n        for(int i = 1; i < n; i++){\n            buy[i] = Math.max(buy[i - 1], (i >= 2 ? sell[i - 2] : 0) - prices[i]);\n            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);\n        }\n        return sell[n - 1];\n        \n    }\n}"}
{"id": "757", "path": "output2\\java\\Medium\\757-minimum-height-trees.java", "hypo_code": "class MinimumHeightTrees {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        List<Integer> result = new ArrayList<>();\n        if(n == 1){\n            result.add(0);\n            return result;\n        }\n        List<Set<Integer>> graph = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            graph.add(new HashSet<>());\n        }\n        for(int[] edge : edges){\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        for(int i = 0; i < n; i++){\n            if(graph.get(i).size() == 1){\n                queue.offer(i);\n            }\n        }\n        while(n > 2){\n            int size = queue.size();\n            n -= size;\n            for(int i = 0; i < size; i++){\n                int node = queue.poll();\n                int neighbor = graph.get(node).iterator().next();\n                graph.get(neighbor).remove(node);\n                if(graph.get(neighbor).size() == 1){\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        while(!queue.isEmpty()){\n            result.add(queue.poll());\n        }\n        return result;\n        \n        \n        \n    }\n}"}
{"id": "758", "path": "output2\\java\\Medium\\758-super-ugly-number.java", "hypo_code": "class Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        int[] ugly = new int[n];\n        int[] index = new int[primes.length];\n        ugly[0] = 1; \n        for(int i = 1; i < n; i++) {\n            int min = Integer.MAX_VALUE;\n            for(int j = 0; j < primes.length; j++) {\n                min = Math.min(min, primes[j] * ugly[index[j]]);\n            }\n            ugly[i] = min;\n            for(int j = 0; j < primes.length; j++) {\n                if(min == primes[j] * ugly[index[j]]) index[j]++;\n            }\n        }\n        return ugly[n - 1];\n    }\n}"}
{"id": "759", "path": "output2\\java\\Medium\\759-remove-duplicate-letters.java", "hypo_code": "class RemoveDuplicateLetters {\n    public String removeDuplicateLetters(String s) {\n        int[] map = new int[26];\n        boolean[] visited = new boolean[26];\n        for(char c : s.toCharArray()){\n            map[c - 'a']++;\n        }\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            map[c - 'a']--;\n            if(visited[c - 'a']){\n                continue;\n            }\n            while(!stack.isEmpty() && stack.peek() > c && map[stack.peek() - 'a'] > 0){\n                visited[stack.pop() - 'a'] = false;\n            }\n            stack.push(c);\n            visited[c - 'a'] = true;\n        }\n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()){\n            sb.append(stack.pop());\n        }\n        return sb.reverse().toString();\n        \n        \n    }\n}"}
{"id": "760", "path": "output2\\java\\Medium\\760-maximum-product-of-word-lengths.java", "hypo_code": "class MaximumProductOfWordLengths {\n    public int maxProduct(String[] words) {\n        int[] mask = new int[words.length];\n        for(int i = 0; i < words.length; i++){\n            for(char c : words[i].toCharArray()){\n                mask[i] |= 1 << (c - 'a');\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < words.length; i++){\n            for(int j = i + 1; j < words.length; j++){\n                if((mask[i] & mask[j]) == 0){\n                    res = Math.max(res, words[i].length() * words[j].length());\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "761", "path": "output2\\java\\Medium\\761-bulb-switcher.java", "hypo_code": "class BulbSwitcher {\n    public int bulbSwitch(int n) {\n        return (int)Math.sqrt(n);\n        \n    }\n}"}
{"id": "762", "path": "output2\\java\\Medium\\762-coin-change.java", "hypo_code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        for(int i = 1; i <= amount; i++) {\n            int min = Integer.MAX_VALUE;\n            for(int coin : coins) {\n                if(i - coin >= 0 && dp[i - coin] != -1) {\n                    min = Math.min(min, dp[i - coin] + 1);\n                }\n            }\n            dp[i] = min == Integer.MAX_VALUE ? -1 : min;\n        }\n        return dp[amount];\n    }\n}"}
{"id": "763", "path": "output2\\java\\Medium\\763-wiggle-sort-ii.java", "hypo_code": "class Solution {\n    public void wiggleSort(int[] nums) {\n        int len = nums.length;\n        int[] temp = new int[len];\n        System.arraycopy(nums, 0, temp, 0, len);\n        Arrays.sort(temp);\n        int l = (len + 1) / 2 - 1, r = len - 1;\n        for(int i = 0; i < len; i++) {\n            if((i & 1) == 0) nums[i] = temp[l--];\n            else nums[i] = temp[r--];\n        }\n    }\n}"}
{"id": "764", "path": "output2\\java\\Medium\\764-odd-even-linked-list.java", "hypo_code": "class Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if(head == null) return head;\n        ListNode odd = head, even = head.next, evenHead = even;\n        while(even != null && even.next != null) {\n            odd = odd.next = even.next;\n            even = even.next = odd.next;\n        }\n        odd.next = evenHead;\n        return head;\n    }\n}"}
{"id": "765", "path": "output2\\java\\Medium\\765-verify-preorder-serialization-of-a-binary-tree.java", "hypo_code": "class Solution {\n    public boolean isValidSerialization(String preorder) {\n        int diff = 1;\n        String[] nodes = preorder.split(\",\");\n        for(String node : nodes) {\n            if(--diff < 0) return false;\n            if(!node.equals(\"#\")) diff += 2;\n        }\n        return diff == 0;\n    }\n}"}
{"id": "766", "path": "output2\\java\\Medium\\766-increasing-triplet-subsequence.java", "hypo_code": "class Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int len = nums.length;\n        if(len < 3) return false;\n        int min = Integer.MAX_VALUE, mid = Integer.MAX_VALUE;\n        for(int num : nums) {\n            if(num <= min) min = num;\n            else if(num <= mid) mid = num;\n            else return true;\n        }\n        return false;\n    }\n}"}
{"id": "767", "path": "output2\\java\\Medium\\767-house-robber-iii.java", "hypo_code": "class Solution {\n    public int rob(TreeNode root) {\n        int[] res = dfs(root);\n        return Math.max(res[0], res[1]);\n    }\n    private int[] dfs(TreeNode root) {\n        if(root == null) return new int[2];\n        int[] res = new int[2];\n        int[] left = dfs(root.left), right = dfs(root.right);\n        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n        res[1] = left[0] + right[0] + root.val;\n        return res;\n    }\n}"}
{"id": "769", "path": "output2\\java\\Medium\\769-integer-break.java", "hypo_code": "class Solution {\n    public int integerBreak(int n) {\n        if(n == 2) return 1;\n        if(n == 3) return 2;\n        int res = 1;\n        while(n > 4) {\n            res *= 3;\n            n -= 3;\n        }\n        return res * n;\n    }\n}"}
{"id": "770", "path": "output2\\java\\Medium\\770-top-k-frequent-elements.java", "hypo_code": "class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int len = nums.length;\n        for(int i = 0; i < len; i++) {\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n        }\n        int[][] temp = new int[map.size()][2];\n        int index = 0;\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            temp[index][0] = entry.getKey();\n            temp[index][1] = entry.getValue();\n            index++;\n        }\n        Arrays.sort(temp, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return b[1] - a[1];\n            } \n        });\n        int[] res = new int[k];\n        for(int i = 0; i < k; i++) {\n            res[i] = temp[i][0];\n        }\n        return res;\n    }\n}"}
{"id": "772", "path": "output2\\java\\Medium\\772-count-numbers-with-unique-digits.java", "hypo_code": "class Solution {\n    public int countNumbersWithUniqueDigits(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1; dp[1] = 10;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + (dp[i - 1] - dp[i - 2]) * (10 - i + 1);\n        }\n        return dp[n];\n    }\n}"}
{"id": "773", "path": "output2\\java\\Medium\\773-water-and-jug-problem.java", "hypo_code": "class Solution {\n    public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {   \n\n    }\n}"}
{"id": "774", "path": "output2\\java\\Medium\\774-largest-divisible-subset.java", "hypo_code": "class Solution {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        List<Integer> result = new ArrayList<>();\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        int max = 1;\n        int maxIndex = 0;\n        for (int i = 1; i < n; i++) {\n            int j = i - 1;\n            int maxVal = 0;\n            while (j >= 0) {\n                if (nums[i] % nums[j] == 0) {\n                    maxVal = Math.max(maxVal, dp[j]);\n                }\n                j--;\n            }\n            dp[i] = maxVal + 1;\n            if (dp[i] > max) {\n                max = dp[i];\n                maxIndex = i;\n            }\n        }\n        int val = nums[maxIndex];\n        int count = dp[maxIndex];\n        for (int i = maxIndex; i >= 0; i--) {\n            if (val % nums[i] == 0 && dp[i] == count) {\n                result.add(nums[i]);\n                val = nums[i];\n                count--;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "775", "path": "output2\\java\\Medium\\775-sum-of-two-integers.java", "hypo_code": "class SumOfTwoIntegers {\n    public int getSum(int a, int b) {\n        while(b != 0){\n            int carry = (a & b) << 1;\n            a = a ^ b;\n            b = carry;\n        }\n        return a;\n        \n        \n    }\n}"}
{"id": "776", "path": "output2\\java\\Medium\\776-super-pow.java", "hypo_code": "class SuperPow {\n    public int superPow(int a, int[] b) {\n        int res = 1;\n        for(int i = 0; i < b.length; i++){\n            res = pow(res, 10) * pow(a, b[i]) % 1337;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "777", "path": "output2\\java\\Medium\\777-find-k-pairs-with-smallest-sums.java", "hypo_code": "class FindKPairsWithSmallestSums {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums1.length == 0 || nums2.length == 0 || k == 0){\n            return res;\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] + a[1]) - (b[0] + b[1]));\n        for(int i = 0; i < nums1.length && i < k; i++){\n            pq.offer(new int[]{nums1[i], nums2[0], 0});\n        }\n        while(k-- > 0 && !pq.isEmpty()){\n            int[] cur = pq.poll();\n            res.add(Arrays.asList(cur[0], cur[1]));\n            if(cur[2] == nums2.length - 1){\n                continue;\n            }\n            pq.offer(new int[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "778", "path": "output2\\java\\Medium\\778-guess-number-higher-or-lower-ii.java", "hypo_code": "class GuessNumberHigherOrLowerIi {\n    public int getMoneyAmount(int n) {\n        int[][] dp = new int[n + 1][n + 1];\n        for(int i = 2; i <= n; i++){\n            for(int j = i - 1; j > 0; j--){\n                int min = Integer.MAX_VALUE;\n                for(int k = j + 1; k < i; k++){\n                    min = Math.min(min, k + Math.max(dp[j][k - 1], dp[k + 1][i]));\n                }\n                dp[j][i] = j + 1 == i ? j : min;\n            }\n        }\n        return dp[1][n];\n        \n    }\n}"}
{"id": "779", "path": "output2\\java\\Medium\\779-wiggle-subsequence.java", "hypo_code": "class WiggleSubsequence {\n    public int wiggleMaxLength(int[] nums) {\n        int n = nums.length;\n        if(n < 2){\n            return n;\n        }\n        int[] up = new int[n];\n        int[] down = new int[n];\n        up[0] = 1;\n        down[0] = 1;\n        for(int i = 1; i < n; i++){\n            if(nums[i] > nums[i - 1]){\n                up[i] = down[i - 1] + 1;\n                down[i] = down[i - 1];\n            }else if(nums[i] < nums[i - 1]){\n                down[i] = up[i - 1] + 1;\n                up[i] = up[i - 1];\n            }else{\n                up[i] = up[i - 1];\n                down[i] = down[i - 1];\n            }\n        }\n        return Math.max(up[n - 1], down[n - 1]);\n        \n        \n    }\n}"}
{"id": "780", "path": "output2\\java\\Medium\\780-combination-sum-iv.java", "hypo_code": "class CombinationSumIv {\n    public int combinationSum4(int[] nums, int target) {\n        int[] dp = new int[target + 1];\n        dp[0] = 1;\n        for(int i = 1; i <= target; i++){\n            for(int num : nums){\n                if(i >= num){\n                    dp[i] += dp[i - num];\n                }\n            }\n        }\n        return dp[target];\n        \n    }\n}"}
{"id": "781", "path": "output2\\java\\Medium\\781-kth-smallest-element-in-a-sorted-matrix.java", "hypo_code": "class KthSmallestElementInASortedMatrix {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        int left = matrix[0][0];\n        int right = matrix[n - 1][n - 1];\n        while(left < right){\n            int mid = left + (right - left) / 2;\n            int count = 0;\n            int j = n - 1;\n            for(int i = 0; i < n; i++){\n                while(j >= 0 && matrix[i][j] > mid){\n                    j--;\n                }\n                count += (j + 1);\n            }\n            if(count < k){\n                left = mid + 1;\n            }else{\n                right = mid;\n            }\n        }\n        return left;\n        \n        \n        \n    }\n}"}
{"id": "785", "path": "output2\\java\\Medium\\785-mini-parser.java", "hypo_code": "class Solution {\n    public NestedInteger deserialize(String s) {\n        NestedInteger result = new NestedInteger();\n        if (s == null || s.length() == 0) {\n            return result;\n        }\n        if (s.charAt(0) != '[') {\n            result.setInteger(Integer.valueOf(s));\n        } else if (s.length() > 2) {\n            int start = 1;\n            int count = 0;\n            for (int i = 1; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if (count == 0 && (c == ',' || i == s.length() - 1)) {\n                    result.add(deserialize(s.substring(start, i)));\n                    start = i + 1;\n                } else if (c == '[') {\n                    count++;\n                } else if (c == ']') {\n                    count--;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "786", "path": "output2\\java\\Medium\\786-lexicographical-numbers.java", "hypo_code": "class LexicographicalNumbers {\n    public List<Integer> lexicalOrder(int n) {\n        List<Integer> res = new ArrayList<>();\n        int cur = 1;\n        for(int i = 1; i <= n; i++){\n            res.add(cur);\n            if(cur * 10 <= n){\n                cur *= 10;\n            }else if(cur % 10 != 9 && cur + 1 <= n){\n                cur++;\n            }else{\n                while((cur / 10) % 10 == 9){\n                    cur /= 10;\n                }\n                cur = cur / 10 + 1;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "787", "path": "output2\\java\\Medium\\787-longest-absolute-file-path.java", "hypo_code": "class Solution {\n    public int lengthLongestPath(String input) {\n        int max = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, 0);\n        for (String s : input.split(\"\\n\")) {\n            int level = s.lastIndexOf(\"\\t\") + 1;\n            int len = s.length() - level;\n            if (s.contains(\".\")) {\n                max = Math.max(max, map.get(level) + len);\n            } else {\n                map.put(level + 1, map.get(level) + len + 1);\n            }\n        }\n        return max;\n    }\n}"}
{"id": "788", "path": "output2\\java\\Medium\\788-elimination-game.java", "hypo_code": "class EliminationGame {\n    public int lastRemaining(int n) {\n        boolean left = true;\n        int step = 1;\n        int head = 1;\n        int remaining = n;\n        while(remaining > 1){\n            if(left || remaining % 2 == 1){\n                head = head + step;\n            }\n            remaining = remaining / 2;\n            step = step * 2;\n            left = !left;\n        }\n        return head;\n        \n        \n    }\n}"}
{"id": "789", "path": "output2\\java\\Medium\\789-utf-8-validation.java", "hypo_code": "class Utf8Validation {\n    public boolean validUtf8(int[] data) {\n        int n = data.length;\n        int i = 0;\n        while(i < n){\n            int num = data[i];\n            int count = 0;\n            if((num & 128) == 0){\n                i++;\n                continue;\n            }\n            while((num & 128) != 0){\n                count++;\n                num <<= 1;\n            }\n            if(count == 1 || count > 4){\n                return false;\n            }\n            for(int j = 1; j < count; j++){\n                if(i + j >= n || (data[i + j] & 192) != 128){\n                    return false;\n                }\n            }\n            i += count;\n        }\n        return true;\n        \n    }\n}"}
{"id": "790", "path": "output2\\java\\Medium\\790-decode-string.java", "hypo_code": "class DecodeString {\n    public String decodeString(String s) {\n        Stack<Integer> countStack = new Stack<>();\n        Stack<StringBuilder> strStack = new Stack<>();\n        StringBuilder currStr = new StringBuilder();\n        int k = 0;\n        for(char c : s.toCharArray()){\n            if(Character.isDigit(c)){\n                k = k * 10 + c - '0';\n            }else if(c == '['){\n                countStack.push(k);\n                strStack.push(currStr);\n                currStr = new StringBuilder();\n                k = 0;\n            }else if(c == ']'){\n                StringBuilder temp = currStr;\n                currStr = strStack.pop();\n                for(k = countStack.pop(); k > 0; k--){\n                    currStr.append(temp);\n                }\n            }else{\n                currStr.append(c);\n            }\n        }\n        return currStr.toString();\n        \n    }\n}"}
{"id": "791", "path": "output2\\java\\Medium\\791-longest-substring-with-at-least-k-repeating-characters.java", "hypo_code": "class LongestSubstringWithAtLeastKRepeatingCharacters {\n    public int longestSubstring(String s, int k) {\n        int n = s.length();\n        int[] count = new int[26];\n        for(int i = 0; i < n; i++){\n            count[s.charAt(i) - 'a']++;\n        }\n        int res = 0;\n        for(int i = 0; i < 26; i++){\n            if(count[i] > 0 && count[i] < k){\n                for(String t : s.split(String.valueOf((char)('a' + i)))){\n                    res = Math.max(res, longestSubstring(t, k));\n                }\n                return res;\n            }\n        }\n        return n;\n                \n    }\n}"}
{"id": "792", "path": "output2\\java\\Medium\\792-rotate-function.java", "hypo_code": "class RotateFunction {\n    public int maxRotateFunction(int[] nums) {\n        int n = nums.length;\n        int sum = 0;\n        int f = 0;\n        for(int i = 0; i < n; i++){\n            sum += nums[i];\n            f += i * nums[i];\n        }\n        int res = f;\n        for(int i = 1; i < n; i++){\n            f = f + sum - n * nums[n - i];\n            res = Math.max(res, f);\n        }\n        return res;\n        \n    }\n}"}
{"id": "793", "path": "output2\\java\\Medium\\793-integer-replacement.java", "hypo_code": "class IntegerReplacement {\n    public int integerReplacement(int n) {\n        int res = 0;\n        while(n != 1){\n            if((n & 1) == 0){\n                n >>>= 1;\n            }else if(n == 3 || ((n >>> 1) & 1) == 0){\n                n--;\n            }else{\n                n++;\n            }\n            res++;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "795", "path": "output2\\java\\Medium\\795-evaluate-division.java", "hypo_code": "class EvaluateDivision {\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        int n = equations.size();\n        Map<String, Integer> map = new HashMap<>();\n        int idx = 0;\n        for(int i = 0; i < n; i++){\n            String a = equations.get(i).get(0);\n            String b = equations.get(i).get(1);\n            if(!map.containsKey(a)){\n                map.put(a, idx++);\n            }\n            if(!map.containsKey(b)){\n                map.put(b, idx++);\n            }\n        }\n        double[][] g = new double[idx][idx];\n        for(int i = 0; i < idx; i++){\n            Arrays.fill(g[i], -1);\n        }\n        for(int i = 0; i < n; i++){\n            String a = equations.get(i).get(0);\n            String b = equations.get(i).get(1);\n            int x = map.get(a);\n            int y = map.get(b);\n            g[x][y] = values[i];\n            g[y][x] = 1 / values[i];\n        }\n        for(int i = 0; i < idx; i++){\n            g[i][i] = 1;\n        }\n        for(int k = 0; k < idx; k++){\n            for(int i = 0; i < idx; i++){\n                for(int j = 0; j < idx; j++){\n                    if(g[i][k] != -1 && g[k][j] != -1){\n                        g[i][j] = g[i][k] * g[k][j];\n                    }\n                }\n            }\n        }\n        int m = queries.size();\n        double[] res = new double[m];\n        for(int i = 0; i < m; i++){\n            String a = queries.get(i).get(0);\n            String b = queries.get(i).get(1);\n            if(!map.containsKey(a) || !map.containsKey(b)){\n                res[i] = -1;\n            }else{\n                int x = map.get(a);\n                int y = map.get(b);\n                res[i] = g[x][y];\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "796", "path": "output2\\java\\Medium\\796-nth-digit.java", "hypo_code": "class NthDigit {\n    public int findNthDigit(int n) {\n        int digit = 1;\n        long start = 1;\n        long count = 9;\n        while(n > count){\n            n -= count;\n            digit++;\n            start *= 10;\n            count = digit * start * 9;\n        }\n        long num = start + (n - 1) / digit;\n        return Long.toString(num).charAt((n - 1) % digit) - '0';\n        \n    }\n}"}
{"id": "797", "path": "output2\\java\\Medium\\797-remove-k-digits.java", "hypo_code": "class RemoveKDigits {\n    public String removeKdigits(String num, int k) {\n        if(num.length() == k){\n            return \"0\";\n        }\n        Stack<Character> stack = new Stack<>();\n        for(char c : num.toCharArray()){\n            while(!stack.isEmpty() && stack.peek() > c && k > 0){\n                stack.pop();\n                k--;\n            }\n            stack.push(c);\n        }\n        while(k > 0){\n            stack.pop();\n            k--;\n        }\n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()){\n            sb.append(stack.pop());\n        }\n        sb.reverse();\n        while(sb.length() > 1 && sb.charAt(0) == '0'){\n            sb.deleteCharAt(0);\n        }\n        return sb.toString();\n        \n    }\n}"}
{"id": "798", "path": "output2\\java\\Medium\\798-queue-reconstruction-by-height.java", "hypo_code": "class QueueReconstructionByHeight {\n    public int[][] reconstructQueue(int[][] people) {\n        int n = people.length;\n        Arrays.sort(people, (a, b) -> {\n            if(a[0] != b[0]){\n                return b[0] - a[0];\n            }else{\n                return a[1] - b[1];\n            }\n        });\n        List<int[]> list = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            list.add(people[i][1], people[i]);\n        }\n        int[][] res = new int[n][2];\n        for(int i = 0; i < n; i++){\n            res[i] = list.get(i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "799", "path": "output2\\java\\Medium\\799-arithmetic-slices.java", "hypo_code": "class ArithmeticSlices {\n    public int numberOfArithmeticSlices(int[] nums) {\n        int n = nums.length;\n        if(n < 3){\n            return 0;\n        }\n        int[] dp = new int[n];\n        int res = 0;\n        for(int i = 2; i < n; i++){\n            if(nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]){\n                dp[i] = dp[i - 1] + 1;\n                res += dp[i];\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "800", "path": "output2\\java\\Medium\\800-partition-equal-subset-sum.java", "hypo_code": "class PartitionEqualSubsetSum {\n    public boolean canPartition(int[] nums) {\n        int n = nums.length;\n        int sum = 0;\n        for(int num : nums){\n            sum += num;\n        }\n        if(sum % 2 == 1){\n            return false;\n        }\n        sum /= 2;\n        boolean[][] dp = new boolean[n + 1][sum + 1];\n        for(int i = 0; i <= n; i++){\n            dp[i][0] = true;\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= sum; j++){\n                if(j >= nums[i - 1]){\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];\n                }else{\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[n][sum];\n        \n        \n        \n    }\n}"}
{"id": "801", "path": "output2\\java\\Medium\\801-pacific-atlantic-water-flow.java", "hypo_code": "class PacificAtlanticWaterFlow {\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        List<List<Integer>> result = new ArrayList<>();\n        int m = heights.length;\n        int n = heights[0].length;\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n        for(int i = 0; i < m; i++){\n            dfs(heights, pacific, Integer.MIN_VALUE, i, 0);\n            dfs(heights, atlantic, Integer.MIN_VALUE, i, n - 1);\n        }\n        for(int i = 0; i < n; i++){\n            dfs(heights, pacific, Integer.MIN_VALUE, 0, i);\n            dfs(heights, atlantic, Integer.MIN_VALUE, m - 1, i);\n        }\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(pacific[i][j] && atlantic[i][j]){\n                    List<Integer> list = new ArrayList<>();\n                    list.add(i);\n                    list.add(j);\n                    result.add(list);\n                }\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "802", "path": "output2\\java\\Medium\\802-battleships-in-a-board.java", "hypo_code": "class Solution {\n    public int countBattleships(char[][] board) {\n        int m = board.length;\n        int n = board[0].length;\n        int result = 0;\n        int[][] dirs = {{0, 1}, {1, 0}};\n        boolean[][] visited = new boolean[m][n];\n        Queue<int[]> queue = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            if (board[i][0] == 'X' && !visited[i][0]) {\n                result++;\n                queue.offer(new int[]{i, 0});\n                visited[i][0] = true;\n                while (!queue.isEmpty()) {\n                    int[] cur = queue.poll();\n                    for (int[] dir : dirs) {\n                        int x = cur[0] + dir[0];\n                        int y = cur[1] + dir[1];\n                        if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y] && board[x][y] == 'X') {\n                            queue.offer(new int[]{x, y});\n                            visited[x][y] = true;\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "803", "path": "output2\\java\\Medium\\803-maximum-xor-of-two-numbers-in-an-array.java", "hypo_code": "class Solution {\n    public int findMaximumXOR(int[] nums) {\n        int result = 0;\n        int mask = 0;\n        for (int i = 31; i >= 0; i--) {\n            mask = mask | (1 << i);\n            Set<Integer> set = new HashSet<>();\n            for (int num : nums) {\n                set.add(num & mask);\n            }\n            int tmp = result | (1 << i);\n            for (int num : set) {\n                if (set.contains(num ^ tmp)) {\n                    result = tmp;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "804", "path": "output2\\java\\Medium\\804-reconstruct-original-digits-from-english.java", "hypo_code": "class Solution {\n    public String originalDigits(String s) {\n          int[] count = new int[26];\n        int[] digit = new int[10];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        digit[0] = count['z' - 'a'];\n        digit[2] = count['w' - 'a'];\n        digit[4] = count['u' - 'a'];\n        digit[6] = count['x' - 'a'];\n        digit[8] = count['g' - 'a'];\n        digit[3] = count['h' - 'a'] - digit[8];\n        digit[5] = count['f' - 'a'] - digit[4];\n        digit[7] = count['v' - 'a'] - digit[5];\n        digit[9] = count['i' - 'a'] - digit[5] - digit[6] - digit[8];\n        digit[1] = count['n' - 'a'] - digit[7] - 2 * digit[9];\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < digit[i]; j++) {\n                sb.append(i);\n            }\n        }\n        return sb.toString();   \n    }\n}"}
{"id": "805", "path": "output2\\java\\Medium\\805-longest-repeating-character-replacement.java", "hypo_code": "class Solution {\n    public int characterReplacement(String s, int k) {\n        int result = 0;\n        int[] count = new int[26];\n        int left = 0;\n        int right = 0;\n        int maxCount = 0;\n        while (right < s.length()) {\n            count[s.charAt(right) - 'A']++;\n            maxCount = Math.max(maxCount, count[s.charAt(right) - 'A']);\n            if (right - left + 1 - maxCount > k) {\n                count[s.charAt(left) - 'A']--;\n                left++;\n            }\n            result = Math.max(result, right - left + 1);\n            right++;\n        }\n        return result;\n    }\n}"}
{"id": "807", "path": "output2\\java\\Medium\\807-n-ary-tree-level-order-traversal.java", "hypo_code": "class Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n        Queue<Node> q = new LinkedList<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            List<Integer> tmp = new ArrayList<>();\n            while (size > 0) {\n                Node node = q.poll();\n                tmp.add(node.val);\n                for (Node child : node.children) {\n                    q.offer(child);\n                }\n                size--;\n            }\n            result.add(tmp);\n        }\n        return result;\n    }\n}"}
{"id": "809", "path": "output2\\java\\Medium\\809-minimum-genetic-mutation.java", "hypo_code": "class MinimumGeneticMutation {\n    public int minMutation(String startGene, String endGene, String[] bank) {\n        Set<String> bankSet = new HashSet<>(Arrays.asList(bank));\n        if(!bankSet.contains(endGene)){\n            return -1;\n        }\n        char[] genes = new char[]{'A', 'C', 'G', 'T'};\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(startGene);\n        int res = 0;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String cur = queue.poll();\n                if(cur.equals(endGene)){\n                    return res;\n                }\n                char[] curArray = cur.toCharArray();\n                for(int j = 0; j < curArray.length; j++){\n                    char old = curArray[j];\n                    for(char c : genes){\n                        curArray[j] = c;\n                        String next = new String(curArray);\n                        if(bankSet.contains(next)){\n                            queue.offer(next);\n                            bankSet.remove(next);\n                        }\n                    }\n                    curArray[j] = old;\n                }\n            }\n            res++;\n        }\n        return -1;\n        \n        \n        \n    }\n}"}
{"id": "810", "path": "output2\\java\\Medium\\810-non-overlapping-intervals.java", "hypo_code": "class NonOverlappingIntervals {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        int n = intervals.length;\n        if(n == 0){\n            return 0;\n        }\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n        int res = 1;\n        int end = intervals[0][1];\n        for(int i = 1; i < n; i++){\n            if(intervals[i][0] >= end){\n                res++;\n                end = intervals[i][1];\n            }\n        }\n        return n - res;\n        \n    }\n}"}
{"id": "811", "path": "output2\\java\\Medium\\811-find-right-interval.java", "hypo_code": "class FindRightInterval {\n    public int[] findRightInterval(int[][] intervals) {\n        int n = intervals.length;\n        int[] res = new int[n];\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for(int i = 0; i < n; i++){\n            map.put(intervals[i][0], i);\n        }\n        for(int i = 0; i < n; i++){\n            Map.Entry<Integer, Integer> entry = map.ceilingEntry(intervals[i][1]);\n            res[i] = entry == null ? -1 : entry.getValue();\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "812", "path": "output2\\java\\Medium\\812-path-sum-iii.java", "hypo_code": "class PathSumIii {\n    public int pathSum(TreeNode root, int targetSum) {\n        if(root == null){\n            return 0;\n        }\n        return pathSumFrom(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);\n        \n    }\n}"}
{"id": "813", "path": "output2\\java\\Medium\\813-find-all-anagrams-in-a-string.java", "hypo_code": "class FindAllAnagramsInAString {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> res = new ArrayList<>();\n        int[] map = new int[26];\n        for(char c : p.toCharArray()){\n            map[c - 'a']++;\n        }\n        int left = 0;\n        int right = 0;\n        int count = p.length();\n        while(right < s.length()){\n            if(map[s.charAt(right++) - 'a']-- >= 1){\n                count--;\n            }\n            if(count == 0){\n                res.add(left);\n            }\n            if(right - left == p.length() && map[s.charAt(left++) - 'a']++ >= 0){\n                count++;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "814", "path": "output2\\java\\Medium\\814-find-all-duplicates-in-an-array.java", "hypo_code": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            int index = Math.abs(nums[i]) - 1;\n            nums[index] = -nums[index];\n            if (nums[index] > 0) {\n                result.add(index + 1);\n            }\n        }\n        return result;\n    }\n}"}
{"id": "815", "path": "output2\\java\\Medium\\815-string-compression.java", "hypo_code": "class Solution {\n    public int compress(char[] chars) {\n        int n = chars.length;\n        int index = 0;\n        int i = 0;\n        while (i < n) {\n            char c = chars[i];\n            int count = 0;\n            while (i < n && chars[i] == c) {\n                i++;\n                count++;\n            }\n            chars[index++] = c;\n            if (count > 1) {\n                for (char x : String.valueOf(count).toCharArray()) {\n                    chars[index++] = x;\n                }\n            }\n        }\n        return index;\n    }\n}"}
{"id": "816", "path": "output2\\java\\Medium\\816-add-two-numbers-ii.java", "hypo_code": "class AddTwoNumbersIi {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        Stack<Integer> s1 = new Stack<>();\n        Stack<Integer> s2 = new Stack<>();\n        while(l1 != null){\n            s1.push(l1.val);\n            l1 = l1.next;\n        }\n        while(l2 != null){\n            s2.push(l2.val);\n            l2 = l2.next;\n        }\n        ListNode head = null;\n        int carry = 0;\n        while(!s1.isEmpty() || !s2.isEmpty() || carry != 0){\n            int sum = carry;\n            if(!s1.isEmpty()){\n                sum += s1.pop();\n            }\n            if(!s2.isEmpty()){\n                sum += s2.pop();\n            }\n            ListNode node = new ListNode(sum % 10);\n            node.next = head;\n            head = node;\n            carry = sum / 10;\n        }\n        return head;\n        \n        \n    }\n}"}
{"id": "817", "path": "output2\\java\\Medium\\817-number-of-boomerangs.java", "hypo_code": "class NumberOfBoomerangs {\n    public int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            Map<Integer, Integer> map = new HashMap<>();\n            for(int j = 0; j < n; j++){\n                if(i == j){\n                    continue;\n                }\n                int dist = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            for(int val : map.values()){\n                res += val * (val - 1);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "819", "path": "output2\\java\\Medium\\819-delete-node-in-a-bst.java", "hypo_code": "class DeleteNodeInABst {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if(root == null){\n            return null;\n        }\n        if(root.val == key){\n            if(root.left == null){\n                return root.right;\n            }else if(root.right == null){\n                return root.left;\n            }else{\n                TreeNode min = findMin(root.right);\n                root.val = min.val;\n                root.right = deleteNode(root.right, min.val);\n            }\n        }else if(root.val > key){\n            root.left = deleteNode(root.left, key);\n        }else{\n            root.right = deleteNode(root.right, key);\n        }\n        return root;\n        \n    }\n}"}
{"id": "820", "path": "output2\\java\\Medium\\820-sort-characters-by-frequency.java", "hypo_code": "class SortCharactersByFrequency {\n    public String frequencySort(String s) {\n        int n = s.length();\n        int[] cnt = new int[256];\n        for(int i = 0; i < n; i++){\n            cnt[s.charAt(i)]++;\n        }\n        List<Character>[] bucket = new List[n + 1];\n        for(int i = 0; i < 256; i++){\n            if(cnt[i] > 0){\n                if(bucket[cnt[i]] == null){\n                    bucket[cnt[i]] = new ArrayList<>();\n                }\n                bucket[cnt[i]].add((char)i);\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i = n; i >= 0; i--){\n            if(bucket[i] != null){\n                for(char c : bucket[i]){\n                    for(int j = 0; j < i; j++){\n                        sb.append(c);\n                    }\n                }\n            }\n        }\n        return sb.toString();\n        \n        \n    }\n}"}
{"id": "821", "path": "output2\\java\\Medium\\821-minimum-number-of-arrows-to-burst-balloons.java", "hypo_code": "class Solution {\n    public int findMinArrowShots(int[][] points) {    \n          \n    }\n}"}
{"id": "822", "path": "output2\\java\\Medium\\822-minimum-moves-to-equal-array-elements.java", "hypo_code": "class MinimumMovesToEqualArrayElements {\n    public int minMoves(int[] nums) {\n        int n = nums.length;\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            min = Math.min(min, nums[i]);\n        }\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            res += nums[i] - min;\n        }\n        return res;\n        \n    }\n}"}
{"id": "823", "path": "output2\\java\\Medium\\823-4sum-ii.java", "hypo_code": "class 4SumIi {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                map.put(nums1[i] + nums2[j], map.getOrDefault(nums1[i] + nums2[j], 0) + 1);\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                res += map.getOrDefault(-nums3[i] - nums4[j], 0);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "824", "path": "output2\\java\\Medium\\824-132-pattern.java", "hypo_code": "class OneThreeTwoPattern {\n    public boolean find132pattern(int[] nums) {\n        int n = nums.length;\n        int[] min = new int[n];\n        min[0] = nums[0];\n        for(int i = 1; i < n; i++){\n            min[i] = Math.min(min[i - 1], nums[i]);\n        }\n        Stack<Integer> stack = new Stack<>();\n        for(int i = n - 1; i >= 0; i--){\n            if(nums[i] > min[i]){\n                while(!stack.isEmpty() && stack.peek() <= min[i]){\n                    stack.pop();\n                }\n                if(!stack.isEmpty() && stack.peek() < nums[i]){\n                    return true;\n                }\n                stack.push(nums[i]);\n            }\n        }\n        return false;\n        \n        \n    }\n}"}
{"id": "825", "path": "output2\\java\\Medium\\825-circular-array-loop.java", "hypo_code": "class CircularArrayLoop {\n    public boolean circularArrayLoop(int[] nums) {\n        int n = nums.length;\n        for(int i = 0; i < n; i++){\n            if(nums[i] == 0){\n                continue;\n            }\n            int slow = i;\n            int fast = next(nums, i);\n            while(nums[slow] * nums[fast] > 0 && nums[slow] * nums[next(nums, fast)] > 0){\n                if(slow == fast){\n                    if(slow != next(nums, slow)){\n                        return true;\n                    }\n                    break;\n                }\n                slow = next(nums, slow);\n                fast = next(nums, next(nums, fast));\n            }\n            slow = i;\n            int val = nums[i];\n            while(nums[slow] * val > 0){\n                int next = next(nums, slow);\n                nums[slow] = 0;\n                slow = next;\n            }\n        }\n        return false;\n        \n        \n    }\n}"}
{"id": "826", "path": "output2\\java\\Medium\\826-minimum-moves-to-equal-array-elements-ii.java", "hypo_code": "class MinimumMovesToEqualArrayElementsIi {\n    public int minMoves2(int[] nums) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int res = 0;\n        int i = 0;\n        int j = n - 1;\n        while(i < j){\n            res += nums[j] - nums[i];\n            i++;\n            j--;\n        }\n        return res;\n        \n    }\n}"}
{"id": "827", "path": "output2\\java\\Medium\\827-can-i-win.java", "hypo_code": "class CanIWin {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if(desiredTotal <= maxChoosableInteger){\n            return true;\n        }\n        if((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal){\n            return false;\n        }\n        return canIWin(maxChoosableInteger, desiredTotal, 0, new HashMap<>());\n        \n    }\n}"}
{"id": "828", "path": "output2\\java\\Medium\\828-unique-substrings-in-wraparound-string.java", "hypo_code": "class UniqueSubstringsInWraparoundString {\n    public int findSubstringInWraproundString(String s) {\n        int n = s.length();\n        int[] cnt = new int[26];\n        int maxLen = 0;\n        for(int i = 0; i < n; i++){\n            if(i > 0 && (s.charAt(i) - s.charAt(i - 1) == 1 || s.charAt(i - 1) - s.charAt(i) == 25)){\n                maxLen++;\n            }else{\n                maxLen = 1;\n            }\n            int index = s.charAt(i) - 'a';\n            cnt[index] = Math.max(cnt[index], maxLen);\n        }\n        int res = 0;\n        for(int i = 0; i < 26; i++){\n            res += cnt[i];\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "829", "path": "output2\\java\\Medium\\829-validate-ip-address.java", "hypo_code": "class ValidateIpAddress {\n    public String validIPAddress(String queryIP) {\n        if(queryIP.contains(\".\")){\n            String[] arr = queryIP.split(\"\\\\.\");\n            if(arr.length != 4){\n                return \"Neither\";\n            }\n            for(String s : arr){\n                if(s.length() == 0 || s.length() > 3){\n                    return \"Neither\";\n                }\n                if(s.charAt(0) == '0' && s.length() > 1){\n                    return \"Neither\";\n                }\n                for(int i = 0; i < s.length(); i++){\n                    if(!Character.isDigit(s.charAt(i))){\n                        return \"Neither\";\n                    }\n                }\n                int num = Integer.parseInt(s);\n                if(num < 0 || num > 255){\n                    return \"Neither\";\n                }\n            }\n            return \"IPv4\";\n        }else if(queryIP.contains(\":\")){\n            String[] arr = queryIP.split(\":\");\n            if(arr.length != 8){\n                return \"Neither\";\n            }\n            for(String s : arr){\n                if(s.length() == 0 || s.length() > 4){\n                    return \"Neither\";\n                }\n                for(int i = 0; i < s.length(); i++){\n                    char c = s.charAt(i);\n                    if(!Character.isDigit(c) && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F')){\n                        return \"Neither\";\n                    }\n                }\n            }\n            return \"IPv6\";\n        }else{\n            return \"Neither\";\n        }\n        \n        \n        \n    }\n}"}
{"id": "830", "path": "output2\\java\\Medium\\830-implement-rand10-using-rand7.java", "hypo_code": "class ImplementRand10UsingRand7 extends SolBase {\n    public int rand10() {\n        int res = 40;\n        while(res >= 40){\n            res = 7 * (rand7() - 1) + rand7() - 1;\n        }\n        return res % 10 + 1;\n        \n        \n    }\n}"}
{"id": "831", "path": "output2\\java\\Medium\\831-matchsticks-to-square.java", "hypo_code": "class MatchsticksToSquare {\n    public boolean makesquare(int[] matchsticks) {\n        int n = matchsticks.length;\n        if(n < 4){\n            return false;\n        }\n        int sum = 0;\n        for(int i = 0; i < n; i++){\n            sum += matchsticks[i];\n        }\n        if(sum % 4 != 0){\n            return false;\n        }\n        int target = sum / 4;\n        Arrays.sort(matchsticks);\n        int i = n - 1;\n        if(matchsticks[i] > target){\n            return false;\n        }\n        while(i >= 0 && matchsticks[i] == target){\n            i--;\n            n--;\n        }\n        return dfs(matchsticks, new int[4], i, target);\n        \n        \n    }\n}"}
{"id": "832", "path": "output2\\java\\Medium\\832-ones-and-zeroes.java", "hypo_code": "class OnesAndZeroes {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int[][] dp = new int[m + 1][n + 1];\n        for(String str : strs){\n            int[] cnt = count(str);\n            for(int i = m; i >= cnt[0]; i--){\n                for(int j = n; j >= cnt[1]; j--){\n                    dp[i][j] = Math.max(dp[i][j], dp[i - cnt[0]][j - cnt[1]] + 1);\n                }\n            }\n        }\n        return dp[m][n];\n        \n        \n    }\n}"}
{"id": "833", "path": "output2\\java\\Medium\\833-heaters.java", "hypo_code": "class Heaters {\n    public int findRadius(int[] houses, int[] heaters) {\n        Arrays.sort(heaters);\n        int res = 0;\n        for(int i = 0; i < houses.length; i++){\n            int left = 0;\n            int right = heaters.length - 1;\n            while(left < right){\n                int mid = left + (right - left) / 2;\n                if(heaters[mid] < houses[i]){\n                    left = mid + 1;\n                }else{\n                    right = mid;\n                }\n            }\n            int dist1 = Math.abs(heaters[left] - houses[i]);\n            int dist2 = Integer.MAX_VALUE;\n            if(left > 0){\n                dist2 = Math.abs(heaters[left - 1] - houses[i]);\n            }\n            res = Math.max(res, Math.min(dist1, dist2));\n        }\n        return res;\n        \n    }\n}"}
{"id": "834", "path": "output2\\java\\Medium\\834-total-hamming-distance.java", "hypo_code": "class TotalHammingDistance {\n    public int totalHammingDistance(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        for(int i = 0; i < 32; i++){\n            int cnt = 0;\n            for(int j = 0; j < n; j++){\n                cnt += (nums[j] >> i) & 1;\n            }\n            res += cnt * (n - cnt);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "836", "path": "output2\\java\\Medium\\836-magical-string.java", "hypo_code": "class MagicalString {\n    public int magicalString(int n) {\n        if(n == 0){\n            return 0;\n        }\n        if(n <= 3){\n            return 1;\n        }\n        int[] arr = new int[n + 1];\n        arr[0] = 1;\n        arr[1] = 2;\n        arr[2] = 2;\n        int i = 2;\n        int j = 3;\n        int res = 1;\n        while(j < n){\n            int num = arr[i];\n            int val = arr[j - 1] == 1 ? 2 : 1;\n            for(int k = 0; k < num; k++){\n                arr[j] = val;\n                if(val == 1 && j < n){\n                    res++;\n                }\n                j++;\n            }\n            i++;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "837", "path": "output2\\java\\Medium\\837-predict-the-winner.java", "hypo_code": "class Solution {\n    public boolean predictTheWinner(int[] nums) {\n        int n = nums.length;\n        if (n % 2 == 0) {\n            return true;\n        }\n        int[][] dp = new int[n][n];\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            dp[i][i] = nums[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            for (int j = n - 1; j >= i + 1; j--) {\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n            }\n        }\n        return dp[0][n - 1] >= 0;\n    }\n}"}
{"id": "838", "path": "output2\\java\\Medium\\838-non-decreasing-subsequences.java", "hypo_code": "class Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        dfs(nums, 0, new ArrayList<>(), result);\n        return result;\n    }\n    private void dfs(int[] nums, int index, List<Integer> list, List<List<Integer>> result) {\n        if (list.size() >= 2) {\n            result.add(new ArrayList<>(list));\n        }\n        if (index >= nums.length) {\n            return;\n        }\n        Set<Integer> set = new HashSet<>();\n        for (int i = index; i < nums.length; i++) {\n            if (set.contains(nums[i])) {\n                continue;\n            }\n            if (list.size() == 0 || nums[i] >= list.get(list.size() - 1)) {\n                set.add(nums[i]);\n                list.add(nums[i]);\n                dfs(nums, i + 1, list, result);\n                list.remove(list.size() - 1);\n            }\n        }\n    }\n}"}
{"id": "839", "path": "output2\\java\\Medium\\839-target-sum.java", "hypo_code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int n = nums.length;\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        int[][] dp = new int[n][2 * sum + 1];\n        dp[0][sum + nums[0]] = 1;\n        dp[0][sum - nums[0]] += 1;\n        for (int i = 1; i < n; i++) {\n            for (int j = -sum; j <= sum; j++) {\n                if (dp[i - 1][sum + j] > 0) {\n                    dp[i][sum + j + nums[i]] += dp[i - 1][sum + j];\n                    dp[i][sum + j - nums[i]] += dp[i - 1][sum + j];\n                }\n            }\n        }\n        return target > sum ? 0 : dp[n - 1][sum + target];\n    }\n}"}
{"id": "841", "path": "output2\\java\\Medium\\841-diagonal-traverse.java", "hypo_code": "class Solution {\n    public int[] findDiagonalOrder(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] result = new int[m * n];\n        int index = 0;\n        int row = 0, col = 0;\n        boolean up = true;\n        while (index < m * n) {\n            result[index++] = mat[row][col];\n            if (up) {\n                if (row - 1 >= 0 && col + 1 < n) {\n                    row--;\n                    col++;\n                } else if (row - 1 < 0 && col + 1 < n) {\n                    col++;\n                    up = false;\n                } else if (row - 1 >= 0 && col + 1 >= n) {\n                    row++;\n                    up = false;\n                }\n            } else {\n                if (row + 1 < m && col - 1 >= 0) {\n                    row++;\n                    col--;\n                } else if (row + 1 < m && col - 1 < 0) {\n                    row++;\n                    up = true;\n                } else if (row + 1 >= m && col - 1 >= 0) {\n                    col++;\n                    up = true;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "842", "path": "output2\\java\\Medium\\842-next-greater-element-ii.java", "hypo_code": "class Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        Arrays.fill(result, -1);\n        for (int i = 0; i < 2 * n; i++) {\n            int index = i % n;\n            while (!stack.isEmpty() && nums[index] > nums[stack.peek()]) {\n                result[stack.pop()] = nums[index];\n            }\n            stack.push(index);\n        }\n        return result;\n    }\n}"}
{"id": "843", "path": "output2\\java\\Medium\\843-most-frequent-subtree-sum.java", "hypo_code": "class Solution {\n    public int[] findFrequentTreeSum(TreeNode root) { \n        Map<Integer, Integer> map = new HashMap<>();\n        helper(root, map);\n        int max = 0;\n        for (int key : map.keySet()) {\n            max = Math.max(max, map.get(key));\n        }\n        List<Integer> list = new ArrayList<>();\n        for (int key : map.keySet()) {\n            if (map.get(key) == max) {\n                list.add(key);\n            }\n        }\n        int[] result = new int[list.size()];\n        int index = 0;\n        for (int num : list) {\n            result[index++] = num;\n        }\n        return result;\n    }\n    private int helper(TreeNode root, Map<Integer, Integer> map) {\n        if (root == null) {\n            return 0;\n        }\n        int left = helper(root.left, map);\n        int right = helper(root.right, map);\n        int sum = left + right + root.val;\n        map.put(sum, map.getOrDefault(sum, 0) + 1);\n        return sum;\n    }\n}"}
{"id": "844", "path": "output2\\java\\Medium\\844-find-bottom-left-tree-value.java", "hypo_code": "class Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        int result = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            result = q.peek().val;\n            while (size > 0) {\n                TreeNode node = q.poll();\n                if (node.left != null) {\n                    q.offer(node.left);\n                } \n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n                size--;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "845", "path": "output2\\java\\Medium\\845-find-largest-value-in-each-tree-row.java", "hypo_code": "class Solution {\n    public List<Integer> largestValues(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        int max = Integer.MIN_VALUE;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            max = Integer.MIN_VALUE;\n            while (size > 0) {\n                TreeNode node = q.poll();\n                max = Math.max(max, node.val);\n                if (node.left != null) {\n                    q.offer(node.left);\n                } \n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n                size--;\n            }\n            result.add(max);\n        }\n        return result;\n    }\n}"}
{"id": "846", "path": "output2\\java\\Medium\\846-longest-palindromic-subsequence.java", "hypo_code": "class Solution {\n    public int longestPalindromeSubseq(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n]; \n        for (int i = n - 1; i >= 0; i--) {\n            dp[i][i] = 1; \n            for (int j = i + 1; j < n; j++) {\n                \n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i + 1][j - 1] + 2; \n                } else {\n                \n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n                }\n            } \n        }\n        return dp[0][n - 1];\n    }\n}"}
{"id": "847", "path": "output2\\java\\Medium\\847-coin-change-ii.java", "hypo_code": "class Solution {\n    public int change(int amount, int[] coins) {\n        int n = coins.length;\n        int[] dp = new int[amount + 1]; \n        dp[0] = 1;\n        for (int coin : coins) {\n            for (int i = 0; i <= amount; i++) {\n                if (i - coin >= 0) {\n                    dp[i] += dp[i - coin];\n                }\n            }\n        }\n        return dp[amount];\n    }\n}"}
{"id": "849", "path": "output2\\java\\Medium\\849-longest-uncommon-subsequence-ii.java", "hypo_code": "class Solution {\n    public int findLUSlength(String[] strs) {\n        int n = strs.length;\n        int result = -1;\n        for (int i = 0; i < n; i++) {\n            boolean flag = true;\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    continue;\n                }\n                if (isSubsequence(strs[i], strs[j])) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result = Math.max(result, strs[i].length());\n            }\n        }\n        return result;\n    }\n}"}
{"id": "850", "path": "output2\\java\\Medium\\850-continuous-subarray-sum.java", "hypo_code": "class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        int n = nums.length;\n        int[] sums = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            sums[i + 1] = sums[i] + nums[i];\n            if (i >= 1 && sums[i + 1] % k == 0) {\n                return true;\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = i + 2; j <= n; j++) {\n                if ((sums[j] - sums[i]) % k == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}"}
{"id": "851", "path": "output2\\java\\Medium\\851-longest-word-in-dictionary-through-deleting.java", "hypo_code": "class Solution {\n    public String findLongestWord(String s, List<String> dictionary) {\n        String result = \"\";\n        for (String str : dictionary) {\n            if (isSubsequence(str, s)) {\n                if (str.length() > result.length()) {\n                    result = str;\n                } else if (str.length() == result.length()) {\n                    result = result.compareTo(str) <= 0 ? result : str;\n                }\n            }\n        }\n        return result;\n    }\n    private boolean isSubsequence(String str, String s) {\n        int index = 0;\n        for (char c : s.toCharArray()) {\n            if (c == str.charAt(index)) {\n                index++;\n            }\n            if (index == str.length()) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}
{"id": "852", "path": "output2\\java\\Medium\\852-contiguous-array.java", "hypo_code": "class Solution {\n    public int findMaxLength(int[] nums) {\n        int result = 0;\n        int n = nums.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i] == 0 ? -1 : 1;\n            if (map.containsKey(sum)) {\n                result = Math.max(result, i - map.get(sum));\n            } else {\n                map.put(sum, i);\n            }\n        }\n        return result;\n    }\n}"}
{"id": "853", "path": "output2\\java\\Medium\\853-beautiful-arrangement.java", "hypo_code": "class Solution {\n    public int countArrangement(int n) {\n        public int countArrangement(int n) {\n        int[] result = new int[1];\n        int[] nums = new int[n];\n        for (int i = 1; i <= n; i++) {\n            nums[i - 1] = i;\n        }\n        helper(nums, 0, result);\n        return result[0];\n    }\n    public void helper(int[] nums, int index, int[] result) {\n        if (index == nums.length) {\n            result[0]++;\n            return;\n        }\n        for (int i = index; i < nums.length; i++) {\n            if (nums[i] % (index + 1) == 0 || (index + 1) % nums[i] == 0) {\n                swap(nums, i, index);\n                helper(nums, index + 1, result);\n                swap(nums, i, index);\n            }\n        }\n    }\n    public void swap(int[] nums, int i, int j) {\n        if (i == j) return;\n        int val = nums[i];\n        nums[i] = nums[j];\n        nums[j] = val;\n    }\n}"}
{"id": "855", "path": "output2\\java\\Medium\\855-minesweeper.java", "hypo_code": "class Solution {\n    public char[][] updateBoard(char[][] board, int[] click) {\n        int m = board.length, n = board[0].length;\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(click);\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int row = cur[0], col = cur[1];\n            if (board[row][col] == 'M') {\n                board[row][col] = 'X';\n                return board;\n            } else if (board[row][col] == 'E') {\n                int count = 0;\n                for (int i = row - 1; i <= row + 1; i++) {\n                    for (int j = col - 1; j <= col + 1; j++) {\n                        if (i >= 0 && i < m && j >= 0 && j < n && board[i][j] == 'M') {\n                            count++;\n                        }\n                    }\n                }\n                if (count > 0) {\n                    board[row][col] = (char)('0' + count);\n                } else {\n                    board[row][col] = 'B';\n                    for (int i = row - 1; i <= row + 1; i++) {\n                        for (int j = col - 1; j <= col + 1; j++) {\n                            if (i >= 0 && i < m && j >= 0 && j < n && board[i][j] == 'E') {\n                                queue.offer(new int[]{i, j});\n                                board[i][j] = 'B';\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return board;\n    }\n}"}
{"id": "856", "path": "output2\\java\\Medium\\856-k-diff-pairs-in-an-array.java", "hypo_code": "class Solution {\n    public int findPairs(int[] nums, int k) {\n        int n = nums.length;\n        int result = 0;\n        Arrays.sort(nums);\n        int i = 0, j = 1;\n        while (i < n && j < n) {\n            if (i == j) {\n                j++;\n            } else if (nums[j] - nums[i] == k) {\n                result++;\n                i++;\n                j++;\n                while (j < n && nums[j] == nums[j - 1]) {\n                    j++;\n                }\n            } else if (nums[j] - nums[i] > k) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "858", "path": "output2\\java\\Medium\\858-complex-number-multiplication.java", "hypo_code": "class Solution {\n    public String complexNumberMultiply(String num1, String num2) {\n        String[] s1 = num1.split(\"\\\\+\");\n        String[] s2 = num2.split(\"\\\\+\");\n        int a = Integer.parseInt(s1[0]);\n        int b = Integer.parseInt(s1[1].substring(0, s1[1].length() - 1));\n        int c = Integer.parseInt(s2[0]);\n        int d = Integer.parseInt(s2[1].substring(0, s2[1].length() - 1));\n        return (a * c - b * d) + \"+\" + (a * d + b * c) + \"i\";\n\n    }\n}"}
{"id": "859", "path": "output2\\java\\Medium\\859-convert-bst-to-greater-tree.java", "hypo_code": "class Solution {\n    public TreeNode convertBST(TreeNode root) {\n        public TreeNode convertBST(TreeNode root) { \n        helper(root, 0);\n        return root;\n    }\n    private int helper(TreeNode root, int sum) {\n        if (root == null) {\n            return sum;\n        }\n        int right = helper(root.right, sum);\n        root.val += right;\n        int left = helper(root.left, root.val);\n        return left;\n    }\n}"}
{"id": "860", "path": "output2\\java\\Medium\\860-minimum-time-difference.java", "hypo_code": "class Solution {\n    public int findMinDifference(List<String> timePoints) {\n        int n = timePoints.size();\n        int[] minutes = new int[n];\n        for (int i = 0; i < n; i++) {\n            String[] time = timePoints.get(i).split(\":\");\n            minutes[i] = Integer.parseInt(time[0]) * 60 + Integer.parseInt(time[1]);\n        }\n        Arrays.sort(minutes);\n        int result = Integer.MAX_VALUE;\n        for (int i = 1; i < n; i++) {\n            result = Math.min(result, minutes[i] - minutes[i - 1]);\n        }\n        result = Math.min(result, 24 * 60 - minutes[n - 1] + minutes[0]);\n        return result;\n    }\n}"}
{"id": "861", "path": "output2\\java\\Medium\\861-single-element-in-a-sorted-array.java", "hypo_code": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int n = nums.length;\n        int left = 0, right = n - 1;\n        int mid = 0;\n        while (left < right) {\n            mid = (left + right) / 2;\n            if (mid % 2 == 1) {\n                mid--;\n            }\n            if (nums[mid] == nums[mid + 1]) {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        }\n        return nums[left];\n    }\n}"}
{"id": "862", "path": "output2\\java\\Medium\\862-01-matrix.java", "hypo_code": "class Solution {\n    public int[][] updateMatrix(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[][] result = new int[m][n];\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            if (mat[i][0] == 0) {\n                queue.offer(new int[]{i, 0});\n                visited[i][0] = true;\n                result[i][0] = 0;\n            }\n            if (mat[i][n - 1] == 0) {\n                queue.offer(new int[]{i, n - 1});\n                visited[i][n - 1] = true;\n                result[i][n - 1] = 0;\n            }\n        }\n        for (int j = 1; j < n - 1; j++) {\n            if (mat[0][j] == 0) {\n                queue.offer(new int[]{0, j});\n                visited[0][j] = true;\n                result[0][j] = 0;\n            }\n            if (mat[m - 1][j] == 0) {\n                queue.offer(new int[]{m - 1, j});\n                visited[m - 1][j] = true;\n                result[m - 1][j] = 0;\n            }\n        }\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            for (int[] dir : dirs) {\n                int x = cur[0] + dir[0];\n                int y = cur[1] + dir[1];\n                if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\n                    queue.offer(new int[]{x, y});\n                    visited[x][y] = true;\n                    result[x][y] = result[cur[0]][cur[1]] + 1;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "863", "path": "output2\\java\\Medium\\863-number-of-provinces.java", "hypo_code": "class Solution {\n    public int findCircleNum(int[][] isConnected) {\n        int n = isConnected.length;\n        int[] visited = new int[n];\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (visited[i] == 0) {\n                dfs(i, isConnected, visited);\n                result++;\n            }\n        }\n        return result;\n    }\n\n    private void dfs(int i, int[][] isConnected, int[] visited) {\n        for (int j = 0; j < isConnected.length; j++) {\n            if (isConnected[i][j] == 1 && visited[j] == 0) {\n                visited[j] = 1;\n                dfs(j, isConnected, visited);\n            }\n        }\n    }\n}"}
{"id": "865", "path": "output2\\java\\Medium\\865-optimal-division.java", "hypo_code": "class Solution {\n    public String optimalDivision(int[] nums) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(nums[0]);\n        if (nums.length == 1) {\n            return sb.toString();\n        }\n        sb.append('/');\n        if (nums.length == 2) {\n            sb.append(nums[1]);\n            return sb.toString();\n        }\n        sb.append('(');\n        for (int i = 1; i < nums.length; i++) {\n            sb.append(nums[i]);\n            sb.append('/');\n        }\n        sb.deleteCharAt(sb.length() - 1);\n        sb.append(')');\n        return sb.toString();\n    }\n}"}
{"id": "866", "path": "output2\\java\\Medium\\866-brick-wall.java", "hypo_code": "class Solution {\n    public int leastBricks(List<List<Integer>> wall) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int result = 0;\n        for (List<Integer> list : wall) {\n            int sum = 0;\n            for (int i = 0; i < list.size() - 1; i++) {\n                sum += list.get(i);\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\n                result = Math.max(result, map.get(sum));\n            }\n        }\n        return wall.size() - result;\n    }\n}"}
{"id": "867", "path": "output2\\java\\Medium\\867-next-greater-element-iii.java", "hypo_code": "class Solution {\n    public int nextGreaterElement(int n) {\n        char[] nums = String.valueOf(n).toCharArray();\n        int len = nums.length;\n        int i = len - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        if (i < 0) {\n            return -1;\n        }\n        int j = len - 1;\n        while (j >= 0 && nums[j] <= nums[i]) {\n            j--;\n        }\n        swap(nums, i, j);\n        reverse(nums, i + 1, len - 1);\n        long result = Long.parseLong(new String(nums));\n        return result > Integer.MAX_VALUE ? -1 : (int) result;\n    }\n    private void reverse(char[] nums, int start, int end) {\n        while (start < end) {\n            swap(nums, start++, end--);\n        }\n    }\n    private void swap(char[] nums, int i, int j) {\n        nums[i] ^= nums[j];\n        nums[j] ^= nums[i];\n        nums[i] ^= nums[j];\n    }\n}"}
{"id": "869", "path": "output2\\java\\Medium\\869-subarray-sum-equals-k.java", "hypo_code": "class Solution {\n    public int subarraySum(int[] nums, int k) {\n        int n = nums.length;\n        int[] preSum = new int[n + 1];\n        preSum[0] = 0;\n        int result = 0;\n        for (int i = 1; i <= n; i++) {\n            preSum[i] = nums[i - 1] + preSum[i - 1];\n            for (int j = 0; j < i; j++) {\n                if (preSum[i] - preSum[j] == k) {\n                    result++;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "870", "path": "output2\\java\\Medium\\870-array-nesting.java", "hypo_code": "class Solution {\n    public int arrayNesting(int[] nums) {\n        int n = nums.length;\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] < 0) {\n                continue;\n            }\n            int index = i;\n            int count = 0;\n            while (nums[index] >= 0) {\n                count++;\n                int temp = nums[index];\n                nums[index] = -1;\n                index = temp;\n            }\n            result = Math.max(result, count);\n        }\n        return result;\n    }\n}"}
{"id": "871", "path": "output2\\java\\Medium\\871-permutation-in-string.java", "hypo_code": "class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        int[] count = new int[26];\n        for (char c : s1.toCharArray()) {\n            count[c - 'a']++;\n        }\n        int left = 0;\n        int right = 0;\n        int total = s1.length();\n        while (right < s2.length()) {\n            if (count[s2.charAt(right) - 'a'] > 0) {\n                total--;\n            }\n            count[s2.charAt(right) - 'a']--;\n            if (right - left + 1 > s1.length()) {\n                if (count[s2.charAt(left) - 'a'] >= 0) {\n                    total++;\n                }\n                count[s2.charAt(left) - 'a']++;\n                left++;\n            }\n            if (total == 0) {\n                return true;\n            }\n            right++;\n        }\n        return false;\n    }\n}"}
{"id": "873", "path": "output2\\java\\Medium\\873-out-of-boundary-paths.java", "hypo_code": "class Solution {\n    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n        int[][][] dp = new int[m][n][maxMove + 1];\n        int mod = 1000000007;\n        int[][] directions = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\n        for (int k = 1; k <= maxMove; k++) {\n            for (int i = 0; i < m; i++) {\n                for (int j = 0;j < n; j++) {\n                    for (int[] direction : directions) {\n                        int x = i + direction[0];\n                        int y = j + direction[1];\n                        if (x < 0 || x >= m || y < 0 || y >= n) {\n                            dp[i][j][k] += 1;\n                        } else {\n                            dp[i][j][k] = (dp[i][j][k] + dp[x][y][k - 1]) % mod;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[startRow][startColumn][maxMove];\n    }\n}"}
{"id": "874", "path": "output2\\java\\Medium\\874-shortest-unsorted-continuous-subarray.java", "hypo_code": "class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int n = nums.length;\n        int max = nums[0], min = nums[n - 1];\n        int left = -1, right = -2;\n        for (int i = 0; i < n; i++) {\n            max = Math.max(max, nums[i]);\n            min = Math.min(min, nums[n - 1 - i]);\n            if (nums[i] < max) {\n                right = i;\n            }\n            if (nums[n - 1 - i] > min) {\n                left = n - 1 - i;\n            }\n        }\n        return right - left + 1;\n    }\n}"}
{"id": "875", "path": "output2\\java\\Medium\\875-delete-operation-for-two-strings.java", "hypo_code": "class Solution {\n    public int minDistance(String word1, String word2) {\n        int[][] dp = new int[word1.length()][word2.length()];\n        return word1.length() + word2.length() - 2 * lcs(word1, word2, word1.length() - 1, word2.length() - 1, dp);\n    }\n    private int lcs(String word1, String word2, int i, int j, int[][] dp) {\n        if (i < 0 || j < 0) {\n            return 0;\n        }\n        if (dp[i][j] > 0) {\n            return dp[i][j];\n        }\n        if (word1.charAt(i) == word2.charAt(j)) {\n            dp[i][j] = 1 + lcs(word1, word2, i - 1, j - 1, dp);\n        } else {\n            dp[i][j] = Math.max(lcs(word1, word2, i - 1, j, dp), lcs(word1, word2, i, j - 1, dp));\n        }\n        return dp[i][j];\n    }\n}"}
{"id": "877", "path": "output2\\java\\Medium\\877-fraction-addition-and-subtraction.java", "hypo_code": "class Solution {\n    public String fractionAddition(String expression) {\n        List<Integer> numerators = new ArrayList<>();\n        List<Integer> denominators = new ArrayList<>();\n        int i = 0;\n        while (i < expression.length()) {\n            int j = i;\n            while (j < expression.length() && expression.charAt(j) != '/') {\n                j++;\n            }\n            numerators.add(Integer.parseInt(expression.substring(i, j)));\n            i = j + 1;\n            j = i;\n            while (j < expression.length() && expression.charAt(j) != '+' && expression.charAt(j) != '-') {\n                j++;\n            }\n            denominators.add(Integer.parseInt(expression.substring(i, j)));\n            i = j;\n        }\n        int lcm = 1;\n        for (int denominator : denominators) {\n            lcm = lcm(lcm, denominator);\n        }\n        int numerator = 0;\n        for (int i = 0; i < numerators.size(); i++) {\n            numerator += numerators.get(i) * (lcm / denominators.get(i));\n        }\n        if (numerator == 0) {\n            return \"0/1\";\n        }\n        int gcd = gcd(Math.abs(numerator), lcm);\n        return (numerator / gcd) + \"/\" + (lcm / gcd);\n    }\n    private int gcd(int a, int b) {\n        if (a < b) {\n            return gcd(b, a);\n        }\n        if (a % b == 0) {\n            return b;\n        }\n        return gcd(a % b, b);\n    }\n    private int lcm(int a, int b) {\n        return a * b / gcd(a, b);\n    }\n}"}
{"id": "878", "path": "output2\\java\\Medium\\878-valid-square.java", "hypo_code": "class Solution {\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        int[] length = new int[6];\n        length[0] = getLength(p1, p2);\n        length[1] = getLength(p1, p3);\n        length[2] = getLength(p1, p4);\n        length[3] = getLength(p2, p3);\n        length[4] = getLength(p2, p4);\n        length[5] = getLength(p3, p4);\n        Arrays.sort(length);\n        return length[0] > 0 && length[0] == length[1] && length[1] == length[2] && length[2] == length[3] && length[4] == length[5];\n\n    }\n    private int getLength(int[] p1, int[] p2) {\n        return (p1[0] - p2[0]) * (p1[0] - p2[0])\n            + (p1[1] - p2[1]) * (p1[1] - p2[1]);\n    }\n}"}
{"id": "881", "path": "output2\\java\\Medium\\881-find-duplicate-file-in-system.java", "hypo_code": "class Solution {\n    public List<List<String>> findDuplicate(String[] paths) {\n        List<List<String>> result = new ArrayList<>();\n        Map<String, List<String>> map = new HashMap<>();\n        for (String path : paths) {\n            String[] strs = path.split(\" \");\n            for (int i = 1; i < strs.length; i++) {\n                int index = strs[i].indexOf(\"(\");\n                String content = strs[i].substring(index + 1, strs[i].length() - 1);\n                String fileName = strs[0] + \"/\" + strs[i].substring(0, index);\n                map.putIfAbsent(content, new ArrayList<>());\n                map.get(content).add(fileName);\n            }\n        }\n        for (List<String> list : map.values()) {\n            if (list.size() > 1) {\n                result.add(list);\n            }\n        }\n        return result;\n    }\n}"}
{"id": "882", "path": "output2\\java\\Medium\\882-valid-triangle-number.java", "hypo_code": "class Solution {\n    public int triangleNumber(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int result = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (nums[i] == 0) continue;\n            int k = i + 2;\n            for (int j = i + 1; j < n - 1; j++) {\n                while (k < n && nums[i] + nums[j] > nums[k]) {\n                    k++;\n                }\n                result += k - j - 1;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "883", "path": "output2\\java\\Medium\\883-task-scheduler.java", "hypo_code": "class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        int[] counts = new int[26];\n        int max = 0;\n        for (char task : tasks) {\n            counts[task - 'A']++;\n            max = Math.max(max, counts[task - 'A']);\n        }\n        int maxCount = 0;\n        for (int count : counts) {\n            if (count == max) {\n                maxCount++;\n            }\n        }\n        return Math.max((max - 1) * (n + 1) + maxCount, tasks.length);\n\n    }\n}"}
{"id": "885", "path": "output2\\java\\Medium\\885-add-one-row-to-tree.java", "hypo_code": "class Solution {\n    public TreeNode addOneRow(TreeNode root, int val, int depth) {\n        if (depth == 1) {\n            TreeNode node = new TreeNode(val);\n            node.left = root;\n            return node;\n        }\n        helper(root, val, depth, 1);\n        return root;\n    }\n    private void helper(TreeNode root, int val, int depth, int curDepth) {\n        if (root == null) {\n            return;\n        }\n        if (curDepth == depth - 1) {\n            TreeNode left = root.left;\n            TreeNode right = root.right;\n            root.left = new TreeNode(val);\n            root.right = new TreeNode(val);\n            root.left.left = left;\n            root.right.right = right;\n            return;\n        }\n        helper(root.left, val, depth, curDepth + 1);\n        helper(root.right, val, depth, curDepth + 1);\n\n    }\n}"}
{"id": "887", "path": "output2\\java\\Medium\\887-sum-of-square-numbers.java", "hypo_code": "class Solution {\n    public boolean judgeSquareSum(int c) {\n        int left = 0;\n        int right = (int) Math.sqrt(c);\n        while (left <= right) {\n            int tmp = left * left + right * right;\n            if (tmp == c) {\n                return true;\n            } else if (tmp < c) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return false;\n    }\n}"}
{"id": "888", "path": "output2\\java\\Medium\\888-exclusive-time-of-functions.java", "hypo_code": "class Solution {\n    public int[] exclusiveTime(int n, List<String> logs) {\n        int[] result = new int[n];\n        int prev = 0;\n        Stack<Integer> stack = new Stack<>();\n        for (String log : logs) {\n            String[] strs = log.split(\":\");\n            int id = Integer.parseInt(strs[0]);\n            int timestamp = Integer.parseInt(strs[2]);\n            if (strs[1].equals(\"start\")) {\n                if (!stack.isEmpty()) {\n                    result[stack.peek()] += timestamp - prev;\n                }\n                stack.push(id);\n                prev = timestamp;\n            } else {\n                result[stack.pop()] += timestamp - prev + 1;\n                prev = timestamp + 1;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "889", "path": "output2\\java\\Medium\\889-shopping-offers.java", "hypo_code": "class Solution {\n    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {\n        int result = 0;\n        int n = price.size();\n        for (int i = 0; i < n; i++) {\n            result += price.get(i) * needs.get(i);\n        }\n        for (List<Integer> offer : special) {\n            boolean isValid = true;\n            for (int i = 0; i < n; i++) {\n                if (needs.get(i) < offer.get(i)) {\n                    isValid = false;\n                    break;\n                }\n            }\n            if (isValid) {\n                List<Integer> nextNeeds = new ArrayList<>();\n                for (int i = 0; i < n; i++) {\n                    nextNeeds.add(needs.get(i) - offer.get(i));\n                }\n                result = Math.min(result, offer.get(n) + shoppingOffers(price, special, nextNeeds));\n            }\n        }\n        return result;\n    }\n}\n\n=======\nSuggestion 2\n\n                Map<List<Integer>, Integer> map = new HashMap<>();\n        return dfs(price, special, needs, map);\n    }\n    private int dfs(List<Integer> price, List<List<Integer>> special, List<Integer> needs, Map<List<Integer>, Integer> map) {\n        if (map.containsKey(needs)) {\n            return map.get(needs);\n        }\n        int result = 0;\n        for (int i = 0; i < needs.size(); i++) {\n            result += needs.get(i) * price.get(i);\n        }\n        for (List<Integer> offer : special) {\n            List<Integer> tmp = new ArrayList<>();\n            boolean isValid = true;\n            for (int i = 0; i < needs.size(); i++) {\n                int remain = needs.get(i) - offer.get(i);\n                if (remain < 0) {\n                    isValid = false;\n                    break;\n                }\n                tmp.add(remain);\n            }\n            if (isValid) {\n                result = Math.min(result, offer.get(offer.size() - 1) + dfs(price, special, tmp, map));\n            }\n        }\n        map.put(needs, result);\n        return result;\n    }\n}"}
{"id": "890", "path": "output2\\java\\Medium\\890-solve-the-equation.java", "hypo_code": "class Solution {\n    public String solveEquation(String equation) {\n        int[] left = evaluate(equation.split(\"=\")[0]);\n        int[] right = evaluate(equation.split(\"=\")[1]);\n        if (left[0] == right[0] && left[1] == right[1]) {\n            return \"Infinite solutions\";\n        }\n        if (left[0] == right[0]) {\n            return \"No solution\";\n        }\n        return \"x=\" + (right[1] - left[1]) / (left[0] - right[0]);\n    }\n    private int[] evaluate(String expression) {\n        String[] tokens = expression.split(\"(?=[+-])\");\n        int[] result = new int[2];\n        for (String token : tokens) {\n            if (token.equals(\"+x\") || token.equals(\"x\")) {\n                result[0]++;\n            } else if (token.equals(\"-x\")) {\n                result[0]--;\n            } else if (token.contains(\"x\")) {\n                result[0] += Integer.parseInt(token.substring(0, token.length() - 1));\n            } else {\n                result[1] += Integer.parseInt(token);\n            }\n        }\n        return result;\n    }\n}"}
{"id": "892", "path": "output2\\java\\Medium\\892-maximum-length-of-pair-chain.java", "hypo_code": "class Solution {\n    public int findLongestChain(int[][] pairs) {\n        int n = pairs.length;\n        Arrays.sort(pairs, (a, b) -> {\n            if (a[0] != b[0]) {\n                return Integer.compare(a[0], b[0]);\n            } else {\n                return Integer.compare(a[1], b[1]);\n            }\n        });\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        int result = 1;\n        for (int i = 1; i < n; i++) {\n            int cur = pairs[i][0];\n            for (int j = 0; j < i; j++) {\n                if (cur > pairs[j][1]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            result = Math.max(result, dp[i]);\n        }\n        return result;\n    }\n}"}
{"id": "893", "path": "output2\\java\\Medium\\893-palindromic-substrings.java", "hypo_code": "class Solution {\n    public int countSubstrings(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int result = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j <= n - 1; j++) {\n                if (i > j) {\n                    dp[i][j] = false;\n                } else if (i == j) {\n                    dp[i][j] = true;\n                } else {\n                    dp[i][j] = (s.charAt(i) == s.charAt(j)) && (i + 1 == j || dp[i + 1][j - 1]);\n                }\n                if (dp[i][j]) {\n                    result++;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "894", "path": "output2\\java\\Medium\\894-replace-words.java", "hypo_code": "class Solution {\n    public String replaceWords(List<String> dictionary, String sentence) {\n        Trie trie = new Trie();\n        for (String word : dictionary) {\n            trie.insert(word);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String word : sentence.split(\" \")) {\n            sb.append(trie.getShortestPrefix(word));\n            sb.append(\" \");\n        }\n        return sb.substring(0, sb.length() - 1);\n    }\n    class TrieNode {\n        TrieNode[] children;\n        boolean isWord;\n        public TrieNode() {\n            children = new TrieNode[26];\n        }\n    }\n    class Trie {\n        TrieNode root;\n        public Trie() {\n            root = new TrieNode();\n        }\n        public void insert(String word) {\n            TrieNode cur = root;\n            for (char c : word.toCharArray()) {\n                int index = c - 'a';\n                if (cur.children[index] == null) {\n                    cur.children[index] = new TrieNode();\n                }\n                cur = cur.children[index];\n            }\n            cur.isWord = true;\n        }\n        public String getShortestPrefix(String word) {\n            TrieNode cur = root;\n            int i = 0;\n            for (char c : word.toCharArray()) {\n                int index = c - 'a';\n                if (cur.children[index] == null) {\n                    break;\n                }\n                cur = cur.children[index];\n                i++;\n                if (cur.isWord) {\n                    return word.substring(0, i);\n                }\n            }\n            return word;\n        }\n    }\n}"}
{"id": "895", "path": "output2\\java\\Medium\\895-dota2-senate.java", "hypo_code": "class Solution {\n    public String predictPartyVictory(String senate) {\n        Queue<Integer> radiant = new LinkedList<>();\n        Queue<Integer> dire = new LinkedList<>();\n        int n = senate.length();\n        for (int i = 0; i < n; i++) {\n            if (senate.charAt(i) == 'R') {\n                radiant.offer(i);\n            } else {\n                dire.offer(i);\n            }\n        }\n        while (!radiant.isEmpty() && !dire.isEmpty()) {\n            int radiantIndex = radiant.poll();\n            int direIndex = dire.poll();\n            if (radiantIndex < direIndex) {\n                radiant.offer(radiantIndex + n);\n            } else {\n                dire.offer(direIndex + n);\n            }\n        }\n        return radiant.isEmpty() ? \"Dire\" : \"Radiant\";\n    }\n}"}
{"id": "896", "path": "output2\\java\\Medium\\896-2-keys-keyboard.java", "hypo_code": "class Solution {\n    public int minSteps(int n) {\n        int result = 0;\n        for (int i = 2; i <= n; i++) {\n            while (n % i == 0) {\n                result += i;\n                n /= i;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "897", "path": "output2\\java\\Medium\\897-find-duplicate-subtrees.java", "hypo_code": "class Solution {\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n        public List<TreeNode> findDuplicateSubtrees(TreeNode root) { \n        List<TreeNode> result = new ArrayList<>();\n        Map<String, Integer> map = new HashMap<>();\n        helper(root, map, result);\n        return result;\n    }\n    private String helper(TreeNode root, Map<String, Integer> map, List<TreeNode> result) {\n        if (root == null) {\n            return \"#\";\n        }\n        String left = helper(root.left, map, result);\n        String right = helper(root.right, map, result);\n        String cur = root.val + \",\" + left + \",\" + right;\n        map.put(cur, map.getOrDefault(cur, 0) + 1);\n        if (map.get(cur) == 2) {\n            result.add(root);\n        }\n        return cur;\n    }\n}"}
{"id": "898", "path": "output2\\java\\Medium\\898-maximum-binary-tree.java", "hypo_code": "class Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        \n\t\t\n\t\t\n        return helper(nums, 0, nums.length - 1);\n    }\n    private TreeNode helper(int[] nums, int left, int right) {\n\t\tif (left > right) {\n\t\t\treturn null;\n\t\t}\n\t\tint max = nums[left];\n\t\tint index = left;\n\t\tfor (int i = left + 1; i <= right; i++) {\n\t\t\tif (nums[i] > max) {\n\t\t\t\tmax = nums[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tTreeNode root = new TreeNode(max);\n\t\troot.left = helper(nums, left, index - 1);\n\t\troot.right = helper(nums, index + 1, right);\n\t\treturn root;\n    }\n    \n}"}
{"id": "899", "path": "output2\\java\\Medium\\899-print-binary-tree.java", "hypo_code": "class Solution {\n    public List<List<String>> printTree(TreeNode root) {\n        int height = getHeight(root);\n        int rows = height;\n        int cols = (int)Math.pow(2, height) - 1;\n        List<List<String>> result = new ArrayList<>();\n        for (int i = 0; i < rows; i++) {\n            List<String> tmp = new ArrayList<>();\n            for (int j = 0; j < cols; j++) {\n                tmp.add(\"\");\n            }\n            result.add(tmp);\n        }\n        helper(root, result, 0, 0, cols - 1);\n        return result;\n    }\n    private void helper(TreeNode root, List<List<String>> result, int row, int left, int right) {\n        if (root == null) {\n            return;\n        }\n        result.get(row).set((left + right) / 2, String.valueOf(root.val));\n        helper(root.left, result, row + 1, left, (left + right) / 2 - 1);\n        helper(root.right, result, row + 1, (left + right) / 2 + 1, right);\n    }\n    private int getHeight(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftHeight = getHeight(root.left) + 1;\n        int rightHeight = getHeight(root.right) + 1;\n        return Math.max(leftHeight, rightHeight);\n    }\n}"}
{"id": "900", "path": "output2\\java\\Medium\\900-find-k-closest-elements.java", "hypo_code": "class Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        int n = arr.length;\n        List<Integer> result = new ArrayList<>();\n        int index = Arrays.binarySearch(arr, x);\n        if (index < 0) {\n            index = -index - 1;\n        }\n        int left = index - 1, right = index;\n        while (k > 0) {\n            if (left >= 0 && right < n) {\n                if (x - arr[left] <= arr[right] - x) {\n                    result.add(arr[left--]);\n                } else {\n                    result.add(arr[right++]);\n                }\n            } else if (left >= 0) {\n                result.add(arr[left--]);\n            } else {\n                result.add(arr[right++]);\n            }\n            k--;\n        }\n        Collections.sort(result);\n        return result;\n    }\n}"}
{"id": "901", "path": "output2\\java\\Medium\\901-split-array-into-consecutive-subsequences.java", "hypo_code": "class Solution {\n    public boolean isPossible(int[] nums) {\n        int n = nums.length;\n        Map<Integer, Integer> freq = new HashMap<>();\n        Map<Integer, Integer> need = new HashMap<>();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n        for (int num : nums) {\n            if (freq.get(num) == 0) {\n                continue;\n            }\n            if (need.getOrDefault(num, 0) > 0) {\n                need.put(num, need.get(num) - 1);\n                need.put(num + 1, need.getOrDefault(num + 1, 0) + 1);\n            } else if (freq.getOrDefault(num + 1, 0) > 0 && freq.getOrDefault(num + 2, 0) > 0) {\n                freq.put(num + 1, freq.get(num + 1) - 1);\n                freq.put(num + 2, freq.get(num + 2) - 1);\n                need.put(num + 3, need.getOrDefault(num + 3, 0) + 1);\n            } else {\n                return false;\n            }\n            freq.put(num, freq.get(num) - 1);\n        }\n        return true;\n    }\n}"}
{"id": "902", "path": "output2\\java\\Medium\\902-maximum-width-of-binary-tree.java", "hypo_code": "class Solution {\n    public int widthOfBinaryTree(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        Queue<Integer> index = new LinkedList<>();\n        index.offer(1);\n        int result = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            int left = 0;\n            int right = 0;\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                int cur = index.poll();\n                if (i == 0) {\n                    left = cur;\n                }\n                if (i == size - 1) {\n                    right = cur;\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                    index.offer(cur * 2);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                    index.offer(cur * 2 + 1);\n                }\n            }\n            result = Math.max(result, right - left + 1);\n        }\n        return result;\n    }\n}"}
{"id": "903", "path": "output2\\java\\Medium\\903-non-decreasing-array.java", "hypo_code": "class Solution {\n    public boolean checkPossibility(int[] nums) {\n        int n = nums.length;\n        int count = 0;\n        for (int i = 0; i < n - 1; i++) {\n            int num1 = nums[i], num2 = nums[i + 1];\n            if (num1 > num2) {\n                count++;\n                if (count > 1) {\n                    return false;\n                }\n                if (i - 1 >= 0 && num2 < nums[i - 1]) {\n                    nums[i + 1] = num1;\n                }\n            }\n        }\n        return true;\n    }\n}"}
{"id": "904", "path": "output2\\java\\Medium\\904-beautiful-arrangement-ii.java", "hypo_code": "class BeautifulArrangementIi {\n    public int[] constructArray(int n, int k) {\n        int[] res = new int[n];\n        int i = 0;\n        int l = 1;\n        int r = n;\n        while(l <= r){\n            if(k > 1){\n                res[i++] = k-- % 2 == 1 ? l++ : r--;\n            }else{\n                res[i++] = l++;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "905", "path": "output2\\java\\Medium\\905-trim-a-binary-search-tree.java", "hypo_code": "class TrimABinarySearchTree {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        if(root == null){\n            return null;\n        }\n        if(root.val < low){\n            return trimBST(root.right, low, high);\n        }\n        if(root.val > high){\n            return trimBST(root.left, low, high);\n        }\n        root.left = trimBST(root.left, low, high);\n        root.right = trimBST(root.right, low, high);\n        return root;\n        \n    }\n}"}
{"id": "906", "path": "output2\\java\\Medium\\906-maximum-swap.java", "hypo_code": "class MaximumSwap {\n    public int maximumSwap(int num) {\n        char[] arr = Integer.toString(num).toCharArray();\n        int n = arr.length;\n        int[] max = new int[n];\n        max[n - 1] = n - 1;\n        for(int i = n - 2; i >= 0; i--){\n            if(arr[i] > arr[max[i + 1]]){\n                max[i] = i;\n            }else{\n                max[i] = max[i + 1];\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(arr[i] < arr[max[i]]){\n                char temp = arr[i];\n                arr[i] = arr[max[i]];\n                arr[max[i]] = temp;\n                break;\n            }\n        }\n        return Integer.parseInt(new String(arr));\n        \n        \n    }\n}"}
{"id": "907", "path": "output2\\java\\Medium\\907-bulb-switcher-ii.java", "hypo_code": "class BulbSwitcherIi {\n    public int flipLights(int n, int presses) {\n        if(n == 0 || presses == 0) return 1;\n        if(n == 1) return 2;\n        if(n == 2) return presses == 1 ? 3 : 4;\n        if(presses == 1) return 4;\n        if(presses == 2) return 7;\n        return 8;\n        \n        \n    }\n}"}
{"id": "908", "path": "output2\\java\\Medium\\908-number-of-longest-increasing-subsequence.java", "hypo_code": "class NumberOfLongestIncreasingSubsequence {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        int[] cnt = new int[n];\n        Arrays.fill(dp, 1);\n        Arrays.fill(cnt, 1);\n        int max = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < i; j++){\n                if(nums[i] > nums[j]){\n                    if(dp[j] + 1 > dp[i]){\n                        dp[i] = dp[j] + 1;\n                        cnt[i] = cnt[j];\n                    }else if(dp[j] + 1 == dp[i]){\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            max = Math.max(max, dp[i]);\n        }\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            if(dp[i] == max){\n                res += cnt[i];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "911", "path": "output2\\java\\Medium\\911-valid-parenthesis-string.java", "hypo_code": "class ValidParenthesisString {\n    public boolean checkValidString(String s) {\n        int n = s.length();\n        int[] left = new int[n + 1];\n        int[] right = new int[n + 1];\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == '('){\n                left[i + 1] = left[i] + 1;\n                right[i + 1] = right[i];\n            }else if(s.charAt(i) == ')'){\n                left[i + 1] = Math.max(left[i] - 1, 0);\n                right[i + 1] = right[i] + 1;\n            }else{\n                left[i + 1] = Math.max(left[i] - 1, 0);\n                right[i + 1] = right[i] + 1;\n            }\n        }\n        for(int i = 0; i <= n; i++){\n            if(left[i] == 0 && right[i] == 0){\n                return true;\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "912", "path": "output2\\java\\Medium\\912-redundant-connection.java", "hypo_code": "class RedundantConnection {\n    public int[] findRedundantConnection(int[][] edges) {\n        int n = edges.length;\n        int[] parent = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            parent[i] = i;\n        }\n        for(int[] edge : edges){\n            int u = edge[0];\n            int v = edge[1];\n            int pu = find(u, parent);\n            int pv = find(v, parent);\n            if(pu == pv){\n                return edge;\n            }else{\n                parent[pu] = pv;\n            }\n        }\n        return new int[0];\n        \n        \n    }\n}"}
{"id": "913", "path": "output2\\java\\Medium\\913-repeated-string-match.java", "hypo_code": "class RepeatedStringMatch {\n    public int repeatedStringMatch(String a, String b) {\n        int n = a.length();\n        int m = b.length();\n        int cnt = 0;\n        StringBuilder sb = new StringBuilder();\n        while(sb.length() < m){\n            sb.append(a);\n            cnt++;\n        }\n        if(sb.indexOf(b) != -1){\n            return cnt;\n        }\n        if(sb.append(a).indexOf(b) != -1){\n            return cnt + 1;\n        }\n        return -1;\n        \n        \n    }\n}"}
{"id": "914", "path": "output2\\java\\Medium\\914-longest-univalue-path.java", "hypo_code": "class LongestUnivaluePath {\n    public int longestUnivaluePath(TreeNode root) {\n        int[] res = new int[1];\n        helper(root, res);\n        return res[0];\n        \n    }\n}"}
{"id": "915", "path": "output2\\java\\Medium\\915-knight-probability-in-chessboard.java", "hypo_code": "class KnightProbabilityInChessboard {\n    public double knightProbability(int n, int k, int row, int column) {\n        double[][] dp = new double[n][n];\n        dp[row][column] = 1;\n        int[][] dirs = {{1, 2}, {2, 1}, {-1, 2}, {-2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1}};\n        for(int i = 0; i < k; i++){\n            double[][] temp = new double[n][n];\n            for(int r = 0; r < n; r++){\n                for(int c = 0; c < n; c++){\n                    for(int[] dir : dirs){\n                        int nr = r + dir[0];\n                        int nc = c + dir[1];\n                        if(nr >= 0 && nr < n && nc >= 0 && nc < n){\n                            temp[nr][nc] += dp[r][c] / 8.0;\n                        }\n                    }\n                }\n            }\n            dp = temp;\n        }\n        double res = 0;\n        for(int r = 0; r < n; r++){\n            for(int c = 0; c < n; c++){\n                res += dp[r][c];\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "917", "path": "output2\\java\\Medium\\917-top-k-frequent-words.java", "hypo_code": "class TopKFrequentWords {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> map = new HashMap<>();\n        for(String word : words){\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n        PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> map.get(a) == map.get(b) ? b.compareTo(a) : map.get(a) - map.get(b));\n        for(String word : map.keySet()){\n            pq.offer(word);\n            if(pq.size() > k){\n                pq.poll();\n            }\n        }\n        List<String> res = new ArrayList<>();\n        while(!pq.isEmpty()){\n            res.add(pq.poll());\n        }\n        Collections.reverse(res);\n        return res;\n        \n        \n    }\n}"}
{"id": "918", "path": "output2\\java\\Medium\\918-max-area-of-island.java", "hypo_code": "class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int max = 0;\n        int row = grid.length;\n        int col = grid[0].length;\n        boolean[][] visited = new boolean[row][col];\n        for(int i=0; i<row; i++) {\n            for(int j=0; j<col; j++) {\n                int area = dfs(grid, i, j, visited);\n                max = Math.max(max, area);\n            }\n        }\n        return max;\n    }\n    private int dfs(int[][] grid, int i, int j, boolean[][] visited) {\n        int row = grid.length;\n        int col = grid[0].length;\n        if(i<0 || i>=row || j<0 || j>=col || grid[i][j]==0 || visited[i][j]) {\n            return 0;\n        }\n        visited[i][j] = true;\n        int area = 1;\n        area += dfs(grid, i-1, j, visited);\n        area += dfs(grid, i, j-1, visited);\n        area += dfs(grid, i+1, j, visited);\n        area += dfs(grid, i, j+1, visited);\n        return area;\n    }\n}"}
{"id": "919", "path": "output2\\java\\Medium\\919-partition-to-k-equal-sum-subsets.java", "hypo_code": "class Solution {\n    public boolean canPartitionKSubsets(int[] nums, int k) {\n        int sum = 0;\n        for(int num: nums) {\n            sum += num;\n        }\n        if(sum % k != 0) {\n            return false;\n        }\n        int target = sum / k;\n        Arrays.sort(nums);\n        int row = nums.length;\n        int col = k;\n        boolean[][] visited = new boolean[row][col];\n        return dfs(nums, target, 0, 0, visited);\n    }\n    private boolean dfs(int[] nums, int target, int i, int sum, boolean[][] visited) {\n        int row = nums.length;\n        int col = visited[0].length;\n        if(col == 1) {\n            return true;\n        }\n        if(sum == target) {\n            return dfs(nums, target, 0, 0, visited);\n        }\n        if(sum > target) {\n            return false;\n        }\n        for(int j=i; j<row; j++) {\n            if(visited[j][col-1]) {\n                continue;\n            }\n            visited[j][col-1] = true;\n            if(dfs(nums, target, j+1, sum+nums[j], visited)) {\n                return true;\n            }\n            visited[j][col-1] = false;\n        }\n        return false;\n    }\n    }"}
{"id": "920", "path": "output2\\java\\Medium\\920-insert-into-a-binary-search-tree.java", "hypo_code": "class Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if(root == null) {\n\t\t\treturn new TreeNode(val);\n\t\t}\n\t\tif(root.val < val) {\n\t\t\troot.right = insertIntoBST(root.right, val);\n\t\t} else {\n\t\t\troot.left = insertIntoBST(root.left, val);\n\t\t}\n\t\treturn root;\n    }\n}"}
{"id": "922", "path": "output2\\java\\Medium\\922-minimum-ascii-delete-sum-for-two-strings.java", "hypo_code": "class Solution {\n    public int minimumDeleteSum(String s1, String s2) {\n        int row = s1.length();\n        int col = s2.length();\n        int[][] dp = new int[row+1][col+1];\n        for(int i=row-1; i>=0; i--) {\n            dp[i][col] = dp[i+1][col] + s1.charAt(i);\n        }\n        for(int j=col-1; j>=0; j--) {\n            dp[row][j] = dp[row][j+1] + s2.charAt(j);\n        }\n        for(int i=row-1; i>=0; i--) {\n            for(int j=col-1; j>=0; j--) {\n                if(s1.charAt(i) == s2.charAt(j)) {\n                    dp[i][j] = dp[i+1][j+1];\n                } else {\n                    dp[i][j] = Math.min(s1.charAt(i) + dp[i+1][j], s2.charAt(j) + dp[i][j+1]);\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"}
{"id": "923", "path": "output2\\java\\Medium\\923-subarray-product-less-than-k.java", "hypo_code": "class SubarrayProductLessThanK {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int res = 0;\n        int prod = 1;\n        while(right < nums.length){\n            prod *= nums[right];\n            while(prod >= k && left <= right){\n                prod /= nums[left];\n                left++;\n            }\n            res += right - left + 1;\n            right++;\n        }\n        return res;\n        \n    }\n}"}
{"id": "924", "path": "output2\\java\\Medium\\924-best-time-to-buy-and-sell-stock-with-transaction-fee.java", "hypo_code": "class BestTimeToBuyAndSellStockWithTransactionFee {\n    public int maxProfit(int[] prices, int fee) {\n        int n = prices.length;\n        int[] buy = new int[n];\n        int[] sell = new int[n];\n        buy[0] = -prices[0];\n        for(int i = 1; i < n; i++){\n            buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]);\n            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i] - fee);\n        }\n        return sell[n - 1];\n        \n    }\n}"}
{"id": "925", "path": "output2\\java\\Medium\\925-maximum-length-of-repeated-subarray.java", "hypo_code": "class MaximumLengthOfRepeatedSubarray {\n    public int findLength(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int m = nums2.length;\n        int[][] dp = new int[n + 1][m + 1];\n        int res = 0;\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= m; j++){\n                if(nums1[i - 1] == nums2[j - 1]){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    res = Math.max(res, dp[i][j]);\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "926", "path": "output2\\java\\Medium\\926-longest-word-in-dictionary.java", "hypo_code": "class LongestWordInDictionary {\n    public String longestWord(String[] words) {\n        Arrays.sort(words);\n        Set<String> set = new HashSet<>();\n        String res = \"\";\n        for(String word : words){\n            if(word.length() == 1 || set.contains(word.substring(0, word.length() - 1))){\n                res = word.length() > res.length() ? word : res;\n                set.add(word);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "927", "path": "output2\\java\\Medium\\927-accounts-merge.java", "hypo_code": "class AccountsMerge {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        Map<String, String> emailToName = new HashMap<>();\n        Map<String, List<String>> graph = new HashMap<>();\n        for(List<String> account : accounts){\n            String name = account.get(0);\n            for(int i = 1; i < account.size(); i++){\n                String email = account.get(i);\n                emailToName.put(email, name);\n                graph.computeIfAbsent(email, x -> new ArrayList<>()).add(account.get(1));\n                graph.computeIfAbsent(account.get(1), x -> new ArrayList<>()).add(email);\n            }\n        }\n        Set<String> seen = new HashSet<>();\n        List<List<String>> res = new ArrayList<>();\n        for(String email : graph.keySet()){\n            if(!seen.contains(email)){\n                seen.add(email);\n                Stack<String> stack = new Stack<>();\n                stack.push(email);\n                List<String> component = new ArrayList<>();\n                while(!stack.isEmpty()){\n                    String node = stack.pop();\n                    component.add(node);\n                    for(String nei : graph.get(node)){\n                        if(!seen.contains(nei)){\n                            seen.add(nei);\n                            stack.push(nei);\n                        }\n                    }\n                }\n                Collections.sort(component);\n                component.add(0, emailToName.get(email));\n                res.add(component);\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "928", "path": "output2\\java\\Medium\\928-remove-comments.java", "hypo_code": "class RemoveComments {\n    public List<String> removeComments(String[] source) {\n        List<String> res = new ArrayList<>();\n        boolean inBlock = false;\n        StringBuilder sb = new StringBuilder();\n        for(String line : source){\n            int i = 0;\n            char[] chars = line.toCharArray();\n            if(!inBlock){\n                sb = new StringBuilder();\n            }\n            while(i < chars.length){\n                if(!inBlock && i + 1 < chars.length && chars[i] == '/' && chars[i + 1] == '*'){\n                    inBlock = true;\n                    i++;\n                }else if(inBlock && i + 1 < chars.length && chars[i] == '*' && chars[i + 1] == '/'){\n                    inBlock = false;\n                    i++;\n                }else if(!inBlock && i + 1 < chars.length && chars[i] == '/' && chars[i + 1] == '/'){\n                    break;\n                }else if(!inBlock){\n                    sb.append(chars[i]);\n                }\n                i++;\n            }\n            if(!inBlock && sb.length() > 0){\n                res.add(sb.toString());\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "929", "path": "output2\\java\\Medium\\929-split-linked-list-in-parts.java", "hypo_code": "class Solution {\n    public ListNode[] splitListToParts(ListNode head, int k) {\n        ListNode[] res = new ListNode[k];\n\t\tint len = 0;\n\t\tListNode cur = head;\n\t\twhile(cur != null) {\n\t\t\tlen++;\n\t\t\tcur = cur.next;\n\t\t}\n\t\tint size = len / k;\n\t\tint remain = len % k;\n\t\tcur = head;\n\t\tfor(int i=0; i<k && cur!=null; i++) {\n\t\t\tres[i] = cur;\n\t\t\tint curSize = size + (remain-- > 0 ? 1 : 0);\n\t\t\tfor(int j=0; j<curSize-1; j++) {\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\t\t\tListNode next = cur.next;\n\t\t\tcur.next = null;\n\t\t\tcur = next;\n\t\t}\n\t\treturn res;\n    }\n}"}
{"id": "932", "path": "output2\\java\\Medium\\932-asteroid-collision.java", "hypo_code": "class Solution {\n    public int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> stack = new Stack<>();\n        for(int asteroid: asteroids) {\n            if(stack.isEmpty() || asteroid > 0) {\n                stack.push(asteroid);\n                continue;\n            }\n            while(true) {\n                int top = stack.peek();\n                if(top < 0) {\n                    stack.push(asteroid);\n                    break;\n                }\n                if(top == -asteroid) {\n                    stack.pop();\n                    break;\n                }\n                if(top > -asteroid) {\n                    break;\n                }\n                stack.pop();\n                if(stack.isEmpty()) {\n                    stack.push(asteroid);\n                    break;\n                }\n            }\n        }\n        int[] res = new int[stack.size()];\n        for(int i=res.length-1; i>=0; i--) {\n            res[i] = stack.pop();\n        }\n        return res;\n    }\n}"}
{"id": "933", "path": "output2\\java\\Medium\\933-monotone-increasing-digits.java", "hypo_code": "class Solution {\n    public int monotoneIncreasingDigits(int n) {\n       char[] ch = String.valueOf(n).toCharArray();\n\t\tint i = 1;\n\t\twhile(i < ch.length && ch[i-1] <= ch[i]) {\n\t\t\ti++;\n\t\t}\n\t\tif(i < ch.length) {\n\t\t\twhile(i > 0 && ch[i-1] > ch[i]) {\n\t\t\t\tch[--i]--;\n\t\t\t}\n\t\t\tfor(int j=i+1; j<ch.length; j++) {\n\t\t\t\tch[j] = '9';\n\t\t\t}\n\t\t}\n\t\treturn Integer.parseInt(String.valueOf(ch));\n       \n    }\n}"}
{"id": "934", "path": "output2\\java\\Medium\\934-daily-temperatures.java", "hypo_code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n    }\n}"}
{"id": "935", "path": "output2\\java\\Medium\\935-delete-and-earn.java", "hypo_code": "class Solution {\n    public int deleteAndEarn(int[] nums) {\n        int max = 0;\n        for(int num: nums) {\n            max = Math.max(max, num);\n        }\n        int[] count = new int[max+1];\n        for(int num: nums) {\n            count[num]++;\n        }\n        int[] dp = new int[max+1];\n        dp[1] = count[1];\n        for(int i=2; i<=max; i++) {\n            dp[i] = Math.max(dp[i-1], dp[i-2] + count[i] * i);\n        }\n        return dp[max];\n    }\n}"}
{"id": "936", "path": "output2\\java\\Medium\\936-network-delay-time.java", "hypo_code": "class Solution {\n    public int networkDelayTime(int[][] times, int n, int k) {\n        int max = 0;\n        for(int[] time: times) {\n            max = Math.max(max, time[2]);\n        }\n        int[] dist = new int[n+1];\n        Arrays.fill(dist, max + 1);\n        dist[k] = 0;\n        for(int i=1; i<=n; i++) {\n            for(int[] time: times) {\n                int u = time[0];\n                int v = time[1];\n                int w = time[2];\n                if(dist[u] != max + 1 && dist[v] > dist[u] + w) {\n                    dist[v] = dist[u] + w;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i=1; i<=n; i++) {\n            ans = Math.max(ans, dist[i]);\n        }\n        return ans == max + 1 ? -1 : ans;\n    }\n}"}
{"id": "937", "path": "output2\\java\\Medium\\937-open-the-lock.java", "hypo_code": "class Solution {\n    public int openLock(String[] deadends, String target) {\n        Set<String> dead = new HashSet<>(Arrays.asList(deadends));\n\t\tif(dead.contains(\"0000\")) {\n\t\t\treturn -1;\n\t\t}\n\t\tif(\"0000\".equals(target)) {\n\t\t\treturn 0;\n\t\t}\n\t\tSet<String> visited = new HashSet<>();\n\t\tvisited.add(\"0000\");\n\t\tQueue<String> queue = new LinkedList<>();\n\t\tqueue.offer(\"0000\");\n\t\tint step = 0;\n\t\twhile(!queue.isEmpty()) {\n\t\t\tstep++;\n\t\t\tint size = queue.size();\n\t\t\tfor(int i=0; i<size; i++) {\n\t\t\t\tString cur = queue.poll();\n\t\t\t\tfor(String next: getNext(cur)) {\n\t\t\t\t\tif(!visited.contains(next) && !dead.contains(next)) {\n\t\t\t\t\t\tif(target.equals(next)) {\n\t\t\t\t\t\t\treturn step;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvisited.add(next);\n\t\t\t\t\t\tqueue.offer(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n    }\n\tprivate List<String> getNext(String cur) {\n\t\tList<String> res = new ArrayList<>();\n\t\tchar[] arr = cur.toCharArray();\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tchar c = arr[i];\n\t\t\tarr[i] = c == '9' ? '0' : (char)(c+1);\n\t\t\tres.add(new String(arr));\n\t\t\tarr[i] = c == '0' ? '9' : (char)(c-1);\n\t\t\tres.add(new String(arr));\n\t\t\tarr[i] = c;\n\t\t}\n\t\treturn res;\n    }\n}"}
{"id": "938", "path": "output2\\java\\Medium\\938-reach-a-number.java", "hypo_code": "class Solution {\n    public int reachNumber(int target) {\n        target = Math.abs(target);\n        int step = 0;\n        int sum = 0;\n        while(sum < target) {\n            step++;\n            sum += step;\n        }\n        while((sum - target) % 2 != 0) {\n            step++;\n            sum += step;\n        }\n        return step;\n    }\n}"}
{"id": "939", "path": "output2\\java\\Medium\\939-pyramid-transition-matrix.java", "hypo_code": "class Solution {\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\n        Map<String, Set<Character>> map = new HashMap<>();\n        for(String s: allowed) {\n            String key = s.substring(0, 2);\n            map.putIfAbsent(key, new HashSet<>());\n            map.get(key).add(s.charAt(2));\n        }\n        return dfs(bottom, map);\n    }\n    private boolean dfs(String bottom, Map<String, Set<Character>> map) {\n        if(bottom.length() == 1) {\n            return true;\n        }\n        for(int i=0; i<bottom.length()-1; i++) {\n            String key = bottom.substring(i, i+2);\n            if(!map.containsKey(key)) {\n                return false;\n            }\n        }\n        List<String> nexts = getNexts(bottom, map);\n        for(String next: nexts) {\n            if(dfs(next, map)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private List<String> getNexts(String bottom, Map<String, Set<Character>> map) {\n        List<String> nexts = new ArrayList<>();\n        getNexts(bottom, 0, \"\", nexts, map);\n        return nexts;\n    }\n    private void getNexts(String bottom, int index, String next, List<String> nexts, Map<String, Set<Character>> map) {\n        if(index == bottom.length() - 1) {\n            nexts.add(next);\n            return;\n        }\n        String key = bottom.substring(index, index+2);\n        for(char c: map.get(key)) {\n            next += c;\n            getNexts(bottom, index+1, next, nexts, map);\n            next = next.substring(0, next.length()-1);\n        }\n    }\n}"}
{"id": "940", "path": "output2\\java\\Medium\\940-partition-labels.java", "hypo_code": "class Solution {\n    public List<Integer> partitionLabels(String s) {\n        List<Integer> res = new ArrayList<>();\n\t\tint[] last = new int[26];\n\t\tfor(int i=0; i<s.length(); i++) {\n\t\t\tlast[s.charAt(i) - 'a'] = i;\n\t\t}\n\t\tint start = 0, end = 0;\n\t\tfor(int i=0; i<s.length(); i++) {\n\t\t\tend = Math.max(end, last[s.charAt(i) - 'a']);\n\t\t\tif(i == end) {\n\t\t\t\tres.add(end - start + 1);\n\t\t\t\tstart = end + 1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n    }\n}"}
{"id": "941", "path": "output2\\java\\Medium\\941-largest-plus-sign.java", "hypo_code": "class Solution {\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\n        int[][] grid = new int[n][n];\n        for(int[] row: grid) {\n            Arrays.fill(row, n);\n        }\n        for(int[] mine: mines) {\n            grid[mine[0]][mine[1]] = 0;\n        }\n        for(int i=0; i<n; i++) {\n            int left = 0;\n            int right = 0;\n            int up = 0;\n            int down = 0;\n            for(int j=0; j<n; j++) {\n                left = grid[i][j] == 0 ? 0 : left + 1;\n                grid[i][j] = Math.min(grid[i][j], left);\n                right = grid[i][n-j-1] == 0 ? 0 : right + 1;\n                grid[i][n-j-1] = Math.min(grid[i][n-j-1], right);\n                up = grid[j][i] == 0 ? 0 : up + 1;\n                grid[j][i] = Math.min(grid[j][i], up);\n                down = grid[n-j-1][i] == 0 ? 0 : down + 1;\n                grid[n-j-1][i] = Math.min(grid[n-j-1][i], down);\n            }\n        }\n        int max = 0;\n        for(int[] row: grid) {\n            for(int cell: row) {\n                max = Math.max(max, cell);\n            }\n        }\n        return max;\n    }\n}"}
{"id": "942", "path": "output2\\java\\Medium\\942-reorganize-string.java", "hypo_code": "class Solution {\n    public String reorganizeString(String s) {\n        int n = s.length();\n        int[] cnt = new int[26];\n        for(char c: s.toCharArray()) {\n            cnt[c-'a']++;\n        }\n        PriorityQueue<Character> pq = new PriorityQueue<>((a,b) -> cnt[b-'a'] - cnt[a-'a']);\n        for(int i=0; i<26; i++) {\n            if(cnt[i] > 0) {\n                pq.add((char)('a' + i));\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        while(pq.size() >= 2) {\n            char c1 = pq.remove();\n            char c2 = pq.remove();\n            sb.append(c1);\n            sb.append(c2);\n            if(--cnt[c1-'a'] > 0) {\n                pq.add(c1);\n            }\n            if(--cnt[c2-'a'] > 0) {\n                pq.add(c2);\n            }\n        }\n        if(pq.size() > 0) {\n            char c = pq.remove();\n            if(cnt[c-'a'] > 1) {\n                return \"\";\n            }\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}"}
{"id": "943", "path": "output2\\java\\Medium\\943-max-chunks-to-make-sorted.java", "hypo_code": "class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int ans = 0;\n        int max = 0;\n        for(int i=0; i<arr.length; i++) {\n            max = Math.max(max, arr[i]);\n            if(max == i) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "944", "path": "output2\\java\\Medium\\944-global-and-local-inversions.java", "hypo_code": "class Solution {\n    public boolean isIdealPermutation(int[] nums) {\n        for(int i=0; i<nums.length; i++) {\n            if(Math.abs(nums[i] - i) > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "945", "path": "output2\\java\\Medium\\945-swap-adjacent-in-lr-string.java", "hypo_code": "class SwapAdjacentInLrString {\n    public boolean canTransform(String start, String end) {\n        int n = start.length();\n        int m = end.length();\n        if(n != m){\n            return false;\n        }\n        int i = 0;\n        int j = 0;\n        while(i < n && j < m){\n            while(i < n && start.charAt(i) == 'X'){\n                i++;\n            }\n            while(j < m && end.charAt(j) == 'X'){\n                j++;\n            }\n            if(i == n && j == m){\n                return true;\n            }\n            if(i == n || j == m){\n                return false;\n            }\n            if(start.charAt(i) != end.charAt(j)){\n                return false;\n            }\n            if(start.charAt(i) == 'L' && i < j){\n                return false;\n            }\n            if(start.charAt(i) == 'R' && i > j){\n                return false;\n            }\n            i++;\n            j++;\n        }\n        return true;\n        \n    }\n}"}
{"id": "946", "path": "output2\\java\\Medium\\946-k-th-symbol-in-grammar.java", "hypo_code": "class KThSymbolInGrammar {\n    public int kthGrammar(int n, int k) {\n        if(n == 1){\n            return 0;\n        }\n        int mid = (int)Math.pow(2, n - 1) / 2;\n        if(k <= mid){\n            return kthGrammar(n - 1, k);\n        }else{\n            return kthGrammar(n - 1, k - mid) == 0 ? 1 : 0;\n        }\n        \n    }\n}"}
{"id": "947", "path": "output2\\java\\Medium\\947-rabbits-in-forest.java", "hypo_code": "class RabbitsInForest {\n    public int numRabbits(int[] answers) {\n        int[] cnt = new int[1000];\n        for(int ans : answers){\n            cnt[ans]++;\n        }\n        int res = 0;\n        for(int i = 0; i < 1000; i++){\n            res += (cnt[i] + i) / (i + 1) * (i + 1);\n        }\n        return res;\n        \n    }\n}"}
{"id": "948", "path": "output2\\java\\Medium\\948-letter-case-permutation.java", "hypo_code": "class LetterCasePermutation {\n    public List<String> letterCasePermutation(String s) {\n        List<String> res = new ArrayList<>();\n        dfs(s, 0, res);\n        return res;\n        \n        \n    }\n}"}
{"id": "949", "path": "output2\\java\\Medium\\949-is-graph-bipartite.java", "hypo_code": "class IsGraphBipartite {\n    public boolean isBipartite(int[][] graph) {\n        int n = graph.length;\n        int[] color = new int[n];\n        for(int i = 0; i < n; i++){\n            if(color[i] == 0 && !dfs(graph, color, i, 1)){\n                return false;\n            }\n        }\n        return true;\n        \n        \n    }\n}"}
{"id": "950", "path": "output2\\java\\Medium\\950-k-th-smallest-prime-fraction.java", "hypo_code": "class KThSmallestPrimeFraction {\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> arr[a[0]] * arr[b[1]] - arr[a[1]] * arr[b[0]]);\n        for(int i = 0; i < arr.length - 1; i++){\n            pq.offer(new int[]{i, arr.length - 1});\n        }\n        while(k > 1){\n            int[] cur = pq.poll();\n            if(cur[1] - 1 > cur[0]){\n                pq.offer(new int[]{cur[0], cur[1] - 1});\n            }\n            k--;\n        }\n        int[] res = pq.poll();\n        return new int[]{arr[res[0]], arr[res[1]]};\n        \n    }\n}"}
{"id": "951", "path": "output2\\java\\Medium\\951-cheapest-flights-within-k-stops.java", "hypo_code": "class CheapestFlightsWithinKStops {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[src] = 0;\n        for(int i = 0; i <= k; i++){\n            int[] temp = Arrays.copyOf(dp, n);\n            for(int[] flight : flights){\n                int from = flight[0];\n                int to = flight[1];\n                int price = flight[2];\n                if(dp[from] != Integer.MAX_VALUE){\n                    temp[to] = Math.min(temp[to], dp[from] + price);\n                }\n            }\n            dp = temp;\n        }\n        return dp[dst] == Integer.MAX_VALUE ? -1 : dp[dst];\n        \n        \n    }\n}"}
{"id": "952", "path": "output2\\java\\Medium\\952-rotated-digits.java", "hypo_code": "class RotatedDigits {\n    public int rotatedDigits(int n) {\n        int res = 0;\n        for(int i = 1; i <= n; i++){\n            if(isGood(i)){\n                res++;\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "953", "path": "output2\\java\\Medium\\953-escape-the-ghosts.java", "hypo_code": "class EscapeTheGhosts {\n    public boolean escapeGhosts(int[][] ghosts, int[] target) {\n        int n = ghosts.length;\n        int[] start = new int[]{0, 0};\n        int dist = Math.abs(target[0] - start[0]) + Math.abs(target[1] - start[1]);\n        for(int i = 0; i < n; i++){\n            int ghostDist = Math.abs(target[0] - ghosts[i][0]) + Math.abs(target[1] - ghosts[i][1]);\n            if(ghostDist <= dist){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "954", "path": "output2\\java\\Medium\\954-domino-and-tromino-tiling.java", "hypo_code": "class DominoAndTrominoTiling {\n    public int numTilings(int n) {\n        int mod = 1000000007;\n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n        for(int i = 1; i <= n; i++){\n            dp[i] = (dp[i - 1] * 2) % mod;\n            if(i >= 2){\n                dp[i] = (dp[i] + dp[i - 2]) % mod;\n            }\n            if(i >= 3){\n                dp[i] = (dp[i] + dp[i - 3]) % mod;\n            }\n        }\n        return (int)dp[n];\n        \n    }\n}"}
{"id": "955", "path": "output2\\java\\Medium\\955-custom-sort-string.java", "hypo_code": "class CustomSortString {\n    public String customSortString(String order, String s) {\n        int[] count = new int[26];\n        for(char c : s.toCharArray()){\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        for(char c : order.toCharArray()){\n            while(count[c - 'a'] > 0){\n                sb.append(c);\n                count[c - 'a']--;\n            }\n        }\n        for(int i = 0; i < 26; i++){\n            while(count[i] > 0){\n                sb.append((char)(i + 'a'));\n                count[i]--;\n            }\n        }\n        return sb.toString();\n        \n    }\n}"}
{"id": "956", "path": "output2\\java\\Medium\\956-number-of-matching-subsequences.java", "hypo_code": "class NumberOfMatchingSubsequences {\n    public int numMatchingSubseq(String s, String[] words) {\n        int res = 0;\n        Map<Character, Queue<String>> map = new HashMap<>();\n        for(char c = 'a'; c <= 'z'; c++){\n            map.put(c, new LinkedList<>());\n        }\n        for(String word : words){\n            map.get(word.charAt(0)).offer(word);\n        }\n        for(char c : s.toCharArray()){\n            Queue<String> q = map.get(c);\n            int size = q.size();\n            for(int i = 0; i < size; i++){\n                String word = q.poll();\n                if(word.length() == 1){\n                    res++;\n                }else{\n                    map.get(word.charAt(1)).offer(word.substring(1));\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "957", "path": "output2\\java\\Medium\\957-valid-tic-tac-toe-state.java", "hypo_code": "class ValidTicTacToeState {\n    public boolean validTicTacToe(String[] board) {\n        int n = board.length;\n        int x = 0;\n        int o = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(board[i].charAt(j) == 'X'){\n                    x++;\n                }else if(board[i].charAt(j) == 'O'){\n                    o++;\n                }\n            }\n        }\n        if(o > x || x - o > 1){\n            return false;\n        }\n        boolean xWin = false;\n        boolean oWin = false;\n        for(int i = 0; i < n; i++){\n            if(board[i].equals(\"XXX\")){\n                xWin = true;\n            }\n            if(board[i].equals(\"OOO\")){\n                oWin = true;\n            }\n            if(board[0].charAt(i) == board[1].charAt(i) && board[1].charAt(i) == board[2].charAt(i)){\n                if(board[0].charAt(i) == 'X'){\n                    xWin = true;\n                }\n                if(board[0].charAt(i) == 'O'){\n                    oWin = true;\n                }\n            }\n        }\n        if(board[0].charAt(0) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(2)){\n            if(board[0].charAt(0) == 'X'){\n                xWin = true;\n            }\n            if(board[0].charAt(0) == 'O'){\n                oWin = true;\n            }\n        }\n        if(board[0].charAt(2) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(0)){\n            if(board[0].charAt(2) == 'X'){\n                xWin = true;\n            }\n            if(board[0].charAt(2) == 'O'){\n                oWin = true;\n            }\n        }\n        if(xWin && oWin){\n            return false;\n        }\n        if(xWin && x == o){\n            return false;\n        }\n        if(oWin && x > o){\n            return false;\n        }\n        return true;\n        \n    }\n}"}
{"id": "958", "path": "output2\\java\\Medium\\958-number-of-subarrays-with-bounded-maximum.java", "hypo_code": "class NumberOfSubarraysWithBoundedMaximum {\n    public int numSubarrayBoundedMax(int[] nums, int left, int right) {\n        int n = nums.length;\n        int[] dp = new int[n + 1];\n        int count = 0;\n        for(int i = 1; i <= n; i++){\n            if(nums[i - 1] >= left && nums[i - 1] <= right){\n                dp[i] = i;\n                count += dp[i];\n            }else if(nums[i - 1] < left){\n                dp[i] = dp[i - 1];\n                count += dp[i];\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "959", "path": "output2\\java\\Medium\\959-all-paths-from-source-to-target.java", "hypo_code": "class AllPathsFromSourceToTarget {\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> path = new ArrayList<>();\n        path.add(0);\n        dfs(graph, 0, res, path);\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "960", "path": "output2\\java\\Medium\\960-champagne-tower.java", "hypo_code": "class ChampagneTower {\n    public double champagneTower(int poured, int query_row, int query_glass) {\n        double[][] dp = new double[101][101];\n        dp[0][0] = poured;\n        for(int i = 0; i <= query_row; i++){\n            for(int j = 0; j <= i; j++){\n                double q = (dp[i][j] - 1.0) / 2.0;\n                if(q > 0){\n                    dp[i + 1][j] += q;\n                    dp[i + 1][j + 1] += q;\n                }\n            }\n        }\n        return Math.min(1, dp[query_row][query_glass]);\n        \n    }\n}"}
{"id": "961", "path": "output2\\java\\Medium\\961-find-eventual-safe-states.java", "hypo_code": "class FindEventualSafeStates {\n    public List<Integer> eventualSafeNodes(int[][] graph) {\n        int n = graph.length;\n        List<Integer> res = new ArrayList<>();\n        int[] color = new int[n];\n        for(int i = 0; i < n; i++){\n            if(dfs(graph, i, color)){\n                res.add(i);\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "962", "path": "output2\\java\\Medium\\962-max-increase-to-keep-city-skyline.java", "hypo_code": "class MaxIncreaseToKeepCitySkyline {\n    public int maxIncreaseKeepingSkyline(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[] row = new int[m];\n        int[] col = new int[n];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                row[i] = Math.max(row[i], grid[i][j]);\n                col[j] = Math.max(col[j], grid[i][j]);\n            }\n        }\n        int result = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                result += Math.min(row[i], col[j]) - grid[i][j];\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "963", "path": "output2\\java\\Medium\\963-soup-servings.java", "hypo_code": "class SoupServings {\n    public double soupServings(int n) {\n        if(n >= 4800){\n            return 1.0;\n        }\n        int N = (n + 24) / 25;\n        double[][] dp = new double[N + 1][N + 1];\n        dp[0][0] = 0.5;\n        for(int i = 0; i <= N; i++){\n            for(int j = 0; j <= N; j++){\n                for(int x = 0; x < 4; x++){\n                    int a = i + (x == 0 ? 4 : x == 1 ? 3 : x == 2 ? 2 : 1);\n                    int b = j + (x == 0 ? 0 : x == 1 ? 1 : x == 2 ? 2 : 3);\n                    if(a >= N && b >= N){\n                        dp[i][j] += 0.25;\n                    }else if(a >= N){\n                        dp[i][j] += 0.25 * 1;\n                    }else if(b >= N){\n                        dp[i][j] += 0.25 * 0;\n                    }else{\n                        dp[i][j] += 0.25 * dp[a][b];\n                    }\n                }\n            }\n        }\n        return dp[0][0];\n        \n        \n    }\n}"}
{"id": "964", "path": "output2\\java\\Medium\\964-expressive-words.java", "hypo_code": "class ExpressiveWords {\n    public int expressiveWords(String s, String[] words) {\n        int res = 0;\n        for(String word : words){\n            if(isStretchy(s, word)){\n                res++;\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "965", "path": "output2\\java\\Medium\\965-subdomain-visit-count.java", "hypo_code": "class SubdomainVisitCount {\n    public List<String> subdomainVisits(String[] cpdomains) {\n        Map<String, Integer> map = new HashMap<>();\n        for(String cpdomain : cpdomains){\n            String[] arr = cpdomain.split(\" \");\n            int count = Integer.parseInt(arr[0]);\n            String domain = arr[1];\n            map.put(domain, map.getOrDefault(domain, 0) + count);\n            for(int i = 0; i < domain.length(); i++){\n                if(domain.charAt(i) == '.'){\n                    String subdomain = domain.substring(i + 1);\n                    map.put(subdomain, map.getOrDefault(subdomain, 0) + count);\n                }\n            }\n        }\n        List<String> res = new ArrayList<>();\n        for(String domain : map.keySet()){\n            res.add(map.get(domain) + \" \" + domain);\n        }\n        return res;\n        \n    }\n}"}
{"id": "966", "path": "output2\\java\\Medium\\966-largest-sum-of-averages.java", "hypo_code": "class LargestSumOfAverages {\n    public double largestSumOfAverages(int[] nums, int k) {\n        int n = nums.length;\n        double[] sum = new double[n + 1];\n        for(int i = 1; i <= n; i++){\n            sum[i] = sum[i - 1] + nums[i - 1];\n        }\n        double[] dp = new double[n];\n        for(int i = 0; i < n; i++){\n            dp[i] = (sum[n] - sum[i]) / (n - i);\n        }\n        for(int i = 0; i < k - 1; i++){\n            for(int j = 0; j < n; j++){\n                for(int l = j + 1; l < n; l++){\n                    dp[j] = Math.max(dp[j], (sum[l] - sum[j]) / (l - j) + dp[l]);\n                }\n            }\n        }\n        return dp[0];\n        \n        \n    }\n}"}
{"id": "967", "path": "output2\\java\\Medium\\967-binary-tree-pruning.java", "hypo_code": "class BinaryTreePruning {\n    public TreeNode pruneTree(TreeNode root) {\n        if(root == null){\n            return null;\n        }\n        root.left = pruneTree(root.left);\n        root.right = pruneTree(root.right);\n        if(root.val == 0 && root.left == null && root.right == null){\n            return null;\n        }\n        return root;\n        \n    }\n}"}
{"id": "968", "path": "output2\\java\\Medium\\968-ambiguous-coordinates.java", "hypo_code": "class AmbiguousCoordinates {\n    public List<String> ambiguousCoordinates(String s) {\n        List<String> res = new ArrayList<>();\n        for(int i = 2; i < s.length() - 1; i++){\n            List<String> left = getValid(s.substring(1, i));\n            List<String> right = getValid(s.substring(i, s.length() - 1));\n            for(String l : left){\n                for(String r : right){\n                    res.add(\"(\" + l + \", \" + r + \")\");\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "969", "path": "output2\\java\\Medium\\969-linked-list-components.java", "hypo_code": "class LinkedListComponents {\n    public int numComponents(ListNode head, int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for(int num : nums){\n            set.add(num);\n        }\n        int res = 0;\n        ListNode cur = head;\n        while(cur != null){\n            if(set.contains(cur.val) && (cur.next == null || !set.contains(cur.next.val))){\n                res++;\n            }\n            cur = cur.next;\n        }\n        return res;\n        \n    }\n}"}
{"id": "970", "path": "output2\\java\\Medium\\970-short-encoding-of-words.java", "hypo_code": "class ShortEncodingOfWords {\n    public int minimumLengthEncoding(String[] words) {\n        TrieNode root = new TrieNode();\n        Map<TrieNode, Integer> nodes = new HashMap<>();\n        for(int i = 0; i < words.length; i++){\n            String word = words[i];\n            TrieNode cur = root;\n            for(int j = word.length() - 1; j >= 0; j--){\n                char c = word.charAt(j);\n                if(cur.children[c - 'a'] == null){\n                    cur.children[c - 'a'] = new TrieNode();\n                }\n                cur = cur.children[c - 'a'];\n            }\n            nodes.put(cur, i);\n        }\n        int res = 0;\n        for(TrieNode node : nodes.keySet()){\n            if(node.count == 0){\n                res += words[nodes.get(node)].length() + 1;\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "971", "path": "output2\\java\\Medium\\971-card-flipping-game.java", "hypo_code": "class CardFlippingGame {\n    public int flipgame(int[] fronts, int[] backs) {\n        int n = fronts.length;\n        Set<Integer> set = new HashSet<>();\n        for(int i = 0; i < n; i++){\n            if(fronts[i] == backs[i]){\n                set.add(fronts[i]);\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            if(!set.contains(fronts[i])){\n                res = Math.min(res, fronts[i]);\n            }\n            if(!set.contains(backs[i])){\n                res = Math.min(res, backs[i]);\n            }\n        }\n        return res == Integer.MAX_VALUE ? 0 : res;\n        \n    }\n}"}
{"id": "972", "path": "output2\\java\\Medium\\972-binary-trees-with-factors.java", "hypo_code": "class BinaryTreesWithFactors {\n    public int numFactoredBinaryTrees(int[] arr) {\n        int n = arr.length;\n        long res = 0;\n        long mod = (long)1e9 + 7;\n        Arrays.sort(arr);\n        Map<Integer, Long> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            map.put(arr[i], 1L);\n            for(int j = 0; j < i; j++){\n                if(arr[i] % arr[j] == 0){\n                    map.put(arr[i], (map.get(arr[i]) + map.get(arr[j]) * map.getOrDefault(arr[i] / arr[j], 0L)) % mod);\n                }\n            }\n            res = (res + map.get(arr[i])) % mod;\n        }\n        return (int)res;\n        \n    }\n}"}
{"id": "973", "path": "output2\\java\\Medium\\973-friends-of-appropriate-ages.java", "hypo_code": "class FriendsOfAppropriateAges {\n    public int numFriendRequests(int[] ages) {\n        int n = ages.length;\n        int[] cnt = new int[121];\n        for(int i = 0; i < n; i++){\n            cnt[ages[i]]++;\n        }\n        int res = 0;\n        for(int i = 15; i <= 120; i++){\n            int sum = 0;\n            for(int j = 1; j <= i; j++){\n                if(j > 0.5 * i + 7){\n                    sum += cnt[j];\n                }\n            }\n            res += cnt[i] * (sum - 1);\n        }\n        return res;\n        \n    }\n}"}
{"id": "974", "path": "output2\\java\\Medium\\974-most-profit-assigning-work.java", "hypo_code": "class MostProfitAssigningWork {\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\n        int n = difficulty.length;\n        int[][] jobs = new int[n][2];\n        for(int i = 0; i < n; i++){\n            jobs[i] = new int[]{difficulty[i], profit[i]};\n        }\n        Arrays.sort(jobs, (a, b) -> a[0] - b[0]);\n        Arrays.sort(worker);\n        int res = 0;\n        int i = 0;\n        int best = 0;\n        for(int ability : worker){\n            while(i < n && ability >= jobs[i][0]){\n                best = Math.max(best, jobs[i][1]);\n                i++;\n            }\n            res += best;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "975", "path": "output2\\java\\Medium\\975-masking-personal-information.java", "hypo_code": "class MaskingPersonalInformation {\n    public String maskPII(String s) {\n        if(s.contains(\"@\")){\n            return maskEmail(s);\n        }\n        return maskPhone(s);\n        \n    }\n}"}
{"id": "976", "path": "output2\\java\\Medium\\976-find-and-replace-in-string.java", "hypo_code": "class FindAndReplaceInString {\n    public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {\n        int n = s.length();\n        int k = indices.length;\n        int[] match = new int[n];\n        Arrays.fill(match, -1);\n        for(int i = 0; i < k; i++){\n            int idx = indices[i];\n            if(s.startsWith(sources[i], idx)){\n                match[idx] = i;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        int i = 0;\n        while(i < n){\n            if(match[i] >= 0){\n                sb.append(targets[match[i]]);\n                i += sources[match[i]].length();\n            }else{\n                sb.append(s.charAt(i++));\n            }\n        }\n        return sb.toString();\n        \n        \n        \n    }\n}"}
{"id": "977", "path": "output2\\java\\Medium\\977-image-overlap.java", "hypo_code": "class ImageOverlap {\n    public int largestOverlap(int[][] img1, int[][] img2) {\n        int n = img1.length;\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                res = Math.max(res, Math.max(helper(img1, img2, i, j), helper(img2, img1, i, j)));\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "978", "path": "output2\\java\\Medium\\978-new-21-game.java", "hypo_code": "class New21Game {\n    public double new21Game(int n, int k, int maxPts) {\n        if(k == 0 || n >= k + maxPts){\n            return 1.0;\n        }\n        double[] dp = new double[n + 1];\n        dp[0] = 1.0;\n        double sum = 1.0;\n        for(int i = 1; i <= n; i++){\n            dp[i] = sum / maxPts;\n            if(i < k){\n                sum += dp[i];\n            }\n            if(i - maxPts >= 0){\n                sum -= dp[i - maxPts];\n            }\n        }\n        double res = 0.0;\n        for(int i = k; i <= n; i++){\n            res += dp[i];\n        }\n        return res;\n        \n    }\n}"}
{"id": "979", "path": "output2\\java\\Medium\\979-push-dominoes.java", "hypo_code": "class PushDominoes {\n    public String pushDominoes(String dominoes) {\n        int n = dominoes.length();\n        int[] forces = new int[n];\n        int force = 0;\n        for(int i = 0; i < n; i++){\n            if(dominoes.charAt(i) == 'R'){\n                force = n;\n            }else if(dominoes.charAt(i) == 'L'){\n                force = 0;\n            }else{\n                force = Math.max(force - 1, 0);\n            }\n            forces[i] += force;\n        }\n        force = 0;\n        for(int i = n - 1; i >= 0; i--){\n            if(dominoes.charAt(i) == 'L'){\n                force = n;\n            }else if(dominoes.charAt(i) == 'R'){\n                force = 0;\n            }else{\n                force = Math.max(force - 1, 0);\n            }\n            forces[i] -= force;\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int f : forces){\n            if(f > 0){\n                sb.append('R');\n            }else if(f < 0){\n                sb.append('L');\n            }else{\n                sb.append('.');\n            }\n        }\n        return sb.toString();\n        \n    }\n}"}
{"id": "980", "path": "output2\\java\\Medium\\980-magic-squares-in-grid.java", "hypo_code": "class MagicSquaresInGrid {\n    public int numMagicSquaresInside(int[][] grid) {\n        int res = 0;\n        for(int i = 0; i < grid.length - 2; i++){\n            for(int j = 0; j < grid[0].length - 2; j++){\n                if(grid[i + 1][j + 1] != 5){\n                    continue;\n                }\n                if(isMagic(grid, i, j)){\n                    res++;\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "981", "path": "output2\\java\\Medium\\981-keys-and-rooms.java", "hypo_code": "class KeysAndRooms {\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\n        int n = rooms.size();\n        boolean[] visited = new boolean[n];\n        dfs(rooms, 0, visited);\n        for(boolean v : visited){\n            if(!v){\n                return false;\n            }\n        }\n        return true;\n        \n        \n    }\n}"}
{"id": "982", "path": "output2\\java\\Medium\\982-split-array-into-fibonacci-sequence.java", "hypo_code": "class SplitArrayIntoFibonacciSequence {\n    public List<Integer> splitIntoFibonacci(String num) {\n        List<Integer> res = new ArrayList<>();\n        dfs(num, res, 0);\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "983", "path": "output2\\java\\Medium\\983-longest-mountain-in-array.java", "hypo_code": "class LongestMountainInArray {\n    public int longestMountain(int[] arr) {\n        int n = arr.length;\n        int[] left = new int[n];\n        for(int i = 1; i < n; i++){\n            left[i] = arr[i] > arr[i - 1] ? left[i - 1] + 1 : 0;\n        }\n        int[] right = new int[n];\n        for(int i = n - 2; i >= 0; i--){\n            right[i] = arr[i] > arr[i + 1] ? right[i + 1] + 1 : 0;\n        }\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            if(left[i] > 0 && right[i] > 0){\n                res = Math.max(res, left[i] + right[i] + 1);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "984", "path": "output2\\java\\Medium\\984-hand-of-straights.java", "hypo_code": "class HandOfStraights {\n    public boolean isNStraightHand(int[] hand, int groupSize) {\n        if(hand.length % groupSize != 0){\n            return false;\n        }\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for(int i : hand){\n            map.put(i, map.getOrDefault(i, 0) + 1);\n        }\n        while(!map.isEmpty()){\n            int start = map.firstKey();\n            for(int i = start; i < start + groupSize; i++){\n                if(!map.containsKey(i)){\n                    return false;\n                }\n                int count = map.get(i);\n                if(count == 1){\n                    map.remove(i);\n                }else{\n                    map.put(i, count - 1);\n                }\n            }\n        }\n        return true;\n        \n        \n        \n    }\n}"}
{"id": "985", "path": "output2\\java\\Medium\\985-shifting-letters.java", "hypo_code": "class ShiftingLetters {\n    public String shiftingLetters(String s, int[] shifts) {\n        int n = s.length();\n        long[] sum = new long[n];\n        sum[n - 1] = shifts[n - 1];\n        for(int i = n - 2; i >= 0; i--){\n            sum[i] = sum[i + 1] + shifts[i];\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < n; i++){\n            int shift = (int)(sum[i] % 26);\n            char c = (char)((s.charAt(i) - 'a' + shift) % 26 + 'a');\n            sb.append(c);\n        }\n        return sb.toString();\n        \n        \n    }\n}"}
{"id": "986", "path": "output2\\java\\Medium\\986-maximize-distance-to-closest-person.java", "hypo_code": "class MaximizeDistanceToClosestPerson {\n    public int maxDistToClosest(int[] seats) {\n        int n = seats.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int i = 0;\n        int j = 0;\n        while(i < n){\n            if(seats[i] == 1){\n                left[i] = 0;\n            }else{\n                left[i] = i > 0 ? left[i - 1] + 1 : Integer.MAX_VALUE;\n            }\n            i++;\n        }\n        i = n - 1;\n        while(i >= 0){\n            if(seats[i] == 1){\n                right[i] = 0;\n            }else{\n                right[i] = i < n - 1 ? right[i + 1] + 1 : Integer.MAX_VALUE;\n            }\n            i--;\n        }\n        int res = 0;\n        for(i = 0; i < n; i++){\n            if(seats[i] == 0){\n                res = Math.max(res, Math.min(left[i], right[i]));\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "987", "path": "output2\\java\\Medium\\987-loud-and-rich.java", "hypo_code": "class LoudAndRich {\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        int n = quiet.length;\n        List<Integer>[] graph = new List[n];\n        for(int i = 0; i < n; i++){\n            graph[i] = new ArrayList<>();\n        }\n        for(int[] r : richer){\n            graph[r[1]].add(r[0]);\n        }\n        int[] res = new int[n];\n        Arrays.fill(res, -1);\n        for(int i = 0; i < n; i++){\n            dfs(graph, quiet, res, i);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "988", "path": "output2\\java\\Medium\\988-peak-index-in-a-mountain-array.java", "hypo_code": "class PeakIndexInAMountainArray {\n    public int peakIndexInMountainArray(int[] arr) {\n        int left = 0;\n        int right = arr.length - 1;\n        while(left < right){\n            int mid = left + (right - left) / 2;\n            if(arr[mid] < arr[mid + 1]){\n                left = mid + 1;\n            }else{\n                right = mid;\n            }\n        }\n        return left;\n        \n    }\n}"}
{"id": "989", "path": "output2\\java\\Medium\\989-car-fleet.java", "hypo_code": "class CarFleet {\n    public int carFleet(int target, int[] position, int[] speed) {\n        int n = position.length;\n        int[][] cars = new int[n][2];\n        int i = 0;\n        for(i = 0; i < n; i++){\n            cars[i][0] = position[i];\n            cars[i][1] = speed[i];\n        }\n        Arrays.sort(cars, (a, b) -> a[0] - b[0]);\n        int res = 0;\n        double time = 0;\n        for(i = n - 1; i >= 0; i--){\n            if((double)(target - cars[i][0]) / cars[i][1] > time){\n                res++;\n                time = (double)(target - cars[i][0]) / cars[i][1];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "991", "path": "output2\\java\\Medium\\991-score-of-parentheses.java", "hypo_code": "class ScoreOfParentheses {\n    public int scoreOfParentheses(String s) {\n        int res = 0;\n        int bal = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == '('){\n                bal++;\n            }else{\n                bal--;\n                if(s.charAt(i - 1) == '('){\n                    res += 1 << bal;\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "992", "path": "output2\\java\\Medium\\992-mirror-reflection.java", "hypo_code": "class MirrorReflection {\n    public int mirrorReflection(int p, int q) {\n        int g = gcd(p, q);\n        p /= g;\n        p %= 2;\n        q /= g;\n        q %= 2;\n        if(p == 1 && q == 1){\n            return 1;\n        }\n        if(p == 1){\n            return 0;\n        }\n        return 2;\n        \n        \n    }\n}"}
{"id": "993", "path": "output2\\java\\Medium\\993-score-after-flipping-matrix.java", "hypo_code": "class ScoreAfterFlippingMatrix {\n    public int matrixScore(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int res = m * (1 << (n - 1));\n        for(int j = 1; j < n; j++){\n            int ones = 0;\n            for(int i = 0; i < m; i++){\n                if(grid[i][0] == 1){\n                    ones += grid[i][j];\n                }else{\n                    ones += 1 - grid[i][j];\n                }\n            }\n            int k = Math.max(ones, m - ones);\n            res += k * (1 << (n - j - 1));\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "994", "path": "output2\\java\\Medium\\994-all-nodes-distance-k-in-binary-tree.java", "hypo_code": "class AllNodesDistanceKInBinaryTree {\n    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\n        dfs(root, null, parent);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(null);\n        queue.offer(target);\n        Set<TreeNode> seen = new HashSet<>();\n        seen.add(target);\n        seen.add(null);\n        int dist = 0;\n        while(!queue.isEmpty()){\n            TreeNode node = queue.poll();\n            if(node == null){\n                if(dist == k){\n                    List<Integer> res = new ArrayList<>();\n                    for(TreeNode n : queue){\n                        res.add(n.val);\n                    }\n                    return res;\n                }\n                queue.offer(null);\n                dist++;\n            }else{\n                if(!seen.contains(node.left)){\n                    seen.add(node.left);\n                    queue.offer(node.left);\n                }\n                if(!seen.contains(node.right)){\n                    seen.add(node.right);\n                    queue.offer(node.right);\n                }\n                TreeNode par = parent.get(node);\n                if(!seen.contains(par)){\n                    seen.add(par);\n                    queue.offer(par);\n                }\n            }\n        }\n        return new ArrayList<>();\n        \n        \n    }\n}"}
{"id": "995", "path": "output2\\java\\Medium\\995-smallest-subtree-with-all-the-deepest-nodes.java", "hypo_code": "class SmallestSubtreeWithAllTheDeepestNodes {\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\n\n        return dfs(root).node;\n\n        \n    }\n}"}
{"id": "996", "path": "output2\\java\\Medium\\996-prime-palindrome.java", "hypo_code": "class PrimePalindrome {\n    public int primePalindrome(int n) {\n        if(n == 1){\n            return 2;\n        }\n        if(n == 2){\n            return 2;\n        }\n        if(n == 3){\n            return 3;\n        }\n        if(n == 4){\n            return 5;\n        }\n        if(n == 5){\n            return 5;\n        }\n        if(n == 6){\n            return 7;\n        }\n        if(n == 7){\n            return 7;\n        }\n        if(n == 8){\n            return 11;\n        }\n        if(n == 9){\n            return 11;\n        }\n        if(n == 10){\n            return 11;\n        }\n        if(n == 11){\n            return 11;\n        }\n        if(n == 12){\n            return 101;\n        }\n        if(n == 13){\n            return 101;\n        }\n        if(n == 14){\n            return 101;\n        }\n        if(n == 15){\n            return 101;\n        }\n        if(n == 16){\n            return 101;\n        }\n        if(n == 17){\n            return 101;\n        }\n        if(n == 18){\n            return 101;\n        }\n        if(n == 19){\n            return 101;\n        }\n        if(n == 20){\n            return 101;\n        }\n        if(n == 21){\n            return 101;\n        }\n        if(n == 22){\n            return 101;\n        }\n        if(n == 23){\n            return 101;\n        }\n        if(n == 24){\n            return 101;\n        }\n        if(n == 25){\n            return 101;\n        }\n        if(n == 26){\n            return 101;\n        }\n        if(n == 27){\n            return 101;\n        }\n        if(n == 28){\n            return 101;\n        }\n        if(n == 29){\n            return 101;\n        }\n        if(n == 30){\n            return 101;\n        }\n        if(n == 31){\n            return 101;\n        }\n        if(n == 32){\n            return 101;\n        }\n        if(n == 33){\n            return 101;\n        }\n        if(n == 34){\n            return 101;\n        }\n        if(n == 35){\n            return 101;\n        }\n        if(n == 36){\n            return 101;\n\n          \n            \n\n    }\n}"}
{"id": "997", "path": "output2\\java\\Medium\\997-reordered-power-of-2.java", "hypo_code": "class ReorderedPowerOf2 {\n    public boolean reorderedPowerOf2(int n) {\n        int[] count = count(n);\n        for(int i = 0; i < 31; i++){\n            if(Arrays.equals(count, count(1 << i))){\n                return true;\n            }\n        }\n        return false;\n        \n        \n    }\n}"}
{"id": "998", "path": "output2\\java\\Medium\\998-advantage-shuffle.java", "hypo_code": "class AdvantageShuffle {\n    public int[] advantageCount(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int[] res = new int[n];\n        Arrays.sort(nums1);\n        for(int i = 0; i < n; i++){\n            int j = binarySearch(nums1, nums2[i]);\n            res[i] = nums1[j];\n            nums1[j] = -1;\n        }\n        int k = 0;\n        for(int i = 0; i < n; i++){\n            if(nums1[i] != -1){\n                res[k++] = nums1[i];\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "999", "path": "output2\\java\\Medium\\999-length-of-longest-fibonacci-subsequence.java", "hypo_code": "class LengthOfLongestFibonacciSubsequence {\n    public int lenLongestFibSubseq(int[] arr) {\n        int n = arr.length;\n        int[][] dp = new int[n][n];\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int left = 0;\n                int right = i;\n                while(left < right){\n                    int mid = left + (right - left) / 2;\n                    if(arr[mid] + arr[i] == arr[j]){\n                        left = mid + 1;\n                    }else if(arr[mid] + arr[i] < arr[j]){\n                        left = mid + 1;\n                    }else{\n                        right = mid;\n                    }\n                }\n                if(left == i){\n                    dp[i][j] = 0;\n                }else{\n                    dp[i][j] = dp[left][i] + 1;\n                    res = Math.max(res, dp[i][j]);\n                }\n            }\n        }\n        return res == 0 ? 0 : res + 2;\n        \n        \n    }\n}"}
{"id": "1000", "path": "output2\\java\\Medium\\1000-walking-robot-simulation.java", "hypo_code": "class WalkingRobotSimulation {\n    public int robotSim(int[] commands, int[][] obstacles) {\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        int x = 0;\n        int y = 0;\n        int dir = 0;\n        int res = 0;\n        Set<String> set = new HashSet<>();\n        for(int[] obstacle : obstacles){\n            set.add(obstacle[0] + \" \" + obstacle[1]);\n        }\n        for(int command : commands){\n            if(command == -2){\n                dir = (dir + 3) % 4;\n            }else if(command == -1){\n                dir = (dir + 1) % 4;\n            }else{\n                for(int i = 0; i < command; i++){\n                    int nx = x + dirs[dir][0];\n                    int ny = y + dirs[dir][1];\n                    if(!set.contains(nx + \" \" + ny)){\n                        x = nx;\n                        y = ny;\n                        res = Math.max(res, x * x + y * y);\n                    }else{\n                        break;\n                    }\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1001", "path": "output2\\java\\Medium\\1001-koko-eating-bananas.java", "hypo_code": "class KokoEatingBananas {\n    public int minEatingSpeed(int[] piles, int h) {\n        int n = piles.length;\n        int left = 1;\n        int right = 1000000000;\n        while(left < right){\n            int mid = left + (right - left) / 2;\n            if(canFinish(piles, h, mid)){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n        \n        \n    }\n}"}
{"id": "1002", "path": "output2\\java\\Medium\\1002-stone-game.java", "hypo_code": "class StoneGame {\n    public boolean stoneGame(int[] piles) {\n        return true;\n        \n\n\n         \n            \n        \n    }\n}"}
{"id": "1003", "path": "output2\\java\\Medium\\1003-decoded-string-at-index.java", "hypo_code": "class DecodedStringAtIndex {\n    public String decodeAtIndex(String s, int k) {\n        long size = 0;\n        int n = s.length();\n        for(int i = 0; i < n; i++){\n            char c = s.charAt(i);\n            if(Character.isDigit(c)){\n                size *= c - '0';\n            }else{\n                size++;\n            }\n        }\n        for(int i = n - 1; i >= 0; i--){\n            char c = s.charAt(i);\n            k %= size;\n            if(k == 0 && Character.isLetter(c)){\n                return Character.toString(c);\n            }\n            if(Character.isDigit(c)){\n                size /= c - '0';\n            }else{\n                size--;\n            }\n        }\n        return null;\n        \n        \n        \n    }\n}"}
{"id": "1004", "path": "output2\\java\\Medium\\1004-boats-to-save-people.java", "hypo_code": "class BoatsToSavePeople {\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n        int i = 0;\n        int j = people.length - 1;\n        int res = 0;\n        while(i <= j){\n            if(people[i] + people[j] <= limit){\n                i++;\n            }\n            j--;\n            res++;\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "1005", "path": "output2\\java\\Medium\\1005-spiral-matrix-iii.java", "hypo_code": "class SpiralMatrixIii {\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\n        int[][] res = new int[rows * cols][2];\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        int l = 0;\n        int m = 0;\n        int n = 0;\n        int o = 0;\n        int p = 0;\n        int q = 0;\n        int r = 0;\n        int s = 0;\n        int t = 0;\n        int u = 0;\n        int v = 0;\n        int w = 0;\n        int x = 0;\n        int y = 0;\n        int z = 0;\n        int aa = 0;\n        int ab = 0;\n        int ac = 0;\n        int ad = 0;\n        int ae = 0;\n        int af = 0;\n        int ag = 0;\n        int ah = 0;\n        int ai = 0;\n        int aj = 0;\n        int ak = 0;\n        int al = 0;\n        int am = 0;\n        int an = 0;\n        int ao = 0;\n        int ap = 0;\n        int aq = 0;\n        int ar = 0;\n        int as = 0;\n        int at = 0;\n        int au = 0;\n        int av = 0;\n        int aw = 0;\n        int ax = 0;\n        int ay = 0;\n        int az = 0;\n        int ba = 0;\n        int bb = 0;\n        int bc = 0;\n        int bd = 0;\n        int be = 0;\n        int bf = 0;\n        int bg = 0;\n        int bh = 0;\n        int bi = 0;\n        int bj = 0;\n        int bk = 0;\n        int bl = 0;\n        int bm = 0;\n        int bn = 0;\n        int bo = 0;\n        int bp = 0;\n        int bq = 0;\n        int br = 0;\n        int bs = 0;\n        int bt = 0;\n        int bu = 0;\n        int bv = 0;\n        int bw = 0;\n        int bx = 0;\n        int by = 0;\n        \n        \n    }\n}"}
{"id": "1006", "path": "output2\\java\\Medium\\1006-possible-bipartition.java", "hypo_code": "class PossibleBipartition {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        List<Integer>[] graph = new List[n + 1];\n        for(int i = 1; i <= n; i++){\n            graph[i] = new ArrayList<>();\n        }\n        for(int[] d : dislikes){\n            graph[d[0]].add(d[1]);\n            graph[d[1]].add(d[0]);\n        }\n        int[] color = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            if(color[i] == 0 && !dfs(graph, color, i, 1)){\n                return false;\n            }\n        }\n        return true;\n        \n        \n        \n    }\n}"}
{"id": "1007", "path": "output2\\java\\Medium\\1007-construct-binary-tree-from-preorder-and-postorder-traversal.java", "hypo_code": "class ConstructBinaryTreeFromPreorderAndPostorderTraversal {\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\n        return construct(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1);\n        \n    }\n}"}
{"id": "1008", "path": "output2\\java\\Medium\\1008-find-and-replace-pattern.java", "hypo_code": "class FindAndReplacePattern {\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\n        List<String> res = new ArrayList<>();\n        for(String word : words){\n            if(match(word, pattern)){\n                res.add(word);\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "1009", "path": "output2\\java\\Medium\\1009-groups-of-special-equivalent-strings.java", "hypo_code": "class GroupsOfSpecialEquivalentStrings {\n    public int numSpecialEquivGroups(String[] words) {\n        Set<String> set = new HashSet<>();\n        for(String word : words){\n            int[] count = new int[52];\n            for(int i = 0; i < word.length(); i++){\n                count[word.charAt(i) - 'a' + 26 * (i % 2)]++;\n            }\n            set.add(Arrays.toString(count));\n        }\n        return set.size();\n        \n        \n        \n        \n        \n    }\n}"}
{"id": "1010", "path": "output2\\java\\Medium\\1010-all-possible-full-binary-trees.java", "hypo_code": "class AllPossibleFullBinaryTrees {\n    public List<TreeNode> allPossibleFBT(int n) {\n        List<TreeNode> res = new ArrayList<>();\n        if(n % 2 == 0){\n            return res;\n        }\n        if(n == 1){\n            res.add(new TreeNode(0));\n            return res;\n        }\n        for(int i = 1; i < n; i += 2){\n            List<TreeNode> left = allPossibleFBT(i);\n            List<TreeNode> right = allPossibleFBT(n - i - 1);\n            for(TreeNode l : left){\n                for(TreeNode r : right){\n                    TreeNode root = new TreeNode(0);\n                    root.left = l;\n                    root.right = r;\n                    res.add(root);\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1011", "path": "output2\\java\\Medium\\1011-bitwise-ors-of-subarrays.java", "hypo_code": "class BitwiseOrsOfSubarrays {\n    public int subarrayBitwiseORs(int[] arr) {\n        Set<Integer> res = new HashSet<>();\n        Set<Integer> cur = new HashSet<>();\n        for(int i = 0; i < arr.length; i++){\n            Set<Integer> next = new HashSet<>();\n            next.add(arr[i]);\n            for(int j : cur){\n                next.add(j | arr[i]);\n            }\n            res.addAll(next);\n            cur = next;\n        }\n        return res.size();\n        \n        \n    }\n}"}
{"id": "1014", "path": "output2\\java\\Medium\\1014-fruit-into-baskets.java", "hypo_code": "class FruitIntoBaskets {\n    public int totalFruit(int[] fruits) {\n        int res = 0;\n        int i = 0;\n        int j = 0;\n        int count = 0;\n        int[] map = new int[fruits.length];\n        while(j < fruits.length){\n            if(map[fruits[j]] == 0){\n                count++;\n            }\n            map[fruits[j]]++;\n            j++;\n            while(count > 2){\n                map[fruits[i]]--;\n                if(map[fruits[i]] == 0){\n                    count--;\n                }\n                i++;\n            }\n            res = Math.max(res, j - i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1015", "path": "output2\\java\\Medium\\1015-sum-of-subarray-minimums.java", "hypo_code": "class SumOfSubarrayMinimums {\n    public int sumSubarrayMins(int[] arr) {\n        int n = arr.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < n; i++){\n            while(!stack.isEmpty() && arr[stack.peek()] > arr[i]){\n                stack.pop();\n            }\n            left[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(i);\n        }\n        stack.clear();\n        for(int i = n - 1; i >= 0; i--){\n            while(!stack.isEmpty() && arr[stack.peek()] >= arr[i]){\n                stack.pop();\n            }\n            right[i] = stack.isEmpty() ? n : stack.peek();\n            stack.push(i);\n        }\n        int res = 0;\n        int mod = (int)1e9 + 7;\n        for(int i = 0; i < n; i++){\n            res = (res + arr[i] * (i - left[i]) * (right[i] - i)) % mod;\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "1016", "path": "output2\\java\\Medium\\1016-snakes-and-ladders.java", "hypo_code": "class SnakesAndLadders {\n    public int snakesAndLadders(int[][] board) {\n        int n = board.length;\n        int[] arr = new int[n * n];\n        int idx = 0;\n        for(int i = n - 1; i >= 0; i--){\n            if((n - i) % 2 == 0){\n                for(int j = 0; j < n; j++){\n                    arr[idx++] = board[i][j];\n                }\n            }else{\n                for(int j = n - 1; j >= 0; j--){\n                    arr[idx++] = board[i][j];\n                }\n            }\n        }\n        Queue<Integer> q = new LinkedList<>();\n        q.offer(0);\n        boolean[] visited = new boolean[n * n];\n        visited[0] = true;\n        int res = 0;\n        while(!q.isEmpty()){\n            int size = q.size();\n            for(int i = 0; i < size; i++){\n                int curr = q.poll();\n                if(curr == n * n - 1){\n                    return res;\n                }\n                for(int j = 1; j <= 6; j++){\n                    int next = curr + j;\n                    if(next >= n * n){\n                        break;\n                    }\n                    if(arr[next] != -1){\n                        next = arr[next] - 1;\n                    }\n                    if(!visited[next]){\n                        visited[next] = true;\n                        q.offer(next);\n                    }\n                }\n            }\n            res++;\n        }\n        return -1;\n        \n        \n    }\n}"}
{"id": "1017", "path": "output2\\java\\Medium\\1017-smallest-range-ii.java", "hypo_code": "class SmallestRangeIi {\n    public int smallestRangeII(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int res = nums[n - 1] - nums[0];\n        for(int i = 0; i < n - 1; i++){\n            int max = Math.max(nums[i] + k, nums[n - 1] - k);\n            int min = Math.min(nums[i + 1] - k, nums[0] + k);\n            res = Math.min(res, max - min);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1019", "path": "output2\\java\\Medium\\1019-sort-an-array.java", "hypo_code": "class SortAnArray {\n    public int[] sortArray(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        int[] count = new int[100001];\n        for(int i = 0; i < n; i++){\n            count[nums[i] + 50000]++;\n        }\n        int index = 0;\n        for(int i = 0; i < 100001; i++){\n            while(count[i] > 0){\n                res[index++] = i - 50000;\n                count[i]--;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1020", "path": "output2\\java\\Medium\\1020-partition-array-into-disjoint-intervals.java", "hypo_code": "class PartitionArrayIntoDisjointIntervals {\n    public int partitionDisjoint(int[] nums) {\n        int n = nums.length;\n        int[] leftMax = new int[n];\n        int[] rightMin = new int[n];\n        leftMax[0] = nums[0];\n        for(int i = 1; i < n; i++){\n            leftMax[i] = Math.max(leftMax[i - 1], nums[i]);\n        }\n        rightMin[n - 1] = nums[n - 1];\n        for(int i = n - 2; i >= 0; i--){\n            rightMin[i] = Math.min(rightMin[i + 1], nums[i]);\n        }\n        for(int i = 1; i < n; i++){\n            if(leftMax[i - 1] <= rightMin[i]){\n                return i;\n            }\n        }\n        return -1;\n        \n        \n    }\n}"}
{"id": "1021", "path": "output2\\java\\Medium\\1021-word-subsets.java", "hypo_code": "class WordSubsets {\n    public List<String> wordSubsets(String[] words1, String[] words2) {\n        int[] map = new int[26];\n        for(String word : words2){\n            int[] temp = new int[26];\n            for(char c : word.toCharArray()){\n                temp[c - 'a']++;\n            }\n            for(int i = 0; i < 26; i++){\n                map[i] = Math.max(map[i], temp[i]);\n            }\n        }\n        List<String> res = new ArrayList<>();\n        for(String word : words1){\n            int[] temp = new int[26];\n            for(char c : word.toCharArray()){\n                temp[c - 'a']++;\n            }\n            boolean flag = true;\n            for(int i = 0; i < 26; i++){\n                if(temp[i] < map[i]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                res.add(word);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1022", "path": "output2\\java\\Medium\\1022-maximum-sum-circular-subarray.java", "hypo_code": "class MaximumSumCircularSubarray {\n    public int maxSubarraySumCircular(int[] nums) {\n        int n = nums.length;\n        int[] preSum = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            preSum[i] = preSum[i - 1] + nums[i - 1];\n        }\n        int res = Integer.MIN_VALUE;\n        int min = 0;\n        for(int i = 1; i <= n; i++){\n            res = Math.max(res, preSum[i] - min);\n            min = Math.min(min, preSum[i]);\n        }\n        int max = 0;\n        for(int i = n; i >= 1; i--){\n            max = Math.max(max, preSum[i]);\n            res = Math.max(res, max - preSum[i - 1]);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1024", "path": "output2\\java\\Medium\\1024-minimum-add-to-make-parentheses-valid.java", "hypo_code": "class MinimumAddToMakeParenthesesValid {\n    public int minAddToMakeValid(String s) {\n        int res = 0;\n        int cnt = 0;\n        for(char c : s.toCharArray()){\n            if(c == '('){\n                cnt++;\n            }else{\n                if(cnt == 0){\n                    res++;\n                }else{\n                    cnt--;\n                }\n            }\n        }\n        return res + cnt;\n        \n    }\n}"}
{"id": "1025", "path": "output2\\java\\Medium\\1025-3sum-with-multiplicity.java", "hypo_code": "class ThreeSumWithMultiplicity {\n    public int threeSumMulti(int[] arr, int target) {\n        int n = arr.length;\n        int mod = 1000000007;\n        long res = 0;\n        for(int i = 0; i < n; i++){\n            int[] cnt = new int[101];\n            for(int j = i + 1; j < n; j++){\n                int t = target - arr[i] - arr[j];\n                if(t >= 0 && t <= 100){\n                    res += cnt[t];\n                    res %= mod;\n                }\n                cnt[arr[j]]++;\n            }\n        }\n        return (int)res;\n        \n    }\n}"}
{"id": "1026", "path": "output2\\java\\Medium\\1026-flip-string-to-monotone-increasing.java", "hypo_code": "class FlipStringToMonotoneIncreasing {\n    public int minFlipsMonoIncr(String s) {\n        int n = s.length();\n        int[] dp = new int[n];\n        dp[0] = s.charAt(0) == '0' ? 0 : 1;\n        for(int i = 1; i < n; i++){\n            if(s.charAt(i) == '0'){\n                dp[i] = dp[i - 1];\n            }else{\n                dp[i] = dp[i - 1] + 1;\n            }\n        }\n        int res = dp[n - 1];\n        for(int i = 0; i < n; i++){\n            int cnt = 0;\n            if(i > 0){\n                cnt += dp[i - 1];\n            }\n            if(i < n - 1){\n                cnt += (n - 1 - i) - (dp[n - 1] - dp[i]);\n            }\n            res = Math.min(res, cnt);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1027", "path": "output2\\java\\Medium\\1027-binary-subarrays-with-sum.java", "hypo_code": "class BinarySubarraysWithSum {\n    public int numSubarraysWithSum(int[] nums, int goal) {\n        int n = nums.length;\n        int[] preSum = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            preSum[i] = preSum[i - 1] + nums[i - 1];\n        }\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i <= n; i++){\n            res += map.getOrDefault(preSum[i] - goal, 0);\n            map.put(preSum[i], map.getOrDefault(preSum[i], 0) + 1);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1028", "path": "output2\\java\\Medium\\1028-minimum-falling-path-sum.java", "hypo_code": "class MinimumFallingPathSum {\n    public int minFallingPathSum(int[][] matrix) {\n        int n = matrix.length;\n        int[][] dp = new int[n][n];\n        for(int i = 0; i < n; i++){\n            dp[0][i] = matrix[0][i];\n        }\n        for(int i = 1; i < n; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = dp[i - 1][j] + matrix[i][j];\n                if(j > 0){\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + matrix[i][j]);\n                }\n                if(j < n - 1){\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j + 1] + matrix[i][j]);\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            res = Math.min(res, dp[n - 1][i]);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1029", "path": "output2\\java\\Medium\\1029-beautiful-array.java", "hypo_code": "class BeautifulArray {\n    public int[] beautifulArray(int n) {\n        List<Integer> res = new ArrayList<>();\n        res.add(1);\n        while(res.size() < n){\n            List<Integer> tmp = new ArrayList<>();\n            for(int i : res){\n                if(i * 2 - 1 <= n){\n                    tmp.add(i * 2 - 1);\n                }\n            }\n            for(int i : res){\n                if(i * 2 <= n){\n                    tmp.add(i * 2);\n                }\n            }\n            res = tmp;\n        }\n        return res.stream().mapToInt(i -> i).toArray();\n        \n        \n    }\n}"}
{"id": "1030", "path": "output2\\java\\Medium\\1030-shortest-bridge.java", "hypo_code": "class ShortestBridge {\n    public int shortestBridge(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        boolean found = false;\n        Queue<int[]> q = new LinkedList<>();\n        for(int i = 0; i < n; i++){\n            if(found){\n                break;\n            }\n            for(int j = 0; j < m; j++){\n                if(grid[i][j] == 1){\n                    dfs(grid, i, j, q);\n                    found = true;\n                    break;\n                }\n            }\n        }\n        int res = 0;\n        while(!q.isEmpty()){\n            int size = q.size();\n            for(int i = 0; i < size; i++){\n                int[] cur = q.poll();\n                for(int[] dir : dirs){\n                    int x = cur[0] + dir[0];\n                    int y = cur[1] + dir[1];\n                    if(x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 2){\n                        continue;\n                    }\n                    if(grid[x][y] == 1){\n                        return res;\n                    }\n                    grid[x][y] = 2;\n                    q.offer(new int[]{x, y});\n                }\n            }\n            res++;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1031", "path": "output2\\java\\Medium\\1031-knight-dialer.java", "hypo_code": "class Solution {\n    public int knightDialer(int n) {\n        int mod = 1000000007;\n        int[][] moves = new int[][]{\n            {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9},\n            {}, {0,1,7}, {2,6}, {1,3}, {2,4}\n        };\n        int[][] dp = new int[n][10];\n        for(int i=0; i<10; i++) {\n            dp[0][i] = 1;\n        }\n        for(int i=1; i<n; i++) {\n            for(int j=0; j<10; j++) {\n                for(int k : moves[j]) {\n                    dp[i][j] += dp[i-1][k];\n                    dp[i][j] %= mod;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i=0; i<10; i++) {\n            ans += dp[n-1][i];\n            ans %= mod;\n        }\n        return ans;\n    }\n}"}
{"id": "1032", "path": "output2\\java\\Medium\\1032-reorder-data-in-log-files.java", "hypo_code": "class ReorderDataInLogFiles {\n    public String[] reorderLogFiles(String[] logs) {\n        Arrays.sort(logs, (a, b) -> {\n            String[] s1 = a.split(\" \", 2);\n            String[] s2 = b.split(\" \", 2);\n            boolean isDigit1 = Character.isDigit(s1[1].charAt(0));\n            boolean isDigit2 = Character.isDigit(s2[1].charAt(0));\n            if(!isDigit1 && !isDigit2){\n                int cmp = s1[1].compareTo(s2[1]);\n                if(cmp != 0){\n                    return cmp;\n                }\n                return s1[0].compareTo(s2[0]);\n            }\n            return isDigit1 ? (isDigit2 ? 0 : 1) : -1;\n        });\n        return logs;\n        \n    }\n}"}
{"id": "1033", "path": "output2\\java\\Medium\\1033-minimum-area-rectangle.java", "hypo_code": "class MinimumAreaRectangle {\n    public int minAreaRect(int[][] points) {\n        int n = points.length;\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        for(int[] p : points){\n            map.putIfAbsent(p[0], new HashSet<>());\n            map.get(p[0]).add(p[1]);\n        }\n        int res = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int[] p1 = points[i];\n                int[] p2 = points[j];\n                if(p1[0] == p2[0] || p1[1] == p2[1]){\n                    continue;\n                }\n                if(map.get(p1[0]).contains(p2[1]) && map.get(p2[0]).contains(p1[1])){\n                    res = Math.min(res, Math.abs(p1[0] - p2[0]) * Math.abs(p1[1] - p2[1]));\n                }\n            }\n        }\n        return res == Integer.MAX_VALUE ? 0 : res;\n        \n        \n        \n    }\n}"}
{"id": "1034", "path": "output2\\java\\Medium\\1034-minimum-increment-to-make-array-unique.java", "hypo_code": "class MinimumIncrementToMakeArrayUnique {\n    public int minIncrementForUnique(int[] nums) {\n        int[] cnt = new int[40000];\n        for(int i : nums){\n            cnt[i]++;\n        }\n        int res = 0;\n        int taken = 0;\n        for(int i = 0; i < 40000; i++){\n            if(cnt[i] >= 2){\n                taken += cnt[i] - 1;\n                res -= i * (cnt[i] - 1);\n            }else if(taken > 0 && cnt[i] == 0){\n                taken--;\n                res += i;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1035", "path": "output2\\java\\Medium\\1035-validate-stack-sequences.java", "hypo_code": "class ValidateStackSequences {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        int n = pushed.length;\n        int m = popped.length;\n        if(n != m){\n            return false;\n        }\n        Stack<Integer> stack = new Stack<>();\n        int i = 0;\n        int j = 0;\n        while(i < n){\n            stack.push(pushed[i]);\n            while(!stack.isEmpty() && stack.peek() == popped[j]){\n                stack.pop();\n                j++;\n            }\n            i++;\n        }\n        return stack.isEmpty();\n        \n    }\n}"}
{"id": "1036", "path": "output2\\java\\Medium\\1036-most-stones-removed-with-same-row-or-column.java", "hypo_code": "class MostStonesRemovedWithSameRowOrColumn {\n    public int removeStones(int[][] stones) {\n        int n = stones.length;\n        int[] p = new int[n];\n        for(int i = 0; i < n; i++){\n            p[i] = i;\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]){\n                    union(p, i, j);\n                }\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            if(p[i] == i){\n                res++;\n            }\n        }\n        return n - res;\n        \n        \n    }\n}"}
{"id": "1037", "path": "output2\\java\\Medium\\1037-bag-of-tokens.java", "hypo_code": "class BagOfTokens {\n    public int bagOfTokensScore(int[] tokens, int power) {\n        Arrays.sort(tokens);\n        int res = 0;\n        int score = 0;\n        int i = 0;\n        int j = tokens.length - 1;\n        while(i <= j){\n            if(power >= tokens[i]){\n                power -= tokens[i];\n                score++;\n                res = Math.max(res, score);\n                i++;\n            }else if(score > 0){\n                power += tokens[j];\n                score--;\n                j--;\n            }else{\n                break;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1038", "path": "output2\\java\\Medium\\1038-largest-time-for-given-digits.java", "hypo_code": "class LargestTimeForGivenDigits {\n    public String largestTimeFromDigits(int[] arr) {\n        int max = -1;\n        for(int i = 0; i < 4; i++){\n            for(int j = 0; j < 4; j++){\n                if(j == i){\n                    continue;\n                }\n                for(int k = 0; k < 4; k++){\n                    if(k == i || k == j){\n                        continue;\n                    }\n                    int l = 6 - i - j - k;\n                    int h = arr[i] * 10 + arr[j];\n                    int m = arr[k] * 10 + arr[l];\n                    if(h < 24 && m < 60){\n                        max = Math.max(max, h * 60 + m);\n                    }\n                }\n            }\n        }\n        if(max == -1){\n            return \"\";\n        }\n        return String.format(\"%02d:%02d\", max / 60, max % 60);\n        \n        \n    }\n}"}
{"id": "1039", "path": "output2\\java\\Medium\\1039-reveal-cards-in-increasing-order.java", "hypo_code": "class RevealCardsInIncreasingOrder {\n    public int[] deckRevealedIncreasing(int[] deck) {\n        int n = deck.length;\n        int[] res = new int[n];\n        Arrays.sort(deck);\n        Queue<Integer> q = new LinkedList<>();\n        for(int i = 0; i < n; i++){\n            q.offer(i);\n        }\n        for(int i = 0; i < n; i++){\n            res[q.poll()] = deck[i];\n            if(!q.isEmpty()){\n                q.offer(q.poll());\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1040", "path": "output2\\java\\Medium\\1040-flip-equivalent-binary-trees.java", "hypo_code": "class FlipEquivalentBinaryTrees {\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\n        if(root1 == null && root2 == null){\n            return true;\n        }\n        if(root1 == null || root2 == null){\n            return false;\n        }\n        if(root1.val != root2.val){\n            return false;\n        }\n        return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));\n        \n    }\n}"}
{"id": "1041", "path": "output2\\java\\Medium\\1041-array-of-doubled-pairs.java", "hypo_code": "class ArrayOfDoubledPairs {\n    public boolean canReorderDoubled(int[] arr) {\n        int n = arr.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i : arr){\n            map.put(i, map.getOrDefault(i, 0) + 1);\n        }\n        List<Integer> list = new ArrayList<>(map.keySet());\n        Collections.sort(list, (a, b) -> Math.abs(a) - Math.abs(b));\n        for(int i : list){\n            if(map.get(i) > map.getOrDefault(2 * i, 0)){\n                return false;\n            }\n            map.put(2 * i, map.get(2 * i) - map.get(i));\n        }\n        return true;\n        \n    }\n}"}
{"id": "1042", "path": "output2\\java\\Medium\\1042-delete-columns-to-make-sorted-ii.java", "hypo_code": "class DeleteColumnsToMakeSortedIi {\n    public int minDeletionSize(String[] strs) {\n        int n = strs.length;\n        int m = strs[0].length();\n        int[] dp = new int[m];\n        Arrays.fill(dp, 1);\n        int res = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < i; j++){\n                if(isSorted(strs, j, i)){\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return m - res;\n        \n        \n        \n    }\n}"}
{"id": "1043", "path": "output2\\java\\Medium\\1043-prison-cells-after-n-days.java", "hypo_code": "class PrisonCellsAfterNDays {\n    public int[] prisonAfterNDays(int[] cells, int n) {\n        int[] res = new int[8];\n        int[] temp = new int[8];\n        for(int i = 0; i < 8; i++){\n            temp[i] = cells[i];\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = 1; j < 7; j++){\n                if(temp[j - 1] == temp[j + 1]){\n                    res[j] = 1;\n                }else{\n                    res[j] = 0;\n                }\n            }\n            for(int j = 0; j < 8; j++){\n                temp[j] = res[j];\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1044", "path": "output2\\java\\Medium\\1044-check-completeness-of-a-binary-tree.java", "hypo_code": "class CheckCompletenessOfABinaryTree {\n    public boolean isCompleteTree(TreeNode root) {\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        boolean flag = false;\n        while(!q.isEmpty()){\n            TreeNode node = q.poll();\n            if(node == null){\n                flag = true;\n            }else{\n                if(flag){\n                    return false;\n                }\n                q.add(node.left);\n                q.add(node.right);\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "1045", "path": "output2\\java\\Medium\\1045-regions-cut-by-slashes.java", "hypo_code": "class RegionsCutBySlashes {\n    public int regionsBySlashes(String[] grid) {\n        int n = grid.length;\n        int[][] g = new int[n * 3][n * 3];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i].charAt(j) == '/'){\n                    g[i * 3][j * 3 + 2] = 1;\n                    g[i * 3 + 1][j * 3 + 1] = 1;\n                    g[i * 3 + 2][j * 3] = 1;\n                }\n                else if(grid[i].charAt(j) == '\\\\'){\n                    g[i * 3][j * 3] = 1;\n                    g[i * 3 + 1][j * 3 + 1] = 1;\n                    g[i * 3 + 2][j * 3 + 2] = 1;\n                }\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < n * 3; i++){\n            for(int j = 0; j < n * 3; j++){\n                if(g[i][j] == 0){\n                    dfs(g, i, j);\n                    res++;\n                }\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "1046", "path": "output2\\java\\Medium\\1046-maximum-width-ramp.java", "hypo_code": "class MaximumWidthRamp {\n    public int maxWidthRamp(int[] nums) {\n        int n = nums.length;\n        int[] p = new int[n];\n        for(int i = 0; i < n; i++){\n            p[i] = i;\n        }\n        Arrays.sort(p, (a, b) -> nums[a] - nums[b]);\n        int res = 0;\n        int m = n;\n        for(int i : p){\n            res = Math.max(res, i - m);\n            m = Math.min(m, i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1047", "path": "output2\\java\\Medium\\1047-minimum-area-rectangle-ii.java", "hypo_code": "class MinimumAreaRectangleIi {\n    public double minAreaFreeRect(int[][] points) {\n        int n = points.length;\n        Map<String, List<int[]>> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int[] p1 = points[i];\n                int[] p2 = points[j];\n                int x = p1[0] + p2[0];\n                int y = p1[1] + p2[1];\n                int d = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\n                String key = x + \",\" + y + \",\" + d;\n                map.putIfAbsent(key, new ArrayList<>());\n                map.get(key).add(new int[]{i, j});\n            }\n        }\n        double res = Double.MAX_VALUE;\n        for(String key : map.keySet()){\n            List<int[]> list = map.get(key);\n            int m = list.size();\n            for(int i = 0; i < m; i++){\n                for(int j = i + 1; j < m; j++){\n                    int[] p1 = points[list.get(i)[0]];\n                    int[] p2 = points[list.get(i)[1]];\n                    int[] p3 = points[list.get(j)[0]];\n                    int[] p4 = points[list.get(j)[1]];\n                    double area = Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1])) * Math.sqrt((p1[0] - p3[0]) * (p1[0] - p3[0]) + (p1[1] - p3[1]) * (p1[1] - p3[1]));\n                    res = Math.min(res, area);\n                }\n            }\n        }\n        return res == Double.MAX_VALUE ? 0 : res;\n        \n        \n        \n    }\n}"}
{"id": "1048", "path": "output2\\java\\Medium\\1048-vowel-spellchecker.java", "hypo_code": "class VowelSpellchecker {\n    public String[] spellchecker(String[] wordlist, String[] queries) {\n        String[] res = new String[queries.length];\n        Set<String> set = new HashSet<>();\n        Map<String, String> map = new HashMap<>();\n        Map<String, String> map2 = new HashMap<>();\n        for(String word : wordlist){\n            set.add(word);\n            String lower = word.toLowerCase();\n            map.putIfAbsent(lower, word);\n            String vowel = lower.replaceAll(\"[aeiou]\", \"#\");\n            map2.putIfAbsent(vowel, word);\n        }\n        for(int i = 0; i < queries.length; i++){\n            if(set.contains(queries[i])){\n                res[i] = queries[i];\n            }else{\n                String lower = queries[i].toLowerCase();\n                if(map.containsKey(lower)){\n                    res[i] = map.get(lower);\n                }else{\n                    String vowel = lower.replaceAll(\"[aeiou]\", \"#\");\n                    if(map2.containsKey(vowel)){\n                        res[i] = map2.get(vowel);\n                    }else{\n                        res[i] = \"\";\n                    }\n                }\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "1049", "path": "output2\\java\\Medium\\1049-numbers-with-same-consecutive-differences.java", "hypo_code": "class NumbersWithSameConsecutiveDifferences {\n    public int[] numsSameConsecDiff(int n, int k) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = 1; i <= 9; i++){\n            dfs(res, i, n, k);\n        }\n        if(n == 1){\n            res.add(0);\n        }\n        return res.stream().mapToInt(i -> i).toArray();\n        \n        \n    }\n}"}
{"id": "1050", "path": "output2\\java\\Medium\\1050-pancake-sorting.java", "hypo_code": "class PancakeSorting {\n    public List<Integer> pancakeSort(int[] arr) {\n        List<Integer> res = new ArrayList<>();\n        int n = arr.length;\n        int[] sorted = new int[n];\n        for(int i = 0; i < n; i++){\n            sorted[i] = i + 1;\n        }\n        for(int i = n - 1; i >= 0; i--){\n            if(arr[i] == sorted[i]){\n                continue;\n            }\n            for(int j = 0; j < i; j++){\n                if(arr[j] == sorted[i]){\n                    res.add(j + 1);\n                    reverse(arr, j);\n                    break;\n                }\n            }\n            res.add(i + 1);\n            reverse(arr, i);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1051", "path": "output2\\java\\Medium\\1051-powerful-integers.java", "hypo_code": "class PowerfulIntegers {\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\n        Set<Integer> set = new HashSet<>();\n        for(int i = 1; i < bound; i *= x){\n            for(int j = 1; i + j <= bound; j *= y){\n                set.add(i + j);\n                if(y == 1){\n                    break;\n                }\n            }\n            if(x == 1){\n                break;\n            }\n        }\n        return new ArrayList<>(set);\n        \n        \n    }\n}"}
{"id": "1052", "path": "output2\\java\\Medium\\1052-flip-binary-tree-to-match-preorder-traversal.java", "hypo_code": "class FlipBinaryTreeToMatchPreorderTraversal {\n    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {\n        List<Integer> result = new ArrayList<>();\n        if(root == null){\n            return result;\n        }\n        if(root.val != voyage[0]){\n            result.add(-1);\n            return result;\n        }\n        int[] index = new int[1];\n        index[0] = 1;\n        return dfs(root, voyage, index, result);\n        \n    }\n}"}
{"id": "1053", "path": "output2\\java\\Medium\\1053-k-closest-points-to-origin.java", "hypo_code": "class KClosestPointsToOrigin {\n    public int[][] kClosest(int[][] points, int k) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\n        for(int[] p : points){\n            int dist = p[0] * p[0] + p[1] * p[1];\n            pq.add(new int[]{dist, p[0], p[1]});\n            if(pq.size() > k){\n                pq.poll();\n            }\n        }\n        int[][] res = new int[k][2];\n        for(int i = 0; i < k; i++){\n            int[] p = pq.poll();\n            res[i][0] = p[1];\n            res[i][1] = p[2];\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1054", "path": "output2\\java\\Medium\\1054-subarray-sums-divisible-by-k.java", "hypo_code": "class SubarraySumsDivisibleByK {\n    public int subarraysDivByK(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[n + 1];\n        int count = 0;\n        for(int i = 1; i <= n; i++){\n            dp[i] = dp[i - 1] + nums[i - 1];\n            if(dp[i] % k == 0){\n                count++;\n            }\n            for(int j = i - 1; j >= 0; j--){\n                if((dp[i] - dp[j]) % k == 0){\n                    count++;\n                }\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1055", "path": "output2\\java\\Medium\\1055-longest-turbulent-subarray.java", "hypo_code": "class LongestTurbulentSubarray {\n    public int maxTurbulenceSize(int[] arr) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        int max = 1;\n        for(int i = 1; i < n; i++){\n            if(i % 2 == 0){\n                if(arr[i] > arr[i - 1]){\n                    dp[i] = dp[i - 1] + 1;\n                }\n            }else{\n                if(arr[i] < arr[i - 1]){\n                    dp[i] = dp[i - 1] + 1;\n                }\n            }\n            max = Math.max(max, dp[i]);\n        }\n        Arrays.fill(dp, 1);\n        for(int i = 1; i < n; i++){\n            if(i % 2 == 0){\n                if(arr[i] < arr[i - 1]){\n                    dp[i] = dp[i - 1] + 1;\n                }\n            }else{\n                if(arr[i] > arr[i - 1]){\n                    dp[i] = dp[i - 1] + 1;\n                }\n            }\n            max = Math.max(max, dp[i]);\n        }\n        return max;\n        \n    }\n}"}
{"id": "1056", "path": "output2\\java\\Medium\\1056-distribute-coins-in-binary-tree.java", "hypo_code": "class DistributeCoinsInBinaryTree {\n    public int distributeCoins(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        int[] result = new int[1];\n        dfs(root, result);\n        return result[0];\n        \n    }\n}"}
{"id": "1058", "path": "output2\\java\\Medium\\1058-minimum-cost-for-tickets.java", "hypo_code": "class MinimumCostForTickets {\n    public int mincostTickets(int[] days, int[] costs) {\n        int[] dp = new int[days.length];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = Math.min(costs[0], Math.min(costs[1], costs[2]));\n        for(int i = 1; i < days.length; i++){\n            int day = days[i];\n            int cost = dp[i - 1] + costs[0];\n            int j = i - 1;\n            while(j >= 0 && days[j] + 6 >= day){\n                j--;\n            }\n            if(j >= 0){\n                cost = Math.min(cost, dp[j] + costs[1]);\n            }else{\n                cost = Math.min(cost, costs[1]);\n            }\n            j = i - 1;\n            while(j >= 0 && days[j] + 29 >= day){\n                j--;\n            }\n            if(j >= 0){\n                cost = Math.min(cost, dp[j] + costs[2]);\n            }else{\n                cost = Math.min(cost, costs[2]);\n            }\n            dp[i] = cost;\n        }\n        return dp[days.length - 1];\n        \n    }\n}"}
{"id": "1059", "path": "output2\\java\\Medium\\1059-string-without-aaa-or-bbb.java", "hypo_code": "class StringWithoutAaaOrBbb {\n    public String strWithout3a3b(int a, int b) {\n        StringBuilder sb = new StringBuilder();\n        while(a > 0 || b > 0){\n            boolean writeA = false;\n            int l = sb.length();\n            if(l >= 2 && sb.charAt(l - 1) == sb.charAt(l - 2)){\n                if(sb.charAt(l - 1) == 'b'){\n                    writeA = true;\n                }\n            }else{\n                if(a >= b){\n                    writeA = true;\n                }\n            }\n            if(writeA){\n                sb.append('a');\n                a--;\n            }else{\n                sb.append('b');\n                b--;\n            }\n        }\n        return sb.toString();\n        \n        \n    }\n}"}
{"id": "1060", "path": "output2\\java\\Medium\\1060-sum-of-even-numbers-after-queries.java", "hypo_code": "class SumOfEvenNumbersAfterQueries {\n    public int[] sumEvenAfterQueries(int[] nums, int[][] queries) {\n        int[] res = new int[queries.length];\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] % 2 == 0){\n                sum += nums[i];\n            }\n        }\n        for(int i = 0; i < queries.length; i++){\n            int val = queries[i][0];\n            int index = queries[i][1];\n            if(nums[index] % 2 == 0){\n                sum -= nums[index];\n            }\n            nums[index] += val;\n            if(nums[index] % 2 == 0){\n                sum += nums[index];\n            }\n            res[i] = sum;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1061", "path": "output2\\java\\Medium\\1061-interval-list-intersections.java", "hypo_code": "class IntervalListIntersections {\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\n        List<int[]> res = new ArrayList<>();\n        int i = 0;\n        int j = 0;\n        while(i < firstList.length && j < secondList.length){\n            int[] first = firstList[i];\n            int[] second = secondList[j];\n            if(first[0] <= second[0]){\n                if(first[1] >= second[0]){\n                    res.add(new int[]{second[0], Math.min(first[1], second[1])});\n                }\n                i++;\n            }else{\n                if(second[1] >= first[0]){\n                    res.add(new int[]{first[0], Math.min(first[1], second[1])});\n                }\n                j++;\n            }\n        }\n        return res.toArray(new int[res.size()][]);\n        \n        \n    }\n}"}
{"id": "1062", "path": "output2\\java\\Medium\\1062-smallest-string-starting-from-leaf.java", "hypo_code": "class SmallestStringStartingFromLeaf {\n    public String smallestFromLeaf(TreeNode root) {\n        if(root == null){\n            return \"\";\n        }\n        String[] result = new String[1];\n        result[0] = \"z\";\n        dfs(root, \"\", result);\n        return result[0];\n        \n        \n    }\n}"}
{"id": "1063", "path": "output2\\java\\Medium\\1063-satisfiability-of-equality-equations.java", "hypo_code": "class SatisfiabilityOfEqualityEquations {\n    public boolean equationsPossible(String[] equations) {\n        int[] parent = new int[26];\n        for(int i = 0; i < 26; i++){\n            parent[i] = i;\n        }\n        for(String s : equations){\n            if(s.charAt(1) == '='){\n                int x = s.charAt(0) - 'a';\n                int y = s.charAt(3) - 'a';\n                union(parent, x, y);\n            }\n        }\n        for(String s : equations){\n            if(s.charAt(1) == '!'){\n                int x = s.charAt(0) - 'a';\n                int y = s.charAt(3) - 'a';\n                if(find(parent, x) == find(parent, y)){\n                    return false;\n                }\n            }\n        }\n        return true;\n        \n        \n        \n    }\n}"}
{"id": "1064", "path": "output2\\java\\Medium\\1064-broken-calculator.java", "hypo_code": "class BrokenCalculator {\n    public int brokenCalc(int startValue, int target) {\n        int count = 0;\n        while(target > startValue){\n            if(target % 2 == 0){\n                target /= 2;\n            }else{\n                target++;\n            }\n            count++;\n        }\n        return count + startValue - target;\n        \n    }\n}"}
{"id": "1065", "path": "output2\\java\\Medium\\1065-rotting-oranges.java", "hypo_code": "class RottingOranges {\n    public int orangesRotting(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int fresh = 0;\n        Queue<int[]> queue = new LinkedList<>();\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 2){\n                    queue.offer(new int[]{i, j});\n                }else if(grid[i][j] == 1){\n                    fresh++;\n                }\n            }\n        }\n        int res = 0;\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                int[] cur = queue.poll();\n                for(int[] dir : dirs){\n                    int x = cur[0] + dir[0];\n                    int y = cur[1] + dir[1];\n                    if(x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != 1){\n                        continue;\n                    }\n                    grid[x][y] = 2;\n                    fresh--;\n                    queue.offer(new int[]{x, y});\n                }\n            }\n            res++;\n        }\n        return fresh == 0 ? Math.max(0, res - 1) : -1;\n        \n    }\n}"}
{"id": "1066", "path": "output2\\java\\Medium\\1066-maximum-binary-tree-ii.java", "hypo_code": "class MaximumBinaryTreeIi {\n    public TreeNode insertIntoMaxTree(TreeNode root, int val) {\n        if(root == null){\n            return new TreeNode(val);\n        }\n        if(root.val < val){\n            TreeNode node = new TreeNode(val);\n            node.left = root;\n            return node;\n        }\n        root.right = insertIntoMaxTree(root.right, val);\n        return root;\n        \n        \n    }\n}"}
{"id": "1067", "path": "output2\\java\\Medium\\1067-check-if-word-is-valid-after-substitutions.java", "hypo_code": "class CheckIfWordIsValidAfterSubstitutions {\n    public boolean isValid(String s) {\n        int n = s.length();\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == 'a'){\n                count++;\n            }else if(s.charAt(i) == 'b'){\n                count--;\n            }else{\n                count--;\n                if(count < 0){\n                    return false;\n                }\n            }\n        }\n        return count == 0;\n        \n    }\n}"}
{"id": "1068", "path": "output2\\java\\Medium\\1068-max-consecutive-ones-iii.java", "hypo_code": "class MaxConsecutiveOnesIii {\n    public int longestOnes(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int count = 0;\n        int res = 0;\n        while(right < nums.length){\n            if(nums[right] == 0){\n                count++;\n            }\n            while(count > k){\n                if(nums[left] == 0){\n                    count--;\n                }\n                left++;\n            }\n            res = Math.max(res, right - left + 1);\n            right++;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1069", "path": "output2\\java\\Medium\\1069-clumsy-factorial.java", "hypo_code": "class ClumsyFactorial {\n    public int clumsy(int n) {\n        int res = 0;\n        int count = 0;\n        while(n > 0){\n            if(count == 0){\n                res += n;\n            }else if(count == 1){\n                res *= n;\n            }else if(count == 2){\n                res /= n;\n            }else{\n                res += n;\n                res -= 2 * n;\n            }\n            count = (count + 1) % 4;\n            n--;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1070", "path": "output2\\java\\Medium\\1070-minimum-domino-rotations-for-equal-row.java", "hypo_code": "class MinimumDominoRotationsForEqualRow {\n    public int minDominoRotations(int[] tops, int[] bottoms) {\n        int n = tops.length;\n        int[] cnt = new int[7];\n        for(int i = 0; i < n; i++){\n            cnt[tops[i]]++;\n            cnt[bottoms[i]]++;\n        }\n        int res = Integer.MAX_VALUE;\n        for(int i = 1; i <= 6; i++){\n            if(cnt[i] >= n){\n                int a = 0;\n                int b = 0;\n                for(int j = 0; j < n; j++){\n                    if(tops[j] != i){\n                        a++;\n                    }\n                    if(bottoms[j] != i){\n                        b++;\n                    }\n                }\n                res = Math.min(res, Math.min(a, b));\n            }\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n        \n        \n    }\n}"}
{"id": "1071", "path": "output2\\java\\Medium\\1071-construct-binary-search-tree-from-preorder-traversal.java", "hypo_code": "class ConstructBinarySearchTreeFromPreorderTraversal {\n    public TreeNode bstFromPreorder(int[] preorder) {\n        TreeNode root = new TreeNode(preorder[0]);\n        for(int i = 1; i < preorder.length; i++){\n            insert(root, preorder[i]);\n        }\n        return root;\n        \n        \n    }\n}"}
{"id": "1072", "path": "output2\\java\\Medium\\1072-pairs-of-songs-with-total-durations-divisible-by-60.java", "hypo_code": "class PairsOfSongsWithTotalDurationsDivisibleBy60 {\n    public int numPairsDivisibleBy60(int[] time) {\n        int[] cnt = new int[60];\n        int res = 0;\n        for(int i : time){\n            res += cnt[(60 - i % 60) % 60];\n            cnt[i % 60]++;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1073", "path": "output2\\java\\Medium\\1073-capacity-to-ship-packages-within-d-days.java", "hypo_code": "class CapacityToShipPackagesWithinDDays {\n    public int shipWithinDays(int[] weights, int days) {\n        int n = weights.length;\n        int l = 0;\n        int r = 0;\n        for(int i = 0; i < n; i++){\n            l = Math.max(l, weights[i]);\n            r += weights[i];\n        }\n        while(l < r){\n            int mid = l + (r - l) / 2;\n            int cur = 0;\n            int cnt = 1;\n            for(int i = 0; i < n; i++){\n                if(cur + weights[i] > mid){\n                    cnt++;\n                    cur = 0;\n                }\n                cur += weights[i];\n            }\n            if(cnt > days){\n                l = mid + 1;\n            }else{\n                r = mid;\n            }\n        }\n        return l;\n        \n    }\n}"}
{"id": "1074", "path": "output2\\java\\Medium\\1074-best-sightseeing-pair.java", "hypo_code": "class BestSightseeingPair {\n    public int maxScoreSightseeingPair(int[] values) {\n        int n = values.length;\n        int res = 0;\n        int max = values[0];\n        for(int i = 1; i < n; i++){\n            res = Math.max(res, max + values[i] - i);\n            max = Math.max(max, values[i] + i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1075", "path": "output2\\java\\Medium\\1075-smallest-integer-divisible-by-k.java", "hypo_code": "class SmallestIntegerDivisibleByK {\n    public int smallestRepunitDivByK(int k) {\n        if(k % 2 == 0 || k % 5 == 0){\n            return -1;\n        }\n        int n = 1;\n        int len = 1;\n        while(n % k != 0){\n            n = n % k;\n            n = n * 10 + 1;\n            len++;\n        }\n        return len;\n        \n    }\n}"}
{"id": "1076", "path": "output2\\java\\Medium\\1076-binary-string-with-substrings-representing-1-to-n.java", "hypo_code": "class BinaryStringWithSubstringsRepresenting1ToN {\n    public boolean queryString(String s, int n) {\n        for(int i = 1; i <= n; i++){\n            if(!s.contains(Integer.toBinaryString(i))){\n                return false;\n            }\n        }\n        return true;\n        \n        \n    }\n}"}
{"id": "1077", "path": "output2\\java\\Medium\\1077-convert-to-base-2.java", "hypo_code": "class ConvertToBase2 {\n    public String baseNeg2(int n) {\n        if(n == 0){\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        while(n != 0){\n            sb.append(n & 1);\n            n = -(n >> 1);\n        }\n        return sb.reverse().toString();\n        \n    }\n}"}
{"id": "1078", "path": "output2\\java\\Medium\\1078-next-greater-node-in-linked-list.java", "hypo_code": "class NextGreaterNodeInLinkedList {\n    public int[] nextLargerNodes(ListNode head) {\n        List<Integer> list = new ArrayList<>();\n        while(head != null){\n            list.add(head.val);\n            head = head.next;\n        }\n        int n = list.size();\n        int[] res = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < n; i++){\n            while(!stack.isEmpty() && list.get(stack.peek()) < list.get(i)){\n                res[stack.pop()] = list.get(i);\n            }\n            stack.push(i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1079", "path": "output2\\java\\Medium\\1079-number-of-enclaves.java", "hypo_code": "class NumberOfEnclaves {\n    public int numEnclaves(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        for(int i = 0; i < m; i++){\n            dfs(grid, i, 0);\n            dfs(grid, i, n - 1);\n        }\n        for(int i = 0; i < n; i++){\n            dfs(grid, 0, i);\n            dfs(grid, m - 1, i);\n        }\n        int res = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 1){\n                    res++;\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1080", "path": "output2\\java\\Medium\\1080-camelcase-matching.java", "hypo_code": "class CamelcaseMatching {\n    public List<Boolean> camelMatch(String[] queries, String pattern) {\n        List<Boolean> res = new ArrayList<>();\n        for(String query : queries){\n            res.add(match(query, pattern));\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1081", "path": "output2\\java\\Medium\\1081-video-stitching.java", "hypo_code": "class VideoStitching {\n    public int videoStitching(int[][] clips, int time) {\n        int[] dp = new int[time + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE - 1);\n        dp[0] = 0;\n        for(int i = 1; i <= time; i++){\n            for(int[] clip : clips){\n                if(clip[0] < i && i <= clip[1]){\n                    dp[i] = Math.min(dp[i], dp[clip[0]] + 1);\n                }\n            }\n        }\n        return dp[time] == Integer.MAX_VALUE - 1 ? -1 : dp[time];\n        \n    }\n}"}
{"id": "1082", "path": "output2\\java\\Medium\\1082-maximum-difference-between-node-and-ancestor.java", "hypo_code": "class MaximumDifferenceBetweenNodeAndAncestor {\n    public int maxAncestorDiff(TreeNode root) {\n        return dfs(root, root.val, root.val);\n        \n        \n    }\n}"}
{"id": "1083", "path": "output2\\java\\Medium\\1083-longest-arithmetic-subsequence.java", "hypo_code": "class LongestArithmeticSubsequence {\n    public int longestArithSeqLength(int[] nums) {\n        int n = nums.length;\n        int[][] dp = new int[n][20001];\n        int max = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int diff = nums[j] - nums[i] + 10000;\n                dp[j][diff] = Math.max(dp[j][diff], dp[i][diff] + 1);\n                max = Math.max(max, dp[j][diff]);\n            }\n        }\n        return max + 1;\n        \n        \n    }\n}"}
{"id": "1084", "path": "output2\\java\\Medium\\1084-two-city-scheduling.java", "hypo_code": "class TwoCityScheduling {\n    public int twoCitySchedCost(int[][] costs) {\n        int n = costs.length;\n        int[][] dp = new int[n + 1][n + 1];\n        for(int i = 1; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                if(j == 0){\n                    dp[i][j] = dp[i - 1][j] + costs[i - 1][0];\n                }else{\n                    dp[i][j] = Math.min(dp[i - 1][j] + costs[i - 1][0], dp[i - 1][j - 1] + costs[i - 1][1]);\n                }\n            }\n        }\n        return dp[n][n / 2];\n        \n    }\n}"}
{"id": "1085", "path": "output2\\java\\Medium\\1085-maximum-sum-of-two-non-overlapping-subarrays.java", "hypo_code": "class MaximumSumOfTwoNonOverlappingSubarrays {\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\n        int n = nums.length;\n        int[] dp = new int[n + 1];\n        int max = 0;\n        for(int i = 1; i <= n; i++){\n            dp[i] = dp[i - 1] + nums[i - 1];\n            if(i >= firstLen){\n                max = Math.max(max, dp[i] - dp[i - firstLen]);\n                if(i >= firstLen + secondLen){\n                    dp[i] = Math.max(dp[i], dp[i - secondLen] + max);\n                }\n            }\n            if(i >= firstLen + secondLen){\n                max = Math.max(max, dp[i] - dp[i - secondLen] - dp[i - firstLen - secondLen]);\n            }\n        }\n        return dp[n];\n        \n        \n    }\n}"}
{"id": "1086", "path": "output2\\java\\Medium\\1086-moving-stones-until-consecutive.java", "hypo_code": "class MovingStonesUntilConsecutive {\n    public int[] numMovesStones(int a, int b, int c) {\n        int[] arr = new int[]{a, b, c};\n        Arrays.sort(arr);\n        int min = 0;\n        if(arr[1] - arr[0] > 1){\n            min++;\n        }\n        if(arr[2] - arr[1] > 1){\n            min++;\n        }\n        if(arr[1] - arr[0] > 2 || arr[2] - arr[1] > 2){\n            min++;\n        }\n        int max = arr[2] - arr[0] - 2;\n        return new int[]{min, max};\n        \n    }\n}"}
{"id": "1087", "path": "output2\\java\\Medium\\1087-coloring-a-border.java", "hypo_code": "class ColoringABorder {\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        boolean[][] visited = new boolean[m][n];\n        dfs(grid, row, col, grid[row][col], color, visited, dirs);\n        return grid;\n        \n        \n    }\n}"}
{"id": "1088", "path": "output2\\java\\Medium\\1088-uncrossed-lines.java", "hypo_code": "class UncrossedLines {\n    public int maxUncrossedLines(int[] nums1, int[] nums2) {\n        int m = nums1.length;\n        int n = nums2.length;\n        int[][] dp = new int[m + 1][n + 1];\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                if(nums1[i - 1] == nums2[j - 1]){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else{\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n        \n    }\n}"}
{"id": "1089", "path": "output2\\java\\Medium\\1089-binary-search-tree-to-greater-sum-tree.java", "hypo_code": "class BinarySearchTreeToGreaterSumTree {\n    public TreeNode bstToGst(TreeNode root) {\n\n        if(root == null){\n            return null;\n        }\n        int sum = 0;\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode node = root;\n        while(node != null || !stack.isEmpty()){\n            while(node != null){\n                stack.push(node);\n                node = node.right;\n            }\n            node = stack.pop();\n            sum += node.val;\n            node.val = sum;\n            node = node.left;\n        }\n        return root;\n\n        \n    }\n}"}
{"id": "1090", "path": "output2\\java\\Medium\\1090-minimum-score-triangulation-of-polygon.java", "hypo_code": "class MinimumScoreTriangulationOfPolygon {\n    public int minScoreTriangulation(int[] values) {\n        int n = values.length;\n        int[][] dp = new int[n][n];\n        for(int i = n - 1; i >= 0; i--){\n            for(int j = i + 2; j < n; j++){\n                dp[i][j] = Integer.MAX_VALUE;\n                for(int k = i + 1; k < j; k++){\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + values[i] * values[j] * values[k]);\n                }\n            }\n        }\n        return dp[0][n - 1];\n        \n        \n    }\n}"}
{"id": "1091", "path": "output2\\java\\Medium\\1091-moving-stones-until-consecutive-ii.java", "hypo_code": "class MovingStonesUntilConsecutiveIi {\n    public int[] numMovesStonesII(int[] stones) {\n        Arrays.sort(stones);\n        int n = stones.length;\n        int max = Math.max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2);\n        int min = Integer.MAX_VALUE;\n        int i = 0;\n        for(int j = 0; j < n; j++){\n            while(stones[j] - stones[i] >= n){\n                i++;\n            }\n            if(j - i + 1 == n - 1 && stones[j] - stones[i] == n - 2){\n                min = Math.min(min, 2);\n            }else{\n                min = Math.min(min, n - (j - i + 1));\n            }\n        }\n        return new int[]{min, max};\n        \n        \n    }\n}"}
{"id": "1092", "path": "output2\\java\\Medium\\1092-robot-bounded-in-circle.java", "hypo_code": "class RobotBoundedInCircle {\n    public boolean isRobotBounded(String instructions) {\n        int x = 0;\n        int y = 0;\n        int[][] directions = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        int direction = 0;\n        for(char c : instructions.toCharArray()){\n            if(c == 'L'){\n                direction = (direction + 3) % 4;\n            }else if(c == 'R'){\n                direction = (direction + 1) % 4;\n            }else{\n                x += directions[direction][0];\n                y += directions[direction][1];\n            }\n        }\n        return (x == 0 && y == 0) || direction != 0;\n        \n    }\n}"}
{"id": "1093", "path": "output2\\java\\Medium\\1093-flower-planting-with-no-adjacent.java", "hypo_code": "class FlowerPlantingWithNoAdjacent {\n    public int[] gardenNoAdj(int n, int[][] paths) {\n        int[] res = new int[n];\n        List<Integer>[] g = new List[n];\n        for(int i = 0; i < n; i++){\n            g[i] = new ArrayList<>();\n        }\n        for(int[] p : paths){\n            g[p[0] - 1].add(p[1] - 1);\n            g[p[1] - 1].add(p[0] - 1);\n        }\n        for(int i = 0; i < n; i++){\n            boolean[] used = new boolean[5];\n            for(int j : g[i]){\n                used[res[j]] = true;\n            }\n            for(int j = 1; j <= 4; j++){\n                if(!used[j]){\n                    res[i] = j;\n                    break;\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1094", "path": "output2\\java\\Medium\\1094-partition-array-for-maximum-sum.java", "hypo_code": "class PartitionArrayForMaximumSum {\n    public int maxSumAfterPartitioning(int[] arr, int k) {\n        int n = arr.length;\n        int[] dp = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            int max = 0;\n            for(int j = 1; j <= k && i - j >= 0; j++){\n                max = Math.max(max, arr[i - j]);\n                dp[i] = Math.max(dp[i], dp[i - j] + max * j);\n            }\n        }\n        return dp[n];\n        \n        \n        \n    }\n}"}
{"id": "1096", "path": "output2\\java\\Medium\\1096-longest-string-chain.java", "hypo_code": "class Solution {\n    public int longestStrChain(String[] words) {\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\n        Map<String, Integer> dp = new HashMap<>();\n        int res = 0;\n        for(String word: words) {\n            int best = 0;\n            for(int i=0; i<word.length(); i++) {\n                String prev = word.substring(0, i) + word.substring(i+1);\n                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);\n            }\n            dp.put(word, best);\n            res = Math.max(res, best);\n        }\n        return res;\n    }\n}"}
{"id": "1097", "path": "output2\\java\\Medium\\1097-last-stone-weight-ii.java", "hypo_code": "class Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum = 0;\n        for(int stone: stones) {\n            sum += stone;\n        }\n        int n = stones.length;\n        int m = sum / 2;\n        boolean[][] dp = new boolean[n+1][m+1];\n        dp[0][0] = true;\n        for(int i=1; i<=n; i++) {\n            for(int j=0; j<=m; j++) {\n                if(j >= stones[i-1]) {\n                    dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i-1]];\n                } else {\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        for(int i=m; i>=0; i--) {\n            if(dp[n][i]) {\n                return sum - 2 * i;\n            }\n        }\n        return 0;\n    }\n}"}
{"id": "1098", "path": "output2\\java\\Medium\\1098-grumpy-bookstore-owner.java", "hypo_code": "class Solution {\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\n        int n = customers.length;\n        int total = 0;\n        for(int i=0; i<n; i++) {\n            if(grumpy[i] == 0) {\n                total += customers[i];\n            }\n        }\n        int max = 0;\n        for(int i=0; i<minutes; i++) {\n            max += customers[i] * grumpy[i];\n        }\n        int sum = max;\n        for(int i=minutes; i<n; i++) {\n            sum = sum - customers[i-minutes] * grumpy[i-minutes] + customers[i] * grumpy[i];\n            max = Math.max(max, sum);\n        }\n        return total + max;\n    }\n}"}
{"id": "1099", "path": "output2\\java\\Medium\\1099-previous-permutation-with-one-swap.java", "hypo_code": "class Solution {\n    public int[] prevPermOpt1(int[] arr) {\n        int n = arr.length;\n        int i = n-2;\n        while(i>=0 && arr[i] <= arr[i+1]) {\n            i--;\n        }\n        if(i < 0) {\n            return arr;\n        }\n        int j = n-1;\n        while(arr[j] >= arr[i]) {\n            j--;\n        }\n        while(arr[j-1] == arr[j]) {\n            j--;\n        }\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n        return arr;\n    }\n}"}
{"id": "1100", "path": "output2\\java\\Medium\\1100-distant-barcodes.java", "hypo_code": "class Solution {\n    public int[] rearrangeBarcodes(int[] barcodes) {\n        int[] ans = new int[barcodes.length];\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int barcode: barcodes) {\n            map.put(barcode, map.getOrDefault(barcode, 0) + 1);\n        }\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n        pq.addAll(map.entrySet());\n        int i = 0;\n        while(!pq.isEmpty()) {\n            Map.Entry<Integer, Integer> entry = pq.poll();\n            int key = entry.getKey();\n            int val = entry.getValue();\n            while(val > 0) {\n                ans[i] = key;\n                val--;\n                i += 2;\n                if(i >= barcodes.length) {\n                    i = 1;\n                }\n            }\n        }\n        return ans;\n\n    }\n}"}
{"id": "1101", "path": "output2\\java\\Medium\\1101-lexicographically-smallest-equivalent-string.java", "hypo_code": "class Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        int[] root = new int[26];\n        for(int i=0; i<26; i++) {\n            root[i] = i;\n        }\n        for(int i=0; i<s1.length(); i++) {\n            int a = s1.charAt(i) - 'a';\n            int b = s2.charAt(i) - 'a';\n            int ra = find(root, a);\n            int rb = find(root, b);\n            if(ra < rb) {\n                root[rb] = ra;\n            } else {\n                root[ra] = rb;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<baseStr.length(); i++) {\n            int a = baseStr.charAt(i) - 'a';\n            sb.append((char)('a' + find(root, a)));\n        }\n        return sb.toString();\n    }\n    private int find(int[] root, int a) {\n        if(root[a] == a) {\n            return a;\n        }\n        return root[a] = find(root, root[a]);\n    }\n}"}
{"id": "1103", "path": "output2\\java\\Medium\\1103-flip-columns-for-maximum-number-of-equal-rows.java", "hypo_code": "class Solution {\n    public int maxEqualRowsAfterFlips(int[][] matrix) {\n        Map<String, Integer> map = new HashMap<>();\n        for(int[] row: matrix) {\n            StringBuilder sb = new StringBuilder();\n            int diff = row[0];\n            for(int i=0; i<row.length; i++) {\n                if(diff == 0) {\n                    sb.append(row[i]);\n                } else {\n                    sb.append(1-row[i]);\n                }\n            }\n            String key = sb.toString();\n            map.put(key, map.getOrDefault(key, 0) + 1);\n        }\n        int max = 0;\n        for(int val: map.values()) {\n            max = Math.max(max, val);\n        }\n        return max;\n    }\n}"}
{"id": "1104", "path": "output2\\java\\Medium\\1104-adding-two-negabinary-numbers.java", "hypo_code": "class Solution {\n    public int[] addNegabinary(int[] arr1, int[] arr2) {\n        int n = arr1.length;\n        int m = arr2.length;\n        int[] res = new int[Math.max(n, m)+2];\n        int i=n-1, j=m-1, k=res.length-1;\n        int carry = 0;\n        while(i>=0 || j>=0 || carry!=0) {\n            if(i>=0) {\n                carry += arr1[i--];\n            }\n            if(j>=0) {\n                carry += arr2[j--];\n            }\n            res[k--] = carry & 1;\n            carry = -(carry >> 1);\n        }\n        while(k<res.length-1 && res[k+1] == 0) {\n            k++;\n        }\n        return Arrays.copyOfRange(res, k, res.length);\n    } \n\n}"}
{"id": "1105", "path": "output2\\java\\Medium\\1105-letter-tile-possibilities.java", "hypo_code": "class Solution {\n    public int numTilePossibilities(String tiles) {\n        int[] cnt = new int[26];\n        for(char c: tiles.toCharArray()) {\n            cnt[c-'A']++;\n        }\n        return dfs(cnt);\n    }\n    private int dfs(int[] cnt) {\n        int sum = 0;\n        for(int i=0; i<26; i++) {\n            if(cnt[i] == 0) {\n                continue;\n            }\n            sum++;\n            cnt[i]--;\n            sum += dfs(cnt);\n            cnt[i]++;\n        }\n        return sum;\n    }\n}"}
{"id": "1106", "path": "output2\\java\\Medium\\1106-insufficient-nodes-in-root-to-leaf-paths.java", "hypo_code": "class Solution {\n    public TreeNode sufficientSubset(TreeNode root, int limit) {\n        if(root == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif(root.left == null && root.right == null) {\n\t\t\treturn root.val < limit ? null : root;\n\t\t}\n\t\troot.left = sufficientSubset(root.left, limit-root.val);\n\t\troot.right = sufficientSubset(root.right, limit-root.val);\n\t\treturn root.left == null && root.right == null ? null : root;\n\n    }\n}"}
{"id": "1107", "path": "output2\\java\\Medium\\1107-smallest-subsequence-of-distinct-characters.java", "hypo_code": "class Solution {\n    public String smallestSubsequence(String s) {\n        int[] cnt = new int[26];\n\t\tboolean[] used = new boolean[26];\n\t\tfor(char c: s.toCharArray()) {\n\t\t\tcnt[c - 'a']++;\n\t\t}\n\t\tStack<Character> stack = new Stack<>();\n\t\tfor(char c: s.toCharArray()) {\n\t\t\tcnt[c - 'a']--;\n\t\t\tif(used[c - 'a']) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(!stack.isEmpty() && stack.peek() > c && cnt[stack.peek() - 'a'] > 0) {\n\t\t\t\tused[stack.pop() - 'a'] = false;\n\t\t\t}\n\t\t\tstack.push(c);\n\t\t\tused[c - 'a'] = true;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!stack.isEmpty()) {\n\t\t\tsb.append(stack.pop());\n\t\t}\n\t\treturn sb.reverse().toString();\n    }\n}"}
{"id": "1108", "path": "output2\\java\\Medium\\1108-largest-values-from-labels.java", "hypo_code": "class Solution {\n    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {\n        int row = values.length;\n        int[][] pair = new int[row][2];\n        for(int i=0; i<row; i++) {\n            pair[i][0] = values[i];\n            pair[i][1] = labels[i];\n        }\n        Arrays.sort(pair, (a, b) -> b[0] - a[0]);\n        Map<Integer, Integer> map = new HashMap<>();\n        int ans = 0;\n        for(int i=0; i<row; i++) {\n            if(numWanted == 0) {\n                break;\n            }\n            if(map.getOrDefault(pair[i][1], 0) < useLimit) {\n                ans += pair[i][0];\n                map.put(pair[i][1], map.getOrDefault(pair[i][1], 0) + 1);\n                numWanted--;\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1109", "path": "output2\\java\\Medium\\1109-shortest-path-in-binary-matrix.java", "hypo_code": "class Solution {\n    public int shortestPathBinaryMatrix(int[][] grid) {\n        if(grid == null || grid.length == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tint row = grid.length;\n\t\tint col = grid[0].length;\n\t\tboolean[][] visited = new boolean[row][col];\n\t\tif(grid[0][0] == 1 || grid[row-1][col-1] == 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tQueue<int[]> queue = new LinkedList<>();\n\t\tqueue.offer(new int[] {0, 0});\n\t\tvisited[0][0] = true;\n\t\tint[][] dirs = new int[][]{{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\n\t\tint steps = 0;\n\t\twhile(!queue.isEmpty()) {\n\t\t\tint size = queue.size();\n\t\t\twhile(size-- > 0) {\n\t\t\t\tint[] cur = queue.poll();\n\t\t\t\tif(cur[0] == row-1 && cur[1] == col-1) {\n\t\t\t\t\treturn steps+1;\n\t\t\t\t}\n\t\t\t\tfor(int[] dir : dirs) {\n\t\t\t\t\tint x = cur[0] + dir[0];\n\t\t\t\t\tint y = cur[1] + dir[1];\n\t\t\t\t\tif(x>=0 && x<row && y>=0 && y<col && grid[x][y]==0 && !visited[x][y]) {\n\t\t\t\t\t\tqueue.offer(new int[] {x, y});\n\t\t\t\t\t\tvisited[x][y] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsteps++;\n\t\t}\n\t\treturn -1;\n    }\n}"}
{"id": "1110", "path": "output2\\java\\Medium\\1110-statistics-from-a-large-sample.java", "hypo_code": "class Solution {\n    public double[] sampleStats(int[] count) {\n        int min = 0;\n        int max = 0;\n        int mode = 0;\n        long sum = 0;\n        int total = 0;\n        for(int i=0; i<count.length; i++) {\n            if(count[i] > 0) {\n                min = i;\n                break;\n            }\n        }\n        for(int i=count.length-1; i>=0; i--) {\n            if(count[i] > 0) {\n                max = i;\n                break;\n            }\n        }\n        for(int i=0; i<count.length; i++) {\n            if(count[i] > count[mode]) {\n                mode = i;\n            }\n            sum += count[i] * i;\n            total += count[i];\n        }\n        double[] res = new double[5];\n        res[0] = min;\n        res[1] = max;\n        res[2] = (double)sum / total;\n        int left = total / 2;\n        int right = total / 2;\n        if(total % 2 == 0) {\n            left--;\n        }\n        for(int i=0; i<count.length; i++) {\n            left -= count[i];\n            if(left < 0) {\n                res[3] += i;\n                break;\n            }\n        }\n        for(int i=0; i<count.length; i++) {\n            right -= count[i];\n            if(right < 0) {\n                res[3] += i;\n                break;\n            }\n        }\n        res[3] /= 2;\n        res[4] = mode;\n        return res;\n    }\n}"}
{"id": "1111", "path": "output2\\java\\Medium\\1111-car-pooling.java", "hypo_code": "class Solution {\n    public boolean carPooling(int[][] trips, int capacity) {\n        int[] count = new int[1001];\n        for(int[] trip: trips) {\n            count[trip[1]] += trip[0];\n            count[trip[2]] -= trip[0];\n        }\n        int sum = 0;\n        for(int num: count) {\n            sum += num;\n            if(sum > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "1112", "path": "output2\\java\\Medium\\1112-path-in-zigzag-labelled-binary-tree.java", "hypo_code": "class Solution {\n    public List<Integer> pathInZigZagTree(int label) {\n        List<Integer> ans = new ArrayList<>();\n\t\tint level = 0;\n\t\twhile(label > 0) {\n\t\t\tlabel /= 2;\n\t\t\tlevel++;\n\t\t}\n\t\twhile(level > 0) {\n\t\t\tans.add(label);\n\t\t\tlabel = (int) (3 * Math.pow(2, --level) - label - 1) / 2;\n\t\t}\n\t\tCollections.reverse(ans);\n\t\treturn ans;\n    }\n}"}
{"id": "1113", "path": "output2\\java\\Medium\\1113-filling-bookcase-shelves.java", "hypo_code": "class Solution {\n    public int minHeightShelves(int[][] books, int shelfWidth) {\n        int[] dp = new int[books.length+1];\n        dp[0] = 0;\n        for(int i = 1; i <= books.length; i++) {\n            int j = i-1;\n            int width = books[j][0];\n            int height = books[j][1];\n            dp[i] = dp[j] + height;\n            while(j > 0 && width + books[j-1][0] <= shelfWidth) {\n                j--;\n                width += books[j][0];\n                height = Math.max(height, books[j][1]);\n                dp[i] = Math.min(dp[i], dp[j] + height);\n            }\n        }\n        return dp[books.length];\n    }\n}"}
{"id": "1114", "path": "output2\\java\\Medium\\1114-corporate-flight-bookings.java", "hypo_code": "class Solution {\n    public int[] corpFlightBookings(int[][] bookings, int n) {\n        int[] ans = new int[n];\n        for(int[] booking: bookings) {\n            ans[booking[0]-1] += booking[2];\n            if(booking[1] < n) {\n                ans[booking[1]] -= booking[2];\n            }\n        }\n        for(int i = 1; i < n; i++) {\n            ans[i] += ans[i-1];\n        }\n        return ans;\n    }\n}"}
{"id": "1115", "path": "output2\\java\\Medium\\1115-delete-nodes-and-return-forest.java", "hypo_code": "class Solution {\n    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        Set<Integer> set = new HashSet<>();\n        for(int i: to_delete) {\n            set.add(i);\n        }\n        List<TreeNode> list = new ArrayList<>();\n        dfs(root, set, list);\n        if(!set.contains(root.val)) {\n            list.add(root);\n        }\n        return list;\n    }\n    private TreeNode dfs(TreeNode root, Set<Integer> set, List<TreeNode> list) {\n        if(root == null) {\n            return null;\n        }\n        if(set.contains(root.val)) {\n            root.left = dfs(root.left, set, list);\n            root.right = dfs(root.right, set, list);\n            return null;\n        }\n        root.left = dfs(root.left, set, list);\n        root.right = dfs(root.right, set, list);\n        return root;\n    }\n}"}
{"id": "1116", "path": "output2\\java\\Medium\\1116-maximum-nesting-depth-of-two-valid-parentheses-strings.java", "hypo_code": "class Solution {\n    public int[] maxDepthAfterSplit(String seq) {\n        int[] ans = new int[seq.length()];\n        int depth = 0;\n        for(int i = 0; i < seq.length(); i++) {\n            if(seq.charAt(i) == '(') {\n                ans[i] = ++depth % 2;\n            } else {\n                ans[i] = depth-- % 2;\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1120", "path": "output2\\java\\Medium\\1120-lowest-common-ancestor-of-deepest-leaves.java", "hypo_code": "class Solution {\n    public TreeNode lcaDeepestLeaves(TreeNode root) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        int leftDepth = depth(root.left);\n        int rightDepth = depth(root.right);\n        if(leftDepth > rightDepth) {\n            return lcaDeepestLeaves(root.left);\n        }\n        if(leftDepth < rightDepth) {\n            return lcaDeepestLeaves(root.right);\n        }\n        return root;\n    }\n    private int depth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        return Math.max(depth(root.left), depth(root.right)) + 1;\n    }\n}"}
{"id": "1121", "path": "output2\\java\\Medium\\1121-longest-well-performing-interval.java", "hypo_code": "class Solution {\n    public int longestWPI(int[] hours) {\n        int ans = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        int sum = 0;\n        for(int i = 0; i < hours.length; i++) {\n            sum += hours[i] > 8 ? 1 : -1;\n            if(sum > 0) {\n                ans = i+1;\n            }\n            else {\n                map.putIfAbsent(sum, i);\n                if(map.containsKey(sum-1)) {\n                    ans = Math.max(ans, i-map.get(sum-1));\n                }\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1122", "path": "output2\\java\\Medium\\1122-shortest-path-with-alternating-colors.java", "hypo_code": "class Solution {\n    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) { \n      \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for(int[] redEdge: redEdges) {\n            graph.putIfAbsent(redEdge[0], new ArrayList<>());\n            graph.get(redEdge[0]).add(redEdge[1]);\n        }\n        for(int[] blueEdge: blueEdges) {\n            graph.putIfAbsent(blueEdge[0], new ArrayList<>());\n            graph.get(blueEdge[0]).add(blueEdge[1]);\n        }\n        Set<Integer> set = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        int[] ans = new int[n];\n        Arrays.fill(ans, -1);\n        queue.offer(0);\n        set.add(0);\n        ans[0] = 0;\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            for(int i = 0; i < size; i++) {\n                int node = queue.poll();\n                if(graph.containsKey(node)) {\n                    for(int next: graph.get(node)) {\n                        if(!set.contains(next)) {\n                            set.add(next);\n                            queue.offer(next);\n                            ans[next] = ans[node] + 1;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n\t\t\n    }\n}"}
{"id": "1123", "path": "output2\\java\\Medium\\1123-minimum-cost-tree-from-leaf-values.java", "hypo_code": "class Solution {\n    public int mctFromLeafValues(int[] arr) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        int result = 0;\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < arr.length; i++) {\n            while(!stack.isEmpty() && arr[i] > stack.peek()) {\n                int temp = stack.pop();\n                if(!stack.isEmpty()) {\n                    result += temp * Math.min(stack.peek(), arr[i]);\n                }\n                else {\n                    result += temp * arr[i];\n                }\n            }\n            stack.push(arr[i]);\n        }\n        while(!stack.isEmpty()) {\n            int temp = stack.pop();\n            if(!stack.isEmpty()) {\n                result += temp * stack.peek();\n            }\n        }\n        return result;\n    }\n}"}
{"id": "1124", "path": "output2\\java\\Medium\\1124-maximum-of-absolute-value-expression.java", "hypo_code": "class Solution {\n    public int maxAbsValExpr(int[] arr1, int[] arr2) {\n        int ans = 0;\n        for(int i = 0; i < arr1.length; i++) {\n            for(int j = 0; j < arr2.length; j++) {\n                ans = Math.max(ans, Math.abs(arr1[i]-arr1[j])+Math.abs(arr2[i]-arr2[j])+Math.abs(i-j));\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1125", "path": "output2\\java\\Medium\\1125-alphabet-board-path.java", "hypo_code": "class Solution {\n    public String alphabetBoardPath(String target) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        Map<Character, int[]> map = new HashMap<>();\n        int row = 0;\n        int col = 0;\n        for(int i = 0; i < 26; i++) {\n            map.put((char)('a'+i), new int[]{i/5, i%5});\n        }\n        StringBuilder sb = new StringBuilder();\n        for(char c: target.toCharArray()) {\n            int[] cur = map.get(c);\n            while(row > cur[0]) {\n                sb.append('U');\n                row--;\n            }\n            while(col < cur[1]) {\n                sb.append('R');\n                col++;\n            }\n            while(col > cur[1]) {\n                sb.append('L');\n                col--;\n            }\n            while(row < cur[0]) {\n                sb.append('D');\n                row++;\n            }\n            sb.append('!');\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1126", "path": "output2\\java\\Medium\\1126-largest-1-bordered-square.java", "hypo_code": "class Solution {\n    public int largest1BorderedSquare(int[][] grid) {\n        int ans = 0;\n        int[][][] dp = new int[grid.length][grid[0].length][2];\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length;j++) {\n                if(grid[i][j] == 1) {\n                    dp[i][j][0] = j > 0 ? dp[i][j-1][0]+1 : 1;\n                    dp[i][j][1] = i > 0 ? dp[i-1][j][1]+1 : 1;\n                    int min = Math.min(dp[i][j][0], dp[i][j][1]);\n                    while(min > ans) {\n                        if(dp[i][j-min+1][1] >= min && dp[i-min+1][j][0] >= min) {\n                            ans = min;\n                        }\n                        min--;\n                    }\n                }\n            }\n        }\n        return ans*ans;\n    }\n}"}
{"id": "1127", "path": "output2\\java\\Medium\\1127-stone-game-ii.java", "hypo_code": "class Solution {\n    public int stoneGameII(int[] piles) {\n        int n = piles.length;\n        int[] suffixSum = new int[n];\n        suffixSum[n-1] = piles[n-1];\n        for(int i = n-2; i >= 0; i--) {\n            suffixSum[i] = suffixSum[i+1] + piles[i];\n        }\n        int[][] dp = new int[n][n];\n        return helper(piles, suffixSum, 0, 1, dp);\n    }\n    private int helper(int[] piles, int[] suffixSum, int start, int M, int[][] dp) {\n        if(start >= piles.length) {\n            return 0;\n        }\n        if(dp[start][M] != 0) {\n            return dp[start][M];\n        }\n        int max = 0;\n        for(int i = start; i < Math.min(start+2*M, piles.length); i++) {\n            int next = helper(piles, suffixSum, i+1, Math.max(M, i-start+1), dp);\n            int cur = suffixSum[start] - next;\n            max = Math.max(max, cur);\n        }\n        dp[start][M] = max;\n        return max;\n    }\n}"}
{"id": "1128", "path": "output2\\java\\Medium\\1128-longest-common-subsequence.java", "hypo_code": "class Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n        int[][] dp = new int[text1.length()+1][text2.length()+1];\n        for(int i = 1; i <= text1.length(); i++) {\n            char c1 = text1.charAt(i-1);\n            for(int j = 1; j <= text2.length(); j++) {\n                char c2 = text2.charAt(j-1);\n                if(c1 == c2) {\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                }\n                else {\n                    int left = dp[i][j-1];\n                    int up = dp[i-1][j];\n                    dp[i][j] = Math.max(left, up);\n                }\n            }\n        }\n        return dp[text1.length()][text2.length()];\n    }\n}"}
{"id": "1129", "path": "output2\\java\\Medium\\1129-decrease-elements-to-make-array-zigzag.java", "hypo_code": "class Solution {\n    public int movesToMakeZigzag(int[] nums) {\n        int ans = 0;\n        for(int i = 0; i < nums.length; i++) {\n            int left = i > 0 ? nums[i-1] : 1001;\n            int right = i < nums.length-1 ? nums[i+1] : 1001;\n            if(i%2 == 0) {\n                ans += Math.max(0, nums[i]-Math.min(left, right)+1);\n            }\n            else {\n                ans += Math.max(0, nums[i]-Math.min(left, right)+1);\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1130", "path": "output2\\java\\Medium\\1130-binary-tree-coloring-game.java", "hypo_code": "class Solution {\n    public boolean btreeGameWinningMove(TreeNode root, int n, int x) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        int[] count = new int[3];\n        dfs(root, count, x);\n        int max = Math.max(count[0], Math.max(count[1], count[2]));\n        return max > n/2;\n    }\n    private int dfs(TreeNode root, int[] count, int x) {\n        if(root == null) {\n            return 0;\n        }\n        int left = dfs(root.left, count, x);\n        int right = dfs(root.right, count, x);\n        int parent = 1 + left + right;\n        if(root.val == x) {\n            count[0] = left;\n            count[1] = right;\n            count[2] = parent;\n        }\n        return parent;\n    }\n}"}
{"id": "1132", "path": "output2\\java\\Medium\\1132-number-of-dice-rolls-with-target-sum.java", "hypo_code": "class Solution {\n    public int numRollsToTarget(int n, int k, int target) {\n        int[][] dp = new int[n+1][target+1];\n        dp[0][0] = 1;\n        int mod = 1000000007;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= k; j++) {\n                for(int t = j; t <= target; t++) {\n                    dp[i][t] = (dp[i][t] + dp[i-1][t-j]) % mod;\n                }\n            }\n        }\n        return dp[n][target];\n    }\n}"}
{"id": "1133", "path": "output2\\java\\Medium\\1133-swap-for-longest-repeated-character-substring.java", "hypo_code": "class Solution {\n    public int maxRepOpt1(String text) {\n        int ans = 1;\n        Map<Character, Integer> map = new HashMap<>();\n        for(char c: text.toCharArray()) {\n            map.put(c, map.getOrDefault(c, 0)+1);\n        }\n        for(int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            int count = 1;\n            for(int j = i+1; j < text.length(); j++) {\n                if(text.charAt(j) == c) {\n                    count++;\n                }\n                else if(map.get(c) > count) {\n                    count++;\n                }\n                else {\n                    break;\n                }\n            }\n            ans = Math.max(ans, count);\n        }\n        return ans;\n    }\n}"}
{"id": "1135", "path": "output2\\java\\Medium\\1135-maximum-level-sum-of-a-binary-tree.java", "hypo_code": "class Solution {\n    public int maxLevelSum(TreeNode root) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        int level = 1;\n        int max = Integer.MIN_VALUE;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            int sum = 0;\n            for(int i = 0; i < size; i++) {\n                TreeNode curr = queue.poll();\n                sum += curr.val;\n                if(curr.left != null) {\n                    queue.offer(curr.left);\n                }\n                if(curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n            if(sum > max) {\n                max = sum;\n                level = queue.size();\n            }\n        }\n        return level;\n    }\n}"}
{"id": "1136", "path": "output2\\java\\Medium\\1136-as-far-from-land-as-possible.java", "hypo_code": "class Solution {\n    public int maxDistance(int[][] grid) {\n        int n = grid.length;\n        int[][] dist = new int[n][n];\n        Queue<int[]> queue = new LinkedList<>();\n        for(int i = 0; i < n; i++) {\n            Arrays.fill(dist[i], -1);\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == 1) {\n                    queue.add(new int[]{i, j});\n                    dist[i][j] = 0;\n                }\n            }\n        }\n        int ans = -1;\n        while(!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int x = cur[0], y = cur[1], d = dist[x][y];\n            ans = Math.max(ans, d);\n            if(x > 0 && dist[x-1][y] == -1) {\n                dist[x-1][y] = d+1;\n                queue.add(new int[]{x-1, y});\n            }\n            if(x < n-1 && dist[x+1][y] == -1) {\n                dist[x+1][y] = d+1;\n                queue.add(new int[]{x+1, y});\n            }\n            if(y > 0 && dist[x][y-1] == -1) {\n                dist[x][y-1] = d+1;\n                queue.add(new int[]{x, y-1});\n            }\n            if(y < n-1 && dist[x][y+1] == -1) {\n                dist[x][y+1] = d+1;\n                queue.add(new int[]{x, y+1});\n            }\n        }\n        return ans == 0 ? -1 : ans;\n    }\n}"}
{"id": "1138", "path": "output2\\java\\Medium\\1138-invalid-transactions.java", "hypo_code": "class Solution {\n    public List<String> invalidTransactions(String[] transactions) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        List<String> list = new ArrayList<>();\n        Map<String, List<String>> map = new HashMap<>();\n        for(String transaction: transactions) {\n            String[] split = transaction.split(\",\");\n            String name = split[0];\n            int time = Integer.parseInt(split[1]);\n            int amount = Integer.parseInt(split[2]);\n            String city = split[3];\n            if(amount > 1000) {\n                list.add(transaction);\n            }\n            if(map.containsKey(name)) {\n                List<String> transactionsInMap = map.get(name);\n                for(String transactionInMap: transactionsInMap) {\n                    String[] splitInMap = transactionInMap.split(\",\");\n                    int timeInMap = Integer.parseInt(splitInMap[1]);\n                    String cityInMap = splitInMap[3];\n                    if(Math.abs(time - timeInMap) <= 60 && !city.equals(cityInMap)) {\n                        list.add(transaction);\n                        list.add(transactionInMap);\n                    }\n                }\n                transactionsInMap.add(transaction);\n                map.put(name, transactionsInMap);\n            }\n            else {\n                List<String> transactionsInMap = new ArrayList<>();\n                transactionsInMap.add(transaction);\n                map.put(name, transactionsInMap);\n            }\n        }\n        return list;\n    }\n}"}
{"id": "1139", "path": "output2\\java\\Medium\\1139-compare-strings-by-frequency-of-the-smallest-character.java", "hypo_code": "class Solution {\n    public int[] numSmallerByFrequency(String[] queries, String[] words) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        int[] ans = new int[queries.length];\n        int[] frequency = new int[words.length];\n        for(int i = 0; i < words.length; i++) {\n            frequency[i] = countFrequency(words[i]);\n        }\n        Arrays.sort(frequency);\n        for(int i = 0; i < queries.length; i++) {\n            int count = countFrequency(queries[i]);\n            ans[i] = findIndex(frequency, count);\n        }\n        return ans;\n    }\n    private int countFrequency(String s) {\n        int[] count = new int[26];\n        for(char c: s.toCharArray()) {\n            count[c-'a']++;\n        }\n        for(int i = 0; i < 26; i++) {\n            if(count[i] > 0) {\n                return count[i];\n            }\n        }\n        return 0;\n    }\n    private int findIndex(int[] frequency, int count) {\n        int left = 0, right = frequency.length-1;\n        while(left <= right) {\n            int mid = left + (right-left)/2;\n            if(frequency[mid] <= count) {\n                left = mid+1;\n            }\n            else {\n                right = mid-1;\n            }\n        }\n        return frequency.length-left;\n    }\n}"}
{"id": "1140", "path": "output2\\java\\Medium\\1140-remove-zero-sum-consecutive-nodes-from-linked-list.java", "hypo_code": "class Solution {\n    public ListNode removeZeroSumSublists(ListNode head) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        Map<Integer, ListNode> map = new HashMap<>();\n        int sum = 0;\n        for(ListNode cur = dummy; cur != null; cur = cur.next) {\n            sum += cur.val;\n            if(map.containsKey(sum)) {\n                cur.next = map.get(sum).next;\n            } else {\n                map.put(sum, cur);\n            }\n        }\n        return dummy.next;\n    }\n}"}
{"id": "1142", "path": "output2\\java\\Medium\\1142-can-make-palindrome-from-substring.java", "hypo_code": "class Solution {\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\n        \n        \n        \n        \n        \n        \n        \n        \n        List<Boolean> ans = new ArrayList<>();\n        int[][] dp = new int[s.length()+1][26];\n        for(int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            dp[i+1] = dp[i].clone();\n            dp[i+1][c-'a']++;\n        }\n        for(int[] query: queries) {\n            int left = query[0];\n            int right = query[1];\n            int k = query[2];\n            int[] count = new int[26];\n            for(int i = 0; i < 26; i++) {\n                count[i] = dp[right+1][i] - dp[left][i];\n            }\n            int odd = 0;\n            for(int i = 0; i < 26; i++) {\n                if(count[i] % 2 == 1) {\n                    odd++;\n                }\n            }\n            ans.add(odd / 2 <= k);\n        }\n        return ans;\n    }\n}"}
{"id": "1143", "path": "output2\\java\\Medium\\1143-maximum-subarray-sum-with-one-deletion.java", "hypo_code": "class Solution {\n    public int maximumSum(int[] arr) {\n        int ans = arr[0], sum1 = arr[0], sum2 = 0, sum3 = 0;\n        for(int i = 1; i < arr.length; i++) {\n            sum3 = Math.max(sum3+arr[i], sum2+arr[i]);\n            sum2 = Math.max(sum2+arr[i], sum1);\n            sum1 = Math.max(sum1+arr[i], arr[i]);\n            ans = Math.max(ans, Math.max(sum1, sum3));\n        }\n        return ans;\n    }\n}"}
{"id": "1144", "path": "output2\\java\\Medium\\1144-reverse-substrings-between-each-pair-of-parentheses.java", "hypo_code": "class Solution {\n    public String reverseParentheses(String s) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        Stack<Character> stack = new Stack<>();\n        for(char c: s.toCharArray()) {\n            if(c != ')') {\n                stack.push(c);\n            }\n            else {\n                Queue<Character> queue = new LinkedList<>();\n                while(!stack.isEmpty() && stack.peek() != '(') {\n                    queue.offer(stack.pop());\n                }\n                stack.pop();\n                while(!queue.isEmpty()) {\n                    stack.push(queue.poll());\n                }\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()) {\n            sb.append(stack.pop());\n        }\n        return sb.reverse().toString();\n    }\n}"}
{"id": "1145", "path": "output2\\java\\Medium\\1145-k-concatenation-maximum-sum.java", "hypo_code": "class Solution {\n    public int kConcatenationMaxSum(int[] arr, int k) {\n        int mod = 1000000007;\n        int ans = 0;\n        int sum = 0;\n        int max = 0;\n        int[] dp = new int[arr.length];\n        for(int i = 0; i < arr.length; i++) {\n            sum += arr[i];\n            dp[i] = arr[i];\n            if(i > 0 && dp[i-1] > 0) {\n                dp[i] += dp[i-1];\n            }\n            max = Math.max(max, dp[i]);\n        }\n        if(k == 1) {\n            return max;\n        }\n        for(int i = 0; i < arr.length; i++) {\n            if(dp[i] < 0) {\n                dp[i] = 0;\n            }\n            ans = Math.max(ans, dp[i]);\n        }\n        if(sum > 0) {\n            ans += (k-2)*sum;\n        }\n        return ans % mod;\n    }\n}"}
{"id": "1148", "path": "output2\\java\\Medium\\1148-ugly-number-iii.java", "hypo_code": "class Solution {\n    public int nthUglyNumber(int n, int a, int b, int c) {\n        long left = 1, right = (long)2e9;\n        while(left < right) {\n            long mid = (left+right)/2;\n            if(count(mid, a, b, c) >= n) {\n                right = mid;\n            }\n            else {\n                left = mid+1;\n            }\n        }\n        return (int)left;\n    }\n    private long count(long n, long a, long b, long c) {\n        return n/a+n/b+n/c-n/lcm(a, b)-n/lcm(b, c)-n/lcm(a, c)+n/lcm(a, lcm(b, c));\n    }\n    private long lcm(long a, long b) {\n        return a*b/gcd(a, b);\n    }\n    private long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a%b);\n    }\n}"}
{"id": "1149", "path": "output2\\java\\Medium\\1149-smallest-string-with-swaps.java", "hypo_code": "class Solution {\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        Map<Character, List<Integer>> map = new HashMap<>();\n        boolean[] visited = new boolean[s.length()];\n        for(List<Integer> pair: pairs) {\n            int i = pair.get(0);\n            int j = pair.get(1);\n            map.putIfAbsent(s.charAt(i), new ArrayList<>());\n            map.get(s.charAt(i)).add(j);\n            map.putIfAbsent(s.charAt(j), new ArrayList<>());\n            map.get(s.charAt(j)).add(i);\n        }\n        List<List<Integer>> list = new ArrayList<>();\n        char[] chars = s.toCharArray();\n        for(char c: map.keySet()) {\n            List<Integer> indexList = map.get(c);\n            Collections.sort(indexList);\n            list.add(indexList);\n        }\n        Arrays.sort(chars);\n        StringBuilder sb = new StringBuilder();\n        for(List<Integer> indexList: list) {\n            for(int index: indexList) {\n                sb.append(chars[index]);\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1151", "path": "output2\\java\\Medium\\1151-get-equal-substrings-within-budget.java", "hypo_code": "class Solution {\n    public int equalSubstring(String s, String t, int maxCost) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        List<Integer> list = new ArrayList<>();\n        for(int i = 0; i < s.length(); i++) {\n            int cost = Math.abs(s.charAt(i)-t.charAt(i));\n            list.add(cost);\n        }\n        int maxLength = 0;\n        int sum = 0;\n        for(int i = 0; i < list.size(); i++) {\n            sum += list.get(i);\n            if(sum > maxCost) {\n                sum -= list.get(0);\n                list.remove(0);\n            }\n            else {\n                maxLength = Math.max(maxLength, list.size());\n            }\n        }\n        return maxLength;\n    }\n}"}
{"id": "1152", "path": "output2\\java\\Medium\\1152-remove-all-adjacent-duplicates-in-string-ii.java", "hypo_code": "class Solution {\n    public String removeDuplicates(String s, int k) { \n        StringBuilder sb = new StringBuilder(s);\n        int[] count = new int[sb.length()];\n        for(int i = 0; i < sb.length(); i++) {\n            if(i == 0 || sb.charAt(i) != sb.charAt(i-1)) {\n                count[i] = 1;\n            }\n            else {\n                count[i] = count[i-1]+1;\n                if(count[i] == k) {\n                    sb.delete(i-k+1, i+1);\n                    i -= k;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1153", "path": "output2\\java\\Medium\\1153-longest-arithmetic-subsequence-of-given-difference.java", "hypo_code": "class Solution {\n    public int longestSubsequence(int[] arr, int difference) {\n        int ans = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < arr.length; i++) {\n            map.put(arr[i], map.getOrDefault(arr[i]-difference, 0)+1);\n            ans = Math.max(ans, map.get(arr[i]));\n        }\n        return ans;\n    }\n}"}
{"id": "1154", "path": "output2\\java\\Medium\\1154-path-with-maximum-gold.java", "hypo_code": "class Solution {\n    public int getMaximumGold(int[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] dp = new int[m][n][1<<15];\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                ans = Math.max(ans, helper(grid, i, j, 0, dp));\n            }\n        }\n        return ans;\n    }\n    private int helper(int[][] grid, int i, int j, int visited, int[][][] dp) {\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j]==0 || ((visited>>i*n+j)&1)==1) {\n            return 0;\n        }\n        if(dp[i][j][visited] != 0) {\n            return dp[i][j][visited];\n        }\n        int max = 0;\n        visited |= 1<<(i*n+j);\n        max = Math.max(max, helper(grid, i+1, j, visited, dp));\n        max = Math.max(max, helper(grid, i-1, j, visited, dp));\n        max = Math.max(max, helper(grid, i, j+1, visited, dp));\n        max = Math.max(max, helper(grid, i, j-1, visited, dp));\n        visited ^= 1<<(i*n+j);\n        dp[i][j][visited] = max+grid[i][j];\n        return dp[i][j][visited];\n    }\n}"}
{"id": "1155", "path": "output2\\java\\Medium\\1155-queens-that-can-attack-the-king.java", "hypo_code": "class Solution {\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n        int[] ax = new int[]{0, 0, -1, 1, -1, 1, -1, 1};\n        int[] ay = new int[]{-1, 1, 0, 0, -1, -1, 1, 1};\n        List<List<Integer>> ans = new ArrayList<>();\n        for(int i = 0; i < ax.length; i++) {\n            int x = king[0];\n            int y = king[1];\n            while(x >= 0 && x < 8 && y >= 0 && y < 8) {\n                x += ax[i];\n                y += ay[i];\n                for(int j = 0; j < queens.length; j++) {\n                    if(queens[j][0] == x && queens[j][1] == y) {\n                        ans.add(Arrays.asList(x, y));\n                        x = -1;\n                        y = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1157", "path": "output2\\java\\Medium\\1157-airplane-seat-assignment-probability.java", "hypo_code": "class Solution {\n    public double nthPersonGetsNthSeat(int n) {\n        return n == 1 ? 1.0 : 0.5;\n    }\n}"}
{"id": "1158", "path": "output2\\java\\Medium\\1158-remove-sub-folders-from-the-filesystem.java", "hypo_code": "class Solution {\n    public List<String> removeSubfolders(String[] folder) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n        Arrays.sort(folder);\n        List<String> list = new ArrayList<>();\n        for(String f: folder) {\n            if(list.isEmpty() || !f.startsWith(list.get(list.size()-1)+\"/\")) {\n                list.add(f);\n            }\n        }\n        return list;\n    }\n}"}
{"id": "1159", "path": "output2\\java\\Medium\\1159-replace-the-substring-for-balanced-string.java", "hypo_code": "class Solution {\n    public int balancedString(String s) {\n        int ans = s.length();\n        Map<Character, Integer> map = new HashMap<>();\n        for(char c: s.toCharArray()) {\n            map.put(c, map.getOrDefault(c, 0)+1);\n        }\n        int i = 0;\n        for(int j = 0; j < s.length(); j++) {\n            map.put(s.charAt(j), map.get(s.charAt(j))-1);\n            while(i < s.length() && map.get('Q') <= s.length()/4 && map.get('W') <= s.length()/4 && map.get('E') <= s.length()/4 && map.get('R') <= s.length()/4) {\n                ans = Math.min(ans, j-i+1);\n                map.put(s.charAt(i), map.get(s.charAt(i))+1);\n                i++;\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1160", "path": "output2\\java\\Medium\\1160-find-positive-integer-solution-for-a-given-equation.java", "hypo_code": "class Solution {\n    public List<List<Integer>> findSolution(CustomFunction customfunction, int z) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        List<List<Integer>> result = new ArrayList<>();\n        int x = 1;\n        int y = 1000;\n        while(x <= 1000 && y >= 1) {\n            int temp = customfunction.f(x, y);\n            if(temp == z) {\n                List<Integer> list = new ArrayList<>();\n                list.add(x);\n                list.add(y);\n                result.add(list);\n                x++;\n                y--;\n            }\n            else if(temp > z) {\n                y--;\n            }\n            else {\n                x++;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "1161", "path": "output2\\java\\Medium\\1161-circular-permutation-in-binary-representation.java", "hypo_code": "class Solution {\n    public List<Integer> circularPermutation(int n, int start) {\n        List<Integer> ans = new ArrayList<>();\n        for(int i = 0; i < 1<<n; i++) {\n            ans.add(start ^ i ^ i>>1);\n        }\n        return ans;\n    }\n}"}
{"id": "1162", "path": "output2\\java\\Medium\\1162-maximum-length-of-a-concatenated-string-with-unique-characters.java", "hypo_code": "class Solution {\n    public int maxLength(List<String> arr) {\n        int ans = 0;\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        for(String s: arr) {\n            int mask = 0;\n            for(char c: s.toCharArray()) {\n                mask |= 1 << (c-'a');\n            }\n            if(Integer.bitCount(mask) < s.length()) {\n                continue;\n            }\n            for(int i = list.size()-1; i >= 0; i--) {\n                int m = list.get(i);\n                if((m & mask) == 0) {\n                    list.add(m | mask);\n                    ans = Math.max(ans, Integer.bitCount(m | mask));\n                }\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1163", "path": "output2\\java\\Medium\\1163-minimum-swaps-to-make-strings-equal.java", "hypo_code": "class Solution {\n    public int minimumSwap(String s1, String s2) {\n        int ans = 0;\n        int xy = 0;\n        int yx = 0;\n        for(int i = 0; i < s1.length(); i++) {\n            if(s1.charAt(i) == s2.charAt(i)) {\n                continue;\n            }\n            if(s1.charAt(i) == 'x') {\n                xy++;\n            }\n            else {\n                yx++;\n            }\n        }\n        if((xy+yx)%2 == 1) {\n            return -1;\n        }\n        ans += xy/2;\n        ans += yx/2;\n        xy = xy%2;\n        yx = yx%2;\n        if(xy == 1) {\n            ans += 2;\n        }\n        return ans;\n    }\n}"}
{"id": "1164", "path": "output2\\java\\Medium\\1164-count-number-of-nice-subarrays.java", "hypo_code": "class Solution {\n    public int numberOfSubarrays(int[] nums, int k) {\n        int[] cnt = new int[nums.length+1];\n        cnt[0] = 1;\n        int odd = 0, ans = 0;\n        for(int num: nums) {\n            odd += num & 1;\n            if(odd >= k) {\n                ans += cnt[odd-k];\n            }\n            cnt[odd]++;\n        }\n        return ans;\n    }\n}"}
{"id": "1165", "path": "output2\\java\\Medium\\1165-minimum-remove-to-make-valid-parentheses.java", "hypo_code": "class Solution {\n    public String minRemoveToMakeValid(String s) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if(c == '(') {\n                stack.push(i);\n            }\n            else if(c == ')') {\n                if(stack.isEmpty()) {\n                    s = s.substring(0, i) + \"#\" + s.substring(i+1);\n                }\n                else {\n                    stack.pop();\n                }\n            }\n        }\n        while(!stack.isEmpty()) {\n            int index = stack.pop();\n            s = s.substring(0, index) + \"#\" + s.substring(index+1);\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if(c == '#') {\n                continue;\n            }\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1166", "path": "output2\\java\\Medium\\1166-reconstruct-a-2-row-binary-matrix.java", "hypo_code": "class Solution {\n    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {\n        List<List<Integer>> ans = new ArrayList<>();\n        List<Integer> up = new ArrayList<>();\n        List<Integer> low = new ArrayList<>();\n        for(int i = 0; i < colsum.length; i++) {\n            if(colsum[i] == 2) {\n                up.add(1);\n                lower--;\n            }\n            else if(colsum[i] == 0) {\n                up.add(0);\n                low.add(0);\n            }\n            else {\n                if(upper > lower) {\n                    up.add(1);\n                    lower--;\n                }\n                else {\n                    up.add(0);\n                    lower--;\n                }\n            }\n            if(lower < 0) {\n                return ans;\n            }\n        }\n        if(lower != 0) {\n            return ans;\n        }\n        ans.add(up);\n        ans.add(low);\n        return ans;\n    }\n}"}
{"id": "1167", "path": "output2\\java\\Medium\\1167-number-of-closed-islands.java", "hypo_code": "class Solution {\n    public int closedIsland(int[][] grid) {\n        int ans = 0;\n        int[][] dirs = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\n        for(int i = 1; i < grid.length-1; i++) {\n            for(int j = 1; j < grid[0].length-1; j++) {\n                if(grid[i][j] == 0 && !visited[i][j]) {\n                    boolean isClosed = true;\n                    Stack<int[]> stack = new Stack<>();\n                    stack.push(new int[]{i, j});\n                    visited[i][j] = true;\n                    while(!stack.isEmpty()) {\n                        int[] cur = stack.pop();\n                        for(int[] dir : dirs) {\n                            int x = cur[0]+dir[0], y = cur[1]+dir[1];\n                            if(x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) {\n                                isClosed = false;\n                                continue;\n                            }\n                            if(grid[x][y] == 0 && !visited[x][y]) {\n                                stack.push(new int[]{x, y});\n                                visited[x][y] = true;\n                            }\n                        }\n                    }\n                    if(isClosed) {\n                        ans++;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1169", "path": "output2\\java\\Medium\\1169-greatest-sum-divisible-by-three.java", "hypo_code": "class Solution {\n    public int maxSumDivThree(int[] nums) {\n        int[] dp = new int[3];\n        for(int num: nums) {\n            int[] dp2 = new int[3];\n            for(int i = 0; i < 3; i++) {\n                dp2[(i+num)%3] = Math.max(dp[(i+num)%3], dp[i]+num);\n            }\n            dp = dp2;\n        }\n        return dp[0];\n    }\n}"}
{"id": "1170", "path": "output2\\java\\Medium\\1170-count-servers-that-communicate.java", "hypo_code": "class Solution {\n    public int countServers(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[] row = new int[m];\n        int[] col = new int[n];\n        int ans = 0;\n        for(int i = 0; i < m; i++) {\n            int count = 0;\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == 1) {\n                    count++;\n                }\n            }\n            row[i] = count;\n        }\n        for(int i = 0; i < n; i++) {\n            int count = 0;\n            for(int j = 0; j < m; j++) {\n                if(grid[j][i] == 1) {\n                    count++;\n                }\n            }\n            col[i] = count;\n        }\n        for(int i = 0; i < m; i++) {\n            if(row[i] > 1) {\n                for(int j = 0; j < n; j++) {\n                    if(grid[i][j] == 1 && col[j] > 1) {\n                        ans++;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1171", "path": "output2\\java\\Medium\\1171-search-suggestions-system.java", "hypo_code": "class Solution {\n    public List<List<String>> suggestedProducts(String[] products, String searchWord) {\n        List<List<String>> ans = new ArrayList<>();\n        Arrays.sort(products);\n        for(int i = 0; i < searchWord.length(); i++) {\n            String prefix = searchWord.substring(0, i+1);\n            List<String> list = new ArrayList<>();\n            for(String product: products) {\n                if(product.startsWith(prefix)) {\n                    list.add(product);\n                }\n                if(list.size() == 3) {\n                    break;\n                }\n            }\n            ans.add(list);\n        }\n        return ans;\n    }\n}"}
{"id": "1172", "path": "output2\\java\\Medium\\1172-number-of-burgers-with-no-waste-of-ingredients.java", "hypo_code": "class Solution {\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        List<Integer> list = new ArrayList<>();\n        if(tomatoSlices % 2 != 0) {\n            return list;\n        }\n        if(tomatoSlices < 2*cheeseSlices) {\n            return list;\n        }\n        if(cheeseSlices < tomatoSlices/2) {\n            return list;\n        }\n        list.add(tomatoSlices/2-cheeseSlices);\n        list.add(2*cheeseSlices-tomatoSlices/2);\n        return list;\n    }\n}"}
{"id": "1173", "path": "output2\\java\\Medium\\1173-count-square-submatrices-with-all-ones.java", "hypo_code": "class Solution {\n    public int countSquares(int[][] matrix) {\n        int ans = 0;\n        int[][] dp = new int[matrix.length][matrix[0].length];\n        for(int i = 0; i < matrix.length; i++) {\n            ans += dp[i][0] = matrix[i][0];\n        }\n        for(int i = 1; i < matrix[0].length; i++) {\n            ans += dp[0][i] = matrix[0][i];\n        }\n        for(int i = 1; i < matrix.length; i++) {\n            for(int j = 1; j < matrix[0].length;j++) {\n                if(matrix[i][j] == 1) {\n                    dp[i][j] = Math.min(Math.min(dp[i-1][j-1], dp[i][j-1]),dp[i-1][j])+1;\n                    ans += dp[i][j];\n                }\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1174", "path": "output2\\java\\Medium\\1174-group-the-people-given-the-group-size-they-belong-to.java", "hypo_code": "class Solution {\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\n        List<List<Integer>> ans = new ArrayList<>();\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < groupSizes.length; i++) {\n            List<Integer> list = map.getOrDefault(groupSizes[i], new ArrayList<>());\n            list.add(i);\n            map.put(groupSizes[i], list);\n            if(list.size() == groupSizes[i]) {\n                ans.add(list);\n                map.put(groupSizes[i], new ArrayList<>());\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1175", "path": "output2\\java\\Medium\\1175-find-the-smallest-divisor-given-a-threshold.java", "hypo_code": "class Solution {\n    public int smallestDivisor(int[] nums, int threshold) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        int result = 0;\n        int left = 1;\n        int right = 1000000;\n        while(left < right) {\n            int mid = (left + right) / 2;\n            int sum = 0;\n            for(int i = 0; i < nums.length; i++) {\n                sum += (nums[i] - 1) / mid + 1;\n            }\n            if(sum > threshold) {\n                left = mid + 1;\n            }\n            else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}"}
{"id": "1177", "path": "output2\\java\\Medium\\1177-remove-covered-intervals.java", "hypo_code": "class RemoveCoveredIntervals {\n    public int removeCoveredIntervals(int[][] intervals) {\n        int n = intervals.length;\n        int[][] dp = new int[n + 1][2];\n        int max = 0;\n        for(int i = 1; i <= n; i++){\n            dp[i][0] = intervals[i - 1][0];\n            dp[i][1] = intervals[i - 1][1];\n            if(i >= 2){\n                if(dp[i][0] >= dp[i - 1][0] && dp[i][1] <= dp[i - 1][1]){\n                    dp[i][0] = dp[i - 1][0];\n                    dp[i][1] = dp[i - 1][1];\n                }\n            }\n        }\n        int count = 0;\n        for(int i = 1; i <= n; i++){\n            if(dp[i][0] == dp[i - 1][0] && dp[i][1] == dp[i - 1][1]){\n                count++;\n            }\n        }\n        return n - count;\n        \n    }\n}"}
{"id": "1178", "path": "output2\\java\\Medium\\1178-sequential-digits.java", "hypo_code": "class SequentialDigits {\n    public List<Integer> sequentialDigits(int low, int high) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = 1; i <= 9; i++){\n            int num = i;\n            for(int j = i + 1; j <= 9; j++){\n                num = num * 10 + j;\n                if(num >= low && num <= high){\n                    res.add(num);\n                }\n            }\n        }\n        Collections.sort(res);\n        return res;\n        \n    }\n}"}
{"id": "1179", "path": "output2\\java\\Medium\\1179-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold.java", "hypo_code": "class MaximumSideLengthOfASquareWithSumLessThanOrEqualToThreshold {\n    public int maxSideLength(int[][] mat, int threshold) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        int max = 0;\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mat[i - 1][j - 1];\n                if(i >= max + 1 && j >= max + 1 && dp[i][j] - dp[i - max - 1][j] - dp[i][j - max - 1] + dp[i - max - 1][j - max - 1] <= threshold){\n                    max++;\n                }\n            }\n        }\n        return max;\n        \n        \n        \n    }\n}"}
{"id": "1180", "path": "output2\\java\\Medium\\1180-divide-array-in-sets-of-k-consecutive-numbers.java", "hypo_code": "class DivideArrayInSetsOfKConsecutiveNumbers {\n    public boolean isPossibleDivide(int[] nums, int k) {\n        int n = nums.length;\n        if(n % k != 0){\n            return false;\n        }\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int num : nums){\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for(int key : map.keySet()){\n            pq.add(key);\n        }\n        while(!pq.isEmpty()){\n            int start = pq.poll();\n            int count = map.get(start);\n            for(int i = start; i < start + k; i++){\n                if(!map.containsKey(i)){\n                    return false;\n                }\n                map.put(i, map.get(i) - count);\n                if(map.get(i) == 0){\n                    map.remove(i);\n                }\n            }\n        }\n        return true;\n        \n        \n        \n    }\n}"}
{"id": "1181", "path": "output2\\java\\Medium\\1181-maximum-number-of-occurrences-of-a-substring.java", "hypo_code": "class MaximumNumberOfOccurrencesOfASubstring {\n    public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {\n        int n = s.length();\n        int[] count = new int[26];\n        int res = 0;\n        int unique = 0;\n        for(int i = 0; i < n; i++){\n            if(count[s.charAt(i) - 'a']++ == 0){\n                unique++;\n            }\n            if(i >= minSize && count[s.charAt(i - minSize) - 'a']-- == 1){\n                unique--;\n            }\n            if(i >= minSize - 1 && unique <= maxLetters){\n                res = Math.max(res, count(s, s.substring(i - minSize + 1, i + 1), minSize));\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1182", "path": "output2\\java\\Medium\\1182-sum-of-mutated-array-closest-to-target.java", "hypo_code": "class SumOfMutatedArrayClosestToTarget {\n    public int findBestValue(int[] arr, int target) {\n        int n = arr.length;\n        int[] prefix = new int[n + 1];\n        for(int i = 0; i < n; i++){\n            prefix[i + 1] = prefix[i] + arr[i];\n        }\n        int l = 0;\n        int r = 100000;\n        int res = 0;\n        int min = Integer.MAX_VALUE;\n        while(l <= r){\n            int mid = l + (r - l) / 2;\n            int index = Arrays.binarySearch(arr, mid);\n            if(index < 0){\n                index = -index - 1;\n            }\n            int sum = prefix[index] + (n - index) * mid;\n            if(sum <= target){\n                if(target - sum < min){\n                    min = target - sum;\n                    res = mid;\n                }\n                l = mid + 1;\n            }else{\n                if(sum - target < min){\n                    min = sum - target;\n                    res = mid;\n                }\n                r = mid - 1;\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "1183", "path": "output2\\java\\Medium\\1183-deepest-leaves-sum.java", "hypo_code": "class DeepestLeavesSum {\n    public int deepestLeavesSum(TreeNode root) {\n        int sum = 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            sum = 0;\n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                sum += node.val;\n                if(node.left != null){\n                    queue.offer(node.left);\n                }\n                if(node.right != null){\n                    queue.offer(node.right);\n                }\n            }\n        }\n        return sum;\n        \n    }\n}"}
{"id": "1184", "path": "output2\\java\\Medium\\1184-all-elements-in-two-binary-search-trees.java", "hypo_code": "class AllElementsInTwoBinarySearchTrees {\n    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack1 = new Stack<>();\n        Stack<TreeNode> stack2 = new Stack<>();\n        TreeNode node1 = root1;\n        TreeNode node2 = root2;\n        while(node1 != null || !stack1.isEmpty() || node2 != null || !stack2.isEmpty()){\n            while(node1 != null){\n                stack1.push(node1);\n                node1 = node1.left;\n            }\n            while(node2 != null){\n                stack2.push(node2);\n                node2 = node2.left;\n            }\n            if(stack2.isEmpty() || !stack1.isEmpty() && stack1.peek().val <= stack2.peek().val){\n                node1 = stack1.pop();\n                res.add(node1.val);\n                node1 = node1.right;\n            }else{\n                node2 = stack2.pop();\n                res.add(node2.val);\n                node2 = node2.right;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1185", "path": "output2\\java\\Medium\\1185-jump-game-iii.java", "hypo_code": "class JumpGameIii {\n    public boolean canReach(int[] arr, int start) {\n        int n = arr.length;\n        boolean[] visited = new boolean[n];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        while(!queue.isEmpty()){\n            int index = queue.poll();\n            if(arr[index] == 0){\n                return true;\n            }\n            if(visited[index]){\n                continue;\n            }\n            visited[index] = true;\n            if(index + arr[index] < n){\n                queue.add(index + arr[index]);\n            }\n            if(index - arr[index] >= 0){\n                queue.add(index - arr[index]);\n            }\n        }\n        return false;\n        \n        \n        \n    }\n}"}
{"id": "1186", "path": "output2\\java\\Medium\\1186-xor-queries-of-a-subarray.java", "hypo_code": "class Solution {\n    public int[] xorQueries(int[] arr, int[][] queries) {\n        int[] ans = new int[queries.length];\n        int[] prefix = new int[arr.length];\n        prefix[0] = arr[0];\n        for(int i = 1; i < arr.length; i++) {\n            prefix[i] = prefix[i-1] ^ arr[i];\n        }\n        for(int i = 0; i < queries.length; i++) {\n            int left = queries[i][0];\n            int right = queries[i][1];\n            ans[i] = left == 0 ? prefix[right] : prefix[right] ^ prefix[left-1];\n        }\n        return ans;\n    }\n}"}
{"id": "1187", "path": "output2\\java\\Medium\\1187-get-watched-videos-by-your-friends.java", "hypo_code": "class Solution {\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(id);\n        Map<String, Integer> map = new HashMap<>();\n        boolean[] visited = new boolean[friends.length];\n        while(!queue.isEmpty() && level >= 0) {\n            int size = queue.size();\n            while(size-- > 0) {\n                int curr = queue.poll();\n                if(visited[curr]) {\n                    continue;\n                }\n                visited[curr] = true;\n                if(level == 0) {\n                    List<String> list = watchedVideos.get(curr);\n                    for(String video : list) {\n                        map.put(video, map.getOrDefault(video, 0) + 1);\n                    }\n                }\n                else {\n                    for(int friend : friends[curr]) {\n                        queue.offer(friend);\n                    }\n                }\n            }\n            level--;\n        }\n        List<String> ans = new ArrayList<>(map.keySet());\n        Collections.sort(ans, (a, b) -> {\n            if(map.get(a) == map.get(b)) {\n                return a.compareTo(b);\n            }\n            return map.get(a) - map.get(b);\n        });\n        return ans;\n    }\n}"}
{"id": "1188", "path": "output2\\java\\Medium\\1188-matrix-block-sum.java", "hypo_code": "class Solution {\n    public int[][] matrixBlockSum(int[][] mat, int k) {\n        int[][] ans = new int[mat.length][mat[0].length];\n        int[][] sum = new int[mat.length+1][mat[0].length+1];\n        for(int i = 1; i <= mat.length; i++) {\n            for(int j = 1; j <= mat[0].length; j++) {\n                sum[i][j] = mat[i-1][j-1]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\n            }\n        }\n        for(int i = 1; i <= mat.length; i++) {\n            for(int j = 1; j <= mat[0].length; j++) {\n                int r1 = Math.max(i-k-1, 0);\n                int c1 = Math.max(j-k-1, 0);\n                int r2 = Math.min(i+k, mat.length);\n                int c2 = Math.min(j+k, mat[0].length);\n                ans[i-1][j-1] = sum[r2][c2]-sum[r1][c2]-sum[r2][c1]+sum[r1][c1];\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1189", "path": "output2\\java\\Medium\\1189-sum-of-nodes-with-even-valued-grandparent.java", "hypo_code": "class Solution {\n    public int sumEvenGrandparent(TreeNode root) {\n        int sum = 0;\n        dfs(root, sum);\n        return sum;\n    }\n    private void dfs(TreeNode root, int sum) {\n        if(root == null) {\n            return;\n        }\n        if(root.val % 2 == 0) {\n            if(root.left != null) {\n                if(root.left.left != null) {\n                    sum += root.left.left.val;\n                }\n                if(root.left.right != null) {\n                    sum += root.left.right.val;\n                }\n            }\n            if(root.right != null) {\n                if(root.right.left != null) {\n                    sum += root.right.left.val;\n                }\n                if(root.right.right != null) {\n                    sum += root.right.right.val;\n                }\n            }\n        }\n        dfs(root.left, sum);\n        dfs(root.right, sum);\n    }\n}"}
{"id": "1190", "path": "output2\\java\\Medium\\1190-minimum-flips-to-make-a-or-b-equal-to-c.java", "hypo_code": "class Solution {\n    public int minFlips(int a, int b, int c) {\n        int ans = 0;\n        while(a > 0 || b > 0 || c > 0) {\n            int a1 = a & 1;\n            int b1 = b & 1;\n            int c1 = c & 1;\n            if(c1 == 1) {\n                if(a1 == 0 && b1 == 0) {\n                    ans++;\n                }\n            }\n            else {\n                if(a1 == 1) {\n                    ans++;\n                }\n                if(b1 == 1) {\n                    ans++;\n                }\n            }\n            a >>= 1;\n            b >>= 1;\n            c >>= 1;\n        }\n        return ans;\n    }\n}"}
{"id": "1191", "path": "output2\\java\\Medium\\1191-number-of-operations-to-make-network-connected.java", "hypo_code": "class Solution {\n    public int makeConnected(int n, int[][] connections) {\n        if(connections.length < n-1) {\n            return -1;\n        }\n        int[] parent = new int[n];\n        for(int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        for(int[] connection: connections) {\n            int x = findParent(parent, connection[0]);\n            int y = findParent(parent, connection[1]);\n            if(x != y) {\n                parent[x] = y;\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            if(parent[i] == i) {\n                ans++;\n            }\n        }\n        return ans-1;\n    }\n    private int findParent(int[] parent, int x) {\n        if(parent[x] == x) {\n            return x;\n        }\n        parent[x] = findParent(parent, parent[x]);\n        return parent[x];\n    }\n}"}
{"id": "1193", "path": "output2\\java\\Medium\\1193-print-words-vertically.java", "hypo_code": "class PrintWordsVertically {\n    public List<String> printVertically(String s) {\n        String[] words = s.split(\" \");\n        int max = 0;\n        for(String word : words){\n            max = Math.max(max, word.length());\n        }\n        List<String> res = new ArrayList<>();\n        for(int i = 0; i < max; i++){\n            StringBuilder sb = new StringBuilder();\n            for(String word : words){\n                if(i < word.length()){\n                    sb.append(word.charAt(i));\n                }else{\n                    sb.append(\" \");\n                }\n            }\n            while(sb.charAt(sb.length() - 1) == ' '){\n                sb.deleteCharAt(sb.length() - 1);\n            }\n            res.add(sb.toString());\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1194", "path": "output2\\java\\Medium\\1194-delete-leaves-with-a-given-value.java", "hypo_code": "class DeleteLeavesWithAGivenValue {\n    public TreeNode removeLeafNodes(TreeNode root, int target) {\n        if(root == null){\n            return null;\n        }\n        root.left = removeLeafNodes(root.left, target);\n        root.right = removeLeafNodes(root.right, target);\n        if(root.left == null && root.right == null && root.val == target){\n            return null;\n        }\n        return root;\n        \n    }\n}"}
{"id": "1195", "path": "output2\\java\\Medium\\1195-break-a-palindrome.java", "hypo_code": "class BreakAPalindrome {\n    public String breakPalindrome(String palindrome) {\n        int n = palindrome.length();\n        if(n == 1){\n            return \"\";\n        }\n        char[] arr = palindrome.toCharArray();\n        for(int i = 0; i < n / 2; i++){\n            if(arr[i] != 'a'){\n                arr[i] = 'a';\n                return new String(arr);\n            }\n        }\n        arr[n - 1] = 'b';\n        return new String(arr);\n        \n    }\n}"}
{"id": "1196", "path": "output2\\java\\Medium\\1196-sort-the-matrix-diagonally.java", "hypo_code": "class SortTheMatrixDiagonally {\n    public int[][] diagonalSort(int[][] mat) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                dp[i][j] = mat[i - 1][j - 1];\n            }\n        }\n        for(int i = 1; i <= m; i++){\n            int[] arr = new int[Math.min(m - i + 1, n)];\n            int k = 0;\n            for(int j = 1; j <= n; j++){\n                if(i + j - 1 <= m){\n                    arr[k++] = dp[i + j - 1][j];\n                }\n            }\n            Arrays.sort(arr);\n            k = 0;\n            for(int j = 1; j <= n; j++){\n                if(i + j - 1 <= m){\n                    dp[i + j - 1][j] = arr[k++];\n                }\n            }\n        }\n        for(int j = 2; j <= n; j++){\n            int[] arr = new int[Math.min(n - j + 1, m)];\n            int k = 0;\n            for(int i = 1; i <= m; i++){\n                if(i + j - 1 <= n){\n                    arr[k++] = dp[i][i + j - 1];\n                }\n            }\n            Arrays.sort(arr);\n            k = 0;\n            for(int i = 1; i <= m; i++){\n                if(i + j - 1 <= n){\n                    dp[i][i + j - 1] = arr[k++];\n                }\n            }\n        }\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                mat[i - 1][j - 1] = dp[i][j];\n            }\n        }\n        return mat;\n        \n    }\n}"}
{"id": "1197", "path": "output2\\java\\Medium\\1197-filter-restaurants-by-vegan-friendly-price-and-distance.java", "hypo_code": "class FilterRestaurantsByVeganFriendlyPriceAndDistance {\n    public List<Integer> filterRestaurants(int[][] restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        List<int[]> list = new ArrayList<>();\n        for(int[] r : restaurants){\n            if(veganFriendly == 1 && r[2] == 0){\n                continue;\n            }\n            if(r[3] > maxPrice || r[4] > maxDistance){\n                continue;\n            }\n            list.add(r);\n        }\n        Collections.sort(list, (a, b) -> {\n            if(a[1] == b[1]){\n                return b[0] - a[0];\n            }\n            return b[1] - a[1];\n        });\n        List<Integer> res = new ArrayList<>();\n        for(int[] r : list){\n            res.add(r[0]);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1198", "path": "output2\\java\\Medium\\1198-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance.java", "hypo_code": "class FindTheCityWithTheSmallestNumberOfNeighborsAtAThresholdDistance {\n    public int findTheCity(int n, int[][] edges, int distanceThreshold) {\n        int[][] dp = new int[n][n];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(dp[i], 10001);\n            dp[i][i] = 0;\n        }\n        for(int[] e : edges){\n            dp[e[0]][e[1]] = e[2];\n            dp[e[1]][e[0]] = e[2];\n        }\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);\n                }\n            }\n        }\n        int res = 0;\n        int min = n;\n        for(int i = 0; i < n; i++){\n            int count = 0;\n            for(int j = 0; j < n; j++){\n                if(dp[i][j] <= distanceThreshold){\n                    count++;\n                }\n            }\n            if(count <= min){\n                min = count;\n                res = i;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1199", "path": "output2\\java\\Medium\\1199-reduce-array-size-to-the-half.java", "hypo_code": "class ReduceArraySizeToTheHalf {\n    public int minSetSize(int[] arr) {\n        int n = arr.length;\n        int[] count = new int[100001];\n        for(int i : arr){\n            count[i]++;\n        }\n        Arrays.sort(count);\n        int res = 0;\n        int sum = 0;\n        for(int i = count.length - 1; i >= 0; i--){\n            if(sum >= n / 2){\n                break;\n            }\n            sum += count[i];\n            res++;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1200", "path": "output2\\java\\Medium\\1200-maximum-product-of-splitted-binary-tree.java", "hypo_code": "class MaximumProductOfSplittedBinaryTree {\n    public int maxProduct(TreeNode root) {\n        int sum = sum(root);\n        long max = 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                long left = sum - node.val;\n                long right = node.val;\n                max = Math.max(max, left * right);\n                if(node.left != null){\n                    queue.offer(node.left);\n                }\n                if(node.right != null){\n                    queue.offer(node.right);\n                }\n            }\n        }\n        return (int)(max % 1000000007);\n        \n        \n    }\n}"}
{"id": "1202", "path": "output2\\java\\Medium\\1202-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold.java", "hypo_code": "class Solution {\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\n        int ans = 0;\n        int sum = 0;\n        int target = k * threshold;\n        for(int i = 0; i < arr.length; i++) {\n            sum += arr[i];\n            if(i >= k) {\n                sum -= arr[i-k];\n            }\n            if(i >= k-1 && sum >= target) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1203", "path": "output2\\java\\Medium\\1203-angle-between-hands-of-a-clock.java", "hypo_code": "class Solution {\n    public double angleClock(int hour, int minutes) {\n        double m = minutes*6;\n        double h = hour*30+minutes*0.5;\n        double ans = Math.abs(m-h);\n        return ans > 180 ? 360-ans : ans;\n    }\n}"}
{"id": "1204", "path": "output2\\java\\Medium\\1204-minimum-number-of-steps-to-make-two-strings-anagram.java", "hypo_code": "class Solution {\n    public int minSteps(String s, String t) {\n        int[] count = new int[26];\n        for(char c: s.toCharArray()) {\n            count[c-'a']++;\n        }\n        for(char c: t.toCharArray()) {\n            count[c-'a']--;\n        }\n        int ans = 0;\n        for(int i: count) {\n            ans += Math.abs(i);\n        }\n        return ans/2;\n    }\n}"}
{"id": "1207", "path": "output2\\java\\Medium\\1207-maximum-number-of-events-that-can-be-attended.java", "hypo_code": "class Solution {\n    public int maxEvents(int[][] events) {\n        Arrays.sort(events, (a, b) -> {\n            return a[0] - b[0];\n        });\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        int ans = 0;\n        int i = 0;\n        for(int d = 1; d <= 100000; d++) {\n            while(!pq.isEmpty() && pq.peek() < d) {\n                pq.poll();\n            }\n            while(i < events.length && events[i][0] == d) {\n                pq.offer(events[i][1]);\n                i++;\n            }\n            if(!pq.isEmpty()) {\n                pq.poll();\n                ans++;\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1209", "path": "output2\\java\\Medium\\1209-number-of-substrings-containing-all-three-characters.java", "hypo_code": "class NumberOfSubstringsContainingAllThreeCharacters {\n    public int numberOfSubstrings(String s) {\n        int n = s.length();\n        int[] count = new int[3];\n        int res = 0;\n        int unique = 0;\n        for(int i = 0; i < n; i++){\n            if(count[s.charAt(i) - 'a']++ == 0){\n                unique++;\n            }\n            while(unique == 3){\n                res += n - i;\n                if(--count[s.charAt(i - res + 1) - 'a'] == 0){\n                    unique--;\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1210", "path": "output2\\java\\Medium\\1210-validate-binary-tree-nodes.java", "hypo_code": "class ValidateBinaryTreeNodes {\n    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\n        int[] degree = new int[n];\n        for(int i = 0; i < n; i++){\n            if(leftChild[i] != -1){\n                degree[leftChild[i]]++;\n            }\n            if(rightChild[i] != -1){\n                degree[rightChild[i]]++;\n            }\n        }\n        int root = -1;\n        for(int i = 0; i < n; i++){\n            if(degree[i] == 0){\n                if(root != -1){\n                    return false;\n                }\n                root = i;\n            }\n            if(degree[i] > 1){\n                return false;\n            }\n        }\n        if(root == -1){\n            return false;\n        }\n        boolean[] visited = new boolean[n];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int node = queue.poll();\n            if(visited[node]){\n                return false;\n            }\n            visited[node] = true;\n            if(leftChild[node] != -1){\n                queue.offer(leftChild[node]);\n            }\n            if(rightChild[node] != -1){\n                queue.offer(rightChild[node]);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(!visited[i]){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "1211", "path": "output2\\java\\Medium\\1211-closest-divisors.java", "hypo_code": "class ClosestDivisors {\n    public int[] closestDivisors(int num) {\n        int[] res = new int[2];\n        int min = Integer.MAX_VALUE;\n        for(int i = 1; i * i <= num + 2; i++){\n            if((num + 1) % i == 0){\n                int j = (num + 1) / i;\n                if(Math.abs(i - j) < min){\n                    min = Math.abs(i - j);\n                    res[0] = i;\n                    res[1] = j;\n                }\n            }\n            if((num + 2) % i == 0){\n                int j = (num + 2) / i;\n                if(Math.abs(i - j) < min){\n                    min = Math.abs(i - j);\n                    res[0] = i;\n                    res[1] = j;\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1212", "path": "output2\\java\\Medium\\1212-rank-teams-by-votes.java", "hypo_code": "class Solution {\n    public String rankTeams(String[] votes) {\n        int[][] rank = new int[26][27];\n        for (int i = 0; i < 26; i++) {\n            rank[i][26] = -i;\n        }\n        for (String s : votes) {\n            for (int i = 0; i < s.length(); i++) {\n                rank[s.charAt(i) - 'A'][i]++;\n            }\n        }\n        Arrays.sort(rank, (a, b) -> {\n            for (int i = 0; i < 27; i++) {\n                if (a[i] != b[i]) {\n                    return b[i] - a[i];\n                }\n            }\n            return 0;\n        });\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < votes[0].length(); i++) {\n            sb.append((char)('A' - rank[i][26]));\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1213", "path": "output2\\java\\Medium\\1213-linked-list-in-binary-tree.java", "hypo_code": "class LinkedListInBinaryTree {\n    public boolean isSubPath(ListNode head, TreeNode root) {\n        if(root == null){\n            return false;\n        }\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\n        \n        \n    }\n}"}
{"id": "1214", "path": "output2\\java\\Medium\\1214-find-the-longest-substring-containing-vowels-in-even-counts.java", "hypo_code": "class FindTheLongestSubstringContainingVowelsInEvenCounts {\n    public int findTheLongestSubstring(String s) {\n        int n = s.length();\n        int[] count = new int[26];\n        int res = 0;\n        int unique = 0;\n        for(int i = 0; i < n; i++){\n            if(count[s.charAt(i) - 'a']++ == 0){\n                unique++;\n            }\n            if(i >= minSize && count[s.charAt(i - minSize) - 'a']-- == 1){\n                unique--;\n            }\n            if(i >= minSize - 1 && unique <= maxLetters){\n                res = Math.max(res, count(s, s.substring(i - minSize + 1, i + 1), minSize));\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1215", "path": "output2\\java\\Medium\\1215-longest-zigzag-path-in-a-binary-tree.java", "hypo_code": "class LongestZigzagPathInABinaryTree {\n    public int longestZigZag(TreeNode root) {\n        int[] max = new int[1];\n        helper(root, max, true);\n        return max[0];\n        \n    }\n}"}
{"id": "1216", "path": "output2\\java\\Medium\\1216-number-of-times-binary-string-is-prefix-aligned.java", "hypo_code": "class NumberOfTimesBinaryStringIsPrefixAligned {\n    public int numTimesAllBlue(int[] flips) {\n        int max = 0;\n        int count = 0;\n        for(int i = 0; i < flips.length; i++){\n            max = Math.max(max, flips[i]);\n            if(max == i + 1){\n                count++;\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1217", "path": "output2\\java\\Medium\\1217-time-needed-to-inform-all-employees.java", "hypo_code": "class TimeNeededToInformAllEmployees {\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\n        int max = 0;\n        for(int i = 0; i < n; i++){\n            int time = informTime[i];\n            int j = i;\n            while(manager[j] != -1){\n                time += informTime[manager[j]];\n                j = manager[j];\n            }\n            max = Math.max(max, time);\n        }\n        return max;\n        \n    }\n}"}
{"id": "1219", "path": "output2\\java\\Medium\\1219-balance-a-binary-search-tree.java", "hypo_code": "class BalanceABinarySearchTree {\n    public TreeNode balanceBST(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n        inorder(root, list);\n        return buildTree(list, 0, list.size() - 1);\n        \n    }\n}"}
{"id": "1220", "path": "output2\\java\\Medium\\1220-cinema-seat-allocation.java", "hypo_code": "class CinemaSeatAllocation {\n    public int maxNumberOfFamilies(int n, int[][] reservedSeats) {\n        int count = 0;\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        for(int[] seat : reservedSeats){\n            map.putIfAbsent(seat[0], new HashSet<>());\n            map.get(seat[0]).add(seat[1]);\n        }\n        for(int i = 1; i <= n; i++){\n            Set<Integer> set = map.getOrDefault(i, new HashSet<>());\n            if(!set.contains(2) && !set.contains(3) && !set.contains(4) && !set.contains(5)){\n                count++;\n                set.add(2);\n                set.add(3);\n                set.add(4);\n                set.add(5);\n            }\n            if(!set.contains(6) && !set.contains(7) && !set.contains(8) && !set.contains(9)){\n                count++;\n                set.add(6);\n                set.add(7);\n                set.add(8);\n                set.add(9);\n            }\n            if(!set.contains(4) && !set.contains(5) && !set.contains(6) && !set.contains(7)){\n                count++;\n            }\n        }\n        return count;\n        \n        \n    }\n}"}
{"id": "1221", "path": "output2\\java\\Medium\\1221-sort-integers-by-the-power-value.java", "hypo_code": "class SortIntegersByThePowerValue {\n    public int getKth(int lo, int hi, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = lo; i <= hi; i++){\n            int count = 0;\n            int num = i;\n            while(num != 1){\n                if(map.containsKey(num)){\n                    count += map.get(num);\n                    break;\n                }\n                if(num % 2 == 0){\n                    num /= 2;\n                }else{\n                    num = 3 * num + 1;\n                }\n                count++;\n            }\n            map.put(i, count);\n        }\n        List<Integer> list = new ArrayList<>(map.keySet());\n        Collections.sort(list, (a, b) -> map.get(a) == map.get(b) ? a - b : map.get(a) - map.get(b));\n        return list.get(k - 1);\n        \n    }\n}"}
{"id": "1222", "path": "output2\\java\\Medium\\1222-four-divisors.java", "hypo_code": "class FourDivisors {\n    public int sumFourDivisors(int[] nums) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            int count = 0;\n            int divisors = 0;\n            for(int j = 1; j <= nums[i]; j++){\n                if(nums[i] % j == 0){\n                    count++;\n                    divisors += j;\n                }\n            }\n            if(count == 4){\n                sum += divisors;\n            }\n        }\n        return sum;\n        \n        \n    }\n}"}
{"id": "1223", "path": "output2\\java\\Medium\\1223-check-if-there-is-a-valid-path-in-a-grid.java", "hypo_code": "class CheckIfThereIsAValidPathInAGrid {\n    public boolean hasValidPath(int[][] grid) {\n        int[][][] directions = new int[][][]{{{0, 1}, {0, -1}}, {{1, 0}, {-1, 0}}, {{0, 1}, {1, 0}}, {{0, -1}, {1, 0}}, {{0, 1}, {-1, 0}}, {{0, -1}, {-1, 0}}};\n        int[][] visited = new int[grid.length][grid[0].length];\n        return dfs(grid, 0, 0, visited, directions);\n        \n    }\n}"}
{"id": "1225", "path": "output2\\java\\Medium\\1225-count-number-of-teams.java", "hypo_code": "class CountNumberOfTeams {\n    public int numTeams(int[] rating) {\n        int count = 0;\n        for(int i = 0; i < rating.length; i++){\n            for(int j = i + 1; j < rating.length; j++){\n                for(int k = j + 1; k < rating.length; k++){\n                    if(rating[i] < rating[j] && rating[j] < rating[k]){\n                        count++;\n                    }\n                    if(rating[i] > rating[j] && rating[j] > rating[k]){\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n        \n        \n    }\n}"}
{"id": "1227", "path": "output2\\java\\Medium\\1227-construct-k-palindrome-strings.java", "hypo_code": "class ConstructKPalindromeStrings {\n    public boolean canConstruct(String s, int k) {\n        if(s.length() < k){\n            return false;\n        }\n        int[] count = new int[26];\n        for(int i = 0; i < s.length(); i++){\n            count[s.charAt(i) - 'a']++;\n        }\n        int odd = 0;\n        for(int i = 0; i < 26; i++){\n            if(count[i] % 2 == 1){\n                odd++;\n            }\n        }\n        return odd <= k;\n        \n    }\n}"}
{"id": "1228", "path": "output2\\java\\Medium\\1228-circle-and-rectangle-overlapping.java", "hypo_code": "class CircleAndRectangleOverlapping {\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\n        int x = Math.max(x1, Math.min(xCenter, x2));\n        int y = Math.max(y1, Math.min(yCenter, y2));\n        return Math.pow(x - xCenter, 2) + Math.pow(y - yCenter, 2) <= Math.pow(radius, 2);\n        \n        \n    }\n}"}
{"id": "1229", "path": "output2\\java\\Medium\\1229-number-of-steps-to-reduce-a-number-in-binary-representation-to-one.java", "hypo_code": "class NumberOfStepsToReduceANumberInBinaryRepresentationToOne {\n    public int numSteps(String s) {\n        int count = 0;\n        int carry = 0;\n        for(int i = s.length() - 1; i > 0; i--){\n            if(s.charAt(i) == '0'){\n                if(carry == 1){\n                    count += 2;\n                }else{\n                    count++;\n                }\n            }else{\n                if(carry == 1){\n                    count++;\n                }else{\n                    count += 2;\n                    carry = 1;\n                }\n            }\n        }\n        return count + carry;\n        \n    }\n}"}
{"id": "1230", "path": "output2\\java\\Medium\\1230-longest-happy-string.java", "hypo_code": "class LongestHappyString {\n    public String longestDiverseString(int a, int b, int c) {\n        StringBuilder sb = new StringBuilder();\n        int[] count = new int[]{a, b, c};\n        int[] last = new int[]{0, 0, 0};\n        while(count[0] > 0 || count[1] > 0 || count[2] > 0){\n            int max = 0;\n            int index = 0;\n            for(int i = 0; i < 3; i++){\n                if(count[i] > max && last[i] != 2){\n                    max = count[i];\n                    index = i;\n                }\n            }\n            if(max == 0){\n                break;\n            }\n            sb.append((char)('a' + index));\n            count[index]--;\n            last[index]++;\n            last[(index + 1) % 3] = 0;\n            last[(index + 2) % 3] = 0;\n        }\n        return sb.toString();\n        \n        \n    }\n}"}
{"id": "1231", "path": "output2\\java\\Medium\\1231-queries-on-a-permutation-with-key.java", "hypo_code": "class QueriesOnAPermutationWithKey {\n    public int[] processQueries(int[] queries, int m) {\n        int[] P = new int[m];\n        for(int i = 0; i < m; i++){\n            P[i] = i + 1;\n        }\n        int[] result = new int[queries.length];\n        for(int i = 0; i < queries.length; i++){\n            int index = 0;\n            for(int j = 0; j < m; j++){\n                if(P[j] == queries[i]){\n                    index = j;\n                    break;\n                }\n            }\n            result[i] = index;\n            int temp = P[index];\n            for(int j = index; j > 0; j--){\n                P[j] = P[j - 1];\n            }\n            P[0] = temp;\n        }\n        return result;\n        \n    }\n}"}
{"id": "1232", "path": "output2\\java\\Medium\\1232-html-entity-parser.java", "hypo_code": "class HtmlEntityParser {\n    public String entityParser(String text) {\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < text.length(); i++){\n            if(text.charAt(i) == '&'){\n                if(i + 5 < text.length() && text.substring(i, i + 6).equals(\"&quot;\")){\n                    sb.append(\"\\\"\");\n                    i += 5;\n                }else if(i + 5 < text.length() && text.substring(i, i + 6).equals(\"&apos;\")){\n                    sb.append(\"'\");\n                    i += 5;\n                }else if(i + 4 < text.length() && text.substring(i, i + 5).equals(\"&amp;\")){\n                    sb.append(\"&\");\n                    i += 4;\n                }else if(i + 3 < text.length() && text.substring(i, i + 4).equals(\"&gt;\")){\n                    sb.append(\">\");\n                    i += 3;\n                }else if(i + 3 < text.length() && text.substring(i, i + 4).equals(\"&lt;\")){\n                    sb.append(\"<\");\n                    i += 3;\n                }else if(i + 6 < text.length() && text.substring(i, i + 7).equals(\"&frasl;\")){\n                    sb.append(\"/\");\n                    i += 6;\n                }else{\n                    sb.append(text.charAt(i));\n                }\n            }else{\n                sb.append(text.charAt(i));\n            }\n        }\n        return sb.toString();\n        \n        \n    }\n}"}
{"id": "1233", "path": "output2\\java\\Medium\\1233-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k.java", "hypo_code": "class FindTheMinimumNumberOfFibonacciNumbersWhoseSumIsK {\n    public int findMinFibonacciNumbers(int k) {\n        int count = 0;\n        int[] fib = new int[50];\n        fib[0] = 1;\n        fib[1] = 1;\n        for(int i = 2; i < 50; i++){\n            fib[i] = fib[i - 1] + fib[i - 2];\n        }\n        for(int i = 49; i >= 0; i--){\n            if(k >= fib[i]){\n                k -= fib[i];\n                count++;\n            }\n        }\n        return count;\n        \n        \n    }\n}"}
{"id": "1234", "path": "output2\\java\\Medium\\1234-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n.java", "hypo_code": "class TheKThLexicographicalStringOfAllHappyStringsOfLengthN {\n    public String getHappyString(int n, int k) {\n        int total = (int)Math.pow(2, n - 1);\n        if(k > 3 * total){\n            return \"\";\n        }\n        int index = (k - 1) / total;\n        char[] chars = new char[n];\n        chars[0] = (char)('a' + index);\n        int count = 1;\n        while(count < n){\n            int temp = (k - 1) % total;\n            index = temp / (total / 2);\n            chars[count] = (char)('a' + index);\n            count++;\n            total /= 2;\n        }\n        return new String(chars);\n        \n    }\n}"}
{"id": "1235", "path": "output2\\java\\Medium\\1235-display-table-of-food-orders-in-a-restaurant.java", "hypo_code": "class DisplayTableOfFoodOrdersInARestaurant {\n    public List<List<String>> displayTable(List<List<String>> orders) {\n        Set<String> foodItems = new HashSet<>();\n        Map<Integer, Map<String, Integer>> map = new HashMap<>();\n        for(List<String> order : orders){\n            String name = order.get(0);\n            int table = Integer.parseInt(order.get(1));\n            String food = order.get(2);\n            foodItems.add(food);\n            if(!map.containsKey(table)){\n                map.put(table, new HashMap<>());\n            }\n            Map<String, Integer> tableMap = map.get(table);\n            tableMap.put(food, tableMap.getOrDefault(food, 0) + 1);\n        }\n        List<String> foodList = new ArrayList<>(foodItems);\n        Collections.sort(foodList);\n        List<List<String>> res = new ArrayList<>();\n        List<String> header = new ArrayList<>();\n        header.add(\"Table\");\n        header.addAll(foodList);\n        res.add(header);\n        List<Integer> tables = new ArrayList<>(map.keySet());\n        Collections.sort(tables);\n        for(int table : tables){\n            List<String> row = new ArrayList<>();\n            row.add(String.valueOf(table));\n            Map<String, Integer> tableMap = map.get(table);\n            for(String food : foodList){\n                row.add(String.valueOf(tableMap.getOrDefault(food, 0)));\n            }\n            res.add(row);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1236", "path": "output2\\java\\Medium\\1236-minimum-number-of-frogs-croaking.java", "hypo_code": "class MinimumNumberOfFrogsCroaking {\n    public int minNumberOfFrogs(String croakOfFrogs) {\n        int[] count = new int[5];\n        int frogs = 0;\n        int maxFrogs = 0;\n        for(char c : croakOfFrogs.toCharArray()){\n            if(c == 'c'){\n                count[0]++;\n                frogs++;\n                maxFrogs = Math.max(maxFrogs, frogs);\n            }\n            else if(c == 'r'){\n                if(count[0] == 0){\n                    return -1;\n                }\n                count[0]--;\n                count[1]++;\n            }\n            else if(c == 'o'){\n                if(count[1] == 0){\n                    return -1;\n                }\n                count[1]--;\n                count[2]++;\n            }\n            else if(c == 'a'){\n                if(count[2] == 0){\n                    return -1;\n                }\n                count[2]--;\n                count[3]++;\n            }\n            else if(c == 'k'){\n                if(count[3] == 0){\n                    return -1;\n                }\n                count[3]--;\n                frogs--;\n            }\n        }\n        for(int i = 0; i < 5; i++){\n            if(count[i] != 0){\n                return -1;\n            }\n        }\n        return maxFrogs;\n        \n        \n    }\n}"}
{"id": "1237", "path": "output2\\java\\Medium\\1237-maximum-points-you-can-obtain-from-cards.java", "hypo_code": "class MaximumPointsYouCanObtainFromCards {\n    public int maxScore(int[] cardPoints, int k) {\n        int sum = 0;\n        for(int i = 0; i < k; i++){\n            sum += cardPoints[i];\n        }\n        int max = sum;\n        for(int i = 0; i < k; i++){\n            sum -= cardPoints[k - i - 1];\n            sum += cardPoints[cardPoints.length - i - 1];\n            max = Math.max(max, sum);\n        }\n        return max;\n        \n    }\n}"}
{"id": "1238", "path": "output2\\java\\Medium\\1238-diagonal-traverse-ii.java", "hypo_code": "class Solution {\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\n        int size = 0, maxKey = 0;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < nums.size(); i++) {\n            size += nums.get(i).size();\n            for (int j = 0; j < nums.get(i).size(); j++) {\n                int key = i + j;\n                maxKey = Math.max(maxKey, key);\n                map.putIfAbsent(key, new ArrayList<>());\n                map.get(key).add(nums.get(i).get(j));\n            }\n        }\n        int[] result = new int[size];\n        int index = 0;\n        for (int i = 0; i <= maxKey; i++) {\n            List<Integer> list = map.get(i);\n            if (list != null) {\n                for (int j = list.size() - 1; j >= 0; j--) {\n                    result[index++] = list.get(j);\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "1239", "path": "output2\\java\\Medium\\1239-max-difference-you-can-get-from-changing-an-integer.java", "hypo_code": "class Solution {\n    public int maxDiff(int num) {\n        String numStr = String.valueOf(num);\n        int len = numStr.length();\n        int max = num, min = num;\n        for (int i = 0; i < len; i++) {\n            if (numStr.charAt(i) != '9') {\n                max = Integer.parseInt(numStr.replace(numStr.charAt(i), '9'));\n                break;\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            if (i == 0 && numStr.charAt(i) != '1') {\n                min = Integer.parseInt(numStr.replace(numStr.charAt(i), '1'));\n                break;\n            }\n            if (i > 0 && numStr.charAt(i) != '0' && numStr.charAt(i) != numStr.charAt(0)) {\n                min = Integer.parseInt(numStr.replace(numStr.charAt(i), '0'));\n                break;\n            }\n        }\n        return max - min;\n    }\n}"}
{"id": "1240", "path": "output2\\java\\Medium\\1240-check-if-a-string-can-break-another-string.java", "hypo_code": "class Solution {\n    public boolean checkIfCanBreak(String s1, String s2) {\n        int[] count1 = new int[26], count2 = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            count1[s1.charAt(i) - 'a']++;\n            count2[s2.charAt(i) - 'a']++;\n        }\n        int flag1 = 0, flag2 = 0;\n        for (int i = 0; i < 26; i++) {\n            flag1 += count1[i];\n            flag2 += count2[i];\n            if (flag1 > flag2) {\n                return false;\n            }\n        }\n        flag1 = 0;\n        flag2 = 0;\n        for (int i = 25; i >= 0; i--) {\n            flag1 += count1[i];\n            flag2 += count2[i];\n            if (flag1 > flag2) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "1241", "path": "output2\\java\\Medium\\1241-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit.java", "hypo_code": "class Solution {\n    public int longestSubarray(int[] nums, int limit) {\n        int max = 0, min = 0, left = 0, right = 0, result = 0;\n        while (right < nums.length) {\n            max = Math.max(max, nums[right]);\n            min = Math.min(min, nums[right]);\n            if (max - min <= limit) {\n                result = Math.max(result, right - left + 1);\n            } else {\n                if (nums[right] == max) {\n                    while (nums[left] != min) {\n                        left++;\n                    }\n                    left++;\n                    min = nums[left];\n                    for (int i = left + 1; i <= right; i++) {\n                        min = Math.min(min, nums[i]);\n                    }\n                } else {\n                    while (nums[left] != max) {\n                        left++;\n                    }\n                    left++;\n                    max = nums[left];\n                    for (int i = left + 1; i <= right; i++) {\n                        max = Math.max(max, nums[i]);\n                    }\n                }\n            }\n            right++;\n        }\n        return result;\n    }\n}"}
{"id": "1242", "path": "output2\\java\\Medium\\1242-build-an-array-with-stack-operations.java", "hypo_code": "class Solution {\n    public List<String> buildArray(int[] target, int n) {\n        List<String> result = new ArrayList<>();\n        int index = 0;\n        for (int i = 1; i <= n; i++) {\n            if (index >= target.length) {\n                break;\n            }\n            result.add(\"Push\");\n            if (target[index] == i) {\n                index++;\n            } else {\n                result.add(\"Pop\");\n            }\n        }\n        return result;\n    }\n}"}
{"id": "1243", "path": "output2\\java\\Medium\\1243-count-triplets-that-can-form-two-arrays-of-equal-xor.java", "hypo_code": "class Solution {\n    public int countTriplets(int[] arr) {\n        int n = arr.length;\n        int[] s = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            s[i] = s[i - 1] ^ arr[i - 1];\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 1 + i; j < n; j++) {\n                for (int k = j; k < n; k++) {\n                    if (s[j] ^ s[i] == s[k + 1] ^ s[j]) {\n                        ans++;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1244", "path": "output2\\java\\Medium\\1244-minimum-time-to-collect-all-apples-in-a-tree.java", "hypo_code": "class Solution {\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\n        int[] parent = new int[n];\n        Arrays.fill(parent, -1);\n        for (int[] edge : edges) {\n            parent[edge[1]] = edge[0];\n        }\n        boolean[] visited = new boolean[n];\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (hasApple.get(i) && !visited[i]) {\n                visited[i] = true;\n                int j = i;\n                while (parent[j] != -1 && !visited[parent[j]]) {\n                    visited[parent[j]] = true;\n                    j = parent[j];\n                    ans += 2;\n                }\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "1245", "path": "output2\\java\\Medium\\1245-simplified-fractions.java", "hypo_code": "class SimplifiedFractions {\n    public List<String> simplifiedFractions(int n) {\n        List<String> list = new ArrayList<>();\n        for(int i = 1; i < n; i++){\n            for(int j = i + 1; j <= n; j++){\n                if(gcd(i, j) == 1){\n                    list.add(i + \"/\" + j);\n                }\n            }\n        }\n        return list;\n        \n        \n    }\n}"}
{"id": "1246", "path": "output2\\java\\Medium\\1246-count-good-nodes-in-binary-tree.java", "hypo_code": "class CountGoodNodesInBinaryTree {\n    public int goodNodes(TreeNode root) {\n        return helper(root, Integer.MIN_VALUE);\n        \n    }\n}"}
{"id": "1247", "path": "output2\\java\\Medium\\1247-rearrange-words-in-a-sentence.java", "hypo_code": "class RearrangeWordsInASentence {\n    public String arrangeWords(String text) {\n        String[] words = text.split(\" \");\n        words[0] = words[0].toLowerCase();\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        words[0] = words[0].substring(0, 1).toUpperCase() + words[0].substring(1);\n        return String.join(\" \", words);\n        \n    }\n}"}
{"id": "1248", "path": "output2\\java\\Medium\\1248-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list.java", "hypo_code": "class Solution {\n    public List<Integer> peopleIndexes(List<List<String>> favoriteCompanies) {\n        List<Integer> res = new ArrayList<>();\n        Map<String, Set<Integer>> map = new HashMap<>();\n        for (int i = 0; i < favoriteCompanies.size(); i++) {\n            for (String s : favoriteCompanies.get(i)) {\n                Set<Integer> set = map.getOrDefault(s, new HashSet<>());\n                set.add(i);\n                map.put(s, set);\n            }\n        }\n        for (int i = 0; i < favoriteCompanies.size(); i++) {\n            List<String> list = favoriteCompanies.get(i);\n            Set<Integer> set = new HashSet<>();\n            for (String s : list) {\n                set.addAll(map.get(s));\n            }\n            if (set.size() == favoriteCompanies.size()) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1249", "path": "output2\\java\\Medium\\1249-maximum-number-of-vowels-in-a-substring-of-given-length.java", "hypo_code": "class Solution {\n    public int maxVowels(String s, int k) {\n        int n = s.length();\n        int[] arr = new int[n];\n        int[] sum = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == 'a' || s.charAt(i) == 'e'\n               || s.charAt(i) == 'i' || s.charAt(i) == 'o'\n               || s.charAt(i) == 'u') {\n                arr[i] = 1;\n            }\n        }\n        sum[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            sum[i] = sum[i-1] + arr[i];\n        }\n        for (int i = k - 1; i < n; i++) {\n            int cur = sum[i];\n            if (i - k >= 0) {\n                cur -= sum[i-k];\n            }\n            res = Math.max(res, cur);\n        }\n        return res;\n    }\n}"}
{"id": "1250", "path": "output2\\java\\Medium\\1250-pseudo-palindromic-paths-in-a-binary-tree.java", "hypo_code": "class Solution {\n    public int pseudoPalindromicPaths (TreeNode root) {\n        int res = 0;\n        int[] arr = new int[10];\n        dfs(root, arr);\n        for (int i = 1; i <= 9; i++) {\n            if (arr[i] % 2 == 1) {\n                res++;\n            }\n        }\n        return res;\n    }\n    private void dfs(TreeNode root, int[] arr) {\n        if (root == null) {\n            return;\n        }\n        arr[root.val]++;\n        if (root.left == null && root.right == null) {\n            return;\n        }\n        dfs(root.left, arr);\n        dfs(root.right, arr);\n        arr[root.val]--;\n    }\n}"}
{"id": "1251", "path": "output2\\java\\Medium\\1251-check-if-a-string-contains-all-binary-codes-of-size-k.java", "hypo_code": "class Solution {\n    public boolean hasAllCodes(String s, int k) {\n        int n = s.length();\n        Set<String> set = new HashSet<>();\n        for (int i = 0; i <= n - k; i++) {\n            set.add(s.substring(i, i + k));\n        }\n        return set.size() == Math.pow(2, k);\n    }\n}"}
{"id": "1252", "path": "output2\\java\\Medium\\1252-course-schedule-iv.java", "hypo_code": "class Solution {\n    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {\n        List<Boolean> res = new ArrayList<>();\n        boolean[][] dp = new boolean[numCourses][numCourses];\n        for (int[] p : prerequisites) {\n            dp[p[0]][p[1]] = true;\n        }\n        for (int k = 0; k < numCourses; k++) {\n            for (int i = 0; i < numCourses; i++) {\n                for (int j = 0; j < numCourses; j++) {\n                    dp[i][j] = dp[i][j] || (dp[i][k] && dp[k][j]);\n                }\n            }\n        }\n        for (int[] q : queries) {\n            res.add(dp[q[0]][q[1]]);\n        }\n        return res;\n    }\n}"}
{"id": "1253", "path": "output2\\java\\Medium\\1253-maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts.java", "hypo_code": "class Solution {\n    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n        int mod = (int)1e9 + 7;\n        Arrays.sort(horizontalCuts);\n        Arrays.sort(verticalCuts);\n        int maxH = Math.max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.length - 1]);\n        int maxW = Math.max(verticalCuts[0], w - verticalCuts[verticalCuts.length - 1]);\n        for (int i = 1; i < horizontalCuts.length; i++) {\n            maxH = Math.max(maxH, horizontalCuts[i] - horizontalCuts[i-1]);\n        }\n        for (int i = 1; i < verticalCuts.length; i++) {\n            maxW = Math.max(maxW, verticalCuts[i] - verticalCuts[i-1]);\n        }\n        return (int)((long)maxH * maxW % mod);\n    }\n}"}
{"id": "1254", "path": "output2\\java\\Medium\\1254-reorder-routes-to-make-all-paths-lead-to-the-city-zero.java", "hypo_code": "class Solution {\n    public int minReorder(int n, int[][] connections) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(i, new ArrayList<>());\n        }\n        for (int[] c : connections) {\n            graph.get(c[0]).add(c[1]);\n            graph.get(c[1]).add(-c[0]);\n        }\n        boolean[] visited = new boolean[n];\n        return dfs(graph, visited, 0);\n    }\n    private int dfs(List<List<Integer>> graph, boolean[] visited, int cur) {\n        int res = 0;\n        visited[cur] = true;\n        for (int next : graph.get(cur)) {\n            if (visited[Math.abs(next)]) {\n                continue;\n            }\n            res += dfs(graph, visited, Math.abs(next)) + (next > 0 ? 1 : 0);\n        }\n        return res;\n    }\n}"}
{"id": "1255", "path": "output2\\java\\Medium\\1255-the-k-strongest-values-in-an-array.java", "hypo_code": "class TheKStrongestValuesInAnArray {\n    public int[] getStrongest(int[] arr, int k) {\n        Arrays.sort(arr);\n        int median = arr[(arr.length - 1) / 2];\n        int[] result = new int[k];\n        int left = 0;\n        int right = arr.length - 1;\n        int count = 0;\n        while(count < k){\n            if(Math.abs(arr[left] - median) > Math.abs(arr[right] - median)){\n                result[count] = arr[left];\n                left++;\n            }else{\n                result[count] = arr[right];\n                right--;\n            }\n            count++;\n        }\n        return result;\n        \n    }\n}"}
{"id": "1258", "path": "output2\\java\\Medium\\1258-find-two-non-overlapping-sub-arrays-each-with-target-sum.java", "hypo_code": "class FindTwoNonOverlappingSubArraysEachWithTargetSum {\n    public int minSumOfLengths(int[] arr, int target) {\n        int[] dp = new int[arr.length];\n        int sum = 0;\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        for(int i = 0; i < arr.length; i++){\n            sum += arr[i];\n            if(sum == target){\n                dp[i] = i + 1;\n                if(min > dp[i]){\n                    min = dp[i];\n                    minIndex = i;\n                }\n            }\n            for(int j = i - 1; j >= 0; j--){\n                if(sum - arr[j] == target){\n                    dp[j] = i - j + 1;\n                    if(min > dp[j]){\n                        min = dp[j];\n                        minIndex = j;\n                    }\n                }\n                if(sum - arr[j] > target){\n                    break;\n                }\n            }\n        }\n        int min2 = Integer.MAX_VALUE;\n        for(int i = 0; i < arr.length; i++){\n            if(i == minIndex){\n                continue;\n            }\n            if(dp[i] != 0){\n                min2 = Math.min(min2, dp[i]);\n            }\n        }\n        if(min2 == Integer.MAX_VALUE){\n            return -1;\n        }\n        return min + min2;\n        \n    }\n}"}
{"id": "1259", "path": "output2\\java\\Medium\\1259-least-number-of-unique-integers-after-k-removals.java", "hypo_code": "class LeastNumberOfUniqueIntegersAfterKRemovals {\n    public int findLeastNumOfUniqueInts(int[] arr, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < arr.length; i++){\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> map.get(a) - map.get(b));\n        for(int key : map.keySet()){\n            pq.add(key);\n        }\n        while(k > 0){\n            int key = pq.poll();\n            map.put(key, map.get(key) - 1);\n            if(map.get(key) == 0){\n                map.remove(key);\n            }\n            k--;\n        }\n        return map.size();\n        \n    }\n}"}
{"id": "1260", "path": "output2\\java\\Medium\\1260-minimum-number-of-days-to-make-m-bouquets.java", "hypo_code": "class MinimumNumberOfDaysToMakeMBouquets {\n    public int minDays(int[] bloomDay, int m, int k) {\n        if(m * k > bloomDay.length){\n            return -1;\n        }\n        int low = 1;\n        int high = 1000000000;\n        while(low < high){\n            int mid = low + (high - low) / 2;\n            if(canMake(bloomDay, m, k, mid)){\n                high = mid;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        return low;\n        \n    }\n}"}
{"id": "1261", "path": "output2\\java\\Medium\\1261-making-file-names-unique.java", "hypo_code": "class Solution {\n    public String[] getFolderNames(String[] names) {\n        int n = names.length;\n        String[] res = new String[n];\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            String name = names[i];\n            if (map.containsKey(name)) {\n                int k = map.get(name);\n                while (map.containsKey(name + \"(\" + k + \")\")) {\n                    k++;\n                }\n                map.put(name, k + 1);\n                map.put(name + \"(\" + k + \")\", 1);\n                res[i] = name + \"(\" + k + \")\";\n            } else {\n                map.put(name, 1);\n                res[i] = name;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1262", "path": "output2\\java\\Medium\\1262-avoid-flood-in-the-city.java", "hypo_code": "class Solution {\n    public int[] avoidFlood(int[] rains) {\n        int n = rains.length;\n        int[] res = new int[n];\n        Arrays.fill(res, -1);\n        Map<Integer, Integer> map = new HashMap<>();\n        TreeSet<Integer> set = new TreeSet<>();\n        for (int i = 0; i < n; i++) {\n            if (rains[i] == 0) {\n                set.add(i);\n            } else {\n                if (map.containsKey(rains[i])) {\n                    Integer next = set.ceiling(map.get(rains[i]));\n                    if (next == null) {\n                        return new int[0];\n                    }\n                    res[next] = rains[i];\n                    set.remove(next);\n                }\n                map.put(rains[i], i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (res[i] == -1) {\n                res[i] = 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1263", "path": "output2\\java\\Medium\\1263-the-kth-factor-of-n.java", "hypo_code": "class Solution {\n    public int kthFactor(int n, int k) {\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                k--;\n                if (k == 0) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "1264", "path": "output2\\java\\Medium\\1264-longest-subarray-of-1s-after-deleting-one-element.java", "hypo_code": "class Solution {\n    public int longestSubarray(int[] nums) {\n        int n = nums.length;\n        int[] arr = new int[n];\n        int[] sum = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 1) {\n                arr[i] = 1;\n            }\n        }\n        sum[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            sum[i] = sum[i-1] + arr[i];\n        }\n        for (int i = 0; i < n; i++) {\n            int cur = sum[i];\n            if (i - 1 >= 0) {\n                cur -= sum[i-1];\n            }\n            if (cur == i + 1) {\n                res = Math.max(res, cur - 1);\n            } else {\n                res = Math.max(res, cur);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1265", "path": "output2\\java\\Medium\\1265-check-if-array-pairs-are-divisible-by-k.java", "hypo_code": "class Solution {\n    public boolean canArrange(int[] arr, int k) {\n        int n = arr.length;\n        int[] bucket = new int[k];\n        for (int i = 0; i < n; i++) {\n            bucket[(arr[i] % k + k) % k]++;\n        }\n        for (int i = 1; i <= k / 2; i++) {\n            if (bucket[i] != bucket[k - i]) {\n                return false;\n            }\n        }\n        return bucket[0] % 2 == 0;\n    }\n}"}
{"id": "1266", "path": "output2\\java\\Medium\\1266-number-of-subsequences-that-satisfy-the-given-sum-condition.java", "hypo_code": "class Solution {\n    public int numSubseq(int[] nums, int target) {\n        int mod = (int)1e9 + 7;\n        int n = nums.length;\n        Arrays.sort(nums);\n        int[] pows = new int[n];\n        pows[0] = 1;\n        for (int i = 1; i < n; i++) {\n            pows[i] = (pows[i-1] << 1) % mod;\n        }\n        int res = 0;\n        int l = 0, r = n - 1;\n        while (l <= r) {\n            if (nums[l] + nums[r] > target) {\n                r--;\n            } else {\n                res = (res + pows[r - l]) % mod;\n                l++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1267", "path": "output2\\java\\Medium\\1267-last-moment-before-all-ants-fall-out-of-a-plank.java", "hypo_code": "class Solution {\n    public int getLastMoment(int n, int[] left, int[] right) {\n        int res = 0;\n        for (int i = 0; i < left.length; i++) {\n            res = Math.max(res, left[i]);\n        }\n        for (int i = 0; i < right.length; i++) {\n            res = Math.max(res, n - right[i]);\n        }\n        return res;\n    }\n}"}
{"id": "1268", "path": "output2\\java\\Medium\\1268-count-submatrices-with-all-ones.java", "hypo_code": "class Solution {\n    public int numSubmat(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[][] dp = new int[m][n];\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = 0;\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 0) {\n                    cur = 0;\n                } else {\n                    cur++;\n                }\n                dp[i][j] = cur;\n                int min = cur;\n                for (int k = i; k >= 0; k--) {\n                    min = Math.min(min, dp[k][j]);\n                    res += min;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1269", "path": "output2\\java\\Medium\\1269-range-sum-of-sorted-subarray-sums.java", "hypo_code": "class Solution {\n    public int rangeSum(int[] nums, int n, int left, int right) {\n        int mod = (int)1e9 + 7;\n        int[] arr = new int[n * (n + 1) / 2];\n        int idx = 0;\n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                sum += nums[j];\n                arr[idx++] = sum;\n            }\n        }\n        Arrays.sort(arr);\n        int res = 0;\n        for (int i = left - 1; i < right; i++) {\n            res = (res + arr[i]) % mod;\n        }\n        return res;\n    }\n}"}
{"id": "1270", "path": "output2\\java\\Medium\\1270-minimum-difference-between-largest-and-smallest-value-in-three-moves.java", "hypo_code": "class Solution {\n    public int minDifference(int[] nums) {\n        int n = nums.length;\n        if (n < 4) {\n            return 0;\n        }\n        Arrays.sort(nums);\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i <= 3; i++) {\n            res = Math.min(res, nums[n - 4 + i] - nums[i]);\n        }\n        return res;\n    }\n}"}
{"id": "1271", "path": "output2\\java\\Medium\\1271-number-of-substrings-with-only-1s.java", "hypo_code": "class Solution {\n    public int numSub(String s) {\n        int mod = (int)1e9 + 7;\n        int n = s.length();\n        long res = 0;\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                count++;\n            } else {\n                res += count * (count + 1) / 2;\n                count = 0;\n            }\n        }\n        if (count > 0) {\n            res += count * (count + 1) / 2;\n        }\n        return (int)(res % mod);\n    }\n}"}
{"id": "1272", "path": "output2\\java\\Medium\\1272-path-with-maximum-probability.java", "hypo_code": "class Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {\n        int m = edges.length;\n        double[] dis = new double[n];\n        for (int i = 0; i < n; i++) {\n            dis[i] = -1;\n        }\n        dis[start_node] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m;  j++) {\n                int a = edges[j][0];\n                int b = edges[j][1];\n                double p = succProb[j];\n                if (dis[a] != -1 && dis[b] < dis[a] * p) {\n                    dis[b] = dis[a] * p;\n                }\n                if (dis[b] != -1 && dis[a] < dis[b] * p) {\n                    dis[a] = dis[b] * p;\n                }\n            }\n        }\n        return dis[end_node] == -1 ? 0 : dis[end_node];\n    }\n}"}
{"id": "1273", "path": "output2\\java\\Medium\\1273-number-of-nodes-in-the-sub-tree-with-the-same-label.java", "hypo_code": "class Solution {\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\n        int m = edges.length;\n        int[] res = new int[n];\n        int[][] graph = new int[n][n];\n        for (int i = 0; i < m; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            graph[a][b] = 1;\n            graph[b][a] = 1;\n        }\n        for (int i = 0; i < n; i++) {\n            int[] arr = new int[n];\n            int[] sum = new int[n];\n            for (int j = 0; j < n; j++) {\n                if (labels.charAt(j) == labels.charAt(i)) {\n                    arr[j] = 1;\n                }\n            }\n            sum[0] = arr[0];\n            for (int j = 1; j < n; j++) {\n                sum[j] = sum[j-1] + arr[j];\n            }\n            for (int j = 0; j < n; j++) {\n                int cur = sum[j];\n                if (j - 1 >= 0) {\n                    cur -= sum[j-1];\n                }\n                res[i] = cur;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1274", "path": "output2\\java\\Medium\\1274-number-of-sub-arrays-with-odd-sum.java", "hypo_code": "class NumberOfSubArraysWithOddSum {\n    public int numOfSubarrays(int[] arr) {\n        int odd = 0;\n        int even = 0;\n        int sum = 0;\n        int mod = 1000000007;\n        for(int i = 0; i < arr.length; i++){\n            sum += arr[i];\n            if(sum % 2 == 0){\n                even++;\n            }else{\n                odd++;\n            }\n        }\n        return (odd + even) % mod;\n        \n        \n    }\n}"}
{"id": "1275", "path": "output2\\java\\Medium\\1275-number-of-good-ways-to-split-a-string.java", "hypo_code": "class NumberOfGoodWaysToSplitAString {\n    public int numSplits(String s) {\n        int[] left = new int[26];\n        int[] right = new int[26];\n        int leftCount = 0;\n        int rightCount = 0;\n        for(char c : s.toCharArray()){\n            if(right[c - 'a'] == 0){\n                rightCount++;\n            }\n            right[c - 'a']++;\n        }\n        int count = 0;\n        for(char c : s.toCharArray()){\n            if(left[c - 'a'] == 0){\n                leftCount++;\n            }\n            left[c - 'a']++;\n            right[c - 'a']--;\n            if(right[c - 'a'] == 0){\n                rightCount--;\n            }\n            if(leftCount == rightCount){\n                count++;\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1276", "path": "output2\\java\\Medium\\1276-minimum-suffix-flips.java", "hypo_code": "class MinimumSuffixFlips {\n    public int minFlips(String target) {\n        int count = 0;\n        char prev = '0';\n        for(char c : target.toCharArray()){\n            if(c != prev){\n                count++;\n                prev = c;\n            }\n        }\n        return count;\n        \n        \n    }\n}"}
{"id": "1277", "path": "output2\\java\\Medium\\1277-number-of-good-leaf-nodes-pairs.java", "hypo_code": "class NumberOfGoodLeafNodesPairs {\n    public int countPairs(TreeNode root, int distance) {\n        int[] count = new int[1];\n        dfs(root, distance, count);\n        return count[0];\n        \n    }\n}"}
{"id": "1278", "path": "output2\\java\\Medium\\1278-find-the-winner-of-an-array-game.java", "hypo_code": "class Solution {\n    public int getWinner(int[] arr, int k) {\n        int max = arr[0];\n        int count = 0;\n        for(int i = 1; i < arr.length; i++){\n            if(arr[i] > max){\n                max = arr[i];\n                count = 1;\n            }else{\n                count++;\n            }\n            if(count == k){\n                return max;\n            }\n        }\n        return max;\n    }\n}"}
{"id": "1279", "path": "output2\\java\\Medium\\1279-minimum-swaps-to-arrange-a-binary-grid.java", "hypo_code": "class Solution {\n    public int minSwaps(int[][] grid) {\n        int[] arr = new int[grid.length];\n        for(int i = 0; i < grid.length; i++){\n            int count = 0;\n            for(int j = grid.length - 1; j >= 0; j--){\n                if(grid[i][j] == 0){\n                    count++;\n                }else{\n                    break;\n                }\n            }\n            arr[i] = count;\n        }\n        int res = 0;\n        for(int i = 0; i < arr.length; i++){\n            if(arr[i] < grid.length - 1 - i){\n                int j = i + 1;\n                while(j < arr.length){\n                    if(arr[j] >= grid.length - 1 - i){\n                        break;\n                    }\n                    j++;\n                }\n                if(j == arr.length){\n                    return -1;\n                }\n                while(j > i){\n                    int tmp = arr[j];\n                    arr[j] = arr[j - 1];\n                    arr[j - 1] = tmp;\n                    res++;\n                    j--;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1280", "path": "output2\\java\\Medium\\1280-can-convert-string-in-k-moves.java", "hypo_code": "class Solution {\n    public boolean canConvertString(String s, String t, int k) {\n        if(s.length() != t.length()){\n            return false;\n        }\n        int[] arr = new int[26];\n        for(int i = 0; i < s.length(); i++){\n            int diff = t.charAt(i) - s.charAt(i);\n            if(diff < 0){\n                diff += 26;\n            }\n            if(diff != 0){\n                if(diff > k){\n                    return false;\n                }\n                if(arr[diff] > 0){\n                    arr[diff] += 26;\n                    if(arr[diff] > k){\n                        return false;\n                    }\n                }else{\n                    arr[diff] = diff;\n                }\n            }\n        }\n        return true;\n    }\n}"}
{"id": "1281", "path": "output2\\java\\Medium\\1281-minimum-insertions-to-balance-a-parentheses-string.java", "hypo_code": "class Solution {\n    public int minInsertions(String s) {\n        int res = 0;\n        int left = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == '('){\n                left++;\n            }else{\n                if(i == s.length() - 1 || s.charAt(i + 1) != ')'){\n                    res++;\n                }else{\n                    i++;\n                }\n                if(left > 0){\n                    left--;\n                }else{\n                    res++;\n                }\n            }\n        }\n        res += left * 2;\n        return res;\n    }\n}"}
{"id": "1282", "path": "output2\\java\\Medium\\1282-find-kth-bit-in-nth-binary-string.java", "hypo_code": "class Solution {\n    public char findKthBit(int n, int k) {\n        StringBuilder sb = new StringBuilder(\"0\");\n        for(int i = 1; i < n; i++){\n            sb.append(\"1\");\n            for(int j = sb.length() - 2; j >= 0; j--){\n                if(sb.charAt(j) == '0'){\n                    sb.append(\"1\");\n                }else{\n                    sb.append(\"0\");\n                }\n            }\n        }\n        return sb.charAt(k - 1);\n    }\n}"}
{"id": "1283", "path": "output2\\java\\Medium\\1283-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target.java", "hypo_code": "class Solution {\n    public int maxNonOverlapping(int[] nums, int target) {\n        int res = 0;\n        int sum = 0;\n        Set<Integer> set = new HashSet<>();\n        set.add(0);\n        for(int i = 0; i < nums.length; i++){\n            sum += nums[i];\n            if(set.contains(sum - target)){\n                res++;\n                set.clear();\n                set.add(0);\n                sum = 0;\n            }else{\n                set.add(sum);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1284", "path": "output2\\java\\Medium\\1284-minimum-operations-to-make-array-equal.java", "hypo_code": "class Solution {\n    public int minOperations(int n) {\n        int res = 0;\n        for(int i = 0; i < n / 2; i++){\n            res += n - (2 * i + 1);\n        }\n        return res;\n    }\n}"}
{"id": "1285", "path": "output2\\java\\Medium\\1285-magnetic-force-between-two-balls.java", "hypo_code": "class Solution {\n    public int maxDistance(int[] position, int m) {\n        Arrays.sort(position);\n        int l = 1;\n        int r = position[position.length - 1] - position[0];\n        while(l < r){\n            int mid = l + (r - l + 1) / 2;\n            if(check(position, m, mid)){\n                l = mid;\n            }else{\n                r = mid - 1;\n            }\n        }\n        return l;\n    }\n    private boolean check(int[] position, int m, int mid){\n        int count = 1;\n        int left = 0;\n        for(int i = 1; i < position.length; i++){\n            if(position[i] - position[left] >= mid){\n                count++;\n                left = i;\n            }\n        }\n        return count >= m;\n    }\n}"}
{"id": "1286", "path": "output2\\java\\Medium\\1286-minimum-number-of-vertices-to-reach-all-nodes.java", "hypo_code": "class MinimumNumberOfVerticesToReachAllNodes {\n    public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {\n        List<Integer> result = new ArrayList<>();\n        int[] inDegree = new int[n];\n        for(List<Integer> edge : edges){\n            inDegree[edge.get(1)]++;\n        }\n        for(int i = 0; i < n; i++){\n            if(inDegree[i] == 0){\n                result.add(i);\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1287", "path": "output2\\java\\Medium\\1287-minimum-numbers-of-function-calls-to-make-target-array.java", "hypo_code": "class Solution {\n    public int minOperations(int[] nums) {\n        int res = 0;\n        int max = 0;\n        for(int i = 0; i < nums.length; i++){\n            int count = 0;\n            while(nums[i] != 0){\n                if(nums[i] % 2 == 0){\n                    nums[i] /= 2;\n                    count++;\n                }else{\n                    nums[i]--;\n                    res++;\n                }\n            }\n            max = Math.max(max, count);\n        }\n        res += max;\n        return res;\n    }\n}"}
{"id": "1288", "path": "output2\\java\\Medium\\1288-detect-cycles-in-2d-grid.java", "hypo_code": "class DetectCyclesIn2DGrid {\n    public boolean containsCycle(char[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(!visited[i][j]){\n                    if(dfs(grid, i, j, -1, -1, visited)){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n        \n        \n    }\n}"}
{"id": "1289", "path": "output2\\java\\Medium\\1289-maximum-number-of-coins-you-can-get.java", "hypo_code": "class MaximumNumberOfCoinsYouCanGet {\n    public int maxCoins(int[] piles) {\n        Arrays.sort(piles);\n        int sum = 0;\n        int i = piles.length - 2;\n        while(i >= piles.length / 3){\n            sum += piles[i];\n            i -= 2;\n        }\n        return sum;\n        \n    }\n}"}
{"id": "1290", "path": "output2\\java\\Medium\\1290-find-latest-group-of-size-m.java", "hypo_code": "class FindLatestGroupOfSizeM {\n    public int findLatestStep(int[] arr, int m) {\n        int n = arr.length;\n        int[] dp = new int[n + 2];\n        int[] count = new int[n + 1];\n        int res = -1;\n        for(int i = 0; i < n; i++){\n            int index = arr[i];\n            int left = dp[index - 1];\n            int right = dp[index + 1];\n            dp[index - left] = dp[index + right] = left + right + 1;\n            count[left]--;\n            count[right]--;\n            count[left + right + 1]++;\n            if(count[m] > 0){\n                res = i + 1;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1291", "path": "output2\\java\\Medium\\1291-maximum-length-of-subarray-with-positive-product.java", "hypo_code": "class Solution {\n    public int getMaxLen(int[] nums) {\n        int res = 0;\n        int start = 0;\n        int firstNeg = 0;\n        int negCount = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == 0){\n                start = i + 1;\n                firstNeg = 0;\n                negCount = 0;\n            }else{\n                if(nums[i] < 0){\n                    if(firstNeg == 0){\n                        firstNeg = i + 1;\n                    }\n                    negCount++;\n                }\n                if(negCount % 2 == 0){\n                    res = Math.max(res, i - start + 1);\n                }else{\n                    res = Math.max(res, i - firstNeg + 1);\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1292", "path": "output2\\java\\Medium\\1292-number-of-ways-to-split-a-string.java", "hypo_code": "class NumberOfWaysToSplitAString {\n    public int numWays(String s) {\n        int mod = 1000000007;\n        int count = 0;\n        for(char c : s.toCharArray()){\n            if(c == '1'){\n                count++;\n            }\n        }\n        if(count % 3 != 0){\n            return 0;\n        }\n        if(count == 0){\n            return (int)(((long)(s.length() - 1) * (long)(s.length() - 2) / 2) % mod);\n        }\n        int target = count / 3;\n        int[] left = new int[s.length()];\n        int[] right = new int[s.length()];\n        int leftCount = 0;\n        int rightCount = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == '1'){\n                leftCount++;\n            }\n            left[i] = leftCount;\n        }\n        for(int i = s.length() - 1; i >= 0; i--){\n            if(s.charAt(i) == '1'){\n                rightCount++;\n            }\n            right[i] = rightCount;\n        }\n        int leftIndex = 0;\n        int rightIndex = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(left[i] == target){\n                leftIndex = i;\n                break;\n            }\n        }\n        for(int i = s.length() - 1; i >= 0; i--){\n            if(right[i] == target){\n                rightIndex = i;\n                break;\n            }\n        }\n        int leftCount2 = 0;\n        int rightCount2 = 0;\n        for(int i = leftIndex + 1; i < s.length(); i++){\n            if(s.charAt(i) == '1'){\n                leftCount2++;\n            }\n            if(leftCount2 == target){\n                leftIndex = i;\n                break;\n            }\n        }\n        for(int i = rightIndex - 1; i >= 0; i--){\n            if(s.charAt(i) == '1'){\n                rightCount2++;\n            }\n            if(rightCount2 == target){\n                rightIndex = i;\n                break;\n            }\n        }\n        return (int)(((long)(leftIndex - leftCount + 1) * (long)(s.length() - rightIndex)) % mod);\n        \n    }\n}"}
{"id": "1293", "path": "output2\\java\\Medium\\1293-shortest-subarray-to-be-removed-to-make-array-sorted.java", "hypo_code": "class ShortestSubarrayToBeRemovedToMakeArraySorted {\n    public int findLengthOfShortestSubarray(int[] arr) {\n        int n = arr.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            if(i == 0 || arr[i] >= arr[i - 1]){\n                count++;\n            }else{\n                count = 1;\n            }\n            left[i] = count;\n        }\n        count = 0;\n        for(int i = n - 1; i >= 0; i--){\n            if(i == n - 1 || arr[i] <= arr[i + 1]){\n                count++;\n            }else{\n                count = 1;\n            }\n            right[i] = count;\n        }\n        int res = n - 1;\n        for(int i = 0; i < n - 1; i++){\n            if(arr[i] <= arr[i + 1]){\n                res = Math.min(res, n - left[i] - 1);\n            }\n            if(i > 0 && arr[i - 1] <= arr[i + 1]){\n                res = Math.min(res, n - left[i - 1] - right[i + 1]);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1294", "path": "output2\\java\\Medium\\1294-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers.java", "hypo_code": "class NumberOfWaysWhereSquareOfNumberIsEqualToProductOfTwoNumbers {\n    public int numTriplets(int[] nums1, int[] nums2) {\n        int count = 0;\n        for(int i = 0; i < nums1.length; i++){\n            for(int j = i + 1; j < nums1.length; j++){\n                long product = (long)nums1[i] * nums1[j];\n                for(int k = 0; k < nums2.length; k++){\n                    if(product == (long)nums2[k] * nums2[k]){\n                        count++;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < nums2.length; i++){\n            for(int j = i + 1; j < nums2.length; j++){\n                long product = (long)nums2[i] * nums2[j];\n                for(int k = 0; k < nums1.length; k++){\n                    if(product == (long)nums1[k] * nums1[k]){\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1295", "path": "output2\\java\\Medium\\1295-minimum-time-to-make-rope-colorful.java", "hypo_code": "class MinimumTimeToMakeRopeColorful {\n    public int minCost(String colors, int[] neededTime) {\n        int n = colors.length();\n        int[][] dp = new int[n][3];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        for(int i = 0; i < 3; i++){\n            if(colors.charAt(0) == '?' || colors.charAt(0) == (char)('a' + i)){\n                dp[0][i] = neededTime[0];\n            }\n        }\n        for(int i = 1; i < n; i++){\n            for(int j = 0; j < 3; j++){\n                if(colors.charAt(i) == '?' || colors.charAt(i) == (char)('a' + j)){\n                    for(int k = 0; k < 3; k++){\n                        if(j != k){\n                            dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + neededTime[i]);\n                        }\n                    }\n                }\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for(int i = 0; i < 3; i++){\n            ans = Math.min(ans, dp[n - 1][i]);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1296", "path": "output2\\java\\Medium\\1296-count-unhappy-friends.java", "hypo_code": "class Solution {\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\n        int res = 0;\n        int[] pair = new int[n];\n        for(int[] p : pairs){\n            pair[p[0]] = p[1];\n            pair[p[1]] = p[0];\n        }\n        for(int i = 0; i < n; i++){\n            int[] p = preferences[i];\n            for(int j = 0; j < p.length; j++){\n                if(p[j] == pair[i]){\n                    break;\n                }\n                int[] p2 = preferences[p[j]];\n                for(int k = 0; k < p2.length; k++){\n                    if(p2[k] == pair[p[j]]){\n                        break;\n                    }\n                    if(p2[k] == i){\n                        res++;\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1297", "path": "output2\\java\\Medium\\1297-min-cost-to-connect-all-points.java", "hypo_code": "class Solution {\n    public int minCostConnectPoints(int[][] points) {\n        int res = 0, n = points.length;\n        int[] dist = new int[n];\n        boolean[] visited = new boolean[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n        for(int i = 0; i < n; i++){\n            int cur = -1;\n            for(int j = 0; j < n; j++){\n                if(!visited[j] && (cur == -1 || dist[j] < dist[cur])){\n                    cur = j;\n                }\n            }\n            res += dist[cur];\n            visited[cur] = true;\n            for(int j = 0; j < n; j++){\n                if(!visited[j]){\n                    dist[j] = Math.min(dist[j], Math.abs(points[cur][0] - points[j][0]) + Math.abs(points[cur][1] - points[j][1]));\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1298", "path": "output2\\java\\Medium\\1298-maximum-sum-obtained-of-any-permutation.java", "hypo_code": "class Solution {\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\n        int res = 0;\n        int[] count = new int[nums.length];\n        for(int[] request : requests){\n            count[request[0]]++;\n            if(request[1] + 1 < nums.length){\n                count[request[1] + 1]--;\n            }\n        }\n        for(int i = 1; i < nums.length; i++){\n            count[i] += count[i - 1];\n        }\n        Arrays.sort(nums);\n        Arrays.sort(count);\n        for(int i = 0; i < nums.length; i++){\n            res += nums[i] * count[i];\n            res %= 1000000007;\n        }\n        return res;\n    }\n}"}
{"id": "1299", "path": "output2\\java\\Medium\\1299-make-sum-divisible-by-p.java", "hypo_code": "class Solution {\n    public int minSubarray(int[] nums, int p) {\n        int res = nums.length;\n        int sum = 0;\n        int target = 0;\n        for(int num : nums){\n            sum += num;\n        }\n        target = sum % p;\n        if(target == 0){\n            return 0;\n        }\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            sum += nums[i];\n            int mod = sum % p;\n            map.put(mod, i);\n            int diff = (mod - target + p) % p;\n            if(map.containsKey(diff)){\n                res = Math.min(res, i - map.get(diff));\n            }\n        }\n        return res == nums.length ? -1 : res;\n    }\n}"}
{"id": "1300", "path": "output2\\java\\Medium\\1300-split-a-string-into-the-max-number-of-unique-substrings.java", "hypo_code": "class Solution {\n    public int maxUniqueSplit(String s) {\n        return dfs(s, new HashSet<String>());\n    }\n    private int dfs(String s, Set<String> set){\n        int res = 0;\n        for(int i = 1; i <= s.length(); i++){\n            String sub = s.substring(0, i);\n            if(set.contains(sub)){\n                continue;\n            }\n            set.add(sub);\n            res = Math.max(res, 1 + dfs(s.substring(i), set));\n            set.remove(sub);\n        }\n        return res;\n    }\n}"}
{"id": "1301", "path": "output2\\java\\Medium\\1301-maximum-non-negative-product-in-a-matrix.java", "hypo_code": "class Solution {\n    public int maxProductPath(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        long[][] max = new long[m][n];\n        long[][] min = new long[m][n];\n        max[0][0] = grid[0][0];\n        min[0][0] = grid[0][0];\n        for(int i = 1; i < m; i++){\n            max[i][0] = max[i - 1][0] * grid[i][0];\n            min[i][0] = min[i - 1][0] * grid[i][0];\n        }\n        for(int i = 1; i < n; i++){\n            max[0][i] = max[0][i - 1] * grid[0][i];\n            min[0][i] = min[0][i - 1] * grid[0][i];\n        }\n        for(int i = 1; i < m; i++){\n            for(int j = 1; j < n; j++){\n                if(grid[i][j] < 0){\n                    max[i][j] = Math.min(min[i - 1][j], min[i][j - 1]) * grid[i][j];\n                    min[i][j] = Math.max(max[i - 1][j], max[i][j - 1]) * grid[i][j];\n                }else{\n                    max[i][j] = Math.max(max[i - 1][j], max[i][j - 1]) * grid[i][j];\n                    min[i][j] = Math.min(min[i - 1][j], min[i][j - 1]) * grid[i][j];\n                }\n            }\n        }\n        long res = max[m - 1][n - 1] % 1000000007;\n        return res < 0 ? -1 : (int)res;\n    }\n}"}
{"id": "1302", "path": "output2\\java\\Medium\\1302-maximum-profit-of-operating-a-centennial-wheel.java", "hypo_code": "class Solution {\n    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {\n        int res = 0;\n        int max = 0;\n        int count = 0;\n        int profit = 0;\n        int i = 0;\n        while(i < customers.length || count > 0){\n            if(i < customers.length){\n                count += customers[i];\n            }\n            if(count >= 4){\n                profit += 4 * boardingCost - runningCost;\n                count -= 4;\n            }else{\n                profit += count * boardingCost - runningCost;\n                count = 0;\n            }\n            if(profit > max){\n                max = profit;\n                res = i + 1;\n            }\n            i++;\n        }\n        return max > 0 ? res : -1;\n    }\n}"}
{"id": "1304", "path": "output2\\java\\Medium\\1304-alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.java", "hypo_code": "class Solution {\n    public List<String> alertNames(String[] keyName, String[] keyTime) {\n        List<String> res = new ArrayList<>();\n        Map<String, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < keyName.length; i++){\n            if(!map.containsKey(keyName[i])){\n                map.put(keyName[i], new ArrayList<>());\n            }\n            map.get(keyName[i]).add(Integer.parseInt(keyTime[i].substring(0, 2)) * 60 + Integer.parseInt(keyTime[i].substring(3)));\n        }\n        for(String name : map.keySet()){\n            Collections.sort(map.get(name));\n            for(int i = 2; i < map.get(name).size(); i++){\n                if(map.get(name).get(i) - map.get(name).get(i - 2) <= 60){\n                    res.add(name);\n                    break;\n                }\n            }\n        }\n        Collections.sort(res);\n        return res;\n    }\n}"}
{"id": "1305", "path": "output2\\java\\Medium\\1305-find-valid-matrix-given-row-and-column-sums.java", "hypo_code": "class Solution {\n    public int[][] restoreMatrix(int[] rowSum, int[] colSum) {\n        int m = rowSum.length;\n        int n = colSum.length;\n        int[][] res = new int[m][n];\n        for(int i = 0; i < m; i++){\n            int min = rowSum[i];\n            for(int j = 0; j < n; j++){\n                min = Math.min(min, colSum[j]);\n            }\n            for(int j = 0; j < n; j++){\n                res[i][j] = Math.min(min, rowSum[i]);\n                rowSum[i] -= res[i][j];\n                colSum[j] -= res[i][j];\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1306", "path": "output2\\java\\Medium\\1306-even-odd-tree.java", "hypo_code": "class Solution {\n    public boolean isEvenOddTree(TreeNode root) {\n        Queue<TreeNode> q = new LinkedList<>();\n\t\tq.offer(root);\n\t\tint level = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint size = q.size();\n\t\t\tint prev = level % 2 == 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode node = q.poll();\n\t\t\t\tif(level % 2 == 0){\n\t\t\t\t\tif(node.val % 2 == 0 || node.val <= prev){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(node.val % 2 == 1 || node.val >= prev){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprev = node.val;\n\t\t\t\tif(node.left != null){\n\t\t\t\t\tq.offer(node.left);\n\t\t\t\t}\n\t\t\t\tif(node.right != null){\n\t\t\t\t\tq.offer(node.right);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevel++;\n\t\t}\n\t\treturn true;\n    }\n}"}
{"id": "1307", "path": "output2\\java\\Medium\\1307-maximal-network-rank.java", "hypo_code": "class Solution {\n    public int maximalNetworkRank(int n, int[][] roads) {\n        int res = 0;\n        int[] count = new int[n];\n        boolean[][] connected = new boolean[n][n];\n        for(int[] road : roads){\n            count[road[0]]++;\n            count[road[1]]++;\n            connected[road[0]][road[1]] = true;\n            connected[road[1]][road[0]] = true;\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                res = Math.max(res, count[i] + count[j] - (connected[i][j] ? 1 : 0));\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1308", "path": "output2\\java\\Medium\\1308-split-two-strings-to-make-palindrome.java", "hypo_code": "class Solution {\n    public boolean checkPalindromeFormation(String a, String b) {\n        \n    }\n}"}
{"id": "1309", "path": "output2\\java\\Medium\\1309-coordinate-with-maximum-network-quality.java", "hypo_code": "class Solution {\n    public int[] bestCoordinate(int[][] towers, int radius) { \n        int[] best = new int[2];\n        int max = 0;\n        for (int x = 0; x <= 50; x++) {\n            for (int y = 0; y <= 50; y++) {\n                int quality = 0;\n                for (int[] tower : towers) {\n                    double distance = Math.sqrt(Math.pow(tower[0] - x, 2) + Math.pow(tower[1] - y, 2));\n                    if (distance <= radius) {\n                        quality += Math.floor(tower[2] / (1 + distance));\n                    }\n                }\n                if (quality > max) {\n                    max = quality;\n                    best[0] = x;\n                    best[1] = y;\n                }\n            }\n        }\n        return best;\n    }\n}"}
{"id": "1310", "path": "output2\\java\\Medium\\1310-number-of-sets-of-k-non-overlapping-line-segments.java", "hypo_code": "class Solution {\n    public int numberOfSets(int n, int k) { \n        int[][] dp = new int[n][k + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 1;\n        }\n        for (int j = 1; j <= k; j++) {\n            dp[0][j] = 0;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j <= k && j <= i; j++) {\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] + i - j) % 1000000007;\n            }\n        }\n        return dp[n - 1][k];\n    }\n}"}
{"id": "1311", "path": "output2\\java\\Medium\\1311-lexicographically-smallest-string-after-applying-operations.java", "hypo_code": "class Solution {\n    public String findLexSmallestString(String s, int a, int b) {\n        Set<String> seen = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(s);\n        seen.add(s);\n        String res = s;\n        while (!queue.isEmpty()) {\n            s = queue.poll();\n            if (s.compareTo(res) < 0) {\n                res = s;\n            }\n            char[] chars = s.toCharArray();\n            for (int i = 1; i < chars.length; i += 2) {\n                chars[i] = (char) ((chars[i] - '0' + a) % 10 + '0');\n            }\n            String add = String.valueOf(chars);\n            if (!seen.contains(add)) {\n                queue.offer(add);\n                seen.add(add);\n            }\n            String rotate = s.substring(s.length() - b) + s.substring(0, s.length() - b);\n            if (!seen.contains(rotate)) {\n                queue.offer(rotate);\n                seen.add(rotate);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1312", "path": "output2\\java\\Medium\\1312-best-team-with-no-conflicts.java", "hypo_code": "class Solution {\n    public int bestTeamScore(int[] scores, int[] ages) {\n        int n = scores.length;\n        int[][] pairs = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            pairs[i][0] = ages[i];\n            pairs[i][1] = scores[i];\n        }\n        Arrays.sort(pairs, (a, b) -> (a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]));\n        int[] dp = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int score = pairs[i][1];\n            dp[i] = score;\n            for (int j = 0; j < i; j++) {\n                if (pairs[j][1] <= pairs[i][1]) {\n                    dp[i] = Math.max(dp[i], dp[j] + score);\n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n    }\n}"}
{"id": "1313", "path": "output2\\java\\Medium\\1313-arithmetic-subarrays.java", "hypo_code": "class Solution {\n    public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {\n        int m = l.length;\n        List<Boolean> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int left = l[i];\n            int right = r[i];\n            int[] sub = Arrays.copyOfRange(nums, left, right + 1);\n            Arrays.sort(sub);\n            res.add(isArithmetic(sub));\n        }\n        return res;\n    }\n    private boolean isArithmetic(int[] nums) {\n        int n = nums.length;\n        if (n <= 2) {\n            return true;\n        }\n        int diff = nums[1] - nums[0];\n        for (int i = 2; i < n; i++) {\n            if (nums[i] - nums[i - 1] != diff) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "1314", "path": "output2\\java\\Medium\\1314-path-with-minimum-effort.java", "hypo_code": "class Solution {\n    public int minimumEffortPath(int[][] heights) {\n        int m = heights.length;\n        int n = heights[0].length;\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));\n        int[][] dist = new int[m][n];\n        for (int[] d : dist) {\n            Arrays.fill(d, Integer.MAX_VALUE);\n        }\n        dist[0][0] = 0;\n        pq.offer(new int[]{0, 0, 0});\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int x = cur[0];\n            int y = cur[1];\n            int effort = cur[2];\n            if (x == m - 1 && y == n - 1) {\n                return effort;\n            }\n            for (int[] dir : directions) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n) {\n                    continue;\n                }\n                int newEffort = Math.max(effort, Math.abs(heights[nx][ny] - heights[x][y]));\n                if (newEffort < dist[nx][ny]) {\n                    dist[nx][ny] = newEffort;\n                    pq.offer(new int[]{nx, ny, newEffort});\n                }\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "1315", "path": "output2\\java\\Medium\\1315-widest-vertical-area-between-two-points-containing-no-points.java", "hypo_code": "class Solution {\n    public int maxWidthOfVerticalArea(int[][] points) {\n        int n = points.length;\n        int[] x = new int[n];\n        for (int i = 0; i < n; i++) {\n            x[i] = points[i][0];\n        }\n        Arrays.sort(x);\n        int res = 0;\n        for (int i = 1; i < n; i++) {\n            res = Math.max(res, x[i] - x[i - 1]);\n        }\n        return res;\n    }\n}"}
{"id": "1316", "path": "output2\\java\\Medium\\1316-count-substrings-that-differ-by-one-character.java", "hypo_code": "class Solution {\n    public int countSubstrings(String s, String t) {\n        int res = 0;\n        int m = s.length();\n        int n = t.length();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n ; j++) {\n                int diff = 0;\n                int k = 0;\n                while (i + k < m && j + k < n && diff <= 1) {\n                    if (s.charAt(i + k) != t.charAt(j + k)) {\n                        diff++;\n                    }\n                    if (diff == 1) {\n                        res++;\n                    }\n                    k++;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1317", "path": "output2\\java\\Medium\\1317-count-sorted-vowel-strings.java", "hypo_code": "class Solution {\n    public int countVowelStrings(int n) {\n        int[] dp = new int[5];\n        Arrays.fill(dp, 1);\n        for (int i = 2; i <= n; i++) {\n            int[] next = new int[5];\n            for (int j = 0; j < 5; j++) {\n                for (int k = j; k < 5; k++) {\n                    next[j] += dp[k];\n                }\n            }\n            dp = next;\n        }\n        int res = 0;\n        for (int i : dp) {\n            res += i;\n        }\n        return res;\n    }\n}"}
{"id": "1318", "path": "output2\\java\\Medium\\1318-furthest-building-you-can-reach.java", "hypo_code": "class Solution {\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\n        int n = heights.length;\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int i = 0; i < n - 1; i++) {\n            int diff = heights[i + 1] - heights[i];\n            if (diff > 0) {\n                pq.offer(diff);\n            }\n            if (pq.size() > ladders) {\n                bricks -= pq.poll();\n            }\n            if (bricks < 0) {\n                return i;\n            }\n        }\n        return n - 1;\n    }\n}"}
{"id": "1319", "path": "output2\\java\\Medium\\1319-minimum-deletions-to-make-character-frequencies-unique.java", "hypo_code": "class Solution {\n    public int minDeletions(String s) {\n        int[] freq = new int[26];\n        for (char c : s.toCharArray()) {\n            freq[c - 'a']++;\n        }\n        Set<Integer> set = new HashSet<>();\n        int res = 0;\n        for (int i = 0; i < 26; i++) {\n            while (!set.add(freq[i]) && freq[i] != 0) {\n                freq[i]--;\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1320", "path": "output2\\java\\Medium\\1320-sell-diminishing-valued-colored-balls.java", "hypo_code": "class Solution {\n    public int maxProfit(int[] inventory, int orders) {\n        int n = inventory.length;\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n        for (int i : inventory) {\n            pq.offer(i);\n        }\n        long res = 0;\n        while (orders > 0) {\n            int cur = pq.poll();\n            int next = pq.peek();\n            int diff = cur - next;\n            int times = Math.min(diff, orders);\n            res += (long)(cur + cur - times + 1) * times / 2;\n            orders -= times;\n            if (cur - times > 0) {\n                pq.offer(cur - times);\n            }\n        }\n        return (int)(res % 1000000007);\n    }\n}"}
{"id": "1321", "path": "output2\\java\\Medium\\1321-minimum-deletions-to-make-string-balanced.java", "hypo_code": "class Solution {\n    public int minimumDeletions(String s) {\n        int n = s.length();\n        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            a[i + 1] = a[i] + (s.charAt(i) == 'a' ? 1 : 0);\n            b[i + 1] = b[i] + (s.charAt(i) == 'b' ? 1 : 0);\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i <= n; i++) {\n            res = Math.min(res, a[i] + b[n] - b[i]);\n        }\n        return res;\n    }\n}"}
{"id": "1322", "path": "output2\\java\\Medium\\1322-minimum-jumps-to-reach-home.java", "hypo_code": "class Solution {\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : forbidden) {\n            set.add(num);\n        }\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0});\n        int res = 0;\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int pos = cur[0];\n            int d = cur[1];\n            if (pos == x) {\n                return res;\n            }\n            if (pos + a <= 6000 && !set.contains(pos + a) && d != 1) {\n                set.add(pos + a);\n                queue.offer(new int[]{pos + a, 0});\n            }\n            if (pos - b >= 0 && !set.contains(pos - b)) {\n                queue.offer(new int[]{pos - b, 1});\n            }\n            res++;\n        }\n        return -1;\n    }\n}"}
{"id": "1323", "path": "output2\\java\\Medium\\1323-determine-if-two-strings-are-close.java", "hypo_code": "class Solution {\n    public boolean closeStrings(String word1, String word2) {\n        int m = word1.length();\n        int n = word2.length();\n        if (m != n) {\n            return false;\n        }\n        int[] freq1 = new int[26];\n        int[] freq2 = new int[26];\n        for (char c : word1.toCharArray()) {\n            freq1[c - 'a']++;\n        }\n        for (char c : word2.toCharArray()) {\n            freq2[c - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (freq1[i] == 0 && freq2[i] != 0 || freq1[i] != 0 && freq2[i] == 0) {\n                return false;\n            }\n        }\n        Arrays.sort(freq1);\n        Arrays.sort(freq2);\n        for (int i = 0; i < 26; i++) {\n            if (freq1[i] != freq2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "1324", "path": "output2\\java\\Medium\\1324-minimum-operations-to-reduce-x-to-zero.java", "hypo_code": "class Solution {\n    public int minOperations(int[] nums, int x) {\n        int n = nums.length;\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        int target = sum - x;\n        if (target == 0) {\n            return n;\n        }\n        int left = 0;\n        int right = 0;\n        int cur = 0;\n        int res = -1;\n        while (right < n) {\n            cur += nums[right];\n            while (cur > target && left <= right) {\n                cur -= nums[left++];\n            }\n            if (cur == target) {\n                res = Math.max(res, right - left + 1);\n            }\n            right++;\n        }\n        return res == -1 ? -1 : n - res;\n    }\n}"}
{"id": "1325", "path": "output2\\java\\Medium\\1325-smallest-string-with-a-given-numeric-value.java", "hypo_code": "class Solution {\n    public String getSmallestString(int n, int k) {\n        char[] chars = new char[n];\n        Arrays.fill(chars, 'a');\n        k -= n;\n        int i = n - 1;\n        while (k > 0) {\n            chars[i] += Math.min(k, 25);\n            k -= Math.min(k, 25);\n            i--;\n        }\n        return String.valueOf(chars);\n    }\n}"}
{"id": "1326", "path": "output2\\java\\Medium\\1326-ways-to-make-a-fair-array.java", "hypo_code": "class Solution {\n    public int waysToMakeFair(int[] nums) {\n        int n = nums.length;\n        int[] odd = new int[n + 1];\n        int[] even = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            odd[i + 1] = odd[i] + (i % 2 == 1 ? nums[i] : 0);\n            even[i + 1] = even[i] + (i % 2 == 0 ? nums[i] : 0);\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int curOdd = odd[i] + even[n] - even[i + 1];\n            int curEven = even[i] + odd[n] - odd[i + 1];\n            if (curOdd == curEven) {\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1327", "path": "output2\\java\\Medium\\1327-merge-in-between-linked-lists.java", "hypo_code": "class Solution {\n    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\n        ListNode left = list1;\n\t\tListNode right = list1;\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tright = right.next;\n\t\t}\n\t\tfor (int i = 0; i < a - 1; i++) {\n\t\t\tleft = left.next;\n\t\t\tright = right.next;\n\t\t}\n\t\tleft.next = list2;\n\t\twhile (left.next != null) {\n\t\t\tleft = left.next;\n\t\t}\n\t\tleft.next = right.next;\n\t\treturn list1;\n    }\n}"}
{"id": "1329", "path": "output2\\java\\Medium\\1329-find-the-most-competitive-subsequence.java", "hypo_code": "class FindTheMostCompetitiveSubsequence {\n    public int[] mostCompetitive(int[] nums, int k) {\n        int n = nums.length;\n        int[] res = new int[k];\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            while(count > 0 && res[count - 1] > nums[i] && count + n - i > k){\n                count--;\n            }\n            if(count < k){\n                res[count++] = nums[i];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1330", "path": "output2\\java\\Medium\\1330-minimum-moves-to-make-array-complementary.java", "hypo_code": "class MinimumMovesToMakeArrayComplementary {\n    public int minMoves(int[] nums, int limit) {\n        int n = nums.length;\n        int[] diff = new int[2 * limit + 2];\n        for(int i = 0; i < n / 2; i++){\n            int a = nums[i];\n            int b = nums[n - 1 - i];\n            diff[2] += 2;\n            diff[Math.min(a, b) + 1]--;\n            diff[a + b]--;\n            diff[a + b + 1]++;\n            diff[Math.max(a, b) + limit + 1]++;\n        }\n        int res = n;\n        int curr = 0;\n        for(int i = 2; i <= 2 * limit; i++){\n            curr += diff[i];\n            res = Math.min(res, curr);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1331", "path": "output2\\java\\Medium\\1331-max-number-of-k-sum-pairs.java", "hypo_code": "class Solution {\n    public int maxOperations(int[] nums, int k) {\n        int n = nums.length;\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            int target = k - num;\n            if (map.containsKey(target) && map.get(target) > 0) {\n                res++;\n                map.put(target, map.get(target) - 1);\n            } else {\n                map.put(num, map.getOrDefault(num, 0) + 1);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1332", "path": "output2\\java\\Medium\\1332-concatenation-of-consecutive-binary-numbers.java", "hypo_code": "class Solution {\n    public int concatenatedBinary(int n) {\n        int res = 0;\n        int mod = 1000000007;\n        for (int i = 1; i <= n; i++) {\n            String s = Integer.toBinaryString(i);\n            for (int j = 0; j < s.length(); j++) {\n                res = (res * 2 + (s.charAt(j) - '0')) % mod;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1333", "path": "output2\\java\\Medium\\1333-sum-of-absolute-differences-in-a-sorted-array.java", "hypo_code": "class SumOfAbsoluteDifferencesInASortedArray {\n    public int[] getSumAbsoluteDifferences(int[] nums) {\n        int n = nums.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            if(i == 0 || nums[i] != nums[i - 1]){\n                count++;\n            }else{\n                count = 1;\n            }\n            left[i] = count;\n        }\n        count = 0;\n        for(int i = n - 1; i >= 0; i--){\n            if(i == n - 1 || nums[i] != nums[i + 1]){\n                count++;\n            }else{\n                count = 1;\n            }\n            right[i] = count;\n        }\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++){\n            res[i] = nums[i] * (i + 1 - left[i]) + (nums[i] * right[i] - nums[i] * (i + 1));\n        }\n        return res;\n        \n    }\n}"}
{"id": "1334", "path": "output2\\java\\Medium\\1334-stone-game-vi.java", "hypo_code": "class StoneGameVi {\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\n        int n = aliceValues.length;\n        int[][] arr = new int[n][3];\n        for(int i = 0; i < n; i++){\n            arr[i][0] = aliceValues[i] + bobValues[i];\n            arr[i][1] = aliceValues[i];\n            arr[i][2] = bobValues[i];\n        }\n        Arrays.sort(arr, (a, b) -> b[0] - a[0]);\n        int alice = 0;\n        int bob = 0;\n        for(int i = 0; i < n; i++){\n            if(i % 2 == 0){\n                alice += arr[i][1];\n            }else{\n                bob += arr[i][2];\n            }\n        }\n        if(alice > bob){\n            return 1;\n        }else if(alice < bob){\n            return -1;\n        }else{\n            return 0;\n        }\n        \n    }\n}"}
{"id": "1335", "path": "output2\\java\\Medium\\1335-partitioning-into-minimum-number-of-deci-binary-numbers.java", "hypo_code": "class PartitioningIntoMinimumNumberOfDeciBinaryNumbers {\n    public int minPartitions(String n) {\n        int res = 0;\n        for(int i = 0; i < n.length(); i++){\n            res = Math.max(res, n.charAt(i) - '0');\n        }\n        return res;\n        \n    }\n}"}
{"id": "1336", "path": "output2\\java\\Medium\\1336-stone-game-vii.java", "hypo_code": "class StoneGameVii {\n    public int stoneGameVII(int[] stones) {\n        int n = stones.length;\n        int[] pre = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            pre[i] = pre[i - 1] + stones[i - 1];\n        }\n        int[][] dp = new int[n][n];\n        for(int i = n - 2; i >= 0; i--){\n            for(int j = i + 1; j < n; j++){\n                dp[i][j] = Math.max(pre[j + 1] - pre[i + 1] - dp[i + 1][j], pre[j] - pre[i] - dp[i][j - 1]);\n            }\n        }\n        return dp[0][n - 1];\n        \n    }\n}"}
{"id": "1337", "path": "output2\\java\\Medium\\1337-maximum-erasure-value.java", "hypo_code": "class MaximumErasureValue {\n    public int maximumUniqueSubarray(int[] nums) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            pre[i] = pre[i - 1] + nums[i - 1];\n        }\n        int[] dp = new int[n + 1];\n        int res = 0;\n        int[] last = new int[10001];\n        Arrays.fill(last, -1);\n        for(int i = 1; i <= n; i++){\n            dp[i] = dp[i - 1];\n            if(last[nums[i - 1]] != -1){\n                dp[i] = Math.max(dp[i], dp[last[nums[i - 1]]] + pre[i] - pre[last[nums[i - 1]] + 1]);\n            }\n            last[nums[i - 1]] = i - 1;\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1338", "path": "output2\\java\\Medium\\1338-jump-game-vi.java", "hypo_code": "class JumpGameVi {\n    public int maxResult(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        Deque<Integer> q = new LinkedList<>();\n        q.offer(0);\n        for(int i = 1; i < n; i++){\n            while(!q.isEmpty() && q.peekFirst() < i - k){\n                q.pollFirst();\n            }\n            dp[i] = dp[q.peekFirst()] + nums[i];\n            while(!q.isEmpty() && dp[q.peekLast()] <= dp[i]){\n                q.pollLast();\n            }\n            q.offer(i);\n        }\n        return dp[n - 1];\n        \n    }\n}"}
{"id": "1339", "path": "output2\\java\\Medium\\1339-average-waiting-time.java", "hypo_code": "class AverageWaitingTime {\n    public double averageWaitingTime(int[][] customers) {\n        int n = customers.length;\n        int[] pre = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            pre[i] = pre[i - 1] + customers[i - 1][1];\n        }\n        int[] dp = new int[n + 1];\n        int res = 0;\n        int[] last = new int[10001];\n        Arrays.fill(last, -1);\n        for(int i = 1; i <= n; i++){\n            dp[i] = dp[i - 1];\n            if(last[customers[i - 1][0]] != -1){\n                dp[i] = Math.max(dp[i], dp[last[customers[i - 1][0]]] + pre[i] - pre[last[customers[i - 1][0]] + 1]);\n            }\n            last[customers[i - 1][0]] = i - 1;\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1340", "path": "output2\\java\\Medium\\1340-maximum-binary-string-after-change.java", "hypo_code": "class MaximumBinaryStringAfterChange {\n    public String maximumBinaryString(String binary) {\n        int n = binary.length();\n        int[] pre = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            pre[i] = pre[i - 1] + (binary.charAt(i - 1) - '0');\n        }\n        int[] dp = new int[n + 1];\n        int res = 0;\n        int[] last = new int[2];\n        Arrays.fill(last, -1);\n        for(int i = 1; i <= n; i++){\n            dp[i] = dp[i - 1];\n            if(last[binary.charAt(i - 1) - '0'] != -1){\n                dp[i] = Math.max(dp[i], dp[last[binary.charAt(i - 1) - '0']] + pre[i] - pre[last[binary.charAt(i - 1) - '0'] + 1]);\n            }\n            last[binary.charAt(i - 1) - '0'] = i - 1;\n            res = Math.max(res, dp[i]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < n - res; i++){\n            sb.append('1');\n        }\n        for(int i = 0; i < res; i++){\n            sb.append('0');\n        }\n        return sb.toString();\n        \n    }\n}"}
{"id": "1341", "path": "output2\\java\\Medium\\1341-maximum-number-of-eaten-apples.java", "hypo_code": "class MaximumNumberOfEatenApples {\n    public int eatenApples(int[] apples, int[] days) {\n        int n = apples.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            if(apples[i] > 0){\n                pq.offer(new int[]{i + days[i], apples[i]});\n            }\n            while(!pq.isEmpty() && (pq.peek()[0] <= i || pq.peek()[1] == 0)){\n                pq.poll();\n            }\n            if(!pq.isEmpty()){\n                int[] cur = pq.poll();\n                cur[1]--;\n                res++;\n                if(cur[1] > 0){\n                    pq.offer(cur);\n                }\n            }\n        }\n        int i = n;\n        while(!pq.isEmpty()){\n            while(!pq.isEmpty() && (pq.peek()[0] <= i || pq.peek()[1] == 0)){\n                pq.poll();\n            }\n            if(!pq.isEmpty()){\n                int[] cur = pq.poll();\n                cur[1]--;\n                res++;\n                if(cur[1] > 0){\n                    pq.offer(cur);\n                }\n            }\n            i++;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1342", "path": "output2\\java\\Medium\\1342-where-will-the-ball-fall.java", "hypo_code": "class WhereWillTheBallFall {\n    public int[] findBall(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++){\n            res[i] = i;\n        }\n        for(int i = 0; i < m; i++){\n            int[] next = new int[n];\n            Arrays.fill(next, -1);\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 1){\n                    if(j + 1 < n && grid[i][j + 1] == 1 && res[j + 1] != -1){\n                        next[j] = res[j + 1];\n                    }\n                }else{\n                    if(j - 1 >= 0 && grid[i][j - 1] == -1 && res[j - 1] != -1){\n                        next[j] = res[j - 1];\n                    }\n                }\n            }\n            res = next;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1343", "path": "output2\\java\\Medium\\1343-count-good-meals.java", "hypo_code": "class Solution {\n    public int countPairs(int[] deliciousness) {\n        int mod = (int)1e9 + 7;\n        int max = 0;\n        for (int num : deliciousness) {\n            max = Math.max(max, num);\n        }\n        int maxSum = max * 2;\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : deliciousness) {\n            int sum = 1;\n            while (sum <= maxSum) {\n                int target = sum - num;\n                if (map.containsKey(target)) {\n                    res = (res + map.get(target)) % mod;\n                }\n                sum <<= 1;\n            }\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        return res;\n    }\n}"}
{"id": "1344", "path": "output2\\java\\Medium\\1344-ways-to-split-array-into-three-subarrays.java", "hypo_code": "class Solution {\n    public int waysToSplit(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = prefix[i] + nums[i];\n        }\n        int res = 0;\n        int mod = (int)1e9 + 7;\n        for (int i = 1; i < n; i++) {\n            int left = prefix[i];\n            int right = prefix[n] - prefix[i];\n            int leftIndex = binarySearch(prefix, i + 1, n, left * 2);\n            int rightIndex = binarySearch(prefix, i + 1, n, (left + right) / 2);\n            if (leftIndex != -1 && rightIndex != -1) {\n                res = (res + Math.max(0, rightIndex - leftIndex + 1)) % mod;\n            }\n        }\n        return res;\n    }\n    private int binarySearch(int[] prefix, int start, int end, int target) {\n        int res = -1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (prefix[mid] >= target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n                res = mid;\n            }\n        }\n        return res;\n    }\n\n}"}
{"id": "1345", "path": "output2\\java\\Medium\\1345-maximum-score-from-removing-substrings.java", "hypo_code": "class MaximumScoreFromRemovingSubstrings {\n    public int maximumGain(String s, int x, int y) {\n        int res = 0;\n        int n = s.length();\n        int[] pre = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            pre[i] = pre[i - 1] + (s.charAt(i - 1) == 'a' ? x : y);\n        }\n        int[] dp = new int[n + 1];\n        int[] last = new int[2];\n        Arrays.fill(last, -1);\n        for(int i = 1; i <= n; i++){\n            dp[i] = dp[i - 1];\n            if(last[s.charAt(i - 1) - 'a'] != -1){\n                dp[i] = Math.max(dp[i], dp[last[s.charAt(i - 1) - 'a']] + pre[i] - pre[last[s.charAt(i - 1) - 'a'] + 1]);\n            }\n            last[s.charAt(i - 1) - 'a'] = i - 1;\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1346", "path": "output2\\java\\Medium\\1346-construct-the-lexicographically-largest-valid-sequence.java", "hypo_code": "class ConstructTheLexicographicallyLargestValidSequence {\n    public int[] constructDistancedSequence(int n) {\n        int[] res = new int[2 * n - 1];\n        boolean[] used = new boolean[n + 1];\n        dfs(res, used, 0);\n        return res;\n        \n        \n    }\n}"}
{"id": "1347", "path": "output2\\java\\Medium\\1347-swapping-nodes-in-a-linked-list.java", "hypo_code": "class SwappingNodesInALinkedList {\n    public ListNode swapNodes(ListNode head, int k) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode p = dummy;\n        ListNode q = dummy;\n        for(int i = 0; i < k; i++){\n            p = p.next;\n        }\n        ListNode first = p;\n        while(p.next != null){\n            p = p.next;\n            q = q.next;\n        }\n        ListNode second = q.next;\n        int temp = first.val;\n        first.val = second.val;\n        second.val = temp;\n        return dummy.next;\n        \n    }\n}"}
{"id": "1348", "path": "output2\\java\\Medium\\1348-minimize-hamming-distance-after-swap-operations.java", "hypo_code": "class MinimizeHammingDistanceAfterSwapOperations {\n    public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) {\n        int n = source.length;\n        int[] parent = new int[n];\n        for(int i = 0; i < n; i++){\n            parent[i] = i;\n        }\n        for(int[] swap : allowedSwaps){\n            union(parent, swap[0], swap[1]);\n        }\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            int p = find(parent, i);\n            map.putIfAbsent(p, new HashMap<>());\n            map.get(p).put(source[i], map.get(p).getOrDefault(source[i], 0) + 1);\n        }\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            int p = find(parent, i);\n            if(map.get(p).getOrDefault(target[i], 0) == 0){\n                res++;\n            }else{\n                map.get(p).put(target[i], map.get(p).get(target[i]) - 1);\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1349", "path": "output2\\java\\Medium\\1349-tuple-with-same-product.java", "hypo_code": "class TupleWithSameProduct {\n    public int tupleSameProduct(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                map.put(nums[i] * nums[j], map.getOrDefault(nums[i] * nums[j], 0) + 1);\n            }\n        }\n        for(int key : map.keySet()){\n            int count = map.get(key);\n            res += count * (count - 1) * 4;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1350", "path": "output2\\java\\Medium\\1350-largest-submatrix-with-rearrangements.java", "hypo_code": "class LargestSubmatrixWithRearrangements {\n    public int largestSubmatrix(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[] height = new int[n];\n        int res = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(matrix[i][j] == 0){\n                    height[j] = 0;\n                }else{\n                    height[j]++;\n                }\n            }\n            int[] temp = Arrays.copyOf(height, n);\n            Arrays.sort(temp);\n            for(int j = 0; j < n; j++){\n                res = Math.max(res, temp[j] * (n - j));\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1351", "path": "output2\\java\\Medium\\1351-minimum-number-of-people-to-teach.java", "hypo_code": "class MinimumNumberOfPeopleToTeach {\n    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {\n        int m = languages.length;\n        int[] count = new int[n + 1];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < languages[i].length; j++){\n                count[languages[i][j]]++;\n            }\n        }\n        int max = 0;\n        for(int i = 1; i <= n; i++){\n            max = Math.max(max, count[i]);\n        }\n        int ans = m - max;\n        for(int i = 0; i < friendships.length; i++){\n            int[] a = languages[friendships[i][0] - 1];\n            int[] b = languages[friendships[i][1] - 1];\n            int[] temp = new int[n + 1];\n            for(int j = 0; j < a.length; j++){\n                temp[a[j]]++;\n            }\n            for(int j = 0; j < b.length; j++){\n                temp[b[j]]++;\n            }\n            max = 0;\n            for(int j = 1; j <= n; j++){\n                max = Math.max(max, temp[j]);\n            }\n            ans = Math.min(ans, m - max);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1352", "path": "output2\\java\\Medium\\1352-decode-xored-permutation.java", "hypo_code": "class DecodeXoredPermutation {\n    public int[] decode(int[] encoded) {\n        int n = encoded.length + 1;\n        int[] perm = new int[n];\n        int total = 0;\n        for(int i = 1; i <= n; i++){\n            total ^= i;\n        }\n        int odd = 0;\n        for(int i = 1; i < n - 1; i += 2){\n            odd ^= encoded[i];\n        }\n        perm[0] = total ^ odd;\n        for(int i = 0; i < n - 1; i++){\n            perm[i + 1] = perm[i] ^ encoded[i];\n        }\n        return perm;\n        \n    }\n}"}
{"id": "1353", "path": "output2\\java\\Medium\\1353-change-minimum-characters-to-satisfy-one-of-three-conditions.java", "hypo_code": "class ChangeMinimumCharactersToSatisfyOneOfThreeConditions {\n    public int minCharacters(String a, String b) {\n        int[] countA = new int[26];\n        int[] countB = new int[26];\n        for(int i = 0; i < a.length(); i++){\n            countA[a.charAt(i) - 'a']++;\n        }\n        for(int i = 0; i < b.length(); i++){\n            countB[b.charAt(i) - 'a']++;\n        }\n        int ans = Integer.MAX_VALUE;\n        for(int i = 0; i < 26; i++){\n            int temp = 0;\n            for(int j = 0; j < 26; j++){\n                if(j < i){\n                    temp += countA[j] + countB[j];\n                }\n                else if(j > i){\n                    temp += countA[j] + countB[j];\n                }\n            }\n            ans = Math.min(ans, temp);\n        }\n        for(int i = 0; i < 26; i++){\n            int temp = 0;\n            for(int j = 0; j < 26; j++){\n                if(j < i){\n                    temp += countA[j];\n                }\n                else if(j > i){\n                    temp += countB[j];\n                }\n            }\n            ans = Math.min(ans, temp);\n        }\n        for(int i = 0; i < 26; i++){\n            int temp = 0;\n            for(int j = 0; j < 26; j++){\n                if(j < i){\n                    temp += countB[j];\n                }\n                else if(j > i){\n                    temp += countA[j];\n                }\n            }\n            ans = Math.min(ans, temp);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1354", "path": "output2\\java\\Medium\\1354-find-kth-largest-xor-coordinate-value.java", "hypo_code": "class FindKthLargestXorCoordinateValue {\n    public int kthLargestValue(int[][] matrix, int k) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                dp[i][j] = dp[i - 1][j] ^ dp[i][j - 1] ^ dp[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n                pq.add(dp[i][j]);\n                if(pq.size() > k){\n                    pq.poll();\n                }\n            }\n        }\n        return pq.poll();\n        \n    }\n}"}
{"id": "1355", "path": "output2\\java\\Medium\\1355-restore-the-array-from-adjacent-pairs.java", "hypo_code": "class Solution {\n    public int[] restoreArray(int[][] adjacentPairs) {\n        int n = adjacentPairs.length + 1;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int[] adjacentPair : adjacentPairs) {\n            int num1 = adjacentPair[0];\n            int num2 = adjacentPair[1];\n            List<Integer> list1 = map.getOrDefault(num1, new ArrayList<>());\n            list1.add(num2);\n            map.put(num1, list1);\n            List<Integer> list2 = map.getOrDefault(num2, new ArrayList<>());\n            list2.add(num1);\n            map.put(num2, list2);\n        }\n        int[] res = new int[n];\n        for (int key : map.keySet()) {\n            if (map.get(key).size() == 1) {\n                res[0] = key;\n                break;\n            }\n        }\n        res[1] = map.get(res[0]).get(0);\n        for (int i = 2; i < n; i++) {\n            List<Integer> list = map.get(res[i - 1]);\n            res[i] = list.get(0) == res[i - 2] ? list.get(1) : list.get(0);\n        }\n        return res;\n    }\n}"}
{"id": "1356", "path": "output2\\java\\Medium\\1356-can-you-eat-your-favorite-candy-on-your-favorite-day.java", "hypo_code": "class Solution {\n    public boolean[] canEat(int[] candiesCount, int[][] queries) {\n        int n = candiesCount.length;\n        int m = queries.length;\n        long[] prefix = new long[n];\n        prefix[0] = candiesCount[0];\n        for (int i = 1; i < n; i++) {\n            prefix[i] = prefix[i - 1] + candiesCount[i];\n        }\n        boolean[] res = new boolean[m];\n        for (int i = 0; i < m; i++) {\n            int type = queries[i][0];\n            int day = queries[i][1];\n            int cap = queries[i][2];\n            long min = day + 1;\n            long max = (long) (day + 1) * cap;\n            if (type > 0) {\n                min = prefix[type - 1] + 1;\n            }\n            res[i] = !(min > prefix[type] || max < 1);\n        }\n        return res;\n    }\n}"}
{"id": "1357", "path": "output2\\java\\Medium\\1357-maximum-absolute-sum-of-any-subarray.java", "hypo_code": "class Solution {\n    public int maxAbsoluteSum(int[] nums) {\n        int n = nums.length;\n        int[] max = new int[n + 1];\n        int[] min = new int[n + 1];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            max[i + 1] = Math.max(max[i] + nums[i], nums[i]);\n            min[i + 1] = Math.min(min[i] + nums[i], nums[i]);\n            res = Math.max(res, Math.max(Math.abs(max[i + 1]), Math.abs(min[i + 1])));\n        }\n        return res;\n    }\n}"}
{"id": "1358", "path": "output2\\java\\Medium\\1358-minimum-length-of-string-after-deleting-similar-ends.java", "hypo_code": "class Solution {\n    public int minimumLength(String s) {\n        int n = s.length();\n        int left = 0;\n        int right = n - 1;\n        while (left < right && s.charAt(left) == s.charAt(right)) {\n            char c = s.charAt(left);\n            while (left < right && s.charAt(left) == c) {\n                left++;\n            }\n            while (left < right && s.charAt(right) == c) {\n                right--;\n            }\n        }\n        return right - left + 1;\n    }\n}"}
{"id": "1359", "path": "output2\\java\\Medium\\1359-maximum-score-from-removing-stones.java", "hypo_code": "class Solution {\n    public int maximumScore(int a, int b, int c) {\n        int[] arr = new int[]{a, b, c};\n        Arrays.sort(arr);\n        int res = 0;\n        while (arr[1] > 0) {\n            res++;\n            arr[1]--;\n            arr[2]--;\n            Arrays.sort(arr);\n        }\n        return res;\n    }\n}"}
{"id": "1360", "path": "output2\\java\\Medium\\1360-largest-merge-of-two-strings.java", "hypo_code": "class Solution {\n    public String largestMerge(String word1, String word2) {\n        StringBuilder res = new StringBuilder();\n        int m = word1.length();\n        int n = word2.length();\n        int i = 0;\n        int j = 0;\n        while (i < m && j < n) {\n            if (word1.charAt(i) > word2.charAt(j)) {\n                res.append(word1.charAt(i));\n                i++;\n            } else if (word1.charAt(i) < word2.charAt(j)) {\n                res.append(word2.charAt(j));\n                j++;\n            } else {\n                int x = i;\n                int y = j;\n                while (x < m && y < n && word1.charAt(x) == word2.charAt(y)) {\n                    x++;\n                    y++;\n                }\n                if (x == m) {\n                    res.append(word2.charAt(j));\n                    j++;\n                } else if (y == n) {\n                    res.append(word1.charAt(i));\n                    i++;\n                } else if (word1.charAt(x) > word2.charAt(y)) {\n                    res.append(word1.charAt(i));\n                    i++;\n                } else {\n                    res.append(word2.charAt(j));\n                    j++;\n                }\n            }\n        }\n        while (i < m) {\n            res.append(word1.charAt(i));\n            i++;\n        }\n        while (j < n) {\n            res.append(word2.charAt(j));\n            j++;\n        }\n        return res.toString();\n    }\n}"}
{"id": "1361", "path": "output2\\java\\Medium\\1361-count-number-of-homogenous-substrings.java", "hypo_code": "class Solution {\n    public int countHomogenous(String s) {\n        int res = 0;\n        int mod = 1000000007;\n        int count = 0;\n        char prev = ' ';\n        for (char c : s.toCharArray()) {\n            if (c == prev) {\n                count++;\n            } else {\n                prev = c;\n                count = 1;\n            }\n            res = (res + count) % mod;\n        }\n        return res;\n    }\n}"}
{"id": "1362", "path": "output2\\java\\Medium\\1362-minimum-limit-of-balls-in-a-bag.java", "hypo_code": "class Solution {\n    public int minimumSize(int[] nums, int maxOperations) {\n        int left = 1;\n        int right = 1000000000;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (check(nums, maxOperations, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n    private boolean check(int[] nums, int maxOperations, int target) {\n        int res = 0;\n        for (int num : nums) {\n            if (num > target) {\n                res += (num - 1) / target;\n            }\n        }\n        return res <= maxOperations;\n    }\n}"}
{"id": "1363", "path": "output2\\java\\Medium\\1363-form-array-by-concatenating-subarrays-of-another-array.java", "hypo_code": "class Solution {\n    public boolean canChoose(int[][] groups, int[] nums) {\n        int n = nums.length;\n        int m = groups.length;\n        int i = 0;\n        int j = 0;\n        while (i < n && j < m) {\n            int[] cur = groups[j];\n            int len = cur.length;\n            if (i + len > n) {\n                return false;\n            }\n            boolean flag = true;\n            for (int k = 0; k < len; k++) {\n                if (cur[k] != nums[i + k]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                i += len;\n                j++;\n            } else {\n                i++;\n            }\n        }\n        return j == m;\n    }\n}"}
{"id": "1364", "path": "output2\\java\\Medium\\1364-map-of-highest-peak.java", "hypo_code": "class Solution {\n    public int[][] highestPeak(int[][] isWater) {\n        int m = isWater.length;\n        int n = isWater[0].length;\n        int[][] res = new int[m][n];\n        Queue<int[]> q = new LinkedList<>();\n        boolean[][] visited = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(res[i], -1);\n            for (int j = 0; j < n; j++) {\n                if (isWater[i][j] == 1) {\n                    q.offer(new int[]{i, j});\n                    res[i][j] = 0;\n                    visited[i][j] = true;\n                }\n            }\n        }\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        while (!q.isEmpty()) {\n            int[] cur = q.poll();\n            for (int[] dir : directions) {\n                int x = cur[0] + dir[0];\n                int y = cur[1] + dir[1];\n                if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) {\n                    continue;\n                }\n                res[x][y] = res[cur[0]][cur[1]] + 1;\n                visited[x][y] = true;\n                q.offer(new int[]{x, y});\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1365", "path": "output2\\java\\Medium\\1365-minimum-number-of-operations-to-move-all-balls-to-each-box.java", "hypo_code": "class Solution {\n    public int[] minOperations(String boxes) {\n        int n = boxes.length();\n        int[] res = new int[n];\n        int left = 0;\n        int right = 0;\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (boxes.charAt(i) == '1') {\n                right++;\n                count += i;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            res[i] = count;\n            if (boxes.charAt(i) == '1') {\n                left++;\n                right--;\n            }\n            count += left - right;\n        }\n        return res;\n    }\n}"}
{"id": "1366", "path": "output2\\java\\Medium\\1366-closest-dessert-cost.java", "hypo_code": "class Solution {\n    public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {\n        int res = baseCosts[0];\n        for (int base : baseCosts) {\n            int cur = helper(base, toppingCosts, target, 0);\n            if (Math.abs(cur - target) < Math.abs(res - target) || (Math.abs(cur - target) == Math.abs(res - target) && cur < res)) {\n                res = cur;\n            }\n        }\n        return res;\n    }\n    private int helper(int base, int[] toppingCosts, int target, int index) {\n        if (index == toppingCosts.length) {\n            return base;\n        }\n        int res = helper(base, toppingCosts, target, index + 1);\n        res = Math.min(res, helper(base + toppingCosts[index], toppingCosts, target, index + 1));\n        res = Math.min(res, helper(base + toppingCosts[index] * 2, toppingCosts, target, index + 1));\n        return res;\n    }\n}"}
{"id": "1367", "path": "output2\\java\\Medium\\1367-equal-sum-arrays-with-minimum-number-of-operations.java", "hypo_code": "class Solution {\n    public int minOperations(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int m = nums2.length;\n        if (n > 6 * m || m > 6 * n) {\n            return -1;\n        }\n        int sum1 = 0;\n        int sum2 = 0;\n        for (int num : nums1) {\n            sum1 += num;\n        }\n        for (int num : nums2) {\n            sum2 += num;\n        }\n        if (sum1 == sum2) {\n            return 0;\n        }\n        if (sum1 > sum2) {\n            return minOperations(nums2, nums1);\n        }\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i = 0;\n        int j = m - 1;\n        int res = 0;\n        while (sum1 < sum2) {\n            if (j < 0 || i < n && 6 - nums1[i] > nums2[j] - 1) {\n                sum1 += 6 - nums1[i++];\n            } else {\n                sum2 -= nums2[j--] - 1;\n            }\n            res++;\n        }\n        return res;\n    }\n}"}
{"id": "1368", "path": "output2\\java\\Medium\\1368-check-if-number-is-a-sum-of-powers-of-three.java", "hypo_code": "class Solution {\n    public boolean checkPowersOfThree(int n) {\n        while (n > 0) {\n            if (n % 3 == 2) {\n                return false;\n            }\n            n /= 3;\n        }\n        return true;\n    }\n}"}
{"id": "1369", "path": "output2\\java\\Medium\\1369-sum-of-beauty-of-all-substrings.java", "hypo_code": "class Solution {\n    public int beautySum(String s) {\n        int res = 0;\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            int[] freq = new int[26];\n            for (int j = i; j < n; j++) {\n                freq[s.charAt(j) - 'a']++;\n                res += diff(freq);\n            }\n        }\n        return res;\n    }\n    private int diff(int[] freq) {\n        int max = 0;\n        int min = Integer.MAX_VALUE;\n        for (int f : freq) {\n            if (f > 0) {\n                max = Math.max(max, f);\n                min = Math.min(min, f);\n            }\n        }\n        return max - min;\n    }\n}"}
{"id": "1370", "path": "output2\\java\\Medium\\1370-minimum-elements-to-add-to-form-a-given-sum.java", "hypo_code": "class Solution {\n    public int minElements(int[] nums, int limit, int goal) {\n        long sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        long target = Math.abs(goal - sum);\n        if (target == 0) {\n            return 0;\n        }\n        return (int) ((target + limit - 1) / limit);\n    }\n}"}
{"id": "1371", "path": "output2\\java\\Medium\\1371-number-of-restricted-paths-from-first-to-last-node.java", "hypo_code": "class Solution {\n    public int countRestrictedPaths(int n, int[][] edges) {\n        int mod = 1000000007;\n        Map<Integer, List<int[]>> map = new HashMap<>();\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            int w = edge[2];\n            map.putIfAbsent(u, new ArrayList<>());\n            map.putIfAbsent(v, new ArrayList<>());\n            map.get(u).add(new int[]{v, w});\n            map.get(v).add(new int[]{u, w});\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\n        pq.offer(new int[]{n, 0});\n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[n] = 0;\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int u = cur[0];\n            int d = cur[1];\n            if (d > dist[u]) {\n                continue;\n            }\n            if (map.containsKey(u)) {\n                for (int[] v : map.get(u)) {\n                    if (dist[u] + v[1] < dist[v[0]]) {\n                        dist[v[0]] = dist[u] + v[1];\n                        pq.offer(new int[]{v[0], dist[v[0]]});\n                    }\n                }\n            }\n        }\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, -1);\n        return dfs(1, n, map, dist, dp, mod);\n    }\n    private int dfs(int u, int n, Map<Integer, List<int[]>> map, int[] dist, int[] dp, int mod) {\n        if (u == n) {\n            return 1;\n        }\n        if (dp[u] != -1) {\n            return dp[u];\n        }\n        int res = 0;\n        for (int[] v : map.get(u)) {\n            if (dist[u] > dist[v[0]]) {\n                res = (res + dfs(v[0], n, map, dist, dp, mod)) % mod;\n            }\n        }\n        dp[u] = res;\n        return res;\n    }\n}"}
{"id": "1372", "path": "output2\\java\\Medium\\1372-maximum-average-pass-ratio.java", "hypo_code": "class Solution {\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\n        int n = classes.length;\n        PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> Double.compare(b[0], a[0]));\n        for (int[] c : classes) {\n            pq.offer(new double[]{(double)(c[0] + 1) / (c[1] + 1) - (double)c[0] / c[1], (double)c[0], (double)c[1]});\n        }\n        while (extraStudents-- > 0) {\n            double[] cur = pq.poll();\n            cur[1]++;\n            cur[2]++;\n            cur[0] = (cur[1] + 1) / (cur[2] + 1) - cur[1] / cur[2];\n            pq.offer(cur);\n        }\n        double res = 0;\n        while (!pq.isEmpty()) {\n            double[] cur = pq.poll();\n            res += cur[1] / cur[2];\n        }\n        return res / n;\n    }\n}"}
{"id": "1374", "path": "output2\\java\\Medium\\1374-maximum-number-of-consecutive-values-you-can-make.java", "hypo_code": "class Solution {\n    public int getMaximumConsecutive(int[] coins) {\n        int n = coins.length;\n        Arrays.sort(coins);\n        int res = 1;\n        for (int num : coins) {\n            if (num > res) {\n                break;\n            }\n            res += num;\n        }\n        return res;\n    }\n}"}
{"id": "1375", "path": "output2\\java\\Medium\\1375-number-of-orders-in-the-backlog.java", "hypo_code": "class Solution {\n    public int getNumberOfBacklogOrders(int[][] orders) {\n        int n = orders.length;\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> b[0] - a[0]);\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        for (int[] order : orders) {\n            if (order[2] == 0) {\n                while (order[1] > 0 && !sell.isEmpty() && sell.peek()[0] <= order[0]) {\n                    int[] cur = sell.poll();\n                    int diff = Math.min(order[1], cur[1]);\n                    order[1] -= diff;\n                    cur[1] -= diff;\n                    if (cur[1] > 0) {\n                        sell.offer(cur);\n                    }\n                }\n                if (order[1] > 0) {\n                    buy.offer(order);\n                }\n            } else {\n                while (order[1] > 0 && !buy.isEmpty() && buy.peek()[0] >= order[0]) {\n                    int[] cur = buy.poll();\n                    int diff = Math.min(order[1], cur[1]);\n                    order[1] -= diff;\n                    cur[1] -= diff;\n                    if (cur[1] > 0) {\n                        buy.offer(cur);\n                    }\n                }\n                if (order[1] > 0) {\n                    sell.offer(order);\n                }\n            }\n        }\n        long res = 0;\n        while (!buy.isEmpty()) {\n            res += buy.poll()[1];\n        }\n        while (!sell.isEmpty()) {\n            res += sell.poll()[1];\n        }\n        return (int)(res % 1000000007);\n    }\n}"}
{"id": "1376", "path": "output2\\java\\Medium\\1376-maximum-value-at-a-given-index-in-a-bounded-array.java", "hypo_code": "class Solution {\n    public int maxValue(int n, int index, int maxSum) {\n        int left = 1;\n        int right = maxSum;\n        while (left < right) {\n            int mid = right - (right - left) / 2;\n            if (getSum(n, index, mid) <= maxSum) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n    private long getSum(int n, int index, int mid) {\n        long res = 0;\n        int left = Math.min(index, mid - 1);\n        int right = Math.min(n - index - 1, mid - 1);\n        res += (long)(mid - left + mid) * (left + 1) / 2;\n        res += (long)(mid - right + mid) * (right + 1) / 2;\n        return res - mid;\n    }\n}"}
{"id": "1377", "path": "output2\\java\\Medium\\1377-minimum-number-of-operations-to-reinitialize-a-permutation.java", "hypo_code": "class Solution {\n    public int reinitializePermutation(int n) {\n        int res = 0;\n        int i = 1;\n        while (res == 0 || i > 1) {\n            if (i < n / 2) {\n                i *= 2;\n            } else {\n                i = (i - n / 2) * 2 + 1;\n            }\n            res++;\n        }\n        return res;\n    }\n}"}
{"id": "1378", "path": "output2\\java\\Medium\\1378-evaluate-the-bracket-pairs-of-a-string.java", "hypo_code": "class Solution {\n    public String evaluate(String s, List<List<String>> knowledge) {\n        Map<String, String> map = new HashMap<>();\n        for (List<String> pair : knowledge) {\n            map.put(pair.get(0), pair.get(1));\n        }\n        StringBuilder sb = new StringBuilder();\n        int n = s.length();\n        int i = 0;\n        while (i < n) {\n            if (s.charAt(i) != '(') {\n                sb.append(s.charAt(i));\n                i++;\n            } else {\n                int j = i + 1;\n                while (j < n && s.charAt(j) != ')') {\n                    j++;\n                }\n                String key = s.substring(i + 1, j);\n                sb.append(map.getOrDefault(key, \"?\"));\n                i = j + 1;\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1379", "path": "output2\\java\\Medium\\1379-sentence-similarity-iii.java", "hypo_code": "class SentenceSimilarityIii {\n    public boolean areSentencesSimilar(String sentence1, String sentence2) {\n        String[] s1 = sentence1.split(\" \");\n        String[] s2 = sentence2.split(\" \");\n        int i = 0, j = 0;\n        while (i < s1.length && j < s2.length && s1[i].equals(s2[j])) {\n            i++;\n            j++;\n        }\n        int k = s1.length - 1, l = s2.length - 1;\n        while (k >= i && l >= j && s1[k].equals(s2[l])) {\n            k--;\n            l--;\n        }\n        return k < i && l < j;\n        \n    }\n}"}
{"id": "1380", "path": "output2\\java\\Medium\\1380-count-nice-pairs-in-an-array.java", "hypo_code": "class CountNicePairsInAnArray {\n    public int countNicePairs(int[] nums) {\n        int mod = 1000000007;\n        Map<Integer, Integer> map = new HashMap<>();\n        int res = 0;\n        for (int num : nums) {\n            int rev = reverse(num);\n            int diff = num - rev;\n            int count = map.getOrDefault(diff, 0);\n            res = (res + count) % mod;\n            map.put(diff, count + 1);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1381", "path": "output2\\java\\Medium\\1381-finding-the-users-active-minutes.java", "hypo_code": "class FindingTheUsersActiveMinutes {\n    public int[] findingUsersActiveMinutes(int[][] logs, int k) {\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        for(int[] log : logs){\n            map.putIfAbsent(log[0], new HashSet<>());\n            map.get(log[0]).add(log[1]);\n        }\n        int[] res = new int[k];\n        for(int key : map.keySet()){\n            res[map.get(key).size() - 1]++;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1382", "path": "output2\\java\\Medium\\1382-minimum-absolute-sum-difference.java", "hypo_code": "class MinimumAbsoluteSumDifference {\n    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {\n        int mod = 1000000007;\n        int[] sorted = nums1.clone();\n        Arrays.sort(sorted);\n        int sum = 0;\n        int max = 0;\n        for(int i = 0; i < nums1.length; i++){\n            int diff = Math.abs(nums1[i] - nums2[i]);\n            sum = (sum + diff) % mod;\n            int index = binarySearch(sorted, nums2[i]);\n            if(index < nums1.length){\n                max = Math.max(max, diff - (sorted[index] - nums2[i]));\n            }\n            if(index > 0){\n                max = Math.max(max, diff - (nums2[i] - sorted[index - 1]));\n            }\n        }\n        return (sum - max + mod) % mod;\n        \n    }\n}"}
{"id": "1383", "path": "output2\\java\\Medium\\1383-find-the-winner-of-the-circular-game.java", "hypo_code": "class Solution {\n    public int findTheWinner(int n, int k) {\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 1; i <= n; i++) {\n            q.offer(i);\n        }\n        while (q.size() > 1) {\n            for (int i = 1; i < k; i++) {\n                q.offer(q.poll());\n            }\n            q.poll();\n        }\n        return q.poll();\n    }\n}"}
{"id": "1384", "path": "output2\\java\\Medium\\1384-minimum-sideway-jumps.java", "hypo_code": "class Solution {\n    public int minSideJumps(int[] obstacles) {\n        int n = obstacles.length;\n        int[][] dp = new int[n][4];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        dp[0][1] = 1;\n        dp[0][3] = 1;\n        dp[0][2] = 0;\n        for (int i = 1; i < n; i++) {\n            if (obstacles[i] != 1) {\n                dp[i][1] = Math.min(dp[i - 1][1], Math.min(dp[i - 1][2], dp[i - 1][3]) + 1);\n            }\n            if (obstacles[i] != 2) {\n                dp[i][2] = Math.min(dp[i - 1][2], Math.min(dp[i - 1][1], dp[i - 1][3]) + 1);\n            }\n            if (obstacles[i] != 3) {\n                dp[i][3] = Math.min(dp[i - 1][3], Math.min(dp[i - 1][1], dp[i - 1][2]) + 1);\n            }\n        }\n        return Math.min(dp[n - 1][1], Math.min(dp[n - 1][2], dp[n - 1][3]));\n\n    }\n}"}
{"id": "1385", "path": "output2\\java\\Medium\\1385-queries-on-number-of-points-inside-a-circle.java", "hypo_code": "class Solution {\n    public int[] countPoints(int[][] points, int[][] queries) {\n        int m = queries.length;\n        int[] res = new int[m];\n        int i = 0;\n        for (int[] q : queries) {\n            int x = q[0];\n            int y = q[1];\n            int r = q[2];\n            for (int[] p : points) {\n                int px = p[0];\n                int py = p[1];\n                if (Math.pow(px - x, 2) + Math.pow(py - y, 2) <= Math.pow(r, 2)) {\n                    res[i]++;\n                }\n            }\n            i++;\n        }\n        return res;\n    }\n}"}
{"id": "1386", "path": "output2\\java\\Medium\\1386-maximum-xor-for-each-query.java", "hypo_code": "class Solution {\n    public int[] getMaximumXor(int[] nums, int maximumBit) {\n        int n = nums.length;\n        int[] res = new int[n];\n        int[] pre = new int[n];\n        pre[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            pre[i] = pre[i - 1] ^ nums[i];\n        }\n        int max = (1 << maximumBit) - 1;\n        for (int i = 0; i < n; i++) {\n            res[i] = max ^ pre[n - 1 - i];\n        }\n        return res;\n    }\n}"}
{"id": "1387", "path": "output2\\java\\Medium\\1387-maximum-ice-cream-bars.java", "hypo_code": "class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int n = costs.length;\n        int[] count = new int[100001];\n        for (int cost : costs) {\n            count[cost]++;\n        }\n        int res = 0;\n        for (int i = 1; i <= 100000; i++) {\n            if (coins >= i) {\n                int times = Math.min(count[i], coins / i);\n                res += times;\n                coins -= times * i;\n            } else {\n                break;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1388", "path": "output2\\java\\Medium\\1388-single-threaded-cpu.java", "hypo_code": "class Solution {\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        int[][] taskIdx = new int[n][3];\n        for (int i = 0; i < n; i++) {\n            taskIdx[i][0] = tasks[i][0];\n            taskIdx[i][1] = tasks[i][1];\n            taskIdx[i][2] = i;\n        }\n        Arrays.sort(taskIdx, (a, b) -> a[0] - b[0]);\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] == b[1] ? a[2] - b[2] : a[1] - b[1]);\n        int[] res = new int[n];\n        int idx = 0;\n        int time = 0;\n        int i = 0;\n        while (idx < n) {\n            while (i < n && taskIdx[i][0] <= time) {\n                pq.offer(taskIdx[i++]);\n            }\n            if (pq.isEmpty()) {\n                time = taskIdx[i][0];\n                continue;\n            }\n            int[] cur = pq.poll();\n            time += cur[1];\n            res[idx++] = cur[2];\n        }\n        return res;\n    }\n}"}
{"id": "1389", "path": "output2\\java\\Medium\\1389-frequency-of-the-most-frequent-element.java", "hypo_code": "class Solution {\n    public int maxFrequency(int[] nums, int k) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        long[] prefixSum = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int left = 0;\n            int right = i;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                long cur = prefixSum[i + 1] - prefixSum[mid];\n                long target = (long) nums[i] * (i - mid + 1);\n                if (cur + k >= target) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            res = Math.max(res, i - left + 1);\n        }\n        return res;\n    }\n}"}
{"id": "1390", "path": "output2\\java\\Medium\\1390-longest-substring-of-all-vowels-in-order.java", "hypo_code": "class Solution {\n    public int longestBeautifulSubstring(String word) {\n        int res = 0;\n        int cur = 0;\n        int m = word.length();\n        int i = 0;\n        while (i < m) {\n            int j = i;\n            while (j + 1 < m && word.charAt(j) <= word.charAt(j + 1)) {\n                j++;\n            }\n            if (word.charAt(i) == 'a' && word.charAt(j) == 'u') {\n                cur = j - i + 1;\n            }\n            i = j + 1;\n            res = Math.max(res, cur);\n            cur = 0;\n        }\n        return res;\n    }\n}"}
{"id": "1392", "path": "output2\\java\\Medium\\1392-maximum-element-after-decreasing-and-rearranging.java", "hypo_code": "class Solution {\n    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {\n        int n = arr.length;\n        Arrays.sort(arr);\n        arr[0] = 1;\n        for (int i = 1; i < n; i++) {\n            arr[i] = Math.min(arr[i], arr[i - 1] + 1);\n        }\n        return arr[n - 1];\n    }\n}"}
{"id": "1393", "path": "output2\\java\\Medium\\1393-splitting-a-string-into-descending-consecutive-values.java", "hypo_code": "class Solution {\n    public boolean splitString(String s) {\n        return dfs(s, 0, 0);\n    }\n    private boolean dfs(String s, int index, long prev) {\n        if (index == s.length()) {\n            return true;\n        }\n        long cur = 0;\n        for (int i = index; i < s.length(); i++) {\n            cur = cur * 10 + (s.charAt(i) - '0');\n            if (cur >= prev) {\n                break;\n            }\n            if (prev - cur == 1 && dfs(s, i + 1, cur)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    }\n}"}
{"id": "1394", "path": "output2\\java\\Medium\\1394-minimum-adjacent-swaps-to-reach-the-kth-smallest-number.java", "hypo_code": "class Solution {\n    public int getMinSwaps(String num, int k) {\n        char[] nums = num.toCharArray();\n        for (int i = 0; i < k; i++) {\n            nextPermutation(nums);\n        }\n        return minSwaps(num.toCharArray(), nums);\n    }\n    private void nextPermutation(char[] nums) {\n        int n = nums.length;\n        int i = n - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = n - 1;\n            while (j >= 0 && nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n    private int minSwaps(char[] nums, char[] target) {\n        int res = 0;\n        int i = 0;\n        while (i < nums.length) {\n            if (nums[i] != target[i]) {\n                int j = i + 1;\n                while (j < nums.length && nums[j] != target[i]) {\n                    j++;\n                }\n                while (j > i) {\n                    swap(nums, j, j - 1);\n                    j--;\n                    res++;\n                }\n            }\n            i++;\n        }\n        return res;\n    }\n    private void reverse(char[] nums, int start) {\n        int left = start;\n        int right = nums.length - 1;\n        while (left < right) {\n            swap(nums, left++, right--);\n        }\n\n    }\n    private void swap(char[] nums, int i, int j) {\n        char temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n\n    }\n}"}
{"id": "1395", "path": "output2\\java\\Medium\\1395-maximum-distance-between-a-pair-of-values.java", "hypo_code": "class Solution {\n    public int maxDistance(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int m = nums2.length;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int left = i;\n            int right = m - 1;\n            while (left < right) {\n                int mid = left + (right - left + 1) / 2;\n                if (nums1[i] <= nums2[mid]) {\n                    left = mid;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            if (nums1[i] <= nums2[left]) {\n                res = Math.max(res, left - i);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1396", "path": "output2\\java\\Medium\\1396-maximum-subarray-min-product.java", "hypo_code": "class Solution {\n    public int maxSumMinProduct(int[] nums) {\n        int n = nums.length;\n        long[] preSum = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            preSum[i + 1] = preSum[i] + nums[i];\n        }\n        long res = 0;\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i <= n; i++) {\n            while (!stack.isEmpty() && (i == n || nums[stack.peek()] > nums[i])) {\n                int cur = stack.pop();\n                int left = stack.isEmpty() ? 0 : stack.peek() + 1;\n                int right = i - 1;\n                res = Math.max(res, (preSum[right + 1] - preSum[left]) * nums[cur]);\n            }\n            stack.push(i);\n        }\n        return (int)(res % 1000000007);\n    }\n}"}
{"id": "1397", "path": "output2\\java\\Medium\\1397-incremental-memory-leak.java", "hypo_code": "class Solution {\n    public int[] memLeak(int memory1, int memory2) {\n        int crashTime = 1;\n        while (memory1 >= crashTime || memory2 >= crashTime) {\n            if (memory1 >= memory2) {\n                memory1 -= crashTime;\n            } else {\n                memory2 -= crashTime;\n            }\n            crashTime++;\n        }\n        return new int[]{crashTime, memory1, memory2};\n    }\n}"}
{"id": "1398", "path": "output2\\java\\Medium\\1398-rotating-the-box.java", "hypo_code": "class Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] res = new char[n][m];\n        for (int i = 0; i < m; i++) {\n            int j = n - 1;\n            int k = n - 1;\n            while (j >= 0) {\n                if (box[i][j] == '*') {\n                    k = j - 1;\n                } else if (box[i][j] == '#') {\n                    box[i][j] = '.';\n                    box[i][k] = '#';\n                    k--;\n                }\n                j--;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int j = 0;\n            int k = m - 1;\n            while (j < m) {\n                res[i][j] = box[k][i];\n                j++;\n                k--;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1399", "path": "output2\\java\\Medium\\1399-minimum-number-of-swaps-to-make-the-binary-string-alternating.java", "hypo_code": "class Solution {\n    public int minSwaps(String s) {\n        int n = s.length();\n        int[] ones = new int[n + 1];\n        int[] zeros = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            ones[i + 1] = ones[i] + (s.charAt(i) == '1' ? 1 : 0);\n            zeros[i + 1] = zeros[i] + (s.charAt(i) == '0' ? 1 : 0);\n        }\n        if (Math.abs(ones[n] - zeros[n]) > 1) {\n            return -1;\n        }\n        if (ones[n] == zeros[n]) {\n            int res = Integer.MAX_VALUE;\n            for (int i = 0; i < n; i++) {\n                if (i % 2 == 0 && s.charAt(i) == '1' || i % 2 == 1 && s.charAt(i) == '0') {\n                    res = Math.min(res, ones[i + 1] + zeros[n] - zeros[i + 1]);\n                }\n            }\n            return res;\n        } else if (ones[n] > zeros[n]) {\n            int res = Integer.MAX_VALUE;\n            for (int i = 0; i < n; i++) {\n                if (i % 2 == 0 && s.charAt(i) == '0' || i % 2 == 1 && s.charAt(i) == '1') {\n                    res = Math.min(res, ones[i + 1] + zeros[n] - zeros[i + 1]);\n                }\n            }\n            return res;\n        } else {\n            int res = Integer.MAX_VALUE;\n            for (int i = 0; i < n; i++) {\n                if (i % 2 == 0 && s.charAt(i) == '1' || i % 2 == 1 && s.charAt(i) == '0') {\n                    res = Math.min(res, ones[i + 1] + zeros[n] - zeros[i + 1]);\n                }\n            }\n            return res;\n    }\n}"}
{"id": "1401", "path": "output2\\java\\Medium\\1401-minimum-speed-to-arrive-on-time.java", "hypo_code": "class Solution {\n    public int minSpeedOnTime(int[] dist, double hour) {\n        int n = dist.length;\n        if (hour < n - 1) return -1;\n        int left = 1, right = (int)1e7;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (canArrive(dist, hour, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n    public boolean canArrive(int[] dist, double hour, int speed) {\n        double time = 0;\n        for (int i = 0; i < dist.length - 1; i++) {\n            time += Math.ceil(dist[i] * 1.0 / speed);\n        }\n        time += dist[dist.length - 1] * 1.0 / speed;\n        return time <= hour;\n    }\n}"}
{"id": "1402", "path": "output2\\java\\Medium\\1402-jump-game-vii.java", "hypo_code": "class Solution {\n    public boolean canReach(String s, int minJump, int maxJump) {\n        int n = s.length();\n        boolean[] dp = new boolean[n];\n        dp[0] = true;\n        int pre = 0;\n        for (int i = 1; i < n; i++) {\n            if (i >= minJump) {\n                pre += dp[i - minJump] ? 1 : 0;\n            }\n            if (i > maxJump) {\n                pre -= dp[i - maxJump - 1] ? 1 : 0;\n            }\n            dp[i] = pre > 0 && s.charAt(i) == '0';\n        }\n        return dp[n - 1];\n    }\n}"}
{"id": "1403", "path": "output2\\java\\Medium\\1403-minimize-maximum-pair-sum-in-array.java", "hypo_code": "class Solution {\n    public int minPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int res = 0;\n        for (int i = 0; i < nums.length / 2; i++) {\n            res = Math.max(res, nums[i] + nums[nums.length - 1 - i]);\n        }\n        return res;\n    }\n}"}
{"id": "1404", "path": "output2\\java\\Medium\\1404-get-biggest-three-rhombus-sums-in-a-grid.java", "hypo_code": "class Solution {\n    public int[] getBiggestThree(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][][] sum = new int[m][n][4];\n        sum[0][0][0] = grid[0][0];\n        sum[0][0][1] = grid[0][0];\n        sum[0][0][2] = grid[0][0];\n        sum[0][0][3] = grid[0][0];\n        for (int i = 1; i < m; i++) {\n            sum[i][0][0] = grid[i][0];\n            sum[i][0][1] = grid[i][0];\n            sum[i][0][2] = grid[i][0];\n            sum[i][0][3] = grid[i][0];\n            for (int j = 1; j < n; j++) {\n                sum[i][j][0] = sum[i - 1][j - 1][0] + grid[i][j];\n                sum[i][j][1] = sum[i - 1][j - 1][1] + grid[i][j];\n                sum[i][j][2] = sum[i - 1][j - 1][2] + grid[i][j];\n                sum[i][j][3] = sum[i - 1][j - 1][3] + grid[i][j];\n            }\n        }\n        for (int i = 1; i < m; i++) {\n            sum[i][n - 1][1] = grid[i][n - 1];\n            sum[i][n - 1][2] = grid[i][n - 1];\n            sum[i][n - 1][3] = grid[i][n - 1];\n            for (int j = n - 2; j >= 0; j--) {\n                sum[i][j][1] = sum[i - 1][j + 1][1] + grid[i][j];\n                sum[i][j][2] = sum[i - 1][j + 1][2] + grid[i][j];\n                sum[i][j][3] = sum[i - 1][j + 1][3] + grid[i][j];\n            }\n        }\n        for (int i = m - 2; i >= 0; i--) {\n            sum[i][n - 1][2] = grid[i][n - 1];\n            sum[i][n - 1][3] = grid[i][n - 1];\n            for (int j = n - 2; j >= 0; j--) {\n                sum[i][j][2] = sum[i + 1][j + 1][2] + grid[i][j];\n                sum[i][j][3] = sum[i + 1][j + 1][3] + grid[i][j];\n            }\n        }\n        for (int i = m - 2; i >= 0; i--) {\n            sum[i][0][3] = grid[i][0];\n            for (int j = 1; j < n; j++) {\n                sum[i][j][3] = sum[i + 1][j - 1][3] + grid[i][j];\n            }\n        }\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 3; j < n; j++) {\n                set.add(sum[i][j][0]);\n                set.add(sum[i][j][1]);\n                set.add(sum[i][j][2]);\n                set.add(sum[i][j][3]);\n            }\n        }\n        List<Integer> list = new ArrayList<>(set);\n        Collections.sort(list);\n        Collections.reverse(list);\n        int[] res = new int[Math.min(3, list.size())];\n        for (int i = 0; i < res.length; i++) {\n            res[i] = list.get(i);\n        }\n        return res;\n    }\n}"}
{"id": "1405", "path": "output2\\java\\Medium\\1405-maximum-value-after-insertion.java", "hypo_code": "class Solution {\n    public String maxValue(String n, int x) {\n        boolean isNegative = n.charAt(0) == '-';\n        int i = isNegative ? 1 : 0;\n        while (i < n.length()) {\n            if (isNegative) {\n                if (n.charAt(i) - '0' > x) {\n                    break;\n                }\n            } else {\n                if (n.charAt(i) - '0' < x) {\n                    break;\n                }\n            }\n            i++;\n        }\n        return n.substring(0, i) + x + n.substring(i);\n    }\n}"}
{"id": "1406", "path": "output2\\java\\Medium\\1406-process-tasks-using-servers.java", "hypo_code": "class Solution {\n    public int[] assignTasks(int[] servers, int[] tasks) {\n        int n = servers.length, m = tasks.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] == b[0] ? a[1] - b[1] : (a[0] - b[0])));\n        for (int i = 0; i < n; i++) {\n            pq.offer(new int[]{servers[i], i});\n        }\n        PriorityQueue<int[]> pq2 = new PriorityQueue<>((a, b) -> (a[0] == b[0] ? a[1] - b[1] : (a[0] - b[0])));\n        int[] res = new int[m];\n        int time = 0, index = 0;\n        while (index < m) {\n            while (!pq.isEmpty() && time >= pq.peek()[0]) {\n                pq2.offer(pq.poll());\n            }\n            if (pq2.isEmpty()) {\n                time = pq.peek()[0];\n                continue;\n            }\n            while (!pq2.isEmpty() && index < m && index <= time) {\n                int[] cur = pq2.poll();\n                res[index++] = cur[1];\n                time++;\n            }\n            while (!pq.isEmpty() && time >= pq.peek()[0]) {\n                pq2.offer(pq.poll());\n            }\n            while (!pq2.isEmpty() && index < m && index <= time) {\n                int[] cur = pq2.poll();\n                res[index++] = cur[1];\n                time++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1407", "path": "output2\\java\\Medium\\1407-egg-drop-with-2-eggs-and-n-floors.java", "hypo_code": "class Solution {\n    public int twoEggDrop(int n) {\n        int[][] dp = new int[2][n + 1];\n        for (int i = 1; i <= n; i++) {\n            dp[0][i] = i;\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = i * (i + 1) / 2;\n        }\n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i % 2][j] = Integer.MAX_VALUE;\n                for (int k = 1; k <= j; k++) {\n                    dp[i % 2][j] = Math.min(dp[i % 2][j], Math.max(dp[(i - 1) % 2][k - 1], dp[i % 2][j - k]) + 1);\n                }\n            }\n        }\n        return dp[n % 2][n];\n    }\n}"}
{"id": "1408", "path": "output2\\java\\Medium\\1408-reduction-operations-to-make-the-array-elements-equal.java", "hypo_code": "class Solution {\n    public int reductionOperations(int[] nums) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int res = 0, pre = 0;\n        for (int i = 1; i < n; i++) {\n            if (nums[i] != nums[i - 1]) {\n                res += i - pre;\n                pre = i;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1409", "path": "output2\\java\\Medium\\1409-minimum-number-of-flips-to-make-the-binary-string-alternating.java", "hypo_code": "class Solution {\n    public int minFlips(String s) {\n        int n = s.length();\n        int[] a = new int[2 * n];\n        for (int i = 0; i < n; i++) {\n            a[i] = a[i + n] = s.charAt(i) - '0';\n        }\n        int[] preSum = new int[2 * n + 1];\n        for (int i = 0; i < 2 * n; i++) {\n            preSum[i + 1] = preSum[i] + a[i];\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            int target = i % 2;\n            int sum = preSum[i + n] - preSum[i];\n            res = Math.min(res, sum - (preSum[i + 1 + sum] - preSum[i + 1]) + target);\n        }\n        return res;\n    }\n}"}
{"id": "1410", "path": "output2\\java\\Medium\\1410-find-the-student-that-will-replace-the-chalk.java", "hypo_code": "class Solution {\n    public int chalkReplacer(int[] chalk, int k) {\n        int n = chalk.length;\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += chalk[i];\n        }\n        k %= sum;\n        for (int i = 0; i < n; i++) {\n            if (chalk[i] > k) {\n                return i;\n            }\n            k -= chalk[i];\n        }\n        return -1;\n    }\n}"}
{"id": "1411", "path": "output2\\java\\Medium\\1411-largest-magic-square.java", "hypo_code": "class Solution {\n    public int largestMagicSquare(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][][] sum = new int[m][n][4];\n        sum[0][0][0] = grid[0][0];\n        sum[0][0][1] = grid[0][0];\n        sum[0][0][2] = grid[0][0];\n        sum[0][0][3] = grid[0][0];\n        for (int i = 1; i < m; i++) {\n            sum[i][0][0] = grid[i][0];\n            sum[i][0][1] = grid[i][0];\n            sum[i][0][2] = grid[i][0];\n            sum[i][0][3] = grid[i][0];\n            for (int j = 1; j < n; j++) {\n                sum[i][j][0] = sum[i - 1][j - 1][0] + grid[i][j];\n                sum[i][j][1] = sum[i - 1][j - 1][1] + grid[i][j];\n                sum[i][j][2] = sum[i - 1][j - 1][2] + grid[i][j];\n                sum[i][j][3] = sum[i - 1][j - 1][3] + grid[i][j];\n            }\n        }\n        for (int i = 1; i < m; i++) {\n            sum[i][n - 1][1] = grid[i][n - 1];\n            sum[i][n - 1][2] = grid[i][n - 1];\n            sum[i][n - 1][3] = grid[i][n - 1];\n            for (int j = n - 2; j >= 0; j--) {\n                sum[i][j][1] = sum[i - 1][j + 1][1] + grid[i][j];\n                sum[i][j][2] = sum[i - 1][j + 1][2] + grid[i][j];\n                sum[i][j][3] = sum[i - 1][j + 1][3] + grid[i][j];\n            }\n        }\n        for (int i = m - 2; i >= 0; i--) {\n            sum[i][n - 1][2] = grid[i][n - 1];\n            sum[i][n - 1][3] = grid[i][n - 1];\n            for (int j = n - 2; j >= 0; j--) {\n                sum[i][j][2] = sum[i + 1][j + 1][2] + grid[i][j];\n                sum[i][j][3] = sum[i + 1][j + 1][3] + grid[i][j];\n            }\n        }\n        for (int i = m - 2; i >= 0; i--) {\n            sum[i][0][3] = grid[i][0];\n            for (int j = 1; j < n; j++) {\n                sum[i][j][3] = sum[i + 1][j - 1][3] + grid[i][j];\n            }\n        }\n        for (int k = Math.min(m, n); k >= 1; k--) {\n            for (int i = k - 1; i < m; i++) {\n                for (int j = k - 1; j < n; j++) {\n                    if (check(sum, i, j, k)) {\n                        return k;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n    private boolean check(int[][][] sum, int i, int j, int k) {\n        int a = sum[i][j][0] - (j - k >= 0 ? sum[i][j - k][0] : 0);\n        int b = sum[i][j][1] - (i - k >= 0 ? sum[i - k][j][1] : 0);\n        int c = sum[i][j][2] - (i - k >= 0 && j - k >= 0 ? sum[i - k][j - k][2] : 0);\n        int d = sum[i][j][3] - (i - k >= 0 && j + k < sum[0].length ? sum[i - k][j + k][3] : 0);\n        return a == b && b == c && c == d;\n    }\n}"}
{"id": "1412", "path": "output2\\java\\Medium\\1412-maximum-number-of-removable-characters.java", "hypo_code": "class Solution {\n    public int maximumRemovals(String s, String p, int[] removable) {\n        int l = 0, r = removable.length;\n        while (l < r) {\n            int mid = l + (r - l + 1) / 2;\n            if (isSub(s, p, removable, mid)) {\n                l = mid;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return l;\n    }\n    \n    private boolean isSub(String s, String p, int[] removable, int k) {\n        int n = s.length(), m = p.length();\n        boolean[] removed = new boolean[n];\n        for (int i = 0; i < k; i++) {\n            removed[removable[i]] = true;\n        }\n        int j = 0;\n        for (int i = 0; i < n && j < m; i++) {\n            if (!removed[i] && s.charAt(i) == p.charAt(j)) {\n                j++;\n            }\n        }\n        return j == m;\n    }\n}"}
{"id": "1413", "path": "output2\\java\\Medium\\1413-merge-triplets-to-form-target-triplet.java", "hypo_code": "class Solution {\n    public boolean mergeTriplets(int[][] triplets, int[] target) {\n        int[] res = new int[3];\n        for (int[] triplet : triplets) {\n            if (triplet[0] <= target[0] && triplet[1] <= target[1] && triplet[2] <= target[2]) {\n                res[0] = Math.max(res[0], triplet[0]);\n                res[1] = Math.max(res[1], triplet[1]);\n                res[2] = Math.max(res[2], triplet[2]);\n            }\n        }\n        return res[0] == target[0] && res[1] == target[1] && res[2] == target[2];\n\n    }\n}"}
{"id": "1414", "path": "output2\\java\\Medium\\1414-find-a-peak-element-ii.java", "hypo_code": "class Solution {\n    public int[] findPeakGrid(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int l = 0, r = m - 1, mid = 0;\n        while (l < r) {\n            mid = l + (r - l) / 2;\n            if (mat[mid][n / 2] < mat[mid + 1][n / 2]) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        int[] res = new int[2];\n        res[0] = l;\n        l = 0;\n        r = n - 1;\n        while (l < r) {\n            mid = l + (r - l) / 2;\n            if (mat[n / 2][mid] < mat[n / 2][mid + 1]) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        res[1] = l;\n        return res;\n    }\n}"}
{"id": "1415", "path": "output2\\java\\Medium\\1415-the-number-of-full-rounds-you-have-played.java", "hypo_code": "class Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        int login = Integer.parseInt(loginTime.substring(0, 2)) * 60 + Integer.parseInt(loginTime.substring(3));\n        int logout = Integer.parseInt(logoutTime.substring(0, 2)) * 60 + Integer.parseInt(logoutTime.substring(3));\n        if (login > logout) {\n            logout += 24 * 60;\n        }\n        return Math.max(0, logout / 15 - (login + 14) / 15);\n    }\n}"}
{"id": "1416", "path": "output2\\java\\Medium\\1416-count-sub-islands.java", "hypo_code": "class Solution {\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\n        int m = grid1.length, n = grid1[0].length;\n        int res = 0;\n        boolean[][] visited = new boolean[m][n];\n        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n        Queue<int[]> q = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(visited[i], false);\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid2[i][j] == 1) {\n                    visited[i][j] = true;\n                    if (grid1[i][j] == 1) {\n                        q.offer(new int[]{i, j});\n                        while (!q.isEmpty()) {\n                            int[] cur = q.poll();\n                            for (int[] dir : dirs) {\n                                int x = cur[0] + dir[0];\n                                int y = cur[1] + dir[1];\n                                if (x >= 0 && x < m && y >= 0 && y < n && grid2[x][y] == 1 && !visited[x][y]) {\n                                    visited[x][y] = true;\n                                    if (grid1[x][y] == 1) {\n                                        q.offer(new int[]{x, y});\n                                    }\n                                }\n                            }\n                        }\n                        res++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1417", "path": "output2\\java\\Medium\\1417-minimum-absolute-difference-queries.java", "hypo_code": "class Solution {\n    public int[] minDifference(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int[][] count = new int[n + 1][101];\n        for (int i = 0; i < n; i++) {\n            count[i + 1] = count[i].clone();\n            count[i + 1][nums[i]]++;\n        }\n        int[] res = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            int[] query = queries[i];\n            int min = Integer.MAX_VALUE, pre = -1;\n            for (int j = 1; j <= 100; j++) {\n                if (count[query[1] + 1][j] - count[query[0]][j] > 0) {\n                    if (pre != -1) {\n                        min = Math.min(min, j - pre);\n                    }\n                    pre = j;\n                }\n            }\n            res[i] = min == Integer.MAX_VALUE ? -1 : min;\n        }\n        return res;\n    }\n}"}
{"id": "1419", "path": "output2\\java\\Medium\\1419-remove-all-occurrences-of-a-substring.java", "hypo_code": "class Solution {\n    public String removeOccurrences(String s, String part) {\n        int n = s.length(), m = part.length();\n        char[] a = s.toCharArray(), b = part.toCharArray();\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            a[j++] = a[i];\n            if (j > 1 && a[j - 1] == b[m - 1]) {\n                boolean match = true;\n                for (int k = 0; k < m; k++) {\n                    if (a[j - m + k] != b[k]) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) {\n                    j -= m;\n                }\n            }\n        }\n        return new String(a, 0, j);\n    }\n}"}
{"id": "1420", "path": "output2\\java\\Medium\\1420-maximum-alternating-subsequence-sum.java", "hypo_code": "class Solution {\n    public long maxAlternatingSum(int[] nums) {\n         int n = nums.length;\n        long[][] dp = new long[n][2];\n        dp[0][0] = nums[0];\n        dp[0][1] = -nums[0];\n        long res = nums[0];\n        for (int i = 1; i < n; i++) {\n            dp[i][0] = Math.max(dp[i - 1][1] + nums[i], nums[i]);\n            dp[i][1] = Math.max(dp[i - 1][0] - nums[i], -nums[i]);\n            res = Math.max(res, Math.max(dp[i][0], dp[i][1]));\n        }\n        return res;\n    }\n}"}
{"id": "1421", "path": "output2\\java\\Medium\\1421-cyclically-rotating-a-grid.java", "hypo_code": "class Solution {\n    public int[][] rotateGrid(int[][] grid, int k) {\n        int m = grid.length, n = grid[0].length;\n        int[][] res = new int[m][n];\n        int l = 0, r = n - 1, u = 0, d = m - 1;\n        while (l < r && u < d) {\n            int len = (r - l + 1) * 2 + (d - u - 1) * 2;\n            int[] arr = new int[len];\n            int idx = 0;\n            for (int i = l; i <= r; i++) {\n                arr[idx++] = grid[u][i];\n            }\n            for (int i = u + 1; i <= d; i++) {\n                arr[idx++] = grid[i][r];\n            }\n            for (int i = r - 1; i >= l; i--) {\n                arr[idx++] = grid[d][i];\n            }\n            for (int i = d - 1; i >= u + 1; i--) {\n                arr[idx++] = grid[i][l];\n            }\n            int offset = k % len;\n            idx = 0;\n            for (int i = l; i <= r; i++) {\n                res[u][i] = arr[(idx + offset) % len];\n                idx++;\n            }\n            for (int i = u + 1; i <= d; i++) {\n                res[i][r] = arr[(idx + offset) % len];\n                idx++;\n            }\n            for (int i = r - 1; i >= l; i--) {\n                res[d][i] = arr[(idx + offset) % len];\n                idx++;\n            }\n            for (int i = d - 1; i >= u + 1; i--) {\n                res[i][l] = arr[(idx + offset) % len];\n                idx++;\n            }\n            l++;\n            r--;\n            u++;\n            d--;\n        }\n        if (l == r) {\n            for (int i = u; i <= d; i++) {\n                res[i][l] = grid[i][l];\n            }\n        } else if (u == d) {\n            for (int i = l; i <= r; i++) {\n                res[u][i] = grid[u][i];\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1422", "path": "output2\\java\\Medium\\1422-number-of-wonderful-substrings.java", "hypo_code": "class Solution {\n    public long wonderfulSubstrings(String word) {    \n        int[] cnt = new int[1024];\n        cnt[0] = 1;\n        int mask = 0;\n        long res = 0;\n        for (char c : word.toCharArray()) {\n            mask ^= 1 << (c - 'a');\n            res += cnt[mask];\n            for (int i = 0; i < 10; i++) {\n                res += cnt[mask ^ (1 << i)];\n            }\n            cnt[mask]++;\n        }\n        return res;\n    }\n}"}
{"id": "1423", "path": "output2\\java\\Medium\\1423-eliminate-maximum-number-of-monsters.java", "hypo_code": "class Solution {\n    public int eliminateMaximum(int[] dist, int[] speed) {\n        int n = dist.length;\n        int[] time = new int[n];\n        for (int i = 0; i < n; i++) {\n            time[i] = (dist[i] - 1) / speed[i];\n        }\n        Arrays.sort(time);\n        for (int i = 0; i < n; i++) {\n            if (time[i] < i) {\n                return i;\n            }\n        }\n        return n;\n    }\n}"}
{"id": "1424", "path": "output2\\java\\Medium\\1424-count-good-numbers.java", "hypo_code": "class Solution {\n    public int countGoodNumbers(long n) {\n        long res = 1;\n        long mod = 1000000007;\n        long a = 20;\n        long b = 5;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                res = (res * a) % mod;\n            }\n            a = (a * a) % mod;\n            n >>= 1;\n        }\n        return (int)res;\n    }\n}"}
{"id": "1425", "path": "output2\\java\\Medium\\1425-nearest-exit-from-entrance-in-maze.java", "hypo_code": "class Solution {\n    public int nearestExit(char[][] maze, int[] entrance) {\n        int m = maze.length, n = maze[0].length;\n        boolean[][] visited = new boolean[m][n];\n        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(entrance);\n        visited[entrance[0]][entrance[1]] = true;\n        int res = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            res++;\n            while (size-- > 0) {\n                int[] cur = q.poll();\n                for (int[] dir : dirs) {\n                    int x = cur[0] + dir[0];\n                    int y = cur[1] + dir[1];\n                    if (x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == '.' && !visited[x][y]) {\n                        if (x == 0 || x == m - 1 || y == 0 || y == n - 1) {\n                            return res;\n                        }\n                        visited[x][y] = true;\n                        q.offer(new int[]{x, y});\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "1426", "path": "output2\\java\\Medium\\1426-sum-game.java", "hypo_code": "class Solution {\n    public boolean sumGame(String num) {\n        int n = num.length();\n        int left = 0, right = 0, leftq = 0, rightq = 0;\n        for (int i = 0; i < n / 2; i++) {\n            if (num.charAt(i) == '?') {\n                leftq++;\n            } else {\n                left += num.charAt(i) - '0';\n            }\n        }\n        for (int i = n / 2; i < n; i++) {\n            if (num.charAt(i) == '?') {\n                rightq++;\n            } else {\n                right += num.charAt(i) - '0';\n            }\n        }\n        if ((leftq + rightq) % 2 == 1) {\n            return true;\n        }\n        int diff = Math.abs(left - right);\n        if (diff % 2 == 1) {\n            return true;\n        }\n        int q = (leftq + rightq) / 2;\n        if (left > right) {\n            left -= q;\n        } else {\n            right -= q;\n        }\n        return Math.abs(left - right) > q;\n    }\n}"}
{"id": "1427", "path": "output2\\java\\Medium\\1427-unique-length-3-palindromic-subsequences.java", "hypo_code": "class Solution {\n    public int countPalindromicSubsequence(String s) {\n        int res = 0;\n        for (char c = 'a'; c <= 'z'; c++) {\n            int l = s.indexOf(c), r = s.lastIndexOf(c);\n            if (l != -1 && r != -1 && l != r) {\n                res += s.substring(l + 1, r).chars().distinct().count();\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1429", "path": "output2\\java\\Medium\\1429-add-minimum-number-of-rungs.java", "hypo_code": "class Solution {\n    public int addRungs(int[] rungs, int dist) {\n        int res = 0, cur = 0;\n        for (int i = 0; i < rungs.length; i++) {\n            if (cur + dist < rungs[i]) {\n                res += (rungs[i] - cur - 1) / dist;\n            }\n            cur = rungs[i];\n        }\n        return res;\n    }\n}"}
{"id": "1430", "path": "output2\\java\\Medium\\1430-maximum-number-of-points-with-cost.java", "hypo_code": "class Solution {\n    public long maxPoints(int[][] points) {\n        int m = points.length, n = points[0].length;\n        long[][] dp = new long[m][n];\n        for (int i = 0; i < n; i++) {\n            dp[0][i] = points[0][i];\n        }\n        for (int i = 1; i < m; i++) {\n            long[] left = new long[n], right = new long[n];\n            left[0] = dp[i - 1][0];\n            for (int j = 1; j < n; j++) {\n                left[j] = Math.max(left[j - 1] - 1, dp[i - 1][j]);\n            }\n            right[n - 1] = dp[i - 1][n - 1];\n            for (int j = n - 2; j >= 0; j--) {\n                right[j] = Math.max(right[j + 1] - 1, dp[i - 1][j]);\n            }\n            for (int j = 0; j < n; j++) {\n                dp[i][j] = Math.max(left[j], right[j]) + points[i][j];\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            res = Math.max(res, dp[m - 1][i]);\n        }\n        return res;\n    }\n}"}
{"id": "1431", "path": "output2\\java\\Medium\\1431-the-number-of-the-smallest-unoccupied-chair.java", "hypo_code": "class Solution {\n    public int smallestChair(int[][] times, int targetFriend) {\n        int n = times.length;\n        int[] target = times[targetFriend];\n        Arrays.sort(times, (a, b) -> a[0] - b[0]);\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int i = 0; i < n; i++) {\n            if (pq.isEmpty()) {\n                pq.offer(0);\n            } else if (times[i][0] >= target[0]) {\n                break;\n            } else {\n                pq.offer(pq.poll() + 1);\n            }\n        }\n        return pq.peek();\n    }\n}"}
{"id": "1432", "path": "output2\\java\\Medium\\1432-describe-the-painting.java", "hypo_code": "class Solution {\n    public List<List<Long>> splitPainting(int[][] segments) {\n        Map<Integer, Long> map = new HashMap<>();\n        for (int[] segment : segments) {\n            map.put(segment[0], map.getOrDefault(segment[0], 0L) + segment[2]);\n            map.put(segment[1], map.getOrDefault(segment[1], 0L) - segment[2]);\n        }\n        List<List<Long>> res = new ArrayList<>();\n        long sum = 0, start = 0;\n        for (int key : map.keySet()) {\n            if (sum > 0) {\n                res.add(Arrays.asList(start, (long)key, sum));\n            }\n            sum += map.get(key);\n            start = key;\n        }\n        return res;\n    }\n}"}
{"id": "1433", "path": "output2\\java\\Medium\\1433-largest-number-after-mutating-substring.java", "hypo_code": "class Solution {\n    public String maximumNumber(String num, int[] change) {\n        StringBuilder sb = new StringBuilder();\n        boolean changed = false;\n        for (int i = 0; i < num.length(); i++) {\n            int digit = num.charAt(i) - '0';\n            if (!changed && change[digit] > digit) {\n                sb.append(change[digit]);\n                changed = true;\n            } else if (changed && change[digit] >= digit) {\n                sb.append(change[digit]);\n            } else {\n                sb.append(digit);\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1434", "path": "output2\\java\\Medium\\1434-maximum-compatibility-score-sum.java", "hypo_code": "class Solution {\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\n        int m = students.length, n = students[0].length;\n        int[] studentScore = new int[m];\n        for (int i = 0; i < m; i++) {\n            int score = 0;\n            for (int j = 0; j < n; j++) {\n                if (students[i][j] == mentors[i][j]) {\n                    score++;\n                }\n            }\n            studentScore[i] = score;\n        }\n        int[] mentorScore = new int[m];\n        for (int i = 0; i < m; i++) {\n            int score = 0;\n            for (int j = 0; j < n; j++) {\n                if (students[j][i] == mentors[j][i]) {\n                    score++;\n                }\n            }\n            mentorScore[i] = score;\n        }\n        int res = 0;\n        boolean[] visited = new boolean[m];\n        return dfs(studentScore, mentorScore, visited, 0);\n    }\n    private int dfs(int[] studentScore, int[] mentorScore, boolean[] visited, int index) {\n        if (index == studentScore.length) {\n            return 0;\n        }\n        int res = 0;\n        for (int i = 0; i < mentorScore.length; i++) {\n            if (visited[i]) {\n                continue;\n            }\n            visited[i] = true;\n            res = Math.max(res, studentScore[index] + mentorScore[i] + dfs(studentScore, mentorScore, visited, index + 1));\n            visited[i] = false;\n        }\n        return res;\n    }\n}"}
{"id": "1435", "path": "output2\\java\\Medium\\1435-maximum-number-of-weeks-for-which-you-can-work.java", "hypo_code": "class Solution {\n    public long numberOfWeeks(int[] milestones) {\n        long sum = 0, max = 0;\n        for (int milestone : milestones) {\n            sum += milestone;\n            max = Math.max(max, milestone);\n        }\n        long rest = sum - max;\n        if (max > rest + 1) {\n            return rest * 2 + 1;\n        } else {\n            return sum;\n        }\n    }\n}"}
{"id": "1436", "path": "output2\\java\\Medium\\1436-minimum-garden-perimeter-to-collect-enough-apples.java", "hypo_code": "class Solution {\n    public long minimumPerimeter(long neededApples) {\n        long l = 0, r = 100000;\n        while (l < r) {\n            long mid = l + (r - l) / 2;\n            if (mid * (mid + 1) * (mid + 2) * 2 >= neededApples) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l * 8;\n    }\n}"}
{"id": "1437", "path": "output2\\java\\Medium\\1437-check-if-move-is-legal.java", "hypo_code": "class Solution {\n    public boolean checkMove(char[][] board, int rMove, int cMove, char color) {\n        int m = board.length, n = board[0].length;\n        board[rMove][cMove] = color;\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}, {-1, -1}, {-1, 1}, {1, 1}, {1, -1}};\n        for (int[] dir : dirs) {\n            int x = rMove + dir[0];\n            int y = cMove + dir[1];\n            int count = 0;\n            while (x >= 0 && x < m && y >= 0 && y < n && board[x][y] != '.' && board[x][y] != color) {\n                count++;\n                x += dir[0];\n                y += dir[1];\n            }\n            if (count > 0 && x >= 0 && x < m && y >= 0 && y < n && board[x][y] == color) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}
{"id": "1438", "path": "output2\\java\\Medium\\1438-minimum-total-space-wasted-with-k-resizing-operations.java", "hypo_code": "class Solution {\n    public int minSpaceWastedKResizing(int[] nums, int k) {\n        int n = nums.length;\n        int[][] dp = new int[n][k + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);\n        }\n        int[] max = new int[n];\n        max[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            max[i] = Math.max(max[i - 1], nums[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = max[i] * (i + 1) - sum(nums, 0, i);\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j <= k; j++) {\n                for (int l = 0; l < i; l++) {\n                    dp[i][j] = Math.min(dp[i][j], dp[l][j - 1] + max[l] * (i - l) - sum(nums, l + 1, i));\n                }\n            }\n        }\n        return dp[n - 1][k];\n    }\n    private int sum(int[] nums, int l, int r) {\n        int res = 0;\n        for (int i = l; i <= r; i++) {\n            res += nums[i];\n        }\n        return res;\n    }\n}"}
{"id": "1439", "path": "output2\\java\\Medium\\1439-remove-stones-to-minimize-the-total.java", "hypo_code": "class Solution {\n    public int minStoneSum(int[] piles, int k) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\n        int sum = 0;\n        for (int pile : piles) {\n            pq.add(pile);\n            sum += pile;\n        }\n        for (int i = 0; i < k; i++) {\n            int cur = pq.poll();\n            pq.add(cur - cur / 2);\n            sum -= cur / 2;\n        }\n        return sum;\n    }\n}"}
{"id": "1440", "path": "output2\\java\\Medium\\1440-minimum-number-of-swaps-to-make-the-string-balanced.java", "hypo_code": "class Solution {\n    public int minSwaps(String s) {\n        int n = s.length();\n        int res = 0, cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '[') {\n                cnt++;\n            } else {\n                cnt--;\n                if (cnt < 0) {\n                    res++;\n                    cnt = 1;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1441", "path": "output2\\java\\Medium\\1441-array-with-elements-not-equal-to-average-of-neighbors.java", "hypo_code": "class Solution {\n    public int[] rearrangeArray(int[] nums) {\n        Arrays.sort(nums);\n        int[] res = new int[nums.length];\n        int i = 0, j = 0;\n        while (i < nums.length) {\n            res[i] = nums[j];\n            i += 2;\n            j++;\n        }\n        i = 1;\n        while (i < nums.length) {\n            res[i] = nums[j];\n            i += 2;\n            j++;\n        }\n        return res;\n    }\n}"}
{"id": "1442", "path": "output2\\java\\Medium\\1442-minimum-non-zero-product-of-the-array-elements.java", "hypo_code": "class Solution {\n    public int minNonZeroProduct(int p) {\n        long mod = 1000000007;\n        long max = (1L << p) - 1;\n        long res = (max - 1) % mod;\n        res = res * quickPow(max - 2, (max - 1) / 2) % mod;\n        return (int)res;\n    }\n    public long quickPow(long a, long b) {\n        long mod = 1000000007;\n        long res = 1;\n        while (b > 0) {\n            if (b % 2 == 1) res = res * a % mod;\n            a = a * a % mod;\n            b /= 2;\n        }\n        return res;\n    }\n}"}
{"id": "1443", "path": "output2\\java\\Medium\\1443-maximum-matrix-sum.java", "hypo_code": "class Solution {\n    public long maxMatrixSum(int[][] matrix) {\n        int n = matrix.length;\n        int min = Integer.MAX_VALUE;\n        long res = 0, cnt = 0;\n        for (int[] row : matrix) {\n            for (int num : row) {\n                res += Math.abs(num);\n                min = Math.min(min, Math.abs(num));\n                cnt += num < 0 ? 1 : 0;\n            }\n        }\n        return cnt % 2 == 0 ? res : res - 2 * min;\n    }\n}"}
{"id": "1444", "path": "output2\\java\\Medium\\1444-number-of-ways-to-arrive-at-destination.java", "hypo_code": "class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int mod = (int)1e9 + 7;\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n        long[] count = new long[n];\n        count[0] = 1;\n        Map<Integer, List<int[]>> map = new HashMap<>();\n        for (int[] road : roads) {\n            map.putIfAbsent(road[0], new ArrayList<>());\n            map.putIfAbsent(road[1], new ArrayList<>());\n            map.get(road[0]).add(new int[]{road[1], road[2]});\n            map.get(road[1]).add(new int[]{road[0], road[2]});\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{0, 0});\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int u = cur[0], d = cur[1];\n            if (d > dist[u]) continue;\n            for (int[] next : map.get(u)) {\n                int v = next[0], w = next[1];\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    pq.offer(new int[]{v, dist[v]});\n                    count[v] = count[u];\n                } else if (d + w == dist[v]) {\n                    count[v] = (count[v] + count[u]) % mod;\n                }\n            }\n        }\n        return (int)count[n - 1];\n    }\n}"}
{"id": "1445", "path": "output2\\java\\Medium\\1445-find-unique-binary-string.java", "hypo_code": "class Solution {\n    public String findDifferentBinaryString(String[] nums) {\n        int n = nums.length;\n        Set<Integer> set = new HashSet<>();\n        for (String num : nums) {\n            set.add(Integer.parseInt(num, 2));\n        }\n        for (int i = 0; i < (1 << n); i++) {\n            if (!set.contains(i)) {\n                StringBuilder sb = new StringBuilder();\n                for (int j = 0; j < n; j++) {\n                    sb.append(((i >> j) & 1) == 0 ? '0' : '1');\n                }\n                return sb.toString();\n            }\n        }\n        return \"\";\n    }\n}"}
{"id": "1446", "path": "output2\\java\\Medium\\1446-minimize-the-difference-between-target-and-chosen-elements.java", "hypo_code": "class Solution {\n    public int minimizeTheDifference(int[][] mat, int target) {\n        int m = mat.length, n = mat[0].length;\n        Set<Integer> set = new HashSet<>();\n        set.add(0);\n        for (int i = 0; i < m; i++) {\n            Set<Integer> temp = new HashSet<>();\n            for (int j = 0; j < n; j++) {\n                for (int num : set) {\n                    temp.add(num + mat[i][j]);\n                }\n            }\n            set = temp;\n        }\n        int res = Integer.MAX_VALUE;\n        for (int num : set) {\n            res = Math.min(res, Math.abs(num - target));\n        }\n        return res;\n    }\n}"}
{"id": "1447", "path": "output2\\java\\Medium\\1447-find-the-kth-largest-integer-in-the-array.java", "hypo_code": "class Solution {\n    public String kthLargestNumber(String[] nums, int k) {\n        Arrays.sort(nums, (a, b) -> {\n            if (a.length() != b.length()) {\n                return b.length() - a.length();\n            }\n            return b.compareTo(a);\n        });\n        return nums[k - 1];\n    }\n}"}
{"id": "1448", "path": "output2\\java\\Medium\\1448-minimum-number-of-work-sessions-to-finish-the-tasks.java", "hypo_code": "class Solution {\n    public int minSessions(int[] tasks, int sessionTime) {\n        int n = tasks.length;\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, n);\n        for (int i = 1; i < 1 << n; i++) {\n            int sum = 0, k = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i >> j & 1) == 1) {\n                    sum += tasks[j];\n                    k++;\n                }\n            }\n            if (sum <= sessionTime) {\n                dp[i] = 1;\n                continue;\n            }\n            for (int j = i; j > 0; j = (j - 1) & i) {\n                if (dp[j] + dp[i ^ j] < dp[i]) {\n                    dp[i] = dp[j] + dp[i ^ j];\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1449", "path": "output2\\java\\Medium\\1449-find-all-groups-of-farmland.java", "hypo_code": "class Solution {\n    public int[][] findFarmland(int[][] land) {\n        int m = land.length, n = land[0].length;\n        boolean[][] visited = new boolean[m][n];\n        int[][] res = new int[m * n][4];\n        int idx = 0;\n        int[][] dirs = {{0, 1}, {1, 0}};\n        Queue<int[]> q = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(visited[i], false);\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && land[i][j] == 1) {\n                    visited[i][j] = true;\n                    q.offer(new int[]{i, j});\n                    int[] farmland = new int[4];\n                    farmland[0] = i;\n                    farmland[1] = j;\n                    farmland[2] = i;\n                    farmland[3] = j;\n                    while (!q.isEmpty()) {\n                        int[] cur = q.poll();\n                        for (int[] dir : dirs) {\n                            int x = cur[0] + dir[0];\n                            int y = cur[1] + dir[1];\n                            if (x >= 0 && x < m && y >= 0 && y < n && land[x][y] == 1 && !visited[x][y]) {\n                                visited[x][y] = true;\n                                q.offer(new int[]{x, y});\n                                farmland[2] = Math.max(farmland[2], x);\n                                farmland[3] = Math.max(farmland[3], y);\n                            }\n                        }\n                    }\n                    res[idx++] = farmland;\n                }\n            }\n        }\n        int[][] ans = new int[idx][4];\n        for (int i = 0; i < idx; i++) {\n            ans[i] = res[i];\n        }\n        return ans;\n    }\n}"}
{"id": "1451", "path": "output2\\java\\Medium\\1451-the-number-of-weak-characters-in-the-game.java", "hypo_code": "class Solution {\n    public int numberOfWeakCharacters(int[][] properties) {\n        Arrays.sort(properties, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n        int res = 0, maxDef = 0;\n        for (int i = properties.length - 1; i >= 0; i--) {\n            if (properties[i][1] < maxDef) {\n                res++;\n            }\n            maxDef = Math.max(maxDef, properties[i][1]);\n        }\n        return res;\n    }\n}"}
{"id": "1452", "path": "output2\\java\\Medium\\1452-first-day-where-you-have-been-in-all-the-rooms.java", "hypo_code": "class Solution {\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\n        \n    }\n}"}
{"id": "1453", "path": "output2\\java\\Medium\\1453-number-of-pairs-of-interchangeable-rectangles.java", "hypo_code": "class NumberOfPairsOfInterchangeableRectangles {\n    public long interchangeableRectangles(int[][] rectangles) {\n        Map<Double, Integer> map = new HashMap<>();\n        for(int[] rectangle : rectangles){\n            double ratio = (double)rectangle[0] / rectangle[1];\n            map.put(ratio, map.getOrDefault(ratio, 0) + 1);\n        }\n        long count = 0;\n        for(int value : map.values()){\n            count += (long)value * (value - 1) / 2;\n        }\n        return count;\n        \n    }\n}"}
{"id": "1454", "path": "output2\\java\\Medium\\1454-maximum-product-of-the-length-of-two-palindromic-subsequences.java", "hypo_code": "class MaximumProductOfTheLengthOfTwoPalindromicSubsequences {\n    public int maxProduct(String s) {\n        int n = s.length();\n        int[] dp = new int[1 << n];\n        for(int i = 0; i < (1 << n); i++){\n            String sub = \"\";\n            for(int j = 0; j < n; j++){\n                if((i & (1 << j)) != 0){\n                    sub += s.charAt(j);\n                }\n            }\n            if(isPalindrome(sub)){\n                dp[i] = sub.length();\n            }\n        }\n        int max = 0;\n        for(int i = 0; i < (1 << n); i++){\n            for(int j = i + 1; j < (1 << n); j++){\n                if((i & j) == 0){\n                    max = Math.max(max, dp[i] * dp[j]);\n                }\n            }\n        }\n        return max;\n        \n        \n    }\n}"}
{"id": "1455", "path": "output2\\java\\Medium\\1455-find-original-array-from-doubled-array.java", "hypo_code": "class FindOriginalArrayFromDoubledArray {\n    public int[] findOriginalArray(int[] changed) {\n        int n = changed.length;\n        if(n % 2 == 1){\n            return new int[0];\n        }\n        Arrays.sort(changed);\n        int[] res = new int[n / 2];\n        int count = 0;\n        for(int i = 0; i < n; i += 2){\n            if(changed[i] != changed[i + 1] || changed[i] % 2 == 1){\n                return new int[0];\n            }\n            res[count++] = changed[i] / 2;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1456", "path": "output2\\java\\Medium\\1456-maximum-earnings-from-taxi.java", "hypo_code": "class MaximumEarningsFromTaxi {\n    public long maxTaxiEarnings(int n, int[][] rides) {\n        Arrays.sort(rides, (a, b) -> a[0] - b[0]);\n        long[] dp = new long[rides.length + 1];\n        for(int i = 1; i < dp.length; i++){\n            dp[i] = Math.max(dp[i - 1], dp[i]);\n            int index = binarySearch(rides, rides[i - 1][1]);\n            dp[index] = Math.max(dp[index], dp[i - 1] + rides[i - 1][1] - rides[i - 1][0] + rides[i - 1][2]);\n        }\n        return dp[dp.length - 1];\n        \n        \n    }\n}"}
{"id": "1457", "path": "output2\\java\\Medium\\1457-sum-of-beauty-in-the-array.java", "hypo_code": "class SumOfBeautyInTheArray {\n    public int sumOfBeauties(int[] nums) {\n        int[] left = new int[nums.length];\n        int[] right = new int[nums.length];\n        int max = nums[0];\n        for(int i = 1; i < nums.length - 1; i++){\n            left[i] = max;\n            max = Math.max(max, nums[i]);\n        }\n        int min = nums[nums.length - 1];\n        for(int i = nums.length - 2; i > 0; i--){\n            right[i] = min;\n            min = Math.min(min, nums[i]);\n        }\n        int sum = 0;\n        for(int i = 1; i < nums.length - 1; i++){\n            if(nums[i] > left[i] && nums[i] < right[i]){\n                sum += 2;\n            }else if(nums[i] > nums[i - 1] && nums[i] < nums[i + 1]){\n                sum += 1;\n            }\n        }\n        return sum;\n        \n    }\n}"}
{"id": "1459", "path": "output2\\java\\Medium\\1459-grid-game.java", "hypo_code": "class Solution {\n    public long gridGame(int[][] grid) {\n        int n = grid[0].length;\n        long[] prefixSum = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            prefixSum[i] = prefixSum[i - 1] + grid[0][i - 1];\n        }\n        long res = Long.MAX_VALUE;\n        for (int i = 1; i <= n; i++) {\n            long firstRobot = prefixSum[n] - prefixSum[i];\n            long secondRobot = prefixSum[i - 1];\n            res = Math.min(res, Math.max(firstRobot, secondRobot));\n        }\n        return res;\n    }\n}"}
{"id": "1460", "path": "output2\\java\\Medium\\1460-check-if-word-can-be-placed-in-crossword.java", "hypo_code": "class Solution {\n    public boolean placeWordInCrossword(char[][] board, String word) {\n           int m = board.length, n = board[0].length;\n        char[] w = word.toCharArray();\n        for (int i = 0; i < m; i++) {\n            int j = 0;\n            while (j < n) {\n                if (board[i][j] == '#') {\n                    j++;\n                    continue;\n                }\n                int start = j;\n                while (j < n && board[i][j] != '#') {\n                    j++;\n                }\n                int end = j - 1;\n                if (end - start + 1 == w.length) {\n                    boolean match = true;\n                    for (int k = 0; k < w.length; k++) {\n                        if (board[i][start + k] != ' ' && board[i][start + k] != w[k]) {\n                            match = false;\n                            break;\n                        }\n                    }\n                    if (match) {\n                        return true;\n                    }\n                    match = true;\n                    for (int k = 0; k < w.length; k++) {\n                        if (board[i][end - k] != ' ' && board[i][end - k] != w[k]) {\n                            match = false;\n                            break;\n                        }\n                    }\n                    if (match) {\n                        return true;\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < n; j++) {\n            int i = 0;\n            while (i < m) {\n                if (board[i][j] == '#') {\n                    i++;\n                    continue;\n                }\n                int start = i;\n                while (i < m && board[i][j] != '#') {\n                    i++;\n                }\n                int end = i - 1;\n                if (end - start + 1 == w.length) {\n                    boolean match = true;\n                    for (int k = 0; k < w.length; k++) {\n                        if (board[start + k][j] != ' ' && board[start + k][j] != w[k]) {\n                            match = false;\n                            break;\n                        }\n                    }\n                    if (match) {\n                        return true;\n                    }\n                    match = true;\n                    for (int k = 0; k < w.length; k++) {\n                        if (board[end - k][j] != ' ' && board[end - k][j] != w[k]) {\n                            match = false;\n                            break;\n                        }\n    }\n}"}
{"id": "1461", "path": "output2\\java\\Medium\\1461-number-of-pairs-of-strings-with-concatenation-equal-to-target.java", "hypo_code": "class Solution {\n    public int numOfPairs(String[] nums, String target) {\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (target.startsWith(nums[i])) {\n                for (int j = 0; j < nums.length; j++) {\n                    if (i != j && target.equals(nums[i] + nums[j])) {\n                        res++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1462", "path": "output2\\java\\Medium\\1462-maximize-the-confusion-of-an-exam.java", "hypo_code": "class Solution {\n    public int maxConsecutiveAnswers(String answerKey, int k) {\n        int n = answerKey.length();\n        int left = 0, right = 0;\n        int[] cnt = new int[2];\n        int res = 0;\n        while (right < n) {\n            cnt[answerKey.charAt(right) - 'T']++;\n            while (Math.min(cnt[0], cnt[1]) > k) {\n                cnt[answerKey.charAt(left) - 'T']--;\n                left++;\n            }\n            res = Math.max(res, right - left + 1);\n            right++;\n        }\n        return res;\n    }\n}"}
{"id": "1463", "path": "output2\\java\\Medium\\1463-find-missing-observations.java", "hypo_code": "class Solution {\n    public int[] missingRolls(int[] rolls, int mean, int n) {\n        int m = rolls.length;\n        int sum = 0;\n        for (int roll : rolls) {\n            sum += roll;\n        }\n        int total = mean * (m + n) - sum;\n        if (total > 6 * n || total < n) {\n            return new int[0];\n        }\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = total / n;\n            total -= total / n;\n        }\n        return res;\n    }\n}"}
{"id": "1464", "path": "output2\\java\\Medium\\1464-stone-game-ix.java", "hypo_code": "class Solution {\n    public boolean stoneGameIX(int[] stones) {\n        int[] count = new int[3];\n        for (int stone : stones) {\n            count[stone % 3]++;\n        }\n        if (count[0] % 2 == 0) {\n            return count[1] > 0 && count[2] > 0;\n        }\n        return Math.abs(count[1] - count[2]) > 2;\n    }\n}"}
{"id": "1465", "path": "output2\\java\\Medium\\1465-minimum-operations-to-make-a-uni-value-grid.java", "hypo_code": "class Solution {\n    public int minOperations(int[][] grid, int x) {\n        int m = grid.length, n = grid[0].length;\n        int[] nums = new int[m * n];\n        int idx = 0;\n        for (int[] row : grid) {\n            for (int col : row) {\n                nums[idx++] = col;\n            }\n        }\n        Arrays.sort(nums);\n        int median = nums[idx / 2];\n        int res = 0;\n        for (int num : nums) {\n            if ((num - median) % x != 0) {\n                return -1;\n            }\n            res += Math.abs(num - median) / x;\n        }\n        return res;\n\n    }\n}"}
{"id": "1467", "path": "output2\\java\\Medium\\1467-remove-colored-pieces-if-both-neighbors-are-the-same-color.java", "hypo_code": "class Solution {\n    public boolean winnerOfGame(String colors) {\n        int a = 0, b = 0, n = colors.length();\n        for (int i = 1; i < n - 1; i++) {\n            if (colors.charAt(i) == colors.charAt(i - 1) && colors.charAt(i) == colors.charAt(i + 1)) {\n                if (colors.charAt(i) == 'A') {\n                    a++;\n                } else {\n                    b++;\n                }\n            }\n        }\n        return a > b;\n    }\n}"}
{"id": "1468", "path": "output2\\java\\Medium\\1468-the-time-when-the-network-becomes-idle.java", "hypo_code": "class Solution {\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\n        int n = patience.length;\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0});\n        Set<Integer> visited = new HashSet<>();\n        visited.add(0);\n        int res = 0;\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int node = cur[0], time = cur[1];\n            res = time;\n            for (int next : graph.get(node)) {\n                if (!visited.contains(next)) {\n                    visited.add(next);\n                    queue.offer(new int[]{next, time + 1});\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 1; i < n; i++) {\n            int time = res * 2 - (res * 2) % patience[i];\n            time += res * 2 % patience[i] == 0 ? 0 : patience[i];\n            ans = Math.max(ans, time + 1);\n        }\n        return ans;\n    }\n}"}
{"id": "1470", "path": "output2\\java\\Medium\\1470-count-number-of-maximum-bitwise-or-subsets.java", "hypo_code": "class Solution {\n    public int countMaxOrSubsets(int[] nums) {\n        int n = nums.length;\n        int max = 0;\n        for (int num : nums) {\n            max |= num;\n        }\n        int res = 0;\n        for (int i = 0; i < (1 << n); i++) {\n            int cur = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) != 0) {\n                    cur |= nums[j];\n                }\n            }\n            if (cur == max) {\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1471", "path": "output2\\java\\Medium\\1471-next-greater-numerically-balanced-number.java", "hypo_code": "class Solution {\n    public int nextBeautifulNumber(int n) {\n        String s = String.valueOf(n + 1);\n        int[] count = new int[10];\n        for (char c : s.toCharArray()) {\n            count[c - '0']++;\n        }\n        for (int i = 0; i <= 9; i++) {\n            if (count[i] != 0) {\n                count[i]--;\n                for (int j = 0; j <= 9; j++) {\n                    if (count[j] != 0) {\n                        count[j]--;\n                        for (int k = 0; k <= 9; k++) {\n                            if (count[k] != 0) {\n                                count[k]--;\n                                for (int l = 0; l <= 9; l++) {\n                                    if (count[l] != 0) {\n                                        count[l]--;\n                                        return i * 1000 + j * 100 + k * 10 + l;\n                                    }\n                                }\n                                count[k]++;\n                            }\n                        }\n                        count[j]++;\n                    }\n                }\n                count[i]++;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "1472", "path": "output2\\java\\Medium\\1472-count-nodes-with-the-highest-score.java", "hypo_code": "class Solution {\n    public int countHighestScoreNodes(int[] parents) {\n        int n = parents.length;\n        int[] res = new int[n];\n        for (int i = 1; i < n; i++) {\n            res[i] = 1;\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if (parents[i] != -1) {\n                res[parents[i]] += res[i];\n            }\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            max = Math.max(max, res[i]);\n        }\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (res[i] == max) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "1473", "path": "output2\\java\\Medium\\1473-two-best-non-overlapping-events.java", "hypo_code": "class Solution {\n    public int maxTwoEvents(int[][] events) {\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\n        int n = events.length;\n        int[] dp = new int[n];\n        dp[0] = events[0][2];\n        int max = dp[0];\n        for (int i = 1; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (events[mid][1] < events[i][0]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (events[l][1] < events[i][0]) {\n                dp[i] = Math.max(dp[i - 1], events[i][2]);\n            } else {\n                dp[i] = Math.max(dp[i - 1], dp[l] + events[i][2]);\n            }\n            max = Math.max(max, dp[i]);\n        }\n        return max;\n    }\n}"}
{"id": "1474", "path": "output2\\java\\Medium\\1474-plates-between-candles.java", "hypo_code": "class Solution {\n    public int[] platesBetweenCandles(String s, int[][] queries) {\n        int n = s.length();\n        int[] res = new int[queries.length];\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (s.charAt(i - 1) == '|') {\n                pre[i]++;\n            }\n        }\n        for (int i = 0; i < queries.length; i++) {\n            res[i] = pre[queries[i][1] + 1] - pre[queries[i][0]];\n        }\n        return res;\n    }\n}"}
{"id": "1475", "path": "output2\\java\\Medium\\1475-find-the-minimum-and-maximum-number-of-nodes-between-critical-points.java", "hypo_code": "class Solution {\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\n        int[] res = new int[2];\n        res[0] = -1;\n        res[1] = -1;\n        ListNode pre = head;\n        ListNode cur = head.next;\n        int i = 0;\n        while (cur != null) {\n            if (pre.val < cur.val && cur.val > cur.next.val) {\n                if (res[0] == -1) {\n                    res[0] = i;\n                } else {\n                    res[1] = i;\n                }\n            } else if (pre.val > cur.val && cur.val < cur.next.val) {\n                if (res[0] == -1) {\n                    res[0] = i;\n                } else {\n                    res[1] = i;\n                }\n            }\n            pre = cur;\n            cur = cur.next;\n            i++;\n        }\n        return res;\n    }\n}"}
{"id": "1476", "path": "output2\\java\\Medium\\1476-minimum-operations-to-convert-number.java", "hypo_code": "class Solution {\n    public int minimumOperations(int[] nums, int start, int goal) {\n        if (start == goal) {\n            return 0;\n        }\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(start, 0);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            int step = map.get(cur);\n            for (int num : nums) {\n                int next = cur + num;\n                if (next <= 1000 && !map.containsKey(next)) {\n                    map.put(next, step + 1);\n                    queue.offer(next);\n                }\n                next = cur - num;\n                if (next >= 0 && !map.containsKey(next)) {\n                    map.put(next, step + 1);\n                    queue.offer(next);\n                }\n                next = cur ^ num;\n                if (!map.containsKey(next)) {\n                    map.put(next, step + 1);\n                    queue.offer(next);\n                }\n            }\n            if (map.containsKey(goal)) {\n                return map.get(goal);\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "1477", "path": "output2\\java\\Medium\\1477-vowels-of-all-substrings.java", "hypo_code": "class Solution {\n    public long countVowels(String word) {\n        int n = word.length();\n        long[] pre = new long[n + 1];\n        int[] map = new int[26];\n        map['a' - 'a'] = 1;\n        map['e' - 'a'] = 1;\n        map['i' - 'a'] = 1;\n        map['o' - 'a'] = 1;\n        map['u' - 'a'] = 1;\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (map[word.charAt(i - 1) - 'a'] == 1) {\n                pre[i]++;\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j <= n; j++) {\n                res += pre[j] - pre[i];\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1478", "path": "output2\\java\\Medium\\1478-minimized-maximum-of-products-distributed-to-any-store.java", "hypo_code": "class Solution {\n    public int minimizedMaximum(int n, int[] quantities) {\n        int l = 0, r = 1000000000;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (check(quantities, n, mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n    \n    private boolean check(int[] quantities, int n, int mid) {\n        int count = 0;\n        for (int quantity : quantities) {\n            count += quantity / mid;\n            if (quantity % mid != 0) {\n                count++;\n            }\n        }\n        return count <= n;\n    }\n}"}
{"id": "1480", "path": "output2\\java\\Medium\\1480-most-beautiful-item-for-each-query.java", "hypo_code": "class MostBeautifulItemForEachQuery {\n    public int[] maximumBeauty(int[][] items, int[] queries) {\n        int[] ans = new int[queries.length];\n        int[] beauty = new int[100001];\n        for(int i = 0; i < items.length; i++){\n            beauty[items[i][0]] = Math.max(beauty[items[i][0]], items[i][1]);\n        }\n        for(int i = 1; i < beauty.length; i++){\n            beauty[i] = Math.max(beauty[i], beauty[i - 1]);\n        }\n        for(int i = 0; i < queries.length; i++){\n            ans[i] = beauty[queries[i]];\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1481", "path": "output2\\java\\Medium\\1481-reverse-nodes-in-even-length-groups.java", "hypo_code": "class ReverseNodesInEvenLengthGroups {\n    public ListNode reverseEvenLengthGroups(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode prev = dummy;\n        ListNode curr = head;\n        int count = 1;\n        while(curr != null){\n            if(count % 2 == 0){\n                ListNode next = curr.next;\n                curr.next = prev;\n                prev = curr;\n                curr = next;\n            }else{\n                ListNode next = curr.next;\n                curr.next = prev;\n                prev = curr;\n                curr = next;\n                count++;\n            }\n        }\n        return prev;\n        \n    }\n}"}
{"id": "1482", "path": "output2\\java\\Medium\\1482-decode-the-slanted-ciphertext.java", "hypo_code": "class Solution {\n    public String decodeCiphertext(String encodedText, int rows) {\n        StringBuilder sb = new StringBuilder();\n        int n = encodedText.length();\n        int cols = n / rows;\n        char[][] matrix = new char[rows][cols];\n        int index = 0;\n        for (int i = 0; i < cols; i++) {\n            if (i % 2 == 0) {\n                for (int j = 0; j < rows; j++) {\n                    matrix[j][i] = encodedText.charAt(index++);\n                }\n            } else {\n                for (int j = rows - 1; j >= 0; j--) {\n                    matrix[j][i] = encodedText.charAt(index++);\n                }\n            }\n        }\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols && matrix[i][j] != ' '; j++) {\n                sb.append(matrix[i][j]);\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1483", "path": "output2\\java\\Medium\\1483-watering-plants.java", "hypo_code": "class Solution {\n    public int wateringPlants(int[] plants, int capacity) {\n        int n = plants.length;\n        int res = 0;\n        int cur = capacity;\n        for (int i = 0; i < n; i++) {\n            if (cur < plants[i]) {\n                res += 2 * i + 1;\n                cur = capacity;\n            }\n            cur -= plants[i];\n        }\n        return res + n * 2;\n    }\n}"}
{"id": "1485", "path": "output2\\java\\Medium\\1485-minimum-number-of-food-buckets-to-feed-the-hamsters.java", "hypo_code": "class MinimumNumberOfFoodBucketsToFeedTheHamsters {\n    public int minimumBuckets(String hamsters) {\n        int count = 0;\n        int n = hamsters.length();\n        for(int i = 0; i < n; i++){\n            if(hamsters.charAt(i) == 'H'){\n                if(i == 0){\n                    if(hamsters.charAt(i + 1) == '.'){\n                        count++;\n                    }\n                }else if(i == n - 1){\n                    if(hamsters.charAt(i - 1) == '.'){\n                        count++;\n                    }\n                }else{\n                    if(hamsters.charAt(i - 1) == '.' && hamsters.charAt(i + 1) == '.'){\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1486", "path": "output2\\java\\Medium\\1486-minimum-cost-homecoming-of-a-robot-in-a-grid.java", "hypo_code": "class MinimumCostHomecomingOfARobotInAGrid {\n    public int minCost(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {\n        int[][] directions = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int[][] visited = new int[rowCosts.length][colCosts.length];\n        return dfs(startPos, homePos, rowCosts, colCosts, visited, directions);\n        \n        \n    }\n}"}
{"id": "1487", "path": "output2\\java\\Medium\\1487-k-radius-subarray-averages.java", "hypo_code": "class KRadiusSubarrayAverages {\n    public int[] getAverages(int[] nums, int k) {\n        int n = nums.length;\n        int[] res = new int[n];\n        int sum = 0;\n        for(int i = 0; i < n; i++){\n            if(i <= k){\n                sum += nums[i];\n                if(i == k){\n                    res[i - k] = sum / (k + 1);\n                }\n            }else{\n                sum += nums[i];\n                sum -= nums[i - k - 1];\n                res[i - k] = sum / (k + 1);\n            }\n        }\n        for(int i = n - k; i < n; i++){\n            sum -= nums[i - k - 1];\n            res[i] = sum / (n - i + k);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1488", "path": "output2\\java\\Medium\\1488-removing-minimum-and-maximum-from-array.java", "hypo_code": "class RemovingMinimumAndMaximumFromArray {\n    public int minimumDeletions(int[] nums) {\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for(int i = 0; i < nums.length; i++){\n            min = Math.min(min, nums[i]);\n            max = Math.max(max, nums[i]);\n        }\n        int minIndex = 0;\n        int maxIndex = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == min){\n                minIndex = i;\n            }\n            if(nums[i] == max){\n                maxIndex = i;\n            }\n        }\n        return Math.min(minIndex, nums.length - 1 - maxIndex);\n        \n    }\n}"}
{"id": "1489", "path": "output2\\java\\Medium\\1489-delete-the-middle-node-of-a-linked-list.java", "hypo_code": "class Solution {\n    public ListNode deleteMiddle(ListNode head) {\n        ListNode pre = head;\n        ListNode cur = head.next;\n        while (cur != null && cur.next != null) {\n            pre = pre.next;\n            cur = cur.next.next;\n        }\n        pre.next = pre.next.next;\n        return head;\n    }\n}"}
{"id": "1490", "path": "output2\\java\\Medium\\1490-step-by-step-directions-from-a-binary-tree-node-to-another.java", "hypo_code": "class Solution {\n    public String getDirections(TreeNode root, int startValue, int destValue) {\n        TreeNode start = find(root, startValue);\n        TreeNode dest = find(root, destValue);\n        List<Character> list = new ArrayList<>();\n        while (start != dest) {\n            if (start.val < dest.val) {\n                start = start.right;\n                list.add('R');\n            } else {\n                start = start.left;\n                list.add('L');\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for (char c : list) {\n            sb.append(c);\n        }\n        int n = sb.length();\n        for (int i = 0; i < n >> 1; i++) {\n            char temp = sb.charAt(i);\n            sb.setCharAt(i, sb.charAt(n - 1 - i));\n            sb.setCharAt(n - 1 - i, temp);\n        }\n        return sb.toString();\n    }\n    private TreeNode find(TreeNode root, int target) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val == target) {\n            return root;\n        }\n        TreeNode left = find(root.left, target);\n        if (left != null) {\n            return left;\n        }\n        TreeNode right = find(root.right, target);\n        if (right != null) {\n            return right;\n        }\n        return null;\n    }\n}"}
{"id": "1491", "path": "output2\\java\\Medium\\1491-find-good-days-to-rob-the-bank.java", "hypo_code": "class Solution {\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\n        int n = security.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (security[i - 1] > security[i]) {\n                pre[i]++;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (security[mid] < security[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (security[l] < security[i]) {\n                left[i] = i - l;\n            } else {\n                left[i] = i - l - 1;\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            int l = i + 1, r = n - 1;\n            while (l < r) {\n                int mid = l + r + 1 >> 1;\n                if (security[mid] < security[i]) {\n                    r = mid - 1;\n                } else {\n                    l = mid;\n                }\n            }\n            if (security[l] < security[i]) {\n                right[i] = l - i;\n            } else {\n                right[i] = l - i - 1;\n            }\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (left[i] >= time && right[i] >= time && pre[i - time + 1] == pre[i + time]) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1492", "path": "output2\\java\\Medium\\1492-detonate-the-maximum-bombs.java", "hypo_code": "class Solution {\n    public int maximumDetonation(int[][] bombs) {\n        int n = bombs.length;\n        int[] dp = new int[n];\n        dp[0] = 1;\n        int max = dp[0];\n        for (int i = 1; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (bombs[mid][0] + bombs[mid][2] < bombs[i][0]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (bombs[l][0] + bombs[l][2] < bombs[i][0]) {\n                dp[i] = Math.max(dp[i - 1], 1);\n            } else {\n                dp[i] = Math.max(dp[i - 1], dp[l] + 1);\n            }\n            max = Math.max(max, dp[i]);\n        }\n        return max;\n    }\n}"}
{"id": "1493", "path": "output2\\java\\Medium\\1493-sum-of-subarray-ranges.java", "hypo_code": "class Solution {\n    public long subArrayRanges(int[] nums) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        long res = 0;\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i - 2]) {\n                pre[i]++;\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums[l] < nums[i - 1]) {\n                res += pre[i - 1] - pre[l];\n            } else {\n                res += pre[i - 1] - pre[l] + 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1494", "path": "output2\\java\\Medium\\1494-watering-plants-ii.java", "hypo_code": "class Solution {\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\n        int n = plants.length;\n        int res = 0;\n        int curA = capacityA, curB = capacityB;\n        for (int i = 0, j = n - 1; i <= j; i++, j--) {\n            if (i == j) {\n                if (curA < plants[i] && curB < plants[i]) {\n                    res += 2;\n                } else if (curA < plants[i]) {\n                    res++;\n                }\n                break;\n            }\n            if (curA < plants[i]) {\n                res++;\n                curA = capacityA;\n            }\n            curA -= plants[i];\n            if (curB < plants[j]) {\n                res++;\n                curB = capacityB;\n            }\n            curB -= plants[j];\n        }\n        return res;\n    }\n}"}
{"id": "1495", "path": "output2\\java\\Medium\\1495-adding-spaces-to-a-string.java", "hypo_code": "class Solution {\n    public String addSpaces(String s, int[] spaces) {\n        StringBuilder sb = new StringBuilder();\n        int pre = 0;\n        for (int i = 0; i < spaces.length; i++) {\n            sb.append(s.substring(pre, spaces[i]));\n            sb.append(' ');\n            pre = spaces[i];\n        }\n        sb.append(s.substring(pre));\n        return sb.toString();\n    }\n}"}
{"id": "1496", "path": "output2\\java\\Medium\\1496-number-of-smooth-descent-periods-of-a-stock.java", "hypo_code": "class Solution {\n    public long getDescentPeriods(int[] prices) {\n        int n = prices.length;\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (prices[i - 1] > prices[i - 2]) {\n                pre[i]++;\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (prices[mid] < prices[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (prices[l] < prices[i]) {\n                res += pre[i] - pre[l];\n            } else {\n                res += pre[i] - pre[l] - 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1497", "path": "output2\\java\\Medium\\1497-find-all-possible-recipes-from-given-supplies.java", "hypo_code": "class FindAllPossibleRecipesFromGivenSupplies {\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\n        List<String> res = new ArrayList<>();\n        Map<String, List<String>> map = new HashMap<>();\n        for(int i = 0; i < recipes.length; i++){\n            map.put(recipes[i], ingredients.get(i));\n        }\n        for(String recipe : recipes){\n            if(canMake(map, recipe, new HashSet<>(Arrays.asList(supplies)))){\n                res.add(recipe);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1498", "path": "output2\\java\\Medium\\1498-check-if-a-parentheses-string-can-be-valid.java", "hypo_code": "class CheckIfAParenthesesStringCanBeValid {\n    public boolean canBeValid(String s, String locked) {\n        int[] count = new int[2];\n        for(int i = 0; i < s.length(); i++){\n            if(locked.charAt(i) == '0'){\n                if(s.charAt(i) == '('){\n                    count[0]++;\n                }else{\n                    count[1]++;\n                }\n            }\n        }\n        return count[0] == count[1];\n        \n    }\n}"}
{"id": "1499", "path": "output2\\java\\Medium\\1499-execution-of-all-suffix-instructions-staying-in-a-grid.java", "hypo_code": "class ExecutionOfAllSuffixInstructionsStayingInAGrid {\n    public int[] executeInstructions(int n, int[] startPos, String s) {\n        int[][] directions = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int[][] visited = new int[n][n];\n        int[] res = new int[s.length()];\n        for(int i = 0; i < s.length(); i++){\n            int[] dir = directions[getDirection(s.charAt(i))];\n            int x = startPos[0] + dir[0];\n            int y = startPos[1] + dir[1];\n            if(x < 0 || x >= n || y < 0 || y >= n){\n                res[i] = i;\n            }else{\n                res[i] = i + 1;\n                startPos[0] = x;\n                startPos[1] = y;\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1500", "path": "output2\\java\\Medium\\1500-intervals-between-identical-elements.java", "hypo_code": "class IntervalsBetweenIdenticalElements {\n    public long[] getDistances(int[] arr) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < arr.length; i++){\n            map.putIfAbsent(arr[i], new ArrayList<>());\n            map.get(arr[i]).add(i);\n        }\n        long[] res = new long[arr.length];\n        for(int i = 0; i < arr.length; i++){\n            long sum = 0;\n            for(int j = 0; j < map.get(arr[i]).size() - 1; j++){\n                sum += map.get(arr[i]).get(j + 1) - map.get(arr[i]).get(j);\n            }\n            res[i] = sum;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1501", "path": "output2\\java\\Medium\\1501-number-of-laser-beams-in-a-bank.java", "hypo_code": "class NumberOfLaserBeamsInABank {\n    public int numberOfBeams(String[] bank) {\n        int m = bank.length;\n        int n = bank[0].length();\n        int[][] dp = new int[m][n];\n        int res = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(bank[i].charAt(j) == '1'){\n                    dp[i][j] = 1;\n                    if(i > 0){\n                        dp[i][j] += dp[i - 1][j];\n                    }\n                    res += dp[i][j];\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1502", "path": "output2\\java\\Medium\\1502-destroying-asteroids.java", "hypo_code": "class DestroyingAsteroids {\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\n        int sum = 0;\n        for(int i = 0; i < asteroids.length; i++){\n            sum += asteroids[i];\n        }\n        return sum <= mass;\n        \n    }\n}"}
{"id": "1503", "path": "output2\\java\\Medium\\1503-maximum-twin-sum-of-a-linked-list.java", "hypo_code": "class Solution {\n    public int pairSum(ListNode head) {\n        int[] max = new int[1];\n        max[0] = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        dfs(head, max, map);\n        return max[0];\n    }\n\n    private int dfs(ListNode root, int[] max, Map<Integer, Integer> map) {\n        if (root == null) {\n            return 0;\n        }\n        int res = dfs(root.next, max, map);\n        if (map.containsKey(root.val)) {\n            max[0] = Math.max(max[0], map.get(root.val) + root.val);\n        }\n        map.put(res + root.val, Math.max(map.getOrDefault(res + root.val, 0), res));\n        return res + root.val;\n    }\n}"}
{"id": "1504", "path": "output2\\java\\Medium\\1504-longest-palindrome-by-concatenating-two-letter-words.java", "hypo_code": "class Solution {\n    public int longestPalindrome(String[] words) {\n        int n = words.length;\n        int[] map = new int[26];\n        for (String word : words) {\n            map[word.charAt(0) - 'a']++;\n        }\n        int res = 0;\n        for (int i = 0; i < 26; i++) {\n            res += map[i] / 2 * 2;\n        }\n        return res == n ? res : res + 1;\n    }\n}"}
{"id": "1505", "path": "output2\\java\\Medium\\1505-minimum-swaps-to-group-all-1s-together-ii.java", "hypo_code": "class Solution {\n    public int minSwaps(int[] nums) {\n        int n = nums.length;\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        if (sum == 0 || sum == n) {\n            return 0;\n        }\n        int l = 0, r = 0;\n        int count = 0;\n        int res = Integer.MAX_VALUE;\n        while (r < n) {\n            while (r < n && count < sum) {\n                count += nums[r++];\n            }\n            while (l < r && count > sum) {\n                count -= nums[l++];\n            }\n            if (count == sum) {\n                res = Math.min(res, r - l - sum);\n            }\n            count -= nums[l++];\n        }\n        return res;\n    }\n}"}
{"id": "1506", "path": "output2\\java\\Medium\\1506-count-words-obtained-after-adding-a-letter.java", "hypo_code": "class Solution {\n    public int wordCount(String[] startWords, String[] targetWords) {\n        int res = 0;\n        for (String target : targetWords) {\n            for (String start : startWords) {\n                if (isWord(start, target)) {\n                    res++;\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n    private boolean isWord(String start, String target) {\n        if (start.length() + 1 != target.length()) {\n            return false;\n        }\n        int[] map = new int[26];\n        for (char c : start.toCharArray()) {\n            map[c - 'a']++;\n        }\n        for (char c : target.toCharArray()) {\n            if (map[c - 'a'] == 0) {\n                return false;\n            }\n            map[c - 'a']--;\n        }\n        return true;\n    }\n}"}
{"id": "1507", "path": "output2\\java\\Medium\\1507-minimum-moves-to-reach-target-score.java", "hypo_code": "class Solution {\n    public int minMoves(int target, int maxDoubles) {\n        int res = 0;\n        while (target > 1) {\n            if (target % 2 == 0) {\n                target /= 2;\n            } else {\n                target--;\n            }\n            res++;\n        }\n        return res;\n    }\n}"}
{"id": "1508", "path": "output2\\java\\Medium\\1508-solving-questions-with-brainpower.java", "hypo_code": "class Solution {\n    public long mostPoints(int[][] questions) {\n        int n = questions.length;\n        int[] dp = new int[n];\n        dp[0] = questions[0][0];\n        int max = dp[0];\n        for (int i = 1; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (mid + questions[mid][1] >= i) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (l + questions[l][1] >= i) {\n                dp[i] = Math.max(dp[i - 1], questions[i][0]);\n            } else {\n                dp[i] = Math.max(dp[i - 1], dp[l] + questions[i][0]);\n            }\n            max = Math.max(max, dp[i]);\n        }\n        return max;\n    }\n}"}
{"id": "1509", "path": "output2\\java\\Medium\\1509-count-the-hidden-sequences.java", "hypo_code": "class Solution {\n    public int numberOfArrays(int[] differences, int lower, int upper) {\n        int n = differences.length;\n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            long sum = 0;\n            for (int j = i - 1; j >= 0; j--) {\n                if (differences[j] >= lower && differences[j] <= upper) {\n                    sum += dp[j];\n                }\n                if (differences[j] > upper) {\n                    break;\n                }\n            }\n            dp[i] = sum;\n        }\n        long res = 0;\n        for (int i = 0; i <= n; i++) {\n            res += dp[i];\n        }\n        return (int)res;\n    }\n}"}
{"id": "1510", "path": "output2\\java\\Medium\\1510-k-highest-ranked-items-within-a-price-range.java", "hypo_code": "class Solution {\n    public List<List<Integer>> highestRankedKItems(int[][] grid, int[] pricing, int[] start, int k) {  \n        int m = grid.length, n = grid[0].length;\n        int low = pricing[0], high = pricing[1];\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\n            if (a[1] != b[1]) {\n                return Integer.compare(a[1], b[1]);\n            }\n            if (a[0] != b[0]) {\n                return Integer.compare(a[0], b[0]);\n            }\n            if (a[2] != b[2]) {\n                return Integer.compare(a[2], b[2]);\n            }\n            return Integer.compare(a[3], b[3]);\n        });\n        pq.offer(new int[]{start[0], 0, start[1], grid[start[0]][start[1]]});\n        boolean[][] visited = new boolean[m][n];\n        visited[start[0]][start[1]] = true;\n        List<List<Integer>> res = new ArrayList<>();\n        while (!pq.isEmpty() && res.size() < k) {\n            int[] cur = pq.poll();\n            List<Integer> list = new ArrayList<>();\n            list.add(cur[0]);\n            list.add(cur[2]);\n            res.add(list);\n            for (int[] dir : dirs) {\n                int x = cur[0] + dir[0], y = cur[2] + dir[1];\n                if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || grid[x][y] < low || grid[x][y] > high) {\n                    continue;\n                }\n                visited[x][y] = true;\n                pq.offer(new int[]{x, cur[1] + 1, y, grid[x][y]});\n            }\n        }\n        return res;\n\n    }\n}"}
{"id": "1511", "path": "output2\\java\\Medium\\1511-rearrange-array-elements-by-sign.java", "hypo_code": "class Solution {\n    public int[] rearrangeArray(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        int[] pos = new int[n], neg = new int[n];\n        int p = 0, q = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > 0) {\n                pos[p++] = nums[i];\n            } else {\n                neg[q++] = -nums[i];\n            }\n        }\n        int l = 0, r = 0;\n        while (l < p && r < q) {\n            if (pos[l] < neg[r]) {\n                res[l + r] = pos[l++];\n            } else {\n                res[l + r] = -neg[r++];\n            }\n        }\n        while (l < p) {\n            res[l + r] = pos[l++];\n        }\n        while (r < q) {\n            res[l + r] = -neg[r++];\n        }\n        return res;\n    }\n}"}
{"id": "1512", "path": "output2\\java\\Medium\\1512-find-all-lonely-numbers-in-the-array.java", "hypo_code": "class Solution {\n    public List<Integer> findLonely(int[] nums) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i - 2]) {\n                pre[i]++;\n            }\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums[l] < nums[i - 1]) {\n                if (pre[i - 1] - pre[l] == 0 && pre[i] - pre[l] == 0) {\n                    res.add(nums[i - 1]);\n                }\n            } else {\n                if (pre[i - 1] - pre[l] - 1 == 0 && pre[i] - pre[l] - 1 == 0) {\n                    res.add(nums[i - 1]);\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1513", "path": "output2\\java\\Medium\\1513-all-divisions-with-the-highest-score-of-a-binary-array.java", "hypo_code": "class Solution {\n    public List<Integer> maxScoreIndices(int[] nums) {\n        int n = nums.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i]) {\n                pre[i]++;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums[l] < nums[i]) {\n                left[i] = i - l;\n            } else {\n                left[i] = i - l - 1;\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            int l = i + 1, r = n - 1;\n            while (l < r) {\n                int mid = l + r + 1 >> 1;\n                if (nums[mid] < nums[i]) {\n                    r = mid - 1;\n                } else {\n                    l = mid;\n                }\n            }\n            if (nums[l] < nums[i]) {\n                right[i] = l - i;\n            } else {\n                right[i] = l - i - 1;\n            }\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            max = Math.max(max, left[i] + right[i]);\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (left[i] + right[i] == max) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1514", "path": "output2\\java\\Medium\\1514-partition-array-according-to-given-pivot.java", "hypo_code": "class PartitionArrayAccordingToGivenPivot {\n    public int[] pivotArray(int[] nums, int pivot) {\n        int i = 0, j = 0, k = nums.length - 1;\n        while(j <= k){\n            if(nums[j] < pivot){\n                swap(nums, i, j);\n                i++;\n                j++;\n            }else if(nums[j] > pivot){\n                swap(nums, j, k);\n                k--;\n            }else{\n                j++;\n            }\n        }\n        return nums;\n        \n        \n    }\n}"}
{"id": "1515", "path": "output2\\java\\Medium\\1515-minimum-cost-to-set-cooking-time.java", "hypo_code": "class MinimumCostToSetCookingTime {\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\n        int[] digits = new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        int[][] dp = new int[10][6000];\n        for(int i = 0; i < 10; i++){\n            for(int j = 0; j < 6000; j++){\n                dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        dp[startAt][0] = 0;\n        for(int i = 0; i < 6000; i++){\n            for(int j = 0; j < 10; j++){\n                if(dp[j][i] == Integer.MAX_VALUE){\n                    continue;\n                }\n                for(int k = 0; k < 10; k++){\n                    int next = i + (j * 60 + k);\n                    if(next >= 6000){\n                        continue;\n                    }\n                    int cost = dp[j][i] + Math.abs(k - j) * moveCost + k * pushCost;\n                    dp[k][next] = Math.min(dp[k][next], cost);\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for(int i = 0; i < 10; i++){\n            res = Math.min(res, dp[i][targetSeconds]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1516", "path": "output2\\java\\Medium\\1516-smallest-value-of-the-rearranged-number.java", "hypo_code": "class SmallestValueOfTheRearrangedNumber {\n    public long smallestNumber(long num) {\n        long[] digits = new long[10];\n        long n = num;\n        while(n > 0){\n            digits[(int)(n % 10)]++;\n            n /= 10;\n        }\n        long res = 0;\n        for(int i = 1; i < 10; i++){\n            while(digits[i] > 0){\n                res = res * 10 + i;\n                digits[i]--;\n            }\n        }\n        while(digits[0] > 0){\n            res = res * 10;\n            digits[0]--;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1518", "path": "output2\\java\\Medium\\1518-minimum-operations-to-make-the-array-alternating.java", "hypo_code": "class Solution {\n    public int minimumOperations(int[] nums) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i - 2]) {\n                pre[i]++;\n            }\n        }\n        int res = Math.min(pre[n], n - pre[n]);\n        for (int i = 1; i <= n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            int cnt = pre[i - 1] - pre[l];\n            l = 0;\n            r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] > nums[i - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            cnt += i - 1 - l - (pre[i - 1] - pre[l]);\n            res = Math.min(res, cnt);\n        }\n        return res;\n    }\n}"}
{"id": "1519", "path": "output2\\java\\Medium\\1519-removing-minimum-number-of-magic-beans.java", "hypo_code": "class Solution {\n    public long minimumRemoval(int[] beans) {\n        int n = beans.length;\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (beans[i - 1] > beans[i - 2]) {\n                pre[i]++;\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (beans[mid] < beans[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (beans[l] < beans[i]) {\n                res += pre[i] - pre[l];\n            } else {\n                res += pre[i] - pre[l] - 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1520", "path": "output2\\java\\Medium\\1520-find-three-consecutive-integers-that-sum-to-a-given-number.java", "hypo_code": "class Solution {\n    public long[] sumOfThree(long num) {\n        long[] res = new long[3];\n        for (int i = 1; i < num / 3; i++) {\n            for (int j = i + 1; j < num / 2; j++) {\n                long sum = (long) i * (i + 1) / 2 + (long) j * (j + 1) / 2;\n                if (sum > num) {\n                    break;\n                }\n                long k = num - sum;\n                if (k >= j + 1 && k <= num / 2) {\n                    res[0] = i;\n                    res[1] = j;\n                    res[2] = k;\n                    return res;\n                }\n            }\n        }\n        return new long[0];\n    }\n}"}
{"id": "1521", "path": "output2\\java\\Medium\\1521-maximum-split-of-positive-even-integers.java", "hypo_code": "class Solution {\n    public List<Long> maximumEvenSplit(long finalSum) {\n        List<Long> res = new ArrayList<>();\n        if (finalSum % 2 == 1) {\n            return res;\n        }\n        long n = finalSum / 2;\n        long sum = 0;\n        for (long i = 1; i <= n; i++) {\n            sum += i;\n            res.add(i);\n            if (sum > n) {\n                sum -= res.get(0);\n                res.remove(0);\n            } else if (sum == n) {\n                return res;\n            }\n        }\n        return new ArrayList<>();\n    }\n}"}
{"id": "1522", "path": "output2\\java\\Medium\\1522-merge-nodes-in-between-zeros.java", "hypo_code": "class Solution {\n    public ListNode mergeNodes(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = head;\n        ListNode pre = dummy;\n        int sum = 0;\n        while (cur != null) {\n            if (cur.val == 0) {\n                pre.next = cur.next;\n                sum += cur.val;\n            } else {\n                sum += cur.val;\n                if (cur.next == null || cur.next.val == 0) {\n                    pre.next = new ListNode(sum);\n                    sum = 0;\n                }\n            }\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}"}
{"id": "1523", "path": "output2\\java\\Medium\\1523-construct-string-with-repeat-limit.java", "hypo_code": "class Solution {\n    public String repeatLimitedString(String s, int repeatLimit) {\n        StringBuilder sb = new StringBuilder();\n        int n = s.length();\n        int[] map = new int[26];\n        for (int i = 0; i < n; i++) {\n            int l = i;\n            while (i + 1 < n && s.charAt(i + 1) == s.charAt(i)) {\n                i++;\n            }\n            map[s.charAt(i) - 'a'] = Math.min(i - l + 1, repeatLimit);\n        }\n        for (int i = 0; i < 26; i++) {\n            for (int j = 0; j < map[i]; j++) {\n                sb.append((char)(i + 'a'));\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1524", "path": "output2\\java\\Medium\\1524-minimum-number-of-steps-to-make-two-strings-anagram-ii.java", "hypo_code": "class Solution {\n    public int minSteps(String s, String t) {\n        int[] map = new int[26];\n        for (char c : s.toCharArray()) {\n            map[c - 'a']++;\n        }\n        for (char c : t.toCharArray()) {\n            map[c - 'a']--;\n        }\n        int res = 0;\n        for (int i = 0; i < 26; i++) {\n            res += Math.abs(map[i]);\n        }\n        return res / 2;\n    }\n}"}
{"id": "1525", "path": "output2\\java\\Medium\\1525-minimum-time-to-complete-trips.java", "hypo_code": "class Solution {\n    public long minimumTime(int[] time, int totalTrips) {\n        int n = time.length;\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1] + time[i - 1];\n        }\n        long res = Long.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (pre[i] - pre[mid] < time[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (pre[i] - pre[l] < time[i]) {\n                res = Math.min(res, (long)time[i] * totalTrips - (pre[i] - pre[l]));\n            } else {\n                res = Math.min(res, (long)time[i] * totalTrips - (pre[i] - pre[l] - time[i]));\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1526", "path": "output2\\java\\Medium\\1526-sort-the-jumbled-numbers.java", "hypo_code": "class Solution {\n    public int[] sortJumbled(int[] mapping, int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            int cur = nums[i];\n            while (cur > 0) {\n                int digit = cur % 10;\n                cur /= 10;\n                res[i] = res[i] * 10 + mapping[digit];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            nums[i] = res[i];\n        }\n        Arrays.sort(nums);\n        for (int i = 0; i < n; i++) {\n            int cur = nums[i];\n            res[i] = 0;\n            while (cur > 0) {\n                int digit = cur % 10;\n                cur /= 10;\n                res[i] = res[i] * 10 + digit;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1527", "path": "output2\\java\\Medium\\1527-all-ancestors-of-a-node-in-a-directed-acyclic-graph.java", "hypo_code": "class Solution {\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer>[] graph = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList();\n        }\n        for (int[] edge : edges) {\n            graph[edge[0]].add(edge[1]);\n        }\n        for (int i = 0; i < n; i++) {\n            res.add(getAncestors(graph, i));\n        }\n        return res;\n    }\n    private List<Integer> getAncestors(List<Integer>[] graph, int i) {\n        List<Integer> res = new ArrayList<>();\n        Queue<Integer> q = new LinkedList<>();\n        q.offer(i);\n        while (!q.isEmpty()) {\n            int cur = q.poll();\n            for (int next : graph[cur]) {\n                res.add(next);\n                q.offer(next);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1528", "path": "output2\\java\\Medium\\1528-append-k-integers-with-minimal-sum.java", "hypo_code": "class Solution {\n    public long minimalKSum(int[] nums, int k) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        long res = 0;\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i - 2]) {\n                pre[i]++;\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums[l] < nums[i - 1]) {\n                res += pre[i - 1] - pre[l];\n            } else {\n                res += pre[i - 1] - pre[l] - 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1529", "path": "output2\\java\\Medium\\1529-create-binary-tree-from-descriptions.java", "hypo_code": "class Solution {\n    public TreeNode createBinaryTree(int[][] descriptions) {\n        Map<Integer, TreeNode> map = new HashMap<>();\n        for (int[] d : descriptions) {\n            TreeNode parent = map.getOrDefault(d[0], new TreeNode(d[0]));\n            TreeNode child = map.getOrDefault(d[1], new TreeNode(d[1]));\n            if (d[2] == 1) {\n                parent.left = child;\n            } else {\n                parent.right = child;\n            }\n            map.put(d[0], parent);\n            map.put(d[1], child);\n        }\n        for (TreeNode node : map.values()) {\n            if (node.left != null && node.right != null) {\n                return node;\n            }\n        }\n        return null;\n    }\n}"}
{"id": "1530", "path": "output2\\java\\Medium\\1530-count-artifacts-that-can-be-extracted.java", "hypo_code": "class CountArtifactsThatCanBeExtracted {\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\n        int[][] grid = new int[n][n];\n        for(int[] artifact : artifacts){\n            for(int i = artifact[0]; i <= artifact[2]; i++){\n                for(int j = artifact[1]; j <= artifact[3]; j++){\n                    grid[i][j] = 1;\n                }\n            }\n        }\n        int res = 0;\n        for(int[] digPos : dig){\n            if(grid[digPos[0]][digPos[1]] == 1){\n                res++;\n                grid[digPos[0]][digPos[1]] = 0;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1531", "path": "output2\\java\\Medium\\1531-maximize-the-topmost-element-after-k-moves.java", "hypo_code": "class MaximizeTheTopmostElementAfterKMoves {\n    public int maximumTop(int[] nums, int k) {\n        int max = Integer.MIN_VALUE;\n        for(int i = 0; i < nums.length; i++){\n            max = Math.max(max, nums[i]);\n        }\n        int count = 0;\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] == max){\n                count++;\n            }\n        }\n        if(k >= nums.length){\n            return max;\n        }\n        if(count > k){\n            return max;\n        }\n        return max - (k - count + 1) / 2;\n        \n\n    }\n}"}
{"id": "1532", "path": "output2\\java\\Medium\\1532-maximize-number-of-subsequences-in-a-string.java", "hypo_code": "class MaximizeNumberOfSubsequencesInAString {\n    public long maximumSubsequenceCount(String text, String pattern) {\n        int n = text.length();\n        int m = pattern.length();\n        long[][] dp = new long[n + 1][m + 1];\n        for(int i = 0; i <= n; i++){\n            dp[i][0] = 1;\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= m; j++){\n                if(text.charAt(i - 1) == pattern.charAt(j - 1)){\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                }else{\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[n][m];\n        \n    }\n}"}
{"id": "1533", "path": "output2\\java\\Medium\\1533-minimum-operations-to-halve-array-sum.java", "hypo_code": "class MinimumOperationsToHalveArraySum {\n    public int halveArray(int[] nums) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++){\n            sum += nums[i];\n        }\n        int count = 0;\n        while(sum > 0){\n            sum /= 2;\n            count++;\n        }\n        return count;\n        \n    }\n}"}
{"id": "1534", "path": "output2\\java\\Medium\\1534-count-collisions-on-a-road.java", "hypo_code": "class CountCollisionsOnARoad {\n    public int countCollisions(String directions) {\n        int res = 0;\n        int n = directions.length();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        for(int i = 0; i < n; i++){\n            if(directions.charAt(i) == 'L'){\n                left[i] = 1;\n            }else if(directions.charAt(i) == 'R'){\n                right[i] = 1;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(left[i] == 1){\n                for(int j = i + 1; j < n; j++){\n                    if(right[j] == 1){\n                        res += 2;\n                        left[i] = 0;\n                        right[j] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(left[i] == 1){\n                for(int j = i + 1; j < n; j++){\n                    if(left[j] == 1){\n                        res += 1;\n                        left[i] = 0;\n                        left[j] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(right[i] == 1){\n                for(int j = i + 1; j < n; j++){\n                    if(right[j] == 1){\n                        res += 1;\n                        right[i] = 0;\n                        right[j] = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1535", "path": "output2\\java\\Medium\\1535-maximum-points-in-an-archery-competition.java", "hypo_code": "class MaximumPointsInAnArcheryCompetition {\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\n        int[] bobArrows = new int[12];\n        int sum = 0;\n        for(int i = 0; i < 12; i++){\n            sum += aliceArrows[i];\n        }\n        int diff = numArrows - sum;\n        for(int i = 0; i < 12; i++){\n            if(aliceArrows[i] == 0){\n                bobArrows[i] = diff / 12;\n                diff -= bobArrows[i];\n            }\n        }\n        for(int i = 0; i < 12; i++){\n            if(aliceArrows[i] == 0){\n                if(diff > 0){\n                    bobArrows[i]++;\n                    diff--;\n                }\n            }\n        }\n        return bobArrows;\n        \n    }\n}"}
{"id": "1536", "path": "output2\\java\\Medium\\1536-minimum-deletions-to-make-array-beautiful.java", "hypo_code": "class Solution {\n    public int minDeletion(int[] nums) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i - 2]) {\n                pre[i]++;\n            }\n        }\n        int res = n;\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums[l] < nums[i]) {\n                res = Math.min(res, pre[i] - pre[l]);\n            } else {\n                res = Math.min(res, pre[i] - pre[l] - 1);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1537", "path": "output2\\java\\Medium\\1537-find-palindrome-with-fixed-length.java", "hypo_code": "class Solution {\n    public long[] kthPalindrome(int[] queries, int intLength) {\n        int n = queries.length;\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = getKthPalindrome(queries[i], intLength);\n        }\n        return res;\n    }\n    long getKthPalindrome(int k, int len) {\n        int[] nums = new int[len];\n        int i = 0;\n        while (k > 0) {\n            nums[i++] = k % 10;\n            k /= 10;\n        }\n        int j = 0;\n        while (j < i - j - 1) {\n            nums[i - j - 1] = nums[j];\n            j++;\n        }\n        long res = 0;\n        for (int l = 0; l < i; l++) {\n            res = res * 10 + nums[l];\n        }\n        return res;\n    }\n}"}
{"id": "1538", "path": "output2\\java\\Medium\\1538-find-triangular-sum-of-an-array.java", "hypo_code": "class Solution {\n    public int triangularSum(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        while (n > 1) {\n            int[] newNums = new int[n - 1];\n            for (int i = 0; i < n - 1; i++) {\n                newNums[i] = (nums[i] + nums[i + 1]) % 10;\n            }\n            n--;\n            res = newNums[0];\n            nums = newNums;\n        }\n        return res;\n    }\n}"}
{"id": "1539", "path": "output2\\java\\Medium\\1539-number-of-ways-to-select-buildings.java", "hypo_code": "class Solution {\n    public long numberOfWays(String s) {\n        int n = s.length();\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (s.charAt(i - 1) == '1') {\n                pre[i]++;\n            }\n        }\n        long res = 0;\n        for (int i = 1; i < n - 1; i++) {\n            if (s.charAt(i) == '0') {\n                res += (long)pre[i] * (pre[n] - pre[i + 1]);\n            }\n        }\n        return res;\n\n    }\n}"}
{"id": "1540", "path": "output2\\java\\Medium\\1540-find-players-with-zero-or-one-losses.java", "hypo_code": "class Solution {\n    public List<List<Integer>> findWinners(int[][] matches) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] match : matches) {\n            map.put(match[0], map.getOrDefault(match[0], 0) + 1);\n            map.put(match[1], map.getOrDefault(match[1], 0) + 2);\n        }\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> win = new ArrayList<>();\n        List<Integer> lose = new ArrayList<>();\n        for (int key : map.keySet()) {\n            if (map.get(key) == 1) {\n                win.add(key);\n            } else if (map.get(key) == 2) {\n                lose.add(key);\n            }\n        }\n        res.add(win);\n        res.add(lose);\n        return res;\n    }\n}"}
{"id": "1541", "path": "output2\\java\\Medium\\1541-maximum-candies-allocated-to-k-children.java", "hypo_code": "class Solution {\n    public int maximumCandies(int[] candies, long k) {\n        int n = candies.length;\n        long l = 0, r = (long) 1e10;\n        while (l < r) {\n            long mid = l + r + 1 >> 1;\n            if (check(candies, k, mid)) {\n                l = mid;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return (int) l;\n    }\n\n    public boolean check(int[] candies, long k, long mid) {\n        long sum = 0;\n        for (int candy : candies) {\n            sum += (candy + mid - 1) / mid;\n        }\n        return sum <= k;\n    }\n}"}
{"id": "1542", "path": "output2\\java\\Medium\\1542-minimize-result-by-adding-parentheses-to-expression.java", "hypo_code": "class Solution {\n    public String minimizeResult(String expression) {\n        int n = expression.length();\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (expression.charAt(i - 1) == '+') {\n                pre[i]++;\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        int minIdx = -1;\n        for (int i = 1; i < n; i++) {\n            if (expression.charAt(i) == '+') {\n                int l = 0, r = i - 1;\n                while (l < r) {\n                    int mid = l + r >> 1;\n                    if (expression.charAt(mid) == '+') {\n                        l = mid + 1;\n                    } else {\n                        r = mid;\n                    }\n                }\n                if (expression.charAt(l) == '+') {\n                    if (pre[i + 1] - pre[l + 1] < min) {\n                        min = pre[i + 1] - pre[l + 1];\n                        minIdx = i;\n                    }\n                }\n            }\n        }\n        if (minIdx == -1) {\n            return expression;\n        }\n        return expression.substring(0, minIdx) + \"(\" + expression.substring(minIdx) + \")\";\n\n    }\n}"}
{"id": "1543", "path": "output2\\java\\Medium\\1543-maximum-product-after-k-increments.java", "hypo_code": "class Solution {\n    public int maximumProduct(int[] nums, int k) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i - 2]) {\n                pre[i]++;\n            }\n        }\n        long res = 1;\n        for (int i = 0; i < k; i++) {\n            res = res * nums[i] % 1000000007;\n        }\n        for (int i = k; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums[l] < nums[i]) {\n                res = Math.max(res, nums[i] * pre[i]);\n            } else {\n                res = Math.max(res, nums[i] * pre[i] - nums[l] * pre[l]);\n            }\n        }\n        return (int)res;\n    }\n}"}
{"id": "1544", "path": "output2\\java\\Medium\\1544-number-of-ways-to-buy-pens-and-pencils.java", "hypo_code": "class Solution {\n    public long waysToBuyPensPencils(int total, int cost1, int cost2) {\n        int l = 0, r = total / Math.min(cost1, cost2);\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (check(total, cost1, cost2, mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        if (check(total, cost1, cost2, l)) {\n            return l * 2 + 1;\n        } else {\n            return l * 2;\n        }\n    }\n    \n    private boolean check(int total, int cost1, int cost2, int mid) {\n        return total >= mid * cost1 || total >= mid * cost2;\n    }\n    \n}"}
{"id": "1546", "path": "output2\\java\\Medium\\1546-minimum-rounds-to-complete-all-tasks.java", "hypo_code": "class MinimumRoundsToCompleteAllTasks {\n    public int minimumRounds(int[] tasks) {\n        int[] count = new int[11];\n        for(int i = 0; i < tasks.length; i++){\n            count[tasks[i]]++;\n        }\n        int res = 0;\n        for(int i = 1; i < 11; i++){\n            if(count[i] > 0){\n                res += count[i] / 3;\n                count[i] %= 3;\n                if(count[i] > 0){\n                    res++;\n                    count[i] = 3 - count[i];\n                }\n            }\n            if(count[i] > 0){\n                count[i + 1] += count[i];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1547", "path": "output2\\java\\Medium\\1547-maximum-trailing-zeros-in-a-cornered-path.java", "hypo_code": "class MaximumTrailingZerosInACorneredPath {\n    public int maxTrailingZeros(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] dp = new int[m][n][2];\n        int[][] directions = new int[][]{{0, 1}, {1, 0}};\n        int res = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                for(int[] dir : directions){\n                    int x = i + dir[0];\n                    int y = j + dir[1];\n                    if(x < m && y < n){\n                        int[] temp = new int[2];\n                        temp[0] = dp[x][y][0];\n                        temp[1] = dp[x][y][1];\n                        if(grid[i][j] == 0){\n                            temp[0] = 0;\n                            temp[1] = 0;\n                        }\n                        else{\n                            while(grid[i][j] % 2 == 0){\n                                temp[0]++;\n                                grid[i][j] /= 2;\n                            }\n                            while(grid[i][j] % 5 == 0){\n                                temp[1]++;\n                                grid[i][j] /= 5;\n                            }\n                        }\n                        if(temp[0] > dp[i][j][0] || (temp[0] == dp[i][j][0] && temp[1] > dp[i][j][1])){\n                            dp[i][j][0] = temp[0];\n                            dp[i][j][1] = temp[1];\n                        }\n                    }\n                }\n                res = Math.max(res, dp[i][j][1]);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1548", "path": "output2\\java\\Medium\\1548-count-lattice-points-inside-a-circle.java", "hypo_code": "class CountLatticePointsInsideACircle {\n    public int countLatticePoints(int[][] circles) {\n        int count = 0;\n        for(int i = 0; i < circles.length; i++){\n            int x = circles[i][0];\n            int y = circles[i][1];\n            int r = circles[i][2];\n            for(int j = x - r; j <= x + r; j++){\n                for(int k = y - r; k <= y + r; k++){\n                    if(Math.pow(j - x, 2) + Math.pow(k - y, 2) <= Math.pow(r, 2)){\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1549", "path": "output2\\java\\Medium\\1549-count-number-of-rectangles-containing-each-point.java", "hypo_code": "class CountNumberOfRectanglesContainingEachPoint {\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\n        int[] res = new int[points.length];\n        for(int i = 0; i < points.length; i++){\n            int x = points[i][0];\n            int y = points[i][1];\n            for(int j = 0; j < rectangles.length; j++){\n                int l = rectangles[j][0];\n                int h = rectangles[j][1];\n                if(x <= l && y <= h){\n                    res[i]++;\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1550", "path": "output2\\java\\Medium\\1550-minimum-average-difference.java", "hypo_code": "class MinimumAverageDifference {\n    public int minimumAverageDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        for(int i = 0; i < n; i++){\n            prefix[i + 1] = prefix[i] + nums[i];\n        }\n        int res = 0;\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < n - 1; i++){\n            int left = prefix[i + 1];\n            int right = prefix[n] - prefix[i + 1];\n            int avg = (left + right) / (n - i - 1);\n            int diff = Math.abs(avg - left / (i + 1));\n            if(diff < min){\n                min = diff;\n                res = i;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1551", "path": "output2\\java\\Medium\\1551-count-unguarded-cells-in-the-grid.java", "hypo_code": "class CountUnguardedCellsInTheGrid {\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\n        int[][] grid = new int[m][n];\n        for(int[] guard : guards){\n            int x = guard[0];\n            int y = guard[1];\n            grid[x][y] = 1;\n            for(int i = x - 1; i >= 0; i--){\n                if(grid[i][y] == 2){\n                    break;\n                }\n                grid[i][y] = 1;\n            }\n            for(int i = x + 1; i < m; i++){\n                if(grid[i][y] == 2){\n                    break;\n                }\n                grid[i][y] = 1;\n            }\n            for(int i = y - 1; i >= 0; i--){\n                if(grid[x][i] == 2){\n                    break;\n                }\n                grid[x][i] = 1;\n            }\n            for(int i = y + 1; i < n; i++){\n                if(grid[x][i] == 2){\n                    break;\n                }\n                grid[x][i] = 1;\n            }\n        }\n        for(int[] wall : walls){\n            int x = wall[0];\n            int y = wall[1];\n            grid[x][y] = 2;\n        }\n        int count = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 0){\n                    count++;\n                }\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1552", "path": "output2\\java\\Medium\\1552-minimum-consecutive-cards-to-pick-up.java", "hypo_code": "class MinimumConsecutiveCardsToPickUp {\n    public int minimumCardPickup(int[] cards) {\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for (int card : cards) {\n            min = Math.min(min, card);\n            max = Math.max(max, card);\n        }\n        int[] count = new int[max - min + 1];\n        for (int card : cards) {\n            count[card - min]++;\n        }\n        int result = 0;\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] == 0) {\n                result++;\n            } else {\n                result = 0;\n            }\n            if (result == 2) {\n                return 2;\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1553", "path": "output2\\java\\Medium\\1553-k-divisible-elements-subarrays.java", "hypo_code": "class KDivisibleElementsSubarrays {\n    public int countDistinct(int[] nums, int k, int p) {\n        int[] count = new int[p];\n        int sum = 0;\n        int result = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            int mod = sum % p;\n            if (mod < 0) {\n                mod += p;\n            }\n            if (mod == 0) {\n                result++;\n            }\n            if (i >= k) {\n                sum -= nums[i - k];\n            }\n            if (i >= k - 1) {\n                result += count[mod];\n                count[mod]++;\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1554", "path": "output2\\java\\Medium\\1554-count-nodes-equal-to-average-of-subtree.java", "hypo_code": "class CountNodesEqualToAverageOfSubtree {\n    public int averageOfSubtree(TreeNode root) {\n        int[] result = new int[1];\n        averageOfSubtree(root, result);\n        return result[0];\n        \n    }\n}"}
{"id": "1555", "path": "output2\\java\\Medium\\1555-count-number-of-texts.java", "hypo_code": "class Solution {\n    public int countTexts(String pressedKeys) {\n        int n = pressedKeys.length();\n        int mod = (int)1e9 + 7;\n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            long count = 0;\n            for (int j = i - 1; j >= 0; j--) {\n                if (pressedKeys.charAt(j) != pressedKeys.charAt(i - 1)) {\n                    break;\n                }\n                count += dp[j];\n            }\n            dp[i] = (count + 1) % mod;\n        }\n        return (int)dp[n];\n    }\n}"}
{"id": "1556", "path": "output2\\java\\Medium\\1556-number-of-ways-to-split-array.java", "hypo_code": "class NumberOfWaysToSplitArray {\n    public int waysToSplitArray(int[] nums) {\n        int[] sum = new int[nums.length];\n        sum[0] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            sum[i] = sum[i - 1] + nums[i];\n        }\n        int result = 0;\n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1;\n            int right = nums.length - 1;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (sum[mid] - sum[i] >= sum[nums.length - 1] - sum[mid]) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            int rightIndex = right;\n            left = i + 1;\n            right = nums.length - 1;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (sum[mid] - sum[i] > sum[nums.length - 1] - sum[mid]) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            int leftIndex = left;\n            if (leftIndex <= rightIndex) {\n                result += rightIndex - leftIndex + 1;\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1557", "path": "output2\\java\\Medium\\1557-maximum-white-tiles-covered-by-a-carpet.java", "hypo_code": "class MaximumWhiteTilesCoveredByACarpet {\n    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {\n        int[] count = new int[100000];\n        for (int[] tile : tiles) {\n            count[tile[0]]++;\n            count[tile[1] + 1]--;\n        }\n        for (int i = 1; i < count.length; i++) {\n            count[i] += count[i - 1];\n        }\n        int result = 0;\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] > 0) {\n                result += Math.min(carpetLen, count[i]);\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1558", "path": "output2\\java\\Medium\\1558-maximum-consecutive-floors-without-special-floors.java", "hypo_code": "class MaximumConsecutiveFloorsWithoutSpecialFloors {\n    public int maxConsecutive(int bottom, int top, int[] special) {\n        int[] count = new int[top - bottom + 1];\n        for (int floor : special) {\n            count[floor - bottom]++;\n        }\n        int result = 0;\n        int current = 0;\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] == 0) {\n                current++;\n            } else {\n                result = Math.max(result, current);\n                current = 0;\n            }\n        }\n        result = Math.max(result, current);\n        return result;\n        \n    }\n}"}
{"id": "1559", "path": "output2\\java\\Medium\\1559-largest-combination-with-bitwise-and-greater-than-zero.java", "hypo_code": "class LargestCombinationWithBitwiseAndGreaterThanZero {\n    public int largestCombination(int[] candidates) {\n        int[] count = new int[32];\n        for (int candidate : candidates) {\n            int index = 0;\n            while (candidate > 0) {\n                if ((candidate & 1) == 1) {\n                    count[index]++;\n                }\n                candidate >>= 1;\n                index++;\n            }\n        }\n        int result = 0;\n        for (int i = 31; i >= 0; i--) {\n            if (count[i] > 0) {\n                result += 1 << i;\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1560", "path": "output2\\java\\Medium\\1560-maximum-bags-with-full-capacity-of-rocks.java", "hypo_code": "class MaximumBagsWithFullCapacityOfRocks {\n    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\n        int[] count = new int[100000];\n        for (int i = 0; i < capacity.length; i++) {\n            count[capacity[i]]++;\n            count[rocks[i]]--;\n        }\n        for (int i = 1; i < count.length; i++) {\n            count[i] += count[i - 1];\n        }\n        int result = 0;\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] > 0) {\n                result += Math.min(additionalRocks, count[i]);\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1561", "path": "output2\\java\\Medium\\1561-minimum-lines-to-represent-a-line-chart.java", "hypo_code": "class Solution {\n    public int minimumLines(int[][] stockPrices) {\n        int n = stockPrices.length;\n        int[] dp = new int[n];\n        int[] pre = new int[n];\n        dp[0] = 1;\n        pre[0] = stockPrices[0][1];\n        for (int i = 1; i < n; i++) {\n            dp[i] = dp[i - 1] + 1;\n            pre[i] = stockPrices[i][1];\n            for (int j = 0; j < i; j++) {\n                if (stockPrices[i][1] > pre[j]) {\n                    dp[i] = Math.min(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        return dp[n - 1];\n    }\n}"}
{"id": "1562", "path": "output2\\java\\Medium\\1562-sender-with-largest-word-count.java", "hypo_code": "class SenderWithLargestWordCount {\n    public String largestWordCount(String[] messages, String[] senders) {\n        Map<String, Integer> count = new HashMap<>();\n        for (int i = 0; i < messages.length; i++) {\n            String[] words = messages[i].split(\" \");\n            count.put(senders[i], count.getOrDefault(senders[i], 0) + words.length);\n        }\n        String result = \"\";\n        int max = 0;\n        for (String sender : count.keySet()) {\n            if (count.get(sender) > max) {\n                result = sender;\n                max = count.get(sender);\n            } else if (count.get(sender) == max) {\n                result = result.compareTo(sender) < 0 ? result : sender;\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1563", "path": "output2\\java\\Medium\\1563-maximum-total-importance-of-roads.java", "hypo_code": "class MaximumTotalImportanceOfRoads {\n    public long maximumImportance(int n, int[][] roads) {\n        int[] count = new int[n];\n        for (int[] road : roads) {\n            count[road[0]]++;\n            count[road[1]]++;\n        }\n        long result = 0;\n        for (int i = 0; i < count.length; i++) {\n            result += count[i];\n        }\n        return result;\n        \n    }\n}"}
{"id": "1564", "path": "output2\\java\\Medium\\1564-apply-discount-to-prices.java", "hypo_code": "class ApplyDiscountToPrices {\n    public String discountPrices(String sentence, int discount) {\n        String[] words = sentence.split(\" \");\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].charAt(0) == '$') {\n                int price = Integer.parseInt(words[i].substring(1));\n                price = price - price * discount / 100;\n                words[i] = \"$\" + String.format(\"%.2f\", price / 100.0);\n            }\n        }\n        return String.join(\" \", words);\n        \n    }\n}"}
{"id": "1565", "path": "output2\\java\\Medium\\1565-steps-to-make-array-non-decreasing.java", "hypo_code": "class StepsToMakeArrayNonDecreasing {\n    public int totalSteps(int[] nums) {\n        int[] count = new int[100000];\n        for (int num : nums) {\n            count[num]++;\n        }\n        int result = 0;\n        int prev = 0;\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] > 0) {\n                result += Math.max(0, prev - i);\n                prev = i + count[i];\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1566", "path": "output2\\java\\Medium\\1566-partition-array-such-that-maximum-difference-is-k.java", "hypo_code": "class Solution {\n    public int partitionArray(int[] nums, int k) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i - 2]) {\n                pre[i]++;\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums[l] < nums[i - 1]) {\n                res += pre[i - 1] - pre[l];\n            } else {\n                res += pre[i - 1] - pre[l] - 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1567", "path": "output2\\java\\Medium\\1567-replace-elements-in-an-array.java", "hypo_code": "class Solution {\n    public int[] arrayChange(int[] nums, int[][] operations) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i - 2]) {\n                pre[i]++;\n            }\n        }\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums[l] < nums[i]) {\n                res[i] = pre[i] - pre[l];\n            } else {\n                res[i] = pre[i] - pre[l] - 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1568", "path": "output2\\java\\Medium\\1568-successful-pairs-of-spells-and-potions.java", "hypo_code": "class SuccessfulPairsOfSpellsAndPotions {\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\n        int[] count = new int[100000];\n        for (int spell : spells) {\n            count[spell]++;\n        }\n        int[] result = new int[spells.length];\n        for (int i = 0; i < potions.length; i++) {\n            for (int j = 1; j * j <= potions[i]; j++) {\n                if (potions[i] % j == 0) {\n                    if (j * j == potions[i]) {\n                        result[i] += count[j];\n                    } else {\n                        result[i] += count[j] + count[potions[i] / j];\n                    }\n                }\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1569", "path": "output2\\java\\Medium\\1569-minimum-path-cost-in-a-grid.java", "hypo_code": "class MinimumPathCostInAGrid {\n    public int minPathCost(int[][] grid, int[][] moveCost) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            dp[0][i] = grid[0][i];\n        }\n        for(int i = 1; i < m; i++){\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][k] + moveCost[grid[i-1][k]][k] + grid[i][j]);\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            min = Math.min(min, dp[m-1][i]);\n        }\n        return min;\n        \n    }\n}"}
{"id": "1570", "path": "output2\\java\\Medium\\1570-fair-distribution-of-cookies.java", "hypo_code": "class FairDistributionOfCookies {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        int n = cookies.length;\n        int[][] dp = new int[n][k];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < k; j++){\n                dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            dp[i][0] = cookies[i];\n        }\n        for(int i = 1; i < n; i++){\n            for(int j = 1; j < k; j++){\n                for(int l = 0; l < i; l++){\n                    dp[i][j] = Math.min(dp[i][j], dp[l][j-1] + cookies[i] - cookies[l]);\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            min = Math.min(min, dp[i][k-1]);\n        }\n        return min;\n        \n    }\n}"}
{"id": "1571", "path": "output2\\java\\Medium\\1571-sum-of-numbers-with-units-digit-k.java", "hypo_code": "class Solution {\n    public int minimumNumbers(int num, int k) {\n        if (num == 0) {\n            return 0;\n        }\n        int[] dp = new int[10];\n        Arrays.fill(dp, Integer.MAX_VALUE / 2);\n        dp[0] = 0;\n        for (int i = 1; i <= 9; i++) {\n            for (int j = i; j <= num; j++) {\n                dp[j % 10] = Math.min(dp[j % 10], dp[(j - i) % 10] + 1);\n            }\n        }\n        return dp[k] > num ? -1 : dp[k];\n    }\n}"}
{"id": "1572", "path": "output2\\java\\Medium\\1572-longest-binary-subsequence-less-than-or-equal-to-k.java", "hypo_code": "class Solution {\n    public int longestSubsequence(String s, int k) {\n        int n = s.length();\n        int[][] f = new int[n + 1][k + 1];\n        for (int i = n; i >= 1; i--) {\n            for (int j = 0; j <= k; j++) {\n                f[i][j] = f[i + 1][j];\n                if (j > 0 && s.charAt(i - 1) == '1') {\n                    f[i][j] = Math.max(f[i][j], f[i + 1][j - 1] + 1);\n                }\n            }\n        }\n        return f[1][k];\n    }\n}"}
{"id": "1573", "path": "output2\\java\\Medium\\1573-count-unreachable-pairs-of-nodes-in-an-undirected-graph.java", "hypo_code": "class Solution {\n    public long countPairs(int n, int[][] edges) {\n        int[] deg = new int[n];\n        for (int[] edge : edges) {\n            deg[edge[0]]++;\n            deg[edge[1]]++;\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            res += deg[i] * (n - deg[i] - 1);\n        }\n        return res / 2;\n    }\n}"}
{"id": "1574", "path": "output2\\java\\Medium\\1574-maximum-xor-after-operations.java", "hypo_code": "class Solution {\n    public int maximumXOR(int[] nums) {\n        Trie trie = new Trie();\n        for (int num : nums) {\n            trie.insert(num);\n        }\n        int res = 0;\n        for (int num : nums) {\n            res = Math.max(res, trie.query(num));\n        }\n        return res;\n    }\n}"}
{"id": "1575", "path": "output2\\java\\Medium\\1575-count-number-of-ways-to-place-houses.java", "hypo_code": "class Solution {\n    public int countHousePlacements(int n) {\n        long[] dp = new long[2];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            long[] temp = new long[2];\n            temp[0] = (dp[0] * 2 + dp[1]) % 1000000007;\n            temp[1] = (dp[0] + dp[1] * 2) % 1000000007;\n            dp = temp;\n        }\n        return (int) ((dp[0] + dp[1]) % 1000000007);\n    }\n}"}
{"id": "1576", "path": "output2\\java\\Medium\\1576-spiral-matrix-iv.java", "hypo_code": "class Solution {\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\n        int[][] res = new int[m][n];\n        int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        int d = 0;\n        int i = 0;\n        int j = 0;\n        while (head != null) {\n            res[i][j] = head.val;\n            head = head.next;\n            int x = i + dir[d][0];\n            int y = j + dir[d][1];\n            if (x < 0 || x >= m || y < 0 || y >= n || res[x][y] != 0) {\n                d = (d + 1) % 4;\n                x = i + dir[d][0];\n                y = j + dir[d][1];\n            }\n            i = x;\n            j = y;\n        }\n        return res;\n    }\n}"}
{"id": "1577", "path": "output2\\java\\Medium\\1577-number-of-people-aware-of-a-secret.java", "hypo_code": "class Solution {\n    public int peopleAwareOfSecret(int n, int delay, int forget) {\n        int[][] dp = new int[n + 1][n + 1];\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            dp[i][0] = dp[i - 1][0];\n            for (int j = 1; j <= i; j++) {\n                dp[i][j] = dp[i - 1][j - 1];\n                if (j >= delay) {\n                    dp[i][j] = (dp[i][j] + dp[i - delay][j - delay]) % 1000000007;\n                }\n                if (j >= forget) {\n                    dp[i][j] = (dp[i][j] - dp[i - forget][j - forget] + 1000000007) % 1000000007;\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i <= n; i++) {\n            res = (res + dp[n][i]) % 1000000007;\n        }\n        return res;\n    }\n}"}
{"id": "1578", "path": "output2\\java\\Medium\\1578-the-latest-time-to-catch-a-bus.java", "hypo_code": "class Solution {\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\n        int n = buses.length;\n        int m = passengers.length;\n        int[] dp = new int[m];\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (buses[i - 1] > pre[i]) {\n                pre[i] = buses[i - 1];\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            int l = 0, r = n - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (buses[mid] < passengers[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (buses[l] < passengers[i]) {\n                dp[i] = pre[n];\n            } else {\n                dp[i] = pre[l];\n            }\n        }\n        Arrays.sort(dp);\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            if (i % capacity == 0) {\n                ans++;\n            }\n            ans = Math.max(ans, dp[i] + 1);\n        }\n        return ans;\n    }\n}"}
{"id": "1579", "path": "output2\\java\\Medium\\1579-minimum-sum-of-squared-difference.java", "hypo_code": "class Solution {\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\n        int n = nums1.length;\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums1[i - 1] > nums2[i - 1]) {\n                pre[i]++;\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums2[mid] < nums2[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums2[l] < nums2[i]) {\n                res += pre[i] - pre[l];\n            } else {\n                res += pre[i] - pre[l] - 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1581", "path": "output2\\java\\Medium\\1581-move-pieces-to-obtain-a-string.java", "hypo_code": "class Solution {\n    public boolean canChange(String start, String target) {\n        int n = start.length();\n        int i = 0, j = 0;\n        while (i < n && j < n) {\n            while (i < n && start.charAt(i) == '_') {\n                i++;\n            }\n            while (j < n && target.charAt(j) == '_') {\n                j++;\n            }\n            if (i == n || j == n) {\n                return i == n && j == n;\n            }\n            if (start.charAt(i) != target.charAt(j)) {\n                return false;\n            }\n            if (start.charAt(i) == 'L' && i < j) {\n                return false;\n            }\n            if (start.charAt(i) == 'R' && i > j) {\n                return false;\n            }\n            i++;\n            j++;\n        }\n        return true;\n    }\n}"}
{"id": "1582", "path": "output2\\java\\Medium\\1582-max-sum-of-a-pair-with-equal-sum-of-digits.java", "hypo_code": "class Solution {\n    public int maximumSum(int[] nums) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        int[] cnt = new int[100];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            int sum = 0, x = nums[i - 1];\n            while (x > 0) {\n                sum += x % 10;\n                x /= 10;\n            }\n            pre[i] += ++cnt[sum];\n        }\n        int max = 0;\n        for (int i = 1; i <= n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (pre[mid] < pre[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (pre[l] < pre[i]) {\n                max = Math.max(max, nums[i - 1] + nums[l - 1]);\n            }\n        }\n        return max == 0 ? -1 : max;\n    }\n}"}
{"id": "1583", "path": "output2\\java\\Medium\\1583-query-kth-smallest-trimmed-number.java", "hypo_code": "class Solution {\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\n        int n = nums.length;\n        int[] res = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            String[] temp = new String[n];\n            for (int j = 0; j < n; j++) {\n                temp[j] = nums[j].substring(nums[j].length() - queries[i][1]);\n            }\n            Arrays.sort(temp);\n            res[i] = Integer.parseInt(temp[queries[i][0] - 1]);\n        }\n        return res;\n    }\n}"}
{"id": "1584", "path": "output2\\java\\Medium\\1584-number-of-zero-filled-subarrays.java", "hypo_code": "class NumberOfZeroFilledSubarrays {\n    public long zeroFilledSubarray(int[] nums) {\n        int n = nums.length;\n        long[][] dp = new long[n][n];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = -1;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            dp[i][i] = nums[i];\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                dp[i][j] = dp[i][j-1] & nums[j];\n            }\n        }\n        long count = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                if(dp[i][j] == 0){\n                    count++;\n                }\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1586", "path": "output2\\java\\Medium\\1586-equal-row-and-column-pairs.java", "hypo_code": "class EqualRowAndColumnPairs {\n    public int equalPairs(int[][] grid) {\n        int n = grid.length;\n        int[][] row = new int[n][n];\n        int[][] col = new int[n][n];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                row[i][j] = -1;\n                col[i][j] = -1;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            row[i][0] = grid[i][0];\n            col[0][i] = grid[0][i];\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = 1; j < n; j++){\n                row[i][j] = row[i][j-1] & grid[i][j];\n                col[j][i] = col[j-1][i] & grid[j][i];\n            }\n        }\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(row[i][j] == col[j][i]){\n                    count++;\n                }\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1588", "path": "output2\\java\\Medium\\1588-maximum-number-of-groups-entering-a-competition.java", "hypo_code": "class Solution {\n    public int maximumGroups(int[] grades) {\n        int[] cnt = new int[100001];\n        for (int grade : grades) {\n            cnt[grade]++;\n        }\n        int res = 0;\n        for (int i = 1; i <= 100000; i++) {\n            res += cnt[i] / i;\n            cnt[i] %= i;\n            cnt[i + 1] += cnt[i];\n        }\n        return res;\n    }\n}"}
{"id": "1589", "path": "output2\\java\\Medium\\1589-find-closest-node-to-given-two-nodes.java", "hypo_code": "class Solution {\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\n        int n = edges.length;\n        int[] inDegree = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (edges[i] != -1) {\n                inDegree[edges[i]]++;\n            }\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0 && (i == node1 || i == node2)) {\n                q.offer(i);\n            }\n        }\n        int res = -1;\n        while (!q.isEmpty()) {\n            int cur = q.poll();\n            if (res == -1 || Math.abs(cur - node1) < Math.abs(res - node1) || Math.abs(cur - node2) < Math.abs(res - node2)) {\n                res = cur;\n            }\n            if (cur == node1 && inDegree[node2] == 0) {\n                return res;\n            }\n            if (cur == node2 && inDegree[node1] == 0) {\n                return res;\n            }\n            if (edges[cur] != -1 && --inDegree[edges[cur]] == 0) {\n                q.offer(edges[cur]);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1590", "path": "output2\\java\\Medium\\1590-count-number-of-bad-pairs.java", "hypo_code": "class Solution {\n    public long countBadPairs(int[] nums) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1];\n            if (nums[i - 1] > nums[i - 2]) {\n                pre[i]++;\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int l = 0, r = i - 1;\n            while (l < r) {\n                int mid = l + r >> 1;\n                if (nums[mid] < nums[i]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            if (nums[l] < nums[i]) {\n                res += pre[i] - pre[l];\n            } else {\n                res += pre[i] - pre[l] - 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1591", "path": "output2\\java\\Medium\\1591-task-scheduler-ii.java", "hypo_code": "class Solution {\n    public long taskSchedulerII(int[] tasks, int space) {\n        if (tasks == null || tasks.length == 0) {\n            return 0;\n        }\n        int len = tasks.length;\n        int[] count = new int[26];\n        for (int task : tasks) {\n            count[task - 1]++;\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n        for (int i : count) {\n            if (i > 0) {\n                pq.offer(i);\n            }\n        }\n        int[] cd = new int[space];\n        int day = 0;\n        while (!pq.isEmpty()) {\n            int i = 0;\n            while (i < space) {\n                if (pq.isEmpty()) {\n                    break;\n                }\n                if (pq.peek() > 1) {\n                    cd[i++] = pq.poll() - 1;\n                } else {\n                    pq.poll();\n                    i++;\n                }\n            }\n            for (int j : cd) {\n                if (j > 0) {\n                    pq.offer(j);\n                }\n            }\n            day += pq.isEmpty() ? i : space;\n            Arrays.fill(cd, 0);\n        }\n        return day;\n    }\n}"}
{"id": "1592", "path": "output2\\java\\Medium\\1592-reachable-nodes-with-restrictions.java", "hypo_code": "class Solution {\n    public int reachableNodes(int n, int[][] edges, int[] restricted) {\n        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\n        for (int[] edge : edges) {\n            graph.computeIfAbsent(edge[0], k -> new HashMap<>()).put(edge[1], edge[2]);\n            graph.computeIfAbsent(edge[1], k -> new HashMap<>()).put(edge[0], edge[2]);\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);\n        Map<Integer, Integer> dist = new HashMap<>();\n        pq.offer(new int[]{0, 0});\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int node = cur[0];\n            int d = cur[1];\n            if (dist.containsKey(node)) {\n                continue;\n            }\n            dist.put(node, d);\n            for (int next : graph.getOrDefault(node, new HashMap<>()).keySet()) {\n                if (dist.containsKey(next)) {\n                    continue;\n                }\n                pq.offer(new int[]{next, d + graph.get(node).get(next) + 1});\n            }\n        }\n        int res = 0;\n        for (int[] edge : edges) {\n            int d1 = dist.getOrDefault(edge[0], 0);\n            int d2 = dist.getOrDefault(edge[1], 0);\n            if (d1 > d2) {\n                res += edge[2];\n            } else {\n                int left = edge[2] - (d2 - d1);\n                res += Math.max(0, left);\n            }\n        }\n        for (int r : restricted) {\n            if (dist.containsKey(r)) {\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1593", "path": "output2\\java\\Medium\\1593-check-if-there-is-a-valid-partition-for-the-array.java", "hypo_code": "class Solution {\n    public boolean validPartition(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int n : nums) {\n            map.put(n, map.getOrDefault(n, 0) + 1);\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);\n        for (int k : map.keySet()) {\n            pq.offer(new int[]{k, map.get(k)});\n        }\n        int[] prev = pq.poll();\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            if (cur[1] == 1) {\n                return false;\n            }\n            if (cur[1] == 2) {\n                if (prev[1] == 2) {\n                    return false;\n                }\n                prev = cur;\n                continue;\n            }\n            if (prev[1] == 2) {\n                prev = cur;\n                continue;\n            }\n            if (cur[0] - 1 != prev[0]) {\n                return false;\n            }\n            prev = cur;\n        }\n        return true;\n    }\n}"}
{"id": "1594", "path": "output2\\java\\Medium\\1594-longest-ideal-subsequence.java", "hypo_code": "class Solution {\n    public int longestIdealString(String s, int k) {\n        int n = s.length();\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int[] count = new int[26];\n            int max = 0;\n            for (int j = i; j < n; j++) {\n                int c = s.charAt(j) - 'a';\n                count[c]++;\n                max = Math.max(max, count[c]);\n                if (max - count[c] > k) {\n                    break;\n                }\n                res = Math.max(res, j - i + 1);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1595", "path": "output2\\java\\Medium\\1595-node-with-highest-edge-score.java", "hypo_code": "class Solution {\n    public int edgeScore(int[] edges) {\n        int n = edges.length;\n        int[] score = new int[n];\n        for (int i = 0; i < n; i++) {\n            score[edges[i]] += i;\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (score[i] > score[res]) {\n                res = i;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1596", "path": "output2\\java\\Medium\\1596-construct-smallest-number-from-di-string.java", "hypo_code": "class Solution {\n    public String smallestNumber(String pattern) {\n        int n = pattern.length();\n        int[] count = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            count[i] = i;\n        }\n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            if (pattern.charAt(i) == 'I') {\n                res.append(count[i]);\n                for (int j = i + 1; j >= 0; j--) {\n                    count[j]++;\n                }\n            }\n        }\n        res.append(count[n]);\n        return res.toString();\n    }\n}"}
{"id": "1597", "path": "output2\\java\\Medium\\1597-time-needed-to-rearrange-a-binary-string.java", "hypo_code": "class Solution {\n    public int secondsToRemoveOccurrences(String s) {\n        int n = s.length();\n        int res = 0;\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '0') {\n                count++;\n            } else {\n                res += count;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1598", "path": "output2\\java\\Medium\\1598-shifting-letters-ii.java", "hypo_code": "class Solution {\n    public String shiftingLetters(String s, int[][] shifts) {\n        int n = s.length();\n        int[] count = new int[n];\n        for (int[] shift : shifts) {\n            count[shift[0]] += shift[2];\n            if (shift[1] + 1 < n) {\n                count[shift[1] + 1] -= shift[2];\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += count[i];\n            res.append((char) ((s.charAt(i) - 'a' + sum) % 26 + 'a'));\n        }\n        return res.toString();\n    }\n}"}
{"id": "1599", "path": "output2\\java\\Medium\\1599-largest-palindromic-number.java", "hypo_code": "class Solution {\n    public String largestPalindromic(String num) {\n        int n = num.length();\n        char[] cs = num.toCharArray();\n        Arrays.sort(cs);\n        int l = 0;\n        int r = n - 1;\n        int[] count = new int[10];\n        for (int i = 0; i < n; i++) {\n            count[cs[i] - '0']++;\n        }\n        StringBuilder res = new StringBuilder();\n        for (int i = 9; i >= 0; i--) {\n            while (count[i] > 0) {\n                count[i]--;\n                if (l == r) {\n                    res.append(i);\n                    break;\n                }\n                if (cs[l] == i + '0') {\n                    res.append(cs[l]);\n                    l++;\n                    r--;\n                } else if (cs[r] == i + '0') {\n                    res.append(cs[r]);\n                    r--;\n                } else {\n                    res.append(i);\n                    break;\n                }\n            }\n            if (count[i] == 0) {\n                break;\n            }\n        }\n        return res.toString();\n    }\n}"}
{"id": "1600", "path": "output2\\java\\Medium\\1600-amount-of-time-for-binary-tree-to-be-infected.java", "hypo_code": "class Solution {\n    public int amountOfTime(TreeNode root, int start) {\n        if (root == null) {\n            return 0;\n        }\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\n        dfs(root, parent, null);\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        int res = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            boolean found = false;\n            for (int i = 0; i < size; i++) {\n                TreeNode cur = q.poll();\n                if (cur.val == start) {\n                    found = true;\n                }\n                if (cur.left != null) {\n                    q.offer(cur.left);\n                }\n                if (cur.right != null) {\n                    q.offer(cur.right);\n                } \n                if (parent.get(cur) != null) {\n                    q.offer(parent.get(cur));\n                }\n            }\n            if (found) {\n                res++;\n            }\n        }\n        return res;\n    }\n    private void dfs(TreeNode root, Map<TreeNode, TreeNode> parent, TreeNode pre) {\n        if (root == null) {\n            return;\n        }\n        parent.put(root, pre);\n        dfs(root.left, parent, root);\n        dfs(root.right, parent, root);\n\n    }\n}"}
{"id": "1601", "path": "output2\\java\\Medium\\1601-removing-stars-from-a-string.java", "hypo_code": "class Solution {\n    public String removeStars(String s) {\n        int n = s.length();\n        int[] count = new int[n];\n        int[] pos = new int[n];\n        int idx = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '*') {\n                pos[idx++] = i;\n            } else {\n                count[i] = idx;\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) != '*') {\n                if (count[i] > 0 && pos[count[i] - 1] == i - 1) {\n                    res.setLength(res.length() - 1);\n                } else {\n                    res.append(s.charAt(i));\n                }\n            }\n        }\n        return res.toString();\n    }\n}"}
{"id": "1602", "path": "output2\\java\\Medium\\1602-minimum-amount-of-time-to-collect-garbage.java", "hypo_code": "class Solution {\n    public int garbageCollection(String[] garbage, int[] travel) {\n        int n = garbage.length;\n        int[] time = new int[n];\n        for (int i = 0; i < n; i++) {\n            time[i] = garbage[i].length();\n        }\n        int m = travel.length;\n        int[] prefix = new int[m + 1];\n        for (int i = 0; i < m; i++) {\n            prefix[i + 1] = prefix[i] + travel[i];\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            int cur = 0;\n            for (int j = 0; j < n; j++) {\n                if (garbage[j].charAt(i) == 'M') {\n                    cur += prefix[j + 1] - prefix[j];\n                }\n            }\n            res = Math.min(res, cur + time[i]);\n        }\n        return res;\n    }\n}"}
{"id": "1603", "path": "output2\\java\\Medium\\1603-strictly-palindromic-number.java", "hypo_code": "class Solution {\n    public boolean isStrictlyPalindromic(int n) {\n        for (int i = 2; i <= n - 2; i++) {\n            int num = n;\n            int base = i;\n            StringBuilder sb = new StringBuilder();\n            while (num > 0) {\n                sb.append(num % base);\n                num /= base;\n            }\n            if (!sb.toString().equals(sb.reverse().toString())) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "1604", "path": "output2\\java\\Medium\\1604-maximum-rows-covered-by-columns.java", "hypo_code": "class Solution {\n    public int maximumRows(int[][] matrix, int numSelect) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int res = 0;\n        for (int i = 0; i < (1 << n); i++) {\n            int[] count = new int[m];\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                if (((i >> j) & 1) == 1) {\n                    cnt++;\n                    for (int k = 0; k < m; k++) {\n                        count[k] += matrix[k][j];\n                    }\n                }\n            }\n            if (cnt == numSelect) {\n                int c = 0;\n                for (int k = 0; k < m; k++) {\n                    if (count[k] == 0) {\n                        c++;\n                    }\n                }\n                res = Math.max(res, c);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1605", "path": "output2\\java\\Medium\\1605-number-of-ways-to-reach-a-position-after-exactly-k-steps.java", "hypo_code": "class Solution {\n    public int numberOfWays(int startPos, int endPos, int k) {\n        int mod = 1000000007;\n        int n = 1001;\n        int[][] dp = new int[k + 1][n];\n        dp[0][startPos] = 1;\n        for (int i = 1; i <= k; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod;\n            }\n        }\n        return dp[k][endPos];\n    }\n}"}
{"id": "1606", "path": "output2\\java\\Medium\\1606-longest-nice-subarray.java", "hypo_code": "class Solution {\n    public int longestNiceSubarray(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int[] count = new int[26];\n            int[] count2 = new int[26];\n            int max = 0;\n            int max2 = 0;\n            for (int j = i; j < n; j++) {\n                int c = nums[j];\n                if (c < 0) {\n                    c = -c;\n                    count2[c]++;\n                    max2 = Math.max(max2, count2[c]);\n                } else {\n                    count[c]++;\n                    max = Math.max(max, count[c]);\n                }\n                if (max > 0 && max2 > 0) {\n                    continue;\n                }\n                if (max > 0 && j - i + 1 > res) {\n                    res = j - i + 1;\n                }\n                if (max2 > 0 && j - i + 1 > res) {\n                    res = j - i + 1;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1607", "path": "output2\\java\\Medium\\1607-optimal-partition-of-string.java", "hypo_code": "class Solution {\n    public int partitionString(String s) {\n        int n = s.length();\n        int[] last = new int[26];\n        for (int i = 0; i < n; i++) {\n            last[s.charAt(i) - 'a'] = i;\n        }\n        int res = 0;\n        int l = 0;\n        int r = 0;\n        for (int i = 0; i < n; i++) {\n            r = Math.max(r, last[s.charAt(i) - 'a']);\n            if (i == r) {\n                res++;\n                l = i + 1;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1608", "path": "output2\\java\\Medium\\1608-divide-intervals-into-minimum-number-of-groups.java", "hypo_code": "class Solution {\n    public int minGroups(int[][] intervals) {\n        int n = intervals.length;\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n        int res = 1;\n        int prev = intervals[0][1];\n        for (int i = 1; i < n; i++) {\n            if (intervals[i][0] > prev) {\n                res++;\n                prev = intervals[i][1];\n            }\n        }\n        return res;\n\n    }\n}"}
{"id": "1609", "path": "output2\\java\\Medium\\1609-maximum-matching-of-players-with-trainers.java", "hypo_code": "class Solution {\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\n        int n = players.length;\n        int res = 0;\n        Arrays.sort(players);\n        Arrays.sort(trainers);\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        int i = 0;\n        for (int trainer : trainers) {\n            pq.offer(new int[]{trainer, i++});\n        }\n        for (int player : players) {\n            while (!pq.isEmpty() && pq.peek()[0] < player) {\n                pq.poll();\n            }\n            if (!pq.isEmpty()) {\n                pq.poll();\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1610", "path": "output2\\java\\Medium\\1610-smallest-subarrays-with-maximum-bitwise-or.java", "hypo_code": "class Solution {\n    public int[] smallestSubarrays(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        int[] max = new int[n];\n        max[n - 1] = nums[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            max[i] = nums[i] | max[i + 1];\n        }\n        for (int i = 0; i < n; i++) {\n            int cur = 0;\n            int min = Integer.MAX_VALUE;\n            for (int j = i; j < n; j++) {\n                cur |= nums[j];\n                if (cur == max[i]) {\n                    min = Math.min(min, j - i + 1);\n                }\n            }\n            res[i] = min;\n        }\n        return res;\n    }\n}"}
{"id": "1611", "path": "output2\\java\\Medium\\1611-length-of-the-longest-alphabetical-continuous-substring.java", "hypo_code": "class Solution {\n    public int longestContinuousSubstring(String s) {\n        int res = 0;\n        int n = s.length();\n        int len = 1;\n        for (int i = 1; i < n; i++) {\n            if (s.charAt(i) - s.charAt(i - 1) == 1) {\n                len++;\n            } else {\n                res = Math.max(res, len);\n                len = 1;\n            }\n        }\n        return Math.max(res, len);\n    }\n}"}
{"id": "1612", "path": "output2\\java\\Medium\\1612-reverse-odd-levels-of-binary-tree.java", "hypo_code": "class Solution {\n    public TreeNode reverseOddLevels(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        int level = 1;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            if (level % 2 == 1) {\n                List<TreeNode> list = new ArrayList<>();\n                for (int i = 0; i < size; i++) {\n                    TreeNode cur = q.poll();\n                    list.add(cur);\n                    if (cur.left != null) {\n                        q.offer(cur.left);\n                    }\n                    if (cur.right != null) {\n                        q.offer(cur.right);\n                    }\n                }\n                for (int i = 0, j = list.size() - 1; i < j; i++, j--) {\n                    TreeNode temp = list.get(i);\n                    list.set(i, list.get(j));\n                    list.set(j, temp);\n                }\n                for (TreeNode node : list) {\n                    q.offer(node);\n                }\n            } else {\n                for (int i = 0; i < size; i++) {\n                    TreeNode cur = q.poll();\n                    if (cur.left != null) {\n                        q.offer(cur.left);\n                    }\n                    if (cur.right != null) {\n                        q.offer(cur.right);\n                    }\n                }\n            }\n            level++;\n        }\n        return root;\n    }\n}"}
{"id": "1613", "path": "output2\\java\\Medium\\1613-longest-subarray-with-maximum-bitwise-and.java", "hypo_code": "class Solution {\n    public int longestSubarray(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int max = nums[i];\n            int min = nums[i];\n            for (int j = i; j < n; j++) {\n                max = Math.max(max, nums[j]);\n                min = Math.min(min, nums[j]);\n                if ((max & min) == max) {\n                    res = Math.max(res, j - i + 1);\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1614", "path": "output2\\java\\Medium\\1614-find-all-good-indices.java", "hypo_code": "class Solution {\n    public List<Integer> goodIndices(int[] nums, int k) {\n        int n = nums.length;\n        List<Integer> res = new ArrayList<>();\n        for (int i = k; i < n - k; i++) {\n            boolean valid = true;\n            for (int j = 1; j <= k; j++) {\n                if (nums[i - j] < nums[i - j + 1]) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (!valid) {\n                continue;\n            }\n            for (int j = 1; j <= k; j++) {\n                if (nums[i + j] > nums[i + j - 1]) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                res.add(i);\n            }\n        }\n        return res;\n\n    }\n}"}
{"id": "1616", "path": "output2\\java\\Medium\\1616-bitwise-xor-of-all-pairings.java", "hypo_code": "class Solution {\n    public int xorAllNums(int[] nums1, int[] nums2) {\n        int res = 0;\n        for (int i = 0; i < nums1.length; i++) {\n            res ^= nums1[i];\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            res ^= nums2[i];\n        }\n        return res;\n    }\n}"}
{"id": "1617", "path": "output2\\java\\Medium\\1617-maximum-sum-of-an-hourglass.java", "hypo_code": "class Solution {\n    public int maxSum(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int res = Integer.MIN_VALUE;\n        for (int i = 0; i < m - 2; i++) {\n            for (int j = 0; j < n - 2; j++) {\n                res = Math.max(res, grid[i][j] + grid[i][j + 1] + grid[i][j + 2]\n                                  + grid[i + 1][j + 1] + grid[i + 2][j] + grid[i + 2][j + 1]\n                                  + grid[i + 2][j + 2]);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1618", "path": "output2\\java\\Medium\\1618-minimize-xor.java", "hypo_code": "class Solution {\n    public int minimizeXor(int num1, int num2) {\n        int res = 0;\n        for (int i = 31; i >= 0; i--) {\n            int mask = 1 << i;\n            int b1 = num1 & mask;\n            int b2 = num2 & mask;\n            if (b1 == 0 && b2 == 0) {\n                continue;\n            }\n            if (b1 > 0 && b2 > 0) {\n                res |= mask;\n            }\n            if (b1 == 0 && b2 > 0) {\n                res |= mask;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1619", "path": "output2\\java\\Medium\\1619-find-the-original-array-of-prefix-xor.java", "hypo_code": "class Solution {\n    public int[] findArray(int[] pref) {\n        int n = pref.length;\n        if (n % 2 == 1) {\n            return new int[0];\n        }\n        Arrays.sort(pref);\n        int[] res = new int[n / 2];\n        int j = 0;\n        for (int i = 1; i < n; i += 2) {\n            res[j++] = pref[i] ^ pref[i - 1];\n        }\n        return res;\n    }\n}"}
{"id": "1620", "path": "output2\\java\\Medium\\1620-using-a-robot-to-print-the-lexicographically-smallest-string.java", "hypo_code": "class Solution {\n    public String robotWithString(String s) {\n        int n = s.length();\n        StringBuilder res = new StringBuilder();\n        int l = 0;\n        int r = n - 1;\n        while (l <= r) {\n            if (s.charAt(l) < s.charAt(r)) {\n                res.append(s.charAt(l++));\n            } else if (s.charAt(l) > s.charAt(r)) {\n                res.append(s.charAt(r--));\n            } else {\n                int i = l + 1;\n                int j = r - 1;\n                while (i < j && s.charAt(i) == s.charAt(j)) {\n                    i++;\n                    j--;\n                }\n                if (i < j && s.charAt(i) < s.charAt(j)) {\n                    res.append(s.charAt(l++));\n                } else {\n                    res.append(s.charAt(r--));\n                }\n            }\n        }\n        return res.toString();\n    }\n}"}
{"id": "1621", "path": "output2\\java\\Medium\\1621-range-product-queries-of-powers.java", "hypo_code": "class Solution {\n    public int[] productQueries(int n, int[][] queries) {\n        int[] res = new int[queries.length];\n        List<Integer> powers = new ArrayList<>();\n        powers.add(1);\n        int power = 1;\n        while (power <= n) {\n            powers.add(power);\n            power *= 2;\n        }\n        int i = 0;\n        for (int[] query : queries) {\n            int left = query[0];\n            int right = query[1];\n            int product = 1;\n            for (int j = left; j <= right; j++) {\n                product = (int)((long)product * powers.get(j) % (long)(1e9 + 7));\n            }\n            res[i++] = product;\n        }\n        return res;\n    }\n}"}
{"id": "1622", "path": "output2\\java\\Medium\\1622-minimize-maximum-of-array.java", "hypo_code": "class MinimizeMaximumOfArray {\n    public int minimizeArrayValue(int[] nums) {\n        int n = nums.length;\n        int[][] dp = new int[n][n];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            dp[i][i] = nums[i];\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                dp[i][j] = Math.min(dp[i][j-1], nums[j]);\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                min = Math.min(min, Math.max(dp[i][j], j-i+1));\n            }\n        }\n        return min;\n        \n    }\n}"}
{"id": "1623", "path": "output2\\java\\Medium\\1623-count-number-of-distinct-integers-after-reverse-operations.java", "hypo_code": "class CountNumberOfDistinctIntegersAfterReverseOperations {\n    public int countDistinctIntegers(int[] nums) {\n        int[] count = new int[100000];\n        for (int num : nums) {\n            count[reverse(num)]++;\n        }\n        int result = 0;\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] > 0) {\n                result++;\n            }\n        }\n        return result;\n        \n        \n    }\n}"}
{"id": "1624", "path": "output2\\java\\Medium\\1624-sum-of-number-and-its-reverse.java", "hypo_code": "class SumOfNumberAndItsReverse {\n    public boolean sumOfNumberAndReverse(int num) {\n        int sum = 0;\n        int reverse = 0;\n        int temp = num;\n        while (temp > 0) {\n            int digit = temp % 10;\n            reverse = reverse * 10 + digit;\n            temp /= 10;\n        }\n        sum = num + reverse;\n        while (sum > 0) {\n            int digit = sum % 10;\n            if (digit % 2 == 1) {\n                return false;\n            }\n            sum /= 10;\n        }\n        return true;\n        \n    }\n}"}
{"id": "1625", "path": "output2\\java\\Medium\\1625-number-of-subarrays-with-gcd-equal-to-k.java", "hypo_code": "class NumberOfSubarraysWithGcdEqualToK {\n    public int subarrayGCD(int[] nums, int k) {\n        int[] count = new int[k + 1];\n        for(int i = 0; i < nums.length; i++){\n            int gcd = nums[i];\n            for(int j = i; j < nums.length; j++){\n                gcd = gcd(gcd, nums[j]);\n                if(gcd == k){\n                    count[k]++;\n                }else if(gcd < k){\n                    count[gcd]++;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 1; i <= k; i++){\n            ans += count[i];\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "1626", "path": "output2\\java\\Medium\\1626-words-within-two-edits-of-dictionary.java", "hypo_code": "class WordsWithinTwoEditsOfDictionary {\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\n        Set<String> dict = new HashSet<>(Arrays.asList(dictionary));\n        List<String> res = new ArrayList<>();\n        for(String query : queries){\n            if(dict.contains(query)){\n                res.add(query);\n            }else{\n                if(canEdit(query, dict)){\n                    res.add(query);\n                }\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1627", "path": "output2\\java\\Medium\\1627-destroy-sequential-targets.java", "hypo_code": "class DestroySequentialTargets {\n    public int destroyTargets(int[] nums, int space) {\n        int max = 0;\n        for(int i = 0; i < nums.length; i++){\n            int count = 0;\n            for(int j = 0; j < nums.length; j++){\n                if(nums[j] % space == nums[i] % space){\n                    count++;\n                }\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n        \n    }\n}"}
{"id": "1628", "path": "output2\\java\\Medium\\1628-most-popular-video-creator.java", "hypo_code": "class MostPopularVideoCreator {\n    public List<List<String>> mostPopularCreator(String[] creators, String[] ids, int[] views) {\n        Map<String, Map<String, Integer>> map = new HashMap<>();\n        for(int i = 0; i < creators.length; i++){\n            map.putIfAbsent(creators[i], new HashMap<>());\n            map.get(creators[i]).put(ids[i], views[i]);\n        }\n        int max = 0;\n        List<List<String>> res = new ArrayList<>();\n        for(String creator : map.keySet()){\n            int sum = 0;\n            for(String id : map.get(creator).keySet()){\n                sum += map.get(creator).get(id);\n            }\n            if(sum > max){\n                max = sum;\n                res = new ArrayList<>();\n                res.add(Arrays.asList(creator, getMostPopularVideo(map.get(creator))));\n            }else if(sum == max){\n                res.add(Arrays.asList(creator, getMostPopularVideo(map.get(creator))));\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1629", "path": "output2\\java\\Medium\\1629-minimum-addition-to-make-integer-beautiful.java", "hypo_code": "class MinimumAdditionToMakeIntegerBeautiful {\n    public long makeIntegerBeautiful(long n, int target) {\n        long sum = 0;\n        long num = n;\n        while(num > 0){\n            sum += num % 10;\n            num /= 10;\n        }\n        if(sum <= target){\n            return 0;\n        }\n        long count = 0;\n        long base = 1;\n        while(sum > target){\n            long digit = n / base % 10;\n            long diff = 10 - digit;\n            count += diff * base;\n            sum -= digit;\n            sum += 9;\n            base *= 10;\n        }\n        return count;\n        \n    }\n}"}
{"id": "1630", "path": "output2\\java\\Medium\\1630-maximum-sum-of-distinct-subarrays-with-length-k.java", "hypo_code": "class MaximumSumOfDistinctSubarraysWithLengthK {\n    public long maximumSubarraySum(int[] nums, int k) {\n        long res = 0;\n        int n = nums.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            if(i == 0 || nums[i] != nums[i - 1]){\n                count++;\n            }else{\n                count = 1;\n            }\n            left[i] = count;\n        }\n        count = 0;\n        for(int i = n - 1; i >= 0; i--){\n            if(i == n - 1 || nums[i] != nums[i + 1]){\n                count++;\n            }else{\n                count = 1;\n            }\n            right[i] = count;\n        }\n        for(int i = 0; i < n - 1; i++){\n            if(nums[i] != nums[i + 1]){\n                res = Math.max(res, nums[i] * left[i] + nums[i + 1] * right[i + 1]);\n            }\n            if(i > 0 && nums[i - 1] != nums[i + 1]){\n                res = Math.max(res, nums[i - 1] * left[i - 1] + nums[i] * (left[i] - 1) + nums[i + 1] * right[i + 1]);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1631", "path": "output2\\java\\Medium\\1631-total-cost-to-hire-k-workers.java", "hypo_code": "class TotalCostToHireKWorkers {\n    public long totalCost(int[] costs, int k, int candidates) {\n        int n = costs.length;\n        int[][] workers = new int[n][2];\n        for(int i = 0; i < n; i++){\n            workers[i][0] = costs[i];\n            workers[i][1] = i;\n        }\n        Arrays.sort(workers, (a, b) -> a[0] - b[0]);\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        long sum = 0;\n        long res = Long.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            sum += workers[i][0];\n            pq.offer(workers[i][0]);\n            if(pq.size() > k){\n                sum -= pq.poll();\n            }\n            if(pq.size() == k){\n                res = Math.min(res, sum * candidates);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1632", "path": "output2\\java\\Medium\\1632-count-ways-to-build-good-strings.java", "hypo_code": "class CountWaysToBuildGoodStrings {\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int mod = 1000000007;\n        int[][][] dp = new int[low + 1][high + 1][2];\n        for(int i = 0; i <= low; i++){\n            for(int j = 0; j <= high; j++){\n                for(int k = 0; k < 2; k++){\n                    dp[i][j][k] = -1;\n                }\n            }\n        }\n        return dfs(low, high, zero, one, 0, 0, 0, dp) % mod;\n        \n        \n    }\n}"}
{"id": "1633", "path": "output2\\java\\Medium\\1633-most-profitable-path-in-a-tree.java", "hypo_code": "class MostProfitablePathInATree {\n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\n        int[] dp = new int[amount.length];\n        for(int i = 0; i < amount.length; i++){\n            if(amount[i] < 0){\n                dp[i] = amount[i];\n            }\n        }\n        for(int i = 0; i < edges.length; i++){\n            int[] edge = edges[i];\n            int a = edge[0];\n            int b = edge[1];\n            if(amount[a] < 0 && amount[b] < 0){\n                dp[a] = Math.min(dp[a], dp[b] + amount[a] + amount[b]);\n                dp[b] = Math.min(dp[b], dp[a] + amount[a] + amount[b]);\n            }\n            if(amount[a] < 0 && amount[b] >= 0){\n                dp[a] = Math.min(dp[a], dp[b] + amount[a]);\n                dp[b] = Math.min(dp[b], dp[a] + amount[a]);\n            }\n            if(amount[a] >= 0 && amount[b] < 0){\n                dp[a] = Math.min(dp[a], dp[b] + amount[b]);\n                dp[b] = Math.min(dp[b], dp[a] + amount[b]);\n            }\n            if(amount[a] >= 0 && amount[b] >= 0){\n                dp[a] = Math.min(dp[a], dp[b]);\n                dp[b] = Math.min(dp[b], dp[a]);\n            }\n        }\n        return -dp[bob];\n        \n    }\n}"}
{"id": "1634", "path": "output2\\java\\Medium\\1634-number-of-subarrays-with-lcm-equal-to-k.java", "hypo_code": "class NumberOfSubarraysWithLcmEqualToK {\n    public int subarrayLCM(int[] nums, int k) {\n        int count = 0;\n        int[] dp = new int[nums.length];\n        for(int i = 0; i < nums.length; i++){\n            if(nums[i] % k == 0){\n                dp[i] = 1;\n            }\n            for(int j = i - 1; j >= 0; j--){\n                if(nums[j] % k == 0){\n                    dp[j] = 0;\n                }\n                if(nums[j] % k == 0 && nums[i] % k == 0){\n                    dp[j] = dp[j] + 1;\n                }\n                if(nums[j] % k == 0 && nums[i] % k != 0){\n                    dp[j] = dp[j] + 1;\n                }\n                if(nums[j] % k != 0 && nums[i] % k == 0){\n                    dp[j] = dp[j] + 1;\n                }\n                if(nums[j] % k != 0 && nums[i] % k != 0){\n                    dp[j] = dp[j] + 1;\n                }\n            }\n            for(int j = 0; j < dp.length; j++){\n                count += dp[j];\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1635", "path": "output2\\java\\Medium\\1635-minimum-number-of-operations-to-sort-a-binary-tree-by-level.java", "hypo_code": "class MinimumNumberOfOperationsToSortABinaryTreeByLevel {\n    public int minimumOperations(TreeNode root) {\n        List<List<Integer>> list = new ArrayList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            List<Integer> temp = new ArrayList<>();\n            for(int i = 0; i < size; i++){\n                TreeNode node = queue.poll();\n                temp.add(node.val);\n                if(node.left != null){\n                    queue.add(node.left);\n                }\n                if(node.right != null){\n                    queue.add(node.right);\n                }\n            }\n            list.add(temp);\n        }\n        int count = 0;\n        for(int i = 0; i < list.size(); i++){\n            List<Integer> temp = list.get(i);\n            Collections.sort(temp);\n            for(int j = 0; j < temp.size(); j++){\n                if(temp.get(j) != list.get(i).get(j)){\n                    count++;\n                }\n            }\n        }\n        return count;\n        \n    }\n}"}
{"id": "1636", "path": "output2\\java\\Medium\\1636-closest-nodes-queries-in-a-binary-search-tree.java", "hypo_code": "class ClosestNodesQueriesInABinarySearchTree {\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\n        List<List<Integer>> list = new ArrayList<>();\n        for(int i = 0; i < queries.size(); i++){\n            int min = Integer.MIN_VALUE;\n            int max = Integer.MAX_VALUE;\n            TreeNode node = root;\n            while(node != null){\n                if(node.val == queries.get(i)){\n                    min = node.val;\n                    max = node.val;\n                    break;\n                }\n                else if(node.val > queries.get(i)){\n                    max = node.val;\n                    node = node.left;\n                }\n                else{\n                    min = node.val;\n                    node = node.right;\n                }\n            }\n            List<Integer> temp = new ArrayList<>();\n            temp.add(min);\n            temp.add(max);\n            list.add(temp);\n        }\n        return list;\n        \n        \n    }\n}"}
{"id": "1637", "path": "output2\\java\\Medium\\1637-minimum-fuel-cost-to-report-to-the-capital.java", "hypo_code": "class MinimumFuelCostToReportToTheCapital {\n    public long minimumFuelCost(int[][] roads, int seats) {\n        int n = roads.length + 1;\n        List<List<int[]>> graph = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            graph.add(new ArrayList<>());\n        }\n        for(int[] road : roads){\n            graph.get(road[0]).add(new int[]{road[1], 1});\n            graph.get(road[1]).add(new int[]{road[0], 1});\n        }\n        long[] dp = new long[n];\n        Arrays.fill(dp, Long.MAX_VALUE);\n        dp[0] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{0, 0});\n        while(!pq.isEmpty()){\n            int[] cur = pq.poll();\n            int city = cur[0];\n            long cost = cur[1];\n            if(cost > dp[city]){\n                continue;\n            }\n            for(int[] next : graph.get(city)){\n                int nextCity = next[0];\n                long nextCost = cost + next[1];\n                if(nextCost < dp[nextCity]){\n                    dp[nextCity] = nextCost;\n                    pq.offer(new int[]{nextCity, (int)nextCost});\n                }\n            }\n        }\n        long res = 0;\n        for(int i = 1; i < n; i++){\n            res += dp[i];\n        }\n        return res;\n        \n    }\n}"}
{"id": "1638", "path": "output2\\java\\Medium\\1638-difference-between-ones-and-zeros-in-row-and-column.java", "hypo_code": "class DifferenceBetweenOnesAndZerosInRowAndColumn {\n    public int[][] onesMinusZeros(int[][] grid) {\n        int[][] diff = new int[grid.length][grid[0].length];\n        int[] onesRow = new int[grid.length];\n        int[] onesCol = new int[grid[0].length];\n        int[] zerosRow = new int[grid.length];\n        int[] zerosCol = new int[grid[0].length];\n        for(int i = 0; i < grid.length; i++){\n            for(int j = 0; j < grid[0].length; j++){\n                if(grid[i][j] == 1){\n                    onesRow[i]++;\n                    onesCol[j]++;\n                }else{\n                    zerosRow[i]++;\n                    zerosCol[j]++;\n                }\n            }\n        }\n        for(int i = 0; i < grid.length; i++){\n            for(int j = 0; j < grid[0].length; j++){\n                diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j];\n            }\n        }\n        return diff;\n        \n    }\n}"}
{"id": "1639", "path": "output2\\java\\Medium\\1639-minimum-penalty-for-a-shop.java", "hypo_code": "class MinimumPenaltyForAShop {\n    public int bestClosingTime(String customers) {\n        int n = customers.length();\n        int[] prefix = new int[n + 1];\n        for(int i = 0; i < n; i++){\n            prefix[i + 1] = prefix[i] + (customers.charAt(i) == 'Y' ? 1 : 0);\n        }\n        int res = 0;\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i <= n; i++){\n            int penalty = prefix[i] + (n - i - (prefix[n] - prefix[i]));\n            if(penalty < min){\n                min = penalty;\n                res = i;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1640", "path": "output2\\java\\Medium\\1640-append-characters-to-string-to-make-subsequence.java", "hypo_code": "class AppendCharactersToStringToMakeSubsequence {\n    public int appendCharacters(String s, String t) {\n        int m = s.length();\n        int n = t.length();\n        int[][] dp = new int[m + 1][n + 1];\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                if(s.charAt(i - 1) == t.charAt(j - 1)){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else{\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return n - dp[m][n];\n        \n    }\n}"}
{"id": "1641", "path": "output2\\java\\Medium\\1641-remove-nodes-from-linked-list.java", "hypo_code": "class RemoveNodesFromLinkedList {\n    public ListNode removeNodes(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        ListNode curr = head;\n        while(curr != null){\n            while(curr.next != null && curr.val >= curr.next.val){\n                curr = curr.next;\n            }\n            if(prev.next == curr){\n                prev = prev.next;\n            }else{\n                prev.next = curr.next;\n            }\n            curr = curr.next;\n        }\n        return dummy.next;\n        \n        \n    }\n}"}
{"id": "1642", "path": "output2\\java\\Medium\\1642-divide-players-into-teams-of-equal-skill.java", "hypo_code": "class DividePlayersIntoTeamsOfEqualSkill {\n    public long dividePlayers(int[] skill) {\n        int n = skill.length;\n        long[][] dp = new long[n][n];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(dp[i], -1);\n        }\n        return dividePlayers(skill, 0, n - 1, dp);\n        \n        \n        \n    }\n}"}
{"id": "1643", "path": "output2\\java\\Medium\\1643-minimum-score-of-a-path-between-two-cities.java", "hypo_code": "class MinimumScoreOfAPathBetweenTwoCities {\n    public int minScore(int n, int[][] roads) {\n        int[][] g = new int[n][n];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(g[i], Integer.MAX_VALUE);\n        }\n        for(int[] r : roads){\n            g[r[0] - 1][r[1] - 1] = r[2];\n            g[r[1] - 1][r[0] - 1] = r[2];\n        }\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n        boolean[] visited = new boolean[n];\n        for(int i = 0; i < n; i++){\n            int min = Integer.MAX_VALUE;\n            int u = -1;\n            for(int j = 0; j < n; j++){\n                if(!visited[j] && dist[j] < min){\n                    min = dist[j];\n                    u = j;\n                }\n            }\n            if(u == -1){\n                break;\n            }\n            visited[u] = true;\n            for(int v = 0; v < n; v++){\n                if(!visited[v] && g[u][v] != Integer.MAX_VALUE){\n                    dist[v] = Math.min(dist[v], Math.max(dist[u], g[u][v]));\n                }\n            }\n        }\n        return dist[n - 1];\n        \n        \n        \n    }\n}"}
{"id": "1644", "path": "output2\\java\\Medium\\1644-maximum-star-sum-of-a-graph.java", "hypo_code": "class MaximumStarSumOfAGraph {\n    public int maxStarSum(int[] vals, int[][] edges, int k) {\n        int n = vals.length;\n        int[] dp = new int[n];\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i != j && vals[i] > vals[j]){\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                    res = Math.max(res, dp[i]);\n                }\n            }\n        }\n        return res == 0 ? -1 : res + 1;\n        \n    }\n}"}
{"id": "1645", "path": "output2\\java\\Medium\\1645-frog-jump-ii.java", "hypo_code": "class FrogJumpIi {\n    public int maxJump(int[] stones) {\n        int n = stones.length;\n        int[] dp = new int[n];\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < i; j++){\n                if(stones[i] - stones[j] <= i - j){\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                    res = Math.max(res, dp[i]);\n                }\n            }\n        }\n        return res == 0 ? -1 : res + 1;\n        \n    }\n}"}
{"id": "1646", "path": "output2\\java\\Medium\\1646-longest-square-streak-in-an-array.java", "hypo_code": "class LongestSquareStreakInAnArray {\n    public int longestSquareStreak(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < i; j++){\n                if(nums[i] == nums[j] * nums[j]){\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                    res = Math.max(res, dp[i]);\n                }\n            }\n        }\n        return res == 0 ? -1 : res + 1;\n        \n    }\n}"}
{"id": "1648", "path": "output2\\java\\Medium\\1648-smallest-value-after-replacing-with-sum-of-prime-factors.java", "hypo_code": "class SmallestValueAfterReplacingWithSumOfPrimeFactors {\n    public int smallestValue(int n) {\n        int res = 0;\n        for(int i = 2; i * i <= n; i++){\n            while(n % i == 0){\n                res += i;\n                n /= i;\n            }\n        }\n        if(n > 1){\n            res += n;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1649", "path": "output2\\java\\Medium\\1649-reward-top-k-students.java", "hypo_code": "class RewardTopKStudents {\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\n        Map<String, Integer> positive = new HashMap<>();\n        Map<String, Integer> negative = new HashMap<>();\n        for(String s : positive_feedback){\n            positive.put(s, positive.getOrDefault(s, 0) + 1);\n        }\n        for(String s : negative_feedback){\n            negative.put(s, negative.getOrDefault(s, 0) + 1);\n        }\n        Map<Integer, Integer> points = new HashMap<>();\n        for(int i = 0; i < report.length; i++){\n            String[] words = report[i].split(\" \");\n            for(String word : words){\n                if(positive.containsKey(word)){\n                    points.put(student_id[i], points.getOrDefault(student_id[i], 0) + 3);\n                }else if(negative.containsKey(word)){\n                    points.put(student_id[i], points.getOrDefault(student_id[i], 0) - 1);\n                }\n            }\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\n            if(a[0] == b[0]){\n                return a[1] - b[1];\n            }\n            return b[0] - a[0];\n        });\n        for(int id : points.keySet()){\n            pq.add(new int[]{points.get(id), id});\n        }\n        List<Integer> ans = new ArrayList<>();\n        while(k-- > 0){\n            ans.add(pq.poll()[1]);\n        }\n        return ans;\n    }\n}"}
{"id": "1650", "path": "output2\\java\\Medium\\1650-minimize-the-maximum-of-two-arrays.java", "hypo_code": "class MinimizeTheMaximumOfTwoArrays {\n    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {\n        int l = 1;\n        int r = 1000000000;\n        while(l < r){\n            int mid = l + (r - l) / 2;\n            if(check(mid, divisor1, divisor2, uniqueCnt1, uniqueCnt2)){\n                r = mid;\n            }else{\n                l = mid + 1;\n            }\n        }\n        return l;\n        \n        \n    }\n}"}
{"id": "1651", "path": "output2\\java\\Medium\\1651-take-k-of-each-character-from-left-and-right.java", "hypo_code": "class TakeKOfEachCharacterFromLeftAndRight {\n    public int takeCharacters(String s, int k) {\n        int n = s.length();\n        int[][] dp = new int[n + 1][k + 1];\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= k; j++){\n                dp[i][j] = dp[i - 1][j];\n                if(s.charAt(i - 1) == 'a'){\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);\n                }\n            }\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= k; j++){\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n                if(s.charAt(n - i) == 'a'){\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);\n                }\n            }\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= k; j++){\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n                if(s.charAt(i - 1) == 'b'){\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);\n                }\n            }\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= k; j++){\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n                if(s.charAt(n - i) == 'b'){\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);\n                }\n            }\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= k; j++){\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n                if(s.charAt(i - 1) == 'c'){\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);\n        \n    }\n}"}
{"id": "1652", "path": "output2\\java\\Medium\\1652-maximum-tastiness-of-candy-basket.java", "hypo_code": "class MaximumTastinessOfCandyBasket {\n    public int maximumTastiness(int[] price, int k) {\n        int n = price.length;\n        int[][] dp = new int[n + 1][k + 1];\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= k; j++){\n                dp[i][j] = dp[i - 1][j];\n                if(j <= i){\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + price[i - 1]);\n                }\n            }\n        }\n        return dp[n][k];\n        \n    }\n}"}
{"id": "1653", "path": "output2\\java\\Medium\\1653-distinct-prime-factors-of-product-of-array.java", "hypo_code": "class DistinctPrimeFactorsOfProductOfArray {\n    public int distinctPrimeFactors(int[] nums) {\n        int n = nums.length;\n        int[] cnt = new int[100001];\n        for(int i = 0; i < n; i++){\n            int num = nums[i];\n            for(int j = 2; j * j <= num; j++){\n                if(num % j == 0){\n                    cnt[j]++;\n                    while(num % j == 0){\n                        num /= j;\n                    }\n                }\n            }\n            if(num > 1){\n                cnt[num]++;\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < 100001; i++){\n            if(cnt[i] > 0){\n                res++;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1654", "path": "output2\\java\\Medium\\1654-partition-string-into-substrings-with-values-at-most-k.java", "hypo_code": "class PartitionStringIntoSubstringsWithValuesAtMostK {\n    public int minimumPartition(String s, int k) {\n        int n = s.length();\n        int[] cnt = new int[10];\n        for(int i = 0; i < n; i++){\n            cnt[s.charAt(i) - '0']++;\n        }\n        int res = 0;\n        for(int i = 1; i <= 9; i++){\n            if(cnt[i] > 0){\n                res++;\n                cnt[i]--;\n                int j = i;\n                while(j <= 9 && cnt[j] > 0){\n                    cnt[j]--;\n                    j++;\n                }\n                if(j > k){\n                    return -1;\n                }\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "1655", "path": "output2\\java\\Medium\\1655-closest-prime-numbers-in-range.java", "hypo_code": "class ClosestPrimeNumbersInRange {\n    public int[] closestPrimes(int left, int right) {\n        int[] res = new int[2];\n        int min = Integer.MAX_VALUE;\n        for(int i = left; i <= right; i++){\n            if(isPrime(i)){\n                if(i - 1 >= left && isPrime(i - 1) && i - 1 - left < min){\n                    min = i - 1 - left;\n                    res[0] = i - 1;\n                    res[1] = i;\n                }\n                if(i + 1 <= right && isPrime(i + 1) && right - i < min){\n                    min = right - i;\n                    res[0] = i;\n                    res[1] = i + 1;\n                }\n            }\n        }\n        return res[0] == 0 ? new int[]{-1, -1} : res;\n        \n    }\n}"}
{"id": "1657", "path": "output2\\java\\Medium\\1657-find-xor-beauty-of-array.java", "hypo_code": "class FindXorBeautyOfArray {\n    public int xorBeauty(int[] nums) {\n        int n = nums.length;\n        int[] cnt = new int[1 << 10];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                cnt[nums[i] | nums[j]]++;\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            res ^= cnt[nums[i]];\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "1658", "path": "output2\\java\\Medium\\1658-maximal-score-after-applying-k-operations.java", "hypo_code": "class MaximalScoreAfterApplyingKOperations {\n    public long maxKelements(int[] nums, int k) {\n        int n = nums.length;\n        long[] dp = new long[n + 1];\n        for(int i = 0; i < n; i++){\n            dp[i + 1] = dp[i] + nums[i];\n        }\n        long res = 0;\n        for(int i = 0; i <= k; i++){\n            if(i <= n && k - i <= n){\n                res = Math.max(res, maxKelements(dp, i) + maxKelements(dp, k - i));\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "1659", "path": "output2\\java\\Medium\\1659-make-number-of-distinct-characters-equal.java", "hypo_code": "class MakeNumberOfDistinctCharactersEqual {\n    public boolean isItPossible(String word1, String word2) {\n        int[] count1 = new int[26];\n        int[] count2 = new int[26];\n        for(char c : word1.toCharArray()){\n            count1[c - 'a']++;\n        }\n        for(char c : word2.toCharArray()){\n            count2[c - 'a']++;\n        }\n        int diff = 0;\n        for(int i = 0; i < 26; i++){\n            if(count1[i] > 0 && count2[i] > 0){\n                diff++;\n            }\n        }\n        int sum1 = 0;\n        int sum2 = 0;\n        for(int i = 0; i < 26; i++){\n            sum1 += count1[i];\n            sum2 += count2[i];\n        }\n        if(sum1 == sum2){\n            return diff < 26;\n        }\n        if(sum1 > sum2){\n            return (sum1 - sum2) % 2 == 0 && diff < 25;\n        }\n        return (sum2 - sum1) % 2 == 0 && diff < 25;\n        \n        \n        \n    }\n}"}
{"id": "1660", "path": "output2\\java\\Medium\\1660-increment-submatrices-by-one.java", "hypo_code": "class IncrementSubmatricesByOne {\n    public int[][] rangeAddQueries(int n, int[][] queries) {\n        int[][] res = new int[n][n];\n        for(int[] query : queries){\n            int row1 = query[0];\n            int col1 = query[1];\n            int row2 = query[2];\n            int col2 = query[3];\n            res[row1][col1]++;\n            if(row2 + 1 < n){\n                res[row2 + 1][col1]--;\n            }\n            if(col2 + 1 < n){\n                res[row1][col2 + 1]--;\n            }\n            if(row2 + 1 < n && col2 + 1 < n){\n                res[row2 + 1][col2 + 1]++;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = 1; j < n; j++){\n                res[i][j] += res[i][j - 1];\n            }\n        }\n        for(int i = 1; i < n; i++){\n            for(int j = 0; j < n; j++){\n                res[i][j] += res[i - 1][j];\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1661", "path": "output2\\java\\Medium\\1661-count-the-number-of-good-subarrays.java", "hypo_code": "class CountTheNumberOfGoodSubarrays {\n    public long countGood(int[] nums, int k) {\n        int n = nums.length;\n        int[] odd = new int[n + 2];\n        int m = 0;\n        for(int i = 0; i < n; i++){\n            if(nums[i] % 2 == 1){\n                odd[++m] = i;\n            }\n        }\n        odd[0] = -1;\n        odd[++m] = n;\n        long res = 0;\n        for(int i = k; i <= m - k; i++){\n            res += (long)(odd[i] - odd[i - 1]) * (odd[i + k] - odd[i + k - 1]);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1662", "path": "output2\\java\\Medium\\1662-minimum-operations-to-make-array-equal-ii.java", "hypo_code": "class MinimumOperationsToMakeArrayEqualIi {\n    public long minOperations(int[] nums1, int[] nums2, int k) {\n        int n = nums1.length;\n        int m = nums2.length;\n        if(n * 6 < k || m * 6 < k){\n            return -1;\n        }\n        int[] diff = new int[n + m];\n        for(int i = 0; i < n; i++){\n            diff[i] = nums1[i] - 1;\n        }\n        for(int i = 0; i < m; i++){\n            diff[n + i] = 6 - nums2[i];\n        }\n        Arrays.sort(diff);\n        long res = 0;\n        for(int i = 0; i < k; i++){\n            res += diff[i];\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1663", "path": "output2\\java\\Medium\\1663-maximum-subsequence-score.java", "hypo_code": "class MaximumSubsequenceScore {\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        long res = 0;\n        for(int i = 0; i <= k; i++){\n            if(i <= nums1.length && k - i <= nums2.length){\n                res = Math.max(res, maxScore(nums1, nums2, i) + maxScore(nums2, nums1, k - i));\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1664", "path": "output2\\java\\Medium\\1664-sort-the-students-by-their-kth-score.java", "hypo_code": "class SortTheStudentsByTheirKthScore {\n    public int[][] sortTheStudents(int[][] score, int k) {\n        Arrays.sort(score, (a, b) -> b[k] - a[k]);\n        return score;\n        \n        \n    }\n}"}
{"id": "1665", "path": "output2\\java\\Medium\\1665-apply-bitwise-operations-to-make-strings-equal.java", "hypo_code": "class ApplyBitwiseOperationsToMakeStringsEqual {\n    public boolean makeStringsEqual(String s, String target) {\n        int xor = 0;\n        for(int i = 0; i < s.length(); i++){\n            xor ^= s.charAt(i) ^ target.charAt(i);\n        }\n        return xor == 0;\n        \n    }\n}"}
{"id": "1666", "path": "output2\\java\\Medium\\1666-count-collisions-of-monkeys-on-a-polygon.java", "hypo_code": "class CountCollisionsOfMonkeysOnAPolygon {\n    public int monkeyMove(int n) {\n        long[] dp = new long[n];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i = 2; i < n; i++){\n            dp[i] = (dp[i - 1] + dp[i - 2]) * (i - 1) % 1000000007;\n        }\n        return (int)dp[n - 1];\n        \n        \n    }\n}"}
{"id": "1667", "path": "output2\\java\\Medium\\1667-maximum-number-of-integers-to-choose-from-a-range-i.java", "hypo_code": "class MaximumNumberOfIntegersToChooseFromARangeI {\n    public int maxCount(int[] banned, int n, int maxSum) {\n        int[] prefix = new int[n + 1];\n        for(int i : banned){\n            prefix[i]++;\n        }\n        for(int i = 1; i <= n; i++){\n            prefix[i] += prefix[i - 1];\n        }\n        int res = 0;\n        for(int i = 1; i <= n; i++){\n            int j = Math.min(n, maxSum - i);\n            if(prefix[j] - prefix[i - 1] == 0){\n                res = Math.max(res, j - i + 1);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1668", "path": "output2\\java\\Medium\\1668-maximize-win-from-two-segments.java", "hypo_code": "class MaximizeWinFromTwoSegments {\n    public int maximizeWin(int[] prizePositions, int k) {\n        int n = prizePositions.length;\n        int[] prefix = new int[n];\n        int[] suffix = new int[n];\n        int i = 0;\n        int j = 0;\n        int res = 0;\n        while(i < n){\n            while(j < n && prizePositions[j] - prizePositions[i] <= k){\n                j++;\n            }\n            prefix[i] = j - i;\n            res = Math.max(res, prefix[i]);\n            i++;\n        }\n        i = n - 1;\n        j = n - 1;\n        while(i >= 0){\n            while(j >= 0 && prizePositions[i] - prizePositions[j] <= k){\n                j--;\n            }\n            suffix[i] = i - j;\n            res = Math.max(res, suffix[i]);\n            i--;\n        }\n        for(i = 0; i < n - 1; i++){\n            res = Math.max(res, prefix[i] + suffix[i + 1]);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1669", "path": "output2\\java\\Medium\\1669-disconnect-path-in-a-binary-matrix-by-at-most-one-flip.java", "hypo_code": "class DisconnectPathInABinaryMatrixByAtMostOneFlip {\n    public boolean isPossibleToCutPath(int[][] grid) {\n         \n        int m = grid.length;\n        int n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        boolean[][] visited2 = new boolean[m][n];\n        boolean[][] visited3 = new boolean[m][n];\n        boolean[][] visited4 = new boolean[m][n];\n        boolean[][] visited5 = new boolean[m][n];\n        boolean[][] visited6 = new boolean[m][n];\n        boolean[][] visited7 = new boolean[m][n];\n        boolean[][] visited8 = new boolean[m][n];\n        boolean[][] visited9 = new boolean[m][n];\n        boolean[][] visited10 = new boolean[m][n];\n        boolean[][] visited11 = new boolean[m][n];\n        boolean[][] visited12 = new boolean[m][n];\n        boolean[][] visited13 = new boolean[m][n];\n        boolean[][] visited14 = new boolean[m][n];\n        boolean[][] visited15 = new boolean[m][n];\n        boolean[][] visited16 = new boolean[m][n];\n        boolean[][] visited17 = new boolean[m][n];\n        boolean[][] visited18 = new boolean[m][n];\n        boolean[][] visited19 = new boolean[m][n];\n        boolean[][] visited20 = new boolean[m][n];\n        boolean[][] visited21 = new boolean[m][n];\n        boolean[][] visited22 = new boolean[m][n];\n        boolean[][] visited23 = new boolean[m][n];\n        boolean[][] visited24 = new boolean[m][n];\n        boolean[][] visited25 = new boolean[m][n];\n        boolean[][] visited26 = new boolean[m][n];\n        boolean[][] visited27 = new boolean[m][n];\n        boolean[][] visited28 = new boolean[m][n];\n        boolean[][] visited29 = new boolean[m][n];\n        boolean[][] visited30 = new boolean[m][n];\n        boolean[][] visited31 = new boolean[m][n];\n        boolean[][] visited32 = new boolean[m][n];\n        boolean[][] visited33 = new boolean[m][n];\n        boolean[][] visited34 = new boolean[m][n];\n        boolean[][] visited35 = new boolean[m][n];\n        boolean[][] visited36 = new boolean[m][n];\n        boolean[][] visited37 = new boolean[m][n];\n        boolean[][] visited38 = new boolean[m][n];\n        boolean[][] visited39 = new boolean[m][n];\n        boolean[][] visited40 = new boolean[m][n];\n        boolean[][] visited41 = new boolean[m][n];\n\n        \n    }\n}"}
{"id": "1670", "path": "output2\\java\\Medium\\1670-count-vowel-strings-in-ranges.java", "hypo_code": "class CountVowelStringsInRanges {\n    public int[] vowelStrings(String[] words, int[][] queries) {\n        int[] res = new int[queries.length];\n        int[][] dp = new int[words.length + 1][5];\n        for(int i = 1; i <= words.length; i++){\n            for(int j = 0; j < 5; j++){\n                dp[i][j] = dp[i - 1][j];\n            }\n            char c = words[i - 1].charAt(0);\n            if(c == 'a'){\n                dp[i][0]++;\n            }else if(c == 'e'){\n                dp[i][1]++;\n            }else if(c == 'i'){\n                dp[i][2]++;\n            }else if(c == 'o'){\n                dp[i][3]++;\n            }else if(c == 'u'){\n                dp[i][4]++;\n            }\n        }\n        for(int i = 0; i < queries.length; i++){\n            int[] q = queries[i];\n            int[] start = dp[q[0]];\n            int[] end = dp[q[1] + 1];\n            res[i] = end[0] - start[0] + end[1] - start[1] + end[2] - start[2] + end[3] - start[3] + end[4] - start[4];\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1671", "path": "output2\\java\\Medium\\1671-house-robber-iv.java", "hypo_code": "class HouseRobberIv {\n    public int minCapability(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        int[] sum = new int[n];\n        sum[0] = nums[0];\n        for(int i = 1; i < n; i++){\n            sum[i] = sum[i - 1] + nums[i];\n        }\n        for(int i = 0; i < k; i++){\n            dp[i] = sum[i];\n        }\n        for(int i = k; i < n; i++){\n            dp[i] = sum[i] - sum[i - k];\n            for(int j = i - k + 1; j < i; j++){\n                dp[i] = Math.min(dp[i], dp[j] + sum[i] - sum[j]);\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for(int i = n - k; i < n; i++){\n            res = Math.min(res, dp[i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1672", "path": "output2\\java\\Medium\\1672-count-the-number-of-fair-pairs.java", "hypo_code": "class Solution {\n    public long countFairPairs(int[] nums, int lower, int upper) {\n        long count = 0;\n        int[] counts = new int[upper - lower + 1];\n        for (int num : nums) {\n            counts[num - lower]++;\n        }\n        for (int i = 0; i < counts.length; i++) {\n            count += (long) counts[i] * (counts[i] - 1) / 2;\n        }\n        return count;\n    }\n}"}
{"id": "1673", "path": "output2\\java\\Medium\\1673-substring-xor-queries.java", "hypo_code": "class Solution {\n    public int[][] substringXorQueries(String s, int[][] queries) {\n        int n = s.length();\n        int[] prefix = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = prefix[i] ^ (s.charAt(i) - '0');\n        }\n        int[][] result = new int[queries.length][2];\n        for (int i = 0; i < queries.length; i++) {\n            int[] query = queries[i];\n            int start = query[0];\n            int end = query[1];\n            result[i][0] = -1;\n            result[i][1] = -1;\n            for (int j = start; j <= end; j++) {\n                int xor = prefix[j] ^ prefix[start];\n                if (xor == end - start) {\n                    if (result[i][0] == -1) {\n                        result[i][0] = j - start;\n                    }\n                    result[i][1] = j - start;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "1674", "path": "output2\\java\\Medium\\1674-minimum-score-by-changing-two-elements.java", "hypo_code": "class Solution {\n    public int minimizeSum(int[] nums) {\n        int n = nums.length;\n        int min1 = Integer.MAX_VALUE;\n        int min2 = Integer.MAX_VALUE;\n        int max1 = Integer.MIN_VALUE;\n        int max2 = Integer.MIN_VALUE;\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            if (num < min1) {\n                min2 = min1;\n                min1 = num;\n            } else if (num < min2) {\n                min2 = num;\n            }\n            if (num > max1) {\n                max2 = max1;\n                max1 = num;\n            } else if (num > max2) {\n                max2 = num;\n            }\n        }\n        return Math.min(max1 - min1, max2 - min2);\n    }\n}"}
{"id": "1675", "path": "output2\\java\\Medium\\1675-minimum-impossible-or.java", "hypo_code": "class Solution {\n    public int minImpossibleOR(int[] nums) {\n        int n = nums.length;\n        int max = 1;\n        for (int num : nums) {\n            max |= num;\n        }\n        int[] dp = new int[max + 1];\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            for (int j = max; j >= 0; j--) {\n                if (dp[j] == 1 && j | num <= max) {\n                    dp[j | num] = 1;\n                }\n            }\n            dp[num] = 1;\n        }\n        for (int i = 1; i <= max; i++) {\n            if (dp[i] == 0) {\n                return i;\n            }\n        }\n        return max + 1;\n    }\n}"}
{"id": "1676", "path": "output2\\java\\Medium\\1676-minimum-operations-to-reduce-an-integer-to-0.java", "hypo_code": "class Solution {\n    public int minOperations(int n) {\n        int count = 0;\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    }\n}"}
{"id": "1677", "path": "output2\\java\\Medium\\1677-count-the-number-of-square-free-subsets.java", "hypo_code": "class Solution {\n    public int squareFreeSubsets(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[1 << n];\n        int[] counts = new int[31];\n        for (int num : nums) {\n            counts[num]++;\n        }\n        dp[0] = 1;\n        for (int i = 1; i < 1 << n; i++) {\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    product *= nums[j];\n                }\n            }\n            int count = 1;\n            for (int j = 2; j * j <= product; j++) {\n                if (product % (j * j) == 0) {\n                    count = 0;\n                }\n            }\n            dp[i] = count;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    dp[i] += dp[i ^ (1 << j)];\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1678", "path": "output2\\java\\Medium\\1678-find-the-divisibility-array-of-a-string.java", "hypo_code": "class Solution {\n    public int[] divisibilityArray(String word, int m) {\n         int n = word.length();\n        int[] div = new int[n];\n        int[] dp = new int[m];\n        int num = 0;\n        for (int i = 0; i < n; i++) {\n            int digit = word.charAt(i) - '0';\n            num = (num * 10 + digit) % m;\n            dp[num]++;\n            if (num == 0) {\n                div[i] = 1;\n            }\n            if (dp[num] > 1) {\n                div[i] = 1;\n            }\n        }\n        return div;\n    }\n}"}
{"id": "1679", "path": "output2\\java\\Medium\\1679-find-the-maximum-number-of-marked-indices.java", "hypo_code": "class Solution {\n    public int maxNumOfMarkedIndices(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            int j = 0;\n            while (j < n && 2 * num > nums[j]) {\n                j++;\n            }\n            if (j < n) {\n                dp[j]++;\n            }\n        }\n        int count = 0;\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            if (dp[i] > max) {\n                count = 1;\n                max = dp[i];\n            } else if (dp[i] == max) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"}
{"id": "1680", "path": "output2\\java\\Medium\\1680-count-total-number-of-colored-cells.java", "hypo_code": "class Solution {\n    public long coloredCells(int n) {\n        long count = 0;\n        for (int i = 1; i <= n; i++) {\n            count += (long) i * (n - i + 1);\n        }\n        return count;\n    }\n}"}
{"id": "1681", "path": "output2\\java\\Medium\\1681-count-ways-to-group-overlapping-ranges.java", "hypo_code": "class Solution {\n    public int countWays(int[][] ranges) {\n        int n = ranges.length;\n        int[][] sortedRanges = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            sortedRanges[i][0] = ranges[i][0];\n            sortedRanges[i][1] = ranges[i][1];\n        }\n        Arrays.sort(sortedRanges, (a, b) -> (a[0] - b[0]));\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 0; i < n; i++) {\n            int[] range = sortedRanges[i];\n            int start = range[0];\n            int end = range[1];\n            int index = Arrays.binarySearch(sortedRanges, new int[]{end, -1}, (a, b) -> (a[0] - b[0]));\n            if (index < 0) {\n                index = -(index + 1);\n            }\n            dp[index] += dp[i];\n            dp[index] %= 1000000007;\n            dp[i + 1] += dp[i];\n            dp[i + 1] %= 1000000007;\n        }\n        return dp[n];\n    }\n}"}
{"id": "1682", "path": "output2\\java\\Medium\\1682-kth-largest-sum-in-a-binary-tree.java", "hypo_code": "class Solution {\n    public long kthLargestLevelSum(TreeNode root, int k) {\n        Map<Integer, Long> levelSums = new HashMap<>();\n        dfs(root, 0, levelSums);\n        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (Long levelSum : levelSums.values()) {\n            pq.offer(levelSum);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n        return pq.size() < k ? -1 : pq.poll();\n    }\n    private void dfs(TreeNode root, int level, Map<Integer, Long> levelSums) {\n        if (root == null) {\n            return;\n        }\n        levelSums.put(level, levelSums.getOrDefault(level, 0L) + root.val);\n        dfs(root.left, level + 1, levelSums);\n        dfs(root.right, level + 1, levelSums);\n    }\n}"}
{"id": "1683", "path": "output2\\java\\Medium\\1683-rearrange-array-to-maximize-prefix-score.java", "hypo_code": "class Solution {\n    public int maxScore(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[1 << n];\n        for (int i = 1; i < 1 << n; i++) {\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    product *= nums[j];\n                }\n            }\n            int count = 0;\n            for (int j = 2; j * j <= product; j++) {\n                if (product % (j * j) == 0) {\n                    count++;\n                }\n            }\n            dp[i] = count;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    dp[i] = Math.max(dp[i], dp[i ^ (1 << j)]);\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1684", "path": "output2\\java\\Medium\\1684-count-the-number-of-beautiful-subarrays.java", "hypo_code": "class Solution {\n    public long beautifulSubarrays(int[] nums) {\n        int n = nums.length;\n        int[] counts = new int[n + 1];\n        int oddCount = 0;\n        counts[0] = 1;\n        long res = 0;\n        for (int num : nums) {\n            oddCount += num & 1;\n            res += oddCount >= 2 ? counts[oddCount - 2] : 0;\n            counts[oddCount]++;\n        }\n        return res;\n    }\n}"}
{"id": "1685", "path": "output2\\java\\Medium\\1685-maximize-greatness-of-an-array.java", "hypo_code": "class Solution {\n    public int maximizeGreatness(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[1 << n];\n        for (int i = 1; i < 1 << n; i++) {\n            int max = Integer.MIN_VALUE;\n            int min = Integer.MAX_VALUE;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    max = Math.max(max, nums[j]);\n                    min = Math.min(min, nums[j]);\n                }\n            }\n            dp[i] = dp[i ^ (1 << Integer.bitCount(i) - 1)] + Integer.bitCount(i) - 2 * Integer.bitCount(i & (1 << n - 1) - 1) + (max > min ? 1 : 0);\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1686", "path": "output2\\java\\Medium\\1686-find-score-of-an-array-after-marking-all-elements.java", "hypo_code": "class Solution {\n    public long findScore(int[] nums) {\n        int n = nums.length;\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int j = i;\n            while (j > 0 && nums[j - 1] > nums[j]) {\n                int temp = nums[j - 1];\n                nums[j - 1] = nums[j];\n                nums[j] = temp;\n                j--;\n            }\n            if (j > 0 && nums[j - 1] == nums[j]) {\n                j--;\n            }\n            res += nums[j];\n        }\n        return res;\n    }\n}"}
{"id": "1687", "path": "output2\\java\\Medium\\1687-minimum-time-to-repair-cars.java", "hypo_code": "class Solution {\n    public long repairCars(int[] ranks, int cars) {\n        int n = ranks.length;\n        Arrays.sort(ranks);\n        int[] counts = new int[101];\n        for (int rank : ranks) {\n            counts[rank]++;\n        }\n        long[] dp = new long[cars + 1];\n        for (int i = 1; i <= cars; i++) {\n            dp[i] = dp[i - 1];\n            int minRank = 1;\n            int minCount = Integer.MAX_VALUE;\n            for (int j = 1; j < counts.length; j++) {\n                if (counts[j] > 0 && counts[j] < minCount) {\n                    minRank = j;\n                    minCount = counts[j];\n                }\n            }\n            dp[i] += (long) minRank * minCount * minCount;\n            counts[minRank]--;\n        }\n        return dp[cars];\n    }\n}"}
{"id": "1688", "path": "output2\\java\\Medium\\1688-check-knight-tour-configuration.java", "hypo_code": "class Solution {\n    public boolean checkValidGrid(int[][] grid) {\n        int n = grid.length;\n        int[] dr = new int[]{1, 1, -1, -1, 2, 2, -2, -2};\n        int[] dc = new int[]{2, -2, 2, -2, 1, -1, 1, -1};\n        boolean[][] visited = new boolean[n][n];\n        int count = 1;\n        int r = 0;\n        int c = 0;\n        int num = grid[0][0];\n        visited[r][c] = true;\n        while (count < n * n) {\n            for (int i = 0; i < 8; i++) {\n                int nr = r + dr[i];\n                int nc = c + dc[i];\n                if (nr >= 0 && nr < n && nc >= 0 && nc < n && !visited[nr][nc] && grid[nr][nc] == num + 1) {\n                    r = nr;\n                    c = nc;\n                    num++;\n                    visited[r][c] = true;\n                    count++;\n                    break;\n                }\n            }\n        }\n        return count == n * n;\n    }\n}"}
{"id": "1689", "path": "output2\\java\\Medium\\1689-the-number-of-beautiful-subsets.java", "hypo_code": "class Solution {\n    public int beautifulSubsets(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[1 << n];\n        int[] counts = new int[1001];\n        for (int num : nums) {\n            counts[num]++;\n        }\n        dp[0] = 1;\n        for (int i = 1; i < 1 << n; i++) {\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    product *= nums[j];\n                }\n            }\n            int count = 0;\n            for (int j = 1; j * j <= product; j++) {\n                if (product % j == 0) {\n                    if (j != product / j) {\n                        count += counts[j];\n                        count += counts[product / j];\n                    } else {\n                        count += counts[j];\n                    }\n                }\n            }\n            dp[i] = count;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    dp[i] -= dp[i ^ (1 << j)];\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1690", "path": "output2\\java\\Medium\\1690-smallest-missing-non-negative-integer-after-operations.java", "hypo_code": "class Solution {\n    public int findSmallestInteger(int[] nums, int value) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > max) {\n                break;\n            }\n            max = Math.max(max, nums[i] + value);\n        }\n        return max;\n    }\n}"}
{"id": "1691", "path": "output2\\java\\Medium\\1691-prime-subtraction-operation.java", "hypo_code": "class Solution {\n    public boolean primeSubOperation(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = nums[0];\n        int max = dp[0];\n        for (int i = 1; i < n; i++) {\n            int num = nums[i];\n            if (num > max) {\n                dp[i] = num;\n                max = num;\n            }\n            for (int j = 0; j < i; j++) {\n                if (num > nums[j]) {\n                    dp[i] = Math.min(dp[i], dp[j] - num);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == Integer.MAX_VALUE) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "1692", "path": "output2\\java\\Medium\\1692-minimum-operations-to-make-all-array-elements-equal.java", "hypo_code": "class Solution {\n    public List<Long> minOperations(int[] nums, int[] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        List<Long> res = new ArrayList<>();\n        int max = 0;\n        for (int num : nums) {\n            max = Math.max(max, num);\n        }\n        int[] dp = new int[max + 1];\n        for (int num : nums) {\n            dp[num]++;\n        }\n        for (int i = 1; i <= max; i++) {\n            dp[i] += dp[i - 1];\n        }\n        for (int i = 0; i < m; i++) {\n            int query = queries[i];\n            if (query > max) {\n                res.add((long) n);\n            } else {\n                res.add((long) (n - dp[query]));\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1693", "path": "output2\\java\\Medium\\1693-find-the-substring-with-maximum-cost.java", "hypo_code": "class Solution {\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\n        int n = s.length();\n        int[] prefix = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            int index = chars.indexOf(s.charAt(i));\n            if (index == -1) {\n                prefix[i + 1] = prefix[i] + s.charAt(i) - 'a' + 1;\n            } else {\n                prefix[i + 1] = prefix[i] + vals[index];\n            }\n        }\n        int maxCost = 0;\n        for (int i = 0; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                maxCost = Math.max(maxCost, prefix[j] - prefix[i]);\n            }\n        }\n        return maxCost;\n    }\n}"}
{"id": "1694", "path": "output2\\java\\Medium\\1694-make-k-subarray-sums-equal.java", "hypo_code": "class Solution {\n    public long makeSubKSumEqual(int[] arr, int k) {\n        int n = arr.length;\n        int[] counts = new int[k];\n        for (int i = 0; i < n; i++) {\n            counts[i % k] += arr[i];\n        }\n        int min = Integer.MAX_VALUE;\n        for (int count : counts) {\n            min = Math.min(min, count);\n        }\n        long res = 0;\n        for (int count : counts) {\n            res += (long) (count - min) / k;\n        }\n        return res;\n    }\n}"}
{"id": "1695", "path": "output2\\java\\Medium\\1695-convert-an-array-into-a-2d-array-with-conditions.java", "hypo_code": "class Solution {\n    public List<List<Integer>> findMatrix(int[] nums) {\n        int n = nums.length;\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> list = new ArrayList<>();\n        for (int num : nums) {\n            list.add(num);\n        }\n        while (!list.isEmpty()) {\n            List<Integer> row = new ArrayList<>();\n            int i = 0;\n            while (i < list.size()) {\n                int num = list.get(i);\n                if (row.isEmpty() || num > row.get(row.size() - 1)) {\n                    row.add(num);\n                    list.remove(i);\n                } else {\n                    i++;\n                }\n            }\n            res.add(row);\n        }\n        return res;\n    }\n}"}
{"id": "1696", "path": "output2\\java\\Medium\\1696-mice-and-cheese.java", "hypo_code": "class Solution {\n    public int miceAndCheese(int[] reward1, int[] reward2, int k) {\n        int n = reward1.length;\n        int[][] dp = new int[n + 1][k + 1];\n        for (int i = 1; i <= n; i++) {\n            dp[i][0] = dp[i - 1][0] + reward2[i - 1];\n        }\n        for (int i = 1; i <= k; i++) {\n            dp[i][i] = dp[i - 1][i - 1] + reward1[i - 1];\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= Math.min(i, k); j++) {\n                dp[i][j] = Math.max(dp[i - 1][j - 1] + reward1[i - 1], dp[i - 1][j] + reward2[i - 1]);\n            }\n        }\n        return dp[n][k];\n    }\n}"}
{"id": "1697", "path": "output2\\java\\Medium\\1697-sum-of-distances.java", "hypo_code": "class Solution {\n    public long[] distance(int[] nums) {\n        int n = nums.length;\n        long[] res = new long[n];\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            List<Integer> indices = map.getOrDefault(nums[i], new ArrayList<>());\n            indices.add(i);\n            map.put(nums[i], indices);\n        }\n        for (int i = 0; i < n; i++) {\n            List<Integer> indices = map.get(nums[i]);\n            long sum = 0;\n            for (int index : indices) {\n                sum += Math.abs(i - index);\n            }\n            res[i] = sum;\n        }\n        return res;\n    }\n}"}
{"id": "1698", "path": "output2\\java\\Medium\\1698-minimize-the-maximum-difference-of-pairs.java", "hypo_code": "class Solution {\n    public int minimizeMax(int[] nums, int p) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int[] prefix = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            prefix[i] = prefix[i - 1] + nums[i - 1];\n        }\n        int[][] dp = new int[n + 1][p + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        dp[0][0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= Math.min(i, p); j++) {\n                for (int k = j - 1; k < i; k++) {\n                    dp[i][j] = Math.min(dp[i][j], dp[k][j - 1] + (i - k) * nums[i - 1] - (prefix[i] - prefix[k]));\n                }\n            }\n        }\n        return dp[n][p];\n    }\n}"}
{"id": "1707", "path": "output2\\java\\Medium\\1707-find-the-score-of-all-prefixes-of-an-array.java", "hypo_code": "class Solution {\n    public long[] findPrefixScore(int[] nums) {\n        int n = nums.length;\n        long[] max = new long[n];\n        max[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            max[i] = Math.max(max[i - 1], nums[i]);\n        }\n        long[] sum = new long[n];\n        sum[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            sum[i] = sum[i - 1] + nums[i];\n        }\n        long[] ans = new long[n];\n        ans[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            ans[i] = ans[i - 1] + sum[i] + max[i];\n        }\n        return ans;\n    }\n}"}
{"id": "1708", "path": "output2\\java\\Medium\\1708-cousins-in-binary-tree-ii.java", "hypo_code": "class Solution {\n    public TreeNode replaceValueInTree(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            Map<Integer, Integer> cousins = new HashMap<>();\n            for (int i = 0; i < size; i++) {\n                TreeNode curr = queue.poll();\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                    cousins.put(curr.left.val, curr.val);\n                }\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                    cousins.put(curr.right.val, curr.val);\n                }\n            }\n            for (Map.Entry<Integer, Integer> entry : cousins.entrySet()) {\n                int cousinVal = entry.getKey();\n                int parentVal = entry.getValue();\n                TreeNode cousinNode = findNode(root, cousinVal);\n                cousinNode.val += parentVal;\n            }\n        }\n        return root;\n    }\n    private TreeNode findNode(TreeNode root, int val) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val == val) {\n            return root;\n        }\n        TreeNode left = findNode(root.left, val);\n        TreeNode right = findNode(root.right, val);\n        if (left == null) {\n            return right;\n        } else {\n            return left;\n    }\n}"}
{"id": "1709", "path": "output2\\java\\Medium\\1709-minimum-additions-to-make-valid-string.java", "hypo_code": "class Solution {\n    public int addMinimum(String word) {\n        int n = word.length();\n        int count = 0;\n        int a = 0;\n        int b = 0;\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (ch == 'a') {\n                if (b > 0 || c > 0) {\n                    count++;\n                    b = 0;\n                    c = 0;\n                }\n                a++;\n            } else if (ch == 'b') {\n                if (a > 0) {\n                    a--;\n                    b++;\n                } else if (c > 0) {\n                    c--;\n                    b++;\n                } else {\n                    count += 2;\n                }\n            } else {\n                if (a > 0 || b > 0) {\n                    count++;\n                    a = 0;\n                    b = 0;\n                }\n                c++;\n            }\n        }\n        if (a > 0 || b > 0 || c > 0) {\n            count += 2;\n        }\n        return count;\n\n    }\n}"}
{"id": "1711", "path": "output2\\java\\Medium\\1711-sliding-subarray-beauty.java", "hypo_code": "class Solution {\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\n        int n = nums.length;\n        int[] res = new int[n - k + 1];\n        int[] counts = new int[101];\n        int count = 0;\n        for (int i = 0; i < k; i++) {\n            if (nums[i] < x) {\n                count++;\n            }\n            counts[nums[i]]++;\n        }\n        int j = 0;\n        res[j++] = count;\n        for (int i = k; i < n; i++) {\n            if (nums[i - k] < x) {\n                count--;\n            }\n            counts[nums[i - k]]--;\n            if (nums[i] < x) {\n                count++;\n            }\n            counts[nums[i]]++;\n            while (counts[x] > 0) {\n                x++;\n            }\n            res[j++] = count;\n        }\n        return res;\n    }\n}"}
{"id": "1712", "path": "output2\\java\\Medium\\1712-minimum-number-of-operations-to-make-all-array-elements-equal-to-1.java", "hypo_code": "class Solution {\n    public int minOperations(int[] nums) {\n        int n = nums.length;\n        int max = 0;\n        int count = 0;\n        for (int num : nums) {\n            if (num == 1) {\n                count++;\n            } else {\n                max = Math.max(max, num);\n            }\n        }\n        if (count == n) {\n            return 0;\n        }\n        if (max == 0) {\n            return -1;\n        }\n        int res = 0;\n        while (max > 0) {\n            res++;\n            max >>= 1;\n        }\n        return res + count - 1;\n    }\n}"}
{"id": "1713", "path": "output2\\java\\Medium\\1713-find-the-prefix-common-array-of-two-arrays.java", "hypo_code": "class Solution {\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\n        int n = A.length;\n        int[] res = new int[n];\n        int[] counts = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            counts[A[i]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            counts[i] += counts[i - 1];\n        }\n        for (int i = 0; i < n; i++) {\n            res[i] = counts[B[i] - 1];\n        }\n        return res;\n    }\n}"}
{"id": "1714", "path": "output2\\java\\Medium\\1714-maximum-number-of-fish-in-a-grid.java", "hypo_code": "class Solution {\n    public int findMaxFish(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][][] dp = new int[m][n][2];\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(dp[i][0], grid[i][0]);\n            res = Math.max(res, dp[i][0][0]);\n        }\n        for (int j = 0; j < n; j++) {\n            dp[0][j][1] = grid[0][j];\n            res = Math.max(res, dp[0][j][1]);\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i][j - 1][0]) + grid[i][j];\n                res = Math.max(res, dp[i][j][0]);\n            }\n            for (int j = n - 2; j >= 1; j--) {\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i][j + 1][1]) + grid[i][j];\n                res = Math.max(res, dp[i][j][1]);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1715", "path": "output2\\java\\Medium\\1715-first-completely-painted-row-or-column.java", "hypo_code": "class Solution {\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] rows = new int[m], cols = new int[n];\n        int res = 0;\n        for (int i = 0; i < arr.length; i++) {\n            int num = arr[i];\n            int r = (num - 1) / n, c = (num - 1) % n;\n            rows[r]++;\n            cols[c]++;\n            if (rows[r] == n) {\n                res = Math.max(res, r);\n            }\n            if (cols[c] == m) {\n                res = Math.max(res, m + c);\n            }\n        }\n        return res + 1;\n    }\n}"}
{"id": "1716", "path": "output2\\java\\Medium\\1716-minimum-cost-of-a-path-with-special-roads.java", "hypo_code": "class Solution {\n    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {\n        int n = specialRoads.length;\n        int[][] dp = new int[1 << n][n + 2];\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE / 2);\n        }\n        int[] costs = new int[n + 2];\n        for (int i = 0; i < n; i++) {\n            int[] road = specialRoads[i];\n            costs[i] = road[4];\n            dp[1 << i][i] = Math.abs(start[0] - road[0]) + Math.abs(start[1] - road[1]);\n            dp[1 << i][n + 1] = Math.abs(target[0] - road[2]) + Math.abs(target[1] - road[3]);\n        }\n        costs[n] = Math.abs(start[0] - target[0]) + Math.abs(start[1] - target[1]);\n        costs[n + 1] = 0;\n        for (int i = 1; i < 1 << n; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    for (int k = 0; k < n + 2; k++) {\n                        dp[i][k] = Math.min(dp[i][k], dp[i ^ (1 << j)][k] + Math.abs(specialRoads[j][2] - specialRoads[j][0]) + Math.abs(specialRoads[j][3] - specialRoads[j][1]));\n                        if (k < n) {\n                            dp[i][k] = Math.min(dp[i][k], dp[i ^ (1 << j)][k + 1] + costs[j]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[(1 << n) - 1][0];\n    }\n}"}
{"id": "1718", "path": "output2\\java\\Medium\\1718-number-of-adjacent-elements-with-the-same-color.java", "hypo_code": "class Solution {\n    public int[] colorTheArray(int n, int[][] queries) {\n        int[] dp = new int[100001];\n        int[] next = new int[100001];\n        int[] prev = new int[100001];\n        for (int i = 0; i < 100001; i++) {\n            dp[i] = 1;\n            next[i] = i + 1;\n            prev[i] = i - 1;\n        }\n        for (int[] query : queries) {\n            int index = query[0];\n            int color = query[1];\n            if (dp[index] > 0) {\n                if (prev[color] >= 0 && dp[prev[color]] > 0) {\n                    dp[prev[color]] += dp[index];\n                    next[prev[color]] = next[index];\n                    prev[next[index]] = prev[color];\n                }\n                if (next[color] < 100001 && dp[next[color]] > 0) {\n                    dp[next[color]] += dp[index];\n                    next[prev[index]] = next[color];\n                    prev[next[color]] = prev[index];\n                }\n                dp[index] = 0;\n            }\n        }\n        int[] answer = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            int index = queries[i][0];\n            answer[i] = dp[index] - 1;\n        }\n        return answer;\n    }\n}"}
{"id": "1719", "path": "output2\\java\\Medium\\1719-make-costs-of-paths-equal-in-a-binary-tree.java", "hypo_code": "class Solution {\n    public int minIncrements(int n, int[] cost) {\n        int[] ans = new int[1];\n        dfs(cost, 0, ans);\n        return ans[0];\n    }\n    private int dfs(int[] cost, int i, int[] ans) {\n        if (i >= cost.length) {\n            return 0;\n        }\n        int left = dfs(cost, 2 * i + 1, ans);\n        int right = dfs(cost, 2 * i + 2, ans);\n        ans[0] += Math.abs(left - right);\n        return cost[i] + left + right;\n    }\n}"}
{"id": "1720", "path": "output2\\java\\Medium\\1720-sum-in-a-matrix.java", "hypo_code": "class Solution {\n    public int matrixSum(int[][] nums) {\n        int n = nums.length;\n        int m = nums[0].length;\n        int[] row = new int[n];\n        int[] col = new int[m];\n        for (int i = 0; i < n; i++) {\n            int max = 0;\n            for (int j = 0; j < m; j++) {\n                max = Math.max(max, nums[i][j]);\n            }\n            row[i] = max;\n        }\n        for (int j = 0; j < m; j++) {\n            int max = 0;\n            for (int i = 0; i < n; i++) {\n                max = Math.max(max, nums[i][j]);\n            }\n            col[j] = max;\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res += row[i];\n        }\n        for (int j = 0; j < m; j++) {\n            res += col[j];\n        }\n        return res;\n    }\n}"}
{"id": "1721", "path": "output2\\java\\Medium\\1721-maximum-or.java", "hypo_code": "class Solution {\n    public long maximumOr(int[] nums, int k) {\n        int n = nums.length;\n        int[] bits = new int[31];\n        for (int num : nums) {\n            for (int i = 0; i < 31; i++) {\n                bits[i] += num >> i & 1;\n            }\n        }\n        long res = 0;\n        for (int i = 0; i < 31; i++) {\n            if (bits[i] > 0) {\n                if (bits[i] <= k) {\n                    res |= 1L << i;\n                    k -= bits[i];\n                } else {\n                    res |= 1L << i;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1722", "path": "output2\\java\\Medium\\1722-neighboring-bitwise-xor.java", "hypo_code": "class Solution {\n    public boolean doesValidArrayExist(int[] derived) {\n        int n = derived.length;\n        if (n % 2 == 1) {\n            return false;\n        }\n        int[] original = new int[n];\n        for (int i = 0; i < n / 2; i++) {\n            original[i] = derived[i] ^ (i == 0 ? 0 : original[i - 1]);\n            original[i + n / 2] = derived[i + n / 2] ^ original[i];\n        }\n        for (int i = 0; i < n; i++) {\n            if (original[i] != derived[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "1723", "path": "output2\\java\\Medium\\1723-maximum-number-of-moves-in-a-grid.java", "hypo_code": "class Solution {\n    public int maxMoves(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dp = new int[m][n];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            res = Math.max(res, dfs(grid, i, 0, dp));\n        }\n        return res;\n    }\n    private int dfs(int[][] grid, int i, int j, int[][] dp) {\n        if (j == grid[0].length) {\n            return 0;\n        }\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int res = 0;\n        for (int k = -1; k <= 1; k++) {\n            if (i + k >= 0 && i + k < grid.length) {\n                res = Math.max(res, dfs(grid, i + k, j + 1, dp));\n            }\n        }\n        return dp[i][j] = res + grid[i][j];\n    }\n}"}
{"id": "1724", "path": "output2\\java\\Medium\\1724-count-the-number-of-complete-components.java", "hypo_code": "class Solution {\n    public int countCompleteComponents(int n, int[][] edges) {\n        int[] parents = new int[n];\n        for (int i = 0; i < n; i++) {\n            parents[i] = i;\n        }\n        int count = n;\n        for (int[] edge : edges) {\n            int parent1 = findParent(edge[0], parents);\n            int parent2 = findParent(edge[1], parents);\n            if (parent1 != parent2) {\n                parents[parent1] = parent2;\n                count--;\n            }\n        }\n        return count;\n    }\n    private int findParent(int index, int[] parents) {\n        if (parents[index] != index) {\n            parents[index] = findParent(parents[index], parents);\n        }\n        return parents[index];\n    }\n}"}
{"id": "1727", "path": "output2\\java\\Medium\\1727-find-the-punishment-number-of-an-integer.java", "hypo_code": "class Solution {\n    public int punishmentNumber(int n) {\n        int[] dp = new int[n + 1];\n        int[] counts = new int[1001];\n        for (int i = 1; i <= n; i++) {\n            counts[i]++;\n        }\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            int product = i * i;\n            int count = 0;\n            for (int j = 1; j * j <= product; j++) {\n                if (product % j == 0) {\n                    if (j != product / j) {\n                        count += counts[j];\n                        count += counts[product / j];\n                    } else {\n                        count += counts[j];\n                    }\n                }\n            }\n            dp[i] = count;\n            for (int j = 1; j <= i; j++) {\n                dp[i] -= dp[j - 1];\n            }\n        }\n        return dp[n];\n    }\n}"}
{"id": "1729", "path": "output2\\java\\Medium\\1729-extra-characters-in-a-string.java", "hypo_code": "class Solution {\n    public int minExtraChar(String s, String[] dictionary) {\n        int n = s.length();\n        int m = dictionary.length;\n        int max = 0;\n        for (String word : dictionary) {\n            max = Math.max(max, word.length());\n        }\n        int[][] dp = new int[n][max + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        int ans = minExtraChar(s, 0, 0, max, dictionary, dp);\n        return ans;\n    }\n    private int minExtraChar(String s, int index, int len, int max, String[] dictionary, int[][] dp) {\n        int n = s.length();\n        if (index == n) {\n            return 0;\n        }\n        if (dp[index][len] != -1) {\n            return dp[index][len];\n        }\n        int ans = n - index;\n        for (int i = index; i < n; i++) {\n            String word = s.substring(index, i + 1);\n            boolean found = false;\n            for (String target : dictionary) {\n                if (target.equals(word)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (found) {\n                ans = Math.min(ans, minExtraChar(s, i + 1, 0, max, dictionary, dp));\n            } else if (len < max) {\n                ans = Math.min(ans, 1 + minExtraChar(s, i + 1, len + 1, max, dictionary, dp));\n            } else {\n                break;\n            }\n        }\n        dp[index][len] = ans;\n        return ans;\n    }\n}"}
{"id": "1730", "path": "output2\\java\\Medium\\1730-maximum-strength-of-a-group.java", "hypo_code": "class Solution {\n    public long maxStrength(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[1 << n];\n        for (int i = 1; i < 1 << n; i++) {\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    product *= nums[j];\n                }\n            }\n            int count = 0;\n            for (int j = 2; j * j <= product; j++) {\n                if (product % (j * j) == 0) {\n                    count++;\n                }\n            }\n            dp[i] = count;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    dp[i] = Math.max(dp[i], dp[i ^ (1 << j)]);\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n\n    }\n}"}
{"id": "1731", "path": "output2\\java\\Medium\\1731-difference-of-number-of-distinct-values-on-diagonals.java", "hypo_code": "class Solution {\n    public int[][] differenceOfDistinctValues(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] topLeft = new int[m][n];\n        int[][] bottomRight = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Set<Integer> set = new HashSet<>();\n            for (int j = 0; j < n; j++) {\n                set.add(grid[i][j]);\n                topLeft[i][j] = set.size();\n            }\n        }\n        for (int j = 0; j < n; j++) {\n            Set<Integer> set = new HashSet<>();\n            for (int i = 0; i < m; i++) {\n                set.add(grid[i][j]);\n                bottomRight[i][j] = set.size();\n            }\n        }\n        int[][] result = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            result[i] = new int[n];\n            for (int j = 0; j < n; j++) {\n                result[i][j] = Math.abs(topLeft[i][j] - bottomRight[i][j]);\n            }\n        }\n        return result;\n    }\n}"}
{"id": "1732", "path": "output2\\java\\Medium\\1732-minimum-cost-to-make-all-characters-equal.java", "hypo_code": "class Solution {\n    public long minimumCost(String s) {\n        int n = s.length();\n        int[] prefix = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = prefix[i] + (s.charAt(i) - '0');\n        }\n        long res = Long.MAX_VALUE;\n        for (int i = 0; i <= n; i++) {\n            res = Math.min(res, prefix[i] + n - i - (prefix[n] - prefix[i]));\n        }\n        return res;\n    }\n}"}
{"id": "1733", "path": "output2\\java\\Medium\\1733-sum-of-matrix-after-queries.java", "hypo_code": "class Solution {\n    public long matrixSumQueries(int n, int[][] queries) {\n        int[] rows = new int[n];\n        int[] cols = new int[n];\n        for (int[] query : queries) {\n            int type = query[0], index = query[1], val = query[2];\n            if (type == 0) {\n                rows[index] += val;\n            } else {\n                cols[index] += val;\n            }\n        }\n        int[][] matrix = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            matrix[i] = rows[i] * n + cols[i];\n        }\n        long sum = 0;\n        for (int[] row : matrix) {\n            for (int num : row) {\n                sum += num;\n            }\n        }\n        return sum;\n    }\n}"}
{"id": "1736", "path": "output2\\java\\Medium\\1736-find-the-longest-semi-repetitive-substring.java", "hypo_code": "class Solution {\n    public int longestSemiRepetitiveSubstring(String s) {\n        int n = s.length();\n        int max = 0;\n        int start = 0;\n        int end = 0;\n        while (start < n) {\n            int count = 0;\n            int i = start + 1;\n            while (i < n && s.charAt(i) == s.charAt(start)) {\n                i++;\n            }\n            count = i - start;\n            if (count >= 2) {\n                int j = i + 1;\n                while (j < n && s.charAt(j) != s.charAt(start)) {\n                    j++;\n                }\n                count += j - i;\n                i = j;\n            }\n            max = Math.max(max, count);\n            start = i;\n        }\n        return max;\n    }\n}"}
{"id": "1737", "path": "output2\\java\\Medium\\1737-movement-of-robots.java", "hypo_code": "class Solution {\n    public int sumDistance(int[] nums, String s, int d) {\n        int n = nums.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        for (int i = 0; i < n; i++) {\n            left[i] = nums[i] - i * d;\n            right[i] = nums[i] + i * d;\n        }\n        Arrays.sort(left);\n        Arrays.sort(right);\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == 'L') {\n                sum += right[0];\n                right = Arrays.copyOfRange(right, 1, right.length);\n            } else {\n                sum += left[left.length - 1];\n                left = Arrays.copyOfRange(left, 0, left.length - 1);\n            }\n        }\n        return sum;\n    }\n}"}
{"id": "1738", "path": "output2\\java\\Medium\\1738-lexicographically-smallest-string-after-substring-operation.java", "hypo_code": "class Solution {\n    public String smallestString(String s) {\n        int n = s.length();\n        String result = s;\n        for (int i = 0; i < n; i++) {\n            String str = s.substring(i) + s.substring(0, i);\n            result = result.compareTo(str) < 0 ? result : str;\n        }\n        return result;\n    }\n}"}
{"id": "1739", "path": "output2\\java\\Medium\\1739-collecting-chocolates.java", "hypo_code": "class Solution {\n    public long minCost(int[] nums, int x) {\n        int n = nums.length;\n        long[] prefixSum = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\n        }\n        long res = Long.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            long cost = prefixSum[i + 1];\n            int j = i;\n            while (j < n && prefixSum[j + 1] - prefixSum[i] <= x) {\n                j++;\n            }\n            cost += prefixSum[n] - prefixSum[j];\n            res = Math.min(res, cost);\n        }\n        return res;\n    }\n}"}
{"id": "1740", "path": "output2\\java\\Medium\\1740-find-the-value-of-the-partition.java", "hypo_code": "class Solution {\n    public int findValueOfPartition(int[] nums) {\n        int n = nums.length;\n        int min1 = Integer.MAX_VALUE;\n        int min2 = Integer.MAX_VALUE;\n        int max1 = Integer.MIN_VALUE;\n        int max2 = Integer.MIN_VALUE;\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            if (num < min1) {\n                min2 = min1;\n                min1 = num;\n            } else if (num < min2) {\n                min2 = num;\n            }\n            if (num > max1) {\n                max2 = max1;\n                max1 = num;\n            } else if (num > max2) {\n                max2 = num;\n            }\n        }\n        return Math.min(max1 - min2, max2 - min1);\n    }\n}"}
{"id": "1741", "path": "output2\\java\\Medium\\1741-special-permutations.java", "hypo_code": "class Solution {\n    public int specialPerm(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[1 << n];\n        dp[0] = 1;\n        for (int i = 1; i < 1 << n; i++) {\n            int count = 0;\n            int index = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    index = j;\n                    count++;\n                }\n            }\n            if (count == 1) {\n                dp[i] = 1;\n            } else {\n                for (int j = 0; j < n; j++) {\n                    if ((i & (1 << j)) > 0 && (nums[index] % nums[j] == 0 || nums[j] % nums[index] == 0)) {\n                        dp[i] += dp[i ^ (1 << index)];\n                    }\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1742", "path": "output2\\java\\Medium\\1742-construct-the-longest-new-string.java", "hypo_code": "class Solution {\n    public int longestString(int x, int y, int z) {\n        int result = 0;\n        while (x > 0 || y > 0 || z > 0) {\n            if (x >= y && x >= z) {\n                if (x > 1) {\n                    result += 2;\n                } else {\n                    result += 1;\n                }\n                x -= 2;\n            } else if (y >= x && y >= z) {\n                if (y > 1) {\n                    result += 2;\n                } else {\n                    result += 1;\n                }\n                y -= 2;\n            } else {\n                if (z > 0) {\n                    result += 1;\n                }\n                z -= 1;\n            }\n        }\n        return result;\n    }\n}"}
{"id": "1743", "path": "output2\\java\\Medium\\1743-decremental-string-concatenation.java", "hypo_code": "class Solution {\n    public int minimizeConcatenatedLength(String[] words) {\n        int n = words.length;\n        int[] dp = new int[1 << n];\n        for (int i = 1; i < 1 << n; i++) {\n            dp[i] = Integer.MAX_VALUE;\n            int length = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    length += words[j].length();\n                }\n            }\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    int newLength = length - words[j].length();\n                    if (newLength > 0) {\n                        dp[i] = Math.min(dp[i], dp[i ^ (1 << j)] + newLength);\n                    }\n                    for (int k = 0; k < n; k++) {\n                        if ((i & (1 << k)) > 0) {\n                            if (words[j].charAt(words[j].length() - 1) == words[k].charAt(0)) {\n                                newLength = length - words[j].length() - words[k].length() + 1;\n                            } else {\n                                newLength = length - words[j].length() - words[k].length();\n                            }\n                            if (newLength > 0) {\n                                dp[i] = Math.min(dp[i], dp[i ^ (1 << j) ^ (1 << k)] + newLength);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1744", "path": "output2\\java\\Medium\\1744-count-zero-request-servers.java", "hypo_code": "class Solution {\n    public int[] countServers(int n, int[][] logs, int x, int[] queries) {\n        int m = queries.length;\n        int[] results = new int[m];\n        int[] counts = new int[n];\n        boolean[] isZero = new boolean[n];\n        for (int[] log : logs) {\n            counts[log[0] - 1]++;\n            if (log[1] <= x) {\n                isZero[log[0] - 1] = true;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            int query = queries[i];\n            for (int[] log : logs) {\n                int server = log[0] - 1;\n                int time = log[1];\n                if (time > query - x && time <= query) {\n                    if (counts[server] == 1 && !isZero[server]) {\n                        results[i]++;\n                    }\n                }\n            }\n        }\n        return results;\n\n    }\n}"}
{"id": "1745", "path": "output2\\java\\Medium\\1745-minimum-operations-to-make-the-integer-zero.java", "hypo_code": "class Solution {\n    public int makeTheIntegerZero(int num1, int num2) {\n        int count = 0;\n        while (num1 != 0) {\n            if ((num1 & 1) == 1) {\n                if (num2 > 0) {\n                    num1 -= num2;\n                    count++;\n                } else {\n                    return -1;\n                }\n            }\n            num1 >>= 1;\n            num2 <<= 1;\n            count++;\n        }\n        return count;\n    }\n}"}
{"id": "1746", "path": "output2\\java\\Medium\\1746-ways-to-split-array-into-good-subarrays.java", "hypo_code": "class Solution {\n    public int numberOfGoodSubarraySplits(int[] nums) {\n        int n = nums.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                count++;\n            }\n            left[i] = count;\n        }\n        count = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            if (nums[i] == 1) {\n                count++;\n            }\n            right[i] = count;\n        }\n        int res = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (left[i] > 0 && right[i + 1] > 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1747", "path": "output2\\java\\Medium\\1747-prime-pairs-with-target-sum.java", "hypo_code": "class Solution {\n    public List<List<Integer>> findPrimePairs(int n) {\n        List<List<Integer>> res = new ArrayList<>();\n        boolean[] isPrime = new boolean[n + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = false;\n        for (int i = 2; i <= n; i++) {\n            if (isPrime[i]) {\n                for (int j = 2; i * j <= n; j++) {\n                    isPrime[i * j] = false;\n                }\n            }\n        }\n        for (int i = 2; i <= n / 2; i++) {\n            if (isPrime[i] && isPrime[n - i]) {\n                res.add(Arrays.asList(i, n - i));\n            }\n        }\n        if (n % 2 == 0 && isPrime[n / 2]) {\n            res.add(Arrays.asList(n / 2, n / 2));\n        }\n        return res;\n    }\n}"}
{"id": "1748", "path": "output2\\java\\Medium\\1748-continuous-subarrays.java", "hypo_code": "class Solution {\n    public long continuousSubarrays(int[] nums) {\n        int n = nums.length;\n        int[] counts = new int[n + 1];\n        int oddCount = 0;\n        counts[0] = 1;\n        long res = 0;\n        for (int num : nums) {\n            oddCount += num & 1;\n            res += oddCount >= 2 ? counts[oddCount - 2] : 0;\n            counts[oddCount]++;\n        }\n        return res;\n    }\n}"}
{"id": "1749", "path": "output2\\java\\Medium\\1749-relocate-marbles.java", "hypo_code": "class Solution {\n    public List<Integer> relocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {\n        int n = nums.length;\n        int[] counts = new int[10];\n        for (int num : nums) {\n            counts[num]++;\n        }\n        for (int i = 0; i < moveFrom.length; i++) {\n            counts[nums[moveFrom[i]]]--;\n            counts[nums[moveTo[i]]]++;\n            nums[moveTo[i]] = nums[moveFrom[i]];\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i = 1; i <= 9; i++) {\n            if (counts[i] > 0) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1750", "path": "output2\\java\\Medium\\1750-partition-string-into-minimum-beautiful-substrings.java", "hypo_code": "class Solution {\n    public int minimumBeautifulSubstrings(String s) {\n        int n = s.length();\n        int[] prefix = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = prefix[i] + (s.charAt(i) - '0');\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '0') {\n                continue;\n            }\n            for (int j = i + 1; j <= n; j++) {\n                if (prefix[j] - prefix[i] == j - i) {\n                    result++;\n                    i = j - 1;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "1751", "path": "output2\\java\\Medium\\1751-number-of-black-blocks.java", "hypo_code": "class Solution {\n    public long[] countBlackBlocks(int m, int n, int[][] coordinates) {\n        long[] res = new long[5];\n        int[] counts = new int[m + n];\n        for (int[] coordinate : coordinates) {\n            counts[coordinate[0]]++;\n            counts[m + coordinate[1]]++;\n        }\n        for (int count : counts) {\n            if (count == 0) {\n                continue;\n            }\n            res[count - 1]++;\n        }\n        return res;\n    }\n}"}
{"id": "1752", "path": "output2\\java\\Medium\\1752-maximum-number-of-jumps-to-reach-the-last-index.java", "hypo_code": "class Solution {\n    public int maximumJumps(int[] nums, int target) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, -1);\n        int[] sorted = new int[n];\n        for (int i = 0; i < n; i++) {\n            sorted[i] = i;\n        }\n        Arrays.sort(sorted, (a, b) -> nums[a] - nums[b]);\n        for (int i : sorted) {\n            int max = 0;\n            for (int j = i - 1; j >= 0 && i - j <= target; j--) {\n                if (nums[j] >= nums[i]) {\n                    break;\n                }\n                max = Math.max(max, dp[j]);\n            }\n            for (int j = i + 1; j < n && j - i <= target; j++) {\n                if (nums[j] >= nums[i]) {\n                    break;\n                }\n                max = Math.max(max, dp[j]);\n            }\n            dp[i] = max + 1;\n        }\n        int res = 0;\n        for (int num : dp) {\n            res = Math.max(res, num);\n        }\n        return res;\n    }\n}"}
{"id": "1753", "path": "output2\\java\\Medium\\1753-longest-non-decreasing-subarray-from-two-arrays.java", "hypo_code": "class Solution {\n    public int maxNonDecreasingLength(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int[] dp = new int[1 << n];\n        for (int i = 1; i < 1 << n; i++) {\n            int max = Integer.MIN_VALUE;\n            int min = Integer.MAX_VALUE;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    max = Math.max(max, nums1[j]);\n                    min = Math.min(min, nums2[j]);\n                }\n            }\n            dp[i] = dp[i ^ (1 << Integer.bitCount(i) - 1)] + Integer.bitCount(i) - 2 * Integer.bitCount(i & (1 << n - 1) - 1) + (max > min ? 1 : 0);\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1754", "path": "output2\\java\\Medium\\1754-apply-operations-to-make-all-array-elements-equal-to-zero.java", "hypo_code": "class Solution {\n    public boolean checkArray(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[1 << n];\n        int[] counts = new int[1001];\n        for (int num : nums) {\n            counts[num]++;\n        }\n        dp[0] = 1;\n        for (int i = 1; i < 1 << n; i++) {\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    product *= nums[j];\n                }\n            }\n            int count = 0;\n            for (int j = 1; j * j <= product; j++) {\n                if (product % j == 0) {\n                    if (j != product / j) {\n                        count += counts[j];\n                        count += counts[product / j];\n                    } else {\n                        count += counts[j];\n                    }\n                }\n            }\n            dp[i] = count;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    dp[i] -= dp[i ^ (1 << j)];\n                }\n            }\n        }\n        return dp[(1 << n) - 1] > 0;\n    }\n}"}
{"id": "1755", "path": "output2\\java\\Medium\\1755-maximum-beauty-of-an-array-after-applying-operation.java", "hypo_code": "class Solution {\n    public int maximumBeauty(int[] nums, int k) {\n        int n = nums.length;\n        int[] counts = new int[200001];\n        for (int i = 0; i < n; i++) {\n            counts[nums[i]]++;\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            if (counts[nums[i]] == 1) {\n                continue;\n            }\n            int left = i, right = i, sum = nums[i];\n            while (left >= 0 && right < n) {\n                while (left - 1 >= 0 && nums[left - 1] == nums[left]) {\n                    left--;\n                }\n                while (right + 1 < n && nums[right + 1] == nums[right]) {\n                    right++;\n                }\n                int leftCount = left > 0 ? counts[nums[left - 1]] : 0;\n                int rightCount = right < n - 1 ? counts[nums[right + 1]] : 0;\n                if (leftCount > 0 && rightCount > 0) {\n                    sum += Math.max(nums[left - 1], nums[right + 1]);\n                    left--;\n                    right++;\n                } else if (leftCount > 0) {\n                    sum += nums[left - 1];\n                    left--;\n                } else if (rightCount > 0) {\n                    sum += nums[right + 1];\n                    right++;\n                } else {\n                    break;\n                }\n            }\n            max = Math.max(max, sum);\n        }\n        return max;\n\n    }\n}"}
{"id": "1756", "path": "output2\\java\\Medium\\1756-minimum-index-of-a-valid-split.java", "hypo_code": "class Solution {\n    public int minimumIndex(List<Integer> nums) {\n        int n = nums.size();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int max = 0;\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            int num = nums.get(i);\n            if (num > max) {\n                max = num;\n            }\n            left[i] = max;\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            int num = nums.get(i);\n            if (num < min) {\n                min = num;\n            }\n            right[i] = min;\n        }\n        for (int i = 1; i < n; i++) {\n            if (left[i - 1] == right[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}"}
{"id": "1757", "path": "output2\\java\\Medium\\1757-sort-vowels-in-a-string.java", "hypo_code": "class Solution {\n    public String sortVowels(String s) {\n        int n = s.length();\n        char[] arr = s.toCharArray();\n        int i = 0;\n        int j = n - 1;\n        while (i < j) {\n            while (i < n && !isVowel(arr[i])) {\n                i++;\n            }\n            while (j >= 0 && !isVowel(arr[j])) {\n                j--;\n            }\n            if (i < j) {\n                char temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                i++;\n                j--;\n            }\n        }\n        Arrays.sort(arr, 0, i);\n        Arrays.sort(arr, i, n);\n        return String.valueOf(arr);\n    }\n}"}
{"id": "1758", "path": "output2\\java\\Medium\\1758-visit-array-positions-to-maximize-score.java", "hypo_code": "class Solution {\n    public long maxScore(int[] nums, int x) {\n        int n = nums.length;\n        long[] dp = new long[1 << n];\n        for (int i = 1; i < 1 << n; i++) {\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    product *= nums[j];\n                }\n            }\n            int count = 0;\n            for (int j = 2; j * j <= product; j++) {\n                if (product % (j * j) == 0) {\n                    count++;\n                }\n            }\n            dp[i] = count;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    dp[i] = Math.max(dp[i], dp[i ^ (1 << j)]);\n                }\n            }\n        }\n        return dp[(1 << n) - 1] * x;\n    }\n}"}
{"id": "1759", "path": "output2\\java\\Medium\\1759-ways-to-express-an-integer-as-sum-of-powers.java", "hypo_code": "class Solution {\n    public int numberOfWays(int n, int x) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= x; i++) {\n            for (int j = i; j <= n; j++) {\n                dp[j] = (dp[j] + dp[j - i]) % 1000000007;\n            }\n        }\n        return dp[n];\n    }\n}"}
{"id": "1760", "path": "output2\\java\\Medium\\1760-largest-element-in-an-array-after-merge-operations.java", "hypo_code": "class Solution {\n    public long maxArrayValue(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[1 << n];\n        for (int i = 1; i < 1 << n; i++) {\n            int sum = 0;\n            int count = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    sum += nums[j];\n                    count++;\n                }\n            }\n            if (count % 2 == 0) {\n                dp[i] = sum;\n            } else {\n                dp[i] = -sum;\n            }\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    dp[i] = Math.max(dp[i], dp[i ^ (1 << j)]);\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1761", "path": "output2\\java\\Medium\\1761-count-complete-subarrays-in-an-array.java", "hypo_code": "class Solution {\n    public int countCompleteSubarrays(int[] nums) {\n        int n = nums.length;\n        int[] counts = new int[n + 1];\n        int res = 0;\n        int xor = 0;\n        counts[0] = 1;\n        for (int num : nums) {\n            xor ^= num;\n            res += counts[xor]++;\n        }\n        return res;\n    }\n}"}
{"id": "1762", "path": "output2\\java\\Medium\\1762-shortest-string-that-contains-three-strings.java", "hypo_code": "class Solution {\n    public String minimumString(String a, String b, String c) {\n        String result = a + b + c;\n        int n = result.length();\n        int[] dp = new int[1 << n];\n        for (int i = 1; i < 1 << n; i++) {\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    product *= result.charAt(j);\n                }\n            }\n            int count = 0;\n            for (int j = 2; j * j <= product; j++) {\n                if (product % (j * j) == 0) {\n                    count++;\n                }\n            }\n            dp[i] = count;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    dp[i] = Math.max(dp[i], dp[i ^ (1 << j)]);\n                }\n            }\n        }\n        int max = dp[(1 << n) - 1];\n        for (int i = 1; i < 1 << n; i++) {\n            if (dp[i] == max) {\n                String sub = \"\";\n                for (int j = 0; j < n; j++) {\n                    if ((i & (1 << j)) > 0) {\n                        sub += result.charAt(j);\n                    }\n                }\n                if (sub.contains(a) && sub.contains(b) && sub.contains(c)) {\n                    result = sub;\n                }\n            }\n        }\n        return result;\n    }\n}"}
{"id": "1763", "path": "output2\\java\\Medium\\1763-insert-greatest-common-divisors-in-linked-list.java", "hypo_code": "class Solution {\n    public ListNode insertGreatestCommonDivisors(ListNode head) {\n        ListNode dummy = new ListNode(-1, head);\n        ListNode prev = dummy;\n        ListNode cur = head;\n        while (cur != null && cur.next != null) {\n            ListNode next = cur.next;\n            int gcd = gcd(cur.val, next.val);\n            ListNode newNode = new ListNode(gcd, next);\n            prev.next = newNode;\n            cur = next;\n        }\n        return dummy.next;\n    }\n    private int gcd(int a, int b) {\n        if (a < b) {\n            return gcd(b, a);\n        }\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n}"}
{"id": "1764", "path": "output2\\java\\Medium\\1764-minimum-seconds-to-equalize-a-circular-array.java", "hypo_code": "class Solution {\n    public int minimumSeconds(List<Integer> nums) {\n        int n = nums.size();\n        int[] dp = new int[1 << n];\n        for (int i = 1; i < 1 << n; i++) {\n            int sum = 0, max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    sum += nums.get(j);\n                    max = Math.max(max, nums.get(j));\n                    min = Math.min(min, nums.get(j));\n                }\n            }\n            dp[i] = dp[i ^ (1 << Integer.bitCount(i) - 1)] + Integer.bitCount(i) - 2 * Integer.bitCount(i & (1 << n - 1) - 1) + (max == min ? 1 : 0);\n            if (sum % n == 0) {\n                dp[i] = Math.min(dp[i], dp[i ^ (1 << Integer.bitCount(i) - 1)] + Integer.bitCount(i) - 2 * Integer.bitCount(i & (1 << n - 1) - 1));\n            }\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1765", "path": "output2\\java\\Medium\\1765-check-if-it-is-possible-to-split-array.java", "hypo_code": "class Solution {\n    public boolean canSplitArray(List<Integer> nums, int m) {\n        int n = nums.size();\n        int[] prefix = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = prefix[i] + nums.get(i);\n        }\n        int[][] dp = new int[n + 1][m + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return dfs(prefix, m, 0, dp) == 1;\n    }\n    private int dfs(int[] prefix, int m, int start, int[][] dp) {\n        if (m == 1) {\n            return dp[start][m] = 1;\n        }\n        if (dp[start][m] != -1) {\n            return dp[start][m];\n        }\n        int n = prefix.length;\n        for (int i = start + 1; i < n; i++) {\n            int sum = prefix[i] - prefix[start];\n            if (sum >= m && dfs(prefix, m, i, dp) == 1) {\n                return dp[start][m] = 1;\n            }\n        }\n        return dp[start][m] = 0;\n    }\n}"}
{"id": "1766", "path": "output2\\java\\Medium\\1766-find-the-safest-path-in-a-grid.java", "hypo_code": "class Solution {\n    public int maximumSafenessFactor(List<List<Integer>> grid) {\n        int n = grid.size();\n        int[][] dp = new int[n][n];\n        for (int i = n - 1; i >= 0; i--) {\n            List<Integer> row = grid.get(i);\n            for (int j = n - 1; j >= 0; j--) {\n                int cell = row.get(j);\n                if (cell == 1) {\n                    dp[i][j] = Integer.MAX_VALUE;\n                } else {\n                    if (i == n - 1 && j == n - 1) {\n                        dp[i][j] = 0;\n                    } else {\n                        dp[i][j] = Math.min((i == n - 1 ? Integer.MAX_VALUE : dp[i + 1][j]), (j == n - 1 ? Integer.MAX_VALUE : dp[i][j + 1])) + 1;\n                    }\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"}
{"id": "1767", "path": "output2\\java\\Medium\\1767-double-a-number-represented-as-a-linked-list.java", "hypo_code": "class Solution {\n    public ListNode doubleIt(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n        ListNode last = doubleIt(head.next);\n        head.next = new ListNode(head.val);\n        head.next.next = last;\n        return head;\n    }\n}"}
{"id": "1768", "path": "output2\\java\\Medium\\1768-minimum-absolute-difference-between-elements-with-constraint.java", "hypo_code": "class Solution {\n    public int minAbsoluteDifference(List<Integer> nums, int x) {\n        int n = nums.size();\n        int[] dp = new int[1 << n];\n        int max = 0;\n        for (int num : nums) {\n            max |= num;\n        }\n        for (int i = 1; i < 1 << n; i++) {\n            int min = Integer.MAX_VALUE;\n            int max2 = Integer.MIN_VALUE;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    min = Math.min(min, nums.get(j));\n                    max2 = Math.max(max2, nums.get(j));\n                }\n            }\n            dp[i] = Math.min(dp[i ^ (1 << Integer.bitCount(i) - 1)], Math.max(0, max2 - min));\n        }\n        return dp[(1 << n) - 1];\n    }\n}"}
{"id": "1769", "path": "output2\\java\\Hard\\1769-median-of-two-sorted-arrays.java", "hypo_code": "class MedianOfTwoSortedArrays {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int[] nums3 = new int[nums1.length + nums2.length];\n        int i = 0, j = 0, k = 0;\n        while (i < nums1.length && j < nums2.length) {\n            if (nums1[i] < nums2[j]) {\n                nums3[k] = nums1[i];\n                i++;\n            } else {\n                nums3[k] = nums2[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < nums1.length) {\n            nums3[k] = nums1[i];\n            i++;\n            k++;\n        }\n        while (j < nums2.length) {\n            nums3[k] = nums2[j];\n            j++;\n            k++;\n        }\n        if (nums3.length % 2 == 0) {\n            return (nums3[nums3.length / 2] + nums3[nums3.length / 2 - 1]) / 2.0;\n        } else {\n            return nums3[nums3.length / 2];\n        }\n        \n    }\n}"}
{"id": "1770", "path": "output2\\java\\Hard\\1770-regular-expression-matching.java", "hypo_code": "class RegularExpressionMatching {\n    public boolean isMatch(String s, String p) {\n        if (p.isEmpty()) {\n            return s.isEmpty();\n        }\n        boolean firstMatch = (!s.isEmpty() && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.'));\n        if (p.length() >= 2 && p.charAt(1) == '*') {\n            return (isMatch(s, p.substring(2)) || (firstMatch && isMatch(s.substring(1), p)));\n        } else {\n            return firstMatch && isMatch(s.substring(1), p.substring(1));\n        }\n        \n    }\n}"}
{"id": "1771", "path": "output2\\java\\Hard\\1771-merge-k-sorted-lists.java", "hypo_code": "class MergeKSortedLists {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        ListNode head = new ListNode();\n        ListNode curr = head;\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);\n        for(ListNode node : lists){\n            if(node != null) pq.add(node);\n        }\n        while(!pq.isEmpty()){\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if(node.next != null) pq.add(node.next);\n        }\n        return head.next;\n        \n    }\n}"}
{"id": "1772", "path": "output2\\java\\Hard\\1772-reverse-nodes-in-k-group.java", "hypo_code": "class ReverseNodesInKGroup {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode curr = head;\n        int count = 0;\n        while(curr != null && count != k){\n            curr = curr.next;\n            count++;\n        }\n        if(count == k){\n            curr = reverseKGroup(curr, k);\n            while(count-- > 0){\n                ListNode temp = head.next;\n                head.next = curr;\n                curr = head;\n                head = temp;\n            }\n            head = curr;\n        }\n        return head;\n        \n    }\n}"}
{"id": "1773", "path": "output2\\java\\Hard\\1773-substring-with-concatenation-of-all-words.java", "hypo_code": "class SubstringWithConcatenationOfAllWords {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        if(words.length == 0) return res;\n        int wordLen = words[0].length();\n        int totalLen = wordLen * words.length;\n        Map<String, Integer> map = new HashMap<>();\n        for(String word : words){\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n        for(int i = 0; i < s.length() - totalLen + 1; i++){\n            Map<String, Integer> seen = new HashMap<>();\n            int j = 0;\n            while(j < words.length){\n                String word = s.substring(i + j * wordLen, i + (j + 1) * wordLen);\n                if(!map.containsKey(word)) break;\n                seen.put(word, seen.getOrDefault(word, 0) + 1);\n                if(seen.get(word) > map.get(word)) break;\n                j++;\n            }\n            if(j == words.length) res.add(i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1774", "path": "output2\\java\\Hard\\1774-longest-valid-parentheses.java", "hypo_code": "class LongestValidParentheses {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.empty()) {\n                    stack.push(i);\n                } else {\n                    maxans = Math.max(maxans, i - stack.peek());\n                }\n            }\n        }\n        return maxans;\n        \n    }\n}"}
{"id": "1775", "path": "output2\\java\\Hard\\1775-sudoku-solver.java", "hypo_code": "class SudokuSolver {\n    public void solveSudoku(char[][] board) {\n        solve(board);\n\n     \n        \n    }\n}"}
{"id": "1776", "path": "output2\\java\\Hard\\1776-first-missing-positive.java", "hypo_code": "class FirstMissingPositive {\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n        for(int i = 0; i < n; i++){\n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]){\n                int temp = nums[nums[i] - 1];\n                nums[nums[i] - 1] = nums[i];\n                nums[i] = temp;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(nums[i] != i + 1) return i + 1;\n        }\n        return n + 1;\n        \n    }\n}"}
{"id": "1777", "path": "output2\\java\\Hard\\1777-trapping-rain-water.java", "hypo_code": "class TrappingRainWater {\n    public int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int max = 0;\n        for(int i = 0; i < n; i++){\n            left[i] = max;\n            max = Math.max(max, height[i]);\n        }\n        max = 0;\n        for(int i = n - 1; i >= 0; i--){\n            right[i] = max;\n            max = Math.max(max, height[i]);\n        }\n        int ans = 0;\n        for(int i = 0; i < n; i++){\n            int min = Math.min(left[i], right[i]);\n            if(min > height[i]) ans += min - height[i];\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1778", "path": "output2\\java\\Hard\\1778-wildcard-matching.java", "hypo_code": "class WildcardMatching {\n    public boolean isMatch(String s, String p) {\n        int m = s.length();\n        int n = p.length();\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        dp[0][0] = true;\n        for(int i = 1; i <= n; i++){\n            if(p.charAt(i - 1) == '*') dp[0][i] = dp[0][i - 1];\n        }\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                if(p.charAt(j - 1) == '*'){\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                }else if(p.charAt(j - 1) == '?' || s.charAt(i - 1) == p.charAt(j - 1)){\n                    dp[i][j] = dp[i - 1][j - 1];\n                }\n            }\n        }\n        return dp[m][n];\n        \n    }\n}"}
{"id": "1779", "path": "output2\\java\\Hard\\1779-n-queens.java", "hypo_code": "class NQueens {\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> res = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                board[i][j] = '.';\n            }\n        }\n        backtrack(res, board, 0);\n        return res;\n        \n        \n    }\n}"}
{"id": "1780", "path": "output2\\java\\Hard\\1780-n-queens-ii.java", "hypo_code": "class NQueensIi {\n    public int totalNQueens(int n) {\n        int[] res = new int[1];\n        char[][] board = new char[n][n];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                board[i][j] = '.';\n            }\n        }\n        backtrack(res, board, 0);\n        return res[0];\n        \n        \n        \n    }\n}"}
{"id": "1781", "path": "output2\\java\\Hard\\1781-permutation-sequence.java", "hypo_code": "class PermutationSequence {\n    public String getPermutation(int n, int k) {\n        int[] factorial = new int[n];\n        factorial[0] = 1;\n        for (int i = 1; i < n; i++) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n        List<Integer> numbers = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            numbers.add(i);\n        }\n        k--;\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= n; i++) {\n            int index = k / factorial[n - i];\n            sb.append(numbers.get(index));\n            numbers.remove(index);\n            k -= index * factorial[n - i];\n        }\n        return sb.toString();\n        \n    }\n}"}
{"id": "1782", "path": "output2\\java\\Hard\\1782-valid-number.java", "hypo_code": "class ValidNumber {\n    public boolean isNumber(String s) {\n        s = s.trim();\n        boolean pointSeen = false;\n        boolean eSeen = false;\n        boolean numberSeen = false;\n        boolean numberAfterE = true;\n        for (int i = 0; i < s.length(); i++) {\n            if ('0' <= s.charAt(i) && s.charAt(i) <= '9') {\n                numberSeen = true;\n                numberAfterE = true;\n            } else if (s.charAt(i) == '.') {\n                if (eSeen || pointSeen) {\n                    return false;\n                }\n                pointSeen = true;\n            } else if (s.charAt(i) == 'e' || s.charAt(i) == 'E') {\n                if (eSeen || !numberSeen) {\n                    return false;\n                }\n                numberAfterE = false;\n                eSeen = true;\n            } else if (s.charAt(i) == '-' || s.charAt(i) == '+') {\n                if (i != 0 && s.charAt(i - 1) != 'e' && s.charAt(i - 1) != 'E') {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return numberSeen && numberAfterE;\n        \n    }\n}"}
{"id": "1783", "path": "output2\\java\\Hard\\1783-text-justification.java", "hypo_code": "class TextJustification {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> lines = new ArrayList<>();\n        int index = 0;\n        while (index < words.length) {\n            int count = words[index].length();\n            int last = index + 1;\n            while (last < words.length) {\n                if (words[last].length() + count + 1 > maxWidth) break;\n                count += words[last].length() + 1;\n                last++;\n            }\n            StringBuilder builder = new StringBuilder();\n            builder.append(words[index]);\n            int diff = last - index - 1;\n            \n            if (last == words.length || diff == 0) {\n                for (int i = index + 1; i < last; i++) {\n                    builder.append(\" \");\n                    builder.append(words[i]);\n                }\n                for (int i = builder.length(); i < maxWidth; i++) {\n                    builder.append(\" \");\n                }\n            } else {\n                \n                int spaces = (maxWidth - count) / diff;\n                int r = (maxWidth - count) % diff;\n                for (int i = index + 1; i < last; i++) {\n                    for (int k = spaces; k > 0; k--) {\n                        builder.append(\" \");\n                    }\n                    if (r > 0) {\n                        builder.append(\" \");\n                        r--;\n                    }\n                    builder.append(\" \");\n                    builder.append(words[i]);\n                }\n            }\n            lines.add(builder.toString());\n            index = last;\n        }\n        return lines;\n        \n    }\n}"}
{"id": "1784", "path": "output2\\java\\Hard\\1784-minimum-window-substring.java", "hypo_code": "class MinimumWindowSubstring {\n    public String minWindow(String s, String t) {\n        if (s.length() == 0 || t.length() == 0) {\n            return \"\";\n        }\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < t.length(); i++) {\n            int count = map.getOrDefault(t.charAt(i), 0);\n            map.put(t.charAt(i), count + 1);\n        }\n        int required = map.size();\n        int l = 0, r = 0;\n        int formed = 0;\n        Map<Character, Integer> windowCounts = new HashMap<>();\n        int[] ans = {-1, 0, 0};\n        while (r < s.length()) {\n            char c = s.charAt(r);\n            int count = windowCounts.getOrDefault(c, 0);\n            windowCounts.put(c, count + 1);\n            if (map.containsKey(c) && windowCounts.get(c).intValue() == map.get(c).intValue()) {\n                formed++;\n            }\n            while (l <= r && formed == required) {\n                c = s.charAt(l);\n                if (ans[0] == -1 || r - l + 1 < ans[0]) {\n                    ans[0] = r - l + 1;\n                    ans[1] = l;\n                    ans[2] = r;\n                }\n                windowCounts.put(c, windowCounts.get(c) - 1);\n                if (map.containsKey(c) && windowCounts.get(c).intValue() < map.get(c).intValue()) {\n                    formed--;\n                }\n                l++;\n            }\n            r++;\n        }\n        return ans[0] == -1 ? \"\" : s.substring(ans[1], ans[2] + 1);\n        \n    }\n}"}
{"id": "1785", "path": "output2\\java\\Hard\\1785-largest-rectangle-in-histogram.java", "hypo_code": "class LargestRectangleInHistogram {\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\n                stack.pop();\n            }\n            left[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(i);\n        }\n        stack.clear();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\n                stack.pop();\n            }\n            right[i] = stack.isEmpty() ? n : stack.peek();\n            stack.push(i);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1786", "path": "output2\\java\\Hard\\1786-maximal-rectangle.java", "hypo_code": "class MaximalRectangle {\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix.length == 0) {\n            return 0;\n        }\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int[] height = new int[n];\n        Arrays.fill(right, n);\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur_left = 0, cur_right = n;\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == '1') {\n                    height[j]++;\n                } else {\n                    height[j] = 0;\n                }\n            }\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == '1') {\n                    left[j] = Math.max(left[j], cur_left);\n                } else {\n                    left[j] = 0;\n                    cur_left = j + 1;\n                }\n            }\n            for (int j = n - 1; j >= 0; j--) {\n                if (matrix[i][j] == '1') {\n                    right[j] = Math.min(right[j], cur_right);\n                } else {\n                    right[j] = n;\n                    cur_right = j;\n                }\n            }\n            for (int j = 0; j < n; j++) {\n                ans = Math.max(ans, (right[j] - left[j]) * height[j]);\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1787", "path": "output2\\java\\Hard\\1787-scramble-string.java", "hypo_code": "class ScrambleString {\n    public boolean isScramble(String s1, String s2) {\n        if (s1.length() != s2.length()) {\n            return false;\n        }\n        if (s1.equals(s2)) {\n            return true;\n        }\n        int n = s1.length();\n        int[] count = new int[26];\n        for (int i = 0; i < n; i++) {\n            count[s1.charAt(i) - 'a']++;\n            count[s2.charAt(i) - 'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) {\n                return false;\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))) {\n                return true;\n            }\n            if (isScramble(s1.substring(0, i), s2.substring(n - i)) && isScramble(s1.substring(i), s2.substring(0, n - i))) {\n                return true;\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "1788", "path": "output2\\java\\Hard\\1788-distinct-subsequences.java", "hypo_code": "class DistinctSubsequences {\n    public int numDistinct(String s, String t) {\n        int m = s.length();\n        int n = t.length();\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[m][n];\n        \n    }\n}"}
{"id": "1789", "path": "output2\\java\\Hard\\1789-best-time-to-buy-and-sell-stock-iii.java", "hypo_code": "class BestTimeToBuyAndSellStockIii {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int min = prices[0];\n        for (int i = 1; i < n; i++) {\n            min = Math.min(min, prices[i]);\n            left[i] = Math.max(left[i - 1], prices[i] - min);\n        }\n        int max = prices[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            max = Math.max(max, prices[i]);\n            right[i] = Math.max(right[i + 1], max - prices[i]);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = Math.max(ans, left[i] + right[i]);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1790", "path": "output2\\java\\Hard\\1790-binary-tree-maximum-path-sum.java", "hypo_code": "class BinaryTreeMaximumPathSum {\n    public int maxPathSum(TreeNode root) {\n        int[] max = new int[1];\n        max[0] = Integer.MIN_VALUE;\n        maxPathSum(root, max);\n        return max[0];\n        \n    }\n}"}
{"id": "1791", "path": "output2\\java\\Hard\\1791-word-ladder-ii.java", "hypo_code": "class WordLadderIi {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        List<List<String>> res = new ArrayList<>();\n        Set<String> dict = new HashSet<>(wordList);\n        if (!dict.contains(endWord)) return res;\n        Map<String, List<String>> map = new HashMap<>();\n        Map<String, Integer> distance = new HashMap<>();\n        bfs(beginWord, endWord, dict, map, distance);\n        List<String> path = new ArrayList<>();\n        path.add(beginWord);\n        dfs(beginWord, endWord, map, distance, path, res);\n        return res;\n        \n    }\n}"}
{"id": "1792", "path": "output2\\java\\Hard\\1792-word-ladder.java", "hypo_code": "class WordLadder {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> dict = new HashSet<>(wordList);\n        if (!dict.contains(endWord)) return 0;\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(beginWord);\n        int level = 1;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String word = queue.poll();\n                if (word.equals(endWord)) return level;\n                for (int j = 0; j < word.length(); j++) {\n                    char[] chars = word.toCharArray();\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        chars[j] = c;\n                        String newWord = new String(chars);\n                        if (dict.contains(newWord)) {\n                            queue.offer(newWord);\n                            dict.remove(newWord);\n                        }\n                    }\n                }\n            }\n            level++;\n        }\n        return 0;\n        \n    }\n}"}
{"id": "1793", "path": "output2\\java\\Hard\\1793-palindrome-partitioning-ii.java", "hypo_code": "class PalindromePartitioningIi {\n    public int minCut(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] cuts = new int[n];\n        for (int i = 0; i < n; i++) {\n            int min = i;\n            for (int j = 0; j <= i; j++) {\n                if (s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j + 1][i - 1])) {\n                    dp[j][i] = true;\n                    min = j == 0 ? 0 : Math.min(min, cuts[j - 1] + 1);\n                }\n            }\n            cuts[i] = min;\n        }\n        return cuts[n - 1];\n        \n    }\n}"}
{"id": "1794", "path": "output2\\java\\Hard\\1794-candy.java", "hypo_code": "class Candy {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Arrays.fill(left, 1);\n        Arrays.fill(right, 1);\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                right[i] = right[i + 1] + 1;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans += Math.max(left[i], right[i]);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1795", "path": "output2\\java\\Hard\\1795-word-break-ii.java", "hypo_code": "class WordBreakIi {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        List<String> res = new ArrayList<>();\n        Set<String> dict = new HashSet<>(wordDict);\n        Map<String, List<String>> map = new HashMap<>();\n        dfs(s, dict, map, res);\n        return res;\n        \n        \n    }\n}"}
{"id": "1796", "path": "output2\\java\\Hard\\1796-max-points-on-a-line.java", "hypo_code": "class MaxPointsOnALine {\n    public int maxPoints(int[][] points) {\n        int n = points.length;\n        if (n < 3) {\n            return n;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            Map<String, Integer> map = new HashMap<>();\n            int same = 0;\n            int max = 0;\n            for (int j = i + 1; j < n; j++) {\n                int x = points[j][0] - points[i][0];\n                int y = points[j][1] - points[i][1];\n                if (x == 0 && y == 0) {\n                    same++;\n                    continue;\n                }\n                int gcd = gcd(x, y);\n                x /= gcd;\n                y /= gcd;\n                String key = x + \",\" + y;\n                map.put(key, map.getOrDefault(key, 0) + 1);\n                max = Math.max(max, map.get(key));\n            }\n            ans = Math.max(ans, max + same + 1);\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "1797", "path": "output2\\java\\Hard\\1797-find-minimum-in-rotated-sorted-array-ii.java", "hypo_code": "class FindMinimumInRotatedSortedArrayIi {\n    public int findMin(int[] nums) {\n        int n = nums.length;\n        int left = 0;\n        int right = n - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < nums[right]) {\n                right = mid;\n            } else if (nums[mid] > nums[right]) {\n                left = mid + 1;\n            } else {\n                right--;\n            }\n        }\n        return nums[left];\n        \n    }\n}"}
{"id": "1798", "path": "output2\\java\\Hard\\1798-maximum-gap.java", "hypo_code": "class MaximumGap {\n    public int maximumGap(int[] nums) {\n        int n = nums.length;\n        if (n < 2) {\n            return 0;\n        }\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for (int num : nums) {\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n        int gap = (int) Math.ceil((double) (max - min) / (n - 1));\n        int[] bucketMin = new int[n - 1];\n        int[] bucketMax = new int[n - 1];\n        Arrays.fill(bucketMin, Integer.MAX_VALUE);\n        Arrays.fill(bucketMax, Integer.MIN_VALUE);\n        for (int num : nums) {\n            if (num == min || num == max) {\n                continue;\n            }\n            int idx = (num - min) / gap;\n            bucketMin[idx] = Math.min(bucketMin[idx], num);\n            bucketMax[idx] = Math.max(bucketMax[idx], num);\n        }\n        int maxGap = Integer.MIN_VALUE;\n        int previous = min;\n        for (int i = 0; i < n - 1; i++) {\n            if (bucketMin[i] == Integer.MAX_VALUE && bucketMax[i] == Integer.MIN_VALUE) {\n                continue;\n            }\n            maxGap = Math.max(maxGap, bucketMin[i] - previous);\n            previous = bucketMax[i];\n        }\n        maxGap = Math.max(maxGap, max - previous);\n        return maxGap;\n        \n    }\n}"}
{"id": "1799", "path": "output2\\java\\Hard\\1799-dungeon-game.java", "hypo_code": "class DungeonGame {\n    public int calculateMinimumHP(int[][] dungeon) {\n        int m = dungeon.length;\n        int n = dungeon[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        dp[m][n - 1] = 1;\n        dp[m - 1][n] = 1;\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                int min = Math.min(dp[i + 1][j], dp[i][j + 1]);\n                dp[i][j] = Math.max(min - dungeon[i][j], 1);\n            }\n        }\n        return dp[0][0];\n        \n    }\n}"}
{"id": "1801", "path": "output2\\java\\Hard\\1801-best-time-to-buy-and-sell-stock-iv.java", "hypo_code": "class BestTimeToBuyAndSellStockIv {\n    public int maxProfit(int k, int[] prices) {\n        int n = prices.length;\n        if (n == 0) {\n            return 0;\n        }\n        if (k >= n / 2) {\n            int ans = 0;\n            for (int i = 1; i < n; i++) {\n                ans += Math.max(0, prices[i] - prices[i - 1]);\n            }\n            return ans;\n        }\n        int[] buy = new int[k + 1];\n        int[] sell = new int[k + 1];\n        Arrays.fill(buy, Integer.MIN_VALUE);\n        for (int price : prices) {\n            for (int i = 1; i <= k; i++) {\n                buy[i] = Math.max(buy[i], sell[i - 1] - price);\n                sell[i] = Math.max(sell[i], buy[i] + price);\n            }\n        }\n        return sell[k];\n        \n    }\n}"}
{"id": "1802", "path": "output2\\java\\Hard\\1802-word-search-ii.java", "hypo_code": "class WordSearchIi {\n    public List<String> findWords(char[][] board, String[] words) {\n        List<String> ans = new ArrayList<>();\n        Trie trie = new Trie();\n        for (String word : words) {\n            trie.insert(word);\n        }\n        int m = board.length;\n        int n = board[0].length;\n        boolean[][] visited = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dfs(board, visited, i, j, trie.root, ans);\n            }\n        }\n        return ans;\n        \n\n        \n    }\n}"}
{"id": "1803", "path": "output2\\java\\Hard\\1803-shortest-palindrome.java", "hypo_code": "class ShortestPalindrome {\n    public String shortestPalindrome(String s) {\n        int n = s.length();\n        int[] dp = new int[n];\n        for (int i = 1; i < n; i++) {\n            int j = dp[i - 1];\n            while (j > 0 && s.charAt(i) != s.charAt(j)) {\n                j = dp[j - 1];\n            }\n            if (s.charAt(i) == s.charAt(j)) {\n                j++;\n            }\n            dp[i] = j;\n        }\n        int j = dp[n - 1];\n        for (int i = n - 1; i >= 0; i--) {\n            while (j > 0 && s.charAt(i) != s.charAt(j)) {\n                j = dp[j - 1];\n            }\n            if (s.charAt(i) == s.charAt(j)) {\n                j++;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = n - 1; i >= j; i--) {\n            sb.append(s.charAt(i));\n        }\n        sb.append(s);\n        return sb.toString();\n        \n    }\n}"}
{"id": "1804", "path": "output2\\java\\Hard\\1804-the-skyline-problem.java", "hypo_code": "class TheSkylineProblem {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<int[]> heights = new ArrayList<>();\n        for (int[] b : buildings) {\n            heights.add(new int[]{b[0], -b[2]});\n            heights.add(new int[]{b[1], b[2]});\n        }\n        Collections.sort(heights, (a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            }\n            return a[1] - b[1];\n        });\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\n        pq.offer(0);\n        int prev = 0;\n        for (int[] h : heights) {\n            if (h[1] < 0) {\n                pq.offer(-h[1]);\n            } else {\n                pq.remove(h[1]);\n            }\n            int cur = pq.peek();\n            if (prev != cur) {\n                List<Integer> list = new ArrayList<>();\n                list.add(h[0]);\n                list.add(cur);\n                res.add(list);\n                prev = cur;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1805", "path": "output2\\java\\Hard\\1805-contains-duplicate-iii.java", "hypo_code": "class ContainsDuplicateIii {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\n        int n = nums.length;\n        TreeSet<Long> set = new TreeSet<>();\n        for (int i = 0; i < n; i++) {\n            Long ceiling = set.ceiling((long) nums[i] - valueDiff);\n            if (ceiling != null && ceiling <= (long) nums[i] + valueDiff) {\n                return true;\n            }\n            set.add((long) nums[i]);\n            if (i >= indexDiff) {\n                set.remove((long) nums[i - indexDiff]);\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "1806", "path": "output2\\java\\Hard\\1806-basic-calculator.java", "hypo_code": "class BasicCalculator {\n    public int calculate(String s) {\n        int n = s.length();\n        int ans = 0;\n        int sign = 1;\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                int num = c - '0';\n                while (i + 1 < n && Character.isDigit(s.charAt(i + 1))) {\n                    num = num * 10 + s.charAt(i + 1) - '0';\n                    i++;\n                }\n                ans += sign * num;\n            } else if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                stack.push(ans);\n                stack.push(sign);\n                ans = 0;\n                sign = 1;\n            } else if (c == ')') {\n                ans = ans * stack.pop() + stack.pop();\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1807", "path": "output2\\java\\Hard\\1807-number-of-digit-one.java", "hypo_code": "class NumberOfDigitOne {\n    public int countDigitOne(int n) {\n        int ans = 0;\n        for (long i = 1; i <= n; i *= 10) {\n            long div = i * 10;\n            ans += (n / div) * i + Math.min(Math.max(n % div - i + 1, 0), i);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1808", "path": "output2\\java\\Hard\\1808-sliding-window-maximum.java", "hypo_code": "class SlidingWindowMaximum {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        left[0] = nums[0];\n        right[n - 1] = nums[n - 1];\n        for (int i = 1; i < n; i++) {\n            if (i % k == 0) {\n                left[i] = nums[i];\n            } else {\n                left[i] = Math.max(left[i - 1], nums[i]);\n            }\n            int j = n - i - 1;\n            if ((j + 1) % k == 0) {\n                right[j] = nums[j];\n            } else {\n                right[j] = Math.max(right[j + 1], nums[j]);\n            }\n        }\n        int[] ans = new int[n - k + 1];\n        for (int i = 0; i < n - k + 1; i++) {\n            ans[i] = Math.max(right[i], left[i + k - 1]);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1810", "path": "output2\\java\\Hard\\1810-integer-to-english-words.java", "hypo_code": "class Solution {\n    public String numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        String[] units = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n        String res = \"\";\n        for (int i = 0; i < units.length && num > 0; i++) {\n            if (num % 1000 != 0) {\n                res = helper(num % 1000) + units[i] + \" \" + res;\n            }\n            num /= 1000;\n        }\n        return res.trim();\n    }\n    \n    private String helper(int num) {\n        String[] lessThan20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \n                               \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\n                               \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n        String[] tens = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \n                         \"Eighty\", \"Ninety\"};\n        if (num < 20) {\n            return lessThan20[num] + \" \";\n        } else if (num < 100) {\n            return tens[num / 10] + \" \" + helper(num % 10);\n        } else {\n            return lessThan20[num / 100] + \" Hundred \" + helper(num % 100);\n        }\n    }\n}"}
{"id": "1811", "path": "output2\\java\\Hard\\1811-expression-add-operators.java", "hypo_code": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        List<String> res = new ArrayList<>();\n        helper(res, num, target, 0, \"\", 0, 0);\n        return res;\n    }\n    \n    private void helper(List<String> res, String num, int target, int pos, String path, long eval, long multed) {\n        if (pos == num.length()) {\n            if (eval == target) {\n                res.add(path);\n            }\n            return;\n        }\n        for (int i = pos; i < num.length(); i++) {\n            if (i != pos && num.charAt(pos) == '0') {\n                break;\n            }\n            long cur = Long.parseLong(num.substring(pos, i + 1));\n            if (pos == 0) {\n                helper(res, num, target, i + 1, path + cur, cur, cur);\n            } else {\n                helper(res, num, target, i + 1, path + \"+\" + cur, eval + cur, cur);\n                helper(res, num, target, i + 1, path + \"-\" + cur, eval - cur, -cur);\n                helper(res, num, target, i + 1, path + \"*\" + cur, eval - multed + multed * cur, multed * cur);\n            }\n        }\n    }\n}"}
{"id": "1814", "path": "output2\\java\\Hard\\1814-remove-invalid-parentheses.java", "hypo_code": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        List<String> res = new ArrayList<>();\n        helper(res, s, 0, 0, new char[]{'(', ')'});\n        return res;\n    }\n    \n    private void helper(List<String> res, String s, int last_i, int last_j, char[] par) {\n        for (int stack = 0, i = last_i; i < s.length(); i++) {\n            if (s.charAt(i) == par[0]) {\n                stack++;\n            }\n            if (s.charAt(i) == par[1]) {\n                stack--;\n            }\n            if (stack >= 0) {\n                continue;\n            }\n            for (int j = last_j; j <= i; j++) {\n                if (s.charAt(j) == par[1] && (j == last_j || s.charAt(j - 1) != par[1])) {\n                    helper(res, s.substring(0, j) + s.substring(j + 1), i, j, par);\n                }\n            }\n            return;\n        }\n        String reversed = new StringBuilder(s).reverse().toString();\n        if (par[0] == '(') {\n            helper(res, reversed, 0, 0, new char[]{')', '('});\n        } else {\n            res.add(reversed);\n        }\n    }\n}"}
{"id": "1815", "path": "output2\\java\\Hard\\1815-burst-balloons.java", "hypo_code": "class BurstBalloons {\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        int[] newNums = new int[n + 2];\n        newNums[0] = 1;\n        newNums[n + 1] = 1;\n        for (int i = 0; i < n; i++) {\n            newNums[i + 1] = nums[i];\n        }\n        int[][] dp = new int[n + 2][n + 2];\n        for (int len = 1; len <= n; len++) {\n            for (int i = 1; i <= n - len + 1; i++) {\n                int j = i + len - 1;\n                for (int k = i; k <= j; k++) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k - 1] + newNums[i - 1] * newNums[k] * newNums[j + 1] + dp[k + 1][j]);\n                }\n            }\n        }\n        return dp[1][n];\n        \n    }\n}"}
{"id": "1816", "path": "output2\\java\\Hard\\1816-count-of-smaller-numbers-after-self.java", "hypo_code": "class CountOfSmallerNumbersAfterSelf {\n    public List<Integer> countSmaller(int[] nums) {\n        int n = nums.length;\n        int[] indexes = new int[n];\n        for (int i = 0; i < n; i++) {\n            indexes[i] = i;\n        }\n        int[] counts = new int[n];\n        mergeSort(nums, indexes, counts, 0, n - 1);\n        List<Integer> ans = new ArrayList<Integer>();\n        for (int count : counts) {\n            ans.add(count);\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "1817", "path": "output2\\java\\Hard\\1817-create-maximum-number.java", "hypo_code": "class CreateMaximumNumber {\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int m = nums1.length;\n        int n = nums2.length;\n        int[] ans = new int[k];\n        for (int i = Math.max(0, k - n); i <= k && i <= m; i++) {\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\n            if (greater(candidate, 0, ans, 0)) {\n                ans = candidate;\n            }\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "1818", "path": "output2\\java\\Hard\\1818-count-of-range-sum.java", "hypo_code": "class CountOfRangeSum {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        int n = nums.length;\n        long[] sums = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            sums[i + 1] = sums[i] + nums[i];\n        }\n        return countWhileMergeSort(sums, 0, n + 1, lower, upper);\n        \n        \n    }\n}"}
{"id": "1819", "path": "output2\\java\\Hard\\1819-longest-increasing-path-in-a-matrix.java", "hypo_code": "class LongestIncreasingPathInAMatrix {\n    public int longestIncreasingPath(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[][] left = new int[m][n];\n        int[][] right = new int[m][n];\n        int[][] up = new int[m][n];\n        int[][] down = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                left[i][j] = 1;\n                right[i][j] = 1;\n                up[i][j] = 1;\n                down[i][j] = 1;\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][j] > matrix[i][j - 1]) {\n                    left[i][j] = left[i][j - 1] + 1;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = n - 2; j >= 0; j--) {\n                if (matrix[i][j] > matrix[i][j + 1]) {\n                    right[i][j] = right[i][j + 1] + 1;\n                }\n            }\n        }\n        for (int j = 0; j < n; j++) {\n            for (int i = 1; i < m; i++) {\n                if (matrix[i][j] > matrix[i - 1][j]) {\n                    up[i][j] = up[i - 1][j] + 1;\n                }\n            }\n        }\n        for (int j = 0; j < n; j++) {\n            for (int i = m - 2; i >= 0; i--) {\n                if (matrix[i][j] > matrix[i + 1][j]) {\n                    down[i][j] = down[i + 1][j] + 1;\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                ans = Math.max(ans, left[i][j] + right[i][j + 1] - 1);\n                ans = Math.max(ans, up[i][j] + down[i + 1][j] - 1);\n\n                \n        \n    }\n}"}
{"id": "1820", "path": "output2\\java\\Hard\\1820-patching-array.java", "hypo_code": "class PatchingArray {\n    public int minPatches(int[] nums, int n) {\n        int patches = 0, i = 0;\n        long miss = 1;\n        while (miss <= n) {\n            if (i < nums.length && nums[i] <= miss) {\n                miss += nums[i++];\n            } else {\n                miss += miss;\n                patches++;\n            }\n        }\n        return patches;\n        \n    }\n}"}
{"id": "1821", "path": "output2\\java\\Hard\\1821-reconstruct-itinerary.java", "hypo_code": "class ReconstructItinerary {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\n        for (List<String> ticket : tickets) {\n            map.computeIfAbsent(ticket.get(0), k -> new PriorityQueue<>()).add(ticket.get(1));\n        }\n        List<String> ans = new ArrayList<>();\n        dfs(map, \"JFK\", ans);\n        Collections.reverse(ans);\n        return ans;\n        \n        \n        \n    }\n}"}
{"id": "1822", "path": "output2\\java\\Hard\\1822-self-crossing.java", "hypo_code": "class SelfCrossing {\n    public boolean isSelfCrossing(int[] distance) {\n        int n = distance.length;\n        for (int i = 3; i < n; i++) {\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\n                return true;\n            }\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) {\n                return true;\n            }\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\n                return true;\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "1823", "path": "output2\\java\\Hard\\1823-palindrome-pairs.java", "hypo_code": "class PalindromePairs {\n    public List<List<Integer>> palindromePairs(String[] words) {\n        int n = words.length;\n        List<List<Integer>> ans = new ArrayList<>();\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.put(words[i], i);\n        }\n        for (int i = 0; i < n; i++) {\n            String word = words[i];\n            int m = word.length();\n            for (int j = 0; j <= m; j++) {\n                String left = word.substring(0, j);\n                String right = word.substring(j);\n                if (isPalindrome(left)) {\n                    String rightRev = new StringBuilder(right).reverse().toString();\n                    if (map.containsKey(rightRev) && map.get(rightRev) != i) {\n                        List<Integer> list = new ArrayList<>();\n                        list.add(map.get(rightRev));\n                        list.add(i);\n                        ans.add(list);\n                    }\n                }\n                if (isPalindrome(right)) {\n                    String leftRev = new StringBuilder(left).reverse().toString();\n                    if (map.containsKey(leftRev) && map.get(leftRev) != i && right.length() != 0) {\n                        List<Integer> list = new ArrayList<>();\n                        list.add(i);\n                        list.add(map.get(leftRev));\n                        ans.add(list);\n                    }\n                }\n            }\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "1825", "path": "output2\\java\\Hard\\1825-russian-doll-envelopes.java", "hypo_code": "class RussianDollEnvelopes {\n    public int maxEnvelopes(int[][] envelopes) {\n        int n = envelopes.length;\n        Arrays.sort(envelopes, (a, b) -> {\n            if (a[0] == b[0]) {\n                return b[1] - a[1];\n            } else {\n                return a[0] - b[0];\n            }\n        });\n        int[] dp = new int[n];\n        int len = 0;\n        for (int[] envelope : envelopes) {\n            int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\n            if (index < 0) {\n                index = -(index + 1);\n            }\n            dp[index] = envelope[1];\n            if (index == len) {\n                len++;\n            }\n        }\n        return len;\n        \n    }\n}"}
{"id": "1826", "path": "output2\\java\\Hard\\1826-max-sum-of-rectangle-no-larger-than-k.java", "hypo_code": "class MaxSumOfRectangleNoLargerThanK {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int ans = Integer.MIN_VALUE;\n        for (int i = 0; i < m; i++) {\n            int[] rowSum = new int[n];\n            for (int j = i; j < m; j++) {\n                for (int c = 0; c < n; c++) {\n                    rowSum[c] += matrix[j][c];\n                }\n                TreeSet<Integer> set = new TreeSet<>();\n                set.add(0);\n                int sum = 0;\n                for (int c = 0; c < n; c++) {\n                    sum += rowSum[c];\n                    Integer ceiling = set.ceiling(sum - k);\n                    if (ceiling != null) {\n                        ans = Math.max(ans, sum - ceiling);\n                    }\n                    set.add(sum);\n                }\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1828", "path": "output2\\java\\Hard\\1828-perfect-rectangle.java", "hypo_code": "class PerfectRectangle {\n    public boolean isRectangleCover(int[][] rectangles) {\n        int n = rectangles.length;\n        int x1 = Integer.MAX_VALUE, y1 = Integer.MAX_VALUE;\n        int x2 = Integer.MIN_VALUE, y2 = Integer.MIN_VALUE;\n        Set<String> set = new HashSet<>();\n        int area = 0;\n        for (int[] rec : rectangles) {\n            x1 = Math.min(x1, rec[0]);\n            y1 = Math.min(y1, rec[1]);\n            x2 = Math.max(x2, rec[2]);\n            y2 = Math.max(y2, rec[3]);\n            area += (rec[2] - rec[0]) * (rec[3] - rec[1]);\n            String s1 = rec[0] + \" \" + rec[1];\n            String s2 = rec[0] + \" \" + rec[3];\n            String s3 = rec[2] + \" \" + rec[3];\n            String s4 = rec[2] + \" \" + rec[1];\n            if (!set.add(s1)) set.remove(s1);\n            if (!set.add(s2)) set.remove(s2);\n            if (!set.add(s3)) set.remove(s3);\n            if (!set.add(s4)) set.remove(s4);\n        }\n        if (!set.contains(x1 + \" \" + y1) || !set.contains(x1 + \" \" + y2) || !set.contains(x2 + \" \" + y1) || !set.contains(x2 + \" \" + y2) || set.size() != 4) return false;\n        return area == (x2 - x1) * (y2 - y1);\n        \n    }\n}"}
{"id": "1829", "path": "output2\\java\\Hard\\1829-frog-jump.java", "hypo_code": "class FrogJump {\n    public boolean canCross(int[] stones) {\n        int n = stones.length;\n        boolean[][] dp = new boolean[n][n];\n        dp[0][0] = true;\n        for (int i = 1; i < n; i++) {\n            if (stones[i] - stones[i - 1] > i) {\n                return false;\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = i - 1; j >= 0; j--) {\n                int k = stones[i] - stones[j];\n                if (k > j + 1) {\n                    break;\n                }\n                dp[i][k] = dp[j][k] || dp[j][k - 1] || dp[j][k + 1];\n                if (i == n - 1 && dp[i][k]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "1830", "path": "output2\\java\\Hard\\1830-trapping-rain-water-ii.java", "hypo_code": "class TrappingRainWaterIi {\n    public int trapRainWater(int[][] heightMap) {\n        int m = heightMap.length;\n        int n = heightMap[0].length;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        boolean[][] visited = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            pq.offer(new int[]{i, 0, heightMap[i][0]});\n            pq.offer(new int[]{i, n - 1, heightMap[i][n - 1]});\n            visited[i][0] = true;\n            visited[i][n - 1] = true;\n        }\n        for (int j = 1; j < n - 1; j++) {\n            pq.offer(new int[]{0, j, heightMap[0][j]});\n            pq.offer(new int[]{m - 1, j, heightMap[m - 1][j]});\n            visited[0][j] = true;\n            visited[m - 1][j] = true;\n        }\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int ans = 0;\n        while (!pq.isEmpty()) {\n            int[] cell = pq.poll();\n            for (int[] dir : dirs) {\n                int x = cell[0] + dir[0];\n                int y = cell[1] + dir[1];\n                if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\n                    visited[x][y] = true;\n                    ans += Math.max(0, cell[2] - heightMap[x][y]);\n                    pq.offer(new int[]{x, y, Math.max(heightMap[x][y], cell[2])});\n                }\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1831", "path": "output2\\java\\Hard\\1831-split-array-largest-sum.java", "hypo_code": "class SplitArrayLargestSum {\n    public int splitArray(int[] nums, int k) {\n        int n = nums.length;\n        int[] sums = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            sums[i + 1] = sums[i] + nums[i];\n        }\n        int[][] dp = new int[k + 1][n + 1];\n        for (int i = 0; i <= k; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        dp[0][0] = 0;\n        for (int i = 1; i <= k; i++) {\n            for (int j = i; j <= n; j++) {\n                for (int p = i - 1; p < j; p++) {\n                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - 1][p], sums[j] - sums[p]));\n                }\n            }\n        }\n        return dp[k][n];\n        \n    }\n}"}
{"id": "1832", "path": "output2\\java\\Hard\\1832-strong-password-checker.java", "hypo_code": "class Solution {\n    public int strongPasswordChecker(String password) {\n        int res = 0, a = 1, A = 1, d = 1;\n        char[] p = password.toCharArray();\n        int[] arr = new int[p.length];\n        for (int i = 0; i < arr.length;) {\n            if (Character.isLowerCase(p[i])) {\n                a = 0;\n            }\n            if (Character.isUpperCase(p[i])) {\n                A = 0;\n            }\n            if (Character.isDigit(p[i])) {\n                d = 0;\n            }\n            int j = i;\n            while (i < p.length && p[i] == p[j]) {\n                i++;\n            }\n            arr[j] = i - j;\n        }\n        int total_missing = (a + A + d);\n        if (arr.length < 6) {\n            res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\n        } else {\n            int over_len = Math.max(arr.length - 20, 0), left_over = 0;\n            res += over_len;\n            for (int k = 1; k < 3; k++) {\n                for (int i = 0; i < arr.length && over_len > 0; i++) {\n                    if (arr[i] < 3 || arr[i] % 3 != (k - 1)) {\n                        continue;\n                    }\n                    arr[i] -= Math.min(over_len, k);\n                    over_len -= k;\n                }\n            }\n            for (int i = 0; i < arr.length; i++) {\n                if (arr[i] >= 3 && over_len > 0) {\n                    int need = arr[i] - 2;\n                    arr[i] -= over_len;\n                    over_len -= need;\n                }\n                if (arr[i] >= 3) {\n                    left_over += arr[i] / 3;\n                }\n            }\n            res += Math.max(total_missing, left_over);\n        }\n        return res;\n    }\n}"}
{"id": "1834", "path": "output2\\java\\Hard\\1834-k-th-smallest-in-lexicographical-order.java", "hypo_code": "class KThSmallestInLexicographicalOrder {\n    public int findKthNumber(int n, int k) {\n        int curr = 1;\n        k = k - 1;\n        while (k > 0) {\n            int steps = calSteps(n, curr, curr + 1);\n            if (steps <= k) {\n                curr += 1;\n                k -= steps;\n            } else {\n                curr *= 10;\n                k -= 1;\n            }\n        }\n        return curr;\n        \n        \n    }\n}"}
{"id": "1835", "path": "output2\\java\\Hard\\1835-arithmetic-slices-ii-subsequence.java", "hypo_code": "class ArithmeticSlicesIiSubsequence {\n    public int numberOfArithmeticSlices(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n        Map<Long, Integer>[] f = new Map[n];\n        for (int i = 0; i < n; i++) {\n            f[i] = new HashMap<Long, Integer>();\n            for (int j = 0; j < i; j++) {\n                long d = (long) nums[i] - nums[j];\n                int cnt = f[j].getOrDefault(d, 0);\n                ans += cnt;\n                f[i].put(d, f[i].getOrDefault(d, 0) + cnt + 1);\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1836", "path": "output2\\java\\Hard\\1836-poor-pigs.java", "hypo_code": "class PoorPigs {\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        int states = minutesToTest / minutesToDie + 1;\n        int pigs = 0;\n        while (Math.pow(states, pigs) < buckets) {\n            pigs++;\n        }\n        return pigs;\n        \n    }\n}"}
{"id": "1838", "path": "output2\\java\\Hard\\1838-count-the-repetitions.java", "hypo_code": "class Solution {\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n        int count1 = 0, count2 = 0, i = 0, j = 0;\n        while (count1 < n1) {\n            if (s1.charAt(i) == s2.charAt(j)) {\n                j++;\n                if (j == s2.length()) {\n                    j = 0;\n                    count2++;\n                }\n            }\n            i++;\n            if (i == s1.length()) {\n                i = 0;\n                count1++;\n            }\n        }\n        return count2 / n2;\n    }\n}"}
{"id": "1839", "path": "output2\\java\\Hard\\1839-concatenated-words.java", "hypo_code": "class ConcatenatedWords {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        List<String> ans = new ArrayList<>();\n        Set<String> set = new HashSet<>();\n        for (String word : words) {\n            set.add(word);\n        }\n        for (String word : words) {\n            set.remove(word);\n            if (canForm(word, set)) {\n                ans.add(word);\n            }\n            set.add(word);\n        }\n        return ans;\n        \n        \n        \n    }\n}"}
{"id": "1840", "path": "output2\\java\\Hard\\1840-largest-palindrome-product.java", "hypo_code": "class LargestPalindromeProduct {\n    public int largestPalindrome(int n) {\n        if (n == 1) {\n            return 9;\n        }\n        int upper = (int) Math.pow(10, n) - 1;\n        int lower = upper / 10;\n        for (int i = upper; i > lower; i--) {\n            long palindrome = createPalindrome(i);\n            for (long j = upper; j * j >= palindrome; j--) {\n                if (palindrome % j == 0) {\n                    return (int) (palindrome % 1337);\n                }\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1841", "path": "output2\\java\\Hard\\1841-sliding-window-median.java", "hypo_code": "class SlidingWindowMedian {\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        double[] ans = new double[n - k + 1];\n        PriorityQueue<Integer> small = new PriorityQueue<Integer>(new Comparator<Integer>() {\n            public int compare(Integer num1, Integer num2) {\n                return num2 - num1;\n            }\n        });\n        PriorityQueue<Integer> large = new PriorityQueue<Integer>((num1, num2) -> (num1 - num2));\n        for (int i = 0; i < n; i++) {\n            if (small.size() <= large.size()) {\n                large.add(nums[i]);\n                small.add(large.poll());\n            } else {\n                small.add(nums[i]);\n                large.add(small.poll());\n            }\n            if (small.size() + large.size() == k) {\n                ans[i - k + 1] = ((long) small.peek() + large.peek()) / 2.0;\n                if (!small.remove(nums[i - k + 1])) {\n                    large.remove(nums[i - k + 1]);\n                }\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1842", "path": "output2\\java\\Hard\\1842-smallest-good-base.java", "hypo_code": "class SmallestGoodBase {\n    public String smallestGoodBase(String n) {\n        long num = Long.parseLong(n);\n        int mMax = (int) (Math.log(num + 1) / Math.log(2));\n        for (int m = mMax; m > 1; m--) {\n            int k = (int) Math.pow(num, 1.0 / m);\n            long mul = 1, sum = 1;\n            for (int i = 0; i < m; i++) {\n                mul *= k;\n                sum += mul;\n            }\n            if (sum == num) {\n                return Integer.toString(k);\n            }\n        }\n        return Long.toString(num - 1);\n        \n    }\n}"}
{"id": "1843", "path": "output2\\java\\Hard\\1843-zuma-game.java", "hypo_code": "class ZumaGame {\n    public int findMinStep(String board, String hand) {\n        int[] handCount = new int[26];\n        for (char c : hand.toCharArray()) {\n            handCount[c - 'A']++;\n        }\n        int ans = dfs(board + \"#\", handCount);\n        return ans == 6 ? -1 : ans;\n        \n    }\n}"}
{"id": "1844", "path": "output2\\java\\Hard\\1844-reverse-pairs.java", "hypo_code": "class Solution {\n    public int reversePairs(int[] nums) {\n        int n = nums.length;\n        return mergeSort(nums, 0, n - 1);\n    }\n    \n    private int mergeSort(int[] nums, int l, int r) {\n        if (l >= r) {\n            return 0;\n        }\n        int mid = (l + r) >>> 1, res = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r);\n        for (int i = l, j = mid + 1; i <= mid; i++) {\n            while (j <= r && nums[i] > 2L * nums[j]) {\n                j++;\n            }\n            res += j - mid - 1;\n        }\n        Arrays.sort(nums, l, r + 1);\n        return res;\n    }\n}"}
{"id": "1845", "path": "output2\\java\\Hard\\1845-ipo.java", "hypo_code": "class Ipo {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        int n = profits.length;\n        int[][] projects = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            projects[i][0] = capital[i];\n            projects[i][1] = profits[i];\n        }\n        Arrays.sort(projects, (a, b) -> a[0] - b[0]);\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        int i = 0;\n        while (k-- > 0) {\n            while (i < n && projects[i][0] <= w) {\n                pq.offer(projects[i++][1]);\n            }\n            if (!pq.isEmpty()) {\n                w += pq.poll();\n            } else {\n                break;\n            }\n        }\n        return w;\n        \n    }\n}"}
{"id": "1846", "path": "output2\\java\\Hard\\1846-freedom-trail.java", "hypo_code": "class FreedomTrail {\n    public int findRotateSteps(String ring, String key) {\n        int m = ring.length();\n        int n = key.length();\n        int[][] dp = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        for (int j = 0; j < m; j++) {\n            if (ring.charAt(j) == key.charAt(0)) {\n                dp[0][j] = Math.min(j, m - j) + 1;\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (ring.charAt(j) != key.charAt(i)) {\n                    continue;\n                }\n                for (int k = 0; k < m; k++) {\n                    if (dp[i - 1][k] == Integer.MAX_VALUE) {\n                        continue;\n                    }\n                    int diff = Math.abs(j - k);\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + Math.min(diff, m - diff) + 1);\n                }\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int j = 0; j < m; j++) {\n            ans = Math.min(ans, dp[n - 1][j]);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1847", "path": "output2\\java\\Hard\\1847-super-washing-machines.java", "hypo_code": "class SuperWashingMachines {\n    public int findMinMoves(int[] machines) {\n        int n = machines.length;\n        int sum = 0;\n        for (int machine : machines) {\n            sum += machine;\n        }\n        if (sum % n != 0) {\n            return -1;\n        }\n        int avg = sum / n;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        left[0] = machines[0] - avg;\n        right[n - 1] = machines[n - 1] - avg;\n        for (int i = 1; i < n; i++) {\n            left[i] = left[i - 1] + machines[i] - avg;\n            int j = n - i - 1;\n            right[j] = right[j + 1] + machines[j] - avg;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int l = i > 0 ? left[i - 1] : 0;\n            int r = i < n - 1 ? right[i + 1] : 0;\n            int a = Math.abs(left[i]);\n            int b = Math.abs(right[i]);\n            if (l < 0 && r < 0) {\n                ans = Math.max(ans, a + b - Math.min(a, b));\n            } else {\n                ans = Math.max(ans, Math.max(a, b));\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1848", "path": "output2\\java\\Hard\\1848-remove-boxes.java", "hypo_code": "class RemoveBoxes {\n    public int removeBoxes(int[] boxes) {\n        int n = boxes.length;\n        int[][][] dp = new int[n][n][n];\n        return removeBoxesSub(boxes, dp, 0, n - 1, 0);\n        \n        \n    }\n}"}
{"id": "1849", "path": "output2\\java\\Hard\\1849-student-attendance-record-ii.java", "hypo_code": "class StudentAttendanceRecordIi {\n    public int checkRecord(int n) {\n        int mod = 1000000007;\n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n        dp[1] = 2;\n        dp[2] = 4;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = ((dp[i - 1] + dp[i - 2]) % mod + dp[i - 3]) % mod;\n        }\n        long ans = dp[n];\n        for (int i = 0; i < n; i++) {\n            ans = (ans + dp[i] * dp[n - i - 1]) % mod;\n        }\n        return (int) ans;\n        \n\n\n    }\n}"}
{"id": "1850", "path": "output2\\java\\Hard\\1850-find-the-closest-palindrome.java", "hypo_code": "class FindTheClosestPalindrome {\n    public String nearestPalindromic(String n) {\n        int len = n.length();\n        long num = Long.parseLong(n);\n        long minDiff = Long.MAX_VALUE;\n        long minNum = 0;\n        long left = Long.parseLong(n.substring(0, (len + 1) / 2));\n        for (long i = -1; i <= 1; i++) {\n            long cur = left + i;\n            String curStr = Long.toString(cur);\n            String curRev = new StringBuilder(curStr).reverse().toString();\n            String curPal = curStr + curRev.substring(curRev.length() - len % 2);\n            long curPalNum = Long.parseLong(curPal);\n            if (curPalNum == num) {\n                continue;\n            }\n            long diff = Math.abs(curPalNum - num);\n            if (diff < minDiff) {\n                minDiff = diff;\n                minNum = curPalNum;\n            } else if (diff == minDiff) {\n                minNum = Math.min(minNum, curPalNum);\n            }\n        }\n        return Long.toString(minNum);\n        \n    }\n}"}
{"id": "1851", "path": "output2\\java\\Hard\\1851-erect-the-fence.java", "hypo_code": "class Solution {\n    public int[][] outerTrees(int[][] trees) {\n        int n = trees.length;\n        if (n <= 1) {\n            return trees;\n        }\n        Arrays.sort(trees, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0]- b[0]);\n        Stack<int[]> stack = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (stack.size() >= 2 && orientation(stack.get(stack.size() - 2), stack.peek(), trees[i]) > 0) {\n                stack.pop();\n            }\n            stack.push(trees[i]);\n        }\n        stack.pop();\n        for (int i = n - 1; i >= 0; i--) {\n            while (stack.size() >= 2 && orientation(stack.get(stack.size() - 2), stack.peek(), trees[i]) > 0) {\n                stack.pop();\n            }\n            stack.push(trees[i]);\n        }\n        return new ArrayList<>(new HashSet<>(stack)).toArray(new int[0][]);\n\n    }\n}"}
{"id": "1852", "path": "output2\\java\\Hard\\1852-tag-validator.java", "hypo_code": "class Solution {\n    public boolean isValid(String code) {\n        Stack<String> stack = new Stack<>();\n        for (int i = 0; i < code.length();) {\n            if (i > 0 && stack.isEmpty()) {\n                return false;\n            }\n            if (code.startsWith(\"<![CDATA[\", i)) {\n                int j = i + 9;\n                i = code.indexOf(\"]]>\", j);\n                if (i < 0) {\n                    return false;\n                }\n                i += 3;\n            } else if (code.startsWith(\"</\", i)) {\n                int j = i + 2;\n                i = code.indexOf('>', j);\n                if (i < 0 || i == j || i - j > 9) {\n                    return false;\n                }\n                for (int k = j; k < i; k++) {\n                    if (!Character.isUpperCase(code.charAt(k))) {\n                        return false;\n                    }\n                }\n                String s = code.substring(j, i++);\n                if (stack.isEmpty() || !stack.pop().equals(s)) {\n                    return false;\n                }\n            } else if (code.startsWith(\"<\", i)) {\n                int j = i + 1;\n                i = code.indexOf('>', j);\n                if (i < 0 || i == j || i - j > 9) {\n                    return false;\n                }\n                for (int k = j; k < i; k++) {\n                    if (!Character.isUpperCase(code.charAt(k))) {\n                        return false;\n                    }\n                }\n                String s = code.substring(j, i++);\n                stack.push(s);\n            } else {\n                i++;\n            }\n        }\n        return stack.isEmpty();\n    }\n}"}
{"id": "1853", "path": "output2\\java\\Hard\\1853-non-negative-integers-without-consecutive-ones.java", "hypo_code": "class Solution {\n    public int findIntegers(int n) {\n        int res = 0;\n        for (int i = 0; i <= n; i++) {\n            if (check(i)) {\n                res++;\n            }\n        }\n        return res;\n    }\n    \n    private boolean check(int n) {\n        int i = 31;\n        while (i > 0) {\n            if ((n & (1 << i)) != 0 && (n & (1 << (i - 1))) != 0) {\n                return false;\n            }\n            i--;\n        }\n        return true;\n    }\n}"}
{"id": "1855", "path": "output2\\java\\Hard\\1855-k-inverse-pairs-array.java", "hypo_code": "class Solution {\n    public int kInversePairs(int n, int k) {\n        int mod = 1000000007;\n        int[][] dp = new int[n + 1][k + 1];\n        dp[0][0] = 1;\n        for (int i = 1; i < n + 1; i++) {\n            dp[i][0] = 1;\n            for (int j = 1; j < k + 1; j++) {\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;\n                if (j >= i) {\n                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n                }\n            }\n        }\n        return dp[n][k];\n    }\n}"}
{"id": "1856", "path": "output2\\java\\Hard\\1856-course-schedule-iii.java", "hypo_code": "class Solution {\n    public int scheduleCourse(int[][] courses) {\n        Arrays.sort(courses, (a, b) -> a[1] - b[1]);\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        int cur = 0;\n        for (int[] c : courses) {\n            cur += c[0];\n            pq.offer(c[0]);\n            if (cur > c[1]) {\n                cur -= pq.poll();\n            }\n        }\n        return pq.size();\n    }\n}"}
{"id": "1857", "path": "output2\\java\\Hard\\1857-smallest-range-covering-elements-from-k-lists.java", "hypo_code": "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int n = nums.size(), max = Integer.MIN_VALUE, start = 0, end = Integer.MAX_VALUE;\n        int[] next = new int[n], res = new int[2];\n        boolean flag = true;\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((i, j) -> nums.get(i).get(next[i]) - nums.get(j).get(next[j]));\n        for (int i = 0; i < n; i++) {\n            pq.offer(i);\n            max = Math.max(max, nums.get(i).get(0));\n        }\n        for (int i = 0; i < n && flag; i++) {\n            for (int j = 0; j < nums.get(i).size() && flag; j++) {\n                int min_i = pq.poll();\n                if (end - start > max - nums.get(min_i).get(next[min_i])) {\n                    start = nums.get(min_i).get(next[min_i]);\n                    end = max;\n                }\n                next[min_i]++;\n                if (next[min_i] == nums.get(min_i).size()) {\n                    flag = false;\n                    break;\n                }\n                pq.offer(min_i);\n                max = Math.max(max, nums.get(min_i).get(next[min_i]));\n            }\n        }\n        res[0] = start;\n        res[1] = end;\n        return res;\n    }\n}"}
{"id": "1858", "path": "output2\\java\\Hard\\1858-decode-ways-ii.java", "hypo_code": "class Solution {\n    public int numDecodings(String s) {\n        int mod = 1000000007;\n        long[] dp = new long[3];\n        dp[0] = 1;\n        for (char c : s.toCharArray()) {\n            long[] dp2 = new long[3];\n            if (c == '*') {\n                dp2[0] = dp[0] * 9 + dp[1] * 9 + dp[2] * 6;\n                dp2[1] = dp[0];\n                dp2[2] = dp[0];\n            } else {\n                int t = c - '0';\n                if (t == 0) {\n                    dp2[0] = 0;\n                } else {\n                    dp2[0] = dp[0] + dp[1] + dp[2];\n                }\n                if (t >= 1 && t <= 6) {\n                    dp2[1] = dp[0];\n                } else {\n                    dp2[1] = 0;\n                }\n                if (t >= 7 && t <= 9) {\n                    dp2[2] = dp[0];\n                } else {\n                    dp2[2] = 0;\n                }\n            }\n            dp2[0] %= mod;\n            dp2[1] %= mod;\n            dp2[2] %= mod;\n            dp = dp2;\n        }\n        return (int) dp[0];\n    }\n}"}
{"id": "1859", "path": "output2\\java\\Hard\\1859-strange-printer.java", "hypo_code": "class StrangePrinter {\n    public int strangePrinter(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        for (int i = n - 1; i >= 0; i--) {\n            dp[i][i] = 1;\n            for (int j = i + 1; j < n; j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i][j - 1];\n                } else {\n                    int min = Integer.MAX_VALUE;\n                    for (int k = i; k < j; k++) {\n                        min = Math.min(min, dp[i][k] + dp[k + 1][j]);\n                    }\n                    dp[i][j] = min;\n                }\n            }\n        }\n        return dp[0][n - 1];\n        \n    }\n}"}
{"id": "1860", "path": "output2\\java\\Hard\\1860-kth-smallest-number-in-multiplication-table.java", "hypo_code": "class KthSmallestNumberInMultiplicationTable {\n    public int findKthNumber(int m, int n, int k) {\n        int left = 1;\n        int right = m * n;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            int count = 0;\n            for (int i = 1; i <= m; i++) {\n                count += Math.min(mid / i, n);\n            }\n            if (count < k) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n        \n    }\n}"}
{"id": "1861", "path": "output2\\java\\Hard\\1861-cut-off-trees-for-golf-event.java", "hypo_code": "class CutOffTreesForGolfEvent {\n    public int cutOffTree(List<List<Integer>> forest) {\n        int m = forest.size();\n        int n = forest.get(0).size();\n        int[][] trees = new int[m * n][3];\n        int k = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int height = forest.get(i).get(j);\n                if (height > 1) {\n                    trees[k][0] = height;\n                    trees[k][1] = i;\n                    trees[k][2] = j;\n                    k++;\n                }\n            }\n        }\n        Arrays.sort(trees, (a, b) -> a[0] - b[0]);\n        int ans = 0;\n        int x0 = 0;\n        int y0 = 0;\n        for (int i = 0; i < k; i++) {\n            int x1 = trees[i][1];\n            int y1 = trees[i][2];\n            int d = distance(forest, x0, y0, x1, y1);\n            if (d < 0) {\n                return -1;\n            }\n            ans += d;\n            x0 = x1;\n            y0 = y1;\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "1862", "path": "output2\\java\\Hard\\1862-24-game.java", "hypo_code": "class TwoFourGame {\n    public boolean judgePoint24(int[] cards) {\n        List<Double> list = new ArrayList<Double>();\n        for (int card : cards) {\n            list.add((double) card);\n        }\n        return dfs(list);\n        \n    }\n}"}
{"id": "1863", "path": "output2\\java\\Hard\\1863-redundant-connection-ii.java", "hypo_code": "class RedundantConnectionIi {\n    public int[] findRedundantDirectedConnection(int[][] edges) {\n        int n = edges.length;\n        int[] parent = new int[n + 1];\n        int[] candA = null;\n        int[] candB = null;\n        for (int[] edge : edges) {\n            if (parent[edge[1]] == 0) {\n                parent[edge[1]] = edge[0];\n            } else {\n                candA = new int[]{parent[edge[1]], edge[1]};\n                candB = new int[]{edge[0], edge[1]};\n                edge[1] = 0;\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n        }\n        for (int[] edge : edges) {\n            if (edge[1] == 0) {\n                continue;\n            }\n            int rootX = find(parent, edge[0]);\n            int rootY = find(parent, edge[1]);\n            if (rootX == rootY) {\n                if (candA == null) {\n                    return edge;\n                } else {\n                    return candA;\n                }\n            }\n            parent[rootY] = rootX;\n        }\n        return candB;\n        \n    }\n}"}
{"id": "1864", "path": "output2\\java\\Hard\\1864-maximum-sum-of-3-non-overlapping-subarrays.java", "hypo_code": "class MaximumSumOf3NonOverlappingSubarrays {\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\n        int n = nums.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int[] sums = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            sums[i + 1] = sums[i] + nums[i];\n        }\n        for (int i = k, total = sums[k] - sums[0]; i < n; i++) {\n            if (sums[i + 1] - sums[i + 1 - k] > total) {\n                left[i] = i + 1 - k;\n                total = sums[i + 1] - sums[i + 1 - k];\n            } else {\n                left[i] = left[i - 1];\n            }\n        }\n        right[n - k] = n - k;\n        for (int i = n - k - 1, total = sums[n] - sums[n - k]; i >= 0; i--) {\n            if (sums[i + k] - sums[i] >= total) {\n                right[i] = i;\n                total = sums[i + k] - sums[i];\n            } else {\n                right[i] = right[i + 1];\n            }\n        }\n        int[] ans = new int[]{-1, -1, -1};\n        for (int i = k; i <= n - 2 * k; i++) {\n            int l = left[i - 1], r = right[i + k];\n            int total = (sums[i + k] - sums[i]) + (sums[l + k] - sums[l]) + (sums[r + k] - sums[r]);\n            if (ans[0] == -1 || total > (sums[ans[0] + k] - sums[ans[0]]) + (sums[ans[1] + k] - sums[ans[1]]) + (sums[ans[2] + k] - sums[ans[2]])) {\n                ans[0] = l;\n                ans[1] = i;\n                ans[2] = r;\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1865", "path": "output2\\java\\Hard\\1865-stickers-to-spell-word.java", "hypo_code": "class StickersToSpellWord {\n    public int minStickers(String[] stickers, String target) {\n        int n = stickers.length;\n        int[][] map = new int[n][26];\n        for (int i = 0; i < n; i++) {\n            for (char c : stickers[i].toCharArray()) {\n                map[i][c - 'a']++;\n            }\n        }\n        int[] dp = new int[1 << target.length()];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        for (int state = 0; state < (1 << target.length()); state++) {\n            if (dp[state] == Integer.MAX_VALUE) {\n                continue;\n            }\n            for (int i = 0; i < n; i++) {\n                int[] temp = Arrays.copyOf(map[i], 26);\n                int now = state;\n                for (int j = 0; j < target.length(); j++) {\n                    if (((now >> j) & 1) == 1) {\n                        continue;\n                    }\n                    if (temp[target.charAt(j) - 'a'] > 0) {\n                        temp[target.charAt(j) - 'a']--;\n                        now |= 1 << j;\n                    }\n                }\n                dp[now] = Math.min(dp[now], dp[state] + 1);\n            }\n        }\n        return dp[(1 << target.length()) - 1] == Integer.MAX_VALUE ? -1 : dp[(1 << target.length()) - 1];\n        \n    }\n}"}
{"id": "1866", "path": "output2\\java\\Hard\\1866-falling-squares.java", "hypo_code": "class FallingSquares {\n    public List<Integer> fallingSquares(int[][] positions) {\n        List<Integer> ans = new ArrayList<>();\n        int n = positions.length;\n        int[] dp = new int[n];\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            int left = positions[i][0];\n            int right = left + positions[i][1];\n            int height = positions[i][1];\n            dp[i] = height;\n            for (int j = 0; j < i; j++) {\n                int left2 = positions[j][0];\n                int right2 = left2 + positions[j][1];\n                if (left2 < right && left < right2) {\n                    dp[i] = Math.max(dp[i], dp[j] + height);\n                }\n            }\n            max = Math.max(max, dp[i]);\n            ans.add(max);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1869", "path": "output2\\java\\Hard\\1869-find-k-th-smallest-pair-distance.java", "hypo_code": "class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int l = 0, r = nums[nums.length - 1] - nums[0];\n        while (l < r) {\n            int mid = (l + r) >>> 1;\n            int count = 0, start = 0;\n            for (int i = 0; i < nums.length; i++) {\n                while (start < nums.length && nums[i] - nums[start] > mid) {\n                    start++;\n                }\n                count += i - start;\n            }\n            if (count < k) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n}"}
{"id": "1870", "path": "output2\\java\\Hard\\1870-number-of-atoms.java", "hypo_code": "class Solution {\n    public String countOfAtoms(String formula) {\n        int n = formula.length();\n        Deque<Map<String, Integer>> stack = new LinkedList<>();\n        stack.push(new HashMap<>());\n        for (int i = 0; i < n; i++) {\n            char c = formula.charAt(i);\n            if (c == '(') {\n                stack.push(new HashMap<>());\n            } else if (c == ')') {\n                int iStart = ++i;\n                while (i < n && Character.isDigit(formula.charAt(i))) {\n                    i++;\n                }\n                int multiplicity = i > iStart ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                Map<String, Integer> popMap = stack.pop();\n                Map<String, Integer> topMap = stack.peek();\n                for (String key : popMap.keySet()) {\n                    topMap.put(key, topMap.getOrDefault(key, 0) + popMap.get(key) * multiplicity);\n                }\n                i--;\n            } else {\n                int iStart = i++;\n                while (i < n && Character.isLowerCase(formula.charAt(i))) {\n                    i++;\n                }\n                String name = formula.substring(iStart, i);\n                iStart = i;\n                while (i < n && Character.isDigit(formula.charAt(i))) {\n                    i++;\n                }\n                int multiplicity = i > iStart ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                Map<String, Integer> topMap = stack.peek();\n                topMap.put(name, topMap.getOrDefault(name, 0) + multiplicity);\n                i--;\n            }\n        }\n        Map<String, Integer> map = stack.pop();\n        TreeMap<String, Integer> treeMap = new TreeMap<>(map);\n        StringBuilder sb = new StringBuilder();\n        for (String key : treeMap.keySet()) {\n            sb.append(key);\n            int multiplicity = treeMap.get(key);\n            if (multiplicity > 1) {\n                sb.append(multiplicity);\n            }\n        }\n        return sb.toString();\n    }\n}"}
{"id": "1871", "path": "output2\\java\\Hard\\1871-count-different-palindromic-subsequences.java", "hypo_code": "class CountDifferentPalindromicSubsequences {\n    public int countPalindromicSubsequences(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j + i < n; j++) {\n                if (s.charAt(j) == s.charAt(j + i)) {\n                    int left = j + 1;\n                    int right = j + i - 1;\n                    while (left <= right && s.charAt(left) != s.charAt(j)) {\n                        left++;\n                    }\n                    while (left <= right && s.charAt(right) != s.charAt(j)) {\n                        right--;\n                    }\n                    if (left > right) {\n                        dp[j][j + i] = dp[j + 1][j + i - 1] * 2 + 2;\n                    } else if (left == right) {\n                        dp[j][j + i] = dp[j + 1][j + i - 1] * 2 + 1;\n                    } else {\n                        dp[j][j + i] = dp[j + 1][j + i - 1] * 2 - dp[left + 1][right - 1];\n                    }\n                } else {\n                    dp[j][j + i] = dp[j + 1][j + i] + dp[j][j + i - 1] - dp[j + 1][j + i - 1];\n                }\n                dp[j][j + i] = dp[j][j + i] < 0 ? dp[j][j + i] + 1000000007 : dp[j][j + i] % 1000000007;\n            }\n        }\n        return dp[0][n - 1];\n        \n    }\n}"}
{"id": "1873", "path": "output2\\java\\Hard\\1873-parse-lisp-expression.java", "hypo_code": "class ParseLispExpression {\n    public int evaluate(String expression) {\n        return evaluate(expression, new HashMap<>());\n        \n    }\n}"}
{"id": "1874", "path": "output2\\java\\Hard\\1874-cherry-pickup.java", "hypo_code": "class CherryPickup {\n    public int cherryPickup(int[][] grid) {\n        int n = grid.length;\n        int[][][] dp = new int[n][n][n];\n        for (int[][] d : dp) {\n            for (int[] d1 : d) {\n                Arrays.fill(d1, Integer.MIN_VALUE);\n            }\n        }\n        dp[0][0][0] = grid[0][0];\n        for (int t = 1; t <= 2 * n - 2; t++) {\n            for (int i = Math.max(0, t - n + 1); i <= Math.min(n - 1, t); i++) {\n                for (int j = Math.max(0, t - n + 1); j <= Math.min(n - 1, t); j++) {\n                    if (grid[i][t - i] == -1 || grid[j][t - j] == -1) {\n                        dp[i][j][t] = -1;\n                        continue;\n                    }\n                    int val = grid[i][t - i];\n                    if (i != j) {\n                        val += grid[j][t - j];\n                    }\n                    for (int pi = i - 1; pi <= i; pi++) {\n                        for (int pj = j - 1; pj <= j; pj++) {\n                            if (pi >= 0 && pj >= 0) {\n                                dp[i][j][t] = Math.max(dp[i][j][t], dp[pi][pj][t - 1] + val);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return Math.max(0, dp[n - 1][n - 1][2 * n - 2]);\n        \n    }\n}"}
{"id": "1876", "path": "output2\\java\\Hard\\1876-contain-virus.java", "hypo_code": "class ContainVirus {\n    public int containVirus(int[][] isInfected) {\n        int m = isInfected.length, n = isInfected[0].length;\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int res = 0;\n        while (true) {\n            int max = 0, maxI = -1, maxJ = -1;\n            boolean[][] visited = new boolean[m][n];\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (isInfected[i][j] == 1 && !visited[i][j]) {\n                        int[] count = new int[1];\n                        int[] wall = new int[1];\n                        dfs(isInfected, i, j, visited, count, wall);\n                        if (count[0] > max) {\n                            max = count[0];\n                            maxI = i;\n                            maxJ = j;\n                        }\n                    }\n                }\n            }\n            if (max == 0) {\n                break;\n            }\n            visited = new boolean[m][n];\n            dfs(isInfected, maxI, maxJ, visited, new int[1], new int[1]);\n            res += max;\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (isInfected[i][j] == 2) {\n                        isInfected[i][j] = 0;\n                    }\n                }\n            }\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (isInfected[i][j] == 3) {\n                        for (int[] dir : dirs) {\n                            int x = i + dir[0], y = j + dir[1];\n                            if (x >= 0 && x < m && y >= 0 && y < n && isInfected[x][y] == 0) {\n                                isInfected[x][y] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1877", "path": "output2\\java\\Hard\\1877-cracking-the-safe.java", "hypo_code": "class CrackingTheSafe {\n    public String crackSafe(int n, int k) {\n        int total = (int) Math.pow(k, n);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append('0');\n        }\n        Set<String> visited = new HashSet<>();\n        visited.add(sb.toString());\n        dfs(sb, visited, total, n, k);\n        return sb.toString();\n        \n    }\n}"}
{"id": "1878", "path": "output2\\java\\Hard\\1878-set-intersection-size-at-least-two.java", "hypo_code": "class SetIntersectionSizeAtLeastTwo {\n    public int intersectionSizeTwo(int[][] intervals) {\n        int n = intervals.length;\n        Arrays.sort(intervals, (a, b) -> a[1] != b[1] ? a[1] - b[1] : b[0] - a[0]);\n        int[] dp = new int[n + 1];\n        int[] count = new int[n + 1];\n        int[] sum = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            count[nums[i - 1]]++;\n            sum[i] = sum[i - 1] + nums[i - 1];\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[i] = i;\n            for (int j = 1; j <= k; j++) {\n                int l = 0;\n                int r = i;\n                while (l < r) {\n                    int mid = l + r + 1 >> 1;\n                    if (count[nums[mid - 1]] == 1) {\n                        l = mid;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                dp[i] = Math.min(dp[i], dp[l] + i - l - (sum[i] - sum[l]));\n            }\n        }\n        return dp[n];\n        \n    }\n}"}
{"id": "1879", "path": "output2\\java\\Hard\\1879-special-binary-string.java", "hypo_code": "class Solution {\n    public String makeLargestSpecial(String s) {\n        List<String> list = new ArrayList<>();\n        for (int i = 0, cnt = 0, start = 0; i < s.length(); i++) {\n            cnt += s.charAt(i) == '1' ? 1 : -1;\n            if (cnt == 0) {\n                list.add(\"1\" + makeLargestSpecial(s.substring(start + 1, i)) + \"0\");\n                start = i + 1;\n            }\n        }\n        Collections.sort(list, Collections.reverseOrder());\n        return String.join(\"\", list);\n    }\n}"}
{"id": "1880", "path": "output2\\java\\Hard\\1880-couples-holding-hands.java", "hypo_code": "class CouplesHoldingHands {\n    public int minSwapsCouples(int[] row) {\n        int n = row.length;\n        int[] pos = new int[n];\n        for (int i = 0; i < n; i++) {\n            pos[row[i]] = i;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i += 2) {\n            int x = row[i];\n            int y = x % 2 == 0 ? x + 1 : x - 1;\n            if (row[i + 1] == y) {\n                continue;\n            }\n            ans++;\n            int j = pos[y];\n            row[j] = row[i + 1];\n            pos[row[i + 1]] = j;\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1881", "path": "output2\\java\\Hard\\1881-max-chunks-to-make-sorted-ii.java", "hypo_code": "class MaxChunksToMakeSortedIi {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int[] max = new int[n];\n        int[] min = new int[n];\n        max[0] = arr[0];\n        min[n - 1] = arr[n - 1];\n        for (int i = 1; i < n; i++) {\n            max[i] = Math.max(max[i - 1], arr[i]);\n            min[n - i - 1] = Math.min(min[n - i], arr[n - i - 1]);\n        }\n        int ans = 1;\n        for (int i = 0; i < n - 1; i++) {\n            if (max[i] <= min[i + 1]) {\n                ans++;\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1882", "path": "output2\\java\\Hard\\1882-basic-calculator-iv.java", "hypo_code": "class BasicCalculatorIv {\n    public List<String> basicCalculatorIV(String expression, String[] evalvars, int[] evalints) {\n        Map<String, Integer> eval = new HashMap<>();\n        for (int i = 0; i < evalvars.length; i++) {\n            eval.put(evalvars[i], evalints[i]);\n        }\n        return basicCalculatorIV(expression, eval);\n        \n        \n    }\n}"}
{"id": "1883", "path": "output2\\java\\Hard\\1883-sliding-puzzle.java", "hypo_code": "class Solution {\n    public int slidingPuzzle(int[][] board) {\n        String target = \"123450\";\n        String start = \"\";\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 3; j ++) {\n                start += board[i][j];\n            }\n        }\n        int[][] neighbors = new int[][]{{1, 3}, {0, 4, 2}, {1, 5}, {0, 4}, {3, 1, 5}, {4, 2}};\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(start);\n        visited.add(start);\n        int res = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            while (size > 0) {\n                String cur = queue.poll();\n                if (cur.equals(target)) {\n                    return res;\n                }\n                int zero = cur.indexOf('0');\n                for (int neighbor : neighbors[zero]) {\n                    String next = swap(cur, zero, neighbor);\n                    if (visited.add(next)) {\n                        queue.offer(next);\n                    }\n                }\n                size--;\n            }\n            res++;\n        }\n        return -1;\n    }\n}"}
{"id": "1884", "path": "output2\\java\\Hard\\1884-swim-in-rising-water.java", "hypo_code": "class SwimInRisingWater {\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n        int[][] dir = {{0,1},{0,-1},{1,0},{-1,0}};\n        int[][] visited = new int[n][n];\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\n        pq.add(new int[]{grid[0][0],0,0});\n        while(!pq.isEmpty()){\n            int[] curr = pq.poll();\n            int x = curr[1];\n            int y = curr[2];\n            if(x==n-1 && y==n-1) return curr[0];\n            if(visited[x][y]==1) continue;\n            visited[x][y]=1;\n            for(int[] d:dir){\n                int nx = x+d[0];\n                int ny = y+d[1];\n                if(nx>=0 && nx<n && ny>=0 && ny<n && visited[nx][ny]==0){\n                    pq.add(new int[]{Math.max(curr[0],grid[nx][ny]),nx,ny});\n                }\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1885", "path": "output2\\java\\Hard\\1885-reaching-points.java", "hypo_code": "class ReachingPoints {\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        while(tx>=sx && ty>=sy){\n            if(tx==sx && ty==sy) return true;\n            if(tx>ty){\n                if(ty>sy) tx%=ty;\n                else return (tx-sx)%ty==0;\n            }\n            else{\n                if(tx>sx) ty%=tx;\n                else return (ty-sy)%tx==0;\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "1886", "path": "output2\\java\\Hard\\1886-transform-to-chessboard.java", "hypo_code": "class TransformToChessboard {\n    public int movesToChessboard(int[][] board) {\n        int n = board.length;\n        int[] row = new int[n];\n        int[] col = new int[n];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                row[i] = (row[i]<<1) | board[i][j];\n                col[j] = (col[j]<<1) | board[i][j];\n            }\n        }\n        int rowSum = 0;\n        int colSum = 0;\n        int rowSwap = 0;\n        int colSwap = 0;\n        for(int i=0;i<n;i++){\n            rowSum += row[i];\n            colSum += col[i];\n            if(row[i]==i%2) rowSwap++;\n            if(col[i]==i%2) colSwap++;\n        }\n        if(rowSum!=n/2*(n+1) && rowSum!=n/2*(n-1)) return -1;\n        if(colSum!=n/2*(n+1) && colSum!=n/2*(n-1)) return -1;\n        if(n%2==1){\n            if(rowSwap%2==1) rowSwap = n-rowSwap;\n            if(colSwap%2==1) colSwap = n-colSwap;\n        }\n        else{\n            rowSwap = Math.min(n-rowSwap,rowSwap);\n            colSwap = Math.min(n-colSwap,colSwap);\n        }\n        return (rowSwap+colSwap)/2;\n        \n    }\n}"}
{"id": "1887", "path": "output2\\java\\Hard\\1887-preimage-size-of-factorial-zeroes-function.java", "hypo_code": "class PreimageSizeOfFactorialZeroesFunction {\n    public int preimageSizeFZF(int k) {\n        long lo = 0;\n        long hi = 5L * (k + 1);\n        while (lo < hi) {\n            long mi = lo + (hi - lo) / 2;\n            if (trailingZeroes(mi) < k) {\n                lo = mi + 1;\n            } else {\n                hi = mi;\n            }\n        }\n        return trailingZeroes(lo) == k ? 5 : 0;\n        \n    }\n}"}
{"id": "1888", "path": "output2\\java\\Hard\\1888-smallest-rotation-with-highest-score.java", "hypo_code": "class SmallestRotationWithHighestScore {\n    public int bestRotation(int[] nums) {\n        int n = nums.length;\n        int[] change = new int[n];\n        for(int i=0;i<n;i++){\n            change[(i-nums[i]+1+n)%n]--;\n        }\n        for(int i=1;i<n;i++){\n            change[i] += change[i-1]+1;\n        }\n        int best = 0;\n        for(int i=1;i<n;i++){\n            if(change[i]>change[best]) best = i;\n        }\n        return best;\n        \n    }\n}"}
{"id": "1889", "path": "output2\\java\\Hard\\1889-minimum-swaps-to-make-sequences-increasing.java", "hypo_code": "class MinimumSwapsToMakeSequencesIncreasing {\n    public int minSwap(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int[] swap = new int[n];\n        int[] noswap = new int[n];\n        Arrays.fill(swap, Integer.MAX_VALUE);\n        Arrays.fill(noswap, Integer.MAX_VALUE);\n        swap[0] = 1;\n        noswap[0] = 0;\n        for(int i=1;i<n;i++){\n            if(nums1[i]>nums1[i-1] && nums2[i]>nums2[i-1]){\n                noswap[i] = noswap[i-1];\n                swap[i] = swap[i-1]+1;\n            }\n            if(nums1[i]>nums2[i-1] && nums2[i]>nums1[i-1]){\n                noswap[i] = Math.min(noswap[i], swap[i-1]);\n                swap[i] = Math.min(swap[i], noswap[i-1]+1);\n            }\n        }\n        return Math.min(swap[n-1], noswap[n-1]);\n        \n    }\n}"}
{"id": "1890", "path": "output2\\java\\Hard\\1890-bricks-falling-when-hit.java", "hypo_code": "class BricksFallingWhenHit {\n    public int[] hitBricks(int[][] grid, int[][] hits) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[] result = new int[hits.length];\n        for (int i = 0; i < hits.length; i++) {\n            int x = hits[i][0];\n            int y = hits[i][1];\n            if (grid[x][y] == 1) {\n                grid[x][y] = 2;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (grid[0][i] == 1) {\n                dfs(grid, 0, i);\n            }\n        }\n        for (int i = hits.length - 1; i >= 0; i--) {\n            int x = hits[i][0];\n            int y = hits[i][1];\n            if (grid[x][y] == 2) {\n                grid[x][y] = 1;\n                if (x == 0 || grid[x - 1][y] == 3 || grid[x + 1][y] == 3 || grid[x][y - 1] == 3 || grid[x][y + 1] == 3) {\n                    result[i] = dfs(grid, x, y) - 1;\n                }\n            }\n        }\n        return result;\n        \n    }\n}"}
{"id": "1891", "path": "output2\\java\\Hard\\1891-split-array-with-same-average.java", "hypo_code": "class SplitArrayWithSameAverage {\n    public boolean splitArraySameAverage(int[] nums) {\n        int n = nums.length;\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        boolean[][] dp = new boolean[n + 1][sum + 1];\n        dp[0][0] = true;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= sum; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (j >= nums[i - 1]) {\n                    dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]];\n                }\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            if (sum * i % n == 0 && dp[i][sum * i / n]) {\n                return true;\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "1892", "path": "output2\\java\\Hard\\1892-chalkboard-xor-game.java", "hypo_code": "class ChalkboardXorGame {\n    public boolean xorGame(int[] nums) {\n        int xor = 0;\n        for (int num : nums) {\n            xor ^= num;\n        }\n        return xor == 0 || nums.length % 2 == 0;\n        \n    }\n}"}
{"id": "1893", "path": "output2\\java\\Hard\\1893-bus-routes.java", "hypo_code": "class BusRoutes {\n    public int numBusesToDestination(int[][] routes, int source, int target) {\n        if (source == target) {\n            return 0;\n        }\n        int n = routes.length;\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for (int site : routes[i]) {\n                List<Integer> list = map.getOrDefault(site, new ArrayList<>());\n                for (int j : list) {\n                    graph.get(i).add(j);\n                    graph.get(j).add(i);\n                }\n                list.add(i);\n                map.put(site, list);\n            }\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[n];\n        for (int bus : map.get(source)) {\n            queue.offer(bus);\n            visited[bus] = true;\n        }\n        int step = 0;\n        while (!queue.isEmpty()) {\n            step++;\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int bus = queue.poll();\n                for (int nextBus : graph.get(bus)) {\n                    if (visited[nextBus]) {\n                        continue;\n                    }\n                    visited[nextBus] = true;\n                    for (int site : routes[nextBus]) {\n                        if (site == target) {\n                            return step;\n                        }\n                        for (int nextNextBus : map.get(site)) {\n                            if (!visited[nextNextBus]) {\n                                queue.offer(nextNextBus);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1894", "path": "output2\\java\\Hard\\1894-race-car.java", "hypo_code": "class RaceCar {\n    public int racecar(int target) {\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 1});\n        Set<String> visited = new HashSet<>();\n        visited.add(\"0,1\");\n        int step = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] cur = queue.poll();\n                int pos = cur[0];\n                int speed = cur[1];\n                if (pos == target) {\n                    return step;\n                }\n                int[] next = new int[]{pos + speed, speed * 2};\n                String key = next[0] + \",\" + next[1];\n                if (next[0] > 0 && next[0] < 2 * target && !visited.contains(key)) {\n                    queue.offer(next);\n                    visited.add(key);\n                }\n                next = new int[]{pos, speed > 0 ? -1 : 1};\n                key = next[0] + \",\" + next[1];\n                if (!visited.contains(key)) {\n                    queue.offer(next);\n                    visited.add(key);\n                }\n            }\n            step++;\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1895", "path": "output2\\java\\Hard\\1895-making-a-large-island.java", "hypo_code": "class MakingALargeIsland {\n    public int largestIsland(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int[] size = new int[m * n + 2];\n        int index = 2;\n        int max = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    size[index] = dfs(grid, i, j, index, dirs);\n                    max = Math.max(max, size[index]);\n                    index++;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    Set<Integer> set = new HashSet<>();\n                    for (int[] dir : dirs) {\n                        int x = i + dir[0];\n                        int y = j + dir[1];\n                        if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > 1) {\n                            set.add(grid[x][y]);\n                        }\n                    }\n                    int sum = 1;\n                    for (int num : set) {\n                        sum += size[num];\n                    }\n                    max = Math.max(max, sum);\n                }\n            }\n        }\n        return max;\n        \n        \n    }\n}"}
{"id": "1896", "path": "output2\\java\\Hard\\1896-count-unique-characters-of-all-substrings-of-a-given-string.java", "hypo_code": "class CountUniqueCharactersOfAllSubstringsOfAGivenString {\n    public int uniqueLetterString(String s) {\n        int n = s.length();\n        int[] last = new int[26];\n        int[] next = new int[26];\n        Arrays.fill(last, -1);\n        Arrays.fill(next, n);\n        for (int i = 0; i < n; i++) {\n            int c = s.charAt(i) - 'A';\n            last[c] = i;\n        }\n        int res = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            int c = s.charAt(i) - 'A';\n            next[c] = i;\n            int left = i - last[c];\n            int right = next[c] - i;\n            res += left * right;\n            last[c] = i;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1897", "path": "output2\\java\\Hard\\1897-consecutive-numbers-sum.java", "hypo_code": "class ConsecutiveNumbersSum {\n    public int consecutiveNumbersSum(int n) {\n        int res = 0;\n        for (int i = 1; i * (i + 1) / 2 <= n; i++) {\n            if ((n - i * (i + 1) / 2) % i == 0) {\n                res++;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1898", "path": "output2\\java\\Hard\\1898-sum-of-distances-in-tree.java", "hypo_code": "class SumOfDistancesInTree {\n    public int[] sumOfDistancesInTree(int n, int[][] edges) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        int[] count = new int[n];\n        int[] res = new int[n];\n        dfs(graph, count, res, 0, -1);\n        dfs2(graph, count, res, 0, -1, n);\n        return res;\n        \n        \n    }\n}"}
{"id": "1899", "path": "output2\\java\\Hard\\1899-similar-string-groups.java", "hypo_code": "class SimilarStringGroups {\n    public int numSimilarGroups(String[] strs) {\n        int n = strs.length;\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (isSimilar(strs[i], strs[j])) {\n                    union(parent, i, j);\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (parent[i] == i) {\n                res++;\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "1900", "path": "output2\\java\\Hard\\1900-guess-the-word.java", "hypo_code": "class GuessTheWord {\n    public void findSecretWord(String[] words, Master master) {\n        int n = words.length;\n        int[][] count = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int c = 0;\n                for (int k = 0; k < 6; k++) {\n                    if (words[i].charAt(k) == words[j].charAt(k)) {\n                        c++;\n                    }\n                }\n                count[i][j] = c;\n                count[j][i] = c;\n            }\n        }\n        int[] match = new int[n];\n        for (int i = 0; i < n; i++) {\n            match[i] = n;\n        }\n        for (int i = 0; i < n; i++) {\n            int min = Integer.MAX_VALUE;\n            int index = -1;\n            for (int j = 0; j < n; j++) {\n                if (match[j] < min) {\n                    min = match[j];\n                    index = j;\n                }\n            }\n            int c = master.guess(words[index]);\n            if (c == 6) {\n                return;\n            }\n            match[index] = -1;\n            for (int j = 0; j < n; j++) {\n                if (match[j] != -1 && count[index][j] == c) {\n                    match[j]--;\n                }\n            }\n        }\n        \n    }\n}"}
{"id": "1901", "path": "output2\\java\\Hard\\1901-shortest-path-visiting-all-nodes.java", "hypo_code": "class ShortestPathVisitingAllNodes {\n    public int shortestPathLength(int[][] graph) {\n        int n = graph.length;\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[n][1 << n];\n        for (int i = 0; i < n; i++) {\n            queue.offer(new int[]{i, 1 << i, 0});\n            visited[i][1 << i] = true;\n        }\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int u = cur[0], mask = cur[1], dist = cur[2];\n            if (mask == (1 << n) - 1) {\n                return dist;\n            }\n            for (int v : graph[u]) {\n                int maskV = mask | (1 << v);\n                if (!visited[v][maskV]) {\n                    queue.offer(new int[]{v, maskV, dist + 1});\n                    visited[v][maskV] = true;\n                }\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1902", "path": "output2\\java\\Hard\\1902-rectangle-area-ii.java", "hypo_code": "class RectangleAreaIi {\n    public int rectangleArea(int[][] rectangles) {\n        int n = rectangles.length;\n        int[][] events = new int[2 * n][];\n        int t = 0;\n        for (int[] rec : rectangles) {\n            events[t++] = new int[]{rec[1], rec[0], rec[2], 1};\n            events[t++] = new int[]{rec[3], rec[0], rec[2], -1};\n        }\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\n        long res = 0;\n        long prevY = -1;\n        long curY = -1;\n        long curXSum = 0;\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int[] event : events) {\n            curY = event[0];\n            int x1 = event[1], x2 = event[2], sig = event[3];\n            res += (curY - prevY) * curXSum;\n            res %= 1000000007;\n            curXSum = 0;\n            prevY = curY;\n            map.put(x1, map.getOrDefault(x1, 0) + sig);\n            if (sig == 1) {\n                map.put(x2, map.getOrDefault(x2, 0) - 1);\n            }\n            int count = 0;\n            for (int x : map.keySet()) {\n                count += map.get(x);\n                if (count > 0) {\n                    curXSum += x - (map.lowerKey(x) == null ? 0 : map.lowerKey(x));\n                    curXSum %= 1000000007;\n                }\n            }\n        }\n        return (int) res;\n        \n    }\n}"}
{"id": "1903", "path": "output2\\java\\Hard\\1903-k-similar-strings.java", "hypo_code": "class KSimilarStrings {\n    public int kSimilarity(String s1, String s2) {\n        int n = s1.length();\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j] = s1.charAt(i) == s2.charAt(j) ? 0 : 1;\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (i == n - 1 && j == n - 1) {\n                    continue;\n                }\n                if (i == n - 1) {\n                    dp[i][j] += dp[i][j + 1];\n                } else if (j == n - 1) {\n                    dp[i][j] += dp[i + 1][j];\n                } else {\n                    dp[i][j] += Math.min(dp[i + 1][j], dp[i][j + 1]);\n                }\n            }\n        }\n        return dp[0][0];\n        \n    }\n}"}
{"id": "1904", "path": "output2\\java\\Hard\\1904-minimum-cost-to-hire-k-workers.java", "hypo_code": "class MinimumCostToHireKWorkers {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {\n        int n = quality.length;\n        double[][] workers = new double[n][2];\n        for (int i = 0; i < n; i++) {\n            workers[i][0] = (double) wage[i] / quality[i];\n            workers[i][1] = quality[i];\n        }\n        Arrays.sort(workers, (a, b) -> Double.compare(a[0], b[0]));\n        PriorityQueue<Double> pq = new PriorityQueue<>((a, b) -> Double.compare(b, a));\n        double res = Double.MAX_VALUE;\n        double sum = 0;\n        for (double[] worker : workers) {\n            pq.offer(worker[1]);\n            sum += worker[1];\n            if (pq.size() > k) {\n                sum -= pq.poll();\n            }\n            if (pq.size() == k) {\n                res = Math.min(res, sum * worker[0]);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1905", "path": "output2\\java\\Hard\\1905-shortest-subarray-with-sum-at-least-k.java", "hypo_code": "class ShortestSubarrayWithSumAtLeastK {\n    public int shortestSubarray(int[] nums, int k) {\n        int n = nums.length;\n        int[] sum = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            sum[i] = sum[i - 1] + nums[i - 1];\n        }\n        int res = Integer.MAX_VALUE;\n        Deque<Integer> deque = new LinkedList<>();\n        for (int i = 0; i <= n; i++) {\n            while (!deque.isEmpty() && sum[i] <= sum[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            while (!deque.isEmpty() && sum[i] - sum[deque.peekFirst()] >= k) {\n                res = Math.min(res, i - deque.pollFirst());\n            }\n            deque.offerLast(i);\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n        \n    }\n}"}
{"id": "1906", "path": "output2\\java\\Hard\\1906-shortest-path-to-get-all-keys.java", "hypo_code": "class ShortestPathToGetAllKeys {\n    public int shortestPathAllKeys(String[] grid) {\n        int m = grid.length;\n        int n = grid[0].length();\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int[] start = new int[3];\n        int keys = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                char c = grid[i].charAt(j);\n                if (c == '@') {\n                    start[0] = i;\n                    start[1] = j;\n                } else if (c >= 'a' && c <= 'f') {\n                    keys++;\n                }\n            }\n        }\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(start);\n        Set<String> visited = new HashSet<>();\n        visited.add(start[0] + \" \" + start[1] + \" \" + 0);\n        int steps = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] cur = queue.poll();\n                int x = cur[0];\n                int y = cur[1];\n                int key = cur[2];\n                if (key == (1 << keys) - 1) {\n                    return steps;\n                }\n                for (int[] dir : dirs) {\n                    int nx = x + dir[0];\n                    int ny = y + dir[1];\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx].charAt(ny) != '#') {\n                        int nkey = key;\n                        char c = grid[nx].charAt(ny);\n                        if (c >= 'a' && c <= 'f') {\n                            nkey |= 1 << (c - 'a');\n                        }\n                        if (c >= 'A' && c <= 'F' && ((nkey >> (c - 'A')) & 1) == 0) {\n                            continue;\n                        }\n                        if (!visited.contains(nx + \" \" + ny + \" \" + nkey)) {\n                            queue.offer(new int[]{nx, ny, nkey});\n                            visited.add(nx + \" \" + ny + \" \" + nkey);\n                        }\n                    }\n                }\n            }\n            steps ++;\n\n\n            \n        \n    }\n}\n}"}
{"id": "1907", "path": "output2\\java\\Hard\\1907-minimum-number-of-refueling-stops.java", "hypo_code": "class MinimumNumberOfRefuelingStops {\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\n        int n = stations.length;\n        long[] dp = new long[n + 1];\n        dp[0] = startFuel;\n        for (int i = 0; i < n; i++) {\n            for (int t = i; t >= 0 && dp[t] >= stations[i][0]; t--) {\n                dp[t + 1] = Math.max(dp[t + 1], dp[t] + stations[i][1]);\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            if (dp[i] >= target) {\n                return i;\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1908", "path": "output2\\java\\Hard\\1908-nth-magical-number.java", "hypo_code": "class NthMagicalNumber {\n    public int nthMagicalNumber(int n, int a, int b) {\n        int mod = 1000000007;\n        long lcm = (long) a * b / gcd(a, b);\n        long lo = 0, hi = (long) 1e15;\n        while (lo < hi) {\n            long mid = lo + hi >> 1;\n            if (mid / a + mid / b - mid / lcm < n) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return (int) (lo % mod);\n        \n        \n    }\n}"}
{"id": "1909", "path": "output2\\java\\Hard\\1909-profitable-schemes.java", "hypo_code": "class ProfitableSchemes {\n    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {\n        int mod = 1000000007;\n        int[][] dp = new int[n + 1][minProfit + 1];\n        dp[0][0] = 1;\n        for (int k = 0; k < group.length; k++) {\n            int g = group[k], p = profit[k];\n            for (int i = n - g; i >= 0; i--) {\n                for (int j = minProfit; j >= 0; j--) {\n                    dp[i + g][Math.min(j + p, minProfit)] += dp[i][j];\n                    dp[i + g][Math.min(j + p, minProfit)] %= mod;\n                }\n            }\n        }\n        int res = 0;\n        for (int x : dp[n]) {\n            res += x;\n            res %= mod;\n        }\n        return res;\n        \n    }\n}"}
{"id": "1910", "path": "output2\\java\\Hard\\1910-reachable-nodes-in-subdivided-graph.java", "hypo_code": "class ReachableNodesInSubdividedGraph {\n    public int reachableNodes(int[][] edges, int maxMoves, int n) {\n        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\n        for (int[] edge : edges) {\n            graph.computeIfAbsent(edge[0], x -> new HashMap<>()).put(edge[1], edge[2]);\n            graph.computeIfAbsent(edge[1], x -> new HashMap<>()).put(edge[0], edge[2]);\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);\n        pq.offer(new int[]{0, maxMoves});\n        Map<Integer, Integer> dist = new HashMap<>();\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int u = cur[0], d = cur[1];\n            if (dist.containsKey(u)) {\n                continue;\n            }\n            dist.put(u, d);\n            for (int v : graph.getOrDefault(u, new HashMap<>()).keySet()) {\n                int w = graph.get(u).get(v);\n                if (!dist.containsKey(v) && d > w) {\n                    pq.offer(new int[]{v, d - w - 1});\n                }\n            }\n        }\n        int res = dist.size();\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            int du = dist.getOrDefault(u, 0);\n            int dv = dist.getOrDefault(v, 0);\n            res += Math.min(du + dv, w);\n            if (du > w) {\n                res -= du - w;\n            }\n            if (dv > w) {\n                res -= dv - w;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1911", "path": "output2\\java\\Hard\\1911-super-egg-drop.java", "hypo_code": "class SuperEggDrop {\n    public int superEggDrop(int k, int n) {\n        int[][] dp = new int[k + 1][n + 1];\n        int m = 0;\n        while (dp[k][m] < n) {\n            m++;\n            for (int i = 1; i <= k; i++) {\n                dp[i][m] = dp[i][m - 1] + dp[i - 1][m - 1] + 1;\n            }\n        }\n        return m;\n        \n    }\n}"}
{"id": "1912", "path": "output2\\java\\Hard\\1912-sum-of-subsequence-widths.java", "hypo_code": "class SumOfSubsequenceWidths {\n    public int sumSubseqWidths(int[] nums) {\n        int n = nums.length;\n        int mod = 1000000007;\n        Arrays.sort(nums);\n        long[] pow = new long[n];\n        pow[0] = 1;\n        for (int i = 1; i < n; i++) {\n            pow[i] = pow[i - 1] * 2 % mod;\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            res = (res + (pow[i] - pow[n - i - 1]) * nums[i]) % mod;\n        }\n        return (int) res;\n        \n    }\n}"}
{"id": "1914", "path": "output2\\java\\Hard\\1914-orderly-queue.java", "hypo_code": "class OrderlyQueue {\n    public String orderlyQueue(String s, int k) {\n        if (k == 1) {\n            String res = s;\n            for (int i = 0; i < s.length(); i++) {\n                String temp = s.substring(i) + s.substring(0, i);\n                if (temp.compareTo(res) < 0) {\n                    res = temp;\n                }\n            }\n            return res;\n        } else {\n            char[] arr = s.toCharArray();\n            Arrays.sort(arr);\n            return new String(arr);\n        }\n        \n    }\n}"}
{"id": "1915", "path": "output2\\java\\Hard\\1915-numbers-at-most-n-given-digit-set.java", "hypo_code": "class NumbersAtMostNGivenDigitSet {\n    public int atMostNGivenDigitSet(String[] digits, int n) {\n        String s = String.valueOf(n);\n        int k = s.length();\n        int[] dp = new int[k + 1];\n        dp[k] = 1;\n        for (int i = k - 1; i >= 0; i--) {\n            int si = s.charAt(i) - '0';\n            for (String d : digits) {\n                if (Integer.parseInt(d) < si) {\n                    dp[i] += Math.pow(digits.length, k - i - 1);\n                } else if (Integer.parseInt(d) == si) {\n                    dp[i] += dp[i + 1];\n                }\n            }\n        }\n        for (int i = 1; i < k; i++) {\n            dp[0] += Math.pow(digits.length, i);\n        }\n        return dp[0];\n        \n    }\n}"}
{"id": "1916", "path": "output2\\java\\Hard\\1916-valid-permutations-for-di-sequence.java", "hypo_code": "class ValidPermutationsForDiSequence {\n    public int numPermsDISequence(String s) {\n        int n = s.length();\n        int mod = 1000000007;\n        int[][] dp = new int[n + 1][n + 1];\n        Arrays.fill(dp[0], 1);\n        for (int i = 1; i <= n; i++) {\n            if (s.charAt(i - 1) == 'D') {\n                for (int j = i; j >= 0; j--) {\n                    dp[i][j] = j == i ? 0 : (dp[i][j + 1] + dp[i - 1][j]) % mod;\n                }\n            } else {\n                for (int j = 0; j <= i; j++) {\n                    dp[i][j] = j == 0 ? 0 : (dp[i][j - 1] + dp[i - 1][j - 1]) % mod;\n                }\n            }\n        }\n        return dp[n][0];\n        \n    }\n}"}
{"id": "1917", "path": "output2\\java\\Hard\\1917-super-palindromes.java", "hypo_code": "class SuperPalindromes {\n    public int superpalindromesInRange(String left, String right) {\n        long l = Long.parseLong(left);\n        long r = Long.parseLong(right);\n        int ans = 0;\n        for (long i = 1; i <= 100000; i++) {\n            String s = Long.toString(i);\n            String t = new StringBuilder(s).reverse().toString();\n            long v = Long.parseLong(s + t);\n            v *= v;\n            if (v > r) {\n                break;\n            }\n            if (v >= l && isPalindrome(v)) {\n                ans++;\n            }\n        }\n        for (long i = 1; i <= 100000; i++) {\n            String s = Long.toString(i);\n            String t = new StringBuilder(s).deleteCharAt(s.length() - 1).reverse().toString();\n            long v = Long.parseLong(s + t);\n            v *= v;\n            if (v > r) {\n                break;\n            }\n            if (v >= l && isPalindrome(v)) {\n                ans++;\n            }\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "1918", "path": "output2\\java\\Hard\\1918-cat-and-mouse.java", "hypo_code": "class CatAndMouse {\n    public int catMouseGame(int[][] graph) {\n        int n = graph.length;\n        int[][][] color = new int[n][n][2];\n        int[][][] degree = new int[n][n][2];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                degree[i][j][0] = graph[i].length;\n                degree[i][j][1] = graph[j].length;\n                for (int k : graph[j]) {\n                    if (k == 0) {\n                        degree[i][j][1]--;\n                    }\n                }\n            }\n        }\n        Queue<int[]> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            for (int t = 0; t < 2; t++) {\n                color[0][i][t] = 2;\n                queue.offer(new int[]{0, i, t, 2});\n                if (i > 0) {\n                    color[i][i][t] = 1;\n                    queue.offer(new int[]{i, i, t, 1});\n                }\n            }\n        }\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int i = cur[0], j = cur[1], t = cur[2], c = cur[3];\n            for (int k : graph[t == 0 ? i : j]) {\n                if (c == 1) {\n                    if (color[k][j][1 - t] == 0) {\n                        color[k][j][1 - t] = 1;\n                        queue.offer(new int[]{k, j, 1 - t, 1});\n                    }\n                } else {\n                    degree[k][j][1 - t]--;\n                    if (degree[k][j][1 - t] == 0 && color[k][j][1 - t] == 0) {\n                        color[k][j][1 - t] = 2;\n                        queue.offer(new int[]{k, j, 1 - t, 2});\n                    }\n                }\n            }\n        }\n        return color[1][2][0];\n        \n    }\n}"}
{"id": "1919", "path": "output2\\java\\Hard\\1919-number-of-music-playlists.java", "hypo_code": "class NumberOfMusicPlaylists {\n    public int numMusicPlaylists(int n, int goal, int k) {\n        int mod = 1000000007;\n        long[][] dp = new long[goal + 1][n + 1];\n        dp[0][0] = 1;\n        for (int i = 1; i <= goal; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = dp[i - 1][j - 1] * (n - j + 1) + dp[i - 1][j] * Math.max(j - k, 0);\n                dp[i][j] %= mod;\n            }\n        }\n        return (int) dp[goal][n];\n        \n    }\n}"}
{"id": "1920", "path": "output2\\java\\Hard\\1920-minimize-malware-spread.java", "hypo_code": "class MinimizeMalwareSpread {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int n = graph.length;\n        int[] color = new int[n];\n        Arrays.fill(color, -1);\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            if (color[i] == -1) {\n                dfs(graph, color, i, c++);\n            }\n        }\n        int[] size = new int[c];\n        for (int i = 0; i < n; i++) {\n            size[color[i]]++;\n        }\n        int[] infected = new int[c];\n        for (int i : initial) {\n            infected[color[i]]++;\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i : initial) {\n            int nodeColor = color[i];\n            if (infected[nodeColor] == 1) {\n                if (ans == Integer.MAX_VALUE) {\n                    ans = i;\n                } else if (size[nodeColor] > size[color[ans]]) {\n                    ans = i;\n                } else if (size[nodeColor] == size[color[ans]] && i < ans) {\n                    ans = i;\n                }\n            }\n        }\n        if (ans == Integer.MAX_VALUE) {\n            for (int i : initial) {\n                ans = Math.min(ans, i);\n            }\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "1921", "path": "output2\\java\\Hard\\1921-three-equal-parts.java", "hypo_code": "class ThreeEqualParts {\n    public int[] threeEqualParts(int[] arr) {\n        int n = arr.length;\n        int[] res = new int[]{-1, -1};\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (arr[i] == 1) {\n                count++;\n            }\n        }\n        if (count == 0) {\n            return new int[]{0, n - 1};\n        }\n        if (count % 3 != 0) {\n            return res;\n        }\n        int k = count / 3;\n        int i = 0;\n        while (arr[i] == 0) {\n            i++;\n        }\n        int j = i;\n        while (k > 0) {\n            if (arr[j] == 1) {\n                k--;\n            }\n            j++;\n        }\n        int p1 = i;\n        int p2 = j;\n        while (arr[p1] == 0) {\n            p1++;\n        }\n        while (arr[p2] == 0) {\n            p2++;\n        }\n        while (p2 < n) {\n            if (arr[p1] != arr[p2]) {\n                return res;\n            }\n            p1++;\n            p2++;\n        }\n        return new int[]{i + j - 1, j + p2 - 1};\n        \n    }\n}"}
{"id": "1922", "path": "output2\\java\\Hard\\1922-minimize-malware-spread-ii.java", "hypo_code": "class MinimizeMalwareSpreadIi {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int n = graph.length;\n        int[] color = new int[n];\n        Arrays.fill(color, -1);\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            if (color[i] == -1) {\n                dfs(graph, color, i, c++);\n            }\n        }\n        int[] size = new int[c];\n        for (int i = 0; i < n; i++) {\n            size[color[i]]++;\n        }\n        int[] infected = new int[c];\n        for (int i : initial) {\n            infected[color[i]]++;\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i : initial) {\n            int nodeColor = color[i];\n            if (infected[nodeColor] == 1) {\n                if (ans == Integer.MAX_VALUE) {\n                    ans = i;\n                } else if (size[nodeColor] > size[color[ans]]) {\n                    ans = i;\n                } else if (size[nodeColor] == size[color[ans]] && i < ans) {\n                    ans = i;\n                }\n            }\n        }\n        if (ans == Integer.MAX_VALUE) {\n            for (int i : initial) {\n                ans = Math.min(ans, i);\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1923", "path": "output2\\java\\Hard\\1923-stamping-the-sequence.java", "hypo_code": "class StampingTheSequence {\n    public int[] movesToStamp(String stamp, String target) {\n        int n = target.length();\n        int m = stamp.length();\n        char[] t = target.toCharArray();\n        char[] s = stamp.toCharArray();\n        boolean[] done = new boolean[n];\n        List<Integer> res = new ArrayList<>();\n        int count = 0;\n        while (count < n) {\n            boolean found = false;\n            for (int i = 0; i <= n - m; i++) {\n                if (!done[i] && canReplace(t, s, i)) {\n                    found = true;\n                    done[i] = true;\n                    count += replace(t, i, m);\n                    res.add(i);\n                }\n            }\n            if (!found) {\n                return new int[0];\n            }\n        }\n        Collections.reverse(res);\n        int[] ans = new int[res.size()];\n        for (int i = 0; i < res.size(); i++) {\n            ans[i] = res.get(i);\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "1924", "path": "output2\\java\\Hard\\1924-distinct-subsequences-ii.java", "hypo_code": "class DistinctSubsequencesIi {\n    public int distinctSubseqII(String s) {\n        int n = s.length();\n        int mod = 1000000007;\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        int[] last = new int[26];\n        Arrays.fill(last, -1);\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1] * 2 % mod;\n            int c = s.charAt(i - 1) - 'a';\n            if (last[c] >= 0) {\n                dp[i] -= dp[last[c]];\n            }\n            dp[i] %= mod;\n            last[c] = i - 1;\n        }\n        dp[n]--;\n        if (dp[n] < 0) {\n            dp[n] += mod;\n        }\n        return dp[n];\n        \n    }\n}"}
{"id": "1925", "path": "output2\\java\\Hard\\1925-find-the-shortest-superstring.java", "hypo_code": "class FindTheShortestSuperstring {\n    public String shortestSuperstring(String[] words) {\n        int n = words.length;\n        int[][] overlap = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != j) {\n                    overlap[i][j] = getOverlap(words[i], words[j]);\n                }\n            }\n        }\n        int[][] dp = new int[1 << n][n];\n        int[][] parent = new int[1 << n][n];\n        for (int mask = 0; mask < (1 << n); mask++) {\n            Arrays.fill(parent[mask], -1);\n            for (int bit = 0; bit < n; bit++) {\n                if (((mask >> bit) & 1) > 0) {\n                    int pmask = mask ^ (1 << bit);\n                    if (pmask == 0) {\n                        continue;\n                    }\n                    for (int i = 0; i < n; i++) {\n                        if (((pmask >> i) & 1) > 0) {\n                            int val = dp[pmask][i] + overlap[i][bit];\n                            if (val > dp[mask][bit]) {\n                                dp[mask][bit] = val;\n                                parent[mask][bit] = i;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int[] perm = new int[n];\n        int t = (1 << n) - 1;\n        int p = 0;\n        for (int j = 0; j < n; j++) {\n            if (dp[t][j] > dp[t][p]) {\n                p = j;\n            }\n        }\n        int idx = n - 1;\n        while (t > 0) {\n            perm[idx--] = p;\n            int temp = parent[t][p];\n            t = t ^ (1 << p);\n            p = temp;\n        }\n        StringBuilder sb = new StringBuilder(words[perm[0]]);\n        for (int i = 1; i < n; i++) {\n            int overlapLen = overlap[perm[i - 1]][perm[i]];\n            sb.append(words[perm[i]].substring(overlapLen));\n        }\n        return sb.toString();\n        \n        \n    }\n}"}
{"id": "1926", "path": "output2\\java\\Hard\\1926-largest-component-size-by-common-factor.java", "hypo_code": "class LargestComponentSizeByCommonFactor {\n    public int largestComponentSize(int[] nums) {\n        int n = nums.length;\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (gcd(nums[i], nums[j]) > 1) {\n                    union(parent, i, j);\n                }\n            }\n        }\n        int[] count = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int p = find(parent, i);\n            count[p]++;\n            res = Math.max(res, count[p]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1927", "path": "output2\\java\\Hard\\1927-tallest-billboard.java", "hypo_code": "class TallestBillboard {\n    public int tallestBillboard(int[] rods) {\n        int n = rods.length;\n        int sum = 0;\n        for(int i=0;i<n;i++){\n            sum += rods[i];\n        }\n        int[][] dp = new int[n+1][sum+1];\n        for(int i=0;i<=n;i++){\n            for(int j=0;j<=sum;j++){\n                dp[i][j] = -1;\n            }\n        }\n        dp[0][0] = 0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<=sum;j++){\n                if(dp[i][j]>=0){\n                    dp[i+1][j] = Math.max(dp[i+1][j],dp[i][j]);\n                    dp[i+1][j+rods[i]] = Math.max(dp[i+1][j+rods[i]],dp[i][j]);\n                    dp[i+1][Math.abs(j-rods[i])] = Math.max(dp[i+1][Math.abs(j-rods[i])],dp[i][j]+Math.min(j,rods[i]));\n                }\n            }\n        }\n        return dp[n][0];\n        \n    }\n}"}
{"id": "1928", "path": "output2\\java\\Hard\\1928-delete-columns-to-make-sorted-iii.java", "hypo_code": "class DeleteColumnsToMakeSortedIii {\n    public int minDeletionSize(String[] strs) {\n        int n = strs.length;\n        int m = strs[0].length();\n        int[] dp = new int[m];\n        Arrays.fill(dp,1);\n        int res = 0;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<i;j++){\n                if(isSorted(strs,j,i)){\n                    dp[i] = Math.max(dp[i],dp[j]+1);\n                }\n            }\n            res = Math.max(res,dp[i]);\n        }\n        return m-res;\n        \n        \n    }\n}"}
{"id": "1929", "path": "output2\\java\\Hard\\1929-least-operators-to-express-number.java", "hypo_code": "class LeastOperatorsToExpressNumber {\n    public int leastOpsExpressTarget(int x, int target) {\n        int res = 0;\n        int n = 0;\n        while(target>0){\n            n++;\n            res += (target%x)*2;\n            target /= x;\n        }\n        return res/n-1;\n        \n    }\n}"}
{"id": "1930", "path": "output2\\java\\Hard\\1930-binary-tree-cameras.java", "hypo_code": "class BinaryTreeCameras {\n    public int minCameraCover(TreeNode root) {\n        int[] min = new int[1];\n        min[0] = Integer.MAX_VALUE;\n        minCameraCover(root, min);\n        return min[0];\n        \n        \n    }\n}"}
{"id": "1931", "path": "output2\\java\\Hard\\1931-equal-rational-numbers.java", "hypo_code": "class EqualRationalNumbers {\n    public boolean isRationalEqual(String s, String t) {\n        return getDecimal(s).equals(getDecimal(t));\n        \n    }\n}"}
{"id": "1932", "path": "output2\\java\\Hard\\1932-odd-even-jump.java", "hypo_code": "class OddEvenJump {\n    public int oddEvenJumps(int[] arr) {\n        int n = arr.length;\n        boolean[] odd = new boolean[n];\n        boolean[] even = new boolean[n];\n        odd[n-1] = true;\n        even[n-1] = true;\n        TreeMap<Integer,Integer> map = new TreeMap<>();\n        map.put(arr[n-1],n-1);\n        int res = 1;\n        for(int i=n-2;i>=0;i--){\n            Integer next = map.ceilingKey(arr[i]);\n            if(next!=null){\n                odd[i] = even[map.get(next)];\n            }\n            next = map.floorKey(arr[i]);\n            if(next!=null){\n                even[i] = odd[map.get(next)];\n            }\n            if(odd[i]){\n                res++;\n            }\n            map.put(arr[i],i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1933", "path": "output2\\java\\Hard\\1933-unique-paths-iii.java", "hypo_code": "class UniquePathsIii {\n    public int uniquePathsIII(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int start = 0;\n        int end = 0;\n        int empty = 1;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(grid[i][j]==1) start = i*n+j;\n                else if(grid[i][j]==2) end = i*n+j;\n                else if(grid[i][j]==0) empty++;\n            }\n        }\n        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\n        int[] res = new int[1];\n        dfs(grid,start,end,empty,dirs,res);\n        return res[0];\n        \n    }\n}"}
{"id": "1934", "path": "output2\\java\\Hard\\1934-triples-with-bitwise-and-equal-to-zero.java", "hypo_code": "class TriplesWithBitwiseAndEqualToZero {\n    public int countTriplets(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[1 << 16];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[nums[i] & nums[j]]++;\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < (1 << 16); j++) {\n                if ((nums[i] & j) == 0) {\n                    res += dp[j];\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1935", "path": "output2\\java\\Hard\\1935-vertical-order-traversal-of-a-binary-tree.java", "hypo_code": "class VerticalOrderTraversalOfABinaryTree {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n        Map<Integer, List<Integer>> map = new TreeMap<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        Queue<Integer> cols = new LinkedList<>();\n        queue.offer(root);\n        cols.offer(0);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            Map<Integer, List<Integer>> temp = new TreeMap<>();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                int col = cols.poll();\n                if (!temp.containsKey(col)) {\n                    temp.put(col, new ArrayList<>());\n                }\n                temp.get(col).add(node.val);\n                if (node.left != null) {\n                    queue.offer(node.left);\n                    cols.offer(col - 1);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                    cols.offer(col + 1);\n                }\n            }\n            for (int key : temp.keySet()) {\n                List<Integer> list = temp.get(key);\n                Collections.sort(list);\n                if (!map.containsKey(key)) {\n                    map.put(key, new ArrayList<>());\n                }\n                map.get(key).addAll(list);\n            }\n        }\n        for (int key : map.keySet()) {\n            result.add(map.get(key));\n        }\n        return result;\n        \n    }\n}"}
{"id": "1936", "path": "output2\\java\\Hard\\1936-subarrays-with-k-different-integers.java", "hypo_code": "class SubarraysWithKDifferentIntegers {\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        return atMostK(nums,k)-atMostK(nums,k-1);\n        \n    }\n}"}
{"id": "1937", "path": "output2\\java\\Hard\\1937-minimum-number-of-k-consecutive-bit-flips.java", "hypo_code": "class MinimumNumberOfKConsecutiveBitFlips {\n    public int minKBitFlips(int[] nums, int k) {\n        int n = nums.length;\n        int[] diff = new int[n+1];\n        int res = 0;\n        int revCnt = 0;\n        for(int i=0;i<n;i++){\n            revCnt += diff[i];\n            if((nums[i]+revCnt)%2==0){\n                if(i+k>n) return -1;\n                res++;\n                revCnt++;\n                diff[i+k]--;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1938", "path": "output2\\java\\Hard\\1938-number-of-squareful-arrays.java", "hypo_code": "class NumberOfSquarefulArrays {\n    public int numSquarefulPerms(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[1 << n];\n        dp[0] = 1;\n        for (int mask = 1; mask < (1 << n); mask++) {\n            int count = Integer.bitCount(mask);\n            for (int i = 0; i < n; i++) {\n                if (((mask >> i) & 1) == 1) {\n                    for (int j = 0; j < n; j++) {\n                        if (((mask >> j) & 1) == 1 && i != j) {\n                            if (count == 2 || isSquare(nums[i] + nums[j])) {\n                                dp[mask] += dp[mask ^ (1 << i)];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n                \n    }\n}"}
{"id": "1939", "path": "output2\\java\\Hard\\1939-minimum-cost-to-merge-stones.java", "hypo_code": "class MinimumCostToMergeStones {\n    public int mergeStones(int[] stones, int k) {\n        int n = stones.length;\n        if((n-1)%(k-1)!=0) return -1;\n        int[] prefix = new int[n+1];\n        for(int i=0;i<n;i++){\n            prefix[i+1] = prefix[i]+stones[i];\n        }\n        int[][] dp = new int[n][n];\n        for(int m=k;m<=n;m++){\n            for(int i=0;i+m<=n;i++){\n                int j = i+m-1;\n                dp[i][j] = Integer.MAX_VALUE;\n                for(int mid=i;mid<j;mid+=k-1){\n                    dp[i][j] = Math.min(dp[i][j],dp[i][mid]+dp[mid+1][j]);\n                }\n                if((j-i)%(k-1)==0){\n                    dp[i][j] += prefix[j+1]-prefix[i];\n                }\n            }\n        }\n        return dp[0][n-1];\n        \n    }\n}"}
{"id": "1940", "path": "output2\\java\\Hard\\1940-grid-illumination.java", "hypo_code": "class GridIllumination {\n    public int[] gridIllumination(int n, int[][] lamps, int[][] queries) {\n        int[] ans = new int[queries.length];\n        Map<Integer, Integer> row = new HashMap<>();\n        Map<Integer, Integer> col = new HashMap<>();\n        Map<Integer, Integer> diag1 = new HashMap<>();\n        Map<Integer, Integer> diag2 = new HashMap<>();\n        Set<Integer> lampSet = new HashSet<>();\n        for (int[] lamp : lamps) {\n            int x = lamp[0];\n            int y = lamp[1];\n            row.put(x, row.getOrDefault(x, 0) + 1);\n            col.put(y, col.getOrDefault(y, 0) + 1);\n            diag1.put(x - y, diag1.getOrDefault(x - y, 0) + 1);\n            diag2.put(x + y, diag2.getOrDefault(x + y, 0) + 1);\n            lampSet.add(x * n + y);\n        }\n        int[][] dirs = {{0, 0}, {0, 1}, {1, 0}, {1, 1}, {0, -1}, {-1, 0}, {-1, -1}, {1, -1}, {-1, 1}};\n        for (int i = 0; i < queries.length; i++) {\n            int x = queries[i][0];\n            int y = queries[i][1];\n            if (row.getOrDefault(x, 0) > 0 || col.getOrDefault(y, 0) > 0 || diag1.getOrDefault(x - y, 0) > 0 || diag2.getOrDefault(x + y, 0) > 0) {\n                ans[i] = 1;\n            }\n            for (int[] dir : dirs) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n                if (lampSet.contains(newX * n + newY)) {\n                    row.put(newX, row.get(newX) - 1);\n                    col.put(newY, col.get(newY) - 1);\n                    diag1.put(newX - newY, diag1.get(newX - newY) - 1);\n                    diag2.put(newX + newY, diag2.get(newX + newY) - 1);\n                    lampSet.remove(newX * n + newY);\n                }\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "1941", "path": "output2\\java\\Hard\\1941-numbers-with-repeated-digits.java", "hypo_code": "class NumbersWithRepeatedDigits {\n    public int numDupDigitsAtMostN(int n) {\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (hasRepeatedDigits(i)) {\n                count++;\n            }\n        }\n        return count;\n        \n\n    }\n}"}
{"id": "1942", "path": "output2\\java\\Hard\\1942-recover-a-tree-from-preorder-traversal.java", "hypo_code": "class RecoverATreeFromPreorderTraversal {\n    public TreeNode recoverFromPreorder(String traversal) {\n        Stack<TreeNode> stack = new Stack<>();\n        int i = 0;\n        while (i < traversal.length()) {\n            int level = 0;\n            while (traversal.charAt(i) == '-') {\n                level++;\n                i++;\n            }\n            int val = 0;\n            while (i < traversal.length() && traversal.charAt(i) != '-') {\n                val = val * 10 + (traversal.charAt(i) - '0');\n                i++;\n            }\n            TreeNode node = new TreeNode(val);\n            if (level == stack.size()) {\n                if (!stack.isEmpty()) {\n                    stack.peek().left = node;\n                }\n            } else {\n                while (level != stack.size()) {\n                    stack.pop();\n                }\n                stack.peek().right = node;\n            }\n            stack.push(node);\n        }\n        while (stack.size() > 1) {\n            stack.pop();\n        }\n        return stack.pop();\n        \n    }\n}"}
{"id": "1944", "path": "output2\\java\\Hard\\1944-escape-a-large-maze.java", "hypo_code": "class EscapeALargeMaze {\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\n        Set<String> blockedSet = new HashSet<>();\n        for (int[] block : blocked) {\n            blockedSet.add(block[0] + \",\" + block[1]);\n        }\n        return bfs(blockedSet, source, target) && bfs(blockedSet, target, source);\n        \n    }\n}"}
{"id": "1945", "path": "output2\\java\\Hard\\1945-longest-duplicate-substring.java", "hypo_code": "class LongestDuplicateSubstring {\n    public String longestDupSubstring(String s) {\n        int left = 1;\n        int right = s.length() - 1;\n        int mid = 0;\n        while (left <= right) {\n            mid = left + (right - left) / 2;\n            if (search(s, mid) != -1) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        int start = search(s, right);\n        return start != -1 ? s.substring(start, start + right) : \"\";\n        \n        \n    }\n}"}
{"id": "1946", "path": "output2\\java\\Hard\\1946-number-of-submatrices-that-sum-to-target.java", "hypo_code": "class Solution {\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\n        int m = matrix.length, n = matrix[0].length, res = 0;\n        for (int i = 0; i < m; i++) {\n            int[] sum = new int[n];\n            for (int j = i; j < m; j++) {\n                Map<Integer, Integer> map = new HashMap<>();\n                map.put(0, 1);\n                int cur = 0;\n                for (int k = 0; k < n; k++) {\n                    sum[k] += matrix[j][k];\n                    cur += sum[k];\n                    if (map.containsKey(cur - target)) {\n                        res += map.get(cur - target);\n                    }\n                    map.put(cur, map.getOrDefault(cur, 0) + 1);\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1947", "path": "output2\\java\\Hard\\1947-shortest-common-supersequence.java", "hypo_code": "class ShortestCommonSupersequence {\n    public String shortestCommonSupersequence(String str1, String str2) {\n        int m = str1.length();\n        int n = str2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        int i = m;\n        int j = n;\n        StringBuilder sb = new StringBuilder();\n        while (i > 0 && j > 0) {\n            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                sb.append(str1.charAt(i - 1));\n                i--;\n                j--;\n            } else {\n                if (dp[i - 1][j] > dp[i][j - 1]) {\n                    sb.append(str1.charAt(i - 1));\n                    i--;\n                } else {\n                    sb.append(str2.charAt(j - 1));\n                    j--;\n                }\n            }\n        }\n        while (i > 0) {\n            sb.append(str1.charAt(i - 1));\n            i--;\n        }\n        while (j > 0) {\n            sb.append(str2.charAt(j - 1));\n            j--;\n        }\n        return sb.reverse().toString();\n        \n    }\n}"}
{"id": "1948", "path": "output2\\java\\Hard\\1948-find-in-mountain-array.java", "hypo_code": "class FindInMountainArray {\n    public int findInMountainArray(int target, MountainArray mountainArr) {\n        int left = 0;\n        int right = mountainArr.length() - 1;\n        int mid = 0;\n        while (left < right) {\n            mid = left + (right - left) / 2;\n            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        int peak = left;\n        int index = binarySearch(mountainArr, target, 0, peak, true);\n        if (index != -1) {\n            return index;\n        }\n        return binarySearch(mountainArr, target, peak + 1, mountainArr.length() - 1, false);\n        \n        \n    }\n}"}
{"id": "1949", "path": "output2\\java\\Hard\\1949-brace-expansion-ii.java", "hypo_code": "class BraceExpansionIi {\n    public List<String> braceExpansionII(String expression) {\n        List<String> res = new ArrayList<>();\n        if (expression == null || expression.length() == 0) {\n            return res;\n        }\n        Stack<List<String>> stack = new Stack<>();\n        stack.push(new ArrayList<>());\n        int i = 0;\n        while (i < expression.length()) {\n            char c = expression.charAt(i);\n            if (c == '{') {\n                int j = i;\n                int count = 0;\n                while (j < expression.length()) {\n                    if (expression.charAt(j) == '{') {\n                        count++;\n                    } else if (expression.charAt(j) == '}') {\n                        count--;\n                    }\n                    if (count == 0) {\n                        break;\n                    }\n                    j++;\n                }\n                List<String> list = braceExpansionII(expression.substring(i + 1, j));\n                stack.push(list);\n                i = j + 1;\n            } else if (c == ',') {\n                i++;\n            } else if (c == '}') {\n                List<String> list = stack.pop();\n                List<String> prev = stack.peek();\n                prev.addAll(list);\n                i++;\n            } else {\n                int j = i;\n                while (j < expression.length() && Character.isLowerCase(expression.charAt(j))) {\n                    j++;\n                }\n                List<String> prev = stack.peek();\n                prev.add(expression.substring(i, j));\n                i = j;\n            }\n        }\n        List<String> list = stack.pop();\n        Collections.sort(list);\n        return list;\n        \n    }\n}"}
{"id": "1950", "path": "output2\\java\\Hard\\1950-parsing-a-boolean-expression.java", "hypo_code": "class Solution {\n    public boolean parseBoolExpr(String expression) {\n        return helper(expression, 0, expression.length() - 1);\n    }\n    \n    private boolean helper(String s, int l, int r) {\n        if (l == r) {\n            return s.charAt(l) == 't';\n        }\n        char op = s.charAt(l);\n        int start = l + 2;\n        List<Boolean> operands = new ArrayList<>();\n        for (int i = l + 2, cnt = 0; i <= r; i++) {\n            if (cnt == 0 && s.charAt(i) == ',') {\n                operands.add(helper(s, start, i - 1));\n                start = i + 1;\n            } else if (s.charAt(i) == '(') {\n                cnt++;\n            } else if (s.charAt(i) == ')') {\n                cnt--;\n            }\n        }\n        operands.add(helper(s, start, r - 1));\n        if (op == '!') {\n            return !operands.get(0);\n        } else if (op == '&') {\n            for (boolean operand : operands) {\n                if (!operand) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            for (boolean operand : operands) {\n                if (operand) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    }"}
{"id": "1951", "path": "output2\\java\\Hard\\1951-smallest-sufficient-team.java", "hypo_code": "class Solution {\n    public int[] smallestSufficientTeam(String[] req_skills, List<List<String>> people) {\n         int n = req_skills.length;\n        int m = people.size();\n        int[] skillSet = new int[m];\n        Map<String, Integer> skillMap = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            skillMap.put(req_skills[i], i);\n        }\n        for (int i = 0; i < m; i++) {\n            int skillBit = 0;\n            for (String skill : people.get(i)) {\n                skillBit |= 1 << skillMap.get(skill);\n            }\n            skillSet[i] = skillBit;\n        }\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, Integer.MAX_VALUE / 2);\n        dp[0] = 0;\n        int[] prev = new int[1 << n];\n        Arrays.fill(prev, -1);\n        for (int i = 0; i < m; i++) {\n            for (int j = dp.length - 1; j >= 0; j--) {\n                if (dp[j] + 1 < dp[j | skillSet[i]]) {\n                    dp[j | skillSet[i]] = dp[j] + 1;\n                    prev[j | skillSet[i]] = j;\n                }\n            }\n        }\n        int[] res = new int[dp[dp.length - 1]];\n        int index = dp.length - 1;\n        for (int i = res.length - 1; i >= 0; i--) {\n            for (int j = 0; j < m; j++) {\n                if ((index & (1 << j)) != 0 && (index ^ skillSet[j]) == prev[index]) {\n                    res[i] = j;\n                    index = prev[index];\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "1952", "path": "output2\\java\\Hard\\1952-longest-chunked-palindrome-decomposition.java", "hypo_code": "class Solution {\n    public int longestDecomposition(String text) {\n        int len = text.length();\n        if(len <= 1){\n            return len;\n        }\n        int res = 0;\n        int left = 0;\n        int right = len - 1;\n        String leftStr = \"\";\n        String rightStr = \"\";\n        while(left < right){\n            leftStr += text.charAt(left);\n            rightStr = text.charAt(right) + rightStr;\n            if(leftStr.equals(rightStr)){\n                res += 2;\n                leftStr = \"\";\n                rightStr = \"\";\n            }\n            left++;\n            right--;\n        }\n        return res + (leftStr.length() > 0 ? 1 : 0);\n    }\n}"}
{"id": "1954", "path": "output2\\java\\Hard\\1954-last-substring-in-lexicographical-order.java", "hypo_code": "class Solution {\n    public String lastSubstring(String s) {\n        int len = s.length();\n        if(len <= 1){\n            return s;\n        }\n        int res = len - 1;\n        int index = 0;\n        int i = 1;\n        while(i < len){\n            if(s.charAt(i) > s.charAt(index)){\n                index = i;\n                res = len - 1;\n            }else if(s.charAt(i) == s.charAt(index)){\n                int j = i + 1;\n                int k = index + 1;\n                while(j < len && k < i){\n                    if(s.charAt(j) > s.charAt(k)){\n                        index = i;\n                        res = len - 1;\n                        break;\n                    }else if(s.charAt(j) < s.charAt(k)){\n                        break;\n                    }\n                    j++;\n                    k++;\n                }\n                if(j == len || k == i){\n                    res = Math.min(res, index);\n                    index = i;\n                }\n            }\n            i++;\n        }\n        return s.substring(res);\n    }\n}"}
{"id": "1956", "path": "output2\\java\\Hard\\1956-number-of-valid-words-for-each-puzzle.java", "hypo_code": "class Solution {\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\n        Map<Integer, Integer> wordMap = new HashMap<>();\n        for(String word : words){\n            int wordBit = 0;\n            for(int i = 0; i < word.length(); i++){\n                wordBit |= 1 << (word.charAt(i) - 'a');\n            }\n            wordMap.put(wordBit, wordMap.getOrDefault(wordBit, 0) + 1);\n        }\n        List<Integer> res = new ArrayList<>();\n        for(String puzzle : puzzles){\n            int puzzleBit = 0;\n            for(int i = 0; i < puzzle.length(); i++){\n                puzzleBit |= 1 << (puzzle.charAt(i) - 'a');\n            }\n            int firstBit = 1 << (puzzle.charAt(0) - 'a');\n            int cur = puzzleBit;\n            int count = 0;\n            while(cur > 0){\n                if((cur & firstBit) != 0 && wordMap.containsKey(cur)){\n                    count += wordMap.get(cur);\n                }\n                cur = (cur - 1) & puzzleBit;\n            }\n            res.add(count);\n        }\n        return res;\n    }\n}"}
{"id": "1957", "path": "output2\\java\\Hard\\1957-make-array-strictly-increasing.java", "hypo_code": "class Solution {\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        int len1 = arr1.length;\n        int len2 = arr2.length;\n        Arrays.sort(arr2);\n        Map<Integer, Integer> dp = new HashMap<>();\n        dp.put(-1, 0);\n        for(int num : arr1){\n            Map<Integer, Integer> cur = new HashMap<>();\n            for(int key : dp.keySet()){\n                if(num > key){\n                    cur.put(num, Math.min(cur.getOrDefault(num, Integer.MAX_VALUE), dp.get(key)));\n                }\n                int index = binarySearch(arr2, key);\n                if(index < len2){\n                    cur.put(key, Math.min(cur.getOrDefault(key, Integer.MAX_VALUE), dp.get(key) + 1));\n                }\n            }\n            dp = cur;\n        }\n        int res = Integer.MAX_VALUE;\n        for(int key : dp.keySet()){\n            res = Math.min(res, dp.get(key));\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n    }\n    private int binarySearch(int[] arr, int target){\n        int res = Arrays.binarySearch(arr, target);\n        if(res < 0){\n            res = -res - 1;\n        }\n        return res;\n    }\n}"}
{"id": "1958", "path": "output2\\java\\Hard\\1958-critical-connections-in-a-network.java", "hypo_code": "class Solution {\n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        int[] visited = new int[n];\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for(List<Integer> connection : connections){\n            int from = connection.get(0);\n            int to = connection.get(1);\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.putIfAbsent(to, new ArrayList<>());\n            graph.get(from).add(to);\n            graph.get(to).add(from);\n        }\n        List<List<Integer>> res = new ArrayList<>();\n        dfs(graph, visited, -1, 0, 0, res);\n        return res;\n    }\n    private int dfs(Map<Integer, List<Integer>> graph, int[] visited, int from, int cur, int rank, List<List<Integer>> res){\n        visited[cur] = rank + 1;\n        for(int to : graph.get(cur)){\n            if(to == from){\n                continue;\n            }\n            if(visited[to] == 0){\n                visited[cur] = Math.min(visited[cur], dfs(graph, visited, cur, to, rank + 1, res));\n            }else{\n                visited[cur] = Math.min(visited[cur], visited[to]);\n            }\n        }\n        if(visited[cur] == rank + 1 && cur != 0){\n            res.add(Arrays.asList(from, cur));\n        }\n        return visited[cur];\n    }\n}"}
{"id": "1959", "path": "output2\\java\\Hard\\1959-sort-items-by-groups-respecting-dependencies.java", "hypo_code": "class SortItemsByGroupsRespectingDependencies {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        int[] res = new int[n];\n        int[] groupCount = new int[m];\n        int[] itemCount = new int[n];\n        int[] groupInDegree = new int[m];\n        int[] itemInDegree = new int[n];\n        List<Integer>[] groupGraph = new List[m];\n        List<Integer>[] itemGraph = new List[n];\n        for (int i = 0; i < m; i++) {\n            groupGraph[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            itemGraph[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            if (group[i] == -1) {\n                group[i] = m++;\n            }\n            groupCount[group[i]]++;\n            for (int j : beforeItems.get(i)) {\n                if (group[j] == -1) {\n                    group[j] = m++;\n                }\n                if (group[j] != group[i]) {\n                    groupGraph[group[j]].add(group[i]);\n                    groupInDegree[group[i]]++;\n                } else {\n                    itemGraph[j].add(i);\n                    itemInDegree[i]++;\n                }\n            }\n        }\n        List<Integer> groupOrder = topologicalSort(groupGraph, groupInDegree, m);\n        if (groupOrder.size() == 0) {\n            return new int[0];\n        }\n        List<Integer> itemOrder = new ArrayList<>();\n        for (int i : groupOrder) {\n            List<Integer> items = topologicalSort(itemGraph, itemInDegree, n);\n            if (items.size() == 0) {\n                return new int[0];\n            }\n            for (int j : items) {\n                if (group[j] == i) {\n                    itemOrder.add(j);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            res[i] = itemOrder.get(i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1961", "path": "output2\\java\\Hard\\1961-minimum-moves-to-reach-target-with-rotations.java", "hypo_code": "class MinimumMovesToReachTargetWithRotations {\n    public int minimumMoves(int[][] grid) {\n        int n = grid.length;\n        int[][][] visited = new int[n][n][2];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                visited[i][j][0] = Integer.MAX_VALUE;\n                visited[i][j][1] = Integer.MAX_VALUE;\n            }\n        }\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0, 0, 0});\n        visited[0][0][0] = 0;\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int x = cur[0];\n            int y = cur[1];\n            int dir = cur[2];\n            int step = cur[3];\n            if (x == n - 1 && y == n - 2 && dir == 0) {\n                return step;\n            }\n            if (dir == 0) {\n                if (y + 1 < n && grid[x][y + 1] == 0) {\n                    if (step + 1 < visited[x][y + 1][0]) {\n                        visited[x][y + 1][0] = step + 1;\n                        queue.offer(new int[]{x, y + 1, 0, step + 1});\n                    }\n                }\n                if (x + 1 < n && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0) {\n                    if (step + 1 < visited[x + 1][y][1]) {\n                        visited[x + 1][y][1] = step + 1;\n                        queue.offer(new int[]{x + 1, y, 1, step + 1});\n                    }\n                }\n            } else {\n                if (x + 1 < n && grid[x + 1][y] == 0) {\n                    if (step + 1 < visited[x + 1][y][1]) {\n                        visited[x + 1][y][1] = step + 1;\n                        queue.offer(new int[]{x + 1, y, 1, step + 1});\n                    }\n                }\n                if (y + 1 < n && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0) {\n                    if (step + 1 < visited[x][y + 1][0]) {\n                        visited[x][y + 1][0] = step + 1;\n                        queue.offer(new int[]{x, y + 1, 0, step + 1});\n                    }\n                }\n\n                \n        \n    }\n}"}
{"id": "1962", "path": "output2\\java\\Hard\\1962-count-vowels-permutation.java", "hypo_code": "class CountVowelsPermutation {\n    public int countVowelPermutation(int n) {\n        int[][] dp = new int[n + 1][5];\n        for (int i = 0; i < 5; i++) {\n            dp[1][i] = 1;\n        }\n        for (int i = 2; i <= n; i++) {\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % 1000000007;\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 1000000007;\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % 1000000007;\n            dp[i][3] = dp[i - 1][2];\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % 1000000007;\n        }\n        int sum = 0;\n        for (int i = 0; i < 5; i++) {\n            sum = (sum + dp[n][i]) % 1000000007;\n        }\n        return sum;\n        \n    }\n}"}
{"id": "1963", "path": "output2\\java\\Hard\\1963-dice-roll-simulation.java", "hypo_code": "class DiceRollSimulation {\n    public int dieSimulator(int n, int[] rollMax) {\n        int[][] dp = new int[n + 1][6];\n        for (int i = 0; i < 6; i++) {\n            dp[1][i] = 1;\n        }\n        for (int i = 2; i <= n; i++) {\n            for (int j = 0; j < 6; j++) {\n                for (int k = 0; k < 6; k++) {\n                    if (j == k) {\n                        if (rollMax[j] >= i) {\n                            dp[i][j] = (dp[i][j] + dp[i - 1][k]) % 1000000007;\n                        }\n                    } else {\n                        dp[i][j] = (dp[i][j] + dp[i - 1][k]) % 1000000007;\n                    }\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < 6; i++) {\n            sum = (sum + dp[n][i]) % 1000000007;\n        }\n        return sum;\n        \n    }\n}"}
{"id": "1964", "path": "output2\\java\\Hard\\1964-maximum-equal-frequency.java", "hypo_code": "class MaximumEqualFrequency {\n    public int maxEqualFreq(int[] nums) {\n        int[] count = new int[100001];\n        int[] freq = new int[100001];\n        int max = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            int c = count[num];\n            if (c > 0) {\n                freq[c]--;\n            }\n            count[num]++;\n            freq[count[num]]++;\n            if (freq[c] == 0 && c == max) {\n                max--;\n            }\n            if (freq[count[num]] == 1) {\n                max = Math.max(max, count[num]);\n            }\n            if (freq[1] == i + 1 || (freq[max] * max == i && freq[max + 1] == 1) || (freq[1] == 1 && freq[max] * max == i)) {\n                return i + 1;\n            }\n        }\n        return nums.length;\n        \n    }\n}"}
{"id": "1965", "path": "output2\\java\\Hard\\1965-maximum-profit-in-job-scheduling.java", "hypo_code": "class MaximumProfitInJobScheduling {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.length;\n        int[][] jobs = new int[n][3];\n        for (int i = 0; i < n; i++) {\n            jobs[i] = new int[]{startTime[i], endTime[i], profit[i]};\n        }\n        Arrays.sort(jobs, (a, b) -> a[1] - b[1]);\n        TreeMap<Integer, Integer> dp = new TreeMap<>();\n        dp.put(0, 0);\n        for (int[] job : jobs) {\n            int cur = dp.floorEntry(job[0]).getValue() + job[2];\n            if (cur > dp.lastEntry().getValue()) {\n                dp.put(job[1], cur);\n            }\n        }\n        return dp.lastEntry().getValue();\n        \n    }\n}"}
{"id": "1966", "path": "output2\\java\\Hard\\1966-tiling-a-rectangle-with-the-fewest-squares.java", "hypo_code": "class TilingARectangleWithTheFewestSquares {\n    public int tilingRectangle(int n, int m) {\n        int[][] dp = new int[n + 1][m + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (i == j) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = Integer.MAX_VALUE;\n                    for (int k = 1; k <= i / 2; k++) {\n                        dp[i][j] = Math.min(dp[i][j], dp[k][j] + dp[i - k][j]);\n                    }\n                    for (int k = 1; k <= j / 2; k++) {\n                        dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[i][j - k]);\n                    }\n                }\n            }\n        }\n        return dp[n][m];\n        \n    }\n}"}
{"id": "1967", "path": "output2\\java\\Hard\\1967-check-if-it-is-a-good-array.java", "hypo_code": "class CheckIfItIsAGoodArray {\n    public boolean isGoodArray(int[] nums) {\n        int gcd = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            gcd = gcd(gcd, nums[i]);\n        }\n        return gcd == 1;\n        \n        \n    }\n}"}
{"id": "1968", "path": "output2\\java\\Hard\\1968-maximum-score-words-formed-by-letters.java", "hypo_code": "class MaximumScoreWordsFormedByLetters {\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\n        int[] count = new int[26];\n        for (char c : letters) {\n            count[c - 'a']++;\n        }\n        return dfs(words, count, score, 0);\n        \n    }\n}"}
{"id": "1969", "path": "output2\\java\\Hard\\1969-minimum-moves-to-move-a-box-to-their-target-location.java", "hypo_code": "class MinimumMovesToMoveABoxToTheirTargetLocation {\n    public int minPushBox(char[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] visited = new int[m][n][4];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                Arrays.fill(visited[i][j], Integer.MAX_VALUE);\n            }\n        }\n        int[] box = new int[2];\n        int[] target = new int[2];\n        int[] player = new int[2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 'B') {\n                    box[0] = i;\n                    box[1] = j;\n                } else if (grid[i][j] == 'T') {\n                    target[0] = i;\n                    target[1] = j;\n                } else if (grid[i][j] == 'S') {\n                    player[0] = i;\n                    player[1] = j;\n                }\n            }\n        }\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{box[0], box[1], player[0], player[1], 0});\n        visited[box[0]][box[1]][getDir(player, box)] = 0;\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int bx = cur[0];\n            int by = cur[1];\n            int px = cur[2];\n            int py = cur[3];\n            int step = cur[4];\n            if (bx == target[0] && by == target[1]) {\n                return step;\n            }\n            for (int[] dir : new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) {\n                int nx = bx + dir[0];\n                int ny = by + dir[1];\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == '#') {\n                    continue;\n                }\n                int npx = bx - dir[0];\n                int npy = by - dir[1];\n                if (npx == px && npy == py)\n                    if (visited[nx][ny][getDir(new int[]{npx, npy}, new int[]{nx, ny})] > step) {\n                        visited[nx][ny][getDir(new int[]{npx, npy}, new int[]{nx, ny})] = step;\n                        queue.offer(new int[]{nx, ny, npx, npy, step});\n                    }\n\n                    \n        \n    }\n}"}
{"id": "1970", "path": "output2\\java\\Hard\\1970-number-of-ways-to-stay-in-the-same-place-after-some-steps.java", "hypo_code": "class NumberOfWaysToStayInTheSamePlaceAfterSomeSteps {\n    public int numWays(int steps, int arrLen) {\n        int[][] dp = new int[steps + 1][arrLen];\n        for (int i = 0; i < arrLen; i++) {\n            dp[1][i] = 1;\n        }\n        for (int i = 2; i <= steps; i++) {\n            for (int j = 0; j < arrLen; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (j > 0) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % 1000000007;\n                }\n                if (j < arrLen - 1) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % 1000000007;\n                }\n            }\n        }\n        return dp[steps][0];\n\n        \n    }\n}"}
{"id": "1971", "path": "output2\\java\\Hard\\1971-palindrome-partitioning-iii.java", "hypo_code": "class PalindromePartitioningIii {\n    public int palindromePartition(String s, int k) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 0;\n        }\n        for (int i = 0; i < n - 1; i++) {\n            dp[i][i + 1] = s.charAt(i) == s.charAt(i + 1) ? 0 : 1;\n        }\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                dp[i][j] = dp[i + 1][j - 1] + (s.charAt(i) == s.charAt(j) ? 0 : 1);\n            }\n        }\n        int[][] dp2 = new int[n][k];\n        for (int i = 0; i < n; i++) {\n            dp2[i][0] = dp[0][i];\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 1; j < k; j++) {\n                dp2[i][j] = Integer.MAX_VALUE;\n                for (int l = 0; l < i; l++) {\n                    dp2[i][j] = Math.min(dp2[i][j], dp2[l][j - 1] + dp[l + 1][i]);\n                }\n            }\n        }\n        return dp2[n - 1][k - 1];\n        \n    }\n}"}
{"id": "1972", "path": "output2\\java\\Hard\\1972-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.java", "hypo_code": "class MinimumNumberOfFlipsToConvertBinaryMatrixToZeroMatrix {\n    public int minFlips(int[][] mat) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (mat[i - 1][j - 1] == 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + 1 - dp[i - 1][j - 1];\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                int count = dp[i][j] + dp[m][n] - dp[i][n] - dp[m][j];\n                if (count % 2 == 0) {\n                    res = Math.min(res, count / 2);\n                }\n            }\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n        \n    }\n}"}
{"id": "1973", "path": "output2\\java\\Hard\\1973-minimum-falling-path-sum-ii.java", "hypo_code": "class MinimumFallingPathSumIi {\n    public int minFallingPathSum(int[][] grid) {\n        int n = grid.length;\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[0][i] = grid[0][i];\n        }\n        for (int i = 1; i < n; i++) {\n            int min = Integer.MAX_VALUE;\n            int min2 = Integer.MAX_VALUE;\n            for (int j = 0; j < n; j++) {\n                if (dp[i - 1][j] < min) {\n                    min2 = min;\n                    min = dp[i - 1][j];\n                } else if (dp[i - 1][j] < min2) {\n                    min2 = dp[i - 1][j];\n                }\n            }\n            for (int j = 0; j < n; j++) {\n                if (dp[i - 1][j] == min) {\n                    dp[i][j] = min2 + grid[i][j];\n                } else {\n                    dp[i][j] = min + grid[i][j];\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            res = Math.min(res, dp[n - 1][i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1974", "path": "output2\\java\\Hard\\1974-shortest-path-in-a-grid-with-obstacles-elimination.java", "hypo_code": "class ShortestPathInAGridWithObstaclesElimination {\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] visited = new int[m][n][k + 1];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                Arrays.fill(visited[i][j], Integer.MAX_VALUE);\n            }\n        }\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0, 0});\n        visited[0][0][0] = 0;\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int x = cur[0];\n            int y = cur[1];\n            int step = cur[2];\n            if (x == m - 1 && y == n - 1) {\n                return step;\n            }\n            for (int[] dir : new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    int nstep = step + 1;\n                    int nk = grid[nx][ny] == 1 ? k - 1 : k;\n                    if (nk >= 0 && nstep < visited[nx][ny][nk]) {\n                        visited[nx][ny][nk] = nstep;\n                        queue.offer(new int[]{nx, ny, nstep});\n                    }\n                }\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1975", "path": "output2\\java\\Hard\\1975-maximum-candies-you-can-get-from-boxes.java", "hypo_code": "class MaximumCandiesYouCanGetFromBoxes {\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n        int n = status.length;\n        boolean[] opened = new boolean[n];\n        boolean[] hasKey = new boolean[n];\n        boolean[] hasBox = new boolean[n];\n        for (int i : initialBoxes) {\n            hasBox[i] = true;\n        }\n        int res = 0;\n        while (true) {\n            boolean found = false;\n            for (int i = 0; i < n; i++) {\n                if (hasBox[i] && (status[i] == 1 || hasKey[i])) {\n                    res += candies[i];\n                    opened[i] = true;\n                    hasBox[i] = false;\n                    for (int j : keys[i]) {\n                        hasKey[j] = true;\n                    }\n                    for (int j : containedBoxes[i]) {\n                        hasBox[j] = true;\n                    }\n                    found = true;\n                }\n            }\n            if (!found) {\n                break;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "1976", "path": "output2\\java\\Hard\\1976-number-of-paths-with-max-score.java", "hypo_code": "class NumberOfPathsWithMaxScore {\n    public int[] pathsWithMaxScore(List<String> board) {\n        int n = board.size();\n        int[][][] dp = new int[n][n][2];\n        dp[n - 1][n - 1][0] = 0;\n        dp[n - 1][n - 1][1] = 1;\n        for (int i = n - 2; i >= 0; i--) {\n            if (board.get(i).charAt(n - 1) == 'X') {\n                break;\n            }\n            dp[i][n - 1][0] = dp[i + 1][n - 1][0] + board.get(i).charAt(n - 1) - '0';\n            dp[i][n - 1][1] = 1;\n        }\n        for (int j = n - 2; j >= 0; j--) {\n            if (board.get(n - 1).charAt(j) == 'X') {\n                break;\n            }\n            dp[n - 1][j][0] = dp[n - 1][j + 1][0] + board.get(n - 1).charAt(j) - '0';\n            dp[n - 1][j][1] = 1;\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            for (int j = n - 2; j >= 0; j--) {\n                if (board.get(i).charAt(j) == 'X') {\n                    continue;\n                }\n                int max = Math.max(dp[i + 1][j][0], Math.max(dp[i][j + 1][0], dp[i + 1][j + 1][0]));\n                if (max == dp[i + 1][j][0]) {\n                    dp[i][j][1] = (dp[i][j][1] + dp[i + 1][j][1]) % 1000000007;\n                }\n                if (max == dp[i][j + 1][0]) {\n                    dp[i][j][1] = (dp[i][j][1] + dp[i][j + 1][1]) % 1000000007;\n                }\n                if (max == dp[i + 1][j + 1][0]) {\n                    dp[i][j][1] = (dp[i][j][1] + dp[i + 1][j + 1][1]) % 1000000007;\n                    \n        \n    }\n}"}
{"id": "1977", "path": "output2\\java\\Hard\\1977-verbal-arithmetic-puzzle.java", "hypo_code": "class VerbalArithmeticPuzzle {\n    public boolean isSolvable(String[] words, String result) {\n        int[] count = new int[26];\n        for (String word : words) {\n            for (char c : word.toCharArray()) {\n                count[c - 'A']++;\n            }\n        }\n        for (char c : result.toCharArray()) {\n            count[c - 'A']++;\n        }\n        int maxLen = 0;\n        for (int i = 0; i < 26; i++) {\n            if (count[i] > 0) {\n                maxLen++;\n            }\n        }\n        if (maxLen > 10) {\n            return false;\n        }\n        int[] map = new int[26];\n        Arrays.fill(map, -1);\n        return dfs(words, result, 0, 0, 0, map);\n        \n    }\n}"}
{"id": "1978", "path": "output2\\java\\Hard\\1978-minimum-insertion-steps-to-make-a-string-palindrome.java", "hypo_code": "class MinimumInsertionStepsToMakeAStringPalindrome {\n    public int minInsertions(String s) {\n        int n = s.length();\n        int[][] dp = new int[n + 1][n + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s.charAt(i - 1) == s.charAt(n - j)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return n - dp[n][n];\n        \n    }\n}"}
{"id": "1979", "path": "output2\\java\\Hard\\1979-distinct-echo-substrings.java", "hypo_code": "class DistinctEchoSubstrings {\n    public int distinctEchoSubstrings(String text) {\n        int n = text.length();\n        int[][] dp = new int[n + 1][n + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text.charAt(i - 1) == text.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }\n            }\n        }\n        Set<String> set = new HashSet<>();\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                if (dp[i][j] > 0 && dp[i][j] == j - i) {\n                    set.add(text.substring(i - 1, j - 1));\n                }\n            }\n        }\n        return set.size();\n        \n    }\n}"}
{"id": "1980", "path": "output2\\java\\Hard\\1980-minimum-distance-to-type-a-word-using-two-fingers.java", "hypo_code": "class MinimumDistanceToTypeAWordUsingTwoFingers {\n    public int minimumDistance(String word) {\n        int n = word.length();\n        int[][][] dp = new int[n][27][27];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 27; j++) {\n                Arrays.fill(dp[i][j], Integer.MAX_VALUE);\n            }\n        }\n        return dfs(word, 0, 26, 26, dp);\n        \n        \n    }\n}"}
{"id": "1981", "path": "output2\\java\\Hard\\1981-minimum-number-of-taps-to-open-to-water-a-garden.java", "hypo_code": "class MinimumNumberOfTapsToOpenToWaterAGarden {\n    public int minTaps(int n, int[] ranges) {\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        for (int i = 0; i <= n; i++) {\n            int left = Math.max(0, i - ranges[i]);\n            int right = Math.min(n, i + ranges[i]);\n            for (int j = left; j <= right; j++) {\n                dp[j] = Math.min(dp[j], dp[left] + 1);\n            }\n        }\n        return dp[n] == Integer.MAX_VALUE ? -1 : dp[n];\n        \n    }\n}"}
{"id": "1982", "path": "output2\\java\\Hard\\1982-reverse-subarray-to-maximize-array-value.java", "hypo_code": "class ReverseSubarrayToMaximizeArrayValue {\n    public int maxValueAfterReverse(int[] nums) {\n        int n = nums.length;\n        int sum = 0;\n        int maxDiff = 0;\n        for (int i = 0; i < n - 1; i++) {\n            int diff = Math.abs(nums[i] - nums[i + 1]);\n            sum += diff;\n            maxDiff = Math.max(maxDiff, Math.max(Math.abs(nums[0] - nums[i + 1]) - diff, Math.abs(nums[n - 1] - nums[i]) - diff));\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 2; j < n; j++) {\n                maxDiff = Math.max(maxDiff, Math.abs(nums[i] - nums[j]) - Math.abs(nums[i + 1] - nums[j - 1]));\n            }\n        }\n        return sum + maxDiff;\n        \n    }\n}"}
{"id": "1983", "path": "output2\\java\\Hard\\1983-minimum-difficulty-of-a-job-schedule.java", "hypo_code": "class MinimumDifficultyOfAJobSchedule {\n    public int minDifficulty(int[] jobDifficulty, int d) {\n        int n = jobDifficulty.length;\n        if (n < d) {\n            return -1;\n        }\n        int[][] dp = new int[d][n];\n        dp[0][0] = jobDifficulty[0];\n        for (int i = 1; i < n; i++) {\n            dp[0][i] = Math.max(dp[0][i - 1], jobDifficulty[i]);\n        }\n        for (int i = 1; i < d; i++) {\n            for (int j = i; j < n; j++) {\n                int max = jobDifficulty[j];\n                dp[i][j] = Integer.MAX_VALUE;\n                for (int k = j; k >= i; k--) {\n                    max = Math.max(max, jobDifficulty[k]);\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][k - 1] + max);\n                }\n            }\n        }\n        return dp[d - 1][n - 1];\n        \n    }\n}"}
{"id": "1984", "path": "output2\\java\\Hard\\1984-jump-game-v.java", "hypo_code": "class JumpGameV {\n    public int maxJumps(int[] arr, int d) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res = Math.max(res, dfs(arr, d, i, dp));\n        }\n        return res;\n        \n    }\n}"}
{"id": "1985", "path": "output2\\java\\Hard\\1985-jump-game-iv.java", "hypo_code": "class JumpGameIv {\n    public int minJumps(int[] arr) {\n        int n = arr.length;\n        if(n == 1) return 0;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            map.putIfAbsent(arr[i], new ArrayList<>());\n            map.get(arr[i]).add(i);\n        }\n        Queue<Integer> q = new LinkedList<>();\n        q.add(0);\n        boolean[] visited = new boolean[n];\n        visited[0] = true;\n        int steps = 0;\n        while(!q.isEmpty()){\n            int size = q.size();\n            for(int i = 0; i < size; i++){\n                int curr = q.poll();\n                if(curr == n - 1) return steps;\n                if(curr + 1 < n && !visited[curr + 1]){\n                    q.add(curr + 1);\n                    visited[curr + 1] = true;\n                }\n                if(curr - 1 >= 0 && !visited[curr - 1]){\n                    q.add(curr - 1);\n                    visited[curr - 1] = true;\n                }\n                for(int next : map.get(arr[curr])){\n                    if(!visited[next]){\n                        q.add(next);\n                        visited[next] = true;\n                    }\n                }\n                map.get(arr[curr]).clear();\n            }\n            steps++;\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1986", "path": "output2\\java\\Hard\\1986-maximum-students-taking-exam.java", "hypo_code": "class MaximumStudentsTakingExam {\n    public int maxStudents(char[][] seats) {\n        int m = seats.length;\n        int n = seats[0].length;\n        int[] dp = new int[1 << n];\n        for(int i = 0; i < m; i++){\n            int[] next = new int[1 << n];\n            for(int j = 0; j < (1 << n); j++){\n                if(isValid(j, seats[i])){\n                    for(int k = 0; k < (1 << n); k++){\n                        if((j & k) == 0){\n                            next[j] = Math.max(next[j], dp[k] + Integer.bitCount(j));\n                        }\n                    }\n                }\n            }\n            dp = next;\n        }\n        int res = 0;\n        for(int i = 0; i < (1 << n); i++){\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1987", "path": "output2\\java\\Hard\\1987-construct-target-array-with-multiple-sums.java", "hypo_code": "class ConstructTargetArrayWithMultipleSums {\n    public boolean isPossible(int[] target) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        long sum = 0;\n        for(int num : target){\n            sum += num;\n            pq.add(num);\n        }\n        while(!pq.isEmpty()){\n            int curr = pq.poll();\n            sum -= curr;\n            if(curr == 1 || sum == 1) return true;\n            if(curr < sum || sum == 0 || curr % sum == 0) return false;\n            curr %= sum;\n            sum += curr;\n            pq.add(curr);\n        }\n        return true;\n        \n    }\n}"}
{"id": "1988", "path": "output2\\java\\Hard\\1988-count-all-valid-pickup-and-delivery-options.java", "hypo_code": "class CountAllValidPickupAndDeliveryOptions {\n    public int countOrders(int n) {\n        long res = 1;\n        int mod = 1000000007;\n        for(int i = 1; i <= n; i++){\n            res = res * (i * 2 - 1) * (i * 2) % mod;\n        }\n        return (int)res;\n        \n    }\n}"}
{"id": "1989", "path": "output2\\java\\Hard\\1989-largest-multiple-of-three.java", "hypo_code": "class LargestMultipleOfThree {\n    public String largestMultipleOfThree(int[] digits) {\n        int[] count = new int[10];\n        int sum = 0;\n        for(int num : digits){\n            count[num]++;\n            sum += num;\n        }\n        if(sum % 3 == 1){\n            if(count[1] > 0){\n                count[1]--;\n            }else if(count[4] > 0){\n                count[4]--;\n            }else if(count[7] > 0){\n                count[7]--;\n            }else if(count[2] > 1){\n                count[2] -= 2;\n            }else if(count[5] > 1){\n                count[5] -= 2;\n            }else if(count[8] > 1){\n                count[8] -= 2;\n            }else if(count[2] > 0 && count[5] > 0){\n                count[2]--;\n                count[5]--;\n            }else if(count[2] > 0 && count[8] > 0){\n                count[2]--;\n                count[8]--;\n            }else if(count[5] > 0 && count[8] > 0){\n                count[5]--;\n                count[8]--;\n            }else{\n                return \"\";\n            }\n        }else if(sum % 3 == 2){\n            if(count[2] > 0){\n                count[2]--;\n            }else if(count[5] > 0){\n                count[5]--;\n            }else if(count[8] > 0){\n                count[8]--;\n            }else if(count[1] > 1){\n                count[1] -= 2;\n            }else if(count[4] > 1){\n                count[4] -= 2;\n            }else if(count[7] > 1){\n                count[7] -= 2;\n            }else if(count[1] > 0 && count[4] > 0){\n                count[1]--;\n                count[4]--;\n            }else if(count[1] > 0 && count[7] > 0){\n                count[1]--;\n                count[7]--;\n            }else if(count[4] > 0 && count[7] > 0){\n                count[4]--;\n                count[7]--;\n            }else{\n                return \"\";\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i = 9; i >= 0; i--){\n            while(count[i]-- > 0){\n                sb.append(i);\n            }\n        }\n        String res = sb.toString();\n        return res.length() > 0 && res.charAt(0) == '0' ? \"0\" : res;\n        \n        \n    }\n}"}
{"id": "1990", "path": "output2\\java\\Hard\\1990-minimum-cost-to-make-at-least-one-valid-path-in-a-grid.java", "hypo_code": "class MinimumCostToMakeAtLeastOneValidPathInAGrid {\n    public int minCost(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int[][] cost = new int[m][n];\n        for(int i = 0; i < m; i++){\n            Arrays.fill(cost[i], Integer.MAX_VALUE);\n        }\n        cost[0][0] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        pq.add(new int[]{0, 0, 0});\n        while(!pq.isEmpty()){\n            int[] curr = pq.poll();\n            int x = curr[0];\n            int y = curr[1];\n            int c = curr[2];\n            if(x == m - 1 && y == n - 1) return c;\n            for(int i = 0; i < 4; i++){\n                int nx = x + dirs[i][0];\n                int ny = y + dirs[i][1];\n                if(nx < 0 || nx >= m || ny < 0 || ny >= n) continue;\n                int nc = c + (grid[x][y] == i + 1 ? 0 : 1);\n                if(nc < cost[nx][ny]){\n                    cost[nx][ny] = nc;\n                    pq.add(new int[]{nx, ny, nc});\n                }\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "1991", "path": "output2\\java\\Hard\\1991-maximum-sum-bst-in-binary-tree.java", "hypo_code": "class MaximumSumBstInBinaryTree {\n    public int maxSumBST(TreeNode root) {\n        int[] res = new int[1];\n        dfs(root, res);\n        return res[0];\n        \n        \n    }\n}"}
{"id": "1992", "path": "output2\\java\\Hard\\1992-frog-position-after-t-seconds.java", "hypo_code": "class FrogPositionAfterTSeconds {\n    public double frogPosition(int n, int[][] edges, int t, int target) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int[] edge : edges){\n            map.putIfAbsent(edge[0], new ArrayList<>());\n            map.putIfAbsent(edge[1], new ArrayList<>());\n            map.get(edge[0]).add(edge[1]);\n            map.get(edge[1]).add(edge[0]);\n        }\n        Queue<Integer> q = new LinkedList<>();\n        q.add(1);\n        double[] prob = new double[n + 1];\n        prob[1] = 1.0;\n        boolean[] visited = new boolean[n + 1];\n        visited[1] = true;\n        while(!q.isEmpty()){\n            int size = q.size();\n            if(t-- == 0) break;\n            for(int i = 0; i < size; i++){\n                int curr = q.poll();\n                int count = 0;\n                for(int next : map.get(curr)){\n                    if(!visited[next]){\n                        count++;\n                    }\n                }\n                for(int next : map.get(curr)){\n                    if(!visited[next]){\n                        prob[next] = prob[curr] / count;\n                        visited[next] = true;\n                        q.add(next);\n                    }\n                }\n            }\n        }\n        return prob[target];\n        \n    }\n}"}
{"id": "1993", "path": "output2\\java\\Hard\\1993-maximum-performance-of-a-team.java", "hypo_code": "class MaximumPerformanceOfATeam {\n    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\n        int[][] engineers = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            engineers[i] = new int[]{efficiency[i], speed[i]};\n        }\n        Arrays.sort(engineers, (a, b) -> b[0] - a[0]);\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        long res = 0;\n        long sum = 0;\n        int mod = 1000000007;\n        for (int[] engineer : engineers) {\n            pq.offer(engineer[1]);\n            sum += engineer[1];\n            if (pq.size() > k) {\n                sum -= pq.poll();\n            }\n            res = Math.max(res, sum * engineer[0]);\n        }\n        return (int)(res % mod);\n        \n    }\n}"}
{"id": "1994", "path": "output2\\java\\Hard\\1994-pizza-with-3n-slices.java", "hypo_code": "class PizzaWith3NSlices {\n    public int maxSizeSlices(int[] slices) {\n        int n = slices.length;\n        int m = n / 3;\n        return Math.max(maxSum(slices, 0, n - 2, m), maxSum(slices, 1, n - 1, m));\n      \n    }\n}"}
{"id": "1995", "path": "output2\\java\\Hard\\1995-longest-happy-prefix.java", "hypo_code": "class LongestHappyPrefix {\n    public String longestPrefix(String s) {\n        int n = s.length();\n        int[] lps = new int[n];\n        int i = 1;\n        int j = 0;\n        while(i < n){\n            if(s.charAt(i) == s.charAt(j)){\n                lps[i] = j + 1;\n                i++;\n                j++;\n            }else{\n                if(j != 0){\n                    j = lps[j - 1];\n                }else{\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        return s.substring(0, lps[n - 1]);\n        \n    }\n}"}
{"id": "1996", "path": "output2\\java\\Hard\\1996-find-all-good-strings.java", "hypo_code": "class FindAllGoodStrings {\n    public int findGoodStrings(int n, String s1, String s2, String evil) {\n        int mod = 1000000007;\n        int[][][] dp = new int[n + 1][s1.length() + 1][s2.length() + 1];\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= s1.length(); j++){\n                for(int k = 0; k <= s2.length(); k++){\n                    dp[i][j][k] = -1;\n                }\n            }\n        }\n        return dfs(n, s1, s2, evil, 0, 0, 0, dp) % mod;\n        \n        \n    }\n}"}
{"id": "1997", "path": "output2\\java\\Hard\\1997-reducing-dishes.java", "hypo_code": "class ReducingDishes {\n    public int maxSatisfaction(int[] satisfaction) {\n        Arrays.sort(satisfaction);\n        int n = satisfaction.length;\n        int[] prefix = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            prefix[i] = prefix[i - 1] + satisfaction[i - 1];\n        }\n        int res = 0;\n        int sum = 0;\n        for(int i = n - 1; i >= 0; i--){\n            sum += satisfaction[i];\n            res = Math.max(res, sum + prefix[i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "1998", "path": "output2\\java\\Hard\\1998-stone-game-iii.java", "hypo_code": "class StoneGameIii {\n    public String stoneGameIII(int[] stoneValue) {\n        int n = stoneValue.length;\n        int[] dp = new int[n + 1];\n        dp[n] = 0;\n        for(int i = n - 1; i >= 0; i--){\n            int max = Integer.MIN_VALUE;\n            int sum = 0;\n            for(int j = i; j < i + 3 && j < n; j++){\n                sum += stoneValue[j];\n                max = Math.max(max, sum - dp[j + 1]);\n            }\n            dp[i] = max;\n        }\n        if(dp[0] > 0){\n            return \"Alice\";\n        }else if(dp[0] < 0){\n            return \"Bob\";\n        }else{\n            return \"Tie\";\n        }\n        \n    }\n}"}
{"id": "1999", "path": "output2\\java\\Hard\\1999-number-of-ways-to-paint-n-3-grid.java", "hypo_code": "class Solution {\n    public int numOfWays(int n) {\n        int mod = 1000000007;\n        long twoColor = 6;\n        long threeColor = 6;\n        for(int i = 1; i < n; i++){\n            long temp = twoColor;\n            twoColor = (2 * twoColor + 2 * threeColor) % mod;\n            threeColor = (2 * temp + 3 * threeColor) % mod;\n        }\n        return (int)((twoColor + threeColor) % mod);\n    }\n}"}
{"id": "2000", "path": "output2\\java\\Hard\\2000-restore-the-array.java", "hypo_code": "class RestoreTheArray {\n    public int numberOfArrays(String s, int k) {\n        int mod = 1000000007;\n        int n = s.length();\n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n        for(int i = 1; i <= n; i++){\n            for(int j = i - 1; j >= 0; j--){\n                if(s.charAt(j) == '0'){\n                    break;\n                }\n                long num = Long.parseLong(s.substring(j, i));\n                if(num > k){\n                    break;\n                }\n                dp[i] = (dp[i] + dp[j]) % mod;\n            }\n        }\n        return (int)dp[n];\n        \n    }\n}"}
{"id": "2001", "path": "output2\\java\\Hard\\2001-build-array-where-you-can-find-the-maximum-exactly-k-comparisons.java", "hypo_code": "class Solution {\n    public int numOfArrays(int n, int m, int k) {\n        int mod = 1000000007;\n        int[][][] dp = new int[n + 1][m + 1][k + 1];\n        for(int i = 1; i <= m; i++){\n            dp[1][i][1] = 1;\n        }\n        for(int i = 2; i <= n; i++){\n            for(int j = 1; j <= m; j++){\n                for(int l = 1; l <= k; l++){\n                    dp[i][j][l] = (dp[i][j][l] + dp[i - 1][j][l] * j) % mod;\n                    for(int p = 1; p < j; p++){\n                        dp[i][j][l] = (dp[i][j][l] + dp[i - 1][p][l - 1]) % mod;\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for(int i = 1; i <= m; i++){\n            res = (res + dp[n][i][k]) % mod;\n        }\n        return res;\n    }\n}"}
{"id": "2002", "path": "output2\\java\\Hard\\2002-constrained-subsequence-sum.java", "hypo_code": "class ConstrainedSubsequenceSum {\n    public int constrainedSubsetSum(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        int max = Integer.MIN_VALUE;\n        Deque<Integer> dq = new LinkedList<>();\n        for(int i = 0; i < n; i++){\n            dp[i] = nums[i];\n            if(!dq.isEmpty()){\n                dp[i] = Math.max(dp[i], nums[i] + dq.peekFirst());\n            }\n            max = Math.max(max, dp[i]);\n            while(!dq.isEmpty() && dq.peekLast() < dp[i]){\n                dq.pollLast();\n            }\n            dq.offerLast(dp[i]);\n            if(i >= k && dq.peekFirst() == dp[i - k]){\n                dq.pollFirst();\n            }\n        }\n        return max;\n        \n    }\n}"}
{"id": "2003", "path": "output2\\java\\Hard\\2003-number-of-ways-to-wear-different-hats-to-each-other.java", "hypo_code": "class NumberOfWaysToWearDifferentHatsToEachOther {\n    public int numberWays(List<List<Integer>> hats) {\n        int n = hats.size();\n        int mod = 1000000007;\n        int[][] dp = new int[41][1 << n];\n        dp[0][0] = 1;\n        for(int i = 1; i <= 40; i++){\n            for(int j = 0; j < (1 << n); j++){\n                dp[i][j] = dp[i - 1][j];\n                for(int k = 0; k < n; k++){\n                    if((j & (1 << k)) == 0 && hats.get(k).contains(i)){\n                        dp[i][j] = (dp[i][j] + dp[i - 1][j | (1 << k)]) % mod;\n                    }\n                }\n            }\n        }\n        return dp[40][(1 << n) - 1];\n        \n    }\n}"}
{"id": "2004", "path": "output2\\java\\Hard\\2004-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows.java", "hypo_code": "class FindTheKthSmallestSumOfAMatrixWithSortedRows {\n    public int kthSmallest(int[][] mat, int k) {\n        int m = mat.length;\n        int n = mat[0].length;\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        pq.offer(0);\n        for (int i = 0; i < m; i++) {\n            PriorityQueue<Integer> next = new PriorityQueue<>((a, b) -> b - a);\n            for (int j = 0; j < n; j++) {\n                for (int sum : pq) {\n                    next.offer(sum + mat[i][j]);\n                    if (next.size() > k) {\n                        next.poll();\n                    }\n                }\n            }\n            pq = next;\n        }\n        return pq.poll();\n        \n    }\n}"}
{"id": "2005", "path": "output2\\java\\Hard\\2005-number-of-ways-of-cutting-a-pizza.java", "hypo_code": "class NumberOfWaysOfCuttingAPizza {\n    public int ways(String[] pizza, int k) {\n        int mod = 1000000007;\n        int m = pizza.length;\n        int n = pizza[0].length();\n        int[][] preSum = new int[m + 1][n + 1];\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + (pizza[i - 1].charAt(j - 1) == 'A' ? 1 : 0);\n            }\n        }\n        int[][][] dp = new int[m + 1][n + 1][k + 1];\n        for(int i = 0; i <= m; i++){\n            for(int j = 0; j <= n; j++){\n                for(int l = 0; l <= k; l++){\n                    dp[i][j][l] = -1;\n                }\n            }\n        }\n        return dfs(m, n, k, preSum, 0, 0, dp) % mod;\n        \n        \n    }\n}"}
{"id": "2006", "path": "output2\\java\\Hard\\2006-form-largest-integer-with-digits-that-add-up-to-target.java", "hypo_code": "class FormLargestIntegerWithDigitsThatAddUpToTarget {\n    public String largestNumber(int[] cost, int target) {\n        int[] dp = new int[target + 1];\n        Arrays.fill(dp, Integer.MIN_VALUE);\n        dp[0] = 0;\n        for (int i = 0; i < 9; i++) {\n            for (int j = cost[i]; j <= target; j++) {\n                dp[j] = Math.max(dp[j], dp[j - cost[i]] + 1);\n            }\n        }\n        if (dp[target] < 0) {\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 8, j = target; i >= 0; i--) {\n            while (j >= cost[i] && dp[j] == dp[j - cost[i]] + 1) {\n                sb.append(i + 1);\n                j -= cost[i];\n            }\n        }\n        return sb.toString();\n        \n    }\n}"}
{"id": "2007", "path": "output2\\java\\Hard\\2007-maximum-number-of-darts-inside-of-a-circular-dartboard.java", "hypo_code": "class MaximumNumberOfDartsInsideOfACircularDartboard {\n    public int numPoints(int[][] darts, int r) {\n        int n = darts.length;\n        int ans = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int[] p1 = darts[i];\n                int[] p2 = darts[j];\n                int[] center = getCenter(p1, p2, r);\n                if (center == null) {\n                    continue;\n                }\n                int cnt = 0;\n                for (int k = 0; k < n; k++) {\n                    if (inCircle(darts[k], center, r)) {\n                        cnt++;\n                    }\n                }\n                ans = Math.max(ans, cnt);\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2008", "path": "output2\\java\\Hard\\2008-max-dot-product-of-two-subsequences.java", "hypo_code": "class MaxDotProductOfTwoSubsequences {\n    public int maxDotProduct(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int m = nums2.length;\n        int[][] dp = new int[n + 1][m + 1];\n        for(int i = 0; i <= n; i++){\n            Arrays.fill(dp[i], Integer.MIN_VALUE);\n        }\n        dp[0][0] = 0;\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= m; j++){\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1]);\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n                dp[i][j] = Math.max(dp[i][j], dp[i][j - 1]);\n                dp[i][j] = Math.max(dp[i][j], nums1[i - 1] * nums2[j - 1]);\n            }\n        }\n        return dp[n][m];\n        \n    }\n}"}
{"id": "2009", "path": "output2\\java\\Hard\\2009-cherry-pickup-ii.java", "hypo_code": "class CherryPickupIi {\n    public int cherryPickup(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] dp = new int[m][n][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    dp[i][j][k] = -1;\n                }\n            }\n        }\n        dp[0][0][n - 1] = grid[0][0] + grid[0][n - 1];\n        for (int i = 1; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    for (int j1 = j - 1; j1 <= j + 1; j1++) {\n                        for (int k1 = k - 1; k1 <= k + 1; k1++) {\n                            if (j1 >= 0 && j1 < n && k1 >= 0 && k1 < n) {\n                                dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j1][k1]);\n                            }\n                        }\n                    }\n                    if (dp[i][j][k] >= 0) {\n                        dp[i][j][k] += grid[i][j] + (j == k ? 0 : grid[i][k]);\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                res = Math.max(res, dp[m - 1][j][k]);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2010", "path": "output2\\java\\Hard\\2010-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls.java", "hypo_code": "class ProbabilityOfATwoBoxesHavingTheSameNumberOfDistinctBalls {\n    public double getProbability(int[] balls) {\n        int n = balls.length;\n        int sum = 0;\n        for(int i = 0; i < n; i++){\n            sum += balls[i];\n        }\n        int[][] dp = new int[sum + 1][sum + 1];\n        for(int i = 0; i <= sum; i++){\n            for(int j = 0; j <= sum; j++){\n                dp[i][j] = -1;\n            }\n        }\n        int total = dfs(balls, 0, 0, 0, dp);\n        int same = 0;\n        for(int i = 0; i <= sum; i++){\n            same += dfs(balls, 0, i, i, dp);\n        }\n        return (double)same / total;\n        \n        \n    }\n}"}
{"id": "2011", "path": "output2\\java\\Hard\\2011-paint-house-iii.java", "hypo_code": "class PaintHouseIii {\n    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {\n        int[][][] dp = new int[m + 1][n + 1][target + 1];\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                Arrays.fill(dp[i][j], Integer.MAX_VALUE / 2);\n            }\n        }\n        dp[0][0][0] = 0;\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                for (int k = 1; k <= target; k++) {\n                    if (houses[i - 1] == 0) {\n                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k] + cost[i - 1][j - 1]);\n                    }\n                    for (int p = 1; p <= n; p++) {\n                        if (p == j) {\n                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][p][k] + (houses[i - 1] == 0 ? cost[i - 1][j - 1] : 0));\n                        } else {\n                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][p][k - 1] + (houses[i - 1] == 0 ? cost[i - 1][j - 1] : 0));\n                        }\n                    }\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 1; i <= n; i++) {\n            res = Math.min(res, dp[m][i][target]);\n        }\n        return res == Integer.MAX_VALUE / 2 ? -1 : res;\n        \n    }\n}"}
{"id": "2012", "path": "output2\\java\\Hard\\2012-allocate-mailboxes.java", "hypo_code": "class AllocateMailboxes {\n    public int minDistance(int[] houses, int k) {\n        int n = houses.length;\n        Arrays.sort(houses);\n        int[][] cost = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                int mid = (i + j) / 2;\n                for (int p = i; p <= j; p++) {\n                    cost[i][j] += Math.abs(houses[p] - houses[mid]);\n                }\n            }\n        }\n        int[][] dp = new int[n][k];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);\n        }\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = cost[0][i];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < k; j++) {\n                for (int p = 0; p < i; p++) {\n                    dp[i][j] = Math.min(dp[i][j], dp[p][j - 1] + cost[p + 1][i]);\n                }\n            }\n        }\n        return dp[n - 1][k - 1];\n        \n    }\n}"}
{"id": "2014", "path": "output2\\java\\Hard\\2014-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree.java", "hypo_code": "class FindCriticalAndPseudoCriticalEdgesInMinimumSpanningTree {\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n        int m = edges.length;\n        for(int i = 0; i < m; i++){\n            edges[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};\n        }\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\n        UnionFind uf = new UnionFind(n);\n        int value = 0;\n        for(int i = 0; i < m; i++){\n            if(uf.union(edges[i][0], edges[i][1])){\n                value += edges[i][2];\n            }\n        }\n        List<List<Integer>> ans = new ArrayList<>();\n        for(int i = 0; i < 2; i++){\n            ans.add(new ArrayList<>());\n        }\n        for(int i = 0; i < m; i++){\n            UnionFind uf1 = new UnionFind(n);\n            int v = 0;\n            for(int j = 0; j < m; j++){\n                if(i != j && uf1.union(edges[j][0], edges[j][1])){\n                    v += edges[j][2];\n                }\n            }\n            if(uf1.setCount != 1 || (uf1.setCount == 1 && v > value)){\n                ans.get(0).add(edges[i][3]);\n                continue;\n            }\n            UnionFind uf2 = new UnionFind(n);\n            uf2.union(edges[i][0], edges[i][1]);\n            v = edges[i][2];\n            for(int j = 0; j < m; j++){\n                if(i != j && uf2.union(edges[j][0], edges[j][1])){\n                    v += edges[j][2];\n                }\n            }\n            if(v == value){\n                ans.get(1).add(edges[i][3]);\n            }\n        }\n        return ans;\n        \n        \n    }\n}"}
{"id": "2015", "path": "output2\\java\\Hard\\2015-parallel-courses-ii.java", "hypo_code": "class ParallelCoursesIi {\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\n        int[] pre = new int[n];\n        for (int[] r : relations) {\n            pre[r[1] - 1] |= 1 << (r[0] - 1);\n        }\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, n);\n        dp[0] = 0;\n        for (int i = 0; i < 1 << n; i++) {\n            int canTake = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i & pre[j]) == pre[j]) {\n                    canTake |= 1 << j;\n                }\n            }\n            canTake &= ~i;\n            for (int j = canTake; j > 0; j = (j - 1) & canTake) {\n                if (Integer.bitCount(j) <= k) {\n                    dp[i | j] = Math.min(dp[i | j], dp[i] + 1);\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n        \n    }\n}"}
{"id": "2016", "path": "output2\\java\\Hard\\2016-max-value-of-equation.java", "hypo_code": "class MaxValueOfEquation {\n    public int findMaxValueOfEquation(int[][] points, int k) {\n        int n = points.length;\n        int ans = Integer.MIN_VALUE;\n        Deque<int[]> dq = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            int[] p = points[i];\n            while (!dq.isEmpty() && p[0] - dq.peekFirst()[0] > k) {\n                dq.pollFirst();\n            }\n            if (!dq.isEmpty()) {\n                ans = Math.max(ans, p[0] + p[1] + dq.peekFirst()[1]);\n            }\n            while (!dq.isEmpty() && p[1] - p[0] >= dq.peekLast()[1] - dq.peekLast()[0]) {\n                dq.pollLast();\n            }\n            dq.offerLast(new int[]{p[0], p[1] - p[0]});\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2017", "path": "output2\\java\\Hard\\2017-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits.java", "hypo_code": "class MinimumPossibleIntegerAfterAtMostKAdjacentSwapsOnDigits {\n    public String minInteger(String num, int k) {\n        int n = num.length();\n        int[] pos = new int[10];\n        for (int i = 0; i < n; i++) {\n            pos[num.charAt(i) - '0'] = i;\n        }\n        char[] res = new char[n];\n        for (int i = 0; i < n; i++) {\n            for (int d = 0; d < 10; d++) {\n                if (pos[d] < i) {\n                    continue;\n                }\n                int diff = pos[d] - i;\n                if (diff <= k) {\n                    res[i] = (char) (d + '0');\n                    k -= diff;\n                    pos[d] = -1;\n                    break;\n                }\n            }\n        }\n        return new String(res);\n        \n    }\n}"}
{"id": "2018", "path": "output2\\java\\Hard\\2018-stone-game-iv.java", "hypo_code": "class StoneGameIv {\n    public boolean winnerSquareGame(int n) {\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = false;\n        for(int i = 1; i <= n; i++){\n            boolean canWin = false;\n            for(int j = 1; j * j <= i; j++){\n                if(!dp[i - j * j]){\n                    canWin = true;\n                    break;\n                }\n            }\n            dp[i] = canWin;\n        }\n        return dp[n];\n        \n    }\n}"}
{"id": "2019", "path": "output2\\java\\Hard\\2019-best-position-for-a-service-centre.java", "hypo_code": "class Solution {\n    public double getMinDistSum(int[][] positions) {\n        double eps = 1e-7;\n        double res = Double.MAX_VALUE;\n        double step = 100;\n        double x = 50;\n        double y = 50;\n        while(step > eps){\n            double cur = getDist(positions, x, y);\n            res = Math.min(res, cur);\n            boolean found = false;\n            for(int i = 0; i < 4; i++){\n                double nx = x + step * dirs[i][0];\n                double ny = y + step * dirs[i][1];\n                double ncur = getDist(positions, nx, ny);\n                if(ncur < cur){\n                    x = nx;\n                    y = ny;\n                    found = true;\n                    break;\n                }\n            }\n            if(!found){\n                step /= 2;\n            }\n        }\n        return res;\n    }\n    private double getDist(int[][] positions, double x, double y){\n        double res = 0;\n        for(int[] position : positions){\n            res += Math.sqrt(Math.pow(position[0] - x, 2) + Math.pow(position[1] - y, 2));\n        }\n        return res;\n    }\n    private int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n}"}
{"id": "2020", "path": "output2\\java\\Hard\\2020-maximum-number-of-non-overlapping-substrings.java", "hypo_code": "class MaximumNumberOfNonOverlappingSubstrings {\n    public List<String> maxNumOfSubstrings(String s) {\n        int[] left = new int[26];\n        int[] right = new int[26];\n        Arrays.fill(left, Integer.MAX_VALUE);\n        Arrays.fill(right, Integer.MIN_VALUE);\n        for(int i = 0; i < s.length(); i++){\n            int c = s.charAt(i) - 'a';\n            left[c] = Math.min(left[c], i);\n            right[c] = Math.max(right[c], i);\n        }\n        List<int[]> intervals = new ArrayList<>();\n        for(int i = 0; i < 26; i++){\n            if(left[i] == Integer.MAX_VALUE){\n                continue;\n            }\n            int l = left[i];\n            int r = right[i];\n            for(int j = l; j <= r; j++){\n                int c = s.charAt(j) - 'a';\n                l = Math.min(l, left[c]);\n                r = Math.max(r, right[c]);\n            }\n            intervals.add(new int[]{l, r});\n        }\n        Collections.sort(intervals, (a, b) -> a[0] - b[0]);\n        List<String> res = new ArrayList<>();\n        int prev = -1;\n        for(int[] interval : intervals){\n            if(interval[0] > prev){\n                res.add(s.substring(interval[0], interval[1] + 1));\n                prev = interval[1];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2021", "path": "output2\\java\\Hard\\2021-find-a-value-of-a-mysterious-function-closest-to-target.java", "hypo_code": "class Solution {\n    public int closestToTarget(int[] arr, int target) {\n        int len = arr.length;\n        int res = Integer.MAX_VALUE;\n        for(int i = 0; i < len; i++){\n            int cur = arr[i];\n            res = Math.min(res, Math.abs(cur - target));\n            for(int j = i + 1; j < len; j++){\n                cur &= arr[j];\n                res = Math.min(res, Math.abs(cur - target));\n                if(cur < target){\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2022", "path": "output2\\java\\Hard\\2022-minimum-number-of-increments-on-subarrays-to-form-a-target-array.java", "hypo_code": "class MinimumNumberOfIncrementsOnSubarraysToFormATargetArray {\n    public int minNumberOperations(int[] target) {\n        int res = target[0];\n        for(int i = 1; i < target.length; i++){\n            res += Math.max(0, target[i] - target[i - 1]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2023", "path": "output2\\java\\Hard\\2023-string-compression-ii.java", "hypo_code": "class StringCompressionIi {\n    public int getLengthOfOptimalCompression(String s, int k) {\n        int n = s.length();\n        int[][] dp = new int[n + 1][k + 1];\n        for(int i = 0; i <= n; i++){\n            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);\n        }\n        dp[0][0] = 0;\n        for(int i = 1; i <= n; i++){\n            for(int j = 0; j <= k; j++){\n                dp[i][j] = dp[i - 1][j];\n                int cnt = 0;\n                int diff = 0;\n                for(int l = i; l >= 1; l--){\n                    if(s.charAt(l - 1) == s.charAt(i - 1)){\n                        cnt++;\n                    }else{\n                        diff++;\n                    }\n                    if(j >= diff && dp[l - 1][j - diff] != Integer.MAX_VALUE / 2){\n                        dp[i][j] = Math.min(dp[i][j], dp[l - 1][j - diff] + 1 + (cnt >= 100 ? 3 : cnt >= 10 ? 2 : cnt >= 2 ? 1 : 0));\n                    }\n                }\n            }\n        }\n        return dp[n][k];\n        \n    }\n}"}
{"id": "2024", "path": "output2\\java\\Hard\\2024-get-the-maximum-score.java", "hypo_code": "class GetTheMaximumScore {\n    public int maxSum(int[] nums1, int[] nums2) {\n        int i = 0;\n        int j = 0;\n        int sum1 = 0;\n        int sum2 = 0;\n        int mod = 1000000007;\n        while(i < nums1.length || j < nums2.length){\n            if(i < nums1.length && (j == nums2.length || nums1[i] < nums2[j])){\n                sum1 += nums1[i++];\n            }else if(j < nums2.length && (i == nums1.length || nums1[i] > nums2[j])){\n                sum2 += nums2[j++];\n            }else{\n                sum1 = sum2 = Math.max(sum1, sum2) + nums1[i];\n                i++;\n                j++;\n            }\n        }\n        return (int)(Math.max(sum1, sum2) % mod);\n        \n    }\n}"}
{"id": "2025", "path": "output2\\java\\Hard\\2025-find-longest-awesome-substring.java", "hypo_code": "class FindLongestAwesomeSubstring {\n    public int longestAwesome(String s) {\n        int[] seen = new int[1024];\n        Arrays.fill(seen, -1);\n        int res = 0;\n        int mask = 0;\n        seen[0] = 0;\n        for(int i = 0; i < s.length(); i++){\n            int c = s.charAt(i) - '0';\n            mask ^= 1 << c;\n            if(seen[mask] >= 0){\n                res = Math.max(res, i + 1 - seen[mask]);\n            }else{\n                seen[mask] = i + 1;\n            }\n            for(int j = 0; j < 10; j++){\n                int newMask = mask ^ (1 << j);\n                if(seen[newMask] >= 0){\n                    res = Math.max(res, i + 1 - seen[newMask]);\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2026", "path": "output2\\java\\Hard\\2026-minimum-cost-to-cut-a-stick.java", "hypo_code": "class Solution {\n    public int minCost(int n, int[] cuts) {\n        int len = cuts.length;\n        Arrays.sort(cuts);\n        int[] newCuts = new int[len + 2];\n        newCuts[0] = 0;\n        newCuts[len + 1] = n;\n        for(int i = 1; i <= len; i++){\n            newCuts[i] = cuts[i - 1];\n        }\n        int[][] dp = new int[len + 2][len + 2];\n        for(int i = len; i >= 1; i--){\n            for(int j = i; j <= len; j++){\n                if(i == j){\n                    dp[i][j] = 0;\n                }else{\n                    dp[i][j] = Integer.MAX_VALUE;\n                    for(int k = i; k <= j; k++){\n                        dp[i][j] = Math.min(dp[i][j], dp[i][k - 1] + dp[k + 1][j]);\n                    }\n                    dp[i][j] += newCuts[j + 1] - newCuts[i - 1];\n                }\n            }\n        }\n        return dp[1][len];\n\n    }\n}"}
{"id": "2027", "path": "output2\\java\\Hard\\2027-minimum-number-of-days-to-eat-n-oranges.java", "hypo_code": "class MinimumNumberOfDaysToEatNOranges {\n    public int minDays(int n) {\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        for(int i = 1; i <= n; i++){\n            dp[i] = Math.min(dp[i], dp[i - 1] + 1);\n            if(i % 2 == 0){\n                dp[i] = Math.min(dp[i], dp[i / 2] + 1);\n            }\n            if(i % 3 == 0){\n                dp[i] = Math.min(dp[i], dp[i / 3] + 1);\n            }\n        }\n        return dp[n];\n        \n    }\n}"}
{"id": "2028", "path": "output2\\java\\Hard\\2028-stone-game-v.java", "hypo_code": "class StoneGameV {\n    public int stoneGameV(int[] stoneValue) {\n        int n = stoneValue.length;\n        int[] prefix = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            prefix[i] = prefix[i - 1] + stoneValue[i - 1];\n        }\n        int[][] dp = new int[n][n];\n        for(int i = n - 1; i >= 0; i--){\n            for(int j = i + 1; j < n; j++){\n                for(int k = i; k < j; k++){\n                    int left = prefix[k + 1] - prefix[i];\n                    int right = prefix[j + 1] - prefix[k + 1];\n                    if(left < right){\n                        dp[i][j] = Math.max(dp[i][j], dp[i][k] + left);\n                    }else if(left > right){\n                        dp[i][j] = Math.max(dp[i][j], dp[k + 1][j] + right);\n                    }else{\n                        dp[i][j] = Math.max(dp[i][j], dp[i][k] + left);\n                        dp[i][j] = Math.max(dp[i][j], dp[k + 1][j] + right);\n                    }\n                }\n            }\n        }\n        return dp[0][n - 1];\n        \n    }\n}"}
{"id": "2029", "path": "output2\\java\\Hard\\2029-minimum-number-of-days-to-disconnect-island.java", "hypo_code": "class MinimumNumberOfDaysToDisconnectIsland {\n    public int minDays(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int[][] prefix = new int[m + 1][n + 1];\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        int count = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 1){\n                    count++;\n                }\n            }\n        }\n        if(count == 0){\n            return 0;\n        }\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 1){\n                    grid[i][j] = 0;\n                    int newCount = 0;\n                    for(int k = 0; k < m; k++){\n                        for(int l = 0; l < n; l++){\n                            if(grid[k][l] == 1){\n                                newCount++;\n                            }\n                        }\n                    }\n                    if(newCount == 0){\n                        return 1;\n                    }\n                    for(int k = 0; k < m; k++){\n                        for(int l = 0; l < n; l++){\n                            if(grid[k][l] == 1){\n                                boolean flag = false;\n                                for(int[] dir : dirs){\n                                    int x = k + dir[0];\n                                    int y = l + dir[1];\n                                    if(x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 1){\n                                        flag = true;\n                                        break;\n                                    }\n                                }\n                                if(!flag){\n                                    int sum = prefix[k + 1][l + 1] - prefix[k + 1][l] - prefix[k][l + 1] + prefix[k][l];\n                                    if(sum == 1){\n        \n    }\n}"}
{"id": "2030", "path": "output2\\java\\Hard\\2030-number-of-ways-to-reorder-array-to-get-same-bst.java", "hypo_code": "class NumberOfWaysToReorderArrayToGetSameBst {\n    public int numOfWays(int[] nums) {\n        int n = nums.length;\n        int[][] dp = new int[n][n];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(dp[i], -1);\n        }\n        return dfs(nums, 0, n - 1, dp);\n        \n    }\n}"}
{"id": "2031", "path": "output2\\java\\Hard\\2031-count-all-possible-routes.java", "hypo_code": "class CountAllPossibleRoutes {\n    public int countRoutes(int[] locations, int start, int finish, int fuel) {\n        int n = locations.length;\n        int[][] dp = new int[n][fuel + 1];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(dp[i], -1);\n        }\n        return dfs(locations, start, finish, fuel, dp);\n        \n        \n    }\n}"}
{"id": "2032", "path": "output2\\java\\Hard\\2032-remove-max-number-of-edges-to-keep-graph-fully-traversable.java", "hypo_code": "class RemoveMaxNumberOfEdgesToKeepGraphFullyTraversable {\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\n        int[] parent = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            parent[i] = i;\n        }\n        int res = 0;\n        for(int[] edge : edges){\n            if(edge[0] == 3){\n                if(!union(edge[1], edge[2], parent)){\n                    res++;\n                }\n            }\n        }\n        int[] parentA = Arrays.copyOf(parent, n + 1);\n        int[] parentB = Arrays.copyOf(parent, n + 1);\n        for(int[] edge : edges){\n            if(edge[0] == 1){\n                if(!union(edge[1], edge[2], parentA)){\n                    res++;\n                }\n            }else if(edge[0] == 2){\n                if(!union(edge[1], edge[2], parentB)){\n                    res++;\n                }\n            }\n        }\n        if(count(parentA) != 1 || count(parentB) != 1){\n            return -1;\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "2033", "path": "output2\\java\\Hard\\2033-check-if-string-is-transformable-with-substring-sort-operations.java", "hypo_code": "class CheckIfStringIsTransformableWithSubstringSortOperations {\n    public boolean isTransformable(String s, String t) {\n        int n = s.length();\n        List<Integer>[] pos = new List[10];\n        for(int i = 0; i < 10; i++){\n            pos[i] = new ArrayList<>();\n        }\n        for(int i = 0; i < n; i++){\n            int c = s.charAt(i) - '0';\n            pos[c].add(i);\n        }\n        for(int i = 0; i < n; i++){\n            int c = t.charAt(i) - '0';\n            if(pos[c].isEmpty()){\n                return false;\n            }\n            for(int j = 0; j < c; j++){\n                if(!pos[j].isEmpty() && pos[j].get(0) < pos[c].get(0)){\n                    return false;\n                }\n            }\n            pos[c].remove(0);\n        }\n        return true;\n        \n    }\n}"}
{"id": "2034", "path": "output2\\java\\Hard\\2034-strange-printer-ii.java", "hypo_code": "class StrangePrinterIi {\n    public boolean isPrintable(int[][] targetGrid) {\n        int m = targetGrid.length;\n        int n = targetGrid[0].length;\n        int[] minRow = new int[61];\n        int[] maxRow = new int[61];\n        int[] minCol = new int[61];\n        int[] maxCol = new int[61];\n        Arrays.fill(minRow, Integer.MAX_VALUE);\n        Arrays.fill(maxRow, Integer.MIN_VALUE);\n        Arrays.fill(minCol, Integer.MAX_VALUE);\n        Arrays.fill(maxCol, Integer.MIN_VALUE);\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                int color = targetGrid[i][j];\n                minRow[color] = Math.min(minRow[color], i);\n                maxRow[color] = Math.max(maxRow[color], i);\n                minCol[color] = Math.min(minCol[color], j);\n                maxCol[color] = Math.max(maxCol[color], j);\n            }\n        }\n        boolean[] visited = new boolean[61];\n        boolean[] inStack = new boolean[61];\n        for(int i = 1; i <= 60; i++){\n            if(minRow[i] == Integer.MAX_VALUE){\n                continue;\n            }\n            if(!dfs(targetGrid, minRow, maxRow, minCol, maxCol, visited, inStack, i)){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "2035", "path": "output2\\java\\Hard\\2035-minimum-cost-to-connect-two-groups-of-points.java", "hypo_code": "class MinimumCostToConnectTwoGroupsOfPoints {\n    public int connectTwoGroups(List<List<Integer>> cost) {\n        int m = cost.size();\n        int n = cost.get(0).size();\n        int[][] dp = new int[m + 1][1 << n];\n        for(int i = 0; i <= m; i++){\n            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);\n        }\n        dp[0][0] = 0;\n        for(int i = 1; i <= m; i++){\n            for(int j = 0; j < (1 << n); j++){\n                for(int k = 0; k < n; k++){\n                    if((j & (1 << k)) == 0){\n                        dp[i][j | (1 << k)] = Math.min(dp[i][j | (1 << k)], dp[i - 1][j] + cost.get(i - 1).get(k));\n                    }\n                }\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);\n            }\n        }\n        return dp[m][(1 << n) - 1];\n        \n    }\n}"}
{"id": "2036", "path": "output2\\java\\Hard\\2036-maximum-number-of-achievable-transfer-requests.java", "hypo_code": "class MaximumNumberOfAchievableTransferRequests {\n    public int maximumRequests(int n, int[][] requests) {\n        int m = requests.length;\n        int[] dp = new int[1 << m];\n        for(int i = 0; i < (1 << m); i++){\n            int[] count = new int[n];\n            for(int j = 0; j < m; j++){\n                if(((i >> j) & 1) == 1){\n                    count[requests[j][0]]--;\n                    count[requests[j][1]]++;\n                }\n            }\n            boolean flag = true;\n            for(int j = 0; j < n; j++){\n                if(count[j] != 0){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                dp[i] = Integer.bitCount(i);\n            }\n        }\n        for(int i = 0; i < (1 << m); i++){\n            for(int j = i; j > 0; j = (j - 1) & i){\n                dp[i] = Math.max(dp[i], dp[j] + dp[i ^ j]);\n            }\n        }\n        return dp[(1 << m) - 1];\n        \n    }\n}"}
{"id": "2037", "path": "output2\\java\\Hard\\2037-find-servers-that-handled-most-number-of-requests.java", "hypo_code": "class FindServersThatHandledMostNumberOfRequests {\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\n        int n = arrival.length;\n        int[] count = new int[k];\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        PriorityQueue<Integer> available = new PriorityQueue<>();\n        for(int i = 0; i < k; i++){\n            available.offer(i);\n        }\n        for(int i = 0; i < n; i++){\n            while(!pq.isEmpty() && pq.peek()[0] <= arrival[i]){\n                available.offer(pq.poll()[1]);\n            }\n            if(available.isEmpty()){\n                continue;\n            }\n            int idx = available.poll();\n            count[idx]++;\n            pq.offer(new int[]{arrival[i] + load[i], idx});\n        }\n        int max = 0;\n        for(int i = 0; i < k; i++){\n            max = Math.max(max, count[i]);\n        }\n        List<Integer> res = new ArrayList<>();\n        for(int i = 0; i < k; i++){\n            if(count[i] == max){\n                res.add(i);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2038", "path": "output2\\java\\Hard\\2038-maximum-number-of-visible-points.java", "hypo_code": "class MaximumNumberOfVisiblePoints {\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\n        List<Double> angles = new ArrayList<>();\n        int extra = 0;\n        for (List<Integer> point : points) {\n            int x = point.get(0) - location.get(0);\n            int y = point.get(1) - location.get(1);\n            if (x == 0 && y == 0) {\n                extra++;\n                continue;\n            }\n            angles.add(Math.atan2(y, x) * 180 / Math.PI);\n        }\n        Collections.sort(angles);\n        int n = angles.size();\n        for (int i = 0; i < n; i++) {\n            angles.add(angles.get(i) + 360);\n        }\n        int ans = 0;\n        int i = 0;\n        for (int j = 0; j < angles.size(); j++) {\n            while (angles.get(j) - angles.get(i) > angle) {\n                i++;\n            }\n            ans = Math.max(ans, j - i + 1);\n        }\n        return ans + extra;\n        \n    }\n}"}
{"id": "2039", "path": "output2\\java\\Hard\\2039-minimum-one-bit-operations-to-make-integers-zero.java", "hypo_code": "class MinimumOneBitOperationsToMakeIntegersZero {\n    public int minimumOneBitOperations(int n) {\n        int res = 0;\n        while(n > 0){\n            res ^= n;\n            n >>= 1;\n        }\n        return res;\n        \n    }\n}"}
{"id": "2040", "path": "output2\\java\\Hard\\2040-count-subtrees-with-max-distance-between-cities.java", "hypo_code": "class CountSubtreesWithMaxDistanceBetweenCities {\n    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {\n        int[] res = new int[n - 1];\n        int[][] graph = new int[n][n];\n        for(int[] edge : edges){\n            graph[edge[0] - 1][edge[1] - 1] = 1;\n            graph[edge[1] - 1][edge[0] - 1] = 1;\n        }\n        for(int i = 1; i < (1 << n); i++){\n            int[] dist = new int[n];\n            Arrays.fill(dist, -1);\n            int count = 0;\n            int max = 0;\n            for(int j = 0; j < n; j++){\n                if((i & (1 << j)) != 0){\n                    count++;\n                    dist[j] = 0;\n                }\n            }\n            if(count <= 1){\n                continue;\n            }\n            Queue<Integer> queue = new LinkedList<>();\n            for(int j = 0; j < n; j++){\n                if(dist[j] == 0){\n                    queue.offer(j);\n                }\n            }\n            while(!queue.isEmpty()){\n                int cur = queue.poll();\n                for(int j = 0; j < n; j++){\n                    if(graph[cur][j] == 1 && dist[j] == -1){\n                        dist[j] = dist[cur] + 1;\n                        max = Math.max(max, dist[j]);\n                        queue.offer(j);\n                    }\n                }\n            }\n            if(count == max + 1){\n                res[max - 1]++;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2042", "path": "output2\\java\\Hard\\2042-graph-connectivity-with-threshold.java", "hypo_code": "class GraphConnectivityWithThreshold {\n    public List<Boolean> areConnected(int n, int threshold, int[][] queries) {\n        int[] parent = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            parent[i] = i;\n        }\n        for(int i = threshold + 1; i <= n; i++){\n            for(int j = i + i; j <= n; j += i){\n                union(parent, i, j);\n            }\n        }\n        List<Boolean> res = new ArrayList<>();\n        for(int[] q : queries){\n            res.add(find(parent, q[0]) == find(parent, q[1]));\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "2043", "path": "output2\\java\\Hard\\2043-rank-transform-of-a-matrix.java", "hypo_code": "class RankTransformOfAMatrix {\n    public int[][] matrixRankTransform(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[] rowMax = new int[m];\n        int[] colMax = new int[n];\n        int[][] res = new int[m][n];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                rowMax[i] = Math.max(rowMax[i], matrix[i][j]);\n                colMax[j] = Math.max(colMax[j], matrix[i][j]);\n            }\n        }\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                res[i][j] = Math.max(rowMax[i], colMax[j]);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2044", "path": "output2\\java\\Hard\\2044-number-of-ways-to-form-a-target-string-given-a-dictionary.java", "hypo_code": "class NumberOfWaysToFormATargetStringGivenADictionary {\n    public int numWays(String[] words, String target) {\n        int n = words[0].length();\n        int m = target.length();\n        int[][] dp = new int[n][m];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(dp[i], -1);\n        }\n        return dfs(words, target, 0, 0, dp);\n        \n        \n    }\n}"}
{"id": "2045", "path": "output2\\java\\Hard\\2045-kth-smallest-instructions.java", "hypo_code": "class KthSmallestInstructions {\n    public String kthSmallestPath(int[] destination, int k) {\n        int row = destination[0];\n        int col = destination[1];\n        int[][] dp = new int[row + 1][col + 1];\n        dp[0][0] = 1;\n        for(int i = 1; i <= row; i++){\n            dp[i][0] = 1;\n        }\n        for(int i = 1; i <= col; i++){\n            dp[0][i] = 1;\n        }\n        for(int i = 1; i <= row; i++){\n            for(int j = 1; j <= col; j++){\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        while(row > 0 && col > 0){\n            if(dp[row - 1][col] >= k){\n                sb.append('H');\n                row--;\n            }else{\n                sb.append('V');\n                k -= dp[row - 1][col];\n                col--;\n            }\n        }\n        while(row > 0){\n            sb.append('H');\n            row--;\n        }\n        while(col > 0){\n            sb.append('V');\n            col--;\n        }\n        return sb.toString();\n        \n    }\n}"}
{"id": "2046", "path": "output2\\java\\Hard\\2046-create-sorted-array-through-instructions.java", "hypo_code": "class Solution {\n    public int createSortedArray(int[] instructions) {\n        int mod = 1000000007;\n        int len = instructions.length;\n        int[] bit = new int[100001];\n        int res = 0;\n        for(int i = 0; i < len; i++){\n            res = (res + Math.min(get(bit, instructions[i] - 1), i - get(bit, instructions[i]))) % mod;\n            update(bit, instructions[i]);\n        }\n        return res;\n    }\n    private void update(int[] bit, int i){\n        while(i < 100001){\n            bit[i]++;\n            i += i & (-i);\n        }\n    }\n    private int get(int[] bit, int i){\n        int res = 0;\n        while(i > 0){\n            res += bit[i];\n            i -= i & (-i);\n        }\n        return res;\n    }\n}"}
{"id": "2047", "path": "output2\\java\\Hard\\2047-distribute-repeating-integers.java", "hypo_code": "class DistributeRepeatingIntegers {\n    public boolean canDistribute(int[] nums, int[] quantity) {\n        int n = nums.length;\n        int m = quantity.length;\n        int[] count = new int[51];\n        for(int num : nums){\n            count[num]++;\n        }\n        int[] freq = new int[51];\n        for(int i = 1; i <= 50; i++){\n            if(count[i] > 0){\n                freq[count[i]]++;\n            }\n        }\n        int[] dp = new int[10001];\n        dp[0] = 1;\n        for(int i = 1; i <= 50; i++){\n            if(freq[i] > 0){\n                for(int j = 10000; j >= i; j--){\n                    if(dp[j - i] > 0){\n                        dp[j] = Math.max(dp[j], dp[j - i] + freq[i] - 1);\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < m; i++){\n            if(dp[quantity[i]] == 0){\n                return false;\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "2048", "path": "output2\\java\\Hard\\2048-maximize-grid-happiness.java", "hypo_code": "class Solution {\n    public int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n        int[][][] dp = new int[m + 1][n + 1][introvertsCount + 1];\n        for(int i = 0; i <= m; i++){\n            for(int j = 0; j <= n; j++){\n                Arrays.fill(dp[i][j], Integer.MIN_VALUE / 2);\n            }\n        }\n        dp[0][0][0] = 0;\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                for(int k = 0; k <= introvertsCount; k++){\n                    int l = i * j - k;\n                    if(l > extrovertsCount){\n                        continue;\n                    }\n                    for(int a = 0; a <= k; a++){\n                        int b = i * j - a;\n                        if(b > l){\n                            continue;\n                        }\n                        int cur = 0;\n                        if(a > 0){\n                            cur += 120;\n                        }\n                        if(b > 0){\n                            cur += 40;\n                        }\n                        if(a > 1){\n                            cur -= 30 * (a - 1);\n                        }\n                        if(b > 1){\n                            cur += 20 * (b - 1);\n                        }\n                        if(i > 1){\n                            cur -= 30 * (dp[i - 1][j][k - a] / 1000);\n                            cur -= 30 * (dp[i - 1][j][k - a] % 1000);\n                        }\n                        if(j > 1){\n                            cur -= 30 * (dp[i][j - 1][k - a] / 1000);\n                            cur -= 30 * (dp[i][j - 1][k - a] % 1000);\n                        }\n                        dp[i][j][k] = Math.max(dp[i][j][k], cur + dp[i - 1][j][k - a] % 1000 + dp[i][j - 1][k - a] % 1000);\n                    }\n                }\n            }\n        }\n        return dp[m][n][introvertsCount];\n        \n    }\n}"}
{"id": "2049", "path": "output2\\java\\Hard\\2049-minimum-initial-energy-to-finish-tasks.java", "hypo_code": "class MinimumInitialEnergyToFinishTasks {\n    public int minimumEffort(int[][] tasks) {\n        Arrays.sort(tasks, (a, b) -> (a[1] - a[0]) - (b[1] - b[0]));\n        int res = 0;\n        for(int i = tasks.length - 1; i >= 0; i--){\n            res = Math.max(res + tasks[i][0], tasks[i][1]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2050", "path": "output2\\java\\Hard\\2050-minimum-number-of-removals-to-make-mountain-array.java", "hypo_code": "class MinimumNumberOfRemovalsToMakeMountainArray {\n    public int minimumMountainRemovals(int[] nums) {\n        int n = nums.length;\n        int[] lis = new int[n];\n        int[] lds = new int[n];\n        Arrays.fill(lis, 1);\n        Arrays.fill(lds, 1);\n        for(int i = 1; i < n; i++){\n            for(int j = 0; j < i; j++){\n                if(nums[i] > nums[j]){\n                    lis[i] = Math.max(lis[i], lis[j] + 1);\n                }\n            }\n        }\n        for(int i = n - 2; i >= 0; i--){\n            for(int j = n - 1; j > i; j--){\n                if(nums[i] > nums[j]){\n                    lds[i] = Math.max(lds[i], lds[j] + 1);\n                }\n            }\n        }\n        int res = 0;\n        for(int i = 1; i < n - 1; i++){\n            if(lis[i] > 1 && lds[i] > 1){\n                res = Math.max(res, lis[i] + lds[i] - 1);\n            }\n        }\n        return n - res;\n        \n    }\n}"}
{"id": "2051", "path": "output2\\java\\Hard\\2051-minimize-deviation-in-array.java", "hypo_code": "class MinimizeDeviationInArray {\n    public int minimumDeviation(int[] nums) {\n        int n = nums.length;\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            if(nums[i] % 2 == 1){\n                nums[i] *= 2;\n            }\n            pq.add(nums[i]);\n            min = Math.min(min, nums[i]);\n        }\n        int res = Integer.MAX_VALUE;\n        while(!pq.isEmpty()){\n            int cur = pq.poll();\n            res = Math.min(res, cur - min);\n            if(cur % 2 == 0){\n                cur /= 2;\n                min = Math.min(min, cur);\n                pq.add(cur);\n            }else{\n                break;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2052", "path": "output2\\java\\Hard\\2052-minimum-incompatibility.java", "hypo_code": "class MinimumIncompatibility {\n    public int minimumIncompatibility(int[] nums, int k) {\n        int n = nums.length;\n        int m = n / k;\n        int[] count = new int[17];\n        for(int num : nums){\n            count[num]++;\n        }\n        for(int i = 1; i <= 16; i++){\n            if(count[i] > m){\n                return -1;\n            }\n        }\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, -1);\n        dp[0] = 0;\n        for(int i = 1; i < (1 << n); i++){\n            int[] freq = new int[17];\n            int max = 0;\n            int min = 17;\n            for(int j = 0; j < n; j++){\n                if(((i >> j) & 1) == 1){\n                    freq[nums[j]]++;\n                    max = Math.max(max, nums[j]);\n                    min = Math.min(min, nums[j]);\n                }\n            }\n            boolean valid = true;\n            for(int j = 1; j <= 16; j++){\n                if(freq[j] > 1){\n                    valid = false;\n                    break;\n                }\n            }\n            if(valid){\n                dp[i] = max - min;\n            }\n        }\n        for(int i = 1; i < k; i++){\n            for(int j = 0; j < (1 << n); j++){\n                if(dp[j] != -1){\n                    for(int l = j; l < (1 << n); l = (l + 1) | j){\n                        if(dp[l] != -1){\n                            dp[j | l] = Math.max(dp[j | l], dp[j] + dp[l]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n        \n    }\n}"}
{"id": "2053", "path": "output2\\java\\Hard\\2053-delivering-boxes-from-storage-to-ports.java", "hypo_code": "class DeliveringBoxesFromStorageToPorts {\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\n        int n = boxes.length;\n        int[] dp = new int[n + 1];\n        int[] next = new int[n];\n        int j = n;\n        int weight = 0;\n        for(int i = n - 1; i >= 0; i--){\n            weight += boxes[i][1];\n            while(j > i && (j - i > maxBoxes || weight > maxWeight)){\n                j--;\n                weight -= boxes[j][1];\n            }\n            next[i] = j;\n        }\n        int port = -1;\n        for(int i = n - 1; i >= 0; i--){\n            while(next[i] < n && boxes[next[i]][0] == boxes[next[i] - 1][0]){\n                next[i] = next[next[i]];\n            }\n            dp[i] = dp[next[i]] + 1;\n            if(boxes[i][0] != port){\n                port = boxes[i][0];\n                dp[i]++;\n            }\n        }\n        return dp[0];\n        \n    }\n}"}
{"id": "2054", "path": "output2\\java\\Hard\\2054-maximum-height-by-stacking-cuboids.java", "hypo_code": "class MaximumHeightByStackingCuboids {\n    public int maxHeight(int[][] cuboids) {\n        int n = cuboids.length;\n        for(int[] cuboid : cuboids){\n            Arrays.sort(cuboid);\n        }\n        Arrays.sort(cuboids, (a, b) -> {\n            if(a[0] == b[0]){\n                if(a[1] == b[1]){\n                    return a[2] - b[2];\n                }\n                return a[1] - b[1];\n            }\n            return a[0] - b[0];\n        });\n        int[] dp = new int[n];\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            dp[i] = cuboids[i][2];\n            for(int j = 0; j < i; j++){\n                if(cuboids[j][0] <= cuboids[i][0] && cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2]){\n                    dp[i] = Math.max(dp[i], dp[j] + cuboids[i][2]);\n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2055", "path": "output2\\java\\Hard\\2055-checking-existence-of-edge-length-limited-paths.java", "hypo_code": "class CheckingExistenceOfEdgeLengthLimitedPaths {\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\n        int m = queries.length;\n        int[] res = new int[m];\n        int[] parent = new int[n];\n        for(int i = 0; i < n; i++){\n            parent[i] = i;\n        }\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\n        int[][] q = new int[m][4];\n        for(int i = 0; i < m; i++){\n            q[i][0] = queries[i][0];\n            q[i][1] = queries[i][1];\n            q[i][2] = queries[i][2];\n            q[i][3] = i;\n        }\n        Arrays.sort(q, (a, b) -> a[2] - b[2]);\n        int j = 0;\n        for(int i = 0; i < m; i++){\n            while(j < edgeList.length && edgeList[j][2] < q[i][2]){\n                union(parent, edgeList[j][0], edgeList[j][1]);\n                j++;\n            }\n            res[q[i][3]] = find(parent, q[i][0]) == find(parent, q[i][1]) ? 1 : 0;\n        }\n        boolean[] ans = new boolean[m];\n        for(int i = 0; i < m; i++){\n            ans[i] = res[i] == 1;\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2056", "path": "output2\\java\\Hard\\2056-minimum-adjacent-swaps-for-k-consecutive-ones.java", "hypo_code": "class MinimumAdjacentSwapsForKConsecutiveOnes {\n    public int minMoves(int[] nums, int k) {\n        int n = nums.length;\n        int[] ones = new int[k];\n        int idx = 0;\n        for(int i = 0; i < n; i++){\n            if(nums[i] == 1){\n                ones[idx++] = i;\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        int mid = k / 2;\n        for(int i = 0; i < k - mid; i++){\n            int cost = 0;\n            for(int j = i; j < i + mid; j++){\n                cost += ones[j + mid] - ones[j];\n            }\n            res = Math.min(res, cost);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2057", "path": "output2\\java\\Hard\\2057-maximum-xor-with-an-element-from-array.java", "hypo_code": "class MaximumXorWithAnElementFromArray {\n    public int[] maximizeXor(int[] nums, int[][] queries) {\n        int n = nums.length;\n        int m = queries.length;\n        int[] ans = new int[m];\n        Arrays.sort(nums);\n        int[][] q = new int[m][3];\n        for(int i = 0; i < m; i++){\n            q[i][0] = queries[i][0];\n            q[i][1] = queries[i][1];\n            q[i][2] = i;\n        }\n        Arrays.sort(q, (a, b) -> a[1] - b[1]);\n        int[] dp = new int[1 << 17];\n        Arrays.fill(dp, -1);\n        dp[0] = 0;\n        for(int i = 1; i < (1 << 17); i++){\n            int[] freq = new int[17];\n            int max = 0;\n            int min = 17;\n            for(int j = 0; j < 17; j++){\n                if(((i >> j) & 1) == 1){\n                    freq[j]++;\n                    max = Math.max(max, j);\n                    min = Math.min(min, j);\n                }\n            }\n            boolean valid = true;\n            for(int j = 1; j <= 16; j++){\n                if(freq[j] > 1){\n                    valid = false;\n                    break;\n                }\n            }\n            if(valid){\n                dp[i] = max - min;\n            }\n        }\n        int j = 0;\n        for(int i = 0; i < m; i++){\n            while(j < n && nums[j] <= q[i][1]){\n                j++;\n            }\n            if(j == 0){\n                ans[q[i][2]] = -1;\n            }\n            else{\n                int[] freq = new int[17];\n                for(int k = 0; k < j; k++){\n                    freq[nums[k]]++;\n                }\n                int mask = 0;\n                for(int k = 16; k >= 0; k--){\n                    if(freq[k] > 0){\n                        mask |= (1 << k);\n                    }\n                }\n                ans[q[i][2]] = dp[mask] ^ q[i][0];\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2058", "path": "output2\\java\\Hard\\2058-minimum-operations-to-make-a-subsequence.java", "hypo_code": "class MinimumOperationsToMakeASubsequence {\n    public int minOperations(int[] target, int[] arr) {\n        int n = target.length;\n        int m = arr.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            map.put(target[i], i);\n        }\n        List<Integer> list = new ArrayList<>();\n        for(int i = 0; i < m; i++){\n            if(map.containsKey(arr[i])){\n                list.add(map.get(arr[i]));\n            }\n        }\n        int[] dp = new int[list.size()];\n        int len = 0;\n        for(int num : list){\n            int i = Arrays.binarySearch(dp, 0, len, num);\n            if(i < 0){\n                i = -(i + 1);\n            }\n            dp[i] = num;\n            if(i == len){\n                len++;\n            }\n        }\n        return n - len;\n        \n    }\n}"}
{"id": "2059", "path": "output2\\java\\Hard\\2059-number-of-ways-to-reconstruct-a-tree.java", "hypo_code": "class NumberOfWaysToReconstructATree {\n    public int checkWays(int[][] pairs) {\n        int n = pairs.length;\n        int[] parent = new int[n];\n        for(int i = 0; i < n; i++){\n            parent[i] = i;\n        }\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(pairs[i][0] == pairs[j][0] || pairs[i][0] == pairs[j][1] || pairs[i][1] == pairs[j][0] || pairs[i][1] == pairs[j][1]){\n                    union(parent, i, j);\n                }\n            }\n        }\n        int[] count = new int[n];\n        for(int i = 0; i < n; i++){\n            count[find(parent, i)]++;\n        }\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            if(count[i] > 0){\n                res++;\n            }\n        }\n        return res == 1 ? 1 : 2;\n        \n        \n    }\n}"}
{"id": "2060", "path": "output2\\java\\Hard\\2060-find-minimum-time-to-finish-all-jobs.java", "hypo_code": "class FindMinimumTimeToFinishAllJobs {\n    public int minimumTimeRequired(int[] jobs, int k) {\n        int n = jobs.length;\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, Integer.MAX_VALUE / 2);\n        dp[0] = 0;\n        for(int mask = 1; mask < (1 << n); mask++){\n            int sum = 0;\n            for(int i = 0; i < n; i++){\n                if(((mask >> i) & 1) > 0){\n                    sum += jobs[i];\n                }\n            }\n            for(int i = 0; i < n; i++){\n                if(((mask >> i) & 1) > 0){\n                    dp[mask] = Math.min(dp[mask], Math.max(dp[mask ^ (1 << i)], sum));\n                }\n            }\n        }\n        return dp[(1 << n) - 1];\n        \n    }\n}"}
{"id": "2061", "path": "output2\\java\\Hard\\2061-cat-and-mouse-ii.java", "hypo_code": "class CatAndMouseIi {\n    public boolean canMouseWin(String[] grid, int catJump, int mouseJump) {\n        int m = grid.length;\n        int n = grid[0].length();\n        int[][][] dp = new int[m][n][m * n + 1];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n        int[] cat = new int[2];\n        int[] mouse = new int[2];\n        int[] food = new int[2];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i].charAt(j) == 'C'){\n                    cat[0] = i;\n                    cat[1] = j;\n                }\n                else if(grid[i].charAt(j) == 'M'){\n                    mouse[0] = i;\n                    mouse[1] = j;\n                }\n                else if(grid[i].charAt(j) == 'F'){\n                    food[0] = i;\n                    food[1] = j;\n                }\n            }\n        }\n        return dfs(grid, cat, mouse, food, catJump, mouseJump, dp);\n        \n    }\n}"}
{"id": "2062", "path": "output2\\java\\Hard\\2062-count-ways-to-make-array-with-product.java", "hypo_code": "class CountWaysToMakeArrayWithProduct {\n    public int[] waysToFillArray(int[][] queries) {\n        int n = queries.length;\n        int[] res = new int[n];\n        int mod = (int)1e9 + 7;\n        for(int i = 0; i < n; i++){\n            int[] q = queries[i];\n            int len = q[0];\n            int prod = q[1];\n            int[] dp = new int[prod + 1];\n            dp[1] = 1;\n            for(int j = 2; j <= prod; j++){\n                for(int k = 1; k <= len; k++){\n                    if(j % k == 0){\n                        dp[j] = (dp[j] + dp[j / k]) % mod;\n                    }\n                }\n            }\n            res[i] = dp[prod];\n        }\n        return res;\n        \n    }\n}"}
{"id": "2063", "path": "output2\\java\\Hard\\2063-building-boxes.java", "hypo_code": "class BuildingBoxes {\n    public int minimumBoxes(int n) {\n        int res = 0;\n        int i = 1;\n        while(n > 0){\n            n -= i;\n            res += i;\n            i++;\n        }\n        if(n < 0){\n            res += n;\n        }\n        return res;\n        \n    }\n}"}
{"id": "2064", "path": "output2\\java\\Hard\\2064-palindrome-partitioning-iv.java", "hypo_code": "class PalindromePartitioningIv {\n    public boolean checkPartitioning(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        for(int i = 0; i < n; i++){\n            dp[i][i] = true;\n        }\n        for(int i = 0; i < n - 1; i++){\n            dp[i][i + 1] = s.charAt(i) == s.charAt(i + 1);\n        }\n        for(int len = 3; len <= n; len++){\n            for(int i = 0; i + len - 1 < n; i++){\n                int j = i + len - 1;\n                dp[i][j] = dp[i + 1][j - 1] && s.charAt(i) == s.charAt(j);\n            }\n        }\n        for(int i = 0; i < n - 2; i++){\n            if(dp[0][i]){\n                for(int j = i + 1; j < n - 1; j++){\n                    if(dp[i + 1][j] && dp[j + 1][n - 1]){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "2065", "path": "output2\\java\\Hard\\2065-maximum-number-of-events-that-can-be-attended-ii.java", "hypo_code": "class MaximumNumberOfEventsThatCanBeAttendedIi {\n    public int maxValue(int[][] events, int k) {\n        int n = events.length;\n        Arrays.sort(events, (a, b) -> a[1] - b[1]);\n        int[] dp = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            int[] event = events[i - 1];\n            int start = event[0];\n            int end = event[1];\n            int value = event[2];\n            int idx = binarySearch(events, start);\n            dp[i] = Math.max(dp[i - 1], value + dp[idx]);\n        }\n        return dp[n];\n        \n        \n    }\n}"}
{"id": "2066", "path": "output2\\java\\Hard\\2066-closest-subsequence-sum.java", "hypo_code": "class ClosestSubsequenceSum {\n    public int minAbsDifference(int[] nums, int goal) {\n        int n = nums.length;\n        int m = n / 2;\n        int[] left = new int[1 << m];\n        int[] right = new int[1 << (n - m)];\n        for(int i = 0; i < (1 << m); i++){\n            for(int j = 0; j < m; j++){\n                if(((i >> j) & 1) == 1){\n                    left[i] += nums[j];\n                }\n            }\n        }\n        for(int i = 0; i < (1 << (n - m)); i++){\n            for(int j = 0; j < n - m; j++){\n                if(((i >> j) & 1) == 1){\n                    right[i] += nums[m + j];\n                }\n            }\n        }\n        Arrays.sort(left);\n        Arrays.sort(right);\n        int res = Integer.MAX_VALUE;\n        for(int i = 0; i < (1 << m); i++){\n            int idx = Arrays.binarySearch(right, goal - left[i]);\n            if(idx >= 0){\n                return 0;\n            }\n            idx = -idx - 1;\n            if(idx < (1 << (n - m))){\n                res = Math.min(res, Math.abs(goal - left[i] - right[idx]));\n            }\n            if(idx > 0){\n                res = Math.min(res, Math.abs(goal - left[i] - right[idx - 1]));\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2067", "path": "output2\\java\\Hard\\2067-minimum-degree-of-a-connected-trio-in-a-graph.java", "hypo_code": "class MinimumDegreeOfAConnectedTrioInAGraph {\n    public int minTrioDegree(int n, int[][] edges) {\n        int[] degree = new int[n + 1];\n        boolean[][] graph = new boolean[n + 1][n + 1];\n        for(int[] edge : edges){\n            int u = edge[0];\n            int v = edge[1];\n            degree[u]++;\n            degree[v]++;\n            graph[u][v] = true;\n            graph[v][u] = true;\n        }\n        int res = Integer.MAX_VALUE;\n        for(int i = 1; i <= n; i++){\n            for(int j = i + 1; j <= n; j++){\n                if(graph[i][j]){\n                    for(int k = j + 1; k <= n; k++){\n                        if(graph[i][k] && graph[j][k]){\n                            res = Math.min(res, degree[i] + degree[j] + degree[k] - 6);\n                        }\n                    }\n                }\n            }\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n        \n    }\n}"}
{"id": "2068", "path": "output2\\java\\Hard\\2068-tree-of-coprimes.java", "hypo_code": "class TreeOfCoprimes {\n    public int[] getCoprimes(int[] nums, int[][] edges) {\n        int n = nums.length;\n        int[] res = new int[n];\n        Arrays.fill(res, -1);\n        List<Integer>[] graph = new List[n];\n        for(int i = 0; i < n; i++){\n            graph[i] = new ArrayList<>();\n        }\n        for(int[] edge : edges){\n            int u = edge[0];\n            int v = edge[1];\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        dfs(graph, nums, res, 0, -1, new int[51]);\n        return res;\n        \n        \n    }\n}"}
{"id": "2069", "path": "output2\\java\\Hard\\2069-maximum-score-from-performing-multiplication-operations.java", "hypo_code": "class MaximumScoreFromPerformingMultiplicationOperations {\n    public int maximumScore(int[] nums, int[] multipliers) {\n        int n = nums.length;\n        int m = multipliers.length;\n        int[][] dp = new int[m + 1][m + 1];\n        for(int i = 1; i <= m; i++){\n            dp[i][0] = dp[i - 1][0] + multipliers[i - 1] * nums[i - 1];\n        }\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= i; j++){\n                dp[i][j] = Math.max(dp[i - 1][j - 1] + multipliers[i - 1] * nums[j - 1], dp[i - 1][j] + multipliers[i - 1] * nums[n - i + j - 1]);\n            }\n        }\n        int res = Integer.MIN_VALUE;\n        for(int i = 0; i <= m; i++){\n            res = Math.max(res, dp[m][i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2070", "path": "output2\\java\\Hard\\2070-maximize-palindrome-length-from-subsequences.java", "hypo_code": "class MaximizePalindromeLengthFromSubsequences {\n    public int longestPalindrome(String word1, String word2) {\n        String s = word1 + word2;\n        int n = s.length();\n        int m = word1.length();\n        int[][] dp = new int[n][n];\n        for(int i = 0; i < n; i++){\n            dp[i][i] = 1;\n        }\n        for(int i = 0; i < n - 1; i++){\n            if(s.charAt(i) == s.charAt(i + 1)){\n                dp[i][i + 1] = 2;\n            }\n        }\n        for(int len = 3; len <= n; len++){\n            for(int i = 0; i + len - 1 < n; i++){\n                int j = i + len - 1;\n                if(s.charAt(i) == s.charAt(j)){\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\n                }\n                else{\n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = m; j < n; j++){\n                if(s.charAt(i) == s.charAt(j)){\n                    res = Math.max(res, dp[i][j]);\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2071", "path": "output2\\java\\Hard\\2071-car-fleet-ii.java", "hypo_code": "class CarFleetIi {\n    public double[] getCollisionTimes(int[][] cars) {\n        int n = cars.length;\n        double[] res = new double[n];\n        Arrays.fill(res, -1);\n        Stack<Integer> stack = new Stack<>();\n        for(int i = n - 1; i >= 0; i--){\n            int[] car = cars[i];\n            int pos = car[0];\n            int speed = car[1];\n            while(!stack.isEmpty()){\n                int[] top = cars[stack.peek()];\n                int topPos = top[0];\n                int topSpeed = top[1];\n                if(speed <= topSpeed || (res[stack.peek()] > 0 && (double)(topPos - pos) / (speed - topSpeed) >= res[stack.peek()])){\n                    stack.pop();\n                }else{\n                    break;\n                }\n            }\n            if(!stack.isEmpty()){\n                int[] top = cars[stack.peek()];\n                int topPos = top[0];\n                int topSpeed = top[1];\n                res[i] = (double)(topPos - pos) / (speed - topSpeed);\n            }\n            stack.push(i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2072", "path": "output2\\java\\Hard\\2072-count-pairs-of-nodes.java", "hypo_code": "class CountPairsOfNodes {\n    public int[] countPairs(int n, int[][] edges, int[] queries) {\n        int[] ans = new int[queries.length];\n        int[] degree = new int[n];\n        int[][] count = new int[n][n];\n        for (int[] edge : edges) {\n            int u = edge[0] - 1;\n            int v = edge[1] - 1;\n            degree[u]++;\n            degree[v]++;\n            count[u][v]++;\n            count[v][u]++;\n        }\n        for (int i = 0; i < queries.length; i++) {\n            int q = queries[i];\n            int total = 0;\n            for (int j = 0; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if (degree[j] + degree[k] > q && degree[j] + degree[k] - count[j][k] <= q) {\n                        total++;\n                    }\n                }\n            }\n            ans[i] = total;\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2073", "path": "output2\\java\\Hard\\2073-make-the-xor-of-all-segments-equal-to-zero.java", "hypo_code": "class MakeTheXorOfAllSegmentsEqualToZero {\n    public int minChanges(int[] nums, int k) {\n        int n = nums.length;\n        int[] f = new int[1 << 10];\n        Arrays.fill(f, n);\n        f[0] = 0;\n        for (int i = 0; i < k; i++) {\n            int cnt = 0;\n            int[] g = new int[1 << 10];\n            Arrays.fill(g, n);\n            int[] cnts = new int[1 << 10];\n            for (int j = i; j < n; j += k) {\n                cnts[nums[j]]++;\n                cnt++;\n            }\n            for (int mask = 0; mask < 1 << 10; mask++) {\n                g[mask] = Math.min(g[mask], f[mask] + cnt);\n                for (int j = 0; j < 1 << 10; j++) {\n                    g[j ^ mask] = Math.min(g[j ^ mask], f[mask] + cnt - cnts[j]);\n                }\n            }\n            f = g;\n        }\n        return f[0];\n        \n    }\n}"}
{"id": "2074", "path": "output2\\java\\Hard\\2074-maximum-score-of-a-good-subarray.java", "hypo_code": "class MaximumScoreOfAGoodSubarray {\n    public int maximumScore(int[] nums, int k) {\n        int n = nums.length;\n        int res = nums[k];\n        int left = k;\n        int right = k;\n        int min = nums[k];\n        while(left > 0 || right < n - 1){\n            if(left == 0){\n                right++;\n            }else if(right == n - 1){\n                left--;\n            }else if(nums[left - 1] > nums[right + 1]){\n                left--;\n            }else{\n                right++;\n            }\n            min = Math.min(min, Math.min(nums[left], nums[right]));\n            res = Math.max(res, min * (right - left + 1));\n        }\n        return res;\n        \n    }\n}"}
{"id": "2075", "path": "output2\\java\\Hard\\2075-maximize-score-after-n-operations.java", "hypo_code": "class MaximizeScoreAfterNOperations {\n    public int maxScore(int[] nums) {\n        int n = nums.length;\n        int[][] dp = new int[n][n];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = gcd(nums[i], nums[j]);\n            }\n        }\n        int[][] memo = new int[n][1 << n];\n        return dfs(0, 0, dp, memo);\n        \n    }\n}"}
{"id": "2076", "path": "output2\\java\\Hard\\2076-count-pairs-with-xor-in-a-range.java", "hypo_code": "class CountPairsWithXorInARange {\n    public int countPairs(int[] nums, int low, int high) {\n        int n = nums.length;\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                int xor = nums[i] ^ nums[j];\n                if(xor >= low && xor <= high){\n                    res++;\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2077", "path": "output2\\java\\Hard\\2077-maximize-number-of-nice-divisors.java", "hypo_code": "class MaximizeNumberOfNiceDivisors {\n    public int maxNiceDivisors(int primeFactors) {\n        if(primeFactors == 1){\n            return 1;\n        }\n        if(primeFactors == 2){\n            return 2;\n        }\n        if(primeFactors == 3){\n            return 3;\n        }\n        int mod = 1000000007;\n        int a = primeFactors / 3;\n        int b = primeFactors % 3;\n        if(b == 0){\n            return (int)(pow(3, a, mod) % mod);\n        }\n        if(b == 1){\n            return (int)(pow(3, a - 1, mod) * 4 % mod);\n        }\n        return (int)(pow(3, a, mod) * 2 % mod);\n        \n        \n    }\n}"}
{"id": "2078", "path": "output2\\java\\Hard\\2078-maximum-number-of-groups-getting-fresh-donuts.java", "hypo_code": "class MaximumNumberOfGroupsGettingFreshDonuts {\n    public int maxHappyGroups(int batchSize, int[] groups) {\n        int n = groups.length;\n        int[] count = new int[batchSize];\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            if(groups[i] % batchSize == 0){\n                res++;\n            }else{\n                count[groups[i] % batchSize]++;\n            }\n        }\n        int[] dp = new int[batchSize];\n        for(int i = 1; i < batchSize; i++){\n            dp[i] = count[i];\n        }\n        for(int i = 1; i < batchSize; i++){\n            for(int j = 1; j < batchSize; j++){\n                if(i + j < batchSize){\n                    dp[i + j] = Math.max(dp[i + j], dp[i] + count[j]);\n                }else{\n                    dp[(i + j) % batchSize] = Math.max(dp[(i + j) % batchSize], dp[i] + count[j] + 1);\n                }\n            }\n        }\n        return res + dp[0];\n        \n    }\n}"}
{"id": "2079", "path": "output2\\java\\Hard\\2079-number-of-different-subsequences-gcds.java", "hypo_code": "class NumberOfDifferentSubsequencesGcds {\n    public int countDifferentSubsequenceGCDs(int[] nums) {\n        int n = nums.length;\n        int max = 0;\n        for(int num : nums){\n            max = Math.max(max, num);\n        }\n        boolean[] seen = new boolean[max + 1];\n        for(int num : nums){\n            seen[num] = true;\n        }\n        int res = 0;\n        for(int i = 1; i <= max; i++){\n            int gcd = 0;\n            for(int j = i; j <= max; j += i){\n                if(seen[j]){\n                    gcd = gcd(gcd, j);\n                }\n            }\n            if(gcd == i){\n                res++;\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "2081", "path": "output2\\java\\Hard\\2081-minimum-number-of-operations-to-make-string-sorted.java", "hypo_code": "class MinimumNumberOfOperationsToMakeStringSorted {\n    public int makeStringSorted(String s) {\n        int n = s.length();\n        int[] fact = new int[n + 1];\n        fact[0] = 1;\n        for(int i = 1; i <= n; i++){\n            fact[i] = (int)((long)fact[i - 1] * i % 1000000007);\n        }\n        int[] count = new int[26];\n        int res = 0;\n        for(int i = n - 1; i >= 0; i--){\n            int c = s.charAt(i) - 'a';\n            for(int j = 0; j < c; j++){\n                res = (res + count[j]) % 1000000007;\n            }\n            count[c]++;\n        }\n        for(int i = 0; i < n; i++){\n            int c = s.charAt(i) - 'a';\n            res = (int)((long)res * fact[n - i - 1] % 1000000007);\n            for(int j = 0; j < c; j++){\n                count[j]--;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2082", "path": "output2\\java\\Hard\\2082-find-xor-sum-of-all-pairs-bitwise-and.java", "hypo_code": "class FindXorSumOfAllPairsBitwiseAnd {\n    public int getXORSum(int[] arr1, int[] arr2) {\n        int n = arr1.length;\n        int m = arr2.length;\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                res ^= arr1[i] & arr2[j];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2083", "path": "output2\\java\\Hard\\2083-maximum-building-height.java", "hypo_code": "class MaximumBuildingHeight {\n    public int maxBuilding(int n, int[][] restrictions) {\n        Arrays.sort(restrictions, (a, b) -> a[0] - b[0]);\n        int m = restrictions.length;\n        int[][] dp = new int[m][2];\n        for(int i = 0; i < m; i++){\n            dp[i][0] = restrictions[i][0];\n            dp[i][1] = restrictions[i][1];\n        }\n        for(int i = 1; i < m; i++){\n            dp[i][1] = Math.min(dp[i][1], dp[i - 1][1] + dp[i][0] - dp[i - 1][0]);\n        }\n        for(int i = m - 2; i >= 0; i--){\n            dp[i][1] = Math.min(dp[i][1], dp[i + 1][1] + dp[i + 1][0] - dp[i][0]);\n        }\n        int res = 0;\n        for(int i = 0; i < m - 1; i++){\n            int left = dp[i][0];\n            int right = dp[i + 1][0];\n            int height = Math.min(dp[i][1], dp[i + 1][1]);\n            res = Math.max(res, height + (right - left - 1) / 2);\n        }\n        if(m == 0 || dp[0][0] != 1){\n            res = Math.max(res, dp[0][1] + dp[0][0] - 1);\n        }\n        if(m == 0 || dp[m - 1][0] != n){\n            res = Math.max(res, dp[m - 1][1] + n - dp[m - 1][0]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2084", "path": "output2\\java\\Hard\\2084-closest-room.java", "hypo_code": "class ClosestRoom {\n    public int[] closestRoom(int[][] rooms, int[][] queries) {\n        int n = rooms.length;\n        int m = queries.length;\n        int[] res = new int[m];\n        Arrays.fill(res, -1);\n        int[][] qs = new int[m][3];\n        for(int i = 0; i < m; i++){\n            qs[i][0] = queries[i][0];\n            qs[i][1] = queries[i][1];\n            qs[i][2] = i;\n        }\n        Arrays.sort(rooms, (a, b) -> b[1] - a[1]);\n        Arrays.sort(qs, (a, b) -> b[1] - a[1]);\n        TreeSet<Integer> set = new TreeSet<>();\n        int j = 0;\n        for(int i = 0; i < m; i++){\n            while(j < n && rooms[j][1] >= qs[i][1]){\n                set.add(rooms[j][0]);\n                j++;\n            }\n            Integer l = set.floor(qs[i][0]);\n            Integer r = set.ceiling(qs[i][0]);\n            if(l == null && r == null){\n                continue;\n            }\n            if(l == null){\n                res[qs[i][2]] = r;\n            }else if(r == null){\n                res[qs[i][2]] = l;\n            }else{\n                if(Math.abs(l - qs[i][0]) <= Math.abs(r - qs[i][0])){\n                    res[qs[i][2]] = l;\n                }else{\n                    res[qs[i][2]] = r;\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2085", "path": "output2\\java\\Hard\\2085-minimum-interval-to-include-each-query.java", "hypo_code": "class MinimumIntervalToIncludeEachQuery {\n    public int[] minInterval(int[][] intervals, int[] queries) {\n        int n = intervals.length;\n        int m = queries.length;\n        int[] res = new int[m];\n        Arrays.fill(res, -1);\n        int[][] qs = new int[m][2];\n        for(int i = 0; i < m; i++){\n            qs[i][0] = queries[i];\n            qs[i][1] = i;\n        }\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        Arrays.sort(qs, (a, b) -> a[0] - b[0]);\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        int j = 0;\n        for(int i = 0; i < m; i++){\n            while(j < n && intervals[j][0] <= qs[i][0]){\n                pq.offer(intervals[j]);\n                j++;\n            }\n            while(!pq.isEmpty() && pq.peek()[1] < qs[i][0]){\n                pq.poll();\n            }\n            if(!pq.isEmpty()){\n                res[qs[i][1]] = pq.peek()[1] - pq.peek()[0] + 1;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2086", "path": "output2\\java\\Hard\\2086-largest-color-value-in-a-directed-graph.java", "hypo_code": "class LargestColorValueInADirectedGraph {\n    public int largestPathValue(String colors, int[][] edges) {\n        int n = colors.length();\n        int[][] g = new int[n][n];\n        int[] inDegree = new int[n];\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            g[u][v] = 1;\n            inDegree[v]++;\n        }\n        int[] queue = new int[n];\n        int head = 0;\n        int tail = 0;\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                queue[tail++] = i;\n            }\n        }\n        int[] colorCount = new int[26];\n        int[] maxColorCount = new int[n];\n        int[] maxColor = new int[n];\n        int[] color = new int[n];\n        while (head < tail) {\n            int u = queue[head++];\n            colorCount[color[u]]--;\n            for (int v = 0; v < n; v++) {\n                if (g[u][v] == 1) {\n                    if (color[u] == color[v]) {\n                        maxColorCount[v] = Math.max(maxColorCount[v], maxColorCount[u] + 1);\n                    } else if (colorCount[color[u]] < colorCount[color[v]]) {\n                        maxColorCount[v] = maxColorCount[u] + 1;\n                        maxColor[v] = color[v];\n                    } else {\n                        maxColorCount[v] = maxColorCount[u];\n                        maxColor[v] = maxColor[u];\n                    }\n                    if (--inDegree[v] == 0) {\n                        queue[tail++] = v;\n                    }\n                }\n            }\n            colorCount[color[u]]++;\n        }\n        if (tail < n) {\n            return -1;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = Math.max(ans, maxColorCount[i] + 1);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2087", "path": "output2\\java\\Hard\\2087-sum-of-floored-pairs.java", "hypo_code": "class SumOfFlooredPairs {\n    public int sumOfFlooredPairs(int[] nums) {\n        int n = nums.length;\n        int max = 0;\n        for(int num : nums){\n            max = Math.max(max, num);\n        }\n        int[] count = new int[max + 1];\n        for(int num : nums){\n            count[num]++;\n        }\n        int[] sum = new int[max + 1];\n        for(int i = 1; i <= max; i++){\n            sum[i] = sum[i - 1] + count[i];\n        }\n        int res = 0;\n        for(int i = 1; i <= max; i++){\n            for(int j = i; j <= max; j += i){\n                res = (res + (int)((long)count[i] * (sum[Math.min(max, j + i - 1)] - sum[j - 1]) % 1000000007)) % 1000000007;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2088", "path": "output2\\java\\Hard\\2088-number-of-ways-to-rearrange-sticks-with-k-sticks-visible.java", "hypo_code": "class NumberOfWaysToRearrangeSticksWithKSticksVisible {\n    public int rearrangeSticks(int n, int k) {\n        int mod = 1000000007;\n        long[][] dp = new long[n + 1][k + 1];\n        dp[0][0] = 1;\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= k; j++){\n                dp[i][j] = (dp[i - 1][j - 1] + (dp[i - 1][j] * (i - 1)) % mod) % mod;\n            }\n        }\n        return (int)dp[n][k];\n        \n    }\n}"}
{"id": "2089", "path": "output2\\java\\Hard\\2089-stone-game-viii.java", "hypo_code": "class StoneGameViii {\n    public int stoneGameVIII(int[] stones) {\n        int n = stones.length;\n        int[] prefix = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            prefix[i] = prefix[i - 1] + stones[i - 1];\n        }\n        int[] dp = new int[n];\n        dp[n - 1] = prefix[n];\n        for(int i = n - 2; i >= 0; i--){\n            dp[i] = Math.max(dp[i + 1], prefix[i + 1] - dp[i + 1]);\n        }\n        return dp[0];\n        \n\n    }\n}"}
{"id": "2090", "path": "output2\\java\\Hard\\2090-minimum-xor-sum-of-two-arrays.java", "hypo_code": "class MinimumXorSumOfTwoArrays {\n    public int minimumXORSum(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int[][] dp = new int[n][1 << n];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        return dfs(0, 0, nums1, nums2, dp);\n        \n        \n    }\n}"}
{"id": "2091", "path": "output2\\java\\Hard\\2091-minimum-skips-to-arrive-at-meeting-on-time.java", "hypo_code": "class MinimumSkipsToArriveAtMeetingOnTime {\n    public int minSkips(int[] dist, int speed, int hoursBefore) {\n        int n = dist.length;\n        int[][] dp = new int[n + 1][n + 1];\n        for(int i = 0; i <= n; i++){\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        dp[0][0] = 0;\n        for(int i = 1; i <= n; i++){\n            int d = dist[i - 1];\n            for(int j = 0; j <= i; j++){\n                if(dp[i - 1][j] != Integer.MAX_VALUE){\n                    dp[i][j] = Math.min(dp[i][j], (dp[i - 1][j] + d + speed - 1) / speed * speed);\n                }\n                if(j > 0 && dp[i - 1][j - 1] != Integer.MAX_VALUE){\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + d);\n                }\n            }\n        }\n        for(int i = 0; i <= n; i++){\n            if(dp[n][i] <= hoursBefore * speed){\n                return i;\n            }\n        }\n        return -1;\n        \n    }\n}"}
{"id": "2092", "path": "output2\\java\\Hard\\2092-minimum-space-wasted-from-packaging.java", "hypo_code": "class MinimumSpaceWastedFromPackaging {\n    public int minWastedSpace(int[] packages, int[][] boxes) {\n        int mod = 1000000007;\n        Arrays.sort(packages);\n        int n = packages.length;\n        int[][] dp = new int[boxes.length][n];\n        for(int i = 0; i < boxes.length; i++){\n            Arrays.sort(boxes[i]);\n            int j = 0;\n            for(int k = 0; k < boxes[i].length; k++){\n                while(j < n && packages[j] <= boxes[i][k]){\n                    dp[i][j] = boxes[i][k];\n                    j++;\n                }\n            }\n            if(j < n){\n                dp[i][j] = -1;\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for(int i = 0; i < boxes.length; i++){\n            int sum = 0;\n            for(int j = 0; j < n; j++){\n                if(dp[i][j] == -1){\n                    sum = -1;\n                    break;\n                }\n                sum += dp[i][j] - packages[j];\n            }\n            if(sum != -1){\n                ans = Math.min(ans, sum);\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans % mod;\n        \n    }\n}"}
{"id": "2093", "path": "output2\\java\\Hard\\2093-minimum-cost-to-change-the-final-value-of-expression.java", "hypo_code": "class MinimumCostToChangeTheFinalValueOfExpression {\n    public int minOperationsToFlip(String expression) {\n        int n = expression.length();\n        int[][] dp = new int[n][n];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        return dfs(0, n - 1, expression, dp);\n        \n        \n        \n    }\n}"}
{"id": "2094", "path": "output2\\java\\Hard\\2094-the-earliest-and-latest-rounds-where-players-compete.java", "hypo_code": "class TheEarliestAndLatestRoundsWherePlayersCompete {\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n        int[] res = new int[2];\n        if(firstPlayer > secondPlayer){\n            int temp = firstPlayer;\n            firstPlayer = secondPlayer;\n            secondPlayer = temp;\n        }\n        int round = 0;\n        while(n > 1){\n            round++;\n            if(firstPlayer % 2 == 1 && secondPlayer == firstPlayer + 1){\n                res[0] = round;\n                res[1] = round;\n                break;\n            }\n            if(firstPlayer % 2 == 1){\n                firstPlayer = (firstPlayer + 1) / 2;\n            }else{\n                firstPlayer = firstPlayer / 2;\n            }\n            if(secondPlayer % 2 == 1){\n                secondPlayer = (secondPlayer + 1) / 2;\n            }else{\n                secondPlayer = secondPlayer / 2;\n            }\n            n = n / 2;\n        }\n        if(res[0] == 0){\n            res[0] = round;\n            res[1] = round;\n        }\n        return res;\n        \n    }\n}"}
{"id": "2096", "path": "output2\\java\\Hard\\2096-count-ways-to-build-rooms-in-an-ant-colony.java", "hypo_code": "class CountWaysToBuildRoomsInAnAntColony {\n    public int waysToBuildRooms(int[] prevRoom) {\n        int n = prevRoom.length;\n        int[] count = new int[n];\n        int[] dp = new int[n];\n        List<List<Integer>> adj = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            adj.add(new ArrayList<>());\n        }\n        for(int i = 1; i < n; i++){\n            adj.get(prevRoom[i]).add(i);\n        }\n        dfs(adj, count, dp, 0);\n        return dp[0];\n        \n        \n    }\n}"}
{"id": "2097", "path": "output2\\java\\Hard\\2097-longest-common-subpath.java", "hypo_code": "class LongestCommonSubpath {\n    public int longestCommonSubpath(int n, int[][] paths) {\n        int m = paths.length;\n        int[][] g = new int[n][n];\n        int[] inDegree = new int[n];\n        for (int[] path : paths) {\n            for (int i = 1; i < path.length; i++) {\n                int u = path[i - 1];\n                int v = path[i];\n                g[u][v] = 1;\n                inDegree[v]++;\n            }\n        }\n        int[] queue = new int[n];\n        int head = 0;\n        int tail = 0;\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                queue[tail++] = i;\n            }\n        }\n        int[] colorCount = new int[m];\n        int[] maxColorCount = new int[n];\n        int[] maxColor = new int[n];\n        int[] color = new int[n];\n        while (head < tail) {\n            int u = queue[head++];\n            colorCount[color[u]]--;\n            for (int v = 0; v < n; v++) {\n                if (g[u][v] == 1) {\n                    if (color[u] == color[v]) {\n                        maxColorCount[v] = Math.max(maxColorCount[v], maxColorCount[u] + 1);\n                    } else if (colorCount[color[u]] < colorCount[color[v]]) {\n                        maxColorCount[v] = maxColorCount[u] + 1;\n                        maxColor[v] = color[v];\n                    } else {\n                        maxColorCount[v] = maxColorCount[u];\n                        maxColor[v] = maxColor[u];\n                    }\n                    if (--inDegree[v] == 0) {\n                        queue[tail++] = v;\n                    }\n                }\n            }\n            colorCount[color[u]]++;\n        }\n        if (tail < n) {\n            return -1;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = Math.max(ans, maxColorCount[i] + 1);\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2098", "path": "output2\\java\\Hard\\2098-minimum-cost-to-reach-destination-in-time.java", "hypo_code": "class MinimumCostToReachDestinationInTime {\n    public int minCost(int maxTime, int[][] edges, int[] passingFees) {\n        int n = passingFees.length;\n        int[][] g = new int[n][n];\n        int[] inDegree = new int[n];\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            g[u][v] = edge[2];\n            g[v][u] = edge[2];\n            inDegree[u]++;\n            inDegree[v]++;\n        }\n        int[] queue = new int[n];\n        int head = 0;\n        int tail = 0;\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 1) {\n                queue[tail++] = i;\n            }\n        }\n        int[] colorCount = new int[n];\n        int[] maxColorCount = new int[n];\n        int[] maxColor = new int[n];\n        int[] color = new int[n];\n        while (head < tail) {\n            int u = queue[head++];\n            colorCount[color[u]]--;\n            for (int v = 0; v < n; v++) {\n                if (g[u][v] > 0) {\n                    if (color[u] == color[v]) {\n                        maxColorCount[v] = Math.max(maxColorCount[v], maxColorCount[u] + g[u][v]);\n                    } else if (colorCount[color[u]] < colorCount[color[v]]) {\n                        maxColorCount[v] = maxColorCount[u] + g[u][v];\n                        maxColor[v] = color[v];\n                    } else {\n                        maxColorCount[v] = maxColorCount[u];\n                        maxColor[v] = maxColor[u];\n                    }\n                    if (--inDegree[v] == 1) {\n                        queue[tail++] = v;\n                    }\n                }\n            }\n            colorCount[color[u]]++;\n        }\n        if (tail < n) {\n            return -1;\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (maxColorCount[i] <= maxTime) {\n                ans = Math.min(ans, passingFees[i] + passingFees[maxColor[i]]);\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n        \n    }\n}"}
{"id": "2099", "path": "output2\\java\\Hard\\2099-painting-a-grid-with-three-different-colors.java", "hypo_code": "class PaintingAGridWithThreeDifferentColors {\n    public int colorTheGrid(int m, int n) {\n        int mod = 1000000007;\n        int[][] dp = new int[m][n];\n        int[][] next = new int[m][n];\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                dp[i][j] = 1;\n            }\n        }\n        for(int i = 1; i < n; i++){\n            for(int j = 0; j < m; j++){\n                for(int k = 0; k < m; k++){\n                    if(j != k){\n                        next[j][i] = (next[j][i] + dp[k][i - 1]) % mod;\n                    }\n                }\n            }\n            for(int j = 0; j < m; j++){\n                dp[j][i] = next[j][i];\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < m; i++){\n            res = (res + dp[i][n - 1]) % mod;\n        }\n        return res;\n        \n    }\n}"}
{"id": "2100", "path": "output2\\java\\Hard\\2100-merge-bsts-to-create-single-bst.java", "hypo_code": "class MergeBstsToCreateSingleBst {\n    public TreeNode canMerge(List<TreeNode> trees) {\n        Map<Integer, TreeNode> map = new HashMap<>();\n        for(TreeNode node : trees){\n            map.put(node.val, node);\n        }\n        for(TreeNode node : trees){\n            if(node.left != null){\n                if(!map.containsKey(node.left.val)){\n                    return null;\n                }\n                node.left = map.get(node.left.val);\n            }\n            if(node.right != null){\n                if(!map.containsKey(node.right.val)){\n                    return null;\n                }\n                node.right = map.get(node.right.val);\n            }\n        }\n        TreeNode root = null;\n        for(TreeNode node : trees){\n            if(node.left == null && node.right == null){\n                if(root == null){\n                    root = node;\n                }else{\n                    return null;\n                }\n            }\n        }\n        if(root == null){\n            return null;\n        }\n        return dfs(root, map);\n        \n    }\n}"}
{"id": "2101", "path": "output2\\java\\Hard\\2101-maximum-genetic-difference-query.java", "hypo_code": "class MaximumGeneticDifferenceQuery {\n    public int[] maxGeneticDifference(int[] parents, int[][] queries) {\n        int n = parents.length;\n        int[] res = new int[queries.length];\n        Map<Integer, List<int[]>> map = new HashMap<>();\n        for(int i = 0; i < queries.length; i++){\n            map.computeIfAbsent(queries[i][0], x -> new ArrayList<>()).add(new int[]{i, queries[i][1]});\n        }\n        int[] trie = new int[1 << 20];\n        int[] count = new int[1 << 20];\n        dfs(0, parents, map, trie, count, res);\n        return res;\n        \n    }\n}"}
{"id": "2102", "path": "output2\\java\\Hard\\2102-number-of-visible-people-in-a-queue.java", "hypo_code": "class NumberOfVisiblePeopleInAQueue {\n    public int[] canSeePersonsCount(int[] heights) {\n        int n = heights.length;\n        int[] res = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for(int i = n - 1; i >= 0; i--){\n            while(!stack.isEmpty() && heights[stack.peek()] < heights[i]){\n                res[i]++;\n                res[stack.pop()]++;\n            }\n            if(!stack.isEmpty()){\n                res[i]++;\n            }\n            stack.push(i);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2103", "path": "output2\\java\\Hard\\2103-delete-duplicate-folders-in-system.java", "hypo_code": "class DeleteDuplicateFoldersInSystem {\n    public List<List<String>> deleteDuplicateFolder(List<List<String>> paths) {\n        Map<String, Integer> map = new HashMap<>();\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        Map<Integer, String> content = new HashMap<>();\n        int n = paths.size();\n        for (int i = 0; i < n; i++) {\n            List<String> path = paths.get(i);\n            int cur = 0;\n            for (String s : path) {\n                if (!graph.containsKey(cur)) {\n                    graph.put(cur, new ArrayList<>());\n                }\n                if (!map.containsKey(s)) {\n                    map.put(s, map.size());\n                }\n                int next = map.get(s);\n                graph.get(cur).add(next);\n                cur = next;\n            }\n            content.put(cur, path.get(path.size() - 1));\n        }\n        Set<Integer> visited = new HashSet<>();\n        Set<Integer> marked = new HashSet<>();\n        dfs(0, graph, content, visited, marked);\n        List<List<String>> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            List<String> path = paths.get(i);\n            int cur = 0;\n            List<String> list = new ArrayList<>();\n            for (String s : path) {\n                if (marked.contains(cur)) {\n                    break;\n                }\n                list.add(s);\n                cur = map.get(s);\n            }\n            if (list.size() == path.size()) {\n                res.add(list);\n            }\n        }\n        return res;\n\n\n                       \n\n\n\n\n\n        \n    }\n}"}
{"id": "2104", "path": "output2\\java\\Hard\\2104-count-number-of-special-subsequences.java", "hypo_code": "class CountNumberOfSpecialSubsequences {\n    public int countSpecialSubsequences(int[] nums) {\n        int mod = 1000000007;\n        int[] dp = new int[3];\n        for(int i = 0; i < nums.length; i++){\n            dp[nums[i]] = (dp[nums[i]] + dp[nums[i]] + (nums[i] == 0 ? 1 : 0)) % mod;\n        }\n        return dp[2];\n        \n    }\n}"}
{"id": "2105", "path": "output2\\java\\Hard\\2105-maximum-product-of-the-length-of-two-palindromic-substrings.java", "hypo_code": "class MaximumProductOfTheLengthOfTwoPalindromicSubstrings {\n    public long maxProduct(String s) {\n        int n = s.length();\n        int[] dp = new int[1 << n];\n        for(int i = 0; i < (1 << n); i++){\n            int l = 0;\n            int r = n - 1;\n            while(l < r){\n                if(((i >> l) & 1) == 0){\n                    l++;\n                }else if(((i >> r) & 1) == 0){\n                    r--;\n                }else{\n                    if(s.charAt(l) != s.charAt(r)){\n                        break;\n                    }\n                    l++;\n                    r--;\n                }\n            }\n            if(l >= r){\n                dp[i] = Integer.bitCount(i);\n            }\n        }\n        long res = 0;\n        for(int i = 0; i < (1 << n); i++){\n            for(int j = i; j > 0; j = (j - 1) & i){\n                res = Math.max(res, (long)dp[i] * dp[j]);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2106", "path": "output2\\java\\Hard\\2106-find-the-longest-valid-obstacle-course-at-each-position.java", "hypo_code": "class FindTheLongestValidObstacleCourseAtEachPosition {\n    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {\n        int n = obstacles.length;\n        int[] ans = new int[n];\n        int[] dp = new int[n];\n        int len = 0;\n        for(int i = 0; i < n; i++){\n            int idx = Arrays.binarySearch(dp, 0, len, obstacles[i]);\n            if(idx < 0){\n                idx = -(idx + 1);\n            }\n            dp[idx] = obstacles[i];\n            if(idx == len){\n                len++;\n            }\n            ans[i] = idx + 1;\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2107", "path": "output2\\java\\Hard\\2107-last-day-where-you-can-still-cross.java", "hypo_code": "class LastDayWhereYouCanStillCross {\n    public int latestDayToCross(int row, int col, int[][] cells) {\n        int n = cells.length;\n        int l = 1, r = n;\n        int[][] grid = new int[row][col];\n        while(l < r){\n            int m = l + (r - l) / 2;\n            for(int i = 0; i < row; i++){\n                Arrays.fill(grid[i], 0);\n            }\n            for(int i = 0; i < m; i++){\n                grid[cells[i][0] - 1][cells[i][1] - 1] = 1;\n            }\n            if(dfs(grid, 0, 0)){\n                l = m + 1;\n            }else{\n                r = m;\n            }\n        }\n        return l - 1;\n        \n    }\n}"}
{"id": "2108", "path": "output2\\java\\Hard\\2108-number-of-ways-to-separate-numbers.java", "hypo_code": "class NumberOfWaysToSeparateNumbers {\n    public int numberOfCombinations(String num) {\n        int mod = 1000000007;\n        int n = num.length();\n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n        for(int i = 1; i <= n; i++){\n            if(num.charAt(i - 1) != '0'){\n                dp[i] = dp[i - 1];\n            }\n            if(i >= 2 && num.charAt(i - 2) != '0'){\n                long val = Long.parseLong(num.substring(i - 2, i));\n                if(val <= 26){\n                    dp[i] = (dp[i] + dp[i - 2]) % mod;\n                }\n            }\n        }\n        return (int)dp[n];\n        \n    }\n}"}
{"id": "2109", "path": "output2\\java\\Hard\\2109-find-array-given-subset-sums.java", "hypo_code": "class FindArrayGivenSubsetSums {\n    public int[] recoverArray(int n, int[] sums) {\n        int[] res = new int[n];\n        Arrays.sort(sums);\n        int m = sums.length;\n        int[] pre = new int[m];\n        pre[0] = sums[0];\n        for(int i = 1; i < m; i++){\n            pre[i] = pre[i - 1] + sums[i];\n        }\n        int[] dp = new int[m];\n        dp[0] = sums[0];\n        for(int i = 1; i < m; i++){\n            dp[i] = pre[i] - dp[i - 1];\n        }\n        int sum = dp[m - 1];\n        int[] map = new int[sum + 1];\n        for(int i = 0; i < m; i++){\n            map[dp[i]] = sums[i];\n        }\n        int cur = 0;\n        for(int i = n - 1; i >= 0; i--){\n            res[i] = map[cur];\n            cur += map[cur];\n        }\n        return res;\n        \n    }\n}"}
{"id": "2110", "path": "output2\\java\\Hard\\2110-number-of-unique-good-subsequences.java", "hypo_code": "class NumberOfUniqueGoodSubsequences {\n    public int numberOfUniqueGoodSubsequences(String binary) {\n        int mod = 1000000007;\n        int n = binary.length();\n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n        int lastOne = -1;\n        for(int i = 1; i <= n; i++){\n            if(binary.charAt(i - 1) == '0'){\n                dp[i] = (dp[i - 1] * 2) % mod;\n            }else{\n                dp[i] = (dp[i - 1] * 2 + (lastOne == -1 ? 1 : dp[lastOne])) % mod;\n                lastOne = i;\n            }\n        }\n        return (int)(dp[n] - 1);\n        \n    }\n}"}
{"id": "2111", "path": "output2\\java\\Hard\\2111-the-number-of-good-subsets.java", "hypo_code": "class TheNumberOfGoodSubsets {\n    public int numberOfGoodSubsets(int[] nums) {\n        int mod = 1000000007;\n        int n = nums.length;\n        int[] primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};\n        int[] dp = new int[1 << primes.length];\n        dp[0] = 1;\n        int[] count = new int[primes.length];\n        for(int i = 0; i < n; i++){\n            int num = nums[i];\n            for(int j = 0; j < primes.length; j++){\n                if(num % primes[j] == 0){\n                    count[j]++;\n                }\n            }\n        }\n        for(int i = 0; i < primes.length; i++){\n            if(count[i] == 0){\n                continue;\n            }\n            int mask = 1 << i;\n            for(int j = 0; j < (1 << primes.length); j++){\n                if((j & mask) == 0){\n                    dp[j | mask] = (dp[j | mask] + dp[j]) % mod;\n                }\n            }\n        }\n        int res = 0;\n        for(int i = 0; i < (1 << primes.length); i++){\n            int countOnes = 0;\n            for(int j = 0; j < primes.length; j++){\n                if((i & (1 << j)) != 0){\n                    countOnes++;\n                }\n            }\n            int sign = countOnes % 2 == 0 ? 1 : -1;\n            res = (res + sign * dp[i]) % mod;\n        }\n        return (res + mod) % mod;\n\n\n        \n    }\n}"}
{"id": "2112", "path": "output2\\java\\Hard\\2112-gcd-sort-of-an-array.java", "hypo_code": "class GcdSortOfAnArray {\n    public boolean gcdSort(int[] nums) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for(int i = 0; i < n; i++){\n            pre[i + 1] = pre[i] + (nums[i] < k ? -1 : 1);\n        }\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i <= n; i++){\n            res += map.getOrDefault(pre[i], 0);\n            map.put(pre[i] + 1, map.getOrDefault(pre[i] + 1, 0) + 1);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2113", "path": "output2\\java\\Hard\\2113-smallest-missing-genetic-value-in-each-subtree.java", "hypo_code": "class SmallestMissingGeneticValueInEachSubtree {\n    public int[] smallestMissingValueSubtree(int[] parents, int[] nums) {\n        int n = parents.length;\n        int[] res = new int[n];\n        Arrays.fill(res, 1);\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            map.computeIfAbsent(parents[i], x -> new ArrayList<>()).add(i);\n        }\n        int[] trie = new int[1 << 20];\n        int[] count = new int[1 << 20];\n        dfs(0, parents, map, trie, count, res, nums);\n        return res;\n        \n        \n    }\n}"}
{"id": "2114", "path": "output2\\java\\Hard\\2114-minimum-number-of-operations-to-make-array-continuous.java", "hypo_code": "class Solution {\n    public int minOperations(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            int start = nums[i];\n            int end = start + n - 1;\n            int index = binarySearch(nums, end);\n            max = Math.max(max, index - i + 1);\n        }\n        return n - max;\n    }\n\n    public int binarySearch(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        if (target < nums[l]) {\n            return -1;\n        }\n        if (target > nums[r]) {\n            return r;\n        }\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (nums[mid] < target) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return nums[l] == target ? l : l - 1;\n    }\n}"}
{"id": "2115", "path": "output2\\java\\Hard\\2115-longest-subsequence-repeated-k-times.java", "hypo_code": "class LongestSubsequenceRepeatedKTimes {\n    public String longestSubsequenceRepeatedK(String s, int k) {\n        int n = s.length();\n        int[][] dp = new int[n + 1][n + 1];\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++){\n                if(s.charAt(i - 1) == s.charAt(j - 1)){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else{\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        int len = dp[n][n];\n        char[] res = new char[len];\n        int i = n, j = n;\n        while(i > 0 && j > 0){\n            if(s.charAt(i - 1) == s.charAt(j - 1)){\n                res[len - 1] = s.charAt(i - 1);\n                i--;\n                j--;\n                len--;\n            }else if(dp[i - 1][j] > dp[i][j - 1]){\n                i--;\n            }else{\n                j--;\n            }\n        }\n        String str = new String(res);\n        int count = 0;\n        for(i = 0; i < n; i++){\n            if(s.startsWith(str, i)){\n                count++;\n            }\n        }\n        return count == k ? str : \"\";\n        \n    }\n}"}
{"id": "2116", "path": "output2\\java\\Hard\\2116-the-score-of-students-solving-math-expression.java", "hypo_code": "class TheScoreOfStudentsSolvingMathExpression {\n    public int scoreOfStudents(String s, int[] answers) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        for(int i = 0; i < n; i += 2){\n            dp[i][i] = s.charAt(i) - '0';\n        }\n        for(int len = 3; len <= n; len += 2){\n            for(int i = 0; i + len <= n; i += 2){\n                int j = i + len - 1;\n                for(int k = i + 1; k < j; k += 2){\n                    if(s.charAt(k) == '+'){\n                        dp[i][j] = Math.max(dp[i][j], dp[i][k - 1] + dp[k + 1][j]);\n                    }else{\n                        dp[i][j] = Math.max(dp[i][j], dp[i][k - 1] * dp[k + 1][j]);\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for(int a : answers){\n            if(a == dp[0][n - 1]){\n                res += 5;\n            }else if(a == dp[0][n - 1] + 1 || a == dp[0][n - 1] - 1){\n                res += 2;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2117", "path": "output2\\java\\Hard\\2117-maximum-number-of-ways-to-partition-an-array.java", "hypo_code": "class MaximumNumberOfWaysToPartitionAnArray {\n    public int waysToPartition(int[] nums, int k) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for(int i = 0; i < n; i++){\n            pre[i + 1] = pre[i] + (nums[i] < k ? -1 : 1);\n        }\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i <= n; i++){\n            res += map.getOrDefault(pre[i], 0);\n            map.put(pre[i] + 1, map.getOrDefault(pre[i] + 1, 0) + 1);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2118", "path": "output2\\java\\Hard\\2118-smallest-k-length-subsequence-with-occurrences-of-a-letter.java", "hypo_code": "class SmallestKLengthSubsequenceWithOccurrencesOfALetter {\n    public String smallestSubsequence(String s, int k, char letter, int repetition) {\n        int n = s.length();\n        int[] count = new int[26];\n        for(int i = 0; i < n; i++){\n            count[s.charAt(i) - 'a']++;\n        }\n        int[] dp = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            if(s.charAt(i - 1) == letter){\n                dp[i] = dp[i - 1] + 1;\n            }else{\n                dp[i] = dp[i - 1];\n            }\n        }\n        int len = dp[n];\n        char[] res = new char[len];\n        int i = n, j = n;\n        while(i > 0 && j > 0){\n            if(s.charAt(i - 1) == letter){\n                res[len - 1] = s.charAt(i - 1);\n                i--;\n                j--;\n                len--;\n            }else if(dp[i - 1] > dp[j - 1]){\n                i--;\n            }else{\n                j--;\n            }\n        }\n        String str = new String(res);\n        int count = 0;\n        for(i = 0; i < n; i++){\n            if(s.startsWith(str, i)){\n                count++;\n            }\n        }\n        return count == k ? str : \"\";\n        \n    }\n}"}
{"id": "2119", "path": "output2\\java\\Hard\\2119-partition-array-into-two-arrays-to-minimize-sum-difference.java", "hypo_code": "class PartitionArrayIntoTwoArraysToMinimizeSumDifference {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for(int i = 0; i < n; i++){\n            pre[i + 1] = pre[i] + (nums[i] < k ? -1 : 1);\n        }\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i <= n; i++){\n            res += map.getOrDefault(pre[i], 0);\n            map.put(pre[i] + 1, map.getOrDefault(pre[i] + 1, 0) + 1);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2120", "path": "output2\\java\\Hard\\2120-kth-smallest-product-of-two-sorted-arrays.java", "hypo_code": "class KthSmallestProductOfTwoSortedArrays {\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\n        int n = nums1.length;\n        int m = nums2.length;\n        long l = (long)nums1[0] * nums2[0];\n        long r = (long)nums1[n - 1] * nums2[m - 1];\n        while(l < r){\n            long mid = l + r >> 1;\n            if(count(nums1, nums2, mid) < k){\n                l = mid + 1;\n            }else{\n                r = mid;\n            }\n        }\n        return l;\n        \n        \n    }\n}"}
{"id": "2121", "path": "output2\\java\\Hard\\2121-second-minimum-time-to-reach-destination.java", "hypo_code": "class SecondMinimumTimeToReachDestination {\n    public int secondMinimum(int n, int[][] edges, int time, int change) {\n        int[][] g = new int[n][n];\n        for (int[] edge : edges) {\n            int u = edge[0] - 1;\n            int v = edge[1] - 1;\n            g[u][v] = g[v][u] = 1;\n        }\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n        int[] queue = new int[n];\n        int head = 0;\n        int tail = 0;\n        queue[tail++] = 0;\n        while (head < tail) {\n            int u = queue[head++];\n            for (int v = 0; v < n; v++) {\n                if (g[u][v] == 1) {\n                    int d = dist[u] + time;\n                    if (d % (2 * change) >= change) {\n                        d += 2 * change - d % (2 * change);\n                    }\n                    if (d < dist[v]) {\n                        dist[v] = d;\n                        queue[tail++] = v;\n                    }\n                }\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (dist[i] > dist[n - 1]) {\n                ans = Math.min(ans, dist[i]);\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n        \n    }\n}"}
{"id": "2122", "path": "output2\\java\\Hard\\2122-parallel-courses-iii.java", "hypo_code": "class ParallelCoursesIii {\n    public int minimumTime(int n, int[][] relations, int[] time) {\n        int[] pre = new int[n];\n        int[] dp = new int[n];\n        int[] indegree = new int[n];\n        for(int[] r : relations){\n            pre[r[1] - 1] |= 1 << (r[0] - 1);\n            indegree[r[1] - 1]++;\n        }\n        int res = 0;\n        Queue<Integer> q = new LinkedList<>();\n        for(int i = 0; i < n; i++){\n            if(indegree[i] == 0){\n                q.offer(i);\n                dp[i] = time[i];\n            }\n        }\n        while(!q.isEmpty()){\n            int cur = q.poll();\n            res = Math.max(res, dp[cur]);\n            for(int i = 0; i < n; i++){\n                if((pre[i] & (1 << cur)) != 0){\n                    dp[i] = Math.max(dp[i], dp[cur] + time[i]);\n                    if(--indegree[i] == 0){\n                        q.offer(i);\n                    }\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2123", "path": "output2\\java\\Hard\\2123-number-of-valid-move-combinations-on-chessboard.java", "hypo_code": "class NumberOfValidMoveCombinationsOnChessboard {\n    public int countCombinations(String[] pieces, int[][] positions) {\n        int n = pieces.length;\n        int[][][] dp = new int[n][8][8];\n        int[][][] dp2 = new int[n][8][8];\n        int[][][] dp3 = new int[n][8][8];\n        int[][][] dp4 = new int[n][8][8];\n        int[][][] dp5 = new int[n][8][8];\n        int[][][] dp6 = new int[n][8][8];\n        int[][][] dp7 = new int[n][8][8];\n        int[][][] dp8 = new int[n][8][8];\n        int[][][] dp9 = new int[n][8][8];\n        int[][][] dp10 = new int[n][8][8];\n        int[][][] dp11 = new int[n][8][8];\n        int[][][] dp12 = new int[n][8][8];\n        int[][][] dp13 = new int[n][8][8];\n        int[][][] dp14 = new int[n][8][8];\n        int[][][] dp15 = new int[n][8][8];\n        int[][][] dp16 = new int[n][8][8];\n        int[][][] dp17 = new int[n][8][8];\n        int[][][] dp18 = new int[n][8][8];\n        int[][][] dp19 = new int[n][8][8];\n        int[][][] dp20 = new int[n][8][8];\n        int[][][] dp21 = new int[n][8][8];\n        int[][][] dp22 = new int[n][8][8];\n        int[][][] dp23 = new int[n][8][8];\n        int[][][] dp24 = new int[n][8][8];\n        int[][][] dp25 = new int[n][8][8];\n        int[][][] dp26 = new int[n][8][8];\n        int[][][] dp27 = new int[n][8][8];\n        int[][][] dp28 = new int[n][8][8];\n        int[][][] dp29 = new int[n][8][8];\n        int[][][] dp30 = new int[n][8][8];\n        int[][][] dp31 = new int[n][8][8];\n        int[][][] dp32 = new int[n][8][8];\n        int[][][] dp33 = new int[n][8][ 8];\n        \n    }\n}"}
{"id": "2124", "path": "output2\\java\\Hard\\2124-check-if-an-original-string-exists-given-two-encoded-strings.java", "hypo_code": "class CheckIfAnOriginalStringExistsGivenTwoEncodedStrings {\n    public boolean possiblyEquals(String s1, String s2) {\n        int n1 = s1.length();\n        int n2 = s2.length();\n        int i = 0;\n        int j = 0;\n        while (i < n1 && j < n2) {\n            if (s1.charAt(i) == s2.charAt(j)) {\n                i++;\n                j++;\n            } else if (Character.isDigit(s1.charAt(i)) && Character.isDigit(s2.charAt(j))) {\n                int num1 = 0;\n                int num2 = 0;\n                while (i < n1 && Character.isDigit(s1.charAt(i))) {\n                    num1 = num1 * 10 + (s1.charAt(i) - '0');\n                    i++;\n                }\n                while (j < n2 && Character.isDigit(s2.charAt(j))) {\n                    num2 = num2 * 10 + (s2.charAt(j) - '0');\n                    j++;\n                }\n                if (num1 != num2) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return i == n1 && j == n2;\n        \n    }\n}"}
{"id": "2125", "path": "output2\\java\\Hard\\2125-maximum-path-quality-of-a-graph.java", "hypo_code": "class MaximumPathQualityOfAGraph {\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\n        int n = values.length;\n        int[][][] dp = new int[n][n][maxTime + 1];\n        int[][][] dp2 = new int[n][n][maxTime + 1];\n        int[][][] dp3 = new int[n][n][maxTime + 1];\n        int[][][] dp4 = new int[n][n][maxTime + 1];\n        int[][][] dp5 = new int[n][n][maxTime + 1];\n        int[][][] dp6 = new int[n][n][maxTime + 1];\n        int[][][] dp7 = new int[n][n][maxTime + 1];\n        int[][][] dp8 = new int[n][n][maxTime + 1];\n        int[][][] dp9 = new int[n][n][maxTime + 1];\n        int[][][] dp10 = new int[n][n][maxTime + 1];\n        int[][][] dp11 = new int[n][n][maxTime + 1];\n        int[][][] dp12 = new int[n][n][maxTime + 1];\n        int[][][] dp13 = new int[n][n][maxTime + 1];\n        int[][][] dp14 = new int[n][n][maxTime + 1];\n        int[][][] dp15 = new int[n][n][maxTime + 1];\n        int[][][] dp16 = new int[n][n][maxTime + 1];\n        int[][][] dp17 = new int[n][n][maxTime + 1];\n        int[][][] dp18 = new int[n][n][maxTime + 1];\n        int[][][] dp19 = new int[n][n][maxTime + 1];\n        int[][][] dp20 = new int[n][n][maxTime + 1];\n        int[][][] dp21 = new int[n][n][maxTime + 1];\n        int[][][] dp22 = new int[n][n][maxTime + 1];\n        int[][][] dp23 = new int[n][n][maxTime + 1];\n        int[][][] dp24 = new int[n][n][maxTime + 1];\n        int[][][] dp25 = new int[n][n][maxTime + 1];\n        int[][][] dp26 = new int[n][n][maxTime + 1 ];\n        \n    }\n}"}
{"id": "2126", "path": "output2\\java\\Hard\\2126-maximum-number-of-tasks-you-can-assign.java", "hypo_code": "class MaximumNumberOfTasksYouCanAssign {\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\n        int n = tasks.length;\n        int m = workers.length;\n        int[][] dp = new int[n][m];\n        int[][] dp2 = new int[n][m];\n        int[][] dp3 = new int[n][m];\n        int[][] dp4 = new int[n][m];\n        int[][] dp5 = new int[n][m];\n        int[][] dp6 = new int[n][m];\n        int[][] dp7 = new int[n][m];\n        int[][] dp8 = new int[n][m];\n        int[][] dp9 = new int[n][m];\n        int[][] dp10 = new int[n][m];\n        int[][] dp11 = new int[n][m];\n        int[][] dp12 = new int[n][m];\n        int[][] dp13 = new int[n][m];\n        int[][] dp14 = new int[n][m];\n        int[][] dp15 = new int[n][m];\n        int[][] dp16 = new int[n][m];\n        int[][] dp17 = new int[n][m];\n        int[][] dp18 = new int[n][m];\n        int[][] dp19 = new int[n][m];\n        int[][] dp20 = new int[n][m];\n        int[][] dp21 = new int[n][m];\n        int[][] dp22 = new int[n][m];\n        int[][] dp23 = new int[n][m];\n        int[][] dp24 = new int[n][m];\n        int[][] dp25 = new int[n][m];\n        int[][] dp26 = new int[n][m];\n        int[][] dp27 = new int[n][m];\n        int[][] dp28 = new int[n][m];\n        int[][] dp29 = new int[n][m];\n        int[][] dp30 = new int[n][m];\n        int[][] dp31 = new int[n][m];\n        int[][] dp32 = new int[n][m];\n        int[][] dp33 = new int[n][m];\n        int[][] dp34 = new int[n][m];\n        int[][] dp35 = new int[n][m];\n        int[][] dp36 = new int[n][m];\n        int[][] dp37 = new int[n][m];\n        int[][] dp38 = new int[n][m];\n        int[][] dp39 = new int[n][m];\n        int[][] dp40 = new int[n][m];\n        int[][] dp41 =\n        \n    }\n}"}
{"id": "2127", "path": "output2\\java\\Hard\\2127-process-restricted-friend-requests.java", "hypo_code": "class ProcessRestrictedFriendRequests {\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\n        int[][] dp = new int[n][n];\n        int[][] dp2 = new int[n][n];\n        int[][] dp3 = new int[n][n];\n        int[][] dp4 = new int[n][n];\n        int[][] dp5 = new int[n][n];\n        int[][] dp6 = new int[n][n];\n        int[][] dp7 = new int[n][n];\n        int[][] dp8 = new int[n][n];\n        int[][] dp9 = new int[n][n];\n        int[][] dp10 = new int[n][n];\n        int[][] dp11 = new int[n][n];\n        int[][] dp12 = new int[n][n];\n        int[][] dp13 = new int[n][n];\n        int[][] dp14 = new int[n][n];\n        int[][] dp15 = new int[n][n];\n        int[][] dp16 = new int[n][n];\n        int[][] dp17 = new int[n][n];\n        int[][] dp18 = new int[n][n];\n        int[][] dp19 = new int[n][n];\n        int[][] dp20 = new int[n][n];\n        int[][] dp21 = new int[n][n];\n        int[][] dp22 = new int[n][n];\n        int[][] dp23 = new int[n][n];\n        int[][] dp24 = new int[n][n];\n        int[][] dp25 = new int[n][n];\n        int[][] dp26 = new int[n][n];\n        int[][] dp27 = new int[n][n];\n        int[][] dp28 = new int[n][n];\n        int[][] dp29 = new int[n][n];\n        int[][] dp30 = new int[n][n];\n        int[][] dp31 = new int[n][n];\n        int[][] dp32 = new int[n][n];\n        int[][] dp33 = new int[n][n];\n        int[][] dp34 = new int[n][n];\n        int[][] dp35 = new int[n][n];\n        int[][] dp36 = new int[n][n];\n        int[][] dp37 = new int[n][n];\n        int[][] dp38 = new int[n][n];\n        int[][] dp39 = new int[n][n];\n        int[][] dp40 = new int[n][n];\n        int[][] dp41 = new int[n][n];\n        int[][] dp42 = new int [n][n];\n        \n    }\n}"}
{"id": "2128", "path": "output2\\java\\Hard\\2128-sum-of-k-mirror-numbers.java", "hypo_code": "class SumOfKMirrorNumbers {\n    public long kMirror(int k, int n) {\n        long res = 0;\n        for (int i = 1; i <= n; i++) {\n            res += getMirror(i, k);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2129", "path": "output2\\java\\Hard\\2129-count-fertile-pyramids-in-a-land.java", "hypo_code": "class CountFertilePyramidsInALand {\n    public int countPyramids(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int h = 1;\n                    while (i + h < m && j - h >= 0 && j + h < n && grid[i + h][j - h] == 1 && grid[i + h][j + h] == 1) {\n                        h++;\n                    }\n                    if (h > 1) {\n                        res++;\n                    }\n                    h = 1;\n                    while (i - h >= 0 && j - h >= 0 && j + h < n && grid[i - h][j - h] == 1 && grid[i - h][j + h] == 1) {\n                        h++;\n                    }\n                    if (h > 1) {\n                        res++;\n                    }\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2130", "path": "output2\\java\\Hard\\2130-find-all-people-with-secret.java", "hypo_code": "class FindAllPeopleWithSecret {\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        List<Integer> res = new ArrayList<>();\n        int[] visited = new int[n];\n        visited[firstPerson] = 1;\n        for (int[] meeting : meetings) {\n            if (visited[meeting[0]] == 1) {\n                visited[meeting[1]] = 1;\n            }\n            if (visited[meeting[1]] == 1) {\n                visited[meeting[0]] = 1;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (visited[i] == 1) {\n                res.add(i);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2131", "path": "output2\\java\\Hard\\2131-valid-arrangement-of-pairs.java", "hypo_code": "class ValidArrangementOfPairs {\n    public int[][] validArrangement(int[][] pairs) {\n        Arrays.sort(pairs, (a, b) -> a[0] - b[0]);\n        int[][] res = new int[pairs.length][2];\n        res[0] = pairs[0];\n        for (int i = 1; i < pairs.length; i++) {\n            if (pairs[i][0] == res[i - 1][1]) {\n                res[i] = pairs[i];\n            } else {\n                res[i] = pairs[i - 1];\n                res[i - 1] = pairs[i];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2133", "path": "output2\\java\\Hard\\2133-maximum-fruits-harvested-after-at-most-k-steps.java", "hypo_code": "class MaximumFruitsHarvestedAfterAtMostKSteps {\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\n        int res = 0;\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        while (right < fruits.length) {\n            sum += fruits[right][1];\n            while (fruits[right][0] - fruits[left][0] > k) {\n                sum -= fruits[left][1];\n                left++;\n            }\n            res = Math.max(res, sum);\n            right++;\n        }\n        return res;\n        \n    }\n}"}
{"id": "2134", "path": "output2\\java\\Hard\\2134-minimum-operations-to-make-the-array-k-increasing.java", "hypo_code": "class Solution {\n    public int kIncreasing(int[] arr, int k) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, n);\n        dp[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int min = dp[i - 1] + 1;\n            for (int j = i - 1; j >= 0 && i - j <= k; j--) {\n                if (arr[i] > arr[j]) {\n                    min = Math.min(min, dp[j] + i - j - 1);\n                }\n            }\n            dp[i] = min;\n        }\n        return dp[n - 1];\n    }\n}"}
{"id": "2135", "path": "output2\\java\\Hard\\2135-abbreviating-the-product-of-a-range.java", "hypo_code": "class Solution {\n    public String abbreviateProduct(int left, int right) {\n        long prod = 1;\n        for (int i = left; i <= right; i++) {\n            prod *= i;\n            prod = removeZeros(prod);\n        }\n        String res = String.valueOf(prod);\n        int len = res.length();\n        if (len > 10) {\n            res = res.substring(0, 5) + \"...\" + res.substring(len - 5, len) + \"e\" + (len - 1);\n        }\n        return res;\n    }\n\n    public long removeZeros(long prod) {\n        while (prod % 10 == 0) {\n            prod /= 10;\n        }\n        return prod;\n    }\n}"}
{"id": "2136", "path": "output2\\java\\Hard\\2136-recover-the-original-array.java", "hypo_code": "class Solution {\n    public int[] recoverArray(int[] nums) {\n        int n = nums.length;\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for (int num : nums) {\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n        int k = max - min;\n        int[] res = new int[n / 2];\n        int index = 0;\n        while (index < res.length) {\n            int[] lower = new int[n];\n            int[] higher = new int[n];\n            int l = 0, h = 0;\n            for (int num : nums) {\n                if (num < k) {\n                    lower[l++] = num;\n                } else if (num > k) {\n                    higher[h++] = num;\n                }\n            }\n            if (l == h) {\n                k = lower[0];\n                res[index++] = k;\n            } else if (l < h) {\n                k = higher[0] - k;\n                res[index++] = k;\n            } else {\n                k = k - lower[0];\n                res[index++] = k;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2137", "path": "output2\\java\\Hard\\2137-maximum-employees-to-be-invited-to-a-meeting.java", "hypo_code": "class MaximumEmployeesToBeInvitedToAMeeting {\n    public int maximumInvitations(int[] favorite) {\n        int n = favorite.length;\n        int[] visited = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (visited[i] == 0) {\n                res += dfs(favorite, visited, i);\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "2138", "path": "output2\\java\\Hard\\2138-stamping-the-grid.java", "hypo_code": "class StampingTheGrid {\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] stamp = new int[stampHeight][stampWidth];\n        for (int i = 0; i < stampHeight; i++) {\n            for (int j = 0; j < stampWidth; j++) {\n                stamp[i][j] = 1;\n            }\n        }\n        int[][] res = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                res[i][j] = grid[i][j];\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (res[i][j] == 0) {\n                    if (i + stampHeight <= m && j + stampWidth <= n) {\n                        boolean match = true;\n                        for (int k = 0; k < stampHeight; k++) {\n                            for (int l = 0; l < stampWidth; l++) {\n                                if (res[i + k][j + l] != stamp[k][l]) {\n                                    match = false;\n                                    break;\n                                }\n                            }\n                            if (!match) {\n                                break;\n                            }\n                        }\n                        if (match) {\n                            for (int k = 0; k < stampHeight; k++) {\n                                for (int l = 0; l < stampWidth; l++) {\n                                    res[i + k][j + l] = 1;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (res[i][j] == 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "2139", "path": "output2\\java\\Hard\\2139-earliest-possible-day-of-full-bloom.java", "hypo_code": "class EarliestPossibleDayOfFullBloom {\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\n        int n = plantTime.length;\n        int[][] flowers = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            flowers[i][0] = plantTime[i];\n            flowers[i][1] = plantTime[i] + growTime[i];\n        }\n        Arrays.sort(flowers, (a, b) -> a[0] - b[0]);\n        int res = 0;\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        while (right < n) {\n            sum += flowers[right][1];\n            while (flowers[right][0] - flowers[left][0] > 0) {\n                sum -= flowers[left][1];\n                left++;\n            }\n            res = Math.max(res, sum);\n            right++;\n        }\n        return res;\n        \n    }\n}"}
{"id": "2140", "path": "output2\\java\\Hard\\2140-maximum-running-time-of-n-computers.java", "hypo_code": "class MaximumRunningTimeOfNComputers {\n    public long maxRunTime(int n, int[] batteries) {\n        Arrays.sort(batteries);\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            res += batteries[i];\n        }\n        return res;\n        \n    }\n}"}
{"id": "2141", "path": "output2\\java\\Hard\\2141-number-of-ways-to-divide-a-long-corridor.java", "hypo_code": "class Solution {\n    public int numberOfWays(String corridor) {\n        int n = corridor.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (corridor.charAt(i - 1) == 'S') {\n                count++;\n            }\n            for (int j = 0; j < i; j++) {\n                if (count % 2 == 0) {\n                    dp[i] = (dp[i] + dp[j]) % 1000000007;\n                }\n            }\n        }\n        return dp[n];\n    }\n}"}
{"id": "2142", "path": "output2\\java\\Hard\\2142-maximum-good-people-based-on-statements.java", "hypo_code": "class Solution {\n    public int maximumGood(int[][] statements) {\n        int n = statements.length;\n        int res = 0;\n        for (int i = 0; i < 1 << n; i++) {\n            boolean[] good = new boolean[n];\n            boolean[] bad = new boolean[n];\n            int count = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i >> j & 1) == 1) {\n                    good[j] = true;\n                    count++;\n                } else if (statements[j][j] == 1) {\n                    bad[j] = true;\n                }\n            }\n            for (int j = 0; j < n; j++) {\n                if (good[j]) {\n                    for (int k = 0; k < n; k++) {\n                        if (statements[j][k] == 0) {\n                            bad[k] = true;\n                        }\n                    }\n                }\n            }\n            for (int j = 0; j < n; j++) {\n                if (bad[j]) {\n                    for (int k = 0; k < n; k++) {\n                        if (statements[j][k] == 1) {\n                            bad[k] = true;\n                        }\n                    }\n                }\n            }\n            boolean isValid = true;\n            for (int j = 0; j < n; j++) {\n                if (good[j] && bad[j]) {\n                    isValid = false;\n                    break;\n                }\n            }\n            if (isValid) {\n                res = Math.max(res, count);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2143", "path": "output2\\java\\Hard\\2143-find-substring-with-given-hash-value.java", "hypo_code": "class Solution {\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\n        int n = s.length();\n        int[] hash = new int[n + 1];\n        int p = 1;\n        for (int i = 0; i < k; i++) {\n            p = (int) ((long) p * power % modulo);\n        }\n        for (int i = 0; i < n; i++) {\n            hash[i + 1] = (int) (((long) hash[i] * power + (s.charAt(i) - 'a' + 1)) % modulo);\n            if (i >= k) {\n                hash[i + 1] = (hash[i + 1] - (int) ((long) p * (s.charAt(i - k) - 'a' + 1) % modulo) + modulo) % modulo;\n            }\n            if (i >= k - 1 && hash[i + 1] == hashValue) {\n                return s.substring(i - k + 1, i + 1);\n            }\n        }\n        return \"\";\n    }\n}"}
{"id": "2144", "path": "output2\\java\\Hard\\2144-groups-of-strings.java", "hypo_code": "class Solution {\n    public int[] groupStrings(String[] words) {\n        int n = words.length;\n        int[] ans = new int[2];\n        if (n == 0) {\n            return ans;\n        }\n        Map<String, Integer> map = new HashMap<>();\n        int count = 0;\n        for (String word : words) {\n            String key = getKey(word);\n            if (!map.containsKey(key)) {\n                map.put(key, count++);\n            }\n        }\n        UnionFind uf = new UnionFind(count);\n        for (String word : words) {\n            String key = getKey(word);\n            int index = map.get(key);\n            uf.union(index, map.get(key));\n        }\n        int max = 0;\n        for (int i = 0; i < count; i++) {\n            max = Math.max(max, uf.getSize(i));\n        }\n        ans[0] = count;\n        ans[1] = max;\n        return ans;\n    }\n\n    public String getKey(String word) {\n        StringBuilder sb = new StringBuilder();\n        int diff = word.charAt(0) - 'a';\n        for (int i = 0; i < word.length(); i++) {\n            char c = (char) (word.charAt(i) - diff);\n            if (c < 'a') {\n                c += 26;\n            }\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n    }"}
{"id": "2145", "path": "output2\\java\\Hard\\2145-minimum-difference-in-sums-after-removal-of-elements.java", "hypo_code": "class MinimumDifferenceInSumsAfterRemovalOfElements {\n    public long minimumDifference(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length / 3;\n        long sum1 = 0;\n        long sum2 = 0;\n        for (int i = 0; i < n; i++) {\n            sum1 += nums[i];\n        }\n        for (int i = n; i < 2 * n; i++) {\n            sum2 += nums[i];\n        }\n        long res = sum2 - sum1;\n        for (int i = 2 * n; i < nums.length; i++) {\n            sum1 += nums[i] - nums[i - n];\n            sum2 -= nums[i - n];\n            res = Math.min(res, sum2 - sum1);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2146", "path": "output2\\java\\Hard\\2146-minimum-time-to-remove-all-cars-containing-illegal-goods.java", "hypo_code": "class MinimumTimeToRemoveAllCarsContainingIllegalGoods {\n    public int minimumTime(String s) {\n        int n = s.length();\n        int left = 0;\n        int right = n - 1;\n        int res = 0;\n        while (left <= right) {\n            if (s.charAt(left) == '1' && s.charAt(right) == '1') {\n                res += 2;\n                left++;\n                right--;\n            } else if (s.charAt(left) == '1') {\n                res++;\n                left++;\n            } else if (s.charAt(right) == '1') {\n                res++;\n                right--;\n            } else {\n                left++;\n                right--;\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2147", "path": "output2\\java\\Hard\\2147-maximum-and-sum-of-array.java", "hypo_code": "class MaximumAndSumOfArray {\n    public int maximumANDSum(int[] nums, int numSlots) {\n        int n = nums.length;\n        int[] slots = new int[numSlots];\n        int[] slots2 = new int[numSlots];\n        int[] slots3 = new int[numSlots];\n        int[] slots4 = new int[numSlots];\n        int[] slots5 = new int[numSlots];\n        int[] slots6 = new int[numSlots];\n        int[] slots7 = new int[numSlots];\n        int[] slots8 = new int[numSlots];\n        int[] slots9 = new int[numSlots];\n        int[] slots10 = new int[numSlots];\n        int[] slots11 = new int[numSlots];\n        int[] slots12 = new int[numSlots];\n        int[] slots13 = new int[numSlots];\n        int[] slots14 = new int[numSlots];\n        int[] slots15 = new int[numSlots];\n        int[] slots16 = new int[numSlots];\n        int[] slots17 = new int[numSlots];\n        int[] slots18 = new int[numSlots];\n        int[] slots19 = new int[numSlots];\n        int[] slots20 = new int[numSlots];\n        int[] slots21 = new int[numSlots];\n        int[] slots22 = new int[numSlots];\n        int[] slots23 = new int[numSlots];\n        int[] slots24 = new int[numSlots];\n        int[] slots25 = new int[numSlots];\n        int[] slots26 = new int[numSlots];\n        int[] slots27 = new int[numSlots];\n        int[] slots28 = new int[numSlots];\n        int[] slots29 = new int[numSlots];\n        int[] slots30 = new int[numSlots];\n        int[] slots31 = new int[numSlots];\n        int[] slots32 = new int[numSlots];\n        int[] slots33 = new int[numSlots];\n        int[] slots34 = new int[numSlots];\n        int[] slots35 = new int[numSlots];\n        int[] slots36 = new int[numSlots];\n        int[] slots37 = new int[numSlots];\n        int[] slots38 = new int[numSlots];\n        int[] slots39 = new int[numSlots];\n        int[] slots40 = new int[numSlots];\n        int[] slots41 = new int[numSlots];\n        int[] slots42 = new int[numSlots];\n        int[] slots43 = new int[numSlots];\n        int[] slots44 = new int[numSlots];\n        int[] slots45 = new int[num\n        \n    }\n}"}
{"id": "2148", "path": "output2\\java\\Hard\\2148-count-good-triplets-in-an-array.java", "hypo_code": "class CountGoodTripletsInAnArray {\n    public long goodTriplets(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int[] count1 = new int[n];\n            int[] count2 = new int[n];\n            for (int j = i + 1; j < n; j++) {\n                if (nums1[j] > nums1[i]) {\n                    count1[nums1[j]]++;\n                }\n                if (nums2[j] > nums2[i]) {\n                    count2[nums2[j]]++;\n                }\n            }\n            for (int j = i + 1; j < n; j++) {\n                if (nums1[j] > nums1[i]) {\n                    for (int k = nums1[j] + 1; k < n; k++) {\n                        res += count1[k] * count2[k];\n                    }\n                }\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2149", "path": "output2\\java\\Hard\\2149-count-array-pairs-divisible-by-k.java", "hypo_code": "class CountArrayPairsDivisibleByK {\n    public long countPairs(int[] nums, int k) {\n        int n = nums.length;\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int[] count = new int[k];\n            for (int j = i + 1; j < n; j++) {\n                count[(nums[i] * nums[j]) % k]++;\n            }\n            for (int j = i + 1; j < n; j++) {\n                res += count[(k - (nums[i] * nums[j]) % k) % k];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2150", "path": "output2\\java\\Hard\\2150-minimum-time-to-finish-the-race.java", "hypo_code": "class MinimumTimeToFinishTheRace {\n    public int minimumFinishTime(int[][] tires, int changeTime, int numLaps) {\n        int n = tires.length;\n        int[][] dp = new int[n][numLaps + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        for (int i = 0; i < n; i++) {\n            dp[i][1] = tires[i][0] * tires[i][1];\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 2; j <= numLaps; j++) {\n                for (int k = 0; k < n; k++) {\n                    if (i == k) {\n                        dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + tires[i][0] * tires[i][1]);\n                    } else {\n                        dp[i][j] = Math.min(dp[i][j], dp[k][j - 1] + changeTime + tires[i][0] * tires[i][1]);\n                    }\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            res = Math.min(res, dp[i][numLaps]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2151", "path": "output2\\java\\Hard\\2151-minimum-number-of-moves-to-make-palindrome.java", "hypo_code": "class MinimumNumberOfMovesToMakePalindrome {\n    public int minMovesToMakePalindrome(String s) {\n        int n = s.length();\n        int left = 0;\n        int right = n - 1;\n        int res = 0;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                res += Math.min(s.charAt(left), s.charAt(right)) - 'a';\n            }\n            left++;\n            right--;\n        }\n        return res;\n        \n    }\n}"}
{"id": "2152", "path": "output2\\java\\Hard\\2152-replace-non-coprime-numbers-in-array.java", "hypo_code": "class ReplaceNonCoprimeNumbersInArray {\n    public List<Integer> replaceNonCoprimes(int[] nums) {\n        int n = nums.length;\n        int[] primes = new int[100001];\n        for (int i = 2; i < primes.length; i++) {\n            if (primes[i] == 0) {\n                for (int j = i; j < primes.length; j += i) {\n                    primes[j] = i;\n                }\n            }\n        }\n        int[] next = new int[n];\n        Arrays.fill(next, -1);\n        for (int i = n - 1; i >= 0; i--) {\n            int num = nums[i];\n            while (num > 1) {\n                int prime = primes[num];\n                if (next[prime] != -1) {\n                    next[i] = next[prime];\n                    break;\n                }\n                while (num % prime == 0) {\n                    num /= prime;\n                }\n            }\n        }\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (next[i] == -1) {\n                res.add(nums[i]);\n            } else {\n                int lcm = nums[i] * nums[next[i]] / primes[nums[i]];\n                res.add(lcm);\n                i = next[i];\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2153", "path": "output2\\java\\Hard\\2153-minimum-weighted-subgraph-with-the-required-paths.java", "hypo_code": "class Solution {\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\n        List<int[]>[] graph = new List[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int[] edge : edges) {\n            int from = edge[0];\n            int to = edge[1];\n            int weight = edge[2];\n            graph[from].add(new int[]{to, weight});\n        }\n        long[] dist1 = new long[n];\n        long[] dist2 = new long[n];\n        Arrays.fill(dist1, Long.MAX_VALUE / 2);\n        Arrays.fill(dist2, Long.MAX_VALUE / 2);\n        dist1[src1] = 0;\n        dist2[src2] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{src1, 0});\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int from = cur[0];\n            long weight = cur[1];\n            if (dist1[from] < weight) {\n                continue;\n            }\n            for (int[] next : graph[from]) {\n                int to = next[0];\n                long nextWeight = next[1];\n                if (dist1[to] > dist1[from] + nextWeight) {\n                    dist1[to] = dist1[from] + nextWeight;\n                    pq.offer(new int[]{to, (int) dist1[to]});\n                }\n            }\n        }\n        pq.clear();\n        pq.offer(new int[]{src2, 0});\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int from = cur[0];\n            long weight = cur[1];\n            if (dist2[from] < weight) {\n                continue;\n            }\n            for (int[] next : graph[from]) {\n                int to = next[0];\n                long nextWeight = next[1];\n                if (dist2[to] > dist2[from] + nextWeight) {\n                    dist2[to] = dist2[from] + nextWeight;\n                    pq.offer(new int[]{to, (int) dist2[to]});\n                }\n            }\n        }\n        long res = Long.MAX_VALUE;\n        for (int[] edge : edges) {\n            int from = edge[0];\n            int to = edge[1];\n            int weight = edge[2];\n    }\n}"}
{"id": "2154", "path": "output2\\java\\Hard\\2154-minimum-white-tiles-after-covering-with-carpets.java", "hypo_code": "class MinimumWhiteTilesAfterCoveringWithCarpets {\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\n        int n = floor.length();\n        int[] dp = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (floor.charAt(i) == '1') {\n                res++;\n            }\n            if (i >= carpetLen) {\n                res -= dp[i - carpetLen];\n            }\n            dp[i] = res;\n        }\n        return dp[n - 1];\n        \n    }\n}"}
{"id": "2155", "path": "output2\\java\\Hard\\2155-longest-substring-of-one-repeating-character.java", "hypo_code": "class LongestSubstringOfOneRepeatingCharacter {\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\n        int n = s.length();\n        int[] dp = new int[n];\n        int[] res = new int[queryCharacters.length()];\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && s.charAt(i) == s.charAt(i - 1)) {\n                dp[i] = dp[i - 1] + 1;\n            } else {\n                dp[i] = 1;\n            }\n        }\n        for (int i = 0; i < queryCharacters.length(); i++) {\n            int idx = queryIndices[i];\n            char c = queryCharacters.charAt(i);\n            s = s.substring(0, idx) + c + s.substring(idx + 1);\n            if (idx > 0 && s.charAt(idx) == s.charAt(idx - 1)) {\n                dp[idx] = dp[idx - 1] + 1;\n            } else {\n                dp[idx] = 1;\n            }\n            if (idx < n - 1 && s.charAt(idx) == s.charAt(idx + 1)) {\n                dp[idx + 1] = dp[idx] + 1;\n            }\n            res[i] = dp[idx];\n        }\n        return res;\n        \n    }\n}"}
{"id": "2156", "path": "output2\\java\\Hard\\2156-maximum-value-of-k-coins-from-piles.java", "hypo_code": "class MaximumValueOfKCoinsFromPiles {\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\n        int n = piles.size();\n        int[] coins = new int[n];\n        int idx = 0;\n        for (List<Integer> pile : piles) {\n            Collections.sort(pile);\n            coins[idx++] = pile.get(pile.size() - 2);\n        }\n        Arrays.sort(coins);\n        int res = 0;\n        for (int i = n - 1; i >= n - k; i--) {\n            res += coins[i];\n        }\n        return res;\n        \n    }\n}"}
{"id": "2157", "path": "output2\\java\\Hard\\2157-sum-of-scores-of-built-strings.java", "hypo_code": "class SumOfScoresOfBuiltStrings {\n    public long sumScores(String s) {\n        int n = s.length();\n        long res = 0;\n        int[] dp = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && s.charAt(i) == s.charAt(i - 1)) {\n                dp[i] = dp[i - 1] + 1;\n            } else {\n                dp[i] = 1;\n            }\n            res += dp[i];\n        }\n        return res;\n        \n    }\n}"}
{"id": "2159", "path": "output2\\java\\Hard\\2159-maximum-total-beauty-of-the-gardens.java", "hypo_code": "class MaximumTotalBeautyOfTheGardens {\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\n        int n = flowers.length;\n        int[] complete = new int[n];\n        int[] incomplete = new int[n];\n        int completeCount = 0;\n        int incompleteCount = 0;\n        for (int i = 0; i < n; i++) {\n            if (flowers[i] >= target) {\n                complete[completeCount++] = flowers[i];\n            } else {\n                incomplete[incompleteCount++] = flowers[i];\n            }\n        }\n        Arrays.sort(complete, 0, completeCount);\n        Arrays.sort(incomplete, 0, incompleteCount);\n        long res = 0;\n        long sum = 0;\n        for (int i = 0; i < completeCount; i++) {\n            sum += complete[i];\n            res = Math.max(res, (i + 1) * full + (incompleteCount > 0 ? incomplete[0] : 0) * partial);\n        }\n        for (int i = 0; i < incompleteCount; i++) {\n            sum += incomplete[i];\n            res = Math.max(res, completeCount * full + (i + 1) * partial);\n        }\n        long left = 0;\n        long right = 0;\n        long sum2 = 0;\n        while (right < newFlowers) {\n            sum2 += sum;\n            while (right - left > 0) {\n                sum2 -= sum;\n                left++;\n            }\n            res = Math.max(res, sum2);\n            right++;\n        }\n        return res;\n        \n    }\n}"}
{"id": "2160", "path": "output2\\java\\Hard\\2160-maximum-score-of-a-node-sequence.java", "hypo_code": "class MaximumScoreOfANodeSequence {\n    public int maximumScore(int[] scores, int[][] edges) {\n        int n = scores.length;\n        int[] visited = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (visited[i] == 0) {\n                res += dfs(scores, visited, i);\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "2161", "path": "output2\\java\\Hard\\2161-longest-path-with-different-adjacent-characters.java", "hypo_code": "class LongestPathWithDifferentAdjacentCharacters {\n    public int longestPath(int[] parent, String s) {\n        int n = s.length();\n        int[] dp = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && s.charAt(i) != s.charAt(parent[i])) {\n                dp[i] = dp[parent[i]] + 1;\n            } else {\n                dp[i] = 1;\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2162", "path": "output2\\java\\Hard\\2162-number-of-flowers-in-full-bloom.java", "hypo_code": "class Solution {\n    public int[] fullBloomFlowers(int[][] flowers, int[] people) {\n        int n = flowers.length;\n        int[] res = new int[people.length];\n        Arrays.fill(res, -1);\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int i = 0; i < n; i++) {\n            map.put(flowers[i][0], i);\n        }\n        for (int i = 0; i < people.length; i++) {\n            Integer key = map.floorKey(people[i]);\n            if (key != null) {\n                int index = map.get(key);\n                if (people[i] <= flowers[index][1]) {\n                    res[i] = index;\n                    map.remove(key);\n                }\n            }\n        }\n        for (int i = 0; i < res.length; i++) {\n            if (res[i] != -1) {\n                res[i] = flowers[res[i]][1];\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2163", "path": "output2\\java\\Hard\\2163-escape-the-spreading-fire.java", "hypo_code": "class EscapeTheSpreadingFire {\n    public int maximumMinutes(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dist = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n        }\n        dist[0][0] = 0;\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0});\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int x = cur[0];\n            int y = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] != 2 && dist[nx][ny] == Integer.MAX_VALUE) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    queue.offer(new int[]{nx, ny});\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    for (int k = 0; k < 4; k++) {\n                        int nx = i + dx[k];\n                        int ny = j + dy[k];\n                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] != 2) {\n                            res = Math.max(res, dist[nx][ny] - 1);\n                        }\n                    }\n                }\n            }\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n        \n        \n    }\n}"}
{"id": "2164", "path": "output2\\java\\Hard\\2164-total-appeal-of-a-string.java", "hypo_code": "class TotalAppealOfAString {\n    public long appealSum(String s) {\n        int n = s.length();\n        long res = 0;\n        int[] dp = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && s.charAt(i) == s.charAt(i - 1)) {\n                dp[i] = dp[i - 1];\n            } else {\n                dp[i] = 1;\n            }\n            res += dp[i];\n        }\n        return res;\n        \n    }\n}"}
{"id": "2165", "path": "output2\\java\\Hard\\2165-check-if-there-is-a-valid-parentheses-string-path.java", "hypo_code": "class CheckIfThereIsAValidParenthesesStringPath {\n    public boolean hasValidPath(char[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] dirs = new int[][][]{{{0, 1}, {0, -1}}, {{1, 0}, {-1, 0}}, {{1, 0}, {0, 1}}, {{1, 0}, {0, -1}}, {{-1, 0}, {0, 1}}, {{-1, 0}, {0, -1}}};\n        boolean[][] visited = new boolean[m][n];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0});\n        visited[0][0] = true;\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int x = cur[0];\n            int y = cur[1];\n            if (x == m - 1 && y == n - 1) {\n                return true;\n            }\n            int[][] dir = dirs[grid[x][y] - '1'];\n            for (int[] d : dir) {\n                int nx = x + d[0];\n                int ny = y + d[1];\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) {\n                    continue;\n                }\n                for (int[] d2 : dirs[grid[nx][ny] - '1']) {\n                    if (d2[0] == -d[0] && d2[1] == -d[1]) {\n                        queue.offer(new int[]{nx, ny});\n                        visited[nx][ny] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return false;\n        \n    }\n}"}
{"id": "2166", "path": "output2\\java\\Hard\\2166-substring-with-largest-variance.java", "hypo_code": "class SubstringWithLargestVariance {\n    public int largestVariance(String s) {\n        int n = s.length();\n        int res = 0;\n        int[] dp = new int[26];\n        for (int i = 0; i < n; i++) {\n            int[] temp = new int[26];\n            for (int j = i; j < n; j++) {\n                temp[s.charAt(j) - 'a']++;\n                int max = 0;\n                int min = n;\n                for (int k = 0; k < 26; k++) {\n                    if (temp[k] > 0) {\n                        max = Math.max(max, temp[k]);\n                        min = Math.min(min, temp[k]);\n                    }\n                }\n                res = Math.max(res, max - min);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2168", "path": "output2\\java\\Hard\\2168-sum-of-total-strength-of-wizards.java", "hypo_code": "class SumOfTotalStrengthOfWizards {\n    public int totalStrength(int[] strength) {\n        int n = strength.length;\n        int[] dp = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (i >= 1) {\n                dp[i] = Math.min(dp[i - 1], strength[i]);\n            } else {\n                dp[i] = strength[i];\n            }\n            res += dp[i];\n        }\n        return res;\n        \n    }\n}"}
{"id": "2170", "path": "output2\\java\\Hard\\2170-minimum-obstacle-removal-to-reach-corner.java", "hypo_code": "class Solution {\n    public int minimumObstacles(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        for (int[] row : dp) {\n            Arrays.fill(row, m * n);\n        }\n        dp[0][0] = 0;\n        for (int i = 1; i <= m; i++) {\n            if (grid[i - 1][0] == 1) {\n                break;\n            }\n            dp[i][0] = 0;\n        }\n        for (int j = 1; j <= n; j++) {\n            if (grid[0][j - 1] == 1) {\n                break;\n            }\n            dp[0][j] = 0;\n        }\n        for (int i = 1; i <= m; i++) {\n            int count = 0;\n            for (int j = 1; j <= n; j++) {\n                if (grid[i - 1][j - 1] == 1) {\n                    count++;\n                }\n                if (grid[i - 1][j - 1] == 0) {\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + count;\n                }\n            }\n            count = 0;\n            for (int j = n; j >= 1; j--) {\n                if (grid[i - 1][j - 1] == 1) {\n                    count++;\n                }\n                if (grid[i - 1][j - 1] == 0) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + count);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}"}
{"id": "2172", "path": "output2\\java\\Hard\\2172-match-substring-after-replacement.java", "hypo_code": "class Solution {\n    public boolean matchReplacement(String s, String sub, char[][] mappings) {\n         int n = s.length(), m = sub.length();\n        int[][] dp = new int[n + 1][m + 1];\n        dp[0][0] = 1;\n        for (char[] mapping : mappings) {\n            char old = mapping[0], ne = mapping[1];\n            for (int i = 0; i < n; i++) {\n                dp[i + 1][0] |= dp[i][0] & (s.charAt(i) == ne);\n                for (int j = 0; j < m; j++) {\n                    if (s.charAt(i) == ne) {\n                        dp[i + 1][j + 1] |= dp[i][j + 1];\n                    }\n                    if (s.charAt(i) == old) {\n                        dp[i + 1][j + 1] |= dp[i][j];\n                    }\n                }\n            }\n        }\n        return dp[n][m] == 1;\n    }\n}"}
{"id": "2173", "path": "output2\\java\\Hard\\2173-count-subarrays-with-score-less-than-k.java", "hypo_code": "class Solution {\n    public long countSubarrays(int[] nums, long k) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        long res = 0;\n        for (int i = 1; i <= n; i++) {\n            prefix[i] = prefix[i - 1] + nums[i - 1];\n            for (int j = 0; j < i; j++) {\n                if (prefix[i] - prefix[j] < k) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2174", "path": "output2\\java\\Hard\\2174-naming-a-company.java", "hypo_code": "class Solution {\n    public long distinctNames(String[] ideas) {\n        int n = ideas.length;\n        long res = 0;\n        Map<String, Integer> map = new HashMap<>();\n        for (String idea : ideas) {\n            String key = getKey(idea);\n            if (!map.containsKey(key)) {\n                map.put(key, 1);\n            } else {\n                map.put(key, map.get(key) + 1);\n            }\n        }\n        for (String idea : ideas) {\n            String key = getKey(idea);\n            res += map.get(key) - 1;\n        }\n        return res / 2;\n    }\n\n    public String getKey(String s) {\n        int n = s.length();\n        char[] arr = s.toCharArray();\n        Arrays.sort(arr);\n        return new String(arr);\n    }\n}"}
{"id": "2175", "path": "output2\\java\\Hard\\2175-selling-pieces-of-wood.java", "hypo_code": "class Solution {\n    public long sellingWood(int m, int n, int[][] prices) {\n        Arrays.sort(prices, (a, b) -> Integer.compare(a[0], b[0]));\n        long[][] dp = new long[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        dp[0][0] = 0;\n        for (int[] price : prices) {\n            int h = price[0];\n            int w = price[1];\n            int p = price[2];\n            for (int i = m; i >= h; i--) {\n                for (int j = n; j >= w; j--) {\n                    if (dp[i - h][j - w] != -1) {\n                        dp[i][j] = Math.max(dp[i][j], dp[i - h][j - w] + p);\n                    }\n                }\n            }\n        }\n        return dp[m][n];\n\n    }\n}"}
{"id": "2176", "path": "output2\\java\\Hard\\2176-number-of-distinct-roll-sequences.java", "hypo_code": "class Solution {\n    public int distinctSequences(int n) {\n        int mod = 1000000007;\n        long[][] dp = new long[n + 1][7];\n        for (int i = 1; i <= 6; i++) {\n            dp[1][i] = 1;\n        }\n        for (int i = 2; i <= n; i++) {\n            dp[i][1] = (dp[i - 1][2] + dp[i - 1][3] + dp[i - 1][5] + dp[i - 1][6]) % mod;\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][6]) % mod;\n            dp[i][3] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][5] + dp[i - 1][6]) % mod;\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][5]) % mod;\n            dp[i][5] = (dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][6]) % mod;\n            dp[i][6] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3] + dp[i - 1][5]) % mod;\n        }\n        long res = 0;\n        for (int i = 1; i <= 6; i++) {\n            res = (res + dp[n][i]) % mod;\n        }\n        return (int) res;\n    }\n}"}
{"id": "2177", "path": "output2\\java\\Hard\\2177-maximum-score-of-spliced-array.java", "hypo_code": "class Solution {\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        int[] prefix1 = new int[n + 1], prefix2 = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            prefix1[i] = prefix1[i - 1] + nums1[i - 1];\n            prefix2[i] = prefix2[i - 1] + nums2[i - 1];\n        }\n        int res = 0;\n        for (int i = 0; i <= n; i++) {\n            int left = i, right = n;\n            while (left < right) {\n                int mid = left + right + 1 >> 1;\n                if (prefix1[mid] - prefix1[i] < prefix2[mid] - prefix2[i]) {\n                    left = mid;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            res = Math.max(res, prefix1[i] - prefix1[0] + prefix2[left] - prefix2[i]);\n            res = Math.max(res, prefix2[i] - prefix2[0] + prefix1[left] - prefix1[i]);\n        }\n        return res;\n    }\n}"}
{"id": "2178", "path": "output2\\java\\Hard\\2178-minimum-score-after-removals-on-a-tree.java", "hypo_code": "class Solution {\n    public int minimumScore(int[] nums, int[][] edges) {\n        int n = nums.length;\n        int[] degree = new int[n];\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int[] edge : edges) {\n            int x = edge[0];\n            int y = edge[1];\n            degree[x]++;\n            degree[y]++;\n            map.putIfAbsent(x, new ArrayList<>());\n            map.putIfAbsent(y, new ArrayList<>());\n            map.get(x).add(y);\n            map.get(y).add(x);\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 1) {\n                queue.offer(i);\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            int[] tmp = new int[n];\n            for (int i = 0; i < size; i++) {\n                int cur = queue.poll();\n                tmp[cur] = 1;\n                for (int next : map.get(cur)) {\n                    if (tmp[next] == 0) {\n                        degree[next]--;\n                        if (degree[next] == 1) {\n                            queue.offer(next);\n                        }\n                    }\n                }\n            }\n            int score = getScore(tmp, nums, map);\n            res = Math.min(res, score);\n        }\n        return res;\n    }\n}"}
{"id": "2179", "path": "output2\\java\\Hard\\2179-number-of-increasing-paths-in-a-grid.java", "hypo_code": "class Solution {\n    public int countPaths(int[][] grid) {\n       int m = grid.length;\n        int n = grid[0].length;\n        int[][] dp = new int[m][n];\n\n        dp[0][0] = 1;\n        int mod = 1000000007;\n        for (int i = 1; i < m; i++) {\n            dp[i][0] = grid[i][0] < grid[i - 1][0] ? dp[i - 1][0] : 0;\n        }\n        for (int j = 1; j < n; j++) {\n            dp[0][j] = grid[0][j] < grid[0][j - 1] ? dp[0][j - 1] : 0;\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j <= n; j++) {\n                int up = grid[i][j - 1] < grid[i - 1][j - 1] ? dp[i - 1][j - 1] : 0;\n                int left = grid[i - 1][j] < grid[i - 1][j - 1] ? dp[i - 1][j - 1] : 0;\n                dp[i][j] = (up + left) % mod;\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}"}
{"id": "2180", "path": "output2\\java\\Hard\\2180-subarray-with-elements-greater-than-varying-threshold.java", "hypo_code": "class Solution {\n    public int validSubarraySize(int[] nums, int threshold) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        int res = -1;\n        for (int i = 1; i <= n; i++) {\n            prefix[i] = prefix[i - 1] + nums[i - 1];\n            for (int j = 0; j < i; j++) {\n                if (prefix[i] - prefix[j] > threshold) {\n                    res = Math.max(res, i - j - 1);\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2181", "path": "output2\\java\\Hard\\2181-count-the-number-of-ideal-arrays.java", "hypo_code": "class Solution {\n    public int idealArrays(int n, int maxValue) {\n        int mod = 1000000007;\n        long[][] dp = new long[n + 1][maxValue + 1];\n        for (int i = 1; i <= maxValue; i++) {\n            dp[1][i] = 1;\n        }\n        for (int i = 2; i <= n; i++) {\n            long sum = 0;\n            for (int j = 1; j <= maxValue; j++) {\n                sum = (sum + dp[i - 1][j]) % mod;\n            }\n            for (int j = 1; j <= maxValue; j++) {\n                for (int k = 1; k <= maxValue / j; k++) {\n                    dp[i][j * k] = (dp[i][j * k] + sum - dp[i - 1][j] + mod) % mod;\n                }\n            }\n        }\n        long res = 0;\n        for (int i = 1; i <= maxValue; i++) {\n            res = (res + dp[n][i]) % mod;\n        }\n        return (int) res;\n    }\n}"}
{"id": "2182", "path": "output2\\java\\Hard\\2182-minimum-deletions-to-make-array-divisible.java", "hypo_code": "class Solution {\n    public int minOperations(int[] nums, int[] numsDivide) {\n        int n = nums.length;\n        int[] count = new int[100001];\n        for (int num : numsDivide) {\n            count[num]++;\n        }\n        int res = Integer.MAX_VALUE;\n        for (int num : nums) {\n            int cur = 0;\n            for (int i = num; i <= 100000; i += num) {\n                cur += count[i];\n            }\n            res = Math.min(res, n - cur);\n        }\n        return res == Integer.MAX_VALUE ? -1 : res;\n    }\n}"}
{"id": "2183", "path": "output2\\java\\Hard\\2183-shortest-impossible-sequence-of-rolls.java", "hypo_code": "class Solution {\n    public int shortestSequence(int[] rolls, int k) {\n        int n = rolls.length;\n        int[] dp = new int[k + 1];\n        int[] next = new int[k + 1];\n        Arrays.fill(dp, -1);\n        dp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(next, -1);\n            for (int j = 0; j <= k; j++) {\n                if (dp[j] != -1) {\n                    int val = (j + rolls[i]) % k;\n                    next[val] = Math.max(next[val], dp[j] + 1);\n                    val = (j + rolls[i] - 1) % k;\n                    next[val] = Math.max(next[val], dp[j] + 1);\n                }\n            }\n            dp = next;\n        }\n        int res = 0;\n        for (int i = 0; i <= k; i++) {\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n    }\n}"}
{"id": "2184", "path": "output2\\java\\Hard\\2184-number-of-excellent-pairs.java", "hypo_code": "class Solution {\n    public long countExcellentPairs(int[] nums, int k) {\n        int n = nums.length;\n        long[] count = new long[32];\n        for (int num : nums) {\n            for (int i = 0; i < 32; i++) {\n                if ((num >> i & 1) == 1) {\n                    count[i]++;\n                }\n            }\n        }\n        long res = 0;\n        for (int num : nums) {\n            long[] tmp = new long[32];\n            for (int i = 0; i < 32; i++) {\n                if ((num >> i & 1) == 1) {\n                    tmp[i]++;\n                }\n            }\n            for (int i = 0; i < 32; i++) {\n                if ((num >> i & 1) == 1) {\n                    res += count[i] - tmp[i];\n                } else {\n                    res += tmp[i];\n                }\n            }\n        }\n        return res / 2;\n    }\n}"}
{"id": "2185", "path": "output2\\java\\Hard\\2185-longest-cycle-in-a-graph.java", "hypo_code": "class Solution {\n    public int longestCycle(int[] edges) {\n        int n = edges.length;\n        int[] visited = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (visited[i] != 0) {\n                continue;\n            }\n            int cur = i;\n            int count = 0;\n            while (visited[cur] == 0) {\n                count++;\n                visited[cur] = count;\n                cur = edges[cur];\n            }\n            if (visited[cur] == count) {\n                res = Math.max(res, count);\n            }\n        }\n        return res == 1 ? -1 : res;\n\n    }\n}"}
{"id": "2186", "path": "output2\\java\\Hard\\2186-minimum-replacements-to-sort-the-array.java", "hypo_code": "class Solution {\n    public long minimumReplacement(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, n);\n        dp[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int min = dp[i - 1] + 1;\n            for (int j = i - 1; j >= 0; j--) {\n                if (nums[i] >= 2 * nums[j]) {\n                    min = Math.min(min, dp[j] + i - j - 1);\n                }\n            }\n            dp[i] = min;\n        }\n        return dp[n - 1];\n    }\n}"}
{"id": "2187", "path": "output2\\java\\Hard\\2187-count-special-integers.java", "hypo_code": "class Solution {\n    public int countSpecialNumbers(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            int tmp = i;\n            boolean[] visited = new boolean[10];\n            boolean flag = true;\n            while (tmp > 0) {\n                int cur = tmp % 10;\n                if (visited[cur]) {\n                    flag = false;\n                    break;\n                }\n                visited[cur] = true;\n                tmp /= 10;\n            }\n            if (flag) {\n                res++;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2188", "path": "output2\\java\\Hard\\2188-maximum-segment-sum-after-removals.java", "hypo_code": "class Solution {\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            prefix[i] = prefix[i - 1] + nums[i - 1];\n        }\n        long[] res = new long[removeQueries.length];\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int i = 0; i < n; i++) {\n            map.put(prefix[i], i);\n        }\n        for (int i = 0; i < removeQueries.length; i++) {\n            Integer key = map.floorKey(prefix[removeQueries[i]]);\n            if (key != null) {\n                int index = map.get(key);\n                if (index < removeQueries[i]) {\n                    res[i] = prefix[removeQueries[i]] - prefix[index];\n                } else {\n                    res[i] = prefix[index] - prefix[removeQueries[i]];\n                }\n                map.remove(key);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2189", "path": "output2\\java\\Hard\\2189-find-the-k-sum-of-an-array.java", "hypo_code": "class Solution {\n    public long kSum(int[] nums, int k) {\n        int n = nums.length;\n        long[] dp = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1] + nums[i - 1];\n        }\n        long[][] f = new long[n + 1][k + 1];\n        for (int i = 1; i <= n; i++) {\n            f[i][1] = dp[i];\n            for (int j = 2; j <= Math.min(k, i); j++) {\n                f[i][j] = Long.MIN_VALUE;\n                for (int l = 0; l < i; l++) {\n                    f[i][j] = Math.max(f[i][j], f[l][j - 1] + dp[i] - dp[l]);\n                }\n            }\n        }\n        return f[n][k];\n    }\n}"}
{"id": "2190", "path": "output2\\java\\Hard\\2190-build-a-matrix-with-conditions.java", "hypo_code": "class Solution {\n    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {\n        int n = rowConditions.length;\n        int m = colConditions.length;\n        int[][] res = new int[k][k];\n        int[] row = new int[k];\n        int[] col = new int[k];\n        for (int i = 0; i < n; i++) {\n            int above = rowConditions[i][0] - 1;\n            int below = rowConditions[i][1] - 1;\n            row[below] = above;\n        }\n        for (int i = 0; i < m; i++) {\n            int left = colConditions[i][0] - 1;\n            int right = colConditions[i][1] - 1;\n            col[right] = left;\n        }\n        for (int i = 0; i < k; i++) {\n            res[i][col[i]] = i + 1;\n            res[row[i]][i] = i + 1;\n        }\n        for (int i = 0; i < k; i++) {\n            for (int j = 0; j < col[i]; j++) {\n                if (res[i][j] == 0) {\n                    res[i][j] = k;\n                    k--;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2191", "path": "output2\\java\\Hard\\2191-maximum-number-of-robots-within-budget.java", "hypo_code": "class Solution {\n    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {\n        int n = chargeTimes.length;\n        int[] prefix = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            prefix[i] = prefix[i - 1] + runningCosts[i - 1];\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int left = i, right = n;\n            while (left < right) {\n                int mid = left + right + 1 >> 1;\n                if (chargeTimes[mid] - chargeTimes[i] + (long) prefix[mid] * (mid - i) <= budget) {\n                    left = mid;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            res = Math.max(res, left - i + 1);\n        }\n        return res;\n    }\n}"}
{"id": "2192", "path": "output2\\java\\Hard\\2192-meeting-rooms-iii.java", "hypo_code": "class Solution {\n    public int mostBooked(int n, int[][] meetings) {\n        int[] delta = new int[n + 1];\n        for (int[] meeting : meetings) {\n            delta[meeting[0]]++;\n            delta[meeting[1]]--;\n        }\n        int res = 0, cur = 0;\n        for (int i = 0; i < n; i++) {\n            cur += delta[i];\n            res = Math.max(res, cur);\n        }\n        return res;\n    }\n}"}
{"id": "2193", "path": "output2\\java\\Hard\\2193-longest-increasing-subsequence-ii.java", "hypo_code": "class Solution {\n    public int lengthOfLIS(int[] nums, int k) {\n        int n = nums.length;\n        int[][] dp = new int[n + 1][k + 1];\n        for (int i = 1; i <= n; i++) {\n            int max = 0;\n            for (int j = 0; j < i; j++) {\n                if (nums[i - 1] - nums[j] <= k) {\n                    max = Math.max(max, dp[j][nums[i - 1] - nums[j]] + 1);\n                }\n            }\n            for (int j = 0; j <= k; j++) {\n                dp[i][j] = Math.max(dp[i - 1][j], max);\n            }\n        }\n        return dp[n][k];\n    }\n}"}
{"id": "2194", "path": "output2\\java\\Hard\\2194-minimum-money-required-before-transactions.java", "hypo_code": "class Solution {\n    public long minimumMoney(int[][] transactions) {\n        long res = 0;\n        TreeMap<Integer, Long> map = new TreeMap<>();\n        for (int[] transaction : transactions) {\n            int cost = transaction[0];\n            int cashback = transaction[1];\n            map.put(cost, map.getOrDefault(cost, 0L) + cashback);\n        }\n        for (Map.Entry<Integer, Long> entry : map.entrySet()) {\n            int cost = entry.getKey();\n            long cashback = entry.getValue();\n            long min = Math.min(cost, cashback);\n            cost -= min;\n            cashback -= min;\n            res += cost;\n            if (cashback > 0) {\n                map.put(cost, map.getOrDefault(cost, 0L) + cashback);\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2195", "path": "output2\\java\\Hard\\2195-sum-of-prefix-scores-of-strings.java", "hypo_code": "class Solution {\n    public int[] sumPrefixScores(String[] words) {\n        int n = words.length;\n        int[] ans = new int[n];\n        Trie trie = new Trie();\n        for (int i = 0; i < n; i++) {\n            trie.insert(words[i]);\n            ans[i] = trie.search(words[i]);\n        }\n        return ans;\n    }\n}"}
{"id": "2196", "path": "output2\\java\\Hard\\2196-number-of-good-paths.java", "hypo_code": "class Solution {\n    public int numberOfGoodPaths(int[] vals, int[][] edges) {\n        int n = vals.length;\n        List<int[]>[] graph = new List[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        int mod = 1000000007;\n        for (int[] edge : edges) {\n            int x = edge[0];\n            int y = edge[1];\n            graph[x].add(new int[]{y, vals[y]});\n            graph[y].add(new int[]{x, vals[x]});\n        }\n        int[] res = new int[1];\n        dfs(graph, 0, vals[0], res, mod);\n        return res[0];\n    }\n\n    public int[] dfs(List<int[]>[] graph, int cur, int max, int[] res, int mod) {\n        if (graph[cur].size() == 1 && cur != 0) {\n            return new int[]{1, max};\n        }\n        int[] maxes = new int[graph[cur].size()];\n        int[] sums = new int[graph[cur].size()];\n        int index = 0;\n        for (int[] next : graph[cur]) {\n            int[] temp = dfs(graph, next[0], Math.max(max, next[1]), res, mod);\n            maxes[index] = temp[1];\n            sums[index] = temp[0];\n            index++;\n        }\n        for (int i = 0; i < graph[cur].size(); i++) {\n            for (int j = i + 1; j < graph[cur].size(); j++) {\n                if (maxes[i] == maxes[j]) {\n                    res[0] = (res[0] + sums[i] * sums[j]) % mod;\n                }\n            }\n        }\n        return new int[]{Arrays.stream(sums).sum(), max};\n    }\n}"}
{"id": "2197", "path": "output2\\java\\Hard\\2197-number-of-pairs-satisfying-inequality.java", "hypo_code": "class Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\n        int n = nums1.length;\n        int[][] pairs = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            pairs[i] = new int[]{nums1[i] - nums2[i], nums1[i]};\n        }\n        Arrays.sort(pairs, (a, b) -> a[0] - b[0]);\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            int left = i + 1, right = n;\n            while (left < right) {\n                int mid = left + right >> 1;\n                if (pairs[mid][0] < pairs[i][0] + diff) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            res += n - right;\n        }\n        return res;\n    }\n}"}
{"id": "2198", "path": "output2\\java\\Hard\\2198-maximum-deletions-on-a-string.java", "hypo_code": "class Solution {\n    public int deleteString(String s) {\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1] + 1;\n            for (int j = 1; j <= i / 2; j++) {\n                if (s.substring(0, j).equals(s.substring(i - j, i))) {\n                    dp[i] = Math.min(dp[i], dp[i - j] + 1);\n                }\n            }\n        }\n        return dp[n];\n    }\n}"}
{"id": "2199", "path": "output2\\java\\Hard\\2199-paths-in-matrix-whose-sum-is-divisible-by-k.java", "hypo_code": "class Solution {\n    public int numberOfPaths(int[][] grid, int k) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        dp[0][0] = grid[0][0] % k == 0 ? 1 : 0;\n        for (int i = 1; i <= m; i++) {\n            if (grid[i - 1][0] % k == 0) {\n                dp[i][0] = dp[i - 1][0];\n            }\n        }\n        for (int j = 1; j <= n; j++) {\n            if (grid[0][j - 1] % k == 0) {\n                dp[0][j] = dp[0][j - 1];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <=n; j++) {\n                if (grid[i - 1][j - 1] % k == 0) {\n                    dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % 1000000007;\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}"}
{"id": "2200", "path": "output2\\java\\Hard\\2200-create-components-with-same-value.java", "hypo_code": "class Solution {\n    public int componentValue(int[] nums, int[][] edges) {\n        int n = nums.length;\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int[] edge : edges) {\n            int x = edge[0];\n            int y = edge[1];\n            map.putIfAbsent(x, new ArrayList<>());\n            map.putIfAbsent(y, new ArrayList<>());\n            map.get(x).add(y);\n            map.get(y).add(x);\n        }\n        int[] res = new int[1];\n        dfs(nums, map, 0, new HashSet<>(), res);\n        return res[0];\n    }\n    private int dfs(int[] nums, Map<Integer, List<Integer>> map, int cur, Set<Integer> visited, int[] res) {\n        if (visited.contains(cur)) {\n            return 0;\n        }\n        visited.add(cur);\n        int sum = nums[cur];\n        for (int next : map.get(cur)) {\n            sum += dfs(nums, map, next, visited, res);\n        }\n        res[0] = Math.max(res[0], sum);\n        return sum;\n    }\n}"}
{"id": "2201", "path": "output2\\java\\Hard\\2201-count-subarrays-with-fixed-bounds.java", "hypo_code": "class Solution {\n    public long countSubarrays(int[] nums, int minK, int maxK) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        long res = 0;\n        for (int i = 1; i <= n; i++) {\n            prefix[i] = prefix[i - 1] + nums[i - 1];\n            for (int j = 0; j < i; j++) {\n                if (prefix[i] - prefix[j] >= minK && prefix[i] - prefix[j] <= maxK) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2202", "path": "output2\\java\\Hard\\2202-minimum-cost-to-make-array-equal.java", "hypo_code": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n     int n = nums.length;\n        long res = 0;\n        for (int i = 1; i < n; i++) {\n            if (nums[i] != nums[i - 1]) {\n                res += Math.min(cost[i], cost[i - 1]);\n            }\n        }\n        return res;   \n    }\n}"}
{"id": "2203", "path": "output2\\java\\Hard\\2203-minimum-number-of-operations-to-make-arrays-similar.java", "hypo_code": "class Solution {\n    public long makeSimilar(int[] nums, int[] target) {\n        int n = nums.length;\n        int[] diff = new int[n];\n        for (int i = 0; i < n; i++) {\n            diff[i] = nums[i] - target[i];\n        }\n        Arrays.sort(diff);\n        int mid = diff[n / 2];\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            res += Math.abs(diff[i] - mid);\n        }\n        return res;\n    }\n}"}
{"id": "2204", "path": "output2\\java\\Hard\\2204-next-greater-element-iv.java", "hypo_code": "class Solution {\n    public int[] secondGreaterElement(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && nums[stack.peek()] <= nums[i]) {\n                stack.pop();\n            }\n            res[i] = stack.isEmpty() ? -1 : nums[stack.peek()];\n            stack.push(i);\n        }\n        return res;\n    }\n}"}
{"id": "2205", "path": "output2\\java\\Hard\\2205-height-of-binary-tree-after-subtree-removal-queries.java", "hypo_code": "class HeightOfBinaryTreeAfterSubtreeRemovalQueries {\n    public int[] treeQueries(TreeNode root, int[] queries) {\n        int[] res = new int[queries.length];\n        Map<Integer, TreeNode> map = new HashMap<>();\n        map.put(root.val, root);\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            TreeNode node = q.poll();\n            if(node.left != null){\n                map.put(node.left.val, node.left);\n                q.offer(node.left);\n            }\n            if(node.right != null){\n                map.put(node.right.val, node.right);\n                q.offer(node.right);\n            }\n        }\n        for(int i = 0; i < queries.length; i++){\n            TreeNode node = map.get(queries[i]);\n            if(node == root){\n                res[i] = 0;\n                continue;\n            }\n            TreeNode parent = map.get(node.val);\n            if(parent.left == node){\n                parent.left = null;\n            }else{\n                parent.right = null;\n            }\n            res[i] = height(root);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2206", "path": "output2\\java\\Hard\\2206-minimum-total-distance-traveled.java", "hypo_code": "class MinimumTotalDistanceTraveled {\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\n        int n = robot.size();\n        int m = factory.length;\n        long[] dist = new long[n];\n        long res = Long.MAX_VALUE;\n        for (int i = 0; i < m; i++) {\n            int pos = factory[i][0];\n            int limit = factory[i][1];\n            for (int j = 0; j < n; j++) {\n                dist[j] += Math.abs(robot.get(j) - pos);\n            }\n            Arrays.sort(dist);\n            long sum = 0;\n            for (int j = 0; j < limit; j++) {\n                sum += dist[j];\n            }\n            res = Math.min(res, sum);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2207", "path": "output2\\java\\Hard\\2207-split-message-based-on-limit.java", "hypo_code": "class SplitMessageBasedOnLimit {\n    public String[] splitMessage(String message, int limit) {\n        int n = message.length();\n        int[] dp = new int[n];\n        int[] prev = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        for (int i = 0; i < n; i++) {\n            if (i < limit) {\n                dp[i] = 1;\n                prev[i] = -1;\n            }\n            for (int j = i - limit; j >= 0; j--) {\n                if (dp[j] == Integer.MAX_VALUE) {\n                    continue;\n                }\n                if (isPalindrome(message, j + 1, i)) {\n                    if (dp[i] > dp[j] + 1) {\n                        dp[i] = dp[j] + 1;\n                        prev[i] = j;\n                    }\n                }\n            }\n        }\n        if (dp[n - 1] == Integer.MAX_VALUE) {\n            return new String[0];\n        }\n        String[] res = new String[dp[n - 1]];\n        int idx = n - 1;\n        for (int i = dp[n - 1] - 1; i >= 0; i--) {\n            res[i] = message.substring(prev[idx] + 1, idx + 1) + \"<\" + (i + 1) + \"/\" + dp[n - 1] + \">\";\n            idx = prev[idx];\n        }\n        return res;\n        \n    }\n}"}
{"id": "2208", "path": "output2\\java\\Hard\\2208-maximum-number-of-non-overlapping-palindrome-substrings.java", "hypo_code": "class MaximumNumberOfNonOverlappingPalindromeSubstrings {\n    public int maxPalindromes(String s, int k) {\n        int n = s.length();\n        int[] dp = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (i >= k - 1) {\n                dp[i] = 1;\n            }\n            if (i >= k) {\n                dp[i] += dp[i - k];\n            }\n            if (i >= k - 1 && isPalindrome(s, i - k + 1, i)) {\n                res += dp[i - k + 1];\n            }\n        }\n        return res;\n        \n        \n        \n    }\n}"}
{"id": "2209", "path": "output2\\java\\Hard\\2209-number-of-beautiful-partitions.java", "hypo_code": "class NumberOfBeautifulPartitions {\n    public int beautifulPartitions(String s, int k, int minLength) {\n        int n = s.length();\n        int[] dp = new int[n];\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (isPrime(s.charAt(i)) && i >= minLength - 1 && !isPrime(s.charAt(i - minLength + 1))) {\n                dp[i] = 1;\n            }\n            if (i >= minLength) {\n                dp[i] += dp[i - minLength];\n            }\n            if (i >= k - 1) {\n                res += dp[i - k + 1];\n            }\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "2210", "path": "output2\\java\\Hard\\2210-count-palindromic-subsequences.java", "hypo_code": "class CountPalindromicSubsequences {\n    public int countPalindromes(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = 3;\n            } else {\n                dp[i][i + 1] = 2;\n            }\n        }\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i + len - 1 < n; i++) {\n                int j = i + len - 1;\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1;\n                } else {\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1];\n                }\n            }\n        }\n        return dp[0][n - 1];\n        \n    }\n}"}
{"id": "2211", "path": "output2\\java\\Hard\\2211-count-subarrays-with-median-k.java", "hypo_code": "class CountSubarraysWithMedianK {\n    public int countSubarrays(int[] nums, int k) {\n        int n = nums.length;\n        int[] pre = new int[n + 1];\n        for(int i = 0; i < n; i++){\n            pre[i + 1] = pre[i] + (nums[i] < k ? -1 : 1);\n        }\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i <= n; i++){\n            res += map.getOrDefault(pre[i], 0);\n            map.put(pre[i] + 1, map.getOrDefault(pre[i] + 1, 0) + 1);\n        }\n        return res;\n        \n    }\n}"}
{"id": "2212", "path": "output2\\java\\Hard\\2212-divide-nodes-into-the-maximum-number-of-groups.java", "hypo_code": "class DivideNodesIntoTheMaximumNumberOfGroups {\n    public int magnificentSets(int n, int[][] edges) {\n        int[] degree = new int[n];\n        int[][] count = new int[n][n];\n        for (int[] edge : edges) {\n            int u = edge[0] - 1;\n            int v = edge[1] - 1;\n            degree[u]++;\n            degree[v]++;\n            count[u][v]++;\n            count[v][u]++;\n        }\n        int[] dp = new int[1 << n];\n        for (int i = 0; i < n; i++) {\n            dp[1 << i] = degree[i];\n        }\n        for (int i = 1; i < (1 << n); i++) {\n            int j = i & (-i);\n            int k = i ^ j;\n            dp[i] = dp[k] + dp[j];\n        }\n        int[] ans = new int[n + 1];\n        for (int i = 1; i < (1 << n); i++) {\n            int j = i & (-i);\n            int k = i ^ j;\n            if (dp[i] % 2 == 0) {\n                ans[dp[i] / 2] = Math.max(ans[dp[i] / 2], ans[dp[k] / 2] + ans[dp[j] / 2] + 1);\n            }\n        }\n        return ans[n / 2];\n        \n    }\n}"}
{"id": "2213", "path": "output2\\java\\Hard\\2213-minimum-total-cost-to-make-arrays-unequal.java", "hypo_code": "class MinimumTotalCostToMakeArraysUnequal {\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        long res = Long.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            int j = Arrays.binarySearch(nums2, nums1[i]);\n            if(j < 0){\n                j = -j - 1;\n            }\n            long cost = 0;\n            for(int k = 0; k < n; k++){\n                if(k != i){\n                    cost += Math.min(Math.abs(nums1[k] - nums1[i]), Math.abs(nums2[k] - nums1[i]));\n                }\n            }\n            res = Math.min(res, cost);\n            if(j < n){\n                cost = 0;\n                for(int k = 0; k < n; k++){\n                    if(k != i){\n                        cost += Math.min(Math.abs(nums1[k] - nums2[i]), Math.abs(nums2[k] - nums2[i]));\n                    }\n                }\n                res = Math.min(res, cost);\n            }\n        }\n        return res;\n        \n    }\n}"}
{"id": "2214", "path": "output2\\java\\Hard\\2214-maximum-number-of-points-from-grid-queries.java", "hypo_code": "class MaximumNumberOfPointsFromGridQueries {\n    public int[] maxPoints(int[][] grid, int[] queries) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] prefix = new int[m + 1][n + 1];\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + grid[i - 1][j - 1];\n            }\n        }\n        int[] res = new int[queries.length];\n        for(int i = 0; i < queries.length; i++){\n            int x = queries[i] / n;\n            int y = queries[i] % n;\n            int l = 0;\n            int r = Math.min(x, y) + 1;\n            while(l < r){\n                int mid = l + (r - l) / 2;\n                int sum = prefix[x + 1][y + 1] - prefix[x + 1][y - mid] - prefix[x - mid][y + 1] + prefix[x - mid][y - mid];\n                if(sum > 0){\n                    l = mid + 1;\n                }else{\n                    r = mid;\n                }\n            }\n            res[i] = l - 1;\n        }\n        return res;\n        \n    }\n}"}
{"id": "2215", "path": "output2\\java\\Hard\\2215-add-edges-to-make-degrees-of-all-nodes-even.java", "hypo_code": "class AddEdgesToMakeDegreesOfAllNodesEven {\n    public boolean isPossible(int n, List<List<Integer>> edges) {\n        int[] degree = new int[n + 1];\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        for(List<Integer> edge : edges){\n            int u = edge.get(0);\n            int v = edge.get(1);\n            degree[u]++;\n            degree[v]++;\n            map.computeIfAbsent(u, k -> new HashSet<>()).add(v);\n            map.computeIfAbsent(v, k -> new HashSet<>()).add(u);\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        for(int i = 1; i <= n; i++){\n            if(degree[i] % 2 == 1){\n                queue.offer(i);\n            }\n        }\n        while(!queue.isEmpty()){\n            int u = queue.poll();\n            if(degree[u] % 2 == 1){\n                if(!map.containsKey(u)){\n                    return false;\n                }\n                int v = map.get(u).iterator().next();\n                map.get(v).remove(u);\n                degree[v]--;\n                if(degree[v] % 2 == 1){\n                    queue.offer(v);\n                }\n            }\n        }\n        return true;\n        \n    }\n}"}
{"id": "2216", "path": "output2\\java\\Hard\\2216-cycle-length-queries-in-a-tree.java", "hypo_code": "class CycleLengthQueriesInATree {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        int m = queries.length;\n        int[] ans = new int[m];\n        int[] parent = new int[1 << n];\n        for(int i = 0; i < (1 << n); i++){\n            parent[i] = i;\n        }\n        for(int i = 0; i < m; i++){\n            int a = queries[i][0];\n            int b = queries[i][1];\n            int pa = find(parent, a);\n            int pb = find(parent, b);\n            if(pa == pb){\n                ans[i] = -1;\n            }else{\n                parent[pa] = pb;\n            }\n        }\n        for(int i = 0; i < (1 << n); i++){\n            parent[i] = i;\n        }\n        for(int i = m - 1; i >= 0; i--){\n            int a = queries[i][0];\n            int b = queries[i][1];\n            int pa = find(parent, a);\n            int pb = find(parent, b);\n            if(pa == pb){\n                ans[i] = -1;\n            }else{\n                parent[pa] = pb;\n                ans[i] = ans[i] == -1 ? 1 : ans[i] + 1;\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2217", "path": "output2\\java\\Hard\\2217-count-anagrams.java", "hypo_code": "class CountAnagrams {\n    public int countAnagrams(String s) {\n        int n = s.length();\n        int mod = 1000000007;\n        int[][] dp = new int[n + 1][n + 1];\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                dp[i][j] = -1;\n            }\n        }\n        return dfs(s, 0, 0, dp) % mod;\n        \n    }\n}"}
{"id": "2218", "path": "output2\\java\\Hard\\2218-number-of-great-partitions.java", "hypo_code": "class NumberOfGreatPartitions {\n    public int countPartitions(int[] nums, int k) {\n        int n = nums.length;\n        int[] preSum = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            preSum[i] = preSum[i - 1] + nums[i - 1];\n        }\n        int[][] dp = new int[n + 1][n + 1];\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                dp[i][j] = -1;\n            }\n        }\n        return dfs(n, k, preSum, 0, 0, dp);\n        \n    }\n}"}
{"id": "2219", "path": "output2\\java\\Hard\\2219-maximize-the-minimum-powered-city.java", "hypo_code": "class MaximizeTheMinimumPoweredCity {\n    public long maxPower(int[] stations, int r, int k) {\n        int n = stations.length;\n        long[] prefix = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = prefix[i] + stations[i];\n        }\n        long min = 0;\n        long max = prefix[n];\n        while (min < max) {\n            long mid = min + (max - min + 1) / 2;\n            if (canBuild(stations, r, k, mid, prefix)) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n        \n    }\n}"}
{"id": "2220", "path": "output2\\java\\Hard\\2220-time-to-cross-a-bridge.java", "hypo_code": "class TimeToCrossABridge {\n    public int findCrossingTime(int n, int k, int[][] time) {\n        int[][] dp = new int[n + 1][k + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= k; j++) {\n                dp[i][j] = Integer.MAX_VALUE;\n            }\n        }\n        dp[0][0] = 0;\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= k; j++) {\n                if (dp[i][j] == Integer.MAX_VALUE) {\n                    continue;\n                }\n                for (int l = 0; l <= k; l++) {\n                    if (l == j) {\n                        continue;\n                    }\n                    int next = dp[i][j] + time[j][0] + time[j][1] + time[l][2] + time[l][3];\n                    if (i + 1 <= n) {\n                        next = Math.max(next, time[l][0] + time[l][1]);\n                    }\n                    dp[i + 1][l] = Math.min(dp[i + 1][l], next);\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i <= k; i++) {\n            min = Math.min(min, dp[n][i]);\n        }\n        return min;\n        \n    }\n}"}
{"id": "2221", "path": "output2\\java\\Hard\\2221-difference-between-maximum-and-minimum-price-sum.java", "hypo_code": "class DifferenceBetweenMaximumAndMinimumPriceSum {\n    public long maxOutput(int n, int[][] edges, int[] price) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        long[] sum = new long[n];\n        long[] count = new long[n];\n        dfs(graph, sum, count, 0, -1, price);\n        long res = Long.MIN_VALUE;\n        for (int i = 0; i < n; i++) {\n            res = Math.max(res, sum[i] - sum[0] + sum[0] - count[i] * price[i]);\n        }\n        return res;\n        \n        \n    }\n}"}
{"id": "2222", "path": "output2\\java\\Hard\\2222-check-if-point-is-reachable.java", "hypo_code": "class CheckIfPointIsReachable {\n    public boolean isReachable(int targetX, int targetY) {\n        while (targetX > 0 && targetY > 0) {\n            if (targetX > targetY) {\n                targetX %= targetY;\n            } else {\n                targetY %= targetX;\n            }\n        }\n        return targetX + targetY == 1;\n        \n    }\n}"}
{"id": "2223", "path": "output2\\java\\Hard\\2223-minimum-cost-to-split-an-array.java", "hypo_code": "class MinimumCostToSplitAnArray {\n    public int minCost(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[n + 1];\n        int[] count = new int[n + 1];\n        int[] sum = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            count[nums[i - 1]]++;\n            sum[i] = sum[i - 1] + nums[i - 1];\n        }\n        for (int i = 1; i <= n; i++) {\n            dp[i] = i;\n            for (int j = 1; j <= k; j++) {\n                int l = 0;\n                int r = i;\n                while (l < r) {\n                    int mid = l + r + 1 >> 1;\n                    if (count[nums[mid - 1]] == 1) {\n                        l = mid;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                dp[i] = Math.min(dp[i], dp[l] + i - l - (sum[i] - sum[l]));\n            }\n        }\n        return dp[n];\n        \n    }\n}"}
{"id": "2224", "path": "output2\\java\\Hard\\2224-put-marbles-in-bags.java", "hypo_code": "class PutMarblesInBags {\n    public long putMarbles(int[] weights, int k) {\n        int n = weights.length;\n        long[] sum = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            sum[i] = sum[i - 1] + weights[i - 1];\n        }\n        long[][] dp = new long[n + 1][k + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(dp[i], Long.MAX_VALUE);\n        }\n        dp[0][0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= k; j++) {\n                for (int l = 0; l < i; l++) {\n                    dp[i][j] = Math.min(dp[i][j], dp[l][j - 1] + sum[i] - sum[l]);\n                }\n            }\n        }\n        long max = 0;\n        long min = Long.MAX_VALUE;\n        for (int i = 1; i <= k; i++) {\n            max = Math.max(max, dp[n][i]);\n            min = Math.min(min, dp[n][i]);\n        }\n        return max - min;\n        \n    }\n}"}
{"id": "2225", "path": "output2\\java\\Hard\\2225-count-increasing-quadruplets.java", "hypo_code": "class CountIncreasingQuadruplets {\n    public long countQuadruplets(int[] nums) {\n        int n = nums.length;\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    for (int l = k + 1; l < n; l++) {\n                        if (nums[i] < nums[k] && nums[k] < nums[j] && nums[j] < nums[l]) {\n                            ans++;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2226", "path": "output2\\java\\Hard\\2226-rearranging-fruits.java", "hypo_code": "class RearrangingFruits {\n    public long minCost(int[] basket1, int[] basket2) {\n        int n = basket1.length;\n        long[][] dp = new long[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], Long.MAX_VALUE);\n        }\n        dp[0][0] = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dp[i][j] == Long.MAX_VALUE) {\n                    continue;\n                }\n                if (i < n - 1) {\n                    dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + basket1[i]);\n                }\n                if (j < n - 1) {\n                    dp[i][j + 1] = Math.min(dp[i][j + 1], dp[i][j] + basket2[j]);\n                }\n                if (i < n - 1 && j < n - 1) {\n                    dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j] + Math.min(basket1[i], basket2[j]));\n                }\n            }\n        }\n        return dp[n - 1][n - 1] == Long.MAX_VALUE ? -1 : dp[n - 1][n - 1];\n        \n    }\n}"}
{"id": "2227", "path": "output2\\java\\Hard\\2227-subsequence-with-the-minimum-score.java", "hypo_code": "class SubsequenceWithTheMinimumScore {\n    public int minimumScore(String s, String t) {\n        int n = s.length();\n        int m = t.length();\n        int[][] dp = new int[n + 1][m + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        int lcs = dp[n][m];\n        return m - lcs;\n        \n    }\n}"}
{"id": "2228", "path": "output2\\java\\Hard\\2228-handling-sum-queries-after-update.java", "hypo_code": "class HandlingSumQueriesAfterUpdate {\n    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {\n        int n = nums1.length;\n        int m = queries.length;\n        long[] ans = new long[m];\n        int[] nums1Copy = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums1Copy[i] = nums1[i];\n        }\n        for (int i = 0; i < m; i++) {\n            int type = queries[i][0];\n            if (type == 1) {\n                int l = queries[i][1];\n                int r = queries[i][2];\n                for (int j = l; j <= r; j++) {\n                    nums1[j] = 1 - nums1[j];\n                }\n            } else if (type == 2) {\n                int p = queries[i][1];\n                for (int j = 0; j < n; j++) {\n                    nums2[j] += nums1[j] * p;\n                }\n            } else {\n                long sum = 0;\n                for (int j = 0; j < n; j++) {\n                    sum += nums2[j];\n                }\n                ans[i] = sum;\n            }\n        }\n        return ans;\n        \n    }\n}"}
{"id": "2229", "path": "output2\\java\\Hard\\2229-find-the-string-with-lcp.java", "hypo_code": "class FindTheStringWithLcp {\n    public String findTheString(int[][] lcp) {\n        int n = lcp.length;\n        char[] ans = new char[n];\n        for (int i = 0; i < n; i++) {\n            ans[i] = 'a';\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (lcp[i][j] == n - i) {\n                    continue;\n                }\n                if (ans[i + lcp[i][j]] == 'a') {\n                    ans[i + lcp[i][j]] = (char) (ans[i] + 1);\n                } else if (ans[i + lcp[i][j]] != ans[i] + 1) {\n                    return \"\";\n                }\n            }\n        }\n        return new String(ans);\n        \n    }\n}"}
{"id": "2230", "path": "output2\\java\\Hard\\2230-minimum-time-to-visit-a-cell-in-a-grid.java", "hypo_code": "class Solution {\n    public int minimumTime(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        for (int[] row : dp) {\n            Arrays.fill(row, m * n);\n        }\n        dp[0][0] = 0;\n        for (int i = 1; i <= m; i++) {\n            if (grid[i - 1][0] == 0) {\n                dp[i][0] = 0;\n            } else {\n                break;\n            }\n        }\n        for (int j = 1; j <= n; j++) {\n            if (grid[0][j - 1] == 0) {\n                dp[0][j] = 0;\n            } else {\n                break;\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            int count = 0;\n            for (int j = 1; j <= n; j++) {\n                if (grid[i - 1][j - 1] == 1) {\n                    count++;\n                }\n                if (grid[i - 1][j - 1] == 0) {\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + count;\n                }\n            }\n            count = 0;\n            for (int j = n; j >= 1; j--) {\n                if (grid[i - 1][j - 1] == 1) {\n                    count++;\n                }\n                if (grid[i - 1][j - 1] == 0) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + count);\n                }\n            }\n        }\n        return dp[m][n] == m * n ? -1 : dp[m][n];\n    }\n}"}
{"id": "2231", "path": "output2\\java\\Hard\\2231-count-number-of-possible-root-nodes.java", "hypo_code": "class Solution {\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\n        int n = edges.length + 1;\n        int[] degree = new int[n];\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int[] edge : edges) {\n            int x = edge[0];\n            int y = edge[1];\n            degree[x]++;\n            degree[y]++;\n            map.putIfAbsent(x, new ArrayList<>());\n            map.putIfAbsent(y, new ArrayList<>());\n            map.get(x).add(y);\n            map.get(y).add(x);\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 1) {\n                queue.offer(i);\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            res = Math.min(res, size);\n            for (int i = 0; i < size; i++) {\n                int cur = queue.poll();\n                degree[cur]--;\n                for (int next : map.get(cur)) {\n                    if (degree[next] > 0) {\n                        degree[next]--;\n                        if (degree[next] == 1) {\n                            queue.offer(next);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2232", "path": "output2\\java\\Hard\\2232-split-the-array-to-make-coprime-products.java", "hypo_code": "class Solution {\n    public int findValidSplit(int[] nums) {\n        int n = nums.length;\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19};\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < primes.length; i++) {\n            map.put(primes[i], new ArrayList<>());\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < primes.length; j++) {\n                if (nums[i] % primes[j] == 0) {\n                    map.get(primes[j]).add(i);\n                }\n            }\n        }\n        Map<Integer, Integer> gcd = new HashMap<>();\n        int res = -1;\n        for (int i = 0; i < n - 1; i++) {\n            int val = nums[i];\n            for (int j = 0; j < primes.length; j++) {\n                if (val % primes[j] == 0) {\n                    if (gcd.containsKey(primes[j])) {\n                        val = gcd.get(primes[j]);\n                    } else {\n                        val = primes[j];\n                    }\n                }\n            }\n            gcd.put(nums[i], val);\n            if (val == 1) {\n                res = i;\n                break;\n            }\n            int index = Collections.binarySearch(map.get(val), i + 1);\n            if (index < 0) {\n                index = -index - 1;\n            }\n            if (index < map.get(val).size()) {\n                res = i;\n                break;\n            }\n        }\n        return res;\n    }\n}"}
{"id": "2233", "path": "output2\\java\\Hard\\2233-number-of-ways-to-earn-points.java", "hypo_code": "class Solution {\n    public int waysToReachTarget(int target, int[][] types) {\n        int n = types.length;\n        int[][] dp = new int[n][target + 1];\n        int mod = 1000000007;\n        for (int i = 0; i <= target; i++) {\n            if (i % types[0][1] == 0 && i / types[0][1] <= types[0][0]) {\n                dp[0][i] = 1;\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j <= target; j++) {\n                for (int k = 0; k <= types[i][0] && j - k * types[i][1] >= 0; k++) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k * types[i][1]]) % mod;\n                }\n            }\n        }\n        return dp[n - 1][target];\n    }\n}"}
{"id": "2234", "path": "output2\\java\\Hard\\2234-minimum-time-to-complete-all-tasks.java", "hypo_code": "class Solution {\n    public int findMinimumTime(int[][] tasks) {\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\n        int res = 0;\n        int prev = 0;\n        for (int[] task : tasks) {\n            int start = task[0];\n            int end = task[1];\n            int duration = task[2];\n            if (prev < start) {\n                res += start - prev;\n            }\n            res += duration;\n            prev = end + 1;\n        }\n        return res;\n    }\n}"}
{"id": "2235", "path": "output2\\java\\Hard\\2235-collect-coins-in-a-tree.java", "hypo_code": "class Solution {\n    public int collectTheCoins(int[] coins, int[][] edges) {\n        int n = coins.length;\n        int[][] g = new int[n][n];\n        for (int[] e : edges) {\n            int u = e[0], v = e[1];\n            g[u][v] = g[v][u] = 1;\n        }\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(dp[i], -1);\n        }\n        int ans = dfs(0, 0, coins, g, dp);\n        return ans;\n    }\n\n    private int dfs(int u, int p, int[] coins, int[][] g, int[][] dp) {\n        if (dp[u][p] != -1) {\n            return dp[u][p];\n        }\n        int n = coins.length;\n        int ans = Integer.MAX_VALUE;\n        int cnt = 0;\n        for (int v = 0; v < n; ++v) {\n            if (g[u][v] == 1 && v != p) {\n                cnt++;\n                int tmp = dfs(v, u, coins, g, dp);\n                ans = Math.min(ans, tmp);\n            }\n        }\n        if (cnt == 0) {\n            ans = 0;\n        } else {\n            ans += 2;\n        }\n        if (coins[u] == 1) {\n            ans = Math.min(ans, 1);\n        }\n        dp[u][p] = ans;\n        return ans;\n    }\n}"}
{"id": "2236", "path": "output2\\java\\Hard\\2236-shortest-cycle-in-a-graph.java", "hypo_code": "class Solution {\n    public int findShortestCycle(int n, int[][] edges) { \n        int ans = Integer.MAX_VALUE;\n        int[][] g = new int[n][n];\n        for (int[] e : edges) {\n            int u = e[0], v = e[1];\n            g[u][v] = g[v][u] = 1;\n        }\n        for (int u = 0; u < n; ++u) {\n            for (int v = u + 1; v < n; ++v) {\n                if (g[u][v] == 1) {\n                    for (int w = v + 1; w < n; ++w) {\n                        if (g[u][w] == 1 && g[v][w] == 1) {\n                            ans = Math.min(ans, 3);\n                        }\n                    }\n                }\n            }\n        }\n        if (ans == Integer.MAX_VALUE) {\n            ans = -1;\n        }\n        return ans;\n    }\n}"}
{"id": "2237", "path": "output2\\java\\Hard\\2237-minimum-reverse-operations.java", "hypo_code": "class Solution {\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\n        int[] ans = new int[n];\n        Arrays.fill(ans, -1);\n        int[] cnt = new int[n];\n        for (int b : banned) {\n            cnt[b] = 1;\n        }\n        int l = Math.max(0, p - k + 1);\n        int r = Math.min(n - 1, p + k - 1);\n        for (int i = l; i <= r; ++i) {\n            if (cnt[i] == 0) {\n                ans[i] = Math.abs(i - p);\n            }\n        }\n        for (int i = 1; i < n; ++i) {\n            if (ans[i] == -1) {\n                continue;\n            }\n            for (int j = Math.max(0, i - k + 1); j <= Math.min(n - 1, i + k - 1); ++j) {\n                if (cnt[j] == 0) {\n                    ans[j] = Math.min(ans[j], ans[i] + Math.abs(j - i));\n                }\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "2238", "path": "output2\\java\\Hard\\2238-minimum-number-of-visited-cells-in-a-grid.java", "hypo_code": "class Solution {\n    public int minimumVisitedCells(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] dp = new int[m][n];\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        dp[0][0] = 0;\n        int ans = dfs(0, 0, grid, dp);\n        if (ans == Integer.MAX_VALUE) {\n            ans = -1;\n        }\n        return ans;\n    }\n}"}
{"id": "2241", "path": "output2\\java\\Hard\\2241-minimize-the-total-price-of-the-trips.java", "hypo_code": "class Solution {\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\n        int m = trips.length;\n        int[][] g = new int[n][n];\n        for (int[] e : edges) {\n            int u = e[0], v = e[1];\n            g[u][v] = g[v][u] = 1;\n        }\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(dp[i], -1);\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < m; ++i) {\n            int s = trips[i][0], e = trips[i][1];\n            int tmp = dfs(s, e, price, g, dp);\n            ans = Math.min(ans, tmp);\n        }\n        return ans;\n    }\n}"}
{"id": "2243", "path": "output2\\java\\Hard\\2243-make-array-empty.java", "hypo_code": "class Solution {\n    public long countOperationsToEmptyArray(int[] nums) {\n        int n = nums.length;\n        int[] sorted = Arrays.copyOf(nums, n);\n        Arrays.sort(sorted);\n        int[] idx = new int[n];\n        int[] cnt = new int[n];\n        for (int i = 0; i < n; ++i) {\n            idx[i] = Arrays.binarySearch(sorted, nums[i]);\n            cnt[i] = 1;\n        }\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        for (int i = 0; i < n; ++i) {\n            int j = idx[i];\n            dp[j] = Math.min(dp[j], cnt[i]);\n            if (j > 0) {\n                cnt[j - 1] += cnt[i];\n            }\n            if (j < n - 1) {\n                cnt[j + 1] += cnt[i];\n            }\n        }\n        long ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (dp[i] != Integer.MAX_VALUE) {\n                ans += dp[i];\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "2244", "path": "output2\\java\\Hard\\2244-lexicographically-smallest-beautiful-string.java", "hypo_code": "class Solution {\n    public String smallestBeautifulString(String s, int k) {\n        int n = s.length();\n        char[] ans = new char[n];\n        int[] cnt = new int[26];\n        for (char c : s.toCharArray()) {\n            ++cnt[c - 'a'];\n        }\n        int idx = 0;\n        for (int i = 0; i < 26; ++i) {\n            if (cnt[i] > 0) {\n                ans[idx++] = (char)('a' + i);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (idx == k) {\n                break;\n            }\n            for (int j = 0; j < 26; ++j) {\n                if (cnt[j] == 0) {\n                    continue;\n                }\n                --cnt[j];\n                if (isValid(cnt)) {\n                    ans[idx++] = (char)('a' + j);\n                    break;\n                }\n                ++cnt[j];\n            }\n        }\n        if (idx < k) {\n            return \"\";\n        }\n        return new String(ans);\n    }\n    private boolean isValid(int[] cnt) {\n        int sum = 0;\n        for (int i = 0; i < 26; ++i) {\n            if (cnt[i] > 0) {\n                ++sum;\n            } else {\n                sum = 0;\n            }\n            if (sum >= 2) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "2245", "path": "output2\\java\\Hard\\2245-power-of-heroes.java", "hypo_code": "class Solution {\n    public int sumOfPower(int[] nums) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        long ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = (ans + (long)nums[i] * nums[i]) % 1000000007;\n        }\n        int[] cnt = new int[1000001];\n        for (int i = 0; i < n; ++i) {\n            ++cnt[nums[i]];\n        }\n        int[] sum = new int[1000001];\n        for (int i = 1; i <= 1000000; ++i) {\n            sum[i] = sum[i - 1] + cnt[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            int p = nums[i];\n            int l = 0, r = p - 1;\n            while (l < r) {\n                int mid = l + (r - l) / 2;\n                if (sum[mid] >= i + 1) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            if (sum[l] < i + 1) {\n                ++l;\n            }\n            int len = p - l;\n            long tmp = (long)p * p * len;\n            ans = (ans + tmp) % 1000000007;\n        }\n        return (int)ans;\n    }\n}"}
{"id": "2246", "path": "output2\\java\\Hard\\2246-modify-graph-edge-weights.java", "hypo_code": "class Solution {\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\n        int[][] g = new int[n][n];\n        for (int[] e : edges) {\n            int u = e[0], v = e[1], w = e[2];\n            g[u][v] = g[v][u] = w;\n        }\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(dp[i], -1);\n        }\n        int[][] ans = new int[n][3];\n        for (int i = 0; i < n; ++i) {\n            ans[i][0] = i;\n            ans[i][1] = i;\n            ans[i][2] = g[i][i];\n        }\n        for (int i = 0; i < n; ++i) {\n            ans[i][2] = dfs(i, i, g, dp);\n        }\n        return ans;\n    }\n}"}
{"id": "2247", "path": "output2\\java\\Hard\\2247-greatest-common-divisor-traversal.java", "hypo_code": "class Solution {\n    public boolean canTraverseAllPairs(int[] nums) {\n        int n = nums.length;\n        int[] cnt = new int[100001];\n        for (int i = 0; i < n; ++i) {\n            ++cnt[nums[i]];\n        }\n        int[] sum = new int[100001];\n        for (int i = 1; i <= 100000; ++i) {\n            sum[i] = sum[i - 1] + cnt[i];\n        }\n        boolean[][] dp = new boolean[100001][100001];\n        for (int i = 1; i <= 100000; ++i) {\n            if (cnt[i] == 0) {\n                continue;\n            }\n            for (int j = i; j <= 100000; j += i) {\n                dp[i][j] = dp[j][i] = sum[j] - sum[j - i] > 0;\n            }\n        }\n        boolean ans = true;\n        for (int i = 1; i < n; ++i) {\n            if (!dp[nums[i - 1]][nums[i]]) {\n                ans = false;\n                break;\n            }\n        }\n        return ans;\n    }\n}"}
{"id": "2248", "path": "output2\\java\\Hard\\2248-maximum-strictly-increasing-cells-in-a-matrix.java", "hypo_code": "class Solution {\n    public int maxIncreasingCells(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[][] dp = new int[m][n];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            ans = Math.max(ans, dfs(i, 0, mat, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, int[][] mat, int[][] dp) {\n        int m = mat.length, n = mat[0].length;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= m) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (mat[k][l] > mat[i][j]) {\n                    ans = Math.max(ans, 1 + dfs(k, l, mat, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2249", "path": "output2\\java\\Hard\\2249-count-of-integers.java", "hypo_code": "class Solution {\n    public int count(String num1, String num2, int min_sum, int max_sum) {\n        int n1 = num1.length(), n2 = num2.length();\n        int ans = 0;\n        for (int i = n1; i <= n2; ++i) {\n            ans = (ans + dfs(0, i, 0, min_sum, max_sum, num1, num2)) % 1000000007;\n        }\n        return ans;\n    }\n    private int dfs(int i, int n, int sum, int min_sum, int max_sum, String num1, String num2) {\n        if (i == n) {\n            return sum >= min_sum && sum <= max_sum ? 1 : 0;\n        }\n        int ans = 0;\n        int l = 0, r = 9;\n        if (i == 0) {\n            l = 1;\n        }\n        for (int j = l; j <= r; ++j) {\n            int tmp = sum + j;\n            if (tmp > max_sum) {\n                continue;\n            }\n            String s = num1.substring(i, i + 1);\n            String e = num2.substring(i, i + 1);\n            if (tmp + 9 * (n - i - 1) < min_sum || tmp + Integer.parseInt(e) < min_sum || tmp + Integer.parseInt(s) > max_sum) {\n                continue;\n            }\n            ans = (ans + dfs(i + 1, n, tmp, min_sum, max_sum, num1, num2)) % 1000000007;\n        }\n        return ans;\n    }\n}"}
{"id": "2250", "path": "output2\\java\\Hard\\2250-find-a-good-subset-of-the-matrix.java", "hypo_code": "class Solution {\n    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] dp = new int[m][n];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            ans = Math.max(ans, dfs(i, 0, grid, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, int[][] grid, int[][] dp) {\n        int m = grid.length, n = grid[0].length;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= m) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (grid[k][l] > grid[i][j]) {\n                    ans = Math.max(ans, 1 + dfs(k, l, grid, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n\n    }\n}"}
{"id": "2251", "path": "output2\\java\\Hard\\2251-maximum-sum-queries.java", "hypo_code": "class Solution {\n    public int[] maximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {\n        int n = nums1.length;\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, nums1, nums2, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, int[] nums1, int[] nums2, int[][] dp) {\n        int n = nums1.length;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= n) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (nums1[k] >= nums1[i] && nums2[l] >= nums2[j]) {\n                    ans = Math.max(ans, 1 + dfs(k, l, nums1, nums2, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2252", "path": "output2\\java\\Hard\\2252-painting-the-walls.java", "hypo_code": "class Solution {\n    public int paintWalls(int[] cost, int[] time) {\n        int n = cost.length;\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, cost, time, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, int[] cost, int[] time, int[][] dp) {\n        int n = cost.length;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= n) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (cost[k] >= cost[i] && time[l] >= time[j]) {\n                    ans = Math.max(ans, 1 + dfs(k, l, cost, time, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2253", "path": "output2\\java\\Hard\\2253-robot-collisions.java", "hypo_code": "class Solution {\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {\n        int n = positions.length;\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, positions, healths, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, int[] positions, int[] healths, int[][] dp) {\n        int n = positions.length;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= n) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (positions[k] >= positions[i] && healths[l] >= healths[j]) {\n                    ans = Math.max(ans, 1 + dfs(k, l, positions, healths, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2254", "path": "output2\\java\\Hard\\2254-sum-of-imbalance-numbers-of-all-subarrays.java", "hypo_code": "class Solution {\n    public int sumImbalanceNumbers(int[] nums) {\n        int n = nums.length;\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, nums, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, int[] nums, int[][] dp) {\n        int n = nums.length;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= n) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (nums[k] >= nums[i] && nums[l] >= nums[j]) {\n                    ans = Math.max(ans, 1 + dfs(k, l, nums, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2255", "path": "output2\\java\\Hard\\2255-length-of-the-longest-valid-substring.java", "hypo_code": "class Solution {\n    public int longestValidSubstring(String word, List<String> forbidden) {\n        int m = word.length();\n        int[][] dp = new int[m][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            ans = Math.max(ans, dfs(i, 0, word, forbidden, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, String word, List<String> forbidden, int[][] dp) {\n        int m = word.length();\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= m) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= m || k == i && l == j) {\n                    continue;\n                }\n                if (word.charAt(k) >= word.charAt(i) && word.charAt(l) >= word.charAt(j)) {\n                    ans = Math.max(ans, 1 + dfs(k, l, word, forbidden, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2256", "path": "output2\\java\\Hard\\2256-maximum-number-of-groups-with-increasing-length.java", "hypo_code": "class Solution {\n    public int maxIncreasingGroups(List<Integer> usageLimits) {\n        int n = usageLimits.size();\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, usageLimits, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, List<Integer> usageLimits, int[][] dp) {\n        int n = usageLimits.size();\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= n) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (usageLimits.get(k) >= usageLimits.get(i) && usageLimits.get(l) >= usageLimits.get(j)) {\n                    ans = Math.max(ans, 1 + dfs(k, l, usageLimits, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2257", "path": "output2\\java\\Hard\\2257-count-paths-that-can-form-a-palindrome-in-a-tree.java", "hypo_code": "class Solution {\n    public long countPalindromePaths(List<Integer> parent, String s) {\n        int n = parent.size();\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, parent, s, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, List<Integer> parent, String s, int[][] dp) {\n        int n = parent.size();\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= n) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (s.charAt(k) >= s.charAt(i) && s.charAt(l) >= s.charAt(j)) {\n                    ans = Math.max(ans, 1 + dfs(k, l, parent, s, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2258", "path": "output2\\java\\Hard\\2258-count-stepping-numbers-in-range.java", "hypo_code": "class Solution {\n    public int countSteppingNumbers(String low, String high) {\n        int n = low.length();\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, low, high, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, String low, String high, int[][] dp) {\n        int n = low.length();\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= n) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (low.charAt(k) >= low.charAt(i) && high.charAt(l) >= high.charAt(j)) {\n                    ans = Math.max(ans, 1 + dfs(k, l, low, high, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2259", "path": "output2\\java\\Hard\\2259-minimum-time-to-make-array-sum-at-most-x.java", "hypo_code": "class Solution {\n    public int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {\n        int n = nums1.size();\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, nums1, nums2, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, List<Integer> nums1, List<Integer> nums2, int[][] dp) {\n        int n = nums1.size();\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= n) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (nums1.get(k) >= nums1.get(i) && nums2.get(l) >= nums2.get(j)) {\n                    ans = Math.max(ans, 1 + dfs(k, l, nums1, nums2, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2260", "path": "output2\\java\\Hard\\2260-maximum-elegance-of-a-k-length-subsequence.java", "hypo_code": "class Solution {\n    public long findMaximumElegance(int[][] items, int k) {\n        int n = items.length;\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, items, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, int[][] items, int[][] dp) {\n        int n = items.length;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int k = i - 1; k <= i + 1; ++k) {\n            if (k < 0 || k >= n) {\n                continue;\n            }\n            for (int l = j - 1; l <= j + 1; ++l) {\n                if (l < 0 || l >= n || k == i && l == j) {\n                    continue;\n                }\n                if (items[k][0] >= items[i][0] && items[l][1] >= items[j][1]) {\n                    ans = Math.max(ans, 1 + dfs(k, l, items, dp));\n                }\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
{"id": "2261", "path": "output2\\java\\Hard\\2261-apply-operations-to-maximize-score.java", "hypo_code": "class Solution {\n    public int maximumScore(List<Integer> nums, int k) {\n        int n = nums.size();\n        int[][] dp = new int[n][2];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = Math.max(ans, dfs(i, 0, nums, k, dp));\n        }\n        return ans;\n    }\n    private int dfs(int i, int j, List<Integer> nums, int k, int[][] dp) {\n        int n = nums.size();\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        int ans = 1;\n        for (int l = j - 1; l <= j + 1; ++l) {\n            if (l < 0 || l >= n || l == j) {\n                continue;\n            }\n            if (nums.get(l) >= nums.get(j)) {\n                ans = Math.max(ans, 1 + dfs(i, l, nums, k, dp));\n            }\n        }\n        return dp[i][j] = ans;\n    }\n}"}
