{"id": "1", "path": "output2\\js\\Easy\\1-two-sum.js", "hypo_code": "var twoSum = function(nums, target) {\n    let map = new Map();\n    for(let i = 0; i < nums.length; i++){\n        let complement = target - nums[i];\n        if(map.has(complement)){\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    \n};"}
{"id": "2", "path": "output2\\js\\Easy\\2-palindrome-number.js", "hypo_code": "var isPalindrome = function(x) {\n    if(x < 0) return false;\n    let rev = 0;\n    let num = x;\n    while(num > 0){\n        rev = rev * 10 + num % 10;\n        num = Math.floor(num / 10);\n    }\n    return rev === x;\n    \n    \n};"}
{"id": "3", "path": "output2\\js\\Easy\\3-roman-to-integer.js", "hypo_code": "var romanToInt = function(s) {\n    let map = new Map();\n    map.set('I', 1);\n    map.set('V', 5);\n    map.set('X', 10);\n    map.set('L', 50);\n    map.set('C', 100);\n    map.set('D', 500);\n    map.set('M', 1000);\n    let sum = 0;\n    for(let i = 0; i < s.length; i++){\n        let curr = map.get(s[i]);\n        let next = map.get(s[i + 1]);\n        if(curr < next){\n            sum += next - curr;\n            i++;\n        }else{\n            sum += curr;\n        }\n    }\n    return sum;\n   \n    \n};"}
{"id": "4", "path": "output2\\js\\Easy\\4-longest-common-prefix.js", "hypo_code": "var longestCommonPrefix = function(strs) {\n    if(strs.length === 0) return \"\";\n    let prefix = strs[0];\n    for(let i = 1; i < strs.length; i++){\n        while(strs[i].indexOf(prefix) !== 0){\n            prefix = prefix.substring(0, prefix.length - 1);\n            if(prefix === \"\") return \"\";\n        }\n    }\n    return prefix;\n    \n};"}
{"id": "5", "path": "output2\\js\\Easy\\5-valid-parentheses.js", "hypo_code": "var isValid = function(s) {\n    let stack = [];\n    for(let i = 0; i < s.length; i++){\n        let curr = s[i];\n        if(curr === '(' || curr === '{' || curr === '['){\n            stack.push(curr);\n        }else{\n            let last = stack.pop();\n            if(curr === ')' && last !== '(') return false;\n            if(curr === '}' && last !== '{') return false;\n            if(curr === ']' && last !== '[') return false;\n        }\n    }\n    return stack.length === 0;\n    \n    \n};"}
{"id": "6", "path": "output2\\js\\Easy\\6-merge-two-sorted-lists.js", "hypo_code": "var mergeTwoLists = function(list1, list2) {\n    let dummy = new ListNode(0);\n    let head = dummy;\n    while(list1 !== null && list2 !== null){\n        if(list1.val < list2.val){\n            head.next = list1;\n            list1 = list1.next;\n        }else{\n            head.next = list2;\n            list2 = list2.next;\n        }\n        head = head.next;\n    }\n    if(list1 !== null){\n        head.next = list1;\n    }\n    if(list2 !== null){\n        head.next = list2;\n    }\n    return dummy.next;\n    \n    \n};"}
{"id": "7", "path": "output2\\js\\Easy\\7-remove-duplicates-from-sorted-array.js", "hypo_code": "var removeDuplicates = function(nums) {\n    if(nums.length === 0) return 0;\n    let i = 0;\n    for(let j = 1; j < nums.length; j++){\n        if(nums[i] !== nums[j]){\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n    \n};"}
{"id": "8", "path": "output2\\js\\Easy\\8-remove-element.js", "hypo_code": "var removeElement = function(nums, val) {\n    let i = 0;\n    for(let j = 0; j < nums.length; j++){\n        if(nums[j] !== val){\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n    \n};"}
{"id": "9", "path": "output2\\js\\Easy\\9-find-the-index-of-the-first-occurrence-in-a-string.js", "hypo_code": "var strStr = function(haystack, needle) { \n    if(needle.length == 0) return 0;\n    if(haystack.length == 0) return -1;\n    let i = 0;\n    let j = 0;\n    let index = -1;\n    while(i < haystack.length && j < needle.length){\n        if(haystack[i] == needle[j]){\n            if(index == -1) index = i;\n            j++;\n        }else{\n            if(index != -1){\n                i = index;\n                index = -1;\n            }\n            j = 0;\n        }\n        i++;\n    }\n    if(j == needle.length) return index;\n    return -1;\n  \n};"}
{"id": "10", "path": "output2\\js\\Easy\\10-search-insert-position.js", "hypo_code": "var searchInsert = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    while(left <= right){\n        let mid = Math.floor((left + right) / 2);\n        if(nums[mid] === target){\n            return mid;\n        }else if(nums[mid] > target){\n            right = mid - 1;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return left;\n    \n};"}
{"id": "11", "path": "output2\\js\\Easy\\11-length-of-last-word.js", "hypo_code": "var lengthOfLastWord = function(s) {\n    let words = s.trim().split(\" \");\n    return words[words.length - 1].length;\n    \n};"}
{"id": "12", "path": "output2\\js\\Easy\\12-plus-one.js", "hypo_code": "var plusOne = function(digits) {\n    let carry = 1;\n    for(let i = digits.length - 1; i >= 0; i--){\n        let sum = digits[i] + carry;\n        if(sum > 9){\n            digits[i] = sum % 10;\n            carry = 1;\n        }else{\n            digits[i] = sum;\n            carry = 0;\n        }\n    }\n    if(carry == 1){\n        digits.unshift(1);\n    }\n    return digits;\n\n};"}
{"id": "13", "path": "output2\\js\\Easy\\13-add-binary.js", "hypo_code": "var addBinary = function(a, b) {\n    let carry = 0;\n    let result = \"\";\n    let i = a.length - 1;\n    let j = b.length - 1;\n    while(i >= 0 || j >= 0){\n        let sum = carry;\n        if(i >= 0){\n            sum += a[i] - '0';\n            i--;\n        }\n        if(j >= 0){\n            sum += b[j] - '0';\n            j--;\n        }\n        result = sum % 2 + result;\n        carry = Math.floor(sum / 2);\n    }\n    if(carry == 1){\n        result = carry + result;\n    }\n    return result;\n    \n};"}
{"id": "14", "path": "output2\\js\\Easy\\14-sqrtx.js", "hypo_code": "var mySqrt = function(x) {\n    let left = 0;\n    let right = x;\n    while(left <= right){\n        let mid = Math.floor((left + right) / 2);\n        let square = mid * mid;\n        if(square == x){\n            return mid;\n        }else if(square < x){\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return right;\n    \n};"}
{"id": "15", "path": "output2\\js\\Easy\\15-climbing-stairs.js", "hypo_code": "var climbStairs = function(n) {\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for(let i = 2; i <= n; i++){\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n    \n};"}
{"id": "16", "path": "output2\\js\\Easy\\16-remove-duplicates-from-sorted-list.js", "hypo_code": "var deleteDuplicates = function(head) {\n    let current = head;\n    while(current != null && current.next != null){\n        if(current.val == current.next.val){\n            current.next = current.next.next;\n        }else{\n            current = current.next;\n        }\n    }\n    return head;\n    \n};"}
{"id": "17", "path": "output2\\js\\Easy\\17-merge-sorted-array.js", "hypo_code": "var merge = function(nums1, m, nums2, n) {\n    let i = m - 1;\n    let j = n - 1;\n    let k = m + n - 1;\n    while(i >= 0 && j >= 0){\n        if(nums1[i] > nums2[j]){\n            nums1[k] = nums1[i];\n            i--;\n        }else{\n            nums1[k] = nums2[j];\n            j--;\n        }\n        k--;\n    }\n    while(j >= 0){\n        nums1[k] = nums2[j];\n        j--;\n        k--;\n    }\n    \n};"}
{"id": "18", "path": "output2\\js\\Easy\\18-binary-tree-inorder-traversal.js", "hypo_code": "var inorderTraversal = function(root) {\n    let result = [];\n    let stack = [];\n    let current = root;\n    while(current != null || stack.length > 0){\n        while(current != null){\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        result.push(current.val);\n        current = current.right;\n    }\n    return result;\n    \n    \n};"}
{"id": "19", "path": "output2\\js\\Easy\\19-same-tree.js", "hypo_code": "var isSameTree = function(p, q) {\n    if(p == null && q == null){\n        return true;\n    }\n    if(p == null || q == null){\n        return false;\n    }\n    if(p.val != q.val){\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    \n};"}
{"id": "20", "path": "output2\\js\\Easy\\20-symmetric-tree.js", "hypo_code": "var isSymmetric = function(root) {\n    if(root == null){\n        return true;\n    }\n    return isMirror(root.left, root.right);\n    \n    \n};"}
{"id": "21", "path": "output2\\js\\Easy\\21-maximum-depth-of-binary-tree.js", "hypo_code": "var maxDepth = function(root) {\n    if(root == null){\n        return 0;\n    }\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    \n};"}
{"id": "22", "path": "output2\\js\\Easy\\22-convert-sorted-array-to-binary-search-tree.js", "hypo_code": "var sortedArrayToBST = function(nums) {\n    if(nums.length == 0){\n        return null;\n    }\n    let mid = Math.floor(nums.length / 2);\n    let root = new TreeNode(nums[mid]);\n    root.left = sortedArrayToBST(nums.slice(0, mid));\n    root.right = sortedArrayToBST(nums.slice(mid + 1));\n    return root;\n    \n};"}
{"id": "23", "path": "output2\\js\\Easy\\23-balanced-binary-tree.js", "hypo_code": "var isBalanced = function(root) {\n    if(root == null){\n        return true;\n    }\n    return Math.abs(height(root.left) - height(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);\n    \n    \n};"}
{"id": "24", "path": "output2\\js\\Easy\\24-minimum-depth-of-binary-tree.js", "hypo_code": "var minDepth = function(root) {\n    if(root == null){\n        return 0;\n    }\n    if(root.left == null && root.right == null){\n        return 1;\n    }\n    if(root.left == null){\n        return minDepth(root.right) + 1;\n    }\n    if(root.right == null){\n        return minDepth(root.left) + 1;\n    }\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n    \n};"}
{"id": "25", "path": "output2\\js\\Easy\\25-path-sum.js", "hypo_code": "var hasPathSum = function(root, targetSum) {\n    if(root == null){\n        return false;\n    }\n    if(root.left == null && root.right == null){\n        return targetSum == root.val;\n    }\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n    \n};"}
{"id": "26", "path": "output2\\js\\Easy\\26-pascals-triangle.js", "hypo_code": "var generate = function(numRows) {\n    let result = [];\n    for(let i = 0; i < numRows; i++){\n        let row = [];\n        for(let j = 0; j <= i; j++){\n            if(j == 0 || j == i){\n                row.push(1);\n            }\n            else{\n                row.push(result[i - 1][j - 1] + result[i - 1][j]);\n            }\n        }\n        result.push(row);\n    }\n    return result;\n    \n};"}
{"id": "27", "path": "output2\\js\\Easy\\27-pascals-triangle-ii.js", "hypo_code": "var getRow = function(rowIndex) {\n    let result = [];\n    for(let i = 0; i <= rowIndex; i++){\n        let row = [];\n        for(let j = 0; j <= i; j++){\n            if(j == 0 || j == i){\n                row.push(1);\n            }\n            else{\n                row.push(result[j - 1] + result[j]);\n            }\n        }\n        result = row;\n    }\n    return result;\n    \n};"}
{"id": "28", "path": "output2\\js\\Easy\\28-best-time-to-buy-and-sell-stock.js", "hypo_code": "var maxProfit = function(prices) {\n    let min = Infinity;\n    let max = 0;\n    for(let i = 0; i < prices.length; i++){\n        if(prices[i] < min){\n            min = prices[i];\n        }else if(prices[i] - min > max){\n            max = prices[i] - min;\n        }\n    }\n    return max;\n    \n};"}
{"id": "29", "path": "output2\\js\\Easy\\29-valid-palindrome.js", "hypo_code": "var isPalindrome = function(s) {\n    let left = 0;\n    let right = s.length - 1;\n    while(left < right){\n        while(!isAlphaNumeric(s[left]) && left < right){\n            left++;\n        }\n        while(!isAlphaNumeric(s[right]) && left < right){\n            right--;\n        }\n        if(s[left].toLowerCase() !== s[right].toLowerCase()){\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n    \n    \n};"}
{"id": "30", "path": "output2\\js\\Easy\\30-single-number.js", "hypo_code": "var singleNumber = function(nums) {\n    let result = 0;\n    for(let i = 0; i < nums.length; i++){\n        result ^= nums[i];\n    }\n    return result;\n    \n};"}
{"id": "31", "path": "output2\\js\\Easy\\31-linked-list-cycle.js", "hypo_code": "var hasCycle = function(head) {\n    let slow = head;\n    let fast = head;\n    while(fast && fast.next){\n        slow = slow.next;\n        fast = fast.next.next;\n        if(slow === fast){\n            return true;\n        }\n    }\n    return false;\n    \n};"}
{"id": "32", "path": "output2\\js\\Easy\\32-binary-tree-preorder-traversal.js", "hypo_code": "var preorderTraversal = function(root) {\n    let result = [];\n    let stack = [];\n    let current = root;\n    while(current != null || stack.length > 0){\n        while(current != null){\n            result.push(current.val);\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        current = current.right;\n    }\n    return result;\n    \n};"}
{"id": "33", "path": "output2\\js\\Easy\\33-binary-tree-postorder-traversal.js", "hypo_code": "var postorderTraversal = function(root) {\n    let result = [];\n    let stack = [];\n    let current = root;\n    while(current != null || stack.length > 0){\n        while(current != null){\n            result.unshift(current.val);\n            stack.push(current);\n            current = current.right;\n        }\n        current = stack.pop();\n        current = current.left;\n    }\n    return result;\n    \n};"}
{"id": "34", "path": "output2\\js\\Easy\\34-intersection-of-two-linked-lists.js", "hypo_code": "var getIntersectionNode = function(headA, headB) {\n    let a = headA;\n    let b = headB;\n    while(a != b){\n        a = a == null ? headB : a.next;\n        b = b == null ? headA : b.next;\n    }\n    return a;\n    \n};"}
{"id": "35", "path": "output2\\js\\Easy\\35-excel-sheet-column-title.js", "hypo_code": "var convertToTitle = function(columnNumber) {\n    let result = \"\";\n    while(columnNumber > 0){\n        let remainder = columnNumber % 26;\n        if(remainder == 0){\n            result = \"Z\" + result;\n            columnNumber = Math.floor(columnNumber / 26) - 1;\n        }else{\n            result = String.fromCharCode(remainder + 64) + result;\n            columnNumber = Math.floor(columnNumber / 26);\n        }\n    }\n    return result;\n    \n};"}
{"id": "36", "path": "output2\\js\\Easy\\36-majority-element.js", "hypo_code": "var majorityElement = function(nums) {\n    let count = 0;\n    let candidate = 0;\n    for(let i = 0; i < nums.length; i++){\n        if(count == 0){\n            candidate = nums[i];\n        }\n        if(nums[i] == candidate){\n            count++;\n        }else{\n            count--;\n        }\n    }\n    return candidate;\n    \n};"}
{"id": "37", "path": "output2\\js\\Easy\\37-excel-sheet-column-number.js", "hypo_code": "var titleToNumber = function(columnTitle) {\n    let result = 0;\n    for(let i = 0; i < columnTitle.length; i++){\n        result = result * 26 + (columnTitle.charCodeAt(i) - 64);\n    }\n    return result;\n    \n};"}
{"id": "42", "path": "output2\\js\\Easy\\42-reverse-bits.js", "hypo_code": "var reverseBits = function(n) { \n    let result = 0;\n    for(let i = 0; i < 32; i++){\n        result = result * 2 + (n & 1);\n        n = n >> 1;\n    }\n    return result;\n     \n    \n};"}
{"id": "43", "path": "output2\\js\\Easy\\43-number-of-1-bits.js", "hypo_code": "var hammingWeight = function(n) {\n    \n    \n    \n    \n    \n    \n    let result = 0;\n    while(n != 0){\n        result++;\n        n = n & (n - 1);\n    }\n    return result;\n    \n};"}
{"id": "48", "path": "output2\\js\\Easy\\48-happy-number.js", "hypo_code": "var isHappy = function(n) {\n    let slow = n;\n    let fast = n;\n    do{\n        slow = squareSum(slow);\n        fast = squareSum(fast);\n        fast = squareSum(fast);\n    }while(slow != fast);\n    return slow == 1;\n    \n};\nfunction squareSum(n){\n    let sum = 0;\n    while(n != 0){\n        let digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}"}
{"id": "49", "path": "output2\\js\\Easy\\49-remove-linked-list-elements.js", "hypo_code": "var removeElements = function(head, val) {\n    let current = head;\n    let prev = null;\n    while(current != null){\n        if(current.val == val){\n            if(prev == null){\n                head = current.next;\n            }else{\n                prev.next = current.next;\n            }\n        }else{\n            prev = current;\n        }\n        current = current.next;\n    }\n    return head;\n    \n};"}
{"id": "50", "path": "output2\\js\\Easy\\50-isomorphic-strings.js", "hypo_code": "var isIsomorphic = function(s, t) {\n    let map = new Map();\n    let set = new Set();\n    for(let i = 0; i < s.length; i++){\n        let c1 = s[i];\n        let c2 = t[i];\n        if(map.has(c1)){\n            if(map.get(c1) != c2){\n                return false;\n            }\n        }else{\n            if(set.has(c2)){\n                return false;\n            }\n            map.set(c1, c2);\n            set.add(c2);\n        }\n    }\n    return true;\n    \n};"}
{"id": "51", "path": "output2\\js\\Easy\\51-reverse-linked-list.js", "hypo_code": "var reverseList = function(head) {\n    let prev = null;\n    let current = head;\n    while(current != null){\n        let next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n    \n};"}
{"id": "52", "path": "output2\\js\\Easy\\52-contains-duplicate.js", "hypo_code": "var containsDuplicate = function(nums) {\n    let set = new Set();\n    for(let i = 0; i < nums.length; i++){\n        if(set.has(nums[i])){\n            return true;\n        }\n        set.add(nums[i]);\n    }\n    return false;\n    \n};"}
{"id": "53", "path": "output2\\js\\Easy\\53-contains-duplicate-ii.js", "hypo_code": "var containsNearbyDuplicate = function(nums, k) {\n    let map = new Map();\n    for(let i = 0; i < nums.length; i++){\n        let num = nums[i];\n        if(map.has(num)){\n            let index = map.get(num);\n            if(i - index <= k){\n                return true;\n            }\n        }\n        map.set(num, i);\n    }\n    return false;\n    \n};"}
{"id": "54", "path": "output2\\js\\Easy\\54-count-complete-tree-nodes.js", "hypo_code": "var countNodes = function(root) {     \n    if(!root) return 0;\n    let leftHeight = 0;\n    let rightHeight = 0;\n    let left = root;\n    let right = root;\n    while(left){\n        leftHeight++;\n        left = left.left;\n    }\n    while(right){\n        rightHeight++;\n        right = right.right;\n    }\n    if(leftHeight == rightHeight) return Math.pow(2, leftHeight) - 1;\n    return 1 + countNodes(root.left) + countNodes(root.right);\n\n     \n};"}
{"id": "56", "path": "output2\\js\\Easy\\56-invert-binary-tree.js", "hypo_code": "var invertTree = function(root) {\n    if(root == null){\n        return null;\n    }\n    let temp = root.left;\n    root.left = root.right;\n    root.right = temp;\n    invertTree(root.left);\n    invertTree(root.right);\n    return root;\n    \n};"}
{"id": "57", "path": "output2\\js\\Easy\\57-summary-ranges.js", "hypo_code": "var summaryRanges = function(nums) {\n    let result = [];\n    let start = 0;\n    let end = 0;\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i+1] == nums[i]+1){\n            end++;\n        }else{\n            if(start == end){\n                result.push(nums[start].toString());\n            }else{\n                result.push(nums[start].toString() + \"->\" + nums[end].toString());\n            }\n            start = i+1;\n            end = i+1;\n        }\n    }\n    return result;\n    \n};"}
{"id": "58", "path": "output2\\js\\Easy\\58-power-of-two.js", "hypo_code": "var isPowerOfTwo = function(n) {\n    if(n == 0){\n        return false;\n    }\n    while(n%2 == 0){\n        n = n/2;\n    }\n    if(n == 1){\n        return true;\n    }else{\n        return false;\n    }\n    \n};"}
{"id": "60", "path": "output2\\js\\Easy\\60-palindrome-linked-list.js", "hypo_code": "var isPalindrome = function(head) {\n    let arr = [];\n    let temp = head;\n    while(temp != null){\n        arr.push(temp.val);\n        temp = temp.next;\n    }\n    let i = 0;\n    let j = arr.length-1;\n    while(i < j){\n        if(arr[i] != arr[j]){\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n    \n};"}
{"id": "61", "path": "output2\\js\\Easy\\61-valid-anagram.js", "hypo_code": "var isAnagram = function(s, t) {\n    if(s.length != t.length){\n        return false;\n    }\n    let map = {};\n    for(let i = 0; i < s.length; i++){\n        if(map[s[i]] == undefined){\n            map[s[i]] = 1;\n        }else{\n            map[s[i]]++;\n        }\n    }\n    for(let i = 0; i < t.length; i++){\n        if(map[t[i]] == undefined){\n            return false;\n        }else{\n            map[t[i]]--;\n        }\n    }\n    for(let key in map){\n        if(map[key] != 0){\n            return false;\n        }\n    }\n    return true;\n    \n};"}
{"id": "62", "path": "output2\\js\\Easy\\62-binary-tree-paths.js", "hypo_code": "var binaryTreePaths = function(root) { \n    let result = [];\n    let path = [];\n    dfs(root, path, result);\n    return result;\n};\nvar dfs = function(root, path, result){\n    if(!root) return;\n    path.push(root.val);\n    if(!root.left && !root.right){\n        result.push(path.join(\"->\"));\n    }\n    dfs(root.left, path, result);\n    dfs(root.right, path, result);\n    path.pop();\n}"}
{"id": "63", "path": "output2\\js\\Easy\\63-add-digits.js", "hypo_code": "var addDigits = function(num) {   \n    if(num == 0) return 0;\n    let result = 0;\n    while(num > 0){\n        result += num % 10;\n        num = Math.floor(num / 10);\n    }\n    if(result > 9) return addDigits(result);\n    return result;\n};"}
{"id": "64", "path": "output2\\js\\Easy\\64-ugly-number.js", "hypo_code": "var isUgly = function(n) {\n    if (n < 1) return false;\n    while (n % 2 === 0) {\n        n /= 2;\n    }\n    while (n % 3 === 0) {\n        n /= 3;\n    }\n    while (n % 5 === 0) {\n        n /= 5;\n    }\n    return n === 1;\n};"}
{"id": "65", "path": "output2\\js\\Easy\\65-missing-number.js", "hypo_code": "var missingNumber = function(nums) {\n    let n = nums.length;\n    let sum = 0;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n    }\n    return (n * (n + 1)) / 2 - sum;\n    \n};"}
{"id": "66", "path": "output2\\js\\Easy\\66-first-bad-version.js", "hypo_code": "var solution = function(isBadVersion) {\n    \n    return function(n) {\n        let left = 1;\n        let right = n;\n        let mid;\n\n        while (left < right) {\n            mid = Math.floor((left + right) / 2);\n            if (isBadVersion(mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n        \n    };\n};"}
{"id": "67", "path": "output2\\js\\Easy\\67-move-zeroes.js", "hypo_code": "var moveZeroes = function(nums) {\n    let index = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0 ) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (let i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n    \n};"}
{"id": "68", "path": "output2\\js\\Easy\\68-word-pattern.js", "hypo_code": "var wordPattern = function(pattern, s) {\n    let sArr = s.split(' ');\n\tlet pArr = pattern.split('');\n\tlet map = new Map();\n\tif (sArr.length !== pArr.length) return false;\n\tfor (let i = 0; i < sArr.length; i++) {\n\t\tif (map.has(pArr[i])) {\n\t\t\tif (map.get(pArr[i]) !== sArr[i]) return false;\n\t\t} else {\n\t\t\tif (Array.from(map.values()).indexOf(sArr[i]) !== -1) return false;\n\t\t\tmap.set(pArr[i], sArr[i]);\n\t\t}\n\t}\n\treturn true;\n};"}
{"id": "69", "path": "output2\\js\\Easy\\69-nim-game.js", "hypo_code": "var canWinNim = function(n) {\n    return (n % 4 !== 0);\n    \n};"}
{"id": "71", "path": "output2\\js\\Easy\\71-power-of-three.js", "hypo_code": "var isPowerOfThree = function(n) {\n    if (n <= 0) return false;\n    let num = n;\n    while (num % 3 === 0) {\n        num = num / 3;\n    }\n    return num === 1;\n    \n};"}
{"id": "72", "path": "output2\\js\\Easy\\72-counting-bits.js", "hypo_code": "var countBits = function(n) {\n    let ans = [];\n    for (let i = 0; i <= n; i++) {\n        ans.push(i.toString(2).split('').reduce((acc, curr) => acc + parseInt(curr), 0));\n    }\n    return ans;\n    \n};"}
{"id": "73", "path": "output2\\js\\Easy\\73-power-of-four.js", "hypo_code": "var isPowerOfFour = function(n) {\n    if (n <= 0) return false;\n    let num = n;\n    while (num % 4 === 0) {\n        num = num / 4;\n    }\n    return num === 1;\n    \n};"}
{"id": "74", "path": "output2\\js\\Easy\\74-reverse-string.js", "hypo_code": "var reverseString = function(s) {\n    const length = s.length;\n    for (let i = 0; i < length / 2; i++) {\n        const tmp = s[i];\n        s[i] = s[length - 1 - i];\n        s[length - 1 - i] = tmp;\n    }\n    \n};"}
{"id": "75", "path": "output2\\js\\Easy\\75-reverse-vowels-of-a-string.js", "hypo_code": "var reverseVowels = function(s) {\n    const length = s.length;\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    let left = 0;\n    let right = length - 1;\n    const chars = s.split('');\n    while (left < right) {\n        if (vowels.includes(chars[left].toLowerCase()) && vowels.includes(chars[right].toLowerCase())) {\n            const tmp = chars[left];\n            chars[left] = chars[right];\n            chars[right] = tmp;\n            left++;\n            right--;\n        } else if (!vowels.includes(chars[left].toLowerCase())) {\n            left++;\n        } else if (!vowels.includes(chars[right].toLowerCase())) {\n            right--;\n        }\n    }\n    return chars.join('');\n};"}
{"id": "76", "path": "output2\\js\\Easy\\76-intersection-of-two-arrays.js", "hypo_code": "var intersection = function(nums1, nums2) {\n    let result = [];\n    let set = new Set(nums1);\n    for (let i = 0; i < nums2.length; i++) {\n        if (set.has(nums2[i])) {\n            result.push(nums2[i]);\n            set.delete(nums2[i]);\n        }\n    }\n    return result;\n};"}
{"id": "77", "path": "output2\\js\\Easy\\77-intersection-of-two-arrays-ii.js", "hypo_code": "var intersect = function(nums1, nums2) {\n    let result = [];\n    let map = new Map();\n    for (let i = 0; i < nums1.length; i++) {\n        if (map.has(nums1[i])) map.set(nums1[i], map.get(nums1[i]) + 1);\n        else map.set(nums1[i], 1);\n    }\n    for (let i = 0; i < nums2.length; i++) {\n        if (map.has(nums2[i]) && map.get(nums2[i]) > 0) {\n            result.push(nums2[i]);\n            map.set(nums2[i], map.get(nums2[i]) - 1);\n        }\n    }\n    return result;\n};"}
{"id": "78", "path": "output2\\js\\Easy\\78-valid-perfect-square.js", "hypo_code": "var isPerfectSquare = function(num) {\n    let i = 1;\n    while(i*i <= num){\n        if(i*i == num){\n            return true;\n        }\n        i++;\n    }\n    return false;\n    \n};"}
{"id": "79", "path": "output2\\js\\Easy\\79-guess-number-higher-or-lower.js", "hypo_code": "var guessNumber = function(n) {\n    let start = 1;\n    let end = n;\n    while(start <= end){\n        let mid = Math.floor((start+end)/2);\n        let res = guess(mid);\n        if(res == 0){\n            return mid;\n        }else if(res == -1){\n            end = mid-1;\n        }else{\n            start = mid+1;\n        }\n    }\n    return -1;\n    \n};"}
{"id": "80", "path": "output2\\js\\Easy\\80-ransom-note.js", "hypo_code": "var canConstruct = function(ransomNote, magazine) {\n    let map = {};\n    for(let i = 0; i < magazine.length; i++){\n        if(map[magazine[i]] == undefined){\n            map[magazine[i]] = 1;\n        }else{\n            map[magazine[i]]++;\n        }\n    }\n    for(let i = 0; i < ransomNote.length; i++){\n        if(map[ransomNote[i]] == undefined){\n            return false;\n        }else{\n            map[ransomNote[i]]--;\n        }\n    }\n    return true;\n    \n};"}
{"id": "81", "path": "output2\\js\\Easy\\81-first-unique-character-in-a-string.js", "hypo_code": "var firstUniqChar = function(s) {\n    let map = {};\n    for(let i = 0; i < s.length; i++){\n        if(map[s[i]] == undefined){\n            map[s[i]] = 1;\n        }else{\n            map[s[i]]++;\n        }\n    }\n    for(let i = 0; i < s.length; i++){\n        if(map[s[i]] == 1){\n            return i;\n        }\n    }\n    return -1;\n    \n};"}
{"id": "82", "path": "output2\\js\\Easy\\82-find-the-difference.js", "hypo_code": "var findTheDifference = function(s, t) {\n    let map = {};\n    for(let i = 0; i < s.length; i++){\n        if(map[s[i]] == undefined){\n            map[s[i]] = 1;\n        }else{\n            map[s[i]]++;\n        }\n    }\n    for(let i = 0; i < t.length; i++){\n        if(map[t[i]] == undefined){\n            return t[i];\n        }else{\n            map[t[i]]--;\n        }\n    }\n    for(let key in map){\n        if(map[key] != 0){\n            return key;\n        }\n    }\n    return \"\";\n    \n};"}
{"id": "83", "path": "output2\\js\\Easy\\83-is-subsequence.js", "hypo_code": "var isSubsequence = function(s, t) {\n    let i = 0;\n    let j = 0;\n    while(i < s.length && j < t.length){\n        if(s[i] == t[j]){\n            i++;\n        }\n        j++;\n    }\n    return i == s.length;\n    \n};"}
{"id": "84", "path": "output2\\js\\Easy\\84-binary-watch.js", "hypo_code": "var readBinaryWatch = function(turnedOn) {\n    let result = [];\n    for(let i = 0; i < 12; i++){\n        for(let j = 0; j < 60; j++){\n            if(countOnes(i) + countOnes(j) == turnedOn){\n                result.push(i.toString() + \":\" + (j < 10 ? \"0\" : \"\") + j.toString());\n            }\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "85", "path": "output2\\js\\Easy\\85-sum-of-left-leaves.js", "hypo_code": "var sumOfLeftLeaves = function(root) {\n    if(root == null){\n        return 0;\n    }\n    let sum = 0;\n    if(root.left != null && root.left.left == null && root.left.right == null){\n        sum += root.left.val;\n    }\n    sum += sumOfLeftLeaves(root.left);\n    sum += sumOfLeftLeaves(root.right);\n    return sum;\n    \n};"}
{"id": "86", "path": "output2\\js\\Easy\\86-convert-a-number-to-hexadecimal.js", "hypo_code": "var toHex = function(num) {\n    if(num == 0){\n        return \"0\";\n    }\n    let map = {\n        0: \"0\",\n        1: \"1\",\n        2: \"2\",\n        3: \"3\",\n        4: \"4\",\n        5: \"5\",\n        6: \"6\",\n        7: \"7\",\n        8: \"8\",\n        9: \"9\",\n        10: \"a\",\n        11: \"b\",\n        12: \"c\",\n        13: \"d\",\n        14: \"e\",\n        15: \"f\"\n    };\n    let result = \"\";\n    while(num != 0){\n        let remainder = num%16;\n        result = map[remainder] + result;\n        num = Math.floor(num/16);\n    }\n    return result;\n    \n};"}
{"id": "87", "path": "output2\\js\\Easy\\87-longest-palindrome.js", "hypo_code": "var longestPalindrome = function(s) {\n    let map = {};\n    for(let i = 0; i < s.length; i++){\n        if(map[s[i]] == undefined){\n            map[s[i]] = 1;\n        }else{\n            map[s[i]]++;\n        }\n    }\n    let count = 0;\n    let flag = false;\n    for(let key in map){\n        if(map[key]%2 == 0){\n            count += map[key];\n        }else{\n            flag = true;\n            count += map[key] - 1;\n        }\n    }\n    if(flag){\n        count++;\n    }\n    return count;\n    \n};"}
{"id": "88", "path": "output2\\js\\Easy\\88-fizz-buzz.js", "hypo_code": "var fizzBuzz = function(n) {\n    let arr = [];\n    for(let i = 1; i <= n; i++){\n        if(i%3 == 0 && i%5 == 0){\n            arr.push(\"FizzBuzz\");\n        }else if(i%3 == 0){\n            arr.push(\"Fizz\");\n        }else if(i%5 == 0){\n            arr.push(\"Buzz\");\n        }else{\n            arr.push(i.toString());\n        }\n    }\n    return arr;\n    \n};"}
{"id": "89", "path": "output2\\js\\Easy\\89-third-maximum-number.js", "hypo_code": "var thirdMax = function(nums) {\n    let max1 = -Infinity;\n    let max2 = -Infinity;\n    let max3 = -Infinity;\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i] > max1){\n            max3 = max2;\n            max2 = max1;\n            max1 = nums[i];\n        }else if(nums[i] > max2 && nums[i] < max1){\n            max3 = max2;\n            max2 = nums[i];\n        }else if(nums[i] > max3 && nums[i] < max2){\n            max3 = nums[i];\n        }\n    }\n    if(max3 == -Infinity){\n        return max1;\n    }else{\n        return max3;\n    }\n    \n};"}
{"id": "90", "path": "output2\\js\\Easy\\90-add-strings.js", "hypo_code": "var addStrings = function(num1, num2) {\n    let result = \"\";\n    let carry = 0;\n    let i = num1.length - 1;\n    let j = num2.length - 1;\n    while(i >= 0 || j >= 0){\n        let sum = carry;\n        if(i >= 0){\n            sum += parseInt(num1[i]);\n            i--;\n        }\n        if(j >= 0){\n            sum += parseInt(num2[j]);\n            j--;\n        }\n        result = (sum%10) + result;\n        carry = Math.floor(sum/10);\n    }\n    if(carry != 0){\n        result = carry + result;\n    }\n    return result;\n    \n};"}
{"id": "91", "path": "output2\\js\\Easy\\91-number-of-segments-in-a-string.js", "hypo_code": "var countSegments = function(s) {\n    let count = 0;\n    for(let i = 0; i < s.length; i++){\n        if(s[i] != \" \" && (i == 0 || s[i-1] == \" \")){\n            count++;\n        }\n    }\n    return count;\n    \n};"}
{"id": "92", "path": "output2\\js\\Easy\\92-arranging-coins.js", "hypo_code": "var arrangeCoins = function(n) {\n    let i = 1;\n    while(n >= i){\n        n -= i;\n        i++;\n    }\n    return i-1;\n    \n};"}
{"id": "93", "path": "output2\\js\\Easy\\93-find-all-numbers-disappeared-in-an-array.js", "hypo_code": "var findDisappearedNumbers = function(nums) {\n    let map = {};\n    for(let i = 0; i < nums.length; i++){\n        map[nums[i]] = 1;\n    }\n    let arr = [];\n    for(let i = 1; i <= nums.length; i++){\n        if(map[i] == undefined){\n            arr.push(i);\n        }\n    }\n    return arr;\n    \n};"}
{"id": "94", "path": "output2\\js\\Easy\\94-assign-cookies.js", "hypo_code": "var findContentChildren = function(g, s) {\n    g.sort((a,b) => a-b);\n    s.sort((a,b) => a-b);\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while(i < g.length && j < s.length){\n        if(s[j] >= g[i]){\n            count++;\n            i++;\n            j++;\n        }else{\n            j++;\n        }\n    }\n    return count;\n    \n};"}
{"id": "95", "path": "output2\\js\\Easy\\95-repeated-substring-pattern.js", "hypo_code": "var repeatedSubstringPattern = function(s) {\n    let len = s.length;\n    for(let i = 1; i <= len / 2; i++){\n        if(len % i == 0){\n            let sub = s.substring(0, i);\n            let j = i;\n            while(j < len){\n                if(s.substring(j, j + i) != sub){\n                    break;\n                }\n                j += i;\n            }\n            if(j == len){\n                return true;\n            }\n        }\n    }\n    return false;\n    \n};"}
{"id": "96", "path": "output2\\js\\Easy\\96-hamming-distance.js", "hypo_code": "var hammingDistance = function(x, y) {\n    let count = 0;\n    while(x != 0 || y != 0){\n        if(x % 2 != y % 2){\n            count++;\n        }\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n    }\n    return count;\n    \n};"}
{"id": "97", "path": "output2\\js\\Easy\\97-island-perimeter.js", "hypo_code": "var islandPerimeter = function(grid) {\n    let perimeter = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[0].length; j++){\n            if(grid[i][j] == 1){\n                if(i == 0 || grid[i-1][j] == 0){\n                    perimeter++;\n                }\n                if(i == grid.length-1 || grid[i+1][j] == 0){\n                    perimeter++;\n                }\n                if(j == 0 || grid[i][j-1] == 0){\n                    perimeter++;\n                }\n                if(j == grid[0].length-1 || grid[i][j+1] == 0){\n                    perimeter++;\n                }\n            }\n        }\n    }\n    return perimeter;\n    \n};"}
{"id": "98", "path": "output2\\js\\Easy\\98-number-complement.js", "hypo_code": "var findComplement = function(num) {\n    let binary = num.toString(2);\n    let complement = \"\";\n    for(let i = 0; i < binary.length; i++){\n        if(binary[i] == \"0\"){\n            complement += \"1\";\n        }else{\n            complement += \"0\";\n        }\n    }\n    return parseInt(complement, 2);\n    \n};"}
{"id": "99", "path": "output2\\js\\Easy\\99-license-key-formatting.js", "hypo_code": "var licenseKeyFormatting = function(s, k) {\n    let result = \"\";\n    let count = 0;\n    for(let i = s.length - 1; i >= 0; i--){\n        if(s[i] != \"-\"){\n            if(count == k){\n                result = \"-\" + result;\n                count = 0;\n            }\n            result = s[i].toUpperCase() + result;\n            count++;\n        }\n    }\n    return result;\n    \n};"}
{"id": "100", "path": "output2\\js\\Easy\\100-max-consecutive-ones.js", "hypo_code": "var findMaxConsecutiveOnes = function(nums) {\n    let max = 0;\n    let count = 0;\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i] == 1){\n            count++;\n        }else{\n            if(count > max){\n                max = count;\n            }\n            count = 0;\n        }\n    }\n    if(count > max){\n        max = count;\n    }\n    return max;\n    \n};"}
{"id": "101", "path": "output2\\js\\Easy\\101-construct-the-rectangle.js", "hypo_code": "var constructRectangle = function(area) {\n    let L = Math.floor(Math.sqrt(area));\n    let W = Math.ceil(Math.sqrt(area));\n    while(L*W != area){\n        if(L*W < area){\n            W++;\n        }else{\n            L--;\n        }\n    }\n    return [W, L];\n    \n};"}
{"id": "102", "path": "output2\\js\\Easy\\102-teemo-attacking.js", "hypo_code": "var findPoisonedDuration = function(timeSeries, duration) {\n    let total = 0;\n    for(let i = 0; i < timeSeries.length; i++){\n        if(i == timeSeries.length-1){\n            total += duration;\n        }else{\n            if(timeSeries[i+1] - timeSeries[i] >= duration){\n                total += duration;\n            }else{\n                total += timeSeries[i+1] - timeSeries[i];\n            }\n        }\n    }\n    return total;\n    \n};"}
{"id": "103", "path": "output2\\js\\Easy\\103-next-greater-element-i.js", "hypo_code": "var nextGreaterElement = function(nums1, nums2) {\n    let ans = [];\n    for(let i = 0; i < nums1.length; i++){\n        let found = false;\n        for(let j = 0; j < nums2.length; j++){\n            if(nums1[i] == nums2[j]){\n                found = true;\n            }\n            if(found){\n                if(nums2[j] > nums1[i]){\n                    ans.push(nums2[j]);\n                    break;\n                }\n            }\n            if(j == nums2.length-1){\n                ans.push(-1);\n            }\n        }\n    }\n    return ans;\n    \n};"}
{"id": "104", "path": "output2\\js\\Easy\\104-keyboard-row.js", "hypo_code": "var findWords = function(words) {\n    let ans = [];\n    let row1 = \"qwertyuiop\";\n    let row2 = \"asdfghjkl\";\n    let row3 = \"zxcvbnm\";\n    for(let i = 0; i < words.length; i++){\n        let word = words[i].toLowerCase();\n        let row = 0;\n        for(let j = 0; j < word.length; j++){\n            if(row1.includes(word[j])){\n                if(row == 0){\n                    row = 1;\n                }else if(row == 2){\n                    row = 0;\n                    break;\n                }\n            }else if(row2.includes(word[j])){\n                if(row == 0){\n                    row = 2;\n                }else if(row == 1){\n                    row = 0;\n                    break;\n                }\n            }else if(row3.includes(word[j])){\n                if(row == 0){\n                    row = 3;\n                }else if(row == 1){\n                    row = 0;\n                    break;\n                }\n            }\n        }\n        if(row != 0){\n            ans.push(words[i]);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "105", "path": "output2\\js\\Easy\\105-find-mode-in-binary-search-tree.js", "hypo_code": "var findMode = function(root) {\n    let map = {};\n    let max = 0;\n    let ans = [];\n    function dfs(root){\n        if(root == null){\n            return;\n        }\n        if(map[root.val] == undefined){\n            map[root.val] = 1;\n        }else{\n            map[root.val]++;\n        }\n        if(map[root.val] > max){\n            max = map[root.val];\n        }\n        dfs(root.left);\n        dfs(root.right);\n    }\n    dfs(root);\n    for(let key in map){\n        if(map[key] == max){\n            ans.push(key);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "106", "path": "output2\\js\\Easy\\106-base-7.js", "hypo_code": "var convertToBase7 = function(num) {\n    let ans = \"\";\n    let neg = false;\n    if(num < 0){\n        neg = true;\n        num = num * -1;\n    }\n    while(num > 0){\n        ans = num % 7 + ans;\n        num = Math.floor(num / 7);\n    }\n    if(neg){\n        ans = \"-\" + ans;\n    }\n    return ans;\n    \n};"}
{"id": "107", "path": "output2\\js\\Easy\\107-relative-ranks.js", "hypo_code": "var findRelativeRanks = function(score) {\n    let ans = [];\n    let sorted = score.slice().sort((a,b) => b-a);\n    for(let i = 0; i < score.length; i++){\n        let index = sorted.indexOf(score[i]);\n        if(index == 0){\n            ans.push(\"Gold Medal\");\n        }else if(index == 1){\n            ans.push(\"Silver Medal\");\n        }else if(index == 2){\n            ans.push(\"Bronze Medal\");\n        }else{\n            ans.push((index+1).toString());\n        }\n    }\n    return ans;\n    \n};"}
{"id": "108", "path": "output2\\js\\Easy\\108-perfect-number.js", "hypo_code": "var checkPerfectNumber = function(num) {\n    let sum = 0;\n    for(let i = 1; i < num; i++){\n        if(num % i == 0){\n            sum += i;\n        }\n    }\n    return sum == num;\n    \n};"}
{"id": "109", "path": "output2\\js\\Easy\\109-fibonacci-number.js", "hypo_code": "var fib = function(n) {\n    let a = 0;\n    let b = 1;\n    let c = 0;\n    for(let i = 0; i < n; i++){\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return a;\n    \n};"}
{"id": "111", "path": "output2\\js\\Easy\\111-detect-capital.js", "hypo_code": "var detectCapitalUse = function(word) {\n    let len = word.length;\n    let first = word[0];\n    let second = word[1];\n    if(first == first.toUpperCase() && second == second.toUpperCase()){\n        for(let i = 2; i < len; i++){\n            if(word[i] != word[i].toUpperCase()){\n                return false;\n            }\n        }\n    }else if(first == first.toUpperCase() && second == second.toLowerCase()){\n        for(let i = 2; i < len; i++){\n            if(word[i] != word[i].toLowerCase()){\n                return false;\n            }\n        }\n    }else{\n        for(let i = 1; i < len; i++){\n            if(word[i] != word[i].toLowerCase()){\n                return false;\n            }\n        }\n    }\n    return true;\n    \n};"}
{"id": "112", "path": "output2\\js\\Easy\\112-longest-uncommon-subsequence-i.js", "hypo_code": "var findLUSlength = function(a, b) {\n    if(a == b){\n        return -1;\n    }else{\n        return Math.max(a.length, b.length);\n    }\n    \n};"}
{"id": "113", "path": "output2\\js\\Easy\\113-minimum-absolute-difference-in-bst.js", "hypo_code": "var getMinimumDifference = function(root) {\n    let min = Infinity;\n    let prev = null;\n    function dfs(root){\n        if(root == null){\n            return;\n        }\n        dfs(root.left);\n        if(prev != null){\n            min = Math.min(min, root.val - prev);\n        }\n        prev = root.val;\n        dfs(root.right);\n    }\n    dfs(root);\n    return min;\n    \n};"}
{"id": "114", "path": "output2\\js\\Easy\\114-reverse-string-ii.js", "hypo_code": "var reverseStr = function(s, k) {\n    let ans = \"\";\n    let i = 0;\n    while(i < s.length){\n        if(i + k < s.length){\n            ans += reverse(s.substring(i, i + k));\n        }else{\n            ans += reverse(s.substring(i));\n        }\n        i += k;\n        if(i + k < s.length){\n            ans += s.substring(i, i + k);\n        }else{\n            ans += s.substring(i);\n        }\n        i += k;\n    }\n    return ans;\n    \n    \n};"}
{"id": "115", "path": "output2\\js\\Easy\\115-diameter-of-binary-tree.js", "hypo_code": "var diameterOfBinaryTree = function(root) {\n    let max = 0;\n    function dfs(root){\n        if(root == null){\n            return 0;\n        }\n        let left = dfs(root.left);\n        let right = dfs(root.right);\n        max = Math.max(max, left + right);\n        return Math.max(left, right) + 1;\n    }\n    dfs(root);\n    return max;\n    \n};"}
{"id": "116", "path": "output2\\js\\Easy\\116-student-attendance-record-i.js", "hypo_code": "var checkRecord = function(s) {\n    let absent = 0;\n    let late = 0;\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == 'A'){\n            absent++;\n            if(absent > 1){\n                return false;\n            }\n        }\n        if(s[i] == 'L'){\n            late++;\n            if(late > 2){\n                return false;\n            }\n        }else{\n            late = 0;\n        }\n    }\n    return true;\n    \n};"}
{"id": "117", "path": "output2\\js\\Easy\\117-reverse-words-in-a-string-iii.js", "hypo_code": "var reverseWords = function(s) {\n    let ans = \"\";\n    let i = 0;\n    while(i < s.length){\n        let j = i;\n        while(j < s.length && s[j] != \" \"){\n            j++;\n        }\n        ans += reverse(s.substring(i, j));\n        if(j < s.length){\n            ans += \" \";\n        }\n        i = j + 1;\n    }\n    return ans;\n    \n    \n};"}
{"id": "118", "path": "output2\\js\\Easy\\118-maximum-depth-of-n-ary-tree.js", "hypo_code": "var maxDepth = function(root) {\n    if(root == null){\n        return 0;\n    }\n    let max = 0;\n    for(let child of root.children){\n        max = Math.max(max, maxDepth(child));\n    }\n    return max + 1;\n    \n};"}
{"id": "119", "path": "output2\\js\\Easy\\119-array-partition.js", "hypo_code": "var arrayPairSum = function(nums) {\n    nums.sort((a,b) => a - b);\n    let sum = 0;\n    for(let i = 0; i < nums.length; i+=2){\n        sum += nums[i];\n    }\n    return sum;\n    \n};"}
{"id": "120", "path": "output2\\js\\Easy\\120-binary-tree-tilt.js", "hypo_code": "var findTilt = function(root) {\n    let result = 0;\n    function dfs(root){\n        if(root == null){\n            return 0;\n        }\n        let left = dfs(root.left);\n        let right = dfs(root.right);\n        result += Math.abs(left - right);\n        return left + right + root.val;\n    }\n    dfs(root);\n    return result;\n    \n};"}
{"id": "121", "path": "output2\\js\\Easy\\121-reshape-the-matrix.js", "hypo_code": "var matrixReshape = function(mat, r, c) {\n    let m = mat.length;\n    let n = mat[0].length;\n    if(m*n != r*c){\n        return mat;\n    }\n    let ans = [];\n    let temp = [];\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            temp.push(mat[i][j]);\n            if(temp.length == c){\n                ans.push(temp);\n                temp = [];\n            }\n        }\n    }\n    return ans;\n    \n};"}
{"id": "122", "path": "output2\\js\\Easy\\122-subtree-of-another-tree.js", "hypo_code": "var isSubtree = function(root, subRoot) {\n    if(root == null){\n        return false;\n    }\n    if(isSameTree(root, subRoot)){\n        return true;\n    }\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n    \n    \n};"}
{"id": "123", "path": "output2\\js\\Easy\\123-distribute-candies.js", "hypo_code": "var distributeCandies = function(candyType) {\n    let n = candyType.length / 2;\n    let set = new Set();\n    for(let i = 0; i < candyType.length; i++){\n        set.add(candyType[i]);\n    }\n    return Math.min(set.size, n);\n    \n};"}
{"id": "127", "path": "output2\\js\\Easy\\127-n-ary-tree-preorder-traversal.js", "hypo_code": "var preorder = function(root) {\n    let result = [];\n    let stack = [];\n    if(root != null){\n        stack.push(root);\n    }\n    while(stack.length > 0){\n        let current = stack.pop();\n        result.push(current.val);\n        for(let i = current.children.length - 1; i >= 0; i--){\n            stack.push(current.children[i]);\n        }\n    }\n    return result;\n    \n};"}
{"id": "128", "path": "output2\\js\\Easy\\128-n-ary-tree-postorder-traversal.js", "hypo_code": "var postorder = function(root) {\n    \n};"}
{"id": "129", "path": "output2\\js\\Easy\\129-longest-harmonious-subsequence.js", "hypo_code": "var findLHS = function(nums) {\n    let map = new Map();\n    let max = 0;\n    for(let i = 0; i < nums.length; i++){\n        let num = nums[i];\n        if(map.has(num)){\n            map.set(num, map.get(num) + 1);\n        }else{\n            map.set(num, 1);\n        }\n        if(map.has(num + 1)){\n            max = Math.max(max, map.get(num) + map.get(num + 1));\n        }\n        if(map.has(num - 1)){\n            max = Math.max(max, map.get(num) + map.get(num - 1));\n        }\n    }\n    return max;\n    \n};"}
{"id": "132", "path": "output2\\js\\Easy\\132-range-addition-ii.js", "hypo_code": "var maxCount = function(m, n, ops) { \n    for (let i = 0; i < ops.length; i++) {\n        m = Math.min(m, ops[i][0]);\n        n = Math.min(n, ops[i][1]);\n    }\n    return m * n;\n};"}
{"id": "133", "path": "output2\\js\\Easy\\133-minimum-index-sum-of-two-lists.js", "hypo_code": "var findRestaurant = function(list1, list2) {\n    let map = {};\n    let minSum = Infinity;\n    let result = [];\n\n    for (let i = 0; i < list1.length; i++) {\n        map[list1[i]] = i;\n    }\n\n    for (let i = 0; i < list2.length; i++) {\n        if (list2[i] in map) {\n            let sum = i + map[list2[i]];\n            if (sum < minSum) {\n                result = [];\n                result.push(list2[i]);\n                minSum = sum;\n            } else if (sum === minSum) {\n                result.push(list2[i]);\n            }\n        }\n    }\n\n    return result;\n    \n};"}
{"id": "134", "path": "output2\\js\\Easy\\134-can-place-flowers.js", "hypo_code": "var canPlaceFlowers = function(flowerbed, n) {\n    let count = 0;\n    for (let i = 0; i < flowerbed.length; i++) {\n        if (flowerbed[i] === 1) continue;\n        if (i > 0 && flowerbed[i - 1] === 1) continue;\n        if (i < flowerbed.length - 1 && flowerbed[i + 1] === 1) continue;\n        flowerbed[i] = 1;\n        count++;\n    }\n    return count >= n;\n\n    \n};"}
{"id": "135", "path": "output2\\js\\Easy\\135-construct-string-from-binary-tree.js", "hypo_code": "var tree2str = function(root) {\n    if(!root) return \"\";\n    if(!root.left && !root.right) return root.val + \"\";\n    if(!root.right) return root.val + \"(\" + tree2str(root.left) + \")\";\n    return root.val + \"(\" + tree2str(root.left) + \")(\" + tree2str(root.right) + \")\";\n\n};"}
{"id": "138", "path": "output2\\js\\Easy\\138-merge-two-binary-trees.js", "hypo_code": "var mergeTrees = function(root1, root2) {\n    if(!root1) return root2;\n    if(!root2) return root1;\n    let node = new TreeNode(root1.val + root2.val);\n    node.left = mergeTrees(root1.left, root2.left);\n    node.right = mergeTrees(root1.right, root2.right);\n    return node;\n};"}
{"id": "142", "path": "output2\\js\\Easy\\142-maximum-product-of-three-numbers.js", "hypo_code": "var maximumProduct = function(nums) {\n    let max1 = -Infinity;\n    let max2 = -Infinity;\n    let max3 = -Infinity;\n    let min1 = Infinity;\n    let min2 = Infinity;\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i] > max1){\n            max3 = max2;\n            max2 = max1;\n            max1 = nums[i];\n        }else if(nums[i] > max2){\n            max3 = max2;\n            max2 = nums[i];\n        }else if(nums[i] > max3){\n            max3 = nums[i];\n        }\n        if(nums[i] < min1){\n            min2 = min1;\n            min1 = nums[i];\n        }else if(nums[i] < min2){\n            min2 = nums[i];\n        }\n    }\n    return Math.max(max1 * max2 * max3, max1 * min1 * min2);\n    \n};"}
{"id": "143", "path": "output2\\js\\Easy\\143-average-of-levels-in-binary-tree.js", "hypo_code": "var averageOfLevels = function(root) {\n    let result = [];\n    let queue = [root];\n    while(queue.length > 0){\n        let sum = 0;\n        let count = 0;\n        let newQueue = [];\n        for(let node of queue){\n            sum += node.val;\n            count++;\n            if(node.left != null){\n                newQueue.push(node.left);\n            }\n            if(node.right != null){\n                newQueue.push(node.right);\n            }\n        }\n        result.push(sum / count);\n        queue = newQueue;\n    }\n    return result;\n    \n};"}
{"id": "144", "path": "output2\\js\\Easy\\144-maximum-average-subarray-i.js", "hypo_code": "var findMaxAverage = function(nums, k) {\n    let sum = 0;\n    for(let i = 0; i < k; i++){\n        sum += nums[i];\n    }\n    let max = sum;\n    for(let i = k; i < nums.length; i++){\n        sum += nums[i] - nums[i - k];\n        if(sum > max){\n            max = sum;\n        }\n    }\n    return max / k;\n    \n};"}
{"id": "145", "path": "output2\\js\\Easy\\145-set-mismatch.js", "hypo_code": "var findErrorNums = function(nums) {\n    let set = new Set();\n    let sum = 0;\n    let duplicate = 0;\n    for(let i = 0; i < nums.length; i++){\n        let num = nums[i];\n        if(set.has(num)){\n            duplicate = num;\n        }\n        set.add(num);\n        sum += num;\n    }\n    let n = nums.length;\n    let missing = (n * (n + 1) / 2) - (sum - duplicate);\n    return [duplicate, missing];\n    \n};"}
{"id": "146", "path": "output2\\js\\Easy\\146-two-sum-iv-input-is-a-bst.js", "hypo_code": "var findTarget = function(root, k) {\n    let set = new Set();\n    let queue = [root];\n    while(queue.length > 0){\n        let node = queue.shift();\n        if(set.has(k - node.val)){\n            return true;\n        }\n        set.add(node.val);\n        if(node.left != null){\n            queue.push(node.left);\n        }\n        if(node.right != null){\n            queue.push(node.right);\n        }\n    }\n    return false;\n    \n};"}
{"id": "147", "path": "output2\\js\\Easy\\147-robot-return-to-origin.js", "hypo_code": "var judgeCircle = function(moves) {\n    let x = 0;\n    let y = 0;\n    for(let i = 0; i < moves.length; i++){\n        if(moves[i] == 'R'){\n            x++;\n        }else if(moves[i] == 'L'){\n            x--;\n        }else if(moves[i] == 'U'){\n            y++;\n        }else if(moves[i] == 'D'){\n            y--;\n        }\n    }\n    return x == 0 && y == 0;\n    \n};"}
{"id": "148", "path": "output2\\js\\Easy\\148-image-smoother.js", "hypo_code": "var imageSmoother = function(img) {\n    let m = img.length;\n    let n = img[0].length;\n    let result = [];\n    for(let i = 0; i < m; i++){\n        let row = [];\n        for(let j = 0; j < n; j++){\n            let sum = 0;\n            let count = 0;\n            for(let x = i - 1; x <= i + 1; x++){\n                for(let y = j - 1; y <= j + 1; y++){\n                    if(x >= 0 && x < m && y >= 0 && y < n){\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            row.push(Math.floor(sum / count));\n        }\n        result.push(row);\n    }\n    return result;\n    \n};"}
{"id": "149", "path": "output2\\js\\Easy\\149-second-minimum-node-in-a-binary-tree.js", "hypo_code": "var findSecondMinimumValue = function(root) {\n    let min = root.val;\n    let result = -1;\n    let queue = [root];\n    while(queue.length > 0){\n        let node = queue.shift();\n        if(node.val > min){\n            if(result == -1){\n                result = node.val;\n            }else{\n                result = Math.min(result, node.val);\n            }\n        }\n        if(node.left != null){\n            queue.push(node.left);\n        }\n        if(node.right != null){\n            queue.push(node.right);\n        }\n    }\n    return result;\n    \n};"}
{"id": "150", "path": "output2\\js\\Easy\\150-longest-continuous-increasing-subsequence.js", "hypo_code": "var findLengthOfLCIS = function(nums) {\n    let max = 0;\n    let count = 0;\n    for(let i = 0; i < nums.length; i++){\n        if(i == 0 || nums[i] > nums[i - 1]){\n            count++;\n        }else{\n            if(count > max){\n                max = count;\n            }\n            count = 1;\n        }\n    }\n    if(count > max){\n        max = count;\n    }\n    return max;\n    \n};"}
{"id": "151", "path": "output2\\js\\Easy\\151-valid-palindrome-ii.js", "hypo_code": "var validPalindrome = function(s) {\n    let i = 0;\n    let j = s.length - 1;\n    while(i < j){\n        if(s[i] != s[j]){\n            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\n        }\n        i++;\n        j--;\n    }\n    return true;\n    \n    \n};"}
{"id": "152", "path": "output2\\js\\Easy\\152-baseball-game.js", "hypo_code": "var calPoints = function(operations) {\n    let stack = [];\n    let sum = 0;\n    for(let i = 0; i < operations.length; i++){\n        if(operations[i] == 'C'){\n            sum -= stack.pop();\n        }else if(operations[i] == 'D'){\n            let last = stack[stack.length - 1];\n            stack.push(last * 2);\n            sum += last * 2;\n        }else if(operations[i] == '+'){\n            let last = stack[stack.length - 1];\n            let secondLast = stack[stack.length - 2];\n            stack.push(last + secondLast);\n            sum += last + secondLast;\n        }else{\n            let num = parseInt(operations[i]);\n            stack.push(num);\n            sum += num;\n        }\n    }\n    return sum;\n    \n};"}
{"id": "153", "path": "output2\\js\\Easy\\153-binary-number-with-alternating-bits.js", "hypo_code": "var hasAlternatingBits = function(n) {\n    let str = n.toString(2);\n    for(let i = 0; i < str.length - 1; i++){\n        if(str[i] == str[i + 1]){\n            return false;\n        }\n    }\n    return true;\n    \n};"}
{"id": "154", "path": "output2\\js\\Easy\\154-count-binary-substrings.js", "hypo_code": "var countBinarySubstrings = function(s) {\n    let count = 0;\n    let prev = 0;\n    let curr = 1;\n    for(let i = 1; i < s.length; i++){\n        if(s[i] == s[i - 1]){\n            curr++;\n        }else{\n            prev = curr;\n            curr = 1;\n        }\n        if(prev >= curr){\n            count++;\n        }\n    }\n    return count;\n    \n};"}
{"id": "155", "path": "output2\\js\\Easy\\155-degree-of-an-array.js", "hypo_code": "var findShortestSubArray = function(nums) {\n    let map = {};\n    let max = 0;\n    let min = Infinity;\n    for(let i = 0; i < nums.length; i++){\n        if(map[nums[i]]){\n            map[nums[i]].count++;\n            map[nums[i]].end = i;\n        }else{\n            map[nums[i]] = {count: 1, start: i, end: i};\n        }\n        if(map[nums[i]].count > max){\n            max = map[nums[i]].count;\n            min = map[nums[i]].end - map[nums[i]].start + 1;\n        }else if(map[nums[i]].count == max){\n            if(map[nums[i]].end - map[nums[i]].start + 1 < min){\n                min = map[nums[i]].end - map[nums[i]].start + 1;\n            }\n        }\n    }\n    return min;\n    \n};"}
{"id": "156", "path": "output2\\js\\Easy\\156-search-in-a-binary-search-tree.js", "hypo_code": "var searchBST = function(root, val) {\n    if(root == null){\n        return null;\n    }\n    if(root.val == val){\n        return root;\n    }\n    if(root.val > val){\n        return searchBST(root.left, val);\n    } else {\n        return searchBST(root.right, val);\n    }\n    \n};"}
{"id": "158", "path": "output2\\js\\Easy\\158-binary-search.js", "hypo_code": "var search = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    while(left <= right){\n        let mid = Math.floor((left + right) / 2);\n        if(nums[mid] === target){\n            return mid;\n        }else if(nums[mid] > target){\n            right = mid - 1;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return -1;\n    \n};"}
{"id": "161", "path": "output2\\js\\Easy\\161-to-lower-case.js", "hypo_code": "var toLowerCase = function(s) {\n    let str = \"\";\n    for(let i = 0; i < s.length; i++){\n        if(s.charCodeAt(i) >= 65 && s.charCodeAt(i) <= 90){\n            str += String.fromCharCode(s.charCodeAt(i) + 32);\n        }else{\n            str += s[i];\n        }\n    }\n    return str;\n};"}
{"id": "162", "path": "output2\\js\\Easy\\162-1-bit-and-2-bit-characters.js", "hypo_code": "var isOneBitCharacter = function(bits) {\n    let i = 0;\n    while (i < bits.length) {\n        if (bits[i] === 1) {\n            i += 2;\n        } else {\n            if (i === bits.length - 1) return true;\n            i++;\n        }\n    }\n    return false;\n    \n};"}
{"id": "163", "path": "output2\\js\\Easy\\163-find-pivot-index.js", "hypo_code": "var pivotIndex = function(nums) {\n    let leftSum = 0;\n    let rightSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        rightSum += nums[i];\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (i > 0) {\n            leftSum += nums[i - 1];\n        }\n        rightSum -= nums[i];\n        if (leftSum === rightSum) {\n            return i;\n        }\n    }\n    return -1;\n};"}
{"id": "164", "path": "output2\\js\\Easy\\164-self-dividing-numbers.js", "hypo_code": "var selfDividingNumbers = function(left, right) {\n    let result = [];\n    for (let i = left; i <= right; i++) {\n        if (isSelfDividingNumber(i)) {\n            result.push(i);\n        }\n    }\n    return result;\n};\nvar isSelfDividingNumber = function(num) {\n    let temp = num;\n    while (temp > 0) {\n        let digit = temp % 10;\n        if (digit === 0 || num % digit !== 0) {\n            return false;\n        }\n        temp = Math.floor(temp / 10);\n    }\n    return true;\n};"}
{"id": "165", "path": "output2\\js\\Easy\\165-flood-fill.js", "hypo_code": "var floodFill = function(image, sr, sc, color) {\n    if (image[sr][sc] === color) return image;\n    let target = image[sr][sc];\n    let queue = [[sr, sc]];\n    while (queue.length > 0) {\n        let [x, y] = queue.shift();\n        if (image[x][y] === target) {\n            image[x][y] = color;\n            if (x > 0) queue.push([x - 1, y]);\n            if (x < image.length - 1) queue.push([x + 1, y]);\n            if (y > 0) queue.push([x, y - 1]);\n            if (y < image[0].length - 1) queue.push([x, y + 1]);\n        }\n    }\n    return image;\n};"}
{"id": "166", "path": "output2\\js\\Easy\\166-find-smallest-letter-greater-than-target.js", "hypo_code": "var nextGreatestLetter = function(letters, target) {\n    let start = 0;\n    let end = letters.length - 1;\n    while (start <= end) {\n        let mid = Math.floor((start + end) / 2);\n        if (letters[mid] <= target) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return letters[start % letters.length];\n};"}
{"id": "167", "path": "output2\\js\\Easy\\167-min-cost-climbing-stairs.js", "hypo_code": "var minCostClimbingStairs = function(cost) { \n    for (let i = 2; i < cost.length; i++) {\n        cost[i] += Math.min(cost[i - 1], cost[i - 2]);\n    }\n    return Math.min(cost[cost.length - 1], cost[cost.length - 2]);\n\n    \n};"}
{"id": "168", "path": "output2\\js\\Easy\\168-largest-number-at-least-twice-of-others.js", "hypo_code": "var dominantIndex = function(nums) {\n    let max = 0;\n    let maxIndex = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > max) {\n            maxIndex = i;\n            max = nums[i];\n        }\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (i !== maxIndex && nums[i] * 2 > max) {\n            return -1;\n        }\n    }\n    return maxIndex;\n};"}
{"id": "169", "path": "output2\\js\\Easy\\169-shortest-completing-word.js", "hypo_code": "var shortestCompletingWord = function(licensePlate, words) {\n    let count = new Array(26).fill(0);\n    let min = \"\";\n    for (let i = 0; i < licensePlate.length; i++) {\n        let c = licensePlate[i].toLowerCase();\n        if (c >= 'a' && c <= 'z') {\n            count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n        }\n    }\n    for (let i = 0; i < words.length; i++) {\n        let isValid = true;\n        let wordCount = new Array(26).fill(0);\n        for (let j = 0; j < words[i].length; j++) {\n            let c = words[i][j].toLowerCase();\n            wordCount[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n        }\n        for (let j = 0; j < 26; j++) {\n            if (count[j] > wordCount[j]) {\n                isValid = false;\n                break;\n            }\n        }\n        if (isValid) {\n            if (min === \"\" || words[i].length < min.length) {\n                min = words[i];\n            }\n        }\n    }\n    return min;\n};"}
{"id": "170", "path": "output2\\js\\Easy\\170-prime-number-of-set-bits-in-binary-representation.js", "hypo_code": "var countPrimeSetBits = function(left, right) {\n    let result = 0;\n    for (let i = left; i <= right; i++) {\n        let count = 0;\n        let temp = i;\n        while (temp > 0) {\n            if (temp % 2 === 1) {\n                count++;\n            }\n            temp = Math.floor(temp / 2);\n        }\n        if (isPrime(count)) {\n            result++;\n        }\n    }\n    return result;\n};\nvar isPrime = function(num) {\n    if (num <= 1) {\n        return false;\n    }\n    for (let i = 2; i <= Math.floor(Math.sqrt(num)); i++) {\n        if (num % i === 0) {\n            return false;\n        }\n    }\n    return true;\n};"}
{"id": "171", "path": "output2\\js\\Easy\\171-toeplitz-matrix.js", "hypo_code": "var isToeplitzMatrix = function(matrix) {\n    for (let i = 0; i < matrix.length - 1; i++) {\n        for (let j = 0; j < matrix[i].length - 1; j++) {\n            if (matrix[i][j] !== matrix[i + 1][j + 1]) return false;\n        }\n    }\n    return true;\n};"}
{"id": "172", "path": "output2\\js\\Easy\\172-jewels-and-stones.js", "hypo_code": "var numJewelsInStones = function(jewels, stones) {\n    let result = 0;\n\tfor (let i = 0; i < stones.length; i++) {\n\t\tif (jewels.includes(stones[i])) {\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n    \n};"}
{"id": "173", "path": "output2\\js\\Easy\\173-minimum-distance-between-bst-nodes.js", "hypo_code": "var minDiffInBST = function(root) {\n    let result = Number.MAX_SAFE_INTEGER;\n\tlet prev = null;\n\tlet traverse = function(node) {\n\t\tif (node === null) {\n\t\t\treturn;\n\t\t}\n\t\ttraverse(node.left);\n\t\tif (prev !== null) {\n\t\t\tresult = Math.min(result, node.val - prev.val);\n\t\t}\n\t\tprev = node;\n\t\ttraverse(node.right);\n\t};\n\ttraverse(root);\n\treturn result;\n};"}
{"id": "174", "path": "output2\\js\\Easy\\174-rotate-string.js", "hypo_code": "var rotateString = function(s, goal) {\n    if (s.length !== goal.length) return false;\n    if (s === goal) return true;\n    for (let i = 0; i < s.length; i++) {\n        let temp = s.substr(i) + s.substr(0, i);\n        if (temp === goal) return true;\n    }\n    return false;\n};"}
{"id": "175", "path": "output2\\js\\Easy\\175-unique-morse-code-words.js", "hypo_code": "var uniqueMorseRepresentations = function(words) {\n    let morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\n                 \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\n                 \"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\n    let set = new Set();\n    for (let i = 0; i < words.length; i++) {\n        let str = \"\";\n        for (let j = 0; j < words[i].length; j++) {\n            str += morse[words[i].charCodeAt(j) - 'a'.charCodeAt(0)];\n        }\n        set.add(str);\n    }\n    return set.size;\n};"}
{"id": "176", "path": "output2\\js\\Easy\\176-number-of-lines-to-write-string.js", "hypo_code": "var numberOfLines = function(widths, s) {\n    let lines = 1;\n    let pixels = 0;\n    for (let i = 0; i < s.length; i++) {\n        let width = widths[s.charCodeAt(i) - 'a'.charCodeAt(0)];\n        if (pixels + width > 100) {\n            lines++;\n            pixels = width;\n        } else {\n            pixels += width;\n        }\n    }\n    return [lines, pixels];\n};"}
{"id": "177", "path": "output2\\js\\Easy\\177-largest-triangle-area.js", "hypo_code": "var largestTriangleArea = function(points) {\n    let max = 0;\n    for (let i = 0; i < points.length - 2; i++) {\n        for (let j = i + 1; j < points.length - 1; j++) {\n            for (let k = j + 1; k < points.length; k++) {\n                let area = Math.abs(points[i][0] * (points[j][1] - points[k][1]) +\n                                    points[j][0] * (points[k][1] - points[i][1]) +\n                                    points[k][0] * (points[i][1] - points[j][1])) / 2;\n                if (area > max) {\n                    max = area;\n                }\n            }\n        }\n    }\n    return max;\n};"}
{"id": "178", "path": "output2\\js\\Easy\\178-most-common-word.js", "hypo_code": "var mostCommonWord = function(paragraph, banned) {\n    let map = {};\n\tlet maxCount = 0;\n\tlet maxWord = \"\";\n\tlet words = paragraph.toLowerCase().split(/[^A-Za-z]/);\n\tfor (let i = 0; i < words.length; i++) {\n\t\tlet word = words[i];\n\t\tif (word !== \"\") {\n\t\t\tif (!banned.includes(word)) {\n\t\t\t\tif (map[word] === undefined) {\n\t\t\t\t\tmap[word] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tmap[word]++;\n\t\t\t\t}\n\t\t\t\tif (map[word] > maxCount) {\n\t\t\t\t\tmaxCount = map[word];\n\t\t\t\t\tmaxWord = word;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn maxWord;\n};"}
{"id": "179", "path": "output2\\js\\Easy\\179-shortest-distance-to-a-character.js", "hypo_code": "var shortestToChar = function(s, c) {\n    let result = [];\n\tlet prev = -Infinity;\n\tfor (let i = 0; i < s.length; i++) {\n\t\tif (s[i] === c) {\n\t\t\tprev = i;\n\t\t}\n\t\tresult.push(i - prev);\n\t}\n\tprev = Infinity;\n\tfor (let i = s.length - 1; i >= 0; i--) {\n\t\tif (s[i] === c) {\n\t\t\tprev = i;\n\t\t}\n\t\tresult[i] = Math.min(result[i], prev - i);\n\t}\n\treturn result;\n};"}
{"id": "180", "path": "output2\\js\\Easy\\180-goat-latin.js", "hypo_code": "var toGoatLatin = function(sentence) {\n    let arr = sentence.split(' ');\n    let vowels = new Set(['a', 'e', 'i', 'o', 'u']);\n    let ans = \"\";\n    for (let i = 0; i < arr.length; i++) {\n        let str = arr[i];\n        if (vowels.has(str[0].toLowerCase())) {\n            str += 'ma';\n        } else {\n            str = str.substr(1) + str[0] + 'ma';\n        }\n        for (let j = 0; j <= i; j++) {\n            str += 'a';\n        }\n        ans += str + ' ';\n    }\n    return ans.trim();\n};"}
{"id": "181", "path": "output2\\js\\Easy\\181-positions-of-large-groups.js", "hypo_code": "var largeGroupPositions = function(s) {\n    let result = [];\n    let start = 0;\n    let end = 0;\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i - 1]) {\n            end = i;\n        } else {\n            if (end - start >= 2) {\n                result.push([start, end]);\n            }\n            start = i;\n            end = i;\n        }\n    }\n    if (end - start >= 2) {\n        result.push([start, end]);\n    }\n    return result;\n};"}
{"id": "182", "path": "output2\\js\\Easy\\182-flipping-an-image.js", "hypo_code": "var flipAndInvertImage = function(image) {\n    let result = [];\n\tfor (let i = 0; i < image.length; i++) {\n\t\tlet row = [];\n\t\tfor (let j = image[i].length - 1; j >= 0; j--) {\n\t\t\trow.push(image[i][j] === 1 ? 0 : 1);\n\t\t}\n\t\tresult.push(row);\n\t}\n\treturn result;\n};"}
{"id": "183", "path": "output2\\js\\Easy\\183-rectangle-overlap.js", "hypo_code": "var isRectangleOverlap = function(rec1, rec2) {\n    let [x1, y1, x2, y2] = rec1;\n\tlet [x3, y3, x4, y4] = rec2;\n\treturn (x1 < x4 && x2 > x3 && y1 < y4 && y2 > y3);\n};"}
{"id": "184", "path": "output2\\js\\Easy\\184-backspace-string-compare.js", "hypo_code": "var backspaceCompare = function(s, t) {\n    let sStack = [];\n\tlet tStack = [];\n\tfor (let i = 0; i < s.length; i++) {\n\t\tif (s[i] === '#') {\n\t\t\tif (sStack.length > 0) sStack.pop();\n\t\t} else {\n\t\t\tsStack.push(s[i]);\n\t\t}\n\t}\n\tfor (let i = 0; i < t.length; i++) {\n\t\tif (t[i] === '#') {\n\t\t\tif (tStack.length > 0) tStack.pop();\n\t\t} else {\n\t\t\ttStack.push(t[i]);\n\t\t}\n\t}\n\tif (sStack.length !== tStack.length) return false;\n\tfor (let i = 0; i < sStack.length; i++) {\n\t\tif (sStack[i] !== tStack[i]) return false;\n\t}\n\treturn true;\n};"}
{"id": "185", "path": "output2\\js\\Easy\\185-buddy-strings.js", "hypo_code": "var buddyStrings = function(s, goal) {\n    if (s.length !== goal.length) return false;\n\tif (s === goal) return s.split('').find((c, i) => s.indexOf(c) !== i) ? true : false;\n\tlet diff = [];\n\tfor (let i = 0; i < s.length; i++) {\n\t\tif (s[i] !== goal[i]) diff.push(i);\n\t}\n\tif (diff.length === 2) {\n\t\tlet [i, j] = diff;\n\t\treturn s[i] === goal[j] && s[j] === goal[i];\n\t}\n\treturn false;\n};"}
{"id": "186", "path": "output2\\js\\Easy\\186-lemonade-change.js", "hypo_code": "var lemonadeChange = function(bills) {\n    let fives = 0;\n\tlet tens = 0;\n\tfor (let i = 0; i < bills.length; i++) {\n\t\tif (bills[i] === 5) fives++;\n\t\telse if (bills[i] === 10) {\n\t\t\tif (fives > 0) {\n\t\t\t\tfives--;\n\t\t\t\ttens++;\n\t\t\t} else return false;\n\t\t} else if (bills[i] === 20) {\n\t\t\tif (fives > 0 && tens > 0) {\n\t\t\t\tfives--;\n\t\t\t\ttens--;\n\t\t\t} else if (fives >= 3) {\n\t\t\t\tfives -= 3;\n\t\t\t} else return false;\n\t\t}\n\t}\n\treturn true;\n};"}
{"id": "187", "path": "output2\\js\\Easy\\187-transpose-matrix.js", "hypo_code": "var transpose = function(matrix) {\n    let result = [];\n\tfor (let i = 0; i < matrix[0].length; i++) {\n\t\tlet row = [];\n\t\tfor (let j = 0; j < matrix.length; j++) {\n\t\t\trow.push(matrix[j][i]);\n\t\t}\n\t\tresult.push(row);\n\t}\n\treturn result;\n};"}
{"id": "188", "path": "output2\\js\\Easy\\188-binary-gap.js", "hypo_code": "var binaryGap = function(n) {\n    let result = 0;\n    let binary = n.toString(2);\n    let last = -1;\n    for (let i = 0; i < binary.length; i++) {\n        if (binary[i] === '1') {\n            if (last >= 0) {\n                result = Math.max(result, i - last);\n            }\n            last = i;\n        }\n    }\n    return result;\n};"}
{"id": "189", "path": "output2\\js\\Easy\\189-leaf-similar-trees.js", "hypo_code": "var leafSimilar = function(root1, root2) {\n    let traverse = function(node, leaves) {\n\t\tif (node === null) {\n\t\t\treturn;\n\t\t}\n\t\tif (node.left === null && node.right === null) {\n\t\t\tleaves.push(node.val);\n\t\t\treturn;\n\t\t}\n\t\ttraverse(node.left, leaves);\n\t\ttraverse(node.right, leaves);\n\t};\n\tlet leaves1 = [];\n\ttraverse(root1, leaves1);\n\tlet leaves2 = [];\n\ttraverse(root2, leaves2);\n\tif (leaves1.length !== leaves2.length) {\n\t\treturn false;\n\t}\n\tfor (let i = 0; i < leaves1.length; i++) {\n\t\tif (leaves1[i] !== leaves2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};"}
{"id": "190", "path": "output2\\js\\Easy\\190-middle-of-the-linked-list.js", "hypo_code": "var middleNode = function(head) {\n    let slow = head;\n\tlet fast = head;\n\twhile (fast !== null && fast.next !== null) {\n\t\tslow = slow.next;\n\t\tfast = fast.next.next;\n\t}\n\treturn slow;\n};"}
{"id": "191", "path": "output2\\js\\Easy\\191-projection-area-of-3d-shapes.js", "hypo_code": "var projectionArea = function(grid) {\n    let result = 0;\n\tfor (let i = 0; i < grid.length; i++) {\n\t\tlet maxRow = 0;\n\t\tlet maxCol = 0;\n\t\tfor (let j = 0; j < grid[i].length; j++) {\n\t\t\tif (grid[i][j] > 0) {\n\t\t\t\tresult++;\n\t\t\t}\n\t\t\tmaxRow = Math.max(maxRow, grid[i][j]);\n\t\t\tmaxCol = Math.max(maxCol, grid[j][i]);\n\t\t}\n\t\tresult += maxRow + maxCol;\n\t}\n\treturn result;\n};"}
{"id": "192", "path": "output2\\js\\Easy\\192-uncommon-words-from-two-sentences.js", "hypo_code": "var uncommonFromSentences = function(s1, s2) {\n    let arr1 = s1.split(' ');\n\tlet arr2 = s2.split(' ');\n\tlet map = new Map();\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (map.has(arr1[i])) {\n\t\t\tmap.set(arr1[i], map.get(arr1[i]) + 1);\n\t\t} else {\n\t\t\tmap.set(arr1[i], 1);\n\t\t}\n\t}\n\tfor (let i = 0; i < arr2.length; i++) {\n\t\tif (map.has(arr2[i])) {\n\t\t\tmap.set(arr2[i], map.get(arr2[i]) + 1);\n\t\t} else {\n\t\t\tmap.set(arr2[i], 1);\n\t\t}\n\t}\n\tlet ans = [];\n\tfor (let [key, value] of map.entries()) {\n\t\tif (value === 1) ans.push(key);\n\t}\n\treturn ans;\n};"}
{"id": "193", "path": "output2\\js\\Easy\\193-fair-candy-swap.js", "hypo_code": "var fairCandySwap = function(aliceSizes, bobSizes) {\n    let aliceSum = aliceSizes.reduce((a, b) => a + b, 0);\n    let bobSum = bobSizes.reduce((a, b) => a + b, 0);\n    let diff = (bobSum - aliceSum) / 2;\n    let set = new Set(bobSizes);\n    for (let i = 0; i < aliceSizes.length; i++) {\n        if (set.has(aliceSizes[i] + diff)) {\n            return [aliceSizes[i], aliceSizes[i] + diff];\n        }\n    }\n};"}
{"id": "194", "path": "output2\\js\\Easy\\194-surface-area-of-3d-shapes.js", "hypo_code": "var surfaceArea = function(grid) {\n    let result = 0;\n\tfor (let i = 0; i < grid.length; i++) {\n\t\tfor (let j = 0; j < grid[i].length; j++) {\n\t\t\tif (grid[i][j] > 0) {\n\t\t\t\tresult += grid[i][j] * 4 + 2;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tresult -= Math.min(grid[i][j], grid[i - 1][j]) * 2;\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tresult -= Math.min(grid[i][j], grid[i][j - 1]) * 2;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n};"}
{"id": "195", "path": "output2\\js\\Easy\\195-monotonic-array.js", "hypo_code": "var isMonotonic = function(nums) {\n    let increasing = true;\n    let decreasing = true;\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i - 1] < nums[i]) {\n            decreasing = false;\n        }\n        if (nums[i - 1] > nums[i]) {\n            increasing = false;\n        }\n    }\n    return increasing || decreasing;\n};"}
{"id": "196", "path": "output2\\js\\Easy\\196-increasing-order-search-tree.js", "hypo_code": "var increasingBST = function(root) {\n    let result = null;\n\tlet prev = null;\n\tlet traverse = function(node) {\n\t\tif (node === null) {\n\t\t\treturn;\n\t\t}\n\t\ttraverse(node.left);\n\t\tif (result === null) {\n\t\t\tresult = node;\n\t\t}\n\t\tif (prev !== null) {\n\t\t\tprev.right = node;\n\t\t\tnode.left = null;\n\t\t}\n\t\tprev = node;\n\t\ttraverse(node.right);\n\t};\n\ttraverse(root);\n\treturn result;\n};"}
{"id": "197", "path": "output2\\js\\Easy\\197-sort-array-by-parity.js", "hypo_code": "var sortArrayByParity = function(nums) {\n    let i = 0;\n    let j = nums.length - 1;\n    while (i < j) {\n        if (nums[i] % 2 !== 0) {\n            [nums[i], nums[j]] = [nums[j], nums[i]];\n            j--;\n        } else {\n            i++;\n        }\n    }\n    return nums;\n};"}
{"id": "198", "path": "output2\\js\\Easy\\198-smallest-range-i.js", "hypo_code": "var smallestRangeI = function(nums, k) {\n    let max = nums[0];\n    let min = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        max = Math.max(max, nums[i]);\n        min = Math.min(min, nums[i]);\n    }\n    return Math.max(0, max - min - 2 * k);\n};"}
{"id": "199", "path": "output2\\js\\Easy\\199-x-of-a-kind-in-a-deck-of-cards.js", "hypo_code": "var hasGroupsSizeX = function(deck) {\n    let map = new Map();\n    for (let i = 0; i < deck.length; i++) {\n        if (map.has(deck[i])) {\n            map.set(deck[i], map.get(deck[i]) + 1);\n        } else {\n            map.set(deck[i], 1);\n        }\n    }\n    let arr = Array.from(map.values());\n    let min = Math.min(...arr);\n    if (min < 2) return false;\n    for (let i = 2; i <= min; i++) {\n        if (arr.every(num => num % i === 0)) {\n            return true;\n        }\n    }\n    return false;\n};"}
{"id": "200", "path": "output2\\js\\Easy\\200-reverse-only-letters.js", "hypo_code": "var reverseOnlyLetters = function(s) {\n    let arr = s.split('');\n    let start = 0;\n    let end = arr.length - 1;\n    while (start < end) {\n        if (!isLetter(arr[start])) {\n            start++;\n        } else if (!isLetter(arr[end])) {\n            end--;\n        } else {\n            let temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n    return arr.join('');\n};\nfunction isLetter(c) {\n    return c.toLowerCase() !== c.toUpperCase();\n}"}
{"id": "201", "path": "output2\\js\\Easy\\201-sort-array-by-parity-ii.js", "hypo_code": "var sortArrayByParityII = function(nums) {\n    let even = [];\n    let odd = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] % 2 === 0) even.push(nums[i]);\n        else odd.push(nums[i]);\n    }\n    let res = [];\n    for (let i = 0; i < even.length; i++) {\n        res.push(even[i]);\n        res.push(odd[i]);\n    }\n    return res;\n};"}
{"id": "202", "path": "output2\\js\\Easy\\202-long-pressed-name.js", "hypo_code": "var isLongPressedName = function(name, typed) {\n    let i = 0;\n    let j = 0;\n    while (i < name.length && j < typed.length) {\n        if (name[i] === typed[j]) {\n            i++;\n            j++;\n        } else if (j > 0 && typed[j] === typed[j - 1]) {\n            j++;\n        } else {\n            return false;\n        }\n    }\n    while (j > 0 && j < typed.length && typed[j] === typed[j - 1]) {\n        j++;\n    }\n    return i === name.length && j === typed.length;\n\n};"}
{"id": "203", "path": "output2\\js\\Easy\\203-unique-email-addresses.js", "hypo_code": "var numUniqueEmails = function(emails) {\n    let res = new Set();\n\tfor (let i = 0; i < emails.length; i++) {\n\t\tlet email = emails[i];\n\t\tlet arr = email.split('@');\n\t\tlet local = arr[0];\n\t\tlet domain = arr[1];\n\t\tlet plusIndex = local.indexOf('+');\n\t\tif (plusIndex !== -1) {\n\t\t\tlocal = local.substring(0, plusIndex);\n\t\t}\n\t\tlocal = local.replace(/\\./g, '');\n\t\tres.add(local + '@' + domain);\n\t}\n\treturn res.size;\n};"}
{"id": "205", "path": "output2\\js\\Easy\\205-range-sum-of-bst.js", "hypo_code": "var rangeSumBST = function(root, low, high) {\n    let sum = 0;\n\tlet traverse = function(node) {\n\t\tif (node === null) {\n\t\t\treturn;\n\t\t}\n\t\tif (node.val >= low && node.val <= high) {\n\t\t\tsum += node.val;\n\t\t}\n\t\ttraverse(node.left);\n\t\ttraverse(node.right);\n\t};\n\ttraverse(root);\n\treturn sum;\n};"}
{"id": "206", "path": "output2\\js\\Easy\\206-valid-mountain-array.js", "hypo_code": "var validMountainArray = function(arr) {\n    let i = 0;\n    while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\n        i++;\n    }\n    if (i === 0 || i === arr.length - 1) {\n        return false;\n    }\n    while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\n        i++;\n    }\n    return i === arr.length - 1;\n};"}
{"id": "207", "path": "output2\\js\\Easy\\207-di-string-match.js", "hypo_code": "var diStringMatch = function(s) {\n    let n = s.length;\n    let res = [];\n    let l = 0;\n    let h = n;\n    for (let i = 0; i < n; i++) {\n        if (s[i] === 'I') {\n            res.push(l++);\n        } else {\n            res.push(h--);\n        }\n    }\n    res.push(l);\n    return res;\n};"}
{"id": "208", "path": "output2\\js\\Easy\\208-delete-columns-to-make-sorted.js", "hypo_code": "var minDeletionSize = function(strs) {\n    let res = 0;\n    for (let i = 0; i < strs[0].length; i++) {\n        for (let j = 0; j < strs.length - 1; j++) {\n            if (strs[j][i] > strs[j + 1][i]) {\n                res++;\n                break;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "209", "path": "output2\\js\\Easy\\209-verifying-an-alien-dictionary.js", "hypo_code": "var isAlienSorted = function(words, order) {\n    for (let i = 0; i < words.length - 1; i++) {\n        let a = words[i];\n        let b = words[i + 1];\n        let j = 0;\n        while (j < a.length && j < b.length && a[j] === b[j]) {\n            j++;\n        }\n        if (j < a.length && j < b.length && order.indexOf(a[j]) > order.indexOf(b[j])) {\n            return false;\n        }\n        if (j === b.length && j < a.length) {\n            return false;\n        }\n    }\n    return true;\n};"}
{"id": "210", "path": "output2\\js\\Easy\\210-n-repeated-element-in-size-2n-array.js", "hypo_code": "var repeatedNTimes = function(nums) {\n    let res = 0;\n    let set = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        if (set.has(nums[i])) {\n            res = nums[i];\n            break;\n        } else {\n            set.add(nums[i]);\n        }\n    }\n    return res;\n};"}
{"id": "211", "path": "output2\\js\\Easy\\211-univalued-binary-tree.js", "hypo_code": "var isUnivalTree = function(root) {\n    if (root === null) {\n\t\treturn true;\n\t}\n\tlet val = root.val;\n\tlet traverse = function(node) {\n\t\tif (node === null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (node.val !== val) {\n\t\t\treturn false;\n\t\t}\n\t\treturn traverse(node.left) && traverse(node.right);\n\t};\n\treturn traverse(root);\n};"}
{"id": "212", "path": "output2\\js\\Easy\\212-largest-perimeter-triangle.js", "hypo_code": "var largestPerimeter = function(nums) {\n    nums.sort((a, b) => b - a);\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\n            return nums[i] + nums[i + 1] + nums[i + 2];\n        }\n    }\n    return 0;\n};"}
{"id": "213", "path": "output2\\js\\Easy\\213-squares-of-a-sorted-array.js", "hypo_code": "var sortedSquares = function(nums) {\n    let res = [];\n    for (let i = 0; i < nums.length; i++) {\n        res.push(nums[i] * nums[i]);\n    }\n    return res.sort((a, b) => a - b);\n};"}
{"id": "214", "path": "output2\\js\\Easy\\214-add-to-array-form-of-integer.js", "hypo_code": "var addToArrayForm = function(num, k) {\n    let res = [];\n\tlet i = num.length - 1;\n\twhile (k > 0) {\n\t\tif (i < 0) {\n\t\t\tres.unshift(k % 10);\n\t\t\tk = Math.floor(k / 10);\n\t\t\tcontinue;\n\t\t}\n\t\tlet sum = num[i] + k % 10;\n\t\tres.unshift(sum % 10);\n\t\tk = Math.floor(k / 10) + Math.floor(sum / 10);\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tres.unshift(num[i]);\n\t\ti--;\n\t}\n\treturn res;\n};"}
{"id": "215", "path": "output2\\js\\Easy\\215-cousins-in-binary-tree.js", "hypo_code": "var isCousins = function(root, x, y) {\n    let xParent = null;\n\tlet xDepth = -1;\n\tlet yParent = null;\n\tlet yDepth = -1;\n\tlet traverse = function(node, parent, depth) {\n\t\tif (node === null) {\n\t\t\treturn;\n\t\t}\n\t\tif (node.val === x) {\n\t\t\txParent = parent;\n\t\t\txDepth = depth;\n\t\t} else if (node.val === y) {\n\t\t\tyParent = parent;\n\t\t\tyDepth = depth;\n\t\t}\n\t\ttraverse(node.left, node, depth + 1);\n\t\ttraverse(node.right, node, depth + 1);\n\t};\n\ttraverse(root, null, 0);\n\treturn xDepth === yDepth && xParent !== yParent;\n};"}
{"id": "216", "path": "output2\\js\\Easy\\216-find-the-town-judge.js", "hypo_code": "var findJudge = function(n, trust) {\n    let res = -1;\n\tlet set = new Set();\n\tlet map = {};\n\tfor (let i = 0; i < trust.length; i++) {\n\t\tset.add(trust[i][0]);\n\t\tmap[trust[i][1]] = (map[trust[i][1]] || 0) + 1;\n\t}\n\tfor (let i = 1; i <= n; i++) {\n\t\tif (!set.has(i) && map[i] === n - 1) {\n\t\t\tres = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n};"}
{"id": "217", "path": "output2\\js\\Easy\\217-available-captures-for-rook.js", "hypo_code": "var numRookCaptures = function(board) {\n    let res = 0;\n    let i = 0;\n    let j = 0;\n    for (i = 0; i < board.length; i++) {\n        j = board[i].indexOf('R');\n        if (j !== -1) {\n            break;\n        }\n    }\n    for (let k = i - 1; k >= 0; k--) {\n        if (board[k][j] === 'p') {\n            res++;\n            break;\n        } else if (board[k][j] === 'B') {\n            break;\n        }\n    }\n    for (let k = i + 1; k < board.length; k++) {\n        if (board[k][j] === 'p') {\n            res++;\n            break;\n        } else if (board[k][j] === 'B') {\n            break;\n        }\n    }\n    for (let k = j - 1; k >= 0; k--) {\n        if (board[i][k] === 'p') {\n            res++;\n            break;\n        } else if (board[i][k] === 'B') {\n            break;\n        }\n    }\n    for (let k = j + 1; k < board.length; k++) {\n        if (board[i][k] === 'p') {\n            res++;\n            break;\n        } else if (board[i][k] === 'B') {\n            break;\n        }\n    }\n    return res;\n};"}
{"id": "218", "path": "output2\\js\\Easy\\218-find-common-characters.js", "hypo_code": "var commonChars = function(words) {\n    let res = [];\n    for (let c of words[0]) {\n        if (words.every(w => w.includes(c))) {\n            words = words.map(w => w.replace(c, ''));\n            res.push(c);\n        }\n    }\n    return res;\n};"}
{"id": "219", "path": "output2\\js\\Easy\\219-maximize-sum-of-array-after-k-negations.js", "hypo_code": "var largestSumAfterKNegations = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let i = 0;\n    while (nums[i] < 0 && k > 0) {\n        nums[i] = -nums[i];\n        i++;\n        k--;\n    }\n    nums.sort((a, b) => a - b);\n    if (k % 2 === 1) {\n        nums[0] = -nums[0];\n    }\n    return nums.reduce((a, b) => a + b);\n};"}
{"id": "220", "path": "output2\\js\\Easy\\220-complement-of-base-10-integer.js", "hypo_code": "var bitwiseComplement = function(n) {\n    let mask = 1;\n    while (mask < n) {\n        mask = (mask << 1) + 1;\n    }\n    return n ^ mask;\n};"}
{"id": "221", "path": "output2\\js\\Easy\\221-partition-array-into-three-parts-with-equal-sum.js", "hypo_code": "var canThreePartsEqualSum = function(arr) {\n    let sum = arr.reduce((a, b) => a + b);\n    if (sum % 3 !== 0) return false;\n    let target = sum / 3;\n    let cur = 0;\n    let count = 0;\n    for (let i = 0; i < arr.length; i++) {\n        cur += arr[i];\n        if (cur === target) {\n            cur = 0;\n            count++;\n        }\n    }\n    return count === 3;\n};"}
{"id": "222", "path": "output2\\js\\Easy\\222-binary-prefix-divisible-by-5.js", "hypo_code": "var prefixesDivBy5 = function(nums) {\n    let res = [];\n    let prefix = 0;\n    for (let i = 0; i < nums.length; i++) {\n        prefix = ((prefix << 1) + nums[i]) % 5;\n        res.push(prefix === 0);\n    }\n    return res;\n};"}
{"id": "223", "path": "output2\\js\\Easy\\223-remove-outermost-parentheses.js", "hypo_code": "var removeOuterParentheses = function(s) {\n    let res = '';\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '(') {\n            if (count !== 0) {\n                res += s[i];\n            }\n            count++;\n        } else {\n            count--;\n            if (count !== 0) {\n                res += s[i];\n            }\n        }\n    }\n    return res;\n};"}
{"id": "224", "path": "output2\\js\\Easy\\224-sum-of-root-to-leaf-binary-numbers.js", "hypo_code": "var sumRootToLeaf = function(root) {\n    let sum = 0;\n\tlet traverse = function(node, path) {\n\t\tif (node === null) {\n\t\t\treturn;\n\t\t}\n\t\tpath += node.val;\n\t\tif (node.left === null && node.right === null) {\n\t\t\tsum += parseInt(path, 2);\n\t\t\treturn;\n\t\t}\n\t\ttraverse(node.left, path);\n\t\ttraverse(node.right, path);\n\t};\n\ttraverse(root, \"\");\n\treturn sum;\n};"}
{"id": "225", "path": "output2\\js\\Easy\\225-divisor-game.js", "hypo_code": "var divisorGame = function(n) {\n    return n % 2 === 0;\n};"}
{"id": "226", "path": "output2\\js\\Easy\\226-matrix-cells-in-distance-order.js", "hypo_code": "var allCellsDistOrder = function(rows, cols, rCenter, cCenter) {\n    const distance = (r1, c1, r2, c2) => Math.abs(r1 - r2) + Math.abs(c1 - c2);\n    const res = [];\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++){\n            res.push([i, j]);\n        }\n    }\n    res.sort((a, b) => distance(a[0], a[1], rCenter, cCenter) - distance(b[0], b[1], rCenter, cCenter));\n    return res;\n};"}
{"id": "227", "path": "output2\\js\\Easy\\227-valid-boomerang.js", "hypo_code": "var isBoomerang = function(points) {\n    let [p1, p2, p3] = points;\n    return (p2[1] - p1[1]) * (p3[0] - p2[0]) !== (p2[0] - p1[0]) * (p3[1] - p2[1]);\n\n};"}
{"id": "228", "path": "output2\\js\\Easy\\228-last-stone-weight.js", "hypo_code": "var lastStoneWeight = function(stones) {\n    let res = 0;\n    while (stones.length > 1) {\n        let max1 = Math.max(...stones);\n        stones.splice(stones.indexOf(max1), 1);\n        let max2 = Math.max(...stones);\n        stones.splice(stones.indexOf(max2), 1);\n        if (max1 !== max2) {\n            stones.push(Math.abs(max1 - max2));\n        }\n    }\n    if (stones.length === 1) {\n        res = stones[0];\n    }\n    return res;\n};"}
{"id": "229", "path": "output2\\js\\Easy\\229-remove-all-adjacent-duplicates-in-string.js", "hypo_code": "var removeDuplicates = function(s) {\n    let stack = [];\n    for (let i = 0; i < s.length; i++) {\n        if (stack.length === 0 || stack[stack.length - 1] !== s[i]) {\n            stack.push(s[i]);\n        } else {\n            stack.pop();\n        }\n    }\n    return stack.join('');\n};"}
{"id": "231", "path": "output2\\js\\Easy\\231-height-checker.js", "hypo_code": "var heightChecker = function(heights) {\n    let res = 0;\n    let expected = [...heights];\n    expected.sort((a, b) => a - b);\n    for (let i = 0; i < heights.length; i++) {\n        if (heights[i] != expected[i]) {\n            res++;\n        }\n    }\n    return res;\n};"}
{"id": "233", "path": "output2\\js\\Easy\\233-greatest-common-divisor-of-strings.js", "hypo_code": "var gcdOfStrings = function(str1, str2) {\n    if (str1 + str2 !== str2 + str1) {\n\t\treturn '';\n\t}\n\tlet gcd = (a, b) => {\n\t\tif (b === 0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t};\n\treturn str1.substring(0, gcd(str1.length, str2.length));\n\n};"}
{"id": "235", "path": "output2\\js\\Easy\\235-occurrences-after-bigram.js", "hypo_code": "var findOcurrences = function(text, first, second) {\n    text = text.split(' ');\n    let res = [];\n    for (let i = 0; i < text.length - 2; i++) {\n        if (text[i] === first && text[i + 1] === second) {\n            res.push(text[i + 2]);\n        }\n    }\n    return res;\n};"}
{"id": "237", "path": "output2\\js\\Easy\\237-duplicate-zeros.js", "hypo_code": "var duplicateZeros = function(arr) {\n    let i = 0;\n\twhile (i < arr.length) {\n\t\tif (arr[i] === 0) {\n\t\t\tfor (let j = arr.length - 1; j > i; j--) {\n\t\t\t\tarr[j] = arr[j - 1];\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\ti++;\n\t}\n};"}
{"id": "238", "path": "output2\\js\\Easy\\238-distribute-candies-to-people.js", "hypo_code": "var distributeCandies = function(candies, num_people) {\n    let res = new Array(num_people).fill(0);\n    let i = 0;\n    while (candies > 0) {\n        res[i % num_people] += Math.min(candies, i + 1);\n        candies -= i + 1;\n        i++;\n    }\n    return res;\n};"}
{"id": "239", "path": "output2\\js\\Easy\\239-defanging-an-ip-address.js", "hypo_code": "var defangIPaddr = function(address) {\n    return address.replace(/\\./g, '[.]');\n};"}
{"id": "241", "path": "output2\\js\\Easy\\241-relative-sort-array.js", "hypo_code": "var relativeSortArray = function(arr1, arr2) {\n    let map = {};\n    for (let i = 0; i < arr2.length; i++) {\n        map[arr2[i]] = 0;\n    }\n    let res = [];\n    for (let i = 0; i < arr1.length; i++) {\n        if (map[arr1[i]] !== undefined) {\n            map[arr1[i]]++;\n        } else {\n            res.push(arr1[i]);\n        }\n    }\n    res.sort((a, b) => a - b);\n    let res2 = [];\n    for (let i = 0; i < arr2.length; i++) {\n        for (let j = 0; j < map[arr2[i]]; j++) {\n            res2.push(arr2[i]);\n        }\n    }\n    return res2.concat(res);\n};"}
{"id": "242", "path": "output2\\js\\Easy\\242-number-of-equivalent-domino-pairs.js", "hypo_code": "var numEquivDominoPairs = function(dominoes) {\n    let map = new Map();\n    let res = 0;\n    for (let i = 0; i < dominoes.length; i++) {\n        let key = dominoes[i][0] < dominoes[i][1] ? dominoes[i][0] * 10 + dominoes[i][1] : dominoes[i][1] * 10 + dominoes[i][0];\n        if (map.has(key)) {\n            res += map.get(key);\n            map.set(key, map.get(key) + 1);\n        } else {\n            map.set(key, 1);\n        }\n    }\n    return res;\n};"}
{"id": "243", "path": "output2\\js\\Easy\\243-n-th-tribonacci-number.js", "hypo_code": "var tribonacci = function(n) {\n    if (n === 0) return 0;\n    if (n <= 2) return 1;\n    let a = 0;\n    let b = 1;\n    let c = 1;\n    for (let i = 3; i <= n; i++) {\n        let d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;\n};"}
{"id": "246", "path": "output2\\js\\Easy\\246-day-of-the-year.js", "hypo_code": "var dayOfYear = function(date) {\n    let [year, month, day] = date.split('-').map(Number);\n    let res = day;\n    let days = [31, year % 4 === 0 ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30];\n    for (let i = 0; i < month - 1; i++) {\n        res += days[i];\n    }\n    return res;\n};"}
{"id": "247", "path": "output2\\js\\Easy\\247-find-words-that-can-be-formed-by-characters.js", "hypo_code": "var countCharacters = function(words, chars) {\n    let res = 0;\n\tfor (let word of words) {\n\t\tlet flag = true;\n\t\tfor (let c of word) {\n\t\t\tif (word.split(c).length - 1 > chars.split(c).length - 1) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tres += word.length;\n\t\t}\n\t}\n\treturn res;\n};"}
{"id": "249", "path": "output2\\js\\Easy\\249-prime-arrangements.js", "hypo_code": "var numPrimeArrangements = function(n) {\n    let primeCount = 0;\n    for (let i = 2; i <= n; i++) {\n        let isPrime = true;\n        for (let j = 2; j <= i / 2; j++) {\n            if (i % j === 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) {\n            primeCount++;\n        }\n    }\n    let res = 1;\n    for (let i = 2; i <= primeCount; i++) {\n        res *= i;\n        res %= 1000000007;\n    }\n    for (let i = 2; i <= n - primeCount; i++) {\n        res *= i;\n        res %= 1000000007;\n    }\n    return res;\n};"}
{"id": "251", "path": "output2\\js\\Easy\\251-distance-between-bus-stops.js", "hypo_code": "var distanceBetweenBusStops = function(distance, start, destination) {\n    let total = 0;\n\tfor (let i = 0; i < distance.length; i++) {\n\t\ttotal += distance[i];\n\t}\n\tlet clockwise = 0;\n\tlet i = start;\n\twhile (i !== destination) {\n\t\tclockwise += distance[i];\n\t\ti = (i + 1) % distance.length;\n\t}\n\tlet counterclockwise = total - clockwise;\n\treturn Math.min(clockwise, counterclockwise);\n};"}
{"id": "252", "path": "output2\\js\\Easy\\252-day-of-the-week.js", "hypo_code": "var dayOfTheWeek = function(day, month, year) {\n    let date = new Date(year, month - 1, day);\n\tlet days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n\treturn days[date.getDay()];\n};"}
{"id": "253", "path": "output2\\js\\Easy\\253-maximum-number-of-balloons.js", "hypo_code": "var maxNumberOfBalloons = function(text) {\n    let map = new Map();\n    for (let c of text) {\n        map.set(c, (map.get(c) || 0) + 1);\n    }\n    let res = Number.MAX_VALUE;\n    for (let c of 'balloon') {\n        if (!map.has(c)) {\n            return 0;\n        }\n        if (c === 'l' || c === 'o') {\n            res = Math.min(res, Math.floor(map.get(c) / 2));\n        } else {\n            res = Math.min(res, map.get(c));\n        }\n    }\n    return res;\n};"}
{"id": "254", "path": "output2\\js\\Easy\\254-minimum-absolute-difference.js", "hypo_code": "var minimumAbsDifference = function(arr) {\n    arr.sort((a, b) => a - b);\n    let min = Math.abs(arr[0] - arr[1]);\n    let res = [];\n    for (let i = 0; i < arr.length - 1; i++) {\n        let diff = Math.abs(arr[i] - arr[i + 1]);\n        if (diff < min) {\n            min = diff;\n            res = [];\n        }\n        if (diff === min) {\n            res.push([arr[i], arr[i + 1]]);\n        }\n    }\n    return res;\n};"}
{"id": "255", "path": "output2\\js\\Easy\\255-unique-number-of-occurrences.js", "hypo_code": "var uniqueOccurrences = function(arr) {\n    let map = new Map();\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tlet val = arr[i];\n\t\tif (map.has(val)) {\n\t\t\tmap.set(val, map.get(val) + 1);\n\t\t} else {\n\t\t\tmap.set(val, 1);\n\t\t}\n\t}\n\tlet set = new Set();\n\tfor (let [key, value] of map) {\n\t\tif (set.has(value)) {\n\t\t\treturn false;\n\t\t}\n\t\tset.add(value);\n\t}\n\treturn true;\n};"}
{"id": "257", "path": "output2\\js\\Easy\\257-minimum-cost-to-move-chips-to-the-same-position.js", "hypo_code": "var minCostToMoveChips = function(position) {\n    let res = 0;\n    let even = 0;\n    let odd = 0;\n    for (let i = 0; i < position.length; i++) {\n        if (position[i] % 2 === 0) {\n            even++;\n        } else {\n            odd++;\n        }\n    }\n    res = Math.min(even, odd);\n    return res;\n};"}
{"id": "258", "path": "output2\\js\\Easy\\258-split-a-string-in-balanced-strings.js", "hypo_code": "var balancedStringSplit = function(s) {\n    let res = 0;\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === 'R') count++;\n        else count--;\n        if (count === 0) res++;\n    }\n    return res;\n};"}
{"id": "259", "path": "output2\\js\\Easy\\259-check-if-it-is-a-straight-line.js", "hypo_code": "var checkStraightLine = function(coordinates) {\n    let x0 = coordinates[0][0];\n    let y0 = coordinates[0][1];\n    let x1 = coordinates[1][0];\n    let y1 = coordinates[1][1];\n    let dx = x1 - x0;\n    let dy = y1 - y0;\n    for (let i = 2; i < coordinates.length; i++) {\n        let x = coordinates[i][0];\n        let y = coordinates[i][1];\n        if (dx * (y - y1) !== dy * (x - x1)) {\n            return false;\n        }\n    }\n    return true;\n};"}
{"id": "261", "path": "output2\\js\\Easy\\261-cells-with-odd-values-in-a-matrix.js", "hypo_code": "var oddCells = function(m, n, indices) {\n    let matrix = [];\n\tfor (let i = 0; i < m; i++) {\n\t\tmatrix.push(new Array(n).fill(0));\n\t}\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tfor (let j = 0; j < n; j++) {\n\t\t\tmatrix[indices[i][0]][j]++;\n\t\t}\n\t\tfor (let j = 0; j < m; j++) {\n\t\t\tmatrix[j][indices[i][1]]++;\n\t\t}\n\t}\n\tlet res = 0;\n\tfor (let i = 0; i < m; i++) {\n\t\tfor (let j = 0; j < n; j++) {\n\t\t\tres += matrix[i][j] % 2;\n\t\t}\n\t}\n\treturn res;\n};"}
{"id": "262", "path": "output2\\js\\Easy\\262-shift-2d-grid.js", "hypo_code": "var shiftGrid = function(grid, k) {\n    let m = grid.length;\n\tlet n = grid[0].length;\n\tlet res = [];\n\tfor (let i = 0; i < m; i++) {\n\t\tres.push([]);\n\t\tfor (let j = 0; j < n; j++) {\n\t\t\tres[i].push(0);\n\t\t}\n\t}\n\tfor (let i = 0; i < m; i++) {\n\t\tfor (let j = 0; j < n; j++) {\n\t\t\tlet row = i;\n\t\t\tlet col = j;\n\t\t\tfor (let x = 0; x < k; x++) {\n\t\t\t\tif (col < n - 1) {\n\t\t\t\t\tcol++;\n\t\t\t\t} else {\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tif (row < m - 1) {\n\t\t\t\t\t\trow++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trow = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[row][col] = grid[i][j];\n\t\t}\n\t}\n\treturn res;\n};"}
{"id": "263", "path": "output2\\js\\Easy\\263-minimum-time-visiting-all-points.js", "hypo_code": "var minTimeToVisitAllPoints = function(points) {\n    let res = 0;\n    for (let i = 0; i < points.length - 1; i++) {\n        let x = Math.abs(points[i][0] - points[i + 1][0]);\n        let y = Math.abs(points[i][1] - points[i + 1][1]);\n        res += Math.max(x, y);\n    }\n    return res;\n};"}
{"id": "264", "path": "output2\\js\\Easy\\264-find-winner-on-a-tic-tac-toe-game.js", "hypo_code": "var tictactoe = function(moves) {\n    let board = [[], [], []];\n    for (let i = 0; i < moves.length; i++) {\n        board[moves[i][0]][moves[i][1]] = i % 2 === 0 ? 'X' : 'O';\n    }\n    for (let i = 0; i < 3; i++) {\n        if (board[i][0] === board[i][1] && board[i][1] === board[i][2]) {\n            return board[i][0] ? board[i][0] : 'Pending';\n        }\n        if (board[0][i] === board[1][i] && board[1][i] === board[2][i]) {\n            return board[0][i] ? board[0][i] : 'Pending';\n        }\n    }\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]) {\n        return board[0][0] ? board[0][0] : 'Pending';\n    }\n    if (board[0][2] === board[1][1] && board[1][1] === board[2][0]) {\n        return board[0][2] ? board[0][2] : 'Pending';\n    }\n    return moves.length === 9 ? 'Draw' : 'Pending';\n\n};"}
{"id": "266", "path": "output2\\js\\Easy\\266-subtract-the-product-and-sum-of-digits-of-an-integer.js", "hypo_code": "var subtractProductAndSum = function(n) {\n    let product = 1;\n    let sum = 0;\n    while (n > 0) {\n        let digit = n % 10;\n        product *= digit;\n        sum += digit;\n        n = Math.floor(n / 10);\n    }\n    return product - sum;\n};"}
{"id": "267", "path": "output2\\js\\Easy\\267-element-appearing-more-than-25-in-sorted-array.js", "hypo_code": "var findSpecialInteger = function(arr) {\n    let count = 0;\n    let res = arr[0];\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === res) {\n            count++;\n            if (count > arr.length / 4) {\n                return res;\n            }\n        } else {\n            res = arr[i];\n            count = 1;\n        }\n    }\n    return res;\n};"}
{"id": "268", "path": "output2\\js\\Easy\\268-convert-binary-number-in-a-linked-list-to-integer.js", "hypo_code": "var getDecimalValue = function(head) {\n    let num = 0;\n\twhile (head !== null) {\n\t\tnum = num * 2 + head.val;\n\t\thead = head.next;\n\t}\n\treturn num;\n};"}
{"id": "269", "path": "output2\\js\\Easy\\269-find-numbers-with-even-number-of-digits.js", "hypo_code": "var findNumbers = function(nums) {\n    let res = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i].toString().length % 2 === 0) res++;\n    }\n    return res;\n};"}
{"id": "270", "path": "output2\\js\\Easy\\270-replace-elements-with-greatest-element-on-right-side.js", "hypo_code": "var replaceElements = function(arr) {\n    let res = [];\n    for (let i = 0; i < arr.length - 1; i++) {\n        res.push(Math.max(...arr.slice(i + 1)));\n    }\n    res.push(-1);\n    return res;\n};"}
{"id": "271", "path": "output2\\js\\Easy\\271-find-n-unique-integers-sum-up-to-zero.js", "hypo_code": "var sumZero = function(n) {\n    let res = [];\n    if (n % 2 === 1) res.push(0);\n    for (let i = 1; i <= Math.floor(n / 2); i++) {\n        res.push(i);\n        res.push(-i);\n    }\n    return res;\n};"}
{"id": "272", "path": "output2\\js\\Easy\\272-decrypt-string-from-alphabet-to-integer-mapping.js", "hypo_code": "var freqAlphabets = function(s) {\n    let res = '';\n    for (let i = 0; i < s.length; i++) {\n        if (s[i + 2] === '#') {\n            res += String.fromCharCode(parseInt(s.substr(i, 2)) + 96);\n            i += 2;\n        } else {\n            res += String.fromCharCode(parseInt(s[i]) + 96);\n        }\n    }\n    return res;\n};"}
{"id": "273", "path": "output2\\js\\Easy\\273-decompress-run-length-encoded-list.js", "hypo_code": "var decompressRLElist = function(nums) {\n    let res = [];\n\tlet i = 0;\n\twhile (i < nums.length) {\n\t\tlet freq = nums[i];\n\t\tlet val = nums[i + 1];\n\t\tfor (let j = 0; j < freq; j++) {\n\t\t\tres.push(val);\n\t\t}\n\t\ti += 2;\n\t}\n\treturn res;\n};"}
{"id": "274", "path": "output2\\js\\Easy\\274-convert-integer-to-the-sum-of-two-no-zero-integers.js", "hypo_code": "var getNoZeroIntegers = function(n) {\n    for (let i = 1; i < n; i++) {\n        if (i.toString().indexOf('0') === -1 && (n - i).toString().indexOf('0') === -1) {\n            return [i, n - i];\n        }\n    }\n};"}
{"id": "275", "path": "output2\\js\\Easy\\275-maximum-69-number.js", "hypo_code": "var maximum69Number  = function(num) {\n    let res = num.toString();\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] === '6') {\n            res = res.substring(0, i) + '9' + res.substring(i + 1);\n            break;\n        }\n    }\n    return Number(res);\n};"}
{"id": "277", "path": "output2\\js\\Easy\\277-rank-transform-of-an-array.js", "hypo_code": "var arrayRankTransform = function(arr) {\n    let res = [];\n    let temp = [...arr].sort((a, b) => a - b);\n    let map = new Map();\n    for (let i = 0; i < temp.length; i++) {\n        if (!map.has(temp[i])) {\n            map.set(temp[i], map.size + 1);\n        }\n    }\n    for (let i = 0; i < arr.length; i++) {\n        res.push(map.get(arr[i]));\n    }\n    return res;\n};"}
{"id": "278", "path": "output2\\js\\Easy\\278-remove-palindromic-subsequences.js", "hypo_code": "var removePalindromeSub = function(s) {\n    if (s.length === 0) {\n        return 0;\n    }\n    if (s === s.split('').reverse().join('')) {\n        return 1;\n    }\n    return 2;\n};"}
{"id": "279", "path": "output2\\js\\Easy\\279-the-k-weakest-rows-in-a-matrix.js", "hypo_code": "var kWeakestRows = function(mat, k) {\n    let res = [];\n\tlet map = new Map();\n\tfor (let i = 0; i < mat.length; i++) {\n\t\tlet count = 0;\n\t\tfor (let j = 0; j < mat[i].length; j++) {\n\t\t\tif (mat[i][j] === 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tmap.set(i, count);\n\t}\n\tlet sorted = [...map.entries()].sort((a, b) => {\n\t\tif (a[1] === b[1]) {\n\t\t\treturn a[0] - b[0];\n\t\t}\n\t\treturn a[1] - b[1];\n\t});\n\tfor (let i = 0; i < k; i++) {\n\t\tres.push(sorted[i][0]);\n\t}\n\treturn res;\n};"}
{"id": "280", "path": "output2\\js\\Easy\\280-number-of-steps-to-reduce-a-number-to-zero.js", "hypo_code": "var numberOfSteps = function(num) {\n    let res = 0;\n    while (num > 0) {\n        if (num % 2 === 0) num /= 2;\n        else num--;\n        res++;\n    }\n    return res;\n};"}
{"id": "281", "path": "output2\\js\\Easy\\281-check-if-n-and-its-double-exist.js", "hypo_code": "var checkIfExist = function(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        let j = arr.indexOf(arr[i] * 2);\n        if (j !== -1 && j !== i) return true;\n    }\n    return false;\n\n\n};"}
{"id": "282", "path": "output2\\js\\Easy\\282-count-negative-numbers-in-a-sorted-matrix.js", "hypo_code": "var countNegatives = function(grid) {\n    let res = 0;\n    for (let i = 0; i < grid.length; i++) {\n        if (grid[i][0] < 0) {\n            res += grid[i].length;\n            continue;\n        }\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] < 0) {\n                res += grid[i].length - j;\n                break;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "283", "path": "output2\\js\\Easy\\283-sort-integers-by-the-number-of-1-bits.js", "hypo_code": "var sortByBits = function(arr) {\n    arr.sort((a, b) => {\n        let a1 = a.toString(2).split('').filter(item => item === '1').length;\n        let b1 = b.toString(2).split('').filter(item => item === '1').length;\n        if (a1 !== b1) return a1 - b1;\n        else return a - b;\n    });\n    return arr;\n};"}
{"id": "284", "path": "output2\\js\\Easy\\284-number-of-days-between-two-dates.js", "hypo_code": "var daysBetweenDates = function(date1, date2) {\n    let d1 = new Date(date1);\n    let d2 = new Date(date2);\n    return Math.abs((d1.getTime() - d2.getTime()) / (1000 * 3600 * 24));\n\n};"}
{"id": "285", "path": "output2\\js\\Easy\\285-how-many-numbers-are-smaller-than-the-current-number.js", "hypo_code": "var smallerNumbersThanCurrent = function(nums) {\n    let res = [];\n    for (let i = 0; i < nums.length; i++) {\n        let count = 0;\n        for (let j = 0; j < nums.length; j++) {\n            if (nums[j] < nums[i]) count++;\n        }\n        res.push(count);\n    }\n    return res;\n\n};"}
{"id": "286", "path": "output2\\js\\Easy\\286-increasing-decreasing-string.js", "hypo_code": "var sortString = function(s) {\n    let res = '';\n    let arr = s.split('').sort();\n    let set = new Set(arr);\n    while (set.size > 0) {\n        let temp = '';\n        for (let item of set) {\n            temp += item;\n            arr.splice(arr.indexOf(item), 1);\n        }\n        res += temp;\n        temp = '';\n        for (let item of [...set].reverse()) {\n            temp += item;\n            arr.splice(arr.indexOf(item), 1);\n        }\n        res += temp;\n        set = new Set(arr);\n    }\n    return res;\n};"}
{"id": "287", "path": "output2\\js\\Easy\\287-generate-a-string-with-characters-that-have-odd-counts.js", "hypo_code": "var generateTheString = function(n) {\n    let res = '';\n    if (n % 2 === 0) {\n        res += 'a';\n        n--;\n    }\n    while (n > 0) {\n        res += 'b';\n        n--;\n    }\n    return res;\n};"}
{"id": "290", "path": "output2\\js\\Easy\\290-lucky-numbers-in-a-matrix.js", "hypo_code": "var luckyNumbers  = function(matrix) {\n    let res = [];\n    for (let i = 0; i < matrix.length; i++) {\n        let min = matrix[i][0];\n        let minJ = 0;\n        for (let j = 1; j < matrix[i].length; j++) {\n            if (matrix[i][j] < min) {\n                min = matrix[i][j];\n                minJ = j;\n            }\n        }\n        let max = matrix[i][minJ];\n        let maxI = i;\n        for (let k = 0; k < matrix.length; k++) {\n            if (matrix[k][minJ] > max) {\n                max = matrix[k][minJ];\n                maxI = k;\n            }\n        }\n        if (maxI === i) res.push(max);\n    }\n    return res;\n};"}
{"id": "291", "path": "output2\\js\\Easy\\291-find-the-distance-value-between-two-arrays.js", "hypo_code": "var findTheDistanceValue = function(arr1, arr2, d) { \n    let res = 0;\n    for (let i = 0; i < arr1.length; i++) {\n        let flag = true;\n        for (let j = 0; j < arr2.length; j++) {\n            if (Math.abs(arr1[i] - arr2[j]) <= d) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) res++;\n    }\n    return res;\n};"}
{"id": "292", "path": "output2\\js\\Easy\\292-create-target-array-in-the-given-order.js", "hypo_code": "var createTargetArray = function(nums, index) {\n    let res = [];\n    for (let i = 0; i < index.length; i++) {\n        res.splice(index[i], 0, nums[i]);\n    }\n    return res;\n};"}
{"id": "293", "path": "output2\\js\\Easy\\293-find-lucky-integer-in-an-array.js", "hypo_code": "var findLucky = function(arr) {\n    let map = new Map();\n    for (let i = 0; i < arr.length; i++) {\n        if (map.has(arr[i])) map.set(arr[i], map.get(arr[i]) + 1);\n        else map.set(arr[i], 1);\n    }\n    let res = -1;\n    for (let [key, value] of map) {\n        if (key === value && key > res) res = key;\n    }\n    return res;\n};"}
{"id": "294", "path": "output2\\js\\Easy\\294-count-largest-group.js", "hypo_code": "var countLargestGroup = function(n) {\n    let map = new Map();\n    for (let i = 1; i <= n; i++) {\n        let sum = 0;\n        let num = i;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        if (map.has(sum)) map.set(sum, map.get(sum) + 1);\n        else map.set(sum, 1);\n    }\n    let max = 0;\n    for (let [key, value] of map) {\n        if (value > max) max = value;\n    }\n    let res = 0;\n    for (let [key, value] of map) {\n        if (value === max) res++;\n    }\n    return res;\n};"}
{"id": "295", "path": "output2\\js\\Easy\\295-minimum-subsequence-in-non-increasing-order.js", "hypo_code": "var minSubsequence = function(nums) {\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) sum += nums[i];\n    nums.sort((a, b) => b - a);\n    let res = [];\n    let resSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        res.push(nums[i]);\n        resSum += nums[i];\n        if (resSum > sum - resSum) return res;\n    }\n    return res;\n};"}
{"id": "297", "path": "output2\\js\\Easy\\297-string-matching-in-an-array.js", "hypo_code": "var stringMatching = function(words) {\n    let res = [];\n    for (let i = 0; i < words.length; i++) {\n        for (let j = 0; j < words.length && j !== i; j++) {\n            if (words[i].indexOf(words[j]) !== -1) {\n                res.push(words[j]);\n                break;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "298", "path": "output2\\js\\Easy\\298-minimum-value-to-get-positive-step-by-step-sum.js", "hypo_code": "var minStartValue = function(nums) {\n    let sum = 0;\n    let res = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        res = Math.max(res, sum);\n    }\n    return res > 0 ? 1 : 1 - res;\n};"}
{"id": "299", "path": "output2\\js\\Easy\\299-reformat-the-string.js", "hypo_code": "var reformat = function(s) {\n    let num = [];\n    let letter = [];\n    for (let i = 0; i < s.length; i++) {\n        if (Number.isInteger(parseInt(s[i]))) num.push(s[i]);\n        else letter.push(s[i]);\n    }\n    if (Math.abs(num.length - letter.length) > 1) return '';\n    let res = '';\n    if (num.length > letter.length) {\n        for (let i = 0; i < num.length; i++) {\n            res += num[i];\n            if (i < letter.length) res += letter[i];\n        }\n    } else {\n        for (let i = 0; i < letter.length; i++) {\n            res += letter[i];\n            if (i < num.length) res += num[i];\n        }\n    }\n    return res;\n};"}
{"id": "300", "path": "output2\\js\\Easy\\300-maximum-score-after-splitting-a-string.js", "hypo_code": "var maxScore = function(s) {\n    let res = 0;\n    let zeros = 0;\n    let ones = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '1') ones++;\n    }\n    for (let i = 0; i < s.length - 1; i++) {\n        if (s[i] === '0') zeros++;\n        else ones--;\n        res = Math.max(res, zeros + ones);\n    }\n    return res;\n};"}
{"id": "301", "path": "output2\\js\\Easy\\301-kids-with-the-greatest-number-of-candies.js", "hypo_code": "var kidsWithCandies = function(candies, extraCandies) {\n    let max = Math.max(...candies);\n    let res = [];\n    for (let i = 0; i < candies.length; i++) {\n        res.push(candies[i] + extraCandies >= max);\n    }\n    return res;\n};"}
{"id": "302", "path": "output2\\js\\Easy\\302-destination-city.js", "hypo_code": "var destCity = function(paths) {\n    let start = [];\n    let end = [];\n    for (let i = 0; i < paths.length; i++) {\n        start.push(paths[i][0]);\n        end.push(paths[i][1]);\n    }\n    for (let i = 0; i < end.length; i++) {\n        if (start.indexOf(end[i]) === -1) return end[i];\n    }\n    return '';\n};"}
{"id": "303", "path": "output2\\js\\Easy\\303-check-if-all-1s-are-at-least-length-k-places-away.js", "hypo_code": "var kLengthApart = function(nums, k) {\n    let count = k;\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tif (nums[i] === 1) {\n\t\t\tif (count < k) return false;\n\t\t\tcount = 0;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn true;\n};"}
{"id": "304", "path": "output2\\js\\Easy\\304-consecutive-characters.js", "hypo_code": "var maxPower = function(s) {\n    let res = 1;\n    let count = 1;\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i-1]) count++;\n        else count = 1;\n        if (count > res) res = count;\n    }\n    return res;\n};"}
{"id": "305", "path": "output2\\js\\Easy\\305-number-of-students-doing-homework-at-a-given-time.js", "hypo_code": "var busyStudent = function(startTime, endTime, queryTime) {\n    let res = 0;\n    for (let i = 0; i < startTime.length; i++) {\n        if (startTime[i] <= queryTime && endTime[i] >= queryTime) res++;\n    }\n    return res;\n};"}
{"id": "306", "path": "output2\\js\\Easy\\306-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence.js", "hypo_code": "var isPrefixOfWord = function(sentence, searchWord) {\n    let words = sentence.split(' ');\n\tfor (let i = 0; i < words.length; i++) {\n\t\tif (words[i].indexOf(searchWord) === 0) return i + 1;\n\t}\n\treturn -1;\n};"}
{"id": "307", "path": "output2\\js\\Easy\\307-make-two-arrays-equal-by-reversing-subarrays.js", "hypo_code": "var canBeEqual = function(target, arr) {\n    let map = new Map();\n\tfor (let i = 0; i < target.length; i++) {\n\t\tif (map.has(target[i])) map.set(target[i], map.get(target[i]) + 1);\n\t\telse map.set(target[i], 1);\n\t}\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (map.has(arr[i])) {\n\t\t\tif (map.get(arr[i]) === 1) map.delete(arr[i]);\n\t\t\telse map.set(arr[i], map.get(arr[i]) - 1);\n\t\t} else return false;\n\t}\n\treturn true;\n};"}
{"id": "308", "path": "output2\\js\\Easy\\308-maximum-product-of-two-elements-in-an-array.js", "hypo_code": "var maxProduct = function(nums) {\n    let max1 = 0;\n    let max2 = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > max1) {\n            max2 = max1;\n            max1 = nums[i];\n        } else if (nums[i] > max2) {\n            max2 = nums[i];\n        }\n    }\n    return (max1 - 1) * (max2 - 1);\n};"}
{"id": "309", "path": "output2\\js\\Easy\\309-shuffle-the-array.js", "hypo_code": "var shuffle = function(nums, n) {\n    let res = [];\n    for (let i = 0; i < n; i++) {\n        res.push(nums[i]);\n        res.push(nums[i + n]);\n    }\n    return res;\n};"}
{"id": "310", "path": "output2\\js\\Easy\\310-final-prices-with-a-special-discount-in-a-shop.js", "hypo_code": "var finalPrices = function(prices) {\n    let res = [];\n    for (let i = 0; i < prices.length; i++) {\n        let j = i + 1;\n        while (j < prices.length && prices[j] > prices[i]) j++;\n        if (j < prices.length) res.push(prices[i] - prices[j]);\n        else res.push(prices[i]);\n    }\n    return res;\n};"}
{"id": "311", "path": "output2\\js\\Easy\\311-running-sum-of-1d-array.js", "hypo_code": "var runningSum = function(nums) {\n    let res = [];\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        res.push(sum);\n    }\n    return res;\n};"}
{"id": "313", "path": "output2\\js\\Easy\\313-xor-operation-in-an-array.js", "hypo_code": "var xorOperation = function(n, start) {\n    let res = start;\n    for (let i = 1; i < n; i++) {\n        res ^= start + 2 * i;\n    }\n    return res;\n};"}
{"id": "314", "path": "output2\\js\\Easy\\314-average-salary-excluding-the-minimum-and-maximum-salary.js", "hypo_code": "var average = function(salary) {\n    let min = salary[0];\n    let max = salary[0];\n    let sum = 0;\n    for (let i = 0; i < salary.length; i++) {\n        min = Math.min(min, salary[i]);\n        max = Math.max(max, salary[i]);\n        sum += salary[i];\n    }\n    return (sum - min - max) / (salary.length - 2);\n};"}
{"id": "315", "path": "output2\\js\\Easy\\315-path-crossing.js", "hypo_code": "var isPathCrossing = function(path) {\n    let set = new Set();\n    set.add([0, 0].toString());\n    let x = 0, y = 0;\n    for (let i = 0; i < path.length; i++) {\n        switch (path[i]) {\n            case 'N':\n                y++;\n                break;\n            case 'S':\n                y--;\n                break;\n            case 'E':\n                x++;\n                break;\n            case 'W':\n                x--;\n                break;\n        }\n        if (set.has([x, y].toString())) return true;\n        else set.add([x, y].toString());\n    }\n    return false;\n};"}
{"id": "316", "path": "output2\\js\\Easy\\316-can-make-arithmetic-progression-from-sequence.js", "hypo_code": "var canMakeArithmeticProgression = function(arr) {\n    \n};"}
{"id": "317", "path": "output2\\js\\Easy\\317-reformat-date.js", "hypo_code": "var reformatDate = function(date) {    \n    let month = new Map();\n    month.set(\"Jan\", \"01\");\n    month.set(\"Feb\", \"02\");\n    month.set(\"Mar\", \"03\");\n    month.set(\"Apr\", \"04\");\n    month.set(\"May\", \"05\");\n    month.set(\"Jun\", \"06\");\n    month.set(\"Jul\", \"07\");\n    month.set(\"Aug\", \"08\");\n    month.set(\"Sep\", \"09\");\n    month.set(\"Oct\", \"10\");\n    month.set(\"Nov\", \"11\");\n    month.set(\"Dec\", \"12\");\n    let arr = date.split(\" \");\n    let day = arr[0].substr(0, arr[0].length - 2).padStart(2, \"0\");\n    let res = arr[2] + \"-\" + month.get(arr[1]) + \"-\" + day;\n    return res;\n};"}
{"id": "318", "path": "output2\\js\\Easy\\318-number-of-good-pairs.js", "hypo_code": "var numIdenticalPairs = function(nums) {\n    let res = 0;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = nums.length - 1; j > i; j--) {\n            if (nums[i] === nums[j]) res++;\n        }\n    }\n    return res;\n};"}
{"id": "320", "path": "output2\\js\\Easy\\320-water-bottles.js", "hypo_code": "var numWaterBottles = function(numBottles, numExchange) {\n    let res = 0;\n\tlet empty = 0;\n\twhile (numBottles > 0) {\n\t\tres += numBottles;\n\t\tempty += numBottles;\n\t\tnumBottles = Math.floor(empty / numExchange);\n\t\tempty = empty % numExchange;\n\t}\n\treturn res;\n};"}
{"id": "321", "path": "output2\\js\\Easy\\321-count-odd-numbers-in-an-interval-range.js", "hypo_code": "var countOdds = function(low, high) { \n    let res = 0;\n    for (let i = low; i <= high; i++) {\n        if (i % 2 === 1) res++;\n    }\n    return res;\n};"}
{"id": "323", "path": "output2\\js\\Easy\\323-shuffle-string.js", "hypo_code": "var restoreString = function(s, indices) {\n    let res = [];\n    for (let i = 0; i < indices.length; i++) {\n        res[indices[i]] = s[i];\n    }\n    return res.join('');\n};"}
{"id": "324", "path": "output2\\js\\Easy\\324-count-good-triplets.js", "hypo_code": "var countGoodTriplets = function(arr, a, b, c) {\n    let res = 0;\n    for (let i = 0; i < arr.length - 2; i++) {\n        for (let j = 1; j < arr.length - 1; j++) {\n            for (let k = 2; k < arr.length; k++) {\n                if (i < j && j < k && Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c) res++;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "325", "path": "output2\\js\\Easy\\325-kth-missing-positive-number.js", "hypo_code": "var findKthPositive = function(arr, k) {\n    let flag = 0;\n\tlet res = 0;\n\tlet i = 1;\n\twhile (flag < k) {\n\t\tif (arr.includes(i)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tres = i;\n\t\tflag++;\n\t\ti++;\n\t}\n\treturn res;\n};"}
{"id": "326", "path": "output2\\js\\Easy\\326-make-the-string-great.js", "hypo_code": "var makeGood = function(s) {\n    let stack = [];\n    for (let i = 0; i < s.length; i++) {\n        if (stack.length > 0 && Math.abs(stack[stack.length - 1].charCodeAt(0) - s[i].charCodeAt(0)) === 32) stack.pop();\n        else stack.push(s[i]);\n    }\n    return stack.join('');\n};"}
{"id": "327", "path": "output2\\js\\Easy\\327-three-consecutive-odds.js", "hypo_code": "var threeConsecutiveOdds = function(arr) {\n    let count = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] & 1) {\n            count++;\n            if (count === 3) return true;\n        } else {\n            count = 0;\n        }\n    }\n    return false;\n};"}
{"id": "328", "path": "output2\\js\\Easy\\328-thousand-separator.js", "hypo_code": "var thousandSeparator = function(n) {\n    let res = [];\n    let str = n + '';\n    for (let i = str.length - 1; i >= 0; i--) {\n        if ((str.length - 1 - i) % 3 === 0 && i !== str.length - 1) res.unshift('.');\n        res.unshift(str[i]);\n    }\n    return res.join('');\n};"}
{"id": "329", "path": "output2\\js\\Easy\\329-most-visited-sector-in-a-circular-track.js", "hypo_code": "var mostVisited = function(n, rounds) {\n    let res = [];\n    let start = rounds[0];\n    let end = rounds[rounds.length - 1];\n    if (start <= end) {\n        for (let i = start; i <= end; i++) {\n            res.push(i);\n        }\n    } else {\n        for (let i = 1; i <= end; i++) {\n            res.push(i);\n        }\n        for (let i = start; i <= n; i++) {\n            res.push(i);\n        }\n    }\n    return res;\n};"}
{"id": "330", "path": "output2\\js\\Easy\\330-detect-pattern-of-length-m-repeated-k-or-more-times.js", "hypo_code": "var containsPattern = function(arr, m, k) {\n    let count = 0;\n    for (let i = 0; i <= arr.length - m; i++) {\n        let flag = true;\n        for (let j = i; j <= arr.length - m; j++) {\n            flag = true;\n            for (let n = 0; n < m; n++) {\n                if (arr[j + n] !== arr[i + n]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) count++;\n            else break;\n        }\n        if (count >= k) return true;\n    }\n    return false;\n};"}
{"id": "331", "path": "output2\\js\\Easy\\331-matrix-diagonal-sum.js", "hypo_code": "var diagonalSum = function(mat) {\n    let res = 0;\n    for (let i = 0; i < mat.length; i++) {\n        res += mat[i][i] + mat[i][mat.length - i - 1];\n    }\n    if (mat.length % 2 === 1) {\n        res -= mat[(mat.length - 1) / 2][(mat.length - 1) / 2];\n    }\n    return res;\n};"}
{"id": "332", "path": "output2\\js\\Easy\\332-replace-all-s-to-avoid-consecutive-repeating-characters.js", "hypo_code": "var modifyString = function(s) {\n    let res = '';\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '?') {\n            let j = 0;\n            while (res[i - 1] === String.fromCharCode(97 + j) || res[i + 1] === String.fromCharCode(97 + j)) j++;\n            res += String.fromCharCode(97 + j);\n        } else {\n            res += s[i];\n        }\n    }\n    return res;\n};"}
{"id": "334", "path": "output2\\js\\Easy\\334-special-positions-in-a-binary-matrix.js", "hypo_code": "var numSpecial = function(mat) {\n    let res = 0;\n    for (let i = 0; i < mat.length; i++) {\n        let j = mat[i].indexOf(1);\n        if (j !== -1 && mat[i].lastIndexOf(1) === j) {\n            let k = 0;\n            while (k < mat.length && mat[k][j] === 0) k++;\n            if (k === mat.length) res++;\n        }\n    }\n    return res;\n};"}
{"id": "336", "path": "output2\\js\\Easy\\336-sum-of-all-odd-length-subarrays.js", "hypo_code": "var sumOddLengthSubarrays = function(arr) {\n    let res = 0;\n    for (let i = 0; i < arr.length; i++) {\n        let sum = arr[i];\n        res += sum;\n        for (let j = i + 1; j < arr.length; j++) {\n            sum += arr[j];\n            if ((j - i + 1) % 2 === 1) res += sum;\n        }\n    }\n    return res;\n};"}
{"id": "337", "path": "output2\\js\\Easy\\337-rearrange-spaces-between-words.js", "hypo_code": "var reorderSpaces = function(text) {\n    let space = 0;\n    let word = [];\n    let start = 0;\n    let end = 0;\n    while (end < text.length) {\n        if (text[end] === ' ') {\n            space++;\n            if (end > start) word.push(text.substring(start, end));\n            start = end + 1;\n        }\n        end++;\n    }\n    if (end > start) word.push(text.substring(start, end));\n    let res = '';\n    if (word.length === 1) {\n        res = word[0];\n        for (let i = 0; i < space; i++) {\n            res += ' ';\n        }\n        return res;\n    }\n    let each = space / (word.length - 1);\n    let extra = space % (word.length - 1);\n    for (let i = 0; i < word.length; i++) {\n        res += word[i];\n        if (i < word.length - 1) {\n            for (let j = 0; j < each; j++) {\n                res += ' ';\n            }\n        }\n    }\n    for (let i = 0; i < extra; i++) {\n        res += ' ';\n    }\n    return res;\n};"}
{"id": "338", "path": "output2\\js\\Easy\\338-crawler-log-folder.js", "hypo_code": "var minOperations = function(logs) {\n    let res = 0;\n    for (let i = 0; i < logs.length; i++) {\n        if (logs[i] === '../') {\n            if (res > 0) res--;\n        } else if (logs[i] === './') continue;\n        else res++;\n    }\n    return res;\n};"}
{"id": "340", "path": "output2\\js\\Easy\\340-special-array-with-x-elements-greater-than-or-equal-x.js", "hypo_code": "var specialArray = function(nums) {\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i <= nums.length; i++) {\n        let j = nums.length - i;\n        if (nums[j] >= i && (j === 0 || nums[j - 1] < i)) return i;\n    }\n    return -1;\n};"}
{"id": "341", "path": "output2\\js\\Easy\\341-maximum-nesting-depth-of-the-parentheses.js", "hypo_code": "var maxDepth = function(s) {\n    let max = 0;\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '(') count++;\n        else if (s[i] === ')') count--;\n        max = Math.max(max, count);\n    }\n    return max;\n};"}
{"id": "342", "path": "output2\\js\\Easy\\342-mean-of-array-after-removing-some-elements.js", "hypo_code": "var trimMean = function(arr) {\n    let len = arr.length;\n    arr.sort((a, b) => a - b);\n    let start = Math.floor(len * 0.05);\n    let end = Math.floor(len * 0.95);\n    let sum = 0;\n    for (let i = start; i < end; i++) {\n        sum += arr[i];\n    }\n    return sum / (end - start);\n};"}
{"id": "343", "path": "output2\\js\\Easy\\343-largest-substring-between-two-equal-characters.js", "hypo_code": "var maxLengthBetweenEqualCharacters = function(s) {\n    let res = -1;\n    for (let i = 0; i < s.length; i++) {\n        let j = s.lastIndexOf(s[i]);\n        if (j !== -1 && j !== i && j - i - 1 > res) res = j - i - 1;\n    }\n    return res;\n};"}
{"id": "344", "path": "output2\\js\\Easy\\344-slowest-key.js", "hypo_code": "var slowestKey = function(releaseTimes, keysPressed) {\n    let max = releaseTimes[0];\n\tlet maxKey = keysPressed[0];\n\tfor (let i = 1; i < releaseTimes.length; i++) {\n\t\tlet duration = releaseTimes[i] - releaseTimes[i - 1];\n\t\tif (duration > max) {\n\t\t\tmax = duration;\n\t\t\tmaxKey = keysPressed[i];\n\t\t} else if (duration === max && keysPressed[i] > maxKey) maxKey = keysPressed[i];\n\t}\n\treturn maxKey;\n};"}
{"id": "346", "path": "output2\\js\\Easy\\346-sort-array-by-increasing-frequency.js", "hypo_code": "var frequencySort = function(nums) {\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(nums[i])) map.set(nums[i], map.get(nums[i]) + 1);\n        else map.set(nums[i], 1);\n    }\n    return nums.sort((a, b) => {\n        if (map.get(a) !== map.get(b)) return map.get(a) - map.get(b);\n        else return b - a;\n    });\n};"}
{"id": "347", "path": "output2\\js\\Easy\\347-check-array-formation-through-concatenation.js", "hypo_code": "var canFormArray = function(arr, pieces) {\n    let map = new Map();\n\tfor (let i = 0; i < pieces.length; i++) {\n\t\tmap.set(pieces[i][0], pieces[i]);\n\t}\n\tlet res = [];\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (map.has(arr[i])) {\n\t\t\tres.push(...map.get(arr[i]));\n\t\t}\n\t}\n\treturn res.join('') === arr.join('');\n};"}
{"id": "348", "path": "output2\\js\\Easy\\348-get-maximum-in-generated-array.js", "hypo_code": "var getMaximumGenerated = function(n) {\n    let nums = [0, 1];\n    if (n === 0 || n === 1) return nums[n];\n    let max = 1;\n    for (let i = 2; i <= n; i++) {\n        if (i % 2 === 0) nums.push(nums[i / 2]);\n        else nums.push(nums[Math.floor(i / 2)] + nums[Math.floor(i / 2) + 1]);\n        max = Math.max(max, nums[nums.length - 1]);\n    }\n    return max;\n};"}
{"id": "349", "path": "output2\\js\\Easy\\349-defuse-the-bomb.js", "hypo_code": "var decrypt = function(code, k) {\n    let res = [];\n\tif (k === 0) {\n\t\tfor (let i = 0; i < code.length; i++) res[i] = 0;\n\t\treturn res;\n\t}\n\tif (k > 0) {\n\t\tfor (let i = 0; i < code.length; i++) {\n\t\t\tlet sum = 0;\n\t\t\tfor (let j = 1; j <= k; j++) {\n\t\t\t\tsum += code[(i + j) % code.length];\n\t\t\t}\n\t\t\tres[i] = sum;\n\t\t}\n\t}\n\telse {\n\t\tfor (let i = 0; i < code.length; i++) {\n\t\t\tlet sum = 0;\n\t\t\tfor (let j = -1; j >= k; j--) {\n\t\t\t\tsum += code[(i + j + code.length) % code.length];\n\t\t\t}\n\t\t\tres[i] = sum;\n\t\t}\n\t}\n\treturn res;\n};"}
{"id": "352", "path": "output2\\js\\Easy\\352-check-if-two-string-arrays-are-equivalent.js", "hypo_code": "var arrayStringsAreEqual = function(word1, word2) {\n    let str1 = word1.join('');\n\tlet str2 = word2.join('');\n\tif (str1 === str2) return true;\n\telse return false;\n};"}
{"id": "354", "path": "output2\\js\\Easy\\354-maximum-repeating-substring.js", "hypo_code": "var maxRepeating = function(sequence, word) {\n    let count = 0;\n    let str = word;\n    while (sequence.includes(str)) {\n        count++;\n        str += word;\n    }\n    return count;\n};"}
{"id": "355", "path": "output2\\js\\Easy\\355-richest-customer-wealth.js", "hypo_code": "var maximumWealth = function(accounts) {\n    let max = 0;\n    for (let i = 0; i < accounts.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < accounts[i].length; j++) {\n            sum += accounts[i][j];\n        }\n        if (sum > max) max = sum;\n    }\n    return max;\n};"}
{"id": "356", "path": "output2\\js\\Easy\\356-goal-parser-interpretation.js", "hypo_code": "var interpret = function(command) {\n    let str = '';\n    for (let i = 0; i < command.length; i++) {\n        if (command[i] === 'G') str += 'G';\n        else if (command[i] === '(' && command[i + 1] === ')') {\n            str += 'o';\n            i++;\n        } else if (command[i] === '(' && command[i + 1] === 'a' && command[i + 2] === 'l' && command[i + 3] === ')') {\n            str += 'al';\n            i += 3;\n        }\n    }\n    return str;\n};"}
{"id": "358", "path": "output2\\js\\Easy\\358-count-the-number-of-consistent-strings.js", "hypo_code": "var countConsistentStrings = function(allowed, words) {\n    let count = 0;\n\tfor (let i = 0; i < words.length; i++) {\n\t\tlet match = true;\n\t\tfor (let j = 0; j < words[i].length; j++) {\n\t\t\tif (!allowed.includes(words[i][j])) {\n\t\t\t\tmatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (match) count++;\n\t}\n\treturn count;\n};"}
{"id": "359", "path": "output2\\js\\Easy\\359-count-of-matches-in-tournament.js", "hypo_code": "var numberOfMatches = function(n) {\n    let count = 0;\n    while (n > 1) {\n        count += Math.floor(n / 2);\n        n = Math.ceil(n / 2);\n    }\n    return count;\n};"}
{"id": "361", "path": "output2\\js\\Easy\\361-reformat-phone-number.js", "hypo_code": "var reformatNumber = function(number) {\n    let str = '';\n    for (let i = 0; i < number.length; i++) {\n        if (number[i] !== ' ' && number[i] !== '-') str += number[i];\n    }\n    let arr = [];\n    for (let i = 0; i < str.length; i += 3) {\n        if (str.length - i === 4) {\n            arr.push(str.substring(i, i + 2));\n            arr.push(str.substring(i + 2, i + 4));\n            break;\n        } else if (str.length - i === 2) {\n            arr.push(str.substring(i, i + 2));\n            break;\n        } else if (str.length - i === 3) {\n            arr.push(str.substring(i, i + 3));\n            break;\n        } else arr.push(str.substring(i, i + 3));\n    }\n    return arr.join('-');\n};"}
{"id": "362", "path": "output2\\js\\Easy\\362-number-of-students-unable-to-eat-lunch.js", "hypo_code": "var countStudents = function(students, sandwiches) {\n    let count = 0;\n    while (students.length > 0 && count < students.length) {\n        if (students[0] === sandwiches[0]) {\n            students.shift();\n            sandwiches.shift();\n            count = 0;\n        } else {\n            students.push(students.shift());\n            count++;\n        }\n    }\n    return students.length;\n};"}
{"id": "363", "path": "output2\\js\\Easy\\363-determine-if-string-halves-are-alike.js", "hypo_code": "var halvesAreAlike = function(s) {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n\tlet count1 = 0;\n\tlet count2 = 0;\n\tfor (let i = 0; i < s.length / 2; i++) {\n\t\tif (vowels.includes(s[i].toLowerCase())) count1++;\n\t\tif (vowels.includes(s[s.length / 2 + i].toLowerCase())) count2++;\n\t}\n\tif (count1 === count2) return true;\n\telse return false;\n};"}
{"id": "364", "path": "output2\\js\\Easy\\364-maximum-units-on-a-truck.js", "hypo_code": "var maximumUnits = function(boxTypes, truckSize) {\n    let sortedBoxTypes = boxTypes.sort((a, b) => b[1] - a[1]);\n\tlet total = 0;\n\tfor (let i = 0; i < sortedBoxTypes.length; i++) {\n\t\tif (truckSize < sortedBoxTypes[i][0]) {\n\t\t\ttotal += truckSize * sortedBoxTypes[i][1];\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\ttotal += sortedBoxTypes[i][0] * sortedBoxTypes[i][1];\n\t\t\ttruckSize -= sortedBoxTypes[i][0];\n\t\t}\n\t}\n\treturn total;\n};"}
{"id": "365", "path": "output2\\js\\Easy\\365-calculate-money-in-leetcode-bank.js", "hypo_code": "var totalMoney = function(n) {\n    let total = 0;\n    let week = 0;\n    for (let i = 0; i < n; i++) {\n        total += week + (i % 7);\n        if (i % 7 === 6) week++;\n    }\n    return total;\n};"}
{"id": "366", "path": "output2\\js\\Easy\\366-decode-xored-array.js", "hypo_code": "var decode = function(encoded, first) {\n    let result = [first];\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tresult.push(result[i] ^ encoded[i]);\n\t}\n\treturn result;\n};"}
{"id": "367", "path": "output2\\js\\Easy\\367-number-of-rectangles-that-can-form-the-largest-square.js", "hypo_code": "var countGoodRectangles = function(rectangles) {\n    let maxLen = 0;\n    let count = 0;\n    for (let i = 0; i < rectangles.length; i++) {\n        let min = Math.min(rectangles[i][0], rectangles[i][1]);\n        if (min > maxLen) {\n            maxLen = min;\n            count = 1;\n        }\n        else if (min === maxLen) count++;\n    }\n    return count;\n};"}
{"id": "370", "path": "output2\\js\\Easy\\370-find-the-highest-altitude.js", "hypo_code": "var largestAltitude = function(gain) {\n    let max = 0;\n    let sum = 0;\n    for (let i = 0; i < gain.length; i++) {\n        sum += gain[i];\n        if (sum > max) max = sum;\n    }\n    return max;\n};"}
{"id": "371", "path": "output2\\js\\Easy\\371-latest-time-by-replacing-hidden-digits.js", "hypo_code": "var maximumTime = function(time) {\n    let arr = time.split('');\n    if (arr[0] === '?') {\n        if (arr[1] === '?' || arr[1] < 4) arr[0] = '2';\n        else arr[0] = '1';\n    }\n    if (arr[1] === '?') {\n        if (arr[0] === '2') arr[1] = '3';\n        else arr[1] = '9';\n    }\n    if (arr[3] === '?') arr[3] = '5';\n    if (arr[4] === '?') arr[4] = '9';\n    return arr.join('');\n};"}
{"id": "373", "path": "output2\\js\\Easy\\373-maximum-number-of-balls-in-a-box.js", "hypo_code": "var countBalls = function(lowLimit, highLimit) {\n    let map = new Map();\n    let max = 0;\n    for (let i = lowLimit; i <= highLimit; i++) {\n        let sum = 0;\n        let num = i;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        if (map.has(sum)) map.set(sum, map.get(sum) + 1);\n        else map.set(sum, 1);\n        max = Math.max(max, map.get(sum));\n    }\n    return max;\n};"}
{"id": "374", "path": "output2\\js\\Easy\\374-sum-of-unique-elements.js", "hypo_code": "var sumOfUnique = function(nums) {\n    let map = new Map();\n    for (let num of nums) {\n        if (map.has(num)) map.set(num, map.get(num) + 1);\n        else map.set(num, 1);\n    }\n    let sum = 0;\n    for (let [key, value] of map) {\n        if (value === 1) sum += key;\n    }\n    return sum;\n};"}
{"id": "375", "path": "output2\\js\\Easy\\375-check-if-array-is-sorted-and-rotated.js", "hypo_code": "var check = function(nums) {\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > nums[(i + 1) % nums.length]) count++;\n    }\n    return count <= 1;\n};"}
{"id": "377", "path": "output2\\js\\Easy\\377-minimum-changes-to-make-alternating-binary-string.js", "hypo_code": "var minOperations = function(s) {\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === s[i + 1]) count++;\n    }\n    return Math.min(count, s.length - count);\n\n};"}
{"id": "378", "path": "output2\\js\\Easy\\378-longest-nice-substring.js", "hypo_code": "var longestNiceSubstring = function(s) {\n    let arr = s.split('');\n    let max = '';\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = i; j < arr.length; j++) {\n            let sub = s.slice(i, j + 1);\n            if (isNice(sub) && sub.length > max.length) max = sub;\n        }\n    }\n    return max;\n};\nvar isNice = function(s) {\n    let map = new Map();\n    for (let char of s) {\n        if (map.has(char)) map.set(char, map.get(char) + 1);\n        else map.set(char, 1);\n    }\n    for (let char of s) {\n        if (map.get(char.toLowerCase()) !== map.get(char.toUpperCase())) return false;\n    }\n    return true;\n};"}
{"id": "379", "path": "output2\\js\\Easy\\379-merge-strings-alternately.js", "hypo_code": "var mergeAlternately = function(word1, word2) {\n    let arr1 = word1.split('');\n\tlet arr2 = word2.split('');\n\tlet res = '';\n\twhile (arr1.length > 0 && arr2.length > 0) {\n\t\tres += arr1.shift();\n\t\tres += arr2.shift();\n\t}\n\treturn res + arr1.join('') + arr2.join('');\n};"}
{"id": "380", "path": "output2\\js\\Easy\\380-count-items-matching-a-rule.js", "hypo_code": "var countMatches = function(items, ruleKey, ruleValue) {\n    let count = 0;\n\tfor (let i = 0; i < items.length; i++) {\n\t\tif (ruleKey === 'type' && items[i][0] === ruleValue) count++;\n\t\tif (ruleKey === 'color' && items[i][1] === ruleValue) count++;\n\t\tif (ruleKey === 'name' && items[i][2] === ruleValue) count++;\n\t}\n\treturn count;\n};"}
{"id": "381", "path": "output2\\js\\Easy\\381-find-nearest-point-that-has-the-same-x-or-y-coordinate.js", "hypo_code": "var nearestValidPoint = function(x, y, points) {\n    let min = Infinity;\n    let index = -1;\n    for (let i = 0; i < points.length; i++) {\n        let [a, b] = points[i];\n        if (a === x || b === y) {\n            let dist = Math.abs(x - a) + Math.abs(y - b);\n            if (dist < min) {\n                min = dist;\n                index = i;\n            }\n        }\n    }\n    return index;\n};"}
{"id": "382", "path": "output2\\js\\Easy\\382-check-if-binary-string-has-at-most-one-segment-of-ones.js", "hypo_code": "var checkOnesSegment = function(s) {\n    return s.indexOf('01') === -1;\n\n};"}
{"id": "384", "path": "output2\\js\\Easy\\384-check-if-one-string-swap-can-make-strings-equal.js", "hypo_code": "var areAlmostEqual = function(s1, s2) {\n    if (s1 === s2) return true;\n\tlet count = 0;\n\tlet index1 = -1;\n\tlet index2 = -1;\n\tfor (let i = 0; i < s1.length; i++) {\n\t\tif (s1[i] !== s2[i]) {\n\t\t\tcount++;\n\t\t\tif (count === 1) index1 = i;\n\t\t\tif (count === 2) index2 = i;\n\t\t}\n\t}\n\tif (count !== 2) return false;\n\tif (s1[index1] === s2[index2] && s1[index2] === s2[index1]) return true;\n\treturn false;\n};"}
{"id": "385", "path": "output2\\js\\Easy\\385-find-center-of-star-graph.js", "hypo_code": "var findCenter = function(edges) {\n    let map = {};\n    for(let i = 0; i < edges.length; i++){\n        let edge = edges[i];\n        for(let j = 0; j < edge.length; j++){\n            let node = edge[j];\n            if(map[node] == undefined){\n                map[node] = 1;\n            }else{\n                map[node]++;\n            }\n        }\n    }\n    for(let key in map){\n        if(map[key] == edges.length){\n            return key;\n        }\n    }\n    return 0;\n    \n};"}
{"id": "387", "path": "output2\\js\\Easy\\387-second-largest-digit-in-a-string.js", "hypo_code": "var secondHighest = function(s) {\n    let max = -1;\n    let second = -1;\n    for (let char of s) {\n        if (/[0-9]/.test(char)) {\n            let num = Number(char);\n            if (num > max) {\n                second = max;\n                max = num;\n            } else if (num > second && num < max) second = num;\n        }\n    }\n    return second;\n};"}
{"id": "388", "path": "output2\\js\\Easy\\388-maximum-ascending-subarray-sum.js", "hypo_code": "var maxAscendingSum = function(nums) {\n    let sum = nums[0];\n    let max = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] > nums[i-1]) {\n            sum += nums[i];\n        } else {\n            sum = nums[i];\n        }\n        max = Math.max(max, sum);\n    }\n    return max;\n};"}
{"id": "389", "path": "output2\\js\\Easy\\389-number-of-different-integers-in-a-string.js", "hypo_code": "var numDifferentIntegers = function(word) {\n    let set = new Set();\n    let num = '';\n    for (let char of word) {\n        if (/[0-9]/.test(char)) num += char;\n        else if (num.length) {\n            set.add(num.replace(/^0+/, ''));\n            num = '';\n        }\n    }\n    if (num.length) set.add(num.replace(/^0+/, ''));\n    return set.size;\n};"}
{"id": "390", "path": "output2\\js\\Easy\\390-determine-color-of-a-chessboard-square.js", "hypo_code": "var squareIsWhite = function(coordinates) {\n    let [x, y] = coordinates.split('');\n    return (x.charCodeAt(0) + parseInt(y)) % 2 === 0;\n\n};"}
{"id": "391", "path": "output2\\js\\Easy\\391-truncate-sentence.js", "hypo_code": "var truncateSentence = function(s, k) {\n    let arr = s.split(' ');\n\treturn arr.slice(0, k).join(' ');\n};"}
{"id": "392", "path": "output2\\js\\Easy\\392-sign-of-the-product-of-an-array.js", "hypo_code": "var arraySign = function(nums) {\n    let product = 1;\n    for (let num of nums) {\n        if (num === 0) return 0;\n        product *= num > 0 ? 1 : -1;\n    }\n    return product;\n};"}
{"id": "393", "path": "output2\\js\\Easy\\393-minimum-operations-to-make-the-array-increasing.js", "hypo_code": "var minOperations = function(nums) {\n    let count = 0;\n    for (let i = 0; i < nums.length - 1; i++) {\n        if (nums[i] >= nums[i + 1]) {\n            count += nums[i] - nums[i + 1] + 1;\n            nums[i + 1] = nums[i] + 1;\n        }\n    }\n    return count;\n};"}
{"id": "394", "path": "output2\\js\\Easy\\394-check-if-the-sentence-is-pangram.js", "hypo_code": "var checkIfPangram = function(sentence) {\n    let set = new Set();\n    for (let char of sentence) {\n        set.add(char);\n    }\n    return set.size === 26;\n};"}
{"id": "395", "path": "output2\\js\\Easy\\395-sum-of-digits-in-base-k.js", "hypo_code": "var sumBase = function(n, k) {\n    let sum = 0;\n    while (n > 0) {\n        sum += n % k;\n        n = Math.floor(n / k);\n    }\n    return sum;\n};"}
{"id": "396", "path": "output2\\js\\Easy\\396-replace-all-digits-with-characters.js", "hypo_code": "var replaceDigits = function(s) {\n    let arr = s.split('');\n    for (let i = 1; i < arr.length; i += 2) {\n        arr[i] = String.fromCharCode(arr[i - 1].charCodeAt(0) + Number(arr[i]));\n    }\n    return arr.join('');\n};"}
{"id": "397", "path": "output2\\js\\Easy\\397-minimum-distance-to-the-target-element.js", "hypo_code": "var getMinDistance = function(nums, target, start) {\n    let min = Infinity;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === target) {\n            let dist = Math.abs(i - start);\n            if (dist < min) min = dist;\n        }\n    }\n    return min;\n};"}
{"id": "398", "path": "output2\\js\\Easy\\398-maximum-population-year.js", "hypo_code": "var maximumPopulation = function(logs) {\n    let map = new Map();\n    for (let log of logs) {\n        for (let i = log[0]; i < log[1]; i++) {\n            if (map.has(i)) map.set(i, map.get(i) + 1);\n            else map.set(i, 1);\n        }\n    }\n    let max = 0;\n    let maxYear = 0;\n    for (let [key, value] of map) {\n        if (value > max) {\n            max = value;\n            maxYear = key;\n        }\n    }\n    return maxYear;\n};"}
{"id": "399", "path": "output2\\js\\Easy\\399-sorting-the-sentence.js", "hypo_code": "var sortSentence = function(s) {\n    let arr = s.split(' ');\n    let res = new Array(arr.length);\n    for (let word of arr) {\n        let index = Number(word[word.length - 1]) - 1;\n        res[index] = word.substring(0, word.length - 1);\n    }\n    return res.join(' ');\n};"}
{"id": "400", "path": "output2\\js\\Easy\\400-sum-of-all-subset-xor-totals.js", "hypo_code": "var subsetXORSum = function(nums) {\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let temp = nums[i];\n        sum += temp;\n        for (let j = i + 1; j < nums.length; j++) {\n            temp ^= nums[j];\n            sum += temp;\n        }\n    }\n    return sum;\n};"}
{"id": "401", "path": "output2\\js\\Easy\\401-longer-contiguous-segments-of-ones-than-zeros.js", "hypo_code": "var checkZeroOnes = function(s) {\n    let maxOne = 0;\n    let maxZero = 0;\n    let one = 0;\n    let zero = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '1') {\n            one++;\n            maxOne = Math.max(maxOne, one);\n            zero = 0;\n        } else {\n            zero++;\n            maxZero = Math.max(maxZero, zero);\n            one = 0;\n        }\n    }\n    return maxOne > maxZero;\n};"}
{"id": "403", "path": "output2\\js\\Easy\\403-substrings-of-size-three-with-distinct-characters.js", "hypo_code": "var countGoodSubstrings = function(s) {\n    let count = 0;\n    for (let i = 0; i < s.length - 2; i++) {\n        let sub = s.slice(i, i + 3);\n        if (isGood(sub)) count++;\n    }\n    return count;\n};\nvar isGood = function(s) {\n    let map = new Map();\n    for (let char of s) {\n        if (map.has(char)) return false;\n        else map.set(char, 1);\n    }\n    return true;\n};"}
{"id": "404", "path": "output2\\js\\Easy\\404-check-if-word-equals-summation-of-two-words.js", "hypo_code": "var isSumEqual = function(firstWord, secondWord, targetWord) {\n    return convert(firstWord) + convert(secondWord) === convert(targetWord);\n};\nvar convert = function(s) {\n    let res = '';\n    for (let char of s) {\n        res += char.charCodeAt(0) - 'a'.charCodeAt(0);\n    }\n    return parseInt(res);\n};"}
{"id": "405", "path": "output2\\js\\Easy\\405-determine-whether-matrix-can-be-obtained-by-rotation.js", "hypo_code": "var findRotation = function(mat, target) {\n    if (mat === target) return true;\n    let n = mat.length;\n    let rotated = mat.map((val, index) => val.map((val2, index2) => mat[n - index2 - 1][index]));\n    if (rotated === target) return true;\n    rotated = rotated.map((val, index) => val.map((val2, index2) => rotated[n - index2 - 1][index]));\n    if (rotated === target) return true;\n    rotated = rotated.map((val, index) => val.map((val2, index2) => rotated[n - index2 - 1][index]));\n    if (rotated === target) return true;\n    return false;\n};"}
{"id": "407", "path": "output2\\js\\Easy\\407-check-if-all-the-integers-in-a-range-are-covered.js", "hypo_code": "var isCovered = function(ranges, left, right) {\n    let covered = new Array(51).fill(0);\n    for (let [start, end] of ranges) {\n        for (let i = start; i <= end; i++) {\n            covered[i] = 1;\n        }\n    }\n    for (let i = left; i <= right; i++) {\n        if (covered[i] === 0) return false;\n    }\n    return true;\n};"}
{"id": "408", "path": "output2\\js\\Easy\\408-redistribute-characters-to-make-all-strings-equal.js", "hypo_code": "var makeEqual = function(words) {\n    const map = {};\n    for (const word of words) {\n        for (const char of word) {\n            if (!map[char]) map[char] = 1;\n            else map[char]++;\n        }\n    }\n    for (const key in map) {\n        if (map[key] % words.length !== 0) return false;\n    }\n    return true;\n};"}
{"id": "409", "path": "output2\\js\\Easy\\409-largest-odd-number-in-string.js", "hypo_code": "var largestOddNumber = function(num) {\n    let i = num.length - 1;\n    while (i >= 0) {\n        if (num[i] % 2 === 1) return num.slice(0, i + 1);\n        i--;\n    }\n    return '';\n};"}
{"id": "410", "path": "output2\\js\\Easy\\410-remove-one-element-to-make-the-array-strictly-increasing.js", "hypo_code": "var canBeIncreasing = function(nums) {\n    let count = 0;\n    for (let i = 0; i < nums.length - 1; i++) {\n        if (nums[i + 1] <= nums[i]) {\n            if (count === 1) return false;\n            if (i > 0 && nums[i + 1] <= nums[i - 1]) nums[i + 1] = nums[i];\n            count++;\n        }\n    }\n    return true;\n};"}
{"id": "411", "path": "output2\\js\\Easy\\411-maximum-product-difference-between-two-pairs.js", "hypo_code": "_x000D_\nvar maxProductDifference = function(nums) {  \n    let max1 = Math.max(...nums);    let index1 = nums.indexOf(max1);    nums.splice(index1, 1);    let max2 = Math.max(...nums);    let index2 = nums.indexOf(max2);    nums.splice(index2, 1);    let min1 = Math.min(...nums);    let index3 = nums.indexOf(min1);    nums.splice(index3, 1);    let min2 = Math.min(...nums);    let index4 = nums.indexOf(min2);    nums.splice(index4, 1);    return max1 * max2 - min1 * min2;\n\n};"}
{"id": "412", "path": "output2\\js\\Easy\\412-build-array-from-permutation.js", "hypo_code": "var buildArray = function(nums) {\n    let ans = [];\n    for (let i = 0; i < nums.length; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n};"}
{"id": "413", "path": "output2\\js\\Easy\\413-count-square-sum-triples.js", "hypo_code": "var countTriples = function(n) {\n    let count = 0;\n    for (let a = 1; a <= n; a++) {\n        for (let b = 1; b <= n; b++) {\n            let c = Math.sqrt(a * a + b * b);\n            if (c % 1 === 0 && c <= n) count++;\n        }\n    }\n    return count;\n};"}
{"id": "414", "path": "output2\\js\\Easy\\414-concatenation-of-array.js", "hypo_code": "var getConcatenation = function(nums) {\n    let ans = [...nums];\n    for (let num of nums) {\n        ans.push(num);\n    }\n    return ans;\n};"}
{"id": "415", "path": "output2\\js\\Easy\\415-maximum-number-of-words-you-can-type.js", "hypo_code": "var canBeTypedWords = function(text, brokenLetters) {\n    let set = new Set();\n    for (let char of brokenLetters) set.add(char);\n    let arr = text.split(' ');\n    let count = 0;\n    for (let word of arr) {\n        let broken = false;\n        for (let char of word) {\n            if (set.has(char)) {\n                broken = true;\n                break;\n            }\n        }\n        if (!broken) count++;\n    }\n    return count;\n};"}
{"id": "416", "path": "output2\\js\\Easy\\416-check-if-all-characters-have-equal-number-of-occurrences.js", "hypo_code": "var areOccurrencesEqual = function(s) {\n    let map = new Map();\n    for (let char of s) {\n        if (map.has(char)) map.set(char, map.get(char) + 1);\n        else map.set(char, 1);\n    }\n    let count = map.get(s[0]);\n    for (let [key, value] of map) {\n        if (value !== count) return false;\n    }\n    return true;\n};"}
{"id": "417", "path": "output2\\js\\Easy\\417-sum-of-digits-of-string-after-convert.js", "hypo_code": "var getLucky = function(s, k) {\n    let stringToNumber = '';\n\tfor (let i = 0; i < s.length; i++) {\n\t\tstringToNumber += (s.charCodeAt(i) - 96).toString();\n\t}\n\tlet result = 0;\n\tfor (let i = 0; i < k; i++) {\n\t\tfor (let j = 0; j < stringToNumber.length; j++) {\n\t\t\tresult += parseInt(stringToNumber[j]);\n\t\t}\n\t\tstringToNumber = result.toString();\n\t\tresult = 0;\n\t}\n\treturn parseInt(stringToNumber);\n};"}
{"id": "418", "path": "output2\\js\\Easy\\418-three-divisors.js", "hypo_code": "var isThree = function(n) {\n    let count = 2;\n    for (let i = 2; i < n; i++) {\n        if (n % i === 0) count++;\n    }\n    return count === 3;\n};"}
{"id": "419", "path": "output2\\js\\Easy\\419-delete-characters-to-make-fancy-string.js", "hypo_code": "var makeFancyString = function(s) {\n    let result = '';\n    let count = 1;\n    let prev = s[0];\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === prev) {\n            count++;\n        } else {\n            count = 1;\n            prev = s[i];\n        }\n        if (count < 3) result += s[i];\n    }\n    return result;\n};"}
{"id": "420", "path": "output2\\js\\Easy\\420-check-if-string-is-a-prefix-of-array.js", "hypo_code": "var isPrefixString = function(s, words) {\n    let prefix = '';\n    for (let word of words) {\n        prefix += word;\n        if (prefix === s) return true;\n        if (prefix.length > s.length) return false;\n    }\n    return false;\n};"}
{"id": "422", "path": "output2\\js\\Easy\\422-number-of-strings-that-appear-as-substrings-in-word.js", "hypo_code": "var numOfStrings = function(patterns, word) {\n    let count = 0;\n    for (let pattern of patterns) {\n        if (word.includes(pattern)) count++;\n    }\n    return count;\n};"}
{"id": "423", "path": "output2\\js\\Easy\\423-find-if-path-exists-in-graph.js", "hypo_code": "var validPath = function(n, edges, source, destination) {\n    let map = new Map();\n    for (let edge of edges) {\n        let [u, v] = edge;\n        if (map.has(u)) map.get(u).push(v);\n        else map.set(u, [v]);\n        if (map.has(v)) map.get(v).push(u);\n        else map.set(v, [u]);\n    }\n    let visited = new Set();\n    let queue = [source];\n    while (queue.length) {\n        let node = queue.shift();\n        if (node === destination) return true;\n        visited.add(node);\n        let neighbors = map.get(node);\n        for (let neighbor of neighbors) {\n            if (!visited.has(neighbor)) queue.push(neighbor);\n        }\n    }\n    return false;\n};"}
{"id": "424", "path": "output2\\js\\Easy\\424-minimum-time-to-type-word-using-special-typewriter.js", "hypo_code": "var minTimeToType = function(word) {\n    let count = 0;\n    let curr = 0;\n    for (let char of word) {\n        let target = char.charCodeAt(0) - 97;\n        let diff = Math.abs(target - curr);\n        count += Math.min(diff, 26 - diff) + 1;\n        curr = target;\n    }\n    return count;\n};"}
{"id": "426", "path": "output2\\js\\Easy\\426-find-greatest-common-divisor-of-array.js", "hypo_code": "var findGCD = function(nums) {\n    let min = Math.min(...nums);\n    let max = Math.max(...nums);\n    let gcd = 1;\n    for (let i = 1; i <= min; i++) {\n        if (min % i === 0 && max % i === 0) gcd = i;\n    }\n    return gcd;\n};"}
{"id": "427", "path": "output2\\js\\Easy\\427-minimum-difference-between-highest-and-lowest-of-k-scores.js", "hypo_code": "var minimumDifference = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let min = Infinity;\n    for (let i = 0; i <= nums.length - k; i++) {\n        min = Math.min(min, nums[i + k - 1] - nums[i]);\n    }\n    return min;\n};"}
{"id": "428", "path": "output2\\js\\Easy\\428-find-the-middle-index-in-array.js", "hypo_code": "var findMiddleIndex = function(nums) {\n    let leftSum = 0;\n    let rightSum = nums.reduce((a, b) => a + b) - nums[0];\n    let middleIndex = 0;\n    while (middleIndex < nums.length) {\n        if (leftSum === rightSum) return middleIndex;\n        leftSum += nums[middleIndex];\n        rightSum -= nums[middleIndex + 1];\n        middleIndex++;\n    }\n    return -1;\n};"}
{"id": "429", "path": "output2\\js\\Easy\\429-count-special-quadruplets.js", "hypo_code": "var countQuadruplets = function(nums) {\n    let count = 0;\n    for (let i = 0; i < nums.length - 3; i++) {\n        for (let j = i + 1; j < nums.length - 2; j++) {\n            for (let k = j + 1; k < nums.length - 1; k++) {\n                for (let l = k + 1; l < nums.length; l++) {\n                    if (nums[i] + nums[j] + nums[k] === nums[l]) count++;\n                }\n            }\n        }\n    }\n    return count;\n};"}
{"id": "430", "path": "output2\\js\\Easy\\430-reverse-prefix-of-word.js", "hypo_code": "var reversePrefix = function(word, ch) {\n    let index = word.indexOf(ch);\n    if (index === -1) return word;\n    let arr = word.split('');\n    for (let i = 0; i <= Math.floor(index / 2); i++) {\n        let temp = arr[i];\n        arr[i] = arr[index - i];\n        arr[index - i] = temp;\n    }\n    return arr.join('');\n};"}
{"id": "431", "path": "output2\\js\\Easy\\431-count-number-of-pairs-with-absolute-difference-k.js", "hypo_code": "var countKDifference = function(nums, k) {\n    let map = new Map();\n    for (let num of nums) {\n        if (map.has(num)) map.set(num, map.get(num) + 1);\n        else map.set(num, 1);\n    }\n    let count = 0;\n    for (let [key, value] of map) {\n        if (map.has(key + k)) count += value * map.get(key + k);\n    }\n    return count;\n};"}
{"id": "432", "path": "output2\\js\\Easy\\432-final-value-of-variable-after-performing-operations.js", "hypo_code": "var finalValueAfterOperations = function(operations) {\n    var x = 0;\n    for (var i = 0; i < operations.length; i++) {\n        if (operations[i] === '++X' || operations[i] === 'X++') {\n            x++;\n        } else {\n            x--;\n        }\n    }\n    return x;\n};"}
{"id": "433", "path": "output2\\js\\Easy\\433-maximum-difference-between-increasing-elements.js", "hypo_code": "var maximumDifference = function(nums) {\n    var maxDiff = -1;\n    for (var i = 0; i < nums.length - 1; i++) {\n        for (var j = i + 1; j < nums.length; j++) {\n            if (nums[j] > nums[i] && nums[j] - nums[i] > maxDiff) {\n                maxDiff = nums[j] - nums[i];\n            }\n        }\n    }\n    return maxDiff;\n};"}
{"id": "434", "path": "output2\\js\\Easy\\434-convert-1d-array-into-2d-array.js", "hypo_code": "var construct2DArray = function(original, m, n) {\n    if (m * n !== original.length) return [];\n    let res = [];\n    let temp = [];\n    for (let i = 0; i < original.length; i++) {\n        temp.push(original[i]);\n        if (temp.length === n) {\n            res.push(temp);\n            temp = [];\n        }\n    }\n    return res;\n};"}
{"id": "435", "path": "output2\\js\\Easy\\435-minimum-moves-to-convert-string.js", "hypo_code": "var minimumMoves = function(s) {\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === 'X') {\n            count++;\n            i += 2;\n        }\n    }\n    return count;\n};"}
{"id": "436", "path": "output2\\js\\Easy\\436-two-out-of-three.js", "hypo_code": "var twoOutOfThree = function(nums1, nums2, nums3) {\n    let set1 = new Set(nums1);\n    let set2 = new Set(nums2);\n    let set3 = new Set(nums3);\n    let res = new Set();\n    for (let n of set1) {\n        if (set2.has(n) || set3.has(n)) res.add(n);\n    }\n    for (let n of set2) {\n        if (set1.has(n) || set3.has(n)) res.add(n);\n    }\n    for (let n of set3) {\n        if (set1.has(n) || set2.has(n)) res.add(n);\n    }\n    return Array.from(res);\n};"}
{"id": "437", "path": "output2\\js\\Easy\\437-minimum-number-of-moves-to-seat-everyone.js", "hypo_code": "var minMovesToSeat = function(seats, students) {\n    seats.sort((a, b) => a - b);\n    students.sort((a, b) => a - b);\n    let res = 0;\n    for (let i = 0; i < seats.length; i++) {\n        res += Math.abs(seats[i] - students[i]);\n    }\n    return res;\n};"}
{"id": "438", "path": "output2\\js\\Easy\\438-check-if-numbers-are-ascending-in-a-sentence.js", "hypo_code": "var areNumbersAscending = function(s) {\n    let arr = s.split(' ');\n    let prev = -1;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] >= 0 && arr[i] <= 9) {\n            if (arr[i] <= prev) return false;\n            prev = arr[i];\n        }\n    }\n    return true;\n};"}
{"id": "439", "path": "output2\\js\\Easy\\439-number-of-valid-words-in-a-sentence.js", "hypo_code": "var countValidWords = function(sentence) {\n    let arr = sentence.split(' ');\n    let res = 0;\n    for (let word of arr) {\n        if (word.match(/^[a-z\\-]+[!.,]?$/)) res++;\n    }\n    return res;\n};"}
{"id": "440", "path": "output2\\js\\Easy\\440-kth-distinct-string-in-an-array.js", "hypo_code": "var kthDistinct = function(arr, k) {\n    let map = {};\n    for (let s of arr) {\n        if (map[s]) map[s]++;\n        else map[s] = 1;\n    }\n    let count = 0;\n    for (let s of arr) {\n        if (map[s] === 1) {\n            count++;\n            if (count === k) return s;\n        }\n    }\n    return \"\";\n};"}
{"id": "441", "path": "output2\\js\\Easy\\441-smallest-index-with-equal-value.js", "hypo_code": "var smallestEqual = function(nums) {\n    for (let i = 0; i < nums.length; i++) {\n        if (i % 10 === nums[i]) return i;\n    }\n    return -1;\n};"}
{"id": "442", "path": "output2\\js\\Easy\\442-count-vowel-substrings-of-a-string.js", "hypo_code": "var countVowelSubstrings = function(word) {\n    let count = 0;\n    for (let i = 0; i < word.length; i++) {\n        let cur = word[i];\n        if (isVowel(cur)) count++;\n        for (let j = i + 1; j < word.length; j++) {\n            cur += word[j];\n            if (isVowel(cur)) count++;\n        }\n    }\n    return count;\n};\nfunction isVowel(s) {\n    if (s.length > 5) return false;\n    return s.includes('a') && s.includes('e') && s.includes('i') && s.includes('o') && s.includes('u');\n}"}
{"id": "443", "path": "output2\\js\\Easy\\443-check-whether-two-strings-are-almost-equivalent.js", "hypo_code": "var checkAlmostEquivalent = function(word1, word2) {\n    let arr1 = new Array(26).fill(0);\n    let arr2 = new Array(26).fill(0);\n    for (let i = 0; i < word1.length; i++) {\n        arr1[word1.charCodeAt(i) - 97]++;\n        arr2[word2.charCodeAt(i) - 97]++;\n    }\n    let count = 0;\n    for (let i = 0; i < 26; i++) {\n        if (Math.abs(arr1[i] - arr2[i]) > 3) return false;\n        if (arr1[i] !== 0 && arr2[i] !== 0) count++;\n    }\n    return count <= 23;\n};"}
{"id": "444", "path": "output2\\js\\Easy\\444-time-needed-to-buy-tickets.js", "hypo_code": "var timeRequiredToBuy = function(tickets, k) {\n    let res = 0;\n    let queue = [];\n    for (let i = 0; i < tickets.length; i++) {\n        queue.push([i, tickets[i]]);\n    }\n    while (true) {\n        let cur = queue.shift();\n        if (cur[1] === 1) {\n            if (cur[0] === k) return res + 1;\n            else res++;\n        } else {\n            queue.push([cur[0], cur[1] - 1]);\n        }\n    }\n};"}
{"id": "445", "path": "output2\\js\\Easy\\445-two-furthest-houses-with-different-colors.js", "hypo_code": "var maxDistance = function(colors) {\n    let res = 0;\n    for (let i = 0; i < colors.length; i++) {\n        for (let j = i + 1; j < colors.length; j++) {\n            if (colors[i] !== colors[j]) {\n                res = Math.max(res, j - i);\n            }\n        }\n    }\n    return res;\n};"}
{"id": "447", "path": "output2\\js\\Easy\\447-count-common-words-with-one-occurrence.js", "hypo_code": "var countWords = function(words1, words2) {\n    let map1 = {};\n    for (let s of words1) {\n        if (map1[s]) map1[s]++;\n        else map1[s] = 1;\n    }\n    let map2 = {};\n    for (let s of words2) {\n        if (map2[s]) map2[s]++;\n        else map2[s] = 1;\n    }\n    let res = 0;\n    for (let s of words1) {\n        if (map1[s] === 1 && map2[s] === 1) res++;\n    }\n    for (let s of words2) {\n        if (map1[s] === 1 && map2[s] === 1) res++;\n    }\n    return res;\n};"}
{"id": "448", "path": "output2\\js\\Easy\\448-find-target-indices-after-sorting-array.js", "hypo_code": "var targetIndices = function(nums, target) {\n    let sorted = [...nums].sort((a, b) => a - b);\n    let res = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === target) {\n            res.push(sorted.indexOf(nums[i]));\n        }\n    }\n    return res.sort((a, b) => a - b);\n};"}
{"id": "449", "path": "output2\\js\\Easy\\449-finding-3-digit-even-numbers.js", "hypo_code": "var findEvenNumbers = function(digits) {\n    let res = [];\n    for (let i = 0; i < digits.length; i++) {\n        for (let j = 0; j < digits.length; j++) {\n            for (let k = 0; k < digits.length; k++) {\n                if (i !== j && j !== k && i !== k) {\n                    let num = Number(digits[i].toString() + digits[j].toString() + digits[k].toString());\n                    if (num % 2 === 0 && !res.includes(num)) res.push(num);\n                }\n            }\n        }\n    }\n    return res;\n};"}
{"id": "450", "path": "output2\\js\\Easy\\450-find-subsequence-of-length-k-with-the-largest-sum.js", "hypo_code": "var maxSubsequence = function(nums, k) {\n    let res = [];\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        let max = Math.max(...nums);\n        let maxIdx = nums.indexOf(max);\n        res.push(max);\n        nums.splice(maxIdx, 1);\n        sum += max;\n    }\n    return res;\n};"}
{"id": "451", "path": "output2\\js\\Easy\\451-rings-and-rods.js", "hypo_code": "var countPoints = function(rings) {\n    let res = 0;\n    for (let i = 0; i < 10; i++) {\n        let r = false;\n        let g = false;\n        let b = false;\n        for (let j = 0; j < rings.length; j += 2) {\n            if (rings[j + 1] === i.toString()) {\n                if (rings[j] === 'R') {\n                    r = true;\n                } else if (rings[j] === 'G') {\n                    g = true;\n                } else {\n                    b = true;\n                }\n            }\n        }\n        if (r && g && b) {\n            res++;\n        }\n    }\n    return res;\n};"}
{"id": "452", "path": "output2\\js\\Easy\\452-find-first-palindromic-string-in-the-array.js", "hypo_code": "var firstPalindrome = function(words) {\n    for (let s of words) {\n        if (isPalindrome(s)) return s;\n    }\n    return \"\";\n\n};\nfunction isPalindrome(s) {\n    let l = 0, r = s.length - 1;\n    while (l < r) {\n        if (s[l] !== s[r]) return false;\n        l++;\n        r--;\n    }\n    return true;\n}"}
{"id": "453", "path": "output2\\js\\Easy\\453-maximum-number-of-words-found-in-sentences.js", "hypo_code": "var mostWordsFound = function(sentences) {\n    let res = 0;\n    for (let s of sentences) {\n        let count = 0;\n        for (let i = 0; i < s.length; i++) {\n            if (s[i] === ' ') count++;\n        }\n        res = Math.max(res, count + 1);\n    }\n    return res;\n};"}
{"id": "454", "path": "output2\\js\\Easy\\454-a-number-after-a-double-reversal.js", "hypo_code": "var isSameAfterReversals = function(num) {\n    let reversed1 = parseInt(num.toString().split('').reverse().join(''));\n    let reversed2 = parseInt(reversed1.toString().split('').reverse().join(''));\n    return reversed2 === num;\n};"}
{"id": "455", "path": "output2\\js\\Easy\\455-check-if-all-as-appears-before-all-bs.js", "hypo_code": "var checkString = function(s) {\n    let a = 0, b = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === 'a') a++;\n        else b++;\n        if (b > a) return false;\n    }\n    return true;\n};"}
{"id": "456", "path": "output2\\js\\Easy\\456-capitalize-the-title.js", "hypo_code": "var capitalizeTitle = function(title) {\n    let arr = title.split(' ');\n    let res = \"\";\n    for (let i = 0; i < arr.length; i++) {\n        let s = arr[i];\n        if (s.length <= 2) {\n            res += s.toLowerCase();\n        } else {\n            res += s[0].toUpperCase();\n            res += s.substring(1).toLowerCase();\n        }\n        if (i < arr.length - 1) res += ' ';\n    }\n    return res;\n};"}
{"id": "457", "path": "output2\\js\\Easy\\457-check-if-every-row-and-column-contains-all-numbers.js", "hypo_code": "var checkValid = function(matrix) {\n    let n = matrix.length;\n    let rows = new Array(n).fill(0);\n    let cols = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        rows[i] = new Set();\n        cols[i] = new Set();\n    }\n    for (let i = 0; i < n; i++) {\n        let row = rows[i];\n        let col = cols[i];\n        for (let j = 0; j < n; j++) {\n            let num = matrix[i][j];\n            if (num > n || num < 1) return false;\n            if (row.has(num)) return false;\n            row.add(num);\n            if (col.has(num)) return false;\n            col.add(num);\n        }\n    }\n    return true;\n};"}
{"id": "458", "path": "output2\\js\\Easy\\458-divide-a-string-into-groups-of-size-k.js", "hypo_code": "var divideString = function(s, k, fill) {\n    let res = [];\n    let n = s.length;\n    let i = 0;\n    while (i < n) {\n        let str = \"\";\n        for (let j = 0; j < k; j++) {\n            if (i + j < n) str += s[i + j];\n            else str += fill;\n        }\n        res.push(str);\n        i += k;\n    }\n    return res;\n};"}
{"id": "459", "path": "output2\\js\\Easy\\459-minimum-cost-of-buying-candies-with-discount.js", "hypo_code": "var minimumCost = function(cost) {\n    let res = 0;\n    while (cost.length > 1) {\n        let min = Math.min(...cost);\n        let idx = cost.indexOf(min);\n        let free = idx === 0 ? 1 : idx - 1;\n        res += cost[idx] + cost[free];\n        cost.splice(idx, 1);\n        cost.splice(free, 1);\n    }\n    return res;\n};"}
{"id": "460", "path": "output2\\js\\Easy\\460-count-elements-with-strictly-smaller-and-greater-elements.js", "hypo_code": "var countElements = function(nums) {\n    let res = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let n = nums[i];\n        let isFound = false;\n        for (let j = 0; j < nums.length; j++) {\n            if (i !== j) {\n                if (nums[j] < n && !isFound) isFound = true;\n                if (nums[j] > n && isFound) {\n                    res++;\n                    break;\n                }\n            }\n        }\n    }\n    return res;\n};"}
{"id": "461", "path": "output2\\js\\Easy\\461-keep-multiplying-found-values-by-two.js", "hypo_code": "var findFinalValue = function(nums, original) {\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === original) {\n            original *= 2;\n            i = -1;\n        }\n    }\n    return original;\n};"}
{"id": "462", "path": "output2\\js\\Easy\\462-minimum-sum-of-four-digit-number-after-splitting-digits.js", "hypo_code": "var minimumSum = function(num) {\n    let arr = num.toString().split('');\n    let res = [];\n    for (let i = 0; i < arr.length; i++) {\n        let temp = [...arr];\n        let first = temp.splice(i, 1);\n        for (let j = 0; j < temp.length; j++) {\n            let second = temp.splice(j, 1);\n            let new1 = Number(first.toString() + temp.toString());\n            let new2 = Number(second.toString() + temp.toString());\n            res.push(new1 + new2);\n            temp.splice(j, 0, second);\n        }\n    }\n    return Math.min(...res);\n};"}
{"id": "463", "path": "output2\\js\\Easy\\463-sort-even-and-odd-indices-independently.js", "hypo_code": "var sortEvenOdd = function(nums) {\n    let evens = [];\n    let odds = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (i % 2 === 0) evens.push(nums[i]);\n        else odds.push(nums[i]);\n    }\n    evens.sort((a, b) => a - b);\n    odds.sort((a, b) => b - a);\n    let res = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (i % 2 === 0) res.push(evens.shift());\n        else res.push(odds.shift());\n    }\n    return res;\n};"}
{"id": "464", "path": "output2\\js\\Easy\\464-count-operations-to-obtain-zero.js", "hypo_code": "var countOperations = function(num1, num2) {\n    let res = 0;\n    while (num1 !== 0 && num2 !== 0) {\n        if (num1 >= num2) {\n            num1 -= num2;\n        } else {\n            num2 -= num1;\n        }\n        res++;\n    }\n    return res;\n};"}
{"id": "465", "path": "output2\\js\\Easy\\465-count-equal-and-divisible-pairs-in-an-array.js", "hypo_code": "var countPairs = function(nums, k) {\n    let res = 0;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = nums.length - 1; j > i; j--) {\n            if (nums[i] === nums[j] && (i * j) % k === 0) res++;\n        }\n    }\n    return res;\n};"}
{"id": "466", "path": "output2\\js\\Easy\\466-count-integers-with-even-digit-sum.js", "hypo_code": "var countEven = function(num) {\n    let res = 0;\n    for (let i = 1; i <= num; i++) {\n        let sum = 0;\n        let n = i;\n        while (n > 0) {\n            sum += n % 10;\n            n = parseInt(n / 10);\n        }\n        if (sum % 2 === 0) res++;\n    }\n    return res;\n};"}
{"id": "467", "path": "output2\\js\\Easy\\467-counting-words-with-a-given-prefix.js", "hypo_code": "var prefixCount = function(words, pref) {\n    let res = 0;\n    for (let s of words) {\n        if (s.startsWith(pref)) res++;\n    }\n    return res;\n};"}
{"id": "468", "path": "output2\\js\\Easy\\468-most-frequent-number-following-key-in-an-array.js", "hypo_code": "var mostFrequent = function(nums, key) {\n    let res = {};\n    for (let i = 0; i < nums.length - 1; i++) {\n        if (nums[i] === key) {\n            if (!res[nums[i+1]]) res[nums[i+1]] = 1;\n            else res[nums[i+1]]++;\n        }\n    }\n    return Object.keys(res).reduce((a, b) => res[a] > res[b] ? a : b);\n\n};"}
{"id": "469", "path": "output2\\js\\Easy\\469-cells-in-a-range-on-an-excel-sheet.js", "hypo_code": "var cellsInRange = function(s) {\n    let res = [];\n    let [c1, r1, c2, r2] = [s[0], s[1], s[3], s[4]];\n    for (let i = c1.charCodeAt(0); i <= c2.charCodeAt(0); i++) {\n        for (let j = r1; j <= r2; j++) {\n            res.push(String.fromCharCode(i) + j);\n        }\n    }\n    return res;\n};"}
{"id": "470", "path": "output2\\js\\Easy\\470-find-all-k-distant-indices-in-an-array.js", "hypo_code": "var findKDistantIndices = function(nums, key, k) {\n    let res = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === key) {\n            res.push(i);\n        }\n    }\n    return res.filter((a, b) => Math.abs(a - b) <= k);\n\n};"}
{"id": "471", "path": "output2\\js\\Easy\\471-divide-array-into-equal-pairs.js", "hypo_code": "var divideArray = function(nums) {\n    nums.sort((a, b) => a - b);\n    let i = 0;\n    while (i < nums.length) {\n        if (nums[i] !== nums[i + 1]) {\n            return false;\n        }\n        i += 2;\n    }\n    return true;\n};"}
{"id": "472", "path": "output2\\js\\Easy\\472-count-hills-and-valleys-in-an-array.js", "hypo_code": "var countHillValley = function(nums) {\n    let result = 0;\n    for (let i = 1; i < nums.length - 1; i++) {\n        if ((nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) || (nums[i - 1] > nums[i] && nums[i] < nums[i + 1])) {\n            result++;\n        }\n    }\n    return result;\n};"}
{"id": "473", "path": "output2\\js\\Easy\\473-find-the-difference-of-two-arrays.js", "hypo_code": "var findDifference = function(nums1, nums2) {\n    let result = [[], []];\n    for (let i = 0; i < nums1.length; i++) {\n        if (!nums2.includes(nums1[i])) {\n            result[0].push(nums1[i]);\n        }\n    }\n    for (let i = 0; i < nums2.length; i++) {\n        if (!nums1.includes(nums2[i])) {\n            result[1].push(nums2[i]);\n        }\n    }\n    return result;\n};"}
{"id": "474", "path": "output2\\js\\Easy\\474-minimum-bit-flips-to-convert-number.js", "hypo_code": "var minBitFlips = function(start, goal) {\n    let result = 0;\n    let startArr = start.toString(2).split('');\n    let goalArr = goal.toString(2).split('');\n    let i = 0;\n    while (i < startArr.length) {\n        if (startArr[i] !== goalArr[i]) {\n            if (i + goalArr.length > startArr.length) {\n                return -1;\n            }\n            result++;\n            for (let j = 0; j < goalArr.length; j++) {\n                startArr[i + j] = startArr[i + j] === '0' ? '1' : '0';\n            }\n        }\n        i++;\n    }\n    return result;\n};"}
{"id": "475", "path": "output2\\js\\Easy\\475-minimum-number-of-operations-to-convert-time.js", "hypo_code": "var convertTime = function(current, correct) {\n    let currentArr = current.split(':');\n    let correctArr = correct.split(':');\n    let currentMinutes = parseInt(currentArr[0]) * 60 + parseInt(currentArr[1]);\n    let correctMinutes = parseInt(correctArr[0]) * 60 + parseInt(correctArr[1]);\n    let result = 0;\n    while (currentMinutes !== correctMinutes) {\n        if (currentMinutes < correctMinutes) {\n            if (currentMinutes + 60 <= correctMinutes) {\n                result++;\n                currentMinutes += 60;\n            } else if (currentMinutes + 15 <= correctMinutes) {\n                result++;\n                currentMinutes += 15;\n            } else if (currentMinutes + 5 <= correctMinutes) {\n                result++;\n                currentMinutes += 5;\n            } else {\n                result++;\n                currentMinutes++;\n            }\n        } else {\n            if (currentMinutes - 60 >= correctMinutes) {\n                result++;\n                currentMinutes -= 60;\n            } else if (currentMinutes - 15 >= correctMinutes) {\n                result++;\n                currentMinutes -= 15;\n            } else if (currentMinutes - 5 >= correctMinutes) {\n                result++;\n                currentMinutes -= 5;\n            } else {\n                result++;\n                currentMinutes--;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "476", "path": "output2\\js\\Easy\\476-largest-number-after-digit-swaps-by-parity.js", "hypo_code": "var largestInteger = function(num) {\n    let arr = num.toString().split('');\n    for (let i = 0; i < arr.length; i++) {\n        let j = i + 1;\n        let max = arr[i];\n        let maxIndex = i;\n        while (j < arr.length) {\n            if ((arr[j] % 2 === 0 && arr[i] % 2 === 0 && arr[j] > max) || (arr[j] % 2 !== 0 && arr[i] % 2 !== 0 && arr[j] > max)) {\n                max = arr[j];\n                maxIndex = j;\n            }\n            j++;\n        }\n        if (maxIndex !== i) {\n            let temp = arr[i];\n            arr[i] = arr[maxIndex];\n            arr[maxIndex] = temp;\n            break;\n        }\n    }\n    return parseInt(arr.join(''));\n};"}
{"id": "477", "path": "output2\\js\\Easy\\477-add-two-integers.js", "hypo_code": "var sum = function(num1, num2) {\n    return num1 + num2;\n};"}
{"id": "478", "path": "output2\\js\\Easy\\478-root-equals-sum-of-children.js", "hypo_code": "var checkTree = function(root) {\n    if (!root) {\n        return false;\n    }\n    if (!root.left && !root.right) {\n        return true;\n    }\n    let result = false;\n    if (root.left && root.right) {\n        result = root.val === root.left.val + root.right.val;\n    }\n    else if (root.left && !root.right) {\n        result = root.val === root.left.val;\n    }\n    else if (!root.left && root.right) {\n        result = root.val === root.right.val;\n    }\n    return result && checkTree(root.left) && checkTree(root.right);\n\n};"}
{"id": "479", "path": "output2\\js\\Easy\\479-find-closest-number-to-zero.js", "hypo_code": "var findClosestNumber = function(nums) {\n    let result = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        if (Math.abs(nums[i]) < Math.abs(result)) {\n            result = nums[i];\n        } else if (Math.abs(nums[i]) === Math.abs(result) && nums[i] > result) {\n            result = nums[i];\n        }\n    }\n    return result;\n};"}
{"id": "480", "path": "output2\\js\\Easy\\480-calculate-digit-sum-of-a-string.js", "hypo_code": "var digitSum = function(s, k) {\n    let result = '';\n    while (s.length > k) {\n        let i = 0;\n        let temp = 0;\n        while (i < s.length) {\n            temp += parseInt(s[i]);\n            i++;\n            if (i % k === 0) {\n                result += temp.toString();\n                temp = 0;\n            }\n        }\n        s = result;\n        result = '';\n    }\n    return s;\n};"}
{"id": "481", "path": "output2\\js\\Easy\\481-intersection-of-multiple-arrays.js", "hypo_code": "var intersection = function(nums) {\n    let result = [];\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        let arr = nums[i];\n        let tempMap = new Map();\n        for (let j = 0; j < arr.length; j++) {\n            let item = arr[j];\n            if (i === 0) {\n                map.set(item, 1);\n            } else {\n                if (map.has(item) && !tempMap.has(item)) {\n                    let count = map.get(item);\n                    tempMap.set(item, 1);\n                    map.set(item, count + 1);\n                }\n            }\n        }\n    }\n    map.forEach((value, key) => {\n        if (value === nums.length) {\n            result.push(key);\n        }\n    });\n    return result;\n};"}
{"id": "482", "path": "output2\\js\\Easy\\482-count-prefixes-of-a-given-string.js", "hypo_code": "var countPrefixes = function(words, s) {\n    let result = 0;\n    for (let i = 0; i < words.length; i++) {\n        let word = words[i];\n        if (word.length <= s.length) {\n            for (let j = 0; j < word.length; j++) {\n                if (word[j] !== s[j]) {\n                    break;\n                }\n                if (j === word.length - 1) {\n                    result++;\n                }\n            }\n        }\n    }\n    return result;\n};"}
{"id": "483", "path": "output2\\js\\Easy\\483-remove-digit-from-number-to-maximize-result.js", "hypo_code": "var removeDigit = function(number, digit) {\n    for (let i = 0; i < number.length; i++) {\n        if (number[i] === digit) {\n            return number.substring(0, i) + number.substring(i + 1);\n        }\n    }\n    return number;\n};"}
{"id": "484", "path": "output2\\js\\Easy\\484-largest-3-same-digit-number-in-string.js", "hypo_code": "var largestGoodInteger = function(num) {\n    let result = '';\n    for (let i = 0; i < num.length; i++) {\n        let item = num[i];\n        let temp = item;\n        for (let j = i + 1; j < num.length; j++) {\n            let nextItem = num[j];\n            if (nextItem === item) {\n                temp += nextItem;\n                if (temp.length === 3) {\n                    if (temp > result) {\n                        result = temp;\n                    }\n                    break;\n                }\n            } else {\n                temp = '';\n                break;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "485", "path": "output2\\js\\Easy\\485-find-the-k-beauty-of-a-number.js", "hypo_code": "var divisorSubstrings = function(num, k) {\n    let result = 0;\n    let str = num.toString();\n    for (let i = 0; i < str.length; i++) {\n        let item = str[i];\n        let temp = item;\n        for (let j = i + 1; j < str.length; j++) {\n            let nextItem = str[j];\n            if (nextItem === item) {\n                temp += nextItem;\n                if (temp.length === k) {\n                    if (num % parseInt(temp) === 0) {\n                        result++;\n                    }\n                    break;\n                }\n            } else {\n                temp = '';\n                break;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "486", "path": "output2\\js\\Easy\\486-find-resultant-array-after-removing-anagrams.js", "hypo_code": "var removeAnagrams = function(words) {\n    let result = [];\n    for (let i = 0; i < words.length; i++) {\n        let word = words[i];\n        let temp = word.split('');\n        temp = temp.sort();\n        let tempWord = temp.join('');\n        let isAnagram = false;\n        for (let j = 0; j < result.length; j++) {\n            if (tempWord === result[j]) {\n                isAnagram = true;\n                break;\n            }\n        }\n        if (!isAnagram) {\n            result.push(tempWord);\n        }\n    }\n    return result;\n};"}
{"id": "487", "path": "output2\\js\\Easy\\487-percentage-of-letter-in-string.js", "hypo_code": "var percentageLetter = function(s, letter) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let item = s[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    if (map.has(letter)) {\n        let count = map.get(letter);\n        result = (count / s.length * 100).toFixed(0);\n    }\n    return parseInt(result);\n};"}
{"id": "488", "path": "output2\\js\\Easy\\488-check-if-number-has-equal-digit-count-and-digit-value.js", "hypo_code": "var digitCount = function(num) {\n    let map = new Map();\n    for (let i = 0; i < num.length; i++) {\n        let item = num[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    for (let i = 0; i < num.length; i++) {\n        let item = num[i];\n        if (!map.has(item)) {\n            return false;\n        }\n        let count = map.get(item);\n        if (count !== parseInt(item)) {\n            return false;\n        }\n    }\n    return true;\n};"}
{"id": "489", "path": "output2\\js\\Easy\\489-rearrange-characters-to-make-target-string.js", "hypo_code": "var rearrangeCharacters = function(s, target) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let item = s[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    for (let i = 0; i < target.length; i++) {\n        let item = target[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            if (count > 0) {\n                map.set(item, count - 1);\n            } else {\n                return 0;\n            }\n        } else {\n            return 0;\n        }\n    }\n    for (let i = 0; i < target.length; i++) {\n        let item = target[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            if (count > 0) {\n                result++;\n                map.set(item, count - 1);\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n    }\n    return result;\n};"}
{"id": "490", "path": "output2\\js\\Easy\\490-min-max-game.js", "hypo_code": "var minMaxGame = function(nums) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        let item = nums[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    while (nums.length > 1) {\n        let newNums = [];\n        for (let i = 0; i < nums.length; i += 2) {\n            let min = Math.min(nums[i], nums[i + 1]);\n            let max = Math.max(nums[i], nums[i + 1]);\n            newNums.push(min);\n            newNums.push(max);\n        }\n        nums = newNums;\n    }\n    result = nums[0];\n    return result;\n};"}
{"id": "491", "path": "output2\\js\\Easy\\491-strong-password-checker-ii.js", "hypo_code": "var strongPasswordCheckerII = function(password) {\n    let result = false;\n    let hasLowercase = false;\n    let hasUppercase = false;\n    let hasDigit = false;\n    let hasSpecial = false;\n    let hasSame = false;\n    let map = new Map();\n    for (let i = 0; i < password.length; i++) {\n        let item = password[i];\n        if (item >= 'a' && item <= 'z') {\n            hasLowercase = true;\n        } else if (item >= 'A' && item <= 'Z') {\n            hasUppercase = true;\n        } else if (item >= '0' && item <= '9') {\n            hasDigit = true;\n        } else if ('!@#$%^&*()-+'.indexOf(item) > -1) {\n            hasSpecial = true;\n        }\n        if (map.has(item)) {\n            hasSame = true;\n        } else {\n            map.set(item, 1);\n        }\n    }\n    if (password.length >= 8 && hasLowercase && hasUppercase && hasDigit && hasSpecial && !hasSame) {\n        result = true;\n    }\n    return result;\n};"}
{"id": "492", "path": "output2\\js\\Easy\\492-calculate-amount-paid-in-taxes.js", "hypo_code": "var calculateTax = function(brackets, income) {\n    let result = 0;\n    for (let i = 0; i < brackets.length; i++) {\n        let item = brackets[i];\n        let upper = item[0];\n        let percent = item[1];\n        if (income > upper) {\n            result += (upper * percent / 100);\n            income -= upper;\n        } else {\n            result += (income * percent / 100);\n            return result;\n        }\n    }\n    return result;\n};"}
{"id": "493", "path": "output2\\js\\Easy\\493-greatest-english-letter-in-upper-and-lower-case.js", "hypo_code": "var greatestLetter = function(s) {\n    let result = '';\n    let map = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let item = s[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    for (let [key, value] of map) {\n        if (value > 1) {\n            if (key > result) {\n                result = key;\n            }\n        }\n    }\n    return result.toUpperCase();\n};"}
{"id": "494", "path": "output2\\js\\Easy\\494-count-asterisks.js", "hypo_code": "var countAsterisks = function(s) {\n    let result = 0;\n    for (let i = 0; i < s.length; i++) {\n        let item = s[i];\n        if (item === '|') {\n            i++;\n            let nextItem = s[i];\n            while (nextItem === '*') {\n                result++;\n                i++;\n                nextItem = s[i];\n            }\n        }\n    }\n    return result;\n};"}
{"id": "495", "path": "output2\\js\\Easy\\495-check-if-matrix-is-x-matrix.js", "hypo_code": "var checkXMatrix = function(grid) {\n    let n = grid.length;\n    for (let i = 0; i < n; i++) {\n        let item = grid[i];\n        for (let j = 0; j < n; j++) {\n            let value = item[j];\n            if (i === j) {\n                if (value === 0) {\n                    return false;\n                }\n            } else {\n                if (value !== 0) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n};"}
{"id": "496", "path": "output2\\js\\Easy\\496-decode-the-message.js", "hypo_code": "var decodeMessage = function(key, message) {\n    let result = '';\n    let map = new Map();\n    for (let i = 0; i < key.length; i++) {\n        let item = key[i];\n        if (!map.has(item)) {\n            map.set(item, i);\n        }\n    }\n    for (let i = 0; i < message.length; i++) {\n        let item = message[i];\n        if (item === ' ') {\n            result += ' ';\n        } else {\n            result += key[map.get(item)];\n        }\n    }\n    return result;\n};"}
{"id": "497", "path": "output2\\js\\Easy\\497-evaluate-boolean-binary-tree.js", "hypo_code": "var evaluateTree = function(root) {\n    let result = false;\n    if (!root) {\n        return result;\n    }\n    let value = root.val;\n    if (value === 0 || value === 1) {\n        result = value === 1;\n        return result;\n    }\n    let left = evaluateTree(root.left);\n    let right = evaluateTree(root.right);\n    if (value === 2) {\n        result = left || right;\n    } else {\n        result = left && right;\n    }\n    return result;\n};"}
{"id": "498", "path": "output2\\js\\Easy\\498-minimum-amount-of-time-to-fill-cups.js", "hypo_code": "var fillCups = function(amount) {\n    let result = 0;\n    let min = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < amount.length; i++) {\n        let item = amount[i];\n        min = Math.min(min, item);\n    }\n    for (let i = 0; i < amount.length; i++) {\n        let item = amount[i];\n        result += item - min;\n    }\n    return result;\n};"}
{"id": "499", "path": "output2\\js\\Easy\\499-maximum-number-of-pairs-in-array.js", "hypo_code": "var numberOfPairs = function(nums) {\n    let result = [0, 0];\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        let item = nums[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    for (const [key, value] of map.entries()) {\n        if (value >= 2) {\n            result[0] += value * (value - 1) / 2;\n        }\n    }\n    result[1] = nums.length - map.size * 2 + result[0];\n    return result;\n};"}
{"id": "500", "path": "output2\\js\\Easy\\500-best-poker-hand.js", "hypo_code": "var bestHand = function(ranks, suits) {\n    let result = '';\n    let map = new Map();\n    for (let i = 0; i < suits.length; i++) {\n        let item = suits[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    let maxCount = 0;\n    let maxSuit = '';\n    for (let [key, value] of map) {\n        if (value > maxCount) {\n            maxCount = value;\n            maxSuit = key;\n        }\n    }\n    if (maxCount === 5) {\n        return 'Flush';\n    }\n    let maxRank = 0;\n    let maxRankCount = 0;\n    for (let i = 0; i < ranks.length; i++) {\n        let rank = ranks[i];\n        if (rank > maxRank) {\n            maxRank = rank;\n            maxRankCount = 1;\n        } else if (rank === maxRank) {\n            maxRankCount++;\n        }\n    }\n    if (maxRankCount === 3) {\n        return 'Three of a Kind';\n    }\n    if (maxRankCount === 2) {\n        return 'Pair';\n    }\n    return 'High Card';\n};"}
{"id": "501", "path": "output2\\js\\Easy\\501-first-letter-to-appear-twice.js", "hypo_code": "var repeatedCharacter = function(s) {\n    let result = '';\n    let map = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let item = s[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    for (let [key, value] of map) {\n        if (value > 1) {\n            if (result === '') {\n                result = key;\n            } else {\n                if (s.indexOf(key) < s.indexOf(result)) {\n                    result = key;\n                }\n            }\n        }\n    }\n    return result;\n};"}
{"id": "503", "path": "output2\\js\\Easy\\503-make-array-zero-by-subtracting-equal-amounts.js", "hypo_code": "var minimumOperations = function(nums) {\n    let min = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < nums.length; i++) {\n        let item = nums[i];\n        if (item > 0 && item < min) {\n            min = item;\n        }\n    }\n    let result = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let item = nums[i];\n        if (item > 0) {\n            result += Math.floor(item / min);\n            if (item % min > 0) {\n                result++;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "504", "path": "output2\\js\\Easy\\504-merge-similar-items.js", "hypo_code": "var mergeSimilarItems = function(items1, items2) {\n    let result = [];\n    let map = new Map();\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < items1.length; i++) {\n        let item = items1[i];\n        let value = item[0];\n        let weight = item[1];\n        if (map1.has(value)) {\n            let count = map1.get(value);\n            map1.set(value, count + weight);\n        } else {\n            map1.set(value, weight);\n        }\n    }\n    for (let i = 0; i < items2.length; i++) {\n        let item = items2[i];\n        let value = item[0];\n        let weight = item[1];\n        if (map2.has(value)) {\n            let count = map2.get(value);\n            map2.set(value, count + weight);\n        } else {\n            map2.set(value, weight);\n        }\n    }\n    map1.forEach((value, key) => {\n        if (map2.has(key)) {\n            let count = map2.get(key);\n            map.set(key, count + value);\n        } else {\n            map.set(key, value);\n        }\n    });\n    map2.forEach((value, key) => {\n        if (!map.has(key)) {\n            map.set(key, value);\n        }\n    });\n    map.forEach((value, key) => {\n        result.push([key, value]);\n    });\n    result.sort((a, b) => {\n        return a[0] - b[0];\n    });\n    return result;\n};"}
{"id": "505", "path": "output2\\js\\Easy\\505-number-of-arithmetic-triplets.js", "hypo_code": "var arithmeticTriplets = function(nums, diff) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        let item = nums[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    for (let i = 0; i < nums.length; i++) {\n        let item = nums[i];\n        let first = item - diff;\n        let second = item + diff;\n        if (map.has(first) && map.has(second)) {\n            if (diff === 0) {\n                let count = map.get(item);\n                if (count >= 3) {\n                    result += count * (count - 1) * (count - 2) / 6;\n                }\n            } else {\n                result++;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "506", "path": "output2\\js\\Easy\\506-largest-local-values-in-a-matrix.js", "hypo_code": "var largestLocal = function(grid) {\n    let n = grid.length;\n    let result = [];\n    for (let i = 1; i < n - 1; i++) {\n        let item = [];\n        for (let j = 1; j < n - 1; j++) {\n            let value = grid[i][j];\n            let max = value;\n            if (grid[i - 1][j - 1] > max) {\n                max = grid[i - 1][j - 1];\n            }\n            if (grid[i - 1][j] > max) {\n                max = grid[i - 1][j];\n            }\n            if (grid[i - 1][j + 1] > max) {\n                max = grid[i - 1][j + 1];\n            }\n            if (grid[i][j - 1] > max) {\n                max = grid[i][j - 1];\n            }\n            if (grid[i][j + 1] > max) {\n                max = grid[i][j + 1];\n            }\n            if (grid[i + 1][j - 1] > max) {\n                max = grid[i + 1][j - 1];\n            }\n            if (grid[i + 1][j] > max) {\n                max = grid[i + 1][j];\n            }\n            if (grid[i + 1][j + 1] > max) {\n                max = grid[i + 1][j + 1];\n            }\n            item.push(max);\n        }\n        result.push(item);\n    }\n    return result;\n};"}
{"id": "507", "path": "output2\\js\\Easy\\507-minimum-recolors-to-get-k-consecutive-black-blocks.js", "hypo_code": "var minimumRecolors = function(blocks, k) {\n    let result = 0;\n    for (let i = 0; i < blocks.length; i++) {\n        let temp = 0;\n        let j = i;\n        while (j < blocks.length && blocks[j] === 'B') {\n            temp++;\n            j++;\n        }\n        if (temp === k) {\n            return result;\n        }\n        if (temp > k) {\n            result += temp - k;\n        }\n        i = j;\n    }\n    return -1;\n};"}
{"id": "508", "path": "output2\\js\\Easy\\508-minimum-hours-of-training-to-win-a-competition.js", "hypo_code": "var minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\n    let result = 0;\n    let map = new Map();\n    let n = energy.length;\n    for (let i = 0; i < n; i++) {\n        let item = [energy[i], experience[i]];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    let energyLeft = initialEnergy;\n    let experienceLeft = initialExperience;\n    while (energyLeft > 0 && experienceLeft > 0) {\n        let energyNeeded = Math.min(energyLeft, experienceLeft);\n        result += energyNeeded;\n        energyLeft -= energyNeeded;\n        experienceLeft -= energyNeeded;\n        let item = [energyNeeded, experienceNeeded];\n        if (map.has(item)) {\n            let count = map.get(item);\n            if (count > 0) {\n                map.set(item, count - 1);\n            } else {\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n    }\n    if (experienceLeft > 0) {\n        return -1;\n    }\n    return result;\n};"}
{"id": "509", "path": "output2\\js\\Easy\\509-longest-subsequence-with-limited-sum.js", "hypo_code": "var answerQueries = function(nums, queries) {\n    let result = [];\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        nums[i] = sum;\n    }\n    for (let i = 0; i < queries.length; i++) {\n        let query = queries[i];\n        let index = binarySearch(nums, query);\n        result.push(index);\n    }\n    return result;\n};\nvar binarySearch = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    let result = -1;\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (nums[mid] <= target) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result + 1;\n};"}
{"id": "510", "path": "output2\\js\\Easy\\510-find-subarrays-with-equal-sum.js", "hypo_code": "var findSubarrays = function(nums) {\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        let item = nums[i];\n        if (map.has(item)) {\n            let count = map.get(item);\n            map.set(item, count + 1);\n        } else {\n            map.set(item, 1);\n        }\n    }\n    let result = false;\n    for (let i = 0; i < nums.length; i++) {\n        let item = nums[i];\n        let tempMap = new Map();\n        for (let j = i + 1; j < nums.length; j++) {\n            let nextItem = nums[j];\n            let count = map.get(item);\n            if (count > 1) {\n                map.set(item, count - 1);\n            } else {\n                map.delete(item);\n            }\n            if (tempMap.has(nextItem)) {\n                let count = tempMap.get(nextItem);\n                tempMap.set(nextItem, count + 1);\n            } else {\n                tempMap.set(nextItem, 1);\n            }\n            let tempSum = 0;\n            let tempMap2 = new Map();\n            for (let k = j + 1; k < nums.length; k++) {\n                let nextItem2 = nums[k];\n                if (tempMap2.has(nextItem2)) {\n                    let count = tempMap2.get(nextItem2);\n                    tempMap2.set(nextItem2, count + 1);\n                } else {\n                    tempMap2.set(nextItem2, 1);\n                }\n                tempSum += nextItem2;\n                if (tempSum === item) {\n                    let isEqual = true;\n                    tempMap2.forEach((value, key) => {\n                        if (tempMap.has(key)) {\n                            let count = tempMap.get(key);\n                            if (count !== value) {\n                                isEqual = false;\n                            }\n                        } else {\n                            isEqual = false;\n                        }\n                    });\n                    if (isEqual) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n            if (result) {\n                break;\n            }\n        }\n        if (result) {\n            break;\n        }\n    }\n    return result;\n};"}
{"id": "511", "path": "output2\\js\\Easy\\511-check-distances-between-same-letters.js", "hypo_code": "var checkDistances = function(s, distance) {\n    for (let i = 0; i < s.length; i++) {\n        const c = s.charAt(i);\n        const idx = c.charCodeAt(0) - 97;\n        if (distance[idx] === 0) continue;\n        for (let j = i + 1; j < s.length; j++) {\n            if (s.charAt(j) === c) {\n                if (j - i !== distance[idx]) return false;\n                break;\n            }\n        }\n    }\n    return true;\n};"}
{"id": "512", "path": "output2\\js\\Easy\\512-most-frequent-even-element.js", "hypo_code": "var mostFrequentEven = function(nums) {\n    const count = new Array(100001).fill(0);\n    for (const n of nums) {\n        if (n % 2 === 0) count[n]++;\n    }\n    let max = 0;\n    for (let i = 0; i < count.length; i++) {\n        if (count[i] > count[max]) max = i;\n    }\n    return count[max] > 0 ? max : -1;\n};"}
{"id": "513", "path": "output2\\js\\Easy\\513-count-days-spent-together.js", "hypo_code": "var countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\n    const days = [31,28,31,30,31,30,31,31,30,31,30,31];\n    const getDays = (date) => {\n        const m = parseInt(date.substring(0, 2)) - 1;\n        const d = parseInt(date.substring(3));\n        let sum = 0;\n        for (let i = 0; i < m; i++) {\n            sum += days[i];\n        }\n        return sum + d;\n    };\n    const a1 = getDays(arriveAlice);\n    const a2 = getDays(leaveAlice);\n    const b1 = getDays(arriveBob);\n    const b2 = getDays(leaveBob);\n    const min = Math.max(a1, b1);\n    const max = Math.min(a2, b2);\n    return max >= min ? max - min + 1 : 0;\n};"}
{"id": "514", "path": "output2\\js\\Easy\\514-smallest-even-multiple.js", "hypo_code": "var smallestEvenMultiple = function(n) {\n    let x = 1;\n    while (x % n !== 0) {\n        x++;\n    }\n    return x;\n};"}
{"id": "515", "path": "output2\\js\\Easy\\515-sort-the-people.js", "hypo_code": "var sortPeople = function(names, heights) {\n    const arr = [];\n    for (let i = 0; i < names.length; i++) {\n        arr.push({name: names[i], height: heights[i]});\n    }\n    arr.sort((a, b) => b.height - a.height);\n    const res = [];\n    for (const p of arr) {\n        res.push(p.name);\n    }\n    return res;\n};"}
{"id": "516", "path": "output2\\js\\Easy\\516-remove-letter-to-equalize-frequency.js", "hypo_code": "var equalFrequency = function(word) {\n    const count = new Array(26).fill(0);\n    for (const c of word) {\n        count[c.charCodeAt(0) - 97]++;\n    }\n    count.sort((a, b) => b - a);\n    let i = 0;\n    while (i < count.length && count[i] === count[0]) {\n        i++;\n    }\n    if (i === count.length) return true;\n    if (i === count.length - 1 && count[i] - count[i - 1] === 1) return true;\n    if (i === 1 && count[0] - count[1] === 1) return true;\n    return false;\n};"}
{"id": "517", "path": "output2\\js\\Easy\\517-number-of-common-factors.js", "hypo_code": "var commonFactors = function(a, b) {\n    let x = 1;\n    let count = 0;\n    while (x <= a && x <= b) {\n        if (a % x === 0 && b % x === 0) count++;\n        x++;\n    }\n    return count;\n};"}
{"id": "518", "path": "output2\\js\\Easy\\518-the-employee-that-worked-on-the-longest-task.js", "hypo_code": "var hardestWorker = function(n, logs) {\n    const count = new Array(n).fill(0);\n    for (const log of logs) {\n        count[log[0]] += log[1];\n    }\n    let max = 0;\n    for (let i = 0; i < count.length; i++) {\n        if (count[i] > count[max]) max = i;\n    }\n    return max;\n};"}
{"id": "519", "path": "output2\\js\\Easy\\519-number-of-valid-clock-times.js", "hypo_code": "var countTime = function(time) {\n    let count = 0;\n    for (let h = 0; h < 24; h++) {\n        for (let m = 0; m < 60; m++) {\n            if (isValid(h, m, time)) count++;\n        }\n    }\n    return count;\n};\nconst isValid = (h, m, time) => {\n    const hh = time.charAt(0) === '?' ? h : parseInt(time.substring(0, 2));\n    const mm = time.charAt(3) === '?' ? m : parseInt(time.substring(3));\n    return hh === h && mm === m;\n};"}
{"id": "520", "path": "output2\\js\\Easy\\520-largest-positive-integer-that-exists-with-its-negative.js", "hypo_code": "var findMaxK = function(nums) {\n    const count = new Array(2001).fill(0);\n    for (const n of nums) {\n        if (n < 0) count[-n]++;\n        else count[n]++;\n    }\n    for (let i = 1000; i >= 1; i--) {\n        if (count[i] > 0 && count[i] === count[-i]) return i;\n    }\n    return -1;\n};"}
{"id": "521", "path": "output2\\js\\Easy\\521-determine-if-two-events-have-conflict.js", "hypo_code": "var haveConflict = function(event1, event2) {\n    const getMinutes = (time) => {\n        const h = parseInt(time.substring(0, 2));\n        const m = parseInt(time.substring(3));\n        return h * 60 + m;\n    };\n    const e1 = [getMinutes(event1[0]), getMinutes(event1[1])];\n    const e2 = [getMinutes(event2[0]), getMinutes(event2[1])];\n    const min = Math.max(e1[0], e2[0]);\n    const max = Math.min(e1[1], e2[1]);\n    return max >= min;\n};"}
{"id": "522", "path": "output2\\js\\Easy\\522-odd-string-difference.js", "hypo_code": "var oddString = function(words) {\n    const diff = [];\n    for (const w of words) {\n        const arr = [];\n        for (let i = 0; i < w.length - 1; i++) {\n            arr.push(w.charCodeAt(i + 1) - w.charCodeAt(i));\n        }\n        diff.push(arr);\n    }\n    const count = new Array(26).fill(0);\n    for (let i = 0; i < diff.length; i++) {\n        for (const d of diff[i]) {\n            count[d + 10]++;\n        }\n    }\n    let i = 0;\n    while (i < count.length && count[i] % 2 === 0) {\n        i++;\n    }\n    for (let j = 0; j < diff.length; j++) {\n        let sum = 0;\n        for (const d of diff[j]) {\n            sum += d + 10;\n        }\n        if (sum === i - 10) return words[j];\n    }\n    return \"\";\n};"}
{"id": "523", "path": "output2\\js\\Easy\\523-average-value-of-even-numbers-that-are-divisible-by-three.js", "hypo_code": "var averageValue = function(nums) {\n    let sum = 0;\n    let count = 0;\n    for (const n of nums) {\n        if (n % 2 === 0 && n % 3 === 0) {\n            sum += n;\n            count++;\n        }\n    }\n    return count === 0 ? 0 : Math.floor(sum / count);\n\n};"}
{"id": "524", "path": "output2\\js\\Easy\\524-apply-operations-to-an-array.js", "hypo_code": "var applyOperations = function(nums) {\n    let i = 0;\n    while (i < nums.length - 1) {\n        if (nums[i] === nums[i + 1]) {\n            nums[i] *= 2;\n            nums.splice(i + 1, 1);\n        } else i++;\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === 0) {\n            nums.splice(i, 1);\n            nums.push(0);\n            i--;\n        }\n    }\n    return nums;\n};"}
{"id": "525", "path": "output2\\js\\Easy\\525-number-of-distinct-averages.js", "hypo_code": "var distinctAverages = function(nums) {\n    const set = new Set();\n    const dfs = (arr) => {\n        if (arr.length === 2) {\n            set.add((arr[0] + arr[1]) / 2);\n            return;\n        }\n        const min = Math.min(...arr);\n        const max = Math.max(...arr);\n        const minIndex = arr.indexOf(min);\n        const maxIndex = arr.indexOf(max);\n        arr.splice(minIndex, 1);\n        arr.splice(maxIndex, 1);\n        dfs(arr);\n        arr.push(min);\n        dfs(arr);\n        arr.push(max);\n    };\n    dfs(nums);\n    return set.size;\n};"}
{"id": "526", "path": "output2\\js\\Easy\\526-convert-the-temperature.js", "hypo_code": "var convertTemperature = function(celsius) {\n    return [celsius + 273.15, celsius * 1.8 + 32];\n\n};"}
{"id": "527", "path": "output2\\js\\Easy\\527-number-of-unequal-triplets-in-array.js", "hypo_code": "var unequalTriplets = function(nums) {\n    let count = 0;\n    for (let i = 0; i < nums.length - 2; i++) {\n        const set = new Set();\n        for (let j = i + 1; j < nums.length; j++) {\n            if (set.has(nums[j])) continue;\n            for (let k = j + 1; k < nums.length; k++) {\n                if (nums[i] !== nums[j] && nums[i] !== nums[k] && nums[j] !== nums[k]) count++;\n            }\n            set.add(nums[j]);\n        }\n    }\n    return count;\n};"}
{"id": "528", "path": "output2\\js\\Easy\\528-minimum-cuts-to-divide-a-circle.js", "hypo_code": "var numberOfCuts = function(n) {\n    return n === 1 ? 0 : n;\n};"}
{"id": "529", "path": "output2\\js\\Easy\\529-find-the-pivot-integer.js", "hypo_code": "var pivotInteger = function(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += i;\n    }\n    if (sum % 2 !== 0) return -1;\n    let half = sum / 2;\n    sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += i;\n        if (sum === half) return i;\n    }\n    return -1;\n};"}
{"id": "530", "path": "output2\\js\\Easy\\530-circular-sentence.js", "hypo_code": "var isCircularSentence = function(sentence) {\n    let words = sentence.split(\" \");\n    for(let i = 0; i < words.length - 1; i++){\n        if(words[i][words[i].length - 1] != words[i + 1][0]){\n            return false;\n        }\n    }\n    if(words[words.length - 1][words[words.length - 1].length - 1] != words[0][0]){\n        return false;\n    }\n    return true;\n    \n};"}
{"id": "531", "path": "output2\\js\\Easy\\531-maximum-value-of-a-string-in-an-array.js", "hypo_code": "var maximumValue = function(strs) {\n    let max = 0;\n    for(let i = 0; i < strs.length; i++){\n        let val = 0;\n        for(let j = 0; j < strs[i].length; j++){\n            if(strs[i].charCodeAt(j) >= 48 && strs[i].charCodeAt(j) <= 57){\n                val *= 10;\n                val += strs[i].charCodeAt(j) - 48;\n            }else{\n                val = strs[i].length;\n                break;\n            }\n        }\n        if(val > max){\n            max = val;\n        }\n    }\n    return max;\n    \n};"}
{"id": "532", "path": "output2\\js\\Easy\\532-delete-greatest-value-in-each-row.js", "hypo_code": "var deleteGreatestValue = function(grid) {\n    let sum = 0;\n    while(grid.length > 0){\n        let max = 0;\n        let index = 0;\n        for(let i = 0; i < grid.length; i++){\n            if(grid[i][0] > max){\n                max = grid[i][0];\n                index = i;\n            }\n        }\n        sum += max;\n        grid.splice(index, 1);\n        for(let i = 0; i < grid.length; i++){\n            grid[i].splice(0, 1);\n        }\n    }\n    return sum;\n    \n};"}
{"id": "533", "path": "output2\\js\\Easy\\533-count-pairs-of-similar-strings.js", "hypo_code": "var similarPairs = function(words) {\n    let count = 0;\n    for(let i = 0; i < words.length; i++){\n        for(let j = i + 1; j < words.length; j++){\n            if(isSimilar(words[i], words[j])){\n                count++;\n            }\n        }\n    }\n    return count;\n    \n    \n};"}
{"id": "534", "path": "output2\\js\\Easy\\534-maximum-enemy-forts-that-can-be-captured.js", "hypo_code": "var captureForts = function(forts) {\n    let max = 0;\n    let count = 0;\n    let start = 0;\n    let end = 0;\n    let i = 0;\n    while(i < forts.length){\n        if(forts[i] == 1){\n            start = i;\n            break;\n        }\n        i++;\n    }\n    while(i < forts.length){\n        if(forts[i] == 1){\n            end = i;\n            max = Math.max(max, count);\n            count = 0;\n        }else if(forts[i] == 0){\n            count++;\n        }\n        i++;\n    }\n    if(forts[0] == 1){\n        max = Math.max(max, count);\n    }\n    return max;\n    \n};"}
{"id": "535", "path": "output2\\js\\Easy\\535-shortest-distance-to-target-string-in-a-circular-array.js", "hypo_code": "var closetTarget = function(words, target, startIndex) {\n    let min = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < words.length; i++){\n        if(words[i] == target){\n            min = Math.min(min, Math.min(Math.abs(startIndex - i), words.length - Math.abs(startIndex - i)));\n        }\n    }\n    return min == Number.MAX_SAFE_INTEGER ? -1 : min;\n    \n    \n};"}
{"id": "536", "path": "output2\\js\\Easy\\536-count-the-digits-that-divide-a-number.js", "hypo_code": "var countDigits = function(num) {\n    let count = 0;\n    let str = num.toString();\n    for(let i = 0; i < str.length; i++){\n        let digit = parseInt(str[i]);\n        if(digit != 0 && num % digit == 0){\n            count++;\n        }\n    }\n    return count;\n    \n};"}
{"id": "537", "path": "output2\\js\\Easy\\537-categorize-box-according-to-criteria.js", "hypo_code": "var categorizeBox = function(length, width, height, mass) {\n    let volume = length * width * height;\n    if(volume >= 1000000000 || length >= 10000 || width >= 10000 || height >= 10000){\n        if(mass >= 100){\n            return \"Both\";\n        }else{\n            return \"Bulky\";\n        }\n    }else if(mass >= 100){\n        return \"Heavy\";\n    }else{\n        return \"Neither\";\n    }\n    \n};"}
{"id": "538", "path": "output2\\js\\Easy\\538-maximum-count-of-positive-integer-and-negative-integer.js", "hypo_code": "var maximumCount = function(nums) {\n    let pos = 0;\n    let neg = 0;\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i] > 0){\n            pos++;\n        }else if(nums[i] < 0){\n            neg++;\n        }\n    }\n    return Math.max(pos, neg);\n    \n};"}
{"id": "539", "path": "output2\\js\\Easy\\539-difference-between-element-sum-and-digit-sum-of-an-array.js", "hypo_code": "var differenceOfSum = function(nums) {\n    let elementSum = 0;\n    let digitSum = 0;\n    for(let i = 0; i < nums.length; i++){\n        elementSum += nums[i];\n        digitSum += getDigitSum(nums[i]);\n    }\n    return Math.abs(elementSum - digitSum);\n    \n    \n};"}
{"id": "540", "path": "output2\\js\\Easy\\540-minimum-common-value.js", "hypo_code": "var getCommon = function(nums1, nums2) {\n    let i = 0;\n    let j = 0;\n    while(i < nums1.length && j < nums2.length){\n        if(nums1[i] == nums2[j]){\n            return nums1[i];\n        }else if(nums1[i] < nums2[j]){\n            i++;\n        }else{\n            j++;\n        }\n    }\n    return -1;\n    \n    \n};"}
{"id": "541", "path": "output2\\js\\Easy\\541-alternating-digit-sum.js", "hypo_code": "var alternateDigitSum = function(n) {\n    let sum = 0;\n    let isPositive = true;\n    while(n > 0){\n        let digit = n % 10;\n        if(isPositive){\n            sum += digit;\n        }else{\n            sum -= digit;\n        }\n        isPositive = !isPositive;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n    \n};"}
{"id": "542", "path": "output2\\js\\Easy\\542-count-distinct-numbers-on-board.js", "hypo_code": "var distinctIntegers = function(n) {\n    const set = new Set();\n    for (let i = 1; i <= n; i++) {\n        set.add(i);\n    }\n    for (let i = 1; i <= Math.pow(10, 9); i++) {\n        const newSet = new Set();\n        for (let num of set) {\n            for (let j = 1; j <= n; j++) {\n                if ((num % j) === 1) newSet.add(j);\n            }\n        }\n        for (let num of newSet) {\n            set.add(num);\n        }\n    }\n    return set.size;\n};"}
{"id": "543", "path": "output2\\js\\Easy\\543-separate-the-digits-in-an-array.js", "hypo_code": "var separateDigits = function(nums) {\n    let answer = [];\n    for (const n of nums) {\n        let x = n;\n        const digits = [];\n        while (x > 0) {\n            digits.push(x % 10);\n            x = Math.floor(x / 10);\n        }\n        answer = [...answer, ...digits.reverse()];\n    }\n    return answer;\n};"}
{"id": "544", "path": "output2\\js\\Easy\\544-take-gifts-from-the-richest-pile.js", "hypo_code": "var pickGifts = function(gifts, k) {\n    const count = new Array(1000000001).fill(0);\n    for (const g of gifts) {\n        count[g]++;\n    }\n    let max = 0;\n    for (let i = 0; i < count.length; i++) {\n        if (count[i] > 0) max = i;\n    }\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += max;\n        count[max]--;\n        if (count[max] === 0) {\n            max--;\n            while (max > 0 && count[max] === 0) max--;\n        }\n    }\n    return sum;\n};"}
{"id": "545", "path": "output2\\js\\Easy\\545-find-the-array-concatenation-value.js", "hypo_code": "var findTheArrayConcVal = function(nums) {\n    const dfs = (arr) => {\n        if (arr.length === 1) return arr[0];\n        let left = arr[0];\n        let right = arr[arr.length - 1];\n        const leftStr = left.toString();\n        const rightStr = right.toString();\n        if (leftStr.length > 5) left = parseInt(leftStr.slice(0, 5));\n        if (rightStr.length > 5) right = parseInt(rightStr.slice(rightStr.length - 5));\n        const newNum = parseInt(left.toString() + right.toString());\n        return newNum + dfs(arr.slice(1, arr.length - 1));\n    };\n    return dfs(nums);\n};"}
{"id": "546", "path": "output2\\js\\Easy\\546-maximum-difference-by-remapping-a-digit.js", "hypo_code": "var minMaxDifference = function(num) {\n    const str = num.toString();\n    const set = new Set();\n    for (let i = 0; i < str.length; i++) {\n        set.add(str.charAt(i));\n    }\n    const arr = [...set];\n    const map = new Map();\n    for (let i = 0; i < arr.length; i++) {\n        map.set(arr[i], i);\n    }\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    for (let i = 0; i < str.length; i++) {\n        const n = map.get(str.charAt(i));\n        if (i === 0 && n === 0) continue;\n        min = Math.min(min, parseInt(str.substring(0, i) + arr[0] + str.substring(i + 1)));\n        max = Math.max(max, parseInt(str.substring(0, i) + arr[arr.length - 1] + str.substring(i + 1)));\n    }\n    return max - min;\n};"}
{"id": "547", "path": "output2\\js\\Easy\\547-merge-two-2d-arrays-by-summing-values.js", "hypo_code": "var mergeArrays = function(nums1, nums2) {\n    const map = new Map();\n    for (const n of nums1) {\n        map.set(n[0], n[1]);\n    }\n    for (const n of nums2) {\n        if (map.has(n[0])) map.set(n[0], map.get(n[0]) + n[1]);\n        else map.set(n[0], n[1]);\n    }\n    const res = [];\n    for (const [key, value] of map.entries()) {\n        res.push([key, value]);\n    }\n    return res.sort((a, b) => a[0] - b[0]);\n};"}
{"id": "548", "path": "output2\\js\\Easy\\548-left-and-right-sum-differences.js", "hypo_code": "var leftRightDifference = function(nums) {\n    const leftSum = new Array(nums.length).fill(0);\n    const rightSum = new Array(nums.length).fill(0);\n    for (let i = 1; i < nums.length; i++) {\n        leftSum[i] = leftSum[i - 1] + nums[i - 1];\n    }\n    for (let i = nums.length - 2; i >= 0; i--) {\n        rightSum[i] = rightSum[i + 1] + nums[i + 1];\n    }\n    const answer = new Array(nums.length).fill(0);\n    for (let i = 0; i < nums.length; i++) {\n        answer[i] = Math.abs(leftSum[i] - rightSum[i]);\n    }\n    return answer;\n};"}
{"id": "549", "path": "output2\\js\\Easy\\549-split-with-minimum-sum.js", "hypo_code": "var splitNum = function(num) {\n    let min = Infinity;\n    for (let i = 1; i < num; i++) {\n        let n1 = i;\n        let n2 = num - i;\n        let sum = 0;\n        let count = new Array(10).fill(0);\n        while (n1 > 0) {\n            count[n1 % 10]++;\n            n1 = Math.floor(n1 / 10);\n        }\n        while (n2 > 0) {\n            count[n2 % 10]++;\n            n2 = Math.floor(n2 / 10);\n        }\n        for (const c of count) {\n            sum += c * c;\n        }\n        min = Math.min(min, sum);\n    }\n    return min;\n};"}
{"id": "550", "path": "output2\\js\\Easy\\550-pass-the-pillow.js", "hypo_code": "var passThePillow = function(n, time) {\n    let pillow = 1;\n    let direction = 1;\n    for (let i = 0; i < time; i++) {\n        if (pillow === n) direction = -1;\n        else if (pillow === 1) direction = 1;\n        pillow += direction;\n    }\n    return pillow;\n};"}
{"id": "551", "path": "output2\\js\\Easy\\551-count-the-number-of-vowel-strings-in-range.js", "hypo_code": "var vowelStrings = function(words, left, right) {\n    const dp = new Array(words.length).fill(0);\n    dp[0] = 5;\n    for (let i = 1; i < words.length; i++) {\n        if (words[i].charAt(0) === 'a') dp[i] = dp[i - 1] + 5;\n        else if (words[i].charAt(0) === 'e') dp[i] = dp[i - 1] + 4;\n        else if (words[i].charAt(0) === 'i') dp[i] = dp[i - 1] + 3;\n        else if (words[i].charAt(0) === 'o') dp[i] = dp[i - 1] + 2;\n        else if (words[i].charAt(0) === 'u') dp[i] = dp[i - 1] + 1;\n    }\n    let count = 0;\n    for (let i = left; i <= right; i++) {\n        count += dp[i];\n    }\n    return count;\n};"}
{"id": "552", "path": "output2\\js\\Easy\\552-distribute-money-to-maximum-children.js", "hypo_code": "var distMoney = function(money, children) {\n    if (money < children) return -1;\n    if (money === children) return 1;\n    if (money === children * 2) return 2;\n    let count = 0;\n    for (let i = 1; i <= 4; i++) {\n        if (money - i < children - 1) continue;\n        count += distMoney(money - i, children - 1);\n    }\n    return count;\n};"}
{"id": "553", "path": "output2\\js\\Easy\\553-number-of-even-and-odd-bits.js", "hypo_code": "var evenOddBit = function(n) {\n    let even = 0;\n    let odd = 0;\n    let binary = n.toString(2);\n    for (let i = 0; i < binary.length; i++) {\n        if (binary[i] === '1') {\n            if (i % 2 === 0) even++;\n            else odd++;\n        }\n    }\n    return [even, odd];\n};"}
{"id": "554", "path": "output2\\js\\Easy\\554-k-items-with-the-maximum-sum.js", "hypo_code": "var kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\n    const nums = [];\n    for (let i = 0; i < numOnes; i++) {\n        nums.push(1);\n    }\n    for (let i = 0; i < numZeros; i++) {\n        nums.push(0);\n    }\n    for (let i = 0; i < numNegOnes; i++) {\n        nums.push(-1);\n    }\n    nums.sort((a, b) => b - a);\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n    return sum;\n};"}
{"id": "555", "path": "output2\\js\\Easy\\555-form-smallest-number-from-two-digit-arrays.js", "hypo_code": "var minNumber = function(nums1, nums2) {\n    let res = \"\";\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length || j < nums2.length) {\n        let x = i;\n        let y = j;\n        while (nums1[i] === nums2[j] && i < nums1.length && j < nums2.length) {\n            i++;\n            j++;\n        }\n        if (nums1[i] < nums2[j] || j === nums2.length) {\n            res += nums1[x];\n            i++;\n        } else {\n            res += nums2[y];\n            j++;\n        }\n    }\n    return res;\n};"}
{"id": "556", "path": "output2\\js\\Easy\\556-find-the-longest-balanced-substring-of-a-binary-string.js", "hypo_code": "var findTheLongestBalancedSubstring = function(s) {\n    let maxLen = 0;\n    for (let i = 0; i < s.length; i++) {\n        let ones = 0;\n        let zeroes = 0;\n        for (let j = i; j < s.length; j++) {\n            if (s[j] === '1') ones++;\n            else zeroes++;\n            if (ones === zeroes) maxLen = Math.max(maxLen, j - i + 1);\n        }\n    }\n    return maxLen;\n};"}
{"id": "557", "path": "output2\\js\\Easy\\557-prime-in-diagonal.js", "hypo_code": "var diagonalPrime = function(nums) {\n    let max = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (isPrime(nums[i][i])) max = Math.max(max, nums[i][i]);\n        if (isPrime(nums[i][nums.length - i - 1])) max = Math.max(max, nums[i][nums.length - i - 1]);\n    }\n    return max;\n};"}
{"id": "565", "path": "output2\\js\\Easy\\565-find-the-width-of-columns-of-a-grid.js", "hypo_code": "var findColumnWidth = function(grid) {\n    const ans = [];\n    for (let i = 0; i < grid[0].length; i++) {\n        let max = 0;\n        for (let j = 0; j < grid.length; j++) {\n            const len = grid[j][i].toString().length;\n            if (len > max) max = len;\n        }\n        ans.push(max);\n    }\n    return ans;\n};"}
{"id": "566", "path": "output2\\js\\Easy\\566-row-with-maximum-ones.js", "hypo_code": "var rowAndMaximumOnes = function(mat) {\n    let max = 0;\n    let maxRow = 0;\n    for (let i = 0; i < mat.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < mat[i].length; j++) {\n            sum += mat[i][j];\n        }\n        if (sum > max) {\n            max = sum;\n            maxRow = i;\n        }\n    }\n    return [maxRow, max];\n};"}
{"id": "567", "path": "output2\\js\\Easy\\567-find-the-maximum-divisibility-score.js", "hypo_code": "var maxDivScore = function(nums, divisors) {\n    const count = new Array(100001).fill(0);\n    for (const n of nums) {\n        for (const d of divisors) {\n            if (n % d === 0) count[d]++;\n        }\n    }\n    let max = 0;\n    for (let i = 0; i < divisors.length; i++) {\n        if (count[divisors[i]] > count[max]) max = i;\n    }\n    return divisors[max];\n};"}
{"id": "569", "path": "output2\\js\\Easy\\569-calculate-delayed-arrival-time.js", "hypo_code": "var findDelayedArrivalTime = function(arrivalTime, delayedTime) {\n    let arrival = arrivalTime + delayedTime;\n    return arrival % 24;\n};"}
{"id": "570", "path": "output2\\js\\Easy\\570-sum-multiples.js", "hypo_code": "var sumOfMultiples = function(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0) sum += i;\n    }\n    return sum;\n};"}
{"id": "571", "path": "output2\\js\\Easy\\571-maximum-sum-with-exactly-k-elements.js", "hypo_code": "var maximizeSum = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let sum = 0;\n    let index = nums.length - 1;\n    while (k > 0) {\n        if (index > 0 && nums[index] > nums[index - 1]) {\n            sum += nums[index];\n            index--;\n            k--;\n        } else {\n            sum += nums[index] + 1;\n            index--;\n        }\n    }\n    return sum;\n};"}
{"id": "572", "path": "output2\\js\\Easy\\572-determine-the-winner-of-a-bowling-game.js", "hypo_code": "var isWinner = function(player1, player2) {\n    let score1 = 0;\n    let score2 = 0;\n    let turns = 0;\n    for (let i = 0; i < player1.length; i++) {\n        if (player1[i] === 10) {\n            score1 += 2 * 10;\n            turns++;\n        } else if (player1[i] + player1[i - 1] === 10) {\n            score1 += 2 * player1[i];\n            turns++;\n        } else {\n            score1 += player1[i];\n            turns++;\n        }\n        if (turns === 10) break;\n    }\n    turns = 0;\n    for (let i = 0; i < player2.length; i++) {\n        if (player2[i] === 10) {\n            score2 += 2 * 10;\n            turns++;\n        } else if (player2[i] + player2[i - 1] === 10) {\n            score2 += 2 * player2[i];\n            turns++;\n        } else {\n            score2 += player2[i];\n            turns++;\n        }\n        if (turns === 10) break;\n    }\n    if (score1 > score2) return 1;\n    else if (score2 > score1) return 2;\n    else return 0;\n};"}
{"id": "576", "path": "output2\\js\\Easy\\576-find-the-distinct-difference-array.js", "hypo_code": "var distinctDifferenceArray = function(nums) {\n    const res = [];\n    for (let i = 0; i < nums.length; i++) {\n        const set = new Set();\n        for (let j = i + 1; j < nums.length; j++) {\n            set.add(nums[j]);\n        }\n        res.push(set.size - i);\n    }\n    return res;\n\n};"}
{"id": "578", "path": "output2\\js\\Easy\\578-number-of-senior-citizens.js", "hypo_code": "var countSeniors = function(details) {\n    let count = 0;\n    for (const str of details) {\n        const age = parseInt(str.substring(10, 12));\n        if (age > 60) count++;\n    }\n    return count;\n};"}
{"id": "579", "path": "output2\\js\\Easy\\579-find-the-losers-of-the-circular-game.js", "hypo_code": "var circularGameLosers = function(n, k) {\n    const losers = [];\n    const friends = new Array(n).fill(0);\n    let i = 0;\n    while (true) {\n        let j = 0;\n        while (j < k) {\n            if (friends[i] === 1) {\n                j++;\n                if (j === k) {\n                    losers.push(i + 1);\n                    break;\n                }\n            }\n            i++;\n            if (i === n) i = 0;\n        }\n        if (losers.length === n - 1) break;\n        friends[i] = 1;\n    }\n    return losers;\n};"}
{"id": "581", "path": "output2\\js\\Easy\\581-minimum-string-length-after-removing-substrings.js", "hypo_code": "var minLength = function(s) {\n    const stack = [];\n    for (const c of s) {\n        if (stack.length >= 1 && stack[stack.length - 1] === 'A' && c === 'B') {\n            stack.pop();\n        } else if (stack.length >= 2 && stack[stack.length - 2] === 'A' && stack[stack.length - 1] === 'C' && c === 'D') {\n            stack.pop();\n            stack.pop();\n        } else stack.push(c);\n    }\n    return stack.length;\n};"}
{"id": "582", "path": "output2\\js\\Easy\\582-lexicographically-smallest-palindrome.js", "hypo_code": "var makeSmallestPalindrome = function(s) {\n    const arr = s.split(\"\");\n    let i = 0;\n    let j = arr.length - 1;\n    while (i < j) {\n        if (arr[i] !== arr[j]) {\n            arr[j] = arr[i];\n            break;\n        }\n        i++;\n        j--;\n    }\n    if (i >= j) return s;\n    const str = arr.join(\"\");\n    return str;\n};"}
{"id": "585", "path": "output2\\js\\Easy\\585-buy-two-chocolates.js", "hypo_code": "var buyChoco = function(prices, money) {\n    let min = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < prices.length - 1; i++) {\n        for (let j = i + 1; j < prices.length; j++) {\n            const sum = prices[i] + prices[j];\n            if (sum <= money) min = Math.min(min, money - sum);\n        }\n    }\n    return min === Number.MAX_SAFE_INTEGER ? money : min;\n\n};"}
{"id": "586", "path": "output2\\js\\Easy\\586-remove-trailing-zeros-from-a-string.js", "hypo_code": "var removeTrailingZeros = function(num) {\n    let i = num.length - 1;\n    while (i >= 0 && num[i] === '0') {\n        i--;\n    }\n    return num.substring(0, i + 1);\n};"}
{"id": "588", "path": "output2\\js\\Easy\\588-minimize-string-length.js", "hypo_code": "var minimizedStringLength = function(s) {\n    const count = new Array(26).fill(0);\n    for (const c of s) {\n        count[c.charCodeAt(0) - 97]++;\n    }\n    const arr = [];\n    for (let i = 0; i < 26; i++) {\n        if (count[i] > 0) {\n            arr.push(count[i]);\n        }\n    }\n    arr.sort((a, b) => b - a);\n    let res = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (i === 0) {\n            res += arr[i];\n        } else {\n            if (arr[i] >= arr[i - 1]) {\n                res += arr[i] - arr[i - 1] + 1;\n                arr[i] = arr[i - 1] - 1;\n            } else {\n                res += arr[i];\n            }\n        }\n    }\n    return res;\n};"}
{"id": "589", "path": "output2\\js\\Easy\\589-semi-ordered-permutation.js", "hypo_code": "var semiOrderedPermutation = function(nums) {\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== i + 1) count++;\n    }\n    return count - 1;\n};"}
{"id": "595", "path": "output2\\js\\Easy\\595-check-if-the-number-is-fascinating.js", "hypo_code": "var isFascinating = function(n) {\n    const str = n.toString();\n    const str2 = (n * 2).toString();\n    const str3 = (n * 3).toString();\n    const set = new Set();\n    for (let c of str) {\n        if (c === '0') return false;\n        if (set.has(c)) return false;\n        set.add(c);\n    }\n    for (let c of str2) {\n        if (c === '0') return false;\n        if (set.has(c)) return false;\n        set.add(c);\n    }\n    for (let c of str3) {\n        if (c === '0') return false;\n        if (set.has(c)) return false;\n        set.add(c);\n    }\n    return set.size === 9;\n};"}
{"id": "596", "path": "output2\\js\\Easy\\596-neither-minimum-nor-maximum.js", "hypo_code": "var findNonMinOrMax = function(nums) {\n    const min = Math.min(...nums);\n    const max = Math.max(...nums);\n    for (const n of nums) {\n        if (n !== min && n !== max) return n;\n    }\n    return -1;\n};"}
{"id": "597", "path": "output2\\js\\Easy\\597-total-distance-traveled.js", "hypo_code": "var distanceTraveled = function(mainTank, additionalTank) {\n    let main = mainTank;\n    let additional = additionalTank;\n    let distance = 0;\n    while (main > 0) {\n        main--;\n        distance += 10;\n        if (main === 0 && additional > 0) {\n            main += additional;\n            additional = 0;\n        }\n    }\n    return distance;\n};"}
{"id": "598", "path": "output2\\js\\Easy\\598-find-maximum-number-of-string-pairs.js", "hypo_code": "var maximumNumberOfStringPairs = function(words) {\n    const map = {};\n    for (const w of words) {\n        const key = w.charAt(0) + w.charAt(1);\n        if (map[key]) {\n            map[key]++;\n        } else {\n            map[key] = 1;\n        }\n    }\n    let count = 0;\n    for (const k in map) {\n        count += Math.floor(map[k] / 2);\n    }\n    return count;\n};"}
{"id": "599", "path": "output2\\js\\Easy\\599-number-of-beautiful-pairs.js", "hypo_code": "var countBeautifulPairs = function(nums) {\n    let map = {};\n    let count = 0;\n    for (const n of nums) {\n        if (map[n]) map[n]++;\n        else map[n] = 1;\n    }\n    for (const n of nums) {\n        if (map[n] > 0) {\n            map[n]--;\n            count += nums.length - map[n];\n        }\n    }\n    return count - nums.length;\n};"}
{"id": "600", "path": "output2\\js\\Easy\\600-longest-even-odd-subarray-with-threshold.js", "hypo_code": "var longestAlternatingSubarray = function(nums, threshold) {\n    let max = 0;\n    let count = 0;\n    let i = 0;\n    while (i < nums.length) {\n        if (nums[i] <= threshold) {\n            count++;\n            i++;\n        } else {\n            max = Math.max(max, count);\n            count = 0;\n            while (i < nums.length && nums[i] > threshold) i++;\n        }\n    }\n    return Math.max(max, count);\n};"}
{"id": "601", "path": "output2\\js\\Easy\\601-longest-alternating-subarray.js", "hypo_code": "var alternatingSubarray = function(nums) {\n    const dp = Array(nums.length).fill(1);\n    for (let i = 1; i < nums.length; i++) {\n        if ((nums[i] - nums[i - 1]) * (nums[i - 1] - nums[i - 2]) < 0) {\n            dp[i] = dp[i - 1] + 1;\n        }\n    }\n    return Math.max(...dp);\n};"}
{"id": "602", "path": "output2\\js\\Easy\\602-find-the-maximum-achievable-number.js", "hypo_code": "var theMaximumAchievableX = function(num, t) {\n    let x = 0;\n    for (let i = 0; i < t; i++) {\n        if (num > x) {\n            x++;\n            num--;\n        } else {\n            x--;\n            num++;\n        }\n    }\n    return x;\n};"}
{"id": "603", "path": "output2\\js\\Easy\\603-sum-of-squares-of-special-elements.js", "hypo_code": "var sumOfSquares = function(nums) {\n    let sum = 0;\n    for (let i = 1; i <= nums.length; i++) {\n        if (nums.length % i === 0) sum += nums[i - 1] * nums[i - 1];\n    }\n    return sum;\n};"}
{"id": "604", "path": "output2\\js\\Easy\\604-check-if-array-is-good.js", "hypo_code": "var isGood = function(nums) {\n    const n = nums.length;\n    const base = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; i++) {\n        base[i] = i;\n    }\n    nums.sort((a, b) => a - b);\n    return nums.join('') === base.join('');\n};"}
{"id": "605", "path": "output2\\js\\Easy\\605-split-strings-by-separator.js", "hypo_code": "var splitWordsBySeparator = function(words, separator) {\n    const res = [];\n    for (const w of words) {\n        const arr = w.split(separator);\n        for (const a of arr) {\n            if (a.length !== 0) res.push(a);\n        }\n    }\n    return res;\n};"}
{"id": "606", "path": "output2\\js\\Easy\\606-number-of-employees-who-met-the-target.js", "hypo_code": "var numberOfEmployeesWhoMetTarget = function(hours, target) {\n    let count = 0;\n    for (let i = 0; i < hours.length; i++) {\n        if (hours[i] >= target) count++;\n        let sum = hours[i];\n        for (let j = i + 1; j < hours.length; j++) {\n            sum += hours[j];\n            if (sum >= target) {\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n};"}
{"id": "607", "path": "output2\\js\\Easy\\607-account-balance-after-rounded-purchase.js", "hypo_code": "var accountBalanceAfterPurchase = function(purchaseAmount) {\n    let balance = 100;\n    while (purchaseAmount > 0) {\n        const roundedAmount = Math.ceil(purchaseAmount / 10) * 10;\n        const diff = roundedAmount - purchaseAmount;\n        if (balance - roundedAmount < 0) break;\n        balance -= roundedAmount;\n        purchaseAmount = diff;\n    }\n    return balance;\n};"}
{"id": "608", "path": "output2\\js\\Easy\\608-faulty-keyboard.js", "hypo_code": "var finalString = function(s) {\n    const stack = [];\n    for (const c of s) {\n        if (c === 'i') {\n            stack.pop();\n        } else {\n            stack.push(c);\n        }\n    }\n    return stack.join('');\n};"}
{"id": "609", "path": "output2\\js\\Easy\\609-max-pair-sum-in-an-array.js", "hypo_code": "var maxSum = function(nums) {\n    const map = new Map();\n    let max = -1;\n    for (const num of nums) {\n        const digit = Math.max(...num.toString().split(''));\n        if (map.has(digit)) {\n            max = Math.max(max, map.get(digit) + num);\n            map.set(digit, Math.max(map.get(digit), num));\n        } else {\n            map.set(digit, num);\n        }\n    }\n    return max;\n};"}
{"id": "610", "path": "output2\\js\\Medium\\610-add-two-numbers.js", "hypo_code": "var addTwoNumbers = function(l1, l2) {\n    let result = new ListNode();\n    let current = result;\n    let carry = 0;\n    while(l1 != null || l2 != null){\n        let sum = carry;\n        if(l1 != null){\n            sum += l1.val;\n            l1 = l1.next;\n        }\n        if(l2 != null){\n            sum += l2.val;\n            l2 = l2.next;\n        }\n        carry = Math.floor(sum / 10);\n        current.next = new ListNode(sum % 10);\n        current = current.next;\n    }\n    if(carry > 0){\n        current.next = new ListNode(carry);\n    }\n    return result.next;\n    \n};"}
{"id": "611", "path": "output2\\js\\Medium\\611-longest-substring-without-repeating-characters.js", "hypo_code": "var lengthOfLongestSubstring = function(s) {\n    let map = {};\n    let max = 0;\n    let start = 0;\n    for(let i = 0; i < s.length; i++){\n        let char = s[i];\n        if(map[char] != undefined){\n            start = Math.max(start, map[char] + 1);\n        }\n        map[char] = i;\n        max = Math.max(max, i - start + 1);\n    }\n    return max;\n};"}
{"id": "612", "path": "output2\\js\\Medium\\612-longest-palindromic-substring.js", "hypo_code": "var longestPalindrome = function(s) {\n    let max = \"\";\n    for(let i = 0; i < s.length; i++){\n        let odd = expandAroundCenter(s, i, i);\n        let even = expandAroundCenter(s, i, i + 1);\n        let longest = odd.length > even.length ? odd : even;\n        max = longest.length > max.length ? longest : max;\n    }\n    return max;\n    \n};"}
{"id": "613", "path": "output2\\js\\Medium\\613-zigzag-conversion.js", "hypo_code": "var convert = function(s, numRows) {\n    if(numRows == 1){\n        return s;\n    }\n    let result = \"\";\n    let cycle = 2 * numRows - 2;\n    for(let i = 0; i < numRows; i++){\n        for(let j = 0; j + i < s.length; j += cycle){\n            result += s[j + i];\n            if(i != 0 && i != numRows - 1 && j + cycle - i < s.length){\n                result += s[j + cycle - i];\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "614", "path": "output2\\js\\Medium\\614-reverse-integer.js", "hypo_code": "var reverse = function(x) {\n    let reversed = 0;\n    while(x != 0){\n        let digit = x % 10;\n        x = Math.floor(x / 10);\n        reversed = reversed * 10 + digit;\n    }\n    if(reversed > Math.pow(2, 31) - 1 || reversed < Math.pow(-2, 31)){\n        return 0;\n    }\n    return reversed;\n};"}
{"id": "615", "path": "output2\\js\\Medium\\615-string-to-integer-atoi.js", "hypo_code": "var myAtoi = function(s) {\n    let result = 0;\n    let sign = 1;\n    let i = 0;\n    while(s[i] == ' '){\n        i++;\n    }\n    if(s[i] == '-' || s[i] == '+'){\n        sign = s[i] == '-' ? -1 : 1;\n        i++;\n    }\n    while(i < s.length && s[i] >= '0' && s[i] <= '9'){\n        result = result * 10 + (s[i] - '0');\n        i++;\n    }\n    result *= sign;\n    if(result > Math.pow(2, 31) - 1){\n        return Math.pow(2, 31) - 1;\n    }\n    if(result < Math.pow(-2, 31)){\n        return Math.pow(-2, 31);\n    }\n    return result;\n    \n};"}
{"id": "616", "path": "output2\\js\\Medium\\616-container-with-most-water.js", "hypo_code": "var maxArea = function(height) {\n    let max = 0;\n    let left = 0;\n    let right = height.length - 1;\n    while(left < right){\n        let area = Math.min(height[left], height[right]) * (right - left);\n        max = Math.max(max, area);\n        if(height[left] < height[right]){\n            left++;\n        }else{\n            right--;\n        }\n    }\n    return max;\n    \n};"}
{"id": "617", "path": "output2\\js\\Medium\\617-integer-to-roman.js", "hypo_code": "var intToRoman = function(num) {\n    let result = \"\";\n    let roman = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n    let value = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    for(let i = 0; i < roman.length; i++){\n        while(num >= value[i]){\n            result += roman[i];\n            num -= value[i];\n        }\n    }\n    return result;\n    \n};"}
{"id": "618", "path": "output2\\js\\Medium\\618-3sum.js", "hypo_code": "var threeSum = function(nums) {\n    let result = [];\n    nums.sort((a, b) => a - b);\n    for(let i = 0; i < nums.length; i++){\n        if(i > 0 && nums[i] == nums[i - 1]){\n            continue;\n        }\n        let left = i + 1;\n        let right = nums.length - 1;\n        while(left < right){\n            let sum = nums[i] + nums[left] + nums[right];\n            if(sum == 0){\n                result.push([nums[i], nums[left], nums[right]]);\n                left++;\n                right--;\n                while(left < right && nums[left] == nums[left - 1]){\n                    left++;\n                }\n                while(left < right && nums[right] == nums[right + 1]){\n                    right--;\n                }\n            }else if(sum < 0){\n                left++;\n            }else{\n                right--;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "619", "path": "output2\\js\\Medium\\619-3sum-closest.js", "hypo_code": "var threeSumClosest = function(nums, target) {\n    let result = 0;\n    let min = Number.MAX_SAFE_INTEGER;\n    nums.sort((a, b) => a - b);\n    for(let i = 0; i < nums.length; i++){\n        if(i > 0 && nums[i] == nums[i - 1]){\n            continue;\n        }\n        let left = i + 1;\n        let right = nums.length - 1;\n        while(left < right){\n            let sum = nums[i] + nums[left] + nums[right];\n            if(sum == target){\n                return sum;\n            }else if(sum < target){\n                if(target - sum < min){\n                    min = target - sum;\n                    result = sum;\n                }\n                left++;\n            }else{\n                if(sum - target < min){\n                    min = sum - target;\n                    result = sum;\n                }\n                right--;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "620", "path": "output2\\js\\Medium\\620-letter-combinations-of-a-phone-number.js", "hypo_code": "var letterCombinations = function(digits) {\n    let map = {\n        \"2\": [\"a\", \"b\", \"c\"],\n        \"3\": [\"d\", \"e\", \"f\"],\n        \"4\": [\"g\", \"h\", \"i\"],\n        \"5\": [\"j\", \"k\", \"l\"],\n        \"6\": [\"m\", \"n\", \"o\"],\n        \"7\": [\"p\", \"q\", \"r\", \"s\"],\n        \"8\": [\"t\", \"u\", \"v\"],\n        \"9\": [\"w\", \"x\", \"y\", \"z\"]\n    };\n    let result = [];\n    if(digits.length == 0){\n        return result;\n    }\n    let queue = [];\n    queue.push(\"\");\n    while(queue.length > 0){\n        let current = queue.shift();\n        if(current.length == digits.length){\n            result.push(current);\n        }else{\n            let digit = digits[current.length];\n            let letters = map[digit];\n            for(let i = 0; i < letters.length; i++){\n                queue.push(current + letters[i]);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "621", "path": "output2\\js\\Medium\\621-4sum.js", "hypo_code": "var fourSum = function(nums, target) {\n    let result = [];\n    if(nums.length < 4){\n        return result;\n    }\n    nums.sort((a, b) => a - b);\n    for(let i = 0; i < nums.length - 3; i++){\n        if(i > 0 && nums[i] == nums[i - 1]){\n            continue;\n        }\n        for(let j = i + 1; j < nums.length - 2; j++){\n            if(j > i + 1 && nums[j] == nums[j - 1]){\n                continue;\n            }\n            let left = j + 1;\n            let right = nums.length - 1;\n            while(left < right){\n                let sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if(sum == target){\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n                    left++;\n                    right--;\n                    while(left < right && nums[left] == nums[left - 1]){\n                        left++;\n                    }\n                    while(left < right && nums[right] == nums[right + 1]){\n                        right--;\n                    }\n                }else if(sum < target){\n                    left++;\n                }else{\n                    right--;\n                }\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "622", "path": "output2\\js\\Medium\\622-remove-nth-node-from-end-of-list.js", "hypo_code": "var removeNthFromEnd = function(head, n) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let first = dummy;\n    let second = dummy;\n    for(let i = 0; i <= n; i++){\n        first = first.next;\n    }\n    while(first != null){\n        first = first.next;\n        second = second.next;\n    }\n    second.next = second.next.next;\n    return dummy.next;\n    \n};"}
{"id": "623", "path": "output2\\js\\Medium\\623-generate-parentheses.js", "hypo_code": "var generateParenthesis = function(n) {\n    let result = [];\n    if(n == 0){\n        return result;\n    }\n    let queue = [];\n    queue.push({str: \"\", open: 0, close: 0});\n    while(queue.length > 0){\n        let current = queue.shift();\n        if(current.open == n && current.close == n){\n            result.push(current.str);\n        }else{\n            if(current.open < n){\n                queue.push({str: current.str + \"(\", open: current.open + 1, close: current.close});\n            }\n            if(current.close < current.open){\n                queue.push({str: current.str + \")\", open: current.open, close: current.close + 1});\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "624", "path": "output2\\js\\Medium\\624-swap-nodes-in-pairs.js", "hypo_code": "var swapPairs = function(head) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let current = dummy;\n    while(current.next != null && current.next.next != null){\n        let first = current.next;\n        let second = current.next.next;\n        first.next = second.next;\n        current.next = second;\n        current.next.next = first;\n        current = current.next.next;\n    }\n    return dummy.next;\n    \n};"}
{"id": "625", "path": "output2\\js\\Medium\\625-divide-two-integers.js", "hypo_code": "var divide = function(dividend, divisor) {\n    \n    if (dividend === -2147483648 && divisor === -1) return 2147483647;\n    if (dividend === -2147483648 && divisor === 1) return -2147483648;\n    if (dividend === 0) return 0;\n    if (divisor === 1) return dividend;\n    if (divisor === -1) return -dividend;\n    let isNegative = false;\n    if (dividend < 0 && divisor < 0) {\n        dividend = -dividend;\n        divisor = -divisor;\n    } else if (dividend < 0) {\n        dividend = -dividend;\n        isNegative = true;\n    } else if (divisor < 0) {\n        divisor = -divisor;\n        isNegative = true;\n    }\n    let result = 0;\n    while (dividend >= divisor) {\n        dividend -= divisor;\n        result++;\n    }\n    return isNegative ? -result : result;\n};"}
{"id": "626", "path": "output2\\js\\Medium\\626-next-permutation.js", "hypo_code": "var nextPermutation = function(nums) {\n    let n = nums.length;\n    let i = n - 2;\n    while(i >= 0 && nums[i] >= nums[i + 1]){\n        i--;\n    }\n    if(i >= 0){\n        let j = n - 1;\n        while(j >= 0 && nums[j] <= nums[i]){\n            j--;\n        }\n        swap(nums, i, j);\n    }\n    reverse(nums, i + 1, n - 1);\n    \n};"}
{"id": "627", "path": "output2\\js\\Medium\\627-search-in-rotated-sorted-array.js", "hypo_code": "var search = function(nums, target) {\n    let n = nums.length;\n    let left = 0;\n    let right = n - 1;\n    while(left <= right){\n        let mid = left + Math.floor((right - left) / 2);\n        if(nums[mid] == target){\n            return mid;\n        }\n        if(nums[left] <= nums[mid]){\n            if(nums[left] <= target && target < nums[mid]){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }else{\n            if(nums[mid] < target && target <= nums[right]){\n                left = mid + 1;\n            }else{\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n    \n};"}
{"id": "628", "path": "output2\\js\\Medium\\628-find-first-and-last-position-of-element-in-sorted-array.js", "hypo_code": "var searchRange = function(nums, target) {\n    let result = [-1, -1];\n    if(nums.length == 0){\n        return result;\n    }\n    let left = 0;\n    let right = nums.length - 1;\n    while(left < right){\n        let mid = left + Math.floor((right - left) / 2);\n        if(nums[mid] < target){\n            left = mid + 1;\n        }else{\n            right = mid;\n        }\n    }\n    if(nums[left] != target){\n        return result;\n    }\n    result[0] = left;\n    right = nums.length - 1;\n    while(left < right){\n        let mid = left + Math.floor((right - left) / 2) + 1;\n        if(nums[mid] > target){\n            right = mid - 1;\n        }else{\n            left = mid;\n        }\n    }\n    result[1] = right;\n    return result;    \n};"}
{"id": "629", "path": "output2\\js\\Medium\\629-valid-sudoku.js", "hypo_code": "var isValidSudoku = function(board) {\n    let rows = {};\n    let cols = {};\n    let boxes = {};\n    for(let i = 0; i < 9; i++){\n        rows[i] = {};\n        cols[i] = {};\n        boxes[i] = {};\n    }\n    for(let i = 0; i < 9; i++){\n        for(let j = 0; j < 9; j++){\n            let boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);\n            let num = board[i][j];\n            if(num != \".\"){\n                if(rows[i][num] || cols[j][num] || boxes[boxIndex][num]){\n                    return false;\n                }\n                rows[i][num] = true;\n                cols[j][num] = true;\n                boxes[boxIndex][num] = true;\n            }\n        }\n    }\n    return true;\n    \n};"}
{"id": "630", "path": "output2\\js\\Medium\\630-count-and-say.js", "hypo_code": "var countAndSay = function(n) {\n    let result = \"1\";\n    for(let i = 1; i < n; i++){\n        let current = result[0];\n        let count = 1;\n        let temp = \"\";\n        for(let j = 1; j < result.length; j++){\n            if(result[j] == current){\n                count++;\n            }else{\n                temp += count + current;\n                current = result[j];\n                count = 1;\n            }\n        }\n        temp += count + current;\n        result = temp;\n    }\n    return result;\n    \n};"}
{"id": "631", "path": "output2\\js\\Medium\\631-combination-sum.js", "hypo_code": "var combinationSum = function(candidates, target) {\n    let result = [];\n    if(candidates.length == 0){\n        return result;\n    }\n    candidates.sort((a, b) => a - b);\n    let current = [];\n    helper(candidates, target, 0, current, result);\n    return result;\n    \n};"}
{"id": "632", "path": "output2\\js\\Medium\\632-combination-sum-ii.js", "hypo_code": "var combinationSum2 = function(candidates, target) {\n    let result = [];\n    if(candidates.length == 0){\n        return result;\n    }\n    candidates.sort((a, b) => a - b);\n    let current = [];\n    helper(candidates, target, 0, current, result);\n    return result;\n    \n    \n};"}
{"id": "633", "path": "output2\\js\\Medium\\633-multiply-strings.js", "hypo_code": "var multiply = function(num1, num2) {\n    let result = [];\n    let carry = 0;\n    for(let i = num1.length - 1; i >= 0; i--){\n        let current = [];\n        for(let j = num2.length - 1; j >= 0; j--){\n            let product = (num1[i] - '0') * (num2[j] - '0') + carry;\n            carry = Math.floor(product / 10);\n            current.unshift(product % 10);\n        }\n        if(carry > 0){\n            current.unshift(carry);\n            carry = 0;\n        }\n        for(let k = 0; k < num1.length - 1 - i; k++){\n            current.push(0);\n        }\n        result = add(result, current);\n    }\n    return result.join('');\n    \n    \n};"}
{"id": "634", "path": "output2\\js\\Medium\\634-jump-game-ii.js", "hypo_code": "var jump = function(nums) {\n    let result = 0;\n    let current = 0;\n    let next = 0;\n    for(let i = 0; i < nums.length - 1; i++){\n        next = Math.max(next, i + nums[i]);\n        if(i == current){\n            result++;\n            current = next;\n        }\n    }\n    return result;\n    \n};"}
{"id": "635", "path": "output2\\js\\Medium\\635-permutations.js", "hypo_code": "var permute = function(nums) {\n    let result = [];\n    if(nums.length == 0){\n        return result;\n    }\n    let current = [];\n    let visited = new Array(nums.length);\n    helper(nums, current, result, visited);\n    return result;\n    \n    \n};"}
{"id": "636", "path": "output2\\js\\Medium\\636-permutations-ii.js", "hypo_code": "var permuteUnique = function(nums) {\n    let result = [];\n    if(nums.length == 0){\n        return result;\n    }\n    nums.sort((a, b) => a - b);\n    let current = [];\n    let visited = new Array(nums.length);\n    helper(nums, current, result, visited);\n    return result;\n    \n    \n};"}
{"id": "637", "path": "output2\\js\\Medium\\637-rotate-image.js", "hypo_code": "var rotate = function(matrix) {\n    \n    let n = matrix.length;\n    for(let i = 0; i < n; i++){\n        for(let j = i; j < n; j++){\n            swap(matrix, i, j, j, i);\n        }\n    }\n    for(let i = 0; i < n; i++){\n        reverse(matrix[i], 0, n - 1);\n    }\n    \n    \n    \n};"}
{"id": "638", "path": "output2\\js\\Medium\\638-group-anagrams.js", "hypo_code": "var groupAnagrams = function(strs) {\n    let result = [];\n    if(strs.length == 0){\n        return result;\n    }\n    let map = new Map();\n    for(let i = 0; i < strs.length; i++){\n        let sorted = strs[i].split(\"\").sort().join(\"\");\n        if(map.has(sorted)){\n            let list = map.get(sorted);\n            list.push(strs[i]);\n            map.set(sorted, list);\n        }else{\n            let list = [];\n            list.push(strs[i]);\n            map.set(sorted, list);\n        }\n    }\n    for(let list of map.values()){\n        result.push(list);\n    }\n    return result;\n    \n};"}
{"id": "639", "path": "output2\\js\\Medium\\639-powx-n.js", "hypo_code": "var myPow = function(x, n) {\n    if(n == 0){\n        return 1;\n    }\n    if(n == 1){\n        return x;\n    }\n    if(n == -1){\n        return 1/x;\n    }\n    let temp = myPow(x, Math.floor(n/2));\n    if(n % 2 == 0){\n        return temp * temp;\n    }else{\n        return temp * temp * x;\n    }\n    \n};"}
{"id": "640", "path": "output2\\js\\Medium\\640-maximum-subarray.js", "hypo_code": "var maxSubArray = function(nums) {\n    let max = nums[0];\n    let sum = nums[0];\n    for(let i = 1; i < nums.length; i++){\n        sum = Math.max(nums[i], sum + nums[i]);\n        max = Math.max(max, sum);\n    }\n    return max;\n    \n};"}
{"id": "641", "path": "output2\\js\\Medium\\641-spiral-matrix.js", "hypo_code": "var spiralOrder = function(matrix) {\n    let result = [];\n    if(matrix.length == 0){\n        return result;\n    }\n    let top = 0;\n    let bottom = matrix.length - 1;\n    let left = 0;\n    let right = matrix[0].length - 1;\n    while(top <= bottom && left <= right){\n        for(let i = left; i <= right; i++){\n            result.push(matrix[top][i]);\n        }\n        top++;\n        for(let i = top; i <= bottom; i++){\n            result.push(matrix[i][right]);\n        }\n        right--;\n        if(top <= bottom){\n            for(let i = right; i >= left; i--){\n                result.push(matrix[bottom][i]);\n            }\n            bottom--;\n        }\n        if(left <= right){\n            for(let i = bottom; i >= top; i--){\n                result.push(matrix[i][left]);\n            }\n            left++;\n        }\n    }\n    return result;\n    \n};"}
{"id": "642", "path": "output2\\js\\Medium\\642-jump-game.js", "hypo_code": "var canJump = function(nums) {\n    let max = 0;\n    for(let i = 0; i < nums.length; i++){\n        if(i > max){\n            return false;\n        }\n        max = Math.max(max, i + nums[i]);\n    }\n    return true;\n    \n};"}
{"id": "643", "path": "output2\\js\\Medium\\643-merge-intervals.js", "hypo_code": "var merge = function(intervals) {\n    let result = [];\n    if(intervals.length == 0){\n        return result;\n    }\n    intervals.sort((a, b) => a[0] - b[0]);\n    let current = intervals[0];\n    for(let i = 1; i < intervals.length; i++){\n        if(intervals[i][0] <= current[1]){\n            current[1] = Math.max(current[1], intervals[i][1]);\n        } else {\n            result.push(current);\n            current = intervals[i];\n        }\n    }\n    result.push(current);\n    return result;\n};"}
{"id": "644", "path": "output2\\js\\Medium\\644-insert-interval.js", "hypo_code": "var insert = function(intervals, newInterval) {\n    let result = [];\n    let i = 0;\n    while(i < intervals.length && intervals[i][1] < newInterval[0]){\n        result.push(intervals[i]);\n        i++;\n    }\n    while(i < intervals.length && intervals[i][0] <= newInterval[1]){\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    result.push(newInterval);\n    while(i < intervals.length){\n        result.push(intervals[i]);\n        i++;\n    }\n    return result;\n    \n};"}
{"id": "645", "path": "output2\\js\\Medium\\645-spiral-matrix-ii.js", "hypo_code": "var generateMatrix = function(n) {\n    let result = [];\n    for(let i = 0; i < n; i++){\n        result.push(new Array(n));\n    }\n    let top = 0;\n    let bottom = n - 1;\n    let left = 0;\n    let right = n - 1;\n    let num = 1;\n    while(top <= bottom && left <= right){\n        for(let i = left; i <= right; i++){\n            result[top][i] = num;\n            num++;\n        }\n        top++;\n        for(let i = top; i <= bottom; i++){\n            result[i][right] = num;\n            num++;\n        }\n        right--;\n        if(top <= bottom){\n            for(let i = right; i >= left; i--){\n                result[bottom][i] = num;\n                num++;\n            }\n            bottom--;\n        }\n        if(left <= right){\n            for(let i = bottom; i >= top; i--){\n                result[i][left] = num;\n                num++;\n            }\n            left++;\n        }\n    }\n    return result;\n    \n};"}
{"id": "646", "path": "output2\\js\\Medium\\646-rotate-list.js", "hypo_code": "var rotateRight = function(head, k) {\n    if(head == null){\n        return null;\n    }\n    let length = 1;\n    let current = head;\n    while(current.next != null){\n        length++;\n        current = current.next;\n    }\n    current.next = head;\n    let newTail = head;\n    for(let i = 0; i < length - k % length - 1; i++){\n        newTail = newTail.next;\n    }\n    let newHead = newTail.next;\n    newTail.next = null;\n    return newHead;\n    \n};"}
{"id": "647", "path": "output2\\js\\Medium\\647-unique-paths.js", "hypo_code": "var uniquePaths = function(m, n) {\n    let result = 0;\n    let dp = new Array(m);\n    for(let i = 0; i < m; i++){\n        dp[i] = new Array(n);\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(i == 0 || j == 0){\n                dp[i][j] = 1;\n            }else{\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n    \n};"}
{"id": "648", "path": "output2\\js\\Medium\\648-unique-paths-ii.js", "hypo_code": "var uniquePathsWithObstacles = function(obstacleGrid) {\n    let result = 0;\n    let m = obstacleGrid.length;\n    let n = obstacleGrid[0].length;\n    let dp = new Array(m);\n    for(let i = 0; i < m; i++){\n        dp[i] = new Array(n);\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(obstacleGrid[i][j] == 1){\n                dp[i][j] = 0;\n            }else if(i == 0 && j == 0){\n                dp[i][j] = 1;\n            }else if(i == 0){\n                dp[i][j] = dp[i][j - 1];\n            }else if(j == 0){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n    \n};"}
{"id": "649", "path": "output2\\js\\Medium\\649-minimum-path-sum.js", "hypo_code": "var minPathSum = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let dp = new Array(m);\n    for(let i = 0; i < m; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = grid[0][0];\n    for(let i = 1; i < m; i++){\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i - 1] + grid[0][i];\n    }\n    for(let i = 1; i < m; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n    return dp[m - 1][n - 1];\n    \n};"}
{"id": "650", "path": "output2\\js\\Medium\\650-simplify-path.js", "hypo_code": "var simplifyPath = function(path) {\n    let result = [];\n    let current = \"\";\n    for(let i = 0; i < path.length; i++){\n        if(path[i] == '/'){\n            if(current == \"..\"){\n                result.pop();\n            }else if(current != \"\" && current != \".\"){\n                result.push(current);\n            }\n            current = \"\";\n        }else{\n            current += path[i];\n        }\n    }\n    if(current == \"..\"){\n        result.pop();\n    }else if(current != \"\" && current != \".\"){\n        result.push(current);\n    }\n    return \"/\" + result.join('/');\n    \n};"}
{"id": "651", "path": "output2\\js\\Medium\\651-edit-distance.js", "hypo_code": "var minDistance = function(word1, word2) {\n    \n    \n    let len1 = word1.length;\n    let len2 = word2.length;\n    if (len1 === 0) return len2;\n    if (len2 === 0) return len1;\n    let dp = new Array(len1 + 1);\n    for (let i = 0; i <= len1; i++) {\n        dp[i] = new Array(len2 + 1).fill(0);\n    }\n    for (let i = 0; i <= len1; i++) {\n        dp[i][0] = i;\n    }\n    for (let i = 0; i <= len2; i++) {\n        dp[0][i] = i;\n    }\n    \n    for (let i = 1; i <= len1; i++) {\n        let char1 = word1.charAt(i - 1);\n        for (let j = 1; j <= len2; j++) {\n            let char2 = word2.charAt(j - 1);\n            if (char1 === char2) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                let min = Math.min(dp[i - 1][j], dp[i][j - 1]);\n                min = Math.min(min, dp[i - 1][j - 1]);\n                dp[i][j] = min + 1;\n            }\n        }\n    }\n    \n    return dp[len1][len2];\n};"}
{"id": "652", "path": "output2\\js\\Medium\\652-set-matrix-zeroes.js", "hypo_code": "var setZeroes = function(matrix) {\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let rows = new Set();\n    let cols = new Set();\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(matrix[i][j] == 0){\n                rows.add(i);\n                cols.add(j);\n            }\n        }\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(rows.has(i) || cols.has(j)){\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    \n    \n};"}
{"id": "653", "path": "output2\\js\\Medium\\653-search-a-2d-matrix.js", "hypo_code": "var searchMatrix = function(matrix, target) {\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let left = 0;\n    let right = m * n - 1;\n    while(left <= right){\n        let mid = Math.floor((left + right) / 2);\n        let midVal = matrix[Math.floor(mid / n)][mid % n];\n        if(midVal == target){\n            return true;\n        }\n        if(midVal < target){\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return false;\n    \n};"}
{"id": "654", "path": "output2\\js\\Medium\\654-sort-colors.js", "hypo_code": "var sortColors = function(nums) {\n    let n = nums.length;\n    let p0 = 0;\n    let p2 = n - 1;\n    let i = 0;\n    while(i <= p2){\n        if(nums[i] == 0){\n            swap(nums, i, p0);\n            p0++;\n            i++;\n        }else if(nums[i] == 2){\n            swap(nums, i, p2);\n            p2--;\n        }else{\n            i++;\n        }\n    }\n    \n    \n};"}
{"id": "655", "path": "output2\\js\\Medium\\655-combinations.js", "hypo_code": "var combine = function(n, k) {\n    let result = [];\n    if(n == 0){\n        return result;\n    }\n    let current = [];\n    helper(n, k, 1, current, result);\n    return result;\n    \n    \n    \n};"}
{"id": "656", "path": "output2\\js\\Medium\\656-subsets.js", "hypo_code": "var subsets = function(nums) {\n    let result = [];\n    let current = [];\n    helper(nums, 0, current, result);\n    return result;\n    \n    \n    \n};"}
{"id": "657", "path": "output2\\js\\Medium\\657-word-search.js", "hypo_code": "var exist = function(board, word) {\n    let m = board.length;\n    let n = board[0].length;\n    let visited = new Array(m);\n    for(let i = 0; i < m; i++){\n        visited[i] = new Array(n);\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(dfs(board, word, i, j, 0, visited)){\n                return true;\n            }\n        }\n    }\n    return false;\n    \n    \n    \n};"}
{"id": "658", "path": "output2\\js\\Medium\\658-remove-duplicates-from-sorted-array-ii.js", "hypo_code": "var removeDuplicates = function(nums) {\n    let i = 0;\n    for(let n of nums){\n        if(i < 2 || n > nums[i - 2]){\n            nums[i++] = n;\n        }\n    }\n    return i;\n    \n};"}
{"id": "659", "path": "output2\\js\\Medium\\659-search-in-rotated-sorted-array-ii.js", "hypo_code": "var search = function(nums, target) {\n    if(nums.length == 0){\n        return false;\n    }\n    let left = 0;\n    let right = nums.length - 1;\n    while(left <= right){\n        let mid = left + Math.floor((right - left) / 2);\n        if(nums[mid] == target){\n            return true;\n        }\n        if(nums[left] == nums[mid]){\n            left++;\n            continue;\n        }\n        if(nums[left] < nums[mid]){\n            if(nums[left] <= target && target < nums[mid]){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }else{\n            if(nums[mid] < target && target <= nums[right]){\n                left = mid + 1;\n            }else{\n                right = mid - 1;\n            }\n        }\n    }\n    return false;\n    \n};"}
{"id": "660", "path": "output2\\js\\Medium\\660-remove-duplicates-from-sorted-list-ii.js", "hypo_code": "var deleteDuplicates = function(head) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let current = dummy;\n    while(current.next != null && current.next.next != null){\n        if(current.next.val == current.next.next.val){\n            let val = current.next.val;\n            while(current.next != null && current.next.val == val){\n                current.next = current.next.next;\n            }\n        }else{\n            current = current.next;\n        }\n    }\n    return dummy.next;\n    \n};"}
{"id": "661", "path": "output2\\js\\Medium\\661-partition-list.js", "hypo_code": "var partition = function(head, x) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let current = dummy;\n    let prev = dummy;\n    while(current.next != null){\n        if(current.next.val < x){\n            if(current != prev){\n                let temp = current.next;\n                current.next = current.next.next;\n                temp.next = prev.next;\n                prev.next = temp;\n                prev = prev.next;\n            }else{\n                current = current.next;\n                prev = prev.next;\n            }\n        }else{\n            current = current.next;\n        }\n    }\n    return dummy.next;\n    \n};"}
{"id": "662", "path": "output2\\js\\Medium\\662-gray-code.js", "hypo_code": "var grayCode = function(n) {\n    let result = [0];\n    for(let i = 0; i < n; i++){\n        let size = result.length;\n        for(let j = size - 1; j >= 0; j--){\n            result.push(result[j] + Math.pow(2, i));\n        }\n    }\n    return result;\n    \n};"}
{"id": "663", "path": "output2\\js\\Medium\\663-subsets-ii.js", "hypo_code": "var subsetsWithDup = function(nums) {\n    let result = [];\n    if(nums.length == 0){\n        return result;\n    }\n    nums.sort((a, b) => a - b);\n    let current = [];\n    helper(nums, 0, current, result);\n    return result;\n    \n    \n    \n};"}
{"id": "664", "path": "output2\\js\\Medium\\664-decode-ways.js", "hypo_code": "var numDecodings = function(s) {\n    let n = s.length;\n    if(n == 0){\n        return 0;\n    }\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] == \"0\" ? 0 : 1;\n    for(let i = 2; i <= n; i++){\n        let oneDigit = parseInt(s.substring(i - 1, i));\n        let twoDigit = parseInt(s.substring(i - 2, i));\n        if(oneDigit >= 1){\n            dp[i] += dp[i - 1];\n        }\n        if(twoDigit >= 10 && twoDigit <= 26){\n            dp[i] += dp[i - 2];\n        }\n    }\n    return dp[n];\n    \n};"}
{"id": "665", "path": "output2\\js\\Medium\\665-reverse-linked-list-ii.js", "hypo_code": "var reverseBetween = function(head, left, right) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let current = dummy;\n    let prev = dummy;\n    let count = 1;\n    while(current.next != null){\n        if(count == left){\n            let temp = current.next;\n            current.next = current.next.next;\n            temp.next = prev.next;\n            prev.next = temp;\n            prev = prev.next;\n            count++;\n        }else if(count > left && count < right){\n            let temp = current.next;\n            current.next = current.next.next;\n            temp.next = prev.next;\n            prev.next = temp;\n            count++;\n        }else if(count == right){\n            let temp = current.next;\n            current.next = current.next.next;\n            temp.next = prev.next;\n            prev.next = temp;\n            count++;\n        }else{\n            current = current.next;\n            prev = prev.next;\n            count++;\n        }\n    }\n    return dummy.next;\n    \n};"}
{"id": "666", "path": "output2\\js\\Medium\\666-restore-ip-addresses.js", "hypo_code": "var restoreIpAddresses = function(s) {\n    let result = [];\n    if(s.length < 4 || s.length > 12){\n        return result;\n    }\n    let current = [];\n    helper(s, 0, current, result);\n    return result;\n    \n    \n    \n};"}
{"id": "667", "path": "output2\\js\\Medium\\667-unique-binary-search-trees-ii.js", "hypo_code": "var generateTrees = function(n) {\n    if(n == 0){\n        return [];\n    }\n    return generateTreesHelper(1, n);\n    \n    \n};"}
{"id": "668", "path": "output2\\js\\Medium\\668-unique-binary-search-trees.js", "hypo_code": "var numTrees = function(n) {\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for(let i = 2; i <= n; i++){\n        for(let j = 1; j <= i; j++){\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    return dp[n];\n    \n};"}
{"id": "669", "path": "output2\\js\\Medium\\669-interleaving-string.js", "hypo_code": "var isInterleave = function(s1, s2, s3) {\n    let m = s1.length;\n    let n = s2.length;\n    let k = s3.length;\n    if(m + n != k){\n        return false;\n    }\n    let dp = new Array(m + 1);\n    for(let i = 0; i <= m; i++){\n        dp[i] = new Array(n + 1);\n    }\n    dp[0][0] = true;\n    for(let i = 1; i <= m; i++){\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\n    }\n    for(let i = 1; i <= n; i++){\n        dp[0][i] = dp[0][i - 1] && s2[i - 1] == s3[i - 1];\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\n        }\n    }\n    return dp[m][n];\n    \n};"}
{"id": "670", "path": "output2\\js\\Medium\\670-validate-binary-search-tree.js", "hypo_code": "var isValidBST = function(root) {\n    if(root == null){\n        return true;\n    }\n    let left = root.left;\n    let right = root.right;\n    if(left != null){\n        if(left.val >= root.val){\n            return false;\n        }\n    }\n    if(right != null){\n        if(right.val <= root.val){\n            return false;\n        }\n    }\n    let leftValid = isValidBST(left);\n    let rightValid = isValidBST(right);\n    return leftValid && rightValid;\n    \n};"}
{"id": "671", "path": "output2\\js\\Medium\\671-recover-binary-search-tree.js", "hypo_code": "var recoverTree = function(root) {\n    let first = null;\n    let second = null;\n    let prev = null;\n    let current = root;\n    let stack = [];\n    while(current != null || stack.length != 0){\n        while(current != null){\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        if(prev != null && prev.val > current.val){\n            if(first == null){\n                first = prev;\n            }\n            second = current;\n        }\n        prev = current;\n        current = current.right;\n    }\n    let temp = first.val;\n    first.val = second.val;\n    second.val = temp;\n    \n};"}
{"id": "672", "path": "output2\\js\\Medium\\672-binary-tree-level-order-traversal.js", "hypo_code": "var levelOrder = function(root) {\n    let result = [];\n    if(root == null){\n        return result;\n    }\n    let queue = [];\n    queue.push(root);\n    while(queue.length != 0){\n        let currentLevel = [];\n        let currentLevelSize = queue.length;\n        for(let i = 0; i < currentLevelSize; i++){\n            let current = queue.shift();\n            currentLevel.push(current.val);\n            if(current.left != null){\n                queue.push(current.left);\n            }\n            if(current.right != null){\n                queue.push(current.right);\n            }\n        }\n        result.push(currentLevel);\n    }\n    return result;\n    \n};"}
{"id": "673", "path": "output2\\js\\Medium\\673-binary-tree-zigzag-level-order-traversal.js", "hypo_code": "var zigzagLevelOrder = function(root) {\n    let result = [];\n    if(root == null){\n        return result;\n    }\n    let queue = [];\n    queue.push(root);\n    let isLeftToRight = true;\n    while(queue.length != 0){\n        let currentLevel = [];\n        let currentLevelSize = queue.length;\n        for(let i = 0; i < currentLevelSize; i++){\n            let current = queue.shift();\n            if(isLeftToRight){\n                currentLevel.push(current.val);\n            }else{\n                currentLevel.unshift(current.val);\n            }\n            if(current.left != null){\n                queue.push(current.left);\n            }\n            if(current.right != null){\n                queue.push(current.right);\n            }\n        }\n        result.push(currentLevel);\n        isLeftToRight = !isLeftToRight;\n    }\n    return result;\n    \n};"}
{"id": "674", "path": "output2\\js\\Medium\\674-construct-binary-tree-from-preorder-and-inorder-traversal.js", "hypo_code": "var buildTree = function(preorder, inorder) {\n    if(preorder.length == 0 || inorder.length == 0){\n        return null;\n    }\n    let root = new TreeNode(preorder[0]);\n    let rootIndex = inorder.indexOf(preorder[0]);\n    let leftInorder = inorder.slice(0, rootIndex);\n    let rightInorder = inorder.slice(rootIndex + 1);\n    let leftPreorder = preorder.slice(1, leftInorder.length + 1);\n    let rightPreorder = preorder.slice(leftInorder.length + 1);\n    root.left = buildTree(leftPreorder, leftInorder);\n    root.right = buildTree(rightPreorder, rightInorder);\n    return root;\n    \n};"}
{"id": "675", "path": "output2\\js\\Medium\\675-construct-binary-tree-from-inorder-and-postorder-traversal.js", "hypo_code": "var buildTree = function(inorder, postorder) {\n    if(inorder.length == 0 || postorder.length == 0){\n        return null;\n    }\n    let root = new TreeNode(postorder[postorder.length - 1]);\n    let rootIndex = inorder.indexOf(postorder[postorder.length - 1]);\n    let leftInorder = inorder.slice(0, rootIndex);\n    let rightInorder = inorder.slice(rootIndex + 1);\n    let leftPostorder = postorder.slice(0, leftInorder.length);\n    let rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\n    root.left = buildTree(leftInorder, leftPostorder);\n    root.right = buildTree(rightInorder, rightPostorder);\n    return root;\n    \n};"}
{"id": "676", "path": "output2\\js\\Medium\\676-binary-tree-level-order-traversal-ii.js", "hypo_code": "var levelOrderBottom = function(root) {\n    let result = [];\n    if(root == null){\n        return result;\n    }\n    let queue = [];\n    queue.push(root);\n    while(queue.length != 0){\n        let currentLevel = [];\n        let currentLevelSize = queue.length;\n        for(let i = 0; i < currentLevelSize; i++){\n            let current = queue.shift();\n            currentLevel.push(current.val);\n            if(current.left != null){\n                queue.push(current.left);\n            }\n            if(current.right != null){\n                queue.push(current.right);\n            }\n        }\n        result.unshift(currentLevel);\n    }\n    return result;\n    \n};"}
{"id": "677", "path": "output2\\js\\Medium\\677-convert-sorted-list-to-binary-search-tree.js", "hypo_code": "var sortedListToBST = function(head) {\n    if(head == null){\n        return null;\n    }\n    let current = head;\n    let count = 0;\n    while(current != null){\n        current = current.next;\n        count++;\n    }\n    return sortedListToBSTHelper(head, 0, count - 1);\n    \n    \n};"}
{"id": "678", "path": "output2\\js\\Medium\\678-path-sum-ii.js", "hypo_code": "var pathSum = function(root, targetSum) {\n    let result = [];\n    if(root == null){\n        return result;\n    }\n    let currentPath = [];\n    pathSumHelper(root, targetSum, currentPath, result);\n    return result;\n    \n    \n};"}
{"id": "679", "path": "output2\\js\\Medium\\679-flatten-binary-tree-to-linked-list.js", "hypo_code": "var flatten = function(root) {\n    if(root == null){\n        return;\n    }\n    let stack = [];\n    stack.push(root);\n    let prev = null;\n    while(stack.length != 0){\n        let current = stack.pop();\n        if(prev != null){\n            prev.left = null;\n            prev.right = current;\n        }\n        let right = current.right;\n        let left = current.left;\n        if(right != null){\n            stack.push(right);\n        }\n        if(left != null){\n            stack.push(left);\n        }\n        prev = current;\n    }\n    \n};"}
{"id": "680", "path": "output2\\js\\Medium\\680-populating-next-right-pointers-in-each-node.js", "hypo_code": "var connect = function(root) {\n    if(root == null){\n        return root;\n    }\n    let queue = [];\n    queue.push(root);\n    while(queue.length != 0){\n        let currentLevelSize = queue.length;\n        let prev = null;\n        for(let i = 0; i < currentLevelSize; i++){\n            let current = queue.shift();\n            if(prev != null){\n                prev.next = current;\n            }\n            if(current.left != null){\n                queue.push(current.left);\n            }\n            if(current.right != null){\n                queue.push(current.right);\n            }\n            prev = current;\n        }\n    }\n    return root;\n    \n};"}
{"id": "681", "path": "output2\\js\\Medium\\681-populating-next-right-pointers-in-each-node-ii.js", "hypo_code": "var connect = function(root) {\n    if(root == null){\n        return root;\n    }\n    let queue = [];\n    queue.push(root);\n    while(queue.length != 0){\n        let currentLevelSize = queue.length;\n        let prev = null;\n        for(let i = 0; i < currentLevelSize; i++){\n            let current = queue.shift();\n            if(prev != null){\n                prev.next = current;\n            }\n            if(current.left != null){\n                queue.push(current.left);\n            }\n            if(current.right != null){\n                queue.push(current.right);\n            }\n            prev = current;\n        }\n    }\n    return root;\n    \n};"}
{"id": "682", "path": "output2\\js\\Medium\\682-triangle.js", "hypo_code": "var minimumTotal = function(triangle) {\n    let dp = new Array(triangle.length).fill(0);\n    dp[0] = triangle[0][0];\n    for(let i = 1; i < triangle.length; i++){\n        dp[i] = dp[i - 1] + triangle[i][i];\n        for(let j = i - 1; j > 0; j--){\n            dp[j] = Math.min(dp[j - 1], dp[j]) + triangle[i][j];\n        }\n        dp[0] += triangle[i][0];\n    }\n    let min = dp[0];\n    for(let i = 1; i < dp.length; i++){\n        min = Math.min(min, dp[i]);\n    }\n    return min;\n    \n};"}
{"id": "683", "path": "output2\\js\\Medium\\683-best-time-to-buy-and-sell-stock-ii.js", "hypo_code": "var maxProfit = function(prices) {\n    let profit = 0;\n    for(let i = 1; i < prices.length; i++){\n        if(prices[i] > prices[i - 1]){\n            profit += prices[i] - prices[i - 1];\n        }\n    }\n    return profit;\n    \n};"}
{"id": "684", "path": "output2\\js\\Medium\\684-longest-consecutive-sequence.js", "hypo_code": "var longestConsecutive = function(nums) {\n    let map = {};\n    let max = 0;\n    for(let i = 0; i < nums.length; i++){\n        let num = nums[i];\n        if(map[num] == undefined){\n            let left = map[num - 1] == undefined ? 0 : map[num - 1];\n            let right = map[num + 1] == undefined ? 0 : map[num + 1];\n            let sum = left + right + 1;\n            map[num] = sum;\n            max = Math.max(max, sum);\n            map[num - left] = sum;\n            map[num + right] = sum;\n        }\n    }\n    return max;\n    \n};"}
{"id": "685", "path": "output2\\js\\Medium\\685-sum-root-to-leaf-numbers.js", "hypo_code": "var sumNumbers = function(root) {\n    let result = 0;\n    if(root == null){\n        return result;\n    }\n    let currentPath = [];\n    sumNumbersHelper(root, currentPath, result);\n    return result;\n    \n    \n};"}
{"id": "686", "path": "output2\\js\\Medium\\686-surrounded-regions.js", "hypo_code": "var solve = function(board) {\n    if(board.length == 0){\n        return;\n    }\n    let m = board.length;\n    let n = board[0].length;\n    let queue = [];\n    for(let i = 0; i < m; i++){\n        if(board[i][0] == 'O'){\n            queue.push([i, 0]);\n        }\n        if(board[i][n - 1] == 'O'){\n            queue.push([i, n - 1]);\n        }\n    }\n    for(let i = 0; i < n; i++){\n        if(board[0][i] == 'O'){\n            queue.push([0, i]);\n        }\n        if(board[m - 1][i] == 'O'){\n            queue.push([m - 1, i]);\n        }\n    }\n    while(queue.length != 0){\n        let current = queue.shift();\n        let x = current[0];\n        let y = current[1];\n        if(board[x][y] == 'O'){\n            board[x][y] = 'A';\n            if(x > 0 && board[x - 1][y] == 'O'){\n                queue.push([x - 1, y]);\n            }\n            if(x < m - 1 && board[x + 1][y] == 'O'){\n                queue.push([x + 1, y]);\n            }\n            if(y > 0 && board[x][y - 1] == 'O'){\n                queue.push([x, y - 1]);\n            }\n            if(y < n - 1 && board[x][y + 1] == 'O'){\n                queue.push([x, y + 1]);\n            }\n        }\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(board[i][j] == 'O'){\n                board[i][j] = 'X';\n            }\n            if(board[i][j] == 'A'){\n                board[i][j] = 'O';\n            }\n        }\n    }\n    \n};"}
{"id": "687", "path": "output2\\js\\Medium\\687-palindrome-partitioning.js", "hypo_code": "var partition = function(s) {\n    let result = [];\n    let current = [];\n    backtrack(s, 0, current, result);\n    return result;\n    \n};"}
{"id": "688", "path": "output2\\js\\Medium\\688-clone-graph.js", "hypo_code": "var cloneGraph = function(node) {\n    if(node == null){\n        return node;\n    }\n    let visited = new Map();\n    return cloneGraphHelper(node, visited);\n    \n};"}
{"id": "689", "path": "output2\\js\\Medium\\689-gas-station.js", "hypo_code": "var canCompleteCircuit = function(gas, cost) {\n    let total = 0;\n    let tank = 0;\n    let start = 0;\n    for(let i = 0; i < gas.length; i++){\n        tank += gas[i] - cost[i];\n        total += gas[i] - cost[i];\n        if(tank < 0){\n            start = i + 1;\n            tank = 0;\n        }\n    }\n    return total >= 0 ? start : -1;\n    \n};"}
{"id": "690", "path": "output2\\js\\Medium\\690-single-number-ii.js", "hypo_code": "var singleNumber = function(nums) {\n    let ones = 0;\n    let twos = 0;\n    for(let i = 0; i < nums.length; i++){\n        ones = (ones ^ nums[i]) & ~twos;\n        twos = (twos ^ nums[i]) & ~ones;\n    }\n    return ones;\n    \n};"}
{"id": "691", "path": "output2\\js\\Medium\\691-copy-list-with-random-pointer.js", "hypo_code": "var copyRandomList = function(head) {\n    if(head == null){\n        return head;\n    }\n    let visited = new Map();\n    return copyRandomListHelper(head, visited);\n    \n    \n};"}
{"id": "692", "path": "output2\\js\\Medium\\692-word-break.js", "hypo_code": "var wordBreak = function(s, wordDict) {\n    let dp = new Array(s.length + 1);\n    dp[0] = true;\n    for(let i = 1; i <= s.length; i++){\n        for(let j = 0; j < i; j++){\n            if(dp[j] && wordDict.includes(s.substring(j, i))){\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length] || false;\n    \n};"}
{"id": "693", "path": "output2\\js\\Medium\\693-linked-list-cycle-ii.js", "hypo_code": "var detectCycle = function(head) {\n    if(head == null){\n        return null;\n    }\n    let slow = head;\n    let fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n        if(slow == fast){\n            break;\n        }\n    }\n    if(fast == null || fast.next == null){\n        return null;\n    }\n    slow = head;\n    while(slow != fast){\n        slow = slow.next;\n        fast = fast.next;\n    }\n    return slow;\n    \n};"}
{"id": "694", "path": "output2\\js\\Medium\\694-reorder-list.js", "hypo_code": "var reorderList = function(head) {\n    if(head == null){\n        return;\n    }\n    let slow = head;\n    let fast = head;\n    while(fast != null && fast.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let prev = null;\n    let current = slow;\n    while(current != null){\n        let next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    let first = head;\n    let second = prev;\n    while(second.next != null){\n        let firstNext = first.next;\n        let secondNext = second.next;\n        first.next = second;\n        second.next = firstNext;\n        first = firstNext;\n        second = secondNext;\n    }\n    \n};"}
{"id": "696", "path": "output2\\js\\Medium\\696-insertion-sort-list.js", "hypo_code": "var insertionSortList = function(head) {\n    if(head == null){\n        return null;\n    }\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let current = head;\n    while(current != null && current.next != null){\n        if(current.val <= current.next.val){\n            current = current.next;\n        }else{\n            let prev = dummy;\n            while(prev.next.val < current.next.val){\n                prev = prev.next;\n            }\n            let temp = current.next;\n            current.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n    }\n    return dummy.next;\n    \n};"}
{"id": "697", "path": "output2\\js\\Medium\\697-sort-list.js", "hypo_code": "var sortList = function(head) {\n    if(head == null || head.next == null){\n        return head;\n    }\n    let slow = head;\n    let fast = head;\n    while(fast.next != null && fast.next.next != null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let mid = slow.next;\n    slow.next = null;\n    let left = sortList(head);\n    let right = sortList(mid);\n    let result = merge(left, right);\n    return result;\n    \n    \n};"}
{"id": "698", "path": "output2\\js\\Medium\\698-evaluate-reverse-polish-notation.js", "hypo_code": "var evalRPN = function(tokens) {\n    let stack = [];\n    for(let i = 0; i < tokens.length; i++){\n        if(tokens[i] == '+'){\n            let a = stack.pop();\n            let b = stack.pop();\n            stack.push(a + b);\n        }\n        else if(tokens[i] == '-'){\n            let a = stack.pop();\n            let b = stack.pop();\n            stack.push(b - a);\n        }\n        else if(tokens[i] == '*'){\n            let a = stack.pop();\n            let b = stack.pop();\n            stack.push(a * b);\n        }\n        else if(tokens[i] == '/'){\n            let a = stack.pop();\n            let b = stack.pop();\n            stack.push(Math.trunc(b / a));\n        }\n        else{\n            stack.push(parseInt(tokens[i]));\n        }\n    }\n    return stack.pop();\n    \n};"}
{"id": "699", "path": "output2\\js\\Medium\\699-reverse-words-in-a-string.js", "hypo_code": "var reverseWords = function(s) {\n    let result = \"\";\n    let current = \"\";\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == \" \"){\n            if(current != \"\"){\n                result = current + \" \" + result;\n                current = \"\";\n            }\n        }else{\n            current += s[i];\n        }\n    }\n    if(current != \"\"){\n        result = current + \" \" + result;\n    }\n    return result.trim();\n    \n};"}
{"id": "700", "path": "output2\\js\\Medium\\700-maximum-product-subarray.js", "hypo_code": "var maxProduct = function(nums) {\n    let max = nums[0];\n    let min = nums[0];\n    let result = nums[0];\n    for(let i = 1; i < nums.length; i++){\n        let temp = max;\n        max = Math.max(nums[i], Math.max(max * nums[i], min * nums[i]));\n        min = Math.min(nums[i], Math.min(temp * nums[i], min * nums[i]));\n        result = Math.max(result, max);\n    }\n    return result;\n    \n};"}
{"id": "701", "path": "output2\\js\\Medium\\701-find-minimum-in-rotated-sorted-array.js", "hypo_code": "var findMin = function(nums) {\n    let left = 0;\n    let right = nums.length - 1;\n    while(left < right){\n        let mid = left + Math.floor((right - left) / 2);\n        if(nums[mid] < nums[right]){\n            right = mid;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return nums[left];\n    \n};"}
{"id": "703", "path": "output2\\js\\Medium\\703-find-peak-element.js", "hypo_code": "var findPeakElement = function(nums) {\n    let len = nums.length;\n    if (len === 1) return 0;\n    if (len === 2) return nums[0] > nums[1] ? 0 : 1;\n    let left = 0;\n    let right = len - 1;\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        if (mid === 0) {\n            if (nums[mid] > nums[mid + 1]) return mid;\n            left = mid + 1;\n        } else if (mid === len - 1) {\n            if (nums[mid] > nums[mid - 1]) return mid;\n            right = mid - 1;\n        } else {\n            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) return mid;\n            if (nums[mid] < nums[mid + 1]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return left;\n};"}
{"id": "704", "path": "output2\\js\\Medium\\704-compare-version-numbers.js", "hypo_code": "var compareVersion = function(version1, version2) {\n    \n    let arr1 = version1.split(\".\");\n    let arr2 = version2.split(\".\");\n    let len1 = arr1.length;\n    let len2 = arr2.length;\n    let len = Math.max(len1, len2);\n    for (let i = 0; i < len; i++) {\n        let num1 = i < len1 ? parseInt(arr1[i]) : 0;\n        let num2 = i < len2 ? parseInt(arr2[i]) : 0;\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n    }\n    return 0;\n};"}
{"id": "705", "path": "output2\\js\\Medium\\705-fraction-to-recurring-decimal.js", "hypo_code": "var fractionToDecimal = function(numerator, denominator) {\n    \n\tlet isNegative = false;\n\tif (numerator < 0 && denominator < 0) {\n\t\tnumerator = -numerator;\n\t\tdenominator = -denominator;\n\t} else if (numerator < 0) {\n\t\tnumerator = -numerator;\n\t\tisNegative = true;\n\t} else if (denominator < 0) {\n\t\tdenominator = -denominator;\n\t\tisNegative = true;\n\t}\n\tlet result = Math.floor(numerator / denominator);\n\tlet remainder = numerator % denominator;\n\tif (remainder === 0) {\n\t\treturn isNegative ? -result : result;\n\t}\n\tlet map = new Map();\n\tlet arr = [];\n\tlet index = 0;\n\twhile (remainder !== 0) {\n\t\tif (map.has(remainder)) {\n\t\t\tlet startIndex = map.get(remainder);\n\t\t\tlet nonRepeating = arr.slice(0, startIndex);\n\t\t\tlet repeating = arr.slice(startIndex);\n\t\t\tif (nonRepeating.length === 0) {\n\t\t\t\treturn `${result}.${repeating.join(\"\")}`;\n\t\t\t}\n\t\t\treturn `${result}.${nonRepeating.join(\"\")}(${repeating.join(\"\")})`;\n\t\t}\n\t\tmap.set(remainder, index);\n\t\tremainder *= 10;\n\t\tlet digit = Math.floor(remainder / denominator);\n\t\tarr.push(digit);\n\t\tremainder %= denominator;\n\t\tindex++;\n\t}\n\treturn `${result}.${arr.join(\"\")}`;\n};"}
{"id": "706", "path": "output2\\js\\Medium\\706-two-sum-ii-input-array-is-sorted.js", "hypo_code": "var twoSum = function(numbers, target) {\n    let len = numbers.length;\n\tlet left = 0;\n\tlet right = len - 1;\n\twhile (left < right) {\n\t\tlet sum = numbers[left] + numbers[right];\n\t\tif (sum === target) return [left + 1, right + 1];\n\t\tif (sum < target) {\n\t\t\tleft++;\n\t\t} else {\n\t\t\tright--;\n\t\t}\n\t}\n\treturn [];\n};"}
{"id": "707", "path": "output2\\js\\Medium\\707-factorial-trailing-zeroes.js", "hypo_code": "var trailingZeroes = function(n) {\n    let result = 0;\n    while (n >= 5) {\n        let temp = Math.floor(n / 5);\n        result += temp;\n        n = temp;\n    }\n    return result;\n};"}
{"id": "712", "path": "output2\\js\\Medium\\712-largest-number.js", "hypo_code": "var largestNumber = function(nums) {\n    let len = nums.length;\n    if (len === 1) return nums[0].toString();\n    if (len === 2) {\n        let a = nums[0].toString();\n        let b = nums[1].toString();\n        let ab = a + b;\n        let ba = b + a;\n        return ab > ba ? ab : ba;\n    }\n    nums.sort((a, b) => {\n        let ab = a.toString() + b.toString();\n        let ba = b.toString() + a.toString();\n        return ab > ba ? -1 : 1;\n    });\n    if (nums[0] === 0) return \"0\";\n    return nums.join(\"\");\n};"}
{"id": "715", "path": "output2\\js\\Medium\\715-repeated-dna-sequences.js", "hypo_code": "var findRepeatedDnaSequences = function(s) {\n    let result = [];\n    let map = new Map();\n    for(let i = 0; i < s.length - 9; i++){\n        let current = s.substring(i, i + 10);\n        if(map.has(current)){\n            let count = map.get(current);\n            if(count == 1){\n                result.push(current);\n            }\n            map.set(current, count + 1);\n        }else{\n            map.set(current, 1);\n        }\n    }\n    return result;\n    \n};"}
{"id": "716", "path": "output2\\js\\Medium\\716-rotate-array.js", "hypo_code": "var rotate = function(nums, k) {\n    k = k % nums.length;\n    reverse(nums, 0, nums.length - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, nums.length - 1);\n    \n};"}
{"id": "719", "path": "output2\\js\\Medium\\719-house-robber.js", "hypo_code": "var rob = function(nums) {\n    let n = nums.length;\n    let dp = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n    }\n    return dp[n];\n    \n};"}
{"id": "720", "path": "output2\\js\\Medium\\720-binary-tree-right-side-view.js", "hypo_code": "var rightSideView = function(root) {\n    let result = [];\n    if(root == null){\n        return result;\n    }\n    let queue = [];\n    queue.push(root);\n    while(queue.length != 0){\n        let currentLevelSize = queue.length;\n        for(let i = 0; i < currentLevelSize; i++){\n            let current = queue.shift();\n            if(i == currentLevelSize - 1){\n                result.push(current.val);\n            }\n            if(current.left != null){\n                queue.push(current.left);\n            }\n            if(current.right != null){\n                queue.push(current.right);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "721", "path": "output2\\js\\Medium\\721-number-of-islands.js", "hypo_code": "var numIslands = function(grid) {\n    let count = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[0].length; j++){\n            if(grid[i][j] == '1'){\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n    \n    \n};"}
{"id": "722", "path": "output2\\js\\Medium\\722-bitwise-and-of-numbers-range.js", "hypo_code": "var rangeBitwiseAnd = function(left, right) {\n    let count = 0;\n    while(left != right){\n        left = left >> 1;\n        right = right >> 1;\n        count++;\n    }\n    return left << count;\n    \n};"}
{"id": "723", "path": "output2\\js\\Medium\\723-count-primes.js", "hypo_code": "var countPrimes = function(n) {\n    let count = 0;\n    let isPrime = new Array(n).fill(true);\n    for(let i = 2; i < n; i++){\n        if(isPrime[i]){\n            count++;\n            for(let j = 2; i * j < n; j++){\n                isPrime[i * j] = false;\n            }\n        }\n    }\n    return count;\n    \n};"}
{"id": "724", "path": "output2\\js\\Medium\\724-course-schedule.js", "hypo_code": "var canFinish = function(numCourses, prerequisites) {\n    let graph = new Array(numCourses).fill(0).map(() => new Array());\n    let inDegree = new Array(numCourses).fill(0);\n    for(let i = 0; i < prerequisites.length; i++){\n        let course = prerequisites[i][0];\n        let pre = prerequisites[i][1];\n        graph[pre].push(course);\n        inDegree[course]++;\n    }\n    let queue = [];\n    for(let i = 0; i < inDegree.length; i++){\n        if(inDegree[i] == 0){\n            queue.push(i);\n        }\n    }\n    while(queue.length > 0){\n        let course = queue.shift();\n        for(let i = 0; i < graph[course].length; i++){\n            let nextCourse = graph[course][i];\n            inDegree[nextCourse]--;\n            if(inDegree[nextCourse] == 0){\n                queue.push(nextCourse);\n            }\n        }\n    }\n    for(let i = 0; i < inDegree.length; i++){\n        if(inDegree[i] != 0){\n            return false;\n        }\n    }\n    return true;\n    \n};"}
{"id": "726", "path": "output2\\js\\Medium\\726-minimum-size-subarray-sum.js", "hypo_code": "var minSubArrayLen = function(target, nums) {\n    let left = 0;\n    let right = 0;\n    let sum = 0;\n    let min = Number.MAX_SAFE_INTEGER;\n    while(right < nums.length){\n        sum += nums[right];\n        while(sum >= target){\n            min = Math.min(min, right - left + 1);\n            sum -= nums[left];\n            left++;\n        }\n        right++;\n    }\n    return min == Number.MAX_SAFE_INTEGER ? 0 : min;\n    \n};"}
{"id": "727", "path": "output2\\js\\Medium\\727-course-schedule-ii.js", "hypo_code": "var findOrder = function(numCourses, prerequisites) {\n    let graph = new Array(numCourses).fill(0).map(() => new Array());\n    let inDegree = new Array(numCourses).fill(0);\n    for(let i = 0; i < prerequisites.length; i++){\n        let course = prerequisites[i][0];\n        let pre = prerequisites[i][1];\n        graph[pre].push(course);\n        inDegree[course]++;\n    }\n    let queue = [];\n    for(let i = 0; i < inDegree.length; i++){\n        if(inDegree[i] == 0){\n            queue.push(i);\n        }\n    }\n    let result = [];\n    while(queue.length > 0){\n        let course = queue.shift();\n        result.push(course);\n        for(let i = 0; i < graph[course].length; i++){\n            let nextCourse = graph[course][i];\n            inDegree[nextCourse]--;\n            if(inDegree[nextCourse] == 0){\n                queue.push(nextCourse);\n            }\n        }\n    }\n    if(result.length != numCourses){\n        return [];\n    }\n    return result;\n    \n};"}
{"id": "729", "path": "output2\\js\\Medium\\729-house-robber-ii.js", "hypo_code": "var rob = function(nums) {\n    let n = nums.length;\n    if(n == 1){\n        return nums[0];\n    }\n    let dp = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n    }\n    let dp2 = new Array(n + 1).fill(0);\n    for(let i = 2; i <= n; i++){\n        dp2[i] = Math.max(dp2[i - 1], dp2[i - 2] + nums[i - 1]);\n    }\n    return Math.max(dp[n - 1], dp2[n]);\n    \n};"}
{"id": "730", "path": "output2\\js\\Medium\\730-kth-largest-element-in-an-array.js", "hypo_code": "var findKthLargest = function(nums, k) {\n    let left = 0;\n    let right = nums.length - 1;\n    while(left <= right){\n        let mid = left + Math.floor((right - left) / 2);\n        let pivot = nums[mid];\n        let i = left;\n        let j = right;\n        while(i <= j){\n            while(nums[i] > pivot){\n                i++;\n            }\n            while(nums[j] < pivot){\n                j--;\n            }\n            if(i <= j){\n                let temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                i++;\n                j--;\n            }\n        }\n        if(left <= k - 1 && k - 1 <= j){\n            right = j;\n        }else if(i <= k - 1 && k - 1 <= right){\n            left = i;\n        }else{\n            return nums[k - 1];\n        }\n    }\n    return -1;\n    \n};"}
{"id": "731", "path": "output2\\js\\Medium\\731-combination-sum-iii.js", "hypo_code": "var combinationSum3 = function(k, n) {\n    let result = [];\n    if(k == 0){\n        return result;\n    }\n    let current = [];\n    helper(k, n, 1, current, result);\n    return result;\n    \n    \n    \n};"}
{"id": "732", "path": "output2\\js\\Medium\\732-maximal-square.js", "hypo_code": "var maximalSquare = function(matrix) {\n    if(matrix.length == 0 || matrix[0].length == 0){\n        return 0;\n    }\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    let max = 0;\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            if(matrix[i - 1][j - 1] == '1'){\n                dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;\n                max = Math.max(max, dp[i][j]);\n            }\n        }\n    }\n    return max * max;\n    \n};"}
{"id": "733", "path": "output2\\js\\Medium\\733-rectangle-area.js", "hypo_code": "var computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n    let area1 = (ax2 - ax1) * (ay2 - ay1);\n    let area2 = (bx2 - bx1) * (by2 - by1);\n    let overlap = 0;\n    if(ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1){\n        let x = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n        let y = Math.min(ay2, by2) - Math.max(ay1, by1);\n        overlap = x * y;\n    }\n    return area1 + area2 - overlap;\n    \n};"}
{"id": "734", "path": "output2\\js\\Medium\\734-basic-calculator-ii.js", "hypo_code": "var calculate = function(s) {\n    let stack = [];\n    let num = 0;\n    let sign = '+';\n    for(let i = 0; i < s.length; i++){\n        if(!isNaN(s[i]) && s[i] != ' '){\n            num = num * 10 + parseInt(s[i]);\n        }\n        if(isNaN(s[i]) || i == s.length - 1){\n            if(sign == '+'){\n                stack.push(num);\n            }else if(sign == '-'){\n                stack.push(-num);\n            }else if(sign == '*'){\n                stack.push(stack.pop() * num);\n            }else if(sign == '/'){\n                stack.push(Math.trunc(stack.pop() / num));\n            }\n            sign = s[i];\n            num = 0;\n        }\n    }\n    let result = 0;\n    while(stack.length > 0){\n        result += stack.pop();\n    }\n    return result;\n    \n};"}
{"id": "735", "path": "output2\\js\\Medium\\735-majority-element-ii.js", "hypo_code": "var majorityElement = function(nums) {\n    let len = nums.length;\n    if (len === 1) return nums;\n    let result = [];\n    let max = Math.floor(len / 3);\n    let map = new Map();\n    for (let i = 0; i < len; i++) {\n        let key = nums[i];\n        if (map.has(key)) {\n            let value = map.get(key);\n            value++;\n            if (value > max) {\n                result.push(key);\n                map.delete(key);\n            } else {\n                map.set(key, value);\n            }\n        } else {\n            map.set(key, 1);\n        }\n    }\n    return result;\n};"}
{"id": "736", "path": "output2\\js\\Medium\\736-kth-smallest-element-in-a-bst.js", "hypo_code": "var kthSmallest = function(root, k) {\n    let result = [];\n    kthSmallestHelper(root, result);\n    return result[k - 1];\n    \n    \n    \n};"}
{"id": "737", "path": "output2\\js\\Medium\\737-lowest-common-ancestor-of-a-binary-search-tree.js", "hypo_code": "var lowestCommonAncestor = function(root, p, q) {\n    if(root == null){\n        return null;\n    }\n    if(root.val > p.val && root.val > q.val){\n        return lowestCommonAncestor(root.left, p, q);\n    }\n    if(root.val < p.val && root.val < q.val){\n        return lowestCommonAncestor(root.right, p, q);\n    }\n    return root;\n    \n};"}
{"id": "738", "path": "output2\\js\\Medium\\738-lowest-common-ancestor-of-a-binary-tree.js", "hypo_code": "var lowestCommonAncestor = function(root, p, q) {\n    if(root == null){\n        return null;\n    }\n    if(root == p || root == q){\n        return root;\n    }\n    let left = lowestCommonAncestor(root.left, p, q);\n    let right = lowestCommonAncestor(root.right, p, q);\n    if(left != null && right != null){\n        return root;\n    }\n    if(left != null){\n        return left;\n    }\n    if(right != null){\n        return right;\n    }\n    return null;\n    \n};"}
{"id": "739", "path": "output2\\js\\Medium\\739-delete-node-in-a-linked-list.js", "hypo_code": "var deleteNode = function(node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n};"}
{"id": "740", "path": "output2\\js\\Medium\\740-product-of-array-except-self.js", "hypo_code": "var productExceptSelf = function(nums) {\n    let n = nums.length;\n    let left = new Array(n).fill(1);\n    let right = new Array(n).fill(1);\n    let result = new Array(n).fill(1);\n    for(let i = 1; i < n; i++){\n        left[i] = left[i - 1] * nums[i - 1];\n    }\n    for(let i = n - 2; i >= 0; i--){\n        right[i] = right[i + 1] * nums[i + 1];\n    }\n    for(let i = 0; i < n; i++){\n        result[i] = left[i] * right[i];\n    }\n    return result;\n    \n};"}
{"id": "741", "path": "output2\\js\\Medium\\741-search-a-2d-matrix-ii.js", "hypo_code": "var searchMatrix = function(matrix, target) {\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let row = 0;\n    let col = n - 1;\n    while(row < m && col >= 0){\n        if(matrix[row][col] == target){\n            return true;\n        }else if(matrix[row][col] < target){\n            row++;\n        }else{\n            col--;\n        }\n    }\n    return false;\n    \n};"}
{"id": "742", "path": "output2\\js\\Medium\\742-different-ways-to-add-parentheses.js", "hypo_code": "var diffWaysToCompute = function(expression) {\n    let result = [];\n    for(let i = 0; i < expression.length; i++){\n        let char = expression[i];\n        if(char === '+' || char === '-' || char === '*'){\n            let left = diffWaysToCompute(expression.substring(0, i));\n            let right = diffWaysToCompute(expression.substring(i + 1));\n            for(let j = 0; j < left.length; j++){\n                for(let k = 0; k < right.length; k++){\n                    if(char === '+'){\n                        result.push(left[j] + right[k]);\n                    }else if(char === '-'){\n                        result.push(left[j] - right[k]);\n                    }else{\n                        result.push(left[j] * right[k]);\n                    }\n                }\n            }\n        }\n    }\n    if(result.length === 0){\n        result.push(parseInt(expression));\n    }\n    return result;\n    \n};"}
{"id": "743", "path": "output2\\js\\Medium\\743-single-number-iii.js", "hypo_code": "var singleNumber = function(nums) {\n    let len = nums.length;\n    if (len === 2) return nums;\n    let map = new Map();\n    for (let i = 0; i < len; i++) {\n        let key = nums[i];\n        if (map.has(key)) {\n            map.delete(key);\n        } else {\n            map.set(key, 1);\n        }\n    }\n    let result = [];\n    for (let key of map.keys()) {\n        result.push(key);\n    }\n    return result;\n};"}
{"id": "744", "path": "output2\\js\\Medium\\744-ugly-number-ii.js", "hypo_code": "var nthUglyNumber = function(n) {\n    let dp = new Array(n+1);\n    dp[1] = 1;\n    let p2 = 1, p3 = 1, p5 = 1;\n    for(let i = 2; i <= n; i++){\n        let num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;\n        dp[i] = Math.min(num2, num3, num5);\n        if(dp[i] === num2) p2++;\n        if(dp[i] === num3) p3++;\n        if(dp[i] === num5) p5++;\n    }\n    return dp[n];\n};"}
{"id": "745", "path": "output2\\js\\Medium\\745-h-index.js", "hypo_code": "var hIndex = function(citations) {\n    citations.sort((a,b)=>b-a);\n    let h = 0;\n    while(h < citations.length && citations[h] > h) h++;\n    return h;\n};"}
{"id": "746", "path": "output2\\js\\Medium\\746-h-index-ii.js", "hypo_code": "var hIndex = function(citations) {\n    let h = 0, l = 0, r = citations.length-1;\n    while(l <= r){\n        let mid = Math.floor((l + r) / 2);\n        if(citations[mid] >= citations.length - mid){\n            h = citations.length - mid;\n            r = mid - 1;\n        }else l = mid + 1;\n    }\n    return h;\n};"}
{"id": "747", "path": "output2\\js\\Medium\\747-perfect-squares.js", "hypo_code": "var numSquares = function(n) {\n    let dp = new Array(n+1).fill(Infinity);\n    dp[0] = 0;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j*j <= i; j++){\n            dp[i] = Math.min(dp[i], dp[i-j*j] + 1);\n        }\n    }\n    return dp[n];\n};"}
{"id": "749", "path": "output2\\js\\Medium\\749-find-the-duplicate-number.js", "hypo_code": "var findDuplicate = function(nums) {\n    let l = 1, r = nums.length-1;\n    while(l < r){\n        let mid = Math.floor((l + r) / 2), cnt = 0;\n        for(let num of nums){\n            if(num <= mid) cnt++;\n        }\n        if(cnt <= mid) l = mid + 1;\n        else r = mid;\n    }\n    return l;\n};"}
{"id": "750", "path": "output2\\js\\Medium\\750-game-of-life.js", "hypo_code": "var gameOfLife = function(board) {\n    let m = board.length, n = board[0].length;\n\tlet dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];\n\tfor(let i = 0; i < m; i++){\n\t\tfor(let j = 0; j < n; j++){\n\t\t\tlet cnt = 0;\n\t\t\tfor(let dir of dirs){\n\t\t\t\tlet x = i + dir[0], y = j + dir[1];\n\t\t\t\tif(x < 0 || x >= m || y < 0 || y >= n) continue;\n\t\t\t\tif(board[x][y] == 1 || board[x][y] == 2) cnt++;\n\t\t\t}\n\t\t\tif(board[i][j] == 1 && (cnt < 2 || cnt > 3)) board[i][j] = 2;\n\t\t\telse if(board[i][j] == 0 && cnt == 3) board[i][j] = 3;\n\t\t}\n\t}\n\tfor(let i = 0; i < m; i++){\n\t\tfor(let j = 0; j < n; j++){\n\t\t\tboard[i][j] %= 2;\n\t\t}\n\t}\n};"}
{"id": "751", "path": "output2\\js\\Medium\\751-bulls-and-cows.js", "hypo_code": "var getHint = function(secret, guess) {\n    let bulls = 0;\n    let cows = 0;\n    let map = new Map();\n    for(let i = 0; i < secret.length; i++){\n        if(secret[i] === guess[i]){\n            bulls++;\n        }else{\n            if(map.has(secret[i])){\n                map.set(secret[i], map.get(secret[i]) + 1);\n            }else{\n                map.set(secret[i], 1);\n            }\n        }\n    }\n    for(let i = 0; i < guess.length; i++){\n        if(secret[i] !== guess[i]){\n            if(map.has(guess[i]) && map.get(guess[i]) > 0){\n                cows++;\n                map.set(guess[i], map.get(guess[i]) - 1);\n            }\n        }\n    }\n    return bulls + 'A' + cows + 'B';\n    \n};"}
{"id": "752", "path": "output2\\js\\Medium\\752-longest-increasing-subsequence.js", "hypo_code": "var lengthOfLIS = function(nums) {\n    let n = nums.length;\n    let dp = new Array(n).fill(1);\n    let result = 1;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < i; j++){\n            if(nums[i] > nums[j]){\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        result = Math.max(result, dp[i]);\n    }\n    return result;\n    \n};"}
{"id": "754", "path": "output2\\js\\Medium\\754-additive-number.js", "hypo_code": "var isAdditiveNumber = function(num) {\n    let n = num.length;\n    for(let i = 1; i <= n / 2; i++){\n        for(let j = 1; j <= (n - i) / 2; j++){\n            if(isValid(i, j, num)){\n                return true;\n            }\n        }\n    }\n    return false;\n    \n    \n};"}
{"id": "756", "path": "output2\\js\\Medium\\756-best-time-to-buy-and-sell-stock-with-cooldown.js", "hypo_code": "var maxProfit = function(prices) {\n    let n = prices.length;\n    let buy = new Array(n);\n    let sell = new Array(n);\n    let cooldown = new Array(n);\n    buy[0] = -prices[0];\n    sell[0] = 0;\n    cooldown[0] = 0;\n    for(let i = 1; i < n; i++){\n        buy[i] = Math.max(buy[i - 1], cooldown[i - 1] - prices[i]);\n        sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);\n        cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]);\n    }\n    return sell[n - 1];\n    \n};"}
{"id": "757", "path": "output2\\js\\Medium\\757-minimum-height-trees.js", "hypo_code": "var findMinHeightTrees = function(n, edges) {\n    if(n == 1){\n        return [0];\n    }\n    let graph = new Array(n);\n    for(let i = 0; i < n; i++){\n        graph[i] = [];\n    }\n    for(let i = 0; i < edges.length; i++){\n        let u = edges[i][0];\n        let v = edges[i][1];\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    let leaves = [];\n    for(let i = 0; i < n; i++){\n        if(graph[i].length == 1){\n            leaves.push(i);\n        }\n    }\n    let remainingNodes = n;\n    while(remainingNodes > 2){\n        remainingNodes -= leaves.length;\n        let newLeaves = [];\n        for(let i = 0; i < leaves.length; i++){\n            let u = leaves[i];\n            for(let j = 0; j < graph[u].length; j++){\n                let v = graph[u][j];\n                let index = graph[v].indexOf(u);\n                graph[v].splice(index, 1);\n                if(graph[v].length == 1){\n                    newLeaves.push(v);\n                }\n            }\n        }\n        leaves = newLeaves;\n    }\n    return leaves;\n    \n};"}
{"id": "758", "path": "output2\\js\\Medium\\758-super-ugly-number.js", "hypo_code": "var nthSuperUglyNumber = function(n, primes) {\n    let dp = new Array(n+1), p = new Array(primes.length).fill(1);\n\tdp[1] = 1;\n\tfor(let i = 2; i <= n; i++){\n\t\tlet min = Infinity;\n\t\tfor(let j = 0; j < primes.length; j++){\n\t\t\tmin = Math.min(min, dp[p[j]] * primes[j]);\n\t\t}\n\t\tdp[i] = min;\n\t\tfor(let j = 0; j < primes.length; j++){\n\t\t\tif(dp[p[j]] * primes[j] === min) p[j]++;\n\t\t}\n\t}\n\treturn dp[n];\n};"}
{"id": "759", "path": "output2\\js\\Medium\\759-remove-duplicate-letters.js", "hypo_code": "var removeDuplicateLetters = function(s) {\n    let n = s.length;\n    let result = [];\n    let lastOccurence = new Map();\n    for(let i = 0; i < n; i++){\n        lastOccurence.set(s[i], i);\n    }\n    let visited = new Set();\n    for(let i = 0; i < n; i++){\n        let char = s[i];\n        if(!visited.has(char)){\n            while(result.length > 0 && result[result.length - 1] > char && lastOccurence.get(result[result.length - 1]) > i){\n                visited.delete(result[result.length - 1]);\n                result.pop();\n            }\n            result.push(char);\n            visited.add(char);\n        }\n    }\n    return result.join('');\n    \n};"}
{"id": "760", "path": "output2\\js\\Medium\\760-maximum-product-of-word-lengths.js", "hypo_code": "var maxProduct = function(words) {\n    let n = words.length;\n    let result = 0;\n    let masks = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < words[i].length; j++){\n            masks[i] |= 1 << (words[i].charCodeAt(j) - 97);\n        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = i + 1; j < n; j++){\n            if((masks[i] & masks[j]) == 0){\n                result = Math.max(result, words[i].length * words[j].length);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "761", "path": "output2\\js\\Medium\\761-bulb-switcher.js", "hypo_code": "var bulbSwitch = function(n) {\n    return Math.floor(Math.sqrt(n));\n    \n};"}
{"id": "762", "path": "output2\\js\\Medium\\762-coin-change.js", "hypo_code": "var coinChange = function(coins, amount) {\n    let dp = new Array(amount+1).fill(Infinity);\n    dp[0] = 0;\n    for(let i = 1; i <= amount; i++){\n        for(let coin of coins){\n            if(i - coin >= 0) dp[i] = Math.min(dp[i], dp[i-coin] + 1);\n        }\n    }\n    return dp[amount] === Infinity ? -1 : dp[amount];\n};"}
{"id": "763", "path": "output2\\js\\Medium\\763-wiggle-sort-ii.js", "hypo_code": "var wiggleSort = function(nums) {\n    let n = nums.length;\n\tnums.sort((a,b)=>a-b);\n\tlet mid = Math.floor((n-1)/2);\n\tlet tmp = [...nums];\n\tlet idx = 0;\n\tfor(let i = mid; i >= 0; i--){\n\t\tnums[idx] = tmp[i];\n\t\tif(idx+1 < n) nums[idx+1] = tmp[n-1-i];\n\t\tidx += 2;\n\t}\n\treturn nums;\n};"}
{"id": "764", "path": "output2\\js\\Medium\\764-odd-even-linked-list.js", "hypo_code": "var oddEvenList = function(head) {\n    let dummyOdd = new ListNode(0), dummyEven = new ListNode(0);\n\tlet odd = dummyOdd, even = dummyEven;\n\tlet isOdd = true;\n\twhile(head){\n\t\tif(isOdd) odd = odd.next = head;\n\t\telse even = even.next = head;\n\t\tisOdd = !isOdd;\n\t\thead = head.next;\n\t}\n\teven.next = null;\n\todd.next = dummyEven.next;\n\treturn dummyOdd.next;\n};"}
{"id": "765", "path": "output2\\js\\Medium\\765-verify-preorder-serialization-of-a-binary-tree.js", "hypo_code": "var isValidSerialization = function(preorder) {\n    let nodes = preorder.split(',');\n    let slots = 1;\n    for(let node of nodes){\n        if(slots === 0) return false;\n        if(node === '#') slots--;\n        else slots++;\n    }\n    return slots === 0;\n};"}
{"id": "766", "path": "output2\\js\\Medium\\766-increasing-triplet-subsequence.js", "hypo_code": "var increasingTriplet = function(nums) {\n    let n = nums.length;\n    let min = Number.MAX_SAFE_INTEGER, mid = Number.MAX_SAFE_INTEGER;\n    for(let num of nums){\n        if(num <= min) min = num;\n        else if(num <= mid) mid = num;\n        else return true;\n    }\n    return false;\n};"}
{"id": "767", "path": "output2\\js\\Medium\\767-house-robber-iii.js", "hypo_code": "var rob = function(root) {\n    let dfs = (root) => {\n\t\tif(!root) return [0, 0];\n\t\tlet [leftWith, leftWithout] = dfs(root.left);\n\t\tlet [rightWith, rightWithout] = dfs(root.right);\n\t\tlet withRoot = root.val + leftWithout + rightWithout;\n\t\tlet withoutRoot = Math.max(leftWith, leftWithout) + Math.max(rightWith, rightWithout);\n\t\treturn [withRoot, withoutRoot];\n\t}\n\tlet [withRoot, withoutRoot] = dfs(root);\n\treturn Math.max(withRoot, withoutRoot);\n};"}
{"id": "769", "path": "output2\\js\\Medium\\769-integer-break.js", "hypo_code": "var integerBreak = function(n) {\n    let dp = new Array(n+1).fill(1);\n    for(let i = 3; i <= n; i++){\n        for(let j = 1; j < i; j++){\n            dp[i] = Math.max(dp[i], Math.max(j, dp[j]) * Math.max(i-j, dp[i-j]));\n        }\n    }\n    return dp[n];\n};"}
{"id": "770", "path": "output2\\js\\Medium\\770-top-k-frequent-elements.js", "hypo_code": "var topKFrequent = function(nums, k) {\n    let map = new Map();\n    for(let num of nums){\n        if(map.has(num)) map.set(num, map.get(num)+1);\n        else map.set(num, 1);\n    }\n    let arr = [...map];\n    arr.sort((a,b)=>b[1]-a[1]);\n    let ans = [];\n    for(let i = 0; i < k; i++){\n        ans.push(arr[i][0]);\n    }\n    return ans;\n};"}
{"id": "772", "path": "output2\\js\\Medium\\772-count-numbers-with-unique-digits.js", "hypo_code": "var countNumbersWithUniqueDigits = function(n) {\n    let dp = new Array(n+1).fill(0);\n    dp[0] = 1;\n    for(let i = 1; i <= n; i++){\n        let count = 9;\n        for(let j = 1; j < i; j++){\n            count *= (10-j);\n        }\n        dp[i] = dp[i-1] + count;\n    }\n    return dp[n];\n};"}
{"id": "773", "path": "output2\\js\\Medium\\773-water-and-jug-problem.js", "hypo_code": "var canMeasureWater = function(jug1Capacity, jug2Capacity, targetCapacity) {\n    \n};"}
{"id": "774", "path": "output2\\js\\Medium\\774-largest-divisible-subset.js", "hypo_code": "var largestDivisibleSubset = function(nums) { \n    nums.sort((a, b) => a - b);\n    let dp = new Array(nums.length).fill(1);\n    let max = 1;\n    let maxIndex = 0;\n    for (let i = 1; i < nums.length; i++) {\n        let current = nums[i];\n        for (let j = 0; j < i; j++) {\n            if (current % nums[j] === 0) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        if (dp[i] > max) {\n            max = dp[i];\n            maxIndex = i;\n        }\n    }\n    let result = [];\n    let current = nums[maxIndex];\n    let count = max;\n    for (let i = maxIndex; i >= 0; i--) {\n        if (current % nums[i] === 0 && dp[i] === count) {\n            result.push(nums[i]);\n            current = nums[i];\n            count--;\n        }\n    }\n    return result;\n};"}
{"id": "775", "path": "output2\\js\\Medium\\775-sum-of-two-integers.js", "hypo_code": "var getSum = function(a, b) {\n    let carry = 0;\n    while(b != 0){\n        carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n    \n};"}
{"id": "776", "path": "output2\\js\\Medium\\776-super-pow.js", "hypo_code": "var superPow = function(a, b) {\n    let result = 1;\n    for(let i = 0; i < b.length; i++){\n        result = pow(result, 10) * pow(a, b[i]) % 1337;\n    }\n    return result;\n    \n    \n};"}
{"id": "777", "path": "output2\\js\\Medium\\777-find-k-pairs-with-smallest-sums.js", "hypo_code": "var kSmallestPairs = function(nums1, nums2, k) {\n    let n = nums1.length;\n    let m = nums2.length;\n    let result = [];\n    let minHeap = new MinHeap();\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            minHeap.insert([nums1[i], nums2[j]]);\n        }\n    }\n    while(k > 0 && minHeap.size() > 0){\n        result.push(minHeap.remove());\n        k--;\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "778", "path": "output2\\js\\Medium\\778-guess-number-higher-or-lower-ii.js", "hypo_code": "var getMoneyAmount = function(n) {\n    let dp = new Array(n + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for(let i = n - 1; i > 0; i--){\n        for(let j = i + 1; j <= n; j++){\n            let min = Number.MAX_SAFE_INTEGER;\n            for(let k = i; k < j; k++){\n                let temp = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min = Math.min(min, temp);\n            }\n            dp[i][j] = min;\n        }\n    }\n    return dp[1][n];\n    \n};"}
{"id": "779", "path": "output2\\js\\Medium\\779-wiggle-subsequence.js", "hypo_code": "var wiggleMaxLength = function(nums) {\n    let n = nums.length;\n    let up = new Array(n).fill(1);\n    let down = new Array(n).fill(1);\n    let result = 1;\n    for(let i = 1; i < n; i++){\n        for(let j = 0; j < i; j++){\n            if(nums[i] > nums[j]){\n                up[i] = Math.max(up[i], down[j] + 1);\n            }else if(nums[i] < nums[j]){\n                down[i] = Math.max(down[i], up[j] + 1);\n            }\n        }\n        result = Math.max(result, up[i], down[i]);\n    }\n    return result;\n    \n};"}
{"id": "780", "path": "output2\\js\\Medium\\780-combination-sum-iv.js", "hypo_code": "var combinationSum4 = function(nums, target) {\n    let dp = new Array(target + 1).fill(0);\n    dp[0] = 1;\n    for(let i = 1; i <= target; i++){\n        for(let j = 0; j < nums.length; j++){\n            if(i - nums[j] >= 0){\n                dp[i] += dp[i - nums[j]];\n            }\n        }\n    }\n    return dp[target];\n    \n};"}
{"id": "781", "path": "output2\\js\\Medium\\781-kth-smallest-element-in-a-sorted-matrix.js", "hypo_code": "var kthSmallest = function(matrix, k) {\n    let n = matrix.length;\n    let minHeap = new MinHeap();\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            minHeap.insert(matrix[i][j]);\n        }\n    }\n    let result = 0;\n    while(k > 0 && minHeap.size() > 0){\n        result = minHeap.remove();\n        k--;\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "785", "path": "output2\\js\\Medium\\785-mini-parser.js", "hypo_code": "var deserialize = function(s) { \n    if (s[0] !== '[') {\n        return new NestedInteger(Number(s));\n    }\n    let stack = [];\n    let current = null;\n    let start = 0;\n    for (let i = 0; i < s.length; i++) {\n        let char = s[i];\n        if (char === '[') {\n            let nestedInteger = new NestedInteger();\n            if (current !== null) {\n                current.add(nestedInteger);\n            }\n            stack.push(current);\n            current = nestedInteger;\n            start = i + 1;\n        } else if (char === ',' || char === ']') {\n            if (i > start) {\n                let value = Number(s.substring(start, i));\n                let nestedInteger = new NestedInteger(value);\n                current.add(nestedInteger);\n            }\n            start = i + 1;\n            if (char === ']') {\n                current = stack.pop();\n            }\n        }\n    }\n    return current;\n};"}
{"id": "786", "path": "output2\\js\\Medium\\786-lexicographical-numbers.js", "hypo_code": "var lexicalOrder = function(n) {\n    let result = [];\n    for(let i = 1; i < 10; i++){\n        dfs(i, n, result);\n    }\n    return result;\n    \n    \n};"}
{"id": "787", "path": "output2\\js\\Medium\\787-longest-absolute-file-path.js", "hypo_code": "var lengthLongestPath = function(input) { \n    let stack = [];\n    let max = 0;\n    let lines = input.split('\\n');\n    for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        let level = line.lastIndexOf('\\t') + 1;\n        while (level < stack.length) {\n            stack.pop();\n        }\n        let current = line.substring(level);\n        if (current.indexOf('.') !== -1) {\n            max = Math.max(max, stack.reduce((a, b) => a + b, 0) + current.length);\n        } else {\n            stack.push(current.length + 1);\n        }\n    }\n    return max;\n};"}
{"id": "788", "path": "output2\\js\\Medium\\788-elimination-game.js", "hypo_code": "var lastRemaining = function(n) {\n    let head = 1;\n    let step = 1;\n    let remaining = n;\n    let left = true;\n    while(remaining > 1){\n        if(left || remaining % 2 == 1){\n            head += step;\n        }\n        remaining = Math.floor(remaining / 2);\n        step *= 2;\n        left = !left;\n    }\n    return head;\n    \n    \n};"}
{"id": "789", "path": "output2\\js\\Medium\\789-utf-8-validation.js", "hypo_code": "var validUtf8 = function(data) {\n    let n = data.length;\n    let count = 0;\n    for(let i = 0; i < n; i++){\n        if(count == 0){\n            if((data[i] >> 5) == 0b110){\n                count = 1;\n            }else if((data[i] >> 4) == 0b1110){\n                count = 2;\n            }else if((data[i] >> 3) == 0b11110){\n                count = 3;\n            }else if((data[i] >> 7)){\n                return false;\n            }\n        }else{\n            if((data[i] >> 6) != 0b10){\n                return false;\n            }\n            count--;\n        }\n    }\n    return count == 0;\n    \n};"}
{"id": "790", "path": "output2\\js\\Medium\\790-decode-string.js", "hypo_code": "var decodeString = function(s) {\n    let n = s.length;\n    let stack = [];\n    let num = 0;\n    let result = \"\";\n    for(let i = 0; i < n; i++){\n        if(!isNaN(s[i])){\n            num = num * 10 + parseInt(s[i]);\n        }else if(s[i] == \"[\"){\n            stack.push(result);\n            stack.push(num);\n            result = \"\";\n            num = 0;\n        }else if(s[i] == \"]\"){\n            let count = stack.pop();\n            let prev = stack.pop();\n            result = prev + result.repeat(count);\n        }else{\n            result += s[i];\n        }\n    }\n    return result;\n    \n};"}
{"id": "791", "path": "output2\\js\\Medium\\791-longest-substring-with-at-least-k-repeating-characters.js", "hypo_code": "var longestSubstring = function(s, k) {\n    let n = s.length;\n    let result = 0;\n    for(let i = 0; i <= n - k; i++){\n        let map = new Map();\n        let max = 0;\n        let min = n;\n        for(let j = i; j < n; j++){\n            if(map.has(s[j])){\n                map.set(s[j], map.get(s[j]) + 1);\n            }else{\n                map.set(s[j], 1);\n            }\n            if(map.get(s[j]) > max){\n                max = map.get(s[j]);\n            }\n            if(map.get(s[j]) < min){\n                min = map.get(s[j]);\n            }\n            if(max - min >= k){\n                result = Math.max(result, j - i + 1);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "792", "path": "output2\\js\\Medium\\792-rotate-function.js", "hypo_code": "var maxRotateFunction = function(nums) {\n    let n = nums.length;\n    let sum = 0;\n    let f = 0;\n    for(let i = 0; i < n; i++){\n        sum += nums[i];\n        f += i * nums[i];\n    }\n    let result = f;\n    for(let i = n - 1; i >= 1; i--){\n        f = f + sum - n * nums[i];\n        result = Math.max(result, f);\n    }\n    return result;\n    \n};"}
{"id": "793", "path": "output2\\js\\Medium\\793-integer-replacement.js", "hypo_code": "var integerReplacement = function(n) {\n    let count = 0;\n    while(n != 1){\n        if(n % 2 == 0){\n            n /= 2;\n        }else{\n            if(n == 3 || (n & 2) == 0){\n                n--;\n            }else{\n                n++;\n            }\n        }\n        count++;\n    }\n    return count;\n    \n};"}
{"id": "795", "path": "output2\\js\\Medium\\795-evaluate-division.js", "hypo_code": "var calcEquation = function(equations, values, queries) {\n    let result = [];\n    let map = new Map();\n    for(let i = 0; i < equations.length; i++){\n        let [a, b] = equations[i];\n        let value = values[i];\n        if(!map.has(a)){\n            map.set(a, new Map());\n        }\n        if(!map.has(b)){\n            map.set(b, new Map());\n        }\n        map.get(a).set(b, value);\n        map.get(b).set(a, 1 / value);\n    }\n    for(let i = 0; i < queries.length; i++){\n        let [a, b] = queries[i];\n        if(!map.has(a) || !map.has(b)){\n            result.push(-1);\n        }else{\n            let visited = new Set();\n            let value = dfs(a, b, map, visited);\n            result.push(value);\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "796", "path": "output2\\js\\Medium\\796-nth-digit.js", "hypo_code": "var findNthDigit = function(n) {\n    let count = 9;\n    let digits = 1;\n    let start = 1;\n    while(n > count){\n        n -= count;\n        digits++;\n        start *= 10;\n        count = 9 * start * digits;\n    }\n    let num = start + Math.floor((n - 1) / digits);\n    let index = (n - 1) % digits;\n    return parseInt(num.toString().charAt(index));    \n};"}
{"id": "797", "path": "output2\\js\\Medium\\797-remove-k-digits.js", "hypo_code": "var removeKdigits = function(num, k) {\n    let n = num.length;\n    let stack = [];\n    let i = 0;\n    while(i < n){\n        while(k > 0 && stack.length > 0 && stack[stack.length - 1] > num[i]){\n            stack.pop();\n            k--;\n        }\n        stack.push(num[i]);\n        i++;\n    }\n    while(k > 0){\n        stack.pop();\n        k--;\n    }\n    let result = \"\";\n    while(stack.length > 0){\n        result = stack.pop() + result;\n    }\n    while(result.length > 1 && result.charAt(0) == \"0\"){\n        result = result.substring(1);\n    }\n    return result == \"\" ? \"0\" : result;\n    \n};"}
{"id": "798", "path": "output2\\js\\Medium\\798-queue-reconstruction-by-height.js", "hypo_code": "var reconstructQueue = function(people) {\n    people.sort((a, b) => {\n        if(a[0] === b[0]){\n            return a[1] - b[1];\n        }else{\n            return b[0] - a[0];\n        }\n    });\n    let result = [];\n    for(let i = 0; i < people.length; i++){\n        let [h, k] = people[i];\n        result.splice(k, 0, people[i]);\n    }\n    return result;\n    \n};"}
{"id": "799", "path": "output2\\js\\Medium\\799-arithmetic-slices.js", "hypo_code": "var numberOfArithmeticSlices = function(nums) {\n    let n = nums.length;\n    let dp = new Array(n).fill(0);\n    let result = 0;\n    for(let i = 2; i < n; i++){\n        if(nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]){\n            dp[i] = dp[i - 1] + 1;\n        }\n        result += dp[i];\n    }\n    return result;\n    \n};"}
{"id": "800", "path": "output2\\js\\Medium\\800-partition-equal-subset-sum.js", "hypo_code": "var canPartition = function(nums) {\n    let n = nums.length;\n    let sum = 0;\n    for(let i = 0; i < n; i++){\n        sum += nums[i];\n    }\n    if(sum % 2 == 1){\n        return false;\n    }\n    sum /= 2;\n    let dp = new Array(n + 1).fill(false);\n    dp[0] = true;\n    for(let i = 0; i < n; i++){\n        for(let j = sum; j >= nums[i]; j--){\n            dp[j] = dp[j] || dp[j - nums[i]];\n        }\n    }\n    return dp[sum];\n    \n};"}
{"id": "801", "path": "output2\\js\\Medium\\801-pacific-atlantic-water-flow.js", "hypo_code": "var pacificAtlantic = function(heights) {\n    let m = heights.length;\n    let n = heights[0].length;\n    let pacific = new Array(m).fill(0);\n    let atlantic = new Array(m).fill(0);\n    for(let i = 0; i < m; i++){\n        pacific[i] = new Array(n).fill(0);\n        atlantic[i] = new Array(n).fill(0);\n    }\n    for(let i = 0; i < m; i++){\n        dfs(heights, pacific, i, 0, heights[i][0]);\n        dfs(heights, atlantic, i, n - 1, heights[i][n - 1]);\n    }\n    for(let i = 0; i < n; i++){\n        dfs(heights, pacific, 0, i, heights[0][i]);\n        dfs(heights, atlantic, m - 1, i, heights[m - 1][i]);\n    }\n    let result = [];\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(pacific[i][j] === 1 && atlantic[i][j] === 1){\n                result.push([i, j]);\n            }\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "802", "path": "output2\\js\\Medium\\802-battleships-in-a-board.js", "hypo_code": "var countBattleships = function(board) {\n    let count = 0;\n    for (let i = 0; i < board.length; i++) {\n        let row = board[i];\n        for (let j = 0; j < row.length; j++) {\n            let cell = row[j];\n            if (cell === 'X') {\n                if (i === 0 && j === 0) {\n                    count++;\n                } else if (i === 0) {\n                    if (row[j - 1] !== 'X') {\n                        count++;\n                    }\n                } else if (j === 0) {\n                    if (board[i - 1][j] !== 'X') {\n                        count++;\n                    }\n                } else {\n                    if (row[j - 1] !== 'X' && board[i - 1][j] !== 'X') {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n};"}
{"id": "803", "path": "output2\\js\\Medium\\803-maximum-xor-of-two-numbers-in-an-array.js", "hypo_code": "var findMaximumXOR = function(nums) {\n    let max = 0;\n    let mask = 0;\n    for (let i = 31; i >= 0; i--) {\n        mask = mask | (1 << i);\n        let set = new Set();\n        for (let j = 0; j < nums.length; j++) {\n            set.add(nums[j] & mask);\n        }\n        let temp = max | (1 << i);\n        for (let prefix of set) {\n            if (set.has(temp ^ prefix)) {\n                max = temp;\n                break;\n            }\n        }\n    }\n    return max;\n};"}
{"id": "804", "path": "output2\\js\\Medium\\804-reconstruct-original-digits-from-english.js", "hypo_code": "var originalDigits = function(s) {\n    let map = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let char = s[i];\n        if (map.has(char)) {\n            map.set(char, map.get(char) + 1);\n        } else {\n            map.set(char, 1);\n        }\n    }\n    let result = [];\n    let digits = [\n        ['z', 'zero', 0],\n        ['w', 'two', 2],\n        ['u', 'four', 4],\n        ['x', 'six', 6],\n        ['g', 'eight', 8],\n        ['o', 'one', 1],\n        ['t', 'three', 3],\n        ['f', 'five', 5],\n        ['s', 'seven', 7],\n        ['i', 'nine', 9]\n    ];\n    for (let i = 0; i < digits.length; i++) {\n        let digit = digits[i];\n        let char = digit[0];\n        let word = digit[1];\n        let num = digit[2];\n        let count = map.get(char);\n        if (count) {\n            for (let j = 0; j < word.length; j++) {\n                let char = word[j];\n                map.set(char, map.get(char) - count);\n            }\n            for (let j = 0; j < count; j++) {\n                result.push(num);\n            }\n        }\n    }\n    return result.sort((a, b) => a - b).join('');\n};"}
{"id": "805", "path": "output2\\js\\Medium\\805-longest-repeating-character-replacement.js", "hypo_code": "var characterReplacement = function(s, k) { \n    let map = new Map();\n    let start = 0;\n    let maxCount = 0;\n    let maxLength = 0;\n    for (let end = 0; end < s.length; end++) {\n        let char = s[end];\n        if (map.has(char)) {\n            map.set(char, map.get(char) + 1);\n        } else {\n            map.set(char, 1);\n        }\n        maxCount = Math.max(maxCount, map.get(char));\n        while (end - start + 1 - maxCount > k) {\n            let char = s[start];\n            map.set(char, map.get(char) - 1);\n            start++;\n        }\n        maxLength = Math.max(maxLength, end - start + 1);\n    }\n    return maxLength;\n};"}
{"id": "807", "path": "output2\\js\\Medium\\807-n-ary-tree-level-order-traversal.js", "hypo_code": "var levelOrder = function(root) {\n    if (!root) return [];\n    let result = [];\n    let queue = [root];\n    while (queue.length) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let node = queue.shift();\n            current.push(node.val);\n            for (let j = 0; j < node.children.length; j++) {\n                queue.push(node.children[j]);\n            }\n        }\n        result.push(current);\n    }\n    return result;\n};"}
{"id": "809", "path": "output2\\js\\Medium\\809-minimum-genetic-mutation.js", "hypo_code": "var minMutation = function(startGene, endGene, bank) {\n    let queue = [startGene];\n    let visited = new Set();\n    let count = 0;\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let gene = queue.shift();\n            if(gene == endGene){\n                return count;\n            }\n            for(let j = 0; j < bank.length; j++){\n                if(!visited.has(j) && isValid(gene, bank[j])){\n                    visited.add(j);\n                    queue.push(bank[j]);\n                }\n            }\n        }\n        count++;\n    }\n    return -1;\n    \n    \n    \n};"}
{"id": "810", "path": "output2\\js\\Medium\\810-non-overlapping-intervals.js", "hypo_code": "var eraseOverlapIntervals = function(intervals) {\n    let n = intervals.length;\n    if(n == 0){\n        return 0;\n    }\n    intervals.sort((a, b) => a[1] - b[1]);\n    let count = 1;\n    let end = intervals[0][1];\n    for(let i = 1; i < n; i++){\n        if(intervals[i][0] >= end){\n            count++;\n            end = intervals[i][1];\n        }\n    }\n    return n - count;\n    \n};"}
{"id": "811", "path": "output2\\js\\Medium\\811-find-right-interval.js", "hypo_code": "var findRightInterval = function(intervals) {\n    let n = intervals.length;\n    let result = [];\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        let [start, end] = intervals[i];\n        map.set(start, i);\n    }\n    let sorted = [...map.keys()].sort((a, b) => a - b);\n    for(let i = 0; i < n; i++){\n        let [start, end] = intervals[i];\n        let index = binarySearch(sorted, end);\n        if(index == -1){\n            result.push(-1);\n        }else{\n            result.push(map.get(sorted[index]));\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "812", "path": "output2\\js\\Medium\\812-path-sum-iii.js", "hypo_code": "var pathSum = function(root, targetSum) {\n    let count = 0;\n    let map = new Map();\n    map.set(0, 1);\n    function dfs(root, sum){\n        if(root == null){\n            return;\n        }\n        sum += root.val;\n        if(map.has(sum - targetSum)){\n            count += map.get(sum - targetSum);\n        }\n        map.set(sum, map.has(sum) ? map.get(sum) + 1 : 1);\n        dfs(root.left, sum);\n        dfs(root.right, sum);\n        map.set(sum, map.get(sum) - 1);\n    }\n    dfs(root, 0);\n    return count;\n    \n};"}
{"id": "813", "path": "output2\\js\\Medium\\813-find-all-anagrams-in-a-string.js", "hypo_code": "var findAnagrams = function(s, p) {\n    let n = s.length;\n    let m = p.length;\n    let result = [];\n    if(n < m){\n        return result;\n    }\n    let pMap = new Map();\n    let sMap = new Map();\n    for(let i = 0; i < m; i++){\n        let pChar = p[i];\n        let sChar = s[i];\n        if(pMap.has(pChar)){\n            pMap.set(pChar, pMap.get(pChar) + 1);\n        }else{\n            pMap.set(pChar, 1);\n        }\n        if(sMap.has(sChar)){\n            sMap.set(sChar, sMap.get(sChar) + 1);\n        }else{\n            sMap.set(sChar, 1);\n        }\n    }\n    if(isEqual(pMap, sMap)){\n        result.push(0);\n    }\n    for(let i = m; i < n; i++){\n        let sChar = s[i];\n        let sPrevChar = s[i - m];\n        if(sMap.has(sChar)){\n            sMap.set(sChar, sMap.get(sChar) + 1);\n        }else{\n            sMap.set(sChar, 1);\n        }\n        if(sMap.get(sPrevChar) == 1){\n            sMap.delete(sPrevChar);\n        }else{\n            sMap.set(sPrevChar, sMap.get(sPrevChar) - 1);\n        }\n        if(isEqual(pMap, sMap)){\n            result.push(i - m + 1);\n        }\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "814", "path": "output2\\js\\Medium\\814-find-all-duplicates-in-an-array.js", "hypo_code": "var findDuplicates = function(nums) {\n    let result = [];\n    for (let i = 0; i < nums.length; i++) {\n        let index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            result.push(index + 1);\n        }\n        nums[index] = -nums[index];\n    }\n    return result;\n};"}
{"id": "815", "path": "output2\\js\\Medium\\815-string-compression.js", "hypo_code": "var compress = function(chars) {\n    let start = 0;\n    let end = 0;\n    while (end < chars.length) {\n        let char = chars[end];\n        let count = 0;\n        while (end < chars.length && chars[end] === char) {\n            end++;\n            count++;\n        }\n        chars[start] = char;\n        start++;\n        if (count > 1) {\n            for (let digit of count.toString()) {\n                chars[start] = digit;\n                start++;\n            }\n        }\n    }\n    return start;\n};"}
{"id": "816", "path": "output2\\js\\Medium\\816-add-two-numbers-ii.js", "hypo_code": "var addTwoNumbers = function(l1, l2) {\n    let result = new ListNode();\n    let current = result;\n    let carry = 0;\n    while(l1 != null || l2 != null){\n        let sum = carry;\n        if(l1 != null){\n            sum += l1.val;\n            l1 = l1.next;\n        }\n        if(l2 != null){\n            sum += l2.val;\n            l2 = l2.next;\n        }\n        carry = Math.floor(sum / 10);\n        current.next = new ListNode(sum % 10);\n        current = current.next;\n    }\n    if(carry > 0){\n        current.next = new ListNode(carry);\n    }\n    return result.next;\n    \n};"}
{"id": "817", "path": "output2\\js\\Medium\\817-number-of-boomerangs.js", "hypo_code": "var numberOfBoomerangs = function(points) {\n    let n = points.length;\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        let map = new Map();\n        for(let j = 0; j < n; j++){\n            if(i == j){\n                continue;\n            }\n            let distance = getDistance(points[i], points[j]);\n            if(map.has(distance)){\n                map.set(distance, map.get(distance) + 1);\n            }else{\n                map.set(distance, 1);\n            }\n        }\n        for(let [key, value] of map){\n            result += value * (value - 1);\n        }\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "819", "path": "output2\\js\\Medium\\819-delete-node-in-a-bst.js", "hypo_code": "var deleteNode = function(root, key) {\n    if(root == null){\n        return null;\n    }\n    if(root.val == key){\n        if(root.left == null){\n            return root.right;\n        }\n        if(root.right == null){\n            return root.left;\n        }\n        let temp = root.right;\n        while(temp.left != null){\n            temp = temp.left;\n        }\n        root.val = temp.val;\n        root.right = deleteNode(root.right, temp.val);\n    }\n    else if(root.val > key){\n        root.left = deleteNode(root.left, key);\n    }\n    else{\n        root.right = deleteNode(root.right, key);\n    }\n    return root;\n    \n};"}
{"id": "820", "path": "output2\\js\\Medium\\820-sort-characters-by-frequency.js", "hypo_code": "var frequencySort = function(s) {\n    let map = new Map();\n    for(let i = 0; i < s.length; i++){\n        let count = map.get(s[i]) || 0;\n        map.set(s[i], count + 1);\n    }\n    let arr = [];\n    for(let [key, value] of map){\n        arr.push([key, value]);\n    }\n    arr.sort((a, b) => b[1] - a[1]);\n    let result = \"\";\n    for(let i = 0; i < arr.length; i++){\n        result += arr[i][0].repeat(arr[i][1]);\n    }\n    return result;\n    \n};"}
{"id": "821", "path": "output2\\js\\Medium\\821-minimum-number-of-arrows-to-burst-balloons.js", "hypo_code": "var findMinArrowShots = function(points) {\n    \n};"}
{"id": "822", "path": "output2\\js\\Medium\\822-minimum-moves-to-equal-array-elements.js", "hypo_code": "var minMoves = function(nums) {\n    let n = nums.length;\n    let min = nums[0];\n    let sum = 0;\n    for(let i = 0; i < n; i++){\n        min = Math.min(min, nums[i]);\n        sum += nums[i];\n    }\n    return sum - min * n;\n    \n};"}
{"id": "823", "path": "output2\\js\\Medium\\823-4sum-ii.js", "hypo_code": "var fourSumCount = function(nums1, nums2, nums3, nums4) {\n    let n = nums1.length;\n    let map = new Map();\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            let sum = nums1[i] + nums2[j];\n            map.set(sum, map.has(sum) ? map.get(sum) + 1 : 1);\n        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            let sum = -(nums3[i] + nums4[j]);\n            result += map.has(sum) ? map.get(sum) : 0;\n        }\n    }\n    return result;\n    \n};"}
{"id": "824", "path": "output2\\js\\Medium\\824-132-pattern.js", "hypo_code": "var find132pattern = function(nums) {\n    let n = nums.length;\n    let min = new Array(n).fill(0);\n    min[0] = nums[0];\n    for(let i = 1; i < n; i++){\n        min[i] = Math.min(min[i - 1], nums[i]);\n    }\n    let stack = [];\n    for(let i = n - 1; i >= 0; i--){\n        if(nums[i] > min[i]){\n            while(stack.length != 0 && stack[stack.length - 1] <= min[i]){\n                stack.pop();\n            }\n            if(stack.length != 0 && stack[stack.length - 1] < nums[i]){\n                return true;\n            }\n            stack.push(nums[i]);\n        }\n    }\n    return false;\n    \n};"}
{"id": "825", "path": "output2\\js\\Medium\\825-circular-array-loop.js", "hypo_code": "var circularArrayLoop = function(nums) {\n    let n = nums.length;\n    let next = (i) => {\n        return ((i + nums[i]) % n + n) % n;\n    }\n    for(let i = 0; i < n; i++){\n        if(nums[i] == 0){\n            continue;\n        }\n        let slow = i;\n        let fast = next(i);\n        while(nums[slow] * nums[fast] > 0 && nums[slow] * nums[next(fast)] > 0){\n            if(slow == fast){\n                if(slow != next(slow)){\n                    return true;\n                }\n                else{\n                    break;\n                }\n            }\n            slow = next(slow);\n            fast = next(next(fast));\n        }\n        let add = i;\n        while(nums[add] * nums[next(add)] > 0){\n            let tmp = add;\n            add = next(add);\n            nums[tmp] = 0;\n        }\n    }\n    return false;\n    \n};"}
{"id": "826", "path": "output2\\js\\Medium\\826-minimum-moves-to-equal-array-elements-ii.js", "hypo_code": "var minMoves2 = function(nums) {\n    let n = nums.length;\n    nums.sort((a, b) => a - b);\n    let median = nums[Math.floor(n / 2)];\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        result += Math.abs(nums[i] - median);\n    }\n    return result;\n    \n};"}
{"id": "827", "path": "output2\\js\\Medium\\827-can-i-win.js", "hypo_code": "var canIWin = function(maxChoosableInteger, desiredTotal) {\n    if(desiredTotal <= maxChoosableInteger){\n        return true;\n    }\n    if((maxChoosableInteger + 1) * maxChoosableInteger / 2 < desiredTotal){\n        return false;\n    }\n    let map = new Map();\n    return helper(map, maxChoosableInteger, desiredTotal, 0);\n    \n    \n};"}
{"id": "828", "path": "output2\\js\\Medium\\828-unique-substrings-in-wraparound-string.js", "hypo_code": "var findSubstringInWraproundString = function(s) {\n    let n = s.length;\n    let dp = new Array(26).fill(0);\n    let result = 0;\n    let count = 0;\n    for(let i = 0; i < n; i++){\n        if(i > 0 && (s.charCodeAt(i) - s.charCodeAt(i - 1) == 1 || s.charCodeAt(i - 1) - s.charCodeAt(i) == 25)){\n            count++;\n        }else{\n            count = 1;\n        }\n        let index = s.charCodeAt(i) - 'a'.charCodeAt(0);\n        dp[index] = Math.max(dp[index], count);\n    }\n    for(let i = 0; i < 26; i++){\n        result += dp[i];\n    }\n    return result;\n    \n};"}
{"id": "829", "path": "output2\\js\\Medium\\829-validate-ip-address.js", "hypo_code": "var validIPAddress = function(queryIP) {\n    if(queryIP.includes(\".\")){\n        return validateIPv4(queryIP);\n    }else if(queryIP.includes(\":\")){\n        return validateIPv6(queryIP);\n    }else{\n        return \"Neither\";\n    }\n    \n    \n};"}
{"id": "830", "path": "output2\\js\\Medium\\830-implement-rand10-using-rand7.js", "hypo_code": "var rand10 = function() {\n    let row = 0;\n    let col = 0;\n    let idx = 0;\n    do{\n        row = rand7();\n        col = rand7();\n        idx = col + (row - 1) * 7;\n    }while(idx > 40);\n    return 1 + (idx - 1) % 10;\n    \n};"}
{"id": "831", "path": "output2\\js\\Medium\\831-matchsticks-to-square.js", "hypo_code": "var makesquare = function(matchsticks) {\n    let n = matchsticks.length;\n    if(n < 4){\n        return false;\n    }\n    let sum = 0;\n    for(let i = 0; i < n; i++){\n        sum += matchsticks[i];\n    }\n    if(sum % 4 != 0){\n        return false;\n    }\n    let target = sum / 4;\n    matchsticks.sort((a, b) => b - a);\n    let sides = new Array(4).fill(0);\n    return dfs(matchsticks, sides, 0, target);\n    \n    \n};"}
{"id": "832", "path": "output2\\js\\Medium\\832-ones-and-zeroes.js", "hypo_code": "var findMaxForm = function(strs, m, n) {\n    let dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for(let str of strs){\n        let [zero, one] = getZeroOne(str);\n        for(let i = m; i >= zero; i--){\n            for(let j = n; j >= one; j--){\n                dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + 1);\n            }\n        }\n    }\n    return dp[m][n];\n    \n    \n    \n};"}
{"id": "833", "path": "output2\\js\\Medium\\833-heaters.js", "hypo_code": "var findRadius = function(houses, heaters) {\n    let n = houses.length;\n    let m = heaters.length;\n    heaters.sort((a, b) => a - b);\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        let left = 0;\n        let right = m - 1;\n        while(left < right){\n            let mid = Math.floor((left + right) / 2);\n            if(heaters[mid] < houses[i]){\n                left = mid + 1;\n            }\n            else{\n                right = mid;\n            }\n        }\n        let dist1 = Math.abs(heaters[left] - houses[i]);\n        let dist2 = left > 0 ? Math.abs(heaters[left - 1] - houses[i]) : Number.MAX_SAFE_INTEGER;\n        result = Math.max(result, Math.min(dist1, dist2));\n    }\n    return result;\n    \n};"}
{"id": "834", "path": "output2\\js\\Medium\\834-total-hamming-distance.js", "hypo_code": "var totalHammingDistance = function(nums) {\n    let n = nums.length;\n    let result = 0;\n    for(let i = 0; i < 32; i++){\n        let count = 0;\n        for(let j = 0; j < n; j++){\n            count += (nums[j] >> i) & 1;\n        }\n        result += count * (n - count);\n    }\n    return result;\n    \n};"}
{"id": "836", "path": "output2\\js\\Medium\\836-magical-string.js", "hypo_code": "var magicalString = function(n) {\n    let s = \"122\";\n    let i = 2;\n    while(s.length < n){\n        let repeat = s[i] == \"1\" ? \"2\" : \"1\";\n        s += repeat.repeat(s[i + 1]);\n        i++;\n    }\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        if(s[i] == \"1\"){\n            result++;\n        }\n    }\n    return result;\n    \n};"}
{"id": "837", "path": "output2\\js\\Medium\\837-predict-the-winner.js", "hypo_code": "var predictTheWinner = function(nums) {\n    let dp = new Array(nums.length).fill(0).map(() => new Array(nums.length).fill(0));\n    for (let i = 0; i < nums.length; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (let i = nums.length - 2; i >= 0; i--) {\n        for (let j = i + 1; j < nums.length; j++) {\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][nums.length - 1] >= 0;\n};"}
{"id": "838", "path": "output2\\js\\Medium\\838-non-decreasing-subsequences.js", "hypo_code": "var findSubsequences = function(nums) {\n    let result = [];\n    let current = [];\n    let visited = new Set();\n    dfs(nums, 0, current, visited, result);\n    return result;\n};\nfunction dfs(nums, index, current, visited, result) {\n    if (current.length > 1) {\n        result.push(current.slice());\n    }\n    for (let i = index; i < nums.length; i++) {\n        if (visited.has(i) || (current.length && nums[i] < current[current.length - 1])) {\n            continue;\n        }\n        visited.add(i);\n        current.push(nums[i]);\n        dfs(nums, i + 1, current, visited, result);\n        current.pop();\n        visited.delete(i);\n    }\n}"}
{"id": "839", "path": "output2\\js\\Medium\\839-target-sum.js", "hypo_code": "var findTargetSumWays = function(nums, target) {\n    let sum = nums.reduce((a, b) => a + b);\n    if (target > sum || (target + sum) % 2 === 1) {\n        return 0;\n    }\n    let total = (target + sum) / 2;\n    let dp = new Array(total + 1).fill(0);\n    dp[0] = 1;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = total; j >= nums[i]; j--) {\n            dp[j] += dp[j - nums[i]];\n        }\n    }\n    return dp[total];\n};"}
{"id": "841", "path": "output2\\js\\Medium\\841-diagonal-traverse.js", "hypo_code": "var findDiagonalOrder = function(mat) {\n    let result = [];\n    let m = mat.length;\n    let n = mat[0].length;\n    let i = 0;\n    let j = 0;\n    let direction = 1;\n    while (result.length < m * n) {\n        result.push(mat[i][j]);\n        if (direction === 1) {\n            if (j === n - 1) {\n                direction = -1;\n                i++;\n            } else if (i === 0) {\n                direction = -1;\n                j++;\n            } else {\n                i--;\n                j++;\n            }\n        } else {\n            if (i === m - 1) {\n                direction = 1;\n                j++;\n            } else if (j === 0) {\n                direction = 1;\n                i++;\n            } else {\n                i++;\n                j--;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "842", "path": "output2\\js\\Medium\\842-next-greater-element-ii.js", "hypo_code": "var nextGreaterElements = function(nums) {\n    let result = new Array(nums.length).fill(-1);\n    let stack = [];\n    for (let i = 0; i < nums.length * 2; i++) {\n        let index = i % nums.length;\n        while (stack.length && nums[index] > nums[stack[stack.length - 1]]) {\n            result[stack.pop()] = nums[index];\n        }\n        stack.push(index);\n    }\n    return result;\n};"}
{"id": "843", "path": "output2\\js\\Medium\\843-most-frequent-subtree-sum.js", "hypo_code": "var findFrequentTreeSum = function(root) {\n    let map = {};\n    let max = -Infinity;\n    let result = [];\n    let postOrder = (node) => {\n        if (!node) return 0;\n        let left = postOrder(node.left);\n        let right = postOrder(node.right);\n        let sum = left + right + node.val;\n        map[sum] = map[sum] + 1 || 1;\n        max = Math.max(max, map[sum]);\n        return sum;\n    };\n    postOrder(root);\n    for (let key in map) {\n        if (map[key] === max) result.push(key);\n    }\n    return result;\n};"}
{"id": "844", "path": "output2\\js\\Medium\\844-find-bottom-left-tree-value.js", "hypo_code": "var findBottomLeftValue = function(root) {\n    let queue = [root];\n    let result = root.val;\n    while (queue.length) {\n        let size = queue.length;\n        result = queue[0].val;\n        for (let i = 0; i < size; i++) {\n            let node = queue.shift();\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n    }\n    return result;\n};"}
{"id": "845", "path": "output2\\js\\Medium\\845-find-largest-value-in-each-tree-row.js", "hypo_code": "var largestValues = function(root) {\n    let result = [];\n\tlet queue = [root];\n\twhile (queue.length) {\n\t\tlet size = queue.length;\n\t\tlet max = -Infinity;\n\t\tfor (let i = 0; i < size; i++) {\n\t\t\tlet node = queue.shift();\n\t\t\tmax = Math.max(max, node.val);\n\t\t\tif (node.left) queue.push(node.left);\n\t\t\tif (node.right) queue.push(node.right);\n\t\t}\n\t\tresult.push(max);\n\t}\n\treturn result;\n};"}
{"id": "846", "path": "output2\\js\\Medium\\846-longest-palindromic-subsequence.js", "hypo_code": "var longestPalindromeSubseq = function(s) {\n    let n = s.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    for (let i = n - 1; i >= 0; i--) {\n        dp[i][i] = 1;\n        for (let j = i + 1; j < n; j++) {\n            if (s[i] === s[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][n - 1];\n};"}
{"id": "847", "path": "output2\\js\\Medium\\847-coin-change-ii.js", "hypo_code": "var change = function(amount, coins) {\n    let dp = new Array(amount + 1).fill(0);\n\tdp[0] = 1;\n\tfor (let i = 0; i < coins.length; i++) {\n\t\tfor (let j = coins[i]; j <= amount; j++) {\n\t\t\tdp[j] += dp[j - coins[i]];\n\t\t}\n\t}\n\treturn dp[amount];\n};"}
{"id": "849", "path": "output2\\js\\Medium\\849-longest-uncommon-subsequence-ii.js", "hypo_code": "var findLUSlength = function(strs) {\n    let result = -1;\n    for (let i = 0; i < strs.length; i++) {\n        let j = 0;\n        for (; j < strs.length; j++) {\n            if (i === j) {\n                continue;\n            }\n            if (isSubsequence(strs[i], strs[j])) {\n                break;\n            }\n        }\n        if (j === strs.length) {\n            result = Math.max(result, strs[i].length);\n        }\n    }\n    return result;\n};"}
{"id": "850", "path": "output2\\js\\Medium\\850-continuous-subarray-sum.js", "hypo_code": "var checkSubarraySum = function(nums, k) {\n    let sum = 0;\n\tlet map = new Map();\n\tmap.set(0, -1);\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tsum += nums[i];\n\t\tif (k !== 0) {\n\t\t\tsum = sum % k;\n\t\t}\n\t\tif (map.has(sum)) {\n\t\t\tif (i - map.get(sum) > 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tmap.set(sum, i);\n\t\t}\n\t}\n\treturn false;\n};"}
{"id": "851", "path": "output2\\js\\Medium\\851-longest-word-in-dictionary-through-deleting.js", "hypo_code": "var findLongestWord = function(s, dictionary) {\n    let result = '';\n    for (let word of dictionary) {\n        if (word.length < result.length || (word.length === result.length && word > result)) {\n            continue;\n        }\n        if (isSubsequence(s, word)) {\n            result = word;\n        }\n    }\n    return result;\n};"}
{"id": "852", "path": "output2\\js\\Medium\\852-contiguous-array.js", "hypo_code": "var findMaxLength = function(nums) {\n    let count = 0;\n    let map = new Map();\n    let max = 0;\n    map.set(0, -1);\n    for (let i = 0; i < nums.length; i++) {\n        count += nums[i] ? 1 : -1;\n        if (map.has(count)) {\n            max = Math.max(max, i - map.get(count));\n        } else {\n            map.set(count, i);\n        }\n    }\n    return max;\n};"}
{"id": "853", "path": "output2\\js\\Medium\\853-beautiful-arrangement.js", "hypo_code": "var countArrangement = function(n) {\n    let result = 0;\n    let used = new Array(n + 1).fill(false);\n    let dfs = (index) => {\n        if (index > n) {\n            result++;\n            return;\n        }\n        for (let i = 1; i <= n; i++) {\n            if (!used[i] && (index % i === 0 || i % index === 0)) {\n                used[i] = true;\n                dfs(index + 1);\n                used[i] = false;\n            }\n        }\n    };\n    dfs(1);\n    return result;\n};"}
{"id": "855", "path": "output2\\js\\Medium\\855-minesweeper.js", "hypo_code": "var updateBoard = function(board, click) {\n    let m = board.length;\n\tlet n = board[0].length;\n\tlet i = click[0];\n\tlet j = click[1];\n\tif (board[i][j] === 'M') {\n\t\tboard[i][j] = 'X';\n\t\treturn board;\n\t}\n\tlet queue = [];\n\tqueue.push([i, j]);\n\twhile (queue.length) {\n\t\tlet [i, j] = queue.shift();\n\t\tif (board[i][j] !== 'E') {\n\t\t\tcontinue;\n\t\t}\n\t\tlet count = 0;\n\t\tlet neighbors = [];\n\t\tif (i > 0) {\n\t\t\tneighbors.push([i - 1, j]);\n\t\t}\n\t\tif (i < m - 1) {\n\t\t\tneighbors.push([i + 1, j]);\n\t\t}\n\t\tif (j > 0) {\n\t\t\tneighbors.push([i, j - 1]);\n\t\t}\n\t\tif (j < n - 1) {\n\t\t\tneighbors.push([i, j + 1]);\n\t\t}\n\t\tif (i > 0 && j > 0) {\n\t\t\tneighbors.push([i - 1, j - 1]);\n\t\t}\n\t\tif (i > 0 && j < n - 1) {\n\t\t\tneighbors.push([i - 1, j + 1]);\n\t\t}\n\t\tif (i < m - 1 && j > 0) {\n\t\t\tneighbors.push([i + 1, j - 1]);\n\t\t}\n\t\tif (i < m - 1 && j < n - 1) {\n\t\t\tneighbors.push([i + 1, j + 1]);\n\t\t}\n\t\tfor (let [x, y] of neighbors) {\n\t\t\tif (board[x][y] === 'M') {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count > 0) {\n\t\t\tboard[i][j] = count.toString();\n\t\t} else {\n\t\t\tboard[i][j] = 'B';\n\t\t\tqueue.push(...neighbors);\n\t\t}\n\t}\n\treturn board;\n};"}
{"id": "856", "path": "output2\\js\\Medium\\856-k-diff-pairs-in-an-array.js", "hypo_code": "var findPairs = function(nums, k) {\n    let result = 0;\n    let map = new Map();\n    for (let num of nums) {\n        map.set(num, map.get(num) + 1 || 1);\n    }\n    for (let [key, value] of map) {\n        if (k === 0) {\n            if (value > 1) {\n                result++;\n            }\n        } else {\n            if (map.has(key + k)) {\n                result++;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "858", "path": "output2\\js\\Medium\\858-complex-number-multiplication.js", "hypo_code": "var complexNumberMultiply = function(num1, num2) {\n    let [a, b] = num1.split('+');\n\tlet [c, d] = num2.split('+');\n\tlet real = a * c - b * d;\n\tlet imaginary = a * d + b * c;\n\treturn `${real}+${imaginary}i`;\n};"}
{"id": "859", "path": "output2\\js\\Medium\\859-convert-bst-to-greater-tree.js", "hypo_code": "var convertBST = function(root) {\n    let sum = 0;\n\tlet postOrder = (node) => {\n\t\tif (!node) return;\n\t\tpostOrder(node.right);\n\t\tsum += node.val;\n\t\tnode.val = sum;\n\t\tpostOrder(node.left);\n\t};\n\tpostOrder(root);\n\treturn root;\n};"}
{"id": "860", "path": "output2\\js\\Medium\\860-minimum-time-difference.js", "hypo_code": "var findMinDifference = function(timePoints) {\n    let minutes = [];\n    for (let time of timePoints) {\n        let [hour, minute] = time.split(\":\");\n        minutes.push(parseInt(hour) * 60 + parseInt(minute));\n    }\n    minutes.sort((a, b) => a - b);\n    let min = 24 * 60;\n    for (let i = 1; i < minutes.length; i++) {\n        min = Math.min(min, minutes[i] - minutes[i - 1]);\n    }\n    min = Math.min(min, minutes[0] + 24 * 60 - minutes[minutes.length - 1]);\n    return min;\n};"}
{"id": "861", "path": "output2\\js\\Medium\\861-single-element-in-a-sorted-array.js", "hypo_code": "var singleNonDuplicate = function(nums) {\n    let left = 0;\n    let right = nums.length - 1;\n    while (left + 1 < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (mid % 2 === 0) {\n            if (nums[mid] === nums[mid - 1]) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        } else {\n            if (nums[mid] === nums[mid - 1]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    if (left % 2 === 0) {\n        return nums[left];\n    } else {\n        return nums[right];\n    }\n};"}
{"id": "862", "path": "output2\\js\\Medium\\862-01-matrix.js", "hypo_code": "var updateMatrix = function(mat) {\n    let result = [];\n    for (let i = 0; i < mat.length; i++) {\n        let row = mat[i];\n        result.push([]);\n        for (let j = 0; j < row.length; j++) {\n            let cell = row[j];\n            if (cell === 0) {\n                result[i][j] = 0;\n            } else {\n                result[i][j] = Infinity;\n            }\n        }\n    }\n    for (let i = 0; i < mat.length; i++) {\n        let row = mat[i];\n        for (let j = 0; j < row.length; j++) {\n            let cell = row[j];\n            if (cell === 0) {\n                result[i][j] = 0;\n            } else {\n                if (i > 0) {\n                    result[i][j] = Math.min(result[i][j], result[i - 1][j] + 1);\n                }\n                if (j > 0) {\n                    result[i][j] = Math.min(result[i][j], result[i][j - 1] + 1);\n                }\n            }\n        }\n    }\n    for (let i = mat.length - 1; i >= 0; i--) {\n        let row = mat[i];\n        for (let j = row.length - 1; j >= 0; j--) {\n            let cell = row[j];\n            if (cell === 0) {\n                result[i][j] = 0;\n            } else {\n                if (i < mat.length - 1) {\n                    result[i][j] = Math.min(result[i][j], result[i + 1][j] + 1);\n                }\n                if (j < row.length - 1) {\n                    result[i][j] = Math.min(result[i][j], result[i][j + 1] + 1);\n                }\n            }\n        }\n    }\n    return result;\n};"}
{"id": "863", "path": "output2\\js\\Medium\\863-number-of-provinces.js", "hypo_code": "var findCircleNum = function(isConnected) {\n    let n = isConnected.length;\n    let visited = new Set();\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (!visited.has(i)) {\n            result++;\n            dfs(isConnected, i, visited);\n        }\n    }\n    return result;\n};\nfunction dfs(isConnected, i, visited) {\n    for (let j = 0; j < isConnected.length; j++) {\n        if (isConnected[i][j] === 1 && !visited.has(j)) {\n            visited.add(j);\n            dfs(isConnected, j, visited);\n        }\n    }\n}"}
{"id": "865", "path": "output2\\js\\Medium\\865-optimal-division.js", "hypo_code": "var optimalDivision = function(nums) {\n    if (nums.length === 1) {\n        return nums[0].toString();\n    }\n    if (nums.length === 2) {\n        return nums[0].toString() + '/' + nums[1].toString();\n    }\n    let result = nums[0].toString() + '/(';\n    for (let i = 1; i < nums.length; i++) {\n        result += nums[i].toString() + '/';\n    }\n    return result.substring(0, result.length - 1) + ')';\n};"}
{"id": "866", "path": "output2\\js\\Medium\\866-brick-wall.js", "hypo_code": "var leastBricks = function(wall) {\n    let map = new Map();\n    let max = 0;\n    for (let i = 0; i < wall.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < wall[i].length - 1; j++) {\n            sum += wall[i][j];\n            map.set(sum, (map.get(sum) || 0) + 1);\n            max = Math.max(max, map.get(sum));\n        }\n    }\n    return wall.length - max;\n};"}
{"id": "867", "path": "output2\\js\\Medium\\867-next-greater-element-iii.js", "hypo_code": "var nextGreaterElement = function(n) {\n    let numStr = n.toString().split('');\n    let i = numStr.length - 1;\n    while (i > 0 && numStr[i - 1] >= numStr[i]) {\n        i--;\n    }\n    if (i === 0) return -1;\n    let j = numStr.length - 1;\n    while (j >= i && numStr[j] <= numStr[i - 1]) {\n        j--;\n    }\n    swap(numStr, i - 1, j);\n    reverse(numStr, i);\n    let result = parseInt(numStr.join(''));\n    return result > 2147483647 ? -1 : result;\n};\nfunction swap(arr, i, j) {\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n}\n\nfunction reverse(arr, start) {\n    let i = start;\n    let j = arr.length - 1;\n    while (i < j) {\n        swap(arr, i, j);\n        i++;\n        j--;\n    }\n}"}
{"id": "869", "path": "output2\\js\\Medium\\869-subarray-sum-equals-k.js", "hypo_code": "var subarraySum = function(nums, k) {\n    let result = 0;\n\tlet map = new Map();\n\tmap.set(0, 1);\n\tlet sum = 0;\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tsum += nums[i];\n\t\tif (map.has(sum - k)) {\n\t\t\tresult += map.get(sum - k);\n\t\t}\n\t\tmap.set(sum, map.get(sum) ? map.get(sum) + 1 : 1);\n\t}\n\treturn result;\n};"}
{"id": "870", "path": "output2\\js\\Medium\\870-array-nesting.js", "hypo_code": "var arrayNesting = function(nums) {\n    let result = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let count = 0;\n        for (let j = i; nums[j] >= 0; count++) {\n            let next = nums[j];\n            nums[j] = -1;\n            j = next;\n        }\n        result = Math.max(result, count);\n    }\n    return result;\n};"}
{"id": "871", "path": "output2\\js\\Medium\\871-permutation-in-string.js", "hypo_code": "var checkInclusion = function(s1, s2) {\n    let map = new Map();\n    for (let char of s1) {\n        if (map.has(char)) {\n            map.set(char, map.get(char) + 1);\n        } else {\n            map.set(char, 1);\n        }\n    }\n    let start = 0;\n    let end = 0;\n    let count = map.size;\n    while (end < s2.length) {\n        let char = s2[end];\n        if (map.has(char)) {\n            map.set(char, map.get(char) - 1);\n            if (map.get(char) === 0) {\n                count--;\n            }\n        }\n        end++;\n        while (count === 0) {\n            let char = s2[start];\n            if (map.has(char)) {\n                map.set(char, map.get(char) + 1);\n                if (map.get(char) > 0) {\n                    count++;\n                }\n            }\n            if (end - start === s1.length) {\n                return true;\n            }\n            start++;\n        }\n    }\n    return false;\n};"}
{"id": "873", "path": "output2\\js\\Medium\\873-out-of-boundary-paths.js", "hypo_code": "var findPaths = function(m, n, maxMove, startRow, startColumn) {\n    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    dp[startRow][startColumn] = 1;\n    let result = 0;\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    for (let move = 0; move < maxMove; move++) {\n        let temp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j ++) {\n                for (let dir of dirs) {\n                    let x = i + dir[0];\n                    let y = j + dir[1];\n                    if (x < 0 || x >= m || y < 0 || y >= n) {\n                        result = (result + dp[i][j]) % (10 ** 9 + 7);\n                    } else {\n                        temp[x][y] = (temp[x][y] + dp[i][j]) % (10 ** 9 + 7);\n                    }\n                }\n            }\n        }\n        dp = temp;\n    }\n    return result;\n};"}
{"id": "874", "path": "output2\\js\\Medium\\874-shortest-unsorted-continuous-subarray.js", "hypo_code": "var findUnsortedSubarray = function(nums) {\n    let start = 0;\n    let end = 0;\n    let max = nums[0];\n    let min = nums[nums.length - 1];\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] < max) {\n            end = i;\n        }\n        max = Math.max(max, nums[i]);\n    }\n    for (let i = nums.length - 1; i >= 0; i--) {\n        if (nums[i] > min) {\n            start = i;\n        }\n        min = Math.min(min, nums[i]);\n    }\n    return start === end ? 0 : end - start + 1;\n};"}
{"id": "875", "path": "output2\\js\\Medium\\875-delete-operation-for-two-strings.js", "hypo_code": "var minDistance = function(word1, word2) {\n    let m = word1.length;\n    let n = word2.length;\n    let dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (let j = 1; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    for (let i = 1; i <= m; i++) {\n        let char1 = word1[i - 1];\n        for (let j = 1; j <= n; j++) {\n            let char2 = word2[j - 1];\n            if (char1 === char2) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n};"}
{"id": "877", "path": "output2\\js\\Medium\\877-fraction-addition-and-subtraction.js", "hypo_code": "var fractionAddition = function(expression) {\n    let result = 0;\n    let numerator = 0;\n    let denominator = 1;\n    let sign = 1;\n    let i = 0;\n    while (i < expression.length) {\n        if (expression[i] === '-') {\n            sign = -1;\n            i++;\n        } else if (expression[i] === '+') {\n            sign = 1;\n            i++;\n        } else {\n            let start = i;\n            while (i < expression.length && expression[i] !== '+' && expression[i] !== '-') {\n                i++;\n            }\n            let fraction = expression.substring(start, i);\n            let [num, denom] = fraction.split('/');\n            num = Number(num);\n            denom = Number(denom);\n            numerator = numerator * denom + sign * num * denominator;\n            denominator *= denom;\n        }\n    }\n    if (numerator === 0) {\n        return '0/1';\n    }\n    let gcd = GCD(Math.abs(numerator), denominator);\n    return `${numerator / gcd}/${denominator / gcd}`;\n};\nfunction GCD(a, b) {\n    if (a === 0) {\n        return b;\n    }\n    return GCD(b % a, a);\n}"}
{"id": "878", "path": "output2\\js\\Medium\\878-valid-square.js", "hypo_code": "var validSquare = function(p1, p2, p3, p4) {\n    let set = new Set();\n\tlet points = [p1, p2, p3, p4];\n\tfor (let i = 0; i < points.length; i++) {\n\t\tfor (let j = i + 1; j < points.length; j++) {\n\t\t\tlet dist = Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2);\n\t\t\tset.add(dist);\n\t\t}\n\t}\n\treturn set.size === 2 && !set.has(0);\n};"}
{"id": "881", "path": "output2\\js\\Medium\\881-find-duplicate-file-in-system.js", "hypo_code": "var findDuplicate = function(paths) {\n    let map = new Map();\n    for (let path of paths) {\n        let tokens = path.split(' ');\n        let directory = tokens[0];\n        for (let i = 1; i < tokens.length; i++) {\n            let file = tokens[i];\n            let index = file.indexOf('(');\n            let name = file.substring(0, index);\n            let content = file.substring(index + 1, file.length - 1);\n            let fullPath = directory + '/' + name;\n            if (!map.has(content)) {\n                map.set(content, []);\n            }\n            map.get(content).push(fullPath);\n        }\n    }\n    return Array.from(map.values()).filter(list => list.length > 1);\n\n};"}
{"id": "882", "path": "output2\\js\\Medium\\882-valid-triangle-number.js", "hypo_code": "var triangleNumber = function(nums) {\n    let result = 0;\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (nums[i] === 0) {\n            continue;\n        }\n        let k = i + 2;\n        for (let j = i + 1; j < nums.length - 1; j++) {\n            while (k < nums.length && nums[i] + nums[j] > nums[k]) {\n                k++;\n            }\n            result += k - j - 1;\n        }\n    }\n    return result;\n    \n};"}
{"id": "883", "path": "output2\\js\\Medium\\883-task-scheduler.js", "hypo_code": "var leastInterval = function(tasks, n) {\n    let map = new Map();\n\tlet maxCount = 0;\n\tlet max = 0;\n\tfor (let task of tasks) {\n\t\tlet count = map.has(task) ? map.get(task) + 1 : 1;\n\t\tmap.set(task, count);\n\t\tif (count > maxCount) {\n\t\t\tmaxCount = count;\n\t\t\tmax = 1;\n\t\t} else if (count === maxCount) {\n\t\t\tmax++;\n\t\t}\n\t}\n\treturn Math.max(tasks.length, (maxCount - 1) * (n + 1) + max);\n\n};"}
{"id": "885", "path": "output2\\js\\Medium\\885-add-one-row-to-tree.js", "hypo_code": "var addOneRow = function(root, val, depth) {\n    let queue = [root];\n    let level = 1;\n    if (depth === 1) {\n        let newRoot = new TreeNode(val);\n        newRoot.left = root;\n        return newRoot;\n    }\n    while (queue.length) {\n        let size = queue.length;\n        for (let i = 0; i < size; i++) {\n            let node = queue.shift();\n            if (level === depth - 1) {\n                let left = node.left;\n                let right = node.right;\n                let newLeft = new TreeNode(val);\n                let newRight = new TreeNode(val);\n                node.left = newLeft;\n                node.right = newRight;\n                node.left.left = left;\n                node.right.right = right;\n            }\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        level++;\n    }\n    return root;\n};"}
{"id": "887", "path": "output2\\js\\Medium\\887-sum-of-square-numbers.js", "hypo_code": "var judgeSquareSum = function(c) {\n    let left = 0;\n    let right = Math.floor(Math.sqrt(c));\n    while (left <= right) {\n        let sum = left * left + right * right;\n        if (sum === c) {\n            return true;\n        } else if (sum > c) {\n            right--;\n        } else {\n            left++;\n        }\n    }\n    return false;\n};"}
{"id": "888", "path": "output2\\js\\Medium\\888-exclusive-time-of-functions.js", "hypo_code": "var exclusiveTime = function(n, logs) {\n    let result = new Array(n).fill(0);\n\tlet stack = [];\n\tlet prev = 0;\n\tfor (let log of logs) {\n\t\tlet [id, startOrEnd, time] = log.split(':');\n\t\tif (startOrEnd === 'start') {\n\t\t\tif (stack.length) {\n\t\t\t\tresult[stack[stack.length - 1]] += Number(time) - prev;\n\t\t\t}\n\t\t\tstack.push(Number(id));\n\t\t\tprev = Number(time);\n\t\t} else {\n\t\t\tresult[stack.pop()] += Number(time) - prev + 1;\n\t\t\tprev = Number(time) + 1;\n\t\t}\n\t}\n\treturn result;\n};"}
{"id": "889", "path": "output2\\js\\Medium\\889-shopping-offers.js", "hypo_code": "var shoppingOffers = function(price, special, needs) { \n    let map = new Map();\n    return dfs(price, special, needs, map);\n};\nfunction dfs(price, special, needs, map) {\n    let key = needs.join('-');\n    if (map.has(key)) {\n        return map.get(key);\n    }\n    let min = 0;\n    for (let i = 0; i < needs.length; i++) {\n        min += needs[i] * price[i];\n    }\n    for (let i = 0; i < special.length; i++) {\n        let clone = needs.slice();\n        let j = 0;\n        for (j = 0; j < needs.length; j++) {\n            let diff = clone[j] - special[i][j];\n            if (diff < 0) {\n                break;\n            }\n            clone[j] = diff;\n        }\n        if (j === needs.length) {\n            min = Math.min(min, special[i][j] + dfs(price, special, clone, map));\n        }\n    }\n    map.set(key, min);\n    return min;\n}"}
{"id": "890", "path": "output2\\js\\Medium\\890-solve-the-equation.js", "hypo_code": "var solveEquation = function(equation) {\n    let [left, right] = equation.split('=');\n    let [leftX, leftNum] = parse(left);\n    let [rightX, rightNum] = parse(right);\n    let x = leftX - rightX;\n    let num = rightNum - leftNum;\n    if (x === 0 && num === 0) {\n        return 'Infinite solutions';\n    } else if (x === 0 && num !== 0) {\n        return 'No solution';\n    } else {\n        return 'x=' + num / x;\n    }\n};\nfunction parse(str) {\n    let x = 0;\n    let num = 0;\n    let sign = 1;\n    let numStart = false;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charAt(i);\n        if (c === 'x') {\n            if (!numStart) {\n                x += sign;\n            } else {\n                x += sign * parseInt(str.substring(numStart, i));\n            }\n            numStart = false;\n        } else if (c === '+') {\n            if (numStart) {\n                num += sign * parseInt(str.substring(numStart, i));\n            }\n            sign = 1;\n            numStart = false;\n        } else if (c === '-') {\n            if (numStart) {\n                num += sign * parseInt(str.substring(numStart, i));\n            }\n            sign = -1;\n            numStart = false;\n        } else {\n            if (!numStart) {\n                numStart = i;\n            }\n        }\n    }\n    if (numStart) {\n        num += sign * parseInt(str.substring(numStart));\n    }\n    return [x, num];\n}"}
{"id": "892", "path": "output2\\js\\Medium\\892-maximum-length-of-pair-chain.js", "hypo_code": "var findLongestChain = function(pairs) {\n    pairs.sort((a, b) => a[0] - b[0]);\n    let dp = new Array(pairs.length).fill(1);\n    for (let i = 1; i < pairs.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (pairs[i][0] > pairs[j][1]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    return dp[pairs.length - 1];\n};"}
{"id": "893", "path": "output2\\js\\Medium\\893-palindromic-substrings.js", "hypo_code": "var countSubstrings = function(s) {\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        count += helper(s, i, i);\n        count += helper(s, i, i + 1);\n    }\n    return count;\n};\nvar helper = function(s, start, end) {\n    let count = 0;\n    while (start >= 0 && end < s.length && s[start] === s[end]) {\n        count++;\n        start--;\n        end++;\n    }\n    return count;\n};"}
{"id": "894", "path": "output2\\js\\Medium\\894-replace-words.js", "hypo_code": "var replaceWords = function(dictionary, sentence) {\n    let rootSet = new Set(dictionary);\n\tlet words = sentence.split(\" \");\n\tfor (let i = 0; i < words.length; i++) {\n\t\tlet word = words[i];\n\t\tfor (let j = 1; j < word.length; j++) {\n\t\t\tif (rootSet.has(word.substring(0, j))) {\n\t\t\t\twords[i] = word.substring(0, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn words.join(\" \");\n};"}
{"id": "895", "path": "output2\\js\\Medium\\895-dota2-senate.js", "hypo_code": "var predictPartyVictory = function(senate) {\n    let radiant = [];\n    let dire = [];\n    for (let i = 0; i < senate.length; i++) {\n        if (senate[i] === 'R') {\n            radiant.push(i);\n        } else {\n            dire.push(i);\n        }\n    }\n    while (radiant.length && dire.length) {\n        if (radiant[0] < dire[0]) {\n            radiant.push(radiant[0] + senate.length);\n        } else {\n            dire.push(dire[0] + senate.length);\n        }\n        radiant.shift();\n        dire.shift();\n    }\n    return radiant.length ? 'Radiant' : 'Dire';\n};"}
{"id": "896", "path": "output2\\js\\Medium\\896-2-keys-keyboard.js", "hypo_code": "var minSteps = function(n) {\n    let dp = new Array(n + 1).fill(0);\n    for (let i = 2; i <= n; i++) {\n        dp[i] = i;\n        for (let j = i - 1; j > 1; j--) {\n            if (i % j === 0) {\n                dp[i] = dp[j] + (i / j);\n                break;\n            }\n        }\n    }\n    return dp[n];\n};"}
{"id": "897", "path": "output2\\js\\Medium\\897-find-duplicate-subtrees.js", "hypo_code": "var findDuplicateSubtrees = function(root) {\n    let map = {};\n\tlet result = [];\n\tlet postOrder = (node) => {\n\t\tif (!node) return \"#\";\n\t\tlet left = postOrder(node.left);\n\t\tlet right = postOrder(node.right);\n\t\tlet sum = left + \",\" + right + \",\" + node.val;\n\t\tmap[sum] = map[sum] + 1 || 1;\n\t\tif (map[sum] === 2) result.push(node);\n\t\treturn sum;\n\t};\n\tpostOrder(root);\n\treturn result;\n};"}
{"id": "898", "path": "output2\\js\\Medium\\898-maximum-binary-tree.js", "hypo_code": "var constructMaximumBinaryTree = function(nums) {\n    let max = -Infinity;\n\tlet index = -1;\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tif (nums[i] > max) {\n\t\t\tmax = nums[i];\n\t\t\tindex = i;\n\t\t}\n\t}\n\tlet root = new TreeNode(max);\n\tif (index > -1) {\n\t\troot.left = constructMaximumBinaryTree(nums.slice(0, index));\n\t\troot.right = constructMaximumBinaryTree(nums.slice(index + 1));\n\t}\n\treturn root;\n};"}
{"id": "899", "path": "output2\\js\\Medium\\899-print-binary-tree.js", "hypo_code": "var printTree = function(root) {\n    let height = getHeight(root);\n\tlet rows = height + 1;\n\tlet cols = Math.pow(2, height) - 1;\n\tlet result = new Array(rows).fill(null).map(() => new Array(cols).fill(\"\"));\n\tlet fill = (node, row, col, gap) => {\n\t\tif (!node) return;\n\t\tresult[row][col] = node.val.toString();\n\t\tfill(node.left, row + 1, col - gap, Math.floor(gap / 2));\n\t\tfill(node.right, row + 1, col + gap, Math.floor(gap / 2));\n\t};\n\tfill(root, 0, Math.floor(cols / 2), Math.floor(cols / 2));\n\treturn result;\n};\nfunction getHeight(node) {\n\tif (!node) return -1;\n\treturn Math.max(getHeight(node.left), getHeight(node.right)) + 1;\n}"}
{"id": "900", "path": "output2\\js\\Medium\\900-find-k-closest-elements.js", "hypo_code": "var findClosestElements = function(arr, k, x) {\n    let left = 0;\n\tlet right = arr.length - k;\n\twhile (left < right) {\n\t\tlet mid = Math.floor((left + right) / 2);\n\t\tif (x - arr[mid] > arr[mid + k] - x) {\n\t\t\tleft = mid + 1;\n\t\t} else {\n\t\t\tright = mid;\n\t\t}\n\t}\n\treturn arr.slice(left, left + k);\n};"}
{"id": "901", "path": "output2\\js\\Medium\\901-split-array-into-consecutive-subsequences.js", "hypo_code": "var isPossible = function(nums) {\n    let count = new Map();\n    let tails = new Map();\n    for (let num of nums) {\n        count.set(num, (count.get(num) || 0) + 1);\n    }\n    for (let num of nums) {\n        if (count.get(num) === 0) {\n            continue;\n        } else if (tails.get(num) > 0) {\n            tails.set(num, tails.get(num) - 1);\n            tails.set(num + 1, (tails.get(num + 1) || 0) + 1);\n        } else if (count.get(num + 1) > 0 && count.get(num + 2) > 0) {\n            count.set(num + 1, count.get(num + 1) - 1);\n            count.set(num + 2, count.get(num + 2) - 1);\n            tails.set(num + 3, (tails.get(num + 3) || 0) + 1);\n        } else {\n            return false;\n        }\n        count.set(num, count.get(num) - 1);\n    }\n    return true;\n};"}
{"id": "902", "path": "output2\\js\\Medium\\902-maximum-width-of-binary-tree.js", "hypo_code": "var widthOfBinaryTree = function(root) {\n    let queue = [[root, 0, 0]];\n\tlet result = 0;\n\tlet currentDepth = 0;\n\tlet left = 0;\n\twhile (queue.length) {\n\t\tlet [node, depth, position] = queue.shift();\n\t\tif (node) {\n\t\t\tqueue.push([node.left, depth + 1, position * 2]);\n\t\t\tqueue.push([node.right, depth + 1, position * 2 + 1]);\n\t\t\tif (currentDepth !== depth) {\n\t\t\t\tcurrentDepth = depth;\n\t\t\t\tleft = position;\n\t\t\t}\n\t\t\tresult = Math.max(result, position - left + 1);\n\t\t}\n\t}\n\treturn result;\n};"}
{"id": "903", "path": "output2\\js\\Medium\\903-non-decreasing-array.js", "hypo_code": "var checkPossibility = function(nums) {\n    let count = 0;\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i - 1] <= nums[i]) {\n            continue;\n        }\n        count++;\n        if (i - 2 >= 0 && nums[i - 2] > nums[i]) {\n            nums[i] = nums[i - 1];\n        } else {\n            nums[i - 1] = nums[i];\n        }\n        if (count > 1) {\n            return false;\n        }\n    }\n    return true;\n};"}
{"id": "904", "path": "output2\\js\\Medium\\904-beautiful-arrangement-ii.js", "hypo_code": "var constructArray = function(n, k) {\n    let result = [];\n    let left = 1;\n    let right = n;\n    while(left <= right){\n        if(k > 1){\n            if(k % 2 == 0){\n                result.push(left);\n                left++;\n            }else{\n                result.push(right);\n                right--;\n            }\n            k--;\n        }else{\n            result.push(left);\n            left++;\n        }\n    }\n    return result;\n    \n};"}
{"id": "905", "path": "output2\\js\\Medium\\905-trim-a-binary-search-tree.js", "hypo_code": "var trimBST = function(root, low, high) {\n    if(root == null){\n        return null;\n    }\n    if(root.val < low){\n        return trimBST(root.right, low, high);\n    }\n    if(root.val > high){\n        return trimBST(root.left, low, high);\n    }\n    root.left = trimBST(root.left, low, high);\n    root.right = trimBST(root.right, low, high);\n    return root;\n    \n};"}
{"id": "906", "path": "output2\\js\\Medium\\906-maximum-swap.js", "hypo_code": "var maximumSwap = function(num) {\n    let arr = num.toString().split('');\n    let n = arr.length;\n    let max = arr[n - 1];\n    let maxIndex = n - 1;\n    let swapIndex = -1;\n    for(let i = n - 2; i >= 0; i--){\n        if(arr[i] < max){\n            swapIndex = i;\n        }else if(arr[i] > max){\n            max = arr[i];\n            maxIndex = i;\n        }\n    }\n    if(swapIndex != -1){\n        let temp = arr[swapIndex];\n        arr[swapIndex] = arr[maxIndex];\n        arr[maxIndex] = temp;\n    }\n    return parseInt(arr.join(''));\n    \n};"}
{"id": "907", "path": "output2\\js\\Medium\\907-bulb-switcher-ii.js", "hypo_code": "var flipLights = function(n, presses) {\n    if(n == 0 || presses == 0){\n        return 1;\n    }\n    if(n == 1){\n        return 2;\n    }\n    if(n == 2){\n        return presses == 1 ? 3 : 4;\n    }\n    return presses == 1 ? 4 : presses == 2 ? 7 : 8;\n    \n};"}
{"id": "908", "path": "output2\\js\\Medium\\908-number-of-longest-increasing-subsequence.js", "hypo_code": "var findNumberOfLIS = function(nums) {\n    let n = nums.length;\n    let dp = new Array(n).fill(0);\n    let count = new Array(n).fill(0);\n    let max = 0;\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        dp[i] = 1;\n        count[i] = 1;\n        for(let j = 0; j < i; j++){\n            if(nums[i] > nums[j]){\n                if(dp[j] + 1 > dp[i]){\n                    dp[i] = dp[j] + 1;\n                    count[i] = count[j];\n                }else if(dp[j] + 1 == dp[i]){\n                    count[i] += count[j];\n                }\n            }\n        }\n        if(dp[i] > max){\n            max = dp[i];\n            result = count[i];\n        }else if(dp[i] == max){\n            result += count[i];\n        }\n    }\n    return result;\n    \n};"}
{"id": "911", "path": "output2\\js\\Medium\\911-valid-parenthesis-string.js", "hypo_code": "var checkValidString = function(s) {\n    let left = 0;\n    let right = 0;\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == \"(\"){\n            left++;\n            right++;\n        }else if(s[i] == \")\"){\n            left--;\n            right--;\n        }else{\n            left--;\n            right++;\n        }\n        if(right < 0){\n            return false;\n        }\n        left = Math.max(left, 0);\n    }\n    return left == 0;\n    \n};"}
{"id": "912", "path": "output2\\js\\Medium\\912-redundant-connection.js", "hypo_code": "var findRedundantConnection = function(edges) {\n    let n = edges.length;\n    let parent = new Array(n + 1).fill(0).map((_, index) => index);\n    for(let edge of edges){\n        let [node1, node2] = edge;\n        let parent1 = findParent(node1, parent);\n        let parent2 = findParent(node2, parent);\n        if(parent1 == parent2){\n            return edge;\n        }\n        parent[parent1] = parent2;\n    }\n    return [];\n    \n    \n    \n};"}
{"id": "913", "path": "output2\\js\\Medium\\913-repeated-string-match.js", "hypo_code": "var repeatedStringMatch = function(a, b) {\n    let result = 1;\n    let temp = a;\n    while(temp.length < b.length){\n        temp += a;\n        result++;\n    }\n    if(temp.includes(b)){\n        return result;\n    }\n    temp += a;\n    result++;\n    if(temp.includes(b)){\n        return result;\n    }\n    return -1;\n    \n    \n};"}
{"id": "914", "path": "output2\\js\\Medium\\914-longest-univalue-path.js", "hypo_code": "var longestUnivaluePath = function(root) {\n    let max = 0;\n    function dfs(node){\n        if(node == null){\n            return 0;\n        }\n        let left = dfs(node.left);\n        let right = dfs(node.right);\n        let leftPath = 0;\n        let rightPath = 0;\n        if(node.left != null && node.left.val == node.val){\n            leftPath = left + 1;\n        }\n        if(node.right != null && node.right.val == node.val){\n            rightPath = right + 1;\n        }\n        max = Math.max(max, leftPath + rightPath);\n        return Math.max(leftPath, rightPath);\n    }\n    dfs(root);\n    return max;\n    \n};"}
{"id": "915", "path": "output2\\js\\Medium\\915-knight-probability-in-chessboard.js", "hypo_code": "var knightProbability = function(n, k, row, column) {\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[row][column] = 1;\n    let moves = [[-2, -1], [-2, 1], [2, -1], [2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2]];\n    for(let i = 0; i < k; i++){\n        let temp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n        for(let j = 0; j < n; j++){\n            for(let l = 0; l < n; l++){\n                for(let m = 0; m < 8; m++){\n                    let x = j + moves[m][0];\n                    let y = l + moves[m][1];\n                    if(x >= 0 && x < n && y >= 0 && y < n){\n                        temp[x][y] += dp[j][l] / 8;\n                    }\n                }\n            }\n        }\n        dp = temp;\n    }\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            result += dp[i][j];\n        }\n    }\n    return result;\n    \n};"}
{"id": "917", "path": "output2\\js\\Medium\\917-top-k-frequent-words.js", "hypo_code": "var topKFrequent = function(words, k) {\n    let map = new Map();\n    for(let i = 0; i < words.length; i++){\n        if(map.has(words[i])){\n            map.set(words[i], map.get(words[i]) + 1);\n        }else{\n            map.set(words[i], 1);\n        }\n    }\n    let arr = [];\n    for(let [key, value] of map){\n        arr.push([key, value]);\n    }\n    arr.sort((a, b) => {\n        if(a[1] == b[1]){\n            return a[0].localeCompare(b[0]);\n        }else{\n            return b[1] - a[1];\n        }\n    });\n    let result = [];\n    for(let i = 0; i < k; i++){\n        result.push(arr[i][0]);\n    }\n    return result;\n    \n};"}
{"id": "918", "path": "output2\\js\\Medium\\918-max-area-of-island.js", "hypo_code": "var maxAreaOfIsland = function(grid) {\n    let maxArea = 0;\n    let currentArea = 0;\n    const isIsland = (i, j) => {\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) {\n            return false;\n        }\n        return grid[i][j] === 1;\n    }\n    const visitIsland = (i, j) => {\n        if (isIsland(i, j)) {\n            grid[i][j] = 0;\n            currentArea++;\n            visitIsland(i + 1, j);\n            visitIsland(i - 1, j);\n            visitIsland(i, j + 1);\n            visitIsland(i, j - 1);\n        }\n    }\n    for (let i = 0; i < grid.length; i++) {\n        for (let j =0; j < grid[0].length; j++) {\n            if (grid[i][j] === 1) {\n                currentArea = 0;\n                visitIsland(i, j);\n                maxArea = Math.max(maxArea, currentArea);\n            }\n        }\n    }\n    return maxArea;\n};"}
{"id": "919", "path": "output2\\js\\Medium\\919-partition-to-k-equal-sum-subsets.js", "hypo_code": "var canPartitionKSubsets = function(nums, k) {\n    const sum = nums.reduce((a, b) => a + b);\n    if (sum % k !== 0) {\n        return false;\n    }\n    const target = sum / k;\n    const visited = new Array(nums.length).fill(false);\n    const canPartition = (start, currentSum, currentK) => {\n        if (currentK === 0) {\n            return true;\n        }\n        if (currentSum === target) {\n            return canPartition(0, 0, currentK - 1);\n        }\n        for (let i = start; i < nums.length; i++) {\n            if (!visited[i] && currentSum + nums[i] <= target) {\n                visited[i] = true;\n                if (canPartition(i + 1, currentSum + nums[i], currentK)) {\n                    return true;\n                }\n                visited[i] = false;\n            }\n        }\n        return false;\n    }\n    return canPartition(0, 0, k);\n};"}
{"id": "920", "path": "output2\\js\\Medium\\920-insert-into-a-binary-search-tree.js", "hypo_code": "var insertIntoBST = function(root, val) {\n    const insertNode = (node) => {\n        if (!node) {\n            return new TreeNode(val);\n        }\n        if (val < node.val) {\n            node.left = insertNode(node.left);\n        } else {\n            node.right = insertNode(node.right);\n        }\n        return node;\n    }\n    return insertNode(root);\n};"}
{"id": "922", "path": "output2\\js\\Medium\\922-minimum-ascii-delete-sum-for-two-strings.js", "hypo_code": "var minimumDeleteSum = function(s1, s2) {\n    const dp = new Array(s1.length + 1).fill(0).map(() => new Array(s2.length + 1).fill(0));\n    for (let i = 1; i <= s1.length; i++) {\n        dp[i][0] = dp[i - 1][0] + s1.charCodeAt(i - 1);\n    }\n    for (let j = 1; j <= s2.length; j++) {\n        dp[0][j] = dp[0][j - 1] + s2.charCodeAt(j - 1);\n    }\n    for (let i = 1; i <= s1.length; i++) {\n        for (let j =1; j <= s2.length; j++) {\n            if (s1[i - 1] === s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                const deleteS1 = dp[i - 1][j] + s1.charCodeAt(i - 1);\n                const deleteS2 = dp[i][j - 1] + s2.charCodeAt(j - 1);\n                dp[i][j] = Math.min(deleteS1, deleteS2);\n            }\n        }\n    }\n    return dp[s1.length][s2.length];\n};"}
{"id": "923", "path": "output2\\js\\Medium\\923-subarray-product-less-than-k.js", "hypo_code": "var numSubarrayProductLessThanK = function(nums, k) {\n    let n = nums.length;\n    let result = 0;\n    let left = 0;\n    let right = 0;\n    let product = 1;\n    while(right < n){\n        product *= nums[right];\n        while(left <= right && product >= k){\n            product /= nums[left];\n            left++;\n        }\n        result += right - left + 1;\n        right++;\n    }\n    return result;\n    \n};"}
{"id": "924", "path": "output2\\js\\Medium\\924-best-time-to-buy-and-sell-stock-with-transaction-fee.js", "hypo_code": "var maxProfit = function(prices, fee) {\n    let n = prices.length;\n    let dp = new Array(n).fill(0);\n    let min = prices[0];\n    for(let i = 1; i < n; i++){\n        dp[i] = Math.max(dp[i - 1], prices[i] - min - fee);\n        min = Math.min(min, prices[i] - dp[i - 1]);\n    }\n    return dp[n - 1];\n    \n};"}
{"id": "925", "path": "output2\\js\\Medium\\925-maximum-length-of-repeated-subarray.js", "hypo_code": "var findLength = function(nums1, nums2) {\n    let n = nums1.length;\n    let m = nums2.length;\n    let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(0));\n    let result = 0;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            if(nums1[i - 1] == nums2[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n                result = Math.max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "926", "path": "output2\\js\\Medium\\926-longest-word-in-dictionary.js", "hypo_code": "var longestWord = function(words) {\n    let result = \"\";\n    let set = new Set(words);\n    for(let i = 0; i < words.length; i++){\n        let temp = words[i];\n        let flag = true;\n        for(let j = 1; j < temp.length; j++){\n            if(!set.has(temp.substring(0, j))){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            if(temp.length > result.length){\n                result = temp;\n            }else if(temp.length == result.length){\n                result = temp.localeCompare(result) < 0 ? temp : result;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "927", "path": "output2\\js\\Medium\\927-accounts-merge.js", "hypo_code": "var accountsMerge = function(accounts) {\n    let map = new Map();\n    for(let i = 0; i < accounts.length; i++){\n        for(let j = 1; j < accounts[i].length; j++){\n            if(map.has(accounts[i][j])){\n                map.set(accounts[i][j], map.get(accounts[i][j]).concat([i]));\n            }else{\n                map.set(accounts[i][j], [i]);\n            }\n        }\n    }\n    let visited = new Array(accounts.length).fill(false);\n    let result = [];\n    for(let i = 0; i < accounts.length; i++){\n        if(!visited[i]){\n            let set = new Set();\n            let queue = [i];\n            while(queue.length > 0){\n                let index = queue.shift();\n                if(!visited[index]){\n                    visited[index] = true;\n                    for(let j = 1; j < accounts[index].length; j++){\n                        set.add(accounts[index][j]);\n                    }\n                    for(let j = 1; j < accounts[index].length; j++){\n                        for(let k = 0; k < map.get(accounts[index][j]).length; k++){\n                            if(!visited[map.get(accounts[index][j])[k]]){\n                                queue.push(map.get(accounts[index][j])[k]);\n                            }\n                        }\n                    }\n                }\n            }\n            let arr = Array.from(set);\n            arr.sort();\n            arr.unshift(accounts[i][0]);\n            result.push(arr);\n        }\n    }\n    return result;\n    \n};"}
{"id": "928", "path": "output2\\js\\Medium\\928-remove-comments.js", "hypo_code": "var removeComments = function(source) {\n    let result = [];\n    let flag = false;\n    for(let i = 0; i < source.length; i++){\n        let temp = \"\";\n        for(let j = 0; j < source[i].length; j++){\n            if(!flag){\n                if(source[i][j] == \"/\" && source[i][j + 1] == \"/\"){\n                    break;\n                }else if(source[i][j] == \"/\" && source[i][j + 1] == \"*\"){\n                    flag = true;\n                    j++;\n                }else{\n                    temp += source[i][j];\n                }\n            }else{\n                if(source[i][j] == \"*\" && source[i][j + 1] == \"/\"){\n                    flag = false;\n                    j++;\n                }\n            }\n        }\n        if(temp.length > 0 && !flag){\n            result.push(temp);\n        }\n    }\n    return result;\n    \n};"}
{"id": "929", "path": "output2\\js\\Medium\\929-split-linked-list-in-parts.js", "hypo_code": "var splitListToParts = function(head, k) {\n    const result = new Array(k).fill(null);\n\tlet current = head;\n\tlet length = 0;\n\twhile (current) {\n\t\tlength++;\n\t\tcurrent = current.next;\n\t}\n\tlet partLength = Math.floor(length / k);\n\tlet remainder = length % k;\n\tcurrent = head;\n\tfor (let i = 0; i < k; i++) {\n\t\tresult[i] = current;\n\t\tlet currentLength = partLength;\n\t\tif (remainder > 0) {\n\t\t\tcurrentLength++;\n\t\t\tremainder--;\n\t\t}\n\t\tfor (let j = 0; j < currentLength - 1 && current; j++) {\n\t\t\tcurrent = current.next;\n\t\t}\n\t\tif (current) {\n\t\t\tconst temp = current.next;\n\t\t\tcurrent.next = null;\n\t\t\tcurrent = temp;\n\t\t}\n\t}\n\treturn result;\n};"}
{"id": "932", "path": "output2\\js\\Medium\\932-asteroid-collision.js", "hypo_code": "var asteroidCollision = function(asteroids) {\n    const stack = [];\n    for (let i = 0; i < asteroids.length; i++) {\n        const asteroid = asteroids[i];\n        if (asteroid < 0) {\n            while (stack.length && stack[stack.length - 1] > 0 && stack[stack.length - 1] < Math.abs(asteroid)) {\n                stack.pop();\n            }\n            if (stack.length && stack[stack.length - 1] === Math.abs(asteroid)) {\n                stack.pop();\n            } else if (!stack.length || stack[stack.length - 1] < 0) {\n                stack.push(asteroid);\n            }\n        } else {\n            stack.push(asteroid);\n        }\n    }\n    return stack;\n};"}
{"id": "933", "path": "output2\\js\\Medium\\933-monotone-increasing-digits.js", "hypo_code": "var monotoneIncreasingDigits = function(n) {\n    const digits = n.toString().split('');\n    let i = 1;\n    while (i < digits.length && digits[i - 1] <= digits[i]) {\n        i++;\n    }\n    if (i < digits.length) {\n        while (i > 0 && digits[i - 1] > digits[i]) {\n            digits[i - 1]--;\n            i--;\n        }\n        for (let j = i + 1; j < digits.length; j++) {\n            digits[j] = '9';\n        }\n    }\n    return parseInt(digits.join(''));\n};"}
{"id": "934", "path": "output2\\js\\Medium\\934-daily-temperatures.js", "hypo_code": "var dailyTemperatures = function(temperatures) {\n    \n};"}
{"id": "935", "path": "output2\\js\\Medium\\935-delete-and-earn.js", "hypo_code": "var deleteAndEarn = function(nums) {\n    const numCount = new Array(10001).fill(0);\n    for (const num of nums) {\n        numCount[num]++;\n    }\n    const dp = new Array(10001).fill(0);\n    dp[1] = numCount[1];\n    for (let i = 2; i < dp.length; i++) {\n        dp[i] = Math.max(dp[i - 1], dp[i - 2] + numCount[i] * i);\n    }\n    return dp[10000];\n};"}
{"id": "936", "path": "output2\\js\\Medium\\936-network-delay-time.js", "hypo_code": "var networkDelayTime = function(times, n, k) {\n    const INF = Number.MAX_SAFE_INTEGER;\n\tconst dist = new Array(n).fill(INF);\n\tdist[k - 1] = 0;\n\tfor (let i = 0; i < n - 1; i++) {\n\t\tfor (const [u, v, w] of times) {\n\t\t\tif (dist[u - 1] !== INF && dist[u - 1] + w < dist[v - 1]) {\n\t\t\t\tdist[v - 1] = dist[u - 1] + w;\n\t\t\t}\n\t\t}\n\t}\n\tconst maxDist = Math.max(...dist);\n\treturn maxDist === INF ? -1 : maxDist;\n};"}
{"id": "937", "path": "output2\\js\\Medium\\937-open-the-lock.js", "hypo_code": "var openLock = function(deadends, target) {\n    const deadendsSet = new Set(deadends);\n\tconst visited = new Set();\n\tconst queue = [];\n\tqueue.push('0000');\n\tvisited.add('0000');\n\tlet level = 0;\n\twhile (queue.length) {\n\t\tconst size = queue.length;\n\t\tfor (let i = 0; i < size; i++) {\n\t\t\tconst current = queue.shift();\n\t\t\tif (deadendsSet.has(current)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (current === target) {\n\t\t\t\treturn level;\n\t\t\t}\n\t\t\tfor (let j = 0; j < 4; j++) {\n\t\t\t\tconst up = upOne(current, j);\n\t\t\t\tif (!visited.has(up)) {\n\t\t\t\t\tqueue.push(up);\n\t\t\t\t\tvisited.add(up);\n\t\t\t\t}\n\t\t\t\tconst down = downOne(current, j);\n\t\t\t\tif (!visited.has(down)) {\n\t\t\t\t\tqueue.push(down);\n\t\t\t\t\tvisited.add(down);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlevel++;\n\t}\n\treturn -1;\n};\nconst upOne = (str, index) => {\n\tconst digits = str.split('');\n\tif (digits[index] === '9') {\n\t\tdigits[index] = '0';\n\t} else {\n\t\tdigits[index] = (parseInt(digits[index]) + 1).toString();\n\t}\n\treturn digits.join('');\n}\n\nconst downOne = (str, index) => {\n\tconst digits = str.split('');\n\tif (digits[index] === '0') {\n\t\tdigits[index] = '9';\n\t} else {\n\t\tdigits[index] = (parseInt(digits[index]) - 1).toString();\n\t}\n\treturn digits.join('');\n}"}
{"id": "938", "path": "output2\\js\\Medium\\938-reach-a-number.js", "hypo_code": "var reachNumber = function(target) {\n    target = Math.abs(target);\n    let sum = 0;\n    let step = 0;\n    while (sum < target || (sum - target) % 2 !== 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n};"}
{"id": "939", "path": "output2\\js\\Medium\\939-pyramid-transition-matrix.js", "hypo_code": "var pyramidTransition = function(bottom, allowed) {\n    const map = {};\n    for (const pattern of allowed) {\n        const key = pattern.substring(0, 2);\n        if (!map[key]) {\n            map[key] = [];\n        }\n        map[key].push(pattern[2]);\n    }\n    const dfs = (current, next, index) => {\n        if (index === current.length - 1) {\n            if (current.length === 1) {\n                return true;\n            }\n            return dfs(next, '', 0);\n        }\n        const key = current.substring(index, index + 2);\n        if (map[key]) {\n            for (const letter of map[key]) {\n                if (dfs(current, next + letter, index + 1)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    return dfs(bottom, '', 0);\n};"}
{"id": "940", "path": "output2\\js\\Medium\\940-partition-labels.js", "hypo_code": "var partitionLabels = function(s) {\n    const result = [];\n\tlet start = 0;\n\tlet end = 0;\n\tconst map = new Map();\n\tfor (let i = 0; i < s.length; i++) {\n\t\tmap.set(s[i], i);\n\t}\n\tfor (let i = 0; i < s.length; i++) {\n\t\tend = Math.max(end, map.get(s[i]));\n\t\tif (end === i) {\n\t\t\tresult.push(end - start + 1);\n\t\t\tstart = end + 1;\n\t\t}\n\t}\n\treturn result;  \n};"}
{"id": "941", "path": "output2\\js\\Medium\\941-largest-plus-sign.js", "hypo_code": "var orderOfLargestPlusSign = function(n, mines) {\n    const minesSet = new Set();\n    for (const mine of mines) {\n        minesSet.add(`${mine[0]}-${mine[1]}`);\n    }\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    let maxOrder = 0;\n    for (let i = 0; i < n; i++) {\n        let count = 0;\n        for (let j = 0; j < n; j++) {\n            count = minesSet.has(`${i}-${j}`) ? 0 : count + 1;\n            dp[i][j] = count;\n        }\n        count = 0;\n        for (let j = n - 1; j >= 0; j--) {\n            count = minesSet.has(`${i}-${j}`) ? 0 : count + 1;\n            dp[i][j] = Math.min(dp[i][j], count);\n        }\n    }\n    for (let j = 0; j < n; j++) {\n        let count = 0;\n        for (let i = 0; i < n; i++) {\n            count = minesSet.has(`${i}-${j}`) ? 0 : count + 1;\n            dp[i][j] = Math.min(dp[i][j], count);\n        }\n        count = 0;\n        for (let i = n - 1; i >= 0; i--) {\n            count = minesSet.has(`${i}-${j}`) ? 0 : count + 1;\n            dp[i][j] = Math.min(dp[i][j], count);\n            maxOrder = Math.max(maxOrder, dp[i][j]);\n        }\n    }\n    return maxOrder;\n};"}
{"id": "942", "path": "output2\\js\\Medium\\942-reorganize-string.js", "hypo_code": "var reorganizeString = function(s) {\n    const map = new Map();\n    for (let c of s) {\n        map.set(c, map.get(c) + 1 || 1);\n    }\n    const sorted = [...map.entries()].sort((a, b) => b[1] - a[1]);\n    const max = sorted[0][1];\n    if (max > (s.length + 1) / 2) {\n        return '';\n    }\n    const result = new Array(s.length);\n    let index = 0;\n    for (let [c, count] of sorted) {\n        for (let i = 0; i < count; i++) {\n            if (index >= s.length) {\n                index = 1;\n            }\n            result[index] = c;\n            index += 2;\n        }\n    }\n    return result.join('');\n};"}
{"id": "943", "path": "output2\\js\\Medium\\943-max-chunks-to-make-sorted.js", "hypo_code": "var maxChunksToSorted = function(arr) {\n    let count = 0;\n    let max = 0;\n    for (let i = 0; i < arr.length; i++) {\n        max = Math.max(max, arr[i]);\n        if (max === i) {\n            count++;\n        }\n    }\n    return count;\n};"}
{"id": "944", "path": "output2\\js\\Medium\\944-global-and-local-inversions.js", "hypo_code": "var isIdealPermutation = function(nums) {\n    let max = nums[0];\n    for (let i = 2; i < nums.length; i++) {\n        if (nums[i] < max) {\n            return false;\n        }\n        max = Math.max(max, nums[i - 1]);\n    }\n    return true;\n};"}
{"id": "945", "path": "output2\\js\\Medium\\945-swap-adjacent-in-lr-string.js", "hypo_code": "var canTransform = function(start, end) {\n    let n = start.length;\n    let i = 0;\n    let j = 0;\n    while(i < n && j < n){\n        while(i < n && start[i] == \"X\"){\n            i++;\n        }\n        while(j < n && end[j] == \"X\"){\n            j++;\n        }\n        if((i < n) ^ (j < n)){\n            return false;\n        }\n        if(i < n && j < n){\n            if(start[i] != end[j]){\n                return false;\n            }\n            if(start[i] == \"L\" && i < j){\n                return false;\n            }\n            if(start[i] == \"R\" && i > j){\n                return false;\n            }\n        }\n        i++;\n        j++;\n    }\n    return true;\n    \n};"}
{"id": "946", "path": "output2\\js\\Medium\\946-k-th-symbol-in-grammar.js", "hypo_code": "var kthGrammar = function(n, k) {\n    if(n == 1){\n        return 0;\n    }\n    let parent = kthGrammar(n - 1, Math.ceil(k / 2));\n    if(parent == 0){\n        return k % 2 == 0 ? 1 : 0;\n    }else{\n        return k % 2 == 0 ? 0 : 1;\n    }\n    \n};"}
{"id": "947", "path": "output2\\js\\Medium\\947-rabbits-in-forest.js", "hypo_code": "var numRabbits = function(answers) {\n    let map = new Map();\n    let result = 0;\n    for(let i = 0; i < answers.length; i++){\n        if(map.has(answers[i])){\n            map.set(answers[i], map.get(answers[i]) + 1);\n        }else{\n            map.set(answers[i], 1);\n        }\n    }\n    for(let [key, value] of map){\n        result += Math.ceil(value / (key + 1)) * (key + 1);\n    }\n    return result;\n    \n};"}
{"id": "948", "path": "output2\\js\\Medium\\948-letter-case-permutation.js", "hypo_code": "var letterCasePermutation = function(s) {\n    let result = [];\n    let temp = \"\";\n    dfs(0, s, temp, result);\n    return result;\n    \n    \n};"}
{"id": "949", "path": "output2\\js\\Medium\\949-is-graph-bipartite.js", "hypo_code": "var isBipartite = function(graph) {\n    let n = graph.length;\n    let color = new Array(n).fill(-1);\n    for(let i = 0; i < n; i++){\n        if(color[i] == -1){\n            let queue = [];\n            queue.push(i);\n            color[i] = 0;\n            while(queue.length > 0){\n                let node = queue.shift();\n                for(let j = 0; j < graph[node].length; j++){\n                    if(color[graph[node][j]] == -1){\n                        color[graph[node][j]] = color[node] ^ 1;\n                        queue.push(graph[node][j]);\n                    }else if(color[graph[node][j]] == color[node]){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n    \n};"}
{"id": "950", "path": "output2\\js\\Medium\\950-k-th-smallest-prime-fraction.js", "hypo_code": "var kthSmallestPrimeFraction = function(arr, k) {\n    let n = arr.length;\n    let left = 0;\n    let right = 1;\n    let result = [];\n    while(left < right){\n        let mid = left + (right - left) / 2;\n        let count = 0;\n        let max = 0;\n        let maxIndex = 0;\n        let j = 1;\n        for(let i = 0; i < n - 1; i++){\n            while(j < n && arr[i] > mid * arr[j]){\n                j++;\n            }\n            count += n - j;\n            if(j < n && max < arr[i] / arr[j]){\n                max = arr[i] / arr[j];\n                maxIndex = i;\n            }\n        }\n        if(count == k){\n            result.push(arr[maxIndex]);\n            result.push(arr[j]);\n            break;\n        }else if(count > k){\n            right = mid;\n        }else{\n            left = mid;\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "951", "path": "output2\\js\\Medium\\951-cheapest-flights-within-k-stops.js", "hypo_code": "var findCheapestPrice = function(n, flights, src, dst, k) {\n    let graph = new Array(n).fill(0).map(() => new Array());\n    for(let i = 0; i < flights.length; i++){\n        let from = flights[i][0];\n        let to = flights[i][1];\n        let price = flights[i][2];\n        graph[from].push([to, price]);\n    }\n    let pq = new PriorityQueue();\n    pq.push([src, 0, 0]);\n    while(!pq.isEmpty()){\n        let top = pq.pop();\n        let city = top[0];\n        let price = top[1];\n        let stops = top[2];\n        if(city == dst){\n            return price;\n        }\n        if(stops > k){\n            continue;\n        }\n        for(let i = 0; i < graph[city].length; i++){\n            let to = graph[city][i][0];\n            let newPrice = price + graph[city][i][1];\n            pq.push([to, newPrice, stops + 1]);\n        }\n    }\n    return -1;\n    \n    \n};"}
{"id": "952", "path": "output2\\js\\Medium\\952-rotated-digits.js", "hypo_code": "var rotatedDigits = function(n) {\n    let result = 0;\n    for(let i = 1; i <= n; i++){\n        if(isGood(i)){\n            result++;\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "953", "path": "output2\\js\\Medium\\953-escape-the-ghosts.js", "hypo_code": "var escapeGhosts = function(ghosts, target) {\n    let distance = Math.abs(target[0]) + Math.abs(target[1]);\n    for(let i = 0; i < ghosts.length; i++){\n        let ghostDistance = Math.abs(ghosts[i][0] - target[0]) + Math.abs(ghosts[i][1] - target[1]);\n        if(ghostDistance <= distance){\n            return false;\n        }\n    }\n    return true;\n    \n};"}
{"id": "954", "path": "output2\\js\\Medium\\954-domino-and-tromino-tiling.js", "hypo_code": "var numTilings = function(n) {\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for(let i = 2; i <= n; i++){\n        dp[i] = (2 * dp[i - 1] + dp[i - 3]) % 1000000007;\n    }\n    return dp[n];\n    \n};"}
{"id": "955", "path": "output2\\js\\Medium\\955-custom-sort-string.js", "hypo_code": "var customSortString = function(order, s) {\n    let n = s.length;\n    let m = order.length;\n    let result = '';\n    let orderMap = new Map();\n    for(let i = 0; i < m; i++){\n        orderMap.set(order[i], i);\n    }\n    let arr = s.split('');\n    arr.sort((a, b) => {\n        if(orderMap.has(a) && orderMap.has(b)){\n            return orderMap.get(a) - orderMap.get(b);\n        }else if(orderMap.has(a)){\n            return -1;\n        }else if(orderMap.has(b)){\n            return 1;\n        }else{\n            return 0;\n        }\n    });\n    return arr.join('');\n    \n};"}
{"id": "956", "path": "output2\\js\\Medium\\956-number-of-matching-subsequences.js", "hypo_code": "var numMatchingSubseq = function(s, words) {\n    let n = s.length;\n    let m = words.length;\n    let index = new Array(26);\n    for(let i = 0; i < 26; i++){\n        index[i] = [];\n    }\n    for(let i = 0; i < n; i++){\n        index[s.charCodeAt(i) - 97].push(i);\n    }\n    let result = 0;\n    for(let i = 0; i < m; i++){\n        let prev = -1;\n        let flag = true;\n        for(let j = 0; j < words[i].length; j++){\n            let char = words[i].charCodeAt(j) - 97;\n            let pos = binarySearch(index[char], prev);\n            if(pos == index[char].length){\n                flag = false;\n                break;\n            }\n            prev = index[char][pos];\n        }\n        if(flag){\n            result++;\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "957", "path": "output2\\js\\Medium\\957-valid-tic-tac-toe-state.js", "hypo_code": "var validTicTacToe = function(board) {\n    let xCount = 0;\n    let oCount = 0;\n    for(let i = 0; i < 3; i++){\n        for(let j = 0; j < 3; j++){\n            if(board[i][j] == 'X'){\n                xCount++;\n            }\n            if(board[i][j] == 'O'){\n                oCount++;\n            }\n        }\n    }\n    if(oCount > xCount || xCount - oCount > 1){\n        return false;\n    }\n    let xWin = checkWin(board, 'X');\n    let oWin = checkWin(board, 'O');\n    if(xWin && oWin){\n        return false;\n    }\n    if(xWin && xCount == oCount){\n        return false;\n    }\n    if(oWin && xCount > oCount){\n        return false;\n    }\n    return true;\n    \n    \n    \n};"}
{"id": "958", "path": "output2\\js\\Medium\\958-number-of-subarrays-with-bounded-maximum.js", "hypo_code": "var numSubarrayBoundedMax = function(nums, left, right) {\n    let n = nums.length;\n    let dp = new Array(n + 1).fill(0);\n    let result = 0;\n    let prev = 0;\n    for(let i = 0; i < n; i++){\n        if(nums[i] >= left && nums[i] <= right){\n            dp[i + 1] = i + 1 - prev;\n        }\n        else if(nums[i] < left){\n            dp[i + 1] = dp[i];\n        }\n        else{\n            prev = i + 1;\n        }\n        result += dp[i + 1];\n    }\n    return result;\n    \n};"}
{"id": "959", "path": "output2\\js\\Medium\\959-all-paths-from-source-to-target.js", "hypo_code": "var allPathsSourceTarget = function(graph) {\n    let n = graph.length;\n    let result = [];\n    let path = [];\n    function dfs(node){\n        path.push(node);\n        if(node == n - 1){\n            result.push([...path]);\n        }else{\n            for(let i = 0; i < graph[node].length; i++){\n                dfs(graph[node][i]);\n            }\n        }\n        path.pop();\n    }\n    dfs(0);\n    return result;\n    \n};"}
{"id": "960", "path": "output2\\js\\Medium\\960-champagne-tower.js", "hypo_code": "var champagneTower = function(poured, query_row, query_glass) {\n    let dp = new Array(query_row + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(i + 1);\n    }\n    dp[0][0] = poured;\n    for(let i = 0; i < query_row; i++){\n        for(let j = 0; j <= i; j++){\n            let q = (dp[i][j] - 1) / 2;\n            if(q > 0){\n                dp[i + 1][j] += q;\n                dp[i + 1][j + 1] += q;\n            }\n        }\n    }\n    return Math.min(1, dp[query_row][query_glass]);\n    \n};"}
{"id": "961", "path": "output2\\js\\Medium\\961-find-eventual-safe-states.js", "hypo_code": "var eventualSafeNodes = function(graph) {\n    let n = graph.length;\n    let color = new Array(n).fill(0);\n    let result = [];\n    for(let i = 0; i < n; i++){\n        if(dfs(i)){\n            result.push(i);\n        }\n    }\n    return result;\n    \n    function dfs(node){\n        if(color[node] > 0){\n            return color[node] == 2;\n        }\n        color[node] = 1;\n        for(let i = 0; i < graph[node].length; i++){\n            if(color[graph[node][i]] == 2){\n                continue;\n            }\n            if(color[graph[node][i]] == 1 || !dfs(graph[node][i])){\n                return false;\n            }\n        }\n        color[node] = 2;\n        return true;\n    }\n    \n};"}
{"id": "962", "path": "output2\\js\\Medium\\962-max-increase-to-keep-city-skyline.js", "hypo_code": "var maxIncreaseKeepingSkyline = function(grid) {\n    let n = grid.length;\n    let m = grid[0].length;\n    let topBottom = new Array(n).fill(0);\n    let leftRight = new Array(m).fill(0);\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            topBottom[i] = Math.max(topBottom[i], grid[i][j]);\n            leftRight[j] = Math.max(leftRight[j], grid[i][j]);\n        }\n    }\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            result += Math.min(topBottom[i], leftRight[j]) - grid[i][j];\n        }\n    }\n    return result;\n    \n};"}
{"id": "963", "path": "output2\\js\\Medium\\963-soup-servings.js", "hypo_code": "var soupServings = function(n) {\n    if(n >= 4800){\n        return 1;\n    }\n    let dp = new Array(Math.floor(n / 25) + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(Math.floor(n / 25) + 1);\n    }\n    return helper(Math.floor((n + 24) / 25), Math.floor((n + 24) / 25));\n    \n    function helper(a, b){\n        if(a <= 0 && b <= 0){\n            return 0.5;\n        }\n        if(a <= 0){\n            return 1;\n        }\n        if(b <= 0){\n            return 0;\n        }\n        if(dp[a][b] != undefined){\n            return dp[a][b];\n        }\n        dp[a][b] = 0.25 * (helper(a - 4, b) + helper(a - 3, b - 1) + helper(a - 2, b - 2) + helper(a - 1, b - 3));\n        return dp[a][b];\n    }\n    \n};"}
{"id": "964", "path": "output2\\js\\Medium\\964-expressive-words.js", "hypo_code": "var expressiveWords = function(s, words) {\n    let result = 0;\n    for(let i = 0; i < words.length; i++){\n        if(isStretchy(s, words[i])){\n            result++;\n        }\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "965", "path": "output2\\js\\Medium\\965-subdomain-visit-count.js", "hypo_code": "var subdomainVisits = function(cpdomains) {\n    let result = [];\n    let map = new Map();\n    for(let i = 0; i < cpdomains.length; i++){\n        let [count, domain] = cpdomains[i].split(\" \");\n        let subdomains = domain.split(\".\");\n        let temp = \"\";\n        for(let j = subdomains.length - 1; j >= 0; j--){\n            temp = subdomains[j] + (j < subdomains.length - 1 ? \".\" : \"\") + temp;\n            if(map.has(temp)){\n                map.set(temp, map.get(temp) + parseInt(count));\n            }else{\n                map.set(temp, parseInt(count));\n            }\n        }\n    }\n    for(let [key, value] of map){\n        result.push(value + \" \" + key);\n    }\n    return result;\n    \n};"}
{"id": "966", "path": "output2\\js\\Medium\\966-largest-sum-of-averages.js", "hypo_code": "var largestSumOfAverages = function(nums, k) {\n    let n = nums.length;\n    let dp = new Array(n + 1).fill(0);\n    let sum = new Array(n + 1).fill(0);\n    for(let i = 0; i < n; i++){\n        sum[i + 1] = sum[i] + nums[i];\n        dp[i + 1] = (sum[i + 1] * 1.0) / (i + 1);\n    }\n    for(let i = 2; i <= k; i++){\n        for(let j = n; j >= i; j--){\n            for(let p = i - 1; p < j; p++){\n                dp[j] = Math.max(dp[j], dp[p] + (sum[j] - sum[p]) * 1.0 / (j - p));\n            }\n        }\n    }\n    return dp[n];\n    \n};"}
{"id": "967", "path": "output2\\js\\Medium\\967-binary-tree-pruning.js", "hypo_code": "var pruneTree = function(root) {\n    if(root == null){\n        return null;\n    }\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n    if(root.left == null && root.right == null && root.val == 0){\n        return null;\n    }\n    return root;\n    \n};"}
{"id": "968", "path": "output2\\js\\Medium\\968-ambiguous-coordinates.js", "hypo_code": "var ambiguousCoordinates = function(s) {\n    let n = s.length;\n    let result = [];\n    for(let i = 1; i < n - 1; i++){\n        let left = generate(s.substring(1, i + 1));\n        let right = generate(s.substring(i + 1, n - 1));\n        for(let j = 0; j < left.length; j++){\n            for(let k = 0; k < right.length; k++){\n                result.push('(' + left[j] + ', ' + right[k] + ')');\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "969", "path": "output2\\js\\Medium\\969-linked-list-components.js", "hypo_code": "var numComponents = function(head, nums) {\n    let result = 0;\n    let set = new Set();\n    for(let i = 0; i < nums.length; i++){\n        set.add(nums[i]);\n    }\n    let current = head;\n    let connected = false;\n    while(current != null){\n        if(set.has(current.val)){\n            if(!connected){\n                result++;\n                connected = true;\n            }\n        }else{\n            connected = false;\n        }\n        current = current.next;\n    }\n    return result;\n    \n};"}
{"id": "970", "path": "output2\\js\\Medium\\970-short-encoding-of-words.js", "hypo_code": "var minimumLengthEncoding = function(words) {\n    let n = words.length;\n    let trie = new Trie();\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        trie.insert(words[i]);\n    }\n    for(let i = 0; i < n; i++){\n        result += trie.search(words[i]);\n    }\n    return result;\n    \n    \n};"}
{"id": "971", "path": "output2\\js\\Medium\\971-card-flipping-game.js", "hypo_code": "var flipgame = function(fronts, backs) {\n    let n = fronts.length;\n    let set = new Set();\n    for(let i = 0; i < n; i++){\n        if(fronts[i] == backs[i]){\n            set.add(fronts[i]);\n        }\n    }\n    let result = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n; i++){\n        if(!set.has(fronts[i])){\n            result = Math.min(result, fronts[i]);\n        }\n        if(!set.has(backs[i])){\n            result = Math.min(result, backs[i]);\n        }\n    }\n    return result == Number.MAX_SAFE_INTEGER ? 0 : result;\n    \n};"}
{"id": "972", "path": "output2\\js\\Medium\\972-binary-trees-with-factors.js", "hypo_code": "var numFactoredBinaryTrees = function(arr) {\n    let n = arr.length;\n    let mod = 1000000007;\n    let dp = new Array(n).fill(0);\n    let map = new Map();\n    arr.sort((a, b) => a - b);\n    for(let i = 0; i < n; i++){\n        dp[i] = 1;\n        map.set(arr[i], i);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < i; j++){\n            if(arr[i] % arr[j] == 0){\n                let right = arr[i] / arr[j];\n                if(map.has(right)){\n                    dp[i] = (dp[i] + (dp[j] * dp[map.get(right)]) % mod) % mod;\n                }\n            }\n        }\n    }\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        result = (result + dp[i]) % mod;\n    }\n    return result;\n    \n};"}
{"id": "973", "path": "output2\\js\\Medium\\973-friends-of-appropriate-ages.js", "hypo_code": "var numFriendRequests = function(ages) {\n    let result = 0;\n    let count = new Array(121).fill(0);\n    for(let i = 0; i < ages.length; i++){\n        count[ages[i]]++;\n    }\n    for(let i = 15; i <= 120; i++){\n        for(let j = 15; j <= 120; j++){\n            if(i * 0.5 + 7 >= j){\n                continue;\n            }\n            if(i < j){\n                continue;\n            }\n            if(i < 100 && j > 100){\n                continue;\n            }\n            result += count[i] * (count[j] - (i == j ? 1 : 0));\n        }\n    }\n    return result;\n    \n};"}
{"id": "974", "path": "output2\\js\\Medium\\974-most-profit-assigning-work.js", "hypo_code": "var maxProfitAssignment = function(difficulty, profit, worker) {\n    let n = difficulty.length;\n    let jobs = [];\n    for(let i = 0; i < n; i++){\n        jobs.push([difficulty[i], profit[i]]);\n    }\n    jobs.sort((a, b) => a[0] - b[0]);\n    let result = 0;\n    let maxProfit = 0;\n    let i = 0;\n    worker.sort((a, b) => a - b);\n    for(let ability of worker){\n        while(i < n && ability >= jobs[i][0]){\n            maxProfit = Math.max(maxProfit, jobs[i][1]);\n            i++;\n        }\n        result += maxProfit;\n    }\n    return result;\n    \n};"}
{"id": "975", "path": "output2\\js\\Medium\\975-masking-personal-information.js", "hypo_code": "var maskPII = function(s) {\n    let n = s.length;\n    let at = s.indexOf('@');\n    if(at >= 0){\n        let name = s.substring(0, at);\n        let domain = s.substring(at + 1, n);\n        return name[0].toLowerCase() + '*****' + name[name.length - 1].toLowerCase() + '@' + domain.toLowerCase();\n    }\n    let digits = [];\n    for(let i = 0; i < n; i++){\n        if(s[i] >= '0' && s[i] <= '9'){\n            digits.push(s[i]);\n        }\n    }\n    let local = digits.slice(digits.length - 4, digits.length);\n    let country = digits.slice(0, digits.length - 10);\n    let result = '';\n    if(country.length > 0){\n        result += '+';\n        for(let i = 0; i < country.length; i++){\n            result += '*';\n        }\n        result += '-';\n    }\n    result += '***-***-';\n    for(let i = 0; i < local.length; i++){\n        result += local[i];\n    }\n    return result;\n    \n};"}
{"id": "976", "path": "output2\\js\\Medium\\976-find-and-replace-in-string.js", "hypo_code": "var findReplaceString = function(s, indices, sources, targets) {\n    let result = '';\n    let i = 0;\n    let j = 0;\n    while(i < s.length){\n        if(j < indices.length && i === indices[j]){\n            if(s.substring(i, i + sources[j].length) === sources[j]){\n                result += targets[j];\n                i += sources[j].length;\n            }else{\n                result += s[i];\n                i++;\n            }\n            j++;\n        }else{\n            result += s[i];\n            i++;\n        }\n    }\n    return result;\n    \n};"}
{"id": "977", "path": "output2\\js\\Medium\\977-image-overlap.js", "hypo_code": "var largestOverlap = function(img1, img2) {\n    let n = img1.length;\n    let max = 0;\n    for(let i = -n + 1; i < n; i++){\n        for(let j = -n + 1; j < n; j++){\n            max = Math.max(max, countOverlap(img1, img2, i, j));\n        }\n    }\n    return max;\n    \n    \n};"}
{"id": "978", "path": "output2\\js\\Medium\\978-new-21-game.js", "hypo_code": "var new21Game = function(n, k, maxPts) {\n    if(k == 0 || n >= k + maxPts){\n        return 1;\n    }\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    let sum = 1;\n    for(let i = 1; i <= n; i++){\n        dp[i] = sum * 1.0 / maxPts;\n        if(i < k){\n            sum += dp[i];\n        }\n        if(i - maxPts >= 0){\n            sum -= dp[i - maxPts];\n        }\n    }\n    return sum;\n    \n};"}
{"id": "979", "path": "output2\\js\\Medium\\979-push-dominoes.js", "hypo_code": "var pushDominoes = function(dominoes) {\n    let n = dominoes.length;\n    let result = new Array(n).fill('.');\n    let left = -1;\n    let right = -1;\n    for(let i = 0; i < n; i++){\n        if(dominoes[i] == 'R'){\n            right = i;\n            result[i] = 'R';\n        }\n        else if(dominoes[i] == 'L'){\n            if(right == -1){\n                for(let j = left + 1; j < i; j++){\n                    result[j] = 'L';\n                }\n            }\n            else{\n                let j = right + 1;\n                let k = i - 1;\n                while(j < k){\n                    result[j] = 'R';\n                    result[k] = 'L';\n                    j++;\n                    k--;\n                }\n                if(j == k){\n                    result[j] = '.';\n                }\n                right = -1;\n            }\n            left = i;\n        }\n    }\n    if(right != -1){\n        for(let j = right + 1; j < n; j++){\n            result[j] = 'R';\n        }\n    }\n    return result.join('');    \n};"}
{"id": "980", "path": "output2\\js\\Medium\\980-magic-squares-in-grid.js", "hypo_code": "var numMagicSquaresInside = function(grid) {\n    let count = 0;\n    for(let i = 0; i < grid.length - 2; i++){\n        for(let j = 0; j < grid[0].length - 2; j++){\n            if(grid[i + 1][j + 1] != 5){\n                continue;\n            }\n            if(isMagic(grid, i, j)){\n                count++;\n            }\n        }\n    }\n    return count;\n    \n    \n    \n};"}
{"id": "981", "path": "output2\\js\\Medium\\981-keys-and-rooms.js", "hypo_code": "var canVisitAllRooms = function(rooms) {\n    let visited = new Array(rooms.length).fill(false);\n    let stack = [];\n    stack.push(0);\n    while(stack.length > 0){\n        let room = stack.pop();\n        if(visited[room]){\n            continue;\n        }\n        visited[room] = true;\n        for(let i = 0; i < rooms[room].length; i++){\n            stack.push(rooms[room][i]);\n        }\n    }\n    for(let i = 0; i < visited.length; i++){\n        if(!visited[i]){\n            return false;\n        }\n    }\n    return true;\n    \n};"}
{"id": "982", "path": "output2\\js\\Medium\\982-split-array-into-fibonacci-sequence.js", "hypo_code": "var splitIntoFibonacci = function(num) {\n    let result = [];\n    let n = num.length;\n    let backtrack = function(index){\n        if(index == n && result.length >= 3){\n            return true;\n        }\n        let current = 0;\n        for(let i = index; i < n; i++){\n            if(i > index && num[index] == '0'){\n                break;\n            }\n            current = current * 10 + (num[i] - '0');\n            if(current > 2 ** 31 - 1){\n                break;\n            }\n            let len = result.length;\n            if(len >= 2 && current > result[len - 1] + result[len - 2]){\n                break;\n            }\n            if(len <= 1 || current == result[len - 1] + result[len - 2]){\n                result.push(current);\n                if(backtrack(i + 1)){\n                    return true;\n                }\n                result.pop();\n            }\n        }\n        return false;\n    }\n    backtrack(0);\n    return result;\n    \n};"}
{"id": "983", "path": "output2\\js\\Medium\\983-longest-mountain-in-array.js", "hypo_code": "var longestMountain = function(arr) {\n    let n = arr.length;\n    let left = new Array(n).fill(0);\n    let right = new Array(n).fill(0);\n    for(let i = 1; i < n; i++){\n        if(arr[i] > arr[i - 1]){\n            left[i] = left[i - 1] + 1;\n        }\n    }\n    for(let i = n - 2; i >= 0; i--){\n        if(arr[i] > arr[i + 1]){\n            right[i] = right[i + 1] + 1;\n        }\n    }\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        if(left[i] > 0 && right[i] > 0){\n            result = Math.max(result, left[i] + right[i] + 1);\n        }\n    }\n    return result;\n    \n};"}
{"id": "984", "path": "output2\\js\\Medium\\984-hand-of-straights.js", "hypo_code": "var isNStraightHand = function(hand, groupSize) {\n    if(hand.length % groupSize != 0){\n        return false;\n    }\n    let map = {};\n    for(let i = 0; i < hand.length; i++){\n        let num = hand[i];\n        if(map[num] == undefined){\n            map[num] = 0;\n        }\n        map[num]++;\n    }\n    let keys = Object.keys(map);\n    keys.sort((a, b) => a - b);\n    for(let i = 0; i < keys.length; i++){\n        let key = keys[i];\n        let count = map[key];\n        if(count == 0){\n            continue;\n        }\n        for(let j = 1; j < groupSize; j++){\n            let next = parseInt(key) + j;\n            if(map[next] == undefined || map[next] < count){\n                return false;\n            }\n            map[next] -= count;\n        }\n    }\n    return true;\n    \n    \n};"}
{"id": "985", "path": "output2\\js\\Medium\\985-shifting-letters.js", "hypo_code": "var shiftingLetters = function(s, shifts) {\n    let n = s.length;\n    let result = new Array(n);\n    let sum = 0;\n    for(let i = n - 1; i >= 0; i--){\n        sum = (sum + shifts[i]) % 26;\n        result[i] = String.fromCharCode((s.charCodeAt(i) - 'a'.charCodeAt(0) + sum) % 26 + 'a'.charCodeAt(0));\n    }\n    return result.join('');\n    \n};"}
{"id": "986", "path": "output2\\js\\Medium\\986-maximize-distance-to-closest-person.js", "hypo_code": "var maxDistToClosest = function(seats) {\n    let max = 0;\n    let left = 0;\n    let right = 0;\n    let count = 0;\n    while(right < seats.length){\n        while(seats[right] == 1){\n            count--;\n            left++;\n        }\n        count++;\n        max = Math.max(max, count);\n        right++;\n    }\n    return max;\n    \n};"}
{"id": "987", "path": "output2\\js\\Medium\\987-loud-and-rich.js", "hypo_code": "var loudAndRich = function(richer, quiet) {\n    let n = quiet.length;\n    let result = new Array(n).fill(-1);\n    let graph = new Array(n).fill(0).map(() => new Array());\n    for(let i = 0; i < richer.length; i++){\n        let [a, b] = richer[i];\n        graph[b].push(a);\n    }\n    for(let i = 0; i < n; i++){\n        dfs(i, graph, quiet, result);\n    }\n    return result;\n    \n    \n};"}
{"id": "988", "path": "output2\\js\\Medium\\988-peak-index-in-a-mountain-array.js", "hypo_code": "var peakIndexInMountainArray = function(arr) {\n    let n = arr.length;\n    let left = 0;\n    let right = n - 1;\n    while(left < right){\n        let mid = Math.floor((left + right) / 2);\n        if(arr[mid] < arr[mid + 1]){\n            left = mid + 1;\n        }else{\n            right = mid;\n        }\n    }\n    return left;\n    \n};"}
{"id": "989", "path": "output2\\js\\Medium\\989-car-fleet.js", "hypo_code": "var carFleet = function(target, position, speed) {\n    \n    let cars = [];\n    for(let i = 0; i < position.length; i++){\n        cars.push([position[i], speed[i]]);\n    }\n    cars.sort((a, b) => b[0] - a[0]);\n    let fleets = 0;\n    let maxTime = 0;\n    for(let i = 0; i < cars.length; i++){\n        let time = (target - cars[i][0]) / cars[i][1];\n        if(time > maxTime){\n            maxTime = time;\n            fleets++;\n        }\n    }\n    return fleets;\n};"}
{"id": "991", "path": "output2\\js\\Medium\\991-score-of-parentheses.js", "hypo_code": "var scoreOfParentheses = function(s) {\n    let stack = [];\n    let result = 0;\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == '('){\n            stack.push(result);\n            result = 0;\n        }else{\n            result = stack.pop() + Math.max(result * 2, 1);\n        }\n    }\n    return result;\n    \n};"}
{"id": "992", "path": "output2\\js\\Medium\\992-mirror-reflection.js", "hypo_code": "var mirrorReflection = function(p, q) {\n    let m = 1;\n    let n = 1;\n    while(m * p != n * q){\n        n++;\n        m = Math.floor(n * q / p);\n    }\n    if(m % 2 == 0){\n        return 2;\n    }else if(n % 2 == 0){\n        return 0;\n    }else{\n        return 1;\n    }\n    \n};"}
{"id": "993", "path": "output2\\js\\Medium\\993-score-after-flipping-matrix.js", "hypo_code": "var matrixScore = function(grid) {\n    let result = 0;\n    for(let i = 0; i < grid.length; i++){\n        if(grid[i][0] == 0){\n            for(let j = 0; j < grid[0].length; j++){\n                grid[i][j] = 1 - grid[i][j];\n            }\n        }\n    }\n    for(let j = 0; j < grid[0].length; j++){\n        let count = 0;\n        for(let i = 0; i < grid.length; i++){\n            if(grid[i][j] == 1){\n                count++;\n            }\n        }\n        if(count < grid.length / 2){\n            for(let i = 0; i < grid.length; i++){\n                grid[i][j] = 1 - grid[i][j];\n            }\n        }\n    }\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[0].length; j++){\n            result += grid[i][j] * Math.pow(2, grid[0].length - j - 1);\n        }\n    }\n    return result;\n    \n};"}
{"id": "994", "path": "output2\\js\\Medium\\994-all-nodes-distance-k-in-binary-tree.js", "hypo_code": "var distanceK = function(root, target, k) {\n    let map = {};\n    let result = [];\n    let queue = [];\n    let visited = new Set();\n    queue.push(root);\n    visited.add(root);\n    while(queue.length > 0){\n        let node = queue.shift();\n        if(node.left != null){\n            map[node.left.val] = node;\n            queue.push(node.left);\n            visited.add(node.left);\n        }\n        if(node.right != null){\n            map[node.right.val] = node;\n            queue.push(node.right);\n            visited.add(node.right);\n        }\n    }\n    queue.push(target);\n    visited.add(target);\n    let level = 0;\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let node = queue.shift();\n            if(level == k){\n                result.push(node.val);\n            }\n            if(node.left != null && !visited.has(node.left)){\n                queue.push(node.left);\n                visited.add(node.left);\n            }\n            if(node.right != null && !visited.has(node.right)){\n                queue.push(node.right);\n                visited.add(node.right);\n            }\n            if(map[node.val] != null && !visited.has(map[node.val])){\n                queue.push(map[node.val]);\n                visited.add(map[node.val]);\n            }\n        }\n        level++;\n    }\n    return result;\n    \n};"}
{"id": "995", "path": "output2\\js\\Medium\\995-smallest-subtree-with-all-the-deepest-nodes.js", "hypo_code": "var subtreeWithAllDeepest = function(root) {\n    let map = {};\n    let queue = [];\n    let visited = new Set();\n    queue.push(root);\n    visited.add(root);\n    while(queue.length > 0){\n        let node = queue.shift();\n        if(node.left != null){\n            map[node.left.val] = node;\n            queue.push(node.left);\n            visited.add(node.left);\n        }\n        if(node.right != null){\n            map[node.right.val] = node;\n            queue.push(node.right);\n            visited.add(node.right);\n        }\n    }\n    queue.push(root);\n    visited.add(root);\n    let result = root;\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let node = queue.shift();\n            if(node.left != null && !visited.has(node.left)){\n                queue.push(node.left);\n                visited.add(node.left);\n            }\n            if(node.right != null && !visited.has(node.right)){\n                queue.push(node.right);\n                visited.add(node.right);\n            }\n            if(map[node.val] != null && !visited.has(map[node.val])){\n                queue.push(map[node.val]);\n                visited.add(map[node.val]);\n            }\n        }\n        if(queue.length > 0){\n            result = queue[0];\n        }\n    }\n    return result;\n    \n};"}
{"id": "996", "path": "output2\\js\\Medium\\996-prime-palindrome.js", "hypo_code": "var primePalindrome = function(n) {\n    let isPrime = function(n){\n        if(n < 2){\n            return false;\n        }\n        let m = Math.floor(Math.sqrt(n));\n        for(let i = 2; i <= m; i++){\n            if(n % i == 0){\n                return false;\n            }\n        }\n        return true;\n    };\n    let isPalindrome = function(n){\n        let str = n.toString();\n        let left = 0;\n        let right = str.length - 1;\n        while(left < right){\n            if(str[left] != str[right]){\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    };\n    if(n <= 2){\n        return 2;\n    }\n    if(n <= 3){\n        return 3;\n    }\n    if(n <= 5){\n        return 5;\n    }\n    if(n <= 7){\n        return 7;\n    }\n    if(n <= 11){\n        return 11;\n    }\n    let left = Math.floor(n / 100);\n    let right = left + 1;\n    while(true){\n        let leftStr = left.toString();\n        let rightStr = right.toString();\n        let leftPalindrome = parseInt(leftStr + leftStr.split(\"\").reverse().join(\"\"));\n        let rightPalindrome = parseInt(rightStr + rightStr.split(\"\").reverse().join(\"\"));\n        if(leftPalindrome >= n && isPrime(leftPalindrome)){\n            return leftPalindrome;\n        }\n        if(rightPalindrome >= n && isPrime(rightPalindrome)){\n            return rightPalindrome;\n        }\n        left++;\n        right++;\n    }\n    \n};"}
{"id": "997", "path": "output2\\js\\Medium\\997-reordered-power-of-2.js", "hypo_code": "var reorderedPowerOf2 = function(n) {\n    let count = new Array(10).fill(0);\n    while(n > 0){\n        count[n % 10]++;\n        n = Math.floor(n / 10);\n    }\n    for(let i = 0; i < 31; i++){\n        let temp = new Array(10).fill(0);\n        let num = 1 << i;\n        while(num > 0){\n            temp[num % 10]++;\n            num = Math.floor(num / 10);\n        }\n        if(isEqual(count, temp)){\n            return true;\n        }\n    }\n    return false;\n    \n    \n};"}
{"id": "998", "path": "output2\\js\\Medium\\998-advantage-shuffle.js", "hypo_code": "var advantageCount = function(nums1, nums2) {\n    let n = nums1.length;\n    let m = nums2.length;\n    let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(0));\n    let result = 0;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            if(nums1[i - 1] == nums2[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n                result = Math.max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "999", "path": "output2\\js\\Medium\\999-length-of-longest-fibonacci-subsequence.js", "hypo_code": "var lenLongestFibSubseq = function(arr) {\n    let n = arr.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    let result = 0;\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        map.set(arr[i], i);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = i + 1; j < n; j++){\n            let k = map.get(arr[j] - arr[i]);\n            if(k !== undefined && k < i){\n                dp[i][j] = dp[k][i] + 1;\n                result = Math.max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1000", "path": "output2\\js\\Medium\\1000-walking-robot-simulation.js", "hypo_code": "var robotSim = function(commands, obstacles) {\n    let x = 0;\n    let y = 0;\n    let max = 0;\n    let dir = 0;\n    let dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    let obs = new Set();\n    for(let i = 0; i < obstacles.length; i++){\n        obs.add(obstacles[i][0] + \" \" + obstacles[i][1]);\n    }\n    for(let i = 0; i < commands.length; i++){\n        if(commands[i] == -1){\n            dir = (dir + 1) % 4;\n        }else if(commands[i] == -2){\n            dir = (dir + 3) % 4;\n        }else{\n            for(let j = 0; j < commands[i]; j++){\n                let newX = x + dirs[dir][0];\n                let newY = y + dirs[dir][1];\n                if(!obs.has(newX + \" \" + newY)){\n                    x = newX;\n                    y = newY;\n                    max = Math.max(max, x * x + y * y);\n                }else{\n                    break;\n                }\n            }\n        }\n    }\n    return max;\n    \n};"}
{"id": "1001", "path": "output2\\js\\Medium\\1001-koko-eating-bananas.js", "hypo_code": "var minEatingSpeed = function(piles, h) {\n    let left = 1;\n    let right = Math.max(...piles);\n    while(left < right){\n        let mid = Math.floor((left + right) / 2);\n        if(canFinish(piles, h, mid)){\n            right = mid;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return left;\n    \n};"}
{"id": "1002", "path": "output2\\js\\Medium\\1002-stone-game.js", "hypo_code": "var stoneGame = function(piles) {\n    let left = 0;\n    let right = piles.length - 1;\n    let alex = 0;\n    let bob = 0;\n    while(left < right){\n        if(piles[left] > piles[right]){\n            alex += piles[left];\n            left++;\n        }else{\n            alex += piles[right];\n            right--;\n        }\n        if(piles[left] > piles[right]){\n            bob += piles[left];\n            left++;\n        }else{\n            bob += piles[right];\n            right--;\n        }\n    }\n    return alex > bob;\n    \n};"}
{"id": "1003", "path": "output2\\js\\Medium\\1003-decoded-string-at-index.js", "hypo_code": "var decodeAtIndex = function(s, k) {\n    let n = s.length;\n    let size = 0;\n    for(let i = 0; i < n; i++){\n        if(!isNaN(s[i])){\n            size *= s[i];\n        }else{\n            size++;\n        }\n    }\n    for(let i = n - 1; i >= 0; i--){\n        k %= size;\n        if(k == 0 && isNaN(s[i])){\n            return s[i];\n        }\n        if(!isNaN(s[i])){\n            size /= s[i];\n        }else{\n            size--;\n        }\n    }\n    return \"\";\n    \n};"}
{"id": "1004", "path": "output2\\js\\Medium\\1004-boats-to-save-people.js", "hypo_code": "var numRescueBoats = function(people, limit) {\n    let n = people.length;\n    let result = 0;\n    people.sort((a, b) => a - b);\n    let i = 0;\n    let j = n - 1;\n    while(i <= j){\n        if(people[i] + people[j] <= limit){\n            i++;\n        }\n        j--;\n        result++;\n    }\n    return result;\n    \n};"}
{"id": "1005", "path": "output2\\js\\Medium\\1005-spiral-matrix-iii.js", "hypo_code": "var spiralMatrixIII = function(rows, cols, rStart, cStart) {\n    let result = [];\n    let r = rStart;\n    let c = cStart;\n    let count = 0;\n    let direction = 0;\n    let step = 1;\n    while(count < rows * cols){\n        if(r >= 0 && r < rows && c >= 0 && c < cols){\n            result.push([r, c]);\n            count++;\n        }\n        if(direction == 0){\n            c++;\n            if(c == cStart + step){\n                direction = 1;\n            }\n        }else if(direction == 1){\n            r++;\n            if(r == rStart + step){\n                direction = 2;\n            }\n        }else if(direction == 2){\n            c--;\n            if(c == cStart - step){\n                direction = 3;\n            }\n        }else if(direction == 3){\n            r--;\n            if(r == rStart - step){\n                direction = 0;\n                step++;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1006", "path": "output2\\js\\Medium\\1006-possible-bipartition.js", "hypo_code": "var possibleBipartition = function(n, dislikes) {\n    let graph = new Array(n + 1).fill(0).map(() => []);\n    for(let i = 0; i < dislikes.length; i++){\n        graph[dislikes[i][0]].push(dislikes[i][1]);\n        graph[dislikes[i][1]].push(dislikes[i][0]);\n    }\n    let colors = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        if(colors[i] == 0 && !dfs(i, 1)){\n            return false;\n        }\n    }\n    return true;\n    \n    function dfs(node, color){\n        if(colors[node] != 0){\n            return colors[node] == color;\n        }\n        colors[node] = color;\n        for(let i = 0; i < graph[node].length; i++){\n            if(!dfs(graph[node][i], -color)){\n                return false;\n            }\n        }\n        return true;\n    }\n    \n};"}
{"id": "1007", "path": "output2\\js\\Medium\\1007-construct-binary-tree-from-preorder-and-postorder-traversal.js", "hypo_code": "var constructFromPrePost = function(preorder, postorder) {\n    if(preorder.length == 0 || postorder.length == 0){\n        return null;\n    }\n    let root = new TreeNode(preorder[0]);\n    if(preorder.length == 1){\n        return root;\n    }\n    let leftPreorder = preorder.slice(1, postorder.indexOf(preorder[1]) + 2);\n    let rightPreorder = preorder.slice(postorder.indexOf(preorder[1]) + 2);\n    let leftPostorder = postorder.slice(0, postorder.indexOf(preorder[1]) + 1);\n    let rightPostorder = postorder.slice(postorder.indexOf(preorder[1]) + 1, postorder.length - 1);\n    root.left = constructFromPrePost(leftPreorder, leftPostorder);\n    root.right = constructFromPrePost(rightPreorder, rightPostorder);\n    return root;\n    \n};"}
{"id": "1008", "path": "output2\\js\\Medium\\1008-find-and-replace-pattern.js", "hypo_code": "var findAndReplacePattern = function(words, pattern) {\n    let result = [];\n    for(let i = 0; i < words.length; i++){\n        let word = words[i];\n        let map = {};\n        let visited = new Set();\n        let flag = true;\n        for(let j = 0; j < word.length; j++){\n            if(map[word[j]] == null){\n                if(visited.has(pattern[j])){\n                    flag = false;\n                    break;\n                }\n                map[word[j]] = pattern[j];\n                visited.add(pattern[j]);\n            }else{\n                if(map[word[j]] != pattern[j]){\n                    flag = false;\n                    break;\n                }\n            }\n        }\n        if(flag){\n            result.push(word);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1009", "path": "output2\\js\\Medium\\1009-groups-of-special-equivalent-strings.js", "hypo_code": "var numSpecialEquivGroups = function(words) {\n    let result = 0;\n    let set = new Set();\n    for(let i = 0; i < words.length; i++){\n        let odd = \"\";\n        let even = \"\";\n        for(let j = 0; j < words[i].length; j++){\n            if(j % 2 == 0){\n                even += words[i][j];\n            } else {\n                odd += words[i][j];\n            }\n        }\n        even = even.split(\"\").sort().join(\"\");\n        odd = odd.split(\"\").sort().join(\"\");\n        if(!set.has(even + odd)){\n            result++;\n            set.add(even + odd);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1010", "path": "output2\\js\\Medium\\1010-all-possible-full-binary-trees.js", "hypo_code": "var allPossibleFBT = function(n) {\n    if(n % 2 == 0){\n        return [];\n    }\n    let map = {};\n    return helper(n, map);\n    \n};"}
{"id": "1011", "path": "output2\\js\\Medium\\1011-bitwise-ors-of-subarrays.js", "hypo_code": "var subarrayBitwiseORs = function(arr) {\n    let n = arr.length;\n    let set = new Set();\n    let prev = new Set();\n    for(let i = 0; i < n; i++){\n        let curr = new Set();\n        curr.add(arr[i]);\n        for(let x of prev){\n            curr.add(x | arr[i]);\n        }\n        for(let x of curr){\n            set.add(x);\n        }\n        prev = curr;\n    }\n    return set.size;\n    \n};"}
{"id": "1014", "path": "output2\\js\\Medium\\1014-fruit-into-baskets.js", "hypo_code": "var totalFruit = function(fruits) {\n    let map = {};\n    let result = 0;\n    let j = 0;\n    for(let i = 0; i < fruits.length; i++){\n        map[fruits[i]] = map[fruits[i]] + 1 || 1;\n        while(Object.keys(map).length > 2){\n            map[fruits[j]]--;\n            if(map[fruits[j]] == 0){\n                delete map[fruits[j]];\n            }\n            j++;\n        }\n        result = Math.max(result, i - j + 1);\n    }\n    return result;\n    \n};"}
{"id": "1015", "path": "output2\\js\\Medium\\1015-sum-of-subarray-minimums.js", "hypo_code": "var sumSubarrayMins = function(arr) {\n    let n = arr.length;\n    let stack = [];\n    let left = new Array(n);\n    let right = new Array(n);\n    for(let i = 0; i < n; i++){\n        while(stack.length > 0 && arr[stack[stack.length - 1]] > arr[i]){\n            stack.pop();\n        }\n        if(stack.length == 0){\n            left[i] = -1;\n        }else{\n            left[i] = stack[stack.length - 1];\n        }\n        stack.push(i);\n    }\n    stack = [];\n    for(let i = n - 1; i >= 0; i--){\n        while(stack.length > 0 && arr[stack[stack.length - 1]] >= arr[i]){\n            stack.pop();\n        }\n        if(stack.length == 0){\n            right[i] = n;\n        }else{\n            right[i] = stack[stack.length - 1];\n        }\n        stack.push(i);\n    }\n    let result = 0;\n    let mod = Math.pow(10, 9) + 7;\n    for(let i = 0; i < n; i++){\n        result = (result + arr[i] * (i - left[i]) * (right[i] - i)) % mod;\n    }\n    return result;\n    \n};"}
{"id": "1016", "path": "output2\\js\\Medium\\1016-snakes-and-ladders.js", "hypo_code": "var snakesAndLadders = function(board) {\n    let n = board.length;\n    let map = {};\n    let result = 0;\n    let j = 1;\n    for(let i = n - 1; i >= 0; i--){\n        if(j % 2 == 0){\n            for(let k = n - 1; k >= 0; k--){\n                map[j] = board[i][k];\n                j++;\n            }\n        }else{\n            for(let k = 0; k < n; k++){\n                map[j] = board[i][k];\n                j++;\n            }\n        }\n    }\n    let queue = [1];\n    let visited = {};\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let curr = queue.shift();\n            if(curr == n * n){\n                return result;\n            }\n            for(let j = 1; j <= 6; j++){\n                let next = curr + j;\n                if(next > n * n){\n                    break;\n                }\n                if(map[next] != -1){\n                    next = map[next];\n                }\n                if(visited[next]){\n                    continue;\n                }\n                visited[next] = true;\n                queue.push(next);\n            }\n        }\n        result++;\n    }\n    return -1;\n    \n};"}
{"id": "1017", "path": "output2\\js\\Medium\\1017-smallest-range-ii.js", "hypo_code": "var smallestRangeII = function(nums, k) {\n    let n = nums.length;\n    let result = 0;\n    nums.sort((a, b) => a - b);\n    for(let i = 0; i < n - 1; i++){\n        let a = nums[i];\n        let b = nums[i + 1];\n        let high = Math.max(nums[n - 1] - k, a + k);\n        let low = Math.min(nums[0] + k, b - k);\n        result = Math.min(result, high - low);\n    }\n    return result;\n    \n};"}
{"id": "1019", "path": "output2\\js\\Medium\\1019-sort-an-array.js", "hypo_code": "var sortArray = function(nums) {\n    let n = nums.length;\n    let result = [];\n    let map = {};\n    for(let i = 0; i < n; i++){\n        let num = nums[i];\n        if(map[num] == undefined){\n            map[num] = 1;\n        }else{\n            map[num]++;\n        }\n    }\n    let keys = Object.keys(map);\n    keys.sort((a, b) => a - b);\n    for(let i = 0; i < keys.length; i++){\n        let key = keys[i];\n        let count = map[key];\n        for(let j = 0; j < count; j++){\n            result.push(key);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1020", "path": "output2\\js\\Medium\\1020-partition-array-into-disjoint-intervals.js", "hypo_code": "var partitionDisjoint = function(nums) {\n    let n = nums.length;\n    let left = new Array(n).fill(0);\n    let right = new Array(n).fill(0);\n    left[0] = nums[0];\n    right[n - 1] = nums[n - 1];\n    for(let i = 1; i < n; i++){\n        left[i] = Math.max(left[i - 1], nums[i]);\n    }\n    for(let i = n - 2; i >= 0; i--){\n        right[i] = Math.min(right[i + 1], nums[i]);\n    }\n    for(let i = 0; i < n - 1; i++){\n        if(left[i] <= right[i + 1]){\n            return i + 1;\n        }\n    }\n    return 0;\n    \n};"}
{"id": "1021", "path": "output2\\js\\Medium\\1021-word-subsets.js", "hypo_code": "var wordSubsets = function(words1, words2) {\n    let result = [];\n    let map = {};\n    for(let i = 0; i < words2.length; i++){\n        let word = words2[i];\n        let temp = {};\n        for(let j = 0; j < word.length; j++){\n            temp[word[j]] = (temp[word[j]] || 0) + 1;\n        }\n        for(let key in temp){\n            map[key] = Math.max(map[key] || 0, temp[key]);\n        }\n    }\n    for(let i = 0; i < words1.length; i++){\n        let word = words1[i];\n        let temp = {};\n        for(let j = 0; j < word.length; j++){\n            temp[word[j]] = (temp[word[j]] || 0) + 1;\n        }\n        let flag = true;\n        for(let key in map){\n            if(map[key] > temp[key]){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            result.push(word);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1022", "path": "output2\\js\\Medium\\1022-maximum-sum-circular-subarray.js", "hypo_code": "var maxSubarraySumCircular = function(nums) {\n    let n = nums.length;\n    let max = nums[0];\n    let min = nums[0];\n    let sum = nums[0];\n    let maxSum = nums[0];\n    let minSum = nums[0];\n    for(let i = 1; i < n; i++){\n        max = Math.max(max + nums[i], nums[i]);\n        maxSum = Math.max(maxSum, max);\n        min = Math.min(min + nums[i], nums[i]);\n        minSum = Math.min(minSum, min);\n        sum += nums[i];\n    }\n    return maxSum > 0 ? Math.max(maxSum, sum - minSum) : maxSum;\n    \n};"}
{"id": "1024", "path": "output2\\js\\Medium\\1024-minimum-add-to-make-parentheses-valid.js", "hypo_code": "var minAddToMakeValid = function(s) {\n    let stack = [];\n    let result = 0;\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == '('){\n            stack.push(s[i]);\n        }else{\n            if(stack.length == 0){\n                result++;\n            }else{\n                stack.pop();\n            }\n        }\n    }\n    return result + stack.length;\n    \n};"}
{"id": "1025", "path": "output2\\js\\Medium\\1025-3sum-with-multiplicity.js", "hypo_code": "var threeSumMulti = function(arr, target) {\n    let n = arr.length;\n    let mod = 1000000007;\n    let count = new Array(101).fill(0);\n    for(let i = 0; i < n; i++){\n        count[arr[i]]++;\n    }\n    let result = 0;\n    for(let i = 0; i <= 100; i++){\n        for(let j = i; j <= 100; j++){\n            let k = target - i - j;\n            if(k < 0 || k > 100){\n                continue;\n            }\n            if(i == j && j == k){\n                result += count[i] * (count[i] - 1) * (count[i] - 2) / 6;\n            }else if(i == j && j != k){\n                result += count[i] * (count[i] - 1) / 2 * count[k];\n            }else if(i < j && j < k){\n                result += count[i] * count[j] * count[k];\n            }\n        }\n    }\n    return result % mod;\n    \n};"}
{"id": "1026", "path": "output2\\js\\Medium\\1026-flip-string-to-monotone-increasing.js", "hypo_code": "var minFlipsMonoIncr = function(s) {\n    let n = s.length;\n    let result = 0;\n    let ones = 0;\n    for(let i = 0; i < n; i++){\n        if(s[i] == '1'){\n            ones++;\n        }else{\n            result = Math.min(result + 1, ones);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1027", "path": "output2\\js\\Medium\\1027-binary-subarrays-with-sum.js", "hypo_code": "var numSubarraysWithSum = function(nums, goal) {\n    let n = nums.length;\n    let count = new Array(n + 1).fill(0);\n    let sum = 0;\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        count[sum]++;\n        sum += nums[i];\n        result += count[sum - goal];\n    }\n    return result;\n    \n    \n};"}
{"id": "1028", "path": "output2\\js\\Medium\\1028-minimum-falling-path-sum.js", "hypo_code": "var minFallingPathSum = function(matrix) {\n    let n = matrix.length;\n    let dp = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        dp[i] = matrix[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        let temp = new Array(n).fill(0);\n        for(let j = 0; j < n; j++){\n            temp[j] = dp[j] + matrix[i][j];\n            if(j > 0){\n                temp[j] = Math.min(temp[j], dp[j - 1] + matrix[i][j]);\n            }\n            if(j < n - 1){\n                temp[j] = Math.min(temp[j], dp[j + 1] + matrix[i][j]);\n            }\n        }\n        dp = temp;\n    }\n    let result = dp[0];\n    for(let i = 1; i < n; i++){\n        result = Math.min(result, dp[i]);\n    }\n    return result;\n    \n};"}
{"id": "1029", "path": "output2\\js\\Medium\\1029-beautiful-array.js", "hypo_code": "var beautifulArray = function(n) {\n    let result = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        result[i] = i + 1;\n    }\n    return helper(result);\n    \n    \n};"}
{"id": "1030", "path": "output2\\js\\Medium\\1030-shortest-bridge.js", "hypo_code": "var shortestBridge = function(grid) {\n    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() => new Array(m).fill(0));\n    let result = Number.MAX_SAFE_INTEGER;\n    let queue = [];\n    let found = false;\n    for(let i = 0; i < n; i++){\n        if(found){\n            break;\n        }\n        for(let j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n                dfs(grid, visited, i, j, queue);\n                found = true;\n                break;\n            }\n        }\n    }\n    let steps = 0;\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let [x, y] = queue.shift();\n            if(x < 0 || x >= n || y < 0 || y >= m || visited[x][y] == 1){\n                continue;\n            }\n            if(grid[x][y] == 1){\n                result = Math.min(result, steps);\n            }\n            visited[x][y] = 1;\n            queue.push([x + 1, y]);\n            queue.push([x - 1, y]);\n            queue.push([x, y + 1]);\n            queue.push([x, y - 1]);\n        }\n        steps++;\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "1031", "path": "output2\\js\\Medium\\1031-knight-dialer.js", "hypo_code": "var knightDialer = function(n) {\n    const mod = 1e9 + 7;\n    const moves = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]];\n    let dp = Array(10).fill(1);\n    for (let i = 1; i < n; i++) {\n        let next = Array(10).fill(0);\n        for (let j = 0; j < 10; j++) {\n            for (let k = 0; k < moves[j].length; k++) {\n                next[moves[j][k]] = (next[moves[j][k]] + dp[j]) % mod;\n            }\n        }\n        dp = next;\n    }\n    return dp.reduce((a, b) => (a + b) % mod);\n};"}
{"id": "1032", "path": "output2\\js\\Medium\\1032-reorder-data-in-log-files.js", "hypo_code": "var reorderLogFiles = function(logs) {\n    let result = [];\n    let digitLogs = [];\n    let letterLogs = [];\n    for(let i = 0; i < logs.length; i++){\n        let log = logs[i];\n        let index = log.indexOf(' ');\n        let identifier = log.substring(0, index);\n        let content = log.substring(index + 1);\n        if(content[0] >= '0' && content[0] <= '9'){\n            digitLogs.push(log);\n        }else{\n            letterLogs.push({identifier: identifier, content: content});\n        }\n    }\n    letterLogs.sort((a, b) => {\n        if(a.content == b.content){\n            return a.identifier.localeCompare(b.identifier);\n        }\n        return a.content.localeCompare(b.content);\n    });\n    for(let i = 0; i < letterLogs.length; i++){\n        result.push(letterLogs[i].identifier + ' ' + letterLogs[i].content);\n    }\n    for(let i = 0; i < digitLogs.length; i++){\n        result.push(digitLogs[i]);\n    }\n    return result;\n    \n};"}
{"id": "1033", "path": "output2\\js\\Medium\\1033-minimum-area-rectangle.js", "hypo_code": "var minAreaRect = function(points) {\n    let n = points.length;\n    let result = 100000000000000000;\n    let set = new Set();\n    for(let i = 0; i < n; i++){\n        set.add(points[i][0] + \",\" + points[i][1]);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = i + 1; j < n; j++){\n            if(points[i][0] != points[j][0] && points[i][1] != points[j][1]){\n                if(set.has(points[i][0] + \",\" + points[j][1]) && set.has(points[j][0] + \",\" + points[i][1])){\n                    result = Math.min(result, Math.abs(points[i][0] - points[j][0]) * Math.abs(points[i][1] - points[j][1]));\n                }\n            }\n        }\n    }\n    if(result == 100000000000000000){\n        return 0;\n    }\n    return result;\n    \n};"}
{"id": "1034", "path": "output2\\js\\Medium\\1034-minimum-increment-to-make-array-unique.js", "hypo_code": "var minIncrementForUnique = function(nums) {\n    let result = 0;\n    let count = new Array(40000).fill(0);\n    for(let i = 0; i < nums.length; i++){\n        count[nums[i]]++;\n    }\n    let taken = 0;\n    for(let i = 0; i < 40000; i++){\n        if(count[i] >= 2){\n            taken += count[i] - 1;\n            result -= i * (count[i] - 1);\n        }else if(taken > 0 && count[i] == 0){\n            taken--;\n            result += i;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1035", "path": "output2\\js\\Medium\\1035-validate-stack-sequences.js", "hypo_code": "var validateStackSequences = function(pushed, popped) {\n    let stack = [];\n    let i = 0;\n    for(let j = 0; j < pushed.length; j++){\n        stack.push(pushed[j]);\n        while(stack.length > 0 && stack[stack.length - 1] == popped[i]){\n            stack.pop();\n            i++;\n        }\n    }\n    return stack.length == 0;\n    \n};"}
{"id": "1036", "path": "output2\\js\\Medium\\1036-most-stones-removed-with-same-row-or-column.js", "hypo_code": "var removeStones = function(stones) {\n    let n = stones.length;\n    let result = 0;\n    let set = new Set();\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        let row = stones[i][0];\n        let col = stones[i][1];\n        if(!map.has(row)){\n            map.set(row, new Set());\n        }\n        if(!map.has(col)){\n            map.set(col, new Set());\n        }\n        map.get(row).add(col);\n        map.get(col).add(row);\n    }\n    for(let i = 0; i < n; i++){\n        let row = stones[i][0];\n        let col = stones[i][1];\n        if(!set.has(row)){\n            set.add(row);\n            dfs(row, map, set);\n            result++;\n        }\n        if(!set.has(col)){\n            set.add(col);\n            dfs(col, map, set);\n            result++;\n        }\n    }\n    return n - result;\n    \n    \n};"}
{"id": "1037", "path": "output2\\js\\Medium\\1037-bag-of-tokens.js", "hypo_code": "var bagOfTokensScore = function(tokens, power) {\n    let n = tokens.length;\n    let result = 0;\n    let score = 0;\n    tokens.sort((a, b) => a - b);\n    let i = 0;\n    let j = n - 1;\n    while(i <= j){\n        if(power >= tokens[i]){\n            power -= tokens[i];\n            score++;\n            result = Math.max(result, score);\n            i++;\n        }else if(score > 0){\n            power += tokens[j];\n            score--;\n            j--;\n        }else{\n            break;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1038", "path": "output2\\js\\Medium\\1038-largest-time-for-given-digits.js", "hypo_code": "var largestTimeFromDigits = function(arr) {\n    let result = \"\";\n    let max = -1;\n    for(let i = 0; i < 4; i++){\n        for(let j = 0; j < 4; j++){\n            if(j == i) continue;\n            for(let k = 0; k < 4; k++){\n                if(k == i || k == j) continue;\n                let l = 6 - i - j - k;\n                let hour = arr[i] * 10 + arr[j];\n                let minute = arr[k] * 10 + arr[l];\n                if(hour < 24 && minute < 60){\n                    let time = hour * 60 + minute;\n                    if(time > max){\n                        max = time;\n                        result = arr[i] + \"\" + arr[j] + \":\" + arr[k] + \"\" + arr[l];\n                    }\n                }\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1039", "path": "output2\\js\\Medium\\1039-reveal-cards-in-increasing-order.js", "hypo_code": "var deckRevealedIncreasing = function(deck) {\n    deck.sort((a, b) => a - b);\n    let result = new Array(deck.length).fill(0);\n    let index = new Array(deck.length).fill(0);\n    for(let i = 0; i < deck.length; i++){\n        index[i] = i;\n    }\n    let i = 0;\n    while(index.length > 0){\n        result[index.shift()] = deck[i];\n        if(index.length > 0){\n            index.push(index.shift());\n        }\n        i++;\n    }\n    return result;\n    \n};"}
{"id": "1040", "path": "output2\\js\\Medium\\1040-flip-equivalent-binary-trees.js", "hypo_code": "var flipEquiv = function(root1, root2) {\n    if(root1 == null && root2 == null){\n        return true;\n    }\n    if(root1 == null || root2 == null){\n        return false;\n    }\n    if(root1.val != root2.val){\n        return false;\n    }\n    return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));\n    \n};"}
{"id": "1041", "path": "output2\\js\\Medium\\1041-array-of-doubled-pairs.js", "hypo_code": "var canReorderDoubled = function(arr) {\n    let count = new Array(20001).fill(0);\n    for(let i = 0; i < arr.length; i++){\n        count[arr[i] + 10000]++;\n    }\n    for(let i = 0; i < 20001; i++){\n        if(count[i] > count[2 * i] || count[2 * i] > count[i] && count[i] > 0){\n            return false;\n        }\n        count[2 * i] -= count[i];\n    }\n    return true;\n    \n};"}
{"id": "1042", "path": "output2\\js\\Medium\\1042-delete-columns-to-make-sorted-ii.js", "hypo_code": "var minDeletionSize = function(strs) {\n    let n = strs.length;\n    let m = strs[0].length;\n    let result = 0;\n    let dp = new Array(n).fill(0);\n    for(let i = 0; i < m; i++){\n        let temp = new Array(n).fill(0);\n        for(let j = 0; j < n; j++){\n            temp[j] = dp[j];\n        }\n        for(let j = 1; j < n; j++){\n            if(strs[j][i] < strs[j - 1][i]){\n                result++;\n                break;\n            }\n            if(strs[j][i] > strs[j - 1][i]){\n                temp[j] = Math.max(temp[j], dp[j - 1] + 1);\n            }\n        }\n        dp = temp;\n    }\n    return result;\n    \n};"}
{"id": "1043", "path": "output2\\js\\Medium\\1043-prison-cells-after-n-days.js", "hypo_code": "var prisonAfterNDays = function(cells, n) {\n    let result = new Array(8).fill(0);\n    let set = new Set();\n    let i = 0;\n    while(i < n){\n        for(let j = 1; j < 7; j++){\n            if(cells[j - 1] == cells[j + 1]){\n                result[j] = 1;\n            }else{\n                result[j] = 0;\n            }\n        }\n        let key = result.join(\"\");\n        if(set.has(key)){\n            let cycle = i - set.get(key);\n            let remaining = (n - i) % cycle;\n            i = i + remaining;\n        }else{\n            set.set(key, i);\n            i++;\n        }\n        cells = result.slice();\n    }\n    return result;\n    \n};"}
{"id": "1044", "path": "output2\\js\\Medium\\1044-check-completeness-of-a-binary-tree.js", "hypo_code": "var isCompleteTree = function(root) {\n    let q = [];\n    q.push(root);\n    let flag = false;\n    while(q.length > 0){\n        let temp = q.shift();\n        if(temp == null){\n            flag = true;\n        }\n        else{\n            if(flag){\n                return false;\n            }\n            q.push(temp.left);\n            q.push(temp.right);\n        }\n    }\n    return true;\n    \n};"}
{"id": "1045", "path": "output2\\js\\Medium\\1045-regions-cut-by-slashes.js", "hypo_code": "var regionsBySlashes = function(grid) {\n    let n = grid.length;\n    let uf = new UnionFind(4 * n * n);\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            let index = 4 * (i * n + j);\n            if(grid[i][j] == ' '){\n                uf.union(index, index + 1);\n                uf.union(index, index + 2);\n                uf.union(index, index + 3);\n            }else if(grid[i][j] == '/'){\n                uf.union(index, index + 1);\n                uf.union(index + 2, index + 3);\n            }else{\n                uf.union(index, index + 2);\n                uf.union(index + 1, index + 3);\n            }\n            if(i < n - 1){\n                uf.union(index + 3, index + 4 * n);\n            }\n            if(j < n - 1){\n                uf.union(index + 2, index + 4 + 1);\n            }\n        }\n    }\n    return uf.getCount();\n    \n    \n    \n};"}
{"id": "1046", "path": "output2\\js\\Medium\\1046-maximum-width-ramp.js", "hypo_code": "var maxWidthRamp = function(nums) {\n    let n = nums.length;\n    let stack = [];\n    for(let i = 0; i < n; i++){\n        if(stack.length == 0 || nums[stack[stack.length - 1]] > nums[i]){\n            stack.push(i);\n        }\n    }\n    let ans = 0;\n    for(let i = n - 1; i >= 0; i--){\n        while(stack.length > 0 && nums[stack[stack.length - 1]] <= nums[i]){\n            ans = Math.max(ans, i - stack.pop());\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1047", "path": "output2\\js\\Medium\\1047-minimum-area-rectangle-ii.js", "hypo_code": "var minAreaFreeRect = function(points) {\n    let n = points.length;\n    let result = 100000000000000000;\n    let set = new Set();\n    for(let i = 0; i < n; i++){\n        set.add(points[i][0] + \",\" + points[i][1]);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = i + 1; j < n; j++){\n            for(let k = j + 1; k < n; k++){\n                let x1 = points[i][0];\n                let y1 = points[i][1];\n                let x2 = points[j][0];\n                let y2 = points[j][1];\n                let x3 = points[k][0];\n                let y3 = points[k][1];\n                let x4 = x1 + x2 - x3;\n                let y4 = y1 + y2 - y3;\n                if(set.has(x4 + \",\" + y4)){\n                    let a = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n                    let b = Math.sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));\n                    result = Math.min(result, a * b);\n                }\n            }\n        }\n    }\n    if(result == 100000000000000000){\n        return 0;\n    }\n    return result;\n    \n};"}
{"id": "1048", "path": "output2\\js\\Medium\\1048-vowel-spellchecker.js", "hypo_code": "var spellchecker = function(wordlist, queries) {\n    let result = [];\n    let set = new Set(wordlist);\n    let map1 = new Map();\n    let map2 = new Map();\n    for(let word of wordlist){\n        let lower = word.toLowerCase();\n        if(!map1.has(lower)){\n            map1.set(lower, word);\n        }\n        let noVowel = lower.replace(/[aeiou]/g, \"#\");\n        if(!map2.has(noVowel)){\n            map2.set(noVowel, word);\n        }\n    }\n    for(let query of queries){\n        if(set.has(query)){\n            result.push(query);\n        }else{\n            let lower = query.toLowerCase();\n            if(map1.has(lower)){\n                result.push(map1.get(lower));\n            }else{\n                let noVowel = lower.replace(/[aeiou]/g, \"#\");\n                if(map2.has(noVowel)){\n                    result.push(map2.get(noVowel));\n                }else{\n                    result.push(\"\");\n                }\n            }\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1049", "path": "output2\\js\\Medium\\1049-numbers-with-same-consecutive-differences.js", "hypo_code": "var numsSameConsecDiff = function(n, k) {\n    let ans = [];\n    let dfs = (num, len) => {\n        if(len == n){\n            ans.push(num);\n            return;\n        }\n        let lastDigit = num % 10;\n        if(lastDigit + k <= 9){\n            dfs(num * 10 + lastDigit + k, len + 1);\n        }\n        if(k != 0 && lastDigit - k >= 0){\n            dfs(num * 10 + lastDigit - k, len + 1);\n        }\n    }\n    for(let i = 1; i <= 9; i++){\n        dfs(i, 1);\n    }\n    if(n == 1){\n        ans.push(0);\n    }\n    return ans;\n    \n};"}
{"id": "1050", "path": "output2\\js\\Medium\\1050-pancake-sorting.js", "hypo_code": "var pancakeSort = function(arr) {\n    let result = [];\n    let n = arr.length;\n    let index = new Array(n + 1).fill(0);\n    for(let i = 0; i < n; i++){\n        index[arr[i]] = i;\n    }\n    for(let i = n; i >= 1; i--){\n        let j = index[i];\n        if(j == i - 1){\n            continue;\n        }\n        if(j != 0){\n            result.push(j + 1);\n            reverse(arr, j + 1);\n        }\n        result.push(i);\n        reverse(arr, i);\n    }\n    return result;\n    \n    \n};"}
{"id": "1051", "path": "output2\\js\\Medium\\1051-powerful-integers.js", "hypo_code": "var powerfulIntegers = function(x, y, bound) {\n    let ans = new Set();\n    for(let i = 1; i < bound; i *= x){\n        for(let j = 1; i + j <= bound; j *= y){\n            ans.add(i + j);\n            if(y == 1){\n                break;\n            }\n        }\n        if(x == 1){\n            break;\n        }\n    }\n    return Array.from(ans);\n    \n};"}
{"id": "1052", "path": "output2\\js\\Medium\\1052-flip-binary-tree-to-match-preorder-traversal.js", "hypo_code": "var flipMatchVoyage = function(root, voyage) {\n    let result = [];\n    let i = 0;\n    let flag = true;\n    function dfs(root){\n        if(root == null){\n            return;\n        }\n        if(root.val != voyage[i]){\n            flag = false;\n            return;\n        }\n        i++;\n        if(root.left != null && root.left.val != voyage[i]){\n            result.push(root.val);\n            dfs(root.right);\n            dfs(root.left);\n        }else{\n            dfs(root.left);\n            dfs(root.right);\n        }\n    }\n    dfs(root);\n    if(flag == false){\n        return [-1];\n    }\n    return result;\n    \n};"}
{"id": "1053", "path": "output2\\js\\Medium\\1053-k-closest-points-to-origin.js", "hypo_code": "var kClosest = function(points, k) {\n    let n = points.length;\n    let result = [];\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        let dist = Math.sqrt(points[i][0] * points[i][0] + points[i][1] * points[i][1]);\n        if(map.has(dist)){\n            map.get(dist).push(points[i]);\n        }else{\n            map.set(dist, [points[i]]);\n        }\n    }\n    let sorted = Array.from(map.keys()).sort((a, b) => a - b);\n    for(let i = 0; i < sorted.length; i++){\n        let arr = map.get(sorted[i]);\n        for(let j = 0; j < arr.length; j++){\n            result.push(arr[j]);\n            if(result.length == k){\n                return result;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1054", "path": "output2\\js\\Medium\\1054-subarray-sums-divisible-by-k.js", "hypo_code": "var subarraysDivByK = function(nums, k) {\n    let count = new Array(k).fill(0);\n    count[0] = 1;\n    let sum = 0;\n    let ans = 0;\n    for(let i = 0; i < nums.length; i++){\n        sum += nums[i];\n        let mod = ((sum % k) + k) % k;\n        ans += count[mod];\n        count[mod]++;\n    }\n    return ans;\n    \n};"}
{"id": "1055", "path": "output2\\js\\Medium\\1055-longest-turbulent-subarray.js", "hypo_code": "var maxTurbulenceSize = function(arr) {\n    let n = arr.length;\n    let ans = 1;\n    let anchor = 0;\n    for(let i = 1; i < n; i++){\n        let c = compare(arr[i - 1], arr[i]);\n        if(c == 0){\n            anchor = i;\n        }else if(i == n - 1 || c * compare(arr[i], arr[i + 1]) != -1){\n            ans = Math.max(ans, i - anchor + 1);\n            anchor = i;\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "1056", "path": "output2\\js\\Medium\\1056-distribute-coins-in-binary-tree.js", "hypo_code": "var distributeCoins = function(root) {\n    let result = 0;\n    function dfs(root){\n        if(root == null){\n            return 0;\n        }\n        let left = dfs(root.left);\n        let right = dfs(root.right);\n        result += Math.abs(left) + Math.abs(right);\n        return root.val + left + right - 1;\n    }\n    dfs(root);\n    return result;\n    \n};"}
{"id": "1058", "path": "output2\\js\\Medium\\1058-minimum-cost-for-tickets.js", "hypo_code": "var mincostTickets = function(days, costs) {\n    let n = days.length;\n    let dp = new Array(n + 1).fill(0);\n    let dayset = new Set();\n    for(let day of days){\n        dayset.add(day);\n    }\n    for(let i = n - 1; i >= 0; i--){\n        let day1 = days[i] + 1;\n        let day7 = days[i] + 7;\n        let day30 = days[i] + 30;\n        let min1 = dp[i + 1] + costs[0];\n        let min7 = dp[i + 1] + costs[1];\n        let min30 = dp[i + 1] + costs[2];\n        while(dayset.has(day1)){\n            day1++;\n        }\n        while(dayset.has(day7)){\n            day7++;\n        }\n        while(dayset.has(day30)){\n            day30++;\n        }\n        let j1 = binarySearch(days, day1);\n        let j7 = binarySearch(days, day7);\n        let j30 = binarySearch(days, day30);\n        min7 = Math.min(min7, dp[j7] + costs[1]);\n        min30 = Math.min(min30, dp[j30] + costs[2]);\n        dp[i] = Math.min(min1, min7, min30);\n    }\n    return dp[0];\n    \n    \n};"}
{"id": "1059", "path": "output2\\js\\Medium\\1059-string-without-aaa-or-bbb.js", "hypo_code": "var strWithout3a3b = function(a, b) {\n    let ans = [];\n    while(a > 0 || b > 0){\n        let writeA = false;\n        let l = ans.length;\n        if(l >= 2 && ans[l - 1] == ans[l - 2]){\n            if(ans[l - 1] == 'b'){\n                writeA = true;\n            }\n        }else{\n            if(a >= b){\n                writeA = true;\n            }\n        }\n        if(writeA){\n            ans.push('a');\n            a--;\n        }else{\n            ans.push('b');\n            b--;\n        }\n    }\n    return ans.join('');\n    \n};"}
{"id": "1060", "path": "output2\\js\\Medium\\1060-sum-of-even-numbers-after-queries.js", "hypo_code": "var sumEvenAfterQueries = function(nums, queries) {\n    let sum = 0;\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i] % 2 == 0){\n            sum += nums[i];\n        }\n    }\n    let ans = [];\n    for(let i = 0; i < queries.length; i++){\n        let val = queries[i][0];\n        let index = queries[i][1];\n        if(nums[index] % 2 == 0){\n            sum -= nums[index];\n        }\n        nums[index] += val;\n        if(nums[index] % 2 == 0){\n            sum += nums[index];\n        }\n        ans.push(sum);\n    }\n    return ans;\n    \n};"}
{"id": "1061", "path": "output2\\js\\Medium\\1061-interval-list-intersections.js", "hypo_code": "var intervalIntersection = function(firstList, secondList) {\n    let ans = [];\n    let i = 0;\n    let j = 0;\n    while(i < firstList.length && j < secondList.length){\n        let start = Math.max(firstList[i][0], secondList[j][0]);\n        let end = Math.min(firstList[i][1], secondList[j][1]);\n        if(start <= end){\n            ans.push([start, end]);\n        }\n        if(firstList[i][1] < secondList[j][1]){\n            i++;\n        }else{\n            j++;\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1062", "path": "output2\\js\\Medium\\1062-smallest-string-starting-from-leaf.js", "hypo_code": "var smallestFromLeaf = function(root) {\n    let result = [];\n    function dfs(root, str){\n        if(root == null){\n            return;\n        }\n        str = String.fromCharCode(97 + root.val) + str;\n        if(root.left == null && root.right == null){\n            result.push(str);\n            return;\n        }\n        dfs(root.left, str);\n        dfs(root.right, str);\n    }\n    dfs(root, \"\");\n    result.sort();\n    return result[0];\n    \n};"}
{"id": "1063", "path": "output2\\js\\Medium\\1063-satisfiability-of-equality-equations.js", "hypo_code": "var equationsPossible = function(equations) {\n    let n = equations.length;\n    let parent = new Array(26);\n    for(let i = 0; i < 26; i++){\n        parent[i] = i;\n    }\n    for(let i = 0; i < n; i++){\n        if(equations[i][1] == '='){\n            let x = equations[i][0].charCodeAt(0) - 'a'.charCodeAt(0);\n            let y = equations[i][3].charCodeAt(0) - 'a'.charCodeAt(0);\n            union(x, y);\n        }\n    }\n    for(let i = 0; i < n; i++){\n        if(equations[i][1] == '!'){\n            let x = equations[i][0].charCodeAt(0) - 'a'.charCodeAt(0);\n            let y = equations[i][3].charCodeAt(0) - 'a'.charCodeAt(0);\n            if(find(x) == find(y)){\n                return false;\n            }\n        }\n    }\n    return true;\n    \n    \n};"}
{"id": "1064", "path": "output2\\js\\Medium\\1064-broken-calculator.js", "hypo_code": "var brokenCalc = function(startValue, target) {\n    let ans = 0;\n    while(target > startValue){\n        ans++;\n        if(target % 2 == 1){\n            target++;\n        }else{\n            target /= 2;\n        }\n    }\n    return ans + startValue - target;\n    \n};"}
{"id": "1065", "path": "output2\\js\\Medium\\1065-rotting-oranges.js", "hypo_code": "var orangesRotting = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let fresh = 0;\n    let queue = [];\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(grid[i][j] == 1){\n                fresh++;\n            }\n            if(grid[i][j] == 2){\n                queue.push([i, j]);\n            }\n        }\n    }\n    let result = 0;\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let [x, y] = queue.shift();\n            if(x > 0 && grid[x - 1][y] == 1){\n                grid[x - 1][y] = 2;\n                fresh--;\n                queue.push([x - 1, y]);\n            }\n            if(x < m - 1 && grid[x + 1][y] == 1){\n                grid[x + 1][y] = 2;\n                fresh--;\n                queue.push([x + 1, y]);\n            }\n            if(y > 0 && grid[x][y - 1] == 1){\n                grid[x][y - 1] = 2;\n                fresh--;\n                queue.push([x, y - 1]);\n            }\n            if(y < n - 1 && grid[x][y + 1] == 1){\n                grid[x][y + 1] = 2;\n                fresh--;\n                queue.push([x, y + 1]);\n            }\n        }\n        result++;\n    }\n    if(fresh > 0){\n        return -1;\n    }\n    return result == 0 ? 0 : result - 1;\n    \n};"}
{"id": "1066", "path": "output2\\js\\Medium\\1066-maximum-binary-tree-ii.js", "hypo_code": "var insertIntoMaxTree = function(root, val) {\n    if(root == null){\n        return new TreeNode(val);\n    }\n    if(root.val < val){\n        let temp = new TreeNode(val);\n        temp.left = root;\n        return temp;\n    }\n    root.right = insertIntoMaxTree(root.right, val);\n    return root;\n    \n};"}
{"id": "1067", "path": "output2\\js\\Medium\\1067-check-if-word-is-valid-after-substitutions.js", "hypo_code": "var isValid = function(s) {\n    let stack = [];\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == 'a'){\n            stack.push('a');\n        }else if(s[i] == 'b'){\n            if(stack.length == 0 || stack[stack.length - 1] != 'a'){\n                return false;\n            }\n            stack.push('b');\n        }else{\n            if(stack.length < 2 || stack[stack.length - 1] != 'b' || stack[stack.length - 2] != 'a'){\n                return false;\n            }\n            stack.pop();\n            stack.pop();\n        }\n    }\n    return stack.length == 0;    \n\n};"}
{"id": "1068", "path": "output2\\js\\Medium\\1068-max-consecutive-ones-iii.js", "hypo_code": "var longestOnes = function(nums, k) {\n    let ans = 0;\n    let count = 0;\n    let left = 0;\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i] == 1){\n            count++;\n        }\n        while(i - left + 1 - count > k){\n            if(nums[left] == 1){\n                count--;\n            }\n            left++;\n        }\n        ans = Math.max(ans, i - left + 1);\n    }\n    return ans;\n    \n\n};"}
{"id": "1069", "path": "output2\\js\\Medium\\1069-clumsy-factorial.js", "hypo_code": "var clumsy = function(n) {\n    let stack = [n];\n    let index = 0;\n    n--;\n    while(n > 0){\n        if(index % 4 == 0){\n            stack.push(stack.pop() * n);\n        }else if(index % 4 == 1){\n            let temp = stack.pop();\n            if(temp < 0){\n                stack.push(Math.ceil(temp / n));\n            }else{\n                stack.push(Math.floor(temp / n));\n            }\n        }else if(index % 4 == 2){\n            stack.push(n);\n        }else{\n            stack.push(-n);\n        }\n        index++;\n        n--;\n    }\n    let result = 0;\n    while(stack.length > 0){\n        result += stack.pop();\n    }\n    return result;\n    \n};"}
{"id": "1070", "path": "output2\\js\\Medium\\1070-minimum-domino-rotations-for-equal-row.js", "hypo_code": "var minDominoRotations = function(tops, bottoms) {\n    let n = tops.length;\n    let result = Number.MAX_SAFE_INTEGER;\n    for(let i = 1; i <= 6; i++){\n        let count = 0;\n        let flag = true;\n        for(let j = 0; j < n; j++){\n            if(tops[j] != i && bottoms[j] != i){\n                flag = false;\n                break;\n            }\n            else if(tops[j] != i){\n                count++;\n            }\n        }\n        if(flag){\n            result = Math.min(result, count);\n        }\n    }\n    for(let i = 1; i <= 6; i++){\n        let count = 0;\n        let flag = true;\n        for(let j = 0; j < n; j++){\n            if(tops[j] != i && bottoms[j] != i){\n                flag = false;\n                break;\n            }\n            else if(bottoms[j] != i){\n                count++;\n            }\n        }\n        if(flag){\n            result = Math.min(result, count);\n        }\n    }\n    return result == Number.MAX_SAFE_INTEGER ? -1 : result;\n    \n    \n};"}
{"id": "1071", "path": "output2\\js\\Medium\\1071-construct-binary-search-tree-from-preorder-traversal.js", "hypo_code": "var bstFromPreorder = function(preorder) {\n    let n = preorder.length;\n    let root = new TreeNode(preorder[0]);\n    let stack = [];\n    stack.push(root);\n    for(let i = 1; i < n; i++){\n        let node = new TreeNode(preorder[i]);\n        if(preorder[i] < stack[stack.length - 1].val){\n            stack[stack.length - 1].left = node;\n        }\n        else{\n            let temp = null;\n            while(stack.length > 0 && stack[stack.length - 1].val < preorder[i]){\n                temp = stack.pop();\n            }\n            temp.right = node;\n        }\n        stack.push(node);\n    }\n    return root;\n    \n};"}
{"id": "1072", "path": "output2\\js\\Medium\\1072-pairs-of-songs-with-total-durations-divisible-by-60.js", "hypo_code": "var numPairsDivisibleBy60 = function(time) {\n    let result = 0;\n    let n = time.length;\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        let mod = time[i] % 60;\n        let diff = (60 - mod) % 60;\n        if(map.has(diff)){\n            result += map.get(diff);\n        }\n        if(map.has(mod)){\n            map.set(mod, map.get(mod) + 1);\n        }else{\n            map.set(mod, 1);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1073", "path": "output2\\js\\Medium\\1073-capacity-to-ship-packages-within-d-days.js", "hypo_code": "var shipWithinDays = function(weights, days) {\n    let n = weights.length;\n    let dp = new Array(n + 1).fill(0).map(() => new Array(days + 1).fill(0));\n    let sum = 0;\n    for(let i = 1; i <= n; i++){\n        sum += weights[i - 1];\n        dp[i][1] = sum;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 2; j <= days; j++){\n            if(j > i){\n                dp[i][j] = dp[i][j - 1];\n            }else{\n                let min = Number.MAX_SAFE_INTEGER;\n                let sum = 0;\n                for(let k = i; k >= 1; k--){\n                    sum += weights[k - 1];\n                    min = Math.min(min, Math.max(dp[k - 1][j - 1], sum));\n                }\n                dp[i][j] = min;\n            }\n        }\n    }\n    return dp[n][days];\n    \n};"}
{"id": "1074", "path": "output2\\js\\Medium\\1074-best-sightseeing-pair.js", "hypo_code": "var maxScoreSightseeingPair = function(values) {\n    let n = values.length;\n    let dp = new Array(n + 1).fill(0);\n    let result = 0;\n    for(let i = 1; i < n; i++){\n        dp[i] = Math.max(dp[i - 1], values[i - 1] + i - 1);\n        result = Math.max(result, dp[i] + values[i] - i);\n    }\n    return result;\n    \n};"}
{"id": "1075", "path": "output2\\js\\Medium\\1075-smallest-integer-divisible-by-k.js", "hypo_code": "var smallestRepunitDivByK = function(k) {\n    let n = 1;\n    let count = 1;\n    while(n % k != 0){\n        n = n % k;\n        n = n * 10 + 1;\n        count++;\n    }\n    return count;\n    \n};"}
{"id": "1076", "path": "output2\\js\\Medium\\1076-binary-string-with-substrings-representing-1-to-n.js", "hypo_code": "var queryString = function(s, n) {\n    let set = new Set();\n    let i = 0;\n    let j = 0;\n    while(i < s.length){\n        let num = 0;\n        j = i;\n        while(j < s.length){\n            num = num * 2 + (s[j] - '0');\n            if(num > n){\n                break;\n            }\n            set.add(num);\n            j++;\n        }\n        i++;\n    }\n    for(let i = 1; i <= n; i++){\n        if(!set.has(i)){\n            return false;\n        }\n    }\n    return true;\n    \n};"}
{"id": "1077", "path": "output2\\js\\Medium\\1077-convert-to-base-2.js", "hypo_code": "var baseNeg2 = function(n) {\n    let result = \"\";\n    while(n != 0){\n        result = n % 2 + result;\n        n = Math.floor(n / 2);\n    }\n    return result;\n    \n};"}
{"id": "1078", "path": "output2\\js\\Medium\\1078-next-greater-node-in-linked-list.js", "hypo_code": "var nextLargerNodes = function(head) {\n    let result = [];\n    let stack = [];\n    let index = 0;\n    while(head != null){\n        while(stack.length > 0 && stack[stack.length - 1][0] < head.val){\n            result[stack.pop()[1]] = head.val;\n        }\n        stack.push([head.val, index]);\n        index++;\n        head = head.next;\n    }\n    while(stack.length > 0){\n        result[stack.pop()[1]] = 0;\n    }\n    return result;\n    \n};"}
{"id": "1079", "path": "output2\\js\\Medium\\1079-number-of-enclaves.js", "hypo_code": "var numEnclaves = function(grid) {\n    let n = grid.length;\n    let m = grid[0].length;\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n                result += dfs(grid, i, j);\n            }\n        }\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "1080", "path": "output2\\js\\Medium\\1080-camelcase-matching.js", "hypo_code": "var camelMatch = function(queries, pattern) {\n    let n = queries.length;\n    let result = [];\n    for(let i = 0; i < n; i++){\n        result.push(isMatch(queries[i], pattern));\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "1081", "path": "output2\\js\\Medium\\1081-video-stitching.js", "hypo_code": "var videoStitching = function(clips, time) {\n    let n = clips.length;\n    let dp = new Array(time + 1).fill(Infinity);\n    dp[0] = 0;\n    for(let i = 1; i <= time; i++){\n        for(let j = 0; j < n; j++){\n            if(clips[j][0] < i && clips[j][1] >= i){\n                dp[i] = Math.min(dp[i], dp[clips[j][0]] + 1);\n            }\n        }\n    }\n    return dp[time] == Infinity ? -1 : dp[time];\n    \n};"}
{"id": "1082", "path": "output2\\js\\Medium\\1082-maximum-difference-between-node-and-ancestor.js", "hypo_code": "var maxAncestorDiff = function(root) {\n    let result = 0;\n    let dfs = function(node, min, max){\n        if(node == null){\n            return;\n        }\n        result = Math.max(result, Math.abs(node.val - min), Math.abs(node.val - max));\n        min = Math.min(min, node.val);\n        max = Math.max(max, node.val);\n        dfs(node.left, min, max);\n        dfs(node.right, min, max);\n    }\n    dfs(root, root.val, root.val);\n    return result;\n    \n};"}
{"id": "1083", "path": "output2\\js\\Medium\\1083-longest-arithmetic-subsequence.js", "hypo_code": "var longestArithSeqLength = function(nums) {\n    let n = nums.length;\n    let result = 0;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Map();\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 0; j < i; j++){\n            let diff = nums[i] - nums[j];\n            if(dp[j].has(diff)){\n                dp[i].set(diff, dp[j].get(diff) + 1);\n            }else{\n                dp[i].set(diff, 2);\n            }\n            result = Math.max(result, dp[i].get(diff));\n        }\n    }\n    return result;\n    \n};"}
{"id": "1084", "path": "output2\\js\\Medium\\1084-two-city-scheduling.js", "hypo_code": "var twoCitySchedCost = function(costs) {\n    let n = costs.length;\n    let dp = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        dp[i] = costs[i - 1][0] + dp[i - 1];\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i; j >= 1; j--){\n            dp[j] = Math.min(dp[j], dp[j - 1] + costs[i - 1][1] - costs[i - 1][0]);\n        }\n    }\n    return dp[n / 2];\n    \n\n};"}
{"id": "1085", "path": "output2\\js\\Medium\\1085-maximum-sum-of-two-non-overlapping-subarrays.js", "hypo_code": "var maxSumTwoNoOverlap = function(nums, firstLen, secondLen) {\n    let n = nums.length;\n    let first = new Array(n);\n    let second = new Array(n);\n    let sum = 0;\n    for(let i = 0; i < n; i++){\n        sum += nums[i];\n        if(i >= firstLen){\n            sum -= nums[i - firstLen];\n        }\n        first[i] = sum;\n    }\n    sum = 0;\n    for(let i = 0; i < n; i++){\n        sum += nums[i];\n        if(i >= secondLen){\n            sum -= nums[i - secondLen];\n        }\n        second[i] = sum;\n    }\n    let result = 0;\n    for(let i = firstLen - 1; i < n; i++){\n        if(i - firstLen >= 0){\n            result = Math.max(result, first[i] + second[i - firstLen]);\n        }\n        if(i + secondLen < n){\n            result = Math.max(result, first[i] + second[i + secondLen]);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1086", "path": "output2\\js\\Medium\\1086-moving-stones-until-consecutive.js", "hypo_code": "var numMovesStones = function(a, b, c) {\n    let arr = [a, b, c].sort((a, b) => a - b);\n    let min = 0;\n    if(arr[2] - arr[1] > 1){\n        min++;\n    }\n    if(arr[1] - arr[0] > 1){\n        min++;\n    }\n    if(min == 2){\n        if(arr[2] - arr[1] == 2 || arr[1] - arr[0] == 2){\n            min = 1;\n        }\n    }\n    let max = arr[2] - arr[0] - 2;\n    return [min, max];\n    \n};"}
{"id": "1087", "path": "output2\\js\\Medium\\1087-coloring-a-border.js", "hypo_code": "var colorBorder = function(grid, row, col, color) {\n    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() => new Array(m).fill(0));\n    let result = new Array(n).fill(0).map(() => new Array(m).fill(0));\n    let target = grid[row][col];\n    dfs(grid, row, col, color, visited, result, target);\n    return result;\n    \n    \n    \n};"}
{"id": "1088", "path": "output2\\js\\Medium\\1088-uncrossed-lines.js", "hypo_code": "var maxUncrossedLines = function(nums1, nums2) {\n    let n = nums1.length;\n    let m = nums2.length;\n    let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(0));\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            if(nums1[i - 1] == nums2[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }else{\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[n][m];\n    \n};"}
{"id": "1089", "path": "output2\\js\\Medium\\1089-binary-search-tree-to-greater-sum-tree.js", "hypo_code": "var bstToGst = function(root) {\n    let sum = 0;\n    let dfs = function(node){\n        if(node == null){\n            return;\n        }\n        dfs(node.right);\n        sum += node.val;\n        node.val = sum;\n        dfs(node.left);\n    }\n    dfs(root);\n    return root;\n    \n};"}
{"id": "1090", "path": "output2\\js\\Medium\\1090-minimum-score-triangulation-of-polygon.js", "hypo_code": "var minScoreTriangulation = function(values) {\n    let n = values.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    for(let i = 2; i < n; i++){\n        for(let j = 0; j < n - i; j++){\n            let k = j + i;\n            dp[j][k] = Number.MAX_SAFE_INTEGER;\n            for(let m = j + 1; m < k; m++){\n                dp[j][k] = Math.min(dp[j][k], dp[j][m] + dp[m][k] + values[j] * values[m] * values[k]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n    \n};"}
{"id": "1091", "path": "output2\\js\\Medium\\1091-moving-stones-until-consecutive-ii.js", "hypo_code": "var numMovesStonesII = function(stones) {\n    stones.sort((a, b) => a - b);\n    let n = stones.length;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = stones[n - 1] - stones[0] + 1 - n;\n    let i = 0;\n    let j = 0;\n    while(i < n){\n        while(j + 1 < n && stones[j + 1] - stones[i] + 1 <= n){\n            j++;\n        }\n        let cost = n - (j - i + 1);\n        if(j - i + 1 == n - 1 && stones[j] - stones[i] + 1 == n - 1){\n            cost = 2;\n        }\n        min = Math.min(min, cost);\n        i++;\n    }\n    return [min, max];\n    \n};"}
{"id": "1092", "path": "output2\\js\\Medium\\1092-robot-bounded-in-circle.js", "hypo_code": "var isRobotBounded = function(instructions) {\n    let x = 0;\n    let y = 0;\n    let dir = 0;\n    let dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    for(let i = 0; i < instructions.length; i++){\n        let c = instructions[i];\n        if(c == 'G'){\n            x += dirs[dir][0];\n            y += dirs[dir][1];\n        }else if(c == 'L'){\n            dir = (dir + 3) % 4;\n        }else{\n            dir = (dir + 1) % 4;\n        }\n    }\n    return (x == 0 && y == 0) || dir != 0;\n    \n};"}
{"id": "1093", "path": "output2\\js\\Medium\\1093-flower-planting-with-no-adjacent.js", "hypo_code": "var gardenNoAdj = function(n, paths) {\n    let graph = new Array(n).fill(0).map(() => new Array());\n    let result = new Array(n).fill(0);\n    for(let i = 0; i < paths.length; i++){\n        let [a, b] = paths[i];\n        graph[a - 1].push(b - 1);\n        graph[b - 1].push(a - 1);\n    }\n    for(let i = 0; i < n; i++){\n        let used = new Array(5).fill(false);\n        for(let j = 0; j < graph[i].length; j++){\n            used[result[graph[i][j]]] = true;\n        }\n        for(let j = 1; j <= 4; j++){\n            if(!used[j]){\n                result[i] = j;\n                break;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1094", "path": "output2\\js\\Medium\\1094-partition-array-for-maximum-sum.js", "hypo_code": "var maxSumAfterPartitioning = function(arr, k) {\n    let n = arr.length;\n    let dp = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        let max = 0;\n        for(let j = 1; j <= k && i - j + 1 >= 0; j++){\n            max = Math.max(max, arr[i - j + 1]);\n            dp[i] = Math.max(dp[i], (i >= j ? dp[i - j] : 0) + max * j);\n        }\n    }\n    return dp[n - 1];\n    \n};"}
{"id": "1096", "path": "output2\\js\\Medium\\1096-longest-string-chain.js", "hypo_code": "var longestStrChain = function(words) {\n    words.sort((a, b) => a.length - b.length);\n\tconst map = new Map();\n\tlet result = 0;\n\tfor (let word of words) {\n\t\tlet max = 0;\n\t\tfor (let i = 0; i < word.length; i++) {\n\t\t\tconst prev = word.slice(0, i) + word.slice(i + 1);\n\t\t\tmax = Math.max(max, (map.get(prev) || 0) + 1);\n\t\t}\n\t\tmap.set(word, max);\n\t\tresult = Math.max(result, max);\n\t}\n\treturn result;\n};"}
{"id": "1097", "path": "output2\\js\\Medium\\1097-last-stone-weight-ii.js", "hypo_code": "var lastStoneWeightII = function(stones) {\n    const sum = stones.reduce((acc, cur) => acc + cur);\n    const n = Math.floor(sum / 2);\n    const dp = new Array(n + 1).fill(0);\n    for (let i = 0; i < stones.length; i++) {\n        for (let j = n; j >= stones[i]; j--) {\n            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);\n        }\n    }\n    return sum - 2 * dp[n];\n};"}
{"id": "1098", "path": "output2\\js\\Medium\\1098-grumpy-bookstore-owner.js", "hypo_code": "var maxSatisfied = function(customers, grumpy, minutes) {\n    let max = 0;\n    for (let i = 0; i < customers.length; i++) {\n        max += grumpy[i] === 0 ? customers[i] : 0;\n    }\n    let current = 0;\n    for (let i = 0; i < minutes; i++) {\n        current += customers[i] * grumpy[i];\n    }\n    let maxCurrent = current;\n    for (let i = minutes; i < customers.length; i++) {\n        current = current - customers[i - minutes] * grumpy[i - minutes] + customers[i] * grumpy[i];\n        maxCurrent = Math.max(current, maxCurrent);\n    }\n    return max + maxCurrent;\n};"}
{"id": "1099", "path": "output2\\js\\Medium\\1099-previous-permutation-with-one-swap.js", "hypo_code": "var prevPermOpt1 = function(arr) {\n    let i = arr.length - 2;\n    while (i >= 0 && arr[i] <= arr[i + 1]) {\n        i--;\n    }\n    if (i >= 0) {\n        let j = arr.length - 1;\n        while (arr[j] >= arr[i]) {\n            j--;\n        }\n        while (j > 0 && arr[j - 1] === arr[j]) {\n            j--;\n        }\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n};"}
{"id": "1100", "path": "output2\\js\\Medium\\1100-distant-barcodes.js", "hypo_code": "var rearrangeBarcodes = function(barcodes) {\n    const result = new Array(barcodes.length);\n    let i = 0;\n    const barcodeCount = {};\n    for (const barcode of barcodes) {\n        barcodeCount[barcode] = barcodeCount[barcode] + 1 || 1;\n    }\n    const sortedBarcodes = Object.keys(barcodeCount).sort((a, b) => {\n        return barcodeCount[b] - barcodeCount[a];\n    });\n    for (const barcode of sortedBarcodes) {\n        let count = barcodeCount[barcode];\n        while (count > 0) {\n            result[i] = barcode;\n            count--;\n            i += 2;\n            if (i >= barcodes.length) {\n                i = 1;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "1101", "path": "output2\\js\\Medium\\1101-lexicographically-smallest-equivalent-string.js", "hypo_code": "var smallestEquivalentString = function(s1, s2, baseStr) {\n    const parents = new Array(26).fill(0).map((_, i) => i);\n    function find(x) {\n        if (parents[x] !== x) {\n            parents[x] = find(parents[x]);\n        }\n        return parents[x];\n    }\n    function union(x, y) {\n        const rootX = find(x);\n        const rootY = find(y);\n        if (rootX < rootY) {\n            parents[rootY] = rootX;\n        } else {\n            parents[rootX] = rootY;\n        }\n    }\n    for (let i = 0; i < s1.length; i++) {\n        union(s1.charCodeAt(i) - 97, s2.charCodeAt(i) - 97);\n    }\n    const result = [];\n    for (let i = 0; i < baseStr.length; i++) {\n        result.push(String.fromCharCode(find(baseStr.charCodeAt(i) - 97) + 97));\n    }\n    return result.join('');\n};"}
{"id": "1103", "path": "output2\\js\\Medium\\1103-flip-columns-for-maximum-number-of-equal-rows.js", "hypo_code": "var maxEqualRowsAfterFlips = function(matrix) {\n    const map = new Map();\n    for (let i = 0; i < matrix.length; i++) {\n        let row = '';\n        for (let j = 0; j < matrix[0].length; j++) {\n            row += matrix[i][j] ^ matrix[i][0];\n        }\n        map.set(row, (map.get(row) || 0) + 1);\n    }\n    return Math.max(...map.values());\n};"}
{"id": "1104", "path": "output2\\js\\Medium\\1104-adding-two-negabinary-numbers.js", "hypo_code": "var addNegabinary = function(arr1, arr2) {\n    const result = [];\n    let i = arr1.length - 1;\n    let j = arr2.length - 1;\n    let carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        let sum = carry;\n        if (i >= 0) {\n            sum += arr1[i--];\n        }\n        if (j >= 0) {\n            sum += arr2[j--];\n        }\n        result.push(sum & 1);\n        carry = -(sum >> 1);\n    }\n    while (result.length > 1 && result[result.length - 1] === 0) {\n        result.pop();\n    }\n    return result.reverse();\n};"}
{"id": "1105", "path": "output2\\js\\Medium\\1105-letter-tile-possibilities.js", "hypo_code": "var numTilePossibilities = function(tiles) {\n    const visited = new Array(tiles.length).fill(false);\n    const set = new Set();\n    const dfs = (str) => {\n        if (str.length > 0) {\n            set.add(str);\n        }\n        for (let i = 0; i < tiles.length; i++) {\n            if (!visited[i]) {\n                visited[i] = true;\n                dfs(str + tiles[i]);\n                visited[i] = false;\n            }\n        }\n    }\n    dfs('');\n    return set.size;\n};"}
{"id": "1106", "path": "output2\\js\\Medium\\1106-insufficient-nodes-in-root-to-leaf-paths.js", "hypo_code": "var sufficientSubset = function(root, limit) {\n    const removeInsufficientNodes = (node, sum) => {\n        if (!node) {\n            return null;\n        }\n        sum += node.val;\n        if (!node.left && !node.right) {\n            return sum < limit ? null : node;\n        }\n        node.left = removeInsufficientNodes(node.left, sum);\n        node.right = removeInsufficientNodes(node.right, sum);\n        return node.left || node.right ? node : null;\n    }\n    return removeInsufficientNodes(root, 0);\n};"}
{"id": "1107", "path": "output2\\js\\Medium\\1107-smallest-subsequence-of-distinct-characters.js", "hypo_code": "var smallestSubsequence = function(s) {\n    const stack = [];\n    const map = new Map();\n    for (let c of s) {\n        map.set(c, map.get(c) + 1 || 1);\n    }\n    for (let c of s) {\n        map.set(c, map.get(c) - 1);\n        if (stack.includes(c)) {\n            continue;\n        }\n        while (stack.length && c < stack[stack.length - 1] && map.get(stack[stack.length - 1]) > 0) {\n            stack.pop();\n        }\n        stack.push(c);\n    }\n    return stack.join('');\n};"}
{"id": "1108", "path": "output2\\js\\Medium\\1108-largest-values-from-labels.js", "hypo_code": "var largestValsFromLabels = function(values, labels, numWanted, useLimit) {\n    const valueLabel = [];\n    for (let i = 0; i < values.length; i++) {\n        valueLabel.push([values[i], labels[i]]);\n    }\n    valueLabel.sort((a, b) => b[0] - a[0]);\n    const labelUsed = new Map();\n    let count = 0;\n    let sum = 0;\n    for (let i = 0; i < valueLabel.length; i++) {\n        const [value, label] = valueLabel[i];\n        if (count === numWanted) {\n            break;\n        }\n        if (labelUsed.get(label) === undefined) {\n            labelUsed.set(label, 1);\n            sum += value;\n            count++;\n        } else if (labelUsed.get(label) < useLimit) {\n            labelUsed.set(label, labelUsed.get(label) + 1);\n            sum += value;\n            count++;\n        }\n    }\n    return sum;\n};"}
{"id": "1109", "path": "output2\\js\\Medium\\1109-shortest-path-in-binary-matrix.js", "hypo_code": "var shortestPathBinaryMatrix = function(grid) {\n    if (grid[0][0] !== 0) {\n        return -1;\n    }\n    let queue = [[0, 0]];\n    let steps = 0;\n    while (queue.length) {\n        steps++;\n        const nextQueue = [];\n        for (let i = 0; i < queue.length; i++) {\n            const [x, y] = queue[i];\n            if (x === grid.length - 1 && y === grid[0].length - 1) {\n                return steps;\n            }\n            grid[x][y] = 1;\n            if (x > 0 && y > 0 && grid[x - 1][y - 1] === 0) {\n                nextQueue.push([x - 1, y - 1]);\n            }\n            if (x > 0 && grid[x - 1][y] === 0) {\n                nextQueue.push([x - 1, y]);\n            }\n            if (x > 0 && y < grid[0].length - 1 && grid[x - 1][y + 1] === 0) {\n                nextQueue.push([x - 1, y + 1]);\n            }\n            if (y > 0 && grid[x][y - 1] === 0) {\n                nextQueue.push([x, y - 1]);\n            }\n            if (y < grid[0].length - 1 && grid[x][y + 1] === 0) {\n                nextQueue.push([x, y + 1]);\n            }\n            if (x < grid.length - 1 && y > 0 && grid[x + 1][y - 1] === 0) {\n                nextQueue.push([x + 1, y - 1]);\n            }\n            if (x < grid.length - 1 && grid[x + 1][y] === 0) {\n                nextQueue.push([x + 1, y]);\n            }\n            if (x < grid.length - 1 && y < grid[0].length - 1 && grid[x + 1][y + 1] === 0) {\n                nextQueue.push([x + 1, y + 1]);\n            }\n        }\n        queue = nextQueue;\n    }\n    return -1;\n\n\n};"}
{"id": "1110", "path": "output2\\js\\Medium\\1110-statistics-from-a-large-sample.js", "hypo_code": "var sampleStats = function(count) {\n    let min = -1;\n    let max = -1;\n    let sum = 0;\n    let total = 0;\n    let median = -1;\n    let mode = -1;\n    let modeCount = 0;\n    for (let i = 0; i < count.length; i++) {\n        if (count[i] > 0) {\n            if (min === -1) {\n                min = i;\n            }\n            max = i;\n            sum += i * count[i];\n            total += count[i];\n            if (count[i] > modeCount) {\n                modeCount = count[i];\n                mode = i;\n            }\n        }\n    }\n    const mean = sum / total;\n    let left = 0;\n    let right = count.length - 1;\n    while (left <= right) {\n        while (count[left] === 0) {\n            left++;\n        }\n        while (count[right] === 0) {\n            right--;\n        }\n        if (left <= right) {\n            if (left === right) {\n                median = left;\n            } else if (left + 1 === right) {\n                median = (left + right) / 2;\n            }\n            left++;\n            right--;\n        }\n    }\n    return [min, max, mean, median, mode];\n};"}
{"id": "1111", "path": "output2\\js\\Medium\\1111-car-pooling.js", "hypo_code": "var carPooling = function(trips, capacity) {\n    const stops = new Array(1001).fill(0);\n    for (const trip of trips) {\n        stops[trip[1]] += trip[0];\n        stops[trip[2]] -= trip[0];\n    }\n    let current = 0;\n    for (const stop of stops) {\n        current += stop;\n        if (current > capacity) {\n            return false;\n        }\n    }\n    return true;\n};"}
{"id": "1112", "path": "output2\\js\\Medium\\1112-path-in-zigzag-labelled-binary-tree.js", "hypo_code": "var pathInZigZagTree = function(label) {\n    const result = [];\n    let level = 1;\n    while (Math.pow(2, level) - 1 < label) {\n        level++;\n    }\n    while (label > 0) {\n        result.push(label);\n        label = Math.floor((Math.pow(2, level) - 1 + Math.pow(2, level - 1) - label) / 2);\n        level--;\n    }\n    return result.reverse();\n};"}
{"id": "1113", "path": "output2\\js\\Medium\\1113-filling-bookcase-shelves.js", "hypo_code": "var minHeightShelves = function(books, shelfWidth) {\n    \n\t\n\t\n\t\n\tvar dp = Array(books.length + 1).fill(1000000);\n\tdp[0] = 0;\n\tfor (var i = 1; i <= books.length; i++) {\n\t\tvar w = 0;\n\t\tvar h = 0;\n\t\tfor (var j = i; j >= 1; j--) {\n\t\t\tw += books[j - 1][0];\n\t\t\tif (w > shelfWidth) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th = Math.max(h, books[j - 1][1]);\n\t\t\tdp[i] = Math.min(dp[i], dp[j - 1] + h);\n\t\t}\n\t}\n\treturn dp[books.length];\n};"}
{"id": "1114", "path": "output2\\js\\Medium\\1114-corporate-flight-bookings.js", "hypo_code": "var corpFlightBookings = function(bookings, n) {\n    var ans = Array(n).fill(0);\n\tfor (var i = 0; i < bookings.length; i++) {\n\t\tans[bookings[i][0] - 1] += bookings[i][2];\n\t\tif (bookings[i][1] < n) {\n\t\t\tans[bookings[i][1]] -= bookings[i][2];\n\t\t}\n\t}\n\tfor (var i = 1; i < n; i++) {\n\t\tans[i] += ans[i - 1];\n\t}\n\treturn ans;\n};"}
{"id": "1115", "path": "output2\\js\\Medium\\1115-delete-nodes-and-return-forest.js", "hypo_code": "var delNodes = function(root, to_delete) {\n    var ans = [];\n\tvar deleteSet = new Set(to_delete);\n\tvar dfs = function(node, isRoot) {\n\t\tif (node == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar deleted = deleteSet.has(node.val);\n\t\tif (isRoot && !deleted) {\n\t\t\tans.push(node);\n\t\t}\n\t\tnode.left = dfs(node.left, deleted);\n\t\tnode.right = dfs(node.right, deleted);\n\t\treturn deleted ? null : node;\n\t};\n\tdfs(root, true);\n\treturn ans;\n};"}
{"id": "1116", "path": "output2\\js\\Medium\\1116-maximum-nesting-depth-of-two-valid-parentheses-strings.js", "hypo_code": "var maxDepthAfterSplit = function(seq) {\n    var ans = [];\n\tvar d = 0;\n\tfor (var i = 0; i < seq.length; i++) {\n\t\tif (seq[i] == '(') {\n\t\t\td++;\n\t\t\tans.push(d % 2);\n\t\t} else {\n\t\t\tans.push(d % 2);\n\t\t\td--;\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1120", "path": "output2\\js\\Medium\\1120-lowest-common-ancestor-of-deepest-leaves.js", "hypo_code": "var lcaDeepestLeaves = function(root) {\n    var ans = null;\n\tvar maxDepth = 0;\n\tvar dfs = function(node, depth) {\n\t\tif (node == null) {\n\t\t\treturn depth;\n\t\t}\n\t\tvar left = dfs(node.left, depth + 1);\n\t\tvar right = dfs(node.right, depth + 1);\n\t\tif (left == right && left >= maxDepth) {\n\t\t\tans = node;\n\t\t\tmaxDepth = left;\n\t\t}\n\t\treturn Math.max(left, right);\n\t};\n\tdfs(root, 0);\n\treturn ans;\n};"}
{"id": "1121", "path": "output2\\js\\Medium\\1121-longest-well-performing-interval.js", "hypo_code": "var longestWPI = function(hours) {\n    var ans = 0;\n\tvar sum = 0;\n\tvar map = {};\n\tfor (var i = 0; i < hours.length; i++) {\n\t\tsum += hours[i] > 8 ? 1 : -1;\n\t\tif (sum > 0) {\n\t\t\tans = i + 1;\n\t\t} else {\n\t\t\tif (map[sum] == null) {\n\t\t\t\tmap[sum] = i;\n\t\t\t}\n\t\t\tif (map[sum - 1] != null) {\n\t\t\t\tans = Math.max(ans, i - map[sum - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1122", "path": "output2\\js\\Medium\\1122-shortest-path-with-alternating-colors.js", "hypo_code": "var shortestAlternatingPaths = function(n, redEdges, blueEdges) {\n    var ans = Array(n).fill(-1);\n\tvar redAdj = Array(n).fill(null).map(() => []);\n\tvar blueAdj = Array(n).fill(null).map(() => []);\n\tfor (var i = 0; i < redEdges.length; i++) {\n\t\tredAdj[redEdges[i][0]].push(redEdges[i][1]);\n\t}\n\tfor (var i = 0; i < blueEdges.length; i++) {\n\t\tblueAdj[blueEdges[i][0]].push(blueEdges[i][1]);\n\t}\n\tvar queue = [[0, 0], [0, 1]];\n\tvar visited = Array(n).fill(null).map(() => Array(2).fill(false));\n\tvisited[0][0] = true;\n\tvisited[0][1] = true;\n\tvar steps = 0;\n\twhile (queue.length > 0) {\n\t\tvar len = queue.length;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar cur = queue.shift();\n\t\t\tvar color = cur[1];\n\t\t\tvar adj = color == 0 ? blueAdj[cur[0]] : redAdj[cur[0]];\n\t\t\tfor (var j = 0; j < adj.length; j++) {\n\t\t\t\tvar next = adj[j];\n\t\t\t\tif (visited[next][1 - color]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisited[next][1 - color] = true;\n\t\t\t\tif (ans[next] == -1) {\n\t\t\t\t\tans[next] = steps + 1;\n\t\t\t\t}\n\t\t\t\tqueue.push([next, 1 - color]);\n\t\t\t}\n\t\t}\n\t\tsteps++;\n\t}\n\treturn ans;\n};"}
{"id": "1123", "path": "output2\\js\\Medium\\1123-minimum-cost-tree-from-leaf-values.js", "hypo_code": "var mctFromLeafValues = function(arr) {\n    var ans = 0;\n\tvar stack = [];\n\tstack.push(100000);\n\tfor (var i = 0; i < arr.length; i++) {\n\t\twhile (stack[stack.length - 1] <= arr[i]) {\n\t\t\tvar mid = stack.pop();\n\t\t\tans += mid * Math.min(stack[stack.length - 1], arr[i]);\n\t\t}\n\t\tstack.push(arr[i]);\n\t}\n\twhile (stack.length > 2) {\n\t\tans += stack.pop() * stack[stack.length - 1];\n\t}\n\treturn ans;\n};"}
{"id": "1124", "path": "output2\\js\\Medium\\1124-maximum-of-absolute-value-expression.js", "hypo_code": "var maxAbsValExpr = function(arr1, arr2) {\n    var ans = 0;\n\tvar n = arr1.length;\n\tvar max1 = -Infinity;\n\tvar max2 = -Infinity;\n\tvar max3 = -Infinity;\n\tvar max4 = -Infinity;\n\tfor (var i = 0; i < n; i++) {\n\t\tmax1 = Math.max(max1, arr1[i] + arr2[i] + i);\n\t\tmax2 = Math.max(max2, arr1[i] - arr2[i] + i);\n\t\tmax3 = Math.max(max3, arr1[i] + arr2[i] - i);\n\t\tmax4 = Math.max(max4, arr1[i] - arr2[i] - i);\n\t}\n\tvar min1 = Infinity;\n\tvar min2 = Infinity;\n\tvar min3 = Infinity;\n\tvar min4 = Infinity;\n\tfor (var i = 0; i < n; i++) {\n\t\tmin1 = Math.min(min1, arr1[i] + arr2[i] + i);\n\t\tmin2 = Math.min(min2, arr1[i] - arr2[i] + i);\n\t\tmin3 = Math.min(min3, arr1[i] + arr2[i] - i);\n\t\tmin4 = Math.min(min4, arr1[i] - arr2[i] - i);\n\t}\n\tans = Math.max(ans, max1 - min1, max2 - min2, max3 - min3, max4 - min4);\n\treturn ans;\n};"}
{"id": "1125", "path": "output2\\js\\Medium\\1125-alphabet-board-path.js", "hypo_code": "var alphabetBoardPath = function(target) {\n    var ans = '';\n\tvar cur = [0, 0];\n\tvar board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\n\tvar getPos = function(c) {\n\t\tfor (var i = 0; i < board.length; i++) {\n\t\t\tfor (var j = 0; j < board[i].length; j++) {\n\t\t\t\tif (board[i][j] == c) {\n\t\t\t\t\treturn [i, j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [-1, -1];\n\t};\n\tvar getMove = function(c) {\n\t\tvar pos = getPos(c);\n\t\tvar ans = '';\n\t\tvar x = pos[0] - cur[0];\n\t\tvar y = pos[1] - cur[1];\n\t\tif (x > 0) {\n\t\t\tans += 'D'.repeat(x);\n\t\t} else {\n\t\t\tans += 'U'.repeat(-x);\n\t\t}\n\t\tif (y > 0) {\n\t\t\tans += 'R'.repeat(y);\n\t\t} else {\n\t\t\tans += 'L'.repeat(-y);\n\t\t}\n\t\tcur = pos;\n\t\treturn ans;\n\t};\n\tfor (var i = 0; i < target.length; i++) {\n\t\tans += getMove(target[i]);\n\t\tans += '!';\n\t}\n\treturn ans;\n};"}
{"id": "1126", "path": "output2\\js\\Medium\\1126-largest-1-bordered-square.js", "hypo_code": "var largest1BorderedSquare = function(grid) {\n    var ans = 0;\n\tvar m = grid.length;\n\tvar n = grid[0].length;\n\tvar hor = Array(m).fill(0).map(() => Array(n).fill(0));\n\tvar ver = Array(m).fill(0).map(() => Array(n).fill(0));\n\tfor (var i = 0; i < m; i++) {\n\t\tfor (var j = 0; j < n; j++) {\n\t\t\tif (grid[i][j] == 1) {\n\t\t\t\thor[i][j] = j > 0 ? hor[i][j - 1] + 1 : 1;\n\t\t\t\tver[i][j] = i > 0 ? ver[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (var i = m - 1; i >= 0; i--) {\n\t\tfor (var j = n - 1; j >= 0; j--) {\n\t\t\tvar small = Math.min(hor[i][j], ver[i][j]);\n\t\t\twhile (small > ans) {\n\t\t\t\tif (ver[i][j - small + 1] >= small && hor[i - small + 1][j] >= small) {\n\t\t\t\t\tans = small;\n\t\t\t\t}\n\t\t\t\tsmall--;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans * ans;\n};"}
{"id": "1127", "path": "output2\\js\\Medium\\1127-stone-game-ii.js", "hypo_code": "var stoneGameII = function(piles) {\n    var n = piles.length;\n\tvar sum = Array(n).fill(0);\n\tsum[n - 1] = piles[n - 1];\n\tfor (var i = n - 2; i >= 0; i--) {\n\t\tsum[i] = sum[i + 1] + piles[i];\n\t}\n\tvar memo = {};\n\tvar dfs = function(i, m) {\n\t\tif (i >= n) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar key = i + \",\" + m;\n\t\tif (memo[key] != null) {\n\t\t\treturn memo[key];\n\t\t}\n\t\tvar ans = 0;\n\t\tfor (var x = 1; x <= 2 * m; x++) {\n\t\t\tans = Math.max(ans, sum[i] - dfs(i + x, Math.max(m, x)));\n\t\t}\n\t\tmemo[key] = ans;\n\t\treturn ans;\n\t};\n\treturn dfs(0, 1);\n};"}
{"id": "1128", "path": "output2\\js\\Medium\\1128-longest-common-subsequence.js", "hypo_code": "var longestCommonSubsequence = function(text1, text2) { \n    var dp = [];\n\tfor (var i = 0; i <= text1.length; i++) {\n\t\tdp[i] = [];\n\t\tfor (var j = 0; j <= text2.length; j++) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tfor (var i = 1; i <= text1.length; i++) {\n\t\tfor (var j = 1; j <= text2.length; j++) {\n\t\t\tif (text1[i - 1] == text2[j - 1]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[text1.length][text2.length];\n};"}
{"id": "1129", "path": "output2\\js\\Medium\\1129-decrease-elements-to-make-array-zigzag.js", "hypo_code": "var movesToMakeZigzag = function(nums) {\n    var len = nums.length;\n\tvar ans1 = 0;\n\tvar ans2 = 0;\n\tfor (var i = 0; i < len; i++) {\n\t\tvar left = i > 0 ? nums[i - 1] : Infinity;\n\t\tvar right = i < len - 1 ? nums[i + 1] : Infinity;\n\t\tans1 += Math.max(0, nums[i] - Math.min(left, right) + 1);\n\t\tif (i > 0 && nums[i - 1] >= nums[i]) {\n\t\t\tans1 += nums[i - 1] - nums[i] + 1;\n\t\t}\n\t\tif (i < len - 1 && nums[i + 1] >= nums[i]) {\n\t\t\tans1 += nums[i + 1] - nums[i] + 1;\n\t\t}\n\t}\n\tfor (var i = 0; i < len; i++) {\n\t\tvar left = i > 0 ? nums[i - 1] : Infinity;\n\t\tvar right = i < len - 1 ? nums[i + 1] : Infinity;\n\t\tans2 += Math.max(0, nums[i] - Math.min(left, right) + 1);\n\t\tif (i > 0 && nums[i - 1] <= nums[i]) {\n\t\t\tans2 += nums[i] - nums[i - 1] + 1;\n\t\t}\n\t\tif (i < len - 1 && nums[i + 1] <= nums[i]) {\n\t\t\tans2 += nums[i] - nums[i + 1] + 1;\n\t\t}\n\t}\n\treturn Math.min(ans1, ans2);\n};"}
{"id": "1130", "path": "output2\\js\\Medium\\1130-binary-tree-coloring-game.js", "hypo_code": "var btreeGameWinningMove = function(root, n, x) {\n    var left, right;\n\tvar dfs = function(node) {\n\t\tif (node == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar l = dfs(node.left);\n\t\tvar r = dfs(node.right);\n\t\tif (node.val == x) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\t\treturn l + r + 1;\n\t};\n\tdfs(root);\n\treturn Math.max(left, right, n - left - right - 1) > n / 2;\n\n};"}
{"id": "1132", "path": "output2\\js\\Medium\\1132-number-of-dice-rolls-with-target-sum.js", "hypo_code": "var numRollsToTarget = function(n, k, target) {\n    var mod = 1000000007;\n\tvar dp = Array(n + 1).fill(0).map(() => Array(target + 1).fill(0));\n\tdp[0][0] = 1;\n\tfor (var i = 1; i <= n; i++) {\n\t\tfor (var j = 1; j <= target; j++) {\n\t\t\tfor (var l = 1; l <= k; l++) {\n\t\t\t\tif (j >= l) {\n\t\t\t\t\tdp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n][target];\n};"}
{"id": "1133", "path": "output2\\js\\Medium\\1133-swap-for-longest-repeated-character-substring.js", "hypo_code": "var maxRepOpt1 = function(text) {\n    var map = {};\n\tvar ans = 0;\n\tfor (var i = 0; i < text.length; i++) {\n\t\tif (map[text[i]] == null) {\n\t\t\tmap[text[i]] = [];\n\t\t}\n\t\tmap[text[i]].push(i);\n\t}\n\tfor (var key in map) {\n\t\tvar arr = map[key];\n\t\tvar count = 1;\n\t\tvar maxCount = 0;\n\t\tfor (var i = 1; i < arr.length; i++) {\n\t\t\tif (arr[i] == arr[i - 1] + 1) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tmaxCount = Math.max(maxCount, count);\n\t\t\t\tcount = 1;\n\t\t\t\tif (arr[i] == arr[i - 1] + 2) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmaxCount = Math.max(maxCount, count);\n\t\tans = Math.max(ans, maxCount + (arr.length > maxCount ? 1 : 0));\n\t}\n\treturn ans;\n};"}
{"id": "1135", "path": "output2\\js\\Medium\\1135-maximum-level-sum-of-a-binary-tree.js", "hypo_code": "var maxLevelSum = function(root) {\n    var ans = 1;\n\tvar maxSum = Number.MIN_SAFE_INTEGER;\n\tvar queue = [];\n\tqueue.push(root);\n\tfor (var level = 1; queue.length > 0; level++) {\n\t\tvar sum = 0;\n\t\tfor (var i = queue.length - 1; i >= 0; i--) {\n\t\t\tvar node = queue.shift();\n\t\t\tsum += node.val;\n\t\t\tif (node.left != null) {\n\t\t\t\tqueue.push(node.left);\n\t\t\t}\n\t\t\tif (node.right != null) {\n\t\t\t\tqueue.push(node.right);\n\t\t\t}\n\t\t}\n\t\tif (sum > maxSum) {\n\t\t\tmaxSum = sum;\n\t\t\tans = level;\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1136", "path": "output2\\js\\Medium\\1136-as-far-from-land-as-possible.js", "hypo_code": "var maxDistance = function(grid) {\n    var n = grid.length;\n\tvar q = [];\n\tvar visited = Array(n).fill(0).map(() => Array(n).fill(0));\n\tfor (var i = 0; i < n; i++) {\n\t\tfor (var j = 0; j < n; j++) {\n\t\t\tvisited[i][j] = grid[i][j] == 1 ? true : false;\n\t\t\tif (grid[i][j] == 1) {\n\t\t\t\tq.push({x:i, y:j});\n\t\t\t}\n\t\t}\n\t}\n\tif (q.length == 0 || q.length == n * n) {\n\t\treturn -1;\n\t}\n\tvar dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\tvar ans = 0;\n\twhile (q.length > 0) {\n\t\tvar len = q.length;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar cur = q.shift();\n\t\t\tfor (var j = 0; j < 4; j++) {\n\t\t\t\tvar x = cur.x + dirs[j][0];\n\t\t\t\tvar y = cur.y + dirs[j][1];\n\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < n && !visited[x][y]) {\n\t\t\t\t\tvisited[x][y] = true;\n\t\t\t\t\tq.push({x:x, y:y});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans++;\n\t}\n\treturn ans - 1;\n};"}
{"id": "1138", "path": "output2\\js\\Medium\\1138-invalid-transactions.js", "hypo_code": "var invalidTransactions = function(transactions) {\n    var map = {};\n\tvar ans = [];\n\tfor (var i = 0; i < transactions.length; i++) {\n\t\tvar arr = transactions[i].split(',');\n\t\tif (arr[2] > 1000) {\n\t\t\tans.push(transactions[i]);\n\t\t}\n\t\tif (map[arr[0]] == null) {\n\t\t\tmap[arr[0]] = [];\n\t\t}\n\t\tmap[arr[0]].push([parseInt(arr[1]), arr[3], i]);\n\t}\n\tfor (var key in map) {\n\t\tvar arr = map[key];\n\t\tarr.sort(function(a, b) {\n\t\t\treturn a[0] - b[0];\n\t\t});\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\tif (arr[i][0] - arr[j][0] > 60) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (arr[i][1] != arr[j][1]) {\n\t\t\t\t\tans.push(transactions[arr[i][2]]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1139", "path": "output2\\js\\Medium\\1139-compare-strings-by-frequency-of-the-smallest-character.js", "hypo_code": "var numSmallerByFrequency = function(queries, words) {\n    var q = [];\n\tvar w = [];\n\tvar ans = [];\n\tfor (var i = 0; i < queries.length; i++) {\n\t\tq.push(f(queries[i]));\n\t}\n\tfor (var i = 0; i < words.length; i++) {\n\t\tw.push(f(words[i]));\n\t}\n\tw.sort(function(a, b) {\n\t\treturn a - b;\n\t});\n\tfor (var i = 0; i < q.length; i++) {\n\t\tvar count = 0;\n\t\tfor (var j = 0; j < w.length; j++) {\n\t\t\tif (w[j] > q[i]) {\n\t\t\t\tcount = w.length - j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans.push(count);\n\t}\n\treturn ans;\n};"}
{"id": "1140", "path": "output2\\js\\Medium\\1140-remove-zero-sum-consecutive-nodes-from-linked-list.js", "hypo_code": "var removeZeroSumSublists = function(head) {\n    var dummy = new ListNode(0);\n\tdummy.next = head;\n\tvar map = {};\n\tvar sum = 0;\n\tfor (var node = dummy; node != null; node = node.next) {\n\t\tsum += node.val;\n\t\tmap[sum] = node;\n\t}\n\tsum = 0;\n\tfor (var node = dummy; node != null; node = node.next) {\n\t\tsum += node.val;\n\t\tnode.next = map[sum].next;\n\t}\n\treturn dummy.next;\n};"}
{"id": "1142", "path": "output2\\js\\Medium\\1142-can-make-palindrome-from-substring.js", "hypo_code": "var canMakePaliQueries = function(s, queries) {\n    var ans = [];\n\tvar dp = [];\n\tfor (var i = 0; i <= s.length; i++) {\n\t\tdp[i] = [];\n\t\tfor (var j = 0; j < 26; j++) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tfor (var i = 1; i <= s.length; i++) {\n\t\tvar index = s.charCodeAt(i - 1) - 'a'.charCodeAt(0);\n\t\tdp[i][index]++;\n\t\tfor (var j = 0; j < 26; j++) {\n\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t}\n\t}\n\tfor (var i = 0; i < queries.length; i++) {\n\t\tvar left = queries[i][0];\n\t\tvar right = queries[i][1];\n\t\tvar k = queries[i][2];\n\t\tvar odd = 0;\n\t\tfor (var j = 0; j < 26; j++) {\n\t\t\tvar count = dp[right + 1][j] - dp[left][j];\n\t\t\todd += count % 2;\n\t\t}\n\t\tans.push(odd / 2 <= k);\n\t}\n\treturn ans;\n};"}
{"id": "1143", "path": "output2\\js\\Medium\\1143-maximum-subarray-sum-with-one-deletion.js", "hypo_code": "var maximumSum = function(arr) {\n    var len = arr.length;\n\tvar dp0 = Array(len).fill(0);\n\tvar dp1 = Array(len).fill(0);\n\tdp0[0] = arr[0];\n\tdp1[0] = -Infinity;\n\tvar ans = dp0[0];\n\tfor (var i = 1; i < len; i++) {\n\t\tdp0[i] = Math.max(arr[i], dp0[i - 1] + arr[i]);\n\t\tdp1[i] = Math.max(dp0[i - 1], dp1[i - 1] + arr[i]);\n\t\tans = Math.max(ans, dp0[i], dp1[i]);\n\t}\n\treturn ans;\n};"}
{"id": "1144", "path": "output2\\js\\Medium\\1144-reverse-substrings-between-each-pair-of-parentheses.js", "hypo_code": "var reverseParentheses = function(s) {\n    var stack = [];\n\tvar str = '';\n\tfor (var i = 0; i < s.length; i++) {\n\t\tif (s[i] == '(') {\n\t\t\tstack.push(str);\n\t\t\tstr = '';\n\t\t} else if (s[i] == ')') {\n\t\t\tstr = stack.pop() + str.split('').reverse().join('');\n\t\t} else {\n\t\t\tstr += s[i];\n\t\t}\n\t}\n\treturn str;\n};"}
{"id": "1145", "path": "output2\\js\\Medium\\1145-k-concatenation-maximum-sum.js", "hypo_code": "var kConcatenationMaxSum = function(arr, k) {\n    var mod = 1000000007;\n\tvar sum = 0;\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tsum += arr[i];\n\t}\n\tvar ans = 0;\n\tvar dp = 0;\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tdp = Math.max(dp + arr[i], arr[i]);\n\t\tans = Math.max(ans, dp);\n\t}\n\tvar left = 0;\n\tdp = 0;\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tleft += arr[i];\n\t\tdp = Math.max(dp + arr[i], arr[i]);\n\t\tans = Math.max(ans, dp);\n\t}\n\tvar right = 0;\n\tdp = 0;\n\tfor (var i = arr.length - 1; i >= 0; i--) {\n\t\tright += arr[i];\n\t\tdp = Math.max(dp + arr[i], arr[i]);\n\t\tans = Math.max(ans, dp);\n\t}\n\tif (k == 1) {\n\t\treturn ans;\n\t}\n\tif (sum <= 0) {\n\t\treturn Math.max(ans, left + right);\n\t}\n\treturn Math.max(ans, left + right + (k - 2) * sum) % mod;\n\n};"}
{"id": "1148", "path": "output2\\js\\Medium\\1148-ugly-number-iii.js", "hypo_code": "var nthUglyNumber = function(n, a, b, c) {\n    var left = 1;\n\tvar right = 2000000000;\n\tvar ans = 0;\n\twhile (left <= right) {\n\t\tvar mid = left + Math.floor((right - left) / 2);\n\t\tvar count = Math.floor(mid / a) + Math.floor(mid / b) + Math.floor(mid / c) - Math.floor(mid / lcm(a, b)) - Math.floor(mid / lcm(a, c)) - Math.floor(mid / lcm(b, c)) + Math.floor(mid / lcm(a, lcm(b, c)));\n\t\tif (count >= n) {\n\t\t\tans = mid;\n\t\t\tright = mid - 1;\n\t\t} else {\n\t\t\tleft = mid + 1;\n\t\t}\n\t}\n\treturn ans;\n};\nvar gcd = function(a, b) {\n\treturn b == 0 ? a : gcd(b, a % b);\n}\nvar lcm = function(a, b) {\n\treturn a * b / gcd(a, b);\n}"}
{"id": "1149", "path": "output2\\js\\Medium\\1149-smallest-string-with-swaps.js", "hypo_code": "var smallestStringWithSwaps = function(s, pairs) {\n    var n = s.length;\n\tvar fa = [];\n\tfor (var i = 0; i < n; i++) {\n\t\tfa[i] = i;\n\t}\n\tvar find = function(x) {\n\t\treturn fa[x] == x ? x : fa[x] = find(fa[x]);\n\t}\n\tvar merge = function(x, y) {\n\t\tfa[find(x)] = find(y);\n\t}\n\tfor (var i = 0; i < pairs.length; i++) {\n\t\tmerge(pairs[i][0], pairs[i][1]);\n\t}\n\tvar map = {};\n\tfor (var i = 0; i < n; i++) {\n\t\tvar root = find(i);\n\t\tif (map[root] == null) {\n\t\t\tmap[root] = [];\n\t\t}\n\t\tmap[root].push(i);\n\t}\n\tvar ans = s.split(\"\");\n\tfor (var key in map) {\n\t\tvar arr = map[key];\n\t\tvar list = [];\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tlist.push(s[arr[i]]);\n\t\t}\n\t\tlist.sort();\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tans[arr[i]] = list[i];\n\t\t}\n\t}\n\treturn ans.join(\"\");\n};"}
{"id": "1151", "path": "output2\\js\\Medium\\1151-get-equal-substrings-within-budget.js", "hypo_code": "var equalSubstring = function(s, t, maxCost) {\n    var ans = 0;\n\tvar sum = 0;\n\tvar i = 0;\n\tvar j = 0;\n\twhile (j < s.length) {\n\t\tsum += Math.abs(s.charCodeAt(j) - t.charCodeAt(j));\n\t\twhile (sum > maxCost) {\n\t\t\tsum -= Math.abs(s.charCodeAt(i) - t.charCodeAt(i));\n\t\t\ti++;\n\t\t}\n\t\tans = Math.max(ans, j - i + 1);\n\t\tj++;\n\t}\n\treturn ans;\n};"}
{"id": "1152", "path": "output2\\js\\Medium\\1152-remove-all-adjacent-duplicates-in-string-ii.js", "hypo_code": "var removeDuplicates = function(s, k) {\n    var stack = [];\n\tfor (var i = 0; i < s.length; i++) {\n\t\tif (stack.length > 0 && stack[stack.length - 1][0] == s[i]) {\n\t\t\tstack[stack.length - 1][1]++;\n\t\t\tif (stack[stack.length - 1][1] == k) {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t} else {\n\t\t\tstack.push([s[i], 1]);\n\t\t}\n\t}\n\tvar ans = '';\n\tfor (var i = 0; i < stack.length; i++) {\n\t\tans += stack[i][0].repeat(stack[i][1]);\n\t}\n\treturn ans;\n};"}
{"id": "1153", "path": "output2\\js\\Medium\\1153-longest-arithmetic-subsequence-of-given-difference.js", "hypo_code": "var longestSubsequence = function(arr, difference) {\n    var map = {};\n\tvar ans = 0;\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar num = arr[i];\n\t\tvar pre = num - difference;\n\t\tvar count = map[pre] || 0;\n\t\tmap[num] = count + 1;\n\t\tans = Math.max(ans, map[num]);\n\t}\n\treturn ans;\n};"}
{"id": "1154", "path": "output2\\js\\Medium\\1154-path-with-maximum-gold.js", "hypo_code": "var getMaximumGold = function(grid) {\n    var n = grid.length;\n\tvar m = grid[0].length;\n\tvar dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\tvar visited = Array(n).fill(0).map(() => Array(m).fill(0));\n\tvar dfs = function(i, j, sum) {\n\t\tvar ans = sum;\n\t\tfor (var k = 0; k < 4; k++) {\n\t\t\tvar x = i + dirs[k][0];\n\t\t\tvar y = j + dirs[k][1];\n\t\t\tif (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != 0 && visited[x][y] == 0) {\n\t\t\t\tvisited[x][y] = 1;\n\t\t\t\tans = Math.max(ans, dfs(x, y, sum + grid[x][y]));\n\t\t\t\tvisited[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t};\n\tvar ans = 0;\n\tfor (var i = 0; i < n; i++) {\n\t\tfor (var j = 0; j < m; j++) {\n\t\t\tif (grid[i][j] != 0) {\n\t\t\t\tvisited[i][j] = 1;\n\t\t\t\tans = Math.max(ans, dfs(i, j, grid[i][j]));\n\t\t\t\tvisited[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1155", "path": "output2\\js\\Medium\\1155-queens-that-can-attack-the-king.js", "hypo_code": "var queensAttacktheKing = function(queens, king) {\n    var ans = [];\n\tvar directions = [\n\t\t[-1, -1],\n\t\t[-1, 0],\n\t\t[-1, 1],\n\t\t[0, -1],\n\t\t[0, 1],\n\t\t[1, -1],\n\t\t[1, 0],\n\t\t[1, 1]\n\t];\n\tvar map = {};\n\tfor (var i = 0; i < queens.length; i++) {\n\t\tmap[queens[i][0] + \",\" + queens[i][1]] = true;\n\t}\n\tfor (var i = 0; i < directions.length; i++) {\n\t\tvar x = king[0] + directions[i][0];\n\t\tvar y = king[1] + directions[i][1];\n\t\twhile (x >= 0 && x < 8 && y >= 0 && y < 8) {\n\t\t\tif (map[x + \",\" + y]) {\n\t\t\t\tans.push([x, y]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx += directions[i][0];\n\t\t\ty += directions[i][1];\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1157", "path": "output2\\js\\Medium\\1157-airplane-seat-assignment-probability.js", "hypo_code": "var nthPersonGetsNthSeat = function(n) {\n    return n == 1 ? 1 : 0.5;\n};"}
{"id": "1158", "path": "output2\\js\\Medium\\1158-remove-sub-folders-from-the-filesystem.js", "hypo_code": "var removeSubfolders = function(folder) {\n    folder.sort();\n\tvar ans = [];\n\tfor (var i = 0; i < folder.length; i++) {\n\t\tif (ans.length == 0 || folder[i].indexOf(ans[ans.length - 1] + '/') != 0) {\n\t\t\tans.push(folder[i]);\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1159", "path": "output2\\js\\Medium\\1159-replace-the-substring-for-balanced-string.js", "hypo_code": "var balancedString = function(s) {\n    var map = {};\n\tvar len = s.length;\n\tvar count = len / 4;\n\tvar ans = len;\n\tfor (var i = 0; i < len; i++) {\n\t\tif (map[s[i]] == null) {\n\t\t\tmap[s[i]] = 0;\n\t\t}\n\t\tmap[s[i]]++;\n\t}\n\tvar left = 0;\n\tvar right = 0;\n\twhile (right < len) {\n\t\tmap[s[right]]--;\n\t\twhile (left < len && map.Q <= count && map.W <= count && map.E <= count && map.R <= count) {\n\t\t\tans = Math.min(ans, right - left + 1);\n\t\t\tmap[s[left]]++;\n\t\t\tleft++;\n\t\t}\n\t\tright++;\n\t}\n\treturn ans;\n};"}
{"id": "1160", "path": "output2\\js\\Medium\\1160-find-positive-integer-solution-for-a-given-equation.js", "hypo_code": "var findSolution = function(customfunction, z) {\n    var ans = [];\n\tvar x = 1;\n\tvar y = 1000;\n\twhile (x <= 1000 && y >= 1) {\n\t\tvar res = customfunction.f(x, y);\n\t\tif (res > z) {\n\t\t\ty--;\n\t\t} else if (res < z) {\n\t\t\tx++;\n\t\t} else {\n\t\t\tans.push([x, y]);\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1161", "path": "output2\\js\\Medium\\1161-circular-permutation-in-binary-representation.js", "hypo_code": "var circularPermutation = function(n, start) {\n    var ans = [];\n\tfor (var i = 0; i < 1 << n; i++) {\n\t\tans.push(start ^ i ^ i >> 1);\n\t}\n\treturn ans;\n};"}
{"id": "1162", "path": "output2\\js\\Medium\\1162-maximum-length-of-a-concatenated-string-with-unique-characters.js", "hypo_code": "var maxLength = function(arr) {\n    var ans = 0;\n\tvar dfs = function(index, mask, len) {\n\t\tif (index == arr.length) {\n\t\t\tans = Math.max(ans, len);\n\t\t\treturn;\n\t\t}\n\t\tdfs(index + 1, mask, len);\n\t\tvar newMask = 0;\n\t\tvar valid = true;\n\t\tfor (var i = 0; i < arr[index].length; i++) {\n\t\t\tvar bit = 1 << (arr[index].charCodeAt(i) - 'a'.charCodeAt(0));\n\t\t\tif ((newMask & bit) != 0) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewMask |= bit;\n\t\t}\n\t\tif (valid && (newMask & mask) == 0) {\n\t\t\tdfs(index + 1, newMask | mask, len + arr[index].length);\n\t\t}\n\t};\n\tdfs(0, 0, 0);\n\treturn ans;\n};"}
{"id": "1163", "path": "output2\\js\\Medium\\1163-minimum-swaps-to-make-strings-equal.js", "hypo_code": "var minimumSwap = function(s1, s2) {\n    var x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n\tfor (var i = 0; i < s1.length; i++) {\n\t\tif (s1[i] == 'x') {\n\t\t\tx1++;\n\t\t} else {\n\t\t\ty1++;\n\t\t}\n\t\tif (s2[i] == 'x') {\n\t\t\tx2++;\n\t\t} else {\n\t\t\ty2++;\n\t\t}\n\t}\n\tif ((x1 + x2) % 2 != 0 || (y1 + y2) % 2 != 0) {\n\t\treturn -1;\n\t}\n\tvar ans = 0;\n\tans += Math.floor(x1 / 2);\n\tans += Math.floor(y1 / 2);\n\tif (x1 % 2 == 1) {\n\t\tans += 2;\n\t}\n\treturn ans;\n};"}
{"id": "1164", "path": "output2\\js\\Medium\\1164-count-number-of-nice-subarrays.js", "hypo_code": "var numberOfSubarrays = function(nums, k) {\n    var ans = 0;\n\tvar n = nums.length;\n\tvar odd = 0;\n\tvar map = {};\n\tmap[0] = 1;\n\tfor (var i = 0; i < n; i++) {\n\t\todd += nums[i] % 2;\n\t\tif (map[odd - k] != null) {\n\t\t\tans += map[odd - k];\n\t\t}\n\t\tmap[odd] = (map[odd] || 0) + 1;\n\t}\n\treturn ans;\n};"}
{"id": "1165", "path": "output2\\js\\Medium\\1165-minimum-remove-to-make-valid-parentheses.js", "hypo_code": "var minRemoveToMakeValid = function(s) {\n    var stack = [];\n\tvar arr = s.split('');\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (arr[i] == '(') {\n\t\t\tstack.push(i);\n\t\t} else if (arr[i] == ')') {\n\t\t\tif (stack.length > 0) {\n\t\t\t\tstack.pop();\n\t\t\t} else {\n\t\t\t\tarr[i] = '';\n\t\t\t}\n\t\t}\n\t}\n\twhile (stack.length > 0) {\n\t\tarr[stack.pop()] = '';\n\t}\n\treturn arr.join('');\n};"}
{"id": "1166", "path": "output2\\js\\Medium\\1166-reconstruct-a-2-row-binary-matrix.js", "hypo_code": "var reconstructMatrix = function(upper, lower, colsum) {\n    var ans = [[], []];\n\tvar len = colsum.length;\n\tfor (var i = 0; i < len; i++) {\n\t\tif (colsum[i] == 2) {\n\t\t\tans[0][i] = 1;\n\t\t\tans[1][i] = 1;\n\t\t\tupper--;\n\t\t\tlower--;\n\t\t}\n\t}\n\tfor (var i = 0; i < len; i++) {\n\t\tif (colsum[i] == 1) {\n\t\t\tif (upper > 0) {\n\t\t\t\tans[0][i] = 1;\n\t\t\t\tupper--;\n\t\t\t} else {\n\t\t\t\tans[1][i] = 1;\n\t\t\t\tlower--;\n\t\t\t}\n\t\t}\n\t}\n\tif (upper != 0 || lower != 0) {\n\t\treturn [];\n\t}\n\treturn ans;\n};"}
{"id": "1167", "path": "output2\\js\\Medium\\1167-number-of-closed-islands.js", "hypo_code": "var closedIsland = function(grid) {\n    var m = grid.length;\n\tvar n = grid[0].length;\n\tvar visited = Array(m).fill(0).map(() => Array(n).fill(0));\n\tvar dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\tvar ans = 0;\n\tfor (var i = 0; i < m; i++) {\n\t\tfor (var j = 0; j < n; j++) {\n\t\t\tif (grid[i][j] == 0 && !visited[i][j]) {\n\t\t\t\tvar q = [];\n\t\t\t\tvar flag = true;\n\t\t\t\tq.push({x:i, y:j});\n\t\t\t\tvisited[i][j] = true;\n\t\t\t\twhile (q.length > 0) {\n\t\t\t\t\tvar cur = q.shift();\n\t\t\t\t\tfor (var k = 0; k < 4; k++) {\n\t\t\t\t\t\tvar x = cur.x + dirs[k][0];\n\t\t\t\t\t\tvar y = cur.y + dirs[k][1];\n\t\t\t\t\t\tif (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 0 && !visited[x][y]) {\n\t\t\t\t\t\t\tvisited[x][y] = true;\n\t\t\t\t\t\t\tq.push({x:x, y:y});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cur.x == 0 || cur.x == m - 1 || cur.y == 0 || cur.y == n - 1) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1169", "path": "output2\\js\\Medium\\1169-greatest-sum-divisible-by-three.js", "hypo_code": "var maxSumDivThree = function(nums) {\n    var dp = Array(3).fill(0);\n\tfor (var i = 0; i < nums.length; i++) {\n\t\tvar mod = nums[i] % 3;\n\t\tvar tmp = dp.slice();\n\t\tfor (var j = 0; j < 3; j++) {\n\t\t\tdp[(j + mod) % 3] = Math.max(dp[(j + mod) % 3], tmp[j] + nums[i]);\n\t\t}\n\t}\n\treturn dp[0];\n};"}
{"id": "1170", "path": "output2\\js\\Medium\\1170-count-servers-that-communicate.js", "hypo_code": "var countServers = function(grid) {\n    var m = grid.length;\n\tvar n = grid[0].length;\n\tvar row = Array(m).fill(0);\n\tvar col = Array(n).fill(0);\n\tvar ans = 0;\n\tfor (var i = 0; i < m; i++) {\n\t\tfor (var j = 0; j < n; j++) {\n\t\t\tif (grid[i][j] == 1) {\n\t\t\t\trow[i]++;\n\t\t\t\tcol[j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (var i = 0; i < m; i++) {\n\t\tif (row[i] > 1) {\n\t\t\tfor (var j = 0; j < n; j++) {\n\t\t\t\tif (grid[i][j] == 1) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (var j = 0; j < n; j++) {\n\t\tif (col[j] > 1) {\n\t\t\tfor (var i = 0; i < m; i++) {\n\t\t\t\tif (grid[i][j] == 1) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1171", "path": "output2\\js\\Medium\\1171-search-suggestions-system.js", "hypo_code": "var suggestedProducts = function(products, searchWord) {\n    products.sort();\n\tvar ans = [];\n\tvar word = \"\";\n\tfor (var i = 0; i < searchWord.length; i++) {\n\t\tword += searchWord[i];\n\t\tvar tmp = [];\n\t\tfor (var j = 0; j < products.length; j++) {\n\t\t\tif (products[j].indexOf(word) == 0) {\n\t\t\t\ttmp.push(products[j]);\n\t\t\t}\n\t\t}\n\t\tans.push(tmp.slice(0, 3));\n\t}\n\treturn ans;\n};"}
{"id": "1172", "path": "output2\\js\\Medium\\1172-number-of-burgers-with-no-waste-of-ingredients.js", "hypo_code": "var numOfBurgers = function(tomatoSlices, cheeseSlices) {\n    var ans = [];\n\tvar jumbo = (tomatoSlices - 2 * cheeseSlices) / 2;\n\tvar small = cheeseSlices - jumbo;\n\tif (jumbo >= 0 && small >= 0 && jumbo == Math.floor(jumbo) && small == Math.floor(small)) {\n\t\tans = [jumbo, small];\n\t}\n\treturn ans;\n};"}
{"id": "1173", "path": "output2\\js\\Medium\\1173-count-square-submatrices-with-all-ones.js", "hypo_code": "var countSquares = function(matrix) {\n    var ans = 0;\n\tvar m = matrix.length;\n\tvar n = matrix[0].length;\n\tvar dp = Array(m).fill(0).map(() => Array(n).fill(0));\n\tfor (var i = 0; i < m; i++) {\n\t\tdp[i][0] = matrix[i][0];\n\t\tans += dp[i][0];\n\t}\n\tfor (var j = 1; j < n; j++) {\n\t\tdp[0][j] = matrix[0][j];\n\t\tans += dp[0][j];\n\t}\n\tfor (var i = 1; i < m; i++) {\n\t\tfor (var j = 1; j < n; j++) {\n\t\t\tif (matrix[i][j] == 1) {\n\t\t\t\tdp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + matrix[i][j];\n\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1174", "path": "output2\\js\\Medium\\1174-group-the-people-given-the-group-size-they-belong-to.js", "hypo_code": "var groupThePeople = function(groupSizes) {\n    var map = {};\n\tvar ans = [];\n\tfor (var i = 0; i < groupSizes.length; i++) {\n\t\tif (map[groupSizes[i]] == undefined) {\n\t\t\tmap[groupSizes[i]] = [];\n\t\t}\n\t\tmap[groupSizes[i]].push(i);\n\t\tif (map[groupSizes[i]].length == groupSizes[i]) {\n\t\t\tans.push(map[groupSizes[i]]);\n\t\t\tmap[groupSizes[i]] = [];\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1175", "path": "output2\\js\\Medium\\1175-find-the-smallest-divisor-given-a-threshold.js", "hypo_code": "var smallestDivisor = function(nums, threshold) {\n    var l = 1;\n\tvar r = 1000000;\n\twhile (l < r) {\n\t\tvar mid = l + Math.floor((r - l) / 2);\n\t\tvar sum = 0;\n\t\tfor (var i = 0; i < nums.length; i++) {\n\t\t\tsum += Math.ceil(nums[i] / mid);\n\t\t}\n\t\tif (sum > threshold) {\n\t\t\tl = mid + 1;\n\t\t} else {\n\t\t\tr = mid;\n\t\t}\n\t}\n\treturn l;\n};"}
{"id": "1177", "path": "output2\\js\\Medium\\1177-remove-covered-intervals.js", "hypo_code": "var removeCoveredIntervals = function(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    let result = 0;\n    let max = 0;\n    for(let i = 0; i < intervals.length; i++){\n        if(intervals[i][1] > max){\n            result++;\n            max = intervals[i][1];\n        }\n    }\n    return result;\n    \n};"}
{"id": "1178", "path": "output2\\js\\Medium\\1178-sequential-digits.js", "hypo_code": "var sequentialDigits = function(low, high) {\n    let result = [];\n    let queue = [];\n    for(let i = 1; i <= 9; i++){\n        queue.push(i);\n    }\n    while(queue.length > 0){\n        let num = queue.shift();\n        if(num >= low && num <= high){\n            result.push(num);\n        }\n        if(num > high){\n            break;\n        }\n        let lastDigit = num % 10;\n        if(lastDigit < 9){\n            let nextNum = num * 10 + lastDigit + 1;\n            queue.push(nextNum);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1179", "path": "output2\\js\\Medium\\1179-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold.js", "hypo_code": "var maxSideLength = function(mat, threshold) {\n    let n = mat.length;\n    let m = mat[0].length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(m + 1).fill(0);\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mat[i - 1][j - 1];\n        }\n    }\n    let result = 0;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            let l = 0;\n            let r = Math.min(i, j);\n            while(l <= r){\n                let mid = Math.floor((l + r) / 2);\n                let sum = dp[i][j] - dp[i - mid][j] - dp[i][j - mid] + dp[i - mid][j - mid];\n                if(sum <= threshold){\n                    result = Math.max(result, mid);\n                    l = mid + 1;\n                }else{\n                    r = mid - 1;\n                }\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1180", "path": "output2\\js\\Medium\\1180-divide-array-in-sets-of-k-consecutive-numbers.js", "hypo_code": "var maxSideLength = function(mat, threshold) {\n    let n = mat.length;\n    let m = mat[0].length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(m + 1).fill(0);\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mat[i - 1][j - 1];\n        }\n    }\n    let result = 0;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            let l = 0;\n            let r = Math.min(i, j);\n            while(l <= r){\n                let mid = Math.floor((l + r) / 2);\n                let sum = dp[i][j] - dp[i - mid][j] - dp[i][j - mid] + dp[i - mid][j - mid];\n                if(sum <= threshold){\n                    result = Math.max(result, mid);\n                    l = mid + 1;\n                }else{\n                    r = mid - 1;\n                }\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1181", "path": "output2\\js\\Medium\\1181-maximum-number-of-occurrences-of-a-substring.js", "hypo_code": "var maxFreq = function(s, maxLetters, minSize, maxSize) {\n    let result = 0;\n    let map = new Map();\n    for(let i = 0; i < s.length - minSize + 1; i++){\n        let str = s.substring(i, i + minSize);\n        if(str.length == new Set(str).size && str.length <= maxLetters){\n            if(map.has(str)){\n                map.set(str, map.get(str) + 1);\n            }else{\n                map.set(str, 1);\n            }\n            result = Math.max(result, map.get(str));\n        }\n    }\n    return result;\n    \n};"}
{"id": "1182", "path": "output2\\js\\Medium\\1182-sum-of-mutated-array-closest-to-target.js", "hypo_code": "var findBestValue = function(arr, target) {\n    let n = arr.length;\n    let l = 0;\n    let r = 0;\n    for(let i = 0; i < n; i++){\n        r = Math.max(r, arr[i]);\n    }\n    while(l <= r){\n        let mid = Math.floor((l + r) / 2);\n        let sum = 0;\n        for(let i = 0; i < n; i++){\n            sum += Math.min(arr[i], mid);\n        }\n        if(sum < target){\n            l = mid + 1;\n        }else{\n            r = mid - 1;\n        }\n    }\n    let sum1 = 0;\n    let sum2 = 0;\n    for(let i = 0; i < n; i++){\n        sum1 += Math.min(arr[i], l);\n        sum2 += Math.min(arr[i], l - 1);\n    }\n    return Math.abs(sum1 - target) <= Math.abs(sum2 - target) ? l : l - 1;\n    \n};"}
{"id": "1183", "path": "output2\\js\\Medium\\1183-deepest-leaves-sum.js", "hypo_code": "var deepestLeavesSum = function(root) {\n    let maxDepth = 0;\n    let sum = 0;\n    let dfs = function(node, depth){\n        if(node == null){\n            return;\n        }\n        if(node.left == null && node.right == null){\n            if(depth > maxDepth){\n                maxDepth = depth;\n                sum = node.val;\n            }else if(depth == maxDepth){\n                sum += node.val;\n            }\n        }\n        dfs(node.left, depth + 1);\n        dfs(node.right, depth + 1);\n    }\n    dfs(root, 0);\n    return sum;\n    \n};"}
{"id": "1184", "path": "output2\\js\\Medium\\1184-all-elements-in-two-binary-search-trees.js", "hypo_code": "var getAllElements = function(root1, root2) {\n    let result = [];\n    let dfs = function(node){\n        if(node == null){\n            return;\n        }\n        result.push(node.val);\n        dfs(node.left);\n        dfs(node.right);\n    }\n    dfs(root1);\n    dfs(root2);\n    result.sort((a, b) => a - b);\n    return result;\n    \n};"}
{"id": "1185", "path": "output2\\js\\Medium\\1185-jump-game-iii.js", "hypo_code": "var canReach = function(arr, start) {\n    let n = arr.length;\n    let visited = new Array(n).fill(false);\n    let queue = [start];\n    while(queue.length > 0){\n        let i = queue.shift();\n        if(arr[i] == 0){\n            return true;\n        }\n        if(!visited[i]){\n            visited[i] = true;\n            if(i + arr[i] < n){\n                queue.push(i + arr[i]);\n            }\n            if(i - arr[i] >= 0){\n                queue.push(i - arr[i]);\n            }\n        }\n    }\n    return false;\n    \n};"}
{"id": "1186", "path": "output2\\js\\Medium\\1186-xor-queries-of-a-subarray.js", "hypo_code": "var xorQueries = function(arr, queries) {\n    var ans = [];\n\tvar prefix = [0];\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tprefix[i + 1] = prefix[i] ^ arr[i];\n\t}\n\tfor (var i = 0; i < queries.length; i++) {\n\t\tans[i] = prefix[queries[i][0]] ^ prefix[queries[i][1] + 1];\n\t}\n\treturn ans;\n};"}
{"id": "1187", "path": "output2\\js\\Medium\\1187-get-watched-videos-by-your-friends.js", "hypo_code": "var watchedVideosByFriends = function(watchedVideos, friends, id, level) {\n    var n = friends.length;\n\tvar queue = [];\n\tvar visited = Array(n).fill(false);\n\tqueue.push(id);\n\tvisited[id] = true;\n\tvar count = 0;\n\twhile (queue.length > 0) {\n\t\tvar size = queue.length;\n\t\tfor (var i = 0; i < size; i++) {\n\t\t\tvar cur = queue.shift();\n\t\t\tfor (var j = 0; j < friends[cur].length; j++) {\n\t\t\t\tif (!visited[friends[cur][j]]) {\n\t\t\t\t\tqueue.push(friends[cur][j]);\n\t\t\t\t\tvisited[friends[cur][j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount++;\n\t\tif (count == level) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tvar map = {};\n\twhile (queue.length > 0) {\n\t\tvar cur = queue.shift();\n\t\tfor (var i = 0; i < watchedVideos[cur].length; i++) {\n\t\t\tif (map[watchedVideos[cur][i]] == null) {\n\t\t\t\tmap[watchedVideos[cur][i]] = 1;\n\t\t\t} else {\n\t\t\t\tmap[watchedVideos[cur][i]]++;\n\t\t\t}\n\t\t}\n\t}\n\tvar res = [];\n\tfor (var key in map) {\n\t\tres.push(key);\n\t}\n\tres.sort((a, b) => {\n\t\tif (map[a] == map[b]) {\n\t\t\treturn a.localeCompare(b);\n\t\t} else {\n\t\t\treturn map[a] - map[b];\n\t\t}\n\t});\n\treturn res;\n};"}
{"id": "1188", "path": "output2\\js\\Medium\\1188-matrix-block-sum.js", "hypo_code": "var matrixBlockSum = function(mat, k) {\n    var m = mat.length;\n\tvar n = mat[0].length;\n\tvar ans = Array(m).fill(0).map(() => Array(n).fill(0));\n\tvar dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));\n\tfor (var i = 1; i <= m; i++) {\n\t\tfor (var j = 1; j <= n; j++) {\n\t\t\tdp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n\t\t}\n\t}\n\tfor (var i = 1; i <= m; i++) {\n\t\tfor (var j = 1; j <= n; j++) {\n\t\t\tvar r1 = Math.max(1, i - k);\n\t\t\tvar c1 = Math.max(1, j - k);\n\t\t\tvar r2 = Math.min(m, i + k);\n\t\t\tvar c2 = Math.min(n, j + k);\n\t\t\tans[i - 1][j - 1] = dp[r2][c2] - dp[r2][c1 - 1] - dp[r1 - 1][c2] + dp[r1 - 1][c1 - 1];\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1189", "path": "output2\\js\\Medium\\1189-sum-of-nodes-with-even-valued-grandparent.js", "hypo_code": "var sumEvenGrandparent = function(root) {\n    var ans = 0;\n\tvar dfs = function(node, parent, grandparent) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (grandparent != null && grandparent.val % 2 == 0) {\n\t\t\tans += node.val;\n\t\t}\n\t\tdfs(node.left, node, parent);\n\t\tdfs(node.right, node, parent);\n\t};\n\tdfs(root, null, null);\n\treturn ans;\n};"}
{"id": "1190", "path": "output2\\js\\Medium\\1190-minimum-flips-to-make-a-or-b-equal-to-c.js", "hypo_code": "var minFlips = function(a, b, c) {\n    var ans = 0;\n\twhile (a > 0 || b > 0 || c > 0) {\n\t\tvar a0 = a & 1;\n\t\tvar b0 = b & 1;\n\t\tvar c0 = c & 1;\n\t\tif (c0 == 0) {\n\t\t\tans += a0 + b0;\n\t\t} else {\n\t\t\tans += a0 + b0 == 0 ? 1 : 0;\n\t\t}\n\t\ta >>= 1;\n\t\tb >>= 1;\n\t\tc >>= 1;\n\t}\n\treturn ans;\n};"}
{"id": "1191", "path": "output2\\js\\Medium\\1191-number-of-operations-to-make-network-connected.js", "hypo_code": "var makeConnected = function(n, connections) {\n    var parent = Array(n).fill(0).map((value, index) => index);\n\tvar count = 0;\n\tvar ans = 0;\n\tfor (var i = 0; i < connections.length; i++) {\n\t\tvar x = find(parent, connections[i][0]);\n\t\tvar y = find(parent, connections[i][1]);\n\t\tif (x != y) {\n\t\t\tparent[x] = y;\n\t\t} else {\n\t\t\tans++;\n\t\t}\n\t}\n\tfor (var i = 0; i < n; i++) {\n\t\tif (parent[i] == i) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn ans >= count - 1 ? count - 1 : -1;\n};\nvar find = function(parent, x) {\n\tif (parent[x] != x) {\n\t\tparent[x] = find(parent, parent[x]);\n\t}\n\treturn parent[x];\n};"}
{"id": "1193", "path": "output2\\js\\Medium\\1193-print-words-vertically.js", "hypo_code": "var printVertically = function(s) {\n    let words = s.split(\" \");\n    let maxLen = 0;\n    for(let i = 0; i < words.length; i++){\n        maxLen = Math.max(maxLen, words[i].length);\n    }\n    let result = [];\n    for(let i = 0; i < maxLen; i++){\n        let str = \"\";\n        for(let j = 0; j < words.length; j++){\n            if(i < words[j].length){\n                str += words[j][i];\n            }else{\n                str += \" \";\n            }\n        }\n        result.push(str);\n    }\n    for(let i = 0; i < result.length; i++){\n        result[i] = result[i].trimEnd();\n    }\n    return result;\n    \n};"}
{"id": "1194", "path": "output2\\js\\Medium\\1194-delete-leaves-with-a-given-value.js", "hypo_code": "var removeLeafNodes = function(root, target) {\n    let dfs = function(node){\n        if(node == null){\n            return null;\n        }\n        node.left = dfs(node.left);\n        node.right = dfs(node.right);\n        if(node.left == null && node.right == null && node.val == target){\n            return null;\n        }\n        return node;\n    }\n    return dfs(root);\n    \n};"}
{"id": "1195", "path": "output2\\js\\Medium\\1195-break-a-palindrome.js", "hypo_code": "var breakPalindrome = function(palindrome) {\n    let n = palindrome.length;\n    if(n == 1){\n        return \"\";\n    }\n    let result = palindrome.split(\"\");\n    for(let i = 0; i < n / 2; i++){\n        if(palindrome[i] != 'a'){\n            result[i] = 'a';\n            return result.join(\"\");\n        }\n    }\n    result[n - 1] = 'b';\n    return result.join(\"\");\n    \n};"}
{"id": "1196", "path": "output2\\js\\Medium\\1196-sort-the-matrix-diagonally.js", "hypo_code": "var diagonalSort = function(mat) {\n    let n = mat.length;\n    let m = mat[0].length;\n    let result = new Array(n);\n    for(let i = 0; i < n; i++){\n        result[i] = new Array(m).fill(0);\n    }\n    for(let i = 0; i < n; i++){\n        let x = i;\n        let y = 0;\n        let temp = [];\n        while(x < n && y < m){\n            temp.push(mat[x][y]);\n            x++;\n            y++;\n        }\n        temp.sort((a, b) => a - b);\n        x = i;\n        y = 0;\n        while(x < n && y < m){\n            result[x][y] = temp.shift();\n            x++;\n            y++;\n        }\n    }\n    for(let i = 1; i < m; i++){\n        let x = 0;\n        let y = i;\n        let temp = [];\n        while(x < n && y < m){\n            temp.push(mat[x][y]);\n            x++;\n            y++;\n        }\n        temp.sort((a, b) => a - b);\n        x = 0;\n        y = i;\n        while(x < n && y < m){\n            result[x][y] = temp.shift();\n            x++;\n            y++;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1197", "path": "output2\\js\\Medium\\1197-filter-restaurants-by-vegan-friendly-price-and-distance.js", "hypo_code": "var filterRestaurants = function(restaurants, veganFriendly, maxPrice, maxDistance) {\n    let result = [];\n    for(let i = 0; i < restaurants.length; i++){\n        if(veganFriendly == 1 && restaurants[i][2] == 0){\n            continue;\n        }\n        if(restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance){\n            result.push(restaurants[i]);\n        }\n    }\n    result.sort((a, b) => {\n        if(a[1] == b[1]){\n            return b[0] - a[0];\n        }\n        return b[1] - a[1];\n    });\n    let finalResult = [];\n    for(let i = 0; i < result.length; i++){\n        finalResult.push(result[i][0]);\n    }\n    return finalResult;\n    \n};"}
{"id": "1198", "path": "output2\\js\\Medium\\1198-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance.js", "hypo_code": "var findTheCity = function(n, edges, distanceThreshold) {\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n).fill(Infinity);\n        dp[i][i] = 0;\n    }\n    for(let i = 0; i < edges.length; i++){\n        let from = edges[i][0];\n        let to = edges[i][1];\n        let weight = edges[i][2];\n        dp[from][to] = weight;\n        dp[to][from] = weight;\n    }\n    for(let k = 0; k < n; k++){\n        for(let i = 0; i < n; i++){\n            for(let j = 0; j < n; j++){\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);\n            }\n        }\n    }\n    let result = Infinity;\n    let resultIndex = -1;\n    for(let i = 0; i < n; i++){\n        let count = 0;\n        for(let j = 0; j < n; j++){\n            if(dp[i][j] <= distanceThreshold){\n                count++;\n            }\n        }\n        if(count <= result){\n            result = count;\n            resultIndex = i;\n        }\n    }\n    return resultIndex;\n    \n};"}
{"id": "1199", "path": "output2\\js\\Medium\\1199-reduce-array-size-to-the-half.js", "hypo_code": "var minSetSize = function(arr) {\n    let map = new Map();\n    for(let i = 0; i < arr.length; i++){\n        if(map.has(arr[i])){\n            map.set(arr[i], map.get(arr[i]) + 1);\n        }else{\n            map.set(arr[i], 1);\n        }\n    }\n    let values = Array.from(map.values());\n    values.sort((a, b) => b - a);\n    let result = 0;\n    let sum = 0;\n    for(let i = 0; i < values.length; i++){\n        sum += values[i];\n        result++;\n        if(sum >= arr.length / 2){\n            break;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1200", "path": "output2\\js\\Medium\\1200-maximum-product-of-splitted-binary-tree.js", "hypo_code": "var maxProduct = function(root) {\n    let total = 0;\n    let dfs = function(node){\n        if(node == null){\n            return 0;\n        }\n        let left = dfs(node.left);\n        let right = dfs(node.right);\n        total += node.val;\n        return left + right + node.val;\n    }\n    let max = 0;\n    let sum = dfs(root);\n    dfs = function(node){\n        if(node == null){\n            return 0;\n        }\n        let left = dfs(node.left);\n        let right = dfs(node.right);\n        let current = left + right + node.val;\n        let other = sum - current;\n        let product = current * other;\n        if(product > max){\n            max = product;\n        }\n        return current;\n    }\n    dfs(root);\n    return max % (10 ** 9 + 7);\n    \n};"}
{"id": "1202", "path": "output2\\js\\Medium\\1202-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold.js", "hypo_code": "var numOfSubarrays = function(arr, k, threshold) {\n    var ans = 0;\n\tvar sum = 0;\n\tfor (var i = 0; i < k; i++) {\n\t\tsum += arr[i];\n\t}\n\tif (sum / k >= threshold) {\n\t\tans++;\n\t}\n\tfor (var i = k; i < arr.length; i++) {\n\t\tsum += arr[i] - arr[i - k];\n\t\tif (sum / k >= threshold) {\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1203", "path": "output2\\js\\Medium\\1203-angle-between-hands-of-a-clock.js", "hypo_code": "var angleClock = function(hour, minutes) {\n    var h = (hour % 12) * 30 + minutes / 2;\n\tvar m = minutes * 6;\n\tvar ans = Math.abs(h - m);\n\treturn Math.min(ans, 360 - ans);\n};"}
{"id": "1204", "path": "output2\\js\\Medium\\1204-minimum-number-of-steps-to-make-two-strings-anagram.js", "hypo_code": "var minSteps = function(s, t) {\n    var map = {};\n\tvar ans = 0;\n\tfor (var i = 0; i < s.length; i++) {\n\t\tif (map[s[i]] == null) {\n\t\t\tmap[s[i]] = 0;\n\t\t}\n\t\tmap[s[i]]++;\n\t}\n\tfor (var i = 0; i < t.length; i++) {\n\t\tif (map[t[i]] > 0) {\n\t\t\tmap[t[i]]--;\n\t\t} else {\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n};"}
{"id": "1207", "path": "output2\\js\\Medium\\1207-maximum-number-of-events-that-can-be-attended.js", "hypo_code": "var maxEvents = function(events) {  \n    events.sort((a,b) => a[1] - b[1]);\n    let max = 0;\n    let day = 0;\n    let i = 0;\n    while (events.length > 0) {\n        if (events[i][0] <= day) {\n            day++;\n            events.splice(i, 1);\n            i = 0;\n        } else {\n            if (i === events.length - 1) {\n                day++;\n                events.splice(i, 1);\n                i = 0;\n            } else {\n                i++;\n            }\n        }\n    }\n    return day;\n};"}
{"id": "1209", "path": "output2\\js\\Medium\\1209-number-of-substrings-containing-all-three-characters.js", "hypo_code": "var numberOfSubstrings = function(s) {\n    let result = 0;\n    let left = 0;\n    let right = 0;\n    let map = new Map();\n    while(right < s.length){\n        if(map.has(s[right])){\n            map.set(s[right], map.get(s[right]) + 1);\n        }else{\n            map.set(s[right], 1);\n        }\n        while(map.size == 3){\n            result += s.length - right;\n            if(map.get(s[left]) == 1){\n                map.delete(s[left]);\n            }else{\n                map.set(s[left], map.get(s[left]) - 1);\n            }\n            left++;\n        }\n        right++;\n    }\n    return result;\n    \n};"}
{"id": "1210", "path": "output2\\js\\Medium\\1210-validate-binary-tree-nodes.js", "hypo_code": "var validateBinaryTreeNodes = function(n, leftChild, rightChild) {\n    let indegree = new Array(n).fill(0);\n    let outdegree = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        if(leftChild[i] != -1){\n            indegree[leftChild[i]]++;\n            outdegree[i]++;\n        }\n        if(rightChild[i] != -1){\n            indegree[rightChild[i]]++;\n            outdegree[i]++;\n        }\n    }\n    let root = -1;\n    for(let i = 0; i < n; i++){\n        if(indegree[i] == 0){\n            if(root != -1){\n                return false;\n            }\n            root = i;\n        }\n        if(outdegree[i] > 2){\n            return false;\n        }\n    }\n    if(root == -1){\n        return false;\n    }\n    return true;\n    \n};"}
{"id": "1211", "path": "output2\\js\\Medium\\1211-closest-divisors.js", "hypo_code": "var closestDivisors = function(num) {\n    let result1 = findDivisors(num + 1);\n    let result2 = findDivisors(num + 2);\n    if(Math.abs(result1[0] - result1[1]) < Math.abs(result2[0] - result2[1])){\n        return result1;\n    }else{\n        return result2;\n    }\n    \n    \n};"}
{"id": "1212", "path": "output2\\js\\Medium\\1212-rank-teams-by-votes.js", "hypo_code": "var rankTeams = function(votes) {    \n    const memo = {};\n    const teams = votes[0].split('');\n    for (let i = 0; i < votes[0].length; i++) {\n        memo[teams[i]] = new Array(votes[0].length).fill(0);\n        for (let j = 0; j < votes.length; j++) {\n            memo[teams[i]][j] = votes[j][i];\n        }\n    }\n    const sorted = Object.entries(memo).sort((a,b) => {\n        for (let i = 0; i < a[1].length; i++) {\n            if (a[1][i] !== b[1][i]) {\n                return b[1][i] < a[1][i] ? -1 : 1;\n            }\n        }\n        return a[0] < b[0] ? -1 : 1;\n    });\n    let result = '';\n    for (let i = 0; i < sorted.length; i++) {\n        result += sorted[i][0];\n    }\n    return result;\n};"}
{"id": "1213", "path": "output2\\js\\Medium\\1213-linked-list-in-binary-tree.js", "hypo_code": "var isSubPath = function(head, root) {\n    let dfs = function(node, head){\n        if(head == null){\n            return true;\n        }\n        if(node == null){\n            return false;\n        }\n        if(node.val != head.val){\n            return false;\n        }\n        return dfs(node.left, head.next) || dfs(node.right, head.next);\n    }\n    let dfs2 = function(node){\n        if(node == null){\n            return false;\n        }\n        if(node.val == head.val){\n            if(dfs(node, head)){\n                return true;\n            }\n        }\n        return dfs2(node.left) || dfs2(node.right);\n    }\n    return dfs2(root);\n    \n};"}
{"id": "1214", "path": "output2\\js\\Medium\\1214-find-the-longest-substring-containing-vowels-in-even-counts.js", "hypo_code": "var findTheLongestSubstring = function(s) {\n    let result = 0;\n    let left = 0;\n    let right = 0;\n    let map = new Map();\n    map.set(\"a\", 0);\n    map.set(\"e\", 0);\n    map.set(\"i\", 0);\n    map.set(\"o\", 0);\n    map.set(\"u\", 0);\n    while(right < s.length){\n        if(map.has(s[right])){\n            map.set(s[right], map.get(s[right]) + 1);\n        }\n        while(isValid(map)){\n            result = Math.max(result, right - left + 1);\n            if(map.has(s[left])){\n                map.set(s[left], map.get(s[left]) - 1);\n            }\n            left++;\n        }\n        right++;\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "1215", "path": "output2\\js\\Medium\\1215-longest-zigzag-path-in-a-binary-tree.js", "hypo_code": "var longestZigZag = function(root) {\n    let dfs = function(node, isLeft){\n        if(node == null){\n            return 0;\n        }\n        let left = dfs(node.left, true);\n        let right = dfs(node.right, false);\n        let max = Math.max(left, right);\n        if(isLeft){\n            max = Math.max(max, right + 1);\n        }else{\n            max = Math.max(max, left + 1);\n        }\n        return max;\n    }\n    return dfs(root, true);\n    \n};"}
{"id": "1216", "path": "output2\\js\\Medium\\1216-number-of-times-binary-string-is-prefix-aligned.js", "hypo_code": "var numTimesAllBlue = function(flips) {\n    let max = 0;\n    let count = 0;\n    for (let i = 0; i < flips.length; i++) {\n        max = Math.max(max, flips[i]);\n        if (max === i + 1) {\n            count++;\n        }\n    }\n    return count;\n    \n};"}
{"id": "1217", "path": "output2\\js\\Medium\\1217-time-needed-to-inform-all-employees.js", "hypo_code": "var numOfMinutes = function(n, headID, manager, informTime) {\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        let time = informTime[i];\n        let j = i;\n        while (manager[j] !== -1) {\n            time += informTime[manager[j]];\n            j = manager[j];\n        }\n        max = Math.max(max, time);\n    }\n    return max;\n    \n};"}
{"id": "1219", "path": "output2\\js\\Medium\\1219-balance-a-binary-search-tree.js", "hypo_code": "var balanceBST = function(root) {\n    let arr = [];\n    let stack = [];\n    let node = root;\n    while (node || stack.length) {\n        while (node) {\n            stack.push(node);\n            node = node.left;\n        }\n        node = stack.pop();\n        arr.push(node.val);\n        node = node.right;\n    }\n    return buildTree(arr, 0, arr.length - 1);\n    \n};"}
{"id": "1220", "path": "output2\\js\\Medium\\1220-cinema-seat-allocation.js", "hypo_code": "var maxNumberOfFamilies = function(n, reservedSeats) {\n    let count = 0;\n    let map = new Map();\n    for (let i = 0; i < reservedSeats.length; i++) {\n        let row = reservedSeats[i][0];\n        let col = reservedSeats[i][1];\n        if (!map.has(row)) {\n            map.set(row, new Set());\n        }\n        map.get(row).add(col);\n    }\n    for (let i = 1; i <= n; i++) {\n        let set = map.get(i);\n        if (set === undefined) {\n            count += 2;\n        } else {\n            if (!set.has(2) && !set.has(3) && !set.has(4) && !set.has(5)) {\n                count++;\n            }\n            if (!set.has(6) && !set.has(7) && !set.has(8) && !set.has(9)) {\n                count++;\n            }\n            if (!set.has(4) && !set.has(5) && !set.has(6) && !set.has(7)) {\n                count++;\n            }\n        }\n    }\n    return count;\n    \n};"}
{"id": "1221", "path": "output2\\js\\Medium\\1221-sort-integers-by-the-power-value.js", "hypo_code": "var getKth = function(lo, hi, k) {\n    let map = new Map();\n    for (let i = lo; i <= hi; i++) {\n        let count = 0;\n        let j = i;\n        while (j !== 1) {\n            if (j % 2 === 0) {\n                j /= 2;\n            } else {\n                j = 3 * j + 1;\n            }\n            count++;\n        }\n        map.set(i, count);\n    }\n    let arr = [];\n    for (let i = lo; i <= hi; i++) {\n        arr.push(i);\n    }\n    arr.sort((a, b) => {\n        if (map.get(a) === map.get(b)) {\n            return a - b;\n        } else {\n            return map.get(a) - map.get(b);\n        }\n    });\n    return arr[k - 1];\n    \n};"}
{"id": "1222", "path": "output2\\js\\Medium\\1222-four-divisors.js", "hypo_code": "var sumFourDivisors = function(nums) {\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let count = 0;\n        let divisors = [];\n        for (let j = 1; j <= Math.sqrt(nums[i]); j++) {\n            if (nums[i] % j === 0) {\n                if (nums[i] / j === j) {\n                    count++;\n                    divisors.push(j);\n                } else {\n                    count += 2;\n                    divisors.push(j);\n                    divisors.push(nums[i] / j);\n                }\n            }\n        }\n        if (count === 4) {\n            sum += divisors.reduce((a, b) => a + b);\n        }\n    }\n    return sum;\n    \n};"}
{"id": "1223", "path": "output2\\js\\Medium\\1223-check-if-there-is-a-valid-path-in-a-grid.js", "hypo_code": "var hasValidPath = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    let queue = [[0, 0]];\n    visited[0][0] = true;\n    while (queue.length > 0) {\n        let [i, j] = queue.shift();\n        if (i === m - 1 && j === n - 1) {\n            return true;\n        }\n        let street = grid[i][j];\n        if (street === 1) {\n            if (j + 1 < n && !visited[i][j + 1] && (grid[i][j + 1] === 1 || grid[i][j + 1] === 4 || grid[i][j + 1] === 6)) {\n                queue.push([i, j + 1]);\n                visited[i][j + 1] = true;\n            }\n            if (j - 1 >= 0 && !visited[i][j - 1] && (grid[i][j - 1] === 1 || grid[i][j - 1] === 3 || grid[i][j - 1] === 5)) {\n                queue.push([i, j - 1]);\n                visited[i][j - 1] = true;\n            }\n        } else if (street === 2) {\n            if (i + 1 < m && !visited[i + 1][j] && (grid[i + 1][j] === 2 || grid[i + 1][j] === 3 || grid[i + 1][j] === 4)) {\n                queue.push([i + 1, j]);\n                visited[i + 1][j] = true;\n            }\n            if (i - 1 >= 0 && !visited[i - 1][j] && (grid[i - 1][j] === 2 || grid[i - 1][j] === 5 || grid[i - 1][j] === 6)) {\n                queue.push([i - 1, j]);\n                visited[i - 1][j] = true;\n            }\n        } else if (street === 3) {\n            if (j + 1 < n && !visited[i][j + 1] && ( grid[i][j + 1] === 1 || grid[i][j + 1] === 4 || grid[i][j + 1] === 6)) {\n                queue.push([i, j + 1]);\n                visited[i][j + 1] = true;\n            }\n            if (i + 1 < m && !visited[i + 1][j] && (grid[i + 1][j] === 2 || grid[i + 1][j] === 3 || grid[i + 1][j] === 4)) {\n                queue.push([i + 1, j]);\n                visited[i + 1][j] = true;\n            }\n        } else if (street === 4) {\n            if (j - 1 >= 0 && !visited[i][j - 1] && (grid[i][j - 1] === 1 || grid[i][j - 1] === 3 || grid[i][j - 1] === 5)) {\n                queue.push([i, j - 1]);\n                visited[i][j - 1] = true;\n            }\n            if (i + 1 < m && !visited[i + 1][j] && (grid[i + 1][j] === 2 || grid[i + 1][j] === 3 || grid[i + 1][j] === 4)) {\n                queue.push([i + 1, j]);\n                visited[i + 1][j] = true;\n            }\n        } else if (street === 5) { \n            if (j + 1 < n && !visited[i][j + 1] && (grid[i][j + 1] === 1 || grid[i][j + 1] === 4 || grid[i][j + 1] === 6)) {\n                queue.push([i, j + 1]);\n                visited[i][j + 1] = true;\n            }\n            if (i - 1 >= 0 && !visited[i - 1][j] && (grid[i - 1][j] === 2 || grid[i - 1][j] === 5 || grid[i - 1][j] === 6)) {\n                queue.push([i - 1, j]);\n                visited[i - 1][j] = true;\n            }\n        } else if (street === 6) {\n            if (j - 1 >= 0 && !visited[i][j - 1] && (grid[i][j - 1] === 1 || grid[i][j - 1] === 3 || grid[i][j - 1] === 5)) {\n                queue.push([i, j - 1]);\n                visited[i][j - 1] = true;\n            }\n            if (i - 1 >= 0 && !visited[i - 1][j] && (grid[i - 1][j] === 2 || grid[i - 1][j] === 5 || grid[i - 1][j] === 6)) {\n                queue.push([i - 1, j]);\n                visited[i - 1][j] = true;\n            }\n        }\n\n    }\n    \n};"}
{"id": "1225", "path": "output2\\js\\Medium\\1225-count-number-of-teams.js", "hypo_code": "var numTeams = function(rating) {\n    let count = 0;\n    for (let i = 0; i < rating.length - 2; i++) {\n        for (let j = i + 1; j < rating.length - 1; j++) {\n            for (let k = j + 1; k < rating.length; k++) {\n                if ((rating[i] < rating[j] && rating[j] < rating[k]) || (rating[i] > rating[j] && rating[j] > rating[k])) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n    \n};"}
{"id": "1227", "path": "output2\\js\\Medium\\1227-construct-k-palindrome-strings.js", "hypo_code": "var canConstruct = function(s, k) {\n    if (k > s.length) {\n        return false;\n    }\n    let map = {};\n    for (let i = 0; i < s.length; i++) {\n        if (map[s[i]]) {\n            map[s[i]]++;\n        } else {\n            map[s[i]] = 1;\n        }\n    }\n    let odd = 0;\n    for (let key in map) {\n        if (map[key] % 2 !== 0) {\n            odd++;\n        }\n    }\n    return odd <= k;\n    \n};"}
{"id": "1228", "path": "output2\\js\\Medium\\1228-circle-and-rectangle-overlapping.js", "hypo_code": "var checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\n    let x = Math.max(x1, Math.min(xCenter, x2));\n    let y = Math.max(y1, Math.min(yCenter, y2));\n    return Math.pow(x - xCenter, 2) + Math.pow(y - yCenter, 2) <= Math.pow(radius, 2);\n    \n};"}
{"id": "1229", "path": "output2\\js\\Medium\\1229-number-of-steps-to-reduce-a-number-in-binary-representation-to-one.js", "hypo_code": "var numSteps = function(s) {\n    let count = 0;\n    let i = s.length - 1;\n    while (i > 0) {\n        if (s[i] === '0') {\n            s = s.substring(0, i);\n        } else {\n            let j = i;\n            while (j >= 0 && s[j] === '1') {\n                s = s.substring(0, j) + '0' + s.substring(j + 1);\n                j--;\n            }\n            if (j < 0) {\n                s = '1' + s;\n            } else {\n                s = s.substring(0, j) + '1' + s.substring(j + 1);\n            }\n        }\n        count++;\n        i = s.length - 1;\n    }\n    return count;\n    \n};"}
{"id": "1230", "path": "output2\\js\\Medium\\1230-longest-happy-string.js", "hypo_code": "var longestDiverseString = function(a, b, c) {\n    let result = '';\n    let map = {};\n    map['a'] = a;\n    map['b'] = b;\n    map['c'] = c;\n    let prev = '';\n    while (true) {\n        let max = 0;\n        let maxKey = '';\n        for (let key in map) {\n            if (map[key] > max && key !== prev) {\n                max = map[key];\n                maxKey = key;\n            }\n        }\n        if (max === 0) {\n            break;\n        }\n        if (max >= 2) {\n            result += maxKey + maxKey;\n            map[maxKey] -= 2;\n        } else {\n            result += maxKey;\n            map[maxKey]--;\n        }\n        prev = maxKey;\n    }\n    return result;\n    \n};"}
{"id": "1231", "path": "output2\\js\\Medium\\1231-queries-on-a-permutation-with-key.js", "hypo_code": "var processQueries = function(queries, m) {\n    let p = [];\n    for (let i = 1; i <= m; i++) {\n        p.push(i);\n    }\n    let result = [];\n    for (let i = 0; i < queries.length; i++) {\n        let index = p.indexOf(queries[i]);\n        result.push(index);\n        p.splice(index, 1);\n        p.unshift(queries[i]);\n    }\n    return result;\n    \n};"}
{"id": "1232", "path": "output2\\js\\Medium\\1232-html-entity-parser.js", "hypo_code": "var entityParser = function(text) {\n    let map = {};\n    map['&quot;'] = '\"';\n    map['&apos;'] = \"'\";\n    map['&amp;'] = '&';\n    map['&gt;'] = '>';\n    map['&lt;'] = '<';\n    map['&frasl;'] = '/';\n    for (let key in map) {\n        text = text.replace(new RegExp(key, 'g'), map[key]);\n    }\n    return text;\n    \n};"}
{"id": "1233", "path": "output2\\js\\Medium\\1233-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k.js", "hypo_code": "var findMinFibonacciNumbers = function(k) {\n    let fib = [1, 1];\n    let i = 2;\n    while (fib[i - 1] + fib[i - 2] <= k) {\n        fib.push(fib[i - 1] + fib[i - 2]);\n        i++;\n    }\n    let count = 0;\n    while (k > 0) {\n        let j = fib.length - 1;\n        while (j >= 0 && fib[j] > k) {\n            j--;\n        }\n        k -= fib[j];\n        count++;\n    }\n    return count;\n    \n};"}
{"id": "1234", "path": "output2\\js\\Medium\\1234-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n.js", "hypo_code": "var getHappyString = function(n, k) {\n    let arr = ['a', 'b', 'c'];\n    let res = [];\n    let count = 0;\n    let dfs = (str) => {\n        if (str.length === n) {\n            res.push(str);\n            count++;\n            return;\n        }\n        for (let i = 0; i < arr.length; i++) {\n            if (str.length === 0 || arr[i] !== str[str.length - 1]) {\n                dfs(str + arr[i]);\n            }\n        }\n    }\n    dfs('');\n    return res[k - 1] || '';\n    \n};"}
{"id": "1235", "path": "output2\\js\\Medium\\1235-display-table-of-food-orders-in-a-restaurant.js", "hypo_code": "var displayTable = function(orders) {\n    let map = {};\n    let food = new Set();\n    for (let i = 0; i < orders.length; i++) {\n        let table = orders[i][1];\n        let item = orders[i][2];\n        food.add(item);\n        if (map[table]) {\n            map[table].push(item);\n        } else {\n            map[table] = [item];\n        }\n    }\n    let res = [];\n    let header = ['Table'];\n    for (let item of food) {\n        header.push(item);\n    }\n    res.push(header);\n    let tables = Object.keys(map);\n    tables.sort((a, b) => a - b);\n    for (let i = 0; i < tables.length; i++) {\n        let table = tables[i];\n        let row = [table];\n        for (let j = 1; j < header.length; j++) {\n            let count = 0;\n            for (let k = 0; k < map[table].length; k++) {\n                if (map[table][k] === header[j]) {\n                    count++;\n                }\n            }\n            row.push(count.toString());\n        }\n        res.push(row);\n    }\n    return res;\n    \n};"}
{"id": "1236", "path": "output2\\js\\Medium\\1236-minimum-number-of-frogs-croaking.js", "hypo_code": "var minNumberOfFrogs = function(croakOfFrogs) {\n    let count = 0;\n    let c = 0;\n    let r = 0;\n    let o = 0;\n    let a = 0;\n    let k = 0;\n    for (let i = 0; i < croakOfFrogs.length; i++) {\n        if (croakOfFrogs[i] === 'c') {\n            c++;\n        } else if (croakOfFrogs[i] === 'r') {\n            r++;\n        } else if (croakOfFrogs[i] === 'o') {\n            o++;\n        } else if (croakOfFrogs[i] === 'a') {\n            a++;\n        } else if (croakOfFrogs[i] === 'k') {\n            k++;\n        }\n        if (c < r || r < o || o < a || a < k) {\n            return -1;\n        }\n        count = Math.max(count, c - k);\n    }\n    if (c !== k) {\n        return -1;\n    }\n    return count;\n    \n};"}
{"id": "1237", "path": "output2\\js\\Medium\\1237-maximum-points-you-can-obtain-from-cards.js", "hypo_code": "var maxScore = function(cardPoints, k) {\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += cardPoints[i];\n    }\n    let max = sum;\n    for (let i = 0; i < k; i++) {\n        sum -= cardPoints[k - 1 - i];\n        sum += cardPoints[cardPoints.length - 1 - i];\n        max = Math.max(max, sum);\n    }\n    return max;\n    \n};"}
{"id": "1238", "path": "output2\\js\\Medium\\1238-diagonal-traverse-ii.js", "hypo_code": "var findDiagonalOrder = function(nums) {\n    const memo = {};\n    const max = nums.length + nums[0].length - 1;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = 0; j < nums[i].length; j++) {            \n            if (!memo[i + j]) {\n                memo[i + j] = [];\n            }\n            memo[i + j].push(nums[i][j]);\n        }\n    }\n    const result = [];\n    for (let i = 0; i < max; i++) {\n        if (memo[i]) {\n            result.push(...memo[i].reverse());\n        }\n    }\n    return result;\n};"}
{"id": "1239", "path": "output2\\js\\Medium\\1239-max-difference-you-can-get-from-changing-an-integer.js", "hypo_code": "var maxDiff = function(num) {\n    let max = 0;\n    let min = 0;\n    let numArr = num.toString().split('');\n    if (numArr[0] === '1') {\n        let i = 1;\n        while (numArr[i] === '1' || numArr[i] === '0') {\n            i++;\n        }\n        max = parseInt(numArr.join('').replace(new RegExp(numArr[i], 'g'), '9'));\n    } else {\n        max = parseInt(numArr.join('').replace(new RegExp(numArr[0], 'g'), '9'));\n    }\n    if (numArr[0] === '9') {\n        let i = 1;\n        while (numArr[i] === '9') {\n            i++;\n        }\n        min = parseInt(numArr.join('').replace(new RegExp(numArr[i], 'g'), '1'));\n    } else {\n        min = parseInt(numArr.join('').replace(new RegExp(numArr[0], 'g'), '1'));\n    }\n    return max - min;\n};"}
{"id": "1240", "path": "output2\\js\\Medium\\1240-check-if-a-string-can-break-another-string.js", "hypo_code": "var checkIfCanBreak = function(s1, s2) {\n    const memo1 = {};\n    const memo2 = {};\n    for (let i = 0; i < s1.length; i++) {\n        if (!memo1[s1[i]]) {\n            memo1[s1[i]] = 0;\n        }\n        memo1[s1[i]]++;\n        if (!memo2[s2[i]]) {\n            memo2[s2[i]] = 0;\n        }\n        memo2[s2[i]]++;\n    }\n    const s1Arr = Object.entries(memo1).sort((a,b) => a[0] < b[0] ? -1 : 1);\n    const s2Arr = Object.entries(memo2).sort((a,b) => a[0] < b[0] ? -1 : 1);\n    let s1Count = 0;\n    let s2Count = 0;\n    for (let i = 0; i < s1Arr.length; i++) {\n        s1Count += s1Arr[i][1];\n        s2Count += s2Arr[i][1];\n        if (s1Count < s2Count || s2Count < s1Count) {\n            return false;\n        }\n    }\n    return true;\n};"}
{"id": "1241", "path": "output2\\js\\Medium\\1241-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit.js", "hypo_code": "var longestSubarray = function(nums, limit) {\n    const minQueue = [];\n\tconst maxQueue = [];\n\tlet left = 0;\n\tlet right = 0;\n\tlet result = 0;\n\twhile (right < nums.length) {\n\t\twhile (minQueue.length > 0 && nums[right] < minQueue[minQueue.length - 1]) {\n\t\t\tminQueue.pop();\n\t\t}\n\t\twhile (maxQueue.length > 0 && nums[right] > maxQueue[maxQueue.length - 1]) {\n\t\t\tmaxQueue.pop();\n\t\t}\n\t\tminQueue.push(nums[right]);\n\t\tmaxQueue.push(nums[right]);\n\t\twhile (maxQueue[0] - minQueue[0] > limit) {\n\t\t\tif (nums[left] === minQueue[0]) {\n\t\t\t\tminQueue.shift();\n\t\t\t}\n\t\t\tif (nums[left] === maxQueue[0]) {\n\t\t\t\tmaxQueue.shift();\n\t\t\t}\n\t\t\tleft++;\n\t\t}\n\t\tresult = Math.max(result, right - left + 1);\n\t\tright++;\n\t}\n\treturn result;\n};"}
{"id": "1242", "path": "output2\\js\\Medium\\1242-build-an-array-with-stack-operations.js", "hypo_code": "var buildArray = function(target, n) {\n    const result = [];\n    let i = 1;\n    let j = 0;\n    while (i <= n && j < target.length) {\n        if (target[j] === i) {\n            result.push('Push');\n            j++;\n        } else {\n            result.push('Push');\n            result.push('Pop');\n        }\n        i++;\n    }\n    return result;\n};"}
{"id": "1243", "path": "output2\\js\\Medium\\1243-count-triplets-that-can-form-two-arrays-of-equal-xor.js", "hypo_code": "var countTriplets = function(arr) {\n    let res = 0;\n    for(let i = 0; i < arr.length; i++){\n        let a = 0;\n        for(let k = i; k < arr.length; k++){\n            a ^= arr[k];\n            let b = 0;\n            for(let j = i; j < k; j++){\n                b ^= arr[j];\n                if(a == b){\n                    res++;\n                }\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1244", "path": "output2\\js\\Medium\\1244-minimum-time-to-collect-all-apples-in-a-tree.js", "hypo_code": "var minTime = function(n, edges, hasApple) {\n    const graph = new Map();\n    for (const [from, to] of edges) {\n        if (!graph.has(from)) {\n            graph.set(from, new Set());\n        }\n        if (!graph.has(to)) {\n            graph.set(to, new Set());\n        }\n        graph.get(from).add(to);\n        graph.get(to).add(from);\n    }\n    const visited = new Set();\n    visited.add(0);\n    const dfs = (node) => {\n        let res = 0;\n        for (const child of graph.get(node)) {\n            if (!visited.has(child)) {\n                visited.add(child);\n                res += dfs(child);\n            }\n        }\n        if (res !== 0) {\n            return res + 2;\n        }\n        if (hasApple[node]) {\n            return 2;\n        }\n        return 0;\n    }\n    return dfs(0);\n};"}
{"id": "1245", "path": "output2\\js\\Medium\\1245-simplified-fractions.js", "hypo_code": "var simplifiedFractions = function(n) {\n    let res = [];\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j < i; j++) {\n            if (gcd(i, j) === 1) {\n                res.push(j + '/' + i);\n            }\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "1246", "path": "output2\\js\\Medium\\1246-count-good-nodes-in-binary-tree.js", "hypo_code": "var goodNodes = function(root) {\n    let result = 0;\n    let stack = [];\n    let node = root;\n    while (node || stack.length) {\n        while (node) {\n            stack.push(node);\n            node = node.left;\n        }\n        node = stack.pop();\n        if (node.val >= root.val) {\n            result++;\n        }\n        node = node.right;\n    }\n    return result;\n    \n};"}
{"id": "1247", "path": "output2\\js\\Medium\\1247-rearrange-words-in-a-sentence.js", "hypo_code": "var arrangeWords = function(text) {\n    let arr = text.split(' ');\n    arr[0] = arr[0].toLowerCase();\n    arr.sort((a, b) => a.length - b.length);\n    arr[0] = arr[0][0].toUpperCase() + arr[0].substring(1);\n    return arr.join(' ');\n    \n    \n};"}
{"id": "1248", "path": "output2\\js\\Medium\\1248-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list.js", "hypo_code": "var peopleIndexes = function(favoriteCompanies) {\n    let result = [];\n    let set = new Set();\n    for (let i = 0; i < favoriteCompanies.length; i++) {\n        set.add(i);\n    }\n    for (let i = 0; i < favoriteCompanies.length; i++) {\n        let set2 = new Set();\n        for (let j = 0; j < favoriteCompanies.length; j++) {\n            if (i === j) continue;\n            let isSubset = true;\n            for (let k = 0; k < favoriteCompanies[i].length; k++) {\n                if (!favoriteCompanies[j].includes(favoriteCompanies[i][k])) {\n                    isSubset = false;\n                    break;\n                }\n            }\n            if (isSubset) {\n                set2.add(i);\n            }\n        }\n        if (set2.size === 0) {\n            result.push(i);\n        }\n    }\n    return result;\n};"}
{"id": "1249", "path": "output2\\js\\Medium\\1249-maximum-number-of-vowels-in-a-substring-of-given-length.js", "hypo_code": "var maxVowels = function(s, k) {\n    let result = 0;\n    let sum = 0;\n    let vowels = new Set(['a', 'e', 'i', 'o', 'u']);\n    for (let i = 0; i < s.length; i++) {\n        if (vowels.has(s[i])) {\n            sum++;\n        }\n        if (i >= k && vowels.has(s[i - k])) {\n            sum--;\n        }\n        result = Math.max(result, sum);\n    }\n    return result;\n};"}
{"id": "1250", "path": "output2\\js\\Medium\\1250-pseudo-palindromic-paths-in-a-binary-tree.js", "hypo_code": "var pseudoPalindromicPaths  = function(root) {\n    let result = 0;\n    let arr = new Array(9).fill(0);\n    function dfs(node) {\n        arr[node.val - 1]++;\n        if (!node.left && !node.right) {\n            let odd = 0;\n            for (let i = 0; i < arr.length; i++) {\n                if (arr[i] % 2 === 1) {\n                    odd++;\n                }\n            }\n            if (odd <= 1) {\n                result++;\n            }\n        }\n        if (node.left) {\n            dfs(node.left);\n        }\n        if (node.right) {\n            dfs(node.right);\n        }\n        arr[node.val - 1]--;\n    }\n    dfs(root);\n    return result;\n};"}
{"id": "1251", "path": "output2\\js\\Medium\\1251-check-if-a-string-contains-all-binary-codes-of-size-k.js", "hypo_code": "var hasAllCodes = function(s, k) {\n    let set = new Set();\n    for (let i = 0; i <= s.length - k; i++) {\n        set.add(s.substring(i, i + k));\n    }\n    return set.size === Math.pow(2, k);\n};"}
{"id": "1252", "path": "output2\\js\\Medium\\1252-course-schedule-iv.js", "hypo_code": "var checkIfPrerequisite = function(numCourses, prerequisites, queries) {\n    let adjList = new Array(numCourses).fill(0).map(() => []);\n    for (let i = 0; i < prerequisites.length; i++) {\n        let [a, b] = prerequisites[i];\n        adjList[a].push(b);\n    }\n    let result = [];\n    for (let i = 0; i < queries.length; i++) {\n        let [a, b] = queries[i];\n        let visited = new Set();\n        let queue = [a];\n        let hasPath = false;\n        while (queue.length > 0) {\n            let node = queue.shift();\n            visited.add(node);\n            if (node === b) {\n                hasPath = true;\n                break;\n            }\n            for (let j = 0; j < adjList[node].length; j++) {\n                let next = adjList[node][j];\n                if (!visited.has(next)) {\n                    queue.push(next);\n                }\n            }\n        }\n        result.push(hasPath);\n    }\n    return result;\n};"}
{"id": "1253", "path": "output2\\js\\Medium\\1253-maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts.js", "hypo_code": "var maxArea = function(h, w, horizontalCuts, verticalCuts) {\n    let maxH = 0;\n\tlet maxW = 0;\n\thorizontalCuts.sort((a, b) => a - b);\n\tverticalCuts.sort((a, b) => a - b);\n\tfor (let i = 0; i < horizontalCuts.length; i++) {\n\t\tlet curH = i === 0 ? horizontalCuts[i] : horizontalCuts[i] - horizontalCuts[i - 1];\n\t\tmaxH = Math.max(maxH, curH);\n\t}\n\tmaxH = Math.max(maxH, h - horizontalCuts[horizontalCuts.length - 1]);\n\tfor (let i = 0; i < verticalCuts.length; i++) {\n\t\tlet curW = i === 0 ? verticalCuts[i] : verticalCuts[i] - verticalCuts[i - 1];\n\t\tmaxW = Math.max(maxW, curW);\n\t}\n\tmaxW = Math.max(maxW, w - verticalCuts[verticalCuts.length - 1]);\n\treturn (maxH * maxW) % (Math.pow(10, 9) + 7);\n\n};"}
{"id": "1254", "path": "output2\\js\\Medium\\1254-reorder-routes-to-make-all-paths-lead-to-the-city-zero.js", "hypo_code": "var minReorder = function(n, connections) {\n    let adjList = new Array(n).fill(0).map(() => []);\n    let count = 0;\n    for (let i = 0; i < connections.length; i++) {\n        let [a, b] = connections[i];\n        adjList[a].push([b, 1]);\n        adjList[b].push([a, 0]);\n    }\n    let visited = new Set();\n    function dfs(node) {\n        visited.add(node);\n        for (let i = 0; i < adjList[node].length; i++) {\n            let next = adjList[node][i][0];\n            if (!visited.has(next)) {\n                count += adjList[node][i][1];\n                dfs(next);\n            }\n        }\n    }\n    dfs(0);\n    return count;\n};"}
{"id": "1255", "path": "output2\\js\\Medium\\1255-the-k-strongest-values-in-an-array.js", "hypo_code": "var getStrongest = function(arr, k) {\n    let res = [];\n    let median = findMedian(arr);\n    arr.sort((a, b) => Math.abs(b - median) - Math.abs(a - median) || b - a);\n    for (let i = 0; i < k; i++) {\n        res.push(arr[i]);\n    }\n    return res;\n    \n    \n};"}
{"id": "1258", "path": "output2\\js\\Medium\\1258-find-two-non-overlapping-sub-arrays-each-with-target-sum.js", "hypo_code": "var minSumOfLengths = function(arr, target) {\n    let n = arr.length;\n    let dp = new Array(n).fill(Infinity);\n    let res = Infinity;\n    let sum = 0;\n    let map = new Map();\n    map.set(0, -1);\n    for (let i = 0; i < n; i++) {\n        sum += arr[i];\n        if (map.has(sum - target)) {\n            let j = map.get(sum - target);\n            if (j >= 0) {\n                dp[i] = i - j;\n                if (j > 0) {\n                    dp[i] += dp[j - 1];\n                }\n            }\n        }\n        if (i > 0) {\n            dp[i] = Math.min(dp[i], dp[i - 1]);\n        }\n        map.set(sum, i);\n    }\n    return dp[n - 1] === Infinity ? -1 : dp[n - 1];\n    \n};"}
{"id": "1259", "path": "output2\\js\\Medium\\1259-least-number-of-unique-integers-after-k-removals.js", "hypo_code": "var findLeastNumOfUniqueInts = function(arr, k) {\n    let map = new Map();\n    for (let num of arr) {\n        map.set(num, (map.get(num) || 0) + 1);\n    }\n    let arr2 = Array.from(map.values());\n    arr2.sort((a, b) => a - b);\n    let i = 0;\n    while (i < arr2.length && k >= arr2[i]) {\n        k -= arr2[i];\n        i++;\n    }\n    return arr2.length - i;\n    \n};"}
{"id": "1260", "path": "output2\\js\\Medium\\1260-minimum-number-of-days-to-make-m-bouquets.js", "hypo_code": "var minDays = function(bloomDay, m, k) {\n    if (m * k > bloomDay.length) {\n        return -1;\n    }\n    let left = 1;\n    let right = Math.max(...bloomDay);\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        if (canMake(bloomDay, m, k, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n    \n    \n};"}
{"id": "1261", "path": "output2\\js\\Medium\\1261-making-file-names-unique.js", "hypo_code": "var getFolderNames = function(names) {\n    let map = new Map();\n    let result = [];\n    for (let i = 0; i < names.length; i++) {\n        if (!map.has(names[i])) {\n            map.set(names[i], 1);\n            result.push(names[i]);\n        } else {\n            let num = map.get(names[i]);\n            while (map.has(names[i] + '(' + num + ')')) {\n                num++;\n            }\n            result.push(names[i] + '(' + num + ')');\n            map.set(names[i], num + 1);\n            map.set(names[i] + '(' + num + ')', 1);\n        }\n    }\n    return result;\n};"}
{"id": "1262", "path": "output2\\js\\Medium\\1262-avoid-flood-in-the-city.js", "hypo_code": "var avoidFlood = function(rains) {\n    let result = new Array(rains.length).fill(-1);\n    let map = new Map();\n    let set = new Set();\n    for (let i = 0; i < rains.length; i++) {\n        if (rains[i] === 0) {\n            set.add(i);\n        } else {\n            if (map.has(rains[i])) {\n                let arr = map.get(rains[i]);\n                let index = -1;\n                for (let j = 0; j < arr.length; j++) {\n                    if (set.size === 0) {\n                        return [];\n                    }\n                    let temp = arr[j];\n                    let it = set.values();\n                    let temp2 = it.next().value;\n                    if (temp2 < temp) {\n                        index = temp2;\n                    } else {\n                        index = temp;\n                    }\n                    result[index] = rains[i];\n                    set.delete(index);\n                }\n                arr = [];\n                map.set(rains[i], arr);\n            }\n            map.set(rains[i], map.has(rains[i]) ? map.get(rains[i]).concat(i) : [i]);\n        }\n    }\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === -1) {\n            result[i] = 1;\n        }\n    }\n    return result;\n};"}
{"id": "1263", "path": "output2\\js\\Medium\\1263-the-kth-factor-of-n.js", "hypo_code": "var kthFactor = function(n, k) {\n    let result = -1;\n\tlet count = 0;\n\tfor (let i = 1; i <= n; i++) {\n\t\tif (n % i === 0) {\n\t\t\tcount++;\n\t\t\tif (count === k) {\n\t\t\t\tresult = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n};"}
{"id": "1264", "path": "output2\\js\\Medium\\1264-longest-subarray-of-1s-after-deleting-one-element.js", "hypo_code": "var longestSubarray = function(nums) {\n    let result = 0;\n    let left = 0;\n    let right = 0;\n    let count = 0;\n    while (right < nums.length) {\n        if (nums[right] === 0) {\n            count++;\n        }\n        while (count > 1) {\n            if (nums[left] === 0) {\n                count--;\n            }\n            left++;\n        }\n        result = Math.max(result, right - left);\n        right++;\n    }\n    return result;  \n};"}
{"id": "1265", "path": "output2\\js\\Medium\\1265-check-if-array-pairs-are-divisible-by-k.js", "hypo_code": "var canArrange = function(arr, k) {\n    let map = new Map();\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tlet remainder = arr[i] % k;\n\t\tif (remainder < 0) {\n\t\t\tremainder += k;\n\t\t}\n\t\tmap.set(remainder, (map.get(remainder) || 0) + 1);\n\t}\n\tif (map.get(0) % 2 !== 0) {\n\t\treturn false;\n\t}\n\tfor (let i = 1; i <= k / 2; i++) {\n\t\tif (map.get(i) !== map.get(k - i)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};"}
{"id": "1266", "path": "output2\\js\\Medium\\1266-number-of-subsequences-that-satisfy-the-given-sum-condition.js", "hypo_code": "var numSubseq = function(nums, target) {\n    let result = 0;\n    let mod = Math.pow(10, 9) + 7;\n    nums.sort((a, b) => a - b);\n    let left = 0;\n    let right = nums.length - 1;\n    let pow = new Array(nums.length);\n    pow[0] = 1;\n    for (let i = 1; i < nums.length; i++) {\n        pow[i] = pow[i - 1] * 2 % mod;\n    }\n    while (left <= right) {\n        if (nums[left] + nums[right] > target) {\n            right--;\n        } else {\n            result = (result + pow[right - left]) % mod;\n            left++;\n        }\n    }\n    return result;\n};"}
{"id": "1267", "path": "output2\\js\\Medium\\1267-last-moment-before-all-ants-fall-out-of-a-plank.js", "hypo_code": "var getLastMoment = function(n, left, right) {\n    let result = 0;\n    for (let i = 0; i < left.length; i++) {\n        result = Math.max(result, left[i]);\n    }\n    for (let i = 0; i < right.length; i++) {\n        result = Math.max(result, n - right[i]);\n    }\n    return result;\n};"}
{"id": "1268", "path": "output2\\js\\Medium\\1268-count-submatrices-with-all-ones.js", "hypo_code": "var numSubmat = function(mat) {\n    let m = mat.length;\n    let n = mat[0].length;\n    let result = 0;\n    let height = Array.from({length: m}, () => new Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++){\n            if (mat[i][j] === 0) {\n                height[i][j] = 0;\n            } else {\n                height[i][j] = i === 0 ? 1 : height[i - 1][j] + 1;\n            }\n        }\n    }\n    for (let i = 0; i < m; i++) {\n        let stack = [];\n        let sum = 0;\n        for (let j = 0; j <= n; j++) {\n            let cur = j === n ? -1 : height[i][j];\n            while (stack.length > 0 && cur <= height[i][stack[stack.length - 1]]) {\n                let h = height[i][stack.pop()];\n                let w = stack.length === 0 ? j : j - stack[stack.length - 1] - 1;\n                sum += h * w;\n            }\n            stack.push(j);\n        }\n        result += sum;\n    }\n    return result;\n};"}
{"id": "1269", "path": "output2\\js\\Medium\\1269-range-sum-of-sorted-subarray-sums.js", "hypo_code": "var rangeSum = function(nums, n, left, right) {\n    let mod = Math.pow(10, 9) + 7;\n    let sums = [];\n    let result = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let sum = 0;\n        for (let j = i; j < nums.length; j++) {\n            sum += nums[j];\n            sums.push(sum);\n        }\n    }\n    sums.sort((a, b) => a - b);\n    for (let i = left - 1; i < right; i++) {\n        result = (result + sums[i]) % mod;\n    }\n    return result;\n};"}
{"id": "1270", "path": "output2\\js\\Medium\\1270-minimum-difference-between-largest-and-smallest-value-in-three-moves.js", "hypo_code": "var minDifference = function(nums) {\n    if (nums.length <= 4) {\n        return 0;\n    }\n    nums.sort((a, b) => a - b);\n    let result = Number.MAX_VALUE;\n    for (let i = 0; i < 4; i++) {\n        let left = i;\n        let right = nums.length - 4 + i;\n        result = Math.min(result, nums[right] - nums[left]);\n    }\n    return result;\n};"}
{"id": "1271", "path": "output2\\js\\Medium\\1271-number-of-substrings-with-only-1s.js", "hypo_code": "var numSub = function(s) {\n    let result = 0;\n    let count = 0;\n    let mod = Math.pow(10, 9) + 7;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '1') {\n            count++;\n            result = (result + count) % mod;\n        } else {\n            count = 0;\n        }\n    }\n    return result;\n};"}
{"id": "1272", "path": "output2\\js\\Medium\\1272-path-with-maximum-probability.js", "hypo_code": "var maxProbability = function(n, edges, succProb, start_node, end_node) {\n    let map = new Map();\n    for (let i = 0; i < edges.length; i++) {\n        let [a, b] = edges[i];\n        if (!map.has(a)) {\n            map.set(a, []);\n        }\n        map.get(a).push([b, succProb[i]]);\n        if (!map.has(b)) {\n            map.set(b, []);\n        }\n        map.get(b).push([a, succProb[i]]);\n    }\n    let visited = new Set();\n    let queue = [[start_node, 1]];\n    while (queue.length > 0) {\n        let [node, prob] = queue.shift();\n        if (node === end_node) {\n            return prob;\n        }\n        visited.add(node);\n        if (map.has(node)) {\n            for (let [next, nextProb] of map.get(node)) {\n                if (!visited.has(next)) {\n                    queue.push([next, prob * nextProb]);\n                }\n            }\n        }\n        queue.sort((a, b) => b[1] - a[1]);\n    }\n    return 0;\n};"}
{"id": "1273", "path": "output2\\js\\Medium\\1273-number-of-nodes-in-the-sub-tree-with-the-same-label.js", "hypo_code": "var countSubTrees = function(n, edges, labels) {\n    let map = new Map();\n    for (let [a, b] of edges) {\n        if (!map.has(a)) {\n            map.set(a, []);\n        }\n        map.get(a).push(b);\n        if (!map.has(b)) {\n            map.set(b, []);\n        }\n        map.get(b).push(a);\n    }\n    let result = new Array(n).fill(0);\n    let dfs = (node, parent) => {\n        let count = new Array(26).fill(0);\n        let index = labels.charCodeAt(node) - 'a'.charCodeAt();\n        count[index]++;\n        if (map.has(node)) {\n            for (let next of map.get(node)) {\n                if (next !== parent) {\n                    let subCount = dfs(next, node);\n                    for (let i = 0; i < 26; i++) {\n                        count[i] += subCount[i];\n                    }\n                }\n            }\n        }\n        result[node] = count[index];\n        return count;\n    };\n    dfs(0, -1);\n    return result;\n};"}
{"id": "1274", "path": "output2\\js\\Medium\\1274-number-of-sub-arrays-with-odd-sum.js", "hypo_code": "var numOfSubarrays = function(arr) {\n    let n = arr.length;\n    let mod = 1000000007;\n    let dp = new Array(n).fill(0);\n    let sum = 0;\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        sum += arr[i];\n        if (sum % 2 === 0) {\n            dp[i] = 1;\n        }\n        if (i > 0) {\n            dp[i] += dp[i - 1];\n        }\n        res += dp[i];\n        res %= mod;\n    }\n    return res;\n    \n};"}
{"id": "1275", "path": "output2\\js\\Medium\\1275-number-of-good-ways-to-split-a-string.js", "hypo_code": "var numSplits = function(s) {\n    let count = 0;\n    let left = new Set();\n    let right = new Set();\n    let leftCount = 0;\n    let rightCount = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (!right.has(s[i])) {\n            rightCount++;\n            right.add(s[i]);\n        }\n    }\n    for (let i = 0; i < s.length; i++) {\n        if (!left.has(s[i])) {\n            leftCount++;\n            left.add(s[i]);\n        }\n        if (right.has(s[i])) {\n            rightCount--;\n            right.delete(s[i]);\n        }\n        if (leftCount === rightCount) {\n            count++;\n        }\n    }\n    return count;\n    \n};"}
{"id": "1276", "path": "output2\\js\\Medium\\1276-minimum-suffix-flips.js", "hypo_code": "var minFlips = function(target) {\n    let res = 0;\n    let prev = 0;\n    for (let i = 0; i < target.length; i++) {\n        if (target[i] - '0' !== prev) {\n            res++;\n            prev = 1 - prev;\n        }\n    }\n    return res;\n    \n};"}
{"id": "1277", "path": "output2\\js\\Medium\\1277-number-of-good-leaf-nodes-pairs.js", "hypo_code": "var countPairs = function(root, distance) {\n    let res = 0;\n    let dfs = (node) => {\n        if (!node) {\n            return [];\n        }\n        if (!node.left && !node.right) {\n            return [1];\n        }\n        let left = dfs(node.left);\n        let right = dfs(node.right);\n        for (let i = 0; i < left.length; i++) {\n            for (let j = 0; j < right.length; j++) {\n                if (left[i] + right[j] <= distance) {\n                    res++;\n                }\n            }\n        }\n        let res = [];\n        for (let i = 0; i < left.length; i++) {\n            if (left[i] + 1 < distance) {\n                res.push(left[i] + 1);\n            }\n        }\n        for (let i = 0; i < right.length; i++) {\n            if (right[i] + 1 < distance) {\n                res.push(right[i] + 1);\n            }\n        }\n        return res;\n    }\n    dfs(root);\n    return res;\n    \n};"}
{"id": "1278", "path": "output2\\js\\Medium\\1278-find-the-winner-of-an-array-game.js", "hypo_code": "var getWinner = function(arr, k) {\n    let winner = arr[0], count = 0;\n\tfor (let i = 1; i < arr.length; i++) {\n\t\tif (arr[i] > winner) {\n\t\t\twinner = arr[i];\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\t\tif (count === k) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn winner;\n};"}
{"id": "1279", "path": "output2\\js\\Medium\\1279-minimum-swaps-to-arrange-a-binary-grid.js", "hypo_code": "var minSwaps = function(grid) {\n    let count = 0;\n\tfor (let i = 0; i < grid.length; i++) {\n\t\tlet j = i;\n\t\twhile (j < grid.length && grid[j][i] === 0) {\n\t\t\tj++;\n\t\t}\n\t\tif (j === grid.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tcount += j - i;\n\t\tgrid.splice(j, 1);\n\t\tgrid.unshift(new Array(grid.length).fill(0));\n\t}\n\treturn count;\n};"}
{"id": "1280", "path": "output2\\js\\Medium\\1280-can-convert-string-in-k-moves.js", "hypo_code": "var canConvertString = function(s, t, k) {\n    if (s.length !== t.length) {\n\t\treturn false;\n\t}\n\tlet count = new Array(26).fill(0);\n\tfor (let i = 0; i < s.length; i++) {\n\t\tlet diff = (t.charCodeAt(i) - s.charCodeAt(i) + 26) % 26;\n\t\tif (diff > 0 && diff + count[diff] * 26 > k) {\n\t\t\treturn false;\n\t\t}\n\t\tcount[diff]++;\n\t}\n\treturn true;\n};"}
{"id": "1281", "path": "output2\\js\\Medium\\1281-minimum-insertions-to-balance-a-parentheses-string.js", "hypo_code": "var minInsertions = function(s) {\n    let count = 0, right = 0;\n\tfor (let i = 0; i < s.length; i++) {\n\t\tif (s[i] === '(') {\n\t\t\tif (right % 2 !== 0) {\n\t\t\t\tcount++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t\tright += 2;\n\t\t} else {\n\t\t\tright--;\n\t\t\tif (right < 0) {\n\t\t\t\tcount++;\n\t\t\t\tright += 2;\n\t\t\t}\n\t\t}\n\t}\n\treturn count + right;\n};"}
{"id": "1282", "path": "output2\\js\\Medium\\1282-find-kth-bit-in-nth-binary-string.js", "hypo_code": "var findKthBit = function(n, k) {\n    let count = 0;\n\tfor (let i = 1; i < n; i++) {\n\t\tcount = count * 2 + 1;\n\t}\n\tlet left = 0, right = count;\n\twhile (left < right) {\n\t\tlet mid = Math.floor((left + right) / 2);\n\t\tif (mid === k - 1) {\n\t\t\treturn '1';\n\t\t} else if (mid < k - 1) {\n\t\t\tleft = mid + 1;\n\t\t} else {\n\t\t\tright = mid;\n\t\t}\n\t}\n\treturn '0';\n};"}
{"id": "1283", "path": "output2\\js\\Medium\\1283-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target.js", "hypo_code": "var maxNonOverlapping = function(nums, target) {\n    let sum = 0, count = 0, map = new Map();\n\tmap.set(0, -1);\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tsum += nums[i];\n\t\tif (map.has(sum - target)) {\n\t\t\tcount++;\n\t\t\tmap.clear();\n\t\t\tmap.set(0, i);\n\t\t\tsum = 0;\n\t\t} else {\n\t\t\tmap.set(sum, i);\n\t\t}\n\t}\n\treturn count;\n};"}
{"id": "1284", "path": "output2\\js\\Medium\\1284-minimum-operations-to-make-array-equal.js", "hypo_code": "var minOperations = function(n) {\n    return n * n >> 2;\n\n};"}
{"id": "1285", "path": "output2\\js\\Medium\\1285-magnetic-force-between-two-balls.js", "hypo_code": "var maxDistance = function(position, m) {\n    position.sort((a, b) => a - b);\n\tlet left = 1, right = position[position.length - 1] - position[0];\n\twhile (left < right) {\n\t\tlet mid = left + right + 1 >> 1;\n\t\tif (check(position, mid, m)) {\n\t\t\tleft = mid;\n\t\t} else {\n\t\t\tright = mid - 1;\n\t\t}\n\t}\n\treturn left;\n};\nvar check = function(position, mid, m) {\n\tlet count = 1, pre = position[0];\n\tfor (let i = 1; i < position.length; i++) {\n\t\tif (position[i] - pre >= mid) {\n\t\t\tcount++;\n\t\t\tpre = position[i];\n\t\t}\n\t}\n\treturn count >= m;\n};"}
{"id": "1286", "path": "output2\\js\\Medium\\1286-minimum-number-of-vertices-to-reach-all-nodes.js", "hypo_code": "var findSmallestSetOfVertices = function(n, edges) {\n    let res = new Array(n).fill(0);\n    for (let edge of edges) {\n        res[edge[1]] = 1;\n    }\n    let ans = [];\n    for (let i = 0; i < n; i++) {\n        if (res[i] === 0) {\n            ans.push(i);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1287", "path": "output2\\js\\Medium\\1287-minimum-numbers-of-function-calls-to-make-target-array.js", "hypo_code": "var minOperations = function(nums) {\n    let max = 0, count = 0;\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tlet n = nums[i];\n\t\tlet c = 0;\n\t\twhile (n) {\n\t\t\tif (n & 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tn >>= 1;\n\t\t\tc++;\n\t\t}\n\t\tmax = Math.max(max, c - 1);\n\t}\n\treturn count + max;\n};"}
{"id": "1288", "path": "output2\\js\\Medium\\1288-detect-cycles-in-2d-grid.js", "hypo_code": "var containsCycle = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let visited = new Array(m);\n    for (let i = 0; i < m; i++) {\n        visited[i] = new Array(n).fill(false);\n    }\n    let dfs = (i, j, pi, pj, c) => {\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != c || visited[i][j]) {\n            return false;\n        }\n        if (i == pi && j == pj) {\n            return false;\n        }\n        if (visited[i][j]) {\n            return true;\n        }\n        visited[i][j] = true;\n        let res = dfs(i + 1, j, i, j, c) || dfs(i - 1, j, i, j, c) || dfs(i, j + 1, i, j, c) || dfs(i, j - 1, i, j, c);\n        visited[i][j] = false;\n        return res;\n    }\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (dfs(i, j, -1, -1, grid[i][j])) {\n                return true;\n            }\n        }\n    }\n    return false;\n    \n};"}
{"id": "1289", "path": "output2\\js\\Medium\\1289-maximum-number-of-coins-you-can-get.js", "hypo_code": "var maxCoins = function(piles) {\n    piles.sort((a, b) => a - b);\n    let res = 0;\n    let n = piles.length;\n    let i = n - 2;\n    while (i >= n / 3) {\n        res += piles[i];\n        i -= 2;\n    }\n    return res;\n    \n};"}
{"id": "1290", "path": "output2\\js\\Medium\\1290-find-latest-group-of-size-m.js", "hypo_code": "var findLatestStep = function(arr, m) {\n    let n = arr.length;\n    let res = -1;\n    let dp = new Array(n + 2).fill(0);\n    let count = new Array(n + 1).fill(0);\n    for (let i = 0; i < n; i++) {\n        let a = arr[i];\n        let left = dp[a - 1];\n        let right = dp[a + 1];\n        dp[a - left] = dp[a + right] = left + right + 1;\n        count[left]--;\n        count[right]--;\n        count[left + right + 1]++;\n        if (count[m] > 0) {\n            res = i + 1;\n        }\n    }\n    return res;\n    \n};"}
{"id": "1291", "path": "output2\\js\\Medium\\1291-maximum-length-of-subarray-with-positive-product.js", "hypo_code": "var getMaxLen = function(nums) {\n    let max = 0, neg = 0, pos = 0;\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tif (nums[i] === 0) {\n\t\t\tneg = 0;\n\t\t\tpos = 0;\n\t\t} else if (nums[i] > 0) {\n\t\t\tpos++;\n\t\t\tif (neg) {\n\t\t\t\tneg++;\n\t\t\t}\n\t\t} else {\n\t\t\tlet t = neg;\n\t\t\tneg = pos ? pos + 1 : 0;\n\t\t\tpos = t ? t + 1 : 0;\n\t\t}\n\t\tmax = Math.max(max, pos);\n\t}\n\treturn max;\n};"}
{"id": "1292", "path": "output2\\js\\Medium\\1292-number-of-ways-to-split-a-string.js", "hypo_code": "var numWays = function(s) {\n    let n = s.length;\n    let mod = 1000000007;\n    let ones = 0;\n    for (let i = 0; i < n; i++) {\n        if (s[i] === '1') {\n            ones++;\n        }\n    }\n    if (ones === 0) {\n        return (n - 1) * (n - 2) / 2 % mod;\n    }\n    if (ones % 3 !== 0) {\n        return 0;\n    }\n    let count = 0;\n    let res = 0;\n    let first = ones / 3;\n    let second = ones / 3 * 2;\n    for (let i = 0; i < n; i++) {\n        if (s[i] === '1') {\n            count++;\n        }\n        if (count === first) {\n            res++;\n        }\n        if (count === second) {\n            res++;\n        }\n    }\n    return res % mod;\n    \n};"}
{"id": "1293", "path": "output2\\js\\Medium\\1293-shortest-subarray-to-be-removed-to-make-array-sorted.js", "hypo_code": "var findLengthOfShortestSubarray = function(arr) {\n    let left = 0;\n    let right = arr.length - 1;\n    while (left + 1 < arr.length && arr[left] <= arr[left + 1]) {\n        left++;\n    }\n    if (left === arr.length - 1) {\n        return 0;\n    }\n    while (right - 1 >= 0 && arr[right] >= arr[right - 1]) {\n        right--;\n    }\n    let result = Math.min(arr.length - left - 1, right);\n    let i = 0;\n    let j = right;\n    while (i <= left && j < arr.length) {\n        if (arr[i] <= arr[j]) {\n            result = Math.min(result, j - i - 1);\n            i++;\n        } else {\n            j++;\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1294", "path": "output2\\js\\Medium\\1294-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers.js", "hypo_code": "var numTriplets = function(nums1, nums2) {\n    let n = nums1.length;\n    let m = nums2.length;\n    let res = 0;\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            let product = nums1[i] * nums1[j];\n            map1.set(product, (map1.get(product) || 0) + 1);\n        }\n    }\n    for (let i = 0; i < m; i++) {\n        for (let j = i + 1; j < m; j++) {\n            let product = nums2[i] * nums2[j];\n            map2.set(product, (map2.get(product) || 0) + 1);\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        let square = nums1[i] * nums1[i];\n        if (map2.has(square)) {\n            res += map2.get(square);\n        }\n    }\n    for (let i = 0; i < m; i++) {\n        let square = nums2[i] * nums2[i];\n        if (map1.has(square)) {\n            res += map1.get(square);\n        }\n    }\n    return res;\n    \n};"}
{"id": "1295", "path": "output2\\js\\Medium\\1295-minimum-time-to-make-rope-colorful.js", "hypo_code": "var minCost = function(colors, neededTime) {\n    let n = colors.length;\n    let dp = new Array(n).fill(Infinity);\n    let res = Infinity;\n    let sum = 0;\n    let map = new Map();\n    map.set(0, -1);\n    for (let i = 0; i < n; i++) {\n        sum += colors[i];\n        if (map.has(sum - neededTime)) {\n            let j = map.get(sum - neededTime);\n            if (j >= 0) {\n                dp[i] = i - j;\n                if (j > 0) {\n                    dp[i] += dp[j - 1];\n                }\n            }\n        }\n        if (i > 0) {\n            dp[i] = Math.min(dp[i], dp[i - 1]);\n        }\n        map.set(sum, i);\n    }\n    return dp[n - 1] === Infinity ? -1 : dp[n - 1];\n    \n};"}
{"id": "1296", "path": "output2\\js\\Medium\\1296-count-unhappy-friends.js", "hypo_code": "var unhappyFriends = function(n, preferences, pairs) {\n    let unhappy = 0;\n    for (let i = 0; i < pairs.length; i++) {\n        for (let j = 0; j < 2; j++) {\n            let x = pairs[i][j];\n            let y = pairs[i][1 - j];\n            for (let k = 0; k < pairs.length; k++) {\n                if (k === i) {\n                    continue;\n                }\n                let u = pairs[k][0];\n                let v = pairs[k][1];\n                if (preferences[x].indexOf(u) < preferences[x].indexOf(y) && preferences[u].indexOf(x) < preferences[u].indexOf(v)) {\n                    unhappy++;\n                    break;\n                }\n            }\n        }\n    }\n    return unhappy;\n};"}
{"id": "1297", "path": "output2\\js\\Medium\\1297-min-cost-to-connect-all-points.js", "hypo_code": "var minCostConnectPoints = function(points) {\n    const n = points.length;\n    const edges = [];\n    for (let i = 0; i < n; i++) {\n        const [x1, y1] = points[i];\n        for (let j = i + 1; j < n; j++) {\n            const [x2, y2] = points[j];\n            edges.push([Math.abs(x1 - x2) + Math.abs(y1 - y2), i, j]);\n        }\n    }\n    edges.sort((a, b) => a[0] - b[0]);\n    const uf = new UnionFind(n);\n    let cost = 0;\n    for (const [d, x, y] of edges) {\n        if (uf.union(x, y)) {\n            cost += d;\n        }\n    }\n    return cost;\n};"}
{"id": "1298", "path": "output2\\js\\Medium\\1298-maximum-sum-obtained-of-any-permutation.js", "hypo_code": "var maxSumRangeQuery = function(nums, requests) {\n    let count = new Array(nums.length).fill(0);\n    for (let r of requests) {\n        count[r[0]]++;\n        if (r[1] + 1 < nums.length) {\n            count[r[1] + 1]--;\n        }\n    }\n    for (let i = 1; i < count.length; i++) {\n        count[i] += count[i - 1];\n    }\n    count.sort((a, b) => b - a);\n    nums.sort((a, b) => b - a);\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i] * count[i];\n    }\n    return sum % 1000000007;\n};"}
{"id": "1299", "path": "output2\\js\\Medium\\1299-make-sum-divisible-by-p.js", "hypo_code": "var minSubarray = function(nums, p) {\n    let sum = nums.reduce((a, b) => a + b) % p;\n    if (sum === 0) {\n        return 0;\n    }\n    let map = new Map();\n    map.set(0, -1);\n    let cur = 0, min = nums.length;\n    for (let i = 0; i < nums.length; i++) {\n        cur = (cur + nums[i]) % p;\n        let target = (cur - sum + p) % p;\n        if (map.has(target)) {\n            min = Math.min(min, i - map.get(target));\n        }\n        map.set(cur, i);\n    }\n    return min === nums.length ? -1 : min;\n};"}
{"id": "1300", "path": "output2\\js\\Medium\\1300-split-a-string-into-the-max-number-of-unique-substrings.js", "hypo_code": "var maxUniqueSplit = function(s) {\n    let max = 0;\n    let set = new Set();\n    let dfs = (idx) => {\n        if (idx === s.length) {\n            max = Math.max(max, set.size);\n            return;\n        }\n        for (let i = idx + 1; i <= s.length; i++) {\n            let str = s.substring(idx, i);\n            if (!set.has(str)) {\n                set.add(str);\n                dfs(i);\n                set.delete(str);\n            }\n        }\n    };\n    dfs(0);\n    return max;\n};"}
{"id": "1301", "path": "output2\\js\\Medium\\1301-maximum-non-negative-product-in-a-matrix.js", "hypo_code": "var maxProductPath = function(grid) {\n    const mod = 1000000007;\n    const m = grid.length, n = grid[0].length;\n    const dpMax = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    const dpMin = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    dpMax[0][0] = dpMin[0][0] = grid[0][0];\n    for (let i = 1; i < m; i++) {\n        dpMax[i][0] = dpMin[i][0] = dpMax[i - 1][0] * grid[i][0];\n    }\n    for (let j = 1; j < n; j++) {\n        dpMax[0][j] = dpMin[0][j] = dpMax[0][j - 1] * grid[0][j];\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            const max = Math.max(dpMax[i - 1][j], dpMax[i][j - 1]);\n            const min = Math.min(dpMin[i - 1][j], dpMin[i][j - 1]);\n            dpMax[i][j] = Math.max(max * grid[i][j], min * grid[i][j]);\n            dpMin[i][j] = Math.min(max * grid[i][j], min * grid[i][j]);\n        }\n    }\n    return dpMax[m - 1][n - 1] < 0 ? -1 : dpMax[m - 1][n - 1] % mod;\n\n};"}
{"id": "1302", "path": "output2\\js\\Medium\\1302-maximum-profit-of-operating-a-centennial-wheel.js", "hypo_code": "var minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\n    let max = 0, sum = 0, cur = 0, count = 0, i = 0;\n    while (i < customers.length || cur) {\n        if (i < customers.length) {\n            cur += customers[i];\n        }\n        let n = Math.min(4, cur);\n        cur -= n;\n        sum += n * boardingCost - runningCost;\n        if (sum > max) {\n            max = sum;\n            count = i + 1;\n        }\n        i++;\n    }\n    return max ? count : -1;\n};"}
{"id": "1304", "path": "output2\\js\\Medium\\1304-alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.js", "hypo_code": "var alertNames = function(keyName, keyTime) {\n    const map = {};\n    for (let i = 0; i < keyName.length; i++) {\n        if (!map[keyName[i]]) {\n            map[keyName[i]] = [];\n        }\n        map[keyName[i]].push(keyTime[i]);\n    }\n    const res = [];\n    for (const name in map) {\n        const times = map[name].sort();\n        for (let i = 2; i < times.length; i++) {\n            if (compare(times[i - 2], times[i])) {\n                res.push(name);\n                break;\n            }\n        }\n    }\n    return res.sort();\n};"}
{"id": "1305", "path": "output2\\js\\Medium\\1305-find-valid-matrix-given-row-and-column-sums.js", "hypo_code": "var restoreMatrix = function(rowSum, colSum) {\n    let m = rowSum.length, n = colSum.length;\n    let ans = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        ans[i][0] = rowSum[i];\n    }\n    for (let j = 0; j < n; j++) {\n        ans[0][j] = colSum[j];\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            ans[i][j] = Math.min(rowSum[i], colSum[j]);\n            rowSum[i] -= ans[i][j];\n            colSum[j] -= ans[i][j];\n        }\n    }\n    return ans;\n};"}
{"id": "1306", "path": "output2\\js\\Medium\\1306-even-odd-tree.js", "hypo_code": "var isEvenOddTree = function(root) {\n    let queue = [root], level = 0;\n\twhile (queue.length) {\n\t\tlet count = queue.length, prev = level % 2 ? Infinity : -Infinity;\n\t\twhile (count--) {\n\t\t\tlet node = queue.shift();\n\t\t\tif (level % 2 && (node.val % 2 || node.val <= prev)) {\n\t\t\t\treturn false;\n\t\t\t} else if (level % 2 === 0 && (node.val % 2 === 0 || node.val >= prev)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tprev = node.val;\n\t\t\tif (node.left) {\n\t\t\t\tqueue.push(node.left);\n\t\t\t}\n\t\t\tif (node.right) {\n\t\t\t\tqueue.push(node.right);\n\t\t\t}\n\t\t}\n\t\tlevel++;\n\t}\n\treturn true;\n};"}
{"id": "1307", "path": "output2\\js\\Medium\\1307-maximal-network-rank.js", "hypo_code": "var maximalNetworkRank = function(n, roads) {\n    const graph = new Array(n).fill(0).map(() => new Set());\n    for (const [u, v] of roads) {\n        graph[u].add(v);\n        graph[v].add(u);\n    }\n    let max = 0;\n    for (let u = 0; u < n; u++) {\n        for (let v = u + 1; v < n; v++) {\n            let rank = graph[u].size + graph[v].size;\n            if (graph[u].has(v)) {\n                rank--;\n            }\n            max = Math.max(max, rank);\n        }\n    }\n    return max;\n};"}
{"id": "1308", "path": "output2\\js\\Medium\\1308-split-two-strings-to-make-palindrome.js", "hypo_code": "var checkPalindromeFormation = function(a, b) {\n    \n};"}
{"id": "1309", "path": "output2\\js\\Medium\\1309-coordinate-with-maximum-network-quality.js", "hypo_code": "var bestCoordinate = function(towers, radius) { \n    let max = 0;\n    let res = [];\n    for (let x = 0; x <= 50; x++) {\n        for (let y = 0; y <= 50; y++) {\n            let sum = 0;\n            for (let i = 0; i < towers.length; i++) {\n                let d = Math.sqrt(Math.pow(x - towers[i][0], 2) + Math.pow(y - towers[i][1], 2));\n                if (d <= radius) {\n                    sum += Math.floor(towers[i][2] / (1 + d));\n                }\n            }\n            if (sum > max) {\n                max = sum;\n                res = [x, y];\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1310", "path": "output2\\js\\Medium\\1310-number-of-sets-of-k-non-overlapping-line-segments.js", "hypo_code": "var numberOfSets = function(n, k) { \n    let dp = Array.from({length: k + 1}, () => Array.from({length: n}, () => 0));\n    let sum = Array.from({length: n}, () => 0);\n    dp[0][0] = 1;\n    sum[0] = 1;\n    let mod = 1000000007;\n    for (let i = 1; i <= k; i++) {\n        for (let j = i; j < n; j++) {\n            dp[i][j] = sum[j - 1];\n            sum[j] = (sum[j - 1] + dp[i][j]) % mod;\n        }\n    }\n    return dp[k][n - 1];\n};"}
{"id": "1311", "path": "output2\\js\\Medium\\1311-lexicographically-smallest-string-after-applying-operations.js", "hypo_code": "var findLexSmallestString = function(s, a, b) {\n    let visited = new Set();\n    let min = s;\n    let queue = [];\n    queue.push(s);\n    while (queue.length) {\n        let cur = queue.shift();\n        if (visited.has(cur)) continue;\n        visited.add(cur);\n        min = min < cur ? min : cur;\n        queue.push(add(cur, a));\n        queue.push(rotate(cur, b));\n    }\n    return min;\n};\nfunction add(s, a) {\n    let str = '';\n    for (let i = 0; i < s.length; i++) {\n        if (i % 2 === 1) {\n            let num = (parseInt(s[i]) + a) % 10;\n            str += num;\n        } else {\n            str += s[i];\n        }\n    }\n    return str;\n}\nfunction rotate(s, b) {\n    let str = '';\n    let len = s.length;\n    for (let i = 0; i < len; i++) {\n        let idx = (i + b) % len;\n        str += s[idx];\n    }\n    return str;\n}"}
{"id": "1312", "path": "output2\\js\\Medium\\1312-best-team-with-no-conflicts.js", "hypo_code": "var bestTeamScore = function(scores, ages) {  \n    let players = [];\n    for (let i = 0; i < scores.length; i++) {\n        players.push([ages[i], scores[i]]);\n    }\n    players.sort((a, b) => (a[0] - b[0] || a[1] - b[1]));\n    let dp = new Array(players.length).fill(0);\n    dp[0] = players[0][1];\n    let max = dp[0];\n    for (let i = 1; i < players.length; i++) {\n        dp[i] = players[i][1];\n        for (let j = 0; j < i; j++) {\n            if (players[i][1] >= players[j][1]) {\n                dp[i] = Math.max(dp[i], dp[j] + players[i][1]);\n            }\n        }\n        max = Math.max(max, dp[i]);\n    }\n    return max;\n};"}
{"id": "1313", "path": "output2\\js\\Medium\\1313-arithmetic-subarrays.js", "hypo_code": "var checkArithmeticSubarrays = function(nums, l, r) { \n    let res = [];\n    for (let i = 0; i < l.length; i++) {\n        let sorted = nums.slice(l[i], r[i] + 1).sort((a, b) => a - b);\n        let diff = sorted[1] - sorted[0];\n        let flag = true;\n        for (let j = 2; j < sorted.length; j++) {\n            if (sorted[j] - sorted[j - 1] !== diff) {\n                flag = false;\n                break;\n            }\n        }\n        res.push(flag);\n    }\n    return res;\n};"}
{"id": "1314", "path": "output2\\js\\Medium\\1314-path-with-minimum-effort.js", "hypo_code": "_x000D_\nvar minimumEffortPath = function(heights) {\n    let m = heights.length;\n    let n = heights[0].length;\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let queue = [];\n    queue.push([0, 0]);\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    while (queue.length) {\n        let cur = queue.shift();\n        if (visited[cur[0]][cur[1]]) continue;\n        visited[cur[0]][cur[1]] = true;\n        for (let dir of dirs) {\n            let x = cur[0] + dir[0];\n            let y = cur[1] + dir[1];\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\n            let diff = Math.abs(heights[cur[0]][cur[1]] - heights[x][y]);\n            queue.push([x, y, Math.max(diff, cur[2])]);\n        }\n    }\n    return visited[m - 1][n - 1];\n};"}
{"id": "1315", "path": "output2\\js\\Medium\\1315-widest-vertical-area-between-two-points-containing-no-points.js", "hypo_code": "var maxWidthOfVerticalArea = function(points) {\n    let xs = points.map(p => p[0]).sort((a, b) => a - b);\n    let max = 0;\n    for (let i = 1; i < xs.length; i++) {\n        max = Math.max(max, xs[i] - xs[i - 1]);\n    }\n    return max;\n};"}
{"id": "1316", "path": "output2\\js\\Medium\\1316-count-substrings-that-differ-by-one-character.js", "hypo_code": "var countSubstrings = function(s, t) { \n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        for (let j = 0; j < t.length; j++) {\n            let diff = 0;\n            for (let k = 0; i + k < s.length && j + k < t.length; k++) {\n                diff += s[i + k] !== t[j + k] ? 1 : 0;\n                if (diff === 1) count++;\n                if (diff > 1) break;\n            }\n        }\n    }\n    return count;\n};"}
{"id": "1317", "path": "output2\\js\\Medium\\1317-count-sorted-vowel-strings.js", "hypo_code": "var countVowelStrings = function(n) {\n    let dp = Array.from(new Array(n + 1), () => new Array(6).fill(0));\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j < 6; j++) {\n            if (i === 1) dp[i][j] = j;\n            else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[n][5];\n};"}
{"id": "1318", "path": "output2\\js\\Medium\\1318-furthest-building-you-can-reach.js", "hypo_code": "var furthestBuilding = function(heights, bricks, ladders) {\n    let queue = [];\n    for (let i = 1; i < heights.length; i++) {\n        let diff = heights[i] - heights[i - 1];\n        if (diff > 0) {\n            queue.push(diff);\n        }\n        if (queue.length > ladders) {\n            queue.sort((a, b) => a - b);\n            bricks -= queue.shift();\n            if (bricks < 0) return i - 1;\n        }\n    }\n    return heights.length - 1;\n};"}
{"id": "1319", "path": "output2\\js\\Medium\\1319-minimum-deletions-to-make-character-frequencies-unique.js", "hypo_code": "var minDeletions = function(s) {\n    let map = {};\n    for (let c of s) {\n        map[c] = map[c] + 1 || 1;\n    }\n    let set = new Set();\n    let count = 0;\n    for (let key in map) {\n        while (set.has(map[key])) {\n            map[key]--;\n            count++;\n        }\n        if (map[key] !== 0) set.add(map[key]);\n    }\n    return count;\n};"}
{"id": "1320", "path": "output2\\js\\Medium\\1320-sell-diminishing-valued-colored-balls.js", "hypo_code": "var maxProfit = function(inventory, orders) {\n    let mod = 1000000007;\n    inventory.sort((a, b) => b - a);\n    let res = 0;\n    for (let i = 0; i < inventory.length; i++) {\n        if (orders <= 0) break;\n        let cur = inventory[i];\n        let next = i === inventory.length - 1 ? 0 : inventory[i + 1];\n        let diff = cur - next;\n        let count = diff * (i + 1);\n        if (count < orders) {\n            let sum = (cur + next + 1) * diff / 2 * (i + 1);\n            res += sum;\n            orders -= count;\n        } else {\n            let rows = Math.floor(orders / (i + 1));\n            let cols = orders % (i + 1);\n            let sum = (cur + cur - rows + 1) * rows / 2 * (i + 1) + (cur - rows) * cols;\n            res += sum;\n            orders = 0;\n        }\n    }\n    return res % mod;\n};"}
{"id": "1321", "path": "output2\\js\\Medium\\1321-minimum-deletions-to-make-string-balanced.js", "hypo_code": "var minimumDeletions = function(s) {\n    let bCount = 0;\n    let res = 0;\n    for (let c of s) {\n        if (c === 'a') {\n            res = Math.min(bCount, res + 1);\n        } else {\n            bCount++;\n        }\n    }\n    return res;\n};"}
{"id": "1322", "path": "output2\\js\\Medium\\1322-minimum-jumps-to-reach-home.js", "hypo_code": "var minimumJumps = function(forbidden, a, b, x) {\n    let visited = new Set();\n    for (let i = 0; i < forbidden.length; i++) {\n        visited.add(`${forbidden[i]}-0`);\n        visited.add(`${forbidden[i]}-1`);\n    }\n    let queue = [[0, 0, 0]];\n    while (queue.length) {\n        let [pos, step, dir] = queue.shift();\n        if (pos === x) return step;\n        if (visited.has(`${pos}-${dir}`)) continue;\n        visited.add(`${pos}-${dir}`);\n        if (dir === 0 && pos - b >= 0) {\n            queue.push([pos - b, step + 1, 1]);\n        }\n        if (dir === 1 && pos + a <= 6000) {\n            queue.push([pos + a, step + 1, 0]);\n        }\n    }\n    return -1;\n};"}
{"id": "1323", "path": "output2\\js\\Medium\\1323-determine-if-two-strings-are-close.js", "hypo_code": "var closeStrings = function(word1, word2) { \n    if (word1.length !== word2.length) return false;\n    let count1 = new Array(26).fill(0);\n    let count2 = new Array(26).fill(0);\n    let set1 = new Set();\n    let set2 = new Set();\n    for (let i = 0; i < word1.length; i++) {\n        count1[word1.charCodeAt(i) - 97]++;\n        set1.add(word1[i]);\n        count2[word2.charCodeAt(i) - 97]++;\n        set2.add(word2[i]);\n    }\n    count1.sort((a, b) => a - b);\n    count2.sort((a, b) => a - b);\n    return count1.join('') === count2.join('') && set1.size === set2.size;\n\n};"}
{"id": "1324", "path": "output2\\js\\Medium\\1324-minimum-operations-to-reduce-x-to-zero.js", "hypo_code": "var minOperations = function(nums, x) {\n    let sum = nums.reduce((a, b) => a + b);\n    if (sum < x) return -1;\n    let target = sum - x;\n    let max = 0;\n    let l = 0;\n    let cur = 0;\n    for (let r = 0; r < nums.length; r++) {\n        cur += nums[r];\n        while (cur > target && l <= r) {\n            cur -= nums[l++];\n        }\n        if (cur === target) {\n            max = Math.max(max, r - l + 1);\n        }\n    }\n    return max === 0 ? -1 : nums.length - max;\n};"}
{"id": "1325", "path": "output2\\js\\Medium\\1325-smallest-string-with-a-given-numeric-value.js", "hypo_code": "var getSmallestString = function(n, k) {\n    let res = '';\n    for (let i = 0; i < n; i++) {\n        let max = k - (n - i - 1) * 26;\n        let min = k - (n - i - 1) * 1;\n        if (max <= 0) {\n            res += 'a';\n            k--;\n        } else if (min >= 26) {\n            res += 'z';\n            k -= 26;\n        } else {\n            res += String.fromCharCode(min + 96);\n            k -= min;\n        }\n    }\n    return res;\n};"}
{"id": "1326", "path": "output2\\js\\Medium\\1326-ways-to-make-a-fair-array.js", "hypo_code": "var waysToMakeFair = function(nums) {\n    let even = 0;\n    let odd = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (i % 2 === 0) {\n            even += nums[i];\n        } else {\n            odd += nums[i];\n        }\n    }\n    let res = 0;\n    let curEven = 0;\n    let curOdd = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (i % 2 === 0) {\n            even -= nums[i];\n        } else {\n            odd -= nums[i];\n        }\n        if (curEven + odd === curOdd + even) {\n            res++;\n        }\n        if (i % 2 === 0) {\n            curEven += nums[i];\n        } else {\n            curOdd += nums[i];\n        }\n    }\n    return res;\n};"}
{"id": "1327", "path": "output2\\js\\Medium\\1327-merge-in-between-linked-lists.js", "hypo_code": "var mergeInBetween = function(list1, a, b, list2) {\n    let dummy = new ListNode(0, list1);\n    let cur = dummy;\n    for (let i = 0; i < a; i++) {\n        cur = cur.next;\n    }\n    let start = cur;\n    for (let i = a; i <= b; i++) {\n        cur = cur.next;\n    }\n    let end = cur.next;\n    start.next = list2;\n    while (list2.next) {\n        list2 = list2.next;\n    }\n    list2.next = end;\n    return dummy.next;\n};"}
{"id": "1329", "path": "output2\\js\\Medium\\1329-find-the-most-competitive-subsequence.js", "hypo_code": "var mostCompetitive = function(nums, k) {\n    let stack = [];\n    for (let i = 0; i < nums.length; i++) {\n        while (stack.length > 0 && nums[i] < stack[stack.length - 1] && stack.length + nums.length - i > k) {\n            stack.pop();\n        }\n        if (stack.length < k) {\n            stack.push(nums[i]);\n        }\n    }\n    return stack;\n    \n};"}
{"id": "1330", "path": "output2\\js\\Medium\\1330-minimum-moves-to-make-array-complementary.js", "hypo_code": "var minMoves = function(nums, limit) {\n    let n = nums.length;\n    let diff = new Array(2 * limit + 2).fill(0);\n    for (let i = 0; i < n / 2; i++) {\n        let a = nums[i];\n        let b = nums[n - 1 - i];\n        diff[2] += 2;\n        diff[Math.min(a, b) + 1] -= 1;\n        diff[a + b] -= 1;\n        diff[a + b + 1] += 1;\n        diff[Math.max(a, b) + limit + 1] += 1;\n    }\n    let res = n;\n    let cur = 0;\n    for (let i = 2; i <= 2 * limit; i++) {\n        cur += diff[i];\n        res = Math.min(res, cur);\n    }\n    return res;\n    \n};"}
{"id": "1331", "path": "output2\\js\\Medium\\1331-max-number-of-k-sum-pairs.js", "hypo_code": "var maxOperations = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let l = 0;\n    let r = nums.length - 1;\n    let res = 0;\n    while (l < r) {\n        if (nums[l] + nums[r] === k) {\n            res++;\n            l++;\n            r--;\n        } else if (nums[l] + nums[r] > k) {\n            r--;\n        } else {\n            l++;\n        }\n    }\n    return res;\n};"}
{"id": "1332", "path": "output2\\js\\Medium\\1332-concatenation-of-consecutive-binary-numbers.js", "hypo_code": "var concatenatedBinary = function(n) {\n    let res = 0;\n    let mod = 10 ** 9 + 7;\n    for (let i = 1; i <= n; i++) {\n        let bits = i.toString(2);\n        for (let j = 0; j < bits.length; j++) {\n            res = (res * 2 + parseInt(bits[j])) % mod;\n        }\n    }\n    return res;\n};"}
{"id": "1333", "path": "output2\\js\\Medium\\1333-sum-of-absolute-differences-in-a-sorted-array.js", "hypo_code": "var getSumAbsoluteDifferences = function(nums) {\n    let n = nums.length;\n    let result = new Array(n).fill(0);\n    let prefix = new Array(n).fill(0);\n    for (let i = 1; i < n; i++) {\n        prefix[i] = prefix[i - 1] + nums[i - 1];\n    }\n    let suffix = new Array(n).fill(0);\n    for (let i = n - 2; i >= 0; i--) {\n        suffix[i] = suffix[i + 1] + nums[i + 1];\n    }\n    for (let i = 0; i < n; i++) {\n        result[i] = nums[i] * i - prefix[i] + suffix[i] - nums[i] * (n - i - 1);\n    }\n    return result;\n    \n};"}
{"id": "1334", "path": "output2\\js\\Medium\\1334-stone-game-vi.js", "hypo_code": "var stoneGameVI = function(aliceValues, bobValues) {\n    let n = aliceValues.length;\n    let sum = 0;\n    let alice = 0;\n    let bob = 0;\n    let arr = [];\n    for (let i = 0; i < n; i++) {\n        arr.push([aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]]);\n    }\n    arr.sort((a, b) => b[0] - a[0]);\n    for (let i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            alice += arr[i][1];\n        } else {\n            bob += arr[i][2];\n        }\n    }\n    if (alice > bob) {\n        return 1;\n    } else if (alice < bob) {\n        return -1;\n    } else {\n        return 0;\n    }\n    \n};"}
{"id": "1335", "path": "output2\\js\\Medium\\1335-partitioning-into-minimum-number-of-deci-binary-numbers.js", "hypo_code": "var minPartitions = function(n) {\n    let max = 0;\n    for (let i = 0; i < n.length; i++) {\n        max = Math.max(max, n[i]);\n    }\n    return max;\n    \n\n};"}
{"id": "1336", "path": "output2\\js\\Medium\\1336-stone-game-vii.js", "hypo_code": "var stoneGameVII = function(stones) {\n    let n = stones.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    let sum = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; i++) {\n        sum[i] = sum[i - 1] + stones[i - 1];\n    }\n    for (let i = n - 2; i >= 0; i--) {\n        for (let j = i + 1; j < n; j++) {\n            dp[i][j] = Math.max(sum[j + 1] - sum[i + 1] - dp[i + 1][j], sum[j] - sum[i] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1];\n    \n};"}
{"id": "1337", "path": "output2\\js\\Medium\\1337-maximum-erasure-value.js", "hypo_code": "var maximumUniqueSubarray = function(nums) {\n    let n = nums.length;\n    let result = 0;\n    let sum = 0;\n    let set = new Set();\n    let left = 0;\n    for (let right = 0; right < n; right++) {\n        while (set.has(nums[right])) {\n            set.delete(nums[left]);\n            sum -= nums[left];\n            left++;\n        }\n        set.add(nums[right]);\n        sum += nums[right];\n        result = Math.max(result, sum);\n    }\n    return result;\n    \n};"}
{"id": "1338", "path": "output2\\js\\Medium\\1338-jump-game-vi.js", "hypo_code": "var maxResult = function(nums, k) {\n    let n = nums.length;\n    let dp = new Array(n).fill(0);\n    dp[0] = nums[0];\n    let queue = [0];\n    for (let i = 1; i < n; i++) {\n        while (queue.length > 0 && queue[0] < i - k) {\n            queue.shift();\n        }\n        dp[i] = dp[queue[0]] + nums[i];\n        while (queue.length > 0 && dp[queue[queue.length - 1]] <= dp[i]) {\n            queue.pop();\n        }\n        queue.push(i);\n    }\n    return dp[n - 1];\n    \n};"}
{"id": "1339", "path": "output2\\js\\Medium\\1339-average-waiting-time.js", "hypo_code": "var averageWaitingTime = function(customers) {\n    let n = customers.length;\n    let result = 0;\n    let time = 0;\n    for (let i = 0; i < n; i++) {\n        let [arrival, timeToPrepare] = customers[i];\n        if (time < arrival) {\n            time = arrival;\n        }\n        time += timeToPrepare;\n        result += time - arrival;\n    }\n    return result / n;\n    \n};"}
{"id": "1340", "path": "output2\\js\\Medium\\1340-maximum-binary-string-after-change.js", "hypo_code": "var maximumBinaryString = function(binary) {\n    let n = binary.length;\n    let count = 0;\n    let first = 0;\n    for (let i = 0; i < n; i++) {\n        if (binary[i] == '0') {\n            count++;\n        } else if (count > 0) {\n            first = i;\n            break;\n        }\n    }\n    return '1'.repeat(first) + '0'.repeat(count - 1) + '1'.repeat(n - first - count + 1);\n    \n};"}
{"id": "1341", "path": "output2\\js\\Medium\\1341-maximum-number-of-eaten-apples.js", "hypo_code": "var eatenApples = function(apples, days) {\n    let n = apples.length;\n    let res = 0;\n    let q = [];\n    for (let i = 0; i < n || q.length; i++) {\n        if (i < n && apples[i]) {\n            q.push([i + days[i], apples[i]]);\n        }\n        while (q.length && (q[0][0] <= i || q[0][1] == 0)) {\n            q.shift();\n        }\n        if (q.length) {\n            res++;\n            q[0][1]--;\n        }\n    }\n    return res;\n    \n};"}
{"id": "1342", "path": "output2\\js\\Medium\\1342-where-will-the-ball-fall.js", "hypo_code": "var findBall = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let result = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        result[i] = i;\n    }\n    for (let i = 0; i < m; i++) {\n        let next = new Array(n).fill(-1);\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                if (j + 1 < n && grid[i][j + 1] == 1) {\n                    next[j + 1] = result[j];\n                }\n            } else {\n                if (j - 1 >= 0 && grid[i][j - 1] == -1) {\n                    next[j - 1] = result[j];\n                }\n            }\n        }\n        result = next;\n    }\n    return result;\n    \n};"}
{"id": "1343", "path": "output2\\js\\Medium\\1343-count-good-meals.js", "hypo_code": "var countPairs = function(deliciousness) {\n    let max = Math.max(...deliciousness);\n    let maxSum = 2 * max;\n    let map = {};\n    let res = 0;\n    for (let i = 0; i < deliciousness.length; i++) {\n        let cur = deliciousness[i];\n        for (let sum = 1; sum <= maxSum; sum <<= 1) {\n            let target = sum - cur;\n            if (target in map) {\n                res += map[target];\n                res %= 1000000007;\n            }\n        }\n        map[cur] = (map[cur] || 0) + 1;\n    }\n    return res;\n};"}
{"id": "1344", "path": "output2\\js\\Medium\\1344-ways-to-split-array-into-three-subarrays.js", "hypo_code": "var waysToSplit = function(nums) {\n    let mod = 10 ** 9 + 7;\n    let res = 0;\n    let l = 0;\n    let r = 0;\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n    }\n    let left = 0;\n    let right = sum;\n    for (let i = 0; i < nums.length - 2; i++) {\n        left += nums[i];\n        right -= nums[i];\n        l = i + 1;\n        r = i + 1;\n        while (l < nums.length - 1 && left > sum - left - right) {\n            left -= nums[l++];\n        }\n        while (r < nums.length - 1 && right >= left) {\n            right -= nums[r++];\n        }\n        if (left <= right) {\n            res = (res + r - l) % mod;\n        }\n    }\n    return res;\n};"}
{"id": "1345", "path": "output2\\js\\Medium\\1345-maximum-score-from-removing-substrings.js", "hypo_code": "var maximumGain = function(s, x, y) {\n    let n = s.length;\n    let stack = [];\n    let result = 0;\n    let a = 'a'.charCodeAt(0);\n    let b = 'b'.charCodeAt(0);\n    let ab = 'ab'.charCodeAt(0);\n    let ba = 'ba'.charCodeAt(0);\n    for (let i = 0; i < n; i++) {\n        let c = s.charCodeAt(i);\n        if (c == a || c == b) {\n            stack.push(c);\n        } else {\n            if (stack.length >= 2) {\n                let last = stack[stack.length - 1];\n                let secondLast = stack[stack.length - 2];\n                if (last + secondLast == ab) {\n                    result += x;\n                    stack.pop();\n                    stack.pop();\n                } else if (last + secondLast == ba) {\n                    result += y;\n                    stack.pop();\n                    stack.pop();\n                }\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1346", "path": "output2\\js\\Medium\\1346-construct-the-lexicographically-largest-valid-sequence.js", "hypo_code": "var constructDistancedSequence = function(n) {\n    let result = new Array(2 * n - 1).fill(0);\n    let visited = new Array(n + 1).fill(false);\n    let dfs = function(index) {\n        if (index == result.length) {\n            return true;\n        }\n        if (result[index] != 0) {\n            return dfs(index + 1);\n        }\n        for (let i = n; i >= 1; i--) {\n            if (visited[i]) {\n                continue;\n            }\n            if (i == 1 || index + i < result.length && result[index + i] == 0) {\n                visited[i] = true;\n                result[index] = i;\n                if (i > 1) {\n                    result[index + i] = i;\n                }\n                if (dfs(index + 1)) {\n                    return true;\n                }\n                visited[i] = false;\n                result[index] = 0;\n                if (i > 1) {\n                    result[index + i] = 0;\n                }\n            }\n        }\n        return false;\n    }\n    dfs(0);\n    return result;\n    \n};"}
{"id": "1347", "path": "output2\\js\\Medium\\1347-swapping-nodes-in-a-linked-list.js", "hypo_code": "var swapNodes = function(head, k) {\n    let n = 0;\n    let node = head;\n    while (node != null) {\n        n++;\n        node = node.next;\n    }\n    let first = head;\n    for (let i = 1; i < k; i++) {\n        first = first.next;\n    }\n    let second = head;\n    for (let i = 1; i < n - k + 1; i++) {\n        second = second.next;\n    }\n    let temp = first.val;\n    first.val = second.val;\n    second.val = temp;\n    return head;\n    \n};"}
{"id": "1348", "path": "output2\\js\\Medium\\1348-minimize-hamming-distance-after-swap-operations.js", "hypo_code": "var minimumHammingDistance = function(source, target, allowedSwaps) {\n    let n = source.length;\n    let uf = new UnionFind(n);\n    for (let i = 0; i < allowedSwaps.length; i++) {\n        let [a, b] = allowedSwaps[i];\n        uf.union(a, b);\n    }\n    let groups = new Map();\n    for (let i = 0; i < n; i++) {\n        let parent = uf.find(i);\n        if (!groups.has(parent)) {\n            groups.set(parent, []);\n        }\n        groups.get(parent).push(i);\n    }\n    let result = 0;\n    for (let group of groups.values()) {\n        let count = new Map();\n        for (let i of group) {\n            count.set(source[i], (count.get(source[i]) || 0) + 1);\n        }\n        for (let i of group) {\n            if (count.get(target[i])) {\n                count.set(target[i], count.get(target[i]) - 1);\n            } else {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n\n    \n};"}
{"id": "1349", "path": "output2\\js\\Medium\\1349-tuple-with-same-product.js", "hypo_code": "var tupleSameProduct = function(nums) {\n    let n = nums.length;\n    let map = new Map();\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            let product = nums[i] * nums[j];\n            if (map.has(product)) {\n                result += 8 * map.get(product);\n                map.set(product, map.get(product) + 1);\n            } else {\n                map.set(product, 1);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1350", "path": "output2\\js\\Medium\\1350-largest-submatrix-with-rearrangements.js", "hypo_code": "var largestSubmatrix = function(matrix) {\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let heights = new Array(n).fill(0);\n    let result = 0;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (matrix[i][j] == 0) {\n                heights[j] = 0;\n            } else {\n                heights[j]++;\n            }\n        }\n        let sorted = heights.slice();\n        sorted.sort((a, b) => a - b);\n        for (let j = 0; j < n; j++) {\n            result = Math.max(result, sorted[j] * (n - j));\n        }\n    }\n    return result;\n    \n};"}
{"id": "1351", "path": "output2\\js\\Medium\\1351-minimum-number-of-people-to-teach.js", "hypo_code": "var minimumTeachings = function(n, languages, friendships) {\n    let map = new Map();\n    let set = new Set();\n    let count = 0;\n    for(let i = 0; i < languages.length; i++){\n        for(let j = 0; j < languages[i].length; j++){\n            if(map.has(languages[i][j])){\n                map.get(languages[i][j]).push(i);\n            }else{\n                map.set(languages[i][j], [i]);\n            }\n        }\n    }\n    for(let i = 0; i < friendships.length; i++){\n        let [u, v] = friendships[i];\n        let flag = false;\n        for(let j = 0; j < languages[u-1].length; j++){\n            if(map.get(languages[u-1][j]).includes(v-1)){\n                flag = true;\n                break;\n            }\n        }\n        if(!flag){\n            set.add(u);\n            set.add(v);\n        }\n    }\n    return set.size;\n    \n};"}
{"id": "1352", "path": "output2\\js\\Medium\\1352-decode-xored-permutation.js", "hypo_code": "var decode = function(encoded) {\n    let n = encoded.length + 1;\n    let total = 0;\n    for(let i = 1; i <= n; i++){\n        total ^= i;\n    }\n    let odd = 0;\n    for(let i = 1; i < n - 1; i += 2){\n        odd ^= encoded[i];\n    }\n    let perm = new Array(n);\n    perm[0] = total ^ odd;\n    for(let i = 0; i < n - 1; i++){\n        perm[i+1] = perm[i] ^ encoded[i];\n    }\n    return perm;\n    \n};"}
{"id": "1353", "path": "output2\\js\\Medium\\1353-change-minimum-characters-to-satisfy-one-of-three-conditions.js", "hypo_code": "var minCharacters = function(a, b) {\n    let map1 = new Map();\n    let map2 = new Map();\n    let res = Infinity;\n    for(let i = 0; i < a.length; i++){\n        if(map1.has(a[i])){\n            map1.set(a[i], map1.get(a[i]) + 1);\n        }else{\n            map1.set(a[i], 1);\n        }\n    }\n    for(let i = 0; i < b.length; i++){\n        if(map2.has(b[i])){\n            map2.set(b[i], map2.get(b[i]) + 1);\n        }else{\n            map2.set(b[i], 1);\n        }\n    }\n    let count1 = 0;\n    let count2 = 0;\n    for(let i = 0; i < 26; i++){\n        let c = String.fromCharCode(97 + i);\n        if(map1.has(c)){\n            count1 += map1.get(c);\n        }\n        if(map2.has(c)){\n            count2 += map2.get(c);\n        }\n        res = Math.min(res, a.length + b.length - count1 - count2);\n    }\n    count1 = 0;\n    count2 = 0;\n    for(let i = 0; i < 25; i++){\n        let c = String.fromCharCode(97 + i);\n        if(map1.has(c)){\n            count1 += map1.get(c);\n        }\n        if(map2.has(c)){\n            count2 += map2.get(c);\n        }\n        res = Math.min(res, a.length - count1 + count2);\n        res = Math.min(res, b.length - count2 + count1);\n    }\n    return res;\n    \n};"}
{"id": "1354", "path": "output2\\js\\Medium\\1354-find-kth-largest-xor-coordinate-value.js", "hypo_code": "var kthLargestValue = function(matrix, k) {\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let dp = new Array(m);\n    for (let i = 0; i < m; i++) {\n        dp[i] = new Array(n).fill(0);\n    }\n    let res = [];\n    dp[0][0] = matrix[0][0];\n    res.push(dp[0][0]);\n    for (let i = 1; i < m; i++) {\n        dp[i][0] = dp[i - 1][0] ^ matrix[i][0];\n        res.push(dp[i][0]);\n    }\n    for (let j = 1; j < n; j++) {\n        dp[0][j] = dp[0][j - 1] ^ matrix[0][j];\n        res.push(dp[0][j]);\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] ^ dp[i][j - 1] ^ dp[i - 1][j - 1] ^ matrix[i][j];\n            res.push(dp[i][j]);\n        }\n    }\n    res.sort((a, b) => b - a);\n    return res[k - 1];\n    \n};"}
{"id": "1355", "path": "output2\\js\\Medium\\1355-restore-the-array-from-adjacent-pairs.js", "hypo_code": "var restoreArray = function(adjacentPairs) {\n    const map = new Map();\n    for (const [u, v] of adjacentPairs) {\n        map.set(u, (map.get(u) || new Set()).add(v));\n        map.set(v, (map.get(v) || new Set()).add(u));\n    }\n    const res = [];\n    for (const [key, val] of map) {\n        if (val.size === 1) {\n            res.push(key);\n            res.push(...val);\n            break;\n        }\n    }\n    while (res.length < adjacentPairs.length + 1) {\n        const next = map.get(res[res.length - 1]);\n        if (next.has(res[res.length - 2])) {\n            res.push(...next);\n        } else {\n            res.push(...next.values());\n        }\n    }\n    return res;\n};"}
{"id": "1356", "path": "output2\\js\\Medium\\1356-can-you-eat-your-favorite-candy-on-your-favorite-day.js", "hypo_code": "var canEat = function(candiesCount, queries) {\n    let preSum = [];\n    let cur = 0;\n    for (let i = 0; i < candiesCount.length; i++) {\n        cur += candiesCount[i];\n        preSum.push(cur);\n    }\n    let res = [];\n    for (let i = 0; i < queries.length; i++) {\n        let [type, day, cap] = queries[i];\n        let min = day + 1;\n        let max = (day + 1) * cap;\n        let left = type === 0 ? 1 : preSum[type - 1] + 1;\n        let right = preSum[type];\n        res.push(!(min > right || max < left));\n    }\n    return res;\n};"}
{"id": "1357", "path": "output2\\js\\Medium\\1357-maximum-absolute-sum-of-any-subarray.js", "hypo_code": "var maxAbsoluteSum = function(nums) {\n    let max = 0;\n    let min = 0;\n    let curMax = 0;\n    let curMin = 0;\n    for (let i = 0; i < nums.length; i++) {\n        curMax = Math.max(curMax + nums[i], nums[i]);\n        max = Math.max(max, curMax);\n        curMin = Math.min(curMin + nums[i], nums[i]);\n        min = Math.min(min, curMin);\n    }\n    return Math.max(max, Math.abs(min));\n};"}
{"id": "1358", "path": "output2\\js\\Medium\\1358-minimum-length-of-string-after-deleting-similar-ends.js", "hypo_code": "var minimumLength = function(s) {\n    let l = 0;\n    let r = s.length - 1;\n    while (l < r && s[l] === s[r]) {\n        let c = s[l];\n        while (l <= r && s[l] === c) {\n            l++;\n        }\n        while (l <= r && s[r] === c) {\n            r--;\n        }\n    }\n    return l > r ? 0 : r - l + 1;\n};"}
{"id": "1359", "path": "output2\\js\\Medium\\1359-maximum-score-from-removing-stones.js", "hypo_code": "var maximumScore = function(a, b, c) {\n    let xs = [a, b, c].sort((a, b) => a - b);\n    let res = 0;\n    while (xs[1] > 0) {\n        xs[1]--;\n        xs[2]--;\n        xs.sort((a, b) => a - b);\n        res++;\n    }\n    return res;\n};"}
{"id": "1360", "path": "output2\\js\\Medium\\1360-largest-merge-of-two-strings.js", "hypo_code": "var largestMerge = function(word1, word2) {\n    let res = '';\n    while (word1.length && word2.length) {\n        if (word1 > word2) {\n            res += word1[0];\n            word1 = word1.substring(1);\n        } else {\n            res += word2[0];\n            word2 = word2.substring(1);\n        }\n    }\n    res += word1 + word2;\n    return res;\n\n};"}
{"id": "1361", "path": "output2\\js\\Medium\\1361-count-number-of-homogenous-substrings.js", "hypo_code": "var countHomogenous = function(s) {\n    let res = 0;\n    let mod = 10 ** 9 + 7;\n    let count = 0;\n    let prev = '';\n    for (let c of s) {\n        if (c === prev) {\n            count++;\n        } else {\n            count = 1;\n        }\n        res = (res + count) % mod;\n        prev = c;\n    }\n    return res;\n};"}
{"id": "1362", "path": "output2\\js\\Medium\\1362-minimum-limit-of-balls-in-a-bag.js", "hypo_code": "var minimumSize = function(nums, maxOperations) {\n    let l = 1;\n    let r = Math.max(...nums);\n    while (l < r) {\n        let mid = Math.floor((l + r) / 2);\n        let count = 0;\n        for (let i = 0; i < nums.length; i++) {\n            count += Math.ceil(nums[i] / mid) - 1;\n        }\n        if (count > maxOperations) {\n            l = mid + 1;\n        } else {\n            r = mid;\n        }\n    }\n    return l;\n};"}
{"id": "1363", "path": "output2\\js\\Medium\\1363-form-array-by-concatenating-subarrays-of-another-array.js", "hypo_code": "var canChoose = function(groups, nums) {\n    let i = 0;\n    let j = 0;\n    while (i < nums.length && j < groups.length) {\n        let flag = true;\n        for (let k = 0; k < groups[j].length; k++) {\n            if (nums[i + k] !== groups[j][k]) {\n                flag = false;\n                i++;\n                break;\n            }\n        }\n        if (flag) {\n            i += groups[j].length;\n            j++;\n        }\n    }\n    return j === groups.length;\n};"}
{"id": "1364", "path": "output2\\js\\Medium\\1364-map-of-highest-peak.js", "hypo_code": "var highestPeak = function(isWater) {\n    let m = isWater.length;\n    let n = isWater[0].length;\n    let queue = [];\n    let res = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++){\n            if (isWater[i][j] === 1) {\n                queue.push([i, j]);\n                visited[i][j] = true;\n            }\n        }\n    }\n    let level = 0;\n    while (queue.length) {\n        let size = queue.length;\n        for (let i = 0; i < size; i++) {\n            let cur = queue.shift();\n            res[cur[0]][cur[1]] = level;\n            for (let dir of dirs) {\n                let x = cur[0] + dir[0];\n                let y = cur[1] + dir[1];\n                if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\n                queue.push([x, y]);\n                visited[x][y] = true;\n            }\n        }\n        level++;\n    }\n    return res;\n};"}
{"id": "1365", "path": "output2\\js\\Medium\\1365-minimum-number-of-operations-to-move-all-balls-to-each-box.js", "hypo_code": "var minOperations = function(boxes) {\n    let res = [];\n    for (let i = 0; i < boxes.length; i++) {\n        let sum = 0;\n        for (let j = 0; j < boxes.length; j++) {\n            if (i !== j && boxes[j] === '1') {\n                sum += Math.abs(i - j);\n            }\n        }\n        res.push(sum);\n    }\n    return res;\n};"}
{"id": "1366", "path": "output2\\js\\Medium\\1366-closest-dessert-cost.js", "hypo_code": "var closestCost = function(baseCosts, toppingCosts, target) {\n    let res = Infinity;\n    let minDiff = Infinity;\n    for (let base of baseCosts) {\n        let stack = [];\n        stack.push(base);\n        while (stack.length > 0) {\n            let cur = stack.pop();\n            let diff = Math.abs(cur - target);\n            if (diff < minDiff) {\n                minDiff = diff;\n                res = cur;\n            } else if (diff === minDiff) {\n                res = Math.min(res, cur);\n            }\n            for (let topping of toppingCosts) {\n                stack.push(cur + topping);\n                stack.push(cur + topping * 2);\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1367", "path": "output2\\js\\Medium\\1367-equal-sum-arrays-with-minimum-number-of-operations.js", "hypo_code": "var minOperations = function(nums1, nums2) {\n    let sum1 = nums1.reduce((a, b) => a + b);\n    let sum2 = nums2.reduce((a, b) => a + b);\n    if (sum1 === sum2) return 0;\n    if (sum1 > sum2) {\n        let temp = nums1;\n        nums1 = nums2;\n        nums2 = temp;\n        let tempSum = sum1;\n        sum1 = sum2;\n        sum2 = tempSum;\n    }\n    let diff = sum2 - sum1;\n    let map = new Map();\n    for (let num of nums1) {\n        map.set(num, (map.get(num) || 0) + 1);\n    }\n    for (let num of nums2) {\n        map.set(num, (map.get(num) || 0) - 1);\n    }\n    let res = 0;\n    for (let i = 5; i >= 1; i--) {\n        while (map.get(i) > 0 && diff > 0) {\n            res++;\n            diff -= i - 1;\n            map.set(i, map.get(i) - 1);\n        }\n    }\n    if (diff > 0) return -1;\n    return res;\n};"}
{"id": "1368", "path": "output2\\js\\Medium\\1368-check-if-number-is-a-sum-of-powers-of-three.js", "hypo_code": "var checkPowersOfThree = function(n) {\n    while (n > 0) {\n        if (n % 3 === 2) return false;\n        n = Math.floor(n / 3);\n    }\n    return true;\n};"}
{"id": "1369", "path": "output2\\js\\Medium\\1369-sum-of-beauty-of-all-substrings.js", "hypo_code": "var beautySum = function(s) {\n    let res = 0;\n    for (let i = 0; i < s.length; i++) {\n        let map = {};\n        for (let j = i; j < s.length; j++) {\n            map[s[j]] = map[s[j]] + 1 || 1;\n            let max = 0;\n            let min = Infinity;\n            for (let key in map) {\n                max = Math.max(max, map[key]);\n                min = Math.min(min, map[key]);\n            }\n            res += max - min;\n        }\n    }\n    return res;\n};"}
{"id": "1370", "path": "output2\\js\\Medium\\1370-minimum-elements-to-add-to-form-a-given-sum.js", "hypo_code": "var minElements = function(nums, limit, goal) {\n    let sum = nums.reduce((a, b) => a + b);\n    let target = Math.abs(goal - sum);\n    return Math.ceil(target / limit);\n};"}
{"id": "1371", "path": "output2\\js\\Medium\\1371-number-of-restricted-paths-from-first-to-last-node.js", "hypo_code": "var countRestrictedPaths = function(n, edges) {\n    let graph = new Map();\n    for (let [u, v, w] of edges) {\n        if (!graph.has(u)) graph.set(u, []);\n        if (!graph.has(v)) graph.set(v, []);\n        graph.get(u).push([v, w]);\n        graph.get(v).push([u, w]);\n    }\n    let dist = new Array(n + 1).fill(Infinity);\n    dist[n] = 0;\n    let pq = [[0, n]];\n    while (pq.length) {\n        let [d, u] = pq.pop();\n        for (let [v, w] of graph.get(u)) {\n            if (d + w < dist[v]) {\n                dist[v] = d + w;\n                pq.push([dist[v], v]);\n            }\n        }\n    }\n    let dp = new Array(n + 1).fill(-1);\n    let dfs = (u) => {\n        if (u === n) return 1;\n        if (dp[u] !== -1) return dp[u];\n        let res = 0;\n        for (let [v, w] of graph.get(u)) {\n            if (dist[u] > dist[v]) {\n                res = (res + dfs(v)) % 1000000007;\n            }\n        }\n        dp[u] = res;\n        return res;\n    }\n    return dfs(1);\n};"}
{"id": "1372", "path": "output2\\js\\Medium\\1372-maximum-average-pass-ratio.js", "hypo_code": "var maxAverageRatio = function(classes, extraStudents) {\n    let queue = new PriorityQueue((a, b) => (a[0] - b[0]) / (a[1] * a[1] + a[1]) < (b[0] - b[1]) / (b[1] * b[1] + b[1]));\n    let sum = 0;\n    for (let i = 0; i < classes.length; i++) {\n        let cur = classes[i];\n        sum += cur[0] / cur[1];\n        queue.push(cur);\n    }\n    while (extraStudents > 0) {\n        let cur = queue.pop();\n        cur[0]++;\n        cur[1]++;\n        sum += 1 / cur[1];\n        queue.push(cur);\n        extraStudents--;\n    }\n    return sum / classes.length;\n};"}
{"id": "1374", "path": "output2\\js\\Medium\\1374-maximum-number-of-consecutive-values-you-can-make.js", "hypo_code": "var getMaximumConsecutive = function(coins) {\n    coins.sort((a, b) => a - b);\n    let res = 0;\n    for (let i = 0; i < coins.length; i++) {\n        if (coins[i] > res + 1) {\n            break;\n        } else {\n            res += coins[i];\n        }\n    }\n    return res + 1;\n};"}
{"id": "1375", "path": "output2\\js\\Medium\\1375-number-of-orders-in-the-backlog.js", "hypo_code": "var getNumberOfBacklogOrders = function(orders) {\n    let mod = 1000000007;\n    let buy = new MaxPriorityQueue({\n        priority: (a, b) => a[0] - b[0]\n    });\n    let sell = new MinPriorityQueue({\n        priority: (a, b) => a[0] - b[0]\n    });\n    for (let [price, amount, type] of orders) {\n        if (type === 0) {\n            while (amount > 0 && sell.size() > 0 && sell.front().element[0] <= price) {\n                let [minPrice, minAmount] = sell.dequeue().element;\n                if (minAmount > amount) {\n                    sell.enqueue([minPrice, minAmount - amount]);\n                    amount = 0;\n                } else {\n                    amount -= minAmount;\n                }\n            }\n            if (amount > 0) {\n                buy.enqueue([price, amount]);\n            }\n        } else {\n            while (amount > 0 && buy.size() > 0 && buy.front().element[0] >= price) {\n                let [maxPrice, maxAmount] = buy.dequeue().element;\n                if (maxAmount > amount) {\n                    buy.enqueue([maxPrice, maxAmount - amount]);\n                    amount = 0;\n                } else {\n                    amount -= maxAmount;\n                }\n            }\n            if (amount > 0) {\n                sell.enqueue([price, amount]);\n            }\n        }\n    }\n    let res = 0;\n    while (buy.size() > 0) {\n        res += buy.dequeue().element[1];\n    }\n    while (sell.size() > 0) {\n        res += sell.dequeue().element[1];\n    }\n    return res % mod;\n};"}
{"id": "1376", "path": "output2\\js\\Medium\\1376-maximum-value-at-a-given-index-in-a-bounded-array.js", "hypo_code": "var maxValue = function(n, index, maxSum) {\n    let l = 1;\n    let r = maxSum;\n    while (l < r) {\n        let m = Math.floor((l + r + 1) / 2);\n        if (check(n, index, maxSum, m)) {\n            l = m;\n        } else {\n            r = m - 1;\n        }\n    }\n    return l;\n};"}
{"id": "1377", "path": "output2\\js\\Medium\\1377-minimum-number-of-operations-to-reinitialize-a-permutation.js", "hypo_code": "var reinitializePermutation = function(n) {\n    let res = 0;\n    let i = 1;\n    while (true) {\n        i = i * 2 % (n - 1);\n        res++;\n        if (i === 1) break;\n    }\n    return res;\n};"}
{"id": "1378", "path": "output2\\js\\Medium\\1378-evaluate-the-bracket-pairs-of-a-string.js", "hypo_code": "var evaluate = function(s, knowledge) {\n    let map = {};\n    for (let [key, value] of knowledge) {\n        map[key] = value;\n    }\n    let res = '';\n    let key = '';\n    let flag = false;\n    for (let c of s) {\n        if (c === '(') flag = true;\n        else if (c === ')') {\n            res += map[key] ? map[key] : '?';\n            key = '';\n            flag = false;\n        } else {\n            if (flag) key += c;\n            else res += c;\n        }\n    }\n    return res;\n};"}
{"id": "1379", "path": "output2\\js\\Medium\\1379-sentence-similarity-iii.js", "hypo_code": "var areSentencesSimilar = function(sentence1, sentence2) {\n    let s1 = sentence1.split(\" \");\n    let s2 = sentence2.split(\" \");\n    let i = 0;\n    let j = 0;\n    let k = s1.length - 1;\n    let l = s2.length - 1;\n    while (i < s1.length && j < s2.length && s1[i] === s2[j]) {\n        i++;\n        j++;\n    }\n    while (k >= 0 && l >= 0 && s1[k] === s2[l]) {\n        k--;\n        l--;\n    }\n    return i > k && j > l;\n    \n};"}
{"id": "1380", "path": "output2\\js\\Medium\\1380-count-nice-pairs-in-an-array.js", "hypo_code": "var countNicePairs = function(nums) {\n    let map = new Map();\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let rev = parseInt(nums[i].toString().split(\"\").reverse().join(\"\"));\n        let diff = nums[i] - rev;\n        if (map.has(diff)) {\n            count = (count + map.get(diff)) % 1000000007;\n            map.set(diff, map.get(diff) + 1);\n        } else {\n            map.set(diff, 1);\n        }\n    }\n    return count;\n    \n};"}
{"id": "1381", "path": "output2\\js\\Medium\\1381-finding-the-users-active-minutes.js", "hypo_code": "var findingUsersActiveMinutes = function(logs, k) {\n    let map = new Map();\n    let result = new Array(k).fill(0);\n    for (let i = 0; i < logs.length; i++) {\n        let id = logs[i][0];\n        let time = logs[i][1];\n        if (map.has(id)) {\n            map.get(id).add(time);\n        } else {\n            map.set(id, new Set([time]));\n        }\n    }\n    for (let [key, value] of map) {\n        result[value.size - 1]++;\n    }\n    return result;\n    \n};"}
{"id": "1382", "path": "output2\\js\\Medium\\1382-minimum-absolute-sum-difference.js", "hypo_code": "var minAbsoluteSumDiff = function(nums1, nums2) {\n    let sum = 0;\n    let max = 0;\n    let set = new Set(nums1);\n    for (let i = 0; i < nums1.length; i++) {\n        let diff = Math.abs(nums1[i] - nums2[i]);\n        sum = (sum + diff) % 1000000007;\n        if (diff > max) {\n            for (let num of set) {\n                let newDiff = Math.abs(num - nums2[i]);\n                max = Math.max(max, diff - newDiff);\n            }\n        }\n    }\n    return (sum - max) % 1000000007;\n    \n};"}
{"id": "1383", "path": "output2\\js\\Medium\\1383-find-the-winner-of-the-circular-game.js", "hypo_code": "var findTheWinner = function(n, k) {\n    let list = [];\n    for (let i = 1; i <= n; i++) {\n        list.push(i);\n    }\n    let i = 0;\n    while (list.length > 1) {\n        i = (i + k - 1) % list.length;\n        list.splice(i, 1);\n    }\n    return list[0];\n};"}
{"id": "1384", "path": "output2\\js\\Medium\\1384-minimum-sideway-jumps.js", "hypo_code": "var minSideJumps = function(obstacles) {\n    let dp = [1, 0, 1];\n    for (let i = 1; i < obstacles.length; i++) {\n        if (obstacles[i] !== 0) {\n            dp[obstacles[i] - 1] = Infinity;\n        }\n        for (let j = 0; j < 3; j++) {\n            if (j !== obstacles[i] - 1) {\n                dp[j] = Math.min(dp[j], dp[(j + 1) % 3] + 1, dp[(j + 2) % 3] + 1);\n            }\n        }\n    }\n    return Math.min(...dp);\n};"}
{"id": "1385", "path": "output2\\js\\Medium\\1385-queries-on-number-of-points-inside-a-circle.js", "hypo_code": "var countPoints = function(points, queries) {\n    let res = [];\n    for (let i = 0; i < queries.length; i++) {\n        let count = 0;\n        for (let j = 0; j < points.length; j++) {\n            let x = points[j][0] - queries[i][0];\n            let y = points[j][1] - queries[i][1];\n            if (x * x + y * y <= queries[i][2] * queries[i][2]) count++;\n        }\n        res.push(count);\n    }\n    return res;\n};"}
{"id": "1386", "path": "output2\\js\\Medium\\1386-maximum-xor-for-each-query.js", "hypo_code": "var getMaximumXor = function(nums, maximumBit) {\n    let res = [];\n    let max = (1 << maximumBit) - 1;\n    let cur = 0;\n    for (let i = 0; i < nums.length; i++) {\n        cur ^= nums[i];\n        res.push(max ^ cur);\n    }\n    return res.reverse();\n};"}
{"id": "1387", "path": "output2\\js\\Medium\\1387-maximum-ice-cream-bars.js", "hypo_code": "var maxIceCream = function(costs, coins) {\n    let count = new Array(100001).fill(0);\n    for (let i = 0; i < costs.length; i++) {\n        count[costs[i]]++;\n    }\n    let res = 0;\n    for (let i = 1; i < count.length; i++) {\n        if (coins >= i) {\n            let cur = Math.min(count[i], Math.floor(coins / i));\n            res += cur;\n            coins -= cur * i;\n        } else {\n            break;\n        }\n    }\n    return res;\n};"}
{"id": "1388", "path": "output2\\js\\Medium\\1388-single-threaded-cpu.js", "hypo_code": "var getOrder = function(tasks) {\n    let res = [];\n    let queue = [];\n    let time = 0;\n    let i = 0;\n    tasks.sort((a, b) => a[0] - b[0]);\n    while (i < tasks.length || queue.length > 0) {\n        if (queue.length === 0) {\n            time = Math.max(time, tasks[i][0]);\n        }\n        while (i < tasks.length && tasks[i][0] <= time) {\n            queue.push([tasks[i][1], tasks[i][0], i]);\n            i++;\n        }\n        queue.sort((a, b) => a[0] - b[0]);\n        let [processingTime, enqueueTime, index] = queue.shift();\n        time += processingTime;\n        res.push(index);\n    }\n    return res;\n};"}
{"id": "1389", "path": "output2\\js\\Medium\\1389-frequency-of-the-most-frequent-element.js", "hypo_code": "var maxFrequency = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let l = 0;\n    let r = 0;\n    let sum = 0;\n    let res = 0;\n    while (r < nums.length) {\n        sum += nums[r];\n        while (sum + k < nums[r] * (r - l + 1)) {\n            sum -= nums[l];\n            l++;\n        }\n        res = Math.max(res, r - l + 1);\n        r++;\n    }\n    return res;\n};"}
{"id": "1390", "path": "output2\\js\\Medium\\1390-longest-substring-of-all-vowels-in-order.js", "hypo_code": "var longestBeautifulSubstring = function(word) {\n    let res = 0;\n    let count = 0;\n    for (let i = 0; i < word.length; i++) {\n        if (i > 0 && word[i - 1] > word[i]) count = 0;\n        if (i > 0 && word[i - 1] === word[i]) continue;\n        count++;\n        if (word[i] === 'u') res = Math.max(res, count);\n    }\n    return res;\n};"}
{"id": "1392", "path": "output2\\js\\Medium\\1392-maximum-element-after-decreasing-and-rearranging.js", "hypo_code": "var maximumElementAfterDecrementingAndRearranging = function(arr) {\n    arr.sort((a, b) => a - b);\n    arr[0] = 1;\n    for (let i = 1; i < arr.length; i++) {\n        arr[i] = Math.min(arr[i], arr[i - 1] + 1);\n    }\n    return arr[arr.length - 1];\n};"}
{"id": "1393", "path": "output2\\js\\Medium\\1393-splitting-a-string-into-descending-consecutive-values.js", "hypo_code": "var splitString = function(s) {\n    if (s.length === 1) return false;\n    let res = false;\n    for (let i = 1; i < s.length; i++) {\n        let cur = s.slice(0, i);\n        if (cur.startsWith('0')) continue;\n        let next = cur - 1;\n        let start = i;\n        let flag = true;\n        while (start < s.length) {\n            let end = start + next.toString().length;\n            if (end > s.length || s.slice(start, end) !== next.toString()) {\n                flag = false;\n                break;\n            }\n            next--;\n            start = end;\n        }\n        if (flag) {\n            res = true;\n            break;\n        }\n    }\n    return res;\n};"}
{"id": "1394", "path": "output2\\js\\Medium\\1394-minimum-adjacent-swaps-to-reach-the-kth-smallest-number.js", "hypo_code": "var getMinSwaps = function(num, k) {\n    let res = 0;\n    let sorted = num.split('').sort();\n    let cur = num.split('');\n    for (let i = 0; i < k; i++) {\n        cur = nextPermutation(cur);\n    }\n    for (let i = 0; i < num.length; i++) {\n        if (cur[i] !== sorted[i]) {\n            let j = i + 1;\n            while (j < num.length && cur[j] !== sorted[i]) {\n                j++;\n            }\n            while (j > i) {\n                let tmp = cur[j];\n                cur[j] = cur[j - 1];\n                cur[j - 1] = tmp;\n                j--;\n                res++;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1395", "path": "output2\\js\\Medium\\1395-maximum-distance-between-a-pair-of-values.js", "hypo_code": "var maxDistance = function(nums1, nums2) {\n    let res = 0;\n    for (let i = 0; i < nums1.length; i++) {\n        let l = i;\n        let r = nums2.length - 1;\n        let j = -1;\n        while (l <= r) {\n            let mid = l + Math.floor((r - l) / 2);\n            if (nums2[mid] >= nums1[i]) {\n                j = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        if (j !== -1) {\n            res = Math.max(res, j - i);\n        }\n    }\n    return res;\n};"}
{"id": "1396", "path": "output2\\js\\Medium\\1396-maximum-subarray-min-product.js", "hypo_code": "var maxSumMinProduct = function(nums) {\n    let mod = 1000000007;\n    let sum = nums.reduce((a, b) => a + b);\n    let max = 0;\n    let l = 0;\n    let cur = 0;\n    for (let r = 0; r < nums.length; r++) {\n        cur += nums[r];\n        while (cur > sum && l <= r) {\n            cur -= nums[l++];\n        }\n        if (cur <= sum) {\n            let min = Math.min(...nums.slice(l, r + 1));\n            max = Math.max(max, min * cur);\n        }\n    }\n    return max % mod;\n};"}
{"id": "1397", "path": "output2\\js\\Medium\\1397-incremental-memory-leak.js", "hypo_code": "var memLeak = function(memory1, memory2) {\n    let i = 1;\n    while (true) {\n        if (memory1 >= memory2) {\n            if (memory1 < i) {\n                return [i, memory1, memory2];\n            }\n            memory1 -= i;\n        } else {\n            if (memory2 < i) {\n                return [i, memory1, memory2];\n            }\n            memory2 -= i;\n        }\n        i++;\n    }\n};"}
{"id": "1398", "path": "output2\\js\\Medium\\1398-rotating-the-box.js", "hypo_code": "var rotateTheBox = function(box) {\n    let m = box.length;\n    let n = box[0].length;\n    let res = new Array(n).fill(0).map(() => new Array(m).fill('.'));\n    for (let i = 0; i < m; i++) {\n        let start = 0;\n        let end = 0;\n        for (let j = 0; j < n; j++) {\n            if (box[i][j] === '*') {\n                start = j + 1;\n                end = j + 1;\n            } else if (box[i][j] === '#') {\n                end = j + 1;\n            }\n        }\n        for (let j = start; j < end; j++) {\n            res[j][m - i - 1] = '#';\n        }\n    }\n    return res;\n};"}
{"id": "1399", "path": "output2\\js\\Medium\\1399-minimum-number-of-swaps-to-make-the-binary-string-alternating.js", "hypo_code": "var minSwaps = function(s) {\n    let zeroCount = 0;\n    let oneCount = 0;\n    for (let c of s) {\n        if (c === '0') zeroCount++;\n        else oneCount++;\n    }\n    if (Math.abs(zeroCount - oneCount) > 1) return -1;\n    if (zeroCount > oneCount) return getSwapCount(s, '0');\n    if (zeroCount < oneCount) return getSwapCount(s, '1');\n    return Math.min(getSwapCount(s, '0'), getSwapCount(s, '1'));\n\n};\nfunction getSwapCount(s, start) {\n    let swapCount = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] !== start) swapCount++;\n        start = start === '0' ? '1' : '0';\n    }\n    return swapCount / 2;\n}"}
{"id": "1401", "path": "output2\\js\\Medium\\1401-minimum-speed-to-arrive-on-time.js", "hypo_code": "var minSpeedOnTime = function(dist, hour) {\n    let left = 1;\n    let right = 10000000;\n    let mid = 0;\n    let result = -1;\n    while(left <= right){\n        mid = Math.floor((left + right) / 2);\n        let time = 0;\n        for(let i = 0; i < dist.length - 1; i++){\n            time += Math.ceil(dist[i] / mid);\n        }\n        time += dist[dist.length - 1] / mid;\n        if(time > hour){\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n            result = mid;\n        }\n    }\n    return result;\n};"}
{"id": "1402", "path": "output2\\js\\Medium\\1402-jump-game-vii.js", "hypo_code": "var canReach = function(s, minJump, maxJump) {\n    let n = s.length;\n    let dp = new Array(n).fill(false);\n    dp[0] = true;\n    let pre = 0;\n    for(let i = 1; i < n; i++){\n        if(i >= minJump){\n            pre += dp[i - minJump] ? 1 : 0;\n        }\n        if(i > maxJump){\n            pre -= dp[i - maxJump - 1] ? 1 : 0;\n        }\n        dp[i] = pre > 0 && s[i] === '0';\n    }\n    return dp[n - 1];\n};"}
{"id": "1403", "path": "output2\\js\\Medium\\1403-minimize-maximum-pair-sum-in-array.js", "hypo_code": "var minPairSum = function(nums) {\n    nums.sort((a, b) => a - b);\n    let result = 0;\n    for(let i = 0; i < nums.length / 2; i++){\n        result = Math.max(result, nums[i] + nums[nums.length - i - 1]);\n    }\n    return result;\n\n};"}
{"id": "1404", "path": "output2\\js\\Medium\\1404-get-biggest-three-rhombus-sums-in-a-grid.js", "hypo_code": "var getBiggestThree = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let result = new Set();\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            let k = 0;\n            while(i + k < m && i - k >= 0 && j + k < n && j - k >= 0){\n                let sum = 0;\n                if(k === 0){\n                    sum = grid[i][j];\n                }else{\n                    sum = grid[i + k][j] + grid[i - k][j] + grid[i][j + k] + grid[i][j - k];\n                    for(let l = 1; l < k; l++){\n                        sum += grid[i + l][j + k - l] + grid[i + l][j - k + l] + grid[i - l][j + k - l] + grid[i - l][j - k + l];\n                    }\n                }\n                result.add(sum);\n                k++;\n            }\n        }\n    }\n    return [...result].sort((a, b) => b - a).slice(0, 3);\n\n};"}
{"id": "1405", "path": "output2\\js\\Medium\\1405-maximum-value-after-insertion.js", "hypo_code": "var maxValue = function(n, x) {\n    if(n[0] === '-'){\n        for(let i = 1; i < n.length; i++){\n            if(n[i] > x){\n                return n.slice(0, i) + x + n.slice(i);\n            }\n        }\n    }else{\n        for(let i = 0; i < n.length; i++){\n            if(n[i] < x){\n                return n.slice(0, i) + x + n.slice(i);\n            }\n        }\n    }\n    return n + x;\n};"}
{"id": "1406", "path": "output2\\js\\Medium\\1406-process-tasks-using-servers.js", "hypo_code": "var assignTasks = function(servers, tasks) {\n    let freeServers = [];\n    let busyServers = [];\n    let result = [];\n    for(let i = 0; i < servers.length; i++){\n        freeServers.push([servers[i], i]);\n    }\n    for(let i = 0; i < tasks.length; i++){\n        while(busyServers.length > 0 && busyServers[0][0] <= i){\n            let [time, index] = busyServers.shift();\n            freeServers.push([servers[index], index]);\n        }\n        freeServers.sort((a, b) => a[0] - b[0]);\n        let [time, index] = freeServers.shift();\n        result.push(index);\n        busyServers.push([time + tasks[i], index]);\n    }\n    return result;\n};"}
{"id": "1407", "path": "output2\\js\\Medium\\1407-egg-drop-with-2-eggs-and-n-floors.js", "hypo_code": "var twoEggDrop = function(n) {\n    let dp = new Array(n + 1).fill(0);\n    dp[1] = 1;\n    dp[2] = 2;\n    for(let i = 3; i <= n; i++){\n        dp[i] = i;\n        for(let j = 1; j < i; j++){\n            dp[i] = Math.min(dp[i], Math.max(j, dp[i - j] + 1));\n        }\n    }\n    return dp[n];\n};"}
{"id": "1408", "path": "output2\\js\\Medium\\1408-reduction-operations-to-make-the-array-elements-equal.js", "hypo_code": "var reductionOperations = function(nums) {\n    let map = new Map();\n    for(let i = 0; i < nums.length; i++){\n        map.set(nums[i], (map.get(nums[i]) || 0) + 1);\n    }\n    let keys = [...map.keys()].sort((a, b) => b - a);\n    let result = 0;\n    for(let i = 0; i < keys.length - 1; i++){\n        result += map.get(keys[i]);\n        map.set(keys[i + 1], map.get(keys[i + 1]) + map.get(keys[i]));\n    }\n    return result;\n};"}
{"id": "1409", "path": "output2\\js\\Medium\\1409-minimum-number-of-flips-to-make-the-binary-string-alternating.js", "hypo_code": "var minFlips = function(s) {\n    let n = s.length;\n    let s1 = '', s2 = '';\n    for(let i = 0; i < n; i++){\n        s1 += i % 2 === 0 ? '1' : '0';\n        s2 += i % 2 === 0 ? '0' : '1';\n    }\n    let result = n;\n    for(let i = 0; i < n; i++){\n        if(s[i] !== s1[i]){\n            result--;\n        }\n    }\n    let result2 = n;\n    for(let i = 0; i < n; i++){\n        if(s[i] !== s2[i]){\n            result2--;\n        }\n    }\n    return Math.min(result, result2);\n};"}
{"id": "1410", "path": "output2\\js\\Medium\\1410-find-the-student-that-will-replace-the-chalk.js", "hypo_code": "var chalkReplacer = function(chalk, k) {\n    let sum = 0;\n    for(let i = 0; i < chalk.length; i++){\n        sum += chalk[i];\n        if(sum > k){\n            return i;\n        }\n    }\n    k %= sum;\n    for(let i = 0; i < chalk.length; i++){\n        if(chalk[i] > k){\n            return i;\n        }\n        k -= chalk[i];\n    }\n};"}
{"id": "1411", "path": "output2\\js\\Medium\\1411-largest-magic-square.js", "hypo_code": "var largestMagicSquare = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let rowSum = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    let colSum = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    let diaSum1 = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    let diaSum2 = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    let result = 1;\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            rowSum[i][j] = rowSum[i][j - 1] + grid[i - 1][j - 1];\n            colSum[i][j] = colSum[i - 1][j] + grid[i - 1][j - 1];\n            diaSum1[i][j] = diaSum1[i - 1][j - 1] + grid[i - 1][j - 1];\n            diaSum2[i][j] = diaSum2[i - 1][j + 1] + grid[i - 1][j - 1];\n        }\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            for(let k = result + 1; k <= Math.min(m - i + 1, n - j + 1); k++){\n                let row = rowSum[i][j + k - 1] - rowSum[i][j - 1];\n                let col = colSum[i + k - 1][j] - colSum[i - 1][j];\n                let dia1 = diaSum1[i + k - 1][j + k - 1] - diaSum1[i - 1][j - 1];\n                let dia2 = diaSum2[i + k - 1][j - 1] - diaSum2[i - 1][j + k + 1];\n                if(row === col && row === dia1 && row === dia2){\n                    result = k;\n                }\n            }\n        }\n    }\n    return result;\n\n};"}
{"id": "1412", "path": "output2\\js\\Medium\\1412-maximum-number-of-removable-characters.js", "hypo_code": "var maximumRemovals = function(s, p, removable) {\n    let left = 0, right = removable.length;\n    while(left < right){\n        let mid = left + right + 1 >> 1;\n        if(check(s, p, removable, mid)){\n            left = mid;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return left;\n};\nfunction check(s, p, removable, k){\n    let arr = new Array(s.length).fill(0);\n    for(let i = 0; i < k; i++){\n        arr[removable[i]] = 1;\n    }\n    let index = 0;\n    for(let i = 0; i < s.length; i++){\n        if(arr[i] === 1){\n            continue;\n        }\n        if(s[i] === p[index]){\n            index++;\n        }\n        if(index === p.length){\n            return true;\n        }\n    }\n    return false;\n}"}
{"id": "1413", "path": "output2\\js\\Medium\\1413-merge-triplets-to-form-target-triplet.js", "hypo_code": "var mergeTriplets = function(triplets, target) {\n    let result = [0, 0, 0];\n    for(let i = 0; i < triplets.length; i++){\n        if(triplets[i][0] <= target[0] && triplets[i][1] <= target[1] && triplets[i][2] <= target[2]){\n            result[0] = Math.max(result[0], triplets[i][0]);\n            result[1] = Math.max(result[1], triplets[i][1]);\n            result[2] = Math.max(result[2], triplets[i][2]);\n        }\n    }\n    return result[0] === target[0] && result[1] === target[1] && result[2] === target[2];\n\n};"}
{"id": "1414", "path": "output2\\js\\Medium\\1414-find-a-peak-element-ii.js", "hypo_code": "var findPeakGrid = function(mat) {\n    let m = mat.length;\n    let n = mat[0].length;\n    let left = 0;\n    let right = n - 1;\n    while(left <= right){\n        let mid = left + Math.floor((right - left) / 2);\n        let maxRow = 0;\n        for(let i = 0; i < m; i++){\n            if(mat[i][mid] > mat[maxRow][mid]){\n                maxRow = i;\n            }\n        }\n        let flag = true;\n        if(mid - 1 >= 0 && mat[maxRow][mid - 1] > mat[maxRow][mid]){\n            right = mid - 1;\n            flag = false;\n        }\n        if(mid + 1 < n && mat[maxRow][mid + 1] > mat[maxRow][mid]){\n            left = mid + 1;\n            flag = false;\n        }\n        if(flag){\n            return [maxRow, mid];\n        }\n    }\n    return [-1, -1];\n};"}
{"id": "1415", "path": "output2\\js\\Medium\\1415-the-number-of-full-rounds-you-have-played.js", "hypo_code": "var numberOfRounds = function(loginTime, logoutTime) {\n    let [h1, m1] = loginTime.split(':');\n    let [h2, m2] = logoutTime.split(':');\n    let t1 = h1 * 60 + m1 * 1;\n    let t2 = h2 * 60 + m2 * 1;\n    if(t1 > t2){\n        t2 += 24 * 60;\n    }\n    let result = 0;\n    for(let i = t1; i <= t2; i += 15){\n        if(i + 15 <= t2){\n            result++;\n        }\n    }\n    return result;\n};"}
{"id": "1416", "path": "output2\\js\\Medium\\1416-count-sub-islands.js", "hypo_code": "var countSubIslands = function(grid1, grid2) {\n    let m = grid1.length;\n    let n = grid1[0].length;\n    let result = 0;\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let dfs = function(i, j){\n        if(i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || grid2[i][j] === 0){\n            return true;\n        }\n        let flag = true;\n        if(grid1[i][j] === 0){\n            flag = false;\n        }\n        visited[i][j] = true;\n        for(let direction of directions){\n            flag = dfs(i + direction[0], j + direction[1]) && flag;\n        }\n        return flag;\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(grid2[i][j] === 1 && !visited[i][j]){\n                if(dfs(i, j)){\n                    result++;\n                }\n            }\n        }\n    }\n    return result;\n};"}
{"id": "1417", "path": "output2\\js\\Medium\\1417-minimum-absolute-difference-queries.js", "hypo_code": "var minDifference = function(nums, queries) {\n    let result = [];\n    for(let i = 0; i < queries.length; i++){\n        let min = Number.MAX_SAFE_INTEGER;\n        for(let j = queries[i][0]; j < queries[i][1]; j++){\n            for(let k = j + 1; k <= queries[i][1]; k++){\n                min = Math.min(min, Math.abs(nums[j] - nums[k]));\n            }\n        }\n        result.push(min === Number.MAX_SAFE_INTEGER ? -1 : min);\n    }\n    return result;\n};"}
{"id": "1419", "path": "output2\\js\\Medium\\1419-remove-all-occurrences-of-a-substring.js", "hypo_code": "var removeOccurrences = function(s, part) {\n    let stack = [];\n    for(let c of s){\n        stack.push(c);\n        if(stack.length >= part.length && stack.slice(-part.length).join('') === part){\n            stack.splice(-part.length);\n        }\n    }\n    return stack.join('');\n\n};"}
{"id": "1420", "path": "output2\\js\\Medium\\1420-maximum-alternating-subsequence-sum.js", "hypo_code": "_x000D_\nvar maxAlternatingSum = function(nums) {\n    let even = 0, odd = 0;\n    for(let i = 0; i < nums.length; i++){\n        even = Math.max(even, odd + nums[i]);\n        odd = Math.max(odd, even - nums[i]);\n    }\n    return even;\n};"}
{"id": "1421", "path": "output2\\js\\Medium\\1421-cyclically-rotating-a-grid.js", "hypo_code": "var rotateGrid = function(grid, k) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let result = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    let min = Math.min(m, n);\n    for(let i = 0; i < min / 2; i++){\n        let len = (m - i * 2) * 2 + (n - i * 2) * 2 - 4;\n        let temp = new Array(len);\n        let index = 0;\n        for(let j = i; j < m - i - 1; j++){\n            temp[index++] = grid[j][i];\n        }\n        for(let j = i; j < n - i - 1; j++){\n            temp[index++] = grid[m - i - 1][j];\n        }\n        for(let j = m - i - 1; j > i; j--){\n            temp[index++] = grid[j][n - i - 1];\n        }\n        for(let j = n - i - 1; j > i; j--){\n            temp[index++] = grid[i][j];\n        }\n        let offset = k % len;\n        index = 0;\n        for(let j = i; j < m - i - 1; j++){\n            result[j][i] = temp[(index + offset) % len];\n            index++;\n        }\n        for(let j = i; j < n - i - 1; j++){\n            result[m - i - 1][j] = temp[(index + offset) % len];\n            index++;\n        }\n        for(let j = m - i - 1; j > i; j--){\n            result[j][n - i - 1] = temp[(index + offset) % len];\n            index++;\n        }\n        for(let j = n - i - 1; j > i; j--){\n            result[i][j] = temp[(index + offset) % len];\n            index++;\n        }\n    }\n    return result;\n};"}
{"id": "1422", "path": "output2\\js\\Medium\\1422-number-of-wonderful-substrings.js", "hypo_code": "var wonderfulSubstrings = function(word) {\n    let map = new Map();\n    map.set(0, 1);\n    let result = 0, prefix = 0;\n    for(let i = 0; i < word.length; i++){\n        prefix ^= 1 << (word.charCodeAt(i) - 'a'.charCodeAt(0));\n        result += map.get(prefix) || 0;\n        for(let j = 0; j < 10; j++){\n            let temp = prefix ^ (1 << j);\n            result += map.get(temp) || 0;\n        }\n        map.set(prefix, (map.get(prefix) || 0) + 1);\n    }\n    return result;\n};"}
{"id": "1423", "path": "output2\\js\\Medium\\1423-eliminate-maximum-number-of-monsters.js", "hypo_code": "var eliminateMaximum = function(dist, speed) {\n    let n = dist.length;\n    let time = new Array(n);\n    for(let i = 0; i < n; i++){\n        time[i] = Math.ceil(dist[i] / speed[i]);\n    }\n    time.sort((a, b) => a - b);\n    for(let i = 0; i < n; i++){\n        if(time[i] <= i){\n            return i;\n        }\n    }\n    return n;\n};"}
{"id": "1424", "path": "output2\\js\\Medium\\1424-count-good-numbers.js", "hypo_code": "var countGoodNumbers = function(n) {\n    let even = BigInt(Math.floor(n / 2));\n    let odd = BigInt(n - even);\n    return Number((BigInt(5) ** even * BigInt(4) ** odd) % BigInt(1000000007));\n\n};"}
{"id": "1425", "path": "output2\\js\\Medium\\1425-nearest-exit-from-entrance-in-maze.js", "hypo_code": "var nearestExit = function(maze, entrance) {\n    let m = maze.length;\n    let n = maze[0].length;\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let queue = [];\n    queue.push(entrance);\n    maze[entrance[0]][entrance[1]] = '+';\n    let result = 0;\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let [x, y] = queue.shift();\n            if(x === 0 || x === m - 1 || y === 0 || y === n - 1){\n                if(result > 0){\n                    return result;\n                }\n            }\n            for(let direction of directions){\n                let newX = x + direction[0];\n                let newY = y + direction[1];\n                if(newX >= 0 && newX < m && newY >= 0 && newY < n && maze[newX][newY] === '.'){\n                    queue.push([newX, newY]);\n                    maze[newX][newY] = '+';\n                }\n            }\n        }\n        result++;\n    }\n    return -1;\n};"}
{"id": "1426", "path": "output2\\js\\Medium\\1426-sum-game.js", "hypo_code": "var sumGame = function(num) {\n    let n = num.length;\n    let sum = 0;\n    let cnt = 0;\n    for(let i = 0; i < n; i++){\n        if(i < n / 2){\n            if(num[i] === '?'){\n                cnt++;\n            }else{\n                sum += +num[i];\n            }\n        }else{\n            if(num[i] === '?'){\n                cnt--;\n            }else{\n                sum -= +num[i];\n            }\n        }\n    }\n    return cnt % 2 === 1 || sum !== cnt * 9 / 2;\n};"}
{"id": "1427", "path": "output2\\js\\Medium\\1427-unique-length-3-palindromic-subsequences.js", "hypo_code": "var countPalindromicSubsequence = function(s) {\n    let result = 0;\n    for(let i = 0; i < 26; i++){\n        let start = s.indexOf(String.fromCharCode(i + 97));\n        let end = s.lastIndexOf(String.fromCharCode(i + 97));\n        if(start < end){\n            result += new Set(s.slice(start + 1, end)).size;\n        }\n    }\n    return result;\n};"}
{"id": "1429", "path": "output2\\js\\Medium\\1429-add-minimum-number-of-rungs.js", "hypo_code": "var addRungs = function(rungs, dist) {\n    let result = 0;\n    let prev = 0;\n    for(let i = 0; i < rungs.length; i++){\n        result += Math.ceil((rungs[i] - prev) / dist) - 1;\n        prev = rungs[i];\n    }\n    return result;\n\n};"}
{"id": "1430", "path": "output2\\js\\Medium\\1430-maximum-number-of-points-with-cost.js", "hypo_code": "var maxPoints = function(points) {\n    let m = points.length;\n    let n = points[0].length;\n    let dp = points[0];\n    for(let i = 1; i < m; i++){\n        let left = new Array(n).fill(0);\n        let right = new Array(n).fill(0);\n        left[0] = dp[0];\n        for(let j = 1; j < n; j++){\n            left[j] = Math.max(left[j - 1] - 1, dp[j]);\n        }\n        right[n - 1] = dp[n - 1];\n        for(let j = n - 2; j >= 0; j--){\n            right[j] = Math.max(right[j + 1] - 1, dp[j]);\n        }\n        for(let j = 0; j < n; j++){\n            dp[j] = points[i][j] + Math.max(left[j], right[j]);\n        }\n    }\n    return Math.max(...dp);\n};"}
{"id": "1431", "path": "output2\\js\\Medium\\1431-the-number-of-the-smallest-unoccupied-chair.js", "hypo_code": "var smallestChair = function(times, targetFriend) {\n    let arrivals = [];\n    for(let i = 0; i < times.length; i++){\n        arrivals.push([times[i][0], i]);\n    }\n    arrivals.sort((a, b) => a[0] - b[0]);\n    let chairs = [];\n    for(let i = 0; i < times.length; i++){\n        chairs.push(i);\n    }\n    let occupied = [];\n    for(let i = 0; i < times.length; i++){\n        occupied.push([-1, -1]);\n    }\n    let result = -1;\n    for(let i = 0; i < arrivals.length; i++){\n        let [time, index] = arrivals[i];\n        let chair = chairs.shift();\n        if(index === targetFriend){\n            result = chair;\n        }\n        occupied[index] = [chair, time];\n    }\n    return result;\n};"}
{"id": "1432", "path": "output2\\js\\Medium\\1432-describe-the-painting.js", "hypo_code": "var splitPainting = function(segments) {\n    let result = [];\n    let map = {};\n    for(let i = 0; i < segments.length; i++){\n        if(!map[segments[i][0]]){\n            map[segments[i][0]] = segments[i][2];\n        }else{\n            map[segments[i][0]] += segments[i][2];\n        }\n        if(!map[segments[i][1]]){\n            map[segments[i][1]] = -segments[i][2];\n        }else{\n            map[segments[i][1]] -= segments[i][2];\n        }\n    }\n    let keys = Object.keys(map);\n    keys.sort((a, b) => a - b);\n    let sum = 0;\n    let start = 0;\n    for(let i = 0; i < keys.length; i++){\n        if(sum === 0){\n            start = keys[i];\n        }\n        sum += map[keys[i]];\n        if(sum === 0){\n            result.push([start, keys[i], map[start]]);\n        }\n    }\n    return result;\n};"}
{"id": "1433", "path": "output2\\js\\Medium\\1433-largest-number-after-mutating-substring.js", "hypo_code": "var maximumNumber = function(num, change) {\n    let flag = false;\n    let result = \"\";\n    for(let i = 0; i < num.length; i++){\n        if(num[i] < change[num[i]]){\n            result += change[num[i]];\n            flag = true;\n        }else if(num[i] === change[num[i]]){\n            result += num[i];\n        }else{\n            if(flag){\n                result += num.slice(i);\n                return result;\n            }else{\n                result += num[i];\n            }\n        }\n    }\n    return result;\n};"}
{"id": "1434", "path": "output2\\js\\Medium\\1434-maximum-compatibility-score-sum.js", "hypo_code": "var maxCompatibilitySum = function(students, mentors) {\n    let result = 0;\n    let visited = new Array(mentors.length).fill(false);\n    dfs(0, 0);\n    return result;\n    function dfs(index, sum){\n        if(index === students.length){\n            result = Math.max(result, sum);\n            return;\n        }\n        for(let i = 0; i < mentors.length; i++){\n            if(visited[i]){\n                continue;\n            }\n            visited[i] = true;\n            let temp = 0;\n            for(let j = 0; j < students[index].length; j++){\n                if(students[index][j] === mentors[i][j]){\n                    temp++;\n                }\n            }\n            dfs(index + 1, sum + temp);\n            visited[i] = false;\n        }\n    }\n};"}
{"id": "1435", "path": "output2\\js\\Medium\\1435-maximum-number-of-weeks-for-which-you-can-work.js", "hypo_code": "var numberOfWeeks = function(milestones) {\n    let sum = 0;\n    let max = 0;\n    for(let i = 0; i < milestones.length; i++){\n        sum += milestones[i];\n        max = Math.max(max, milestones[i]);\n    }\n    return Math.min(sum, (sum - max) * 2 + 1);\n};"}
{"id": "1436", "path": "output2\\js\\Medium\\1436-minimum-garden-perimeter-to-collect-enough-apples.js", "hypo_code": "var minimumPerimeter = function(neededApples) {\n    let left = 1;\n    let right = 100000;\n    while(left <= right){\n        let mid = left + Math.floor((right - left) / 2);\n        let sum = 2 * mid * (mid + 1) * (2 * mid + 1);\n        if(sum >= neededApples){\n            right = mid - 1;\n        }\n        else{\n            left = mid + 1;\n        }\n    }\n    return left * 8;\n};"}
{"id": "1437", "path": "output2\\js\\Medium\\1437-check-if-move-is-legal.js", "hypo_code": "var checkMove = function(board, rMove, cMove, color) {\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0], [-1, -1], [-1, 1], [1, -1], [1, 1]];\n    let m = board.length;\n    let n = board[0].length;\n    let dfs = function(x, y, direction, color, flag){\n        if(x < 0 || x >= m || y < 0 || y >= n || board[x][y] === '.'){\n            return false;\n        }\n        if(board[x][y] === color){\n            return flag;\n        }\n        return dfs(x + direction[0], y + direction[1], direction, color, true);\n    }\n    for(let direction of directions){\n        let x = rMove + direction[0];\n        let y = cMove + direction[1];\n        if(x < 0 || x >= m || y < 0 || y >= n || board[x][y] === color){\n            continue;\n        }\n        if(dfs(x, y, direction, color, false)){\n            return true;\n        }\n    }\n    return false;\n};"}
{"id": "1438", "path": "output2\\js\\Medium\\1438-minimum-total-space-wasted-with-k-resizing-operations.js", "hypo_code": "var minSpaceWastedKResizing = function(nums, k) {\n    let result = Number.MAX_SAFE_INTEGER;\n    let dp = new Array(nums.length + 1).fill(0).map(() => new Array(k + 1).fill(0).map(() => new Array(nums.length + 1).fill(0)));\n    for(let i = 1; i <= nums.length; i++){\n        for(let j = 1; j <= k; j++){\n            for(let m = 1; m <= i; m++){\n                let max = 0, sum = 0, min = Number.MAX_SAFE_INTEGER;\n                for(let n = m; n <= i; n++){\n                    max = Math.max(max, nums[n - 1]);\n                    sum += nums[n - 1];\n                    min = Math.min(min, nums[n - 1]);\n                }\n                dp[i][j][m] = max * (i - m + 1) - sum + dp[m - 1][j - 1][m - 1];\n                if(j === k){\n                    result = Math.min(result, dp[i][j][m]);\n                }\n            }\n        }\n    }\n    return result;\n};"}
{"id": "1439", "path": "output2\\js\\Medium\\1439-remove-stones-to-minimize-the-total.js", "hypo_code": "var minStoneSum = function(piles, k) {\n    let sum = 0;\n    let maxHeap = new MaxHeap();\n    for(let i = 0; i < piles.length; i++){\n        sum += piles[i];\n        maxHeap.push(piles[i]);\n    }\n    for(let i = 0; i < k; i++){\n        let top = maxHeap.pop();\n        sum -= Math.floor(top / 2);\n        if(top % 2 === 1){\n            maxHeap.push(top - Math.floor(top / 2));\n        }\n    }\n    return sum;\n};"}
{"id": "1440", "path": "output2\\js\\Medium\\1440-minimum-number-of-swaps-to-make-the-string-balanced.js", "hypo_code": "var minSwaps = function(s) {\n    let stack = [];\n    for(let i = 0; i < s.length; i++){\n        if(s[i] === '['){\n            stack.push(s[i]);\n        } else {\n            if(stack[stack.length - 1] === '['){\n                stack.pop();\n            } else {\n                stack.push(s[i]);\n            }\n        }\n    }\n    return Math.ceil(stack.length / 2);\n};"}
{"id": "1441", "path": "output2\\js\\Medium\\1441-array-with-elements-not-equal-to-average-of-neighbors.js", "hypo_code": "var rearrangeArray = function(nums) {\n    nums.sort((a, b) => a - b);\n    let result = [];\n    for(let i = 0; i < nums.length; i++){\n        if(i % 2 === 0){\n            result.push(nums[i / 2]);\n        }else{\n            result.push(nums[nums.length - (i - 1) / 2 - 1]);\n        }\n    }\n    return result;\n};"}
{"id": "1442", "path": "output2\\js\\Medium\\1442-minimum-non-zero-product-of-the-array-elements.js", "hypo_code": "var minNonZeroProduct = function(p) {\n    let mod = 1000000007;\n    let max = Math.pow(2, p) - 1;\n    let result = 1;\n    while(max > 1){\n        result = (result * (max - 1)) % mod;\n        max -= 2;\n    }\n    return (result * max) % mod;\n};"}
{"id": "1443", "path": "output2\\js\\Medium\\1443-maximum-matrix-sum.js", "hypo_code": "var maxMatrixSum = function(matrix) {\n    let n = matrix.length;\n    let negatives = 0;\n    let result = 0;\n    let min = Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            if(matrix[i][j] < 0){\n                negatives++;\n            }\n            result += Math.abs(matrix[i][j]);\n            min = Math.min(min, Math.abs(matrix[i][j]));\n        }\n    }\n    return negatives % 2 === 0 ? result : result - 2 * min;\n};"}
{"id": "1444", "path": "output2\\js\\Medium\\1444-number-of-ways-to-arrive-at-destination.js", "hypo_code": "var countPaths = function(n, roads) {\n    let map = new Map();\n    for(let i = 0; i < roads.length; i++){\n        if(!map.has(roads[i][0])){\n            map.set(roads[i][0], []);\n        }\n        if(!map.has(roads[i][1])){\n            map.set(roads[i][1], []);\n        }\n        map.get(roads[i][0]).push([roads[i][1], roads[i][2]]);\n        map.get(roads[i][1]).push([roads[i][0], roads[i][2]]);\n    }\n    let time = new Array(n).fill(Number.MAX_SAFE_INTEGER);\n    let count = new Array(n).fill(0);\n    time[0] = 0;\n    count[0] = 1;\n    let queue = [0];\n    while(queue.length > 0){\n        let current = queue.shift();\n        if(map.has(current)){\n            for(let i = 0; i < map.get(current).length; i++){\n                let next = map.get(current)[i][0];\n                let cost = map.get(current)[i][1];\n                if(time[current] + cost < time[next]){\n                    time[next] = time[current] + cost;\n                    count[next] = count[current];\n                    queue.push(next);\n                }else if(time[current] + cost === time[next]){\n                    count[next] = (count[next] + count[current]) % (Math.pow(10, 9) + 7);\n                }\n            }\n        }\n    }\n    return count[n - 1];\n};"}
{"id": "1445", "path": "output2\\js\\Medium\\1445-find-unique-binary-string.js", "hypo_code": "var findDifferentBinaryString = function(nums) {\n    let n = nums.length;\n    let result = '';\n    for(let i = 0; i < n; i++){\n        result += nums[i][i] === '0' ? '1' : '0';\n    }\n    return result;\n};"}
{"id": "1446", "path": "output2\\js\\Medium\\1446-minimize-the-difference-between-target-and-chosen-elements.js", "hypo_code": "var minimizeTheDifference = function(mat, target) {\n    let dp = new Set([0]);\n    for(let i = 0; i < mat.length; i++){\n        let temp = new Set();\n        for(let j = 0; j < mat[i].length; j++){\n            for(let k of dp){\n                temp.add(k + mat[i][j]);\n            }\n        }\n        dp = temp;\n    }\n    let result = Number.MAX_SAFE_INTEGER;\n    for(let i of dp){\n        result = Math.min(result, Math.abs(i - target));\n    }\n    return result;\n};"}
{"id": "1447", "path": "output2\\js\\Medium\\1447-find-the-kth-largest-integer-in-the-array.js", "hypo_code": "var kthLargestNumber = function(nums, k) {\n    nums.sort((a, b) => {\n        if(a.length !== b.length){\n            return a.length - b.length;\n        }\n        for(let i = 0; i < a.length; i++){\n            if(a[i] !== b[i]){\n                return a[i] - b[i];\n            }\n        }\n    });\n    return nums[nums.length - k];\n};"}
{"id": "1448", "path": "output2\\js\\Medium\\1448-minimum-number-of-work-sessions-to-finish-the-tasks.js", "hypo_code": "var minSessions = function(tasks, sessionTime) {\n    let result = tasks.length;\n    let dp = new Array(1 << tasks.length).fill(Infinity);\n    for(let i = 1; i < dp.length; i++){\n        let time = 0;\n        let count = 0;\n        for(let j = 0; j < tasks.length; j++){\n            if((i & (1 << j)) !== 0){\n                time += tasks[j];\n                count++;\n            }\n        }\n        if(time <= sessionTime){\n            dp[i] = 1;\n        }else{\n            for(let j = i; j > 0; j = (j - 1) & i){\n                dp[i] = Math.min(dp[i], dp[j] + dp[i ^ j]);\n            }\n        }\n    }\n    return dp[dp.length - 1];\n};"}
{"id": "1449", "path": "output2\\js\\Medium\\1449-find-all-groups-of-farmland.js", "hypo_code": "var findFarmland = function(land) {\n    let m = land.length;\n    let n = land[0].length;\n    let result = [];\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let dfs = function(i, j){\n        if(i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || land[i][j] === 0){\n            return [i - 1, j - 1];\n        }\n        visited[i][j] = true;\n        let left = dfs(i + directions[0][0], j + directions[0][1]);\n        let right = dfs(i + directions[1][0], j + directions[1][1]);\n        let bottom = dfs(i + directions[2][0], j + directions[2][1]);\n        let top = dfs(i + directions[3][0], j + directions[3][1]);\n        return [Math.max(i, left[0], right[0], bottom[0], top[0]), Math.max(j, left[1], right[1], bottom[1], top[1])];\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(land[i][j] === 1 && !visited[i][j]){\n                let left = dfs(i, j)[1];\n                let right = dfs(i, left + 1)[1];\n                result.push([i, left, i, right]);\n            }\n        }\n    }\n    return result;\n};"}
{"id": "1451", "path": "output2\\js\\Medium\\1451-the-number-of-weak-characters-in-the-game.js", "hypo_code": "var numberOfWeakCharacters = function(properties) {\n    properties.sort((a, b) => a[0] - b[0]);\n    let result = 0;\n    let max = 0;\n    for(let i = properties.length - 1; i >= 0; i--){\n        if(properties[i][1] < max){\n            result++;\n        }\n        max = Math.max(max, properties[i][1]);\n    }\n    return result;\n};"}
{"id": "1452", "path": "output2\\js\\Medium\\1452-first-day-where-you-have-been-in-all-the-rooms.js", "hypo_code": "var firstDayBeenInAllRooms = function(nextVisit) {\n    const n = nextVisit.length;\n    const dp = new Array(n).fill(0);\n    const mod = 1e9 + 7;\n    for(let i = 1; i < n; i++){\n        dp[i] = (2 * dp[i - 1] + 2 - dp[nextVisit[i - 1]] + mod) % mod;\n    }\n    return dp[n - 1];\n};"}
{"id": "1453", "path": "output2\\js\\Medium\\1453-number-of-pairs-of-interchangeable-rectangles.js", "hypo_code": "var interchangeableRectangles = function(rectangles) {\n    let map = new Map();\n    let count = 0;\n    for (let i = 0; i < rectangles.length; i++) {\n        let ratio = rectangles[i][0] / rectangles[i][1];\n        if (map.has(ratio)) {\n            count += map.get(ratio);\n            map.set(ratio, map.get(ratio) + 1);\n        } else {\n            map.set(ratio, 1);\n        }\n    }\n    return count;\n    \n};"}
{"id": "1454", "path": "output2\\js\\Medium\\1454-maximum-product-of-the-length-of-two-palindromic-subsequences.js", "hypo_code": "var maxProduct = function(s) {\n    let n = s.length;\n    let dp = new Array(1 << n).fill(0);\n    let result = 0;\n    for (let i = 0; i < 1 << n; i++) {\n        let str = '';\n        for (let j = 0; j < n; j++) {\n            if (i & (1 << j)) {\n                str += s[j];\n            }\n        }\n        if (isPalindrome(str)) {\n            dp[i] = str.length;\n        }\n    }\n    for (let i = 0; i < 1 << n; i++) {\n        for (let j = i; j > 0; j = (j - 1) & i) {\n            result = Math.max(result, dp[i] * dp[j]);\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1455", "path": "output2\\js\\Medium\\1455-find-original-array-from-doubled-array.js", "hypo_code": "var findOriginalArray = function(changed) {\n    let map = new Map();\n    let result = [];\n    for (let i = 0; i < changed.length; i++) {\n        if (map.has(changed[i])) {\n            map.set(changed[i], map.get(changed[i]) + 1);\n        } else {\n            map.set(changed[i], 1);\n        }\n    }\n    let sorted = [...map.keys()].sort((a, b) => a - b);\n    for (let i = 0; i < sorted.length; i++) {\n        let num = sorted[i];\n        let count = map.get(num);\n        if (count === 0) {\n            continue;\n        }\n        if (!map.has(num * 2) || map.get(num * 2) < count) {\n            return [];\n        }\n        for (let j = 0; j < count; j++) {\n            result.push(num);\n            map.set(num, map.get(num) - 1);\n            map.set(num * 2, map.get(num * 2) - 1);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1456", "path": "output2\\js\\Medium\\1456-maximum-earnings-from-taxi.js", "hypo_code": "var maxTaxiEarnings = function(n, rides) {\n    let dp = new Array(n + 1).fill(0);\n    rides.sort((a, b) => a[1] - b[1]);\n    for (let i = 0; i < rides.length; i++) {\n        let [start, end, tip] = rides[i];\n        let index = binarySearch(rides, start);\n        dp[end] = Math.max(dp[end], dp[start] + end - start + tip);\n        dp[end] = Math.max(dp[end], dp[rides[index][1]] + end - rides[index][1] + tip);\n    }\n    return dp[n];\n    \n    \n};"}
{"id": "1457", "path": "output2\\js\\Medium\\1457-sum-of-beauty-in-the-array.js", "hypo_code": "var sumOfBeauties = function(nums) {\n    let max = nums[0];\n    let min = nums[nums.length - 1];\n    let maxArr = [max];\n    let minArr = [min];\n    for (let i = 1; i < nums.length; i++) {\n        max = Math.max(max, nums[i]);\n        maxArr.push(max);\n    }\n    for (let i = nums.length - 2; i >= 0; i--) {\n        min = Math.min(min, nums[i]);\n        minArr.unshift(min);\n    }\n    let count = 0;\n    for (let i = 1; i < nums.length - 1; i++) {\n        if (nums[i] > maxArr[i - 1] && nums[i] < minArr[i + 1]) {\n            count += 2;\n        } else if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1]) {\n            count++;\n        }\n    }\n    return count;\n    \n};"}
{"id": "1459", "path": "output2\\js\\Medium\\1459-grid-game.js", "hypo_code": "var gridGame = function(grid) {\n    let n = grid[0].length;\n    let sum = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        sum[i] = sum[i - 1] + grid[0][i - 1];\n    }\n    let result = Number.MAX_SAFE_INTEGER;\n    for(let i = 1; i <= n; i++){\n        result = Math.min(result, Math.max(sum[i], sum[n] - sum[i - 1]));\n    }\n    return result;\n};"}
{"id": "1460", "path": "output2\\js\\Medium\\1460-check-if-word-can-be-placed-in-crossword.js", "hypo_code": "var placeWordInCrossword = function(board, word) {\n    let m = board.length;\n    let n = board[0].length;\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let check = function(i, j, k, direction){\n        if(i < 0 || i >= m || j < 0 || j >= n || board[i][j] === '#' || (board[i][j] !== ' ' && board[i][j] !== word[k])){\n            return false;\n        }\n        if(k === word.length - 1){\n            return true;\n        }\n        return check(i + direction[0], j + direction[1], k + 1, direction);\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            for(let direction of directions){\n                if(check(i, j, 0, direction)){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};"}
{"id": "1461", "path": "output2\\js\\Medium\\1461-number-of-pairs-of-strings-with-concatenation-equal-to-target.js", "hypo_code": "var numOfPairs = function(nums, target) {\n    let result = 0;\n    for(let i = 0; i < nums.length; i++){\n        for(let j = 0; j < nums.length; j++){\n            if(i !== j && nums[i] + nums[j] === target){\n                result++;\n            }\n        }\n    }\n    return result;\n\n};"}
{"id": "1462", "path": "output2\\js\\Medium\\1462-maximize-the-confusion-of-an-exam.js", "hypo_code": "var maxConsecutiveAnswers = function(answerKey, k) {\n    let n = answerKey.length;\n    let left = 0, right = 0;\n    let count = new Array(2).fill(0);\n    let result = 0;\n    while(right < n){\n        count[answerKey[right] === 'T' ? 0 : 1]++;\n        while(Math.min(count[0], count[1]) > k){\n            count[answerKey[left] === 'T' ? 0 : 1]--;\n            left++;\n        }\n        result = Math.max(result, right - left + 1);\n        right++;\n    }\n    return result;\n};"}
{"id": "1463", "path": "output2\\js\\Medium\\1463-find-missing-observations.js", "hypo_code": "var missingRolls = function(rolls, mean, n) {\n    let sum = 0;\n    for(let i = 0; i < rolls.length; i++){\n        sum += rolls[i];\n    }\n    let sum2 = mean * (n + rolls.length) - sum;\n    if(sum2 < n || sum2 > n * 6){\n        return [];\n    }\n    let result = [];\n    let num = Math.floor(sum2 / n);\n    for(let i = 0; i < n; i++){\n        result.push(num);\n    }\n    for(let i = 0; i < sum2 % n; i++){\n        result[i]++;\n    }\n    return result;\n};"}
{"id": "1464", "path": "output2\\js\\Medium\\1464-stone-game-ix.js", "hypo_code": "var stoneGameIX = function(stones) {\n    let cnt = new Array(3).fill(0);\n    for(let i = 0; i < stones.length; i++){\n        cnt[stones[i] % 3]++;\n    }\n    if(cnt[0] % 2 === 0){\n        return cnt[1] > 0 && cnt[2] > 0;\n    }\n    return Math.abs(cnt[1] - cnt[2]) >= 3;\n};"}
{"id": "1465", "path": "output2\\js\\Medium\\1465-minimum-operations-to-make-a-uni-value-grid.js", "hypo_code": "var minOperations = function(grid, x) {\n    let arr = [];\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n            arr.push(grid[i][j]);\n        }\n    }\n    arr.sort((a, b) => a - b);\n    let result = 0;\n    let median = arr[Math.floor(arr.length / 2)];\n    for(let i = 0; i < arr.length; i++){\n        if(Math.abs(arr[i] - median) % x !== 0){\n            return -1;\n        }\n        result += Math.abs(arr[i] - median) / x;\n    }\n    return result;\n};"}
{"id": "1467", "path": "output2\\js\\Medium\\1467-remove-colored-pieces-if-both-neighbors-are-the-same-color.js", "hypo_code": "var winnerOfGame = function(colors) {\n    let n = colors.length;\n    let a = 0, b = 0;\n    for(let i = 0; i < n; i++){\n        let j = i;\n        while(j < n && colors[j] === colors[i]){\n            j++;\n        }\n        if(colors[i] === 'A'){\n            a += Math.max(0, j - i - 2);\n        }else{\n            b += Math.max(0, j - i - 2);\n        }\n        i = j - 1;\n    }\n    return a > b;\n};"}
{"id": "1468", "path": "output2\\js\\Medium\\1468-the-time-when-the-network-becomes-idle.js", "hypo_code": "var networkBecomesIdle = function(edges, patience) {\n    let graph = new Map();\n    for(let i = 0; i < edges.length; i++){\n        if(!graph.has(edges[i][0])){\n            graph.set(edges[i][0], []);\n        }\n        graph.get(edges[i][0]).push(edges[i][1]);\n        if(!graph.has(edges[i][1])){\n            graph.set(edges[i][1], []);\n        }\n        graph.get(edges[i][1]).push(edges[i][0]);\n    }\n    let visited = new Set();\n    let queue = [];\n    queue.push(0);\n    visited.add(0);\n    let time = 0;\n    let result = 0;\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let current = queue.shift();\n            for(let j = 0; j < graph.get(current).length; j++){\n                if(!visited.has(graph.get(current)[j])){\n                    queue.push(graph.get(current)[j]);\n                    visited.add(graph.get(current)[j]);\n                }\n            }\n            if(current !== 0){\n                let distance = Math.ceil((time + 1) / patience[current]);\n                result = Math.max(result, time + distance * 2);\n            }\n        }\n        time++;\n    }\n    return result + 1;\n};"}
{"id": "1470", "path": "output2\\js\\Medium\\1470-count-number-of-maximum-bitwise-or-subsets.js", "hypo_code": "var countMaxOrSubsets = function(nums) {\n    let max = 0;\n    for(let i = 0; i < nums.length; i++){\n        max |= nums[i];\n    }\n    let result = 0;\n    for(let i = 0; i < (1 << nums.length); i++){\n        let or = 0;\n        for(let j = 0; j < nums.length; j++){\n            if((i & (1 << j)) > 0){\n                or |= nums[j];\n            }\n        }\n        if(or === max){\n            result++;\n        }\n    }\n    return result;\n};"}
{"id": "1471", "path": "output2\\js\\Medium\\1471-next-greater-numerically-balanced-number.js", "hypo_code": "var nextBeautifulNumber = function(n) {\n    let result = n + 1;\n    while(!isBeautiful(result)){\n        result++;\n    }\n    return result;\n};\nvar isBeautiful = function(n){\n    let map = new Map();\n    while(n > 0){\n        map.set(n % 10, (map.get(n % 10) || 0) + 1);\n        n = Math.floor(n / 10);\n    }\n    for(let [key, value] of map){\n        if(key !== 0 && key !== value){\n            return false;\n        }\n    }\n    return true;\n}"}
{"id": "1472", "path": "output2\\js\\Medium\\1472-count-nodes-with-the-highest-score.js", "hypo_code": "var countHighestScoreNodes = function(parents) {\n    let n = parents.length;\n    let children = new Array(n).fill(0).map(() => []);\n    let result = 0;\n    for(let i = 1; i < n; i++){\n        children[parents[i]].push(i);\n    }\n    let dfs = function(i){\n        let max1 = 0;\n        let max2 = 0;\n        for(let child of children[i]){\n            let temp = dfs(child);\n            if(temp > max1){\n                max2 = max1;\n                max1 = temp;\n            }else if(temp > max2){\n                max2 = temp;\n            }\n        }\n        result = Math.max(result, max1 * max2);\n        return max1 + 1;\n    }\n    dfs(0);\n    return result;\n};"}
{"id": "1473", "path": "output2\\js\\Medium\\1473-two-best-non-overlapping-events.js", "hypo_code": "var maxTwoEvents = function(events) {\n    events.sort((a, b) => a[1] - b[1]);\n    let dp = new Array(events.length).fill(0);\n    dp[0] = events[0][2];\n    for (let i = 1; i < events.length; i++) {\n        dp[i] = Math.max(dp[i - 1], events[i][2]);\n        for (let j = i - 1; j >= 0; j--) {\n            if (events[i][0] > events[j][1]) {\n                dp[i] = Math.max(dp[i], dp[j] + events[i][2]);\n                break;\n            }\n        }\n    }\n    return dp[events.length - 1];\n};"}
{"id": "1474", "path": "output2\\js\\Medium\\1474-plates-between-candles.js", "hypo_code": "var platesBetweenCandles = function(s, queries) {\n    let n = s.length;\n    let prefix = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; i++) {\n        prefix[i] = prefix[i - 1] + (s[i - 1] === '|');\n    }\n    let res = [];\n    for (let query of queries) {\n        let left = query[0];\n        let right = query[1];\n        res.push(prefix[right + 1] - prefix[left + 1] - 1);\n    }\n    return res;\n};"}
{"id": "1475", "path": "output2\\js\\Medium\\1475-find-the-minimum-and-maximum-number-of-nodes-between-critical-points.js", "hypo_code": "var nodesBetweenCriticalPoints = function(head) {\n    let res = [-1, -1];\n    let prev = null;\n    let cur = head;\n    let next = null;\n    let count = 0;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    while (cur) {\n        next = cur.next;\n        if (prev && next) {\n            if (prev.val < cur.val && next.val < cur.val || prev.val > cur.val && next.val > cur.val) {\n                min = Math.min(min, count);\n                max = Math.max(max, count);\n            }\n        }\n        prev = cur;\n        cur = next;\n        count++;\n    }\n    if (min !== Number.MAX_SAFE_INTEGER) {\n        res[0] = min;\n        res[1] = max;\n    }\n    return res;\n};"}
{"id": "1476", "path": "output2\\js\\Medium\\1476-minimum-operations-to-convert-number.js", "hypo_code": "var minimumOperations = function(nums, start, goal) {\n    let visited = new Set();\n    let queue = [];\n    queue.push(start);\n    visited.add(start);\n    let res = 0;\n    while (queue.length) {\n        let size = queue.length;\n        for (let i = 0; i < size; i++) {\n            let cur = queue.shift();\n            if (cur === goal) {\n                return res;\n            }\n            for (let num of nums) {\n                let next = cur + num;\n                if (next >= 0 && next <= 1000 && !visited.has(next)) {\n                    queue.push(next);\n                    visited.add(next);\n                }\n                next = cur - num;\n                if (next >= 0 && next <= 1000 && !visited.has(next)) {\n                    queue.push(next);\n                    visited.add(next);\n                }\n                next = cur ^ num;\n                if (next >= 0 && next <= 1000 && !visited.has(next)) {\n                    queue.push(next);\n                    visited.add(next);\n                }\n            }\n        }\n        res++;\n    }\n    return -1;\n};"}
{"id": "1477", "path": "output2\\js\\Medium\\1477-vowels-of-all-substrings.js", "hypo_code": "var countVowels = function(word) {\n    let n = word.length;\n    let res = 0;\n    let count = new Array(5).fill(0);\n    let vowels = new Map();\n    vowels.set('a', 0);\n    vowels.set('e', 1);\n    vowels.set('i', 2);\n    vowels.set('o', 3);\n    vowels.set('u', 4);\n    let bit = 0;\n    let mask = 0;\n    let one = 1;\n    for (let i = 0; i < n; i++) {\n        let ch = word[i];\n        if (vowels.has(ch)) {\n            bit ^= one << vowels.get(ch);\n        }\n        for (let j = 0; j < 5; j++) {\n            if ((bit & (one << j)) > 0) {\n                count[j]++;\n            }\n        }\n        mask |= bit;\n        for (let j = 0; j < 5; j++) {\n            if ((mask & (one << j)) > 0) {\n                res += count[j];\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1478", "path": "output2\\js\\Medium\\1478-minimized-maximum-of-products-distributed-to-any-store.js", "hypo_code": "var minimizedMaximum = function(n, quantities) {\n    let start = 1;\n    let end = Math.max(...quantities);\n    let res = 0;\n    while (start <= end) {\n        let mid = start + Math.floor((end - start) / 2);\n        if (check(n, quantities, mid)) {\n            res = mid;\n            end = mid - 1;\n        } else {\n            start = mid + 1;\n        }\n    }\n    return res;\n};"}
{"id": "1480", "path": "output2\\js\\Medium\\1480-most-beautiful-item-for-each-query.js", "hypo_code": "var maximumBeauty = function(items, queries) {\n    let max = 0;\n    let map = new Map();\n    for (let i = 0; i < items.length; i++) {\n        max = Math.max(max, items[i][1]);\n        if (map.has(items[i][0])) {\n            map.set(items[i][0], Math.max(map.get(items[i][0]), items[i][1]));\n        } else {\n            map.set(items[i][0], items[i][1]);\n        }\n    }\n    let arr = Array.from(map).sort((a, b) => a[0] - b[0]);\n    for (let i = 1; i < arr.length; i++) {\n        arr[i][1] = Math.max(arr[i][1], arr[i - 1][1]);\n    }\n    let res = [];\n    for (let i = 0; i < queries.length; i++) {\n        let idx = binarySearch(arr, queries[i]);\n        if (idx === -1) {\n            res.push(0);\n        } else {\n            res.push(arr[idx][1]);\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "1481", "path": "output2\\js\\Medium\\1481-reverse-nodes-in-even-length-groups.js", "hypo_code": "var reverseEvenLengthGroups = function(head) {\n    let curr = head;\n    let prev = null;\n    let next = null;\n    let count = 0;\n    while (curr !== null) {\n        count++;\n        next = curr.next;\n        if (count % 2 === 0) {\n            curr.next = prev;\n        }\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n    \n};"}
{"id": "1482", "path": "output2\\js\\Medium\\1482-decode-the-slanted-ciphertext.js", "hypo_code": "var decodeCiphertext = function(encodedText, rows) {\n    let n = encodedText.length;\n    let cols = Math.ceil(n / rows);\n    let matrix = new Array(rows).fill(0).map(() => new Array(cols).fill(''));\n    let i = 0;\n    let j = 0;\n    for (let k = 0; k < n; k++) {\n        if (encodedText[k] !== ' ') {\n            matrix[i][j] = encodedText[k];\n            i++;\n            if (i === rows) {\n                i = 0;\n                j++;\n            }\n        }\n    }\n    let res = '';\n    i = 0;\n    j = 0;\n    for (let k = 0; k < n; k++) {\n        res += matrix[i][j];\n        i++;\n        if (i === rows) {\n            i = 0;\n            j++;\n        }\n    }\n    return res;\n};"}
{"id": "1483", "path": "output2\\js\\Medium\\1483-watering-plants.js", "hypo_code": "var wateringPlants = function(plants, capacity) {\n    let n = plants.length;\n    let res = 0;\n    let can = capacity;\n    let left = 0;\n    let right = n - 1;\n    while (left <= right) {\n        if (plants[left] > can) {\n            res += left * 2 + 1;\n            can = capacity;\n        } else {\n            can -= plants[left];\n            left++;\n        }\n        if (plants[right] > can) {\n            res += (n - right) * 2 + 1;\n            can = capacity;\n        } else {\n            can -= plants[right];\n            right--;\n        }\n    }\n    return res;\n};"}
{"id": "1485", "path": "output2\\js\\Medium\\1485-minimum-number-of-food-buckets-to-feed-the-hamsters.js", "hypo_code": "var minimumBuckets = function(hamsters) {\n    let count = 0;\n    let left = 0;\n    let right = 0;\n    for (let i = 0; i < hamsters.length; i++) {\n        if (hamsters[i] === 'H') {\n            right++;\n        }\n    }\n    for (let i = 0; i < hamsters.length; i++) {\n        if (hamsters[i] === 'H') {\n            if (left === 0 && right === 0) {\n                return -1;\n            }\n            if (left === 0) {\n                count++;\n                right--;\n            } else {\n                left--;\n            }\n        } else {\n            left++;\n        }\n    }\n    return count;\n    \n};"}
{"id": "1486", "path": "output2\\js\\Medium\\1486-minimum-cost-homecoming-of-a-robot-in-a-grid.js", "hypo_code": "var minCost = function(startPos, homePos, rowCosts, colCosts) {\n    let m = rowCosts.length;\n    let n = colCosts.length;\n    let x = startPos[0];\n    let y = startPos[1];\n    let total = 0;\n    let max = 0;\n    let set = new Set(rowCosts);\n    for (let i = 0; i < m; i++) {\n        let diff = Math.abs(rowCosts[i] - colCosts[i]);\n        total = (total + diff) % 1000000007;\n        if (diff > max) {\n            for (let num of set) {\n                let newDiff = Math.abs(num - colCosts[i]);\n                max = Math.max(max, diff - newDiff);\n            }\n        }\n    }\n    return (total - max) % 1000000007;\n    \n};"}
{"id": "1487", "path": "output2\\js\\Medium\\1487-k-radius-subarray-averages.js", "hypo_code": "var getAverages = function(nums, k) {\n    let res = [];\n    for (let i = 0; i < nums.length; i++) {\n        let sum = 0;\n        let count = 0;\n        for (let j = i - k; j <= i + k; j++) {\n            if (j >= 0 && j < nums.length) {\n                sum += nums[j];\n                count++;\n            }\n        }\n        if (count === 2 * k + 1) {\n            res.push(Math.floor(sum / count));\n        } else {\n            res.push(-1);\n        }\n    }\n    return res;\n    \n};"}
{"id": "1488", "path": "output2\\js\\Medium\\1488-removing-minimum-and-maximum-from-array.js", "hypo_code": "var minimumDeletions = function(nums) {\n    let n = nums.length;\n    let min = nums[0];\n    let max = nums[n - 1];\n    let left = 0;\n    let right = n - 1;\n    let count = 0;\n    while (left < right) {\n        if (min < max) {\n            left++;\n            min = Math.min(min, nums[left]);\n        } else if (min > max) {\n            right--;\n            max = Math.max(max, nums[right]);\n        } else {\n            left++;\n            right--;\n            min = Math.min(min, nums[left]);\n            max = Math.max(max, nums[right]);\n        }\n        count++;\n    }\n    return count;\n    \n};"}
{"id": "1489", "path": "output2\\js\\Medium\\1489-delete-the-middle-node-of-a-linked-list.js", "hypo_code": "var deleteMiddle = function(head) {\n    let slow = head;\n    let fast = head;\n    let prev = null;\n    while (fast && fast.next) {\n        fast = fast.next.next;\n        prev = slow;\n        slow = slow.next;\n    }\n    prev.next = slow.next;\n    slow.next = null;\n    return head;\n};"}
{"id": "1490", "path": "output2\\js\\Medium\\1490-step-by-step-directions-from-a-binary-tree-node-to-another.js", "hypo_code": "var getDirections = function(root, startValue, destValue) {\n    let start = null;\n    let dest = null;\n    let res = '';\n    let dfs = function(node, path) {\n        if (!node) {\n            return;\n        }\n        if (node.val === startValue) {\n            start = path;\n        }\n        if (node.val === destValue) {\n            dest = path;\n        }\n        dfs(node.left, path + 'L');\n        dfs(node.right, path + 'R');\n    };\n    dfs(root, '');\n    let i = 0;\n    while (i < start.length && i < dest.length && start[i] === dest[i]) {\n        i++;\n    }\n    for (let j = i; j < start.length; j++) {\n        res += 'U';\n    }\n    for (let j = i; j < dest.length; j++) {\n        res += dest[j];\n    }\n    return res;\n};"}
{"id": "1491", "path": "output2\\js\\Medium\\1491-find-good-days-to-rob-the-bank.js", "hypo_code": "var goodDaysToRobBank = function(security, time) {\n    let n = security.length;\n    let res = [];\n    let left = new Array(n).fill(0);\n    let right = new Array(n).fill(0);\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        if (i - time - 1 >= 0) {\n            max = Math.max(max, security[i - time - 1]);\n        }\n        left[i] = max;\n    }\n    max = 0;\n    for (let i = n - 1; i >= 0; i--) {\n        if (i + time < n) {\n            max = Math.max(max, security[i + time]);\n        }\n        right[i] = max;\n    }\n    for (let i = 0; i < n; i++) {\n        if (left[i] >= security[i] && right[i] >= security[i]) {\n            res.push(i);\n        }\n    }\n    return res;\n};"}
{"id": "1492", "path": "output2\\js\\Medium\\1492-detonate-the-maximum-bombs.js", "hypo_code": "var maximumDetonation = function(bombs) {\n    let n = bombs.length;\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        let count = 0;\n        let x1 = bombs[i][0];\n        let y1 = bombs[i][1];\n        let r1 = bombs[i][2];\n        for (let j = 0; j < n; j++) {\n            if (i === j) {\n                continue;\n            }\n            let x2 = bombs[j][0];\n            let y2 = bombs[j][1];\n            let r2 = bombs[j][2];\n            if ((x1 - x2) ** 2 + (y1 - y2) ** 2 <= (r1 + r2) ** 2) {\n                count++;\n            }\n        }\n        res = Math.max(res, count);\n    }\n    return res;\n};"}
{"id": "1493", "path": "output2\\js\\Medium\\1493-sum-of-subarray-ranges.js", "hypo_code": "var subArrayRanges = function(nums) {\n    let n = nums.length;\n    let res = 0;\n    let min = nums[0];\n    let max = nums[0];\n    let sum = 0;\n    for (let i = 0; i < n; i++) {\n        min = Math.min(min, nums[i]);\n        max = Math.max(max, nums[i]);\n        sum += nums[i];\n        res += (max - min) * (i + 1) - sum;\n    }\n    return res;\n};"}
{"id": "1494", "path": "output2\\js\\Medium\\1494-watering-plants-ii.js", "hypo_code": "var minimumRefill = function(plants, capacityA, capacityB) {\n    let n = plants.length;\n    let res = 0;\n    let canA = capacityA;\n    let canB = capacityB;\n    let left = 0;\n    let right = n - 1;\n    while (left <= right) {\n        if (plants[left] > canA) {\n            res++;\n            canA = capacityA;\n        } else {\n            canA -= plants[left];\n            left++;\n        }\n        if (plants[right] > canB) {\n            res++;\n            canB = capacityB;\n        } else {\n            canB -= plants[right];\n            right--;\n        }\n    }\n    return res;\n};"}
{"id": "1495", "path": "output2\\js\\Medium\\1495-adding-spaces-to-a-string.js", "hypo_code": "var addSpaces = function(s, spaces) {\n    let res = '';\n    let n = s.length;\n    let j = 0;\n    for (let i = 0; i < n; i++) {\n        if (j < spaces.length && i === spaces[j]) {\n            res += ' ';\n            j++;\n        }\n        res += s[i];\n    }\n    while (j < spaces.length) {\n        res += ' ';\n        j++;\n    }\n    return res;\n};"}
{"id": "1496", "path": "output2\\js\\Medium\\1496-number-of-smooth-descent-periods-of-a-stock.js", "hypo_code": "var getDescentPeriods = function(prices) {\n    let n = prices.length;\n    let res = 0;\n    let dp = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        dp[i] = 1;\n        for (let j = i - 1; j >= 0; j--) {\n            if (prices[j] - prices[i] === i - j) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i];\n    }\n    return res;\n};"}
{"id": "1497", "path": "output2\\js\\Medium\\1497-find-all-possible-recipes-from-given-supplies.js", "hypo_code": "var findAllRecipes = function(recipes, ingredients, supplies) {\n    let map = new Map();\n    let set = new Set(supplies);\n    for (let i = 0; i < recipes.length; i++) {\n        map.set(recipes[i], ingredients[i]);\n    }\n    let result = [];\n    for (let i = 0; i < recipes.length; i++) {\n        let recipe = recipes[i];\n        let ingredient = ingredients[i];\n        if (canMake(recipe, ingredient, map, set)) {\n            result.push(recipe);\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1498", "path": "output2\\js\\Medium\\1498-check-if-a-parentheses-string-can-be-valid.js", "hypo_code": "var canBeValid = function(s, locked) {\n    let stack = [];\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (locked[i] === '1') {\n            continue;\n        }\n        if (s[i] === '(') {\n            stack.push('(');\n        } else {\n            if (stack.length === 0) {\n                count++;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return count <= stack.length;\n    \n};"}
{"id": "1499", "path": "output2\\js\\Medium\\1499-execution-of-all-suffix-instructions-staying-in-a-grid.js", "hypo_code": "var executeInstructions = function(n, startPos, s) {\n    let x = startPos[0];\n    let y = startPos[1];\n    let result = [];\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === 'L') {\n            y--;\n        } else if (s[i] === 'R') {\n            y++;\n        } else if (s[i] === 'U') {\n            x--;\n        } else {\n            x++;\n        }\n        if (x < 0 || x >= n || y < 0 || y >= n) {\n            result.push(count);\n        } else {\n            count++;\n        }\n    }\n    for (let i = 0; i < result.length; i++) {\n        result[i] = count;\n    }\n    return result;\n    \n};"}
{"id": "1500", "path": "output2\\js\\Medium\\1500-intervals-between-identical-elements.js", "hypo_code": "var getDistances = function(arr) {\n    let map = new Map();\n    for (let i = 0; i < arr.length; i++) {\n        if (map.has(arr[i])) {\n            map.get(arr[i]).push(i);\n        } else {\n            map.set(arr[i], [i]);\n        }\n    }\n    let res = [];\n    for (let i = 0; i < arr.length; i++) {\n        let sum = 0;\n        let list = map.get(arr[i]);\n        for (let j = 0; j < list.length; j++) {\n            sum += Math.abs(list[j] - i);\n        }\n        res.push(sum);\n    }\n    return res;\n    \n};"}
{"id": "1501", "path": "output2\\js\\Medium\\1501-number-of-laser-beams-in-a-bank.js", "hypo_code": "var numberOfBeams = function(bank) {\n    let result = 0;\n    for (let i = 0; i < bank.length; i++) {\n        let row = bank[i];\n        let count = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j] === '1') {\n                count++;\n            }\n        }\n        if (count > 1) {\n            result += count - 1;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1502", "path": "output2\\js\\Medium\\1502-destroying-asteroids.js", "hypo_code": "var asteroidsDestroyed = function(mass, asteroids) {\n    let stack = [];\n    for (let i = 0; i < asteroids.length; i++) {\n        if (mass >= asteroids[i]) {\n            mass += asteroids[i];\n        } else {\n            stack.push(asteroids[i]);\n        }\n    }\n    while (stack.length > 0) {\n        let cur = stack.pop();\n        if (mass >= cur) {\n            mass += cur;\n        } else {\n            return false;\n        }\n    }\n    return true;\n    \n};"}
{"id": "1503", "path": "output2\\js\\Medium\\1503-maximum-twin-sum-of-a-linked-list.js", "hypo_code": "var pairSum = function(head) {\n    let map = {};\n    let res = Number.MIN_SAFE_INTEGER;\n    let cur = head;\n    while (cur) {\n        let twin = map[cur.val];\n        if (twin) {\n            res = Math.max(res, twin + cur.val);\n        }\n        map[cur.val] = cur.val;\n        cur = cur.next;\n    }\n    return res;\n};"}
{"id": "1504", "path": "output2\\js\\Medium\\1504-longest-palindrome-by-concatenating-two-letter-words.js", "hypo_code": "var longestPalindrome = function(words) {\n    let res = 0;\n    let n = words.length;\n    let set = new Set();\n    for (let i = 0; i < n; i++) {\n        let word = words[i];\n        if (set.has(word)) {\n            res += word.length;\n            set.delete(word);\n        } else {\n            set.add(word);\n        }\n    }\n    if (set.size > 0) {\n        res++;\n    }\n    return res;\n};"}
{"id": "1505", "path": "output2\\js\\Medium\\1505-minimum-swaps-to-group-all-1s-together-ii.js", "hypo_code": "var minSwaps = function(nums) {\n    let n = nums.length;\n    let res = Number.MAX_SAFE_INTEGER;\n    let sum = 0;\n    let count = 0;\n    let left = 0;\n    let right = 0;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n    }\n    if (sum <= 1) {\n        return 0;\n    }\n    for (let i = 0; i < n; i++) {\n        if (nums[i] === 1) {\n            count++;\n        }\n        if (i === sum - 1) {\n            right = count;\n        }\n    }\n    for (let i = 0; i < sum - 1; i++) {\n        if (nums[i] === 1) {\n            left++;\n        }\n        if (nums[i + sum - 1] === 1) {\n            right++;\n        }\n        res = Math.min(res, sum - (right - left));\n    }\n    return res;\n};"}
{"id": "1506", "path": "output2\\js\\Medium\\1506-count-words-obtained-after-adding-a-letter.js", "hypo_code": "var wordCount = function(startWords, targetWords) {\n    let res = 0;\n    let n = startWords.length;\n    let m = targetWords.length;\n    let count = new Array(26).fill(0);\n    for (let word of startWords) {\n        let mask = 0;\n        for (let i = 0; i < word.length; i++) {\n            mask |= 1 << (word.charCodeAt(i) - 'a'.charCodeAt(0));\n        }\n        for (let i = 0; i < 26; i++) {\n            if ((mask & (1 << i)) > 0) {\n                count[i]++;\n            }\n        }\n    }\n    for (let word of targetWords) {\n        let mask = 0;\n        for (let i = 0; i < word.length; i++) {\n            mask |= 1 << (word.charCodeAt(i) - 'a'.charCodeAt(0));\n        }\n        let flag = true;\n        for (let i = 0; i < 26; i++) {\n            if ((mask & (1 << i)) > 0) {\n                if (count[i] === 0) {\n                    flag = false;\n                    break;\n                }\n            }\n        }\n        if (flag) {\n            res++;\n        }\n    }\n    return res;\n};"}
{"id": "1507", "path": "output2\\js\\Medium\\1507-minimum-moves-to-reach-target-score.js", "hypo_code": "var minMoves = function(target, maxDoubles) {\n    let res = 0;\n    while (target > 1) {\n        if (target % 2 === 0) {\n            target /= 2;\n        } else {\n            target--;\n        }\n        res++;\n    }\n    return res + maxDoubles;\n};"}
{"id": "1508", "path": "output2\\js\\Medium\\1508-solving-questions-with-brainpower.js", "hypo_code": "var mostPoints = function(questions) {\n    let n = questions.length;\n    let dp = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        dp[i] = questions[i][0];\n        for (let j = i - 1; j >= 0; j--) {\n            if (i - j > questions[j][1]) {\n                dp[i] = Math.max(dp[i], dp[j] + questions[i][0]);\n                break;\n            }\n        }\n    }\n    return Math.max(...dp);\n};"}
{"id": "1509", "path": "output2\\js\\Medium\\1509-count-the-hidden-sequences.js", "hypo_code": "var numberOfArrays = function(differences, lower, upper) {\n    let n = differences.length;\n    let res = 0;\n    let dp = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        if (i === 0) {\n            dp[i] = [differences[i]];\n        } else {\n            dp[i] = [];\n            for (let j = 0; j < dp[i - 1].length; j++) {\n                let num = dp[i - 1][j] + differences[i];\n                if (num >= lower && num <= upper) {\n                    res++;\n                }\n                dp[i].push(num);\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1510", "path": "output2\\js\\Medium\\1510-k-highest-ranked-items-within-a-price-range.js", "hypo_code": "var highestRankedKItems = function(grid, pricing, start, k) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    let pq = new PriorityQueue((a, b) => {\n        if (a[0] === b[0]) {\n            if (a[1] === b[1]) {\n                if (a[2] === b[2]) {\n                    return a[3] - b[3];\n                } else {\n                    return a[2] - b[2];\n                }\n            } else {\n                return a[1] - b[1];\n            }\n        } else {\n            return a[0] - b[0];\n        }\n    });\n    pq.push([0, grid[start[0]][start[1]], start[0], start[1]]);\n    visited[start[0]][start[1]] = true;\n    let res = [];\n    let dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n    while (pq.size() > 0 && res.length < k) {\n        let [dist, price, i, j] = pq.pop();\n        if (price >= pricing[0] && price <= pricing[1]) {\n            res.push([i, j]);\n        }\n        for (let [di, dj] of dirs) {\n            let newI = i + di;\n            let newJ = j + dj;\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n && !visited[newI][newJ]) {\n                pq.push([dist + 1, grid[newI][newJ], newI, newJ]);\n                visited[newI][newJ] = true;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1511", "path": "output2\\js\\Medium\\1511-rearrange-array-elements-by-sign.js", "hypo_code": "var rearrangeArray = function(nums) {\n    let n = nums.length;\n    let res = [];\n    let pos = [];\n    let neg = [];\n    for (let num of nums) {\n        if (num > 0) {\n            pos.push(num);\n        } else {\n            neg.push(num);\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        if (i % 2 === 0) {\n            res.push(pos.pop());\n        } else {\n            res.push(neg.pop());\n        }\n    }\n    return res;\n};"}
{"id": "1512", "path": "output2\\js\\Medium\\1512-find-all-lonely-numbers-in-the-array.js", "hypo_code": "var findLonely = function(nums) {\n    let n = nums.length;\n    let res = [];\n    let map = {};\n    for (let i = 0; i < n; i++) {\n        if (nums[i] - 1 in map) {\n            map[nums[i] - 1]++;\n        } else if (nums[i] + 1 in map) {\n            map[nums[i] + 1]++;\n        } else {\n            map[nums[i]] = 1;\n        }\n    }\n    for (let num in map) {\n        if (map[num] === 1) {\n            res.push(parseInt(num));\n        }\n    }\n    return res;\n};"}
{"id": "1513", "path": "output2\\js\\Medium\\1513-all-divisions-with-the-highest-score-of-a-binary-array.js", "hypo_code": "var maxScoreIndices = function(nums) {\n    let n = nums.length;\n    let res = [];\n    let left = 0;\n    let right = 0;\n    let leftZeros = 0;\n    let rightOnes = 0;\n    for (let i = 0; i < n; i++) {\n        if (nums[i] === 0) {\n            leftZeros++;\n        }\n        if (nums[i] === 1) {\n            rightOnes++;\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        if (nums[i] === 0) {\n            left++;\n        }\n        if (nums[i] === 1) {\n            right++;\n        }\n        if (left + right === leftZeros + rightOnes) {\n            res.push(i);\n        }\n    }\n    return res;\n\n};"}
{"id": "1514", "path": "output2\\js\\Medium\\1514-partition-array-according-to-given-pivot.js", "hypo_code": "var pivotArray = function(nums, pivot) {\n    let i = 0;\n    let j = 0;\n    let k = nums.length - 1;\n    while (j <= k) {\n        if (nums[j] < pivot) {\n            swap(nums, i, j);\n            i++;\n            j++;\n        } else if (nums[j] > pivot) {\n            swap(nums, j, k);\n            k--;\n        } else {\n            j++;\n        }\n    }\n    return nums;\n    \n    \n};"}
{"id": "1515", "path": "output2\\js\\Medium\\1515-minimum-cost-to-set-cooking-time.js", "hypo_code": "var minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {\n    let min = Number.MAX_VALUE;\n    let minutes = Math.floor(targetSeconds / 60);\n    let seconds = targetSeconds % 60;\n    let arr = [minutes, seconds];\n    let set = new Set();\n    let visited = new Set();\n    let queue = [];\n    queue.push([startAt, 0]);\n    while (queue.length > 0) {\n        let [digit, cost] = queue.shift();\n        if (visited.has(digit)) {\n            continue;\n        }\n        visited.add(digit);\n        if (set.size === 2) {\n            let sum = 0;\n            for (let num of set) {\n                sum += num;\n            }\n            if (sum === targetSeconds) {\n                min = Math.min(min, cost);\n            }\n        }\n        for (let i = 0; i < arr.length; i++) {\n            let diff = Math.abs(digit - arr[i]);\n            let newCost = cost + diff * moveCost + pushCost;\n            if (newCost < min) {\n                queue.push([arr[i], newCost]);\n                set.add(arr[i]);\n            }\n        }\n    }\n    return min;\n    \n};"}
{"id": "1516", "path": "output2\\js\\Medium\\1516-smallest-value-of-the-rearranged-number.js", "hypo_code": "var smallestNumber = function(num) {\n    let arr = [];\n    while (num > 0) {\n        let digit = num % 10;\n        arr.push(digit);\n        num = Math.floor(num / 10);\n    }\n    arr.sort((a, b) => a - b);\n    let res = 0;\n    for (let i = 0; i < arr.length; i++) {\n        res = res * 10 + arr[i];\n    }\n    return res;\n    \n};"}
{"id": "1518", "path": "output2\\js\\Medium\\1518-minimum-operations-to-make-the-array-alternating.js", "hypo_code": "var minimumOperations = function(nums) {\n    let n = nums.length;\n    let res = 0;\n    let even = 0;\n    let odd = 0;\n    for (let i = 0; i < n; i++) {\n        if (nums[i] % 2 === 0) {\n            even++;\n        } else {\n            odd++;\n        }\n    }\n    if (Math.abs(even - odd) > 1) {\n        return -1;\n    }\n    if (even > odd) {\n        for (let i = 0; i < n; i++) {\n            if (i % 2 === 0 && nums[i] % 2 === 1) {\n                res++;\n            }\n        }\n    } else if (odd > even) {\n        for (let i = 0; i < n; i++) {\n            if (i % 2 === 1 && nums[i] % 2 === 0) {\n                res++;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1519", "path": "output2\\js\\Medium\\1519-removing-minimum-number-of-magic-beans.js", "hypo_code": "var minimumRemoval = function(beans) {\n    let n = beans.length;\n    let sum = 0;\n    for (let i = 0; i < n; i++) {\n        sum += beans[i];\n    }\n    if (sum % n !== 0) {\n        return -1;\n    }\n    let avg = sum / n;\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        if (beans[i] > avg) {\n            res += beans[i] - avg;\n        }\n    }\n    return res;\n};"}
{"id": "1520", "path": "output2\\js\\Medium\\1520-find-three-consecutive-integers-that-sum-to-a-given-number.js", "hypo_code": "var sumOfThree = function(num) {\n    let n = num;\n    for (let i = 1; i <= n; i++) {\n        let j = i + 1;\n        let k = j + 1;\n        while (k <= n) {\n            let sum = i + j + k;\n            if (sum === num) {\n                return [i, j, k];\n            } else if (sum > num) {\n                break;\n            }\n            k++;\n        }\n    }\n    return [];\n};"}
{"id": "1521", "path": "output2\\js\\Medium\\1521-maximum-split-of-positive-even-integers.js", "hypo_code": "var maximumEvenSplit = function(finalSum) {\n    let n = finalSum;\n    let res = [];\n    for (let i = 2; i <= n; i += 2) {\n        res.push(i);\n        n -= i;\n    }\n    if (n > 0) {\n        res[res.length - 1] += n;\n    }\n    return res;\n};"}
{"id": "1522", "path": "output2\\js\\Medium\\1522-merge-nodes-in-between-zeros.js", "hypo_code": "var mergeNodes = function(head) {\n    let cur = head;\n    let sum = 0;\n    let prev = null;\n    let res = [];\n    while (cur) {\n        if (cur.val === 0) {\n            if (sum) {\n                res.push(sum);\n                sum = 0;\n            }\n        } else {\n            sum += cur.val;\n        }\n        prev = cur;\n        cur = cur.next;\n    }\n    if (sum) {\n        res.push(sum);\n    }\n    cur = head;\n    let i = 0;\n    while (cur) {\n        if (cur.val === 0) {\n            cur.val = res[i++];\n        }\n        cur = cur.next;\n    }\n    cur = head;\n    while (cur) {\n        if (cur.val === 0) {\n            prev.next = cur.next;\n            cur = cur.next;\n        } else {\n            prev = cur;\n            cur = cur.next;\n        }\n    }\n    return head;\n\n};"}
{"id": "1523", "path": "output2\\js\\Medium\\1523-construct-string-with-repeat-limit.js", "hypo_code": "var repeatLimitedString = function(s, repeatLimit) {\n    let n = s.length;\n    let res = '';\n    let count = new Array(26).fill(0);\n    let last = new Array(26).fill(-1);\n    let max = -1;\n    for (let i = 0; i < n; i++) {\n        let ch = s.charCodeAt(i) - 97;\n        count[ch]++;\n        max = Math.max(max, count[ch]);\n        if (last[ch] !== -1 && i - last[ch] + 1 > repeatLimit) {\n            for (let j = 0; j < 26; j++) {\n                count[j] = 0;\n                last[j] = -1;\n            }\n            max = -1;\n            res = '';\n        } else {\n            last[ch] = i;\n            if (max <= repeatLimit) {\n                res += s[i];\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1524", "path": "output2\\js\\Medium\\1524-minimum-number-of-steps-to-make-two-strings-anagram-ii.js", "hypo_code": "var minSteps = function(s, t) {\n    let n = s.length;\n    let countS = new Array(26).fill(0);\n    let countT = new Array(26).fill(0);\n    for (let i = 0; i < n; i++) {\n        countS[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n        countT[t.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n    }\n    let res = 0;\n    for (let i = 0; i < 26; i++) {\n        if (countS[i] > countT[i]) {\n            res += countS[i] - countT[i];\n        }\n    }\n    return res;\n};"}
{"id": "1525", "path": "output2\\js\\Medium\\1525-minimum-time-to-complete-trips.js", "hypo_code": "var minimumTime = function(time, totalTrips) {\n    let n = time.length;\n    let dp = new Array(n).fill(0);\n    let res = 0;\n    for (let i = 0; i < totalTrips; i++) {\n        dp[0]++;\n        res = Math.max(res, time[0]);\n        for (let j = 1; j < n; j++) {\n            if (dp[j - 1] === 0) {\n                dp[j]++;\n                res = Math.max(res, time[j]);\n            } else {\n                dp[j - 1]--;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1526", "path": "output2\\js\\Medium\\1526-sort-the-jumbled-numbers.js", "hypo_code": "var sortJumbled = function(mapping, nums) {\n    let n = nums.length;\n    let arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        let num = nums[i];\n        let res = 0;\n        while (num > 0) {\n            let digit = num % 10;\n            res = res * 10 + mapping[digit];\n            num = Math.floor(num / 10);\n        }\n        arr[i] = res;\n    }\n    nums.sort((a, b) => a - b);\n    arr.sort((a, b) => a - b);\n    let res = new Array(n);\n    for (let i = 0; i < n; i++) {\n        res[i] = nums[i];\n        for (let j = 0; j < n; j++) {\n            if (nums[i] === arr[j]) {\n                res[i] = nums[j];\n                break;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1527", "path": "output2\\js\\Medium\\1527-all-ancestors-of-a-node-in-a-directed-acyclic-graph.js", "hypo_code": "var getAncestors = function(n, edges) {\n    let res = [];\n    let graph = new Array(n);\n    for (let i = 0; i < n; i++) {\n        graph[i] = [];\n    }\n    let indegree = new Array(n).fill(0);\n    for (let edge of edges) {\n        let from = edge[0];\n        let to = edge[1];\n        graph[from].push(to);\n        indegree[to]++;\n    }\n    let queue = [];\n    for (let i = 0; i < n; i++) {\n        if (indegree[i] === 0) {\n            queue.push(i);\n        }\n    }\n    while (queue.length > 0) {\n        let cur = queue.shift();\n        let ancestors = [];\n        for (let i = 0; i < n; i++) {\n            if (indegree[i] > 0 && graph[i].includes(cur)) {\n                ancestors.push(i);\n                indegree[i]--;\n                if (indegree[i] === 0) {\n                    queue.push(i);\n                }\n            }\n        }\n        res[cur] = ancestors;\n    }\n    return res;\n};"}
{"id": "1528", "path": "output2\\js\\Medium\\1528-append-k-integers-with-minimal-sum.js", "hypo_code": "var minimalKSum = function(nums, k) {\n    let n = nums.length;\n    nums.sort((a, b) => a - b);\n    let sum = 0;\n    let j = 1;\n    for (let i = 0; i < n; i++) {\n        if (j <= nums[i]) {\n            sum += j;\n            j++;\n            i--;\n            k--;\n            if (k === 0) {\n                return sum;\n            }\n        }\n    }\n    while (k > 0) {\n        sum += j;\n        j++;\n        k--;\n    }\n    return sum;\n};"}
{"id": "1529", "path": "output2\\js\\Medium\\1529-create-binary-tree-from-descriptions.js", "hypo_code": "var createBinaryTree = function(descriptions) {\n    let n = descriptions.length;\n    let root = new TreeNode(1);\n    let map = new Map();\n    map.set(1, root);\n    for (let i = 0; i < n; i++) {\n        let parent = descriptions[i][0];\n        let child = descriptions[i][1];\n        let isLeft = descriptions[i][2];\n        let node = new TreeNode(child);\n        if (isLeft) {\n            map.get(parent).left = node;\n        } else {\n            map.get(parent).right = node;\n        }\n        map.set(child, node);\n    }\n    return root;\n};"}
{"id": "1530", "path": "output2\\js\\Medium\\1530-count-artifacts-that-can-be-extracted.js", "hypo_code": "var digArtifacts = function(n, artifacts, dig) {\n    let result = 0;\n    let grid = new Array(n);\n    for (let i = 0; i < n; i++) {\n        grid[i] = new Array(n);\n    }\n    for (let i = 0; i < artifacts.length; i++) {\n        let artifact = artifacts[i];\n        for (let j = artifact[0]; j <= artifact[2]; j++) {\n            for (let k = artifact[1]; k <= artifact[3]; k++) {\n                grid[j][k] = i;\n            }\n        }\n    }\n    for (let i = 0; i < dig.length; i++) {\n        let x = dig[i][0];\n        let y = dig[i][1];\n        if (grid[x][y] !== undefined) {\n            let artifact = artifacts[grid[x][y]];\n            let count = 0;\n            for (let j = artifact[0]; j <= artifact[2]; j++) {\n                for (let k = artifact[1]; k <= artifact[3]; k++) {\n                    if (grid[j][k] !== undefined) {\n                        count++;\n                    }\n                }\n            }\n            if (count === (artifact[2] - artifact[0] + 1) * (artifact[3] - artifact[1] + 1)) {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1531", "path": "output2\\js\\Medium\\1531-maximize-the-topmost-element-after-k-moves.js", "hypo_code": "var maximumTop = function(nums, k) {\n    let n = nums.length;\n    let result = -1;\n    let left = 0;\n    let right = n - 1;\n    let count = 0;\n    while (left < right) {\n        if (nums[left] < nums[right]) {\n            left++;\n        } else if (nums[left] > nums[right]) {\n            right--;\n        } else {\n            left++;\n            right--;\n        }\n        count++;\n    }\n    if (left === right) {\n        result = nums[left];\n    }\n    if (k > count) {\n        k = k - count;\n        if (k % 2 === 1) {\n            result = -1;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1532", "path": "output2\\js\\Medium\\1532-maximize-number-of-subsequences-in-a-string.js", "hypo_code": "var maximumSubsequenceCount = function(text, pattern) {\n    let n = text.length;\n    let m = pattern.length;\n    let dp = new Array(n + 1);\n    for (let i = 0; i <= n; i++) {\n        dp[i] = new Array(m + 1).fill(0);\n    }\n    for (let i = 0; i <= n; i++) {\n        dp[i][0] = 1;\n    }\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= m; j++) {\n            if (text[i - 1] === pattern[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[n][m];\n    \n};"}
{"id": "1533", "path": "output2\\js\\Medium\\1533-minimum-operations-to-halve-array-sum.js", "hypo_code": "var halveArray = function(nums) {\n    let n = nums.length;\n    let sum = 0;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n    }\n    let target = Math.ceil(sum / 2);\n    let left = 0;\n    let right = 0;\n    let curr = 0;\n    let result = n;\n    while (right < n) {\n        curr += nums[right];\n        while (curr >= target) {\n            result = Math.min(result, right - left + 1);\n            curr -= nums[left];\n            left++;\n        }\n        right++;\n    }\n    return n - result;\n    \n};"}
{"id": "1534", "path": "output2\\js\\Medium\\1534-count-collisions-on-a-road.js", "hypo_code": "var countCollisions = function(directions) {\n    let count = 0;\n    let left = 0;\n    let right = 0;\n    for (let i = 0; i < directions.length; i++) {\n        if (directions[i] === 'R') {\n            right++;\n        }\n    }\n    for (let i = 0; i < directions.length; i++) {\n        if (directions[i] === 'L') {\n            left++;\n        } else if (directions[i] === 'R') {\n            right--;\n        } else {\n            count += Math.min(left, right);\n        }\n    }\n    return count;\n    \n};"}
{"id": "1535", "path": "output2\\js\\Medium\\1535-maximum-points-in-an-archery-competition.js", "hypo_code": "var maximumBobPoints = function(numArrows, aliceArrows) {\n    let bobArrows = new Array(12).fill(0);\n    let sum = 0;\n    for (let i = 0; i < 12; i++) {\n        sum += aliceArrows[i];\n    }\n    let max = sum;\n    for (let i = 0; i < 12; i++) {\n        sum -= aliceArrows[i];\n        sum += numArrows;\n        if (sum > max) {\n            max = sum;\n            bobArrows[i] = numArrows;\n        } else {\n            bobArrows[i] = 0;\n        }\n    }\n    return bobArrows;\n    \n};"}
{"id": "1536", "path": "output2\\js\\Medium\\1536-minimum-deletions-to-make-array-beautiful.js", "hypo_code": "var minDeletion = function(nums) {\n    let n = nums.length;\n    let res = n;\n    let dp = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        dp[i] = 1;\n        for (let j = i - 1; j >= 0; j--) {\n            if (nums[j] < nums[i] && (i - j) % 2 === 1) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        res = Math.min(res, n - dp[i]);\n    }\n    return res;\n\n};"}
{"id": "1537", "path": "output2\\js\\Medium\\1537-find-palindrome-with-fixed-length.js", "hypo_code": "var kthPalindrome = function(queries, intLength) {\n    let res = [];\n    for (let query of queries) {\n        res.push(findPalindrome(query, intLength));\n    }\n    return res;\n};\nvar getPalindrome = function(num) {\n    let res = num;\n    let temp = num;\n    while (temp > 0) {\n        res = res * 10 + temp % 10;\n        temp = Math.floor(temp / 10);\n    }\n    return res;\n};"}
{"id": "1538", "path": "output2\\js\\Medium\\1538-find-triangular-sum-of-an-array.js", "hypo_code": "var triangularSum = function(nums) {\n    let n = nums.length;\n    while (n > 1) {\n        let newNums = new Array(n - 1).fill(0);\n        for (let i = 0; i < n - 1; i++) {\n            newNums[i] = (nums[i] + nums[i + 1]) % 10;\n        }\n        nums = newNums;\n        n--;\n    }\n    return nums[0];\n};"}
{"id": "1539", "path": "output2\\js\\Medium\\1539-number-of-ways-to-select-buildings.js", "hypo_code": "var numberOfWays = function(s) {\n    let n = s.length;\n    let mod = 1e9 + 7;\n    let dp = new Array(n + 1).fill(0);\n    let count = 0;\n    for (let i = 0; i < n; i++) {\n        if (s[i] === '1') {\n            count++;\n        }\n    }\n    if (count < 3) {\n        return 0;\n    }\n    dp[3] = count * (count - 1) * (count - 2) / 6;\n    for (let i = 4; i <= n; i++) {\n        if (s[i - 1] === '1') {\n            count--;\n        }\n        dp[i] = dp[i - 1] + (count * (count - 1) / 2) % mod;\n    }\n    return dp[n] % mod;\n};"}
{"id": "1540", "path": "output2\\js\\Medium\\1540-find-players-with-zero-or-one-losses.js", "hypo_code": "var findWinners = function(matches) {\n    let res = [[], []];\n    let map = {};\n    for (let match of matches) {\n        let winner = match[0];\n        let loser = match[1];\n        if (!map[winner]) {\n            map[winner] = 0;\n        }\n        map[winner]++;\n        if (!map[loser]) {\n            map[loser] = 0;\n        }\n        map[loser]--;\n    }\n    for (let key in map) {\n        if (map[key] === 0) {\n            res[0].push(parseInt(key));\n        } else if (map[key] === -1) {\n            res[1].push(parseInt(key));\n        }\n    }\n    return res;\n};"}
{"id": "1541", "path": "output2\\js\\Medium\\1541-maximum-candies-allocated-to-k-children.js", "hypo_code": "var maximumCandies = function(candies, k) {\n    let res = 0;\n    let n = candies.length;\n    let dp = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        dp[i] = 1;\n        for (let j = i - 1; j >= 0; j--) {\n            if (candies[j] - candies[i] === i - j) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i];\n    }\n    return res;\n};"}
{"id": "1542", "path": "output2\\js\\Medium\\1542-minimize-result-by-adding-parentheses-to-expression.js", "hypo_code": "var minimizeResult = function(expression) {\n    let n = expression.length;\n    let res = [];\n    let i = 0;\n    while (i < n) {\n        if (expression[i] !== '+') {\n            res.push(expression[i]);\n            i++;\n        } else {\n            let j = i + 1;\n            while (j < n && expression[j] !== '+') {\n                j++;\n            }\n            res.push('+');\n            res.push('(');\n            res.push(expression.substring(i + 1, j));\n            res.push(')');\n            i = j;\n        }\n    }\n    return res.join('');\n};"}
{"id": "1543", "path": "output2\\js\\Medium\\1543-maximum-product-after-k-increments.js", "hypo_code": "var maximumProduct = function(nums, k) {\n    let res = 1;\n    let n = nums.length;\n    let dp = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        dp[i] = 1;\n        for (let j = i - 1; j >= 0; j--) {\n            if (nums[j] - nums[i] === i - j) {\n                dp[i] += dp[j];\n            }\n        }\n        res = (res + dp[i]) % 1000000007;\n    }\n    return res;\n};"}
{"id": "1544", "path": "output2\\js\\Medium\\1544-number-of-ways-to-buy-pens-and-pencils.js", "hypo_code": "var waysToBuyPensPencils = function(total, cost1, cost2) {\n    let res = 0;\n    for (let i = 0; i <= total / cost1; i++) {\n        let j = Math.floor((total - i * cost1) / cost2);\n        res += j + 1;\n    }\n    return res;\n};"}
{"id": "1546", "path": "output2\\js\\Medium\\1546-minimum-rounds-to-complete-all-tasks.js", "hypo_code": "var minimumRounds = function(tasks) {\n    let n = tasks.length;\n    let result = 0;\n    let left = 0;\n    let right = n - 1;\n    let count = 0;\n    while (left < right) {\n        if (tasks[left] < tasks[right]) {\n            left++;\n        } else if (tasks[left] > tasks[right]) {\n            right--;\n        } else {\n            left++;\n            right--;\n        }\n        count++;\n    }\n    if (left === right) {\n        result = 1;\n    }\n    if (count > 0) {\n        result += Math.ceil(count / 3);\n    }\n    return result;\n    \n};"}
{"id": "1547", "path": "output2\\js\\Medium\\1547-maximum-trailing-zeros-in-a-cornered-path.js", "hypo_code": "var maxTrailingZeros = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    let result = 0;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let count = 0;\n            let num = grid[i][j];\n            while (num % 5 == 0) {\n                count++;\n                num /= 5;\n            }\n            if (i > 0 && j > 0) {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + count;\n            } else if (i > 0) {\n                dp[i][j] = dp[i - 1][j] + count;\n            } else if (j > 0) {\n                dp[i][j] = dp[i][j - 1] + count;\n            } else {\n                dp[i][j] = count;\n            }\n            result = Math.max(result, dp[i][j]);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1548", "path": "output2\\js\\Medium\\1548-count-lattice-points-inside-a-circle.js", "hypo_code": "var countLatticePoints = function(circles) {\n    let count = 0;\n    for (let i = 0; i < circles.length; i++) {\n        let x = circles[i][0];\n        let y = circles[i][1];\n        let r = circles[i][2];\n        for (let j = x - r; j <= x + r; j++) {\n            let y1 = Math.sqrt(r * r - (j - x) * (j - x));\n            let y2 = -y1;\n            if (Math.floor(y1) === y1) {\n                if (y1 + y === Math.floor(y1 + y)) {\n                    count++;\n                }\n                if (y2 + y === Math.floor(y2 + y)) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n    \n};"}
{"id": "1549", "path": "output2\\js\\Medium\\1549-count-number-of-rectangles-containing-each-point.js", "hypo_code": "var countRectangles = function(rectangles, points) {\n    let count = [];\n    for (let i = 0; i < points.length; i++) {\n        let x = points[i][0];\n        let y = points[i][1];\n        let c = 0;\n        for (let j = 0; j < rectangles.length; j++) {\n            let l = rectangles[j][0];\n            let h = rectangles[j][1];\n            if (x <= l && y <= h) {\n                c++;\n            }\n        }\n        count.push(c);\n    }\n    return count;\n    \n    \n\n};"}
{"id": "1550", "path": "output2\\js\\Medium\\1550-minimum-average-difference.js", "hypo_code": "var minimumAverageDifference = function(nums) {\n    let n = nums.length;\n    let prefix = new Array(n + 1).fill(0);\n    for (let i = 0; i < n; i++) {\n        prefix[i + 1] = prefix[i] + nums[i];\n    }\n    let min = Infinity;\n    let result = 0;\n    for (let i = 0; i < n - 1; i++) {\n        let left = Math.floor(prefix[i + 1] / (i + 1));\n        let right = Math.floor((prefix[n] - prefix[i + 1]) / (n - i - 1));\n        let diff = Math.abs(left - right);\n        if (diff < min) {\n            min = diff;\n            result = i;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1551", "path": "output2\\js\\Medium\\1551-count-unguarded-cells-in-the-grid.js", "hypo_code": "var countUnguarded = function(m, n, guards, walls) {\n    let result = m * n;\n    let seen = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    for (let i = 0; i < guards.length; i++) {\n        let guard = guards[i];\n        let x = guard[0];\n        let y = guard[1];\n        seen[x][y] = true;\n        for (let j = 0; j < dirs.length; j++) {\n            let dir = dirs[j];\n            let dx = dir[0];\n            let dy = dir[1];\n            let nx = x + dx;\n            let ny = y + dy;\n            while (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                if (seen[nx][ny]) {\n                    break;\n                }\n                seen[nx][ny] = true;\n                nx += dx;\n                ny += dy;\n            }\n        }\n    }\n    for (let i = 0; i < walls.length; i++) {\n        let wall = walls[i];\n        let x = wall[0];\n        let y = wall[1];\n        if (seen[x][y]) {\n            result--;\n            seen[x][y] = false;\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1552", "path": "output2\\js\\Medium\\1552-minimum-consecutive-cards-to-pick-up.js", "hypo_code": "var minimumCardPickup = function(cards) {\n    let map = {};\n    for (let i = 0; i < cards.length; i++) {\n        if (map[cards[i]] === undefined) {\n            map[cards[i]] = 1;\n        } else {\n            map[cards[i]]++;\n        }\n    }\n    let min = Infinity;\n    for (let key in map) {\n        if (map[key] % 2 === 0) {\n            min = Math.min(min, cards.length - map[key]);\n        }\n    }\n    return min === Infinity ? -1 : min;\n    \n};"}
{"id": "1553", "path": "output2\\js\\Medium\\1553-k-divisible-elements-subarrays.js", "hypo_code": "var countDistinct = function(nums, k, p) {\n    let map = {};\n    let count = 0;\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        let mod = sum % p;\n        if (map[mod] === undefined) {\n            map[mod] = 1;\n        } else {\n            map[mod]++;\n        }\n        if (i >= k) {\n            let prevMod = (sum - nums[i - k]) % p;\n            map[prevMod]--;\n        }\n        if (i >= k - 1) {\n            for (let key in map) {\n                if (map[key] > 0) {\n                    count += map[key];\n                }\n            }\n        }\n    }\n    return count;\n    \n};"}
{"id": "1554", "path": "output2\\js\\Medium\\1554-count-nodes-equal-to-average-of-subtree.js", "hypo_code": "var averageOfSubtree = function(root) {\n    let result = 0;\n    let stack = [];\n    let node = root;\n    while (node || stack.length) {\n        while (node) {\n            stack.push(node);\n            node = node.left;\n        }\n        node = stack.pop();\n        if (node.val >= root.val) {\n            result++;\n        }\n        node = node.right;\n    }\n    return result;\n    \n};"}
{"id": "1555", "path": "output2\\js\\Medium\\1555-count-number-of-texts.js", "hypo_code": "var countTexts = function(pressedKeys) {\n    let mod = 1e9 + 7;\n    let n = pressedKeys.length;\n    let res = 1;\n    let cur = 0;\n    for (let i = 0; i < n; i++) {\n        if (i > 0 && pressedKeys[i] !== pressedKeys[i - 1]) {\n            res = (res * getCombinations(cur)) % mod;\n            cur = 0;\n        }\n        cur++;\n    }\n    res = (res * getCombinations(cur)) % mod;\n    return res;\n};"}
{"id": "1556", "path": "output2\\js\\Medium\\1556-number-of-ways-to-split-array.js", "hypo_code": "var waysToSplitArray = function(nums) {\n    let n = nums.length;\n    let sum = 0;\n    let left = 0;\n    let right = 0;\n    let count = 0;\n    let mod = 1000000007;\n    let prefix = new Array(n);\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        prefix[i] = sum;\n    }\n    for (let i = 0; i < n - 2; i++) {\n        left = prefix[i];\n        let max = Math.min(prefix[n - 1] - left, 2 * left);\n        let min = Math.max(prefix[n - 2] - left, left);\n        let start = i + 1;\n        let end = n - 2;\n        while (start <= end) {\n            let mid = Math.floor((start + end) / 2);\n            if (prefix[mid] >= min && prefix[mid] <= max) {\n                count = (count + (mid - i)) % mod;\n                break;\n            } else if (prefix[mid] < min) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n    return count;\n    \n};"}
{"id": "1557", "path": "output2\\js\\Medium\\1557-maximum-white-tiles-covered-by-a-carpet.js", "hypo_code": "var maximumWhiteTiles = function(tiles, carpetLen) {\n    let n = tiles.length;\n    let start = new Array(n);\n    let end = new Array(n);\n    for (let i = 0; i < n; i++) {\n        start[i] = tiles[i][0];\n        end[i] = tiles[i][1];\n    }\n    start.sort((a, b) => a - b);\n    end.sort((a, b) => a - b);\n    let count = 0;\n    let max = 0;\n    let i = 0;\n    let j = 0;\n    while (i < n && j < n) {\n        if (start[i] <= end[j]) {\n            count++;\n            max = Math.max(max, count);\n            i++;\n        } else {\n            count--;\n            j++;\n        }\n    }\n    return max + carpetLen - 1;\n    \n};"}
{"id": "1558", "path": "output2\\js\\Medium\\1558-maximum-consecutive-floors-without-special-floors.js", "hypo_code": "var maxConsecutive = function(bottom, top, special) {\n    let n = top - bottom + 1;\n    let count = 0;\n    let max = 0;\n    let map = {};\n    for (let i = 0; i < special.length; i++) {\n        map[special[i]] = true;\n    }\n    for (let i = bottom; i <= top; i++) {\n        if (map[i] === undefined) {\n            count++;\n            max = Math.max(max, count);\n        } else {\n            count = 0;\n        }\n    }\n    return max;\n    \n};"}
{"id": "1559", "path": "output2\\js\\Medium\\1559-largest-combination-with-bitwise-and-greater-than-zero.js", "hypo_code": "var largestCombination = function(candidates) {\n    let n = candidates.length;\n    let max = 0;\n    let map = {};\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            let and = candidates[i] & candidates[j];\n            if (and > 0) {\n                map[and] = true;\n                max = Math.max(max, and);\n            }\n        }\n    }\n    return max;\n    \n};"}
{"id": "1560", "path": "output2\\js\\Medium\\1560-maximum-bags-with-full-capacity-of-rocks.js", "hypo_code": "var maximumBags = function(capacity, rocks, additionalRocks) {\n    let n = capacity.length;\n    let minHeap = new MinHeap();\n    for (let i = 0; i < n; i++) {\n        minHeap.add(capacity[i] - rocks[i]);\n    }\n    while (additionalRocks > 0) {\n        let min = minHeap.poll();\n        if (min === 0) {\n            break;\n        }\n        min--;\n        additionalRocks--;\n        minHeap.add(min);\n    }\n    let count = 0;\n    while (minHeap.size() > 0) {\n        let min = minHeap.poll();\n        if (min === 0) {\n            count++;\n        }\n    }\n    return count;\n    \n    \n};"}
{"id": "1561", "path": "output2\\js\\Medium\\1561-minimum-lines-to-represent-a-line-chart.js", "hypo_code": "var minimumLines = function(stockPrices) {\n    let result = 1;\n    for(let i = 1; i < stockPrices.length; i++){\n        if(stockPrices[i][1] !== stockPrices[i - 1][1]){\n            result++;\n        }\n    }\n    return result;\n};"}
{"id": "1562", "path": "output2\\js\\Medium\\1562-sender-with-largest-word-count.js", "hypo_code": "var largestWordCount = function(messages, senders) {\n    let map = {};\n    for (let i = 0; i < messages.length; i++) {\n        let words = messages[i].split(\" \");\n        if (map[senders[i]] === undefined) {\n            map[senders[i]] = words.length;\n        } else {\n            map[senders[i]] += words.length;\n        }\n    }\n    let max = 0;\n    let name = \"\";\n    for (let key in map) {\n        if (map[key] > max) {\n            max = map[key];\n            name = key;\n        } else if (map[key] === max) {\n            name = key > name ? key : name;\n        }\n    }\n    return name;\n    \n};"}
{"id": "1563", "path": "output2\\js\\Medium\\1563-maximum-total-importance-of-roads.js", "hypo_code": "var maximumImportance = function(n, roads) {\n    let graph = new Graph(n);\n    for (let i = 0; i < roads.length; i++) {\n        graph.addEdge(roads[i][0], roads[i][1]);\n    }\n    let max = 0;\n    for (let i = 1; i <= n; i++) {\n        let sum = 0;\n        for (let j = 0; j < n; j++) {\n            sum += graph.dijkstra(i, j);\n        }\n        max = Math.max(max, sum);\n    }\n    return max;\n    \n    \n};"}
{"id": "1564", "path": "output2\\js\\Medium\\1564-apply-discount-to-prices.js", "hypo_code": "var discountPrices = function(sentence, discount) {\n    let words = sentence.split(\" \");\n    for (let i = 0; i < words.length; i++) {\n        if (words[i].charAt(0) === \"$\") {\n            let price = parseInt(words[i].substring(1));\n            let discountPrice = (price - (price * discount / 100)).toFixed(2);\n            words[i] = \"$\" + discountPrice;\n        }\n    }\n    return words.join(\" \");\n    \n};"}
{"id": "1565", "path": "output2\\js\\Medium\\1565-steps-to-make-array-non-decreasing.js", "hypo_code": "var totalSteps = function(nums) {\n    let n = nums.length;\n    let count = 0;\n    let left = 0;\n    let right = n - 1;\n    let max = -Infinity;\n    while (left < right) {\n        if (nums[left] < nums[right]) {\n            max = Math.max(max, nums[left]);\n            left++;\n        } else if (nums[left] > nums[right]) {\n            max = Math.max(max, nums[right]);\n            right--;\n        } else {\n            max = Math.max(max, nums[left]);\n            left++;\n            right--;\n        }\n        count++;\n    }\n    if (left === right) {\n        max = Math.max(max, nums[left]);\n    }\n    return count;\n    \n    \n};"}
{"id": "1566", "path": "output2\\js\\Medium\\1566-partition-array-such-that-maximum-difference-is-k.js", "hypo_code": "var partitionArray = function(nums, k) {\n    let n = nums.length;\n    let res = 0;\n    let map = new Map();\n    for (let i = 0; i < n; i++) {\n        let min = nums[i] - k;\n        if (map.has(min)) {\n            let val = map.get(min);\n            if (val === 1) {\n                map.delete(min);\n            } else {\n                map.set(min, val - 1);\n            }\n        } else {\n            res++;\n        }\n        map.set(nums[i], (map.get(nums[i]) || 0) + 1);\n    }\n    return res;\n};"}
{"id": "1567", "path": "output2\\js\\Medium\\1567-replace-elements-in-an-array.js", "hypo_code": "var arrayChange = function(nums, operations) {\n    let n = nums.length;\n    let m = operations.length;\n    let res = [];\n    let map = new Map();\n    for (let i = 0; i < n; i++) {\n        map.set(nums[i], i);\n    }\n    for (let i = 0; i < m; i++) {\n        let index = map.get(operations[i][0]);\n        map.set(operations[i][0], -1);\n        map.set(operations[i][1], index);\n    }\n    let max = -1;\n    for (let i = 0; i < n; i++) {\n        if (map.get(i) === -1) {\n            res.push(i);\n        } else {\n            res.push(nums[map.get(i)]);\n            max = Math.max(max, nums[map.get(i)]);\n        }\n    }\n    res.push(max + 1);\n    return res;\n};"}
{"id": "1568", "path": "output2\\js\\Medium\\1568-successful-pairs-of-spells-and-potions.js", "hypo_code": "var successfulPairs = function(spells, potions, success) {\n    let n = spells.length;\n    let m = potions.length;\n    let pairs = new Array(n);\n    for (let i = 0; i < n; i++) {\n        let count = 0;\n        for (let j = 0; j < m; j++) {\n            if (spells[i] * potions[j] >= success) {\n                count++;\n            }\n        }\n        pairs[i] = count;\n    }\n    return pairs;\n    \n};"}
{"id": "1569", "path": "output2\\js\\Medium\\1569-minimum-path-cost-in-a-grid.js", "hypo_code": "var minPathCost = function(grid, moveCost) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let dp = new Array(m).fill(0).map(() => new Array(n).fill(Number.MAX_VALUE));\n    for (let i = 0; i < n; i++) {\n        dp[0][i] = grid[0][i];\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            for (let k = 0; k < n; k++) {\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + moveCost[grid[i - 1][k]][k] + grid[i][j]);\n            }\n        }\n    }\n    let min = Number.MAX_VALUE;\n    for (let i = 0; i < n; i++) {\n        min = Math.min(min, dp[m - 1][i]);\n    }\n    return min;\n    \n};"}
{"id": "1570", "path": "output2\\js\\Medium\\1570-fair-distribution-of-cookies.js", "hypo_code": "var distributeCookies = function(cookies, k) {\n    cookies.sort((a, b) => a - b);\n    let n = cookies.length;\n    let dp = new Array(n).fill(0).map(() => new Array(k).fill(Number.MAX_VALUE));\n    for (let i = 0; i < n; i++) {\n        dp[i][0] = 0;\n    }\n    for (let i = 1; i < k; i++) {\n        for (let j = i; j < n; j++) {\n            for (let l = i - 1; l < j; l++) {\n                dp[j][i] = Math.min(dp[j][i], dp[l][i - 1] + (cookies[j] - cookies[l]) * (cookies[j] - cookies[l]));\n            }\n        }\n    }\n    return dp[n - 1][k - 1];\n    \n};"}
{"id": "1571", "path": "output2\\js\\Medium\\1571-sum-of-numbers-with-units-digit-k.js", "hypo_code": "var minimumNumbers = function(num, k) {\n    if (num < k) {\n        return -1;\n    }\n    if (num === k) {\n        return 1;\n    }\n    let res = 0;\n    while (num > 0) {\n        let digit = num % 10;\n        num = Math.floor(num / 10);\n        if (digit > k) {\n            res += Math.ceil(digit / k);\n            k = 10;\n        } else if (digit === k) {\n            res++;\n            k = 10;\n        } else {\n            k -= digit;\n        }\n    }\n    return res;\n};"}
{"id": "1572", "path": "output2\\js\\Medium\\1572-longest-binary-subsequence-less-than-or-equal-to-k.js", "hypo_code": "var longestSubsequence = function(s, k) {\n    let n = s.length;\n    let dp = new Array(n + 1).fill(0).map(() => new Array(k + 1).fill(0));\n    for (let j = 0; j <= k; j++) {\n        dp[0][j] = -1;\n    }\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j <= k; j++) {\n            if (s[i - 1] === '0') {\n                dp[i][j] = dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n        }\n        for (let j = 0; j <= k; j++) {\n            if (dp[i - 1][j] !== -1) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    let res = 0;\n    for (let j = 0; j <= k; j++) {\n        res = Math.max(res, dp[n][j]);\n    }\n    return res;\n};"}
{"id": "1573", "path": "output2\\js\\Medium\\1573-count-unreachable-pairs-of-nodes-in-an-undirected-graph.js", "hypo_code": "var countPairs = function(n, edges) {\n    let graph = new Array(n).fill(0).map(() => new Array());\n    for (let edge of edges) {\n        let u = edge[0];\n        let v = edge[1];\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    let visited = new Array(n).fill(false);\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            let cnt = 0;\n            dfs(i);\n            res += cnt * (cnt - 1) / 2;\n        }\n    }\n    return res;\n    function dfs(u) {\n        visited[u] = true;\n        cnt++;\n        for (let v of graph[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    }\n};"}
{"id": "1574", "path": "output2\\js\\Medium\\1574-maximum-xor-after-operations.js", "hypo_code": "var maximumXOR = function(nums) {\n    let res = 0;\n    for (let i = 30; i >= 0; i--) {\n        let prefix = new Set();\n        for (let num of nums) {\n            prefix.add(num >> i);\n        }\n        let cur = (res << 1) + 1;\n        let found = false;\n        for (let num of nums) {\n            if (prefix.has(num >> i ^ cur)) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            res = cur;\n        } else {\n            res = cur - 1;\n        }\n    }\n    return res;\n};"}
{"id": "1575", "path": "output2\\js\\Medium\\1575-count-number-of-ways-to-place-houses.js", "hypo_code": "var countHousePlacements = function(n) {\n    let result = 0;\n    let i = 0;\n    while (i < n) {\n        result += 2;\n        i++;\n    }\n    return result;\n};"}
{"id": "1576", "path": "output2\\js\\Medium\\1576-spiral-matrix-iv.js", "hypo_code": "var spiralMatrix = function(m, n, head) {\n    let res = [];\n    for (let i = 0; i < m; i++) {\n        res.push(new Array(n).fill(-1));\n    }\n    let count = 0;\n    let cur = head;\n    let len = m * n;\n    let row = 0;\n    let col = 0;\n    let dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    let dir = 0;\n    while (cur && count < len) {\n        res[row][col] = cur.val;\n        count++;\n        let nextRow = row + dirs[dir][0];\n        let nextCol = col + dirs[dir][1];\n        if (nextRow < 0 || nextRow >= m || nextCol < 0 || nextCol >= n || res[nextRow][nextCol] !== -1) {\n            dir = (dir + 1) % 4;\n        }\n        row += dirs[dir][0];\n        col += dirs[dir][1];\n        cur = cur.next;\n    }\n    return res;\n};"}
{"id": "1577", "path": "output2\\js\\Medium\\1577-number-of-people-aware-of-a-secret.js", "hypo_code": "var peopleAwareOfSecret = function(n, delay, forget) {\n    let dp = new Array(delay + 1).fill(0);\n    dp[0] = 1;\n    for (let i = 1; i <= n; i++) {\n        let sum = 0;\n        for (let j = delay; j > 0; j--) {\n            sum += dp[j - 1];\n            if (j > forget) {\n                sum -= dp[j - forget - 1];\n            }\n        }\n        dp[delay] = sum % 1000000007;\n        for (let j = 0; j < delay; j++) {\n            dp[j] = dp[j + 1];\n        }\n    }\n    return dp[0];\n};"}
{"id": "1578", "path": "output2\\js\\Medium\\1578-the-latest-time-to-catch-a-bus.js", "hypo_code": "var latestTimeCatchTheBus = function(buses, passengers, capacity) {\n    let n = buses.length;\n    let m = passengers.length;\n    let maxTime = buses[n - 1];\n    let waiting = [];\n    for (let i = 0; i < m; i++) {\n        waiting.push([passengers[i], i]);\n    }\n    waiting.sort((a, b) => a[0] - b[0]);\n    let time = 0;\n    let idx = 0;\n    let curPassengers = 0;\n    while (time <= maxTime && idx < n) {\n        if (curPassengers >= capacity) {\n            curPassengers -= capacity;\n            idx++;\n        } else {\n            if (waiting.length && waiting[0][0] <= buses[idx]) {\n                curPassengers++;\n                waiting.shift();\n            } else {\n                time++;\n            }\n        }\n    }\n    return time;\n};"}
{"id": "1579", "path": "output2\\js\\Medium\\1579-minimum-sum-of-squared-difference.js", "hypo_code": "var minSumSquareDiff = function(nums1, nums2, k1, k2) {\n    let n = nums1.length;\n    let m = nums2.length;\n    nums1.sort((a, b) => a - b);\n    nums2.sort((a, b) => a - b);\n    let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(0));\n    for (let i = 1; i <= n; i++) {\n        dp[i][0] = dp[i - 1][0] + nums1[i - 1] * nums1[i - 1];\n    }\n    for (let j = 1; j <= m; j++) {\n        dp[0][j] = dp[0][j - 1] + nums2[j - 1] * nums2[j - 1];\n    }\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= m; j++) {            \n            dp[i][j] = Math.min(dp[i - 1][j] + nums1[i - 1] * nums1[i - 1], dp[i][j - 1] + nums2[j - 1] * nums2[j - 1], dp[i - 1][j - 1] + (nums1[i - 1] - nums2[j - 1]) * (nums1[i - 1] - nums2[j - 1]));\n        }\n    }\n    return dp[n][m];\n};"}
{"id": "1581", "path": "output2\\js\\Medium\\1581-move-pieces-to-obtain-a-string.js", "hypo_code": "var canChange = function(start, target) {\n    let n = start.length;\n    let i = 0;\n    while (i < n) {\n        if (start[i] !== '_') {\n            if (start[i] !== target[i]) {\n                return false;\n            }\n        }\n        i++;\n    }\n    return true;\n};"}
{"id": "1582", "path": "output2\\js\\Medium\\1582-max-sum-of-a-pair-with-equal-sum-of-digits.js", "hypo_code": "var maximumSum = function(nums) {\n    let max = 0;\n    let map = new Map();\n    for (let num of nums) {\n        let sum = getSum(num);\n        max = Math.max(max, sum);\n        if (map.has(sum)) {\n            map.set(sum, Math.max(map.get(sum), num));\n        } else {\n            map.set(sum, num);\n        }\n    }\n    for (let num of nums) {\n        let sum = getSum(num);\n        if (map.get(sum) !== num) {\n            max = Math.max(max, sum + map.get(sum));\n        }\n    }\n    return max;\n    function getSum(num) {\n        let sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        return sum;\n};"}
{"id": "1583", "path": "output2\\js\\Medium\\1583-query-kth-smallest-trimmed-number.js", "hypo_code": "var smallestTrimmedNumbers = function(nums, queries) {\n    let n = nums.length;\n    let m = queries.length;\n    let res = new Array(m).fill(0);\n    let radix = 10;\n    for (let i = 0; i < m; i++) {\n        let k = queries[i][0];\n        let trim = queries[i][1];\n        let arr = new Array(radix).fill(0);\n        for (let j = 0; j < n; j++) {\n            let str = nums[j];\n            let num = parseInt(str.substring(str.length - trim));\n            arr[num] += 1;\n        }\n        let count = 0;\n        let index = 0;\n        while (count < k) {\n            count += arr[index];\n            index += 1;\n        }\n        res[i] = index - 1;\n    }\n    return res;\n};"}
{"id": "1584", "path": "output2\\js\\Medium\\1584-number-of-zero-filled-subarrays.js", "hypo_code": "var zeroFilledSubarray = function(nums) {\n    let n = nums.length;\n    let dp = new Array(n).fill(0).map(() => new Array(2).fill(0));\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        if (nums[i] === 0) {\n            dp[i][0] = 1;\n            if (i > 0) {\n                dp[i][1] = dp[i - 1][0] + 1;\n            }\n        }\n        res += dp[i][1];\n    }\n    return res;\n    \n};"}
{"id": "1586", "path": "output2\\js\\Medium\\1586-equal-row-and-column-pairs.js", "hypo_code": "var equalPairs = function(grid) {\n    let n = grid.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === grid[j][i]) {\n                dp[i][j] = 1;\n                if (i > 0) {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if (j > 0) {\n                    dp[i][j] += dp[i][j - 1];\n                }\n                if (i > 0 && j > 0) {\n                    dp[i][j] -= dp[i - 1][j - 1];\n                }\n            }\n            res += dp[i][j];\n        }\n    }\n    return res;\n    \n};"}
{"id": "1588", "path": "output2\\js\\Medium\\1588-maximum-number-of-groups-entering-a-competition.js", "hypo_code": "var maximumGroups = function(grades) {\n    let n = grades.length;\n    let res = 0;\n    let sum = 0;\n    let count = 0;\n    let map = new Map();\n    for (let i = 0; i < n; i++) {\n        sum += grades[i];\n        if (sum % 5 === 0) {\n            res++;\n            sum = 0;\n            count = 0;\n        } else {\n            count++;\n            let diff = sum % 5;\n            if (map.has(diff)) {\n                res++;\n                sum = 0;\n                count = 0;\n                map.delete(diff);\n            } else {\n                map.set(5 - diff, 1);\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1589", "path": "output2\\js\\Medium\\1589-find-closest-node-to-given-two-nodes.js", "hypo_code": "var closestMeetingNode = function(edges, node1, node2) {\n    let n = edges.length;\n    let graph = new Array(n).fill(0).map(() => new Array());\n    for (let i = 0; i < n; i++) {\n        let u = i;\n        let v = edges[i];\n        if (v === -1) {\n            continue;\n        }\n        graph[u].push(v);\n    }\n    let visited = new Array(n).fill(false);\n    let dist1 = new Array(n).fill(0);\n    let dist2 = new Array(n).fill(0);\n    let res = -1;\n    dfs(node1, dist1);\n    dfs(node2, dist2);\n    for (let i = 0; i < n; i++) {\n        if (dist1[i] !== 0 && dist2[i] !== 0) {\n            if (res === -1 || Math.max(dist1[i], dist2[i]) < Math.max(dist1[res], dist2[res])) {\n                res = i;\n            }\n        }\n    }\n    return res;\n    function dfs(u, dist) {\n        visited[u] = true;\n        for (let v of graph[u]) {\n            if (!visited[v]) {\n                dist[v] = dist[u] + 1;\n                dfs(v, dist);\n            }\n        }\n    }\n};"}
{"id": "1590", "path": "output2\\js\\Medium\\1590-count-number-of-bad-pairs.js", "hypo_code": "var countBadPairs = function(nums) {\n    let n = nums.length;\n    let res = 0;\n    let dp = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        dp[i] = 1;\n        for (let j = i - 1; j >= 0; j--) {\n            if (nums[i] - nums[j] !== i - j) {\n                dp[i] += dp[j];\n            }\n        }\n        res += dp[i] - 1;\n    }\n    return res;\n};"}
{"id": "1591", "path": "output2\\js\\Medium\\1591-task-scheduler-ii.js", "hypo_code": "var taskSchedulerII = function(tasks, space) {\n    \n\tlet map = new Map();\n\tfor (let task of tasks) {\n\t\tmap.set(task, map.get(task) + 1 || 1);\n\t}\n\t\n\tlet arr = [...map.entries()].sort((a, b) => b[1] - a[1]);\n\t\n\tlet max = arr[0][1];\n\tlet res = (max - 1) * (space + 1);\n\t\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i][1] === max) {\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn Math.max(res, tasks.length);\n};"}
{"id": "1592", "path": "output2\\js\\Medium\\1592-reachable-nodes-with-restrictions.js", "hypo_code": "var reachableNodes = function(n, edges, restricted) {\n    let graph = new Map();\n    for (let [u, v, w] of edges) {\n        if (!graph.has(u)) graph.set(u, []);\n        if (!graph.has(v)) graph.set(v, []);\n        graph.get(u).push([v, w]);\n        graph.get(v).push([u, w]);\n    }\n    let dist = new Map();\n    let pq = [[0, 0]];\n    while (pq.length) {\n        let [d, u] = pq.pop();\n        if (dist.has(u)) continue;\n        dist.set(u, d);\n        if (graph.has(u)) {\n            for (let [v, w] of graph.get(u)) {\n                if (dist.has(v)) continue;\n                pq.push([d + w + 1, v]);\n            }\n        }\n    }\n    let res = 0;\n    for (let [u, v, w] of edges) {\n        let d1 = dist.has(u) ? dist.get(u) : Infinity;\n        let d2 = dist.has(v) ? dist.get(v) : Infinity;\n        if (d1 + d2 > w) {\n            res += w;\n        } else if (d1 + d2 === w) {\n            res += Math.min(d1, d2);\n        } else {\n            res += Math.max(0, w - (d1 - d2));\n        }\n    }\n    for (let u of restricted) {\n        if (dist.has(u)) {\n            res++;\n        } else {\n            return -1;\n        }\n    }\n    return res;\n\n};"}
{"id": "1593", "path": "output2\\js\\Medium\\1593-check-if-there-is-a-valid-partition-for-the-array.js", "hypo_code": "var validPartition = function(nums) {\n    let map = new Map();\n    for (let num of nums) {\n        map.set(num, map.get(num) + 1 || 1);\n    }\n    let arr = [...map.entries()].sort((a, b) => b[1] - a[1]);\n    let max = arr[0][1];\n    let res = (max - 1) * 2;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i][1] === max) {\n            res++;\n        }\n    }\n    return res >= nums.length;\n};"}
{"id": "1594", "path": "output2\\js\\Medium\\1594-longest-ideal-subsequence.js", "hypo_code": "var longestIdealString = function(s, k) {\n    let map = new Map();\n    for (let c of s) {\n        map.set(c, map.get(c) + 1 || 1);\n    }\n    let arr = [...map.entries()].sort((a, b) => a[0].charCodeAt() - b[0].charCodeAt());\n    let res = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (i === arr.length - 1) {\n            res += arr[i][1];\n        } else {\n            let diff = arr[i + 1][0].charCodeAt() - arr[i][0].charCodeAt();\n            if (diff <= k) {\n                res += arr[i][1];\n            } else {\n                res += arr[i][1] - 1;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1595", "path": "output2\\js\\Medium\\1595-node-with-highest-edge-score.js", "hypo_code": "var edgeScore = function(edges) {\n    let n = edges.length;\n    let arr = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        if (edges[i] >= n) continue;\n        arr[edges[i]] += i;\n    }\n    let max = 0;\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        if (max < arr[i]) {\n            max = arr[i];\n            res = i;\n        }\n    }\n    return res;\n};"}
{"id": "1596", "path": "output2\\js\\Medium\\1596-construct-smallest-number-from-di-string.js", "hypo_code": "var smallestNumber = function(pattern) {\n    let n = pattern.length;\n    let arr = new Array(n + 1).fill(0);\n    for (let i = 0; i <= n; i++) {\n        arr[i] = i + 1;\n    }\n    let res = \"\";\n    for (let i = 0; i < n; i++) {\n        if (pattern[i] === \"I\") {\n            res += arr.shift();\n        } else {\n            res += arr.pop();\n        }\n    }\n    res += arr[0];\n    return res;\n};"}
{"id": "1597", "path": "output2\\js\\Medium\\1597-time-needed-to-rearrange-a-binary-string.js", "hypo_code": "var secondsToRemoveOccurrences = function(s) {\n    let res = 0;\n    while (s.indexOf('01') !== -1) {\n        s = s.replace(/01/g, '10');\n        res++;\n    }\n    return res;\n};"}
{"id": "1598", "path": "output2\\js\\Medium\\1598-shifting-letters-ii.js", "hypo_code": "var shiftingLetters = function(s, shifts) {\n    let n = s.length;\n    let arr = new Array(n).fill(0);\n    for (let i = 0; i < shifts.length; i++) {\n        arr[shifts[i][0]] += shifts[i][2];\n        if (shifts[i][1] + 1 < n) {\n            arr[shifts[i][1] + 1] -= shifts[i][2];\n        }\n    }\n    let res = \"\";\n    let sum = 0;\n    for (let i = 0; i < n; i++) {\n        sum += arr[i];\n        let char = String.fromCharCode((s[i].charCodeAt() - 97 + sum) % 26 + 97);\n        res += char;\n    }\n    return res;\n};"}
{"id": "1599", "path": "output2\\js\\Medium\\1599-largest-palindromic-number.js", "hypo_code": "var largestPalindromic = function(num) {\n    let n = num.length;\n    let arr = new Array(10).fill(0);\n    for (let i = 0; i < n; i++) {\n        arr[num[i].charCodeAt() - 48]++;\n    }\n    let res = \"\";\n    let i = 9;\n    while (i >= 0) {\n        while (arr[i] > 0) {\n            res += i;\n            arr[i]--;\n        }\n        i--;\n    }\n    let l = 0;\n    let r = res.length - 1;\n    while (l < r) {\n        if (res[l] === res[r]) {\n            l++;\n            r--;\n        } else {\n            break;\n        }\n    }\n    if (l >= r) return res;\n    let arr2 = [...res];\n    let arr3 = [...res];\n    let l2 = l;\n    let r2 = r;\n    while (l2 < r2) {\n        if (res[l2] === res[r2]) {\n            l2++;\n            r2--;\n        } else if (res[l2] < res[r2]) {\n            while (l < r) {\n                if (res[l] === res[r]) {\n                    l++;\n                    r--;\n                } else {\n                    arr2[r] = res[l];\n                    break;\n                }\n            }\n            break;\n        } else {\n            while (l < r) {\n                if (res[l] === res[r]) {\n                    l++;\n                    r--;\n                } else {\n                    arr3[l] = res[r];\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    return arr2.join(\"\") > arr3.join(\"\") ? arr2.join(\"\") : arr3.join(\"\");\n\n};"}
{"id": "1600", "path": "output2\\js\\Medium\\1600-amount-of-time-for-binary-tree-to-be-infected.js", "hypo_code": "var amountOfTime = function(root, start) {\n    let map = new Map();\n    let dfs = (root) => {\n        if (!root) return 0;\n        let left = dfs(root.left);\n        let right = dfs(root.right);\n        if (left === start || right === start) {\n            map.set(root.val, 1);\n        } else if (map.has(left) || map.has(right)) {\n            map.set(root.val, 1);\n        } else if (map.has(root.val)) {\n            map.set(root.val, 1);\n        }\n        return root.val;\n    }\n    dfs(root);\n    let res = 0;\n    for (let [key, val] of map) {\n        if (val === 1) res++;\n    }\n    return res;\n\n};"}
{"id": "1601", "path": "output2\\js\\Medium\\1601-removing-stars-from-a-string.js", "hypo_code": "var removeStars = function(s) {\n    let stack = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === \"*\") {\n            if (stack.length > 0) {\n                stack.pop();\n            }\n        } else {\n            stack.push(s[i]);\n        }\n    }\n    return stack.join(\"\");\n};"}
{"id": "1602", "path": "output2\\js\\Medium\\1602-minimum-amount-of-time-to-collect-garbage.js", "hypo_code": "var garbageCollection = function(garbage, travel) {\n    let res = 0;\n    let m = 0;\n    let p = 0;\n    let g = 0;\n    for (let i = 0; i < garbage.length; i++) {\n        if (garbage[i].includes(\"M\")) m++;\n        if (garbage[i].includes(\"P\")) p++;\n        if (garbage[i].includes(\"G\")) g++;\n    }\n    let arr = [m, p, g].sort((a, b) => a - b);\n    let max = arr.pop();\n    res = (max - 1) * (travel[0] + travel[1]);\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === max) {\n            res++;\n        } else {\n            res += travel[0] + travel[1];\n        }\n    }\n    return res;\n};"}
{"id": "1603", "path": "output2\\js\\Medium\\1603-strictly-palindromic-number.js", "hypo_code": "var isStrictlyPalindromic = function(n) {\n    for (let i = 2; i <= n - 2; i++) {\n        let str = n.toString(i);\n        if (str !== str.split('').reverse().join('')) return false;\n    }\n    return true;\n};"}
{"id": "1604", "path": "output2\\js\\Medium\\1604-maximum-rows-covered-by-columns.js", "hypo_code": "var maximumRows = function(matrix, numSelect) {\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let res = 0;\n    for (let i = 0; i < m; i++) {\n        let arr = [];\n        for (let j = 0; j < n; j++) {\n            if (matrix[i][j] === 1) {\n                arr.push(j);\n            }\n        }\n        if (arr.length <= numSelect) {\n            res++;\n        }\n    }\n    return res;\n};"}
{"id": "1605", "path": "output2\\js\\Medium\\1605-number-of-ways-to-reach-a-position-after-exactly-k-steps.js", "hypo_code": "var numberOfWays = function(startPos, endPos, k) {\n    let mod = 1000000007;\n    let dp = new Array(k + 1).fill(0).map(() => new Array(2001).fill(0));\n    dp[0][startPos] = 1;\n    for (let i = 1; i <= k; i++) {\n        for (let j = 1; j <= 2000; j++) {\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];\n            dp[i][j] %= mod;\n        }\n    }\n    return dp[k][endPos];\n};"}
{"id": "1606", "path": "output2\\js\\Medium\\1606-longest-nice-subarray.js", "hypo_code": "var longestNiceSubarray = function(nums) {\n    let res = 0;\n    let n = nums.length;\n    for (let i = 0; i < n; i++) {\n        let max = nums[i];\n        let min = nums[i];\n        for (let j = i + 1; j < n; j++) {\n            max = Math.max(max, nums[j]);\n            min = Math.min(min, nums[j]);\n            if (max - min === j - i) {\n                res = Math.max(res, j - i + 1);\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1607", "path": "output2\\js\\Medium\\1607-optimal-partition-of-string.js", "hypo_code": "var partitionString = function(s) {\n    let map = new Map();\n    for (let c of s) {\n        map.set(c, map.get(c) + 1 || 1);\n    }\n    let arr = [...map.entries()].sort((a, b) => a[0].charCodeAt() - b[0].charCodeAt());\n    let res = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (i === arr.length - 1) {\n            res += arr[i][1];\n        } else {\n            let diff = arr[i + 1][0].charCodeAt() - arr[i][0].charCodeAt();\n            if (diff <= k) {\n                res += arr[i][1];\n            } else {\n                res += arr[i][1] - 1;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1608", "path": "output2\\js\\Medium\\1608-divide-intervals-into-minimum-number-of-groups.js", "hypo_code": "var minGroups = function(intervals) {\n    let n = intervals.length;\n    let start = new Array(n).fill(0);\n    let end = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        start[i] = intervals[i][0];\n        end[i] = intervals[i][1];\n    }\n    start.sort((a, b) => a - b);\n    end.sort((a, b) => a - b);\n    let res = 0;\n    let j = 0;\n    for (let i = 0; i < n; i++) {\n        if (start[i] > end[j]) {\n            j++;\n        } else {\n            res++;\n        }\n    }\n    return res;\n};"}
{"id": "1609", "path": "output2\\js\\Medium\\1609-maximum-matching-of-players-with-trainers.js", "hypo_code": "var matchPlayersAndTrainers = function(players, trainers) {\n    let n = players.length;\n    let m = trainers.length;\n    let arr = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        arr[i] = [players[i], i];\n    }\n    arr.sort((a, b) => a[0] - b[0]);\n    trainers.sort((a, b) => a - b);\n    let res = 0;\n    let set = new Set();\n    for (let i = 0; i < n; i++) {\n        let j = 0;\n        while (j < m && trainers[j] < arr[i][0]) {\n            j++;\n        }\n        while (j < m && set.has(j)) {\n            j++;\n        }\n        if (j < m) {\n            set.add(j);\n            res++;\n        }\n    }\n    return res;\n};"}
{"id": "1610", "path": "output2\\js\\Medium\\1610-smallest-subarrays-with-maximum-bitwise-or.js", "hypo_code": "var smallestSubarrays = function(nums) {\n    let n = nums.length;\n    let res = new Array(n).fill(1);\n    for (let i = 0; i < n; i++) {\n        let max = nums[i];\n        for (let j = i + 1; j < n; j++) {\n            max |= nums[j];\n            if (max === nums[i]) {\n                res[i] = j - i + 1;\n                break;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1611", "path": "output2\\js\\Medium\\1611-length-of-the-longest-alphabetical-continuous-substring.js", "hypo_code": "var longestContinuousSubstring = function(s) {\n    let max = 1;\n    let count = 1;\n    for (let i = 0; i < s.length - 1; i++) {\n        let diff = s.charCodeAt(i + 1) - s.charCodeAt(i);\n        if (diff === 1) {\n            count++;\n        } else {\n            count = 1;\n        }\n        max = Math.max(max, count);\n    }\n    return max;\n};"}
{"id": "1612", "path": "output2\\js\\Medium\\1612-reverse-odd-levels-of-binary-tree.js", "hypo_code": "var reverseOddLevels = function(root) {\n    let dfs = (root, level) => {\n        if (!root) return;\n        if (level % 2 === 1) {\n            let temp = root.left.val;\n            root.left.val = root.right.val;\n            root.right.val = temp;\n        }\n        dfs(root.left, level + 1);\n        dfs(root.right, level + 1);\n    }\n    dfs(root, 1);\n    return root;\n};"}
{"id": "1613", "path": "output2\\js\\Medium\\1613-longest-subarray-with-maximum-bitwise-and.js", "hypo_code": "var longestSubarray = function(nums) {\n    let n = nums.length;\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        let max = nums[i];\n        for (let j = i + 1; j < n; j++) {\n            max = Math.max(max, nums[j]);\n            if ((max & nums[j]) === max) {\n                res = Math.max(res, j - i + 1);\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1614", "path": "output2\\js\\Medium\\1614-find-all-good-indices.js", "hypo_code": "var goodIndices = function(nums, k) {\n    let res = [];\n    let n = nums.length;\n    for (let i = k; i < n - k; i++) {\n        let pre = nums.slice(i - k, i);\n        let post = nums.slice(i + 1, i + k + 1);\n        if (isNonIncreasing(pre) && isNonDecreasing(post)) {\n            res.push(i);\n        }\n    }\n    return res;\n};"}
{"id": "1616", "path": "output2\\js\\Medium\\1616-bitwise-xor-of-all-pairings.js", "hypo_code": "var xorAllNums = function(nums1, nums2) {\n    let res = 0;\n    let n = nums1.length;\n    let m = nums2.length;\n    for (let i = 0; i < n; i++) {\n        res ^= nums1[i];\n    }\n    for (let i = 0; i < m; i++) {\n        res ^= nums2[i];\n    }\n    return res;\n\n};"}
{"id": "1617", "path": "output2\\js\\Medium\\1617-maximum-sum-of-an-hourglass.js", "hypo_code": "var maxSum = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let res = -Infinity;\n    for (let i = 1; i < m - 1; i++) {\n        for (let j = 1; j < n - 1; j++) {\n            let sum = grid[i][j];\n            sum += grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1];\n            sum += grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1];\n            res = Math.max(res, sum);\n        }\n    }\n    return res;\n};"}
{"id": "1618", "path": "output2\\js\\Medium\\1618-minimize-xor.js", "hypo_code": "var minimizeXor = function(num1, num2) {\n    let res = 0;\n    for (let i = 31; i >= 0; i--) {\n        let mask = 1 << i;\n        let bit1 = num1 & mask;\n        let bit2 = num2 & mask;\n        if (bit1 && !bit2) {\n            res |= mask;\n        } else if (!bit1 && bit2) {\n            res |= mask;\n        }\n    }\n    return res;\n};"}
{"id": "1619", "path": "output2\\js\\Medium\\1619-find-the-original-array-of-prefix-xor.js", "hypo_code": "var findArray = function(pref) {\n    let n = pref.length;\n    if (n % 2 === 1) return [];\n    let res = new Array(n / 2).fill(0);\n    let map = new Map();\n    let xor = 0;\n    for (let i = 0; i < n; i++) {\n        xor ^= pref[i];\n        if (i % 2 === 1) {\n            if (!map.has(xor)) return [];\n            res[i / 2] = xor ^ map.get(xor);\n        }\n        map.set(xor, pref[i]);\n    }\n    return res;\n};"}
{"id": "1620", "path": "output2\\js\\Medium\\1620-using-a-robot-to-print-the-lexicographically-smallest-string.js", "hypo_code": "var robotWithString = function(s) {\n    let n = s.length;\n    let i = 0;\n    let j = n - 1;\n    let res = \"\";\n    while (i <= j) {\n        if (s[i] < s[j]) {\n            res += s[i];\n            i++;\n        } else if (s[i] > s[j]) {\n            res += s[j];\n            j--;\n        } else {\n            let ii = i + 1;\n            let jj = j - 1;\n            let flag = true;\n            while (ii <= jj) {\n                if (s[ii] < s[jj]) {\n                    res += s[i];\n                    i++;\n                    flag = false;\n                    break;\n                } else if (s[ii] > s[jj]) {\n                    res += s[j];\n                    j--;\n                    flag = false;\n                    break;\n                } else {\n                    ii++;\n                    jj--;\n                }\n            }\n            if (flag) {\n                res += s[i];\n                i++;\n            }\n        }\n    }\n    return res;\n};"}
{"id": "1621", "path": "output2\\js\\Medium\\1621-range-product-queries-of-powers.js", "hypo_code": "var productQueries = function(n, queries) {\n    let mod = 1e9 + 7;\n    let res = [];\n    let powers = [];\n    let sum = 0;\n    for (let i = 0; sum < n; i++) {\n        let cur = 1 << i;\n        powers.push(cur);\n        sum += cur;\n    }\n    let m = powers.length;\n    for (let query of queries) {\n        let [left, right] = query;\n        let start = left;\n        let end = right;\n        while (start < end) {\n            let mid = start + ((end - start) >> 1);\n            if (powers[mid] <= left) {\n                start = mid + 1;\n            } else {\n                end = mid;\n            }\n        }\n        left = start;\n        start = left;\n        end = right;\n        while (start < end) {\n            let mid = start + ((end - start) >> 1) + 1;\n            if (powers[mid] <= right) {\n                start = mid;\n            } else {\n                end = mid - 1;\n            }\n        }\n        right = start;\n        let cur = 1;\n        for (let i = left; i <= right; i++) {\n            cur = (cur * powers[i]) % mod;\n        }\n        res.push(cur);\n    }\n    return res;\n};"}
{"id": "1622", "path": "output2\\js\\Medium\\1622-minimize-maximum-of-array.js", "hypo_code": "var minimizeArrayValue = function(nums) {\n    let n = nums.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            dp[i][j] = dp[i][j - 1] + nums[j];\n        }\n    }\n    let result = Number.MAX_VALUE;\n    for (let i = 0; i < n; i++) {\n        let sum = 0;\n        for (let j = i; j < n; j++) {\n            sum += nums[j];\n            result = Math.min(result, Math.max(dp[0][i - 1] || 0, sum, dp[j + 1][n - 1] || 0));\n        }\n    }\n    return result;\n    \n};"}
{"id": "1623", "path": "output2\\js\\Medium\\1623-count-number-of-distinct-integers-after-reverse-operations.js", "hypo_code": "var countDistinctIntegers = function(nums) {\n    let n = nums.length;\n    let set = new Set();\n    for (let i = 0; i < n; i++) {\n        let reverse = parseInt(nums[i].toString().split('').reverse().join(''));\n        set.add(reverse);\n    }\n    return set.size;\n    \n};"}
{"id": "1624", "path": "output2\\js\\Medium\\1624-sum-of-number-and-its-reverse.js", "hypo_code": "var sumOfNumberAndReverse = function(num) {\n    let reverse = 0;\n    let temp = num;\n    while (temp) {\n        reverse = reverse * 10 + temp % 10;\n        temp = Math.floor(temp / 10);\n    }\n    return num + reverse === num;\n    \n};"}
{"id": "1625", "path": "output2\\js\\Medium\\1625-number-of-subarrays-with-gcd-equal-to-k.js", "hypo_code": "var subarrayGCD = function(nums, k) {\n    let count = 0;\n    let gcd = 0;\n    let map = new Map();\n    map.set(0, 1);\n    for (let i = 0; i < nums.length; i++) {\n        gcd = gcd(nums[i], gcd);\n        if (gcd % k === 0) {\n            count += map.get(gcd / k) || 0;\n        }\n        map.set(gcd, (map.get(gcd) || 0) + 1);\n    }\n    return count;\n    \n    \n    \n};"}
{"id": "1626", "path": "output2\\js\\Medium\\1626-words-within-two-edits-of-dictionary.js", "hypo_code": "var twoEditWords = function(queries, dictionary) {\n    let set = new Set(dictionary);\n    let result = [];\n    for (let i = 0; i < queries.length; i++) {\n        let query = queries[i];\n        if (set.has(query)) {\n            result.push(query);\n        } else {\n            if (oneEdit(query, set)) {\n                result.push(query);\n            }\n        }\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "1627", "path": "output2\\js\\Medium\\1627-destroy-sequential-targets.js", "hypo_code": "var destroyTargets = function(nums, space) {\n    let n = nums.length;\n    let result = 0;\n    let set = new Set();\n    let left = 0;\n    for (let right = 0; right < n; right++) {\n        while (set.has(nums[right])) {\n            set.delete(nums[left]);\n            left++;\n        }\n        set.add(nums[right]);\n        result = Math.max(result, right - left + 1);\n    }\n    return n - result;\n    \n    \n};"}
{"id": "1628", "path": "output2\\js\\Medium\\1628-most-popular-video-creator.js", "hypo_code": "var mostPopularCreator = function(creators, ids, views) {\n    let map = new Map();\n    let max = 0;\n    for (let i = 0; i < creators.length; i++) {\n        let creator = creators[i];\n        let id = ids[i];\n        let view = views[i];\n        if (map.has(creator)) {\n            let video = map.get(creator);\n            video[0] += view;\n            if (video[0] > max) {\n                max = video[0];\n            }\n            if (video[0] === max) {\n                if (video[1] > id) {\n                    video[1] = id;\n                }\n            }\n            map.set(creator, video);\n        } else {\n            map.set(creator, [view, id]);\n            if (view > max) {\n                max = view;\n            }\n        }\n    }\n    let result = [];\n    for (let [creator, video] of map) {\n        if (video[0] === max) {\n            result.push([creator, video[1]]);\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1629", "path": "output2\\js\\Medium\\1629-minimum-addition-to-make-integer-beautiful.js", "hypo_code": "var makeIntegerBeautiful = function(n, target) {\n    let sum = 0;\n    let count = 0;\n    let arr = [];\n    while (n > 0) {\n        let digit = n % 10;\n        arr.push(digit);\n        sum += digit;\n        n = Math.floor(n / 10);\n    }\n    arr.reverse();\n    let i = 0;\n    while (sum > target) {\n        let diff = sum - target;\n        if (arr[i] > diff) {\n            sum -= arr[i];\n            arr[i] = diff;\n            sum += arr[i];\n            count += diff;\n        }\n        i++;\n    }\n    return count;\n    \n};"}
{"id": "1630", "path": "output2\\js\\Medium\\1630-maximum-sum-of-distinct-subarrays-with-length-k.js", "hypo_code": "var maximumSubarraySum = function(nums, k) {\n    let set = new Set();\n    let sum = 0;\n    let result = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        set.add(nums[i]);\n        if (set.size === k) {\n            result = Math.max(result, sum);\n            sum -= nums[i - k + 1];\n            set.delete(nums[i - k + 1]);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1631", "path": "output2\\js\\Medium\\1631-total-cost-to-hire-k-workers.js", "hypo_code": "var totalCost = function(costs, k, candidates) {\n    let n = costs.length;\n    let res = Infinity;\n    let sum = 0;\n    let pq = new PriorityQueue((a, b) => a[0] < b[0]);\n    for (let i = 0; i < n; i++) {\n        if (i < k) {\n            sum += costs[i];\n            pq.push([costs[i], i]);\n        } else {\n            if (i >= k + candidates) {\n                let [cost, index] = pq.pop();\n                sum -= cost;\n            }\n            sum += costs[i];\n            pq.push([costs[i], i]);\n        }\n        if (i >= k - 1) {\n            res = Math.min(res, sum * (i - k + 2));\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "1632", "path": "output2\\js\\Medium\\1632-count-ways-to-build-good-strings.js", "hypo_code": "var countGoodStrings = function(low, high, zero, one) {\n    let mod = 1000000007;\n    let n = high.length;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    for (let i = 1; i <= n; i++) {\n        dp[i] = dp[i - 1] * (zero + one) % mod;\n    }\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        let l = low[i] - '0';\n        let h = high[i] - '0';\n        if (l === 0) {\n            res += dp[n - i - 1] * zero % mod;\n        } else {\n            res += dp[n - i - 1] * one % mod;\n        }\n        res %= mod;\n        if (l === h) {\n            if (l === 0) {\n                zero--;\n            } else {\n                one--;\n            }\n        } else {\n            break;\n        }\n    }\n    return res;\n    \n};"}
{"id": "1633", "path": "output2\\js\\Medium\\1633-most-profitable-path-in-a-tree.js", "hypo_code": "var mostProfitablePath = function(edges, bob, amount) {\n    let n = amount.length;\n    let adj = new Array(n);\n    for (let i = 0; i < n; i++) {\n        adj[i] = [];\n    }\n    for (let i = 0; i < edges.length; i++) {\n        adj[edges[i][0]].push(edges[i][1]);\n        adj[edges[i][1]].push(edges[i][0]);\n    }\n    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(n).fill(-Infinity);\n    }\n    let res = -Infinity;\n    dfs(0, bob, 0, adj, amount, dp);\n    for (let i = 0; i < n; i++) {\n        res = Math.max(res, dp[i][bob]);\n    }\n    return res;\n    \n};"}
{"id": "1634", "path": "output2\\js\\Medium\\1634-number-of-subarrays-with-lcm-equal-to-k.js", "hypo_code": "var subarrayLCM = function(nums, k) {\n    let count = 0;\n    let lcm = 1;\n    let map = new Map();\n    map.set(0, 1);\n    for (let i = 0; i < nums.length; i++) {\n        lcm = lcm * nums[i] / gcd(lcm, nums[i]);\n        if (lcm % k === 0) {\n            count += map.get(lcm / k) || 0;\n        }\n        map.set(lcm, (map.get(lcm) || 0) + 1);\n    }\n    return count;\n    \n};"}
{"id": "1635", "path": "output2\\js\\Medium\\1635-minimum-number-of-operations-to-sort-a-binary-tree-by-level.js", "hypo_code": "var minimumOperations = function(root) {\n    let arr = [];\n    let stack = [];\n    let node = root;\n    while (node || stack.length) {\n        while (node) {\n            stack.push(node);\n            node = node.left;\n        }\n        node = stack.pop();\n        arr.push(node.val);\n        node = node.right;\n    }\n    let result = 0;\n    let left = 0;\n    let right = arr.length - 1;\n    while (left < right) {\n        if (arr[left] > arr[right]) {\n            result++;\n            left++;\n        } else {\n            left++;\n            right--;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1636", "path": "output2\\js\\Medium\\1636-closest-nodes-queries-in-a-binary-search-tree.js", "hypo_code": "var closestNodes = function(root, queries) {\n    let arr = [];\n    let stack = [];\n    let node = root;\n    while (node || stack.length) {\n        while (node) {\n            stack.push(node);\n            node = node.left;\n        }\n        node = stack.pop();\n        arr.push(node.val);\n        node = node.right;\n    }\n    let result = [];\n    for (let i = 0; i < queries.length; i++) {\n        let query = queries[i];\n        let min = -1;\n        let max = -1;\n        let left = 0;\n        let right = arr.length - 1;\n        while (left <= right) {\n            let mid = Math.floor((left + right) / 2);\n            if (arr[mid] === query) {\n                min = arr[mid];\n                max = arr[mid];\n                break;\n            } else if (arr[mid] < query) {\n                min = arr[mid];\n                left = mid + 1;\n            } else {\n                max = arr[mid];\n                right = mid - 1;\n            }\n        }\n        result.push([min, max]);\n    }\n    return result;\n    \n};"}
{"id": "1637", "path": "output2\\js\\Medium\\1637-minimum-fuel-cost-to-report-to-the-capital.js", "hypo_code": "var minimumFuelCost = function(roads, seats) {\n    let n = roads.length + 1;\n    let graph = new Array(n);\n    for (let i = 0; i < n; i++) {\n        graph[i] = new Array();\n    }\n    for (let i = 0; i < roads.length; i++) {\n        graph[roads[i][0]].push(roads[i][1]);\n        graph[roads[i][1]].push(roads[i][0]);\n    }\n    let dp = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(seats + 1).fill(Infinity);\n    }\n    let visited = new Array(n).fill(false);\n    let min = Infinity;\n    dfs(0, 0, 0, graph, dp, visited, seats);\n    for (let i = 1; i <= seats; i++) {\n        min = Math.min(min, dp[0][i]);\n    }\n    return min;\n    \n    \n};"}
{"id": "1638", "path": "output2\\js\\Medium\\1638-difference-between-ones-and-zeros-in-row-and-column.js", "hypo_code": "var onesMinusZeros = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let diff = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    let onesRow = new Array(m).fill(0);\n    let onesCol = new Array(n).fill(0);\n    let zerosRow = new Array(m).fill(0);\n    let zerosCol = new Array(n).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                onesRow[i]++;\n                onesCol[j]++;\n            } else {\n                zerosRow[i]++;\n                zerosCol[j]++;\n            }\n        }\n    }\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j];\n        }\n    }\n    return diff;\n    \n};"}
{"id": "1639", "path": "output2\\js\\Medium\\1639-minimum-penalty-for-a-shop.js", "hypo_code": "var bestClosingTime = function(customers) {\n    let n = customers.length;\n    let result = n;\n    let penalty = 0;\n    for(let i = 0; i < n; i++){\n        if(customers[i] == 'N'){\n            penalty++;\n        }\n    }\n    let minPenalty = penalty;\n    for(let i = 0; i < n; i++){\n        if(customers[i] == 'N'){\n            penalty--;\n        }\n        else{\n            penalty++;\n        }\n        if(penalty < minPenalty){\n            minPenalty = penalty;\n            result = i + 1;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1640", "path": "output2\\js\\Medium\\1640-append-characters-to-string-to-make-subsequence.js", "hypo_code": "var appendCharacters = function(s, t) {\n    let m = s.length;\n    let n = t.length;\n    let dp = new Array(m + 1).fill(0);\n    for(let i = 1; i <= m; i++){\n        dp[i] = new Array(n + 1).fill(0);\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            if(s[i - 1] == t[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return n - dp[m][n];\n    \n};"}
{"id": "1641", "path": "output2\\js\\Medium\\1641-remove-nodes-from-linked-list.js", "hypo_code": "var removeNodes = function(head) {\n    let result = new ListNode(0);\n    let temp = result;\n    let max = 0;\n    while(head != null){\n        if(head.val >= max){\n            max = head.val;\n            temp.next = head;\n            temp = temp.next;\n        }\n        head = head.next;\n    }\n    temp.next = null;\n    return result.next;\n    \n};"}
{"id": "1642", "path": "output2\\js\\Medium\\1642-divide-players-into-teams-of-equal-skill.js", "hypo_code": "var dividePlayers = function(skill) {\n    let n = skill.length;\n    let sum = 0;\n    for(let i = 0; i < n; i++){\n        sum += skill[i];\n    }\n    if(sum % (n / 2) != 0){\n        return -1;\n    }\n    let target = sum / (n / 2);\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    for(let i = 0; i < n; i++){\n        for(let j = n; j >= skill[i]; j--){\n            dp[j] = Math.max(dp[j], dp[j - skill[i]]);\n        }\n    }\n    if(dp[target] == 0){\n        return -1;\n    }\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        result += skill[i] * skill[n - i - 1];\n    }\n    return result;\n    \n};"}
{"id": "1643", "path": "output2\\js\\Medium\\1643-minimum-score-of-a-path-between-two-cities.js", "hypo_code": "var minScore = function(n, roads) {\n    let graph = new Array(n).fill(0).map(() => new Array());\n    let dist = new Array(n).fill(Infinity);\n    for(let i = 0; i < roads.length; i++){\n        let [a, b, d] = roads[i];\n        graph[a - 1].push([b - 1, d]);\n        graph[b - 1].push([a - 1, d]);\n    }\n    dijkstra(0, graph, dist);\n    return dist[n - 1];\n    \n    \n    \n};"}
{"id": "1644", "path": "output2\\js\\Medium\\1644-maximum-star-sum-of-a-graph.js", "hypo_code": "var maxStarSum = function(vals, edges, k) {\n    let n = vals.length;\n    let result = 0;\n    let graph = new Array(n).fill(0).map(() => new Array());\n    for(let i = 0; i < edges.length; i++){\n        let [a, b] = edges[i];\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n    let dp = new Array(n).fill(0).map(() => new Array(k + 1).fill(0));\n    let dfs = (node, parent) => {\n        for(let i = 0; i < graph[node].length; i++){\n            let child = graph[node][i];\n            if(child != parent){\n                dfs(child, node);\n                for(let j = k; j >= 1; j--){\n                    for(let l = 0; l < j; l++){\n                        dp[node][j] = Math.max(dp[node][j], dp[node][j - l - 1] + dp[child][l]);\n                    }\n                }\n            }\n        }\n        for(let i = k; i >= 1; i--){\n            dp[node][i] = dp[node][i - 1] + vals[node];\n        }\n        dp[node][0] = 0;\n    }\n    dfs(0, -1);\n    return dp[0][k];\n    \n};"}
{"id": "1645", "path": "output2\\js\\Medium\\1645-frog-jump-ii.js", "hypo_code": "var maxJump = function(stones) {\n    let n = stones.length;\n    let dp = new Array(n).fill(0);\n    let result = 0;\n    for(let i = 1; i < n; i++){\n        for(let j = 0; j < i; j++){\n            if(stones[i] - stones[j] <= i - j){\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n                result = Math.max(result, dp[i]);\n            }\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1646", "path": "output2\\js\\Medium\\1646-longest-square-streak-in-an-array.js", "hypo_code": "var longestSquareStreak = function(nums) {\n    let n = nums.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    let result = 0;\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        map.set(nums[i], i);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = i + 1; j < n; j++){\n            let k = map.get(nums[j] - nums[i]);\n            if(k !== undefined && k < i){\n                dp[i][j] = dp[k][i] + 1;\n                result = Math.max(result, dp[i][j]);\n            }\n        }\n    }\n    return result === 0 ? -1 : result + 2;\n\n    \n};"}
{"id": "1648", "path": "output2\\js\\Medium\\1648-smallest-value-after-replacing-with-sum-of-prime-factors.js", "hypo_code": "var smallestValue = function(n) {\n    let result = 0;\n    while(n > 1){\n        let min = n;\n        for(let i = 2; i * i <= n; i++){\n            if(n % i == 0){\n                min = Math.min(min, i);\n                while(n % i == 0){\n                    n /= i;\n                }\n            }\n        }\n        if(n > 1){\n            min = Math.min(min, n);\n        }\n        result += min;\n        n = min;\n    }\n    return result;\n    \n};"}
{"id": "1649", "path": "output2\\js\\Medium\\1649-reward-top-k-students.js", "hypo_code": "var topStudents = function(positive_feedback, negative_feedback, report, student_id, k) {\n    let n = report.length;\n    let m = student_id.length;\n    let p = positive_feedback.length;\n    let q = negative_feedback.length;\n    let points = new Array(m).fill(0);\n    let idToIndex = new Map();\n    for(let i = 0; i < m; i++){\n        idToIndex.set(student_id[i], i);\n    }\n    for(let i = 0; i < n; i++){\n        let id = student_id[i];\n        let index = idToIndex.get(id);\n        let words = report[i].split(\" \");\n        for(let word of words){\n            if(positive_feedback.includes(word)){\n                points[index] += 3;\n            }else if(negative_feedback.includes(word)){\n                points[index] -= 1;\n            }\n        }\n    }\n    let ans = [];\n    let maxHeap = new MaxHeap();\n    for(let i = 0; i < m; i++){\n        maxHeap.add([points[i], student_id[i]]);\n    }\n    for(let i = 0; i < k; i++){\n        ans.push(maxHeap.poll()[1]);\n    }\n    return ans;\n    \n    \n};"}
{"id": "1650", "path": "output2\\js\\Medium\\1650-minimize-the-maximum-of-two-arrays.js", "hypo_code": "var minimizeSet = function(divisor1, divisor2, uniqueCnt1, uniqueCnt2) {\n    let gcd = getGCD(divisor1, divisor2);\n    let lcm = divisor1 * divisor2 / gcd;\n    let max1 = divisor1 * uniqueCnt1;\n    let max2 = divisor2 * uniqueCnt2;\n    let max3 = lcm * Math.min(uniqueCnt1, uniqueCnt2);\n    let result = Math.max(max1, max2, max3);\n    return result;\n    \n    \n};"}
{"id": "1651", "path": "output2\\js\\Medium\\1651-take-k-of-each-character-from-left-and-right.js", "hypo_code": "var takeCharacters = function(s, k) {\n    let n = s.length;\n    let dp = new Array(n + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(s[i - 1] == s[n - j]){\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }else{\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    let lcs = dp[n][n];\n    if(lcs >= k){\n        return 2 * (n - lcs);\n    }else{\n        return -1;\n    }\n    \n};"}
{"id": "1652", "path": "output2\\js\\Medium\\1652-maximum-tastiness-of-candy-basket.js", "hypo_code": "var maximumTastiness = function(price, k) {\n    let n = price.length;\n    let dp = new Array(n + 1).fill(0).map(() => new Array(k + 1).fill(0));\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= k; j++){\n            if(j > i){\n                dp[i][j] = dp[i][j - 1];\n            }else{\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + price[i - 1]);\n            }\n        }\n    }\n    return dp[n][k];\n    \n};"}
{"id": "1653", "path": "output2\\js\\Medium\\1653-distinct-prime-factors-of-product-of-array.js", "hypo_code": "var distinctPrimeFactors = function(nums) {\n    let n = nums.length;\n    let max = 0;\n    for(let i = 0; i < n; i++){\n        max = Math.max(max, nums[i]);\n    }\n    let primeFactors = new Array(max + 1).fill(0);\n    for(let i = 2; i <= max; i++){\n        if(primeFactors[i] == 0){\n            for(let j = i; j <= max; j += i){\n                primeFactors[j]++;\n            }\n        }\n    }\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        result += primeFactors[nums[i]];\n    }\n    return result;\n    \n};"}
{"id": "1654", "path": "output2\\js\\Medium\\1654-partition-string-into-substrings-with-values-at-most-k.js", "hypo_code": "var minimumPartition = function(s, k) {\n    let result = 0;\n    let start = 0;\n    let end = 0;\n    let max = 0;\n    let map = new Map();\n    while(end < s.length){\n        let char = s[end];\n        if(map.has(char)){\n            map.set(char, map.get(char) + 1);\n        }else{\n            map.set(char, 1);\n        }\n        max = Math.max(max, map.get(char));\n        if(end - start + 1 - max > k){\n            let char = s[start];\n            map.set(char, map.get(char) - 1);\n            start++;\n        }\n        end++;\n    }\n    return end - start;\n    \n    \n};"}
{"id": "1655", "path": "output2\\js\\Medium\\1655-closest-prime-numbers-in-range.js", "hypo_code": "var closestPrimes = function(left, right) {\n    let result = [-1, -1];\n    let minDiff = Number.MAX_VALUE;\n    for(let i = left; i <= right; i++){\n        if(isPrime(i)){\n            for(let j = i + 1; j <= right; j++){\n                if(isPrime(j)){\n                    if(j - i < minDiff){\n                        minDiff = j - i;\n                        result = [i, j];\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "1657", "path": "output2\\js\\Medium\\1657-find-xor-beauty-of-array.js", "hypo_code": "var xorBeauty = function(nums) {\n    let n = nums.length;\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = i; j < n; j++){\n            for(let k = j; k < n; k++){\n                result ^= ((nums[i] | nums[j]) & nums[k]);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1658", "path": "output2\\js\\Medium\\1658-maximal-score-after-applying-k-operations.js", "hypo_code": "var maxKelements = function(nums, k) {\n    let n = nums.length;\n    let result = 0;\n    for(let i = 0; i <= k; i++){\n        let j = k - i;\n        if(i > n || j > n){\n            continue;\n        }\n        let max1 = getMax(nums, i);\n        let max2 = getMax(nums, j);\n        result = Math.max(result, max1 + max2);\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "1659", "path": "output2\\js\\Medium\\1659-make-number-of-distinct-characters-equal.js", "hypo_code": "var isItPossible = function(word1, word2) {\n    let n = word1.length;\n    let m = word2.length;\n    if(n != m){\n        return false;\n    }\n    let count = 0;\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        if(word1[i] != word2[i]){\n            count++;\n            if(map.has(word1[i])){\n                map.set(word1[i], map.get(word1[i]) + 1);\n            }\n            else{\n                map.set(word1[i], 1);\n            }\n            if(map.has(word2[i])){\n                map.set(word2[i], map.get(word2[i]) + 1);\n            }\n            else{\n                map.set(word2[i], 1);\n            }\n        }\n    }\n    if(count == 2){\n        for(let [key, value] of map){\n            if(value == 2){\n                return true;\n            }\n        }\n    }\n    return false;\n    \n};"}
{"id": "1660", "path": "output2\\js\\Medium\\1660-increment-submatrices-by-one.js", "hypo_code": "var rangeAddQueries = function(n, queries) {\n    let result = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        result[i] = new Array(n).fill(0);\n    }\n    for(let i = 0; i < queries.length; i++){\n        let query = queries[i];\n        let row1 = query[0];\n        let col1 = query[1];\n        let row2 = query[2];\n        let col2 = query[3];\n        result[row1][col1]++;\n        if(row2 + 1 < n){\n            result[row2 + 1][col1]--;\n        }\n        if(col2 + 1 < n){\n            result[row1][col2 + 1]--;\n        }\n        if(row2 + 1 < n && col2 + 1 < n){\n            result[row2 + 1][col2 + 1]++;\n        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            if(i > 0){\n                result[i][j] += result[i - 1][j];\n            }\n            if(j > 0){\n                result[i][j] += result[i][j - 1];\n            }\n            if(i > 0 && j > 0){\n                result[i][j] -= result[i - 1][j - 1];\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1661", "path": "output2\\js\\Medium\\1661-count-the-number-of-good-subarrays.js", "hypo_code": "var countGood = function(nums, k) {\n    let n = nums.length;\n    let count = 0;\n    for(let i = 0; i < n; i++){\n        let map = new Map();\n        let odd = 0;\n        for(let j = i; j < n; j++){\n            if(map.has(nums[j])){\n                map.set(nums[j], map.get(nums[j]) + 1);\n            }else{\n                map.set(nums[j], 1);\n            }\n            if(map.get(nums[j]) % 2 == 1){\n                odd++;\n            }else{\n                odd--;\n            }\n            if(odd >= k){\n                count++;\n            }\n        }\n    }\n    return count;\n    \n};"}
{"id": "1662", "path": "output2\\js\\Medium\\1662-minimum-operations-to-make-array-equal-ii.js", "hypo_code": "var minOperations = function(nums1, nums2, k) {\n    let n = nums1.length;\n    let m = nums2.length;\n    if(n * 6 < k || m * 6 < k){\n        return -1;\n    }\n    let sum1 = 0;\n    let sum2 = 0;\n    for(let i = 0; i < n; i++){\n        sum1 += nums1[i];\n    }\n    for(let i = 0; i < m; i++){\n        sum2 += nums2[i];\n    }\n    if(sum1 > sum2){\n        return minOperations(nums2, nums1, k);\n    }\n    let diff = sum2 - sum1;\n    let dp = new Array(k + 1).fill(0);\n    for(let i = 0; i <= k; i++){\n        dp[i] = new Array(diff + 1).fill(-1);\n    }\n    let result = helper(nums1, nums2, k, diff, 0, 0, dp);\n    return result == Number.MAX_SAFE_INTEGER ? -1 : result;\n    \n    \n};"}
{"id": "1663", "path": "output2\\js\\Medium\\1663-maximum-subsequence-score.js", "hypo_code": "var maxScore = function(nums1, nums2, k) {\n    let n = nums1.length;\n    let m = nums2.length;\n    let result = 0;\n    for(let i = 0; i <= k; i++){\n        let j = k - i;\n        if(i > n || j > m){\n            continue;\n        }\n        let max1 = getMax(nums1, i);\n        let max2 = getMax(nums2, j);\n        result = Math.max(result, max1 + max2);\n    }\n    return result;\n    \n    \n};"}
{"id": "1664", "path": "output2\\js\\Medium\\1664-sort-the-students-by-their-kth-score.js", "hypo_code": "var sortTheStudents = function(score, k) {\n    let m = score.length;\n    let n = score[0].length;\n    let map = new Map();\n    for(let i = 0; i < m; i++){\n        let key = score[i][k];\n        if(map.has(key)){\n            map.get(key).push(i);\n        }else{\n            map.set(key, [i]);\n        }\n    }\n    let keys = Array.from(map.keys()).sort((a, b) => b - a);\n    let result = [];\n    for(let i = 0; i < keys.length; i++){\n        let students = map.get(keys[i]);\n        for(let j = 0; j < students.length; j++){\n            result.push(score[students[j]]);\n        }\n    }\n    return result;\n    \n};"}
{"id": "1665", "path": "output2\\js\\Medium\\1665-apply-bitwise-operations-to-make-strings-equal.js", "hypo_code": "var makeStringsEqual = function(s, target) {\n    let s1 = 0;\n    let s2 = 0;\n    for(let i = 0; i < s.length; i++){\n        s1 += s[i].charCodeAt(0) - 'a'.charCodeAt(0);\n        s2 += target[i].charCodeAt(0) - 'a'.charCodeAt(0);\n    }\n    return s1 == s2;\n    \n};"}
{"id": "1666", "path": "output2\\js\\Medium\\1666-count-collisions-of-monkeys-on-a-polygon.js", "hypo_code": "var monkeyMove = function(n) {\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        for(let j = 0; j < n; j++){\n            dp[i][j] = 0;\n        }\n    }\n    for(let i = 0; i < n; i++){\n        dp[0][i] = 1;\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 0; j < n; j++){\n            dp[i][j] = (dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]) % 1000000007;\n        }\n    }\n    let res = 0;\n    for(let i = 0; i < n; i++){\n        res = (res + dp[n - 1][i]) % 1000000007;\n    }\n    return res;\n    \n};"}
{"id": "1667", "path": "output2\\js\\Medium\\1667-maximum-number-of-integers-to-choose-from-a-range-i.js", "hypo_code": "var maxCount = function(banned, n, maxSum) {\n    let sum = 0;\n    let count = 0;\n    let i = 0;\n    let j = 0;\n    while(i < banned.length && j < banned.length){\n        if(sum + banned[j] <= maxSum){\n            sum += banned[j];\n            j++;\n        }else{\n            sum -= banned[i];\n            i++;\n        }\n        if(sum <= maxSum){\n            count = Math.max(count, j - i);\n        }\n    }\n    return count;\n    \n};"}
{"id": "1668", "path": "output2\\js\\Medium\\1668-maximize-win-from-two-segments.js", "hypo_code": "var maximizeWin = function(prizePositions, k) {\n    let max = 0;\n    let left = 0;\n    let right = 0;\n    let count = 0;\n    while(right < prizePositions.length){\n        while(prizePositions[right] - prizePositions[left] + 1 > k){\n            count--;\n            left++;\n        }\n        count++;\n        max = Math.max(max, count);\n        right++;\n    }\n    return max;\n    \n};"}
{"id": "1669", "path": "output2\\js\\Medium\\1669-disconnect-path-in-a-binary-matrix-by-at-most-one-flip.js", "hypo_code": "var isPossibleToCutPath = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let visited = new Array(m);\n    for(let i = 0; i < m; i++){\n        visited[i] = new Array(n);\n        for(let j = 0; j < n; j++){\n            visited[i][j] = false;\n        }\n    }\n    let queue = [[0, 0]];\n    visited[0][0] = true;\n    while(queue.length > 0){\n        let [row, col] = queue.shift();\n        if(row == m - 1 && col == n - 1){\n            return true;\n        }\n        if(row + 1 < m && grid[row + 1][col] == 1 && !visited[row + 1][col]){\n            queue.push([row + 1, col]);\n            visited[row + 1][col] = true;\n        }\n        if(col + 1 < n && grid[row][col + 1] == 1 && !visited[row][col + 1]){\n            queue.push([row, col + 1]);\n            visited[row][col + 1] = true;\n        }\n    }\n    return false;\n    \n};"}
{"id": "1670", "path": "output2\\js\\Medium\\1670-count-vowel-strings-in-ranges.js", "hypo_code": "var vowelStrings = function(words, queries) {\n    let result = [];\n    for(let i = 0; i < queries.length; i++){\n        let count = 0;\n        for(let j = queries[i][0]; j <= queries[i][1]; j++){\n            if(words[j][0] == 'a' || words[j][0] == 'e' || words[j][0] == 'i' || words[j][0] == 'o' || words[j][0] == 'u'){\n                if(words[j][words[j].length - 1] == 'a' || words[j][words[j].length - 1] == 'e' || words[j][words[j].length - 1] == 'i' || words[j][words[j].length - 1] == 'o' || words[j][words[j].length - 1] == 'u'){\n                    count++;\n                }\n            }\n        }\n        result.push(count);\n    }\n    return result;\n    \n};"}
{"id": "1671", "path": "output2\\js\\Medium\\1671-house-robber-iv.js", "hypo_code": "var minCapability = function(nums, k) {\n    let n = nums.length;\n    let dp = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        dp[i] = dp[i - 1] + nums[i - 1];\n    }\n    let result = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i <= n - k; i++){\n        result = Math.min(result, dp[i + k] - dp[i]);\n    }\n    return result;\n    \n};"}
{"id": "1672", "path": "output2\\js\\Medium\\1672-count-the-number-of-fair-pairs.js", "hypo_code": "var countFairPairs = function(nums, lower, upper) {\n    let count = 0;\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tfor (let j = i+1; j < nums.length; j++) {\n\t\t\tif (lower <= nums[i] + nums[j] && nums[i] + nums[j] <= upper) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n};"}
{"id": "1673", "path": "output2\\js\\Medium\\1673-substring-xor-queries.js", "hypo_code": "var substringXorQueries = function(s, queries) { \n    let ans = [];\n    for (let i = 0; i < queries.length; i++) {\n        let [left, right] = queries[i];\n        let substr = s.substring(left, right+1);\n        let val = parseInt(substr, 2);\n        let xor = val ^ left;\n        let xorStr = xor.toString(2);\n        let lefti = substr.indexOf(xorStr);\n        let righti = lefti + xorStr.length - 1;\n        ans.push([lefti, righti]);\n    }\n    return ans;\n};"}
{"id": "1674", "path": "output2\\js\\Medium\\1674-minimum-score-by-changing-two-elements.js", "hypo_code": "var minimizeSum = function(nums) {\n    let min = Infinity;\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        for (let j = i+1; j < nums.length; j++) {\n            let diff = Math.abs(val - nums[j]);\n            if (diff < min) min = diff;\n        }\n    }\n    return min;\n};"}
{"id": "1675", "path": "output2\\js\\Medium\\1675-minimum-impossible-or.js", "hypo_code": "var minImpossibleOR = function(nums) {\n    nums.sort((a,b) => a-b);\n    let max = nums[nums.length-1];\n    let ans = max+1;\n    let set = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        if (val > 1) {\n            if (!set.has(val)) {\n                ans = Math.min(ans, val);\n                set.add(val);\n            }\n            for (let j = i+1; j < nums.length; j++) {\n                val |= nums[j];\n                if (val > max) break;\n                if (!set.has(val)) {\n                    ans = Math.min(ans, val);\n                    set.add(val);\n                }\n            }\n        }\n    }\n    return ans;\n\n};"}
{"id": "1676", "path": "output2\\js\\Medium\\1676-minimum-operations-to-reduce-an-integer-to-0.js", "hypo_code": "var minOperations = function(n) {\n    let ans = 0;\n    while (n > 0) {\n        if (n % 2 === 0) {\n            n /= 2;\n        } else {\n            n--;\n        }\n        ans++;\n    }\n    return ans-1;\n};"}
{"id": "1677", "path": "output2\\js\\Medium\\1677-count-the-number-of-square-free-subsets.js", "hypo_code": "var squareFreeSubsets = function(nums) {\n    let count = 0;\n    let set = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        if (val === 1) {\n            count++;\n        } else {\n            let isSquareFree = true;\n            for (let j = 2; j <= val; j++) {\n                let pow = j*j;\n                if (val % pow === 0) {\n                    isSquareFree = false;\n                    break;\n                }\n            }\n            if (isSquareFree) {\n                count++;\n            } else {\n                set.add(val);\n            }\n        }\n    }\n    let arr = Array.from(set);\n    let len = arr.length;\n    for (let i = 0; i < len; i++) {\n        let val = arr[i];\n        let isSquareFree = true;\n        for (let j = i+1; j < len; j++) {\n            let pow = arr[j]*arr[j];\n            if (val % pow === 0) {\n                isSquareFree = false;\n                break;\n            }\n        }\n        if (isSquareFree) {\n            count++;\n        }\n    }\n    return count;\n};"}
{"id": "1678", "path": "output2\\js\\Medium\\1678-find-the-divisibility-array-of-a-string.js", "hypo_code": "var divisibilityArray = function(word, m) {\n    let n = word.length;\n    let arr = new Array(n);\n    arr[0] = word[0] % m === 0 ? 1 : 0;\n    for (let i = 1; i < n; i++) {\n        let val = (arr[i-1] * 10 + word[i]) % m;\n        arr[i] = val === 0 ? 1 : 0;\n    }\n    return arr;\n};"}
{"id": "1679", "path": "output2\\js\\Medium\\1679-find-the-maximum-number-of-marked-indices.js", "hypo_code": "var maxNumOfMarkedIndices = function(nums) {\n    let count = 0;\n    let len = nums.length;\n    for (let i = 0; i < len; i++) {\n        let val = nums[i];\n        for (let j = i+1; j < len; j++) {\n            if (2*val <= nums[j]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};"}
{"id": "1680", "path": "output2\\js\\Medium\\1680-count-total-number-of-colored-cells.js", "hypo_code": "var coloredCells = function(n) {\n    let ans = 1;\n    if (n > 1) {\n        ans = 5;\n        let i = 2;\n        while (i < n) {\n            ans += 4;\n            i++;\n        }\n    }\n    return ans;\n};"}
{"id": "1681", "path": "output2\\js\\Medium\\1681-count-ways-to-group-overlapping-ranges.js", "hypo_code": "var countWays = function(ranges) {\n    let count = 0;\n    let len = ranges.length;\n    let arr = new Array(len);\n    for (let i = 0; i < len; i++) {\n        arr[i] = i;\n    }\n    for (let i = 0; i < len; i++) {\n        let [starti, endi] = ranges[i];\n        for (let j = i+1; j < len; j++) {\n            let [startj, endj] = ranges[j];\n            if (starti <= startj && startj <= endi) {\n                arr[j] = arr[i];\n            }\n        }\n    }\n    let set = new Set();\n    for (let i = 0; i < len; i++) {\n        set.add(arr[i]);\n    }\n    return set.size;\n};"}
{"id": "1682", "path": "output2\\js\\Medium\\1682-kth-largest-sum-in-a-binary-tree.js", "hypo_code": "var kthLargestLevelSum = function(root, k) { \n    let queue = [root];\n    let level = 0;\n    let map = new Map();\n    while (queue.length > 0) {\n        let len = queue.length;\n        let sum = 0;\n        for (let i = 0; i < len; i++) {\n            let node = queue.shift();\n            sum += node.val;\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        map.set(level, sum);\n        level++;\n    }\n    let arr = [...map.values()];\n    arr.sort((a,b) => b-a);\n    return arr[k-1];\n};"}
{"id": "1683", "path": "output2\\js\\Medium\\1683-rearrange-array-to-maximize-prefix-score.js", "hypo_code": "var maxScore = function(nums) {\n    let n = nums.length;\n    let sum = 0;\n    let min = Infinity;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        if (nums[i] > 0 && nums[i] < min) min = nums[i];\n    }\n    if (min === Infinity) return 0;\n    return sum - min;\n};"}
{"id": "1684", "path": "output2\\js\\Medium\\1684-count-the-number-of-beautiful-subarrays.js", "hypo_code": "var beautifulSubarrays = function(nums) {\n    let count = 0;\n\tlet set = new Set();\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tlet val = nums[i];\n\t\tif (val % 2 !== 0) {\n\t\t\tset.add(i);\n\t\t}\n\t}\n\tlet arr = Array.from(set);\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tlet val = arr[i];\n\t\tlet left = val-1;\n\t\tlet right = val+1;\n\t\twhile (left >= 0 && right < nums.length) {\n\t\t\tif (nums[left] % 2 !== 0 && nums[right] % 2 !== 0) {\n\t\t\t\tcount += 2;\n\t\t\t\tleft--;\n\t\t\t\tright++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n};"}
{"id": "1685", "path": "output2\\js\\Medium\\1685-maximize-greatness-of-an-array.js", "hypo_code": "var maximizeGreatness = function(nums) {\n    let n = nums.length;\n    let ans = 0;\n    let max = nums[0];\n    let min = nums[0];\n    for (let i = 0; i < n; i++) {\n        max = Math.max(max, nums[i]);\n        min = Math.min(min, nums[i]);\n    }\n    let set = new Set();\n    for (let i = 0; i < n; i++) {\n        let val = nums[i];\n        if (val === max || val === min) {\n            if (!set.has(val)) {\n                ans++;\n                set.add(val);\n            }\n        }\n    }\n    return ans;\n};"}
{"id": "1686", "path": "output2\\js\\Medium\\1686-find-score-of-an-array-after-marking-all-elements.js", "hypo_code": "var findScore = function(nums) {\n    nums.sort((a,b) => a-b);\n    let n = nums.length;\n    let score = 0;\n    let i = 0;\n    while (i < n) {\n        let j = i;\n        while (j < n && nums[j] === nums[i]) {\n            j++;\n        }\n        let count = j-i;\n        score += count * nums[i];\n        i = j;\n    }\n    return score;\n\n};"}
{"id": "1687", "path": "output2\\js\\Medium\\1687-minimum-time-to-repair-cars.js", "hypo_code": "var repairCars = function(ranks, cars) {\n    let min = Math.min(...ranks);\n    let max = Math.max(...ranks);\n    let count = new Array(max+1).fill(0);\n    for (let i = 0; i < ranks.length; i++) {\n        count[ranks[i]]++;\n    }\n    let sum = 0;\n    let i = min;\n    let j = max;\n    while (cars > 0) {\n        if (count[j] > 0) {\n            sum += j;\n            cars--;\n            count[j]--;\n        } else {\n            j--;\n        }\n        if (cars === 0) break;\n        if (count[i] > 0) {\n            sum += i;\n            cars--;\n            count[i]--;\n        } else {\n            i++;\n        }\n    }\n    return sum;\n};"}
{"id": "1688", "path": "output2\\js\\Medium\\1688-check-knight-tour-configuration.js", "hypo_code": "var checkValidGrid = function(grid) {\n    let n = grid.length;\n    let map = new Map();\n    let visited = new Array(n*n).fill(0);\n    let directions = [[-2,1],[-2,-1],[-1,2],[-1,-2],[1,2],[1,-2],[2,1],[2,-1]];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++ ) {\n            map.set(grid[i][j], [i,j]);\n        }\n    }\n    for (let i = 0; i < n*n; i++) {\n        let [x,y] = map.get(i);\n        if (visited[i] === 0) {\n            visited[i] = 1;\n            for (let j = 0; j < directions.length; j++) {\n                let [dx, dy] = directions[j];\n                let newX = x + dx;\n                let newY = y + dy;\n                if (newX >= 0 && newX < n && newY >= 0 && newY < n && visited[grid[newX][newY]] === 0) {\n                    visited[grid[newX][newY]] = 1;\n                }\n            }\n        }\n    }\n    return visited.every(val => val === 1);\n};"}
{"id": "1689", "path": "output2\\js\\Medium\\1689-the-number-of-beautiful-subsets.js", "hypo_code": "var beautifulSubsets = function(nums, k) {\n    let count = 0;\n    let set = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        if (val === 1) {\n            count++;\n        } else {\n            let isBeautiful = true;\n            for (let j = 2; j <= val; j++) {\n                let diff = Math.abs(val - j);\n                if (diff === k) {\n                    isBeautiful = false;\n                    break;\n                }\n            }\n            if (isBeautiful) {\n                count++;\n            } else {\n                set.add(val);\n            }\n        }\n    }\n    let arr = Array.from(set);\n    let len = arr.length;\n    for (let i = 0; i < len; i++) {\n        let val = arr[i];\n        let isBeautiful = true;\n        for (let j = i+1; j < len; j++) {\n            let diff = Math.abs(val - arr[j]);\n            if (diff === k) {\n                isBeautiful = false;\n                break;\n            }\n        }\n        if (isBeautiful) {\n            count++;\n        }\n    }\n    return count;\n};"}
{"id": "1690", "path": "output2\\js\\Medium\\1690-smallest-missing-non-negative-integer-after-operations.js", "hypo_code": "var findSmallestInteger = function(nums, value) {\n    let min = Infinity;\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        if (val < min) min = val;\n    }\n    let diff = value - min;\n    let ans = diff;\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        if (val < diff) {\n            diff -= val;\n        } else if (val === diff) {\n            diff = 0;\n        } else {\n            break;\n        }\n    }\n    if (diff > 0) {\n        ans += Math.ceil(diff / nums.length) * nums.length;\n    }\n    return ans;\n};"}
{"id": "1691", "path": "output2\\js\\Medium\\1691-prime-subtraction-operation.js", "hypo_code": "var primeSubOperation = function(nums) {\n    let len = nums.length;\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0; i < len; i++) {\n        let val = nums[i];\n        if (val < min) min = val;\n        if (val > max) max = val;\n    }\n    let isPrime = new Array(max+1).fill(true);\n    let sqrt = Math.sqrt(max);\n    for (let i = 2; i <= sqrt; i++) {\n        if (isPrime[i]) {\n            for (let j = i*2; j <= max; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    let primes = [];\n    for (let i = 2; i <= max; i++) {\n        if (isPrime[i]) primes.push(i);\n    }\n    let dp = new Array(len).fill(false);\n    for (let i = 0; i < len; i++) {\n        let val = nums[i];\n        for (let j = 0; j < primes.length; j++) {\n            let p = primes[j];\n            if (p >= val) break;\n            dp[i] = dp[i] || (i > 0 && dp[i-1] && val-p > nums[i-1]);\n        }\n    }\n    return dp[len-1];\n};"}
{"id": "1692", "path": "output2\\js\\Medium\\1692-minimum-operations-to-make-all-array-elements-equal.js", "hypo_code": "var minOperations = function(nums, queries) {\n    let max = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        if (val > max) max = val;\n    }\n    let arr = new Array(max+1).fill(0);\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        arr[val]++;\n    }\n    let ans = [];\n    for (let i = 0; i < queries.length; i++) {\n        let target = queries[i];\n        let count = 0;\n        for (let j = 0; j < arr.length; j++) {\n            let val = arr[j];\n            if (j > target) {\n                count += val;\n            } else if (j < target) {\n                count += val * (target - j);\n            }\n        }\n        ans.push(count);\n    }\n    return ans;\n};"}
{"id": "1693", "path": "output2\\js\\Medium\\1693-find-the-substring-with-maximum-cost.js", "hypo_code": "var maximumCostSubstring = function(s, chars, vals) {\n    let n = s.length;\n    let max = 0;\n    let prev = 0;\n    for (let i = 0; i < n; i++) {\n        let val = vals[chars.indexOf(s[i])];\n        if (val === -1000) {\n            prev = 0;\n            continue;\n        }\n        prev = Math.max(prev + val, val);\n        max = Math.max(max, prev);\n    }\n    return max;\n};"}
{"id": "1694", "path": "output2\\js\\Medium\\1694-make-k-subarray-sums-equal.js", "hypo_code": "var makeSubKSumEqual = function(arr, k) {\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += arr[i];\n    }\n    let min = Infinity;\n    let minIdx = -1;\n    for (let i = 0; i < arr.length; i++) {\n        let val = arr[i];\n        if (val < min) {\n            min = val;\n            minIdx = i;\n        }\n    }\n    let diff = sum - min;\n    let ans = diff;\n    for (let i = minIdx; i < arr.length; i++) {\n        let val = arr[i];\n        if (val < diff) {\n            diff -= val;\n        } else if (val === diff) {\n            diff = 0;\n        } else {\n            break;\n        }\n    }\n    if (diff > 0) {\n        ans += Math.ceil(diff / arr.length) * arr.length;\n    }\n    return ans;\n};"}
{"id": "1695", "path": "output2\\js\\Medium\\1695-convert-an-array-into-a-2d-array-with-conditions.js", "hypo_code": "var findMatrix = function(nums) {\n    let n = nums.length;\n    nums.sort((a,b) => a-b);\n    let count = 1;\n    let matrix = [];\n    let row = [];\n    for (let i = 0; i < n; i++) {\n        let val = nums[i];\n        if (row.length === 0) {\n            row.push(val);\n        } else {\n            let last = row[row.length-1];\n            if (val === last + 1) {\n                row.push(val);\n            } else {\n                matrix.push(row);\n                row = [val];\n            }\n        }\n    }\n    if (row.length > 0) {\n        matrix.push(row);\n    }\n    return matrix;\n};"}
{"id": "1696", "path": "output2\\js\\Medium\\1696-mice-and-cheese.js", "hypo_code": "var miceAndCheese = function(reward1, reward2, k) {\n    let n = reward1.length;\n    let arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = [reward1[i], reward2[i]];\n    }\n    arr.sort((a, b) => b[0]-a[0]);\n    let dp = new Array(n+1).fill(0).map(() => new Array(k+1).fill(0));\n    for (let i = 1; i <= n; i++) {\n        let [val1, val2] = arr[i-1];\n        for (let j = 1; j <= k; j++) {\n            dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1]+val1, dp[i-1][j-1]+val2);\n        }\n    }\n    return dp[n][k];\n};"}
{"id": "1697", "path": "output2\\js\\Medium\\1697-sum-of-distances.js", "hypo_code": "var distance = function(nums) {\n    let n = nums.length;\n\tlet arr = new Array(n);\n\tfor (let i = 0; i < n; i++) {\n\t\tlet val = nums[i];\n\t\tlet sum = 0;\n\t\tfor (let j = 0; j < n; j++) {\n\t\t\tif (nums[j] === val && j !== i) {\n\t\t\t\tsum += Math.abs(i - j);\n\t\t\t}\n\t\t}\n\t\tarr[i] = sum;\n\t}\n\treturn arr;\n};"}
{"id": "1698", "path": "output2\\js\\Medium\\1698-minimize-the-maximum-difference-of-pairs.js", "hypo_code": "var minimizeMax = function(nums, p) {\n    nums.sort((a,b) => a-b);\n    let n = nums.length;\n    let max = nums[n-1];\n    let ans = max;\n    let sum = 0;\n    for (let i = 0; i < p; i++) {\n        sum += nums[i];\n    }\n    if (p === 1) {\n        return max - nums[0];\n    }\n    ans = Math.min(ans, max - nums[p-1]);\n    let j = p-1;\n    for (let i = 1; i < n; i++) {\n        sum += nums[i+p-1] - nums[i-1];\n        while (j < n && nums[j+1] < nums[i]) {\n            sum -= nums[j];\n            j++;\n        }\n        ans = Math.min(ans, max*p - sum);\n    }\n    return ans;\n};"}
{"id": "1707", "path": "output2\\js\\Medium\\1707-find-the-score-of-all-prefixes-of-an-array.js", "hypo_code": "var findPrefixScore = function(nums) {\n    let n = nums.length;\n    let ans = [];\n    for (let i = 0; i < n; i++) {\n        let max = nums[0];\n        for (let j = 0; j <= i; j++) {\n            max = Math.max(max, nums[j]);\n        }\n        ans.push(nums[i] + max);\n    }\n    return ans;\n};"}
{"id": "1708", "path": "output2\\js\\Medium\\1708-cousins-in-binary-tree-ii.js", "hypo_code": "var replaceValueInTree = function(root) {\n    let queue = [root];\n    let level = 0;\n    let map = new Map();\n    while (queue.length > 0) {\n        let len = queue.length;\n        let sum = 0;\n        for (let i = 0; i < len; i++) {\n            let node = queue.shift();\n            sum += node.val;\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        map.set(level, sum);\n        level++;\n    }\n    let arr = [...map.values()];\n    arr.sort((a,b) => b-a);\n    return arr[k-1];\n};"}
{"id": "1709", "path": "output2\\js\\Medium\\1709-minimum-additions-to-make-valid-string.js", "hypo_code": "var addMinimum = function(word) {\n    let count = 0;\n    let n = word.length;\n    let a = 0, b = 0, c = 0;\n    for (let i = 0; i < n; i++) {\n        if (word[i] === 'a') {\n            if (b > 0 || c > 0) {\n                count++;\n                b = 0;\n                c = 0;\n            }\n            a++;\n        } else if (word[i] === 'b') {\n            if (a > 0) {\n                a--;\n                b++;\n            } else if (c > 0) {\n                count++;\n                c = 0;\n                b++;\n            } else {\n                count += 2;\n                b++;\n            }\n        } else {\n            if (a > 0) {\n                a--;\n                c++;\n            } else if (b > 0) {\n                b--;\n                c++;\n            } else {\n                count += 2;\n                c++;\n            }\n        }\n    }\n    if (b > 0 || c > 0) {\n        count += 2;\n    }\n    return count;\n};"}
{"id": "1711", "path": "output2\\js\\Medium\\1711-sliding-subarray-beauty.js", "hypo_code": "var getSubarrayBeauty = function(nums, k, x) {\n    let n = nums.length;\n    let arr = new Array(n-k+1);\n    for (let i = 0; i < n-k+1; i++) {\n        let subarr = nums.slice(i, i+k);\n        subarr.sort((a,b) => a-b);\n        arr[i] = subarr[x-1] < 0 ? subarr[x-1] : 0;\n    }\n    return arr;\n};"}
{"id": "1712", "path": "output2\\js\\Medium\\1712-minimum-number-of-operations-to-make-all-array-elements-equal-to-1.js", "hypo_code": "var minOperations = function(nums) {\n    let n = nums.length;\n    let ans = 0;\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        let val = nums[i];\n        let count = 0;\n        while (val !== 1) {\n            if (val % 2 === 0) {\n                val /= 2;\n            } else {\n                val--;\n            }\n            count++;\n        }\n        if (count > max) max = count;\n        ans += count;\n    }\n    return ans-max;\n};"}
{"id": "1713", "path": "output2\\js\\Medium\\1713-find-the-prefix-common-array-of-two-arrays.js", "hypo_code": "var findThePrefixCommonArray = function(A, B) {\n    let n = A.length;\n    let arr = new Array(n);\n    arr[0] = A[0] === B[0] ? 1 : 0;\n    for (let i = 1; i < n; i++) {\n        arr[i] = A[i] === B[i] ? arr[i-1] + 1 : arr[i-1];\n    }\n    return arr;\n};"}
{"id": "1714", "path": "output2\\js\\Medium\\1714-maximum-number-of-fish-in-a-grid.js", "hypo_code": "var findMaxFish = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let max = 0;\n    let visited = new Array(m).fill().map(() => new Array(n).fill(false));\n    let dirs = [[0,1],[0,-1],[1,0],[-1,0]];\n    let dfs = (i, j) => {\n        visited[i][j] = true;\n        let sum = grid[i][j];\n        for (let d of dirs) {\n            let x = i + d[0];\n            let y = j + d[1];\n            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > 0 && !visited[x][y]) {\n                sum += dfs(x, y);\n            }\n        }\n        return sum;\n    }\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n;j++) {\n            if (grid[i][j] > 0 && !visited[i][j]) {\n                max = Math.max(max, dfs(i, j));\n            }\n        }\n    }\n    return max;\n};"}
{"id": "1715", "path": "output2\\js\\Medium\\1715-first-completely-painted-row-or-column.js", "hypo_code": "var firstCompleteIndex = function(arr, mat) {\n    let n = mat.length;\n    let m = mat[0].length;\n    let rows = new Array(n).fill(0);\n    let cols = new Array(m).fill(0);\n    for (let i = 0; i < arr.length; i++) {\n        let val = arr[i];\n        let r = Math.floor((val-1) / m);\n        let c = (val-1) % m;\n        rows[r]++;\n        cols[c]++;\n    }\n    for (let i = 0; i < n; i++) {\n        if (rows[i] === m) return i;\n    }\n    for (let i = 0; i < m; i++) {\n        if (cols[i] === n) return i+n;\n    }\n    return -1;\n};"}
{"id": "1716", "path": "output2\\js\\Medium\\1716-minimum-cost-of-a-path-with-special-roads.js", "hypo_code": "var minimumCost = function(start, target, specialRoads) {\n    let n = specialRoads.length;\n    let min = Infinity;\n    for (let i = 0; i < n; i++) {\n        let road = specialRoads[i];\n        let cost = road[4];\n        let x1 = road[0];\n        let y1 = road[1];\n        let x2 = road[2];\n        let y2 = road[3];\n        let diff = Math.abs(x2-x1) + Math.abs(y2-y1);\n        if (diff < min) min = diff;\n    }\n    return min;\n};"}
{"id": "1718", "path": "output2\\js\\Medium\\1718-number-of-adjacent-elements-with-the-same-color.js", "hypo_code": "var colorTheArray = function(n, queries) {\n    let arr = new Array(n).fill(0);\n    let res = [];\n    for (let i = 0; i < queries.length; i++) {\n        let [index, color] = queries[i];\n        arr[index] = color;\n        let count = 0;\n        for (let j = 0; j < n-1; j++) {\n            if (arr[j] === arr[j+1] && arr[j] !== 0) count++;\n        }\n        res.push(count);\n    }\n    return res;\n};"}
{"id": "1719", "path": "output2\\js\\Medium\\1719-make-costs-of-paths-equal-in-a-binary-tree.js", "hypo_code": "var minIncrements = function(n, cost) {\n    let max = Math.max(...cost);\n    let count = new Array(max+1).fill(0);\n    for (let i = 0; i < cost.length; i++) {\n        count[cost[i]]++;\n    }\n    let sum = 0;\n    let i = 1;\n    while (n > 0) {\n        if (count[i] > 0) {\n            sum += i;\n            n--;\n            count[i]--;\n        } else {\n            i++;\n        }\n    }\n    return sum - max;\n};"}
{"id": "1720", "path": "output2\\js\\Medium\\1720-sum-in-a-matrix.js", "hypo_code": "var matrixSum = function(nums) {\n    let m = nums.length;\n    let n = nums[0].length;\n    let ans = 0;\n    for (let j = 0; j < n; j++) {\n        let max = -Infinity;\n        let maxRow = -1;\n        for (let i = 0; i < m; i++) {\n            let val = nums[i][j];\n            if (val > max) {\n                max = val;\n                maxRow = i;\n            }\n        }\n        ans += max;\n        nums[maxRow][j] = -Infinity;\n    }\n    return ans;\n};"}
{"id": "1721", "path": "output2\\js\\Medium\\1721-maximum-or.js", "hypo_code": "var maximumOr = function(nums, k) {\n    let max = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        if (val > max) max = val;\n    }\n    let maxBinary = max.toString(2);\n    let n = maxBinary.length;\n    let ans = 0;\n    let count = 0;\n    for (let i = n-1; i >= 0; i--) {\n        if (count < k) {\n            ans += 2**i;\n            count++;\n        } else {\n            if (maxBinary[i] === '1') {\n                ans += 2**i;\n            }\n        }\n    }\n    return ans;\n};"}
{"id": "1722", "path": "output2\\js\\Medium\\1722-neighboring-bitwise-xor.js", "hypo_code": "var doesValidArrayExist = function(derived) {\n    let n = derived.length;\n    if (n === 1) return true;\n    let first = derived[0];\n    let last = derived[n-1];\n    if (first !== last) return false;\n    let arr = new Array(n);\n    arr[0] = first;\n    for (let i = 1; i < n; i++) {\n        arr[i] = derived[i-1] ^ arr[i-1];\n    }\n    return arr[n-1] === last;\n};"}
{"id": "1723", "path": "output2\\js\\Medium\\1723-maximum-number-of-moves-in-a-grid.js", "hypo_code": "var maxMoves = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let dp = new Array(m);\n    for (let i = 0; i < m; i++) {\n        dp[i] = new Array(n).fill(0);\n    }\n    for (let i = 0; i < m; i++) {\n        dp[i][n-1] = 1;\n    }\n    for (let j = n-2; j >= 0; j--) {\n        for (let i = 0; i < m; i++) {\n            if (i > 0 && grid[i][j] > grid[i-1][j+1]) {\n                dp[i][j] = Math.max(dp[i][j], dp[i-1][j+1] + 1);\n            }\n            if (grid[i][j] > grid[i][j+1]) {\n                dp[i][j] = Math.max(dp[i][j], dp[i][j+1] + 1);\n            }\n            if (i < m-1 && grid[i][j] > grid[i+1][j+1]) {\n                dp[i][j] = Math.max(dp[i][j], dp[i+1][j+1] + 1);\n            }\n        }\n    }\n    let max = 0;\n    for (let i = 0; i < m; i++) {\n        max = Math.max(max, dp[i][0]);\n    }\n    return max;\n};"}
{"id": "1724", "path": "output2\\js\\Medium\\1724-count-the-number-of-complete-components.js", "hypo_code": "var countCompleteComponents = function(n, edges) {\n    let count = 0;\n    let arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = i;\n    }\n    for (let i = 0; i < edges.length; i++) {\n        let [a, b] = edges[i];\n        for (let j = 0; j < n; j++) {\n            if (arr[j] === b) arr[j] = a;\n        }\n    }\n    let set = new Set();\n    for (let i = 0; i < n; i++) {\n        set.add(arr[i]);\n    }\n    return set.size;\n};"}
{"id": "1727", "path": "output2\\js\\Medium\\1727-find-the-punishment-number-of-an-integer.js", "hypo_code": "var punishmentNumber = function(n) {\n    let count = 0;\n    for (let i = 1; i <= n; i++) {\n        let str = (i*i).toString();\n        let sum = 0;\n        for (let j = 0; j < str.length; j++) {\n            sum += parseInt(str[j]);\n            if (sum > i) break;\n        }\n        if (sum === i) {\n            count += i*i;\n        }\n    }\n    return count;\n};"}
{"id": "1729", "path": "output2\\js\\Medium\\1729-extra-characters-in-a-string.js", "hypo_code": "var minExtraChar = function(s, dictionary) {\n    let n = s.length;\n    let dp = new Array(n+1).fill(0);\n    for (let i = 1; i <= n; i++) {\n        dp[i] = dp[i-1] + 1;\n        for (let j = 0; j < dictionary.length; j++) {\n            let word = dictionary[j];\n            if (i >= word.length && s.substring(i-word.length, i) === word) {\n                dp[i] = Math.min(dp[i], dp[i-word.length]);\n            }\n        }\n    }\n    return dp[n];\n};"}
{"id": "1730", "path": "output2\\js\\Medium\\1730-maximum-strength-of-a-group.js", "hypo_code": "var maxStrength = function(nums) {\n    let n = nums.length;\n    let ans = 0;\n    let max = nums[0];\n    let min = nums[0];\n    for (let i = 0; i < n; i++) {\n        max = Math.max(max, nums[i]);\n        min = Math.min(min, nums[i]);\n    }\n    let set = new Set();\n    for (let i = 0; i < n; i++) {\n        let val = nums[i];\n        if (val === max || val === min) {\n            if (!set.has(val)) {\n                ans++;\n                set.add(val);\n            }\n        }\n    }\n    return ans;\n};"}
{"id": "1731", "path": "output2\\js\\Medium\\1731-difference-of-number-of-distinct-values-on-diagonals.js", "hypo_code": "var differenceOfDistinctValues = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let ans = new Array(m);\n    for (let i = 0; i < m; i++) {\n        ans[i] = new Array(n);\n        for (let j = 0; j < n; j++) {\n            let topLeft = [];\n            let bottomRight = [];\n            let x = i;\n            let y = j;\n            while (x >= 0 && y >= 0) {\n                topLeft.push(grid[x][y]);\n                x--;\n                y--;\n            }\n            x = i;\n            y = j;\n            while (x < m && y < n) {\n                bottomRight.push(grid[x][y]);\n                x++;\n                y++;\n            }\n            ans[i][j] = Math.abs(getDistinctValues(topLeft) - getDistinctValues(bottomRight));\n        }\n    }\n    return ans;\n};"}
{"id": "1732", "path": "output2\\js\\Medium\\1732-minimum-cost-to-make-all-characters-equal.js", "hypo_code": "var minimumCost = function(s) {\n    let n = s.length;\n    let cost = 0;\n    let ones = 0;\n    let zeros = 0;\n    for (let i = 0; i < n; i++) {\n        if (s[i] === '1') ones++;\n        else zeros++;\n    }\n    let min = Math.min(ones, zeros);\n    cost += min;\n    ones -= min;\n    zeros -= min;\n    if (ones > 0) {\n        cost += ones;\n        ones = 0;\n    }\n    if (zeros > 0) {\n        cost += zeros;\n        zeros = 0;\n    }\n    return cost;\n};"}
{"id": "1733", "path": "output2\\js\\Medium\\1733-sum-of-matrix-after-queries.js", "hypo_code": "var matrixSumQueries = function(n, queries) {\n    let matrix = new Array(n);\n    for (let i = 0; i < n; i++) {\n        matrix[i] = new Array(n);\n        for (let j = 0; j < n; j++) {\n            matrix[i][j] = 0;\n        }\n    }\n    let m = queries.length;\n    for (let i = 0; i < m; i++) {\n        let type = queries[i][0];\n        let index = queries[i][1];\n        let val = queries[i][2];\n        if (type === 0) {\n            for (let j = 0; j < n; j++) {\n                matrix[index][j] = val;\n            }\n        } else {\n            for (let j = 0; j < n; j++) {\n                matrix[j][index] = val;\n            }\n        }\n    }\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j =0; j < n; j++) {\n            ans += matrix[i][j]; \n        }\n    }\n    return ans;\n};"}
{"id": "1736", "path": "output2\\js\\Medium\\1736-find-the-longest-semi-repetitive-substring.js", "hypo_code": "var longestSemiRepetitiveSubstring = function(s) {\n    let n = s.length;\n    let maxLen = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i+1; j < n; j++) {\n            let substr = s.substring(i, j+1);\n            if (isSemiRepetitive(substr)) {\n                maxLen = Math.max(maxLen, substr.length);\n            }\n        }\n    }\n    return maxLen;\n};\nvar isSemiRepetitive = function(s) {\n    let count = 0;\n    for (let i = 0; i < s.length-1; i++) {\n        if (s[i] === s[i+1]) {\n            count++;\n        }\n    }\n    return count <= 1;\n};"}
{"id": "1737", "path": "output2\\js\\Medium\\1737-movement-of-robots.js", "hypo_code": "var sumDistance = function(nums, s, d) {\n    let n = nums.length;\n    let pos = new Array(n);\n    for (let i = 0; i < n; i++) {\n        pos[i] = nums[i];\n    }\n    for (let i = 0; i < s.length; i++) {\n        for (let j = 0; j < n; j++) {\n            if (s[i] === 'R') {\n                pos[j]++;\n            } else {\n                pos[j]--;\n            }\n        }\n    }\n    pos.sort((a,b) => a-b);\n    let sum = 0;\n    for (let i = 0; i < n; i++) {\n        let diff = d - pos[i];\n        sum += diff * (i+1) * (n-i);\n        sum %= 1000000007;\n    }\n    return sum;\n};"}
{"id": "1738", "path": "output2\\js\\Medium\\1738-lexicographically-smallest-string-after-substring-operation.js", "hypo_code": "var smallestString = function(s) {\n    let ans = s;\n    let n = s.length;\n    let s2 = s+s;\n    for (let i = 1; i < n; i++) {\n        let substr = s2.substring(i, i+n);\n        ans = Math.min(ans, substr);\n    }\n    return ans;\n};"}
{"id": "1739", "path": "output2\\js\\Medium\\1739-collecting-chocolates.js", "hypo_code": "var minCost = function(nums, x) {\n    let n = nums.length;\n    let sum = 0;\n    let min = Infinity;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        if (nums[i] < min) min = nums[i];\n    }\n    let diff = sum - x;\n    if (diff === 0) return n;\n    let ans = 0;\n    let temp = 0;\n    let i = 0;\n    let j = n-1;\n    while (i < j) {\n        if (temp < diff) {\n            temp += nums[i];\n            i++;\n        } else if (temp === diff) {\n            ans = Math.max(ans, i + n - j);\n            temp -= nums[j];\n            j--;\n        } else {\n            temp -= nums[j];\n            j--;\n        }\n    }\n    return ans;\n};"}
{"id": "1740", "path": "output2\\js\\Medium\\1740-find-the-value-of-the-partition.js", "hypo_code": "var findValueOfPartition = function(nums) {\n    let n = nums.length;\n    let max = nums[0];\n    let min = nums[0];\n    for (let i = 0; i < n; i++) {\n        max = Math.max(max, nums[i]);\n        min = Math.min(min, nums[i]);\n    }\n    return max - min;\n};"}
{"id": "1741", "path": "output2\\js\\Medium\\1741-special-permutations.js", "hypo_code": "var specialPerm = function(nums) {\n    let n = nums.length;\n    let arr = new Array(n);\n    let count = 0;\n    let visited = new Array(n).fill(false);\n    function dfs(pos) {\n        if (pos === n) {\n            count++;\n            return;\n        }\n        for (let i = 0; i < n; i++) {\n            if (visited[i] === true) continue;\n            if (pos > 0 && nums[i] % nums[pos-1] !== 0 && nums[pos-1] % nums[i] !== 0) continue;\n            visited[i] = true;\n            dfs(pos+1);\n            visited[i] = false;\n        }\n    }\n    dfs(0);\n    return count;\n};"}
{"id": "1742", "path": "output2\\js\\Medium\\1742-construct-the-longest-new-string.js", "hypo_code": "var longestString = function(x, y, z) {\n    let ans = \"\";\n    let a = \"A\";\n    let b = \"B\";\n    if (x > y) {\n        let temp = x;\n        x = y;\n        y = temp;\n        let temp2 = a;\n        a = b;\n        b = temp2;\n    }\n    while (x > 0 && y > 0) {\n        ans += a + a + b;\n        x--;\n        y--;\n    }\n    if (y > 0) {\n        ans += b;\n        y--;\n    }\n    if (x > 0) {\n        ans = a + ans;\n        x--;\n    }\n    while (z > 0) {\n        ans += a + b;\n        z--;\n    }\n    return ans.length;\n};"}
{"id": "1743", "path": "output2\\js\\Medium\\1743-decremental-string-concatenation.js", "hypo_code": "var minimizeConcatenatedLength = function(words) {\n    let n = words.length;\n    let dp = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n        for (let j = 0; j < n; j++) {\n            dp[i][j] = Infinity;\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = words[i].length;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = i-1; j >= 0; j--) {\n            let len = Infinity;\n            for (let k = j; k < i; k++) {\n                let left = dp[j][k];\n                let right = dp[k+1][i];\n                if (left === Infinity || right === Infinity) continue;\n                let leftLast = words[k].length-1;\n                let rightFirst = 0;\n                if (words[k][leftLast] === words[k+1][rightFirst]) {\n                    len = Math.min(len, left+right-1);\n                } else {\n                    len = Math.min(len, left+right);\n                }\n            }\n            dp[j][i] = len;\n        }\n    }\n    return dp[0][n-1];\n};"}
{"id": "1744", "path": "output2\\js\\Medium\\1744-count-zero-request-servers.js", "hypo_code": "var countServers = function(n, logs, x, queries) {\n    let arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = new Array(2).fill(0);\n    }\n    for (let i = 0; i < logs.length; i++) {\n        let [server_id, time] = logs[i];\n        arr[server_id-1][0] = time;\n        arr[server_id-1][1] = time + x;\n    }\n    let ans = new Array(queries.length).fill(0);\n    for (let i = 0; i < queries.length; i++) {\n        let count = 0;\n        let time = queries[i];\n        for (let j = 0; j < n; j++) {\n            if (arr[j][0] <= time && time <= arr[j][1]) {\n                count++;\n            }\n        }\n        ans[i] = count;\n    }\n    return ans;\n};"}
{"id": "1745", "path": "output2\\js\\Medium\\1745-minimum-operations-to-make-the-integer-zero.js", "hypo_code": "var makeTheIntegerZero = function(num1, num2) {\n    if (num1 === 0) return 0;\n    if (num2 === 0) return -1;\n    let ans = 0;\n    while (num1 !== 0) {\n        let found = false;\n        for (let i = 0; i <= 60; i++) {\n            let val = Math.pow(2,i)*num2;\n            if (num1 - val === 0) {\n                num1 = 0;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            num1--;\n        }\n        ans++;\n    }\n    return ans;\n};"}
{"id": "1746", "path": "output2\\js\\Medium\\1746-ways-to-split-array-into-good-subarrays.js", "hypo_code": "var numberOfGoodSubarraySplits = function(nums) {\n    let count = 0;\n\tlet set = new Set();\n\tfor (let i = 0; i < nums.length; i++) {\n\t\tlet val = nums[i];\n\t\tif (val === 1) {\n\t\t\tset.add(i);\n\t\t}\n\t}\n\tlet arr = Array.from(set);\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tlet val = arr[i];\n\t\tlet left = val-1;\n\t\tlet right = val+1;\n\t\twhile (left >= 0 && right < nums.length) {\n\t\t\tif (nums[left] === 1 && nums[right] === 1) {\n\t\t\t\tcount += 2;\n\t\t\t\tleft--;\n\t\t\t\tright++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n};"}
{"id": "1747", "path": "output2\\js\\Medium\\1747-prime-pairs-with-target-sum.js", "hypo_code": "var findPrimePairs = function(n) {\n    let primes = [];\n    let isPrime = new Array(n+1).fill(true);\n    for (let i = 2; i <= n; i++) {\n        if (isPrime[i]) {\n            primes.push(i);\n            for (let j = i*i; j <= n; j+=i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    let ans = [];\n    for (let i = 0; i < primes.length; i++) {\n        let val = n - primes[i];\n        if (isPrime[val]) {\n            ans.push([primes[i], val]);\n        }\n    }\n    return ans;\n};"}
{"id": "1748", "path": "output2\\js\\Medium\\1748-continuous-subarrays.js", "hypo_code": "var continuousSubarrays = function(nums) {\n    let count = 0;\n\tlet n = nums.length;\n\tfor (let i = 0; i < n; i++) {\n\t\tlet min = nums[i];\n\t\tlet max = nums[i];\n\t\tfor (let j = i; j < n; j++) {\n\t\t\tif (nums[j] < min) min = nums[j];\n\t\t\tif (nums[j] > max) max = nums[j];\n\t\t\tif (max - min <= 2) count++;\n\t\t}\n\t}\n\treturn count;\n};"}
{"id": "1749", "path": "output2\\js\\Medium\\1749-relocate-marbles.js", "hypo_code": "var relocateMarbles = function(nums, moveFrom, moveTo) {\n    let n = nums.length;\n    let ans = [];\n    for (let i = 0; i < n; i++) {\n        ans.push(nums[i]);\n    }\n    for (let i = 0; i < moveFrom.length; i++) {\n        let from = moveFrom[i];\n        let to = moveTo[i];\n        let val = ans[from];\n        ans[from] = Infinity;\n        ans[to] += val;\n    }\n    ans.sort((a, b) => a - b);\n    let result = [];\n    for (let i = 0; i < n; i++) {\n        if (ans[i] !== Infinity) result.push(ans[i]);\n    }\n    return result;\n};"}
{"id": "1750", "path": "output2\\js\\Medium\\1750-partition-string-into-minimum-beautiful-substrings.js", "hypo_code": "var minimumBeautifulSubstrings = function(s) {\n    let ans = 0;\n    let n = s.length;\n    for (let i = 0; i < n; i++) {\n        let j = i;\n        let val = 0;\n        while (j < n) {\n            val = val * 2 + parseInt(s[j]);\n            if (val % 5 === 0) {\n                ans++;\n                break;\n            }\n            j++;\n        }\n        i = j;\n    }\n    return ans;\n};"}
{"id": "1751", "path": "output2\\js\\Medium\\1751-number-of-black-blocks.js", "hypo_code": "var countBlackBlocks = function(m, n, coordinates) {\n    let blocks = new Set();\n    for (let i = 0; i < coordinates.length; i++) {\n        let [x,y] = coordinates[i];\n        blocks.add(`${x},${y}`);\n    }\n    let arr = new Array(5).fill(0);\n    for (let i = 0; i < m-1; i++) {\n        for (let j = 0; j < n-1; j++) {\n            if (blocks.has(`${i},${j}`) && blocks.has(`${i+1},${j}`) && blocks.has(`${i},${j+1}`) && blocks.has(`${i+1},${j+1}`)) {\n                arr[4]++;\n            } else if (blocks.has(`${i},${j}`) || blocks.has(`${i+1},${j}`) || blocks.has(`${i},${j+1}`) || blocks.has(`${i+1},${j+1}`)) {\n                arr[3]++;\n            } else if (!blocks.has(`${i},${j}`) && !blocks.has(`${i+1},${j}`) && !blocks.has(`${i},${j+1}`) && !blocks.has(`${i+1},${j+1}`)) {\n                arr[0]++;\n            } else {\n                arr[2]++;\n            }\n        }\n    }\n    return arr;\n};"}
{"id": "1752", "path": "output2\\js\\Medium\\1752-maximum-number-of-jumps-to-reach-the-last-index.js", "hypo_code": "var maximumJumps = function(nums, target) {\n    let n = nums.length;\n    let dp = new Array(n).fill(0);\n    let sorted = nums.slice().sort((a,b) => a-b);\n    let map = new Map();\n    for (let i = 0; i < n; i++) {\n        map.set(sorted[i], i);\n    }\n    for (let i = 0; i < n; i++) {\n        let val = nums[i];\n        let idx = map.get(val);\n        let max = 0;\n        for (let j = idx - 1; j >= 0; j--) {\n            let diff = idx - j;\n            if (nums[j] >= val && diff > target) {\n                break;\n            }\n            if (dp[j] > max) {\n                max = dp[j];\n            }\n        }\n        for (let j = idx + 1; j < n; j++) {\n            let diff = j - idx;\n            if (nums[j] >= val && diff > target) {\n                break;\n            }\n            if (dp[j] > max) {\n                max = dp[j];\n            }\n        }\n        dp[idx] = max + 1;\n    }\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        if (dp[i] > ans) {\n            ans = dp[i];\n        }\n    }\n    return ans;\n};"}
{"id": "1753", "path": "output2\\js\\Medium\\1753-longest-non-decreasing-subarray-from-two-arrays.js", "hypo_code": "var maxNonDecreasingLength = function(nums1, nums2) {\n    let n = nums1.length;\n    let arr = [];\n    for (let i = 0; i < n; i++) {\n        arr.push([nums1[i], nums2[i]]);\n    }\n    let dp = new Array(n).fill(0);\n    dp[0] = 1;\n    for (let i = 1; i < n; i++) {\n        if (arr[i][0] >= arr[i-1][0] && arr[i][1] >= arr[i-1][1]) {\n            dp[i] = dp[i-1] + 1;\n        } else if (arr[i][0] >= arr[i-1][1] && arr[i][1] >= arr[i-1][0]) {\n            dp[i] = dp[i-1] + 1;\n        } else {\n            dp[i] = 1;\n        }\n    }\n    let ans = 0;\n    for (let i = 0; i < n; i++) {\n        ans = Math.max(ans, dp[i]);\n    }\n    return ans;\n};"}
{"id": "1754", "path": "output2\\js\\Medium\\1754-apply-operations-to-make-all-array-elements-equal-to-zero.js", "hypo_code": "var checkArray = function(nums, k) {\n    let sum = 0;\n    let set = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        set.add(nums[i]);\n    }\n    let n = nums.length;\n    if (k === 1) {\n        return true;\n    } else if (k === 2) {\n        if (n === sum) {\n            return true;\n        } else if (set.size === 1) {\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        if (n === sum) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};"}
{"id": "1755", "path": "output2\\js\\Medium\\1755-maximum-beauty-of-an-array-after-applying-operation.js", "hypo_code": "var maximumBeauty = function(nums, k) {\n    let n = nums.length;\n    let sum = 0;\n    let max = -Infinity;\n    for (let i = 0; i < n; i++) {\n        let val = nums[i];\n        if (val > 0) {\n            sum += val;\n            if (sum > max) max = sum;\n        }\n    }\n    if (max === -Infinity) return 0;\n    return max * 2;\n};"}
{"id": "1756", "path": "output2\\js\\Medium\\1756-minimum-index-of-a-valid-split.js", "hypo_code": "var minimumIndex = function(nums) {\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        let val = nums[i];\n        if (map.has(val)) {\n            map.set(val, map.get(val)+1);\n        } else {\n            map.set(val, 1);\n        }\n    }\n    let dominantVal = 0;\n    let dominantCount = 0;\n    for (let [key, val] of map) {\n        if (val > dominantCount) {\n            dominantCount = val;\n            dominantVal = key;\n        }\n    }\n    let count = 0;\n    let i = 0;\n    while (i < nums.length) {\n        let val = nums[i];\n        if (val === dominantVal) {\n            count++;\n        }\n        if (count * 2 > nums.length) {\n            break;\n        }\n        i++;\n    }\n    if (i === nums.length) {\n        return -1;\n    }\n    return i;\n};"}
{"id": "1757", "path": "output2\\js\\Medium\\1757-sort-vowels-in-a-string.js", "hypo_code": "var sortVowels = function(s) {\n    let n = s.length;\n    let arr = new Array(n);\n    let i = 0;\n    let j = n - 1;\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    while (i <= j) {\n        let val = s[i];\n        if (vowels.includes(val.toLowerCase())) {\n            arr[i] = val;\n            i++;\n        } else {\n            val = s[j];\n            if (vowels.includes(val.toLowerCase())) {\n                arr[j] = val;\n                j--;\n            } else {\n                arr[i] = s[i];\n                arr[j] = s[j];\n                i++;\n                j--;\n            }\n        }\n    }\n    return arr.join('');\n};"}
{"id": "1758", "path": "output2\\js\\Medium\\1758-visit-array-positions-to-maximize-score.js", "hypo_code": "var maxScore = function(nums, x) {\n    let n = nums.length;\n    let sum = 0;\n    let min = Infinity;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        if (nums[i] > 0 && nums[i] < min) min = nums[i];\n    }\n    if (min === Infinity) return 0;\n    return sum - min;\n};"}
{"id": "1759", "path": "output2\\js\\Medium\\1759-ways-to-express-an-integer-as-sum-of-powers.js", "hypo_code": "var numberOfWays = function(n, x) {\n    let nums = [];\n    for (let i = 1; Math.pow(i, x) <= n; i++) {\n        nums.push(Math.pow(i, x));\n    }\n    return dfs(nums, n, nums.length-1);\n};\nvar dfs = function(nums, n, index) {\n    if (n === 0) return 1;\n    if (n < 0 || index < 0) return 0;\n    return dfs(nums, n-nums[index], index-1) + dfs(nums, n, index-1);\n}"}
{"id": "1760", "path": "output2\\js\\Medium\\1760-largest-element-in-an-array-after-merge-operations.js", "hypo_code": "var maxArrayValue = function(nums) {\n    let n = nums.length;\n    let max = 0;\n    for (let i = 0; i < n; i++) {\n        if (nums[i] > max) max = nums[i];\n    }\n    let left = 0;\n    let right = max;\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (check(nums, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n};"}
{"id": "1761", "path": "output2\\js\\Medium\\1761-count-complete-subarrays-in-an-array.js", "hypo_code": "var countCompleteSubarrays = function(nums) {\n    let count = 0;\n    let n = nums.length;\n    let set = new Set();\n    for (let i = 0; i < n; i++) {\n        let val = nums[i];\n        set.add(val);\n        let size = set.size;\n        let j = i+1;\n        while (j < n && set.size < n) {\n            let val = nums[j];\n            set.add(val);\n            if (set.size === size) {\n                count++;\n            }\n            j++;\n        }\n        set.clear();\n    }\n    return count;\n};"}
{"id": "1762", "path": "output2\\js\\Medium\\1762-shortest-string-that-contains-three-strings.js", "hypo_code": "var minimumString = function(a, b, c) {\n    let s = a + b + c;\n    let n = s.length;\n    let ans = s;\n    for (let i = 0; i < n; i++) {\n        for (let j = i; j < n; j++) {\n            let substr = s.substring(i, j+1);\n            if (substr.includes(a) && substr.includes(b) && substr.includes(c)) {\n                if (substr.length < ans.length) {\n                    ans = substr;\n                } else if (substr.length === ans.length) {\n                    ans = substr < ans ? substr : ans;\n                }\n            }\n        }\n    }\n    return ans;\n};"}
{"id": "1763", "path": "output2\\js\\Medium\\1763-insert-greatest-common-divisors-in-linked-list.js", "hypo_code": "var insertGreatestCommonDivisors = function(head) {\n    let arr = [];\n    let node = head;\n    while (node) {\n        arr.push(node.val);\n        node = node.next;\n    }\n    let gcd = function(a, b) {\n        if (b === 0) return a;\n        return gcd(b, a%b);\n    };\n    let insert = function(a, b) {\n        let node = new ListNode(gcd(a, b), b);\n        return node;\n    };\n    let newHead = new ListNode(arr[0]);\n    let newNode = newHead;\n    for (let i = 1; i < arr.length; i++) {\n        newNode.next = insert(arr[i-1], arr[i]);\n        newNode = newNode.next;\n    }\n    newNode.next = new ListNode(arr[arr.length-1]);\n    return newHead;\n};"}
{"id": "1764", "path": "output2\\js\\Medium\\1764-minimum-seconds-to-equalize-a-circular-array.js", "hypo_code": "var minimumSeconds = function(nums) {\n    let n = nums.length;\n    let max = nums[0];\n    let sum = nums[0];\n    for (let i = 1; i < n; i++) {\n        sum += nums[i];\n        max = Math.max(max, nums[i]);\n    }\n    return Math.max(2*max, Math.ceil(sum/(n-1)));\n};"}
{"id": "1765", "path": "output2\\js\\Medium\\1765-check-if-it-is-possible-to-split-array.js", "hypo_code": "var canSplitArray = function(nums, m) {\n    let n = nums.length;\n    let sum = 0;\n    let max = -Infinity;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        if (nums[i] > max) max = nums[i];\n    }\n    if (max > sum - max) return false;\n    if (max === sum - max) return true;\n    let left = max;\n    let right = sum;\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        let count = 1;\n        let curr = 0;\n        for (let i = 0; i < n; i++) {\n            if (curr + nums[i] > mid) {\n                count++;\n                curr = 0;\n            }\n            curr += nums[i];\n        }\n        if (count <= m) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left === max;\n};"}
{"id": "1766", "path": "output2\\js\\Medium\\1766-find-the-safest-path-in-a-grid.js", "hypo_code": "var maximumSafenessFactor = function(grid) {\n    let n = grid.length;\n    let map = new Map();\n    let directions = [[-1,0],[1,0],[0,-1],[0,1]];\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++ ) {\n            if (grid[i][j] === 1) map.set(`${i},${j}`, 0);\n        }\n    }\n    let bfs = (x, y) => {\n        let queue = [[x,y]];\n        let visited = new Set([[x,y].toString()]);\n        let distance = 0;\n        while (queue.length > 0) {\n            let size = queue.length;\n            for (let i = 0; i < size; i++) {\n                let [x,y] = queue.shift();\n                if (grid[x][y] === 1) {\n                    map.set(`${x},${y}`, distance);\n                    continue;\n                }\n                for (let j = 0; j < directions.length; j++) {\n                    let [dx, dy] = directions[j];\n                    let newX = x + dx;\n                    let newY = y + dy;\n                    if (newX >= 0 && newX < n && newY >= 0 && newY < n && !visited.has(`${newX},${newY}`)) {\n                        visited.add(`${newX},${newY}`);\n                        queue.push([newX, newY]);\n                    }\n                }\n            }\n            distance++;\n        }\n    }\n    bfs(0,0);\n    bfs(n-1,n-1);\n    let max = 0;\n    for (let [key, val] of map) {\n        if (val > max) max = val;\n    }\n    return max;\n};"}
{"id": "1767", "path": "output2\\js\\Medium\\1767-double-a-number-represented-as-a-linked-list.js", "hypo_code": "var doubleIt = function(head) {\n    let node = head;\n    let carry = 0;\n    while (node) {\n        let val = node.val * 2 + carry;\n        let digit = val % 10;\n        carry = Math.floor(val / 10);\n        node.val = digit;\n        if (!node.next && carry > 0) {\n            node.next = new ListNode(carry);\n            break;\n        }\n        node = node.next;\n    }\n    return head;\n};"}
{"id": "1768", "path": "output2\\js\\Medium\\1768-minimum-absolute-difference-between-elements-with-constraint.js", "hypo_code": "var minAbsoluteDifference = function(nums, x) {\n    let n = nums.length;\n    if (n <= 1) return 0;\n    nums.sort((a,b) => a-b);\n    let ans = Infinity;\n    let i = 0;\n    let j = 1;\n    while (i < n && j < n) {\n        let diff = Math.abs(nums[i] - nums[j]);\n        if (diff >= x) {\n            ans = Math.min(ans, diff);\n            i++;\n        } else {\n            j++;\n        }\n    }\n    return ans;\n};"}
{"id": "1769", "path": "output2\\js\\Hard\\1769-median-of-two-sorted-arrays.js", "hypo_code": "var findMedianSortedArrays = function(nums1, nums2) {\n    let arr = [...nums1, ...nums2];\n    arr.sort((a,b) => a - b);\n    let len = arr.length;\n    if(len % 2 == 0){\n        return (arr[len/2] + arr[len/2 - 1])/2;\n    }else{\n        return arr[Math.floor(len/2)];\n    }\n    \n};"}
{"id": "1770", "path": "output2\\js\\Hard\\1770-regular-expression-matching.js", "hypo_code": "var isMatch = function(s, p) {\n    let reg = new RegExp(p);\n    return reg.test(s);\n    \n};"}
{"id": "1771", "path": "output2\\js\\Hard\\1771-merge-k-sorted-lists.js", "hypo_code": "var mergeKLists = function(lists) {\n    let arr = [];\n    for (let i = 0; i < lists.length; i++) {\n        let node = lists[i];\n        while (node) {\n            arr.push(node.val);\n            node = node.next;\n        }\n    }\n    arr.sort((a, b) => a - b);\n    let head = new ListNode();\n    let node = head;\n    for (let i = 0; i < arr.length; i++) {\n        node.next = new ListNode(arr[i]);\n        node = node.next;\n    }\n    return head.next;\n    \n};"}
{"id": "1772", "path": "output2\\js\\Hard\\1772-reverse-nodes-in-k-group.js", "hypo_code": "var reverseKGroup = function(head, k) {\n    let arr = [];\n    let node = head;\n    while (node) {\n        arr.push(node.val);\n        node = node.next;\n    }\n    let len = arr.length;\n    let res = [];\n    for (let i = 0; i < len; i += k) {\n        let temp = arr.slice(i, i + k);\n        if (temp.length == k) {\n            temp.reverse();\n        }\n        res = res.concat(temp);\n    }\n    let headNode = new ListNode();\n    let curNode = headNode;\n    for (let i = 0; i < res.length; i++) {\n        curNode.next = new ListNode(res[i]);\n        curNode = curNode.next;\n    }\n    return headNode.next;\n    \n};"}
{"id": "1773", "path": "output2\\js\\Hard\\1773-substring-with-concatenation-of-all-words.js", "hypo_code": "var findSubstring = function(s, words) {\n    let res = [];\n    let len = words.length;\n    if (len == 0) {\n        return res;\n    }\n    let wordLen = words[0].length;\n    let totalLen = len * wordLen;\n    let map = {};\n    for (let i = 0; i < len; i++) {\n        if (map[words[i]]) {\n            map[words[i]]++;\n        } else {\n            map[words[i]] = 1;\n        }\n    }\n    for (let i = 0; i < s.length - totalLen + 1; i++) {\n        let tempMap = {};\n        let j = 0;\n        for (; j < len; j++) {\n            let word = s.substring(i + j * wordLen, i + (j + 1) * wordLen);\n            if (map[word]) {\n                if (tempMap[word]) {\n                    tempMap[word]++;\n                } else {\n                    tempMap[word] = 1;\n                }\n                if (tempMap[word] > map[word]) {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        if (j == len) {\n            res.push(i);\n        }\n    }\n    return res;\n    \n};"}
{"id": "1774", "path": "output2\\js\\Hard\\1774-longest-valid-parentheses.js", "hypo_code": "var longestValidParentheses = function(s) {\n    let stack = [];\n    let max = 0;\n    let start = 0;\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == '('){\n            stack.push(i);\n        }else{\n            if(stack.length == 0){\n                start = i + 1;\n            }else{\n                stack.pop();\n                if(stack.length == 0){\n                    max = Math.max(max, i - start + 1);\n                }else{\n                    max = Math.max(max, i - stack[stack.length - 1]);\n                }\n            }\n        }\n    }\n    return max;\n    \n};"}
{"id": "1775", "path": "output2\\js\\Hard\\1775-sudoku-solver.js", "hypo_code": "var solveSudoku = function(board) {\n    let row = new Array(9).fill(0).map(() => new Array(9).fill(false));\n    let col = new Array(9).fill(0).map(() => new Array(9).fill(false));\n    let box = new Array(9).fill(0).map(() => new Array(9).fill(false));\n    let empty = [];\n    for(let i = 0; i < 9; i++){\n        for(let j = 0; j < 9; j++){\n            if(board[i][j] != '.'){\n                let num = board[i][j] - 1;\n                let k = Math.floor(i/3) * 3 + Math.floor(j/3);\n                row[i][num] = true;\n                col[j][num] = true;\n                box[k][num] = true;\n            }else{\n                empty.push([i, j]);\n            }\n        }\n    }\n    let dfs = function(n){\n        if(n == empty.length){\n            return true;\n        }\n        let i = empty[n][0];\n        let j = empty[n][1];\n        let k = Math.floor(i/3) * 3 + Math.floor(j/3);\n        for(let num = 0; num < 9; num++){\n            if(!row[i][num] && !col[j][num] && !box[k][num]){\n                row[i][num] = true;\n                col[j][num] = true;\n                box[k][num] = true;\n                board[i][j] = String(num + 1);\n                if(dfs(n + 1)){\n                    return true;\n                }\n                board[i][j] = '.';\n                row[i][num] = false;\n                col[j][num] = false;\n                box[k][num] = false;\n            }\n        }\n        return false;\n    }\n    dfs(0);\n    \n};"}
{"id": "1776", "path": "output2\\js\\Hard\\1776-first-missing-positive.js", "hypo_code": "var firstMissingPositive = function(nums) {\n    let len = nums.length;\n    for(let i = 0; i < len; i++){\n        while(nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]){\n            let temp = nums[nums[i] - 1];\n            nums[nums[i] - 1] = nums[i];\n            nums[i] = temp;\n        }\n    }\n    for(let i = 0; i < len; i++){\n        if(nums[i] != i + 1){\n            return i + 1;\n        }\n    }\n    return len + 1;\n    \n};"}
{"id": "1777", "path": "output2\\js\\Hard\\1777-trapping-rain-water.js", "hypo_code": "var trap = function(height) {\n    let len = height.length;\n    let left = 0;\n    let right = len - 1;\n    let leftMax = 0;\n    let rightMax = 0;\n    let res = 0;\n    while(left < right){\n        if(height[left] < height[right]){\n            if(height[left] >= leftMax){\n                leftMax = height[left];\n            }else{\n                res += leftMax - height[left];\n            }\n            left++;\n        }else{\n            if(height[right] >= rightMax){\n                rightMax = height[right];\n            }else{\n                res += rightMax - height[right];\n            }\n            right--;\n        }\n    }\n    return res;\n    \n};"}
{"id": "1778", "path": "output2\\js\\Hard\\1778-wildcard-matching.js", "hypo_code": "var isMatch = function(s, p) {\n    let reg = new RegExp(p);\n    return reg.test(s);\n    \n};"}
{"id": "1779", "path": "output2\\js\\Hard\\1779-n-queens.js", "hypo_code": "var solveNQueens = function(n) {\n    let res = [];\n    let board = new Array(n);\n    for(let i = 0; i < n; i++){\n        board[i] = new Array(n).fill('.');\n    }\n    backtrack(board, 0, res);\n    return res;\n    \n    \n};"}
{"id": "1780", "path": "output2\\js\\Hard\\1780-n-queens-ii.js", "hypo_code": "var totalNQueens = function(n) {\n    let res = 0;\n    let board = new Array(n);\n    for(let i = 0; i < n; i++){\n        board[i] = new Array(n).fill('.');\n    }\n    backtrack(board, 0, res);\n    return res;\n    \n    \n};"}
{"id": "1781", "path": "output2\\js\\Hard\\1781-permutation-sequence.js", "hypo_code": "var getPermutation = function(n, k) {\n    let arr = [];\n    let result = \"\";\n    for(let i = 1; i <= n; i++){\n        arr.push(i);\n    }\n    let fact = 1;\n    for(let i = 1; i <= n; i++){\n        fact = fact * i;\n    }\n    k = k - 1;\n    for(let i = 0; i < n; i++){\n        fact = fact / (n - i);\n        let index = Math.floor(k / fact);\n        result = result + arr[index];\n        arr.splice(index, 1);\n        k = k % fact;\n    }\n    return result;\n    \n};"}
{"id": "1782", "path": "output2\\js\\Hard\\1782-valid-number.js", "hypo_code": "var isNumber = function(s) {\n    if(s.length == 0) return false;\n    let i = 0;\n    let n = s.length;\n    while(i < n && s[i] == ' '){\n        i++;\n    }\n    if(i < n && (s[i] == '+' || s[i] == '-')){\n        i++;\n    }\n    let isNum = false;\n    while(i < n && s[i] >= '0' && s[i] <= '9'){\n        i++;\n        isNum = true;\n    }\n    if(i < n && s[i] == '.'){\n        i++;\n        while(i < n && s[i] >= '0' && s[i] <= '9'){\n            i++;\n            isNum = true;\n        }\n    }\n    if(i < n && s[i] == 'e'){\n        i++;\n        if(i < n && (s[i] == '+' || s[i] == '-')){\n            i++;\n        }\n        let isNum2 = false;\n        while(i < n && s[i] >= '0' && s[i] <= '9'){\n            i++;\n            isNum2 = true;\n        }\n        if(!isNum2) return false;\n    }\n    while(i < n && s[i] == ' '){\n        i++;\n    }\n    return isNum && i == n;\n    \n};"}
{"id": "1783", "path": "output2\\js\\Hard\\1783-text-justification.js", "hypo_code": "var fullJustify = function(words, maxWidth) {\n    let result = [];\n    let i = 0;\n    let n = words.length;\n    while(i < n){\n        let j = i + 1;\n        let len = words[i].length;\n        while(j < n && len + words[j].length + 1 <= maxWidth){\n            len = len + words[j].length + 1;\n            j++;\n        }\n        let spaces = maxWidth - len;\n        let spacesBetween = j - i - 1;\n        let spacesEach = 0;\n        let spacesExtra = 0;\n        if(spacesBetween > 0){\n            spacesEach = Math.floor(spaces / spacesBetween);\n            spacesExtra = spaces % spacesBetween;\n        }\n        let line = \"\";\n        for(let k = i; k < j; k++){\n            line = line + words[k];\n            if(k < j - 1){\n                for(let l = 0; l < spacesEach; l++){\n                    line = line + \" \";\n                }\n                if(spacesExtra > 0){\n                    line = line + \" \";\n                    spacesExtra--;\n                }\n            }\n        }\n        for(let k = line.length; k < maxWidth; k++){\n            line = line + \" \";\n        }\n        result.push(line);\n        i = j;\n    }\n    return result;\n    \n};"}
{"id": "1784", "path": "output2\\js\\Hard\\1784-minimum-window-substring.js", "hypo_code": "var minWindow = function(s, t) {\n    let map = new Map();\n    for(let i = 0; i < t.length; i++){\n        if(map.has(t[i])){\n            map.set(t[i], map.get(t[i]) + 1);\n        }else{\n            map.set(t[i], 1);\n        }\n    }\n    let count = map.size;\n    let left = 0;\n    let right = 0;\n    let min = Number.MAX_SAFE_INTEGER;\n    let result = \"\";\n    while(right < s.length){\n        if(map.has(s[right])){\n            map.set(s[right], map.get(s[right]) - 1);\n            if(map.get(s[right]) === 0){\n                count--;\n            }\n        }\n        while(count === 0){\n            if(right - left + 1 < min){\n                min = right - left + 1;\n                result = s.substring(left, right + 1);\n            }\n            if(map.has(s[left])){\n                map.set(s[left], map.get(s[left]) + 1);\n                if(map.get(s[left]) > 0){\n                    count++;\n                }\n            }\n            left++;\n        }\n        right++;\n    }\n    return result;\n    \n};"}
{"id": "1785", "path": "output2\\js\\Hard\\1785-largest-rectangle-in-histogram.js", "hypo_code": "var largestRectangleArea = function(heights) {\n    let stack = [];\n    let max = 0;\n    for(let i = 0; i <= heights.length; i++){\n        let current = i === heights.length ? -1 : heights[i];\n        while(stack.length > 0 && current <= heights[stack[stack.length - 1]]){\n            let h = heights[stack.pop()];\n            let w = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            max = Math.max(max, h * w);\n        }\n        stack.push(i);\n    }\n    return max;\n    \n};"}
{"id": "1786", "path": "output2\\js\\Hard\\1786-maximal-rectangle.js", "hypo_code": "var maximalRectangle = function(matrix) {\n    let m = matrix.length;\n    if(m === 0){\n        return 0;\n    }\n    let n = matrix[0].length;\n    let max = 0;\n    let heights = [];\n    for(let i = 0; i < n; i++){\n        heights.push(0);\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(matrix[i][j] === \"1\"){\n                heights[j] = heights[j] + 1;\n            }else{\n                heights[j] = 0;\n            }\n        }\n        max = Math.max(max, largestRectangleArea(heights));\n    }\n    return max;\n    \n    \n};"}
{"id": "1787", "path": "output2\\js\\Hard\\1787-scramble-string.js", "hypo_code": "var isScramble = function(s1, s2) {\n    let m = s1.length;\n    let n = s2.length;\n    if(m !== n){\n        return false;\n    }\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= m; k++){\n                dp[i][j].push(false);\n            }\n        }\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            dp[i][j][1] = s1[i] === s2[j];\n        }\n    }\n    for(let len = 2; len <= m; len++){\n        for(let i = 0; i <= m - len; i++){\n            for(let j = 0; j <= n - len; j++){\n                for(let k = 1; k < len; k++){\n                    if((dp[i][j][k] && dp[i + k][j + k][len - k]) || (dp[i][j + len - k][k] && dp[i + k][j][len - k])){\n                        dp[i][j][len] = true;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][0][m];\n    \n};"}
{"id": "1788", "path": "output2\\js\\Hard\\1788-distinct-subsequences.js", "hypo_code": "var numDistinct = function(s, t) {\n    let m = s.length;\n    let n = t.length;\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= m; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            if(s[i - 1] === t[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[m][n];\n    \n};"}
{"id": "1789", "path": "output2\\js\\Hard\\1789-best-time-to-buy-and-sell-stock-iii.js", "hypo_code": "var maxProfit = function(prices) {\n    let n = prices.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= 2; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= 1; k++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        for(let j = 0; j <= 2; j++){\n            dp[i][j][0] = 0;\n            dp[i][j][1] = -Infinity;\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= 2; j++){\n            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i - 1]);\n            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1]);\n        }\n    }\n    return dp[n][2][0];\n    \n};"}
{"id": "1790", "path": "output2\\js\\Hard\\1790-binary-tree-maximum-path-sum.js", "hypo_code": "var maxPathSum = function(root) {\n    let max = -Infinity;\n    let dfs = function(node){\n        if(node === null){\n            return 0;\n        }\n        let left = Math.max(dfs(node.left), 0);\n        let right = Math.max(dfs(node.right), 0);\n        max = Math.max(max, left + right + node.val);\n        return Math.max(left, right) + node.val;\n    }\n    dfs(root);\n    return max;\n    \n};"}
{"id": "1791", "path": "output2\\js\\Hard\\1791-word-ladder-ii.js", "hypo_code": "var findLadders = function(beginWord, endWord, wordList) {\n    let wordSet = new Set(wordList);\n    if(!wordSet.has(endWord)){\n        return [];\n    }\n    let ans = [];\n    let visited = new Set();\n    let queue = [[beginWord]];\n    let found = false;\n    while(queue.length > 0){\n        let size = queue.length;\n        let nextVisited = new Set();\n        for(let i = 0; i < size; i++){\n            let path = queue.shift();\n            let word = path[path.length - 1];\n            if(word === endWord){\n                ans.push(path);\n                found = true;\n            }\n            if(found){\n                continue;\n            }\n            for(let j = 0; j < word.length; j++){\n                for(let c = 'a'.charCodeAt(0); c <= 'z'.charCodeAt(0); c++){\n                    let newWord = word.slice(0, j) + String.fromCharCode(c) + word.slice(j + 1);\n                    if(wordSet.has(newWord) && !visited.has(newWord)){\n                        queue.push([...path, newWord]);\n                        nextVisited.add(newWord);\n                    }\n                }\n            }\n        }\n        visited = nextVisited;\n    }\n    return ans;\n    \n};"}
{"id": "1792", "path": "output2\\js\\Hard\\1792-word-ladder.js", "hypo_code": "var ladderLength = function(beginWord, endWord, wordList) {\n    let wordSet = new Set(wordList);\n    if(!wordSet.has(endWord)){\n        return 0;\n    }\n    let visited = new Set();\n    let queue = [[beginWord, 1]];\n    while(queue.length > 0){\n        let [word, level] = queue.shift();\n        if(word === endWord){\n            return level;\n        }\n        for(let i = 0; i < word.length; i++){\n            for(let c = 'a'.charCodeAt(0); c <= 'z'.charCodeAt(0); c++){\n                let newWord = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1);\n                if(wordSet.has(newWord) && !visited.has(newWord)){\n                    queue.push([newWord, level + 1]);\n                    visited.add(newWord);\n                }\n            }\n        }\n    }\n    return 0;\n    \n};"}
{"id": "1793", "path": "output2\\js\\Hard\\1793-palindrome-partitioning-ii.js", "hypo_code": "var minCut = function(s) {\n    let n = s.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    let cuts = [];\n    for(let i = 0; i < n; i++){\n        cuts.push(i);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <= i; j++){\n            if(s[i] === s[j] && (i - j < 2 || dp[j + 1][i - 1])){\n                dp[j][i] = true;\n                if(j === 0){\n                    cuts[i] = 0;\n                }else{\n                    cuts[i] = Math.min(cuts[i], cuts[j - 1] + 1);\n                }\n            }\n        }\n    }\n    return cuts[n - 1];\n    \n};"}
{"id": "1794", "path": "output2\\js\\Hard\\1794-candy.js", "hypo_code": "var candy = function(ratings) {\n    let n = ratings.length;\n    let left = [];\n    for(let i = 0; i < n; i++){\n        left.push(1);\n    }\n    for(let i = 1; i < n; i++){\n        if(ratings[i] > ratings[i - 1]){\n            left[i] = left[i - 1] + 1;\n        }\n    }\n    let right = [];\n    for(let i = 0; i < n; i++){\n        right.push(1);\n    }\n    for(let i = n - 2; i >= 0; i--){\n        if(ratings[i] > ratings[i + 1]){\n            right[i] = right[i + 1] + 1;\n        }\n    }\n    let sum = 0;\n    for(let i = 0; i < n; i++){\n        sum += Math.max(left[i], right[i]);\n    }\n    return sum;\n    \n};"}
{"id": "1795", "path": "output2\\js\\Hard\\1795-word-break-ii.js", "hypo_code": "var wordBreak = function(s, wordDict) {\n    let n = s.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(false);\n        }\n    }\n    let wordSet = new Set();\n    for(let word of wordDict){\n        wordSet.add(word);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <= i; j++){\n            if(wordSet.has(s.substring(j, i + 1)) && (j === 0 || dp[j - 1][i])){\n                dp[j][i] = true;\n            }\n        }\n    }\n    let result = [];\n    let path = [];\n    dfs(s, n - 1, dp, path, result);\n    return result;\n    \n    \n};"}
{"id": "1796", "path": "output2\\js\\Hard\\1796-max-points-on-a-line.js", "hypo_code": "var maxPoints = function(points) {\n    let n = points.length;\n    if(n < 3){\n        return n;\n    }\n    let max = 0;\n    for(let i = 0; i < n; i++){\n        let map = new Map();\n        let same = 1;\n        for(let j = i + 1; j < n; j++){\n            if(points[i][0] === points[j][0] && points[i][1] === points[j][1]){\n                same++;\n                continue;\n            }\n            let slope = getSlope(points[i], points[j]);\n            if(map.has(slope)){\n                map.set(slope, map.get(slope) + 1);\n            }else{\n                map.set(slope, 2);\n            }\n        }\n        let localMax = 0;\n        for(let [key, value] of map){\n            localMax = Math.max(localMax, value);\n        }\n        max = Math.max(max, localMax + same);\n    }\n    return max;\n    \n    \n};"}
{"id": "1797", "path": "output2\\js\\Hard\\1797-find-minimum-in-rotated-sorted-array-ii.js", "hypo_code": "var findMin = function(nums) {\n    let n = nums.length;\n    let left = 0;\n    let right = n - 1;\n    while(left < right){\n        let mid = Math.floor((left + right) / 2);\n        if(nums[mid] < nums[right]){\n            right = mid;\n        }else if(nums[mid] > nums[right]){\n            left = mid + 1;\n        }else{\n            right--;\n        }\n    }\n    return nums[left];\n    \n};"}
{"id": "1798", "path": "output2\\js\\Hard\\1798-maximum-gap.js", "hypo_code": "var maximumGap = function(nums) {\n    let n = nums.length;\n    if(n < 2){\n        return 0;\n    }\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    for(let i = 0; i < n; i++){\n        min = Math.min(min, nums[i]);\n        max = Math.max(max, nums[i]);\n    }\n    let bucketSize = Math.max(1, Math.floor((max - min) / (n - 1)));\n    let bucketCount = Math.floor((max - min) / bucketSize) + 1;\n    let buckets = new Array(bucketCount);\n    for(let i = 0; i < bucketCount; i++){\n        buckets[i] = new Bucket();\n    }\n    for(let i = 0; i < n; i++){\n        let index = Math.floor((nums[i] - min) / bucketSize);\n        buckets[index].min = Math.min(buckets[index].min, nums[i]);\n        buckets[index].max = Math.max(buckets[index].max, nums[i]);\n    }\n    let result = 0;\n    let prev = buckets[0].max;\n    for(let i = 1; i < bucketCount; i++){\n        if(buckets[i].min === Number.MAX_SAFE_INTEGER && buckets[i].max === Number.MIN_SAFE_INTEGER){\n            continue;\n        }\n        result = Math.max(result, buckets[i].min - prev);\n        prev = buckets[i].max;\n    }\n    return result;\n    \n    \n};"}
{"id": "1799", "path": "output2\\js\\Hard\\1799-dungeon-game.js", "hypo_code": "var calculateMinimumHP = function(dungeon) {\n    let m = dungeon.length;\n    let n = dungeon[0].length;\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(Number.MAX_SAFE_INTEGER);\n        }\n    }\n    dp[m][n - 1] = 1;\n    dp[m - 1][n] = 1;\n    for(let i = m - 1; i >= 0; i--){\n        for(let j = n - 1; j >= 0; j--){\n            let min = Math.min(dp[i + 1][j], dp[i][j + 1]);\n            dp[i][j] = Math.max(min - dungeon[i][j], 1);\n        }\n    }\n    return dp[0][0];\n    \n};"}
{"id": "1801", "path": "output2\\js\\Hard\\1801-best-time-to-buy-and-sell-stock-iv.js", "hypo_code": "var maxProfit = function(k, prices) {\n    let n = prices.length;\n    if(k >= n / 2){\n        let result = 0;\n        for(let i = 1; i < n; i++){\n            result += Math.max(0, prices[i] - prices[i - 1]);\n        }\n        return result;\n    }\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= k; j++){\n            dp[i].push([]);\n            for(let l = 0; l <= 1; l++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        for(let j = 0; j <= k; j++){\n            dp[i][j][0] = 0;\n            dp[i][j][1] = -Infinity;\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= k; j++){\n            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i - 1]);\n            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1]);\n        }\n    }\n    return dp[n][k][0];\n    \n};"}
{"id": "1802", "path": "output2\\js\\Hard\\1802-word-search-ii.js", "hypo_code": "var findWords = function(board, words) {\n    let result = [];\n    let trie = new Trie();\n    for(let i = 0; i < words.length; i++){\n        trie.insert(words[i]);\n    }\n    for(let i = 0; i < board.length; i++){\n        for(let j = 0; j < board[0].length; j++){\n            dfs(board, i, j, trie.root, result);\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1803", "path": "output2\\js\\Hard\\1803-shortest-palindrome.js", "hypo_code": "var shortestPalindrome = function(s) {\n    let n = s.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(s[i - 1] === s[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + 2;\n            }else{\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    let result = \"\";\n    let i = n;\n    let j = n;\n    while(i > 0 && j > 0){\n        if(s[i - 1] === s[j - 1]){\n            result = s[i - 1] + result;\n            i--;\n            j--;\n        }else{\n            if(dp[i - 1][j] > dp[i][j - 1]){\n                i--;\n            }else{\n                j--;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1804", "path": "output2\\js\\Hard\\1804-the-skyline-problem.js", "hypo_code": "var getSkyline = function(buildings) {\n    let n = buildings.length;\n    let points = [];\n    for(let i = 0; i < n; i++){\n        points.push([buildings[i][0], -buildings[i][2]]);\n        points.push([buildings[i][1], buildings[i][2]]);\n    }\n    points.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n    let heap = new MaxHeap();\n    heap.push(0);\n    let prev = 0;\n    let res = [];\n    for(let i = 0; i < points.length; i++){\n        let [x, y] = points[i];\n        if(y < 0){\n            heap.push(-y);\n        }else{\n            heap.remove(y);\n        }\n        let cur = heap.top();\n        if(cur != prev){\n            res.push([x, cur]);\n            prev = cur;\n        }\n    }\n    return res;\n    \n\n};"}
{"id": "1805", "path": "output2\\js\\Hard\\1805-contains-duplicate-iii.js", "hypo_code": "var containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= indexDiff; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= valueDiff; k++){\n                dp[i][j].push(false);\n            }\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= indexDiff; j++){\n            for(let k = 1; k <= valueDiff; k++){\n                if(i - j >= 0 && Math.abs(nums[i - 1] - nums[i - j - 1]) <= k){\n                    dp[i][j][k] = true;\n                }\n                else{\n                    dp[i][j][k] = dp[i - 1][j][k];\n                }\n            }\n        }\n    }\n    return dp[n][indexDiff][valueDiff];\n    \n};"}
{"id": "1806", "path": "output2\\js\\Hard\\1806-basic-calculator.js", "hypo_code": "var calculate = function(s) {\n    let stack = [];\n    let sign = 1;\n    let result = 0;\n    let i = 0;\n    while(i < s.length){\n        if(s[i] === \" \"){\n            i++;\n        }else if(s[i] === \"+\"){\n            sign = 1;\n            i++;\n        }else if(s[i] === \"-\"){\n            sign = -1;\n            i++;\n        }else if(s[i] === \"(\"){\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n            i++;\n        }else if(s[i] === \")\"){\n            result = result * stack.pop() + stack.pop();\n            i++;\n        }else{\n            let num = 0;\n            while(i < s.length && s[i] >= \"0\" && s[i] <= \"9\"){\n                num = num * 10 + s[i].charCodeAt() - \"0\".charCodeAt();\n                i++;\n            }\n            result += sign * num;\n        }\n    }\n    return result;\n    \n};"}
{"id": "1807", "path": "output2\\js\\Hard\\1807-number-of-digit-one.js", "hypo_code": "var countDigitOne = function(n) {\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= 9; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= 9; j++){\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[n][9];\n    \n};"}
{"id": "1808", "path": "output2\\js\\Hard\\1808-sliding-window-maximum.js", "hypo_code": "var maxSlidingWindow = function(nums, k) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= k; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= k; j++){\n            if(i - j >= 0){\n                dp[i][j] = Math.max(dp[i - 1][j], nums[i - 1]);\n            }\n            else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = k; i <= n; i++){\n        ans.push(dp[i][k]);\n    }\n    return ans;\n    \n};"}
{"id": "1810", "path": "output2\\js\\Hard\\1810-integer-to-english-words.js", "hypo_code": "var numberToWords = function(num) {\n    var numStr = num.toString();\n    var numStrLen = numStr.length;\n    var result = \"\";\n    var billion = \"\";\n    var million = \"\";\n    var thousand = \"\";\n    var hundred = \"\";\n    var tens = \"\";\n    var ones = \"\";\n    var numStrIndex = 0;\n    var numStrIndexMax = 0;\n    var numStrIndexMin = 0;\n    var numStrIndexHundred = 0;\n    var numStrIndexThousand = 0;\n    var numStrIndexMillion = 0;\n    var numStrIndexBillion = 0;\n    var numStrIndexHundredMax = 0;\n    var numStrIndexThousandMax = 0;\n    var numStrIndexMillionMax = 0;\n    var numStrIndexBillionMax = 0;\n    var numStrIndexHundreds = 0;\n    var numStrIndexTens = 0;\n    var numStrIndexOnes = 0;\n    var numStrIndexTensMax = 0;\n    var numStrIndexOnesMax = 0;\n    var numStrIndexHundredsMax = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    if (numStrLen > 9) {\n        numStrIndexBillion = numStrLen - 9;\n        numStrIndexBillionMax = numStrIndexBillion + 3;\n        billion = numStr.substring(numStrIndexBillion, numStrIndexBillionMax);\n        billion = convertHundreds(billion);\n        billion += \" Billion \";\n    }\n    if (numStrLen > 6) {\n        numStrIndexMillion = numStrLen - 6;\n        numStrIndexMillionMax = numStrIndexMillion + 3;\n        million = numStr.substring(numStrIndexMillion, numStrIndexMillionMax);\n        million = convertHundreds(million);\n        million += \" Million \";\n    }\n    if (numStrLen > 3) {\n        numStrIndexThousand = numStrLen - 3;\n        numStrIndexThousandMax = numStrIndexThousand + 3;\n        thousand = numStr.substring(numStrIndexThousand, numStrIndexThousandMax);\n        thousand = convertHundreds(thousand);\n        thousand += \" Thousand \";\n    }\n    numStrIndex = numStrIndexMax;\n    numStrIndexMax = numStrIndex + 3;\n    hundred = numStr.substring(numStrIndex, numStrIndexMax);\n    hundred = convertHundreds(hundred);\n    result = billion + million + thousand + hundred;\n    return result;\n};"}
{"id": "1811", "path": "output2\\js\\Hard\\1811-expression-add-operators.js", "hypo_code": "var addOperators = function(num, target) { \n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n\n    if (numStrLen === 1) {\n        return numStr === target ? numStr : \"\";\n    } else {\n        for (var i = 0; i < numStrLen; i++) {\n            var numStr = num.substring(0, i) + \"+\" + num.substring(i);\n            if (numStr === target) {\n                return numStr;\n            }\n        }\n        for (var i = 0; i < numStrLen; i++) {\n            var numStr = num.substring(0, i) + \"-\" + num.substring(i);\n            if (numStr === target) {\n                return numStr\n            }\n        }\n    }\n    return numStr;\n};"}
{"id": "1814", "path": "output2\\js\\Hard\\1814-remove-invalid-parentheses.js", "hypo_code": "var removeInvalidParentheses = function(s) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    \n};"}
{"id": "1815", "path": "output2\\js\\Hard\\1815-burst-balloons.js", "hypo_code": "var maxCoins = function(nums) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(i - j >= 0){\n                let left = 1;\n                let right = 1;\n                if(i - j - 1 >= 0){\n                    left = nums[i - j - 1];\n                }\n                if(i < n){\n                    right = nums[i];\n                }\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + left * nums[i - j] * right);\n            }\n            else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[n][n];\n    \n};"}
{"id": "1816", "path": "output2\\js\\Hard\\1816-count-of-smaller-numbers-after-self.js", "hypo_code": "var countSmaller = function(nums) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(nums[i - 1] > nums[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][i] - dp[n][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1817", "path": "output2\\js\\Hard\\1817-create-maximum-number.js", "hypo_code": "var maxNumber = function(nums1, nums2, k) {\n    let m = nums1.length;\n    let n = nums2.length;\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= k; k++){\n                dp[i][j].push([]);\n                for(let l = 0; l <= k; l++){\n                    dp[i][j][k].push(0);\n                }\n            }\n        }\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            for(let k = 1; k <= k; k++){\n                for(let l = 1; l <= k; l++){\n                    if(i - j >= 0 && Math.abs(nums1[i - 1] - nums1[i - j - 1]) <= k){\n                        dp[i][j][k][l] = true;\n                    }\n                    else{\n                        dp[i][j][k][l] = dp[i - 1][j][k][l];\n                    }\n                }\n            }\n        }\n    }\n    return dp[m][n][k][k];\n    \n};"}
{"id": "1818", "path": "output2\\js\\Hard\\1818-count-of-range-sum.js", "hypo_code": "var countRangeSum = function(nums, lower, upper) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(nums[i - 1] > nums[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][i] - dp[n][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1819", "path": "output2\\js\\Hard\\1819-longest-increasing-path-in-a-matrix.js", "hypo_code": "var longestIncreasingPath = function(matrix) {\n    let n = matrix.length;\n    let m = matrix[0].length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= m; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            if(matrix[i - 1][j - 1] > matrix[i - 1][j]){\n                dp[i][j] = dp[i - 1][j] + 1;\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = 0;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            ans = Math.max(ans, dp[i][j]);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1820", "path": "output2\\js\\Hard\\1820-patching-array.js", "hypo_code": "var minPatches = function(nums, n) {\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(nums[i - 1] > nums[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][i] - dp[n][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1821", "path": "output2\\js\\Hard\\1821-reconstruct-itinerary.js", "hypo_code": "var findItinerary = function(tickets) {\n    let n = tickets.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= n; k++){\n                dp[i][j].push([]);\n                for(let l = 0; l <= n; l++){\n                    dp[i][j][k].push(0);\n                }\n            }\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        for(let j = 0; j <= n; j++){\n            for(let k = 0; k <= n; k++){\n                dp[i][j][k][0] = 0;\n                dp[i][j][k][1] = -Infinity;\n            }\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            for(let k = 1; k <= n; k++){\n                dp[i][j][k][0] = Math.max(dp[i - 1][j][k][0], dp[i - 1][j][k][1] + tickets[i - 1][0]);\n                dp[i][j][k][1] = Math.max(dp[i - 1][j][k][1], dp[i - 1][j - 1][k][0] - tickets[i - 1][0]);\n            }\n        }\n    }\n    return dp[n][n][n][0];\n    \n    \n};"}
{"id": "1822", "path": "output2\\js\\Hard\\1822-self-crossing.js", "hypo_code": "var isSelfCrossing = function(distance) {\n    let n = distance.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= 3; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= 3; k++){\n                dp[i][j].push(false);\n            }\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= 3; j++){\n            for(let k = 1; k <= 3; k++){\n                if(i - j >= 0 && k === 1 && dp[i - j][k][3]){\n                    dp[i][j][k] = true;\n                }\n                else if(i - j >= 0 && k === 2 && dp[i - j][k][1]){\n                    dp[i][j][k] = true;\n                }\n                else if(i - j >= 0 && k === 3 && dp[i - j][k][2]){\n                    dp[i][j][k] = true;\n                }\n                else if(i - j >= 0 && k === 1 && dp[i - j][k][2] && distance[i - 1] >= distance[i - j - 1]){\n                    dp[i][j][k] = true;\n                }\n                else if(i - j >= 0 && k === 2 && dp[i - j][k][3] && distance[i - 1] >= distance[i - j - 1]){\n                    dp[i][j][k] = true;\n                }\n                else if(i - j >= 0 && k === 3 && dp[i - j][k][1] && distance[i - 1] >= distance[i - j - 1]){\n                    dp[i][j][k] = true;\n                }\n                else if(i - j >= 0 && k === 1 && dp[i - j][k][1] && distance[i - 1] >= distance[i - j - 1] && dp[i - j][k][2] && distance[i - 1] >= distance[i - j - 1]){\n                    dp[i][j][k] = true;\n                }\n                else if(i - j >= 0 && k === 2 && dp[i - j][k][2] && distance [i - 1] >= distance[i - j - 1] && dp[i - j][k][3] && distance[i - 1] >= distance[i - j - 1]){\n                    dp[i][j][k] = true;\n                }\n                else if(i - j >= 0 && k === 3 && dp[i - j][k][3] && distance[i - 1] >= distance[i - j - 1] && dp[i - j][k][1] && distance[i - 1] >= distance[i - j - 1]){\n\n                    dp[i][j][k] = true;\n                }\n                else{\n                    dp[i][j][k] = dp[i - 1][j][k];\n                }\n\n            }\n        }\n    }\n    return dp[n][3][3];\n    \n};"}
{"id": "1823", "path": "output2\\js\\Hard\\1823-palindrome-pairs.js", "hypo_code": "var palindromePairs = function(words) {\n    let n = words.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(false);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(i !== j){\n                dp[i][j] = isPalindrome(words[i - 1] + words[j - 1]);\n            }\n        }\n    }\n    let result = [];\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(dp[i][j]){\n                result.push([i - 1, j - 1]);\n            }\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1825", "path": "output2\\js\\Hard\\1825-russian-doll-envelopes.js", "hypo_code": "var maxEnvelopes = function(envelopes) {\n    let n = envelopes.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push(1);\n    }\n    envelopes.sort((a, b) => a[0] - b[0]);\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j < i; j++){\n            if(envelopes[i - 1][0] > envelopes[j - 1][0] && envelopes[i - 1][1] > envelopes[j - 1][1]){\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    let result = 0;\n    for(let i = 1; i <= n; i++){\n        result = Math.max(result, dp[i]);\n    }\n    return result;\n    \n};"}
{"id": "1826", "path": "output2\\js\\Hard\\1826-max-sum-of-rectangle-no-larger-than-k.js", "hypo_code": "var maxSumSubmatrix = function(matrix, k) {\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let result = -Infinity;\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            let dp = [];\n            for(let a = 0; a <= m; a++){\n                dp.push([]);\n                for(let b = 0; b <= n; b++){\n                    dp[a].push(0);\n                }\n            }\n            for(let a = 1; a <= m; a++){\n                for(let b = 1; b <= n; b++){\n                    dp[a][b] = dp[a - 1][b] + dp[a][b - 1] - dp[a - 1][b - 1] + matrix[a - 1][b - 1];\n                }\n            }\n            for(let a = i; a <= m; a++){\n                for(let b = j; b <= n; b++){\n                    let sum = dp[a][b] - dp[a - i][b] - dp[a][b - j] + dp[a - i][b - j];\n                    if(sum <= k){\n                        result = Math.max(result, sum);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1828", "path": "output2\\js\\Hard\\1828-perfect-rectangle.js", "hypo_code": "var isRectangleCover = function(rectangles) {\n    let n = rectangles.length;\n    let minx = Infinity;\n    let miny = Infinity;\n    let maxx = -Infinity;\n    let maxy = -Infinity;\n    let area = 0;\n    let set = new Set();\n    for(let i = 0; i < n; i++){\n        let [x1, y1, x2, y2] = rectangles[i];\n        minx = Math.min(minx, x1);\n        miny = Math.min(miny, y1);\n        maxx = Math.max(maxx, x2);\n        maxy = Math.max(maxy, y2);\n        area += (x2 - x1) * (y2 - y1);\n        let s1 = x1 + \",\" + y1;\n        let s2 = x1 + \",\" + y2;\n        let s3 = x2 + \",\" + y1;\n        let s4 = x2 + \",\" + y2;\n        if(set.has(s1)){\n            set.delete(s1);\n        }else{\n            set.add(s1);\n        }\n        if(set.has(s2)){\n            set.delete(s2);\n        }else{\n            set.add(s2);\n        }\n        if(set.has(s3)){\n            set.delete(s3);\n        }else{\n            set.add(s3);\n        }\n        if(set.has(s4)){\n            set.delete(s4);\n        }else{\n            set.add(s4);\n        }\n    }\n    if(set.size !== 4){\n        return false;\n    }\n    if(!set.has(minx + \",\" + miny) || !set.has(minx + \",\" + maxy) || !set.has(maxx + \",\" + miny) || !set.has(maxx + \",\" + maxy)){\n        return false;\n    }\n    return area === (maxx - minx) * (maxy - miny);\n    \n};"}
{"id": "1829", "path": "output2\\js\\Hard\\1829-frog-jump.js", "hypo_code": "var canCross = function(stones) {\n    let n = stones.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(false);\n        }\n    }\n    dp[0][0] = true;\n    for(let i = 1; i < n; i++){\n        if(stones[i] - stones[i - 1] > i){\n            return false;\n        }\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            let k = stones[i] - stones[j];\n            if(k > j + 1){\n                break;\n            }\n            dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];\n            if(i == n - 1 && dp[i][k]){\n                return true;\n            }\n        }\n    }\n    return false;\n    \n};"}
{"id": "1830", "path": "output2\\js\\Hard\\1830-trapping-rain-water-ii.js", "hypo_code": "var trapRainWater = function(heightMap) {\n    let m = heightMap.length;\n    let n = heightMap[0].length;\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + heightMap[i - 1][j - 1];\n        }\n    }\n    let result = 0;\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            for(let a = 1; a <= m; a++){\n                for(let b = 1; b <= n; b++){\n                    let sum = dp[a][b] - dp[a - i][b] - dp[a][b - j] + dp[a - i][b - j];\n                    if(sum <= k){\n                        result = Math.max(result, sum);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "1831", "path": "output2\\js\\Hard\\1831-split-array-largest-sum.js", "hypo_code": "var splitArray = function(nums, k) {\n    let dp = [];\n    for(let i = 0; i <= nums.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= k; j++){\n            dp[i].push([]);\n            for(let l = 0; l <= nums.length; l++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    for(let i = 0; i <= nums.length; i++){\n        dp[i][0][0] = 1;\n    }\n    for(let i = 1; i <= nums.length; i++){\n        for(let j = 1; j <= k; j++){\n            for(let l = 1; l <= nums.length; l++){\n                if(nums[i - 1] > nums[l - 1]){\n                    dp[i][j][l] = dp[i - 1][j - 1][l - 1] + dp[i - 1][j][l];\n                }else{\n                    dp[i][j][l] = dp[i - 1][j][l];\n                }\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= nums.length; i++){\n        ans.push(dp[nums.length][k][i] - dp[nums.length][k][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1832", "path": "output2\\js\\Hard\\1832-strong-password-checker.js", "hypo_code": "var strongPasswordChecker = function(password) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1834", "path": "output2\\js\\Hard\\1834-k-th-smallest-in-lexicographical-order.js", "hypo_code": "var findKthNumber = function(n, k) {\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][i] - dp[n][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1835", "path": "output2\\js\\Hard\\1835-arithmetic-slices-ii-subsequence.js", "hypo_code": "var numberOfArithmeticSlices = function(nums) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push(new Map());\n    }\n    let ans = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < i; j++){\n            let diff = nums[i] - nums[j];\n            let cnt = dp[j].get(diff) || 0;\n            ans += cnt;\n            dp[i].set(diff, (dp[i].get(diff) || 0) + cnt + 1);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1836", "path": "output2\\js\\Hard\\1836-poor-pigs.js", "hypo_code": "var poorPigs = function(buckets, minutesToDie, minutesToTest) {\n    let states = Math.floor(minutesToTest / minutesToDie) + 1;\n    return Math.ceil(Math.log(buckets) / Math.log(states));\n    \n};"}
{"id": "1838", "path": "output2\\js\\Hard\\1838-count-the-repetitions.js", "hypo_code": "var getMaxRepetitions = function(s1, n1, s2, n2) {\n    var numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n};"}
{"id": "1839", "path": "output2\\js\\Hard\\1839-concatenated-words.js", "hypo_code": "var findAllConcatenatedWordsInADict = function(words) {\n    let n = words.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(false);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(i !== j){\n                dp[i][j] = isConcatenated(words[i - 1], words[j - 1]);\n            }\n        }\n    }\n    let result = [];\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(dp[i][j]){\n                result.push(words[i - 1]);\n            }\n        }\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "1840", "path": "output2\\js\\Hard\\1840-largest-palindrome-product.js", "hypo_code": "var largestPalindrome = function(n) {\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][i] - dp[n][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1841", "path": "output2\\js\\Hard\\1841-sliding-window-median.js", "hypo_code": "var medianSlidingWindow = function(nums, k) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= k; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= k; j++){\n            if(i - j >= 0){\n                dp[i][j] = Math.max(dp[i - 1][j], nums[i - 1]);\n            }\n            else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = k; i <= n; i++){\n        ans.push(dp[i][k]);\n    }\n    return ans;\n    \n};"}
{"id": "1842", "path": "output2\\js\\Hard\\1842-smallest-good-base.js", "hypo_code": "var smallestGoodBase = function(n) {\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][i] - dp[n][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1843", "path": "output2\\js\\Hard\\1843-zuma-game.js", "hypo_code": "var findMinStep = function(board, hand) {\n    let n = board.length;\n    let m = hand.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push([]);\n            for(let k = 0; k < m; k++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    let ans = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            for(let k = 0; k < m; k++){\n                if(i === j){\n                    if(board[i] === hand[k]){\n                        dp[i][j][k] = 1;\n                    }\n                }else{\n                    if(board[i] === hand[k]){\n                        dp[i][j][k] = dp[i + 1][j][k] + 1;\n                    }else if(board[j] === hand[k]){\n                        dp[i][j][k] = dp[i][j - 1][k] + 1;\n                    }else{\n                        dp[i][j][k] = Math.max(dp[i + 1][j][k], dp[i][j - 1][k]);\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1844", "path": "output2\\js\\Hard\\1844-reverse-pairs.js", "hypo_code": "var reversePairs = function(nums) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1845", "path": "output2\\js\\Hard\\1845-ipo.js", "hypo_code": "var findMaximizedCapital = function(k, w, profits, capital) {\n    let n = profits.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= k; j++){\n            dp[i].push([]);\n            for(let l = 0; l <= k; l++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= k; j++){\n            for(let l = 1; l <= k; l++){\n                if(i - j >= 0 && Math.abs(profits[i - 1] - profits[i - j - 1]) <= k){\n                    dp[i][j][l] = true;\n                }\n                else{\n                    dp[i][j][l] = dp[i - 1][j][l];\n                }\n            }\n        }\n    }\n    return dp[n][k][k];\n    \n};"}
{"id": "1846", "path": "output2\\js\\Hard\\1846-freedom-trail.js", "hypo_code": "var findRotateSteps = function(ring, key) {\n    let m = ring.length;\n    let n = key.length;\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i < m; i++){\n        dp[i][n] = 0;\n    }\n    for(let j = n - 1; j >= 0; j--){\n        for(let i = 0; i < m; i++){\n            dp[i][j] = Number.MAX_VALUE;\n            for(let k = 0; k < m; k++){\n                if(ring[k] === key[j]){\n                    let diff = Math.abs(i - k);\n                    let step = Math.min(diff, m - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[k][j + 1]);\n                }\n            }\n        }\n    }\n    return dp[0][0] + n;\n    \n    \n};"}
{"id": "1847", "path": "output2\\js\\Hard\\1847-super-washing-machines.js", "hypo_code": "var findMinMoves = function(machines) {\n    let n = machines.length;\n    let sum = 0;\n    for(let i = 0; i < n; i++){\n        sum += machines[i];\n    }\n    if(sum % n != 0){\n        return -1;\n    }\n    let avg = sum / n;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(machines[i - 1] > machines[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = 0;\n    for(let i = 1; i <= n; i++){\n        ans += dp[n][i] * Math.abs(avg - machines[i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1848", "path": "output2\\js\\Hard\\1848-remove-boxes.js", "hypo_code": "var removeBoxes = function(boxes) {\n    let n = boxes.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= n; k++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            for(let k = 1; k <= n; k++){\n                if(i - j >= 0 && boxes[i - 1] == boxes[i - j - 1]){\n                    dp[i][j][k] = dp[i - 1][j][k + 1];\n                }\n                else{\n                    dp[i][j][k] = dp[i - 1][j][k] + k * k;\n                }\n            }\n        }\n    }\n    return dp[n][n][1];\n    \n};"}
{"id": "1849", "path": "output2\\js\\Hard\\1849-student-attendance-record-ii.js", "hypo_code": "var checkRecord = function(n) {\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= 2; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= 3; k++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    dp[0][0][0] = 1;\n    for(let i = 1; i <= n; i++){\n        for(let j = 0; j <= 2; j++){\n            for(let k = 0; k <= 3; k++){\n                dp[i][j][0] += dp[i - 1][j][k];\n                if(j < 2){\n                    dp[i][j + 1][0] += dp[i - 1][j][k];\n                }\n                if(k < 3){\n                    dp[i][j][k + 1] += dp[i - 1][j][k];\n                }\n            }\n        }\n    }\n    let ans = 0;\n    for(let j = 0; j <= 2; j++){\n        for(let k = 0; k <= 3; k++){\n            ans += dp[n][j][k];\n        }\n    }\n    return ans % 1000000007;\n    \n    \n};"}
{"id": "1850", "path": "output2\\js\\Hard\\1850-find-the-closest-palindrome.js", "hypo_code": "var nearestPalindromic = function(n) {\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][i] - dp[n][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1851", "path": "output2\\js\\Hard\\1851-erect-the-fence.js", "hypo_code": "var outerTrees = function(trees) {\n    var numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n};"}
{"id": "1852", "path": "output2\\js\\Hard\\1852-tag-validator.js", "hypo_code": "var isValid = function(code) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1853", "path": "output2\\js\\Hard\\1853-non-negative-integers-without-consecutive-ones.js", "hypo_code": "var findIntegers = function(n) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1855", "path": "output2\\js\\Hard\\1855-k-inverse-pairs-array.js", "hypo_code": "var kInversePairs = function(n, k) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1856", "path": "output2\\js\\Hard\\1856-course-schedule-iii.js", "hypo_code": "var scheduleCourse = function(courses) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1857", "path": "output2\\js\\Hard\\1857-smallest-range-covering-elements-from-k-lists.js", "hypo_code": "var smallestRange = function(nums) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1858", "path": "output2\\js\\Hard\\1858-decode-ways-ii.js", "hypo_code": "var numDecodings = function(s) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1859", "path": "output2\\js\\Hard\\1859-strange-printer.js", "hypo_code": "var strangePrinter = function(s) {\n    let n = s.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n};"}
{"id": "1860", "path": "output2\\js\\Hard\\1860-kth-smallest-number-in-multiplication-table.js", "hypo_code": "var findKthNumber = function(m, n, k) {\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= m; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= m; i++){\n        ans.push(dp[m][i] - dp[m][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1861", "path": "output2\\js\\Hard\\1861-cut-off-trees-for-golf-event.js", "hypo_code": "var cutOffTree = function(forest) {\n    let m = forest.length;\n    let n = forest[0].length;\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= m; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            if(forest[i - 1][j - 1] > forest[i - 1][j]){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = 0;\n    for(let i = 1; i <= m; i++){\n        ans += dp[m][i];\n    }\n    return ans;\n    \n};"}
{"id": "1862", "path": "output2\\js\\Hard\\1862-24-game.js", "hypo_code": "var judgePoint24 = function(cards) {\n    let n = cards.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= n; k++){\n                dp[i][j].push([]);\n                for(let l = 0; l <= n; l++){\n                    dp[i][j][k].push(false);\n                }\n            }\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            for(let k = 1; k <= n; k++){\n                for(let l = 1; l <= n; l++){\n                    if(i + j + k + l == n + 1){\n                        dp[i][j][k][l] = check(cards[i - 1], cards[j - 1], cards[k - 1], cards[l - 1]);\n                    }\n                    else{\n                        dp[i][j][k][l] = dp[i - 1][j][k][l] || dp[i][j - 1][k][l] || dp[i][j][k - 1][l] || dp[i][j][k][l - 1];\n                    }\n                }\n            }\n        }\n    }\n    return dp[n][n][n][n];\n    \n    \n};"}
{"id": "1863", "path": "output2\\js\\Hard\\1863-redundant-connection-ii.js", "hypo_code": "var findRedundantDirectedConnection = function(edges) {\n    let n = edges.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= k; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= k; j++){\n            if(i - j >= 0){\n                dp[i][j] = Math.max(dp[i - 1][j], nums[i - 1]);\n            }\n            else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = k; i <= n; i++){\n        ans.push(dp[i][k]);\n    }\n    return ans;\n    \n};"}
{"id": "1864", "path": "output2\\js\\Hard\\1864-maximum-sum-of-3-non-overlapping-subarrays.js", "hypo_code": "var maxSumOfThreeSubarrays = function(nums, k) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= 3; j++){\n            dp[i].push([]);\n            for(let l = 0; l <= n; l++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= 3; j++){\n            for(let l = 1; l <= n; l++){\n                if(nums[i - 1] > nums[l - 1]){\n                    dp[i][j][l] = dp[i - 1][j - 1][l - 1] + dp[i - 1][j][l];\n                }else{\n                    dp[i][j][l] = dp[i - 1][j][l];\n                }\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[nums.length][3][i] - dp[nums.length][3][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1865", "path": "output2\\js\\Hard\\1865-stickers-to-spell-word.js", "hypo_code": "var minStickers = function(stickers, target) {\n    let n = target.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n};"}
{"id": "1866", "path": "output2\\js\\Hard\\1866-falling-squares.js", "hypo_code": "var fallingSquares = function(positions) {\n    let n = positions.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n    \n};"}
{"id": "1869", "path": "output2\\js\\Hard\\1869-find-k-th-smallest-pair-distance.js", "hypo_code": "var smallestDistancePair = function(nums, k) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1870", "path": "output2\\js\\Hard\\1870-number-of-atoms.js", "hypo_code": "var countOfAtoms = function(formula) {\n    var numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n\tvar numStrIndexOnesMin = 0;\n\tvar numStrIndexHundredsMin = 0;\n\tvar numStrIndexTensMin = 0;\n};"}
{"id": "1871", "path": "output2\\js\\Hard\\1871-count-different-palindromic-subsequences.js", "hypo_code": "var countPalindromicSubsequences = function(s) {\n    let n = s.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n\n};"}
{"id": "1873", "path": "output2\\js\\Hard\\1873-parse-lisp-expression.js", "hypo_code": "var evaluate = function(expression) {\n    let stack = [];\n    let i = 0;\n    while(i < expression.length){\n        if(expression[i] === '('){\n            let j = i + 1;\n            while(expression[j] !== ' '){\n                j++;\n            }\n            let op = expression.substring(i + 1, j);\n            if(op === 'let'){\n                stack.push({op: op, vars: {}, expr: []});\n            }else{\n                stack.push({op: op, expr: []});\n            }\n            i = j + 1;\n        }else if(expression[i] === ')'){\n            let top = stack.pop();\n            if(top.op === 'let'){\n                let vars = top.vars;\n                let expr = top.expr;\n                let val = evaluateExpr(expr, vars);\n                stack[stack.length - 1].vars[expr[0]] = val;\n            }else{\n                let expr = top.expr;\n                let val = evaluateExpr(expr, stack[stack.length - 1].vars);\n                if(stack.length === 0){\n                    return val;\n                }\n                stack[stack.length - 1].expr.push(val);\n            }\n            i++;\n        }else{\n            let j = i + 1;\n            while(j < expression.length && expression[j] !== ' ' && expression[j] !== ')'){\n                j++;\n            }\n            let expr = expression.substring(i, j);\n            if(stack.length === 0){\n                return parseInt(expr);\n            }\n            stack[stack.length - 1].expr.push(expr);\n            i = j;\n        }\n    }\n    return evaluateExpr(stack[0].expr, stack[0].vars);\n    \n};"}
{"id": "1874", "path": "output2\\js\\Hard\\1874-cherry-pickup.js", "hypo_code": "var cherryPickup = function(grid) {\n    let n = grid.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= n; k++){\n                dp[i][j].push([]);\n                for(let l = 0; l <= n; l++){\n                    dp[i][j][k].push(0);\n                }\n            }\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i][i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j][i][j] = dp[i - 1][j][i - 1][j];\n            }else{\n                dp[i][j][i][j] = Math.min(dp[i - 1][j][i - 1][j], dp[i][j + 1][i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0][n][0];\n    \n};"}
{"id": "1876", "path": "output2\\js\\Hard\\1876-contain-virus.js", "hypo_code": "var containVirus = function(isInfected) {\n    let m = isInfected.length;\n    let n = isInfected[0].length;\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= m; k++){\n                dp[i][j].push([]);\n                for(let l = 0; l <= n; l++){\n                    dp[i][j][k].push(0);\n                }\n            }\n        }\n    }\n    for(let i = 0; i <= m; i++){\n        dp[i][i][i][i] = 1;\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j][i][j] = dp[i - 1][j][i - 1][j];\n            }else{\n                dp[i][j][i][j] = Math.min(dp[i - 1][j][i - 1][j], dp[i][j + 1][i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[m][0][m][0];\n    \n};"}
{"id": "1877", "path": "output2\\js\\Hard\\1877-cracking-the-safe.js", "hypo_code": "var crackSafe = function(n, k) {\n    let total = Math.pow(k, n);\n    let visited = new Set();\n    let result = [];\n    for(let i = 0; i < n; i++){\n        result.push(0);\n    }\n    let start = result.join(\"\");\n    visited.add(start);\n    dfs(start, total, visited, result, k);\n    return result.join(\"\");\n    \n    \n};"}
{"id": "1878", "path": "output2\\js\\Hard\\1878-set-intersection-size-at-least-two.js", "hypo_code": "var intersectionSizeTwo = function(intervals) {\n    let n = intervals.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n    \n};"}
{"id": "1879", "path": "output2\\js\\Hard\\1879-special-binary-string.js", "hypo_code": "var makeLargestSpecial = function(s) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1880", "path": "output2\\js\\Hard\\1880-couples-holding-hands.js", "hypo_code": "var minSwapsCouples = function(row) {\n    let n = row.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n};"}
{"id": "1881", "path": "output2\\js\\Hard\\1881-max-chunks-to-make-sorted-ii.js", "hypo_code": "var maxChunksToSorted = function(arr) {\n    let n = arr.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(arr[i - 1] > arr[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][i] - dp[n][i - 1]);\n    }\n    return ans;\n    \n};;"}
{"id": "1882", "path": "output2\\js\\Hard\\1882-basic-calculator-iv.js", "hypo_code": "var basicCalculatorIV = function(expression, evalvars, evalints) {\n    let n = expression.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n};"}
{"id": "1883", "path": "output2\\js\\Hard\\1883-sliding-puzzle.js", "hypo_code": "var slidingPuzzle = function(board) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1884", "path": "output2\\js\\Hard\\1884-swim-in-rising-water.js", "hypo_code": "var swimInWater = function(grid) {\n    let n = grid.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i < n; i++){\n        if(grid[i][0] >= grid[i - 1][0]){\n            dp[i][0] = dp[i - 1][0];\n        }\n        if(grid[0][i] >= grid[0][i - 1]){\n            dp[0][i] = dp[0][i - 1];\n        }\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            if(grid[i][j] >= grid[i - 1][j] && grid[i][j] >= grid[i][j - 1]){\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }else if(grid[i][j] >= grid[i - 1][j]){\n                dp[i][j] = dp[i - 1][j];\n            }else if(grid[i][j] >= grid[i][j - 1]){\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    return dp[n - 1][n - 1];\n    \n};"}
{"id": "1885", "path": "output2\\js\\Hard\\1885-reaching-points.js", "hypo_code": "var reachingPoints = function(sx, sy, tx, ty) {\n    while(tx >= sx && ty >= sy){\n        if(tx == sx && ty == sy){\n            return true;\n        }\n        if(tx > ty){\n            tx -= ty;\n        }else{\n            ty -= tx;\n        }\n    }\n    return false;\n    \n};"}
{"id": "1886", "path": "output2\\js\\Hard\\1886-transform-to-chessboard.js", "hypo_code": "var movesToChessboard = function(board) {\n    let n = board.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i < n; i++){\n        if(board[i][0] >= board[i - 1][0]){\n            dp[i][0] = dp[i - 1][0];\n        }\n        if(board[0][i] >= board[0][i - 1]){\n            dp[0][i] = dp[0][i - 1];\n        }\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            if(board[i][j] >= board[i - 1][j] && board[i][j] >= board[i][j - 1]){\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }else if(board[i][j] >= board[i - 1][j]){\n                dp[i][j] = dp[i - 1][j];\n            }else if(board[i][j] >= board[i][j - 1]){\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    return dp[n - 1][n - 1];\n    \n};"}
{"id": "1887", "path": "output2\\js\\Hard\\1887-preimage-size-of-factorial-zeroes-function.js", "hypo_code": "var preimageSizeFZF = function(k) {\n    let low = 0;\n    let high = 5 * (k + 1);\n    while(low < high){\n        let mid = Math.floor((low + high) / 2);\n        let count = countZero(mid);\n        if(count == k){\n            return 5;\n        }else if(count < k){\n            low = mid + 1;\n        }else{\n            high = mid;\n        }\n    }\n    return 0;\n    \n    \n};"}
{"id": "1888", "path": "output2\\js\\Hard\\1888-smallest-rotation-with-highest-score.js", "hypo_code": "var bestRotation = function(nums) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push(0);\n    }\n    for(let i = 0; i < n; i++){\n        let left = (i - nums[i] + 1 + n) % n;\n        let right = (i + 1) % n;\n        dp[left]++;\n        if(left > right){\n            dp[0]++;\n        }\n        dp[right]--;\n    }\n    let max = dp[0];\n    let index = 0;\n    for(let i = 1; i < n; i++){\n        dp[i] += dp[i - 1];\n        if(dp[i] > max){\n            max = dp[i];\n            index = i;\n        }\n    }\n    return index;\n    \n};"}
{"id": "1889", "path": "output2\\js\\Hard\\1889-minimum-swaps-to-make-sequences-increasing.js", "hypo_code": "var minSwap = function(nums1, nums2) {\n    let n = nums1.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < 2; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = 0;\n    dp[0][1] = 1;\n    for(let i = 1; i < n; i++){\n        if(nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]){\n            dp[i][0] = dp[i - 1][0];\n            dp[i][1] = dp[i - 1][1] + 1;\n        }\n        if(nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]){\n            dp[i][0] = Math.min(dp[i][0], dp[i - 1][1]);\n            dp[i][1] = Math.min(dp[i][1], dp[i - 1][0] + 1);\n        }\n    }\n    return Math.min(dp[n - 1][0], dp[n - 1][1]);\n    \n};"}
{"id": "1890", "path": "output2\\js\\Hard\\1890-bricks-falling-when-hit.js", "hypo_code": "var hitBricks = function(grid, hits) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const uf = new UnionFind(m * n + 1);\n    const hitsSet = new Set();\n    const result = new Array(hits.length).fill(0);\n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let count = 0;\n    \n    for (let i = 0; i < hits.length; i++) {\n        hitsSet.add(hits[i][0] * n + hits[i][1]);\n    }\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1 && !hitsSet.has(i * n + j)) {\n                if (i === 0) {\n                    uf.union(i * n + j, m * n);\n                }\n                if (i > 0 && grid[i - 1][j] === 1) {\n                    uf.union(i * n + j, (i - 1) * n + j);\n                }\n                if (j > 0 && grid[i][j - 1] === 1) {\n                    uf.union(i * n + j, i * n + j - 1);\n                }\n            }\n        }\n    }\n    \n    for (let i = hits.length - 1; i >= 0; i--) {\n        const x = hits[i][0];\n        const y = hits[i][1];\n        if (grid[x][y] === 0) {\n            continue;\n        }\n        const prevCount = uf.getSize(m * n);\n        if (x === 0) {\n            uf.union(x * n + y, m * n);\n        }\n        for (let j = 0; j < 4; j++) {\n            const newX = x + directions[j][0];\n            const newY = y + directions[j][1];\n            if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] === 1) {\n                uf.union(x * n + y, newX * n + newY);\n            }\n        }\n        const currentCount = uf.getSize(m * n);\n        result[i] = Math.max( 0, currentCount - prevCount - 1);\n        grid[x][y] = 1;\n    }\n    \n    \n\n};"}
{"id": "1891", "path": "output2\\js\\Hard\\1891-split-array-with-same-average.js", "hypo_code": "var splitArraySameAverage = function(nums) {\n    const sum = nums.reduce((acc, cur) => acc + cur, 0);\n    const n = nums.length;\n    const dp = new Array(sum + 1).fill(false);\n    dp[0] = true;\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = sum; j >= nums[i]; j--) {\n            dp[j] = dp[j] || dp[j - nums[i]];\n        }\n    }\n    \n    for (let i = 1; i <= sum / 2; i++) {\n        if (dp[i] && i * n === sum) {\n            return true;\n        }\n    }\n    \n    return false;\n    \n};"}
{"id": "1892", "path": "output2\\js\\Hard\\1892-chalkboard-xor-game.js", "hypo_code": "var xorGame = function(nums) {\n    let xor = 0;\n    for (let i = 0; i < nums.length; i++) {\n        xor ^= nums[i];\n    }\n    return xor === 0 || nums.length % 2 === 0;\n    \n};"}
{"id": "1893", "path": "output2\\js\\Hard\\1893-bus-routes.js", "hypo_code": "var numBusesToDestination = function(routes, source, target) {\n    if (source === target) {\n        return 0;\n    }\n    \n    const n = routes.length;\n    const graph = new Array(n).fill(0).map(() => new Array(n).fill(false));\n    const routeMap = new Map();\n    \n    for (let i = 0; i < n; i++) {\n        for (const site of routes[i]) {\n            const list = routeMap.get(site) || new Array();\n            for (const j of list) {\n                graph[i][j] = graph[j][i] = true;\n            }\n            list.push(i);\n            routeMap.set(site, list);\n        }\n    }\n    \n    const queue = new Array();\n    const seen = new Array(n).fill(false);\n    let step = 0;\n    \n    for (const site of routeMap.get(source) || []) {\n        queue.push(site);\n        seen[site] = true;\n    }\n    \n    while (queue.length > 0) {\n        step++;\n        const size = queue.length;\n        for (let i = 0; i < size; i++) {\n            const x = queue.shift();\n            for (let y = 0; y < n; y++) {\n                if (graph[x][y] && !seen[y]) {\n                    if (routes[y].includes(target)) {\n                        return step;\n                    }\n                    queue.push(y);\n                    seen[y] = true;\n                }\n            }\n        }\n    }\n    \n    return -1;\n    \n};"}
{"id": "1894", "path": "output2\\js\\Hard\\1894-race-car.js", "hypo_code": "var racecar = function(target) {\n    let dp = new Array(target + 1).fill(0);\n    for(let i = 1; i <= target; i++){\n        dp[i] = Number.MAX_SAFE_INTEGER;\n        let k = 1;\n        let pos = 1;\n        while(pos < i){\n            for(let j = 0; j < k; j++){\n                dp[i] = Math.min(dp[i], dp[i - pos] + k + 1 + j);\n            }\n            k++;\n            pos = Math.pow(2, k) - 1;\n        }\n        if(pos === i){\n            dp[i] = Math.min(dp[i], k);\n        }\n        else{\n            for(let j = 0; j < k; j++){\n                dp[i] = Math.min(dp[i], dp[pos - i] + k + 1 + j);\n            }\n        }\n    }\n    return dp[target];\n    \n};"}
{"id": "1895", "path": "output2\\js\\Hard\\1895-making-a-large-island.js", "hypo_code": "var largestIsland = function(grid) {\n    let n = grid.length;\n    let m = grid[0].length;\n    let visited = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n        }\n    }\n    let islandSizes = [];\n    let islandCount = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            if(grid[i][j] === 1 && !visited[i][j]){\n                islandCount++;\n                let size = dfs(grid, visited, i, j, n, m);\n                islandSizes.push(size);\n            }\n        }\n    }\n    let max = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            if(grid[i][j] === 0){\n                let size = 1;\n                let set = new Set();\n                if(i - 1 >= 0 && grid[i - 1][j] === 1){\n                    set.add(grid[i - 1][j]);\n                }\n                if(i + 1 < n && grid[i + 1][j] === 1){\n                    set.add(grid[i + 1][j]);\n                }\n                if(j - 1 >= 0 && grid[i][j - 1] === 1){\n                    set.add(grid[i][j - 1]);\n                }\n                if(j + 1 < m && grid[i][j + 1] === 1){\n                    set.add(grid[i][j + 1]);\n                }\n                for(let num of set){\n                    size += islandSizes[num - 1];\n                }\n                max = Math.max(max, size);\n            }\n        }\n    }\n    if(max === 0){\n        return n * m;\n    }\n    return max;\n    \n    \n};"}
{"id": "1896", "path": "output2\\js\\Hard\\1896-count-unique-characters-of-all-substrings-of-a-given-string.js", "hypo_code": "var uniqueLetterString = function(s) {\n    const n = s.length;\n    const pos = new Array(26).fill(0).map(() => new Array());\n    const mod = 10 ** 9 + 7;\n    let ans = 0;\n    \n    for (let i = 0; i < n; i++) {\n        pos[s[i].charCodeAt() - 'A'.charCodeAt()].push(i);\n    }\n    \n    for (let i = 0; i < 26; i++) {\n        const m = pos[i].length;\n        for (let j = 0; j < m; j++) {\n            const left = j > 0 ? pos[i][j - 1] : -1;\n            const right = j < m - 1 ? pos[i][j + 1] : n;\n            ans = (ans + (pos[i][j] - left) * (right - pos[i][j])) % mod;\n        }\n    }\n    \n    return ans;\n    \n};"}
{"id": "1897", "path": "output2\\js\\Hard\\1897-consecutive-numbers-sum.js", "hypo_code": "var consecutiveNumbersSum = function(n) {\n    let ans = 0;\n    for (let i = 1; i * (i - 1) / 2 < n; i++) {\n        if ((n - i * (i - 1) / 2) % i === 0) {\n            ans++;\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1898", "path": "output2\\js\\Hard\\1898-sum-of-distances-in-tree.js", "hypo_code": "var sumOfDistancesInTree = function(n, edges) {\n    let graph = new Array(n);\n    for(let i = 0; i < n; i++){\n        graph[i] = [];\n    }\n    for(let i = 0; i < edges.length; i++){\n        graph[edges[i][0]].push(edges[i][1]);\n        graph[edges[i][1]].push(edges[i][0]);\n    }\n    let count = new Array(n).fill(1);\n    let res = new Array(n).fill(0);\n    let visited = new Array(n).fill(false);\n    let dfs = function(node){\n        visited[node] = true;\n        for(let i = 0; i < graph[node].length; i++){\n            if(!visited[graph[node][i]]){\n                dfs(graph[node][i]);\n                count[node] += count[graph[node][i]];\n                res[node] += res[graph[node][i]] + count[graph[node][i]];\n            }\n        }\n    };\n    let dfs2 = function(node){\n        visited[node] = true;\n        for(let i = 0; i < graph[node].length; i++){\n            if(!visited[graph[node][i]]){\n                res[graph[node][i]] = res[node] - count[graph[node][i]] + n - count[graph[node][i]];\n                dfs2(graph[node][i]);\n            }\n        }\n    };\n    dfs(0);\n    visited = new Array(n).fill(false);\n    dfs2(0);\n    return res;\n    \n};"}
{"id": "1899", "path": "output2\\js\\Hard\\1899-similar-string-groups.js", "hypo_code": "var numSimilarGroups = function(strs) {\n    let n = strs.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][i] - dp[n][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1900", "path": "output2\\js\\Hard\\1900-guess-the-word.js", "hypo_code": "var findSecretWord = function(words, master) {\n    let n = words.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            if(i != j){\n                let count = 0;\n                for(let k = 0; k < 6; k++){\n                    if(words[i][k] == words[j][k]){\n                        count++;\n                    }\n                }\n                dp[i][j] = count;\n            }\n        }\n    }\n    let used = [];\n    for(let i = 0; i < n; i++){\n        used.push(false);\n    }\n    for(let i = 0; i < 10; i++){\n        let max = 0;\n        let index = 0;\n        for(let j = 0; j < n; j++){\n            if(!used[j]){\n                let count = 0;\n                for(let k = 0; k < n; k++){\n                    if(!used[k]){\n                        count += dp[j][k];\n                    }\n                }\n                if(count > max){\n                    max = count;\n                    index = j;\n                }\n            }\n        }\n        let guess = master.guess(words[index]);\n        if(guess == 6){\n            return;\n        }\n        used[index] = true;\n        for(let j = 0; j < n; j++){\n            if(dp[index][j] != guess){\n                used[j] = true;\n            }\n        }\n    }\n    \n};"}
{"id": "1901", "path": "output2\\js\\Hard\\1901-shortest-path-visiting-all-nodes.js", "hypo_code": "var shortestPathLength = function(graph) {\n    let n = graph.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push([]);\n            for(let k = 0; k < (1 << n); k++){\n                dp[i][j].push(-1);\n            }\n        }\n    }\n    let dfs = function(node, mask, steps){\n        if(mask === (1 << n) - 1){\n            return steps;\n        }\n        if(dp[node][mask][steps] !== -1){\n            return dp[node][mask][steps];\n        }\n        let result = Infinity;\n        for(let i = 0; i < graph[node].length; i++){\n            let newMask = mask | (1 << graph[node][i]);\n            result = Math.min(result, dfs(graph[node][i], newMask, steps + 1));\n        }\n        dp[node][mask][steps] = result;\n        return result;\n    };\n    let result = Infinity;\n    for(let i = 0; i < n; i++){\n        result = Math.min(result, dfs(i, 1 << i, 0));\n    }\n    return result;\n    \n};"}
{"id": "1902", "path": "output2\\js\\Hard\\1902-rectangle-area-ii.js", "hypo_code": "var rectangleArea = function(rectangles) {\n    let n = rectangles.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(i - j >= 0){\n                let left = 1;\n                let right = 1;\n                if(i - j - 1 >= 0){\n                    left = rectangles[i - j - 1];\n                }\n                if(i < n){\n                    right = rectangles[i];\n                }\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + left * rectangles[i - j] * right);\n            }\n            else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[n][n];\n    \n};"}
{"id": "1903", "path": "output2\\js\\Hard\\1903-k-similar-strings.js", "hypo_code": "var kSimilarity = function(s1, s2) {\n    let dp = [];\n    for(let i = 0; i <= s1.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= s1.length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= s1.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= s1.length; i++){\n        for(let j = 1; j <= s1.length; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= s1.length; i++){\n        ans.push(dp[s1.length][i] - dp[s1.length][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1904", "path": "output2\\js\\Hard\\1904-minimum-cost-to-hire-k-workers.js", "hypo_code": "var mincostToHireWorkers = function(quality, wage, k) {\n    let n = quality.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= k; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= k; j++){\n            if(i - j >= 0){\n                dp[i][j] = Math.max(dp[i - 1][j], quality[i - 1]);\n            }\n            else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = k; i <= n; i++){\n        ans.push(dp[i][k]);\n    }\n    return ans;\n    \n};"}
{"id": "1905", "path": "output2\\js\\Hard\\1905-shortest-subarray-with-sum-at-least-k.js", "hypo_code": "var shortestSubarray = function(nums, k) {\n    let dp = [];\n    for(let i = 0; i <= nums.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= nums.length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= nums.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= nums.length; i++){\n        for(let j = 1; j <= nums.length; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= nums.length; i++){\n        ans.push(dp[nums.length][i] - dp[nums.length][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1906", "path": "output2\\js\\Hard\\1906-shortest-path-to-get-all-keys.js", "hypo_code": "var shortestPathAllKeys = function(grid) {\n    let n = grid.length;\n    let m = grid[0].length;\n    let start = [];\n    let keys = [];\n    let locks = [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            if(grid[i][j] == '@'){\n                start = [i, j];\n            }\n            if(grid[i][j] >= 'a' && grid[i][j] <= 'f'){\n                keys.push([i, j]);\n            }\n            if(grid[i][j] >= 'A' && grid[i][j] <= 'F'){\n                locks.push([i, j]);\n            }\n        }\n    }\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < m; j++){\n            dp[i].push([]);\n            for(let k = 0; k < 64; k++){\n                dp[i][j].push(-1);\n            }\n        }\n    }\n    let queue = [];\n    queue.push([start[0], start[1], 0]);\n    dp[start[0]][start[1]][0] = 0;\n    let dir = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n    while(queue.length > 0){\n        let cur = queue.shift();\n        let x = cur[0];\n        let y = cur[1];\n        let mask = cur[2];\n        for(let i = 0; i < 4; i++){\n            let nx = x + dir[i][0];\n            let ny = y + dir[i][1];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] != '#'){\n                let nmask = mask;\n                if(grid[nx][ny] >= 'a' && grid[nx][ny] <= 'f'){\n                    nmask |= (1 << (grid[nx][ny].charCodeAt() - 'a'.charCodeAt()));\n                }\n                if(grid[nx][ny] >= 'A' && grid[nx][ny] <= 'F'){\n                    if((nmask & (1 << (grid[nx][ny].charCodeAt() - 'A'.charCodeAt()))) == 0){\n                        continue;\n                    }\n                }\n                if(dp[nx][ny][nmask] == -1){\n                    dp[nx][ny][nmask] = dp[x][y][mask] + 1;\n                    queue.push([nx, ny, nmask]);\n                }\n            }\n        }\n    }\n    let result = Infinity;\n    for(let i = 0; i < 64; i++){\n        if(dp[start[0]][start[1]][i] != -1){\n            result = Math.min(result, dp[start[0]][start[1]][i]);\n        }\n    }\n    if(result == Infinity){\n        return -1;\n    }\n    return result;\n    \n    \n};"}
{"id": "1907", "path": "output2\\js\\Hard\\1907-minimum-number-of-refueling-stops.js", "hypo_code": "var minRefuelStops = function(target, startFuel, stations) {\n    let n = stations.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = startFuel;\n    for(let i = 1; i <= n; i++){\n        for(let j = 0; j <= i; j++){\n            if(j > 0){\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + stations[i - 1][1]);\n            }\n            else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        if(dp[n][i] >= target){\n            return i;\n        }\n    }\n    return -1;\n    \n};"}
{"id": "1908", "path": "output2\\js\\Hard\\1908-nth-magical-number.js", "hypo_code": "var nthMagicalNumber = function(n, a, b) {\n    let lcm = a * b / gcd(a, b);\n    let left = Math.min(a, b);\n    let right = Math.max(a, b) * n;\n    while(left < right){\n        let mid = Math.floor((left + right) / 2);\n        if(Math.floor(mid / a) + Math.floor(mid / b) - Math.floor(mid / lcm) < n){\n            left = mid + 1;\n        }else{\n            right = mid;\n        }\n    }\n    return left % 1000000007;\n    \n    \n};"}
{"id": "1909", "path": "output2\\js\\Hard\\1909-profitable-schemes.js", "hypo_code": "var profitableSchemes = function(n, minProfit, group, profit) {\n    let m = group.length;\n    let dp = [];\n    for(let i = 0; i <= m; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= minProfit; k++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    for(let i = 0; i <= m; i++){\n        dp[i][0][0] = 1;\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            for(let k = 0; k <= minProfit; k++){\n                dp[i][j][k] = dp[i - 1][j][k];\n                if(j >= group[i - 1]){\n                    dp[i][j][k] += dp[i - 1][j - group[i - 1]][Math.max(0, k - profit[i - 1])];\n                    dp[i][j][k] %= 1000000007;\n                }\n            }\n        }\n    }\n    let res = 0;\n    for(let i = 0; i <= n; i++){\n        res += dp[m][i][minProfit];\n        res %= 1000000007;\n    }\n    return res;\n    \n};"}
{"id": "1910", "path": "output2\\js\\Hard\\1910-reachable-nodes-in-subdivided-graph.js", "hypo_code": "var reachableNodes = function(edges, maxMoves, n) {\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= maxMoves; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= maxMoves; j++){\n            if(i - j >= 0){\n                dp[i][j] = Math.max(dp[i - 1][j], nums[i - 1]);\n            }\n            else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = maxMoves; i <= n; i++){\n        ans.push(dp[i][maxMoves]);\n    }\n    return ans;\n    \n};"}
{"id": "1911", "path": "output2\\js\\Hard\\1911-super-egg-drop.js", "hypo_code": "var superEggDrop = function(k, n) {\n    let dp = [];\n    for(let i = 0; i <= k; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    let m = 0;\n    while(dp[k][m] < n){\n        m++;\n        for(let i = 1; i <= k; i++){\n            dp[i][m] = dp[i][m - 1] + dp[i - 1][m - 1] + 1;\n        }\n    }\n    return m;\n    \n};"}
{"id": "1912", "path": "output2\\js\\Hard\\1912-sum-of-subsequence-widths.js", "hypo_code": "var sumSubseqWidths = function(nums) {\n    let dp = [];\n    for(let i = 0; i <= nums.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= nums.length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= nums.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= nums.length; i++){\n        for(let j = 1; j <= nums.length; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= nums.length; i++){\n        ans.push(dp[nums.length][i] - dp[nums.length][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1914", "path": "output2\\js\\Hard\\1914-orderly-queue.js", "hypo_code": "var orderlyQueue = function(s, k) {\n    if(k === 1){\n        let result = s;\n        for(let i = 0; i < s.length; i++){\n            let temp = s.substring(i) + s.substring(0, i);\n            if(temp < result){\n                result = temp;\n            }\n        }\n        return result;\n    }else{\n        let arr = s.split(\"\");\n        arr.sort();\n        return arr.join(\"\");\n    }\n    \n};"}
{"id": "1915", "path": "output2\\js\\Hard\\1915-numbers-at-most-n-given-digit-set.js", "hypo_code": "var atMostNGivenDigitSet = function(digits, n) {\n    let dp = [];\n    for(let i = 0; i <= digits.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= digits.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= digits.length; i++){\n        for(let j = 1; j <= n; j++){\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[digits.length][n];\n    \n};"}
{"id": "1916", "path": "output2\\js\\Hard\\1916-valid-permutations-for-di-sequence.js", "hypo_code": "var numPermsDISequence = function(s) {\n    let dp = [];\n    for(let i = 0; i <= s.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= s.length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= s.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= s.length; i++){\n        for(let j = 1; j <= s.length; j++){\n            if(s[i - 1] == 'D'){\n                dp[i][j] = dp[i - 1][j - 1];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = 0;\n    for(let i = 0; i <= s.length; i++){\n        ans += dp[s.length][i];\n    }\n    return ans;\n    \n};"}
{"id": "1917", "path": "output2\\js\\Hard\\1917-super-palindromes.js", "hypo_code": "var superpalindromesInRange = function(left, right) {\n    let ans = 0;\n    let l = Math.ceil(Math.sqrt(Number(left)));\n    let r = Math.floor(Math.sqrt(Number(right)));\n    for(let i = l; i <= r; i++){\n        if(isPalindrome(i) && isPalindrome(i * i)){\n            ans++;\n        }\n    }\n    for(let i = 1; i <= 100000; i++){\n        let s = i.toString();\n        let t = s.split(\"\").reverse().join(\"\");\n        let num = Number(s + t);\n        if(num > r){\n            break;\n        }\n        if(num >= l && isPalindrome(num * num)){\n            ans++;\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "1918", "path": "output2\\js\\Hard\\1918-cat-and-mouse.js", "hypo_code": "var catMouseGame = function(graph) {\n    let n = graph.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push([]);\n            for(let k = 0; k < 3; k++){\n                dp[i][j].push([]);\n                for(let l = 0; l < 2; l++){\n                    dp[i][j][k].push(-1);\n                }\n            }\n        }\n    }\n    let dfs = function(mouse, cat, turn, mouseTurn){\n        if(mouse === cat){\n            return 2;\n        }\n        if(mouse === 0){\n            return 1;\n        }\n        if(dp[mouse][cat][turn][mouseTurn] !== -1){\n            return dp[mouse][cat][turn][mouseTurn];\n        }\n        let result = 0;\n        if(mouseTurn === 1){\n            result = 2;\n            for(let i = 0; i < graph[mouse].length; i++){\n                let newMouse = graph[mouse][i];\n                let newTurn = turn;\n                if(newMouse === cat){\n                    newTurn = 2;\n                }\n                result = Math.min(result, dfs(newMouse, cat, newTurn, 0));\n            }\n        }else{\n            result = 1;\n            for(let i = 0; i < graph[cat].length; i++){\n                let newCat = graph[cat][i];\n                if(newCat === 0){\n                    continue;\n                }\n                let newTurn = turn;\n                if(newCat === mouse){\n                    newTurn = 2;\n                }\n                result = Math.max(result, dfs(mouse, newCat, newTurn, 1));\n            }\n        }\n        dp[mouse][cat][turn][mouseTurn] = result;\n        return result;\n    };\n    return dfs(1, 2, 0, 1);\n    \n};"}
{"id": "1919", "path": "output2\\js\\Hard\\1919-number-of-music-playlists.js", "hypo_code": "var numMusicPlaylists = function(n, goal, k) {\n    let dp = [];\n    for(let i = 0; i <= goal; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i <= goal; i++){\n        for(let j = 1; j <= n; j++){\n            dp[i][j] = dp[i - 1][j - 1] * (n - j + 1);\n            if(j > k){\n                dp[i][j] += dp[i - 1][j] * (j - k);\n            }\n            dp[i][j] %= 1000000007;\n        }\n    }\n    return dp[goal][n];\n    \n};"}
{"id": "1920", "path": "output2\\js\\Hard\\1920-minimize-malware-spread.js", "hypo_code": "var minMalwareSpread = function(graph, initial) {\n    let n = graph.length;\n    let infected = new Array(n).fill(false);\n    for(let i = 0; i < initial.length; i++){\n        infected[initial[i]] = true;\n    }\n    let count = new Array(n).fill(0);\n    let dfs = function(node){\n        if(infected[node]){\n            return 0;\n        }\n        if(count[node] !== 0){\n            return count[node];\n        }\n        let result = 1;\n        for(let i = 0; i < n; i++){\n            if(graph[node][i] === 1){\n                result += dfs(i);\n            }\n        }\n        count[node] = result;\n        return result;\n    };\n    let result = Infinity;\n    let node = -1;\n    for(let i = 0; i < initial.length; i++){\n        let temp = dfs(initial[i]);\n        if(temp < result){\n            result = temp;\n            node = initial[i];\n        }\n        else if(temp === result){\n            node = Math.min(node, initial[i]);\n        }\n    }\n    return node;\n    \n};"}
{"id": "1921", "path": "output2\\js\\Hard\\1921-three-equal-parts.js", "hypo_code": "var threeEqualParts = function(arr) {\n    let dp = [];\n    for(let i = 0; i <= arr.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= arr.length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= arr.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= arr.length; i++){\n        for(let j = 1; j <= arr.length; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= arr.length; i++){\n        ans.push(dp[arr.length][i] - dp[arr.length][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1922", "path": "output2\\js\\Hard\\1922-minimize-malware-spread-ii.js", "hypo_code": "var minMalwareSpread = function(graph, initial) {\n    let n = graph.length;\n    let infected = new Array(n).fill(false);\n    for(let i = 0; i < initial.length; i++){\n        infected[initial[i]] = true;\n    }\n    let count = new Array(n).fill(0);\n    let dfs = function(node){\n        if(infected[node]){\n            return 0;\n        }\n        if(count[node] !== 0){\n            return count[node];\n        }\n        let result = 1;\n        for(let i = 0; i < n; i++){\n            if(graph[node][i] === 1){\n                result += dfs(i);\n            }\n        }\n        count[node] = result;\n        return result;\n    };\n    let result = Infinity;\n    let node = -1;\n    for(let i = 0; i < initial.length; i++){\n        let temp = dfs(initial[i]);\n        if(temp < result){\n            result = temp;\n            node = initial[i];\n        }\n        else if(temp === result){\n            node = Math.min(node, initial[i]);\n        }\n    }\n    return node;\n    \n};"}
{"id": "1923", "path": "output2\\js\\Hard\\1923-stamping-the-sequence.js", "hypo_code": "class Solution {\n    public int[] movesToStamp(String stamp, String target) {\n        int[] dp = new int[target.length()];\n        for(int i = 0; i < target.length(); i++){\n            dp[i] = -1;\n        }\n        int[] ans = new int[target.length()];\n        int ansIndex = 0;\n        int count = 0;\n        while(count < target.length()){\n            boolean found = false;\n            for(int i = 0; i <= target.length() - stamp.length(); i++){\n                if(dp[i] == -1 && canStamp(stamp, target, i, dp)){\n                    found = true;\n                    for(int j = 0; j < stamp.length(); j++){\n                        if(dp[i + j] == -1){\n                            dp[i + j] = 1;\n                            count++;\n                        }\n                    }\n                    ans[ansIndex++] = i;\n                }\n            }\n            if(!found){\n                return new int[0];\n            }\n        }\n        int[] ans2 = new int[ansIndex];\n        for(int i = 0; i < ansIndex; i++){\n            ans2[i] = ans[ansIndex - i - 1];\n        }\n        return ans2;\n        \n    }\n}"}
{"id": "1924", "path": "output2\\js\\Hard\\1924-distinct-subsequences-ii.js", "hypo_code": "var distinctSubseqII = function(s) {\n    let dp = [];\n    for(let i = 0; i <= s.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= s.length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= s.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= s.length; i++){\n        for(let j = 1; j <= s.length; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= s.length; i++){\n        ans.push(dp[s.length][i] - dp[s.length][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1925", "path": "output2\\js\\Hard\\1925-find-the-shortest-superstring.js", "hypo_code": "var shortestSuperstring = function(words) {\n    let dp = [];\n    for(let i = 0; i < words.length; i++){\n        dp.push([]);\n        for(let j = 0; j < words.length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i < words.length; i++){\n        for(let j = 0; j < words.length; j++){\n            if(i == j){\n                continue;\n            }\n            let min = Math.min(words[i].length, words[j].length);\n            for(let k = min; k >= 0; k--){\n                if(words[i].endsWith(words[j].substring(0, k))){\n                    dp[i][j] = k;\n                    break;\n                }\n            }\n        }\n    }\n    let memo = [];\n    for(let i = 0; i < words.length; i++){\n        memo.push([]);\n        for(let j = 0; j < (1 << words.length); j++){\n            memo[i].push(-1);\n        }\n    }\n    let ans = Number.MAX_SAFE_INTEGER;\n    let ansIndex = -1;\n    for(let i = 0; i < words.length; i++){\n        let temp = dfs(i, 1 << i, words, dp, memo);\n        if(temp < ans){\n            ans = temp;\n            ansIndex = i;\n        }\n    }\n    let result = words[ansIndex];\n    let used = 1 << ansIndex;\n    while(used != (1 << words.length) - 1){\n        for(let i = 0; i < words.length; i++){\n            if((used & (1 << i)) == 0){\n                let temp = dfs(i, used | (1 << i), words, dp, memo);\n                if(temp == ans - words[i].length + dp[ansIndex][i]){\n                    ans = temp;\n                    ansIndex = i;\n                    used |= (1 << i);\n                    result += words[i].substring(dp[ansIndex][i]);\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "1926", "path": "output2\\js\\Hard\\1926-largest-component-size-by-common-factor.js", "hypo_code": "var largestComponentSize = function(nums) {\n    let parent = new Array(100001).fill(0);\n    let size = new Array(100001).fill(1);\n    for(let i = 0; i < nums.length; i++){\n        parent[nums[i]] = nums[i];\n    }\n    let find = function(x){\n        if(parent[x] === x){\n            return x;\n        }\n        return parent[x] = find(parent[x]);\n    };\n    let union = function(x, y){\n        let rootX = find(x);\n        let rootY = find(y);\n        if(rootX === rootY){\n            return;\n        }\n        if(size[rootX] > size[rootY]){\n            parent[rootY] = rootX;\n            size[rootX] += size[rootY];\n        }\n        else{\n            parent[rootX] = rootY;\n            size[rootY] += size[rootX];\n        }\n    };\n    for(let i = 0; i < nums.length; i++){\n        for(let j = 2; j * j <= nums[i]; j++){\n            if(nums[i] % j === 0){\n                union(nums[i], j);\n                union(nums[i], nums[i] / j);\n            }\n        }\n    }\n    let res = 0;\n    for(let i = 0; i < nums.length; i++){\n        res = Math.max(res, size[find(nums[i])]);\n    }\n    return res;\n    \n};"}
{"id": "1927", "path": "output2\\js\\Hard\\1927-tallest-billboard.js", "hypo_code": "var tallestBillboard = function(rods) {\n    let dp = [];\n    for(let i = 0; i <= rods.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= 10000; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= rods.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= rods.length; i++){\n        for(let j = 1; j <= 10000; j++){\n            if(j >= rods[i - 1]){\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - rods[i - 1]];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = 0;\n    for(let i = 0; i <= 10000; i++){\n        if(dp[rods.length][i] > 0){\n            ans = Math.max(ans, i);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1928", "path": "output2\\js\\Hard\\1928-delete-columns-to-make-sorted-iii.js", "hypo_code": "var minDeletionSize = function(strs) {\n    let dp = [];\n    for(let i = 0; i <= strs.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= strs[0].length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= strs.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= strs.length; i++){\n        for(let j = 1; j <= strs[0].length; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= strs[0].length; i++){\n        ans.push(dp[strs.length][i] - dp[strs.length][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1929", "path": "output2\\js\\Hard\\1929-least-operators-to-express-number.js", "hypo_code": "var leastOpsExpressTarget = function(x, target) {\n    let dp = [];\n    for(let i = 0; i <= x; i++){\n        dp.push([]);\n        for(let j = 0; j <= target; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= x; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= x; i++){\n        for(let j = 1; j <= target; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= target; i++){\n        ans.push(dp[x][i] - dp[x][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1930", "path": "output2\\js\\Hard\\1930-binary-tree-cameras.js", "hypo_code": "var minCameraCover = function(root) {\n    let res = 0;\n    let dfs = function(node){\n        if(node === null){\n            return 2;\n        }\n        let left = dfs(node.left);\n        let right = dfs(node.right);\n        if(left === 0 || right === 0){\n            res++;\n            return 1;\n        }\n        if(left === 1 || right === 1){\n            return 2;\n        }\n        return 0;\n    }\n    if(dfs(root) === 0){\n        res++;\n    }\n    return res;\n    \n};"}
{"id": "1931", "path": "output2\\js\\Hard\\1931-equal-rational-numbers.js", "hypo_code": "var isRationalEqual = function(s, t) {\n    let a = parse(s);\n    let b = parse(t);\n    return a[0] * b[1] == a[1] * b[0];\n    \n};"}
{"id": "1932", "path": "output2\\js\\Hard\\1932-odd-even-jump.js", "hypo_code": "var oddEvenJumps = function(arr) {\n    let n = arr.length;\n    let odd = new Array(n).fill(false);\n    let even = new Array(n).fill(false);\n    odd[n - 1] = true;\n    even[n - 1] = true;\n    let map = new Map();\n    map.set(arr[n - 1], n - 1);\n    let ans = 1;\n    for(let i = n - 2; i >= 0; i--){\n        let next = map.get(arr[i]);\n        if(next != undefined){\n            odd[i] = even[next];\n            even[i] = odd[next];\n        }else{\n            let next = map.get(Math.min(...map.keys().filter(x => x > arr[i])));\n            if(next != undefined){\n                odd[i] = even[next];\n            }\n            next = map.get(Math.max(...map.keys().filter(x => x < arr[i])));\n            if(next != undefined){\n                even[i] = odd[next];\n            }\n        }\n        if(odd[i]){\n            ans++;\n        }\n        map.set(arr[i], i);\n    }\n    return ans;\n    \n};"}
{"id": "1933", "path": "output2\\js\\Hard\\1933-unique-paths-iii.js", "hypo_code": "var uniquePathsIII = function(grid) {\n    let start = [];\n    let end = [];\n    let empty = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[0].length; j++){\n            if(grid[i][j] === 1){\n                start = [i, j];\n            }\n            if(grid[i][j] === 2){\n                end = [i, j];\n            }\n            if(grid[i][j] === 0){\n                empty++;\n            }\n        }\n    }\n    let ans = 0;\n    let dfs = function(i, j, empty){\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === -1){\n            return;\n        }\n        if(grid[i][j] === 2){\n            if(empty === 0){\n                ans++;\n            }\n            return;\n        }\n        grid[i][j] = -1;\n        dfs(i + 1, j, empty - 1);\n        dfs(i - 1, j, empty - 1);\n        dfs(i, j + 1, empty - 1);\n        dfs(i, j - 1, empty - 1);\n        grid[i][j] = 0;\n    };\n    dfs(start[0], start[1], empty);\n    return ans;\n    \n};"}
{"id": "1934", "path": "output2\\js\\Hard\\1934-triples-with-bitwise-and-equal-to-zero.js", "hypo_code": "var countTriplets = function(nums) {\n    let res = 0;\n    for(let i = 0; i < nums.length; i++){\n        for(let j = 0; j < nums.length; j++){\n            for(let k = 0; k < nums.length; k++){\n                if((nums[i] & nums[j] & nums[k]) === 0){\n                    res++;\n                }\n            }\n        }\n    }\n    return res;\n    \n};"}
{"id": "1935", "path": "output2\\js\\Hard\\1935-vertical-order-traversal-of-a-binary-tree.js", "hypo_code": "var verticalTraversal = function(root) {\n    let map = new Map();\n    let dfs = function(node, row, col){\n        if(node === null){\n            return;\n        }\n        if(!map.has(col)){\n            map.set(col, []);\n        }\n        map.get(col).push([row, node.val]);\n        dfs(node.left, row + 1, col - 1);\n        dfs(node.right, row + 1, col + 1);\n    }\n    dfs(root, 0, 0);\n    let res = [];\n    let keys = [...map.keys()].sort((a, b) => a - b);\n    for(let key of keys){\n        let arr = map.get(key);\n        arr.sort((a, b) => {\n            if(a[0] === b[0]){\n                return a[1] - b[1];\n            }\n            return a[0] - b[0];\n        });\n        let temp = [];\n        for(let i = 0; i < arr.length; i++){\n            temp.push(arr[i][1]);\n        }\n        res.push(temp);\n    }\n    return res;\n\n    \n};"}
{"id": "1936", "path": "output2\\js\\Hard\\1936-subarrays-with-k-different-integers.js", "hypo_code": "var subarraysWithKDistinct = function(nums, k) {\n    let dp = [];\n    for(let i = 0; i <= nums.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= nums.length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= nums.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= nums.length; i++){\n        for(let j = 1; j <= nums.length; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= nums.length; i++){\n        ans.push(dp[nums.length][i] - dp[nums.length][i - 1]);\n    }\n    return ans;\n    \n    \n};"}
{"id": "1937", "path": "output2\\js\\Hard\\1937-minimum-number-of-k-consecutive-bit-flips.js", "hypo_code": "var minKBitFlips = function(nums, k) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n};"}
{"id": "1938", "path": "output2\\js\\Hard\\1938-number-of-squareful-arrays.js", "hypo_code": "var numSquarefulPerms = function(nums) {\n    let dp = [];\n    for(let i = 0; i <= nums.length; i++){\n        dp.push([]);\n        for(let j = 0; j <= nums.length; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= nums.length; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= nums.length; i++){\n        for(let j = 1; j <= nums.length; j++){\n            if(i > j){\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }else{\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    let ans = [];\n    for(let i = 1; i <= nums.length; i++){\n        ans.push(dp[nums.length][i] - dp[nums.length][i - 1]);\n    }\n    return ans;\n    \n};"}
{"id": "1939", "path": "output2\\js\\Hard\\1939-minimum-cost-to-merge-stones.js", "hypo_code": "var mergeStones = function(stones, k) {\n    let n = stones.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let l = 0; l <= k; l++){\n                dp[i][j].push(0);\n            }\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i][1] = 0;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            for(let l = 2; l <= k; l++){\n                dp[i][j][l] = Number.MAX_SAFE_INTEGER;\n                for(let m = j; m < i; m++){\n                    dp[i][j][l] = Math.min(dp[i][j][l], dp[m][j][1] + dp[i][m + 1][l - 1]);\n                }\n            }\n            dp[i][j][1] = dp[i][j][k] + sum(stones, j, i);\n        }\n    }\n    return dp[n][0][1] === Number.MAX_SAFE_INTEGER ? -1 : dp[n][0][1];\n    \n    \n};"}
{"id": "1940", "path": "output2\\js\\Hard\\1940-grid-illumination.js", "hypo_code": "var gridIllumination = function(n, lamps, queries) {\n    let ans = [];\n    let row = new Map();\n    let col = new Map();\n    let diag1 = new Map();\n    let diag2 = new Map();\n    let lampSet = new Set();\n    for(let i = 0; i < lamps.length; i++){\n        let x = lamps[i][0];\n        let y = lamps[i][1];\n        row.set(x, (row.get(x) || 0) + 1);\n        col.set(y, (col.get(y) || 0) + 1);\n        diag1.set(x + y, (diag1.get(x + y) || 0) + 1);\n        diag2.set(x - y, (diag2.get(x - y) || 0) + 1);\n        lampSet.add(x + ',' + y);\n    }\n    for(let i = 0; i < queries.length; i++){\n        let x = queries[i][0];\n        let y = queries[i][1];\n        if(row.get(x) || col.get(y) || diag1.get(x + y) || diag2.get(x - y)){\n            ans.push(1);\n        }else{\n            ans.push(0);\n        }\n        for(let dx = -1; dx <= 1; dx++){\n            for(let dy = -1; dy <= 1; dy++){\n                let nx = x + dx;\n                let ny = y + dy;\n                if(lampSet.has(nx + ',' + ny)){\n                    row.set(nx, row.get(nx) - 1);\n                    col.set(ny, col.get(ny) - 1);\n                    diag1.set(nx + ny, diag1.get(nx + ny) - 1);\n                    diag2.set(nx - ny, diag2.get(nx - ny) - 1);\n                    lampSet.delete(nx + ',' + ny);\n                }\n            }\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1941", "path": "output2\\js\\Hard\\1941-numbers-with-repeated-digits.js", "hypo_code": "var numDupDigitsAtMostN = function(n) {\n    let ans = 0;\n    let digits = [];\n    let num = n;\n    while(num > 0){\n        digits.push(num % 10);\n        num = Math.floor(num / 10);\n    }\n    digits = digits.reverse();\n    let len = digits.length;\n    for(let i = 1; i < len; i++){\n        ans += 9 * A(9, i - 1);\n    }\n    let seen = new Set();\n    for(let i = 0; i < len; i++){\n        for(let j = (i == 0 ? 1 : 0); j < digits[i]; j++){\n            if(!seen.has(j)){\n                ans += A(9 - i, len - i - 1);\n            }\n        }\n        if(seen.has(digits[i])){\n            break;\n        }\n        seen.add(digits[i]);\n        if(i == len - 1){\n            ans++;\n        }\n    }\n    return n - ans;\n    \n};"}
{"id": "1942", "path": "output2\\js\\Hard\\1942-recover-a-tree-from-preorder-traversal.js", "hypo_code": "var recoverFromPreorder = function(traversal) {\n    let stack = [];\n    let i = 0;\n    while(i < traversal.length){\n        let level = 0;\n        while(traversal[i] == '-'){\n            level++;\n            i++;\n        }\n        let val = 0;\n        while(i < traversal.length && traversal[i] != '-'){\n            val = val * 10 + traversal[i].charCodeAt(0) - '0'.charCodeAt(0);\n            i++;\n        }\n        let node = new TreeNode(val);\n        if(level == stack.length){\n            if(stack.length > 0){\n                stack[stack.length - 1].left = node;\n            }\n        }\n        else{\n            stack = stack.slice(0, level);\n            stack[stack.length - 1].right = node;\n        }\n        stack.push(node);\n    }\n    return stack[0];\n    \n};"}
{"id": "1944", "path": "output2\\js\\Hard\\1944-escape-a-large-maze.js", "hypo_code": "var isEscapePossible = function(blocked, source, target) {\n    let blockedSet = new Set();\n    for(let i = 0; i < blocked.length; i++){\n        blockedSet.add(blocked[i][0] + ',' + blocked[i][1]);\n    }\n    let sourceVisited = new Set();\n    let targetVisited = new Set();\n    return bfs(source, target, blockedSet, sourceVisited) && bfs(target, source, blockedSet, targetVisited);\n    \n};"}
{"id": "1945", "path": "output2\\js\\Hard\\1945-longest-duplicate-substring.js", "hypo_code": "var longestDupSubstring = function(s) {\n    let n = s.length;\n    let a = 26;\n    let mod = 2**32;\n    let left = 1;\n    let right = n;\n    let ans = '';\n    while(left <= right){\n        let mid = Math.floor((left + right) / 2);\n        let found = rabinKarp(s, mid, a, mod);\n        if(found != -1){\n            ans = s.substring(found, found + mid);\n            left = mid + 1;\n        }\n        else{\n            right = mid - 1;\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "1946", "path": "output2\\js\\Hard\\1946-number-of-submatrices-that-sum-to-target.js", "hypo_code": "var numSubmatrixSumTarget = function(matrix, target) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1947", "path": "output2\\js\\Hard\\1947-shortest-common-supersequence.js", "hypo_code": "var shortestCommonSupersequence = function(str1, str2) {\n    let m = str1.length;\n    let n = str2.length;\n    let dp = new Array(m + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(n + 1).fill(0);\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            if(str1[i - 1] == str2[j - 1]){\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            }\n            else{\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    let i = m;\n    let j = n;\n    let ans = '';\n    while(i > 0 && j > 0){\n        if(str1[i - 1] == str2[j - 1]){\n            ans = str1[i - 1] + ans;\n            i--;\n            j--;\n        }\n        else{\n            if(dp[i - 1][j] > dp[i][j - 1]){\n                ans = str1[i - 1] + ans;\n                i--;\n            }\n            else{\n                ans = str2[j - 1] + ans;\n                j--;\n            }\n        }\n    }\n    while(i > 0){\n        ans = str1[i - 1] + ans;\n        i--;\n    }\n    while(j > 0){\n        ans = str2[j - 1] + ans;\n        j--;\n    }\n    return ans;\n    \n};"}
{"id": "1948", "path": "output2\\js\\Hard\\1948-find-in-mountain-array.js", "hypo_code": "var findInMountainArray = function(target, mountainArr) {\n    let n = mountainArr.length();\n    let peak = findPeak(mountainArr, 0, n - 1);\n    let left = binarySearch(mountainArr, 0, peak, target, true);\n    if(left != -1){\n        return left;\n    }\n    return binarySearch(mountainArr, peak + 1, n - 1, target, false);\n    \n    \n};"}
{"id": "1949", "path": "output2\\js\\Hard\\1949-brace-expansion-ii.js", "hypo_code": "var braceExpansionII = function(expression) {\n    let n = expression.length;\n    let i = 0;\n    let stack = [];\n    let cur = new Set();\n    cur.add('');\n    stack.push(cur);\n    while(i < n){\n        let ch = expression[i];\n        if(ch == '{'){\n            stack.push(new Set());\n            i++;\n        }\n        else if(ch == '}'){\n            let pre = stack.pop();\n            let cur = stack[stack.length - 1];\n            let temp = new Set();\n            for(let s1 of pre){\n                for(let s2 of cur){\n                    temp.add(s2 + s1);\n                }\n            }\n            stack[stack.length - 1] = temp;\n            i++;\n        }\n        else if(ch == ','){\n            stack.push(new Set());\n            i++;\n        }\n        else{\n            let j = i;\n            while(j < n && expression[j] >= 'a' && expression[j] <= 'z'){\n                j++;\n            }\n            let cur = stack[stack.length - 1];\n            let temp = new Set();\n            for(let s of cur){\n                temp.add(s + expression.substring(i, j));\n            }\n            stack[stack.length - 1] = temp;\n            i = j;\n        }\n    }\n    let ans = [];\n    for(let s of stack[0]){\n        ans.push(s);\n    }\n    ans.sort();\n    return ans;\n    \n};"}
{"id": "1950", "path": "output2\\js\\Hard\\1950-parsing-a-boolean-expression.js", "hypo_code": "var parseBoolExpr = function(expression) {\n    var numStrIndexOnesMin = 0;\n    var numStrIndexHundredsMin = 0;\n    var numStrIndexTensMin = 0;\n};"}
{"id": "1951", "path": "output2\\js\\Hard\\1951-smallest-sufficient-team.js", "hypo_code": "var smallestSufficientTeam = function(req_skills, people) {\n    let skillMap = new Map();\n    let peopleMap = new Map();\n    for (let i = 0; i < req_skills.length; i++) {\n        skillMap.set(req_skills[i], i);\n    }\n    for (let i = 0; i < people.length; i++) {\n        let skill = 0;\n        for (let j = 0; j < people[i].length; j++) {\n            skill |= 1 << skillMap.get(people[i][j]);\n        }\n        peopleMap.set(i, skill);\n    }\n    let dp = new Map();\n    dp.set(0, []);\n    for (let [key, value] of peopleMap) {\n        let newDp = new Map();\n        for (let [key1, value1] of dp) {\n            let newKey = value1 | value;\n            if (!newDp.has(newKey) || newDp.get(newKey).length > value1.length + 1) {\n                let newValue = [...value1, key];\n                newDp.set(newKey, newValue);\n            }\n        }\n        dp = newDp;\n    }\n    return dp.get(Math.pow(2, req_skills.length) - 1);\n\n};"}
{"id": "1952", "path": "output2\\js\\Hard\\1952-longest-chunked-palindrome-decomposition.js", "hypo_code": "var longestDecomposition = function(text) {\n    let len = text.length;\n    let mid = Math.ceil(len / 2);\n    for (let i = 0; i < mid; i++) {\n        let left = text.substring(0, i + 1);\n        let right = text.substring(len - i - 1, len);\n        if (left === right) {\n            return 2 + longestDecomposition(text.substring(i + 1, len - i - 1));\n        }\n    }\n    return len === 0 ? 0 : 1;\n};"}
{"id": "1954", "path": "output2\\js\\Hard\\1954-last-substring-in-lexicographical-order.js", "hypo_code": "var lastSubstring = function(s) {\n    let i = 0;\n    let j = 1;\n    let k = 0;\n    let len = s.length;\n    while (j + k < len) {\n        if (s[i + k] === s[j + k]) {\n            k++;\n            continue;\n        }\n        if (s[i + k] < s[j + k]) {\n            i = Math.max(i + k + 1, j);\n        } else {\n            j = Math.max(j + k + 1, i);\n        }\n        k = 0;\n    }\n    return s.substring(i);\n};"}
{"id": "1956", "path": "output2\\js\\Hard\\1956-number-of-valid-words-for-each-puzzle.js", "hypo_code": "var findNumOfValidWords = function(words, puzzles) {\n    let wordMap = new Map();\n    for (let i = 0; i < words.length; i++) {\n        let word = words[i];\n        let key = 0;\n        for (let j = 0; j < word.length; j++) {\n            key |= 1 << (word.charCodeAt(j) - 97);\n        }\n        if (!wordMap.has(key)) {\n            wordMap.set(key, 1);\n        } else {\n            wordMap.set(key, wordMap.get(key) + 1);\n        }\n    }\n    let result = [];\n    for (let i = 0; i < puzzles.length; i++) {\n        let puzzle = puzzles[i];\n        let key = 0;\n        for (let j = 0; j < puzzle.length; j++) {\n            key |= 1 << (puzzle.charCodeAt(j) - 97);\n        }\n        let count = 0;\n        let subKey = key;\n        let first = 1 << (puzzle.charCodeAt(0) - 97);\n        while (subKey > 0) {\n            if ((subKey & first) === first && wordMap.has(subKey)) {\n                count += wordMap.get(subKey);\n            }\n            subKey = (subKey - 1) & key;\n        }\n        result.push(count);\n    }\n    return result;\n};"}
{"id": "1957", "path": "output2\\js\\Hard\\1957-make-array-strictly-increasing.js", "hypo_code": "var makeArrayIncreasing = function(arr1, arr2) {\n    arr2 = [...new Set(arr2)].sort((a, b) => a - b);\n    let len1 = arr1.length;\n    let len2 = arr2.length;\n    let dp = new Array(len1 + 1);\n    for (let i = 0; i <= len1; i++) {\n        dp[i] = new Array(len2 + 1).fill(Number.MAX_SAFE_INTEGER);\n    }\n    dp[0][0] = Number.MIN_SAFE_INTEGER;\n    for (let i = 1; i <= len1; i++) {\n        for (let j = 0; j <= len2; j++) {\n            if (arr1[i - 1] > dp[i - 1][j]) {\n                dp[i][j] = arr1[i - 1];\n            }\n            if (j > 0 && arr2[j - 1] > dp[i - 1][j - 1]) {\n                dp[i][j] = Math.min(dp[i][j], arr2[j - 1]);\n            }\n            if (i === len1 && dp[i][j] !== Number.MAX_SAFE_INTEGER) {\n                return j;\n            }\n        }\n    }\n    return -1;\n};"}
{"id": "1958", "path": "output2\\js\\Hard\\1958-critical-connections-in-a-network.js", "hypo_code": "var criticalConnections = function(n, connections) {\n    let result = [];\n\tlet visited = new Array(n).fill(false);\n\tlet lowTime = new Array(n).fill(0);\n\tlet time = 0;\n\tlet graph = new Array(n);\n\tfor (let i = 0; i < n; i++) {\n\t\tgraph[i] = [];\n\t}\n\tfor (let i = 0; i < connections.length; i++) {\n\t\tlet [a, b] = connections[i];\n\t\tgraph[a].push(b);\n\t\tgraph[b].push(a);\n\t}\n\tdfs(0, -1);\n\treturn result;\n};\nfunction dfs(current, parent) {\n    visited[current] = true;\n    lowTime[current] = time++;\n    for (let i = 0; i < graph[current].length; i++) {\n        let next = graph[current][i];\n        if (next === parent) {\n            continue;\n        }\n        if (!visited[next]) {\n            dfs(next, current);\n            lowTime[current] = Math.min(lowTime[current], lowTime[next]);\n            if (lowTime[next] > lowTime[current]) {\n                result.push([current, next]);\n            }\n        } else {\n            lowTime[current] = Math.min(lowTime[current], lowTime[next]);\n        }\n    }\n}"}
{"id": "1959", "path": "output2\\js\\Hard\\1959-sort-items-by-groups-respecting-dependencies.js", "hypo_code": "var sortItems = function(n, m, group, beforeItems) {\n    let groupGraph = new Map();\n    let itemGraph = new Map();\n    let groupDegree = new Map();\n    let itemDegree = new Map();\n    let groupItems = new Map();\n    let id = m;\n    for(let i = 0; i < n; i++){\n        if(group[i] == -1){\n            group[i] = id;\n            id++;\n        }\n        if(!groupItems.has(group[i])){\n            groupItems.set(group[i], []);\n        }\n        groupItems.get(group[i]).push(i);\n        groupDegree.set(group[i], 0);\n        itemDegree.set(i, 0);\n        groupGraph.set(group[i], []);\n        itemGraph.set(i, []);\n    }\n    for(let i = 0; i < n; i++){\n        let curGroup = group[i];\n        for(let j of beforeItems[i]){\n            let prevGroup = group[j];\n            if(curGroup != prevGroup){\n                groupGraph.get(prevGroup).push(curGroup);\n                groupDegree.set(curGroup, groupDegree.get(curGroup) + 1);\n            }\n            itemGraph.get(j).push(i);\n            itemDegree.set(i, itemDegree.get(i) + 1);\n        }\n    }\n    let groupOrder = topologicalSort(groupGraph, groupDegree);\n    if(groupOrder.length == 0){\n        return [];\n    }\n    let ans = [];\n    for(let curGroup of groupOrder){\n        let items = groupItems.get(curGroup);\n        let itemOrder = topologicalSort(itemGraph, itemDegree, items);\n        if(itemOrder.length == 0){\n            return [];\n        }\n        ans.push(...itemOrder);\n    }\n    return ans;\n    \n    \n};"}
{"id": "1961", "path": "output2\\js\\Hard\\1961-minimum-moves-to-reach-target-with-rotations.js", "hypo_code": "var minimumMoves = function(grid) {\n    let n = grid.length;\n    let visited = new Set();\n    let queue = [[0, 0, 0, 0, 0]];\n    while(queue.length > 0){\n        let [r, c, d, moves, key] = queue.shift();\n        if(r == n - 1 && c == n - 2 && d == 0){\n            return moves;\n        }\n        if(visited.has(key)){\n            continue;\n        }\n        visited.add(key);\n        if(d == 0){\n            if(c + 1 < n && grid[r][c + 1] == 0){\n                queue.push([r, c + 1, d, moves + 1, getKey(r, c + 1, d)]);\n            }\n            if(r + 1 < n && grid[r + 1][c] == 0 && grid[r + 1][c + 1] == 0){\n                queue.push([r, c, 1, moves + 1, getKey(r, c, 1)]);\n                queue.push([r + 1, c, 1, moves + 1, getKey(r + 1, c, 1)]);\n            }\n        }\n        else{\n            if(r + 1 < n && grid[r + 1][c] == 0){\n                queue.push([r + 1, c, d, moves + 1, getKey(r + 1, c, d)]);\n            }\n            if(c + 1 < n && grid[r][c + 1] == 0 && grid[r + 1][c + 1] == 0){\n                queue.push([r, c, 0, moves + 1, getKey(r, c, 0)]);\n                queue.push([r, c + 1, 0, moves + 1, getKey(r, c + 1, 0)]);\n            }\n        }\n    }\n    return -1;\n    \n    \n};"}
{"id": "1962", "path": "output2\\js\\Hard\\1962-count-vowels-permutation.js", "hypo_code": "var countVowelPermutation = function(n) {\n    let dp = new Array(n + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(5).fill(0);\n    }\n    for(let i = 0; i < 5; i++){\n        dp[1][i] = 1;\n    }\n    for(let i = 2; i <= n; i++){\n        dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % 1000000007;\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 1000000007;\n        dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % 1000000007;\n        dp[i][3] = (dp[i - 1][2]) % 1000000007;\n        dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % 1000000007;\n    }\n    let ans = 0;\n    for(let i = 0; i < 5; i++){\n        ans = (ans + dp[n][i]) % 1000000007;\n    }\n    return ans;\n    \n};"}
{"id": "1963", "path": "output2\\js\\Hard\\1963-dice-roll-simulation.js", "hypo_code": "var dieSimulator = function(n, rollMax) {\n    let dp = new Array(n + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(6).fill(0);\n    }\n    for(let i = 0; i < 6; i++){\n        dp[1][i] = 1;\n    }\n    for(let i = 2; i <= n; i++){\n        for(let j = 0; j < 6; j++){\n            for(let k = 1; k <= rollMax[j]; k++){\n                if(i - k >= 0){\n                    let sum = 0;\n                    for(let l = 0; l < 6; l++){\n                        if(l != j){\n                            sum = (sum + dp[i - k][l]) % 1000000007;\n                        }\n                    }\n                    dp[i][j] = (dp[i][j] + sum) % 1000000007;\n                }\n            }\n        }\n    }\n    let ans = 0;\n    for(let i = 0; i < 6; i++){\n        ans = (ans + dp[n][i]) % 1000000007;\n    }\n    return ans;\n    \n};"}
{"id": "1964", "path": "output2\\js\\Hard\\1964-maximum-equal-frequency.js", "hypo_code": "var maxEqualFreq = function(nums) {\n    let freq = new Map();\n    let count = new Map();\n    let ans = 0;\n    for(let i = 0; i < nums.length; i++){\n        let num = nums[i];\n        let f = freq.get(num) || 0;\n        freq.set(num, f + 1);\n        let c = count.get(f) || 0;\n        count.set(f, c - 1);\n        c = count.get(f + 1) || 0;\n        count.set(f + 1, c + 1);\n        if(count.get(1) == i + 1){\n            ans = i + 1;\n        }\n        else if(count.get(i + 1) == 1){\n            ans = i + 1;\n        }\n        else if(count.get(i) * (i) == i + 1){\n            ans = i + 1;\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1965", "path": "output2\\js\\Hard\\1965-maximum-profit-in-job-scheduling.js", "hypo_code": "var jobScheduling = function(startTime, endTime, profit) {\n    let n = startTime.length;\n    let jobs = [];\n    for(let i = 0; i < n; i++){\n        jobs.push([startTime[i], endTime[i], profit[i]]);\n    }\n    jobs.sort((a, b) => a[1] - b[1]);\n    let dp = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        let [start, end, profit] = jobs[i - 1];\n        let index = binarySearch(jobs, start);\n        dp[i] = Math.max(dp[i - 1], profit + dp[index]);\n    }\n    return dp[n];\n    \n    \n};"}
{"id": "1966", "path": "output2\\js\\Hard\\1966-tiling-a-rectangle-with-the-fewest-squares.js", "hypo_code": "var tilingRectangle = function(n, m) {\n    let dp = new Array(n + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(m + 1).fill(0);\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            if(i == j){\n                dp[i][j] = 1;\n            }\n            else{\n                dp[i][j] = Infinity;\n                for(let k = 1; k <= i / 2; k++){\n                    dp[i][j] = Math.min(dp[i][j], dp[k][j] + dp[i - k][j]);\n                }\n                for(let k = 1; k <= j / 2; k++){\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[i][j - k]);\n                }\n            }\n        }\n    }\n    return dp[n][m];\n    \n};"}
{"id": "1967", "path": "output2\\js\\Hard\\1967-check-if-it-is-a-good-array.js", "hypo_code": "var isGoodArray = function(nums) {\n    let gcd = (a, b) => {\n        if(a == 0){\n            return b;\n        }\n        return gcd(b % a, a);\n    }\n    let g = nums[0];\n    for(let i = 1; i < nums.length; i++){\n        g = gcd(g, nums[i]);\n    }\n    return g == 1;\n    \n};"}
{"id": "1968", "path": "output2\\js\\Hard\\1968-maximum-score-words-formed-by-letters.js", "hypo_code": "var maxScoreWords = function(words, letters, score) {\n    let freq = new Map();\n    for(let i = 0; i < letters.length; i++){\n        let c = freq.get(letters[i]) || 0;\n        freq.set(letters[i], c + 1);\n    }\n    let ans = 0;\n    let dfs = function(i, freq, score){\n        if(i == words.length){\n            return 0;\n        }\n        let f = new Map(freq);\n        let s = 0;\n        for(let j = 0; j < words[i].length; j++){\n            let c = f.get(words[i][j]) || 0;\n            if(c == 0){\n                return dfs(i + 1, freq, score);\n            }\n            f.set(words[i][j], c - 1);\n            s += score[words[i].charCodeAt(j) - 97];\n        }\n        return Math.max(s + dfs(i + 1, f, score), dfs(i + 1, freq, score));\n    }\n    return dfs(0, freq, score);\n    \n};"}
{"id": "1969", "path": "output2\\js\\Hard\\1969-minimum-moves-to-move-a-box-to-their-target-location.js", "hypo_code": "var minPushBox = function(grid) {\n    let n = grid.length;\n    let m = grid[0].length;\n    let box = null;\n    let target = null;\n    let player = null;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            if(grid[i][j] == 'B'){\n                box = [i, j];\n            }\n            if(grid[i][j] == 'T'){\n                target = [i, j];\n            }\n            if(grid[i][j] == 'S'){\n                player = [i, j];\n            }\n        }\n    }\n    let visited = new Set();\n    let queue = [[player[0], player[1], box[0], box[1], 0]];\n    while(queue.length > 0){\n        let [r, c, br, bc, moves] = queue.shift();\n        if(br == target[0] && bc == target[1]){\n            return moves;\n        }\n        if(visited.has(getKey(r, c, br, bc))){\n            continue;\n        }\n        visited.add(getKey(r, c, br, bc));\n        for(let [dr, dc] of [[0, 1], [0, -1], [1, 0], [-1, 0]]){\n            let nr = r + dr;\n            let nc = c + dc;\n            if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] != '#'){\n                if(nr == br && nc == bc){\n                    let nbr = br + dr;\n                    let nbc = bc + dc;\n                    if(nbr >= 0 && nbr < n && nbc >= 0 && nbc < m && grid[nbr][nbc] != '#'){\n                        queue.push([nr, nc, nbr, nbc, moves + 1]);\n                    }\n                }\n                else{\n                    queue.push([nr, nc, br, bc, moves]);\n                }\n            }\n        }\n    }\n    return -1;\n    \n};"}
{"id": "1970", "path": "output2\\js\\Hard\\1970-number-of-ways-to-stay-in-the-same-place-after-some-steps.js", "hypo_code": "var numWays = function(steps, arrLen) {\n    let dp = new Array(steps + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(arrLen).fill(0);\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i <= steps; i++){\n        for(let j = 0; j < arrLen; j++){\n            dp[i][j] = dp[i - 1][j];\n            if(j - 1 >= 0){\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % 1000000007;\n            }\n            if(j + 1 < arrLen){\n                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % 1000000007;\n            }\n        }\n    }\n    return dp[steps][0];\n    \n};"}
{"id": "1971", "path": "output2\\js\\Hard\\1971-palindrome-partitioning-iii.js", "hypo_code": "var palindromePartition = function(s, k) {\n    let n = s.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(k + 1).fill(0);\n    }\n    let cost = new Array(n + 1);\n    for(let i = 0; i < cost.length; i++){\n        cost[i] = new Array(n + 1).fill(0);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = i + 1; j < n; j++){\n            let l = i;\n            let r = j;\n            while(l < r){\n                if(s[l] != s[r]){\n                    cost[i][j]++;\n                }\n                l++;\n                r--;\n            }\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        dp[i][1] = cost[0][i - 1];\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 2; j <= k; j++){\n            dp[i][j] = Infinity;\n            for(let l = 1; l <= i; l++){\n                dp[i][j] = Math.min(dp[i][j], dp[l][j - 1] + cost[l][i - 1]);\n            }\n        }\n    }\n    return dp[n][k];\n    \n};"}
{"id": "1972", "path": "output2\\js\\Hard\\1972-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.js", "hypo_code": "var minFlips = function(mat) {\n    let n = mat.length;\n    let m = mat[0].length;\n    let dp = new Array(n);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(m).fill(0);\n    }\n    let ans = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            if(mat[i][j] == 1){\n                ans++;\n            }\n        }\n    }\n    if(ans == 0){\n        return 0;\n    }\n    let q = [];\n    q.push(mat);\n    let visited = new Set();\n    visited.add(JSON.stringify(mat));\n    let level = 0;\n    while(q.length > 0){\n        let size = q.length;\n        while(size > 0){\n            let curr = q.shift();\n            for(let i = 0; i < n; i++){\n                for(let j = 0; j < m; j++){\n                    let temp = JSON.parse(JSON.stringify(curr));\n                    temp[i][j] = 1 - temp[i][j];\n                    if(i - 1 >= 0){\n                        temp[i - 1][j] = 1 - temp[i - 1][j];\n                    }\n                    if(i + 1 < n){\n                        temp[i + 1][j] = 1 - temp[i + 1][j];\n                    }\n                    if(j - 1 >= 0){\n                        temp[i][j - 1] = 1 - temp[i][j - 1];\n                    }\n                    if(j + 1 < m){\n                        temp[i][j + 1] = 1 - temp[i][j + 1];\n                    }\n                    if(JSON.stringify(temp) == JSON.stringify(dp)){\n                        return level + 1;\n                    }\n                    if(!visited.has(JSON.stringify(temp))){\n                        visited.add(JSON.stringify(temp));\n                        q.push(temp);\n                    }\n                }\n            }\n            size--;\n        }\n        level++;\n    }\n    return -1;\n    \n};"}
{"id": "1973", "path": "output2\\js\\Hard\\1973-minimum-falling-path-sum-ii.js", "hypo_code": "var minFallingPathSum = function(grid) {\n    let n = grid.length;\n    let dp = new Array(n);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            dp[0][j] = grid[0][j];\n        }\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 0; j < n; j++){\n            let min = Infinity;\n            for(let k = 0; k < n; k++){\n                if(k != j){\n                    min = Math.min(min, dp[i - 1][k]);\n                }\n            }\n            dp[i][j] = min + grid[i][j];\n        }\n    }\n    let ans = Infinity;\n    for(let i = 0; i < n; i++){\n        ans = Math.min(ans, dp[n - 1][i]);\n    }\n    return ans;\n    \n};"}
{"id": "1974", "path": "output2\\js\\Hard\\1974-shortest-path-in-a-grid-with-obstacles-elimination.js", "hypo_code": "var shortestPath = function(grid, k) {\n    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Set();\n    let queue = [[0, 0, 0, 0]];\n    while(queue.length > 0){\n        let [r, c, moves, obstacles] = queue.shift();\n        if(r == n - 1 && c == m - 1){\n            return moves;\n        }\n        let key = getKey(r, c, obstacles);\n        if(visited.has(key)){\n            continue;\n        }\n        visited.add(key);\n        for(let [nr, nc] of [[r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]]){\n            if(nr >= 0 && nr < n && nc >= 0 && nc < m){\n                if(grid[nr][nc] == 0){\n                    queue.push([nr, nc, moves + 1, obstacles]);\n                }\n                else if(obstacles < k){\n                    queue.push([nr, nc, moves + 1, obstacles + 1]);\n                }\n            }\n        }\n    }\n    return -1;\n    \n};"}
{"id": "1975", "path": "output2\\js\\Hard\\1975-maximum-candies-you-can-get-from-boxes.js", "hypo_code": "var maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {\n    let n = status.length;\n    let visited = new Array(n).fill(false);\n    let queue = [];\n    for(let i = 0; i < initialBoxes.length; i++){\n        if(status[initialBoxes[i]] == 1){\n            queue.push(initialBoxes[i]);\n        }\n    }\n    let res = 0;\n    while(queue.length > 0){\n        let box = queue.shift();\n        if(visited[box]){\n            continue;\n        }\n        visited[box] = true;\n        res += candies[box];\n        for(let i = 0; i < keys[box].length; i++){\n            status[keys[box][i]] = 1;\n            if(!visited[keys[box][i]]){\n                queue.push(keys[box][i]);\n            }\n        }\n        for(let i = 0; i < containedBoxes[box].length; i++){\n            if(status[containedBoxes[box][i]] == 1){\n                queue.push(containedBoxes[box][i]);\n            }\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "1976", "path": "output2\\js\\Hard\\1976-number-of-paths-with-max-score.js", "hypo_code": "var pathsWithMaxScore = function(board) {\n    let n = board.length;\n    let dp = new Array(n);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    let mod = 1000000007;\n    let paths = new Array(n);\n    for(let i = 0; i < paths.length; i++){\n        paths[i] = new Array(n).fill(0);\n    }\n    paths[n - 1][n - 1] = 1;\n    for(let i = n - 1; i >= 0; i--){\n        for(let j = n - 1; j >= 0; j--){\n            if(board[i][j] == 'X'){\n                continue;\n            }\n            if(i == n - 1 && j == n - 1){\n                continue;\n            }\n            let max = 0;\n            let count = 0;\n            if(i + 1 < n && j + 1 < n){\n                if(dp[i + 1][j + 1] > max){\n                    max = dp[i + 1][j + 1];\n                    count = paths[i + 1][j + 1];\n                }\n                else if(dp[i + 1][j + 1] == max){\n                    count = (count + paths[i + 1][j + 1]) % mod;\n                }\n            }\n            if(i + 1 < n){\n                if(dp[i + 1][j] > max){\n                    max = dp[i + 1][j];\n                    count = paths[i + 1][j];\n                }\n                else if(dp[i + 1][j] == max){\n                    count = (count + paths[i + 1][j]) % mod;\n                }\n            }\n            if(j + 1 < n){\n                if(dp[i][j + 1] > max){\n                    max = dp[i][j + 1];\n                    count = paths[i][j + 1];\n                }\n                else if(dp[i][j + 1] == max){\n                    count = (count + paths[i][j + 1]) % mod;\n                }\n            }\n            dp[i][j] = max + (board[i][j] == 'E' ? 0 : board[i][j].charCodeAt(0) - 48);\n            paths[i ][j] = count;\n        }\n    }\n    \n};"}
{"id": "1977", "path": "output2\\js\\Hard\\1977-verbal-arithmetic-puzzle.js", "hypo_code": "var isSolvable = function(words, result) {\n    let n = words.length;\n    let m = result.length;\n    let max = Math.max(n, m);\n    let dp = new Array(max);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(10).fill(false);\n    }\n    let used = new Array(10).fill(false);\n    let dfs = (index, carry) => {\n        if(index == max){\n            return carry == 0;\n        }\n        let i = n - 1 - index;\n        let j = m - 1 - index;\n        let sum = carry;\n        if(i >= 0){\n            sum += words[i].length - 1 - index;\n        }\n        if(j >= 0){\n            sum -= result[j].length - 1 - index;\n        }\n        if(sum < 0){\n            return false;\n        }\n        if(dp[index][sum]){\n            return false;\n        }\n        for(let k = 0; k < 10; k++){\n            if(used[k]){\n                continue;\n            }\n            used[k] = true;\n            if(i >= 0 && words[i][index] == k){\n                if(dfs(index + 1, carry)){\n                    return true;\n                }\n            }\n            else if(j >= 0 && result[j][index] == k){\n                if(dfs(index + 1, carry + 1)){\n                    return true;\n                }\n            }\n            else if(i < 0 || j < 0 || words[i][index] != k && result[j][index] != k){\n                if(dfs(index + 1, carry)){\n                    return true;\n                }\n            }\n            used[k] = false;\n        }\n        dp[index][sum] = true;\n        return false;\n    }\n    return dfs(0, 0);\n    \n};"}
{"id": "1978", "path": "output2\\js\\Hard\\1978-minimum-insertion-steps-to-make-a-string-palindrome.js", "hypo_code": "var minInsertions = function(s) {\n    let n = s.length;\n    let dp = new Array(n);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    for(let i = 0; i < n; i++){\n        dp[i][i] = 0;\n    }\n    for(let i = 0; i < n - 1; i++){\n        if(s[i] == s[i + 1]){\n            dp[i][i + 1] = 0;\n        }else{\n            dp[i][i + 1] = 1;\n        }\n    }\n    for(let i = 2; i < n; i++){\n        for(let j = 0; j < n - i; j++){\n            if(s[j] == s[j + i]){\n                dp[j][j + i] = dp[j + 1][j + i - 1];\n            }else{\n                dp[j][j + i] = Math.min(dp[j + 1][j + i], dp[j][j + i - 1]) + 1;\n            }\n        }\n    }\n    return dp[0][n - 1];\n    \n};"}
{"id": "1979", "path": "output2\\js\\Hard\\1979-distinct-echo-substrings.js", "hypo_code": "var distinctEchoSubstrings = function(text) {\n    let n = text.length;\n    let dp = new Array(n);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    let ans = 0;\n    let set = new Set();\n    for(let i = 0; i < n; i++){\n        for(let j = i + 1; j < n; j++){\n            if(text[i] == text[j]){\n                if(i == 0 || j == n - 1){\n                    dp[i][j] = 1;\n                }else if(dp[i - 1][j + 1] == 1){\n                    dp[i][j] = 1;\n                }\n            }\n            if(dp[i][j] == 1){\n                let str = text.substring(i, j + 1);\n                if(!set.has(str)){\n                    set.add(str);\n                    ans++;\n                }\n            }\n        }\n    }\n    return ans;\n    \n};"}
{"id": "1980", "path": "output2\\js\\Hard\\1980-minimum-distance-to-type-a-word-using-two-fingers.js", "hypo_code": "var minimumDistance = function(word) {\n    let n = word.length;\n    let dp = new Array(n);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(26);\n        for(let j = 0; j < dp[i].length; j++){\n            dp[i][j] = new Array(26).fill(0);\n        }\n    }\n    let dis = new Array(26);\n    for(let i = 0; i < dis.length; i++){\n        dis[i] = new Array(26).fill(0);\n    }\n    for(let i = 0; i < 26; i++){\n        for(let j = 0; j < 26; j++){\n            dis[i][j] = Math.floor(i / 6) - Math.floor(j / 6) + Math.abs(i % 6 - j % 6);\n        }\n    }\n    for(let i = 0; i < n; i++){\n        let cur = word.charCodeAt(i) - 65;\n        for(let j = 0; j < 26; j++){\n            for(let k = 0; k < 26; k++){\n                if(i == 0){\n                    dp[i][j][k] = dis[j][cur];\n                }else{\n                    dp[i][j][k] = Math.min(dp[i - 1][j][cur], dp[i - 1][k][cur]) + dis[k][cur];\n                }\n            }\n        }\n    }\n    let ans = Number.MAX_VALUE;\n    for(let i = 0; i < 26; i++){\n        for(let j = 0; j < 26; j++){\n            ans = Math.min(ans, dp[n - 1][i][j]);\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "1981", "path": "output2\\js\\Hard\\1981-minimum-number-of-taps-to-open-to-water-a-garden.js", "hypo_code": "var minTaps = function(n, ranges) {\n    let dp = new Array(n + 1).fill(Infinity);\n    dp[0] = 0;\n    for(let i = 0; i <= n; i++){\n        let left = Math.max(0, i - ranges[i]);\n        let right = Math.min(n, i + ranges[i]);\n        for(let j = left; j <= right; j++){\n            dp[j] = Math.min(dp[j], dp[left] + 1);\n        }\n    }\n    return dp[n] == Infinity ? -1 : dp[n];\n    \n    \n};"}
{"id": "1982", "path": "output2\\js\\Hard\\1982-reverse-subarray-to-maximize-array-value.js", "hypo_code": "var maxValueAfterReverse = function(nums) {\n    let ans = 0;\n    let max = -Infinity;\n    let min = Infinity;\n    let n = nums.length;\n    for(let i = 0; i < n - 1; i++){\n        ans += Math.abs(nums[i] - nums[i + 1]);\n        max = Math.max(max, Math.max(nums[i], nums[i + 1]));\n        min = Math.min(min, Math.min(nums[i], nums[i + 1]));\n    }\n    let ans1 = ans;\n    let ans2 = ans;\n    for(let i = 0; i < n - 1; i++){\n        ans1 = Math.max(ans1, ans - Math.abs(nums[i] - nums[i + 1]) + Math.abs(nums[i] - max));\n        ans1 = Math.max(ans1, ans - Math.abs(nums[i] - nums[i + 1]) + Math.abs(nums[i + 1] - max));\n        ans2 = Math.max(ans2, ans - Math.abs(nums[i] - nums[i + 1]) + Math.abs(nums[i] - min));\n        ans2 = Math.max(ans2, ans - Math.abs(nums[i] - nums[i + 1]) + Math.abs(nums[i + 1] - min));\n    }\n    return Math.max(ans1, ans2);\n    \n    \n};"}
{"id": "1983", "path": "output2\\js\\Hard\\1983-minimum-difficulty-of-a-job-schedule.js", "hypo_code": "var minDifficulty = function(jobDifficulty, d) {\n    let n = jobDifficulty.length;\n    if(n < d) return -1;\n    let dp = new Array(d + 1).fill(0).map(() => new Array(n + 1).fill(Infinity));\n    dp[0][0] = 0;\n    for(let i = 1; i <= d; i++){\n        for(let j = i; j <= n; j++){\n            let max = 0;\n            for(let k = j - 1; k >= i - 1; k--){\n                max = Math.max(max, jobDifficulty[k]);\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + max);\n            }\n        }\n    }\n    return dp[d][n];\n    \n};"}
{"id": "1984", "path": "output2\\js\\Hard\\1984-jump-game-v.js", "hypo_code": "var maxJumps = function(arr, d) {\n    let n = arr.length;\n    let dp = new Array(n).fill(0);\n    let max = 0;\n    for(let i = 0; i < n; i++){\n        max = Math.max(max, dfs(arr, d, i, dp));\n    }\n    return max;\n    \n    \n};"}
{"id": "1985", "path": "output2\\js\\Hard\\1985-jump-game-iv.js", "hypo_code": "var minJumps = function(arr) {\n    let map = new Map();\n    for(let i = 0; i < arr.length; i++){\n        if(map.has(arr[i])){\n            map.get(arr[i]).push(i);\n        }else{\n            map.set(arr[i], [i]);\n        }\n    }\n    let visited = new Set();\n    let queue = [0];\n    let step = 0;\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let curr = queue.shift();\n            if(curr == arr.length - 1) return step;\n            if(!visited.has(curr)){\n                visited.add(curr);\n                if(curr - 1 >= 0) queue.push(curr - 1);\n                if(curr + 1 < arr.length) queue.push(curr + 1);\n                if(map.has(arr[curr])){\n                    for(let j of map.get(arr[curr])){\n                        queue.push(j);\n                    }\n                    map.delete(arr[curr]);\n                }\n            }\n        }\n        step++;\n    }\n    return step;\n    \n};"}
{"id": "1986", "path": "output2\\js\\Hard\\1986-maximum-students-taking-exam.js", "hypo_code": "var maxStudents = function(seats) {\n    let m = seats.length;\n    let n = seats[0].length;\n    let dp = new Array(m + 1);\n    for(let i = 0; i <= m; i++){\n        dp[i] = new Array(1 << n).fill(0);\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 0; j < (1 << n); j++){\n            if(isValid(seats[i - 1], j)){\n                for(let k = 0; k < (1 << n); k++){\n                    if((j & k) == 0){\n                        dp[i][j] = Math.max(dp[i][j], dp[i - 1][k] + count(j));\n                    }\n                }\n            }\n        }\n    }\n    return Math.max(...dp[m]);\n    \n    \n};"}
{"id": "1987", "path": "output2\\js\\Hard\\1987-construct-target-array-with-multiple-sums.js", "hypo_code": "var isPossible = function(target) {\n    let sum = 0;\n    let max = 0;\n    let maxIndex = 0;\n    for(let i = 0; i < target.length; i++){\n        sum += target[i];\n        if(target[i] > max){\n            max = target[i];\n            maxIndex = i;\n        }\n    }\n    if(sum == target.length) return true;\n    if(sum < target.length) return false;\n    while(sum > target.length){\n        let prevMax = max;\n        sum -= max;\n        if(sum == 1) return true;\n        max = max - sum;\n        if(max <= 0 || max == prevMax) return false;\n        sum += max;\n    }\n    return true;\n    \n};"}
{"id": "1988", "path": "output2\\js\\Hard\\1988-count-all-valid-pickup-and-delivery-options.js", "hypo_code": "var countOrders = function(n) {\n    let mod = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    for(let i = 1; i <= n; i++){\n        dp[i] = dp[i - 1] * (2 * i - 1) * (2 * i) % mod;\n    }\n    return dp[n];\n    \n};"}
{"id": "1989", "path": "output2\\js\\Hard\\1989-largest-multiple-of-three.js", "hypo_code": "var largestMultipleOfThree = function(digits) {\n    let sum = 0;\n    let count = new Array(10).fill(0);\n    for(let i = 0; i < digits.length; i++){\n        sum += digits[i];\n        count[digits[i]]++;\n    }\n    if(sum % 3 == 1){\n        if(count[1] > 0){\n            count[1]--;\n        }else if(count[4] > 0){\n            count[4]--;\n        }else if(count[7] > 0){\n            count[7]--;\n        }else if(count[2] > 1){\n            count[2] -= 2;\n        }else if(count[5] > 1){\n            count[5] -= 2;\n        }else if(count[8] > 1){\n            count[8] -= 2;\n        }else if(count[2] > 0 && count[5] > 0){\n            count[2]--;\n            count[5]--;\n        }else if(count[2] > 0 && count[8] > 0){\n            count[2]--;\n            count[8]--;\n        }else if(count[5] > 0 && count[8] > 0){\n            count[5]--;\n            count[8]--;\n        }else{\n            return \"\";\n        }\n    }else if(sum % 3 == 2){\n        if(count[2] > 0){\n            count[2]--;\n        }else if(count[5] > 0){\n            count[5]--;\n        }else if(count[8] > 0){\n            count[8]--;\n        }else if(count[1] > 1){\n            count[1] -= 2;\n        }else if(count[4] > 1){\n            count[4] -= 2;\n        }else if(count[7] > 1){\n            count[7] -= 2;\n        }else if(count[1] > 0 && count[4] > 0){\n            count[1]--;\n            count[4]--;\n        }else if(count[1] > 0 && count[7] > 0){\n            count[1]--;\n            count[7]--;\n        }else if(count[4] > 0 && count[7] > 0){\n            count[4]--;\n            count[7]--;\n        }else{\n            return \"\";\n        }\n    }\n    let res = \"\";\n    for(let i = 9; i >= 0; i--){\n        while(count[i] > 0){\n            res += i;\n            count[i]--;\n        }\n    }\n    if(res.length > 0 && res[0] == '0') return \"0\";\n    return res;\n    \n    \n};"}
{"id": "1990", "path": "output2\\js\\Hard\\1990-minimum-cost-to-make-at-least-one-valid-path-in-a-grid.js", "hypo_code": "var minCost = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let dp = new Array(m);\n    for(let i = 0; i < m; i++){\n        dp[i] = new Array(n).fill(Number.MAX_VALUE);\n    }\n    let queue = [[0, 0, 0]];\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    while(queue.length > 0){\n        let curr = queue.shift();\n        let x = curr[0];\n        let y = curr[1];\n        let cost = curr[2];\n        if(x == m - 1 && y == n - 1) return cost;\n        if(cost < dp[x][y]){\n            dp[x][y] = cost;\n            for(let i = 0; i < 4; i++){\n                let nx = x + dirs[i][0];\n                let ny = y + dirs[i][1];\n                if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                    if(grid[x][y] == i + 1){\n                        queue.unshift([nx, ny, cost]);\n                    }else{\n                        queue.push([nx, ny, cost + 1]);\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n    \n};"}
{"id": "1991", "path": "output2\\js\\Hard\\1991-maximum-sum-bst-in-binary-tree.js", "hypo_code": "var maxSumBST = function(root) {\n    let max = 0;\n    let stack = [];\n    let node = root;\n    while(node != null || stack.length > 0){\n        while(node != null){\n            stack.push(node);\n            node = node.left;\n        }\n        node = stack.pop();\n        if(isBST(node)){\n            max = Math.max(max, sum(node));\n        }\n        node = node.right;\n    }\n    return max;\n    \n};"}
{"id": "1992", "path": "output2\\js\\Hard\\1992-frog-position-after-t-seconds.js", "hypo_code": "var frogPosition = function(n, edges, t, target) {\n    let map = new Map();\n    for(let i = 0; i < edges.length; i++){\n        let [a, b] = edges[i];\n        if(map.has(a)){\n            map.get(a).push(b);\n        }else{\n            map.set(a, [b]);\n        }\n        if(map.has(b)){\n            map.get(b).push(a);\n        }else{\n            map.set(b, [a]);\n        }\n    }\n    let visited = new Set();\n    let queue = [1];\n    let step = 0;\n    while(queue.length > 0){\n        let size = queue.length;\n        for(let i = 0; i < size; i++){\n            let curr = queue.shift();\n            if(curr == target){\n                if(step == t || map.get(curr).length == 1) return 1;\n                else return 0;\n            }\n            if(!visited.has(curr)){\n                visited.add(curr);\n                let next = map.get(curr);\n                for(let j = 0; j < next.length; j++){\n                    if(!visited.has(next[j])){\n                        queue.push(next[j]);\n                    }\n                }\n            }\n        }\n        step++;\n    }\n    return 0;\n    \n};"}
{"id": "1993", "path": "output2\\js\\Hard\\1993-maximum-performance-of-a-team.js", "hypo_code": "var maxPerformance = function(n, speed, efficiency, k) {\n    let mod = 1000000007;\n    let arr = [];\n    for(let i = 0; i < n; i++){\n        arr.push([speed[i], efficiency[i]]);\n    }\n    arr.sort((a, b) => b[1] - a[1]);\n    let pq = new PriorityQueue();\n    let sum = 0;\n    let ans = 0;\n    for(let i = 0; i < n; i++){\n        pq.push(arr[i][0]);\n        sum += arr[i][0];\n        if(pq.size() > k){\n            sum -= pq.pop();\n        }\n        ans = Math.max(ans, sum * arr[i][1]);\n    }\n    return ans % mod;\n    \n    \n};"}
{"id": "1994", "path": "output2\\js\\Hard\\1994-pizza-with-3n-slices.js", "hypo_code": "var maxSizeSlices = function(slices) {\n    let n = slices.length;\n    let k = Math.floor(n / 3);\n    let dp = new Array(k + 1);\n    for(let i = 0; i <= k; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    for(let i = 1; i <= k; i++){\n        for(let j = i - 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i][j - 1], (j >= 2 ? dp[i - 1][j - 2] : 0) + slices[j]);\n        }\n    }\n    let ans = dp[k][n - 1];\n    for(let i = 1; i <= k; i++){\n        for(let j = i; j < n; j++){\n            dp[i][j] = Math.max(dp[i][j - 1], (j >= 2 ? dp[i - 1][j - 2] : 0) + slices[j]);\n        }\n    }\n    return Math.max(ans, dp[k][n - 2]);\n    \n    \n};"}
{"id": "1995", "path": "output2\\js\\Hard\\1995-longest-happy-prefix.js", "hypo_code": "var longestPrefix = function(s) {\n    let n = s.length;\n    let lps = new Array(n).fill(0);\n    let i = 1;\n    let j = 0;\n    while(i < n){\n        if(s[i] == s[j]){\n            j++;\n            lps[i] = j;\n            i++;\n        }\n        else{\n            if(j != 0){\n                j = lps[j - 1];\n            }\n            else{\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return s.substring(0, lps[n - 1]);\n\n    \n};"}
{"id": "1996", "path": "output2\\js\\Hard\\1996-find-all-good-strings.js", "hypo_code": "var findGoodStrings = function(n, s1, s2, evil) {\n    let mod = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    for(let i = 1; i <= n; i++){\n        dp[i] = dp[i - 1] * (2 * i - 1) * (2 * i) % mod;\n    }\n    return dp[n];\n    \n};"}
{"id": "1997", "path": "output2\\js\\Hard\\1997-reducing-dishes.js", "hypo_code": "var maxSatisfaction = function(satisfaction) {\n    satisfaction.sort((a, b) => b - a);\n    let n = satisfaction.length;\n    let sum = 0;\n    let ans = 0;\n    for(let i = 0; i < n; i++){\n        sum += satisfaction[i];\n        if(sum < 0) break;\n        ans += sum;\n    }\n    return ans;\n    \n};"}
{"id": "1998", "path": "output2\\js\\Hard\\1998-stone-game-iii.js", "hypo_code": "var stoneGameIII = function(stoneValue) {\n    let n = stoneValue.length;\n    let dp = new Array(n + 1).fill(0);\n    for(let i = n - 1; i >= 0; i--){\n        let sum = 0;\n        let max = -Infinity;\n        for(let j = i; j < i + 3 && j < n; j++){\n            sum += stoneValue[j];\n            max = Math.max(max, sum - dp[j + 1]);\n        }\n        dp[i] = max;\n    }\n    if(dp[0] > 0) return \"Alice\";\n    if(dp[0] < 0) return \"Bob\";\n    return \"Tie\";\n    \n};"}
{"id": "1999", "path": "output2\\js\\Hard\\1999-number-of-ways-to-paint-n-3-grid.js", "hypo_code": "var numOfWays = function(n) {\n    let mod = 1000000007;\n    let dp = new Array(n + 1);\n    for (let i = 0; i <= n; i++) {\n        dp[i] = new Array(3).fill(0);\n    }\n    dp[1][0] = 6;\n    dp[1][1] = 6;\n    for (let i = 2; i <= n; i++) {\n        dp[i][0] = (2 * dp[i - 1][0] + 2 * dp[i - 1][1]) % mod;\n        dp[i][1] = (2 * dp[i - 1][0] + 3 * dp[i - 1][1]) % mod;\n    }\n    return (dp[n][0] + dp[n][1]) % mod;\n};"}
{"id": "2000", "path": "output2\\js\\Hard\\2000-restore-the-array.js", "hypo_code": "var numberOfArrays = function(s, k) {\n    let mod = 1000000007;\n    let dp = new Array(s.length + 1).fill(0);\n    dp[0] = 1;\n    for(let i = 1; i <= s.length; i++){\n        for(let j = 1; j <= k && j <= i; j++){\n            if(s[i - j] == '0'){\n                continue;\n            }\n            let num = parseInt(s.substring(i - j, i));\n            if(num <= k){\n                dp[i] = (dp[i] + dp[i - j]) % mod;\n            }\n        }\n    }\n    return dp[s.length];\n    \n};"}
{"id": "2001", "path": "output2\\js\\Hard\\2001-build-array-where-you-can-find-the-maximum-exactly-k-comparisons.js", "hypo_code": "var numOfArrays = function(n, m, k) {\n    let mod = 1000000007;\n    let dp = new Array(n + 1);\n    for (let i = 0; i <= n; i++) {\n        dp[i] = new Array(m + 1);\n        for (let j = 0; j <= m; j++) {\n            dp[i][j] = new Array(k + 1).fill(0);\n        }\n    }\n    for (let j = 1; j <= m; j++) {\n        dp[1][j][1] = 1;\n    }\n    for (let i = 2; i <= n; i++) {\n        for (let j = 1; j <= m; j++) {\n            for (let l = 1; l <= k; l++) {\n                dp[i][j][l] = ((j * dp[i - 1][j][l]) % mod + dp[i - 1][j - 1][l - 1]) % mod;\n                for (let p = 1; p < j; p++) {\n                    dp[i][j][l] = (dp[i][j][l] + dp[i - 1][p][l - 1]) % mod;\n                }\n            }\n        }\n    }\n    let result = 0;\n    for (let j = 1; j <= m; j++) {\n        result = (result + dp[n][j][k]) % mod;\n    }\n    return result;\n};"}
{"id": "2002", "path": "output2\\js\\Hard\\2002-constrained-subsequence-sum.js", "hypo_code": "var constrainedSubsetSum = function(nums, k) {\n    let n = nums.length;\n    let dp = new Array(n).fill(0);\n    dp[0] = nums[0];\n    let ans = dp[0];\n    let q = [];\n    q.push(0);\n    for(let i = 1; i < n; i++){\n        dp[i] = nums[i];\n        if(q.length > 0 && i - q[0] <= k){\n            dp[i] = Math.max(dp[i], dp[q[0]] + nums[i]);\n        }\n        while(q.length > 0 && dp[q[q.length - 1]] <= dp[i]){\n            q.pop();\n        }\n        q.push(i);\n        ans = Math.max(ans, dp[i]);\n    }\n    return ans;\n    \n};"}
{"id": "2003", "path": "output2\\js\\Hard\\2003-number-of-ways-to-wear-different-hats-to-each-other.js", "hypo_code": "var numberWays = function(hats) {\n    let mod = 1000000007;\n    let dp = new Array(41).fill(0);\n    dp[0] = 1;\n    for(let i = 1; i <= 40; i++){\n        dp[i] = dp[i - 1] * (2 * i - 1) * (2 * i) % mod;\n    }\n    return dp[40];\n    \n};"}
{"id": "2004", "path": "output2\\js\\Hard\\2004-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows.js", "hypo_code": "var kthSmallest = function(mat, k) {\n    let m = mat.length;\n    let n = mat[0].length;\n    let pq = new PriorityQueue();\n    let sum = 0;\n    for(let i = 0; i < m; i++){\n        sum += mat[i][0];\n    }\n    pq.push(sum);\n    let visited = new Set();\n    visited.add(sum);\n    let ans = 0;\n    while(k > 0){\n        let cur = pq.pop();\n        ans = cur;\n        for(let i = 0; i < m; i++){\n            for(let j = 0; j < n; j++){\n                let next = cur - mat[i][0] + mat[i][j];\n                if(!visited.has(next)){\n                    pq.push(next);\n                    visited.add(next);\n                }\n            }\n        }\n        k--;\n    }\n    return ans;\n    \n};"}
{"id": "2005", "path": "output2\\js\\Hard\\2005-number-of-ways-of-cutting-a-pizza.js", "hypo_code": "var ways = function(pizza, k) {\n    let mod = 1000000007;\n    let dp = new Array(k + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(pizza.length + 1);\n        for(let j = 0; j < dp[i].length; j++){\n            dp[i][j] = new Array(pizza[0].length + 1).fill(0);\n        }\n    }\n    let rowSum = new Array(pizza.length + 1);\n    for(let i = 0; i < rowSum.length; i++){\n        rowSum[i] = new Array(pizza[0].length + 1).fill(0);\n    }\n    let colSum = new Array(pizza.length + 1);\n    for(let i = 0; i < colSum.length; i++){\n        colSum[i] = new Array(pizza[0].length + 1).fill(0);\n    }\n    for(let i = pizza.length - 1; i >= 0; i--){\n        for(let j = pizza[0].length - 1; j >= 0; j--){\n            rowSum[i][j] = rowSum[i][j + 1];\n            colSum[i][j] = colSum[i + 1][j];\n            if(pizza[i][j] == 'A'){\n                rowSum[i][j]++;\n                colSum[i][j]++;\n            }\n        }\n    }\n    for(let i = 1; i <= pizza.length; i++){\n        for(let j = 1; j <= pizza[0].length; j++){\n            if(rowSum[i - 1][j - 1] > 0 || colSum[i - 1][j - 1] > 0){\n                dp[1][i][j] = 1;\n            }\n        }\n    }\n    for(let i = 2; i <= k; i++){\n        for(let j = 1; j <= pizza.length; j++){\n            for(let l = 1; l <= pizza[0].length; l++){\n                for(let m = j + 1; m <= pizza.length; m++){\n                    if(rowSum[m - 1][l - 1] > 0){\n                        dp[i][j][l] = (dp[i][j][l] + dp[i - 1][ m][l]) % mod;\n                    }\n                }\n                for(let m = l + 1; m <= pizza[0].length; m++){\n                        \n    \n};"}
{"id": "2006", "path": "output2\\js\\Hard\\2006-form-largest-integer-with-digits-that-add-up-to-target.js", "hypo_code": "var largestNumber = function(cost, target) {\n    let dp = new Array(target + 1).fill(0);\n    for(let i = 0; i < cost.length; i++){\n        for(let j = cost[i]; j <= target; j++){\n            dp[j] = Math.max(dp[j], dp[j - cost[i]] + 1);\n        }\n    }\n    if(dp[target] == 0){\n        return \"0\";\n    }\n    let res = \"\";\n    for(let i = 8; i >= 0; i--){\n        while(target >= cost[i] && dp[target] == dp[target - cost[i]] + 1){\n            res += (i + 1);\n            target -= cost[i];\n        }\n    }\n    return res;\n    \n};"}
{"id": "2007", "path": "output2\\js\\Hard\\2007-maximum-number-of-darts-inside-of-a-circular-dartboard.js", "hypo_code": "var numPoints = function(darts, r) {\n    let n = darts.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(n + 1).fill(0);\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            dp[i][j] = dp[i - 1][j - 1] + (distance(darts[i - 1], darts[j - 1]) <= r * r ? 1 : 0);\n        }\n    }\n    let ans = 0;\n    for(let i = 0; i <= n; i++){\n        for(let j = i + 1; j <= n; j++){\n            let cnt = dp[j][j] - dp[i][i] + dp[i][j] - dp[j][i];\n            ans = Math.max(ans, cnt);\n        }\n    }\n    return ans;\n    \n\n    \n};"}
{"id": "2008", "path": "output2\\js\\Hard\\2008-max-dot-product-of-two-subsequences.js", "hypo_code": "var maxDotProduct = function(nums1, nums2) {\n    let n = nums1.length;\n    let m = nums2.length;\n    let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(-Infinity));\n    dp[0][0] = 0;\n    let ans = -Infinity;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]);\n            dp[i][j] = Math.max(dp[i][j], dp[i - 1][j], dp[i][j - 1]);\n            ans = Math.max(ans, dp[i][j]);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2009", "path": "output2\\js\\Hard\\2009-cherry-pickup-ii.js", "hypo_code": "var cherryPickup = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let dp = new Array(m);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(n);\n        for(let j = 0; j < dp[i].length; j++){\n            dp[i][j] = new Array(n).fill(-1);\n        }\n    }\n    return Math.max(0, dfs(grid, 0, 0, n - 1, dp));\n    \n};"}
{"id": "2010", "path": "output2\\js\\Hard\\2010-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls.js", "hypo_code": "var getProbability = function(balls) {\n    let n = balls.length;\n    let sum = 0;\n    for(let i = 0; i < n; i++){\n        sum += balls[i];\n    }\n    let dp = new Array(sum + 1).fill(0);\n    dp[0] = 1;\n    for(let i = 0; i < n; i++){\n        for(let j = sum; j >= balls[i]; j--){\n            dp[j] += dp[j - balls[i]];\n        }\n    }\n    let total = dp[sum];\n    let half = sum / 2;\n    let ans = 0;\n    for(let i = 0; i <= half; i++){\n        ans += dp[i] * dp[sum - i];\n    }\n    return ans / total;\n    \n};"}
{"id": "2011", "path": "output2\\js\\Hard\\2011-paint-house-iii.js", "hypo_code": "var minCost = function(houses, cost, m, n, target) {\n    let dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0).map(() => new Array(target + 1).fill(Infinity)));\n    for(let i = 0; i <= m; i++){\n        dp[i][0][0] = 0;\n    }\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            for(let k = 1; k <= target; k++){\n                if(houses[i - 1] == 0){\n                    for(let p = 1; p <= n; p++){\n                        if(p == j){\n                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][p][k] + cost[i - 1][j - 1]);\n                        }else{\n                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][p][k - 1] + cost[i - 1][j - 1]);\n                        }\n                    }\n                }else{\n                    if(houses[i - 1] == j){\n                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k]);\n                    }else{\n                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k - 1]);\n                    }\n                }\n            }\n        }\n    }\n    let res = Infinity;\n    for(let i = 1; i <= n; i++){\n        res = Math.min(res, dp[m][i][target]);\n    }\n    return res == Infinity ? -1 : res;\n    \n};"}
{"id": "2012", "path": "output2\\js\\Hard\\2012-allocate-mailboxes.js", "hypo_code": "var minDistance = function(houses, k) {\n    houses.sort((a, b) => a - b);\n    let n = houses.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    for(let i = 0; i < n; i++){\n        for(let j = i; j < n; j++){\n            let mid = (i + j) >> 1;\n            for(let k = i; k <= j; k++){\n                dp[i][j] += Math.abs(houses[k] - houses[mid]);\n            }\n        }\n    }\n    let dp2 = new Array(n).fill(0).map(() => new Array(k).fill(0));\n    for(let i = 0; i < n; i++){\n        dp2[i][0] = dp[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < k; j++){\n            dp2[i][j] = Infinity;\n            for(let l = 0; l < i; l++){\n                dp2[i][j] = Math.min(dp2[i][j], dp2[l][j - 1] + dp[l + 1][i]);\n            }\n        }\n    }\n    return dp2[n - 1][k - 1];\n    \n};"}
{"id": "2014", "path": "output2\\js\\Hard\\2014-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree.js", "hypo_code": "var findCriticalAndPseudoCriticalEdges = function(n, edges) {\n    let m = edges.length;\n    for(let i = 0; i < m; i++){\n        edges[i].push(i);\n    }\n    edges.sort((a, b) => a[2] - b[2]);\n    let uf = new UnionFind(n);\n    let value = 0;\n    for(let i = 0; i < m; i++){\n        if(uf.union(edges[i][0], edges[i][1])){\n            value += edges[i][2];\n        }\n    }\n    let ans = [[], []];\n    for(let i = 0; i < m; i++){\n        let uf = new UnionFind(n);\n        let v = 0;\n        let cnt = 0;\n        for(let j = 0; j < m; j++){\n            if(i != j && uf.union(edges[j][0], edges[j][1])){\n                v += edges[j][2];\n                cnt++;\n            }\n        }\n        if(cnt != n - 1 || (cnt == n - 1 && v > value)){\n            ans[0].push(edges[i][3]);\n            continue;\n        }\n        uf = new UnionFind(n);\n        uf.union(edges[i][0], edges[i][1]);\n        v = edges[i][2];\n        cnt = 1;\n        for(let j = 0; j < m; j++){\n            if(i != j && uf.union(edges[j][0], edges[j][1])){\n                v += edges[j][2];\n                cnt++;\n            }\n        }\n        if(cnt == n - 1){\n            ans[1].push(edges[i][3]);\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "2015", "path": "output2\\js\\Hard\\2015-parallel-courses-ii.js", "hypo_code": "var minNumberOfSemesters = function(n, relations, k) {\n    let graph = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    let indegree = new Array(n).fill(0);\n    for(let i = 0; i < relations.length; i++){\n        let [u, v] = relations[i];\n        graph[u - 1][v - 1] = 1;\n        indegree[v - 1]++;\n    }\n    let q = new Queue();\n    for(let i = 0; i < n; i++){\n        if(indegree[i] == 0){\n            q.push(i);\n        }\n    }\n    let ans = 0;\n    while(!q.isEmpty()){\n        let size = Math.min(q.size(), k);\n        for(let i = 0; i < size; i++){\n            let cur = q.pop();\n            for(let j = 0; j < n; j++){\n                if(graph[cur][j] == 1){\n                    indegree[j]--;\n                    if(indegree[j] == 0){\n                        q.push(j);\n                    }\n                }\n            }\n        }\n        ans++;\n    }\n    return ans;\n    \n    \n};"}
{"id": "2016", "path": "output2\\js\\Hard\\2016-max-value-of-equation.js", "hypo_code": "var findMaxValueOfEquation = function(points, k) {\n    let n = points.length;\n    let ans = -Infinity;\n    let pq = new PriorityQueue();\n    for(let i = 0; i < n; i++){\n        while(pq.length > 0 && points[i][0] - pq.peek()[1] > k){\n            pq.pop();\n        }\n        if(pq.length > 0){\n            ans = Math.max(ans, pq.peek()[0] + points[i][1] + points[i][0]);\n        }\n        pq.push([points[i][1] - points[i][0], points[i][0]]);\n    }\n    return ans;\n    \n\n    \n};"}
{"id": "2017", "path": "output2\\js\\Hard\\2017-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits.js", "hypo_code": "var minInteger = function(num, k) {\n    let arr = num.split('');\n    let n = arr.length;\n    let res = '';\n    let i = 0;\n    while(i < n){\n        let min = arr[i];\n        let minIndex = i;\n        for(let j = i + 1; j < n && j <= i + k; j++){\n            if(arr[j] < min){\n                min = arr[j];\n                minIndex = j;\n            }\n        }\n        res += min;\n        k -= minIndex - i;\n        for(let j = minIndex; j > i; j--){\n            arr[j] = arr[j - 1];\n        }\n        i++;\n    }\n    return res;\n    \n    \n};"}
{"id": "2018", "path": "output2\\js\\Hard\\2018-stone-game-iv.js", "hypo_code": "var winnerSquareGame = function(n) {\n    let dp = new Array(n + 1).fill(false);\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j * j <= i; j++){\n            if(!dp[i - j * j]){\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n    \n};"}
{"id": "2019", "path": "output2\\js\\Hard\\2019-best-position-for-a-service-centre.js", "hypo_code": "var getMinDistSum = function(positions) {\n    let len = positions.length;\n    let x = 0;\n    let y = 0;\n    for (let i = 0; i < len; i++) {\n        x += positions[i][0];\n        y += positions[i][1];\n    }\n    x /= len;\n    y /= len;\n    let result = getDistance(x, y, positions);\n    let delta = 100;\n    while (delta > 0.00001) {\n        let found = false;\n        for (let i = -1; i <= 1; i++) {\n            for (let j = -1; j <= 1; j ++) {\n                let nx = x + delta * i;\n                let ny = y + delta * j;\n                let dist = getDistance(nx, ny, positions);\n                if (dist < result) {\n                    found = true;\n                    result = dist;\n                    x = nx;\n                    y = ny;\n                }\n            }\n        }\n        if (!found) {\n            delta /= 2;\n        }\n    }\n    return result;\n};"}
{"id": "2020", "path": "output2\\js\\Hard\\2020-maximum-number-of-non-overlapping-substrings.js", "hypo_code": "var maxNumOfSubstrings = function(s) {\n    let n = s.length;\n    let left = new Array(26).fill(n);\n    let right = new Array(26).fill(0);\n    for(let i = 0; i < n; i++){\n        let idx = s.charCodeAt(i) - 97;\n        left[idx] = Math.min(left[idx], i);\n        right[idx] = Math.max(right[idx], i);\n    }\n    let res = [];\n    let l = 0;\n    let r = 0;\n    for(let i = 0; i < n; i++){\n        if(i == left[s.charCodeAt(i) - 97]){\n            let l = i;\n            let r = right[s.charCodeAt(i) - 97];\n            for(let j = l; j <= r; j++){\n                if(left[s.charCodeAt(j) - 97] < l){\n                    l = left[s.charCodeAt(j) - 97];\n                    j = l;\n                }\n                else if(right[s.charCodeAt(j) - 97] > r){\n                    r = right[s.charCodeAt(j) - 97];\n                    j = l;\n                }\n            }\n            res.push(s.substring(l, r + 1));\n            i = r;\n        }\n    }\n    return res;\n    \n};"}
{"id": "2021", "path": "output2\\js\\Hard\\2021-find-a-value-of-a-mysterious-function-closest-to-target.js", "hypo_code": "var closestToTarget = function(arr, target) {\n    let len = arr.length;\n    let result = Number.MAX_SAFE_INTEGER;\n    let left = 0;\n    let right = 0;\n    let set = new Set();\n    while (right < len) {\n        let temp = new Set();\n        for (let item of set) {\n            temp.add(item & arr[right]);\n        }\n        temp.add(arr[right]);\n        for (let item of temp) {\n            result = Math.min(result, Math.abs(item - target));\n        }\n        set = temp;\n        if (arr[right] < target) {\n            left = right + 1;\n        }\n        right++;\n    }\n    while (left < len) {\n        let temp = new Set();\n        for (let item of set) {\n            temp.add(item & arr[left]);\n        }\n        temp.add(arr[left]);\n        for (let item of temp) {\n            result = Math.min(result, Math.abs(item - target));\n        }\n        set = temp;\n        left++;\n    }\n    return result;\n};"}
{"id": "2022", "path": "output2\\js\\Hard\\2022-minimum-number-of-increments-on-subarrays-to-form-a-target-array.js", "hypo_code": "var minNumberOperations = function(target) {\n    let res = 0;\n    let prev = 0;\n    for(let i = 0; i < target.length; i++){\n        if(target[i] > prev){\n            res += target[i] - prev;\n        }\n        prev = target[i];\n    }\n    return res;\n    \n};"}
{"id": "2023", "path": "output2\\js\\Hard\\2023-string-compression-ii.js", "hypo_code": "var getLengthOfOptimalCompression = function(s, k) {\n    let n = s.length;\n    let dp = new Array(n);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    for(let i = 0; i < n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 0; i < n - 1; i++){\n        if(s[i] == s[i + 1]){\n            dp[i][i + 1] = 1;\n        }else{\n            dp[i][i + 1] = 2;\n        }\n    }\n    for(let i = 2; i < n; i++){\n        for(let j = 0; j < n - i; j++){\n            if(s[j] == s[j + i]){\n                dp[j][j + i] = dp[j + 1][j + i - 1];\n            }else{\n                dp[j][j + i] = Math.min(dp[j + 1][j + i], dp[j][j + i - 1]) + 1;\n            }\n        }\n    }\n    return dp[0][n - 1];\n    \n    \n};"}
{"id": "2024", "path": "output2\\js\\Hard\\2024-get-the-maximum-score.js", "hypo_code": "var maxSum = function(nums1, nums2) {\n    let i = 0;\n    let j = 0;\n    let sum1 = 0;\n    let sum2 = 0;\n    let res = 0;\n    while(i < nums1.length && j < nums2.length){\n        if(nums1[i] == nums2[j]){\n            res += Math.max(sum1, sum2) + nums1[i];\n            sum1 = 0;\n            sum2 = 0;\n            i++;\n            j++;\n        }\n        else if(nums1[i] < nums2[j]){\n            sum1 += nums1[i];\n            i++;\n        }\n        else{\n            sum2 += nums2[j];\n            j++;\n        }\n    }\n    while(i < nums1.length){\n        sum1 += nums1[i];\n        i++;\n    }\n    while(j < nums2.length){\n        sum2 += nums2[j];\n        j++;\n    }\n    res += Math.max(sum1, sum2);\n    return res % (10 ** 9 + 7);\n    \n    \n};"}
{"id": "2025", "path": "output2\\js\\Hard\\2025-find-longest-awesome-substring.js", "hypo_code": "var longestAwesome = function(s) {\n    let n = s.length;\n    let dp = new Array(1024).fill(-1);\n    dp[0] = -1;\n    let res = 0;\n    let mask = 0;\n    for(let i = 0; i < n; i++){\n        let idx = s.charCodeAt(i) - 48;\n        mask ^= (1 << idx);\n        if(dp[mask] != -1){\n            res = Math.max(res, i - dp[mask]);\n        }else{\n            dp[mask] = i;\n        }\n        for(let j = 0; j < 10; j++){\n            let newMask = mask ^ (1 << j);\n            if(dp[newMask] != -1){\n                res = Math.max(res, i - dp[newMask]);\n            }\n        }\n    }\n    return res;\n    \n};"}
{"id": "2026", "path": "output2\\js\\Hard\\2026-minimum-cost-to-cut-a-stick.js", "hypo_code": "var minCost = function(n, cuts) {\n    cuts.sort((a, b) => a - b);\n    let len = cuts.length;\n    let dp = new Array(len + 1);\n    for (let i = 0; i <= len; i++) {\n        dp[i] = new Array(len + 1).fill(Number.MAX_SAFE_INTEGER);\n    }\n    cuts.unshift(0);\n    cuts.push(n);\n    for (let i = 0; i <= len; i++) {\n        dp[i][i] = 0;\n    }\n    for (let i = len - 1; i >= 0; i--) {\n        for (let j = i + 1; j <= len; j++) {\n            for (let k = i + 1; k < j; k++) {\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i]);\n            }\n        }\n    }\n    return dp[0][len];\n};"}
{"id": "2027", "path": "output2\\js\\Hard\\2027-minimum-number-of-days-to-eat-n-oranges.js", "hypo_code": "var minDays = function(n) {\n    let dp = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        dp[i] = dp[i - 1] + 1;\n        if(i % 2 == 0){\n            dp[i] = Math.min(dp[i], dp[i / 2] + 1);\n        }\n        if(i % 3 == 0){\n            dp[i] = Math.min(dp[i], dp[i / 3] + 1);\n        }\n    }\n    return dp[n];\n    \n};"}
{"id": "2028", "path": "output2\\js\\Hard\\2028-stone-game-v.js", "hypo_code": "var stoneGameV = function(stoneValue) {\n    let n = stoneValue.length;\n    let pre = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        pre[i] = pre[i - 1] + stoneValue[i - 1];\n    }\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(n + 1).fill(0);\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            dp[i][j] = dp[i - 1][j - 1] + (distance(stoneValue[i - 1], stoneValue[j - 1]) <= r * r ? 1 : 0);\n        }\n    }\n    let ans = 0;\n    for(let i = 0; i <= n; i++){\n        for(let j = i + 1; j <= n; j++){\n            let cnt = dp[j][j] - dp[i][i] + dp[i][j] - dp[j][i];\n            ans = Math.max(ans, cnt);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2029", "path": "output2\\js\\Hard\\2029-minimum-number-of-days-to-disconnect-island.js", "hypo_code": "var minDays = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let pre = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + grid[i - 1][j - 1];\n        }\n    }\n    let res = 0;\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(grid[i][j] == 0){\n                continue;\n            }\n            let l = 0;\n            let r = Math.min(i, j) + 1;\n            while(l < r){\n                let mid = Math.floor((l + r) / 2);\n                let sum = pre[i + 1][j + 1] - pre[i + 1][j - mid] - pre[i - mid][j + 1] + pre[i - mid][j - mid];\n                if(sum == 0){\n                    r = mid;\n                }else{\n                    l = mid + 1;\n                }\n            }\n            res = Math.max(res, l * l);\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "2030", "path": "output2\\js\\Hard\\2030-number-of-ways-to-reorder-array-to-get-same-bst.js", "hypo_code": "var numOfWays = function(nums) {\n    let n = nums.length;\n    let mod = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for(let i = 2; i <= n; i++){\n        dp[i] = (dp[i - 1] * (2 * i - 1)) % mod;\n    }\n    let res = 0;\n    let dfs = (nums) => {\n        if(nums.length <= 2){\n            return 1;\n        }\n        let root = nums[0];\n        let left = [];\n        let right = [];\n        for(let i = 1; i < nums.length; i++){\n            if(nums[i] < root){\n                left.push(nums[i]);\n            }else{\n                right.push(nums[i]);\n            }\n        }\n        let leftSize = left.length;\n        let rightSize = right.length;\n        let leftWays = dfs(left);\n        let rightWays = dfs(right);\n        let totalWays = (dp[leftSize] * dp[rightSize]) % mod;\n        let res = (totalWays * leftWays) % mod;\n        res = (res * rightWays) % mod;\n        return res;\n    }\n    res = dfs(nums);\n    return res - 1;\n    \n};"}
{"id": "2031", "path": "output2\\js\\Hard\\2031-count-all-possible-routes.js", "hypo_code": "var countRoutes = function(locations, start, finish, fuel) {\n    let mod = 1000000007;\n    let n = locations.length;\n    let dp = new Array(n).fill(0).map(() => new Array(fuel + 1).fill(0));\n    dp[start][0] = 1;\n    let res = 0;\n    for(let i = 0; i <= fuel; i++){\n        for(let j = 0; j < n; j++){\n            if(dp[j][i] == 0){\n                continue;\n            }\n            for(let k = 0; k < n; k++){\n                if(k == j){\n                    continue;\n                }\n                let cost = Math.abs(locations[j] - locations[k]);\n                if(i + cost <= fuel){\n                    dp[k][i + cost] = (dp[k][i + cost] + dp[j][i]) % mod;\n                }\n            }\n        }\n    }\n    for(let i = 0; i <= fuel; i++){\n        res = (res + dp[finish][i]) % mod;\n    }\n    return res;\n    \n};"}
{"id": "2032", "path": "output2\\js\\Hard\\2032-remove-max-number-of-edges-to-keep-graph-fully-traversable.js", "hypo_code": "var maxNumEdgesToRemove = function(n, edges) {\n    let uf1 = new UnionFind(n);\n    let uf2 = new UnionFind(n);\n    let res = 0;\n    for(let [type, u, v] of edges){\n        u--;\n        v--;\n        if(type == 3){\n            if(!uf1.union(u, v)){\n                res++;\n            }else{\n                uf2.union(u, v);\n            }\n        }\n    }\n    for(let [type, u, v] of edges){\n        u--;\n        v--;\n        if(type == 1){\n            if(!uf1.union(u, v)){\n                res++;\n            }\n        }else if(type == 2){\n            if(!uf2.union(u, v)){\n                res++;\n            }\n        }\n    }\n    if(uf1.count != 1 || uf2.count != 1){\n        return -1;\n    }\n    return res;\n    \n    \n};"}
{"id": "2033", "path": "output2\\js\\Hard\\2033-check-if-string-is-transformable-with-substring-sort-operations.js", "hypo_code": "var isTransformable = function(s, t) {\n    let n = s.length;\n    let m = t.length;\n    if(n != m){\n        return false;\n    }\n    let pos = new Array(10);\n    for(let i = 0; i < 10; i++){\n        pos[i] = [];\n    }\n    for(let i = 0; i < n; i++){\n        let idx = s.charCodeAt(i) - 48;\n        pos[idx].push(i);\n    }\n    for(let i = 0; i < n; i++){\n        let idx = t.charCodeAt(i) - 48;\n        if(pos[idx].length == 0){\n            return false;\n        }\n        for(let j = 0; j < idx; j++){\n            if(pos[j].length > 0 && pos[j][0] < pos[idx][0]){\n                return false;\n            }\n        }\n        pos[idx].shift();\n    }\n    return true;\n    \n};"}
{"id": "2034", "path": "output2\\js\\Hard\\2034-strange-printer-ii.js", "hypo_code": "var isPrintable = function(targetGrid) {\n    let m = targetGrid.length;\n    let n = targetGrid[0].length;\n    let pre = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + targetGrid[i - 1][j - 1];\n        }\n    }\n    let res = 0;\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(targetGrid[i][j] == 0){\n                continue;\n            }\n            let l = 0;\n            let r = Math.min(i, j) + 1;\n            while(l < r){\n                let mid = Math.floor((l + r) / 2);\n                let sum = pre[i + 1][j + 1] - pre[i + 1][j - mid] - pre[i - mid][j + 1] + pre[i - mid][j - mid];\n                if(sum == 0){\n                    r = mid;\n                }else{\n                    l = mid + 1;\n                }\n            }\n            res = Math.max(res, l * l);\n        }\n    }\n    return res;\n    \n};"}
{"id": "2035", "path": "output2\\js\\Hard\\2035-minimum-cost-to-connect-two-groups-of-points.js", "hypo_code": "var connectTwoGroups = function(cost) {\n    let m = cost.length;\n    let n = cost[0].length;\n    let dp = new Array(1 << n).fill(Infinity);\n    dp[0] = 0;\n    for(let i = 0; i < m; i++){\n        let next = new Array(1 << n).fill(Infinity);\n        for(let j = 0; j < (1 << n); j++){\n            for(let k = 0; k < n; k++){\n                if((j & (1 << k)) == 0){\n                    next[j | (1 << k)] = Math.min(next[j | (1 << k)], dp[j] + cost[i][k]);\n                }\n            }\n        }\n        dp = next;\n    }\n    let res = dp[(1 << n) - 1];\n    for(let i = 0; i < n; i++){\n        let min = Infinity;\n        for(let j = 0; j < m; j++){\n            min = Math.min(min, cost[j][i]);\n        }\n        res += min;\n    }\n    return res;\n    \n};"}
{"id": "2036", "path": "output2\\js\\Hard\\2036-maximum-number-of-achievable-transfer-requests.js", "hypo_code": "var maximumRequests = function(n, requests) {\n    let m = requests.length;\n    let res = 0;\n    for(let i = 0; i < (1 << m); i++){\n        let cnt = 0;\n        let inCnt = new Array(n).fill(0);\n        let outCnt = new Array(n).fill(0);\n        for(let j = 0; j < m; j++){\n            if((i & (1 << j)) != 0){\n                cnt++;\n                let from = requests[j][0];\n                let to = requests[j][1];\n                inCnt[to]++;\n                outCnt[from]++;\n            }\n        }\n        let flag = true;\n        for(let j = 0; j < n; j++){\n            if(inCnt[j] != outCnt[j]){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            res = Math.max(res, cnt);\n        }\n    }\n    return res;\n    \n};"}
{"id": "2037", "path": "output2\\js\\Hard\\2037-find-servers-that-handled-most-number-of-requests.js", "hypo_code": "var busiestServers = function(k, arrival, load) {\n    let n = arrival.length;\n    let cnt = new Array(k).fill(0);\n    let busy = new Array(k).fill(0);\n    let pq = new PriorityQueue((a, b) => a[0] < b[0]);\n    for(let i = 0; i < n; i++){\n        let time = arrival[i];\n        let l = load[i];\n        while(pq.length() > 0 && pq.peek()[0] <= time){\n            let [_, id] = pq.poll();\n            busy[id] = 0;\n        }\n        let j = i % k;\n        while(busy[j] == 1){\n            j = (j + 1) % k;\n        }\n        cnt[j]++;\n        busy[j] = 1;\n        pq.offer([time + l, j]);\n    }\n    let maxCnt = 0;\n    let res = [];\n    for(let i = 0; i < k; i++){\n        if(cnt[i] > maxCnt){\n            maxCnt = cnt[i];\n            res = [i];\n        }else if(cnt[i] == maxCnt){\n            res.push(i);\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "2038", "path": "output2\\js\\Hard\\2038-maximum-number-of-visible-points.js", "hypo_code": "var visiblePoints = function(points, angle, location) {\n    let x = location[0];\n    let y = location[1];\n    let n = points.length;\n    let arr = [];\n    let cnt = 0;\n    for(let i = 0; i < n; i++){\n        let [a, b] = points[i];\n        if(a == x && b == y){\n            cnt++;\n        }else{\n            arr.push(Math.atan2(b - y, a - x));\n        }\n    }\n    arr.sort((a, b) => a - b);\n    let m = arr.length;\n    let ans = 0;\n    for(let i = 0; i < m; i++){\n        arr.push(arr[i] + 2 * Math.PI);\n    }\n    let l = 0;\n    for(let r = 0; r < 2 * m; r++){\n        while(arr[r] - arr[l] > angle * Math.PI / 180){\n            l++;\n        }\n        ans = Math.max(ans, r - l + 1);\n    }\n    return ans + cnt;\n    \n};"}
{"id": "2039", "path": "output2\\js\\Hard\\2039-minimum-one-bit-operations-to-make-integers-zero.js", "hypo_code": "var minimumOneBitOperations = function(n) {\n    let dp = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        dp[i] = dp[i - 1] ^ i;\n    }\n    return dp[n];\n    \n};"}
{"id": "2040", "path": "output2\\js\\Hard\\2040-count-subtrees-with-max-distance-between-cities.js", "hypo_code": "var countSubgraphsForEachDiameter = function(n, edges) {\n    let g = new Array(n);\n    for(let i = 0; i < n; i++){\n        g[i] = new Array();\n    }\n    for(let [u, v] of edges){\n        u--;\n        v--;\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let res = new Array(n-1).fill(0);\n    for(let i = 1; i < (1 << n); i++){\n        let cnt = 0;\n        for(let j = 0; j < n; j++){\n            if((i & (1 << j)) != 0){\n                cnt++;\n            }\n        }\n        if(cnt <= 1){\n            continue;\n        }\n        let flag = true;\n        let maxDis = 0;\n        for(let j = 0; j < n; j++){\n            if((i & (1 << j)) != 0){\n                let dis = bfs(g, i, j);\n                if(dis == -1){\n                    flag = false;\n                    break;\n                }\n                maxDis = Math.max(maxDis, dis);\n            }\n        }\n        if(flag){\n            res[maxDis-1]++;\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "2042", "path": "output2\\js\\Hard\\2042-graph-connectivity-with-threshold.js", "hypo_code": "var areConnected = function(n, threshold, queries) {\n    let uf = new UnionFind(n);\n    for(let i = threshold + 1; i <= n; i++){\n        for(let j = i + i; j <= n; j += i){\n            uf.union(i, j);\n        }\n    }\n    let res = [];\n    for(let query of queries){\n        let [a, b] = query;\n        res.push(uf.find(a) == uf.find(b));\n    }\n    return res;\n    \n    \n};"}
{"id": "2043", "path": "output2\\js\\Hard\\2043-rank-transform-of-a-matrix.js", "hypo_code": "var matrixRankTransform = function(matrix) {\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let res = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    let row = new Array(m).fill(0);\n    let col = new Array(n).fill(0);\n    let map = new Map();\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            let key = matrix[i][j];\n            if(!map.has(key)){\n                map.set(key, []);\n            }\n            map.get(key).push([i, j]);\n        }\n    }\n    let keys = Array.from(map.keys()).sort((a, b) => a - b);\n    for(let key of keys){\n        let arr = map.get(key);\n        let rank = 0;\n        let uf = new UnionFind(m + n);\n        for(let [i, j] of arr){\n            uf.union(i, j + m);\n            rank = Math.max(rank, Math.max(row[i], col[j]));\n        }\n        rank++;\n        for(let [i, j] of arr){\n            res[i][j] = rank;\n            row[i] = rank;\n            col[j] = rank;\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "2044", "path": "output2\\js\\Hard\\2044-number-of-ways-to-form-a-target-string-given-a-dictionary.js", "hypo_code": "var numWays = function(words, target) {\n    let mod = 1000000007;\n    let dp = new Array(target.length + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(words[0].length + 1).fill(0);\n    }\n    let count = new Array(words[0].length + 1).fill(0);\n    for(let i = 0; i < words.length; i++){\n        for(let j = 0; j < words[0].length; j++){\n            if(words[i][j] == target[0]){\n                count[j + 1]++;\n            }\n        }\n    }\n    for(let i = 1; i <= words[0].length; i++){\n        count[i] += count[i - 1];\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i <= target.length; i++){\n        for(let j = i; j <= words[0].length; j++){\n            let c = 0;\n            for(let k = j - 1; k >= i - 1; k--){\n                if(words[0][k] == target[i - 1]){\n                    c += count[k];\n                }\n                dp[i][j] = (dp[i][j] + dp[i - 1][k] * c) % mod;\n            }\n        }\n    }\n    return dp[target.length][words[0].length];\n    \n};;"}
{"id": "2045", "path": "output2\\js\\Hard\\2045-kth-smallest-instructions.js", "hypo_code": "var kthSmallestPath = function(destination, k) {\n    let row = destination[0];\n    let col = destination[1];\n    let dp = new Array(row + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(col + 1).fill(0);\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i <= row; i++){\n        dp[i][0] = 1;\n    }\n    for(let i = 1; i <= col; i++){\n        dp[0][i] = 1;\n    }\n    for(let i = 1; i <= row; i++){\n        for(let j = 1; j <= col; j++){\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    let ans = \"\";\n    while(row > 0 && col > 0){\n        if(dp[row - 1][col] >= k){\n            ans += \"H\";\n            row--;\n        }\n        else{\n            ans += \"V\";\n            k -= dp[row - 1][col];\n            col--;\n        }\n    }\n    while(row > 0){\n        ans += \"H\";\n        row--;\n    }\n    while(col > 0){\n        ans += \"V\";\n        col--;\n    }\n    return ans;\n    \n};"}
{"id": "2046", "path": "output2\\js\\Hard\\2046-create-sorted-array-through-instructions.js", "hypo_code": "var createSortedArray = function(instructions) {\n    let mod = 1000000007;\n    let len = instructions.length;\n    let result = 0;\n    let bit = new Array(100002).fill(0);\n    let count = new Array(100002).fill(0);\n    for (let i = 0; i < len; i++) {\n        let left = get(instructions[i] - 1, bit, count);\n        let right = i - get(instructions[i], bit, count);\n        result = (result + Math.min(left, right)) % mod;\n        update(instructions[i], bit, count);\n    }\n    return result;\n};"}
{"id": "2047", "path": "output2\\js\\Hard\\2047-distribute-repeating-integers.js", "hypo_code": "var canDistribute = function(nums, quantity) {\n    let n = quantity.length;\n    let m = 1 << n;\n    let dp = new Array(m).fill(false);\n    dp[0] = true;\n    let freq = new Map();\n    for(let num of nums){\n        freq.set(num, (freq.get(num) || 0) + 1);\n    }\n    let count = Array.from(freq.values());\n    for(let i = 0; i < count.length; i++){\n        let next = dp.slice();\n        for(let j = 0; j < m; j++){\n            if(dp[j]){\n                let mask = j;\n                let sum = 0;\n                for(let k = 0; k < n; k++){\n                    if((mask & (1 << k)) == 0 && quantity[k] <= count[i]){\n                        mask |= 1 << k;\n                        sum += quantity[k];\n                    }\n                }\n                if(sum <= count[i]){\n                    next[mask] = true;\n                }\n            }\n        }\n        dp = next;\n    }\n    return dp[m - 1];\n    \n};"}
{"id": "2048", "path": "output2\\js\\Hard\\2048-maximize-grid-happiness.js", "hypo_code": "var canDistribute = function(nums, quantity) {\n    \n};"}
{"id": "2049", "path": "output2\\js\\Hard\\2049-minimum-initial-energy-to-finish-tasks.js", "hypo_code": "var minimumEffort = function(tasks) {\n    tasks.sort((a, b) => a[1] - a[0] - (b[1] - b[0]));\n    let res = 0;\n    for(let i = 0; i < tasks.length; i++){\n        res = Math.max(res + tasks[i][0], tasks[i][1]);\n    }\n    return res;\n    \n};"}
{"id": "2050", "path": "output2\\js\\Hard\\2050-minimum-number-of-removals-to-make-mountain-array.js", "hypo_code": "var minimumMountainRemovals = function(nums) {\n    let n = nums.length;\n    let dp1 = new Array(n).fill(1);\n    let dp2 = new Array(n).fill(1);\n    for(let i = 1; i < n; i++){\n        for(let j = 0; j < i; j++){\n            if(nums[i] > nums[j]){\n                dp1[i] = Math.max(dp1[i], dp1[j] + 1);\n            }\n        }\n    }\n    for(let i = n - 2; i >= 0; i--){\n        for(let j = n - 1; j > i; j--){\n            if(nums[i] > nums[j]){\n                dp2[i] = Math.max(dp2[i], dp2[j] + 1);\n            }\n        }\n    }\n    let res = 0;\n    for(let i = 0; i < n; i++){\n        if(dp1[i] > 1 && dp2[i] > 1){\n            res = Math.max(res, dp1[i] + dp2[i] - 1);\n        }\n    }\n    return n - res;\n    \n};"}
{"id": "2051", "path": "output2\\js\\Hard\\2051-minimize-deviation-in-array.js", "hypo_code": "var minimumDeviation = function(nums) {\n    let n = nums.length;\n    let pq = new PriorityQueue((a, b) => a - b);\n    let max = 0;\n    for(let i = 0; i < n; i++){\n        if(nums[i] % 2 == 1){\n            nums[i] *= 2;\n        }\n        pq.add(nums[i]);\n        max = Math.max(max, nums[i]);\n    }\n    let res = Infinity;\n    while(pq.size() > 0){\n        let cur = pq.poll();\n        res = Math.min(res, max - cur);\n        if(cur % 2 == 0){\n            cur /= 2;\n            max = Math.max(max, cur);\n            pq.add(cur);\n        }else{\n            break;\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "2052", "path": "output2\\js\\Hard\\2052-minimum-incompatibility.js", "hypo_code": "var minimumIncompatibility = function(nums, k) {\n    let n = nums.length;\n    let m = 1 << n;\n    let dp = new Array(m).fill(Infinity);\n    dp[0] = 0;\n    let freq = new Map();\n    for(let num of nums){\n        freq.set(num, (freq.get(num) || 0) + 1);\n    }\n    let count = Array.from(freq.values());\n    for(let i = 0; i < count.length; i++){\n        let next = dp.slice();\n        for(let j = 0; j < m; j++){\n            if(dp[j] != Infinity){\n                let mask = j;\n                let sum = 0;\n                for(let k = 0; k < n; k++){\n                    if((mask & (1 << k)) == 0 && count[k] <= count[i]){\n                        mask |= 1 << k;\n                        sum += count[k];\n                    }\n                }\n                if(sum <= count[i]){\n                    next[mask] = Math.min(next[mask], dp[j] + count[i] - sum);\n                }\n            }\n        }\n        dp = next;\n    }\n    return dp[m - 1] == Infinity ? -1 : dp[m - 1];\n    \n};"}
{"id": "2053", "path": "output2\\js\\Hard\\2053-delivering-boxes-from-storage-to-ports.js", "hypo_code": "var boxDelivering = function(boxes, portsCount, maxBoxes, maxWeight) {\n    let n = boxes.length;\n    let dp = new Array(n + 1).fill(0);\n    let last = new Array(n + 1).fill(0);\n    let j = 0;\n    let weight = 0;\n    for(let i = 0; i < n; i++){\n        while(j < n && j - i < maxBoxes && weight + boxes[j][1] <= maxWeight){\n            weight += boxes[j][1];\n            if(j == 0 || boxes[j][0] != boxes[j - 1][0]){\n                last[j] = j;\n            }else{\n                last[j] = last[j - 1];\n            }\n            j++;\n        }\n        dp[j] = dp[i] + 2;\n        if(last[i] < j){\n            dp[j] = Math.min(dp[j], dp[last[i]] + 1);\n        }\n        weight -= boxes[i][1];\n    }\n    return dp[n];\n    \n};"}
{"id": "2054", "path": "output2\\js\\Hard\\2054-maximum-height-by-stacking-cuboids.js", "hypo_code": "var maxHeight = function(cuboids) {\n    let n = cuboids.length;\n    for(let i = 0; i < n; i++){\n        cuboids[i].sort((a, b) => a - b);\n    }\n    cuboids.sort((a, b) => a[0] - b[0]);\n    let dp = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        dp[i] = cuboids[i][2];\n    }\n    let res = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < i; j++){\n            if(cuboids[i][0] >= cuboids[j][0] && cuboids[i][1] >= cuboids[j][1] && cuboids[i][2] >= cuboids[j][2]){\n                dp[i] = Math.max(dp[i], dp[j] + cuboids[i][2]);\n            }\n        }\n        res = Math.max(res, dp[i]);\n    }\n    return res;\n    \n};"}
{"id": "2055", "path": "output2\\js\\Hard\\2055-checking-existence-of-edge-length-limited-paths.js", "hypo_code": "var distanceLimitedPathsExist = function(n, edgeList, queries) {\n    let uf = new UnionFind(n);\n    let m = queries.length;\n    for(let i = 0; i < m; i++){\n        queries[i].push(i);\n    }\n    edgeList.sort((a, b) => a[2] - b[2]);\n    queries.sort((a, b) => a[2] - b[2]);\n    let res = new Array(m);\n    let idx = 0;\n    for(let query of queries){\n        let [a, b, limit, i] = query;\n        while(idx < edgeList.length && edgeList[idx][2] < limit){\n            let [x, y, dis] = edgeList[idx];\n            uf.union(x, y);\n            idx++;\n        }\n        res[i] = uf.find(a) == uf.find(b);\n    }\n    return res;\n    \n    \n};"}
{"id": "2056", "path": "output2\\js\\Hard\\2056-minimum-adjacent-swaps-for-k-consecutive-ones.js", "hypo_code": "var minMoves = function(nums, k) {\n    let n = nums.length;\n    let ones = [];\n    for(let i = 0; i < n; i++){\n        if(nums[i] == 1){\n            ones.push(i);\n        }\n    }\n    let m = ones.length;\n    let prefix = new Array(m + 1).fill(0);\n    for(let i = 1; i <= m; i++){\n        prefix[i] = prefix[i - 1] + ones[i - 1];\n    }\n    let dp = new Array(m + 1).fill(0);\n    for(let i = 1; i <= m; i++){\n        dp[i] = dp[i - 1] + (ones[i - 1] - ones[(i - 1) - (k - 1) / 2]) * (k % 2 == 0 ? 1 : 2);\n    }\n    let res = Infinity;\n    for(let i = k - 1; i < m; i++){\n        let left = i - (k - 1) / 2;\n        let right = i + (k - 1) / 2;\n        let sum = prefix[right + 1] - prefix[left];\n        let mid = ones[Math.floor((left + right) / 2)];\n        res = Math.min(res, dp[i + 1] - dp[left] - (sum - mid * (right - left + 1)));\n    }\n    return res;\n    \n};"}
{"id": "2057", "path": "output2\\js\\Hard\\2057-maximum-xor-with-an-element-from-array.js", "hypo_code": "var maximizeXor = function(nums, queries) {\n    let n = nums.length;\n    let m = queries.length;\n    let res = new Array(m).fill(-1);\n    let q = new Array(m);\n    for(let i = 0; i < m; i++){\n        q[i] = [queries[i][0], queries[i][1], i];\n    }\n    q.sort((a, b) => a[1] - b[1]);\n    nums.sort((a, b) => a - b);\n    let trie = new Trie();\n    let j = 0;\n    for(let i = 0; i < m; i++){\n        while(j < n && nums[j] <= q[i][1]){\n            trie.insert(nums[j]);\n            j++;\n        }\n        if(j > 0){\n            res[q[i][2]] = trie.query(q[i][0]);\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "2058", "path": "output2\\js\\Hard\\2058-minimum-operations-to-make-a-subsequence.js", "hypo_code": "var minOperations = function(target, arr) {\n    let n = target.length;\n    let m = arr.length;\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        map.set(target[i], i);\n    }\n    let dp = new Array(m).fill(0);\n    let len = 0;\n    for(let i = 0; i < m; i++){\n        if(map.has(arr[i])){\n            let index = map.get(arr[i]);\n            let pos = binarySearch(dp, 0, len, index);\n            dp[pos] = index;\n            if(pos == len){\n                len++;\n            }\n        }\n    }\n    return n - len;\n    \n};"}
{"id": "2059", "path": "output2\\js\\Hard\\2059-number-of-ways-to-reconstruct-a-tree.js", "hypo_code": "var checkWays = function(pairs) {\n    let n = pairs.length;\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        let x = pairs[i][0];\n        let y = pairs[i][1];\n        if(!map.has(x)){\n            map.set(x, new Set());\n        }\n        if(!map.has(y)){\n            map.set(y, new Set());\n        }\n        map.get(x).add(y);\n        map.get(y).add(x);\n    }\n    let visited = new Set();\n    let count = 0;\n    for(let i = 0; i < n; i++){\n        let x = pairs[i][0];\n        let y = pairs[i][1];\n        if(!visited.has(x)){\n            dfs(x, map, visited);\n            count++;\n        }\n        if(!visited.has(y)){\n            dfs(y, map, visited);\n            count++;\n        }\n    }\n    if(count > 1){\n        return 2;\n    }\n    let root = -1;\n    for(let i = 0; i < n; i++){\n        let x = pairs[i][0];\n        let y = pairs[i][1];\n        if(map.get(x).size == 0){\n            root = x;\n            break;\n        }\n        if(map.get(y).size == 0){\n            root = y;\n            break;\n        }\n    }\n    if(root == -1){\n        return 0;\n    }\n    let ans = 1;\n    let queue = [root];\n    while(queue.length > 0){\n        let size = queue.length;\n        let set = new Set();\n        for(let i = 0; i < size; i++){\n            let node = queue.shift();\n            for(let child of map.get(node)){\n                if(!set.has(child)){\n                    set.add(child);\n                    queue.push(child);\n                }\n            }\n        }\n        ans = (ans * set.size) % 1000000007;\n    }\n    return ans;\n    \n    \n};"}
{"id": "2060", "path": "output2\\js\\Hard\\2060-find-minimum-time-to-finish-all-jobs.js", "hypo_code": "var minimumTimeRequired = function(jobs, k) {\n    let n = jobs.length;\n    let m = 1 << n;\n    let dp = new Array(m).fill(0);\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if((i & (1 << j)) != 0){\n                dp[i] += jobs[j];\n            }\n        }\n    }\n    let dp2 = new Array(m).fill(0);\n    for(let i = 0; i < m; i++){\n        for(let j = i; j > 0; j = (j - 1) & i){\n            dp2[i] = Math.max(dp2[i], Math.min(dp[j], dp[i - j]));\n        }\n    }\n    let dp3 = new Array(k).fill(0);\n    for(let i = 0; i < m; i++){\n        let next = dp3.slice();\n        for(let j = 0; j < k; j++){\n            next[j] = Math.max(dp3[j], dp2[i]);\n        }\n        dp3 = next;\n    }\n    return dp3[k - 1];\n    \n};"}
{"id": "2061", "path": "output2\\js\\Hard\\2061-cat-and-mouse-ii.js", "hypo_code": "var canMouseWin = function(grid, catJump, mouseJump) {\n    let n = grid.length;\n    let m = grid[0].length;\n    let catPos = new Array(2);\n    let mousePos = new Array(2);\n    let foodPos = new Array(2);\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            if(grid[i][j] == 'C'){\n                catPos[0] = i;\n                catPos[1] = j;\n            }else if(grid[i][j] == 'M'){\n                mousePos[0] = i;\n                mousePos[1] = j;\n            }else if(grid[i][j] == 'F'){\n                foodPos[0] = i;\n                foodPos[1] = j;\n            }\n        }\n    }\n    let memo = new Map();\n    let res = dfs(grid, catPos, mousePos, foodPos, catJump, mouseJump, memo);\n    return res;\n    \n};"}
{"id": "2062", "path": "output2\\js\\Hard\\2062-count-ways-to-make-array-with-product.js", "hypo_code": "var waysToFillArray = function(queries) {\n    let n = queries.length;\n    let res = new Array(n).fill(0);\n    let mod = 1000000007;\n    for(let i = 0; i < n; i++){\n        let [n, k] = queries[i];\n        let factors = new Map();\n        let j = 2;\n        while(j * j <= k){\n            if(k % j == 0){\n                let cnt = 0;\n                while(k % j == 0){\n                    k /= j;\n                    cnt++;\n                }\n                factors.set(j, cnt);\n            }\n            j++;\n        }\n        if(k > 1){\n            factors.set(k, 1);\n        }\n        let ans = 1;\n        for(let [_, cnt] of factors){\n            ans = ans * C(n + cnt - 1, cnt) % mod;\n        }\n        res[i] = ans;\n    }\n    return res;\n    \n    \n};"}
{"id": "2063", "path": "output2\\js\\Hard\\2063-building-boxes.js", "hypo_code": "var minimumBoxes = function(n) {\n    let dp = new Array(n + 1).fill(0);\n    let i = 1;\n    let sum = 0;\n    while(sum < n){\n        sum += i;\n        dp[i] = sum;\n        i++;\n    }\n    let res = i - 1;\n    let j = i - 2;\n    while(sum > n){\n        sum -= j;\n        j--;\n        res++;\n    }\n    return res;\n    \n};"}
{"id": "2064", "path": "output2\\js\\Hard\\2064-palindrome-partitioning-iv.js", "hypo_code": "var checkPartitioning = function(s) {\n    let n = s.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    for(let i = 0; i < n; i++){\n        dp[i][i] = true;\n    }\n    for(let i = 0; i < n - 1; i++){\n        dp[i][i + 1] = s[i] == s[i + 1];\n    }\n    for(let len = 3; len <= n; len++){\n        for(let i = 0; i + len - 1 < n; i++){\n            let j = i + len - 1;\n            dp[i][j] = dp[i + 1][j - 1] && s[i] == s[j];\n        }\n    }\n    for(let i = 0; i < n - 2; i++){\n        if(dp[0][i]){\n            for(let j = i + 1; j < n - 1; j++){\n                if(dp[i + 1][j] && dp[j + 1][n - 1]){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n    \n};"}
{"id": "2065", "path": "output2\\js\\Hard\\2065-maximum-number-of-events-that-can-be-attended-ii.js", "hypo_code": "var maxValue = function(events, k) {\n    let n = events.length;\n    events.sort((a, b) => a[1] - b[1]);\n    let dp = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        dp[i] = events[i - 1][2];\n    }\n    for(let i = 1; i < k; i++){\n        let dp2 = new Array(n + 1).fill(0);\n        for(let j = 1; j <= n; j++){\n            let left = 0;\n            let right = j;\n            while(left < right){\n                let mid = Math.floor((left + right) / 2);\n                if(events[mid - 1][1] < events[j - 1][0]){\n                    left = mid + 1;\n                }else{\n                    right = mid;\n                }\n            }\n            dp2[j] = Math.max(dp2[j - 1], dp[left - 1] + events[j - 1][2]);\n        }\n        dp = dp2;\n    }\n    return dp[n];\n    \n    \n};"}
{"id": "2066", "path": "output2\\js\\Hard\\2066-closest-subsequence-sum.js", "hypo_code": "var minAbsDifference = function(nums, goal) {\n    let n = nums.length;\n    let m = 1 << n;\n    let dp = new Array(m).fill(0);\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if((i & (1 << j)) != 0){\n                dp[i] += nums[j];\n            }\n        }\n    }\n    dp.sort((a, b) => a - b);\n    let res = Infinity;\n    for(let i = 0; i < m; i++){\n        let sum = dp[i];\n        let idx = binarySearch(dp, goal - sum);\n        res = Math.min(res, Math.abs(sum + dp[idx] - goal));\n        if(idx > 0){\n            res = Math.min(res, Math.abs(sum + dp[idx - 1] - goal));\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "2067", "path": "output2\\js\\Hard\\2067-minimum-degree-of-a-connected-trio-in-a-graph.js", "hypo_code": "var minTrioDegree = function(n, edges) {\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        map.set(i, new Set());\n    }\n    for(let i = 0; i < edges.length; i++){\n        let x = edges[i][0] - 1;\n        let y = edges[i][1] - 1;\n        map.get(x).add(y);\n        map.get(y).add(x);\n    }\n    let min = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n; i++){\n        for(let j = i + 1; j < n; j++){\n            for(let k = j + 1; k < n; k++){\n                if(map.get(i).has(j) && map.get(i).has(k) && map.get(j).has(k)){\n                    let degree = map.get(i).size + map.get(j).size + map.get(k).size - 6;\n                    min = Math.min(min, degree);\n                }\n            }\n        }\n    }\n    return min == Number.MAX_SAFE_INTEGER ? -1 : min;\n    \n};"}
{"id": "2068", "path": "output2\\js\\Hard\\2068-tree-of-coprimes.js", "hypo_code": "var getCoprimes = function(nums, edges) {\n    let n = nums.length;\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        map.set(i, new Set());\n    }\n    for(let i = 0; i < n - 1; i++){\n        let u = edges[i][0];\n        let v = edges[i][1];\n        map.get(u).add(v);\n        map.get(v).add(u);\n    }\n    let visited = new Set();\n    let ans = new Array(n).fill(-1);\n    dfs(0, map, visited, nums, ans);\n    return ans;\n    \n};"}
{"id": "2069", "path": "output2\\js\\Hard\\2069-maximum-score-from-performing-multiplication-operations.js", "hypo_code": "var maximumScore = function(nums, multipliers) {\n    let n = nums.length;\n    let m = multipliers.length;\n    let dp = new Array(m + 1).fill(0);\n    for(let i = 1; i <= m; i++){\n        for(let j = i; j >= 0; j--){\n            if(j == 0){\n                dp[j] = dp[j] + nums[n - i] * multipliers[i - 1];\n            }else if(j == i){\n                dp[j] = dp[j - 1] + nums[j - 1] * multipliers[i - 1];\n            }else{\n                dp[j] = Math.max(dp[j] + nums[n - i + j] * multipliers[i - 1], dp[j - 1] + nums[j - 1] * multipliers[i - 1]);\n            }\n        }\n    }\n    return Math.max(...dp);\n    \n};"}
{"id": "2070", "path": "output2\\js\\Hard\\2070-maximize-palindrome-length-from-subsequences.js", "hypo_code": "var longestPalindrome = function(word1, word2) {\n    let n = word1.length;\n    let m = word2.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(m + 1).fill(0);\n    }\n    for(let i = n - 1; i >= 0; i--){\n        for(let j = m - 1; j >= 0; j--){\n            if(word1[i] == word2[j]){\n                dp[i][j] = dp[i + 1][j + 1] + 1;\n            }\n        }\n    }\n    let res = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let len = 0;\n            while(i + len < n && j + len < m && word1[i + len] == word2[j + len]){\n                len++;\n            }\n            res = Math.max(res, 2 * len + dp[i + len][j + len]);\n        }\n    }\n    return res;\n    \n    \n};"}
{"id": "2071", "path": "output2\\js\\Hard\\2071-car-fleet-ii.js", "hypo_code": "var getCollisionTimes = function(cars) {\n    let n = cars.length;\n    let ans = new Array(n).fill(-1);\n    let stack = [];\n    for(let i = n - 1; i >= 0; i--){\n        let [pos, speed] = cars[i];\n        while(stack.length > 0){\n            let [pos2, speed2, time] = stack[stack.length - 1];\n            if(speed <= speed2 || (time > 0 && (pos2 - pos) / (speed - speed2) >= time)){\n                stack.pop();\n            }else{\n                break;\n            }\n        }\n        if(stack.length > 0){\n            let [pos2, speed2, time] = stack[stack.length - 1];\n            ans[i] = (pos2 - pos) / (speed - speed2);\n        }\n        stack.push([pos, speed, ans[i]]);\n    }\n    return ans;\n    \n};"}
{"id": "2072", "path": "output2\\js\\Hard\\2072-count-pairs-of-nodes.js", "hypo_code": "var countPairs = function(n, edges, queries) {\n    let result = [];\n    let edgeCount = new Array(n + 1).fill(0);\n    let edgeMap = new Map();\n    for (let i = 0; i < edges.length; i++) {\n        let edge = edges[i];\n        let node1 = edge[0];\n        let node2 = edge[1];\n        let key = node1 + '-' + node2;\n        if (!edgeMap.has(key)) {\n            edgeMap.set(key, 1);\n            edgeCount[node1]++;\n            edgeCount[node2]++;\n        }\n    }\n    for (let i = 0; i < queries.length; i++) {\n        let count = 0;\n        for (let j = 1; j <= n; j++) {\n            for (let k = j + 1; k <= n; k++) {\n                let key = j + '-' + k;\n                if (edgeMap.has(key)) {\n                    if (edgeCount[j] + edgeCount[k] > queries[i]) {\n                        count++;\n                    }\n                }\n            }\n        }\n        result.push(count);\n    }\n    return result;\n    \n};"}
{"id": "2073", "path": "output2\\js\\Hard\\2073-make-the-xor-of-all-segments-equal-to-zero.js", "hypo_code": "var minChanges = function(nums, k) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        let key = i % k;\n        if (!map.has(key)) {\n            map.set(key, new Map());\n        }\n        let subMap = map.get(key);\n        if (!subMap.has(nums[i])) {\n            subMap.set(nums[i], 1);\n        } else {\n            subMap.set(nums[i], subMap.get(nums[i]) + 1);\n        }\n    }\n    let max = 0;\n    let maxKey = 0;\n    for (let [key, value] of map) {\n        for (let [subKey, subValue] of value) {\n            if (subValue > max) {\n                max = subValue;\n                maxKey = subKey;\n            }\n        }\n        result += nums.length / k - max;\n        max = 0;\n        maxKey = 0;\n    }\n    return result;\n    \n};"}
{"id": "2074", "path": "output2\\js\\Hard\\2074-maximum-score-of-a-good-subarray.js", "hypo_code": "var maximumScore = function(nums, k) {\n    let result = 0;\n    let min = nums[k];\n    for (let i = k; i < nums.length; i++) {\n        if (nums[i] < min) {\n            min = nums[i];\n        }\n        result = Math.max(result, min * (i - k + 1));\n    }\n    min = nums[k];\n    for (let i = k; i >= 0; i--) {\n        if (nums[i] < min) {\n            min = nums[i];\n        }\n        result = Math.max(result, min * (k - i + 1));\n    }\n    return result;\n    \n};"}
{"id": "2075", "path": "output2\\js\\Hard\\2075-maximize-score-after-n-operations.js", "hypo_code": "var maxScore = function(nums) {\n    let n = nums.length;\n    let dp = new Array(1 << n).fill(0);\n    for(let i = 1; i < (1 << n); i++){\n        let count = 0;\n        for(let j = 0; j < n; j++){\n            if(i & (1 << j)){\n                count++;\n            }\n        }\n        if(count % 2 == 1){\n            continue;\n        }\n        for(let j = 0; j < n; j++){\n            if(i & (1 << j)){\n                for(let k = j + 1; k < n; k++){\n                    if(i & (1 << k)){\n                        dp[i] = Math.max(dp[i], dp[i ^ (1 << j) ^ (1 << k)] + (count / 2) * gcd(nums[j], nums[k]));\n                    }\n                }\n            }\n        }\n    }\n    return dp[(1 << n) - 1];\n    \n    \n};"}
{"id": "2076", "path": "output2\\js\\Hard\\2076-count-pairs-with-xor-in-a-range.js", "hypo_code": "var countPairs = function(nums, low, high) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            let xor = nums[i] ^ nums[j];\n            if (xor >= low && xor <= high) {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "2077", "path": "output2\\js\\Hard\\2077-maximize-number-of-nice-divisors.js", "hypo_code": "var maxNiceDivisors = function(primeFactors) {\n    let mod = 1000000007;\n    if(primeFactors <= 3){\n        return primeFactors;\n    }\n    let a = Math.floor(primeFactors / 3);\n    let b = primeFactors % 3;\n    if(b == 0){\n        return pow(3, a, mod);\n    }else if(b == 1){\n        return (pow(3, a - 1, mod) * 4) % mod;\n    }else{\n        return (pow(3, a, mod) * 2) % mod;\n    }\n    \n    \n};"}
{"id": "2078", "path": "output2\\js\\Hard\\2078-maximum-number-of-groups-getting-fresh-donuts.js", "hypo_code": "var maxHappyGroups = function(batchSize, groups) {\n    let dp = new Array(batchSize).fill(0);\n    let result = 0;\n    for (let i = 0; i < groups.length; i++) {\n        if (groups[i] % batchSize == 0) {\n            result++;\n            groups[i] = -1;\n        }\n    }\n    for (let i = 0; i < groups.length; i++) {\n        if (groups[i] != -1) {\n            let remain = groups[i] % batchSize;\n            dp[remain]++;\n        }\n    }\n    for (let i = 1; i < batchSize; i++) {\n        let j = batchSize - i;\n        if (i == j) {\n            result += Math.floor(dp[i] / 2);\n        } else {\n            result += Math.min(dp[i], dp[j]);\n        }\n    }\n    return result;\n    \n};"}
{"id": "2079", "path": "output2\\js\\Hard\\2079-number-of-different-subsequences-gcds.js", "hypo_code": "var countDifferentSubsequenceGCDs = function(nums) {\n    let max = Math.max(...nums);\n    let gcd = new Array(max + 1).fill(0);\n    for(let i = 0; i < nums.length; i++){\n        gcd[nums[i]] = nums[i];\n    }\n    for(let i = 1; i <= max; i++){\n        for(let j = 2 * i; j <= max; j += i){\n            gcd[i] = gcd2(gcd[i], gcd[j]);\n        }\n    }\n    let ans = 0;\n    for(let i = 1; i <= max; i++){\n        if(gcd[i] == i){\n            ans++;\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "2081", "path": "output2\\js\\Hard\\2081-minimum-number-of-operations-to-make-string-sorted.js", "hypo_code": "var makeStringSorted = function(s) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let key = s[i];\n        if (!map.has(key)) {\n            map.set(key, 1);\n        } else {\n            map.set(key, map.get(key) + 1);\n        }\n    }\n    let factorial = new Array(s.length + 1);\n    factorial[0] = 1;\n    factorial[1] = 1;\n    for (let i = 2; i <= s.length; i++) {\n        factorial[i] = factorial[i - 1] * i;\n    }\n    let mod = 1000000007;\n    for (let i = 0; i < s.length; i++) {\n        let count = 0;\n        for (let [key, value] of map) {\n            if (key < s[i]) {\n                count += value;\n            }\n        }\n        let current = factorial[s.length - i - 1];\n        for (let [key, value] of map) {\n            current = current / factorial[value];\n        }\n        result += count * current;\n        result = result % mod;\n        map.set(s[i], map.get(s[i]) - 1);\n    }\n    return result;\n    \n};"}
{"id": "2082", "path": "output2\\js\\Hard\\2082-find-xor-sum-of-all-pairs-bitwise-and.js", "hypo_code": "var getXORSum = function(arr1, arr2) {\n    let result = 0;\n    for (let i = 0; i < arr1.length; i++) {\n        for (let j = 0; j < arr2.length; j++) {\n            result ^= arr1[i] & arr2[j];\n        }\n    }\n    return result;\n    \n};"}
{"id": "2083", "path": "output2\\js\\Hard\\2083-maximum-building-height.js", "hypo_code": "var maxBuilding = function(n, restrictions) {\n    restrictions.push([1, 0]);\n    restrictions.sort((a, b) => a[0] - b[0]);\n    let m = restrictions.length;\n    for(let i = 1; i < m; i++){\n        restrictions[i][1] = Math.min(restrictions[i][1], restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]);\n    }\n    for(let i = m - 2; i >= 0; i--){\n        restrictions[i][1] = Math.min(restrictions[i][1], restrictions[i + 1][1] + restrictions[i + 1][0] - restrictions[i][0]);\n    }\n    let result = 0;\n    for(let i = 1; i < m; i++){\n        let diff = restrictions[i][0] - restrictions[i - 1][0];\n        let heightDiff = Math.abs(restrictions[i][1] - restrictions[i - 1][1]);\n        result = Math.max(result, Math.max(restrictions[i][1], restrictions[i - 1][1]) + Math.floor((diff - heightDiff) / 2));\n    }\n    result = Math.max(result, restrictions[m - 1][1] + n - restrictions[m - 1][0]);\n    return result;\n    \n};"}
{"id": "2084", "path": "output2\\js\\Hard\\2084-closest-room.js", "hypo_code": "var closestRoom = function(rooms, queries) {\n    let result = [];\n    let roomMap = new Map();\n    for (let i = 0; i < rooms.length; i++) {\n        let room = rooms[i];\n        let roomId = room[0];\n        let size = room[1];\n        if (!roomMap.has(size)) {\n            roomMap.set(size, []);\n        }\n        roomMap.get(size).push(roomId);\n    }\n    for (let i = 0; i < queries.length; i++) {\n        let query = queries[i];\n        let preferred = query[0];\n        let minSize = query[1];\n        let minDiff = Number.MAX_SAFE_INTEGER;\n        let minRoomId = -1;\n        for (let [size, roomIds] of roomMap) {\n            if (size >= minSize) {\n                for (let j = 0; j < roomIds.length; j++) {\n                    let roomId = roomIds[j];\n                    let diff = Math.abs(roomId - preferred);\n                    if (diff < minDiff) {\n                        minDiff = diff;\n                        minRoomId = roomId;\n                    } else if (diff == minDiff) {\n                        minRoomId = Math.min(minRoomId, roomId);\n                    }\n                }\n            }\n        }\n        result.push(minRoomId);\n    }\n    return result;\n    \n};"}
{"id": "2085", "path": "output2\\js\\Hard\\2085-minimum-interval-to-include-each-query.js", "hypo_code": "var minInterval = function(intervals, queries) {\n    let result = [];\n    let intervalMap = new Map();\n    for (let i = 0; i < intervals.length; i++) {\n        let interval = intervals[i];\n        let left = interval[0];\n        let right = interval[1];\n        let size = right - left + 1;\n        if (!intervalMap.has(size)) {\n            intervalMap.set(size, []);\n        }\n        intervalMap.get(size).push(left);\n    }\n    let intervalArray = [];\n    for (let [key, value] of intervalMap) {\n        intervalArray.push([key, value]);\n    }\n    intervalArray.sort((a, b) => a[0] - b[0]);\n    for (let i = 0; i < queries.length; i++) {\n        let query = queries[i];\n        let min = Number.MAX_SAFE_INTEGER;\n        for (let j = 0; j < intervalArray.length; j++) {\n            let interval = intervalArray[j];\n            let size = interval[0];\n            let leftArray = interval[1];\n            if (size > min) {\n                break;\n            }\n            for (let k = 0; k < leftArray.length; k++) {\n                let left = leftArray[k];\n                if (left <= query) {\n                    min = Math.min(min, size);\n                }\n            }\n        }\n        if (min == Number.MAX_SAFE_INTEGER) {\n            result.push(-1);\n        } else {\n            result.push(min);\n        }\n    }\n    return result;\n    \n};"}
{"id": "2086", "path": "output2\\js\\Hard\\2086-largest-color-value-in-a-directed-graph.js", "hypo_code": "var largestPathValue = function(colors, edges) {\n    let result = 0;\n    let colorMap = new Map();\n    let nodeMap = new Map();\n    let visited = new Array(colors.length).fill(0);\n    let queue = [];\n    for (let i = 0; i < colors.length; i++) {\n        let color = colors[i];\n        if (!colorMap.has(color)) {\n            colorMap.set(color, 1);\n        } else {\n            colorMap.set(color, colorMap.get(color) + 1);\n        }\n        if (!nodeMap.has(i)) {\n            nodeMap.set(i, []);\n        }\n    }\n    for (let i = 0; i < edges.length; i++) {\n        let edge = edges[i];\n        let node1 = edge[0];\n        let node2 = edge[1];\n        let list = nodeMap.get(node1);\n        list.push(node2);\n        nodeMap.set(node1, list);\n    }\n    for (let i = 0; i < colors.length; i++) {\n        if (visited[i] === 0) {\n            queue.push(i);\n            visited[i] = 1;\n            while (queue.length > 0) {\n                let node = queue.shift();\n                let list = nodeMap.get(node);\n                for (let j = 0; j < list.length; j++) {\n                    let next = list[j];\n                    if (visited[next] === 0) {\n                        queue.push(next);\n                        visited[next] = 1;\n                    } else {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n    for (let i = 0; i < colors.length; i++) {\n        let color = colors[i];\n        result = Math.max(result, colorMap.get(color));\n    }\n    return result;\n\n    \n};"}
{"id": "2087", "path": "output2\\js\\Hard\\2087-sum-of-floored-pairs.js", "hypo_code": "var sumOfFlooredPairs = function(nums) {\n    let result = 0;\n    let max = Math.max(...nums);\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (!map.has(nums[i])) {\n            map.set(nums[i], 1);\n        } else {\n            map.set(nums[i], map.get(nums[i]) + 1);\n        }\n    }\n    let sum = 0;\n    for (let i = 1; i <= max; i++) {\n        let count = 0;\n        for (let j = i; j <= max; j += i) {\n            if (map.has(j)) {\n                count += map.get(j);\n            }\n        }\n        sum += count;\n        result += sum * i;\n    }\n    return result % 1000000007;\n    \n};"}
{"id": "2088", "path": "output2\\js\\Hard\\2088-number-of-ways-to-rearrange-sticks-with-k-sticks-visible.js", "hypo_code": "var rearrangeSticks = function(n, k) {\n    let mod = 1000000007;\n    let dp = new Array(n + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(k + 1).fill(0);\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= k; j++){\n            dp[i][j] = (dp[i - 1][j - 1] + (dp[i - 1][j] * (i - 1)) % mod) % mod;\n        }\n    }\n    return dp[n][k];\n    \n};"}
{"id": "2089", "path": "output2\\js\\Hard\\2089-stone-game-viii.js", "hypo_code": "var stoneGameVIII = function(stones) {\n    let n = stones.length;\n    let dp = new Array(n).fill(0);\n    dp[n - 1] = stones[n - 1];\n    for(let i = n - 2; i >= 0; i--){\n        dp[i] = dp[i + 1] + stones[i];\n    }\n    let max = dp[0];\n    for(let i = 1; i < n - 1; i++){\n        max = Math.max(max, dp[i] - max);\n    }\n    return max;\n    \n};"}
{"id": "2090", "path": "output2\\js\\Hard\\2090-minimum-xor-sum-of-two-arrays.js", "hypo_code": "var minimumXORSum = function(nums1, nums2) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            let xor = nums1[i] ^ nums2[j];\n            if (xor >= low && xor <= high) {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "2091", "path": "output2\\js\\Hard\\2091-minimum-skips-to-arrive-at-meeting-on-time.js", "hypo_code": "var minSkips = function(dist, speed, hoursBefore) {\n    let n = dist.length;\n    let dp = new Array(n + 1).fill(0);\n    for(let i = 0; i < n; i++){\n        let time = Math.ceil(dist[i] / speed);\n        for(let j = n; j >= 1; j--){\n            dp[j] = Math.ceil((dp[j] + time) / speed) * speed;\n            if(j < n){\n                dp[j] = Math.min(dp[j], dp[j + 1] + dist[i]);\n            }\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        if(dp[i] <= hoursBefore * speed){\n            return i;\n        }\n    }\n    return -1;\n    \n};"}
{"id": "2092", "path": "output2\\js\\Hard\\2092-minimum-space-wasted-from-packaging.js", "hypo_code": "var minWastedSpace = function(packages, boxes) {\n    let mod = 1000000007;\n    let n = packages.length;\n    let m = boxes.length;\n    let result = Number.MAX_SAFE_INTEGER;\n    packages.sort((a, b) => a - b);\n    for (let i = 0; i < m; i++) {\n        boxes[i].sort((a, b) => a - b);\n        if (boxes[i][boxes[i].length - 1] < packages[packages.length - 1]) {\n            continue;\n        }\n        let waste = 0;\n        let j = 0;\n        for (let k = 0; k < boxes[i].length; k++) {\n            while (j < n && packages[j] <= boxes[i][k]) {\n                waste += boxes[i][k] - packages[j];\n                j++;\n            }\n        }\n        result = Math.min(result, waste);\n    }\n    return result == Number.MAX_SAFE_INTEGER ? -1 : result % mod;\n};"}
{"id": "2093", "path": "output2\\js\\Hard\\2093-minimum-cost-to-change-the-final-value-of-expression.js", "hypo_code": "var minOperationsToFlip = function(expression) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < expression.length; i++) {\n        let char = expression[i];\n        if (char === '(') {\n            let count = 1;\n            let j = i + 1;\n            while (j < expression.length) {\n                if (expression[j] === '(') {\n                    count++;\n                } else if (expression[j] === ')') {\n                    count--;\n                }\n                if (count === 0) {\n                    break;\n                }\n                j++;\n            }\n            let sub = expression.substring(i + 1, j);\n            let subResult = minOperationsToFlip(sub);\n            result += subResult;\n            i = j;\n        } else if (char === '1') {\n            result++;\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "2094", "path": "output2\\js\\Hard\\2094-the-earliest-and-latest-rounds-where-players-compete.js", "hypo_code": "var earliestAndLatest = function(n, firstPlayer, secondPlayer) {\n    let ans = [1, n - 1];\n    if(firstPlayer > secondPlayer){\n        [firstPlayer, secondPlayer] = [secondPlayer, firstPlayer];\n    }\n    while(n > 2){\n        if(firstPlayer <= n / 2 && secondPlayer > n / 2){\n            break;\n        }\n        if(firstPlayer > n / 2){\n            firstPlayer -= n / 2;\n            secondPlayer -= n / 2;\n        }\n        n /= 2;\n        ans[0]++;\n        ans[1]--;\n    }\n    return ans;\n    \n};"}
{"id": "2096", "path": "output2\\js\\Hard\\2096-count-ways-to-build-rooms-in-an-ant-colony.js", "hypo_code": "var waysToBuildRooms = function(prevRoom) {\n    let mod = 1000000007;\n    let n = prevRoom.length;\n    let dp = new Array(n + 1).fill(0);\n    let child = new Array(n + 1).fill(0);\n    let count = new Array(n + 1).fill(0);\n    let sum = new Array(n + 1).fill(0);\n    for(let i = 1; i < n; i++){\n        child[prevRoom[i]]++;\n    }\n    for(let i = n - 1; i >= 0; i--){\n        count[i] = count[i + 1] + child[i];\n    }\n    dp[0] = 1;\n    for(let i = 1; i < n; i++){\n        let c = 1;\n        for(let j = 0; j < child[i]; j++){\n            c = c * (count[i + 1] - j) % mod;\n        }\n        dp[i] = dp[prevRoom[i]] * c % mod;\n        sum[i] = (sum[i - 1] + dp[i]) % mod;\n    }\n    return sum[n - 1];\n    \n};"}
{"id": "2097", "path": "output2\\js\\Hard\\2097-longest-common-subpath.js", "hypo_code": "var longestCommonSubpath = function(n, paths) {\n    let result = 0;\n    let map = new Map();\n    let max = 0;\n    for (let i = 0; i < paths.length; i++) {\n        let path = paths[i];\n        for (let j = 0; j < path.length; j++) {\n            let city = path[j];\n            if (!map.has(city)) {\n                map.set(city, 1);\n            } else {\n                map.set(city, map.get(city) + 1);\n            }\n        }\n    }\n    for (let i = 0; i < paths.length; i++) {\n        let path = paths[i];\n        for (let j = 0; j < path.length; j++) {\n            let city = path[j];\n            if (map.get(city) === paths.length) {\n                max = Math.max(max, city);\n            }\n        }\n    }\n    return max;\n    \n};"}
{"id": "2098", "path": "output2\\js\\Hard\\2098-minimum-cost-to-reach-destination-in-time.js", "hypo_code": "var minCost = function(maxTime, edges, passingFees) {\n    let n = passingFees.length;\n    let dp = new Array(n).fill(Infinity);\n    dp[0] = passingFees[0];\n    let graph = new Array(n);\n    for(let i = 0; i < n; i++){\n        graph[i] = [];\n    }\n    for(let i = 0; i < edges.length; i++){\n        let u = edges[i][0];\n        let v = edges[i][1];\n        let w = edges[i][2];\n        graph[u].push([v, w]);\n        graph[v].push([u, w]);\n    }\n    let pq = new PriorityQueue((a, b) => a[0] < b[0]);\n    pq.push([0, 0, 0]);\n    while(!pq.isEmpty()){\n        let [cost, time, u] = pq.pop();\n        if(time > maxTime) continue;\n        if(u == n - 1) return cost;\n        for(let i = 0; i < graph[u].length; i++){\n            let v = graph[u][i][0];\n            let w = graph[u][i][1];\n            if(dp[v] > cost + passingFees[v]){\n                dp[v] = cost + passingFees[v];\n                pq.push([dp[v], time + w, v]);\n            }\n        }\n    }\n    return -1;\n    \n    \n};"}
{"id": "2099", "path": "output2\\js\\Hard\\2099-painting-a-grid-with-three-different-colors.js", "hypo_code": "var colorTheGrid = function(m, n) {\n    let mod = 1000000007;\n    let dp = new Array(m + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(n + 1).fill(0);\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            dp[i][j] = (dp[i - 1][j - 1] + (dp[i - 1][j] * (i - 1)) % mod) % mod;\n        }\n    }\n    return dp[m][n];\n    \n};"}
{"id": "2100", "path": "output2\\js\\Hard\\2100-merge-bsts-to-create-single-bst.js", "hypo_code": "var canMerge = function(trees) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < trees.length; i++) {\n        for (let j = 0; j < trees.length; j++) {\n            if (i != j) {\n                let root = trees[j];\n                let leaf = findLeaf(trees[i]);\n                if (leaf != null && leaf.val == root.val) {\n                    result++;\n                }\n            }\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "2101", "path": "output2\\js\\Hard\\2101-maximum-genetic-difference-query.js", "hypo_code": "var maxGeneticDifference = function(parents, queries) {\n    let result = [];\n    let map = new Map();\n    for (let i = 0; i < queries.length; i++) {\n        let query = queries[i];\n        let node = query[0];\n        let val = query[1];\n        if (!map.has(node)) {\n            map.set(node, []);\n        }\n        map.get(node).push([val, i]);\n    }\n    let visited = new Set();\n    let stack = [];\n    stack.push(0);\n    while (stack.length > 0) {\n        let node = stack.pop();\n        if (visited.has(node)) {\n            continue;\n        }\n        visited.add(node);\n        let parent = parents[node];\n        if (parent != -1) {\n            if (!map.has(parent)) {\n                map.set(parent, []);\n            }\n            map.get(parent).push(...map.get(node));\n        }\n        if (map.has(node)) {\n            let queryArray = map.get(node);\n            for (let i = 0; i < queryArray.length; i++) {\n                let query = queryArray[i];\n                let val = query[0];\n                let index = query[1];\n                result[index] = val ^ node;\n            }\n        }\n        stack.push(parent);\n    }\n    return result;\n    \n};"}
{"id": "2102", "path": "output2\\js\\Hard\\2102-number-of-visible-people-in-a-queue.js", "hypo_code": "var canSeePersonsCount = function(heights) {\n    let result = new Array(heights.length).fill(0);\n    let stack = [];\n    for (let i = heights.length - 1; i >= 0; i--) {\n        while (stack.length > 0 && heights[i] > heights[stack[stack.length - 1]]) {\n            result[i]++;\n            result[stack[stack.length - 1]]++;\n            stack.pop();\n        }\n        stack.push(i);\n    }\n    return result;\n    \n};"}
{"id": "2103", "path": "output2\\js\\Hard\\2103-delete-duplicate-folders-in-system.js", "hypo_code": "var deleteDuplicateFolder = function(paths) {\n    let result = [];\n    let map = new Map();\n    for (let i = 0; i < paths.length; i++) {\n        let path = paths[i];\n        let current = map;\n        for (let j = 0; j < path.length; j++) {\n            let folder = path[j];\n            if (!current.has(folder)) {\n                current.set(folder, new Map());\n            }\n            current = current.get(folder);\n        }\n    }\n    let visited = new Set();\n    let stack = [];\n    stack.push([map, []]);\n    while (stack.length > 0) {\n        let node = stack.pop();\n        let current = node[0];\n        let path = node[1];\n        if (visited.has(current)) {\n            continue;\n        }\n        visited.add(current);\n        let keys = current.keys();\n        let key = keys.next();\n        while (!key.done) {\n            let folder = key.value;\n            let subPath = [...path, folder];\n            stack.push([current.get(folder), subPath]);\n            key = keys.next();\n        }\n        if (current.size > 1) {\n            let keys = current.keys();\n            let key = keys.next();\n            while (!key.done) {\n                let folder = key.value;\n                let subPath = [...path, folder];\n                result.push(subPath);\n                key = keys.next();\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "2104", "path": "output2\\js\\Hard\\2104-count-number-of-special-subsequences.js", "hypo_code": "var countSpecialSubsequences = function(nums) {\n    let mod = 1000000007;\n    let dp = new Array(nums.length + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(3).fill(0);\n    }\n    for(let i = 0; i < nums.length; i++){\n        dp[i + 1][0] = dp[i][0];\n        dp[i + 1][1] = dp[i][1];\n        dp[i + 1][2] = dp[i][2];\n        if(nums[i] == 0){\n            dp[i + 1][0] = (dp[i + 1][0] * 2 + 1) % mod;\n        }else if(nums[i] == 1){\n            dp[i + 1][1] = (dp[i + 1][1] * 2 + dp[i + 1][0]) % mod;\n        }else{\n            dp[i + 1][2] = (dp[i + 1][2] * 2 + dp[i + 1][1]) % mod;\n        }\n    }\n    return dp[nums.length][2];\n    \n};"}
{"id": "2105", "path": "output2\\js\\Hard\\2105-maximum-product-of-the-length-of-two-palindromic-substrings.js", "hypo_code": "var maxProduct = function(s) {\n    let n = s.length;\n    let lps = new Array(n).fill(0);\n    let i = 1;\n    let j = 0;\n    while(i < n){\n        if(s[i] == s[j]){\n            j++;\n            lps[i] = j;\n            i++;\n        }\n        else{\n            if(j != 0){\n                j = lps[j - 1];\n            }\n            else{\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    return s.substring(0, lps[n - 1]);\n    \n};"}
{"id": "2106", "path": "output2\\js\\Hard\\2106-find-the-longest-valid-obstacle-course-at-each-position.js", "hypo_code": "var longestObstacleCourseAtEachPosition = function(obstacles) {\n    let result = [];\n    let stack = [];\n    for (let i = 0; i < obstacles.length; i++) {\n        let obstacle = obstacles[i];\n        if (stack.length == 0 || stack[stack.length - 1] <= obstacle) {\n            stack.push(obstacle);\n            result.push(stack.length);\n        } else {\n            let index = binarySearch(stack, obstacle);\n            stack[index] = obstacle;\n            result.push(index + 1);\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "2107", "path": "output2\\js\\Hard\\2107-last-day-where-you-can-still-cross.js", "hypo_code": "var latestDayToCross = function(row, col, cells) {\n    let result = 0;\n    let grid = new Array(row);\n    for (let i = 0; i < row; i++) {\n        grid[i] = new Array(col).fill(0);\n    }\n    for (let i = 0; i < cells.length; i++) {\n        let [r, c] = cells[i];\n        grid[r - 1][c - 1] = 1;\n        if (isConnected(grid)) {\n            result = i + 1;\n        }\n    }\n    return result;\n    \n    \n    \n};"}
{"id": "2108", "path": "output2\\js\\Hard\\2108-number-of-ways-to-separate-numbers.js", "hypo_code": "var numberOfCombinations = function(num) {\n    let mod = 1000000007;\n    let dp = new Array(num.length + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(2).fill(0);\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i <= num.length; i++){\n        for(let j = 1; j <= 2; j++){\n            dp[i][j] = (dp[i - 1][j - 1] + (dp[i - 1][j] * (i - 1)) % mod) % mod;\n        }\n    }\n    return dp[num.length][2];\n    \n};"}
{"id": "2109", "path": "output2\\js\\Hard\\2109-find-array-given-subset-sums.js", "hypo_code": "var recoverArray = function(n, sums) {\n    let result = [];\n    let map = new Map();\n    for (let i = 0; i < sums.length; i++) {\n        let sum = sums[i];\n        if (map.has(sum)) {\n            map.set(sum, map.get(sum) + 1);\n        } else {\n            map.set(sum, 1);\n        }\n    }\n    let max = 0;\n    let maxSum = 0;\n    for (let [key, value] of map) {\n        if (value > max) {\n            max = value;\n            maxSum = key;\n        }\n    }\n    result.push(maxSum);\n    let index = 0;\n    while (result.length < n) {\n        let sum = sums[index];\n        if (sum != maxSum) {\n            result.push(sum - maxSum);\n        }\n        index++;\n    }\n    return result;\n    \n};"}
{"id": "2110", "path": "output2\\js\\Hard\\2110-number-of-unique-good-subsequences.js", "hypo_code": "var numberOfUniqueGoodSubsequences = function(binary) {\n    let mod = 1000000007;\n    let dp = new Array(binary.length + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(2).fill(0);\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i <= binary.length; i++){\n        for(let j = 1; j <= 2; j++){\n            dp[i][j] = (dp[i - 1][j - 1] + (dp[i - 1][j] * (i - 1)) % mod) % mod;\n        }\n    }\n    return dp[binary.length][2];\n    \n};"}
{"id": "2111", "path": "output2\\js\\Hard\\2111-the-number-of-good-subsets.js", "hypo_code": "var numberOfGoodSubsets = function(nums) {\n    let mod = 1000000007;\n    let dp = new Array(2).fill(0);\n    dp[0] = 1;\n    for(let i = 1; i <= nums.length; i++){\n        for(let j = 1; j <= 2; j++){\n            dp[j] = (dp[j - 1] + (dp[j] * (i - 1)) % mod) % mod;\n        }\n    }\n    return dp[2];\n\n    \n};"}
{"id": "2112", "path": "output2\\js\\Hard\\2112-gcd-sort-of-an-array.js", "hypo_code": "var gcdSort = function(nums) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = 0; j < nums.length; j++) {\n            let xor = nums[i] ^ nums[j];\n            if (xor >= low && xor <= high) {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "2113", "path": "output2\\js\\Hard\\2113-smallest-missing-genetic-value-in-each-subtree.js", "hypo_code": "var smallestMissingValueSubtree = function(parents, nums) {\n    let result = [];\n    let map = new Map();\n    for (let i = 0; i < parents.length; i++) {\n        let parent = parents[i];\n        if (!map.has(parent)) {\n            map.set(parent, []);\n        }\n        map.get(parent).push(i);\n    }\n    let visited = new Set();\n    let stack = [];\n    stack.push(0);\n    while (stack.length > 0) {\n        let node = stack.pop();\n        if (visited.has(node)) {\n            continue;\n        }\n        visited.add(node);\n        let parent = parents[node];\n        if (parent != -1) {\n            if (!map.has(parent)) {\n                map.set(parent, []);\n            }\n            map.get(parent).push(...map.get(node));\n        }\n        if (map.has(node)) {\n            let childArray = map.get(node);\n            for (let i = 0; i < childArray.length; i++) {\n                let child = childArray[i];\n                result[child] = result[node];\n            }\n        }\n        stack.push(parent);\n    }\n    return result;\n    \n};"}
{"id": "2114", "path": "output2\\js\\Hard\\2114-minimum-number-of-operations-to-make-array-continuous.js", "hypo_code": "var minOperations = function(nums) { \n    nums = [...new Set(nums)].sort((a, b) => a - b);\n\tlet result = nums.length;\n\tlet n = nums.length;\n\tfor (let i = 0; i < n; i++) {\n\t\tlet j = i;\n\t\tlet k = 0;\n\t\twhile (j < n && nums[j] - nums[i] < n) {\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t\tresult = Math.min(result, n - k);\n\t}\n\treturn result;\n};"}
{"id": "2115", "path": "output2\\js\\Hard\\2115-longest-subsequence-repeated-k-times.js", "hypo_code": "var longestSubsequenceRepeatedK = function(s, k) {\n    let result = \"\";\n    let map = new Map();\n    for (let i = 0; i < s.length; i++) {\n        for (let j = 0; j < s.length; j++) {\n            let xor = s[i] ^ s[j];\n            if (xor >= low && xor <= high) {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "2116", "path": "output2\\js\\Hard\\2116-the-score-of-students-solving-math-expression.js", "hypo_code": "var scoreOfStudents = function(s, answers) {\n    let result = 0;\n    let map = new Map();\n    let correct = calculate(s);\n    for (let i = 0; i < answers.length; i++) {\n        let answer = answers[i];\n        if (answer == correct) {\n            result += 5;\n        } else if (calculate(answer) == correct) {\n            result += 2;\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "2117", "path": "output2\\js\\Hard\\2117-maximum-number-of-ways-to-partition-an-array.js", "hypo_code": "var waysToPartition = function(nums, k) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        let num = nums[i];\n        if (!map.has(num)) {\n            map.set(num, []);\n        }\n        map.get(num).push(i);\n    }\n    let visited = new Set();\n    let stack = [];\n    stack.push(0);\n    while (stack.length > 0) {\n        let node = stack.pop();\n        if (visited.has(node)) {\n            continue;\n        }\n        visited.add(node);\n        let parent = parents[node];\n        if (parent != -1) {\n            if (!map.has(parent)) {\n                map.set(parent, []);\n            }\n            map.get(parent).push(...map.get(node));\n        }\n        if (map.has(node)) {\n            let childArray = map.get(node);\n            for (let i = 0; i < childArray.length; i++) {\n                let child = childArray[i];\n                result[child] = result[node];\n            }\n        }\n        stack.push(parent);\n    }\n    return result;\n    \n};"}
{"id": "2118", "path": "output2\\js\\Hard\\2118-smallest-k-length-subsequence-with-occurrences-of-a-letter.js", "hypo_code": "var smallestSubsequence = function(s, k, letter, repetition) {\n    let result = \"\";\n    let map = new Map();\n    for (let i = 0; i < s.length; i++) {\n        for (let j = 0; j < s.length; j++) {\n            let xor = s[i] ^ s[j];\n            if (xor >= low && xor <= high) {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "2119", "path": "output2\\js\\Hard\\2119-partition-array-into-two-arrays-to-minimize-sum-difference.js", "hypo_code": "var minimumDifference = function(nums) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        let num = nums[i];\n        if (!map.has(num)) {\n            map.set(num, []);\n        }\n        map.get(num).push(i);\n    }\n    let visited = new Set();\n    let stack = [];\n    stack.push(0);\n    while (stack.length > 0) {\n        let node = stack.pop();\n        if (visited.has(node)) {\n            continue;\n        }\n        visited.add(node);\n        let parent = parents[node];\n        if (parent != -1) {\n            if (!map.has(parent)) {\n                map.set(parent, []);\n            }\n            map.get(parent).push(...map.get(node));\n        }\n        if (map.has(node)) {\n            let childArray = map.get(node);\n            for (let i = 0; i < childArray.length; i++) {\n                let child = childArray[i];\n                result[child] = result[node];\n            }\n        }\n        stack.push(parent);\n    }\n    return result;\n    \n};"}
{"id": "2120", "path": "output2\\js\\Hard\\2120-kth-smallest-product-of-two-sorted-arrays.js", "hypo_code": "var kthSmallestProduct = function(nums1, nums2, k) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            let xor = nums1[i] ^ nums2[j];\n            if (xor >= low && xor <= high) {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "2121", "path": "output2\\js\\Hard\\2121-second-minimum-time-to-reach-destination.js", "hypo_code": "var secondMinimum = function(n, edges, time, change) {\n    let mod = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            dp[j] = (dp[j - 1] + (dp[j] * (i - 1)) % mod) % mod;\n        }\n    }\n    return dp[n];\n    \n};"}
{"id": "2122", "path": "output2\\js\\Hard\\2122-parallel-courses-iii.js", "hypo_code": "var minimumTime = function(n, relations, time) {\n    let graph = new Map();\n    for (let i = 0; i < n; i++) {\n        graph.set(i, []);\n    }\n    for (let i = 0; i < relations.length; i++) {\n        let [prev, next] = relations[i];\n        graph.get(prev).push(next);\n    }\n    let dp = new Array(n).fill(0);\n    let visited = new Array(n).fill(false);\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            let max = dfs(i, graph, time, dp, visited);\n            result = Math.max(result, max);\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "2123", "path": "output2\\js\\Hard\\2123-number-of-valid-move-combinations-on-chessboard.js", "hypo_code": "var countCombinations = function(pieces, positions) {\n    let mod = 1000000007;\n    let dp = new Array(8);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(8).fill(0);\n    }\n    dp[0][0] = 1;\n    for(let i = 1; i < 8; i++){\n        dp[i][0] = dp[i - 1][0] * 2 % mod;\n        dp[0][i] = dp[0][i - 1] * 2 % mod;\n    }\n    for(let i = 1; i < 8; i++){\n        for(let j = 1; j < 8; j++){\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;\n        }\n    }\n    let ans = 1;\n    for(let i = 0; i < pieces.length; i++){\n        let [x, y] = positions[i];\n        if(pieces[i] == \"Rook\"){\n            ans = ans * dp[x - 1][y - 1] % mod;\n        }else if(pieces[i] == \"Queen\"){\n            ans = ans * dp[7][7] % mod;\n        }else{\n            ans = ans * (dp[x - 1][y - 1] + dp[7][7] - dp[7][y - 1] - dp[x - 1][7]) % mod;\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2124", "path": "output2\\js\\Hard\\2124-check-if-an-original-string-exists-given-two-encoded-strings.js", "hypo_code": "var possiblyEquals = function(s1, s2) {\n    let n1 = s1.length;\n    let n2 = s2.length;\n    let i = 0;\n    let j = 0;\n    while(i < n1 && j < n2){\n        let count1 = 0;\n        while(i < n1 && s1[i] >= '0' && s1[i] <= '9'){\n            count1 = count1 * 10 + (s1[i] - '0');\n            i++;\n        }\n        let count2 = 0;\n        while(j < n2 && s2[j] >= '0' && s2[j] <= '9'){\n            count2 = count2 * 10 + (s2[j] - '0');\n            j++;\n        }\n        if(count1 != count2){\n            return false;\n        }\n    }\n    return i == n1 && j == n2;\n    \n};"}
{"id": "2125", "path": "output2\\js\\Hard\\2125-maximum-path-quality-of-a-graph.js", "hypo_code": "var maximalPathQuality = function(values, edges, maxTime) {\n    let n = values.length;\n    let adj = new Array(n);\n    for(let i = 0; i < n; i++){\n        adj[i] = [];\n    }\n    for(let [u, v, t] of edges){\n        adj[u].push([v, t]);\n        adj[v].push([u, t]);\n    }\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(maxTime + 1).fill(-1);\n    }\n    dp[0][0] = values[0];\n    let ans = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <= maxTime; j++){\n            if(dp[i][j] == -1) continue;\n            ans = Math.max(ans, dp[i][j]);\n            for(let [v, t] of adj[i]){\n                if(j + t <= maxTime){\n                    dp[v][j + t] = Math.max(dp[v][j + t], dp[i][j] + values[v]);\n                }\n            }\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2126", "path": "output2\\js\\Hard\\2126-maximum-number-of-tasks-you-can-assign.js", "hypo_code": "var maxTaskAssign = function(tasks, workers, pills, strength) {\n    let n = tasks.length;\n    let m = workers.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(m + 1).fill(0);\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            if(tasks[i - 1] <= workers[j - 1]){\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n            dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n        }\n    }\n    let ans = dp[n][m];\n    let max = 0;\n    for(let i = 0; i < m; i++){\n        max = Math.max(max, workers[i]);\n    }\n    for(let i = 0; i <= pills; i++){\n        let cur = i * strength + max;\n        let count = 0;\n        for(let j = 0; j < n; j++){\n            if(tasks[j] <= cur){\n                count++;\n            }\n        }\n        ans = Math.max(ans, count);\n    }\n    return ans;\n    \n};"}
{"id": "2127", "path": "output2\\js\\Hard\\2127-process-restricted-friend-requests.js", "hypo_code": "var friendRequests = function(n, restrictions, requests) {\n    let adj = new Array(n);\n    for(let i = 0; i < n; i++){\n        adj[i] = new Array(n).fill(0);\n    }\n    for(let [u, v] of restrictions){\n        adj[u][v] = 1;\n        adj[v][u] = 1;\n    }\n    let ans = [];\n    for(let [u, v] of requests){\n        let flag = false;\n        for(let i = 0; i < n; i++){\n            if(adj[u][i] == 0 && adj[v][i] == 0){\n                flag = true;\n                break;\n            }\n        }\n        ans.push(flag);\n    }\n    return ans;\n    \n    \n};"}
{"id": "2128", "path": "output2\\js\\Hard\\2128-sum-of-k-mirror-numbers.js", "hypo_code": "var kMirror = function(k, n) {\n    let sum = 0;\n    let count = 0;\n    let i = 1;\n    while(count < n){\n        if(isMirror(i, k)){\n            sum += i;\n            count++;\n        }\n        i++;\n    }\n    return sum;\n    \n};"}
{"id": "2129", "path": "output2\\js\\Hard\\2129-count-fertile-pyramids-in-a-land.js", "hypo_code": "var countPyramids = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let ans = 0;\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(grid[i][j] == 1){\n                ans += dfs(grid, i, j);\n            }\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "2130", "path": "output2\\js\\Hard\\2130-find-all-people-with-secret.js", "hypo_code": "var findAllPeople = function(n, meetings, firstPerson) {\n    let adj = new Array(n);\n    for(let i = 0; i < n; i++){\n        adj[i] = new Array(n).fill(0);\n    }\n    for(let [u, v, time] of meetings){\n        adj[u][v] = time;\n        adj[v][u] = time;\n    }\n    let ans = new Set();\n    let visited = new Set();\n    let q = [firstPerson];\n    visited.add(firstPerson);\n    while(q.length > 0){\n        let curr = q.shift();\n        ans.add(curr);\n        for(let i = 0; i < n; i++){\n            if(adj[curr][i] > 0 && !visited.has(i)){\n                q.push(i);\n                visited.add(i);\n            }\n        }\n    }\n    return Array.from(ans);\n    \n};"}
{"id": "2131", "path": "output2\\js\\Hard\\2131-valid-arrangement-of-pairs.js", "hypo_code": "var validArrangement = function(pairs) {\n    let n = pairs.length;\n    let adj = new Array(n);\n    for(let i = 0; i < n; i++){\n        adj[i] = [];\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            if(pairs[i][1] == pairs[j][0]){\n                adj[i].push(j);\n            }\n        }\n    }\n    let ans = [];\n    let visited = new Set();\n    let dfs = (u) => {\n        visited.add(u);\n        for(let v of adj[u]){\n            if(!visited.has(v)){\n                ans.push([pairs[u][0], pairs[v][1]]);\n                dfs(v);\n            }\n        }\n    }\n    dfs(0);\n    return ans;\n    \n};"}
{"id": "2133", "path": "output2\\js\\Hard\\2133-maximum-fruits-harvested-after-at-most-k-steps.js", "hypo_code": "var maxTotalFruits = function(fruits, startPos, k) {\n    let n = fruits.length;\n    let ans = 0;\n    let dfs = (i, j, k, curr) => {\n        if(k < 0){\n            return;\n        }\n        if(i < 0 || j >= n){\n            return;\n        }\n        if(fruits[i][0] == fruits[j][0]){\n            ans = Math.max(ans, curr + fruits[i][1]);\n            dfs(i - 1, j, k - 1, curr + fruits[i][1]);\n            dfs(i, j + 1, k - 1, curr + fruits[j][1]);\n        }else{\n            ans = Math.max(ans, curr + fruits[i][1] + fruits[j][1]);\n            dfs(i - 1, j, k - 1, curr + fruits[i][1]);\n            dfs(i, j + 1, k - 1, curr + fruits[j][1]);\n        }\n    }\n    dfs(startPos, startPos, k, 0);\n    return ans;\n    \n};"}
{"id": "2134", "path": "output2\\js\\Hard\\2134-minimum-operations-to-make-the-array-k-increasing.js", "hypo_code": "var kIncreasing = function(arr, k) {\n    let result = 0;\n    let n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let j = i;\n        let k = 0;\n        while (j < n && arr[j] - arr[i] < n) {\n            j++;\n            k++;\n        }\n        result = Math.min(result, n - k);\n    }\n    return result;\n};"}
{"id": "2135", "path": "output2\\js\\Hard\\2135-abbreviating-the-product-of-a-range.js", "hypo_code": "var abbreviateProduct = function(left, right) {\n    let result = 1n;\n    for (let i = BigInt(left); i <= BigInt(right); i++) {\n        result *= i;\n    }\n    result = result.toString();\n    let count = 0;\n    for (let i = result.length - 1; i >= 0; i--) {\n        if (result[i] === '0') {\n            count++;\n        } else {\n            break;\n        }\n    }\n    result = result.slice(0, result.length - count);\n    let pre = '';\n    let suf = '';\n    if (result.length > 10) {\n        pre = result.slice(0, 5);\n        suf = result.slice(result.length - 5);\n        result = pre + '...' + suf;\n    }\n    result += 'e' + count;\n    return result;\n};"}
{"id": "2136", "path": "output2\\js\\Hard\\2136-recover-the-original-array.js", "hypo_code": "var recoverArray = function(nums) {\n    let n = nums.length / 2;\n    nums.sort((a, b) => a - b);\n    let lower = nums.slice(0, n);\n    let higher = nums.slice(n);\n    let result = [];\n    let k = 0;\n    while (lower.length > 0 && higher.length > 0) {\n        if (lower[0] - k === higher[0]) {\n            result.push(lower.shift());\n        } else if (higher[0] - k === lower[0]) {\n            result.push(higher.shift());\n        } else if (lower[0] - k === higher[1]) {\n            result.push(lower.shift());\n            k = higher.shift();\n        } else {\n            result.push(higher.shift());\n            k = lower.shift();\n        }\n    }\n    return result;\n};"}
{"id": "2137", "path": "output2\\js\\Hard\\2137-maximum-employees-to-be-invited-to-a-meeting.js", "hypo_code": "var maximumInvitations = function(favorite) {\n    let n = favorite.length;\n    let adj = new Array(n);\n    for(let i = 0; i < n; i++){\n        adj[i] = [];\n    }\n    for(let i = 0; i < n; i++){\n        adj[i].push(favorite[i]);\n        adj[favorite[i]].push(i);\n    }\n    let ans = 0;\n    let visited = new Set();\n    let dfs = (u) => {\n        visited.add(u);\n        for(let v of adj[u]){\n            if(!visited.has(v)){\n                ans++;\n                dfs(v);\n            }\n        }\n    }\n    for(let i = 0; i < n; i++){\n        if(!visited.has(i)){\n            dfs(i);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2138", "path": "output2\\js\\Hard\\2138-stamping-the-grid.js", "hypo_code": "var possibleToStamp = function(grid, stampHeight, stampWidth) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let ans = [];\n    let flag = true;\n    while(flag){\n        flag = false;\n        for(let i = 0; i < m; i++){\n            for(let j = 0; j < n; j++){\n                if(grid[i][j] == 0){\n                    let temp = dfs(grid, i, j, stampHeight, stampWidth);\n                    if(temp.length > 0){\n                        flag = true;\n                        ans.push(temp);\n                    }\n                }\n            }\n        }\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(grid[i][j] == 0){\n                return false;\n            }\n        }\n    }\n    return ans;\n    \n    \n    \n};"}
{"id": "2139", "path": "output2\\js\\Hard\\2139-earliest-possible-day-of-full-bloom.js", "hypo_code": "var earliestFullBloom = function(plantTime, growTime) {\n    let n = plantTime.length;\n    let adj = new Array(n);\n    for(let i = 0; i < n; i++){\n        adj[i] = [];\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            if(plantTime[i] + growTime[i] == plantTime[j]){\n                adj[i].push(j);\n            }\n        }\n    }\n    let ans = 0;\n    let visited = new Set();\n    let dfs = (u) => {\n        visited.add(u);\n        for(let v of adj[u]){\n            if(!visited.has(v)){\n                ans = Math.max(ans, plantTime[v] + growTime[v]);\n                dfs(v);\n            }\n        }\n    }\n    for(let i = 0; i < n; i++){\n        dfs(i);\n    }\n    return ans;\n    \n};"}
{"id": "2140", "path": "output2\\js\\Hard\\2140-maximum-running-time-of-n-computers.js", "hypo_code": "var maxRunTime = function(n, batteries) {\n    let m = batteries.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(m + 1).fill(0);\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j - 1] + batteries[j - 1]);\n        }\n    }\n    return dp[n][m];\n    \n};"}
{"id": "2141", "path": "output2\\js\\Hard\\2141-number-of-ways-to-divide-a-long-corridor.js", "hypo_code": "var numberOfWays = function(corridor) {\n    let result = 0;\n    let count = 0;\n    for (let i = 0; i < corridor.length; i++) {\n        if (corridor[i] === 'P') {\n            count++;\n        } else {\n            result += (count * (count - 1)) / 2;\n            count = 0;\n        }\n    }\n    result += (count * (count - 1)) / 2;\n    return result % 1000000007;\n\n};"}
{"id": "2142", "path": "output2\\js\\Hard\\2142-maximum-good-people-based-on-statements.js", "hypo_code": "var maximumGood = function(statements) {\n    let n = statements.length;\n    let result = 0;\n    for (let i = 0; i < (1 << n); i++) {\n        let bad = false;\n        for (let j = 0; j < n; j++) {\n            if ((i & (1 << j)) !== 0) {\n                for (let k = 0; k < n; k++) {\n                    if (statements[j][k] === 0 && (i & (1 << k)) !== 0) {\n                        bad = true;\n                        break;\n                    }\n                }\n                if (bad) {\n                    break;\n                }\n            }\n        }\n        if (!bad) {\n            result = Math.max(result, countOnes(i));\n        }\n    }\n    return result;\n\n};"}
{"id": "2143", "path": "output2\\js\\Hard\\2143-find-substring-with-given-hash-value.js", "hypo_code": "var subStrHash = function(s, power, modulo, k, hashValue) {\n    let result = '';\n    let hash = 0;\n    let p = 1;\n    for (let i = 0; i < k; i++) {\n        hash = (hash * power + s.charCodeAt(i) - 96) % modulo;\n        p = (p * power) % modulo;\n    }\n    if (hash === hashValue) {\n        return s.substring(0, k);\n    }\n    for (let i = k; i < s.length; i++) {\n        hash = ((hash * power) + s.charCodeAt(i) - 96 - ((s.charCodeAt(i - k) - 96) * p)) % modulo;\n        if (hash < 0) {\n            hash += modulo;\n        }\n        if (hash === hashValue) {\n            return s.substring(i - k + 1, i + 1);\n        }\n    }\n    return result;\n};"}
{"id": "2144", "path": "output2\\js\\Hard\\2144-groups-of-strings.js", "hypo_code": "var groupStrings = function(words) {\n    let result = [0, 0];\n    let map = new Map();\n    for (let word of words) {\n        let hash = 0;\n        for (let i = 1; i < word.length; i++) {\n            let diff = word.charCodeAt(i) - word.charCodeAt(i - 1);\n            if (diff < 0) {\n                diff += 26;\n            }\n            hash = hash * 26 + diff;\n        }\n        map.set(hash, (map.get(hash) || 0) + 1);\n        result[1] = Math.max(result[1], map.get(hash));\n    }\n    result[0] = map.size;\n    return result;\n};"}
{"id": "2145", "path": "output2\\js\\Hard\\2145-minimum-difference-in-sums-after-removal-of-elements.js", "hypo_code": "var minimumDifference = function(nums) {\n    let n = nums.length / 3;\n    let dp = new Array(n + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(n + 1).fill(0);\n    }\n    let sum = new Array(n + 1);\n    sum[0] = 0;\n    for(let i = 1; i <= n; i++){\n        sum[i] = sum[i - 1] + nums[i - 1];\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            dp[i][j] = Math.min(dp[i - 1][j] + nums[i + j - 1], dp[i][j - 1] + nums[i + j - 1]);\n        }\n    }\n    let ans = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i <= n; i++){\n        ans = Math.min(ans, Math.abs(sum[n] - 2 * dp[i][n - i]));\n    }\n    return ans;\n    \n};"}
{"id": "2146", "path": "output2\\js\\Hard\\2146-minimum-time-to-remove-all-cars-containing-illegal-goods.js", "hypo_code": "var minimumTime = function(s) {\n    let dp = new Array(s.length + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(s.length + 1).fill(0);\n    }\n    for(let i = 1; i <= s.length; i++){\n        for(let j = 1; j <= s.length; j++){\n            if(s[i - 1] === '1'){\n                dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2);\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n            }\n        }\n    }\n    return dp[s.length][s.length];\n    \n};"}
{"id": "2147", "path": "output2\\js\\Hard\\2147-maximum-and-sum-of-array.js", "hypo_code": "var maximumANDSum = function(nums, numSlots) {\n    let n = nums.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i < dp.length; i++){\n        dp[i] = new Array(numSlots + 1).fill(0);\n    }\n    let sum = new Array(n + 1);\n    sum[0] = 0;\n    for(let i = 1; i <= n; i++){\n        sum[i] = sum[i - 1] + nums[i - 1];\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= numSlots; j++){\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + (nums[i - 1] & j));\n        }\n    }\n    return dp[n][numSlots];\n    \n};"}
{"id": "2148", "path": "output2\\js\\Hard\\2148-count-good-triplets-in-an-array.js", "hypo_code": "var goodTriplets = function(nums1, nums2) {\n    let n = nums1.length;\n    let ans = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = i + 1; j < n; j++){\n            for(let k = j + 1; k < n; k++){\n                if(nums1[i] < nums1[j] && nums1[j] < nums1[k] && nums2[i] < nums2[j] && nums2[j] < nums2[k]){\n                    ans++;\n                }\n            }\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2149", "path": "output2\\js\\Hard\\2149-count-array-pairs-divisible-by-k.js", "hypo_code": "var countPairs = function(nums, k) {\n    let n = nums.length;\n    let count = 0;\n    let map = new Map();\n    for(let i = 0; i < n; i++){\n        let rem = nums[i] % k;\n        if(rem < 0){\n            rem += k;\n        }\n        let req = (k - rem) % k;\n        if(map.has(req)){\n            count += map.get(req);\n        }\n        if(map.has(rem)){\n            map.set(rem, map.get(rem) + 1);\n        }else{\n            map.set(rem, 1);\n        }\n    }\n    return count;\n    \n};"}
{"id": "2150", "path": "output2\\js\\Hard\\2150-minimum-time-to-finish-the-race.js", "hypo_code": "var minimumFinishTime = function(tires, changeTime, numLaps) {\n    let n = tires.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(numLaps + 1).fill(0);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 1; j <= numLaps; j++){\n            dp[i][j] = Infinity;\n            for(let k = 0; k < n; k++){\n                if(i == k){\n                    dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + tires[i][0] * tires[i][1] * j);\n                }else{\n                    dp[i][j] = Math.min(dp[i][j], dp[k][j - 1] + changeTime + tires[i][0] * tires[i][1] * j);\n                }\n            }\n        }\n    }\n    let ans = Infinity;\n    for(let i = 0; i < n; i++){\n        ans = Math.min(ans, dp[i][numLaps]);\n    }\n    return ans;\n    \n};"}
{"id": "2151", "path": "output2\\js\\Hard\\2151-minimum-number-of-moves-to-make-palindrome.js", "hypo_code": "var minMovesToMakePalindrome = function(s) {\n    let n = s.length;\n    let count = new Array(26).fill(0);\n    for(let i = 0; i < n; i++){\n        count[s[i].charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let odd = 0;\n    for(let i = 0; i < 26; i++){\n        if(count[i] % 2 == 1){\n            odd++;\n        }\n    }\n    if(odd == 0){\n        return 0;\n    }\n    let ans = 0;\n    let i = 0;\n    let j = n - 1;\n    while(i < j){\n        if(s[i] == s[j]){\n            i++;\n            j--;\n        }\n        else{\n            let k = j - 1;\n            while(k > i && s[k] != s[i]){\n                k--;\n            }\n            if(k == i){\n                return -1;\n            }\n            for(let l = k; l < j; l++){\n                [s[l], s[l + 1]] = [s[l + 1], s[l]];\n                ans++;\n            }\n            i++;\n            j--;\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2152", "path": "output2\\js\\Hard\\2152-replace-non-coprime-numbers-in-array.js", "hypo_code": "var replaceNonCoprimes = function(nums) {\n    let n = nums.length;\n    let max = 0;\n    for(let i = 0; i < n; i++){\n        max = Math.max(max, nums[i]);\n    }\n    let prime = new Array(max + 1).fill(true);\n    prime[0] = false;\n    prime[1] = false;\n    for(let i = 2; i * i <= max; i++){\n        if(prime[i]){\n            for(let j = i * i; j <= max; j += i){\n                prime[j] = false;\n            }\n        }\n    }\n    let primeFactors = new Array(max + 1).fill(0);\n    for(let i = 2; i <= max; i++){\n        if(prime[i]){\n            for(let j = i; j <= max; j += i){\n                primeFactors[j]++;\n            }\n        }\n    }\n    let ans = new Array(n).fill(0);\n    for(let i = 0; i < n; i++){\n        if(primeFactors[nums[i]] == 1){\n            ans[i] = nums[i];\n        }\n    }\n    for(let i = 0; i < n; i++){\n        if(ans[i] == 0){\n            let j = i + 1;\n            while(j < n && ans[j] == 0){\n                j++;\n            }\n            if(j < n){\n                let lcm = nums[i] * nums[j] / gcd(nums[i], nums[j]);\n                for(let k = i; k < j; k++){\n                    ans[k] = lcm;\n                }\n            }\n            i = j;\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "2153", "path": "output2\\js\\Hard\\2153-minimum-weighted-subgraph-with-the-required-paths.js", "hypo_code": "var minimumWeight = function(n, edges, src1, src2, dest) {\n    let adjList = new Array(n).fill(0).map(() => []);\n    for (let [from, to, weight] of edges) {\n        adjList[from].push([to, weight]);\n    }\n    let dist = new Array(n).fill(Infinity);\n    let pq = [[src1, 0], [src2, 0]];\n    dist[src1] = dist[src2] = 0;\n    while (pq.length > 0) {\n        let [from, weight] = pq.shift();\n        for (let [to, w] of adjList[from]) {\n            if (dist[to] > weight + w) {\n                dist[to] = weight + w;\n                pq.push([to, dist[to]]);\n            }\n        }\n    }\n    let result = Infinity;\n    for (let [from, to, weight] of edges) {\n        if (dist[from] !== Infinity && dist[to] !== Infinity) {\n            result = Math.min(result, dist[from] + dist[to] + weight);\n        }\n    }\n    return result === Infinity ? -1 : result;\n};"}
{"id": "2154", "path": "output2\\js\\Hard\\2154-minimum-white-tiles-after-covering-with-carpets.js", "hypo_code": "var minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\n    let n = floor.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(numCarpets + 1).fill(0);\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= numCarpets; j++){\n            dp[i][j] = dp[i - 1][j];\n            if(floor[i - 1] === '1'){\n                dp[i][j]++;\n            }\n            if(i >= carpetLen){\n                dp[i][j] = Math.min(dp[i][j], dp[i - carpetLen][j - 1]);\n            }\n        }\n    }\n    return dp[n][numCarpets];\n    \n};"}
{"id": "2155", "path": "output2\\js\\Hard\\2155-longest-substring-of-one-repeating-character.js", "hypo_code": "var longestRepeating = function(s, queryCharacters, queryIndices) {\n    let n = s.length;\n    let m = queryCharacters.length;\n    let ans = new Array(m).fill(0);\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(26).fill(0);\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 0; j < 26; j++){\n            if(s[i - 1] == String.fromCharCode(97 + j)){\n                dp[i][j] = dp[i - 1][j] + 1;\n            }else{\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for(let i = 0; i < m; i++){\n        let idx = queryIndices[i] - 1;\n        let ch = queryCharacters[i].charCodeAt(0) - 97;\n        let max = 0;\n        for(let j = 0; j < 26; j++){\n            if(j != ch){\n                max = Math.max(max, dp[idx + 1][j]);\n            }\n        }\n        ans[i] = max;\n    }\n    return ans;\n    \n};"}
{"id": "2156", "path": "output2\\js\\Hard\\2156-maximum-value-of-k-coins-from-piles.js", "hypo_code": "var maxValueOfCoins = function(piles, k) {\n    let n = piles.length;\n    let ans = 0;\n    piles.sort((a, b) => b[0] - a[0]);\n    for(let i = 0; i < n; i++){\n        if(i % 2 == 1){\n            ans += piles[i][0];\n            k--;\n        }\n        if(k == 0){\n            break;\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2157", "path": "output2\\js\\Hard\\2157-sum-of-scores-of-built-strings.js", "hypo_code": "var sumScores = function(s) {\n    let n = s.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(n + 1).fill(0);\n    }\n    let ans = 0;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            if(s[i - 1] == s[n - j]){\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }else{\n                dp[i][j] = 0;\n            }\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2159", "path": "output2\\js\\Hard\\2159-maximum-total-beauty-of-the-gardens.js", "hypo_code": "var maximumBeauty = function(flowers, newFlowers, target, full, partial) {\n    let n = flowers.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(newFlowers + 1).fill(0);\n    }\n    let sum = new Array(n + 1);\n    sum[0] = 0;\n    for(let i = 1; i <= n; i++){\n        sum[i] = sum[i - 1] + flowers[i - 1];\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 0; j <= newFlowers; j++){\n            let min = Infinity;\n            for(let k = 0; k <= j; k++){\n                let complete = Math.floor((sum[i] + k) / target);\n                let incomplete = (sum[i] + k) % target;\n                min = Math.min(min, incomplete);\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k] + complete * full + min * partial);\n            }\n        }\n    }\n    return dp[n][newFlowers];\n    \n};"}
{"id": "2160", "path": "output2\\js\\Hard\\2160-maximum-score-of-a-node-sequence.js", "hypo_code": "var maximumScore = function(scores, edges) {\n    let n = scores.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(n + 1);\n        for(let j = 0; j <= n; j++){\n            dp[i][j] = new Array(n + 1).fill(0);\n        }\n    }\n    let graph = new Array(n);\n    for(let i = 0; i < n; i++){\n        graph[i] = [];\n    }\n    for(let i = 0; i < edges.length; i++){\n        graph[edges[i][0]].push(edges[i][1]);\n        graph[edges[i][1]].push(edges[i][0]);\n    }\n    let ans = -1;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < graph[i].length; j++){\n            for(let k = 0; k < graph[i].length; k++){\n                if(j == k){\n                    continue;\n                }\n                let a = graph[i][j];\n                let b = graph[i][k];\n                for(let l = 0; l < graph[a].length; l++){\n                    for(let m = 0; m < graph[b].length; m++){\n                        if(l == m){\n                            continue;\n                        }\n                        let c = graph[a][l];\n                        let d = graph[b][m];\n                        if(c == d){\n                            continue;\n                        }\n                        dp[a][b][c] = Math.max(dp[a][b][c], dp[i][a][b] + scores[i] + scores[a] + scores[b] + scores[c]);\n                        ans = Math.max(ans, dp[a][b][c]);\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2161", "path": "output2\\js\\Hard\\2161-longest-path-with-different-adjacent-characters.js", "hypo_code": "var longestPath = function(parent, s) {\n    let n = parent.length;\n    let graph = new Array(n);\n    for(let i = 0; i < n; i++){\n        graph[i] = [];\n    }\n    for(let i = 1; i < n; i++){\n        graph[parent[i]].push(i);\n    }\n    let ans = 0;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(26).fill(0);\n    }\n    for(let i = n - 1; i >= 0; i--){\n        let ch = s.charCodeAt(i) - 97;\n        dp[i][ch] = 1;\n        for(let j = 0; j < graph[i].length; j++){\n            let child = graph[i][j];\n            for(let k = 0; k < 26; k++){\n                if(k == ch){\n                    continue;\n                }\n                dp[i][ch] = Math.max(dp[i][ch], 1 + dp[child][k]);\n            }\n        }\n        ans = Math.max(ans, dp[i][ch]);\n    }\n    return ans;\n    \n};"}
{"id": "2162", "path": "output2\\js\\Hard\\2162-number-of-flowers-in-full-bloom.js", "hypo_code": "var fullBloomFlowers = function(flowers, people) {\n    let n = flowers.length;\n    let result = new Array(n).fill(0);\n    let events = [];\n    for (let i = 0; i < n; i++) {\n        events.push([flowers[i][0], i, 1]);\n        events.push([flowers[i][1] + 1, i, -1]);\n    }\n    events.sort((a, b) => a[0] - b[0]);\n    let j = 0;\n    let count = 0;\n    for (let time of people) {\n        while (j < events.length && events[j][0] <= time) {\n            let [_, index, delta] = events[j];\n            count += delta;\n            j++;\n        }\n        result.push(count);\n    }\n    return result;\n};"}
{"id": "2163", "path": "output2\\js\\Hard\\2163-escape-the-spreading-fire.js", "hypo_code": "var maximumMinutes = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let ans = 0;\n    let flag = true;\n    while(flag){\n        flag = false;\n        for(let i = 0; i < m; i++){\n            for(let j = 0; j < n; j++){\n                if(grid[i][j] == 1){\n                    let temp = dfs(grid, i, j);\n                    if(temp.length > 0){\n                        flag = true;\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n    for(let i = 0; i < m; i++){\n        for(let j = 0; j < n; j++){\n            if(grid[i][j] == 1){\n                return -1;\n            }\n        }\n    }\n    return ans;\n    \n    \n    \n};"}
{"id": "2164", "path": "output2\\js\\Hard\\2164-total-appeal-of-a-string.js", "hypo_code": "var appealSum = function(s) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < s.length; i++) {\n        for (let j = 0; j < s.length; j++) {\n            let xor = s[i] ^ s[j];\n            if (xor >= low && xor <= high) {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "2165", "path": "output2\\js\\Hard\\2165-check-if-there-is-a-valid-parentheses-string-path.js", "hypo_code": "var hasValidPath = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let visited = new Array(m);\n    for(let i = 0; i < m; i++){\n        visited[i] = new Array(n).fill(false);\n    }\n    let queue = [];\n    queue.push([0, 0]);\n    visited[0][0] = true;\n    while(queue.length > 0){\n        let [x, y] = queue.shift();\n        if(x == m - 1 && y == n - 1){\n            return true;\n        }\n        if(grid[x][y] == '/'){\n            if(y + 1 < n && !visited[x][y + 1] && (grid[x][y + 1] == '/' || grid[x][y + 1] == '1' || grid[x][y + 1] == '4' || grid[x][y + 1] == '6')){\n                queue.push([x, y + 1]);\n                visited[x][y + 1] = true;\n            }\n            if(x + 1 < m && !visited[x + 1][y] && (grid[x + 1][y] == '/' || grid[x + 1][y] == '2' || grid[x + 1][y] == '3' || grid[x + 1][y] == '5')){\n                queue.push([x + 1, y]);\n                visited[x + 1][y] = true;\n            }\n        }\n        else if(grid[x][y] == '\\\\'){\n            if(y - 1 >= 0 && !visited[x][y - 1] && (grid[x][y - 1] == '\\\\' || grid[x][y - 1] == '1' || grid[x][y - 1] == '3' || grid[x][y - 1] == '5')){\n                queue.push([x, y - 1]);\n                visited[x][y - 1] = true;\n            }\n            if(x + 1 < m && !visited[x + 1][y] && (grid[x + 1][y] == '\\\\' || grid[x + 1][y] == '2' || grid[x + 1][y] == '4' || grid[x + 1][y] == '6')){\n                queue.push([x + 1, y]);\n                visited[x + 1][y] = true;\n            }\n        }\n        else if(grid[x][y] == '1'){\n            if(y + 1 < n && !visited[x][y + 1] && (grid[x][y + 1] == '/' || grid[x][y + 1] == '1' || grid[x][y + 1] == '4' || grid[x][y + 1] == '6')){\n                queue.push([x, y + 1]);\n                visited[x][y + 1] = true;\n            }\n            if(y - 1 >= 0 && !visited[x][y - 1] && (grid[x][y - 1] == '\\\\' || grid[x][y - 1] == '1' || grid[x][y - 1] == '3' || grid[x][y - 1] == '5')){\n                queue.push([x, y - 1]);\n                visited[x][y - 1] = true;\n            }\n        }\n    \n};"}
{"id": "2166", "path": "output2\\js\\Hard\\2166-substring-with-largest-variance.js", "hypo_code": "var largestVariance = function(s) {\n    let n = s.length;\n    let ans = 0;\n    for(let i = 0; i < n; i++){\n        let count = new Array(26).fill(0);\n        for(let j = i; j < n; j++){\n            count[s[j].charCodeAt(0) - 'a'.charCodeAt(0)]++;\n            let maxCount = 0;\n            let minCount = n;\n            for(let k = 0; k < 26; k++){\n                if(count[k] > 0){\n                    maxCount = Math.max(maxCount, count[k]);\n                    minCount = Math.min(minCount, count[k]);\n                }\n            }\n            ans = Math.max(ans, maxCount - minCount);\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2168", "path": "output2\\js\\Hard\\2168-sum-of-total-strength-of-wizards.js", "hypo_code": "var totalStrength = function(strength) {\n    let mod = 1000000007;\n    let n = strength.length;\n    let left = new Array(n);\n    let right = new Array(n);\n    let stack = [];\n    for(let i = 0; i < n; i++){\n        while(stack.length > 0 && strength[stack[stack.length - 1]] >= strength[i]){\n            stack.pop();\n        }\n        left[i] = stack.length == 0 ? -1 : stack[stack.length - 1];\n        stack.push(i);\n    }\n    stack = [];\n    for(let i = n - 1; i >= 0; i--){\n        while(stack.length > 0 && strength[stack[stack.length - 1]] > strength[i]){\n            stack.pop();\n        }\n        right[i] = stack.length == 0 ? n : stack[stack.length - 1];\n        stack.push(i);\n    }\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        let l = i - left[i];\n        let r = right[i] - i;\n        result = (result + strength[i] * l * r) % mod;\n    }\n    return result;\n    \n};"}
{"id": "2170", "path": "output2\\js\\Hard\\2170-minimum-obstacle-removal-to-reach-corner.js", "hypo_code": "var minimumObstacles = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    let queue = [[0, 0, 0]];\n    visited[0][0] = true;\n    while (queue.length > 0) {\n        let [i, j, k] = queue.shift();\n        if (i === m - 1 && j === n - 1) {\n            return k;\n        }\n        for (let [ni, nj] of [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]) {\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && !visited[ni][nj]) {\n                visited[ni][nj] = true;\n                if (grid[ni][nj] === 0) {\n                    queue.push([ni, nj, k]);\n                } else {\n                    queue.push([ni, nj, k + 1]);\n                }\n            }\n        }\n    }\n    return -1;\n};"}
{"id": "2172", "path": "output2\\js\\Hard\\2172-match-substring-after-replacement.js", "hypo_code": "var matchReplacement = function(s, sub, mappings) {\n    let map = new Map();\n    for (let [oldi, newi] of mappings) {\n        if (map.has(oldi) && map.get(oldi) !== newi) {\n            return false;\n        }\n        map.set(oldi, newi);\n    }\n    let i = 0;\n    let j = 0;\n    while (i < s.length && j < sub.length) {\n        if (s[i] === sub[j]) {\n            i++;\n            j++;\n        } else if (map.has(sub[j]) && map.get(sub[j]) === s[i]) {\n            i++;\n            j++;\n        } else if (map.has(sub[j])) {\n            return false;\n        } else {\n            i++;\n        }\n    }\n    return j === sub.length;\n};"}
{"id": "2173", "path": "output2\\js\\Hard\\2173-count-subarrays-with-score-less-than-k.js", "hypo_code": "var countSubarrays = function(nums, k) {\n    let result = 0;\n    let product = 1;\n    let j = 0;\n    for (let i = 0; i < nums.length; i++) {\n        product *= nums[i];\n        while (j <= i && product >= k) {\n            product /= nums[j];\n            j++;\n        }\n        result += i - j + 1;\n    }\n    return result;\n};"}
{"id": "2174", "path": "output2\\js\\Hard\\2174-naming-a-company.js", "hypo_code": "var distinctNames = function(ideas) {\n    let result = 0;\n    let map = new Map();\n    for (let idea of ideas) {\n        let key = idea.substring(1);\n        let value = idea[0];\n        map.set(key, (map.get(key) || new Set()).add(value));\n    }\n    for (let [key, set] of map) {\n        for (let value of set) {\n            if (map.has(value + key)) {\n                result++;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "2175", "path": "output2\\js\\Hard\\2175-selling-pieces-of-wood.js", "hypo_code": "var sellingWood = function(m, n, prices) {\n    let result = 0;\n    let events = [];\n    for (let [h, w, price] of prices) {\n        events.push([h, w, price]);\n        events.push([w, h, price]);\n    }\n    events.sort((a, b) => a[0] - b[0]);\n    let dp = new Array(events.length).fill(0);\n    for (let i = 0; i < events.length; i++) {\n        dp[i] = events[i][2];\n        for (let j = 0; j < i; j++) {\n            if (events[j][0] < events[i][0] && events[j][1] < events[i][1]) {\n                dp[i] = Math.max(dp[i], dp[j] + events[i][2]);\n            }\n        }\n        result = Math.max(result, dp[i]);\n    }\n    return result;\n};"}
{"id": "2176", "path": "output2\\js\\Hard\\2176-number-of-distinct-roll-sequences.js", "hypo_code": "var distinctSequences = function(n) {\n    let result = 0;\n    let mod = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    for (let i = 1; i <= n; i++) {\n        let sum = 0;\n        for (let j = 1; j <= 6; j++) {\n            if (i >= j) {\n                sum += dp[i - j];\n                sum %= mod;\n            }\n        }\n        dp[i] = sum;\n    }\n    result = dp[n];\n    for (let i = 1; i < n; i++) {\n        result *= 6;\n        result %= mod;\n    }\n    return result;\n};"}
{"id": "2177", "path": "output2\\js\\Hard\\2177-maximum-score-of-spliced-array.js", "hypo_code": "var maximumsSplicedArray = function(nums1, nums2) {\n    let n = nums1.length;\n    let result = 0;\n    let sum1 = 0;\n    let sum2 = 0;\n    for (let i = 0; i < n; i++) {\n        sum1 += nums1[i];\n        sum2 += nums2[i];\n    }\n    let diff = Math.abs(sum1 - sum2);\n    let maxDiff = 0;\n    for (let i = 0; i < n; i++) {\n        maxDiff = Math.max(maxDiff, Math.abs(nums1[i] - nums2[i]));\n    }\n    let left = 0;\n    let right = 0;\n    let sum = 0;\n    while (right < n) {\n        sum += nums1[right] - nums2[right];\n        while (left <= right && sum > diff) {\n            sum -= nums1[left] - nums2[left];\n            left++;\n        }\n        result = Math.max(result, Math.min(sum1 - sum + maxDiff * (right - left + 1), sum2 + sum + maxDiff * (right - left + 1)));\n        right++;\n    }\n    return result;\n};"}
{"id": "2178", "path": "output2\\js\\Hard\\2178-minimum-score-after-removals-on-a-tree.js", "hypo_code": "var minimumScore = function(nums, edges) {\n    let n = nums.length;\n    let graph = new Array(n).fill(0).map(() => []);\n    for (let [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    let result = Infinity;\n    let visited = new Array(n).fill(false);\n    let dfs = (u) => {\n        visited[u] = true;\n        let children = [];\n        for (let v of graph[u]) {\n            if (!visited[v]) {\n                children.push(dfs(v));\n            }\n        }\n        if (children.length === 0) {\n            return [nums[u], nums[u]];\n        }\n        if (children.length === 1) {\n            let [min, max] = children[0];\n            return [Math.min(min, nums[u]), Math.max(max, nums[u])];\n        }\n        let min = nums[u];\n        let max = nums[u];\n        for (let [childMin, childMax] of children) {\n            min = Math.min(min, childMin);\n            max = Math.max(max, childMax);\n        }\n        result = Math.min(result, max - min);\n        return [min, max];\n    };\n    dfs(0);\n    return result;\n};"}
{"id": "2179", "path": "output2\\js\\Hard\\2179-number-of-increasing-paths-in-a-grid.js", "hypo_code": "var countPaths = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let mod = 1000000007;\n    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = 1;\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let queue = [[0, 0]];\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    visited[0][0] = true;\n    while (queue.length > 0) {\n        let [i, j] = queue.shift();\n        for (let [di, dj] of directions) {\n            let ni = i + di;\n            let nj = j + dj;\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && !visited[ni][nj]) {\n                if (grid[ni][nj] < grid[i][j]) {\n                    dp[ni][nj] += dp[i][j];\n                    dp[ni][nj] %= mod;\n                } else {\n                    dp[ni][nj] += dp[i][j] + 1;\n                    dp[ni][nj] %= mod;\n                }\n                queue.push([ni, nj]);\n                visited[ni][nj] = true;\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n};"}
{"id": "2180", "path": "output2\\js\\Hard\\2180-subarray-with-elements-greater-than-varying-threshold.js", "hypo_code": "var validSubarraySize = function(nums, threshold) {\n    let n = nums.length;\n    let result = 0;\n    let sum = 0;\n    let j = 0;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        while (j <= i && sum > threshold) {\n            sum -= nums[j];\n            j++;\n        }\n        result += i - j + 1;\n    }\n    return result;\n};"}
{"id": "2181", "path": "output2\\js\\Hard\\2181-count-the-number-of-ideal-arrays.js", "hypo_code": "var idealArrays = function(n, maxValue) {\n    let result = 0;\n    let mod = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    for (let i = 1; i <= n; i++) {\n        let sum = 0;\n        for (let j = 1; j <= maxValue; j++) {\n            if (i >= j) {\n                sum += dp[i - j];\n                sum %= mod;\n            }\n        }\n        dp[i] = sum;\n    }\n    result = dp[n];\n    for (let i = 1; i < n; i++) {\n        result *= maxValue;\n        result %= mod;\n    }\n    return result;\n};"}
{"id": "2182", "path": "output2\\js\\Hard\\2182-minimum-deletions-to-make-array-divisible.js", "hypo_code": "var minOperations = function(nums, numsDivide) {\n    let n = nums.length;\n    let result = 0;\n    let sum = 0;\n    let j = 0;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        while (j <= i && sum > numsDivide[i]) {\n            sum -= nums[j];\n            j++;\n        }\n        result += i - j + 1;\n    }\n    return result;\n};"}
{"id": "2183", "path": "output2\\js\\Hard\\2183-shortest-impossible-sequence-of-rolls.js", "hypo_code": "var shortestSequence = function(rolls, k) {\n    let n = rolls.length;\n    let result = 0;\n    let dp = new Array(k).fill(0);\n    for (let i = 0; i < n; i++) {\n        dp[rolls[i] - 1] = dp[rolls[i] - 1] + 1;\n    }\n    for (let i = 0; i < k; i++) {\n        if (dp[i] === 0) {\n            result = i + 1;\n            break;\n        }\n    }\n    return result;\n};"}
{"id": "2184", "path": "output2\\js\\Hard\\2184-number-of-excellent-pairs.js", "hypo_code": "var countExcellentPairs = function(nums, k) {\n    let result = 0;\n    let mod = 1000000007;\n    let dp = new Array(k).fill(0);\n    for (let num of nums) {\n        let temp = new Array(k).fill(0);\n        for (let i = 0; i < k; i++) {\n            temp[(num & i)] += dp[i];\n            temp[(num | i)] += dp[i];\n        }\n        temp[num]++;\n        dp = temp;\n    }\n    for (let i = 0; i < k; i++) {\n        result += dp[i];\n    }\n    return result % mod;\n};"}
{"id": "2185", "path": "output2\\js\\Hard\\2185-longest-cycle-in-a-graph.js", "hypo_code": "var longestCycle = function(edges) {\n    let n = edges.length;\n    let result = -1;\n    let visited = new Array(n).fill(false);\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            let count = 0;\n            let j = i;\n            while (j !== -1) {\n                visited[j] = true;\n                count++;\n                j = edges[j];\n            }\n            result = Math.max(result, count);\n        }\n    }\n    return result;\n};"}
{"id": "2186", "path": "output2\\js\\Hard\\2186-minimum-replacements-to-sort-the-array.js", "hypo_code": "var minimumReplacement = function(nums) {\n    let result = 0;\n    let n = nums.length;\n    for (let i = 0; i < n; i++) {\n        let j = i;\n        let k = 0;\n        while (j < n && nums[j] - nums[i] < n) {\n            j++;\n            k++;\n        }\n        result = Math.min(result, n - k);\n    }\n    return result;\n};"}
{"id": "2187", "path": "output2\\js\\Hard\\2187-count-special-integers.js", "hypo_code": "var countSpecialNumbers = function(n) {\n    let result = 0;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    for (let i = 1; i <= n; i++) {\n        let sum = 0;\n        for (let j = 1; j <= 9; j++) {\n            if (i >= j) {\n                sum += dp[i - j];\n            }\n        }\n        dp[i] = sum;\n    }\n    result = dp[n];\n    return result;\n\n};"}
{"id": "2188", "path": "output2\\js\\Hard\\2188-maximum-segment-sum-after-removals.js", "hypo_code": "var maximumSegmentSum = function(nums, removeQueries) {\n    let n = nums.length;\n    let result = new Array(n).fill(0);\n    let events = [];\n    for (let i = 0; i < n; i++) {\n        events.push([i, nums[i]]);\n    }\n    for (let i = 0; i < removeQueries.length; i++) {\n        events[removeQueries[i]][1] = 0;\n    }\n    events.sort((a, b) => b[1] - a[1]);\n    let sum = 0;\n    for (let i = 0; i < n; i++) {\n        sum += events[i][1];\n        result[i] = sum;\n    }\n    return result;\n};"}
{"id": "2189", "path": "output2\\js\\Hard\\2189-find-the-k-sum-of-an-array.js", "hypo_code": "var kSum = function(nums, k) {\n    let n = nums.length;\n    let result = 0;\n    let sum = 0;\n    let j = 0;\n    for (let i = 0; i < n; i++) {\n        sum += nums[i];\n        while (j <= i && sum > k) {\n            sum -= nums[j];\n            j++;\n        }\n        result += i - j + 1;\n    }\n    return result;\n};"}
{"id": "2190", "path": "output2\\js\\Hard\\2190-build-a-matrix-with-conditions.js", "hypo_code": "var buildMatrix = function(k, rowConditions, colConditions) {\n    let n = rowConditions.length;\n    let m = colConditions.length;\n    let row = new Array(k).fill(0);\n    let col = new Array(k).fill(0);\n    let matrix = new Array(k).fill(0).map(() => new Array(k).fill(0));\n    for (let i = 0; i < n; i++) {\n        row[rowConditions[i][0] - 1] = rowConditions[i][1] - 1;\n    }\n    for (let i = 0; i < m; i++) {\n        col[colConditions[i][0] - 1] = colConditions[i][1] - 1;\n    }\n    let count = 0;\n    for (let i = 0; i < k; i++) {\n        for (let j = 0; j < k; j++) {\n            if (matrix[i][j] === 0) {\n                let r = i;\n                let c = j;\n                while (r < k && r > row[r]) {\n                    r++;\n                }\n                while (c < k && c > col[c]) {\n                    c++;\n                }\n                if (r === k || c === k) {\n                    return [];\n                }\n                for (let x = i; x <= r; x++) {\n                    for (let y = j; y <= c; y++) {\n                        matrix[x][y] = ++count;\n                    }\n                }\n            }\n        }\n    }\n    return matrix;\n};"}
{"id": "2191", "path": "output2\\js\\Hard\\2191-maximum-number-of-robots-within-budget.js", "hypo_code": "var maximumRobots = function(chargeTimes, runningCosts, budget) {\n    let n = chargeTimes.length;\n    let result = 0;\n    let sum = 0;\n    let maxCharge = 0;\n    let j = 0;\n    for (let i = 0; i < n; i++) {\n        sum += runningCosts[i];\n        maxCharge = Math.max(maxCharge, chargeTimes[i]);\n        while (j <= i && sum + maxCharge * (i - j + 1) > budget) {\n            sum -= runningCosts[j];\n            maxCharge = Math.max(maxCharge, chargeTimes[j]);\n            j++;\n        }\n        result = Math.max(result, i - j + 1);\n    }\n    return result;\n};"}
{"id": "2192", "path": "output2\\js\\Hard\\2192-meeting-rooms-iii.js", "hypo_code": "var mostBooked = function(n, meetings) {\n    let events = [];\n    for (let [start, end] of meetings) {\n        events.push([start, 1]);\n        events.push([end, -1]);\n    }\n    events.sort((a, b) => a[0] - b[0]);\n    let result = 0;\n    let count = 0;\n    for (let [_, delta] of events) {\n        count += delta;\n        result = Math.max(result, count);\n    }\n    return result;\n};"}
{"id": "2193", "path": "output2\\js\\Hard\\2193-longest-increasing-subsequence-ii.js", "hypo_code": "var lengthOfLIS = function(nums, k) {\n    let result = 0;\n    let n = nums.length;\n    for (let i = 0; i < n; i++) {\n        let j = i;\n        let k = 0;\n        while (j < n && nums[j] - nums[i] < n) {\n            j++;\n            k++;\n        }\n        result = Math.min(result, n - k);\n    }\n    return result;\n};"}
{"id": "2194", "path": "output2\\js\\Hard\\2194-minimum-money-required-before-transactions.js", "hypo_code": "var minimumMoney = function(transactions) {\n    let result = 0;\n    let n = transactions.length;\n    for (let i = 0; i < n; i++) {\n        let j = i;\n        let k = 0;\n        while (j < n && transactions[j] - transactions[i] < n) {\n            j++;\n            k++;\n        }\n        result = Math.min(result, n - k);\n    }\n    return result;\n};"}
{"id": "2195", "path": "output2\\js\\Hard\\2195-sum-of-prefix-scores-of-strings.js", "hypo_code": "var sumPrefixScores = function(words) {\n    let result = [];\n    let map = new Map();\n    for (let word of words) {\n        let hash = 0;\n        for (let i = 0; i < word.length; i++) {\n            hash = hash * 26 + word.charCodeAt(i) - 97;\n            map.set(hash, (map.get(hash) || 0) + 1);\n        }\n    }\n    for (let word of words) {\n        let hash = 0;\n        let score = 0;\n        for (let i = 0; i < word.length; i++) {\n            hash = hash * 26 + word.charCodeAt(i) - 97;\n            score += map.get(hash);\n        }\n        result.push(score);\n    }\n    return result;\n};"}
{"id": "2196", "path": "output2\\js\\Hard\\2196-number-of-good-paths.js", "hypo_code": "var numberOfGoodPaths = function(vals, edges) {\n    let n = vals.length;\n    let graph = new Array(n).fill(0).map(() => []);\n    for (let [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    let result = 0;\n    let mod = 1000000007;\n    let visited = new Array(n).fill(false);\n    let dfs = (u) => {\n        visited[u] = true;\n        let children = [];\n        for (let v of graph[u]) {\n            if (!visited[v]) {\n                children.push(dfs(v));\n            }\n        }\n        children.sort((a, b) => a - b);\n        let count = 1;\n        for (let i = 1; i < children.length; i++) {\n            if (vals[children[i]] === vals[u]) {\n                count += children[i] - children[i - 1];\n            }\n        }\n        result += count;\n        return children.length === 0 ? [u] : children;\n    };\n    dfs(0);\n    return result % mod;\n};"}
{"id": "2197", "path": "output2\\js\\Hard\\2197-number-of-pairs-satisfying-inequality.js", "hypo_code": "var numberOfPairs = function(nums1, nums2, diff) {\n    nums1.sort((a, b) => a - b);\n    nums2.sort((a, b) => a - b);\n    let n = nums1.length;\n    let i = 0;\n    let result = 0;\n    for (let j = 0; j < n; j++) {\n        while (i < n && nums1[i] <= nums2[j] - diff) {\n            i++;\n        }\n        result += n - i;\n    }\n    return result;\n};"}
{"id": "2198", "path": "output2\\js\\Hard\\2198-maximum-deletions-on-a-string.js", "hypo_code": "var deleteString = function(s) {\n    let n = s.length;\n    let dp = new Array(n + 1).fill(0);\n    let result = 0;\n    for (let i = 2; i <= n; i++) {\n        let j = dp[i - 1];\n        while (j > 0 && s.charAt(i - 1) !== s.charAt(j)) {\n            j = dp[j];\n        }\n        if (s.charAt(i - 1) === s.charAt(j)) {\n            j++;\n        }\n        dp[i] = j;\n    }\n    return n - dp[n];\n\n};"}
{"id": "2199", "path": "output2\\js\\Hard\\2199-paths-in-matrix-whose-sum-is-divisible-by-k.js", "hypo_code": "var numberOfPaths = function(grid, k) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let mod = 1000000007;\n    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = grid[0][0];\n    let directions = [[0, 1], [1, 0]];\n    let queue = [[0, 0]];\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    visited[0][0] = true;\n    while (queue.length > 0) {\n        let [i, j] = queue.shift();\n        for (let [di, dj] of directions) {\n            let ni = i + di;\n            let nj = j + dj;\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && !visited[ni][nj]) {\n                dp[ni][nj] = (dp[i][j] + grid[ni][nj]) % k;\n                queue.push([ni, nj]);\n                visited[ni][nj] = true;\n            }\n        }\n    }\n    let result = 0;\n    for (let i = 0; i < m; i++) {\n        if (dp[i][n - 1] === 0) {\n            result++;\n        }\n    }\n    for (let j = 0; j < n; j++) {\n        if (dp[m - 1][j] === 0) {\n            result++;\n        }\n    }\n    return result;\n};"}
{"id": "2200", "path": "output2\\js\\Hard\\2200-create-components-with-same-value.js", "hypo_code": "var componentValue = function(nums, edges) {\n    let n = nums.length;\n    let graph = new Array(n).fill(0).map(() => []);\n    for (let [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    let result = 0;\n    let visited = new Array(n).fill(false);\n    let dfs = (u) => {\n        visited[u] = true;\n        let sum = nums[u];\n        let children = [];\n        for (let v of graph[u]) {\n            if (!visited[v]) {\n                let child = dfs(v);\n                sum += child;\n                children.push(child);\n            }\n        }\n        if (children.length > 0 && sum % children.length === 0) {\n            result++;\n        }\n        return sum;\n    }\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n    return result;\n};"}
{"id": "2201", "path": "output2\\js\\Hard\\2201-count-subarrays-with-fixed-bounds.js", "hypo_code": "var countSubarrays = function(nums, minK, maxK) {\n    let result = 0;\n    let j = 0;\n    let k = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] >= minK) {\n            j++;\n        }\n        if (nums[i] > maxK) {\n            k = 0;\n        } else {\n            k++;\n        }\n        result += j - k;\n    }\n    return result;\n};"}
{"id": "2202", "path": "output2\\js\\Hard\\2202-minimum-cost-to-make-array-equal.js", "hypo_code": "var minCost = function(nums, cost) {\n    let result = 0;\n    let n = nums.length;\n    for (let i = 1; i < n; i++) {\n        if (nums[i] === nums[i - 1]) {\n            result += Math.min(cost[i], cost[i - 1]);\n            cost[i] = Math.max(cost[i], cost[i - 1]);\n        }\n    }\n    return result;\n};"}
{"id": "2203", "path": "output2\\js\\Hard\\2203-minimum-number-of-operations-to-make-arrays-similar.js", "hypo_code": "var makeSimilar = function(nums, target) {\n    let result = 0;\n    let n = nums.length;\n    nums.sort((a, b) => a - b);\n    target.sort((a, b) => a - b);\n    for (let i = 0; i < n; i++) {\n        result += Math.abs(nums[i] - target[i]);\n    }\n    return result / 2;\n};"}
{"id": "2204", "path": "output2\\js\\Hard\\2204-next-greater-element-iv.js", "hypo_code": "var secondGreaterElement = function(nums) {\n    let n = nums.length;\n    let result = new Array(n).fill(-1);\n    let stack = [];\n    for (let i = 2 * n - 1; i >= 0; i--) {\n        let index = i % n;\n        while (stack.length > 0 && nums[stack[stack.length - 1]] <= nums[index]) {\n            stack.pop();\n        }\n        if (stack.length > 0) {\n            result[index] = nums[stack[stack.length - 1]];\n        }\n        stack.push(index);\n    }\n    return result;\n};"}
{"id": "2205", "path": "output2\\js\\Hard\\2205-height-of-binary-tree-after-subtree-removal-queries.js", "hypo_code": "var treeQueries = function(root, queries) {\n    let n = queries.length;\n    let ans = new Array(n).fill(0);\n    let map = new Map();\n    let dfs = (node) => {\n        if(node == null){\n            return 0;\n        }\n        let left = dfs(node.left);\n        let right = dfs(node.right);\n        let height = 1 + Math.max(left, right);\n        map.set(node.val, height);\n        return height;\n    }\n    dfs(root);\n    let max = 0;\n    for(let i = 0; i < n; i++){\n        map.delete(queries[i]);\n        for(let [key, value] of map){\n            max = Math.max(max, value);\n        }\n        ans[i] = max;\n        max = 0;\n    }\n    return ans;\n    \n};"}
{"id": "2206", "path": "output2\\js\\Hard\\2206-minimum-total-distance-traveled.js", "hypo_code": "var minimumTotalDistance = function(robot, factory) {\n    let n = robot.length;\n    let m = factory.length;\n    let ans = 0;\n    let flag = true;\n    while(flag){\n        flag = false;\n        for(let i = 0; i < m; i++){\n            for(let j = 0; j < n; j++){\n                if(factory[i][1] > 0){\n                    let temp = dfs(robot, factory, i, j);\n                    if(temp.length > 0){\n                        flag = true;\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "2207", "path": "output2\\js\\Hard\\2207-split-message-based-on-limit.js", "hypo_code": "var splitMessage = function(message, limit) {\n    let n = message.length;\n    let dp = new Array(n + 1).fill(0);\n    let par = new Array(n + 1).fill(0);\n    for(let i = 1; i <= n; i++){\n        dp[i] = 1e9;\n        for(let j = 1; j <= i; j++){\n            let len = i - j + 1;\n            if(len > limit){\n                break;\n            }\n            let cost = len + 1;\n            if(dp[i] > dp[j - 1] + cost){\n                dp[i] = dp[j - 1] + cost;\n                par[i] = j;\n            }\n        }\n    }\n    let ans = [];\n    let idx = n;\n    while(idx > 0){\n        let len = idx - par[idx] + 1;\n        let part = message.substring(par[idx] - 1, idx);\n        let suffix = \"/\" + (n / len) + \")\";\n        let rem = limit - len;\n        let prefix = \"(\" + (n / len) + \"/\";\n        let total = prefix + part + suffix;\n        if(rem > 0){\n            total = total + \" \".repeat(rem);\n        }\n        ans.push(total);\n        idx = par[idx] - 1;\n    }\n    ans.reverse();\n    return ans;\n    \n};"}
{"id": "2208", "path": "output2\\js\\Hard\\2208-maximum-number-of-non-overlapping-palindrome-substrings.js", "hypo_code": "var maxPalindromes = function(s, k) {\n    let n = s.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    for(let i = 0; i < n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 0; i < n - 1; i++){\n        if(s[i] == s[i + 1]){\n            dp[i][i + 1] = 1;\n        }\n    }\n    for(let len = 3; len <= n; len++){\n        for(let i = 0; i < n - len + 1; i++){\n            let j = i + len - 1;\n            if(s[i] == s[j] && dp[i + 1][j - 1] == 1){\n                dp[i][j] = 1;\n            }\n        }\n    }\n    let ans = 0;\n    let dp2 = new Array(n + 1).fill(0);\n    for(let i = 0; i < n; i++){\n        for(let j = i; j < n; j++){\n            if(dp[i][j] == 1 && j - i + 1 >= k){\n                dp2[j + 1] = Math.max(dp2[j + 1], dp2[i] + 1);\n            }\n        }\n    }\n    return dp2[n];\n\n    \n};"}
{"id": "2209", "path": "output2\\js\\Hard\\2209-number-of-beautiful-partitions.js", "hypo_code": "var beautifulPartitions = function(s, k, minLength) {\n    let mod = 1000000007;\n    let n = s.length;\n    let dp = new Array(n + 1);\n    for(let i = 0; i <= n; i++){\n        dp[i] = new Array(k + 1).fill(0);\n    }\n    dp[0][0] = 1;\n    let isPrime = new Array(10).fill(true);\n    isPrime[1] = false;\n    for(let i = 2; i < 10; i++){\n        if(isPrime[i]){\n            for(let j = i * i; j < 10; j += i){\n                isPrime[j] = false;\n            }\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= k; j++){\n            for(let len = minLength; len <= i; len++){\n                if(isPrime[s[i - len].charCodeAt(0) - '0'.charCodeAt(0)] && !isPrime[s[i - 1].charCodeAt(0) - '0'.charCodeAt(0)]){\n                    dp[i][j] = (dp[i][j] + dp[i - len][j - 1]) % mod;\n                }\n            }\n        }\n    }\n    return dp[n][k];\n    \n};"}
{"id": "2210", "path": "output2\\js\\Hard\\2210-count-palindromic-subsequences.js", "hypo_code": "var countPalindromes = function(s) {\n    let mod = 1000000007;\n    let n = s.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    for(let i = 0; i < n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 0; i < n - 1; i++){\n        dp[i][i + 1] = 2;\n    }\n    for(let len = 3; len <= n; len++){\n        for(let i = 0; i < n - len + 1; i++){\n            let j = i + len - 1;\n            if(s[i] == s[j]){\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + 1) % mod;\n            }else{\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] + mod) % mod;\n            }\n        }\n    }\n    return dp[0][n - 1];\n    \n};"}
{"id": "2211", "path": "output2\\js\\Hard\\2211-count-subarrays-with-median-k.js", "hypo_code": "var countSubarrays = function(nums, k) {\n    let result = 0;\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i; j < nums.length; j++) {\n            let median = findMedian(nums, i, j);\n            if (median == k) {\n                result++;\n            }\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "2212", "path": "output2\\js\\Hard\\2212-divide-nodes-into-the-maximum-number-of-groups.js", "hypo_code": "var magnificentSets = function(n, edges) {\n    let result = 0;\n    let edgeMap = new Map();\n    for (let i = 0; i < edges.length; i++) {\n        let edge = edges[i];\n        let node1 = edge[0];\n        let node2 = edge[1];\n        let key = node1 + '-' + node2;\n        if (!edgeMap.has(key)) {\n            edgeMap.set(key, 1);\n        }\n    }\n    let visited = new Array(n + 1).fill(0);\n    let queue = [];\n    for (let i = 1; i <= n; i++) {\n        if (visited[i] === 0) {\n            queue.push(i);\n            visited[i] = 1;\n            while (queue.length > 0) {\n                let node = queue.shift();\n                for (let j = 1; j <= n; j++) {\n                    let key = node + '-' + j;\n                    if (edgeMap.has(key) && visited[j] === 0) {\n                        queue.push(j);\n                        visited[j] = 1;\n                    }\n                }\n            }\n            result++;\n        }\n    }\n    return result;\n    \n    \n};"}
{"id": "2213", "path": "output2\\js\\Hard\\2213-minimum-total-cost-to-make-arrays-unequal.js", "hypo_code": "var minimumTotalCost = function(nums1, nums2) {\n    let n = nums1.length;\n    let dp = new Array(n + 1).fill(Infinity);\n    dp[0] = 0;\n    for(let i = 0; i < n; i++){\n        let next = new Array(n + 1).fill(Infinity);\n        for(let j = 0; j <= n; j++){\n            if(nums1[i] != nums2[i]){\n                next[j] = Math.min(next[j], dp[j] + i);\n            }\n            if(j < n && nums1[i] != nums2[j]){\n                next[j + 1] = Math.min(next[j + 1], dp[j] + j);\n            }\n            if(j < n && nums1[j] != nums2[i]){\n                next[j + 1] = Math.min(next[j + 1], dp[j] + i);\n            }\n        }\n        dp = next;\n    }\n    return dp[n] == Infinity ? -1 : dp[n];\n    \n};"}
{"id": "2214", "path": "output2\\js\\Hard\\2214-maximum-number-of-points-from-grid-queries.js", "hypo_code": "var maxPoints = function(grid, queries) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let pre = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for(let i = 1; i <= m; i++){\n        for(let j = 1; j <= n; j++){\n            pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + grid[i - 1][j - 1];\n        }\n    }\n    let res = [];\n    for(let query of queries){\n        let [x, y, z] = query;\n        let l = 0;\n        let r = Math.min(x, y) + 1;\n        while(l < r){\n            let mid = Math.floor((l + r) / 2);\n            let sum = pre[x + 1][y + 1] - pre[x + 1][y - mid] - pre[x - mid][y + 1] + pre[x - mid][y - mid];\n            if(sum <= z){\n                r = mid;\n            }else{\n                l = mid + 1;\n            }\n        }\n        res.push(l * l);\n    }\n    return res;\n    \n};"}
{"id": "2215", "path": "output2\\js\\Hard\\2215-add-edges-to-make-degrees-of-all-nodes-even.js", "hypo_code": "var isPossible = function(n, edges) {\n    let adj = new Array(n + 1).fill(0).map(() => new Array());\n    for(let [u, v] of edges){\n        adj[u].push(v);\n        adj[v].push(u);\n    }\n    let visited = new Array(n + 1).fill(false);\n    let odd = 0;\n    let even = 0;\n    for(let i = 1; i <= n; i++){\n        if(!visited[i]){\n            let res = dfs(i, adj, visited);\n            if(res[0] == 0){\n                even++;\n            }\n            else{\n                odd++;\n            }\n        }\n    }\n    return (odd == 0 && even > 1) || (odd == 1 && even == 0) || (odd == 0 && even == 1);\n    \n};"}
{"id": "2216", "path": "output2\\js\\Hard\\2216-cycle-length-queries-in-a-tree.js", "hypo_code": "var cycleLengthQueries = function(n, queries) {\n    let m = queries.length;\n    let ans = new Array(m).fill(-1);\n    let edges = new Array(m);\n    for(let i = 0; i < m; i++){\n        edges[i] = [queries[i][0], queries[i][1], i];\n    }\n    edges.sort((a, b) => a[0] - b[0]);\n    let uf = new UnionFind(n);\n    let max = 1;\n    let map = new Map();\n    for(let i = 0; i < m; i++){\n        let [x, y, idx] = edges[i];\n        if(!map.has(x)){\n            map.set(x, max);\n            max++;\n        }\n        if(!map.has(y)){\n            map.set(y, max);\n            max++;\n        }\n        x = map.get(x);\n        y = map.get(y);\n        if(uf.union(x, y)){\n            ans[idx] = uf.size[x];\n        }\n    }\n    return ans;\n    \n    \n};"}
{"id": "2217", "path": "output2\\js\\Hard\\2217-count-anagrams.js", "hypo_code": "var countAnagrams = function(s) {\n    let mod = 1000000007;\n    let dp = new Array(s.length + 1).fill(0);\n    dp[0] = 1;\n    for(let i = 1; i <= s.length; i++){\n        for(let j = 1; j <= i; j++){\n            if(s[i - j] == ' '){\n                continue;\n            }\n            let num = parseInt(s.substring(i - j, i));\n            if(num <= 26){\n                dp[i] = (dp[i] + dp[i - j]) % mod;\n            }\n        }\n    }\n    return dp[s.length];\n    \n};"}
{"id": "2218", "path": "output2\\js\\Hard\\2218-number-of-great-partitions.js", "hypo_code": "var countPartitions = function(nums, k) {\n    let mod = 1000000007;\n    let sum = 0;\n    let ans = 0;\n    let dp = new Array(nums.length + 1).fill(0);\n    dp[0] = 1;\n    for(let i = 0; i < nums.length; i++){\n        sum += nums[i];\n        for(let j = i; j >= 0; j--){\n            if(sum - nums[j] >= k){\n                dp[i + 1] = (dp[i + 1] + dp[j]) % mod;\n            }\n        }\n        if(sum >= k){\n            ans = (ans + dp[i + 1]) % mod;\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2219", "path": "output2\\js\\Hard\\2219-maximize-the-minimum-powered-city.js", "hypo_code": "var maxPower = function(stations, r, k) {\n    let n = stations.length;\n    let ans = 0;\n    let left = 1;\n    let right = 100000;\n    while(left <= right){\n        let mid = Math.floor((left + right) / 2);\n        let cnt = 0;\n        for(let i = 0; i < n; i++){\n            let j = i;\n            while(j < n && stations[j] - stations[i] <= 2 * r){\n                j++;\n            }\n            cnt += Math.floor((j - i - 1) / (mid + 1));\n            i = j - 1;\n        }\n        if(cnt <= k){\n            ans = mid;\n            right = mid - 1;\n        }\n        else{\n            left = mid + 1;\n        }\n    }\n    return ans;\n    \n};"}
{"id": "2220", "path": "output2\\js\\Hard\\2220-time-to-cross-a-bridge.js", "hypo_code": "var findCrossingTime = function(n, k, time) {\n    let ans = 0;\n    let left = new Array(k).fill(0);\n    let right = new Array(k).fill(0);\n    let leftToRight = new Array(k).fill(0);\n    let rightToLeft = new Array(k).fill(0);\n    let pickOld = new Array(k).fill(0);\n    let putNew = new Array(k).fill(0);\n    for(let i = 0; i < k; i++){\n        leftToRight[i] = time[i][0];\n        pickOld[i] = time[i][1];\n        rightToLeft[i] = time[i][2];\n        putNew[i] = time[i][3];\n    }\n    let leftToRightSorted = leftToRight.slice().sort((a, b) => a - b);\n    let rightToLeftSorted = rightToLeft.slice().sort((a, b) => a - b);\n    let pickOldSorted = pickOld.slice().sort((a, b) => a - b);\n    let putNewSorted = putNew.slice().sort((a, b) => a - b);\n    let leftToRightMap = new Map();\n    let rightToLeftMap = new Map();\n    let pickOldMap = new Map();\n    let putNewMap = new Map();\n    for(let i = 0; i < k; i++){\n        leftToRightMap.set(leftToRightSorted[i], i);\n        rightToLeftMap.set(rightToLeftSorted[i], i);\n        pickOldMap.set(pickOldSorted[i], i);\n        putNewMap.set(putNewSorted[i], i);\n    }\n    let leftToRightIndex = 0;\n    let rightToLeftIndex = 0;\n    let pickOldIndex = 0;\n    let putNewIndex = 0;\n    let leftToRightCount = 0;\n    let rightToLeftCount = 0;\n    let pickOldCount = 0;\n    let putNewCount = 0;\n    let leftToRightSet = new Set();\n    let rightToLeftSet = new Set();\n    let pickOldSet = new Set();\n    let putNewSet = new Set();\n    while(n > 0){\n        if(leftToRightCount < k && rightToLeftCount < k && pickOldCount < k && putNewCount < k){\n            let leftToRightMin = leftToRightSorted[leftToRightIndex];\n            let rightToLeftMin = rightToLeftSorted[rightToLeftIndex];\n            let pickOldMin = pickOldSorted[pickOldIndex];\n            let putNewMin = putNewSorted[putNewIndex];\n            let min = Math.min(leftToRightMin, rightToLeftMin, pickOldMin, putNewMin);\n            if(min == leftToRightMin){\n                leftToRightSet.add(leftToRightMap.get(leftToRightMin));\n                leftToRightIndex++;\n                leftToRightCount++;\n            }\n            if(min == rightToLeftMin){\n                rightToLeftSet.add(rightToLeftMap.get(rightToLeftMin));\n                rightToLeftIndex++;\n                rightToLeftCount++;\n            }\n            if(min == pickOldMin){\n                pickOldSet.add(pickOldMap.get(pickOldMin));\n                pickOldIndex++;\n                pickOldCount++;\n            }\n            if(min == putNewMin){\n                putNewSet.add(putNewMap.get(putNewMin));\n                putNewIndex++;\n                putNewCount++;\n            }\n            ans += min;\n        }\n        else if(leftToRightCount < k && rightToLeftCount < k && pickOldCount < k){\n            let leftToRightMin = leftToRightSorted[leftToRightIndex];\n            let rightToLeftMin = rightToLeftSorted[rightToLeftIndex];\n            let pickOldMin = pickOldSorted[pickOldIndex];\n            let min = Math.min(leftToRightMin, rightToLeftMin, pickOldMin);\n            if(min == leftToRightMin){\n                leftToRightSet.add(leftToRightMap.get(leftToRightMin));\n                leftToRightIndex++;\n                leftToRightCount++;\n            }\n            if(min == rightToLeftMin){\n                rightToLeftSet.add(rightToLeftMap.get(rightToLeftMin));\n                rightToLeftIndex++;\n                rightToLeftCount++;\n            }\n            if(min == pickOldMin){\n                pickOldSet.add(pickOldMap.get(pickOldMin));\n                pickOldIndex++;\n                pickOldCount++;\n            }\n            ans += min;\n        }\n        else if(leftToRightCount < k && rightToLeftCount < k && putNewCount < k){\n            let leftToRightMin = leftToRightSorted[leftToRightIndex];\n            let rightToLeftMin = rightToLeftSorted[rightToLeftIndex];\n            let putNewMin = putNewSorted[putNewIndex];\n            let min = Math.min(leftToRightMin, rightToLeftMin, putNewMin);\n            if(min == leftToRightMin){\n                leftToRightSet.add(leftToRightMap.get(leftToRightMin));\n                leftToRightIndex++;\n                leftToRightCount++;\n            }\n            if(min == rightToLeftMin){\n                rightToLeftSet.add(rightToLeftMap.get(rightToLeftMin));\n                rightToLeftIndex++;\n                rightToLeftCount++;\n            }\n            if(min == putNewMin){\n                putNewSet.add(putNewMap.get(putNewMin));\n                putNewIndex++;\n                putNewCount++;\n            }\n            ans += min;\n        }\n        else if(leftToRightCount < k && pickOldCount < k && putNewCount < k){\n     \n};"}
{"id": "2221", "path": "output2\\js\\Hard\\2221-difference-between-maximum-and-minimum-price-sum.js", "hypo_code": "var maxOutput = function(n, edges, price) {\n    let graph = new Array(n);\n    for(let i = 0; i < n; i++){\n        graph[i] = [];\n    }\n    for(let i = 0; i < edges.length; i++){\n        graph[edges[i][0]].push(edges[i][1]);\n        graph[edges[i][1]].push(edges[i][0]);\n    }\n    let max = new Array(n).fill(0);\n    let min = new Array(n).fill(0);\n    let visited = new Array(n).fill(false);\n    let dfs = function(node){\n        visited[node] = true;\n        max[node] = price[node];\n        min[node] = price[node];\n        for(let i = 0; i < graph[node].length; i++){\n            if(!visited[graph[node][i]]){\n                dfs(graph[node][i]);\n                max[node] = Math.max(max[node], max[graph[node][i]]);\n                min[node] = Math.min(min[node], min[graph[node][i]]);\n            }\n        }\n    };\n    dfs(0);\n    let result = 0;\n    for(let i = 0; i < n; i++){\n        result = Math.max(result, max[i] - min[i]);\n    }\n    return result;\n    \n};"}
{"id": "2222", "path": "output2\\js\\Hard\\2222-check-if-point-is-reachable.js", "hypo_code": "var isReachable = function(targetX, targetY) {\n    let dp = [];\n    for(let i = 0; i <= targetX; i++){\n        dp.push([]);\n        for(let j = 0; j <= targetY; j++){\n            dp[i].push(false);\n        }\n    }\n    dp[1][1] = true;\n    for(let i = 1; i <= targetX; i++){\n        for(let j = 1; j <= targetY; j++){\n            if(dp[i][j]){\n                if(i - j > 0){\n                    dp[i - j][j] = true;\n                }\n                if(j - i > 0){\n                    dp[i][j - i] = true;\n                }\n                dp[2 * i][j] = true;\n                dp[i][2 * j] = true;\n            }\n        }\n    }\n    return dp[targetX][targetY];\n    \n};"}
{"id": "2223", "path": "output2\\js\\Hard\\2223-minimum-cost-to-split-an-array.js", "hypo_code": "var minCost = function(nums, k) {\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n};"}
{"id": "2224", "path": "output2\\js\\Hard\\2224-put-marbles-in-bags.js", "hypo_code": "var putMarbles = function(weights, k) {\n    let n = weights.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][i] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = i - 1; j >= 0; j--){\n            if(s[i - 1] === s[j]){\n                dp[i][j] = dp[i - 1][j];\n            }else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j + 1]) + 1;\n            }\n        }\n    }\n    return dp[n][0];\n    \n};"}
{"id": "2225", "path": "output2\\js\\Hard\\2225-count-increasing-quadruplets.js", "hypo_code": "var countQuadruplets = function(nums) {\n\n    let n = nums.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= n; j++){\n            dp[i].push([]);\n            for(let k = 0; k <= n; k++){\n                dp[i][j].push([]);\n                for(let l = 0; l <= n; l++){\n                    dp[i][j][k].push(0);\n                }\n            }\n        }\n    }\n    for(let i = 0; i <= n; i++){\n        dp[i][0][0][0] = 1;\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= n; j++){\n            for(let k = 1; k <= n; k++){\n                for(let l = 1; l <= n; l++){\n                    if(nums[i - 1] > nums[l - 1]){\n                        dp[i][j][k][l] = dp[i - 1][j - 1][k - 1][l - 1] + dp[i - 1][j][k][l];\n                    }else{\n                        dp[i][j][k][l] = dp[i - 1][j][k][l];\n                    }\n                }\n            }\n        }\n    let ans = [];\n    for(let i = 1; i <= n; i++){\n        ans.push(dp[n][n][n][i] - dp[n][n][n][i - 1]);\n    }\n    return ans;\n    \n\n    \n\n    \n};"}
{"id": "2226", "path": "output2\\js\\Hard\\2226-rearranging-fruits.js", "hypo_code": "var minCost = function(basket1, basket2) {\n    let n = basket1.length;\n    let m = basket2.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= m; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            dp[i][j] = Math.min(dp[i - 1][j - 1] + Math.min(basket1[i - 1], basket2[j - 1]), dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    return dp[n][m];\n    \n};"}
{"id": "2227", "path": "output2\\js\\Hard\\2227-subsequence-with-the-minimum-score.js", "hypo_code": "var minimumScore = function(s, t) {\n    let n = s.length;\n    let m = t.length;\n    let dp = [];\n    for(let i = 0; i <= n; i++){\n        dp.push([]);\n        for(let j = 0; j <= m; j++){\n            dp[i].push(0);\n        }\n    }\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            if(s[i - 1] === t[j - 1]){\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            }else{\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    let result = 0;\n    for(let i = 1; i <= n; i++){\n        for(let j = 1; j <= m; j++){\n            if(dp[i][j] === dp[n][m]){\n                result = Math.max(result, i - j + 1);\n            }\n        }\n    }\n    return result;\n    \n};"}
{"id": "2228", "path": "output2\\js\\Hard\\2228-handling-sum-queries-after-update.js", "hypo_code": "var handleQuery = function(nums1, nums2, queries) {\n    let n = nums1.length;\n    let m = nums2.length;\n    let result = [];\n    for(let i = 0; i < queries.length; i++){\n        let type = queries[i][0];\n        if(type === 1){\n            let l = queries[i][1];\n            let r = queries[i][2];\n            for(let j = l; j <= r; j++){\n                nums1[j] = 1 - nums1[j];\n            }\n        }else if(type === 2){\n            let p = queries[i][1];\n            for(let j = 0; j < m; j++){\n                nums2[j] += nums1[j] * p;\n            }\n        }else{\n            let sum = 0;\n            for(let j = 0; j < m; j++){\n                sum += nums2[j];\n            }\n            result.push(sum);\n        }\n    }\n    return result;\n    \n};"}
{"id": "2229", "path": "output2\\js\\Hard\\2229-find-the-string-with-lcp.js", "hypo_code": "var findTheString = function(lcp) {\n    let n = lcp.length;\n    let result = \"\";\n    let visited = new Set();\n    let dfs = function(index, word){\n        if(index === n){\n            if(result === \"\" || word < result){\n                result = word;\n            }\n            return;\n        }\n        for(let i = 0; i < n; i++){\n            if(!visited.has(i)){\n                let prefix = lcp[index][i];\n                let next = word + String.fromCharCode(97 + i);\n                if(result !== \"\" && next > result){\n                    continue;\n                }\n                visited.add(i);\n                dfs(index + 1, next.substring(next.length - prefix));\n                visited.delete(i);\n            }\n        }\n    }\n    dfs(0, \"\");\n    return result;\n    \n    \n};"}
{"id": "2230", "path": "output2\\js\\Hard\\2230-minimum-time-to-visit-a-cell-in-a-grid.js", "hypo_code": "var minimumTime = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let queue = [[0, 0, 0]];\n    let visited = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    visited[0][0] = true;\n    while (queue.length > 0) {\n        let [i, j, k] = queue.shift();\n        if (i === m - 1 && j === n - 1) {\n            return k;\n        }\n        for (let [di, dj] of directions) {\n            let ni = i + di;\n            let nj = j + dj;\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && !visited[ni][nj]) {\n                visited[ni][nj] = true;\n                if (grid[ni][nj] <= k + 1) {\n                    queue.push([ni, nj, k + 1]);\n                } else {\n                    queue.unshift([ni, nj, grid[ni][nj]]);\n                }\n            }\n        }\n    }\n    return -1;\n};"}
{"id": "2231", "path": "output2\\js\\Hard\\2231-count-number-of-possible-root-nodes.js", "hypo_code": "var rootCount = function(edges, guesses, k) {\n    let n = edges.length + 1;\n    let graph = new Array(n).fill(0).map(() => []);\n    for (let [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    let count = 0;\n    let visited = new Array(n).fill(false);\n    let dfs = (u) => {\n        visited[u] = true;\n        let children = [];\n        for (let v of graph[u]) {\n            if (!visited[v]) {\n                children.push(dfs(v));\n            }\n        }\n        if (children.length === 0) {\n            return 1;\n        }\n        children.sort((a, b) => a - b);\n        for (let i = 0; i < k; i++) {\n            if (children[i] === 0) {\n                return 0;\n            }\n        }\n        if (children.length > k) {\n            return 0;\n        }\n        return children.reduce((a, b) => a + b);\n    };\n    for (let [u, v] of guesses) {\n        visited = new Array(n).fill(false);\n        if (dfs(v) > 0) {\n            count++;\n        }\n    }\n    return count;\n};"}
{"id": "2232", "path": "output2\\js\\Hard\\2232-split-the-array-to-make-coprime-products.js", "hypo_code": "var findValidSplit = function(nums) {\n    let n = nums.length;\n    let result = -1;\n    let primes = new Array(50).fill(0).map(() => []);\n    for (let i = 2; i < primes.length; i++) {\n        if (primes[i].length === 0) {\n            for (let j = i; j < primes.length; j += i) {\n                primes[j].push(i);\n            }\n        }\n    }\n    let index = new Array(50).fill(-1);\n    for (let i = 0; i < n; i++) {\n        for (let p of primes[nums[i]]) {\n            if (index[p] !== -1) {\n                result = Math.max(result, index[p]);\n            }\n            index[p] = i;\n        }\n        result = Math.max(result, index[1]);\n    }\n    return result;\n\n};"}
{"id": "2233", "path": "output2\\js\\Hard\\2233-number-of-ways-to-earn-points.js", "hypo_code": "var waysToReachTarget = function(target, types) {\n    let dp = new Array(target + 1).fill(0);\n    dp[0] = 1;\n    let mod = 1000000007;\n    for (let [count, marks] of types) {\n        for (let i = target; i >= 0; i--) {\n            if (i >= marks) {\n                dp[i] += dp[i - marks] * count;\n                dp[i] %= mod;\n            }\n        }\n    }\n    return dp[target];\n};"}
{"id": "2234", "path": "output2\\js\\Hard\\2234-minimum-time-to-complete-all-tasks.js", "hypo_code": "var findMinimumTime = function(tasks) {\n    let events = [];\n    for (let [start, end, duration] of tasks) {\n        events.push([start, duration]);\n        events.push([end + 1, -duration]);\n    }\n    events.sort((a, b) => a[0] - b[0]);\n    let result = 0;\n    let count = 0;\n    for (let [_, delta] of events) {\n        count += delta;\n        result = Math.max(result, count);\n    }\n    return result;\n};"}
{"id": "2235", "path": "output2\\js\\Hard\\2235-collect-coins-in-a-tree.js", "hypo_code": "var collectTheCoins = function(coins, edges) { \n    let n = coins.length;\n    let adj = Array.from({length: n}, () => []);\n    for (let [u, v] of edges) {\n        adj[u].push(v);\n        adj[v].push(u);\n    }\n    let ans = 0;\n    let dfs = (u, p) => {\n        let cnt = coins[u];\n        for (let v of adj[u]) {\n            if (v != p) {\n                cnt += dfs(v, u);\n            }\n        }\n        if (cnt > 1) {\n            ans += 2;\n            cnt -= 2;\n        }\n        return cnt;\n    }\n    dfs(0, -1);\n    return ans;\n};"}
{"id": "2236", "path": "output2\\js\\Hard\\2236-shortest-cycle-in-a-graph.js", "hypo_code": "var findShortestCycle = function(n, edges) {\n    let adj = Array.from({length: n}, () => []);\n    for (let [u, v] of edges) {\n        adj[u].push(v);\n        adj[v].push(u);\n    }\n    let ans = Infinity;\n    let dfs = (u, p, d) => {\n        if (d > ans) return;\n        for (let v of adj[u]) {\n            if (v != p) {\n                if (v == u) {\n                    ans = Math.min(ans, d + 1);\n                } else {\n                    dfs(v, u, d + 1);\n                }\n            }\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        dfs(i, -1, 0);\n    }\n    return ans == Infinity ? -1 : ans;\n};"}
{"id": "2237", "path": "output2\\js\\Hard\\2237-minimum-reverse-operations.js", "hypo_code": "var minReverseOperations = function(n, p, banned, k) {\n    let ans = Array.from({length: n}, () => -1);\n    let adj = Array.from({length: n}, () => []);\n    for (let i = 0; i < n; i++) {\n        if (i - k >= 0) adj[i].push(i - k);\n        if (i + k < n) adj[i].push(i + k);\n    }\n    for (let u of banned) {\n        adj[u] = [];\n    }\n    let dfs = (u, d) => {\n        if (d >= ans[u]) return;\n        ans[u] = d;\n        for (let v of adj[u]) {\n            dfs(v, d + 1);\n        }\n    }\n    dfs(p, 0);\n    return ans;\n};"}
{"id": "2238", "path": "output2\\js\\Hard\\2238-minimum-number-of-visited-cells-in-a-grid.js", "hypo_code": "var minimumVisitedCells = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let ans = Array.from({length: m}, () => Array.from({length: n}, () => Infinity));\n    let q = [];\n    q.push([0, 0]);\n    ans[0][0] = 0;\n    while (q.length) {\n        let [i, j] = q.shift();\n        if (i + grid[i][j] < m && ans[i][j] + 1 < ans[i + grid[i][j]][j]) {\n            ans[i + grid[i][j]][j] = ans[i][j] + 1;\n            q.push([i + grid[i][j], j]);\n        }\n        if (j + grid[i][j] < n && ans[i][j] + 1 < ans[i][j + grid[i][j]]) {\n            ans[i][j + grid[i][j]] = ans[i][j] + 1;\n            q.push([i, j + grid[i][j]]);\n        }\n    }\n    return ans[m - 1][n - 1] == Infinity ? -1 : ans[m - 1][n - 1];\n\n};"}
{"id": "2241", "path": "output2\\js\\Hard\\2241-minimize-the-total-price-of-the-trips.js", "hypo_code": "var minimumTotalPrice = function(n, edges, price, trips) {\n    let adj = Array.from({length: n}, () => []);\n    for (let [u, v] of edges) {\n        adj[u].push(v);\n        adj[v].push(u);\n    }\n    let ans = 0;\n    let dfs = (u, p) => {\n        let cnt = price[u];\n        for (let v of adj[u]) {\n            if (v != p) {\n                cnt += dfs(v, u);\n            }\n        }\n        if (cnt > 1) {\n            ans += 2;\n            cnt -= 2;\n        }\n        return cnt;\n    }\n    dfs(0, -1);\n    return ans;\n};"}
{"id": "2243", "path": "output2\\js\\Hard\\2243-make-array-empty.js", "hypo_code": "var countOperationsToEmptyArray = function(nums) { \n    let n = nums.length;\n    let ans = 0;\n    let idx = 0;\n    while (idx < n) {\n        if (nums[idx] == idx) {\n            idx++;\n        } else {\n            let tmp = nums[nums[idx]];\n            nums[nums[idx]] = nums[idx];\n            nums[idx] = tmp;\n            ans++;\n        }\n    }\n    return ans;\n};"}
{"id": "2244", "path": "output2\\js\\Hard\\2244-lexicographically-smallest-beautiful-string.js", "hypo_code": "var smallestBeautifulString = function(s, k) {\n    let n = s.length;\n    let ans = '';\n    let dfs = (u, d) => {\n        if (d == k) {\n            ans = u;\n            return;\n        }\n        for (let c = 'a'; c <= 'z'; c++) {\n            if (u + c <= s && !u.endsWith(c)) {\n                dfs(u + c, d + 1);\n            }\n        }\n    }\n    dfs('', 0);\n    return ans;\n};"}
{"id": "2245", "path": "output2\\js\\Hard\\2245-power-of-heroes.js", "hypo_code": "var sumOfPower = function(nums) {\n    let n = nums.length;\n    let ans = 0;\n    let dfs = (u, d) => {\n        if (d == n) {\n            ans = (ans + Math.max(...u) * Math.min(...u)) % 1e9 + 7;\n            return;\n        }\n        for (let i = 0; i < 2; i++) {\n            dfs(u.concat(i ? nums[d] : 0), d + 1);\n        }\n    }\n    dfs([], 0);\n    return ans;\n};"}
{"id": "2246", "path": "output2\\js\\Hard\\2246-modify-graph-edge-weights.js", "hypo_code": "var modifiedGraphEdges = function(n, edges, source, destination, target) {\n    let adj = Array.from({length: n}, () => []);\n    let idx = 0;\n    let w = Array.from({length: n}, () => []);\n    for (let [u, v, wi] of edges) {\n        adj[u].push(v);\n        adj[v].push(u);\n        if (wi == -1) {\n            w[u].push(idx);\n            w[v].push(idx);\n            idx++;\n        }\n    }\n    let ans = [];\n    let vis = Array.from({length: n}, () => false);\n    let dfs = (u, p, d) => {\n        if (vis[u]) return;\n        vis[u] = true;\n        if (u == destination) {\n            if (d == target) {\n                for (let i = 0; i < idx; i++) {\n                    ans.push([edges[i][0], edges[i][1], d + 1]);\n                }\n            }\n        } else {\n            for (let v of adj[u]) {\n                if (v != p) {\n                    dfs(v, u, d + 1);\n                }\n            }\n        }\n        vis[u] = false;\n    }\n    dfs(source, -1, 0);\n    return ans;\n};"}
{"id": "2247", "path": "output2\\js\\Hard\\2247-greatest-common-divisor-traversal.js", "hypo_code": "var canTraverseAllPairs = function(nums) {\n    let n = nums.length;\n    let adj = Array.from({length: n}, () => []);\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n ; j++) {\n            if (gcd(nums[i], nums[j]) > 1) {\n                adj[i].push(j);\n                adj[j].push(i);\n            }\n        }\n    }\n    let dfs = (u, p, d) => {\n        if (d == n) return true;\n        for (let v of adj[u]) {\n            if (v != p) {\n                if (dfs(v, u, d + 1)) return true;\n            }\n        }\n        return false;\n    }\n    for (let i = 0; i < n; i++) {\n        if (!dfs(i, -1, 1)) return false;\n    }\n    return true;\n};"}
{"id": "2248", "path": "output2\\js\\Hard\\2248-maximum-strictly-increasing-cells-in-a-matrix.js", "hypo_code": "var maxIncreasingCells = function(mat) {\n    let m = mat.length;\n    let n = mat[0].length;\n    let ans = Array.from({length: m}, () => Array.from({length: n}, () => 1));\n    let q = [];\n    let inq = Array.from({length: m}, () => Array.from({length: n}, () => false));\n    let dx = [1, 0];\n    let dy = [0, 1];\n    let check = (i, j) => {\n        for (let k = 0; k < 2; k++) {\n            let x = i + dx[k];\n            let y = j + dy[k];\n            if (x < m && y < n && mat[x][y] > mat[i][j]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n ; j++) {\n            if (!check(i, j)) {\n                q.push([i, j]);\n                inq[i][j] = true;\n            }\n        }\n    }\n    while (q.length) {\n        let [i, j] = q.shift();\n        for (let k = 0; k < 2; k++) {\n            let x = i + dx[k];\n            let y = j + dy[k];\n            if (x < m && y < n && mat[x][y] > mat[i][j]) {\n                ans[x][y] = Math.max(ans[x][y], ans[i][j] + 1);\n                if (!inq[x][y]) {\n                    q.push([x, y]);\n                    inq[x][y] = true;\n                }\n            }\n        }\n    }\n    let res = 0;\n    for (let i = 0; i < m; i++) {\n        res = Math.max(res, ...ans[i]);\n    }\n    return res;\n};"}
{"id": "2249", "path": "output2\\js\\Hard\\2249-count-of-integers.js", "hypo_code": "var count = function(num1, num2, min_sum, max_sum) { \n    let result = 0;\n    let i = 0;\n    while (i < n) {\n        result += 2;\n        i++;\n    }\n    return result;\n   \n\n};"}
{"id": "2250", "path": "output2\\js\\Hard\\2250-find-a-good-subset-of-the-matrix.js", "hypo_code": "var goodSubsetofBinaryMatrix = function(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    let ans = [];\n    let dfs = (u, d) => {\n        if (d == m) {\n            let s = Array.from({length: n}, () => 0);\n            for (let i = 0; i < m; i++) {\n                if (u & (1 << i)) {\n                    for (let j = 0; j < n; j++) {\n                        s[j] += grid[i][j];\n                    }\n                }\n            }\n            let ok = true;\n            for (let i = 0; i < n; i++) {\n                if (s[i] > (u.toString(2).split('1').length - 1) / 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                ans.push(u);\n            }\n            return;\n        }\n        dfs(u, d + 1);\n        dfs(u | (1 << d), d + 1);\n    }\n    dfs(0, 0);\n    return ans.sort((a, b) => a - b);\n};"}
{"id": "2251", "path": "output2\\js\\Hard\\2251-maximum-sum-queries.js", "hypo_code": "var maximumSumQueries = function(nums1, nums2, queries) {\n    let result = [];\n    for (let i = 0; i < queries.length; i++) {\n        let max = -1;\n        for (let j = 0; j < nums1.length; j++) {\n            if (nums1[j] >= queries[i][0] && nums2[j] >= queries[i][1]) {\n                let sum = nums1[j] + nums2[j];\n                if (sum > max) {\n                    max = sum;\n                }\n            }\n        }\n        result.push(max);\n    }\n    return result;\n\n};"}
{"id": "2252", "path": "output2\\js\\Hard\\2252-painting-the-walls.js", "hypo_code": "var paintWalls = function(cost, time) {\n    let dp = new Array(cost.length).fill(0);\n    dp[0] = cost[0];\n    dp[1] = cost[1];\n    for (let i = 2; i < cost.length; i++) {\n        dp[i] = Math.min(dp[i-1] + cost[i], dp[i-2] + cost[i-1]);\n    }\n    return dp[dp.length-1];\n};"}
{"id": "2253", "path": "output2\\js\\Hard\\2253-robot-collisions.js", "hypo_code": "var survivedRobotsHealths = function(positions, healths, directions) {\n    let result = [];\n    let robots = [];\n    for (let i = 0; i < positions.length; i++) {\n        robots.push([positions[i], healths[i], directions[i]]);\n    }\n    robots.sort(function(a, b) {\n        return a[0] - b[0];\n    });\n    for (let i = 0; i < robots.length; i++) {\n        if (robots[i][2] === 'L') {\n            for (let j = i - 1; j >= 0; j--) {\n                if (robots[j][2] === 'R' && robots[j][0] >= robots[i][0]) {\n                    if (robots[j][1] > robots[i][1]) {\n                        robots.splice(i, 1);\n                        i--;\n                    } else if (robots[j][1] < robots[i][1]) {\n                        robots.splice(j, 1);\n                        i--;\n                    } else {\n                        robots.splice(i, 1);\n                        robots.splice(j, 1);\n                        i--;\n                    }\n                    break;\n                }\n            }\n        } else {\n            for (let j = i + 1; j < robots.length; j++) {\n                if (robots[j][2] === 'L' && robots[j][0] <= robots[i][0]) {\n                    if (robots[j][1] > robots[i][1]) {\n                        robots.splice(i, 1);\n                        i--;\n                    } else if (robots[j][1] < robots[i][1]) {\n                        robots.splice(j, 1);\n                        i--;\n                    } else {\n                        robots.splice(i, 1);\n                        robots.splice(j, 1);\n                        i--;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    for (let i = 0; i < robots.length; i++) {\n        result.push(robots[i][1]);\n    }\n    return result;\n};"}
{"id": "2254", "path": "output2\\js\\Hard\\2254-sum-of-imbalance-numbers-of-all-subarrays.js", "hypo_code": "var sumImbalanceNumbers = function(nums) {\n    let result = 0;\n    for (let i = 0; i < nums.length; i++) {\n        let max = nums[i];\n        let min = nums[i];\n        for (let j = i; j < nums.length; j++) {\n            if (nums[j] > max) {\n                max = nums[j];\n            } else if (nums[j] < min) {\n                min = nums[j];\n            }\n            if (max - min > 1) {\n                result++;\n            }\n        }\n    }\n    return result;\n};"}
{"id": "2255", "path": "output2\\js\\Hard\\2255-length-of-the-longest-valid-substring.js", "hypo_code": "var longestValidSubstring = function(word, forbidden) {\n    let result = 0;\n    let dp = new Array(word.length).fill(0);\n    for (let i = 0; i < word.length; i++) {\n        for (let j = i; j < word.length; j++) {\n            let subStr = word.slice(i, j+1);\n            if (forbidden.indexOf(subStr) === -1) {\n                dp[i] = j - i + 1;\n                break;\n            }\n        }\n        if (dp[i] > result) {\n            result = dp[i];\n        }\n    }\n    return result;\n};"}
{"id": "2256", "path": "output2\\js\\Hard\\2256-maximum-number-of-groups-with-increasing-length.js", "hypo_code": "var maxIncreasingGroups = function(usageLimits) {\n    let result = 0;\n    let dp = new Array(usageLimits.length).fill(0);\n    for (let i = 0; i < usageLimits.length; i++) {\n        if (usageLimits[i] > 0) {\n            dp[i] = 1;\n        }\n    }\n    for (let i = 1; i < usageLimits.length; i++) {\n        if (usageLimits[i] > 0) {\n            if (usageLimits[i] > usageLimits[i-1]) {\n                dp[i] = dp[i-1] + 1;\n            } else {\n                dp[i] = dp[i-1];\n            }\n        }\n    }\n    return dp[dp.length-1];\n};"}
{"id": "2257", "path": "output2\\js\\Hard\\2257-count-paths-that-can-form-a-palindrome-in-a-tree.js", "hypo_code": "var countPalindromePaths = function(parent, s) {\n    let graph = new Array(parent.length).fill(0).map(() => []);\n    for (let i = 1; i < parent.length; i++) {\n        graph[parent[i]].push(i);\n        graph[i].push(parent[i]);\n    }\n    let result = 0;\n    let dfs = (node, path) => {\n        let counts = new Array(26).fill(0);\n        counts[s.charCodeAt(node)-97]++;\n        for (let i = 0; i < graph[node].length; i++) {\n            let child = graph[node][i];\n            if (child !== path) {\n                let childCounts = dfs(child, node);\n                for (let j = 0; j < counts.length; j++) {\n                    counts[j] += childCounts[j];\n                }\n            }\n        }\n        let odd = 0;\n        for (let i = 0; i < counts.length; i++) {\n            if (counts[i] % 2 === 1) {\n                odd++;\n            }\n        }\n        if (odd <= 1) {\n            result++;\n        }\n        return counts;\n    }\n    dfs(0, null);\n    return result;\n};"}
{"id": "2258", "path": "output2\\js\\Hard\\2258-count-stepping-numbers-in-range.js", "hypo_code": "var countSteppingNumbers = function(low, high) {\n    let result = 0;\n    let lowNumber = parseInt(low);\n    let highNumber = parseInt(high);\n    for (let i = lowNumber; i <= highNumber; i++) {\n        let number = i.toString();\n        let isSteppingNumber = true;\n        for (let j = 0; j < number.length - 1; j++) {\n            if (Math.abs(parseInt(number[j]) - parseInt(number[j+1])) !== 1) {\n                isSteppingNumber = false;\n                break;\n            }\n        }\n        if (isSteppingNumber) {\n            result++;\n        }\n    }\n    return result;\n};"}
{"id": "2259", "path": "output2\\js\\Hard\\2259-minimum-time-to-make-array-sum-at-most-x.js", "hypo_code": "var minimumTime = function(nums1, nums2, x) {\n    let result = -1;\n    let sum = 0;\n    let i = 0;\n    for (; i < nums1.length; i++) {\n        sum += nums1[i];\n        if (sum > x) {\n            break;\n        }\n    }\n    if (sum <= x) {\n        return i + nums1.length;\n    }\n    let j = nums2.length - 1;\n    while (j >= 0) {\n        sum += nums2[j];\n        j--;\n        while (sum > x && i >= 0) {\n            sum -= nums1[i];\n            i--;\n        }\n        if (sum <= x && i + j + 2 < result || result === -1) {\n            result = i + j + 2;\n        }\n    }\n    return result;\n};"}
{"id": "2260", "path": "output2\\js\\Hard\\2260-maximum-elegance-of-a-k-length-subsequence.js", "hypo_code": "var findMaximumElegance = function(items, k) {\n    let result = 0;\n    let profits = [];\n    let categories = [];\n    for (let i = 0; i < items.length; i++) {\n        profits.push(items[i][0]);\n        categories.push(items[i][1]);\n    }\n    let max = 0;\n    for (let i = 0; i < profits.length; i++) {\n        for (let j = i + 1; j < profits.length; j++) {\n            if (profits[i] + profits[j] > max) {\n                max = profits[i] + profits[j];\n            }\n        }\n    }\n    result = max;\n    return result;\n};"}
{"id": "2261", "path": "output2\\js\\Hard\\2261-apply-operations-to-maximize-score.js", "hypo_code": "var maximumScore = function(nums, k) {\n    let result = 0;\n    let primes = [];\n    let max = 0;\n    for (let i = 0; i < nums.length; i++) {\n        primes.push(primeFactors(nums[i]));\n        if (primes[i] > max) {\n            max = primes[i];\n        }\n    }\n    let i = k;\n    let j = k;\n    while (i >= 0 && j < nums.length) {\n        let min = nums[i] < nums[j] ? nums[i] : nums[j];\n        let prime = primes[i] < primes[j] ? primes[i] : primes[j];\n        if (prime === max) {\n            result += min * prime;\n            max--;\n        }\n        if (i === 0) {\n            j++;\n        } else if (j === nums.length - 1) {\n            i--;\n        } else if (nums[i - 1] > nums[j + 1]) {\n            i--;\n        } else {\n            j++;\n        }\n    }\n    return result;\n};"}
