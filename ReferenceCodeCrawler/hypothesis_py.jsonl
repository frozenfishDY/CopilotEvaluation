{"id": "1", "path": "output2\\py\\Easy\\1-two-sum.py", "hypo_code": "class Solution(object):\n    def twoSum(self, nums, target):\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]"}
{"id": "2", "path": "output2\\py\\Easy\\2-palindrome-number.py", "hypo_code": "class Solution(object):\n    def isPalindrome(self, x):\n         \n        if x<0:\n            return False\n        else:\n            str=str(x)\n            for i in range(0,len(str)/2):\n                if str[i]!=str[len(str)-1-i]:\n                    return False\n            return True"}
{"id": "3", "path": "output2\\py\\Easy\\3-roman-to-integer.py", "hypo_code": "class Solution(object):\n    def romanToInt(self, s):\n        \n        roman_dict = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i<len(s)-1 and roman_dict[s[i]]<roman_dict[s[i+1]]:\n                result-=roman_dict[s[i]]\n            else:\n                result+=roman_dict[s[i]]\n        return result"}
{"id": "4", "path": "output2\\py\\Easy\\4-longest-common-prefix.py", "hypo_code": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \n        if len(strs)==0:\n            return \"\"\n        elif len(strs)==1:\n            return strs[0]\n        else:\n            res=\"\"\n            for i in range(0,len(strs[0])):\n                for j in range(1,len(strs)):\n                    if i>=len(strs[j]) or strs[0][i]!=strs[j][i]:\n                        return res\n                res=res+strs[0][i]\n            return res"}
{"id": "5", "path": "output2\\py\\Easy\\5-valid-parentheses.py", "hypo_code": "class Solution(object):\n    def isValid(self, s):\n        \n        if len(s)==0:\n            return True\n        elif len(s)%2==1:\n            return False\n        else:\n            stack=[]\n            for i in range(0,len(s)):\n                if s[i]=='(' or s[i]=='[' or s[i]=='{':\n                    stack.append(s[i])\n                else:\n                    if len(stack)==0:\n                        return False\n                    elif s[i]==')' and stack[len(stack)-1]=='(':\n                        stack.pop()\n                    elif s[i]==']' and stack[len(stack)-1]=='[':\n                        stack.pop()\n                    elif s[i]=='}' and stack[len(stack)-1]=='{':\n                        stack.pop()\n                    else:\n                        return False\n            if len(stack)==0:\n                return True\n            else:\n                return False"}
{"id": "6", "path": "output2\\py\\Easy\\6-merge-two-sorted-lists.py", "hypo_code": "class Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \n        if list1==None:\n            return list2\n        elif list2==None:\n            return list1\n        else:\n            if list1.val<list2.val:\n                res=list1\n                res.next=self.mergeTwoLists(list1.next,list2)\n            else:\n                res=list2\n                res.next=self.mergeTwoLists(list1,list2.next)\n            return res"}
{"id": "7", "path": "output2\\py\\Easy\\7-remove-duplicates-from-sorted-array.py", "hypo_code": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \n        if len(nums)==0:\n            return 0\n        else:\n            i=0\n            for j in range(1,len(nums)):\n                if nums[j]!=nums[i]:\n                    i+=1\n                    nums[i]=nums[j]\n            return i+1"}
{"id": "8", "path": "output2\\py\\Easy\\8-remove-element.py", "hypo_code": "class Solution(object):\n    def removeElement(self, nums, val):\n        \n        if len(nums)==0:\n            return 0\n        else:\n            i=0\n            for j in range(1,len(nums)):\n                if nums[j]!=val:\n                    i+=1\n                    nums[i]=nums[j]\n            return i+1"}
{"id": "9", "path": "output2\\py\\Easy\\9-find-the-index-of-the-first-occurrence-in-a-string.py", "hypo_code": "class Solution(object):\n    def strStr(self, haystack, needle):\n               \n        if needle == '':\n            return 0\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)"}
{"id": "10", "path": "output2\\py\\Easy\\10-search-insert-position.py", "hypo_code": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if target<nums[i]:\n                    return i\n            return len(nums)"}
{"id": "11", "path": "output2\\py\\Easy\\11-length-of-last-word.py", "hypo_code": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \n        if len(s)==0:\n            return 0\n        else:\n            str=s.split()\n            if len(str)==0:\n                return 0\n            else:\n                return len(str[len(str)-1])"}
{"id": "12", "path": "output2\\py\\Easy\\12-plus-one.py", "hypo_code": "class Solution(object):\n    def plusOne(self, digits):\n               \n        res=[]\n        carry=1\n        for i in range(len(digits)-1,-1,-1):\n            res.append((digits[i]+carry)%10)\n            carry=(digits[i]+carry)/10\n        if carry==1:\n            res.append(1)\n        res.reverse()\n        return res"}
{"id": "13", "path": "output2\\py\\Easy\\13-add-binary.py", "hypo_code": "class Solution(object):\n    def addBinary(self, a, b):\n        \n        res=\"\"\n        carry=0\n        i=len(a)-1\n        j=len(b)-1\n        while i>=0 or j>=0:\n            if i>=0 and j>=0:\n                res=str((int(a[i])+int(b[j])+carry)%2)+res\n                carry=(int(a[i])+int(b[j])+carry)/2\n            elif i>=0:\n                res=str((int(a[i])+carry)%2)+res\n                carry=(int(a[i])+carry)/2\n            else:\n                res=str((int(b[j])+carry)%2)+res\n                carry=(int(b[j])+carry)/2\n            i=i-1\n            j=j-1\n        if carry==1:\n            res=\"1\"+res\n        return res"}
{"id": "14", "path": "output2\\py\\Easy\\14-sqrtx.py", "hypo_code": "class Solution(object):\n    def mySqrt(self, x):\n        \n        if x==0:\n            return 0\n        else:\n            return int(x**0.5)"}
{"id": "15", "path": "output2\\py\\Easy\\15-climbing-stairs.py", "hypo_code": "class Solution(object):\n    def climbStairs(self, n):\n        \n        if n==1:\n            return 1\n        elif n==2:\n            return 2\n        else:\n            return self.climbStairs(n-1)+self.climbStairs(n-2)"}
{"id": "16", "path": "output2\\py\\Easy\\16-remove-duplicates-from-sorted-list.py", "hypo_code": "class Solution(object):\n    def deleteDuplicates(self, head):\n        \n        if head==None:\n            return head\n        else:\n            temp=head\n            while temp.next!=None:\n                if temp.val==temp.next.val:\n                    temp.next=temp.next.next\n                else:\n                    temp=temp.next\n            return head"}
{"id": "17", "path": "output2\\py\\Easy\\17-merge-sorted-array.py", "hypo_code": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \n        if m==0:\n            nums1[:]=nums2\n        elif n==0:\n            pass\n        else:\n            i=0\n            j=0\n            while i<m and j<n:\n                if nums1[i]<=nums2[j]:\n                    i+=1\n                else:\n                    nums1.insert(i,nums2[j])\n                    nums1.pop()\n                    i+=1\n                    j+=1\n            if j<n:\n                nums1[i:]=nums2[j:]\n        return nums1"}
{"id": "18", "path": "output2\\py\\Easy\\18-binary-tree-inorder-traversal.py", "hypo_code": "class Solution(object):\n    def inorderTraversal(self, root):\n        \n        res=[]\n        if root==None:\n            return res\n        else:\n            self.inorder(root,res)\n            return res"}
{"id": "19", "path": "output2\\py\\Easy\\19-same-tree.py", "hypo_code": "class Solution(object):\n    def isSameTree(self, p, q):\n        \n        if p==None and q==None:\n            return True\n        elif p==None or q==None:\n            return False\n        else:\n            return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)"}
{"id": "20", "path": "output2\\py\\Easy\\20-symmetric-tree.py", "hypo_code": "class Solution(object):\n    def isSymmetric(self, root):\n        \n        if root==None:\n            return True\n        else:\n            return self.isMirror(root.left,root.right)"}
{"id": "21", "path": "output2\\py\\Easy\\21-maximum-depth-of-binary-tree.py", "hypo_code": "class Solution(object):\n    def maxDepth(self, root):\n        \n        if root==None:\n            return 0\n        else:\n            return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))"}
{"id": "22", "path": "output2\\py\\Easy\\22-convert-sorted-array-to-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def sortedArrayToBST(self, nums):\n               \n        if len(nums)==0:\n            return None\n        else:\n            mid=len(nums)//2\n            root=TreeNode(nums[mid])\n            root.left=self.sortedArrayToBST(nums[:mid])\n            root.right=self.sortedArrayToBST(nums[mid+1:])\n            return root"}
{"id": "23", "path": "output2\\py\\Easy\\23-balanced-binary-tree.py", "hypo_code": "class Solution(object):\n    def isBalanced(self, root):\n        \n        if root==None:\n            return True\n        else:\n            return abs(self.height(root.left)-self.height(root.right))<=1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}
{"id": "24", "path": "output2\\py\\Easy\\24-minimum-depth-of-binary-tree.py", "hypo_code": "class Solution(object):\n    def minDepth(self, root):\n        \n        if root==None:\n            return 0\n        else:\n            return 1+min(self.minDepth(root.left),self.minDepth(root.right))"}
{"id": "25", "path": "output2\\py\\Easy\\25-path-sum.py", "hypo_code": "class Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \n        if root==None:\n            return False\n        else:\n            return self.hasPath(root,targetSum,0)"}
{"id": "26", "path": "output2\\py\\Easy\\26-pascals-triangle.py", "hypo_code": "class Solution(object):\n    def generate(self, numRows):\n        \n        res=[]\n        for i in range(numRows):\n            if i==0:\n                res.append([1])\n            elif i==1:\n                res.append([1,1])\n            else:\n                temp=[1]\n                for j in range(i-1):\n                    temp.append(res[i-1][j]+res[i-1][j+1])\n                temp.append(1)\n                res.append(temp)\n        return res"}
{"id": "27", "path": "output2\\py\\Easy\\27-pascals-triangle-ii.py", "hypo_code": "class Solution(object):\n    def getRow(self, rowIndex):\n        \n        res=[]\n        for i in range(rowIndex+1):\n            if i==0:\n                res.append(1)\n            elif i==1:\n                res.append(1)\n            else:\n                temp=[1]\n                for j in range(i-1):\n                    temp.append(res[j]+res[j+1])\n                temp.append(1)\n                res=temp\n        return res"}
{"id": "28", "path": "output2\\py\\Easy\\28-best-time-to-buy-and-sell-stock.py", "hypo_code": "class Solution(object):\n    def maxProfit(self, prices):\n        \n        if len(prices)==0:\n            return 0\n        min_price=prices[0]\n        max_profit=0\n        for i in range(1,len(prices)):\n            if prices[i]<min_price:\n                min_price=prices[i]\n            else:\n                max_profit=max(max_profit,prices[i]-min_price)\n        return max_profit"}
{"id": "29", "path": "output2\\py\\Easy\\29-valid-palindrome.py", "hypo_code": "class Solution(object):\n    def isPalindrome(self, s):\n        \n        res=\"\"\n        for i in range(len(s)):\n            if s[i].isalnum():\n                res=res+s[i].lower()\n        return res==self.reverse(res)"}
{"id": "30", "path": "output2\\py\\Easy\\30-single-number.py", "hypo_code": "class Solution(object):\n    def singleNumber(self, nums):\n        \n        res=0\n        for i in range(len(nums)):\n            res=res^nums[i]\n        return res"}
{"id": "31", "path": "output2\\py\\Easy\\31-linked-list-cycle.py", "hypo_code": "class Solution(object):\n    def hasCycle(self, head):\n        \n        if head==None:\n            return False\n        slow=head\n        fast=head.next\n        while slow!=fast:\n            if fast==None or fast.next==None:\n                return False\n            slow=slow.next\n            fast=fast.next.next\n        return True"}
{"id": "32", "path": "output2\\py\\Easy\\32-binary-tree-preorder-traversal.py", "hypo_code": "class Solution(object):\n    def preorderTraversal(self, root):\n         \n        res=[]\n        self.preorder(root,res)\n        return res"}
{"id": "33", "path": "output2\\py\\Easy\\33-binary-tree-postorder-traversal.py", "hypo_code": "class Solution(object):\n    def postorderTraversal(self, root):\n         \n        res=[]\n        self.postorder(root,res)\n        return res"}
{"id": "34", "path": "output2\\py\\Easy\\34-intersection-of-two-linked-lists.py", "hypo_code": "class Solution(object):\n    def getIntersectionNode(self, headA, headB):\n               \n        if headA==None or headB==None:\n            return None\n        p1=headA\n        p2=headB\n        while p1!=p2:\n            if p1==None:\n                p1=headB\n            else:\n                p1=p1.next\n            if p2==None:\n                p2=headA\n            else:\n                p2=p2.next\n        return p1"}
{"id": "35", "path": "output2\\py\\Easy\\35-excel-sheet-column-title.py", "hypo_code": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n              \n        if columnNumber == 0:\n            return ''\n        else:\n            return self.convertToTitle((columnNumber-1)//26) + chr((columnNumber-1)%26+65)"}
{"id": "36", "path": "output2\\py\\Easy\\36-majority-element.py", "hypo_code": "class Solution(object):\n    def majorityElement(self, nums):\n             \n        nums.sort()\n        return nums[len(nums)//2]"}
{"id": "37", "path": "output2\\py\\Easy\\37-excel-sheet-column-number.py", "hypo_code": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \n        return sum((ord(columnTitle[i])-64)*26**(len(columnTitle)-i-1) for i in range(len(columnTitle)))"}
{"id": "42", "path": "output2\\py\\Easy\\42-reverse-bits.py", "hypo_code": "class Solution:\n    \n    \n    def reverseBits(self, n):\n        return int('{:032b}'.format(n)[::-1],2)"}
{"id": "43", "path": "output2\\py\\Easy\\43-number-of-1-bits.py", "hypo_code": "class Solution(object):\n    def hammingWeight(self, n):\n        \n        return '{:032b}'.format(n).count('1')"}
{"id": "48", "path": "output2\\py\\Easy\\48-happy-number.py", "hypo_code": "class Solution(object):\n    def isHappy(self, n):\n        \n        history = []\n        while n != 1:\n            if n in history:\n                return False\n            history.append(n)\n            n = sum([int(i)**2 for i in str(n)])\n        return True"}
{"id": "49", "path": "output2\\py\\Easy\\49-remove-linked-list-elements.py", "hypo_code": "class Solution(object):\n    def removeElements(self, head, val):\n        \n        if head==None:\n            return head\n        while head!=None and head.val==val:\n            head=head.next\n        if head==None:\n            return head\n        cur=head\n        while cur.next!=None:\n            if cur.next.val==val:\n                cur.next=cur.next.next\n            else:\n                cur=cur.next\n        return head"}
{"id": "50", "path": "output2\\py\\Easy\\50-isomorphic-strings.py", "hypo_code": "class Solution(object):\n    def isIsomorphic(self, s, t):\n         \n        if len(s)!=len(t):\n            return False\n        s2t={}\n        t2s={}\n        for i in range(len(s)):\n            if s[i] in s2t:\n                if s2t[s[i]]!=t[i]:\n                    return False\n            else:\n                s2t[s[i]]=t[i]\n            if t[i] in t2s:\n                if t2s[t[i]]!=s[i]:\n                    return False\n            else:\n                t2s[t[i]]=s[i]\n        return True"}
{"id": "51", "path": "output2\\py\\Easy\\51-reverse-linked-list.py", "hypo_code": "class Solution(object):\n    def reverseList(self, head):\n         \n        if head==None:\n            return head\n        cur=head\n        prev=None\n        while cur!=None:\n            next=cur.next\n            cur.next=prev\n            prev=cur\n            cur=next\n        return prev"}
{"id": "52", "path": "output2\\py\\Easy\\52-contains-duplicate.py", "hypo_code": "class Solution(object):\n    def containsDuplicate(self, nums):\n         \n        res=[]\n        for i in range(len(nums)):\n            if nums[i] in res:\n                return True\n            else:\n                res.append(nums[i])\n        return False"}
{"id": "53", "path": "output2\\py\\Easy\\53-contains-duplicate-ii.py", "hypo_code": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n         \n        res=[]\n        for i in range(len(nums)):\n            if nums[i] in res:\n                return True\n            else:\n                res.append(nums[i])\n        return False"}
{"id": "54", "path": "output2\\py\\Easy\\54-count-complete-tree-nodes.py", "hypo_code": "class Solution(object):\n    def countNodes(self, root):\n         \n        if not root:\n            return 0\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"}
{"id": "56", "path": "output2\\py\\Easy\\56-invert-binary-tree.py", "hypo_code": "class Solution(object):\n    def invertTree(self, root):\n         \n        if root==None:\n            return root\n        temp=root.left\n        root.left=root.right\n        root.right=temp\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root"}
{"id": "57", "path": "output2\\py\\Easy\\57-summary-ranges.py", "hypo_code": "class Solution(object):\n    def summaryRanges(self, nums):\n         \n        if len(nums)==0:\n            return []\n        if len(nums)==1:\n            return [str(nums[0])]\n        result=[]\n        start=nums[0]\n        end=nums[0]\n        for i in range(1,len(nums)):\n            if nums[i]==end+1:\n                end=nums[i]\n            else:\n                if start==end:\n                    result.append(str(start))\n                else:\n                    result.append(str(start)+\"->\"+str(end))\n                start=nums[i]\n                end=nums[i]\n        if start==end:\n            result.append(str(start))\n        else:\n            result.append(str(start)+\"->\"+str(end))\n        return result"}
{"id": "58", "path": "output2\\py\\Easy\\58-power-of-two.py", "hypo_code": "class Solution(object):\n    def isPowerOfTwo(self, n):\n         \n        if n<=0:\n            return False\n        if n==1:\n            return True\n        while n>1:\n            if n%2!=0:\n                return False\n            n=n/2\n        return True"}
{"id": "60", "path": "output2\\py\\Easy\\60-palindrome-linked-list.py", "hypo_code": "class Solution(object):\n    def isPalindrome(self, head):\n         \n        if head==None:\n            return True\n        if head.next==None:\n            return True\n        list=[]\n        while head!=None:\n            list.append(head.val)\n            head=head.next\n        for i in range(0,len(list)/2):\n            if list[i]!=list[len(list)-1-i]:\n                return False\n        return True"}
{"id": "61", "path": "output2\\py\\Easy\\61-valid-anagram.py", "hypo_code": "class Solution(object):\n    def isAnagram(self, s, t):\n         \n        if len(s)!=len(t):\n            return False\n        dict={}\n        for i in range(0,len(s)):\n            if s[i] in dict:\n                dict[s[i]]+=1\n            else:\n                dict[s[i]]=1\n        for i in range(0,len(t)):\n            if t[i] in dict:\n                dict[t[i]]-=1\n            else:\n                return False\n        for key in dict:\n            if dict[key]!=0:\n                return False\n        return True"}
{"id": "62", "path": "output2\\py\\Easy\\62-binary-tree-paths.py", "hypo_code": "class Solution(object):\n    def binaryTreePaths(self, root):\n         \n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [str(root.val)]\n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        return [str(root.val) + '->' + i for i in left + right]"}
{"id": "63", "path": "output2\\py\\Easy\\63-add-digits.py", "hypo_code": "class Solution(object):\n    def addDigits(self, num):"}
{"id": "64", "path": "output2\\py\\Easy\\64-ugly-number.py", "hypo_code": "class Solution(object):\n    def isUgly(self, n):\n                \n        if n <= 0:\n            return False\n        while n > 1:\n            if n % 2 == 0:\n                n /= 2\n            elif n % 3 == 0:\n                n /= 3\n            elif n % 5 == 0:\n                n /= 5\n            else:\n                return False\n        return True"}
{"id": "65", "path": "output2\\py\\Easy\\65-missing-number.py", "hypo_code": "class Solution(object):\n    def missingNumber(self, nums):\n          \n        return (len(nums) * (len(nums) + 1) / 2) - sum(nums)"}
{"id": "66", "path": "output2\\py\\Easy\\66-first-bad-version.py", "hypo_code": "class Solution(object):\n    def firstBadVersion(self, n):\n         \n        low = 1\n        high = n\n        while low < high:\n            mid = (low + high) / 2\n            if isBadVersion(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low"}
{"id": "67", "path": "output2\\py\\Easy\\67-move-zeroes.py", "hypo_code": "class Solution(object):\n    def moveZeroes(self, nums):\n        \n        for i in range(len(nums))[::-1]:\n            if nums[i] == 0:\n                nums.pop(i)\n                nums.append(0)\n        return nums"}
{"id": "68", "path": "output2\\py\\Easy\\68-word-pattern.py", "hypo_code": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \n        words = s.split(' ')\n        if len(pattern) != len(words):\n            return False\n        return len(set(zip(pattern, words))) == len(set(pattern)) == len(set(words))"}
{"id": "69", "path": "output2\\py\\Easy\\69-nim-game.py", "hypo_code": "class Solution(object):\n    def canWinNim(self, n):"}
{"id": "71", "path": "output2\\py\\Easy\\71-power-of-three.py", "hypo_code": "class Solution(object):\n    def isPowerOfThree(self, n):"}
{"id": "72", "path": "output2\\py\\Easy\\72-counting-bits.py", "hypo_code": "class Solution(object):\n    def countBits(self, n):\n          \n        return [bin(i).count('1') for i in range(n+1)]"}
{"id": "73", "path": "output2\\py\\Easy\\73-power-of-four.py", "hypo_code": "class Solution(object):\n    def isPowerOfFour(self, n):"}
{"id": "74", "path": "output2\\py\\Easy\\74-reverse-string.py", "hypo_code": "class Solution(object):\n    def reverseString(self, s):\n         \n        s.reverse()"}
{"id": "75", "path": "output2\\py\\Easy\\75-reverse-vowels-of-a-string.py", "hypo_code": "class Solution(object):\n    def reverseVowels(self, s):\n        \n        vowels = ['a', 'e', 'i', 'o', 'u']\n        s = list(s)\n        l = 0\n        r = len(s)-1\n        while l < r:\n            if s[l].lower() not in vowels:\n                l += 1\n            elif s[r].lower() not in vowels:\n                r -= 1\n            else:\n                s[l], s[r] = s[r], s[l]\n                l += 1\n                r -= 1\n        return ''.join(s)"}
{"id": "76", "path": "output2\\py\\Easy\\76-intersection-of-two-arrays.py", "hypo_code": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \n        return list(set(nums1).intersection(set(nums2)))"}
{"id": "77", "path": "output2\\py\\Easy\\77-intersection-of-two-arrays-ii.py", "hypo_code": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \n        return list((collections.Counter(nums1) & collections.Counter(nums2)).elements())"}
{"id": "78", "path": "output2\\py\\Easy\\78-valid-perfect-square.py", "hypo_code": "class Solution(object):\n    def isPerfectSquare(self, num):\n         \n        if num==1:\n            return True\n        if num==0:\n            return False\n        for i in range(1,num/2+1):\n            if i*i==num:\n                return True\n        return False"}
{"id": "79", "path": "output2\\py\\Easy\\79-guess-number-higher-or-lower.py", "hypo_code": "class Solution(object):\n    def guessNumber(self, n):\n         \n        if n==1:\n            return 1\n        left=1\n        right=n\n        while left<=right:\n            mid=(left+right)/2\n            if guess(mid)==0:\n                return mid\n            elif guess(mid)==1:\n                left=mid+1\n            else:\n                right=mid-1\n        return 0"}
{"id": "80", "path": "output2\\py\\Easy\\80-ransom-note.py", "hypo_code": "class Solution(object):\n    def canConstruct(self, ransomNote, magazine):\n         \n        if len(ransomNote)>len(magazine):\n            return False\n        dict={}\n        for i in range(0,len(magazine)):\n            if magazine[i] in dict:\n                dict[magazine[i]]+=1\n            else:\n                dict[magazine[i]]=1\n        for i in range(0,len(ransomNote)):\n            if ransomNote[i] in dict:\n                dict[ransomNote[i]]-=1\n            else:\n                return False\n        for key in dict:\n            if dict[key]<0:\n                return False\n        return True"}
{"id": "81", "path": "output2\\py\\Easy\\81-first-unique-character-in-a-string.py", "hypo_code": "class Solution(object):\n    def firstUniqChar(self, s):\n         \n        if len(s)==0:\n            return -1\n        if len(s)==1:\n            return 0\n        for i in range(0,len(s)):\n            if s.count(s[i])==1:\n                return i\n        return -1"}
{"id": "82", "path": "output2\\py\\Easy\\82-find-the-difference.py", "hypo_code": "class Solution(object):\n    def findTheDifference(self, s, t):\n         \n        if len(s)==0:\n            return t\n        if len(t)==0:\n            return s\n        if len(s)==1:\n            return t[0]\n        if len(t)==1:\n            return s[0]\n        dict={}\n        for i in range(0,len(s)):\n            if s[i] in dict:\n                dict[s[i]]+=1\n            else:\n                dict[s[i]]=1\n        for i in range(0,len(t)):\n            if t[i] in dict:\n                dict[t[i]]-=1\n            else:\n                return t[i]\n        for key in dict:\n            if dict[key]==1:\n                return key\n        return \"\""}
{"id": "83", "path": "output2\\py\\Easy\\83-is-subsequence.py", "hypo_code": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \n        if len(s)==0:\n            return True\n        if len(t)==0:\n            return False\n        if len(s)>len(t):\n            return False\n        i=0\n        j=0\n        while i<len(s) and j<len(t):\n            if s[i]==t[j]:\n                i+=1\n            j+=1\n        return i==len(s)"}
{"id": "84", "path": "output2\\py\\Easy\\84-binary-watch.py", "hypo_code": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \n        res=[]\n        for i in range(12):\n            for j in range(60):\n                if bin(i).count('1')+bin(j).count('1')==turnedOn:\n                    res.append(str(i)+':'+str(j).zfill(2))\n        return res"}
{"id": "85", "path": "output2\\py\\Easy\\85-sum-of-left-leaves.py", "hypo_code": "class Solution(object):\n    def sumOfLeftLeaves(self, root):\n         \n        if root==None:\n            return 0\n        if root.left==None and root.right==None:\n            return 0\n        if root.left!=None and root.left.left==None and root.left.right==None:\n            return root.left.val+self.sumOfLeftLeaves(root.right)\n        return self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)"}
{"id": "86", "path": "output2\\py\\Easy\\86-convert-a-number-to-hexadecimal.py", "hypo_code": "class Solution(object):\n    def toHex(self, num):\n        \n        if num==0:\n            return \"0\"\n        if num<0:\n            num=2**32+num\n        hex_str=\"\"\n        while num>0:\n            hex_str=hex_str+hex(num%16)[2:]\n            num=num/16\n        return hex_str[::-1]"}
{"id": "87", "path": "output2\\py\\Easy\\87-longest-palindrome.py", "hypo_code": "class Solution(object):\n    def longestPalindrome(self, s):\n         \n        if len(s)==0:\n            return 0\n        if len(s)==1:\n            return 1\n        res=0\n        for i in range(0,len(s)):\n            if s.count(s[i])%2==0:\n                res=res+s.count(s[i])\n            else:\n                res=res+s.count(s[i])-1\n        if res<len(s):\n            res=res+1\n        return res"}
{"id": "88", "path": "output2\\py\\Easy\\88-fizz-buzz.py", "hypo_code": "class Solution(object):\n    def fizzBuzz(self, n):\n         \n        result=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                result.append(\"FizzBuzz\")\n            elif i%3==0:\n                result.append(\"Fizz\")\n            elif i%5==0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result"}
{"id": "89", "path": "output2\\py\\Easy\\89-third-maximum-number.py", "hypo_code": "class Solution(object):\n    def thirdMax(self, nums):\n         \n        if len(nums)==0:\n            return 0\n        if len(nums)==1:\n            return nums[0]\n        if len(nums)==2:\n            return max(nums)\n        nums=sorted(set(nums))\n        if len(nums)<3:\n            return max(nums)\n        return nums[len(nums)-3]"}
{"id": "90", "path": "output2\\py\\Easy\\90-add-strings.py", "hypo_code": "class Solution(object):\n    def addStrings(self, num1, num2):\n         \n        if len(num1)==0:\n            return num2\n        if len(num2)==0:\n            return num1\n        if len(num1)==1:\n            return str(int(num1)+int(num2))\n        if len(num2)==1:\n            return str(int(num1)+int(num2))\n        if len(num1)>len(num2):\n            num2=\"0\"*(len(num1)-len(num2))+num2\n        else:\n            num1=\"0\"*(len(num2)-len(num1))+num1\n        res=\"\"\n        carry=0\n        for i in range(len(num1)-1,-1,-1):\n            temp=int(num1[i])+int(num2[i])+carry\n            res=str(temp%10)+res\n            carry=temp/10\n        if carry==1:\n            res=\"1\"+res\n        return res"}
{"id": "91", "path": "output2\\py\\Easy\\91-number-of-segments-in-a-string.py", "hypo_code": "class Solution(object):\n    def countSegments(self, s):\n         \n        if len(s)==0:\n            return 0\n        if len(s)==1:\n            if s[0]==\" \":\n                return 0\n            else:\n                return 1\n        count=0\n        for i in range(0,len(s)-1):\n            if s[i]==\" \" and s[i+1]!=\" \":\n                count+=1\n        if s[len(s)-1]!=\" \":\n            count+=1\n        return count"}
{"id": "92", "path": "output2\\py\\Easy\\92-arranging-coins.py", "hypo_code": "class Solution(object):\n    def arrangeCoins(self, n):\n              \n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        for i in range(1,n):\n            if i*(i+1)/2<=n and (i+1)*(i+2)/2>n:\n                return i"}
{"id": "93", "path": "output2\\py\\Easy\\93-find-all-numbers-disappeared-in-an-array.py", "hypo_code": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n         \n        result=[]\n        for i in range(1,len(nums)+1):\n            if i not in nums:\n                result.append(i)\n        return result"}
{"id": "94", "path": "output2\\py\\Easy\\94-assign-cookies.py", "hypo_code": "class Solution(object):\n    def findContentChildren(self, g, s):\n         \n        g=sorted(g)\n        s=sorted(s)\n        i=0\n        j=0\n        count=0\n        while i<len(g) and j<len(s):\n            if g[i]<=s[j]:\n                count+=1\n                i+=1\n                j+=1\n            else:\n                j+=1\n        return count"}
{"id": "95", "path": "output2\\py\\Easy\\95-repeated-substring-pattern.py", "hypo_code": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n         \n        if len(s)==0:\n            return False\n        if len(s)==1:\n            return False\n        for i in range(1,len(s)):\n            if len(s)%i==0:\n                res=\"\"\n                for j in range(0,len(s)/i):\n                    res=res+s[0:i]\n                if res==s:\n                    return True\n        return False"}
{"id": "96", "path": "output2\\py\\Easy\\96-hamming-distance.py", "hypo_code": "class Solution(object):\n    def hammingDistance(self, x, y):\n         \n        return bin(x^y).count('1')"}
{"id": "97", "path": "output2\\py\\Easy\\97-island-perimeter.py", "hypo_code": "class Solution(object):\n    def islandPerimeter(self, grid):\n         \n        if len(grid)==0:\n            return 0\n        if len(grid[0])==0:\n            return 0\n        res=0\n        for i in range(0,len(grid)):\n            for j in range(0,len(grid[0])):\n                if grid[i][j]==1:\n                    if i==0:\n                        res+=1\n                    if i==len(grid)-1:\n                        res+=1\n                    if j==0:\n                        res+=1\n                    if j==len(grid[0])-1:\n                        res+=1\n                    if i>0 and grid[i-1][j]==0:\n                        res+=1\n                    if i<len(grid)-1 and grid[i+1][j]==0:\n                        res+=1\n                    if j>0 and grid[i][j-1]==0:\n                        res+=1\n                    if j<len(grid[0])-1 and grid[i][j+1]==0:\n                        res+=1\n        return res"}
{"id": "98", "path": "output2\\py\\Easy\\98-number-complement.py", "hypo_code": "class Solution(object):\n    def findComplement(self, num):\n         \n        return int(''.join(['1' if x=='0' else '0' for x in bin(num)[2:]]),2)"}
{"id": "99", "path": "output2\\py\\Easy\\99-license-key-formatting.py", "hypo_code": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \n        s=s.replace(\"-\",\"\")\n        s=s.upper()\n        if len(s)<=k:\n            return s\n        else:\n            s=s[::-1]\n            s=s[0:k]+\"-\"+s[k:]\n            s=s[::-1]\n            for i in range(k+1,len(s)):\n                if s[i]==\"-\":\n                    s=s[0:i+1]+s[i+1].upper()+s[i+2:]\n            return s"}
{"id": "100", "path": "output2\\py\\Easy\\100-max-consecutive-ones.py", "hypo_code": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n         \n        res=0\n        count=0\n        for i in range(len(nums)):\n            if nums[i]==1:\n                count=count+1\n            else:\n                res=max(res,count)\n                count=0\n        res=max(res,count)\n        return res"}
{"id": "101", "path": "output2\\py\\Easy\\101-construct-the-rectangle.py", "hypo_code": "class Solution(object):\n    def constructRectangle(self, area):\n         \n        for i in range(int(math.sqrt(area)),0,-1):\n            if area%i==0:\n                return [area/i,i]\n        return [area,1]"}
{"id": "102", "path": "output2\\py\\Easy\\102-teemo-attacking.py", "hypo_code": "class Solution(object):\n    def findPoisonedDuration(self, timeSeries, duration):\n               \n        res=0\n        for i in range(len(timeSeries)):\n            if i==0:\n                res=res+duration\n            else:\n                if timeSeries[i]-timeSeries[i-1]>=duration:\n                    res=res+duration\n                else:\n                    res=res+timeSeries[i]-timeSeries[i-1]\n        return res"}
{"id": "103", "path": "output2\\py\\Easy\\103-next-greater-element-i.py", "hypo_code": "class Solution(object):\n    def nextGreaterElement(self, nums1, nums2):\n        \n        res=[]\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if nums1[i]==nums2[j]:\n                    for k in range(j+1,len(nums2)):\n                        if nums2[k]>nums2[j]:\n                            res.append(nums2[k])\n                            break\n                    else:\n                        res.append(-1)\n        return res"}
{"id": "104", "path": "output2\\py\\Easy\\104-keyboard-row.py", "hypo_code": "class Solution(object):\n    def findWords(self, words):\n              \n        res=[]\n        for i in range(len(words)):\n            if words[i][0].lower() in \"qwertyuiop\":\n                for j in range(len(words[i])):\n                    if words[i][j].lower() not in \"qwertyuiop\":\n                        break\n                else:\n                    res.append(words[i])\n            elif words[i][0].lower() in \"asdfghjkl\":\n                for j in range(len(words[i])):\n                    if words[i][j].lower() not in \"asdfghjkl\":\n                        break\n                else:\n                    res.append(words[i])\n            elif words[i][0].lower() in \"zxcvbnm\":\n                for j in range(len(words[i])):\n                    if words[i][j].lower() not in \"zxcvbnm\":\n                        break\n                else:\n                    res.append(words[i])\n        return res"}
{"id": "105", "path": "output2\\py\\Easy\\105-find-mode-in-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def findMode(self, root):\n                \n        if root is None:\n            return []\n        if root.left is None and root.right is None:\n            return [root.val]\n        if root.left is None:\n            return [root.val] + self.findMode(root.right)\n        if root.right is None:\n            return [root.val] + self.findMode(root.left)\n        return [root.val] + self.findMode(root.left) + self.findMode(root.right)"}
{"id": "106", "path": "output2\\py\\Easy\\106-base-7.py", "hypo_code": "class Solution(object):\n    def convertToBase7(self, num):\n               \n        if num==0:\n            return \"0\"\n        res=\"\"\n        if num<0:\n            res=\"-\"\n            num=-num\n        while num>0:\n            res=res+str(num%7)\n            num=num//7\n        return res[::-1]"}
{"id": "107", "path": "output2\\py\\Easy\\107-relative-ranks.py", "hypo_code": "class Solution(object):\n    def findRelativeRanks(self, score):\n              \n        res=[]\n        for i in range(len(score)):\n            for j in range(len(score)):\n                if score[i]>score[j]:\n                    score[i],score[j]=score[j],score[i]\n        for i in range(len(score)):\n            if i==0:\n                res.append(\"Gold Medal\")\n            elif i==1:\n                res.append(\"Silver Medal\")\n            elif i==2:\n                res.append(\"Bronze Medal\")\n            else:\n                res.append(str(i+1))\n        return res"}
{"id": "108", "path": "output2\\py\\Easy\\108-perfect-number.py", "hypo_code": "class Solution(object):\n    def checkPerfectNumber(self, num):\n              \n        if num==1:\n            return False\n        res=1\n        for i in range(2,int(num**0.5)+1):\n            if num%i==0:\n                res+=i\n                if i!=num//i:\n                    res+=num//i\n        return res==num"}
{"id": "109", "path": "output2\\py\\Easy\\109-fibonacci-number.py", "hypo_code": "class Solution(object):\n    def fib(self, n):\n               \n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        return self.fib(n-1)+self.fib(n-2)"}
{"id": "111", "path": "output2\\py\\Easy\\111-detect-capital.py", "hypo_code": "class Solution(object):\n    def detectCapitalUse(self, word):\n             \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        return False"}
{"id": "112", "path": "output2\\py\\Easy\\112-longest-uncommon-subsequence-i.py", "hypo_code": "class Solution(object):\n    def findLUSlength(self, a, b):\n              \n        if a==b:\n            return -1\n        else:\n            return max(len(a),len(b))"}
{"id": "113", "path": "output2\\py\\Easy\\113-minimum-absolute-difference-in-bst.py", "hypo_code": "class Solution(object):\n    def getMinimumDifference(self, root):\n               \n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 0\n        if root.left is None:\n            return min(abs(root.val - root.right.val), self.getMinimumDifference(root.right))\n        if root.right is None:\n            return min(abs(root.val - root.left.val), self.getMinimumDifference(root.left))\n        return min(abs(root.val - root.left.val), abs(root.val - root.right.val), self.getMinimumDifference(root.left), self.getMinimumDifference(root.right))"}
{"id": "114", "path": "output2\\py\\Easy\\114-reverse-string-ii.py", "hypo_code": "class Solution(object):\n    def reverseStr(self, s, k):\n             \n        res=\"\"\n        for i in range(0,len(s),2*k):\n            res=res+s[i:i+k][::-1]+s[i+k:i+2*k]\n        return res"}
{"id": "115", "path": "output2\\py\\Easy\\115-diameter-of-binary-tree.py", "hypo_code": "class Solution(object):\n    def diameterOfBinaryTree(self, root):\n              \n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 0\n        if root.left is None:\n            return max(self.height(root.right), self.diameterOfBinaryTree(root.right))\n        if root.right is None:\n            return max(self.height(root.left), self.diameterOfBinaryTree(root.left))\n        return max(self.height(root.left) + self.height(root.right), self.diameterOfBinaryTree(root.left), self.diameterOfBinaryTree(root.right))"}
{"id": "116", "path": "output2\\py\\Easy\\116-student-attendance-record-i.py", "hypo_code": "class Solution(object):\n    def checkRecord(self, s):\n           \n        return s.count(\"A\")<2 and \"LLL\" not in s"}
{"id": "117", "path": "output2\\py\\Easy\\117-reverse-words-in-a-string-iii.py", "hypo_code": "class Solution(object):\n    def reverseWords(self, s):\n               \n        res=\"\"\n        for i in s.split(\" \"):\n            res=res+i[::-1]+\" \"\n        return res[:-1]"}
{"id": "118", "path": "output2\\py\\Easy\\118-maximum-depth-of-n-ary-tree.py", "hypo_code": "class Solution(object):\n    def maxDepth(self, root):"}
{"id": "119", "path": "output2\\py\\Easy\\119-array-partition.py", "hypo_code": "class Solution(object):\n    def arrayPairSum(self, nums):\n             \n        nums.sort()\n        res=0\n        for i in range(0,len(nums),2):\n            res+=nums[i]\n        return res"}
{"id": "120", "path": "output2\\py\\Easy\\120-binary-tree-tilt.py", "hypo_code": "class Solution(object):\n    def findTilt(self, root):\n              \n        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 0\n        if root.left is None:\n            return abs(root.val - root.right.val) + self.findTilt(root.right)\n        if root.right is None:\n            return abs(root.val - root.left.val) + self.findTilt(root.left)\n        return abs(root.val - root.left.val) + abs(root.val - root.right.val) + self.findTilt(root.left) + self.findTilt(root.right)"}
{"id": "121", "path": "output2\\py\\Easy\\121-reshape-the-matrix.py", "hypo_code": "class Solution(object):\n    def matrixReshape(self, mat, r, c):\n              \n        if len(mat)*len(mat[0])!=r*c:\n            return mat\n        else:\n            result=[]\n            temp=[]\n            for i in range(len(mat)):\n                for j in range(len(mat[0])):\n                    temp.append(mat[i][j])\n                    if len(temp)==c:\n                        result.append(temp)\n                        temp=[]\n            return result"}
{"id": "122", "path": "output2\\py\\Easy\\122-subtree-of-another-tree.py", "hypo_code": "class Solution(object):\n    def isSubtree(self, root, subRoot):\n         \n        if root==None:\n            return False\n        if self.isSameTree(root,subRoot):\n            return True\n        return self.isSubtree(root.left,subRoot) or self.isSubtree(root.right,subRoot)"}
{"id": "123", "path": "output2\\py\\Easy\\123-distribute-candies.py", "hypo_code": "class Solution(object):\n    def distributeCandies(self, candyType):\n               \n        return min(len(candyType)/2,len(set(candyType)))"}
{"id": "127", "path": "output2\\py\\Easy\\127-n-ary-tree-preorder-traversal.py", "hypo_code": "class Solution(object):\n    def preorder(self, root):\n         \n        if root==None:\n            return []\n        if root.children==None:\n            return [root.val]\n        res=[root.val]\n        for child in root.children:\n            res.extend(self.preorder(child))\n        return res"}
{"id": "128", "path": "output2\\py\\Easy\\128-n-ary-tree-postorder-traversal.py", "hypo_code": "class Solution(object):\n    def postorder(self, root):"}
{"id": "129", "path": "output2\\py\\Easy\\129-longest-harmonious-subsequence.py", "hypo_code": "class Solution(object):\n    def findLHS(self, nums):\n               \n        nums.sort()\n        max_length=0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[j]-nums[i]==1:\n                    max_length=max(max_length,j-i+1)\n        return max_length"}
{"id": "132", "path": "output2\\py\\Easy\\132-range-addition-ii.py", "hypo_code": "class Solution(object):\n    def maxCount(self, m, n, ops):\n        \n        for i in ops:\n            m = min(m, i[0])\n            n = min(n, i[1])\n        return m * n"}
{"id": "133", "path": "output2\\py\\Easy\\133-minimum-index-sum-of-two-lists.py", "hypo_code": "class Solution(object):\n    def findRestaurant(self, list1, list2):\n        \n        return [x for x in list1 if x in list2]"}
{"id": "134", "path": "output2\\py\\Easy\\134-can-place-flowers.py", "hypo_code": "class Solution(object):\n    def canPlaceFlowers(self, flowerbed, n):\n         \n        count = 0\n        for i in range(len(flowerbed)):\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\n                flowerbed[i] = 1\n                count += 1\n        return count >= n"}
{"id": "135", "path": "output2\\py\\Easy\\135-construct-string-from-binary-tree.py", "hypo_code": "class Solution(object):\n    def tree2str(self, root):\n        \n        def preorder(node):\n            if node:\n                s.append(str(node.val))\n                if node.left or node.right:\n                    s.append('(')\n                    preorder(node.left)\n                    s.append(')')\n                if node.right:\n                    s.append('(')\n                    preorder(node.right)\n                    s.append(')')\n        s = []\n        preorder(root)\n        return ''.join(s)"}
{"id": "138", "path": "output2\\py\\Easy\\138-merge-two-binary-trees.py", "hypo_code": "class Solution(object):\n    def mergeTrees(self, root1, root2):\n        \n        if root1 and root2:\n            root1.val += root2.val\n            root1.left = self.mergeTrees(root1.left,root2.left)\n            root1.right = self.mergeTrees(root1.right,root2.right)\n            return root1\n        else:\n            return root1 or root2"}
{"id": "142", "path": "output2\\py\\Easy\\142-maximum-product-of-three-numbers.py", "hypo_code": "class Solution(object):\n    def maximumProduct(self, nums):\n              \n        nums.sort()\n        return max(nums[-1]*nums[-2]*nums[-3],nums[0]*nums[1]*nums[-1])"}
{"id": "143", "path": "output2\\py\\Easy\\143-average-of-levels-in-binary-tree.py", "hypo_code": "class Solution(object):\n    def averageOfLevels(self, root):\n              \n        if root==None:\n            return []\n        else:\n            q=[root]\n            res=[]\n            while len(q)>0:\n                n=len(q)\n                sum=0\n                for i in range(n):\n                    sum+=q[0].val\n                    if q[0].left!=None:\n                        q.append(q[0].left)\n                    if q[0].right!=None:\n                        q.append(q[0].right)\n                    q.pop(0)\n                res.append(sum/n)\n            return res"}
{"id": "144", "path": "output2\\py\\Easy\\144-maximum-average-subarray-i.py", "hypo_code": "class Solution(object):\n    def findMaxAverage(self, nums, k):\n             \n        max_sum=0\n        for i in range(k):\n            max_sum+=nums[i]\n        sum=max_sum\n        for i in range(k,len(nums)):\n            sum=sum-nums[i-k]+nums[i]\n            max_sum=max(max_sum,sum)\n        return max_sum/k"}
{"id": "145", "path": "output2\\py\\Easy\\145-set-mismatch.py", "hypo_code": "class Solution(object):\n    def findErrorNums(self, nums):\n          \n        n=len(nums)\n        sum1=n*(n+1)/2\n        sum2=0\n        sum3=0\n        for i in nums:\n            sum2+=i\n            sum3+=i*i\n        sum2=sum2-sum1\n        sum3=sum3-sum1*sum1/n\n        return [(sum2+sum3/sum2)/2,(sum2+sum3/sum2)/2-sum2]"}
{"id": "146", "path": "output2\\py\\Easy\\146-two-sum-iv-input-is-a-bst.py", "hypo_code": "class Solution(object):\n    def findTarget(self, root, k):\n               \n        if root is None:\n            return False\n        if root.left is None and root.right is None:\n            return False\n        if root.left is None:\n            return self.findTarget(root.right, k)\n        if root.right is None:\n            return self.findTarget(root.left, k)\n        if self.findTarget(root.left, k) or self.findTarget(root.right, k):\n            return True\n        else:\n            return self.findTarget(root.left, k-root.val) or self.findTarget(root.right, k-root.val)\n        \n        return False"}
{"id": "147", "path": "output2\\py\\Easy\\147-robot-return-to-origin.py", "hypo_code": "class Solution(object):\n    def judgeCircle(self, moves):\n        \n        x=0\n        y=0\n        for i in moves:\n            if i==\"R\":\n                x+=1\n            elif i==\"L\":\n                x-=1\n            elif i==\"U\":\n                y+=1\n            elif i==\"D\":\n                y-=1\n        if x==0 and y==0:\n            return True\n        else:\n            return False"}
{"id": "148", "path": "output2\\py\\Easy\\148-image-smoother.py", "hypo_code": "class Solution(object):\n    def imageSmoother(self, img):\n                \n        m = len(img)\n        n = len(img[0])\n        res = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                cnt = 0\n                for x in range(i-1, i+2):\n                    for y in range(j-1, j+2):\n                        if 0 <= x < m and 0 <= y < n:\n                            res[i][j] += img[x][y]\n                            cnt += 1\n                res[i][j] /= cnt\n        return res"}
{"id": "149", "path": "output2\\py\\Easy\\149-second-minimum-node-in-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def findSecondMinimumValue(self, root):\n         \n        if root==None:\n            return -1\n        if root.left==None and root.right==None:\n            return -1\n        if root.left.val==root.val:\n            left=self.findSecondMinimumValue(root.left)\n        else:\n            left=root.left.val\n        if root.right.val==root.val:\n            right=self.findSecondMinimumValue(root.right)\n        else:\n            right=root.right.val\n        if left==-1:\n            return right\n        if right==-1:\n            return left\n        return min(left,right)"}
{"id": "150", "path": "output2\\py\\Easy\\150-longest-continuous-increasing-subsequence.py", "hypo_code": "class Solution(object):\n    def findLengthOfLCIS(self, nums):\n          \n        if len(nums)==0:\n            return 0\n        max_count=1\n        count=1\n        for i in range(1,len(nums)):\n            if nums[i]>nums[i-1]:\n                count+=1\n            else:\n                max_count=max(max_count,count)\n                count=1\n        max_count=max(max_count,count)\n        return max_count"}
{"id": "151", "path": "output2\\py\\Easy\\151-valid-palindrome-ii.py", "hypo_code": "class Solution(object):\n    def validPalindrome(self, s):\n               \n        if s==s[::-1]:\n            return True\n        else:\n            for i in range(len(s)):\n                if s[i]!=s[len(s)-1-i]:\n                    return s[i:len(s)-1-i]==s[i:len(s)-1-i][::-1] or s[i+1:len(s)-i]==s[i+1:len(s)-i][::-1]\n        return False"}
{"id": "152", "path": "output2\\py\\Easy\\152-baseball-game.py", "hypo_code": "class Solution(object):\n    def calPoints(self, operations):\n               \n        stack=[]\n        for op in operations:\n            if op==\"+\":\n                stack.append(stack[-1]+stack[-2])\n            elif op==\"D\":\n                stack.append(stack[-1]*2)\n            elif op==\"C\":\n                stack.pop()\n            else:\n                stack.append(int(op))\n        return sum(stack)"}
{"id": "153", "path": "output2\\py\\Easy\\153-binary-number-with-alternating-bits.py", "hypo_code": "class Solution(object):\n    def hasAlternatingBits(self, n):\n               \n        n_bin=bin(n)[2:]\n        for i in range(1,len(n_bin)):\n            if n_bin[i]==n_bin[i-1]:\n                return False\n        return True"}
{"id": "154", "path": "output2\\py\\Easy\\154-count-binary-substrings.py", "hypo_code": "class Solution(object):\n    def countBinarySubstrings(self, s):\n               \n        if len(s)==1:\n            return 0\n        if len(s)==2:\n            return 1\n        count=0\n        for i in range(len(s)-1):\n            if s[i]!=s[i+1]:\n                count+=1\n                left=i\n                right=i+1\n                while left>=0 and right<len(s) and s[left]==s[i] and s[right]==s[i+1]:\n                    count+=1\n                    left-=1\n                    right+=1\n        return count"}
{"id": "155", "path": "output2\\py\\Easy\\155-degree-of-an-array.py", "hypo_code": "class Solution(object):\n    def findShortestSubArray(self, nums):\n        \n        max_count=0\n        min_length=0\n        dict={}\n        for i in range(len(nums)):\n            if nums[i] in dict:\n                dict[nums[i]][0]+=1\n                dict[nums[i]][2]=i\n            else:\n                dict[nums[i]]=[1,i,i]\n        for key in dict:\n            if dict[key][0]>max_count:\n                max_count=dict[key][0]\n                min_length=dict[key][2]-dict[key][1]+1\n            elif dict[key][0]==max_count:\n                min_length=min(min_length,dict[key][2]-dict[key][1]+1)\n        return min_length"}
{"id": "156", "path": "output2\\py\\Easy\\156-search-in-a-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def searchBST(self, root, val):\n               \n        if root==None:\n            return None\n        if root.val==val:\n            return root\n        if root.val>val:\n            return self.searchBST(root.left, val)\n        else:\n            return self.searchBST(root.right, val)\n        \n        return None"}
{"id": "158", "path": "output2\\py\\Easy\\158-binary-search.py", "hypo_code": "class Solution(object):\n    def search(self, nums, target):\n               \n        if target in nums:\n            return nums.index(target)\n        else:\n            return -1"}
{"id": "161", "path": "output2\\py\\Easy\\161-to-lower-case.py", "hypo_code": "class Solution(object):\n    def toLowerCase(self, s):\n              \n        res=\"\"\n        for i in range(len(s)):\n            if ord(s[i])>=65 and ord(s[i])<=90:\n                res+=chr(ord(s[i])+32)\n            else:\n                res+=s[i]\n        return res"}
{"id": "162", "path": "output2\\py\\Easy\\162-1-bit-and-2-bit-characters.py", "hypo_code": "class Solution(object):\n    def isOneBitCharacter(self, bits):\n        \n        i = 0\n        while i < len(bits)-1:\n            i += bits[i] + 1\n        return i == len(bits)-1"}
{"id": "163", "path": "output2\\py\\Easy\\163-find-pivot-index.py", "hypo_code": "class Solution(object):\n    def pivotIndex(self, nums):\n        \n        total = sum(nums)\n        left = 0\n        for i in range(len(nums)):\n            if left == total - left - nums[i]:\n                return i\n            left += nums[i]\n        return -1"}
{"id": "164", "path": "output2\\py\\Easy\\164-self-dividing-numbers.py", "hypo_code": "class Solution(object):\n    def selfDividingNumbers(self, left, right):\n        \n        result = []\n        for i in range(left, right + 1):\n            if not '0' in str(i):\n                if all([i % int(j) == 0 for j in str(i)]):\n                    result.append(i)\n        return result"}
{"id": "165", "path": "output2\\py\\Easy\\165-flood-fill.py", "hypo_code": "class Solution(object):\n    def floodFill(self, image, sr, sc, color):\n        \n        def dfs(image, sr, sc, color):\n            if sr < 0 or sc < 0 or sr >= len(image) or sc >= len(image[0]) or image[sr][sc] == color:\n                return\n            image[sr][sc] = color\n            dfs(image, sr - 1, sc, color)\n            dfs(image, sr + 1, sc, color)\n            dfs(image, sr, sc - 1, color)\n            dfs(image, sr, sc + 1, color)\n        dfs(image, sr, sc, color)\n        return image"}
{"id": "166", "path": "output2\\py\\Easy\\166-find-smallest-letter-greater-than-target.py", "hypo_code": "class Solution(object):\n    def nextGreatestLetter(self, letters, target):\n        \n        for i in letters:\n            if i > target:\n                return i\n        return letters[0]"}
{"id": "167", "path": "output2\\py\\Easy\\167-min-cost-climbing-stairs.py", "hypo_code": "class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        \n        for i in range(2, len(cost)):\n            cost[i] += min(cost[i-1], cost[i-2])\n        return min(cost[-2], cost[-1])"}
{"id": "168", "path": "output2\\py\\Easy\\168-largest-number-at-least-twice-of-others.py", "hypo_code": "class Solution(object):\n    def dominantIndex(self, nums):"}
{"id": "169", "path": "output2\\py\\Easy\\169-shortest-completing-word.py", "hypo_code": "class Solution(object):\n    def shortestCompletingWord(self, licensePlate, words):\n        \n        licensePlate = licensePlate.lower()\n        licensePlate = ''.join([i for i in licensePlate if i.isalpha()])\n        words = sorted(words, key=len)\n        for i in words:\n            temp = licensePlate\n            for j in i:\n                if j in temp:\n                    temp = temp.replace(j, '', 1)\n            if temp == '':\n                return i\n        return ''"}
{"id": "170", "path": "output2\\py\\Easy\\170-prime-number-of-set-bits-in-binary-representation.py", "hypo_code": "class Solution(object):\n    def countPrimeSetBits(self, left, right):\n        \n        count = 0\n        for i in range(left, right+1):\n            if bin(i).count('1') in [2,3,5,7,11,13,17,19]:\n                count += 1\n        return count"}
{"id": "171", "path": "output2\\py\\Easy\\171-toeplitz-matrix.py", "hypo_code": "class Solution(object):\n    def isToeplitzMatrix(self, matrix):\n        \n        for i in range(len(matrix)-1):\n            for j in range(len(matrix[i])-1):\n                if matrix[i][j] != matrix[i+1][j+1]:\n                    return False\n        return True"}
{"id": "172", "path": "output2\\py\\Easy\\172-jewels-and-stones.py", "hypo_code": "class Solution(object):\n    def numJewelsInStones(self, jewels, stones):\n        \n        return sum(stones.count(i) for i in jewels)"}
{"id": "173", "path": "output2\\py\\Easy\\173-minimum-distance-between-bst-nodes.py", "hypo_code": "class Solution(object):\n    def minDiffInBST(self, root):\n        \n        def inorder(root):\n            if not root:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        nums = inorder(root)\n        return min([nums[i+1] - nums[i] for i in range(len(nums)-1)])"}
{"id": "174", "path": "output2\\py\\Easy\\174-rotate-string.py", "hypo_code": "class Solution(object):\n    def rotateString(self, s, goal):\n        \n        return len(s) == len(goal) and goal in s+s"}
{"id": "175", "path": "output2\\py\\Easy\\175-unique-morse-code-words.py", "hypo_code": "class Solution(object):\n    def uniqueMorseRepresentations(self, words):\n        \n        morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\n                 \"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\n                 \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        return len({\"\".join(morse[ord(i) - ord('a')] for i in word) for word in words})"}
{"id": "176", "path": "output2\\py\\Easy\\176-number-of-lines-to-write-string.py", "hypo_code": "class Solution(object):\n    def numberOfLines(self, widths, s):\n        \n        lines, width = 1, 0\n        for i in s:\n            w = widths[ord(i) - ord('a')]\n            width += w\n            if width > 100:\n                lines += 1\n                width = w\n        return [lines, width]"}
{"id": "177", "path": "output2\\py\\Easy\\177-largest-triangle-area.py", "hypo_code": "class Solution(object):\n    def largestTriangleArea(self, points):\n        \n        from itertools import combinations\n        def area(p, q, r):\n            return .5 * abs(p[0]*q[1]+q[0]*r[1]+r[0]*p[1]-p[1]*q[0]-q[1]*r[0]-r[1]*p[0])\n        return max(area(*triangle) for triangle in combinations(points, 3))"}
{"id": "178", "path": "output2\\py\\Easy\\178-most-common-word.py", "hypo_code": "class Solution(object):\n    def mostCommonWord(self, paragraph, banned):\n         \n        paragraph = paragraph.lower()\n        for i in \"!?',;.\":\n            paragraph = paragraph.replace(i, ' ')\n        paragraph = paragraph.split()\n        counter = collections.Counter(paragraph)\n        for i in banned:\n            del counter[i]\n        return counter.most_common(1)[0][0]"}
{"id": "179", "path": "output2\\py\\Easy\\179-shortest-distance-to-a-character.py", "hypo_code": "class Solution(object):\n    def shortestToChar(self, s, c):\n        \n        index = [i for i, x in enumerate(s) if x == c]\n        result = []\n        for i in range(len(s)):\n            result.append(min([abs(i-j) for j in index]))\n        return result"}
{"id": "180", "path": "output2\\py\\Easy\\180-goat-latin.py", "hypo_code": "class Solution(object):\n    def toGoatLatin(self, sentence):\n        \n        vowels = \"aeiouAEIOU\"\n        ans = []\n        for i, word in enumerate(sentence.split(), 1):\n            if word[0] not in vowels:\n                word = word[1:] + word[0]\n            ans.append(word + 'ma' + 'a' * i)\n        return \" \".join(ans)"}
{"id": "181", "path": "output2\\py\\Easy\\181-positions-of-large-groups.py", "hypo_code": "class Solution(object):\n    def largeGroupPositions(self, s):\n        \n        result = []\n        if len(s) < 3:\n            return result\n        start = 0\n        end = 0\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                end = i + 1\n            else:\n                if end - start >= 2:\n                    result.append([start, end])\n                start = i + 1\n                end = i + 1\n        if end - start >= 2:\n            result.append([start, end])\n        return result"}
{"id": "182", "path": "output2\\py\\Easy\\182-flipping-an-image.py", "hypo_code": "class Solution(object):\n    def flipAndInvertImage(self, image):\n        \n        for row in image:\n            row.reverse()\n            for i in range(len(row)):\n                row[i]=row[i]^1\n        return image"}
{"id": "183", "path": "output2\\py\\Easy\\183-rectangle-overlap.py", "hypo_code": "class Solution(object):\n    def isRectangleOverlap(self, rec1, rec2):\n        \n        return not(rec1[2]<=rec2[0] or rec2[2]<=rec1[0] or rec1[3]<=rec2[1] or rec2[3]<=rec1[1])"}
{"id": "184", "path": "output2\\py\\Easy\\184-backspace-string-compare.py", "hypo_code": "class Solution(object):\n    def backspaceCompare(self, s, t):\n        \n        def getStr(s):\n            stack=[]\n            for c in s:\n                if c=='\n                    if stack: stack.pop()\n                else:\n                    stack.append(c)\n            return ''.join(stack)\n        return getStr(s)==getStr(t)"}
{"id": "185", "path": "output2\\py\\Easy\\185-buddy-strings.py", "hypo_code": "class Solution(object):\n    def buddyStrings(self, s, goal):\n        \n        if len(s)!=len(goal): return False\n        if s==goal:\n            return len(set(s))<len(s)\n        diff=[]\n        for i in range(len(s)):\n            if s[i]!=goal[i]:\n                diff.append(i)\n        return len(diff)==2 and s[diff[0]]==goal[diff[1]] and s[diff[1]]==goal[diff[0]]"}
{"id": "186", "path": "output2\\py\\Easy\\186-lemonade-change.py", "hypo_code": "class Solution(object):\n    def lemonadeChange(self, bills):\n        \n        fives, tens=0,0\n        for bill in bills:\n            if bill==5: fives+=1\n            elif bill==10: fives, tens=fives-1, tens+1\n            elif tens>0: fives, tens=fives-1, tens-1\n            else: fives-=3\n            if fives<0: return False\n        return True"}
{"id": "187", "path": "output2\\py\\Easy\\187-transpose-matrix.py", "hypo_code": "class Solution(object):\n    def transpose(self, matrix):\n        \n        return zip(*matrix)"}
{"id": "188", "path": "output2\\py\\Easy\\188-binary-gap.py", "hypo_code": "class Solution(object):\n    def binaryGap(self, n):\n        \n        return len(max(bin(n)[2:].split('1')[1:-1]))+1 if n&(n-1) else 0"}
{"id": "189", "path": "output2\\py\\Easy\\189-leaf-similar-trees.py", "hypo_code": "class Solution(object):\n    def leafSimilar(self, root1, root2):\n        \n        def dfs(node):\n            if not node: return []\n            if not node.left and not node.right: return [node.val]\n            return dfs(node.left)+dfs(node.right)\n        return dfs(root1)==dfs(root2)"}
{"id": "190", "path": "output2\\py\\Easy\\190-middle-of-the-linked-list.py", "hypo_code": "class Solution(object):\n    def middleNode(self, head):\n        \n        slow=fast=head\n        while fast and fast.next:\n            slow=slow.next\n            fast=fast.next.next\n        return slow"}
{"id": "191", "path": "output2\\py\\Easy\\191-projection-area-of-3d-shapes.py", "hypo_code": "class Solution(object):\n    def projectionArea(self, grid):\n        \n        return sum(map(max,grid))+sum(map(max,zip(*grid)))+sum(v>0 for row in grid for v in row)"}
{"id": "192", "path": "output2\\py\\Easy\\192-uncommon-words-from-two-sentences.py", "hypo_code": "class Solution(object):\n    def uncommonFromSentences(self, s1, s2):\n        \n        s1=s1.split()\n        s2=s2.split()\n        c1=collections.Counter(s1)\n        c2=collections.Counter(s2)\n        res=[]\n        for k,v in c1.items():\n            if v==1 and k not in c2:\n                res.append(k)\n        for k,v in c2.items():\n            if v==1 and k not in c1:\n                res.append(k)\n        return res"}
{"id": "193", "path": "output2\\py\\Easy\\193-fair-candy-swap.py", "hypo_code": "class Solution(object):\n    def fairCandySwap(self, aliceSizes, bobSizes):\n        \n        diff=(sum(aliceSizes)-sum(bobSizes))/2\n        setA=set(aliceSizes)\n        for y in bobSizes:\n            if diff+y in setA:\n                return [diff+y, y]"}
{"id": "194", "path": "output2\\py\\Easy\\194-surface-area-of-3d-shapes.py", "hypo_code": "class Solution(object):\n    def surfaceArea(self, grid):\n        \n        return sum(v*4+2 for row in grid for v in row if v)"}
{"id": "195", "path": "output2\\py\\Easy\\195-monotonic-array.py", "hypo_code": "class Solution(object):\n    def isMonotonic(self, nums):\n        \n        return sorted(nums)==nums or sorted(nums, reverse=True)==nums"}
{"id": "196", "path": "output2\\py\\Easy\\196-increasing-order-search-tree.py", "hypo_code": "class Solution(object):\n    def increasingBST(self, root):\n        \n        def dfs(node):\n            if not node: return []\n            return dfs(node.left)+[node.val]+dfs(node.right)\n        res=TreeNode(None)\n        cur=res\n        for i in dfs(root):\n            cur.right=TreeNode(i)\n            cur=cur.right\n        return res.right"}
{"id": "197", "path": "output2\\py\\Easy\\197-sort-array-by-parity.py", "hypo_code": "class Solution(object):\n    def sortArrayByParity(self, nums):\n        \n        return sorted(nums, key=lambda x:x%2)"}
{"id": "198", "path": "output2\\py\\Easy\\198-smallest-range-i.py", "hypo_code": "class Solution(object):\n    def smallestRangeI(self, nums, k):\n        \n        return max(max(nums)-min(nums)-2*k, 0)"}
{"id": "199", "path": "output2\\py\\Easy\\199-x-of-a-kind-in-a-deck-of-cards.py", "hypo_code": "class Solution(object):\n    def hasGroupsSizeX(self, deck):\n        \n        deck.sort()\n        count=1\n        for i in range(1, len(deck)):\n            if deck[i]==deck[i-1]:\n                count+=1\n            else:\n                break\n        if count==len(deck):\n            return True\n        for x in range(2, count+1):\n            if count%x==0:\n                flag=True\n                for i in range(x, len(deck), x):\n                    for j in range(x):\n                        if deck[i]!=deck[i-j-1]:\n                            flag=False\n                            break\n                    if not flag:\n                        break\n                if flag:\n                    return True\n        return False"}
{"id": "200", "path": "output2\\py\\Easy\\200-reverse-only-letters.py", "hypo_code": "class Solution(object):\n    def reverseOnlyLetters(self, s):\n        \n        letters=[c for c in s if c.isalpha()]\n        res=[]\n        for c in s:\n            if c.isalpha():\n                res.append(letters.pop())\n            else:\n                res.append(c)\n        return ''.join(res)"}
{"id": "201", "path": "output2\\py\\Easy\\201-sort-array-by-parity-ii.py", "hypo_code": "class Solution(object):\n    def sortArrayByParityII(self, nums):\n        \n        result = [0]*len(nums)\n        even = 0\n        odd = 1\n        for i in nums:\n            if i%2 == 0:\n                result[even] = i\n                even += 2\n            else:\n                result[odd] = i\n                odd += 2\n        return result"}
{"id": "202", "path": "output2\\py\\Easy\\202-long-pressed-name.py", "hypo_code": "class Solution(object):\n    def isLongPressedName(self, name, typed):\n        \n        nameIndex = 0\n        typedIndex = 0\n        while nameIndex < len(name) and typedIndex < len(typed):\n            if name[nameIndex] == typed[typedIndex]:\n                nameIndex += 1\n                typedIndex += 1\n            elif typedIndex > 0 and typed[typedIndex] == typed[typedIndex - 1]:\n                typedIndex += 1\n            else:\n                return False\n\n        if nameIndex != len(name):\n            return False\n\n        while typedIndex < len(typed):\n            if typed[typedIndex] != typed[typedIndex - 1]:\n                return False\n            typedIndex += 1\n\n        return True"}
{"id": "203", "path": "output2\\py\\Easy\\203-unique-email-addresses.py", "hypo_code": "class Solution(object):\n    def numUniqueEmails(self, emails):\n        \n        def normalize(email):\n            local, domain = email.split('@')\n            local = local.split('+')[0]\n            local = local.replace('.', '')\n            return local + '@' + domain\n\n        return len(set(map(normalize, emails)))"}
{"id": "205", "path": "output2\\py\\Easy\\205-range-sum-of-bst.py", "hypo_code": "class Solution(object):\n    def rangeSumBST(self, root, low, high):\n        \n        def sum(node):\n            if node == None:\n                return 0\n            if node.val < low:\n                return sum(node.right)\n            if node.val > high:\n                return sum(node.left)\n            return node.val + sum(node.left) + sum(node.right)\n\n        return sum(root)"}
{"id": "206", "path": "output2\\py\\Easy\\206-valid-mountain-array.py", "hypo_code": "class Solution(object):\n    def validMountainArray(self, arr):\n        \n        if len(arr)<3:\n            return False\n        i = 1\n        while i<len(arr) and arr[i]>arr[i-1]:\n            i += 1\n        if i == 1 or i == len(arr):\n            return False\n        while i<len(arr) and arr[i]<arr[i-1]:\n            i += 1\n        return i == len(arr)"}
{"id": "207", "path": "output2\\py\\Easy\\207-di-string-match.py", "hypo_code": "class Solution(object):\n    def diStringMatch(self, s):\n        \n        result = []\n        left = 0\n        right = len(s)\n        for i in s:\n            if i == 'I':\n                result.append(left)\n                left += 1\n            else:\n                result.append(right)\n                right -= 1\n        return result + [left]"}
{"id": "208", "path": "output2\\py\\Easy\\208-delete-columns-to-make-sorted.py", "hypo_code": "class Solution(object):\n    def minDeletionSize(self, strs):\n        \n        result = 0\n        for i in range(len(strs[0])):\n            for j in range(len(strs)-1):\n                if strs[j][i]>strs[j+1][i]:\n                    result += 1\n                    break\n        return result"}
{"id": "209", "path": "output2\\py\\Easy\\209-verifying-an-alien-dictionary.py", "hypo_code": "class Solution(object):\n    def isAlienSorted(self, words, order):\n        \n        for i in range(len(words)-1):\n            for j in range(len(words[i])):\n                if j>=len(words[i+1]):\n                    return False\n                if words[i][j]!=words[i+1][j]:\n                    if order.find(words[i][j])>order.find(words[i+1][j]):\n                        return False\n                    break\n        return True"}
{"id": "210", "path": "output2\\py\\Easy\\210-n-repeated-element-in-size-2n-array.py", "hypo_code": "class Solution(object):\n    def repeatedNTimes(self, nums):\n        \n        for i in nums:\n            if nums.count(i) == len(nums)/2:\n                return i"}
{"id": "211", "path": "output2\\py\\Easy\\211-univalued-binary-tree.py", "hypo_code": "class Solution(object):\n    def isUnivalTree(self, root):\n        \n        def dfs(node):\n            if not node: return []\n            return [node.val]+dfs(node.left)+dfs(node.right)\n        return len(set(dfs(root)))==1"}
{"id": "212", "path": "output2\\py\\Easy\\212-largest-perimeter-triangle.py", "hypo_code": "class Solution(object):\n    def largestPerimeter(self, nums):\n        \n        nums.sort(reverse=True)\n        for i in range(len(nums)-2):\n            if nums[i+1]+nums[i+2]>nums[i]:\n                return nums[i]+nums[i+1]+nums[i+2]\n        return 0"}
{"id": "213", "path": "output2\\py\\Easy\\213-squares-of-a-sorted-array.py", "hypo_code": "class Solution(object):\n    def sortedSquares(self, nums):\n        \n        result = []\n        left = 0\n        right = len(nums)-1\n        while left<=right:\n            if abs(nums[left])>abs(nums[right]):\n                result.append(nums[left]*nums[left])\n                left += 1\n            else:\n                result.append(nums[right]*nums[right])\n                right -= 1\n        return result[::-1]"}
{"id": "214", "path": "output2\\py\\Easy\\214-add-to-array-form-of-integer.py", "hypo_code": "class Solution(object):\n    def addToArrayForm(self, num, k):\n        \n        return list(str(int(''.join(map(str,num)))+k))"}
{"id": "215", "path": "output2\\py\\Easy\\215-cousins-in-binary-tree.py", "hypo_code": "class Solution(object):\n    def isCousins(self, root, x, y):\n        \n        def dfs(node, parent, depth):\n            if not node: return\n            if node.val==x:\n                self.x_parent = parent\n                self.x_depth = depth\n            if node.val==y:\n                self.y_parent = parent\n                self.y_depth = depth\n            dfs(node.left, node, depth+1)\n            dfs(node.right, node, depth+1)\n        dfs(root, None, 0)\n        return self.x_depth==self.y_depth and self.x_parent!=self.y_parent"}
{"id": "216", "path": "output2\\py\\Easy\\216-find-the-town-judge.py", "hypo_code": "class Solution(object):\n    def findJudge(self, n, trust):\n        \n        if n==1:\n            return 1\n        result = [0]*(n+1)\n        for i in trust:\n            result[i[0]] -= 1\n            result[i[1]] += 1\n        for i in range(1,len(result)):\n            if result[i] == n-1:\n                return i\n        return -1"}
{"id": "217", "path": "output2\\py\\Easy\\217-available-captures-for-rook.py", "hypo_code": "class Solution(object):\n    def numRookCaptures(self, board):\n        \n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'R':\n                    result = 0\n                    for k in range(j+1,8):\n                        if board[i][k] == 'B':\n                            break\n                        if board[i][k] == 'p':\n                            result += 1\n                            break\n                    for k in range(j-1,-1,-1):\n                        if board[i][k] == 'B':\n                            break\n                        if board[i][k] == 'p':\n                            result += 1\n                            break\n                    for k in range(i+1,8):\n                        if board[k][j] == 'B':\n                            break\n                        if board[k][j] == 'p':\n                            result += 1\n                            break\n                    for k in range(i-1,-1,-1):\n                        if board[k][j] == 'B':\n                            break\n                        if board[k][j] == 'p':\n                            result += 1\n                            break\n                    return result"}
{"id": "218", "path": "output2\\py\\Easy\\218-find-common-characters.py", "hypo_code": "class Solution(object):\n    def commonChars(self, words):\n        \n        result = []\n        for c in set(words[0]):\n            count = min([w.count(c) for w in words])\n            result += [c]*count\n        return result"}
{"id": "219", "path": "output2\\py\\Easy\\219-maximize-sum-of-array-after-k-negations.py", "hypo_code": "class Solution(object):\n    def largestSumAfterKNegations(self, nums, k):\n        \n        nums.sort()\n        for i in range(k):\n            nums[0] = -nums[0]\n            nums.sort()\n        return sum(nums)"}
{"id": "220", "path": "output2\\py\\Easy\\220-complement-of-base-10-integer.py", "hypo_code": "class Solution(object):\n    def bitwiseComplement(self, n):\n        \n        return int(''.join(map(str,[1-int(i) for i in bin(n)[2:]])),2)"}
{"id": "221", "path": "output2\\py\\Easy\\221-partition-array-into-three-parts-with-equal-sum.py", "hypo_code": "class Solution(object):\n    def canThreePartsEqualSum(self, arr):\n        \n        if sum(arr)%3 != 0:\n            return False\n        target = sum(arr)//3\n        count = 0\n        cur = 0\n        for i in arr:\n            cur += i\n            if cur == target:\n                count += 1\n                cur = 0\n        return count == 3"}
{"id": "222", "path": "output2\\py\\Easy\\222-binary-prefix-divisible-by-5.py", "hypo_code": "class Solution(object):\n    def prefixesDivBy5(self, nums):\n        \n        return [int(''.join(map(str,nums[:i+1])),2)%5==0 for i in range(len(nums))]"}
{"id": "223", "path": "output2\\py\\Easy\\223-remove-outermost-parentheses.py", "hypo_code": "class Solution(object):\n    def removeOuterParentheses(self, s):\n        \n        result = ''\n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(i)\n                if len(stack) > 1:\n                    result += i\n            else:\n                stack.pop()\n                if len(stack) > 0:\n                    result += i\n        return result"}
{"id": "224", "path": "output2\\py\\Easy\\224-sum-of-root-to-leaf-binary-numbers.py", "hypo_code": "class Solution(object):\n    def sumRootToLeaf(self, root):\n        \n        def dfs(node, pre):\n            if not node: return 0\n            pre = pre*2+node.val\n            if not node.left and not node.right: return pre\n            return dfs(node.left, pre)+dfs(node.right, pre)\n        return dfs(root, 0)"}
{"id": "225", "path": "output2\\py\\Easy\\225-divisor-game.py", "hypo_code": "class Solution(object):\n    def divisorGame(self, n):\n        \n        return n%2==0"}
{"id": "226", "path": "output2\\py\\Easy\\226-matrix-cells-in-distance-order.py", "hypo_code": "class Solution(object):\n    def allCellsDistOrder(self, rows, cols, rCenter, cCenter):\n        \n        result = []\n        for i in range(rows):\n            for j in range(cols):\n                result.append([i,j])\n        return sorted(result, key=lambda x: abs(x[0]-rCenter)+abs(x[1]-cCenter))"}
{"id": "227", "path": "output2\\py\\Easy\\227-valid-boomerang.py", "hypo_code": "class Solution(object):\n    def isBoomerang(self, points):\n        \n        return (points[1][1]-points[0][1])*(points[2][0]-points[0][0]) != (points[2][1]-points[0][1])*(points[1][0]-points[0][0])"}
{"id": "228", "path": "output2\\py\\Easy\\228-last-stone-weight.py", "hypo_code": "class Solution(object):\n    def lastStoneWeight(self, stones):\n        \n        while len(stones)>1:\n            stones.sort()\n            stones.append(stones.pop()-stones.pop())\n        return stones[0]"}
{"id": "229", "path": "output2\\py\\Easy\\229-remove-all-adjacent-duplicates-in-string.py", "hypo_code": "class Solution(object):\n    def removeDuplicates(self, s):\n        \n        result = []\n        for c in s:\n            if result and result[-1] == c:\n                result.pop()\n            else:\n                result.append(c)\n        return ''.join(result)"}
{"id": "231", "path": "output2\\py\\Easy\\231-height-checker.py", "hypo_code": "class Solution(object):\n    def heightChecker(self, heights):\n        \n        return sum(i != j for i, j in zip(heights, sorted(heights)))"}
{"id": "233", "path": "output2\\py\\Easy\\233-greatest-common-divisor-of-strings.py", "hypo_code": "class Solution(object):\n    def gcdOfStrings(self, str1, str2):\n        \n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n        return str1[:gcd(len(str1), len(str2))] if str1+str2 == str2+str1 else ''"}
{"id": "235", "path": "output2\\py\\Easy\\235-occurrences-after-bigram.py", "hypo_code": "class Solution(object):\n    def findOcurrences(self, text, first, second):\n        \n        result = []\n        words = text.split()\n        for i in range(len(words)-2):\n            if words[i]==first and words[i+1]==second:\n                result.append(words[i+2])\n        return result"}
{"id": "237", "path": "output2\\py\\Easy\\237-duplicate-zeros.py", "hypo_code": "class Solution(object):\n    def duplicateZeros(self, arr):\n        \n        i = 0\n        while i < len(arr):\n            if arr[i] == 0:\n                arr.insert(i,0)\n                arr.pop()\n                i += 1\n            i += 1"}
{"id": "238", "path": "output2\\py\\Easy\\238-distribute-candies-to-people.py", "hypo_code": "class Solution(object):\n    def distributeCandies(self, candies, num_people):\n        \n        result = [0] * num_people\n        i = 0\n        while candies > 0:\n            if candies > i + 1:\n                result[i % num_people] += i + 1\n            else:\n                result[i % num_people] += candies\n            candies -= i + 1\n            i += 1\n        return result"}
{"id": "239", "path": "output2\\py\\Easy\\239-defanging-an-ip-address.py", "hypo_code": "class Solution(object):\n    def defangIPaddr(self, address):\n        \n        return address.replace('.', '[.]')"}
{"id": "241", "path": "output2\\py\\Easy\\241-relative-sort-array.py", "hypo_code": "class Solution(object):\n    def relativeSortArray(self, arr1, arr2):\n        \n        result = []\n        for i in arr2:\n            while i in arr1:\n                result.append(i)\n                arr1.remove(i)\n        result += sorted(arr1)\n        return result"}
{"id": "242", "path": "output2\\py\\Easy\\242-number-of-equivalent-domino-pairs.py", "hypo_code": "class Solution(object):\n    def numEquivDominoPairs(self, dominoes):\n          \n        result = 0\n        for i in range(len(dominoes)):\n            for j in range(i+1,len(dominoes)):\n                if (dominoes[i][0] == dominoes[j][0] and dominoes[i][1] == dominoes[j][1]) or (dominoes[i][0] == dominoes[j][1] and dominoes[i][1] == dominoes[j][0]):\n                    result += 1\n        return result"}
{"id": "243", "path": "output2\\py\\Easy\\243-n-th-tribonacci-number.py", "hypo_code": "class Solution(object):\n    def tribonacci(self, n):\n        \n        a, b, c = 0, 1, 1\n        for i in range(n):\n            a, b, c = b, c, a+b+c\n        return a"}
{"id": "246", "path": "output2\\py\\Easy\\246-day-of-the-year.py", "hypo_code": "class Solution(object):\n    def dayOfYear(self, date):\n        \n        year,month,day = map(int,date.split('-'))\n        return (datetime.date(year,month,day)-datetime.date(year,1,1)).days+1"}
{"id": "247", "path": "output2\\py\\Easy\\247-find-words-that-can-be-formed-by-characters.py", "hypo_code": "class Solution(object):\n    def countCharacters(self, words, chars):\n        \n        result = 0\n        for i in words:\n            flag = True\n            for j in i:\n                if i.count(j)>chars.count(j):\n                    flag = False\n                    break\n            if flag:\n                result += len(i)\n        return result"}
{"id": "249", "path": "output2\\py\\Easy\\249-prime-arrangements.py", "hypo_code": "class Solution(object):\n    def numPrimeArrangements(self, n):\n        \n        prime = [2]\n        for i in range(3,n+1):\n            isPrime = True\n            for j in prime:\n                if i%j == 0:\n                    isPrime = False\n                    break\n            if isPrime:\n                prime.append(i)\n        return math.factorial(len(prime))*math.factorial(n-len(prime))%(10**9+7)"}
{"id": "251", "path": "output2\\py\\Easy\\251-distance-between-bus-stops.py", "hypo_code": "class Solution(object):\n    def distanceBetweenBusStops(self, distance, start, destination):\n          \n        if start > destination:\n            start, destination = destination, start\n        return min(sum(distance[start:destination]), sum(distance)-sum(distance[start:destination]))"}
{"id": "252", "path": "output2\\py\\Easy\\252-day-of-the-week.py", "hypo_code": "class Solution(object):\n    def dayOfTheWeek(self, day, month, year):\n         \n        from datetime import date\n        return date(year, month, day).strftime(\"%A\")"}
{"id": "253", "path": "output2\\py\\Easy\\253-maximum-number-of-balloons.py", "hypo_code": "class Solution(object):\n    def maxNumberOfBalloons(self, text):\n        \n        return min(text.count('b'),text.count('a'),text.count('l')/2,text.count('o')/2,text.count('n'))"}
{"id": "254", "path": "output2\\py\\Easy\\254-minimum-absolute-difference.py", "hypo_code": "class Solution(object):\n    def minimumAbsDifference(self, arr):\n        \n        arr.sort()\n        result = []\n        min_diff = arr[1] - arr[0]\n        for i in range(len(arr)-1):\n            if arr[i+1] - arr[i] < min_diff:\n                min_diff = arr[i+1] - arr[i]\n        for i in range(len(arr)-1):\n            if arr[i+1] - arr[i] == min_diff:\n                result.append([arr[i], arr[i+1]])\n        return result"}
{"id": "255", "path": "output2\\py\\Easy\\255-unique-number-of-occurrences.py", "hypo_code": "class Solution(object):\n    def uniqueOccurrences(self, arr):\n        \n        d = collections.Counter(arr)\n        return len(d.values()) == len(set(d.values()))"}
{"id": "257", "path": "output2\\py\\Easy\\257-minimum-cost-to-move-chips-to-the-same-position.py", "hypo_code": "class Solution(object):\n    def minCostToMoveChips(self, position):\n        \n        result = 0\n        for i in position:\n            if i%2 == 1:\n                result += 1\n        return min(result, len(position)-result)"}
{"id": "258", "path": "output2\\py\\Easy\\258-split-a-string-in-balanced-strings.py", "hypo_code": "class Solution(object):\n    def balancedStringSplit(self, s):\n        \n        result = 0\n        count = 0\n        for i in s:\n            count += 1 if i == 'L' else -1\n            if count == 0:\n                result += 1\n        return result"}
{"id": "259", "path": "output2\\py\\Easy\\259-check-if-it-is-a-straight-line.py", "hypo_code": "class Solution(object):\n    def checkStraightLine(self, coordinates):\n        \n        x1,y1 = coordinates[0]\n        x2,y2 = coordinates[1]\n        for i in range(2,len(coordinates)):\n            x,y = coordinates[i]\n            if (y2-y1)*(x-x1) != (y-y1)*(x2-x1):\n                return False\n        return True"}
{"id": "261", "path": "output2\\py\\Easy\\261-cells-with-odd-values-in-a-matrix.py", "hypo_code": "class Solution(object):\n    def oddCells(self, m, n, indices):\n        \n        row = [0]*m\n        col = [0]*n\n        for i in indices:\n            row[i[0]] += 1\n            col[i[1]] += 1\n        result = 0\n        for i in range(m):\n            for j in range(n):\n                result += (row[i]+col[j])%2\n        return result"}
{"id": "262", "path": "output2\\py\\Easy\\262-shift-2d-grid.py", "hypo_code": "class Solution(object):\n    def shiftGrid(self, grid, k):\n        \n        result = []\n        for i in grid:\n            result += i\n        for i in range(k):\n            result = [result[-1]]+result[:-1]\n        return [result[i:i+len(grid[0])] for i in range(0, len(result), len(grid[0]))]"}
{"id": "263", "path": "output2\\py\\Easy\\263-minimum-time-visiting-all-points.py", "hypo_code": "class Solution(object):\n    def minTimeToVisitAllPoints(self, points):\n         \n        result = 0\n        for i in range(len(points)-1):\n            result += max(abs(points[i+1][0]-points[i][0]), abs(points[i+1][1]-points[i][1]))\n        return result"}
{"id": "264", "path": "output2\\py\\Easy\\264-find-winner-on-a-tic-tac-toe-game.py", "hypo_code": "class Solution(object):\n    def tictactoe(self, moves):\n        \n        a = [0]*8\n        b = [0]*8\n        for i in range(len(moves)):\n            r = moves[i][0]\n            c = moves[i][1]\n            player = b if i%2 else a\n            player[r] += 1\n            player[c+3] += 1\n            if r == c:\n                player[6] += 1\n            if r == 2-c:\n                player[7] += 1\n        for i in range(8):\n            if a[i] == 3:\n                return \"A\"\n            if b[i] == 3:\n                return \"B\"\n        return \"Draw\" if len(moves) == 9 else \"Pending\""}
{"id": "266", "path": "output2\\py\\Easy\\266-subtract-the-product-and-sum-of-digits-of-an-integer.py", "hypo_code": "class Solution(object):\n    def subtractProductAndSum(self, n):\n        \n        product, sum = 1, 0\n        for i in str(n):\n            product *= int(i)\n            sum += int(i)\n        return product-sum"}
{"id": "267", "path": "output2\\py\\Easy\\267-element-appearing-more-than-25-in-sorted-array.py", "hypo_code": "class Solution(object):\n    def findSpecialInteger(self, arr):\n        \n        return collections.Counter(arr).most_common(1)[0][0]"}
{"id": "268", "path": "output2\\py\\Easy\\268-convert-binary-number-in-a-linked-list-to-integer.py", "hypo_code": "class Solution(object):\n    def getDecimalValue(self, head):\n        \n        res = 0\n        while head:\n            res = res*2 + head.val\n            head = head.next\n        return res"}
{"id": "269", "path": "output2\\py\\Easy\\269-find-numbers-with-even-number-of-digits.py", "hypo_code": "class Solution(object):\n    def findNumbers(self, nums):\n        \n        return sum([len(str(i))%2==0 for i in nums])"}
{"id": "270", "path": "output2\\py\\Easy\\270-replace-elements-with-greatest-element-on-right-side.py", "hypo_code": "class Solution(object):\n    def replaceElements(self, arr):\n        \n        result = []\n        for i in range(len(arr)-1):\n            result.append(max(arr[i+1:]))\n        result.append(-1)\n        return result"}
{"id": "271", "path": "output2\\py\\Easy\\271-find-n-unique-integers-sum-up-to-zero.py", "hypo_code": "class Solution(object):\n    def sumZero(self, n):\n        \n        result = []\n        for i in range(1,n/2+1):\n            result.append(i)\n            result.append(-i)\n        if n%2 == 1:\n            result.append(0)\n        return result"}
{"id": "272", "path": "output2\\py\\Easy\\272-decrypt-string-from-alphabet-to-integer-mapping.py", "hypo_code": "class Solution(object):\n    def freqAlphabets(self, s):\n        \n        result = ''\n        i = len(s)-1\n        while i >= 0:\n            if s[i] == '\n                result += chr(int(s[i-2:i])+96)\n                i -= 3\n            else:\n                result += chr(int(s[i])+96)\n                i -= 1\n        return result[::-1]"}
{"id": "273", "path": "output2\\py\\Easy\\273-decompress-run-length-encoded-list.py", "hypo_code": "class Solution(object):\n    def decompressRLElist(self, nums):\n         \n        return [nums[i+1] for i in range(0,len(nums),2) for j in range(nums[i])]"}
{"id": "274", "path": "output2\\py\\Easy\\274-convert-integer-to-the-sum-of-two-no-zero-integers.py", "hypo_code": "class Solution(object):\n    def getNoZeroIntegers(self, n):\n        \n        for i in range(1,n):\n            if '0' not in str(i) and '0' not in str(n-i):\n                return [i,n-i]"}
{"id": "275", "path": "output2\\py\\Easy\\275-maximum-69-number.py", "hypo_code": "class Solution(object):\n    def maximum69Number (self, num):\n        \n        return int(str(num).replace('6','9',1))"}
{"id": "277", "path": "output2\\py\\Easy\\277-rank-transform-of-an-array.py", "hypo_code": "class Solution(object):\n    def arrayRankTransform(self, arr):\n        \n        sort_arr = sorted(set(arr))\n        return [sort_arr.index(i)+1 for i in arr]"}
{"id": "278", "path": "output2\\py\\Easy\\278-remove-palindromic-subsequences.py", "hypo_code": "class Solution(object):\n    def removePalindromeSub(self, s):\n        \n        return 2 if s!=s[::-1] else 1 if len(s)!=0 else 0"}
{"id": "279", "path": "output2\\py\\Easy\\279-the-k-weakest-rows-in-a-matrix.py", "hypo_code": "class Solution(object):\n    def kWeakestRows(self, mat, k):\n        \n        return [i[0] for i in sorted([[i,mat[i].count(1)] for i in range(len(mat))], key=lambda x: x[1])[:k]]"}
{"id": "280", "path": "output2\\py\\Easy\\280-number-of-steps-to-reduce-a-number-to-zero.py", "hypo_code": "class Solution(object):\n    def numberOfSteps(self, num):\n        \n        result = 0\n        while num>0:\n            if num%2 == 0:\n                num /= 2\n            else:\n                num -= 1\n            result += 1\n        return result"}
{"id": "281", "path": "output2\\py\\Easy\\281-check-if-n-and-its-double-exist.py", "hypo_code": "class Solution(object):\n    def checkIfExist(self, arr):\n        \n        return any(arr[i]*2 in arr[:i]+arr[i+1:] for i in range(len(arr)))"}
{"id": "282", "path": "output2\\py\\Easy\\282-count-negative-numbers-in-a-sorted-matrix.py", "hypo_code": "class Solution(object):\n    def countNegatives(self, grid):\n        \n        return sum([1 for i in grid for j in i if j<0])"}
{"id": "283", "path": "output2\\py\\Easy\\283-sort-integers-by-the-number-of-1-bits.py", "hypo_code": "class Solution(object):\n    def sortByBits(self, arr):"}
{"id": "284", "path": "output2\\py\\Easy\\284-number-of-days-between-two-dates.py", "hypo_code": "class Solution(object):\n    def daysBetweenDates(self, date1, date2):\n          \n        from datetime import date\n        return abs((date(*map(int,date1.split('-')))-date(*map(int,date2.split('-')))).days)"}
{"id": "285", "path": "output2\\py\\Easy\\285-how-many-numbers-are-smaller-than-the-current-number.py", "hypo_code": "class Solution(object):\n    def smallerNumbersThanCurrent(self, nums):\n        \n        return [sum([1 for j in nums if j<i]) for i in nums]"}
{"id": "286", "path": "output2\\py\\Easy\\286-increasing-decreasing-string.py", "hypo_code": "class Solution(object):\n    def sortString(self, s):\n        \n        letters = sorted(list(set(s)))\n        result = ''\n        while letters:\n            for i in letters:\n                if i in s:\n                    result += i\n                    s = s.replace(i,'',1)\n            letters = letters[::-1]\n        return result"}
{"id": "287", "path": "output2\\py\\Easy\\287-generate-a-string-with-characters-that-have-odd-counts.py", "hypo_code": "class Solution(object):\n    def generateTheString(self, n):\n        \n        return 'a'*(n-1)+'b'*(n%2)+'c'"}
{"id": "290", "path": "output2\\py\\Easy\\290-lucky-numbers-in-a-matrix.py", "hypo_code": "class Solution(object):\n    def luckyNumbers (self, matrix):\n        \n        return [min(i) for i in matrix if min(i) in [max(j) for j in zip(*matrix)]]"}
{"id": "291", "path": "output2\\py\\Easy\\291-find-the-distance-value-between-two-arrays.py", "hypo_code": "class Solution(object):\n    def findTheDistanceValue(self, arr1, arr2, d):\n        \n        return sum([1 for i in arr1 if all([abs(i-j)>d for j in arr2])])"}
{"id": "292", "path": "output2\\py\\Easy\\292-create-target-array-in-the-given-order.py", "hypo_code": "class Solution(object):\n    def createTargetArray(self, nums, index):\n          \n        return [nums[i] for i in index]"}
{"id": "293", "path": "output2\\py\\Easy\\293-find-lucky-integer-in-an-array.py", "hypo_code": "class Solution(object):\n    def findLucky(self, arr):\n        \n        return max([i for i in arr if arr.count(i)==i]+[-1])"}
{"id": "294", "path": "output2\\py\\Easy\\294-count-largest-group.py", "hypo_code": "class Solution(object):\n    def countLargestGroup(self, n):\n        \n        return len([i for i in range(1,n+1) if sum(map(int,str(i)))==sum(map(int,str(n)))])"}
{"id": "295", "path": "output2\\py\\Easy\\295-minimum-subsequence-in-non-increasing-order.py", "hypo_code": "class Solution(object):\n    def minSubsequence(self, nums):\n        \n        nums.sort()\n        s=sum(nums)\n        for i in range(len(nums)):\n            if sum(nums[i:])>s-sum(nums[i:]):\n                return nums[i:]"}
{"id": "297", "path": "output2\\py\\Easy\\297-string-matching-in-an-array.py", "hypo_code": "class Solution(object):\n    def stringMatching(self, words):"}
{"id": "298", "path": "output2\\py\\Easy\\298-minimum-value-to-get-positive-step-by-step-sum.py", "hypo_code": "class Solution(object):\n    def minStartValue(self, nums):\n        \n        return max(1,1-min(nums))"}
{"id": "299", "path": "output2\\py\\Easy\\299-reformat-the-string.py", "hypo_code": "class Solution(object):\n    def reformat(self, s):\n        \n        a=[i for i in s if i.isalpha()]\n        b=[i for i in s if i.isdigit()]\n        if abs(len(a)-len(b))>1:\n            return ''\n        else:\n            return ''.join([a[i]+b[i] for i in range(min(len(a),len(b)))])+(a[-1] if len(a)>len(b) else b[-1]) if len(a)!=len(b) else ''"}
{"id": "300", "path": "output2\\py\\Easy\\300-maximum-score-after-splitting-a-string.py", "hypo_code": "class Solution(object):\n    def maxScore(self, s):\n        \n        return max([s[:i].count('0')+s[i:].count('1') for i in range(1,len(s))])"}
{"id": "301", "path": "output2\\py\\Easy\\301-kids-with-the-greatest-number-of-candies.py", "hypo_code": "class Solution(object):\n    def kidsWithCandies(self, candies, extraCandies):\n        \n        return [i+extraCandies>=max(candies) for i in candies]"}
{"id": "302", "path": "output2\\py\\Easy\\302-destination-city.py", "hypo_code": "class Solution(object):\n    def destCity(self, paths):\n        \n        return (set([i[1] for i in paths])-set([i[0] for i in paths])).pop()"}
{"id": "303", "path": "output2\\py\\Easy\\303-check-if-all-1s-are-at-least-length-k-places-away.py", "hypo_code": "class Solution(object):\n    def kLengthApart(self, nums, k):\n        \n        return all(i==0 or i>=k for i in (len(nums)-1-i for i in range(len(nums)) if nums[len(nums)-1-i]==1))"}
{"id": "304", "path": "output2\\py\\Easy\\304-consecutive-characters.py", "hypo_code": "class Solution(object):\n    def maxPower(self, s):\n        \n        return max([s.count(i) for i in set(s)])"}
{"id": "305", "path": "output2\\py\\Easy\\305-number-of-students-doing-homework-at-a-given-time.py", "hypo_code": "class Solution(object):\n    def busyStudent(self, startTime, endTime, queryTime):\n        \n        return sum([1 for i in range(len(startTime)) if startTime[i]<=queryTime<=endTime[i]])"}
{"id": "306", "path": "output2\\py\\Easy\\306-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence.py", "hypo_code": "class Solution(object):\n    def isPrefixOfWord(self, sentence, searchWord):\n         \n        return next((i+1 for i,word in enumerate(sentence.split()) if word.startswith(searchWord)), -1)"}
{"id": "307", "path": "output2\\py\\Easy\\307-make-two-arrays-equal-by-reversing-subarrays.py", "hypo_code": "class Solution(object):\n    def canBeEqual(self, target, arr):\n        \n        return sorted(target)==sorted(arr)"}
{"id": "308", "path": "output2\\py\\Easy\\308-maximum-product-of-two-elements-in-an-array.py", "hypo_code": "class Solution(object):\n    def maxProduct(self, nums):\n        \n        return (max(nums)-1)*(sorted(nums)[-2]-1)"}
{"id": "309", "path": "output2\\py\\Easy\\309-shuffle-the-array.py", "hypo_code": "class Solution(object):\n    def shuffle(self, nums, n):\n        \n        return [nums[i//2] if i%2==0 else nums[n+i//2] for i in range(2*n)]"}
{"id": "310", "path": "output2\\py\\Easy\\310-final-prices-with-a-special-discount-in-a-shop.py", "hypo_code": "class Solution(object):\n    def finalPrices(self, prices):\n        \n        return [i-min([j for j in prices[i+1:] if j<=i]) for i in prices]"}
{"id": "311", "path": "output2\\py\\Easy\\311-running-sum-of-1d-array.py", "hypo_code": "class Solution(object):\n    def runningSum(self, nums):\n        \n        return [sum(nums[:i+1]) for i in range(len(nums))]"}
{"id": "313", "path": "output2\\py\\Easy\\313-xor-operation-in-an-array.py", "hypo_code": "class Solution(object):\n    def xorOperation(self, n, start):\n         \n        return reduce(lambda x,y:x^y,[start+2*i for i in range(n)])"}
{"id": "314", "path": "output2\\py\\Easy\\314-average-salary-excluding-the-minimum-and-maximum-salary.py", "hypo_code": "class Solution(object):\n    def average(self, salary):\n        \n        return sum(sorted(salary)[1:-1])/(len(salary)-2)"}
{"id": "315", "path": "output2\\py\\Easy\\315-path-crossing.py", "hypo_code": "class Solution(object):\n    def isPathCrossing(self, path):\n        \n        return any(path.count(i)>=2 for i in set(path))"}
{"id": "316", "path": "output2\\py\\Easy\\316-can-make-arithmetic-progression-from-sequence.py", "hypo_code": "class Solution(object):\n    def canMakeArithmeticProgression(self, arr):"}
{"id": "317", "path": "output2\\py\\Easy\\317-reformat-date.py", "hypo_code": "class Solution(object):\n    def reformatDate(self, date):\n        \n        import datetime\n        return (datetime.datetime.strptime(date,'%d %b %Y')).strftime('%Y-%m-%d')"}
{"id": "318", "path": "output2\\py\\Easy\\318-number-of-good-pairs.py", "hypo_code": "class Solution(object):\n    def numIdenticalPairs(self, nums):\n        \n        return sum([nums[i+1:].count(nums[i]) for i in range(len(nums)-1)])"}
{"id": "320", "path": "output2\\py\\Easy\\320-water-bottles.py", "hypo_code": "class Solution(object):\n    def numWaterBottles(self, numBottles, numExchange):\n        \n        return numBottles+((numBottles-1)/(numExchange-1))"}
{"id": "321", "path": "output2\\py\\Easy\\321-count-odd-numbers-in-an-interval-range.py", "hypo_code": "class Solution(object):\n    def countOdds(self, low, high):\n         \n        return (high-low)/2+(low%2 or high%2)"}
{"id": "323", "path": "output2\\py\\Easy\\323-shuffle-string.py", "hypo_code": "class Solution(object):\n    def restoreString(self, s, indices):\n         \n        return ''.join([c for _,c in sorted(zip(indices,s))])"}
{"id": "324", "path": "output2\\py\\Easy\\324-count-good-triplets.py", "hypo_code": "class Solution(object):\n    def countGoodTriplets(self, arr, a, b, c):\n        \n        return sum([1 for i in range(len(arr)) for j in range(i+1,len(arr)) for k in range(j+1,len(arr)) if abs(arr[i]-arr[j])<=a and abs(arr[j]-arr[k])<=b and abs(arr[i]-arr[k])<=c])"}
{"id": "325", "path": "output2\\py\\Easy\\325-kth-missing-positive-number.py", "hypo_code": "class Solution(object):\n    def findKthPositive(self, arr, k):\n         \n        return min(set(range(1,max(arr)+k+1))-set(arr))"}
{"id": "326", "path": "output2\\py\\Easy\\326-make-the-string-great.py", "hypo_code": "class Solution(object):\n    def makeGood(self, s):\n        \n        for i in range(len(s)-1):\n            if s[i]!=s[i+1] and s[i].upper()==s[i+1].upper():\n                return self.makeGood(s[:i]+s[i+2:])\n        return s"}
{"id": "327", "path": "output2\\py\\Easy\\327-three-consecutive-odds.py", "hypo_code": "class Solution(object):\n    def threeConsecutiveOdds(self, arr):\n        \n        return any(all(i%2==1 for i in arr[j:j+3]) for j in range(len(arr)-2))"}
{"id": "328", "path": "output2\\py\\Easy\\328-thousand-separator.py", "hypo_code": "class Solution(object):\n    def thousandSeparator(self, n):\n        \n        return '{:,}'.format(n).replace(',','.')"}
{"id": "329", "path": "output2\\py\\Easy\\329-most-visited-sector-in-a-circular-track.py", "hypo_code": "class Solution(object):\n    def mostVisited(self, n, rounds):\n        \n        return [i for i in range(rounds[0], rounds[-1]+1)] if rounds[0]<=rounds[-1] else [i for i in range(1, rounds[-1]+1)]+[i for i in range(rounds[0], n+1)]"}
{"id": "330", "path": "output2\\py\\Easy\\330-detect-pattern-of-length-m-repeated-k-or-more-times.py", "hypo_code": "class Solution(object):\n    def containsPattern(self, arr, m, k):\n        \n        return any(arr[i:i+m]*k==arr[i:i+m*k] for i in range(len(arr)-m+1))"}
{"id": "331", "path": "output2\\py\\Easy\\331-matrix-diagonal-sum.py", "hypo_code": "class Solution(object):\n    def diagonalSum(self, mat):\n         \n        return sum([i[j] for i in mat for j in range(len(i)) if i.index(j) == j or i.index(j) == len(i)-1-j])"}
{"id": "332", "path": "output2\\py\\Easy\\332-replace-all-s-to-avoid-consecutive-repeating-characters.py", "hypo_code": "class Solution(object):\n    def modifyString(self, s):\n        \n        s=list(s)\n        for i in range(len(s)):\n            if s[i]=='?':\n                for j in 'abcdefghijklmnopqrstuvwxyz':\n                    if (i==0 or s[i-1]!=j) and (i==len(s)-1 or s[i+1]!=j):\n                        s[i]=j\n                        break\n        return ''.join(s)"}
{"id": "334", "path": "output2\\py\\Easy\\334-special-positions-in-a-binary-matrix.py", "hypo_code": "class Solution(object):\n    def numSpecial(self, mat):\n        \n        return sum([1 for i in range(len(mat)) for j in range(len(mat[i])) if mat[i][j]==1 and sum(mat[i])==1 and sum([mat[k][j] for k in range(len(mat))])==1])"}
{"id": "336", "path": "output2\\py\\Easy\\336-sum-of-all-odd-length-subarrays.py", "hypo_code": "class Solution(object):\n    def sumOddLengthSubarrays(self, arr):\n        \n        return sum([sum(arr[i:i+k]) for k in range(1,len(arr)+1,2) for i in range(len(arr)-k+1)])"}
{"id": "337", "path": "output2\\py\\Easy\\337-rearrange-spaces-between-words.py", "hypo_code": "class Solution(object):\n    def reorderSpaces(self, text):\n        \n        a=text.split()\n        b=text.count(' ')\n        return (' '*(b//(len(a)-1))).join(a)+(' '*(b%(len(a)-1))) if len(a)>1 else ' '.join(a)+(' '*b)"}
{"id": "338", "path": "output2\\py\\Easy\\338-crawler-log-folder.py", "hypo_code": "class Solution(object):\n    def minOperations(self, logs):\n        \n        return max(sum(1 for i in logs if i==\"../\"),0)"}
{"id": "340", "path": "output2\\py\\Easy\\340-special-array-with-x-elements-greater-than-or-equal-x.py", "hypo_code": "class Solution(object):\n    def specialArray(self, nums):\n        \n        return max([i for i in range(len(nums)+1) if nums.count(i)==i]+[-1])"}
{"id": "341", "path": "output2\\py\\Easy\\341-maximum-nesting-depth-of-the-parentheses.py", "hypo_code": "class Solution(object):\n    def maxDepth(self, s):\n        \n        return max([s.count('('),s.count(')')])"}
{"id": "342", "path": "output2\\py\\Easy\\342-mean-of-array-after-removing-some-elements.py", "hypo_code": "class Solution(object):\n    def trimMean(self, arr):\n        \n        return sum(sorted(arr)[len(arr)//20:-len(arr)//20])/len(arr)*10"}
{"id": "343", "path": "output2\\py\\Easy\\343-largest-substring-between-two-equal-characters.py", "hypo_code": "class Solution(object):\n    def maxLengthBetweenEqualCharacters(self, s):\n        \n        return max([s.rfind(i)-s.find(i)-1 for i in s if s.count(i)>1]+[-1])"}
{"id": "344", "path": "output2\\py\\Easy\\344-slowest-key.py", "hypo_code": "class Solution(object):\n    def slowestKey(self, releaseTimes, keysPressed):\n        \n        return max([(keysPressed[i],releaseTimes[i]-releaseTimes[i-1]) for i in range(1,len(keysPressed))], key=lambda x: (x[1],x[0]))[0]"}
{"id": "346", "path": "output2\\py\\Easy\\346-sort-array-by-increasing-frequency.py", "hypo_code": "class Solution(object):\n    def frequencySort(self, nums):\n        \n        return sorted(nums,key=lambda x:(nums.count(x),-x))"}
{"id": "347", "path": "output2\\py\\Easy\\347-check-array-formation-through-concatenation.py", "hypo_code": "class Solution(object):\n    def canFormArray(self, arr, pieces):\n        \n        return all([any(arr[i:i+len(p)]==p for i in range(0,len(arr)-len(p)+1)) for p in pieces])"}
{"id": "348", "path": "output2\\py\\Easy\\348-get-maximum-in-generated-array.py", "hypo_code": "class Solution(object):\n    def getMaximumGenerated(self, n):\n        \n        return max([0,1]+[0]*(n-1) if n<2 else self.getMaximumGenerated(n-1)+[0,1][n%2==0]*self.getMaximumGenerated(n/2))"}
{"id": "349", "path": "output2\\py\\Easy\\349-defuse-the-bomb.py", "hypo_code": "class Solution(object):\n    def decrypt(self, code, k):\n        \n        if k==0:\n            return [0]*len(code)\n        elif k>0:\n            return [sum(code[i+1:i+k+1]) for i in range(len(code))]\n        else:\n            return [sum(code[i-k:i]) for i in range(len(code))]"}
{"id": "352", "path": "output2\\py\\Easy\\352-check-if-two-string-arrays-are-equivalent.py", "hypo_code": "class Solution(object):\n    def arrayStringsAreEqual(self, word1, word2):\n        \n        return ''.join(word1) == ''.join(word2)"}
{"id": "354", "path": "output2\\py\\Easy\\354-maximum-repeating-substring.py", "hypo_code": "class Solution(object):\n    def maxRepeating(self, sequence, word):\n        \n        return sequence.count(word*100)"}
{"id": "355", "path": "output2\\py\\Easy\\355-richest-customer-wealth.py", "hypo_code": "class Solution(object):\n    def maximumWealth(self, accounts):\n        \n        return max(sum(i) for i in accounts)"}
{"id": "356", "path": "output2\\py\\Easy\\356-goal-parser-interpretation.py", "hypo_code": "class Solution(object):\n    def interpret(self, command):\n        \n        return command.replace('()','o').replace('(al)','al')"}
{"id": "358", "path": "output2\\py\\Easy\\358-count-the-number-of-consistent-strings.py", "hypo_code": "class Solution(object):\n    def countConsistentStrings(self, allowed, words):\n        \n        return sum(all(c in allowed for c in w) for w in words)"}
{"id": "359", "path": "output2\\py\\Easy\\359-count-of-matches-in-tournament.py", "hypo_code": "class Solution(object):\n    def numberOfMatches(self, n):\n        \n        return n-1"}
{"id": "361", "path": "output2\\py\\Easy\\361-reformat-phone-number.py", "hypo_code": "class Solution(object):\n    def reformatNumber(self, number):\n        \n        return re.sub('(...?(?=..))','\\\\1-',re.sub('\\D','',number))"}
{"id": "362", "path": "output2\\py\\Easy\\362-number-of-students-unable-to-eat-lunch.py", "hypo_code": "class Solution(object):\n    def countStudents(self, students, sandwiches):\n        \n        while sandwiches:\n            if sandwiches[0] in students:\n                students.remove(sandwiches[0])\n                sandwiches.pop(0)\n            else:\n                break\n        return len(sandwiches)"}
{"id": "363", "path": "output2\\py\\Easy\\363-determine-if-string-halves-are-alike.py", "hypo_code": "class Solution(object):\n    def halvesAreAlike(self, s):\n        \n        vowels = 'aeiouAEIOU'\n        return sum(c in vowels for c in s[:len(s)/2]) == sum(c in vowels for c in s[len(s)/2:])"}
{"id": "364", "path": "output2\\py\\Easy\\364-maximum-units-on-a-truck.py", "hypo_code": "class Solution(object):\n    def maximumUnits(self, boxTypes, truckSize):\n        \n        boxTypes.sort(key=lambda x: -x[1])\n        res = 0\n        for n, units in boxTypes:\n            if truckSize >= n:\n                res += n * units\n                truckSize -= n\n            else:\n                res += truckSize * units\n                break\n        return res"}
{"id": "365", "path": "output2\\py\\Easy\\365-calculate-money-in-leetcode-bank.py", "hypo_code": "class Solution(object):\n    def totalMoney(self, n):\n        \n        res = 0\n        for i in range(n):\n            res += (i//7+1)+i%7\n        return res"}
{"id": "366", "path": "output2\\py\\Easy\\366-decode-xored-array.py", "hypo_code": "class Solution(object):\n    def decode(self, encoded, first):\n         \n        res = [first]\n        for i in encoded:\n            res.append(res[-1]^i)\n        return res"}
{"id": "367", "path": "output2\\py\\Easy\\367-number-of-rectangles-that-can-form-the-largest-square.py", "hypo_code": "class Solution(object):\n    def countGoodRectangles(self, rectangles):\n        \n        return collections.Counter(min(i) for i in rectangles)[max(collections.Counter(min(i) for i in rectangles))]"}
{"id": "370", "path": "output2\\py\\Easy\\370-find-the-highest-altitude.py", "hypo_code": "class Solution(object):\n    def largestAltitude(self, gain):\n        \n        return max(0,max(accumulate(gain)))"}
{"id": "371", "path": "output2\\py\\Easy\\371-latest-time-by-replacing-hidden-digits.py", "hypo_code": "class Solution(object):\n    def maximumTime(self, time):\n        \n        return time.replace('?','9') if time[0]=='?' else (time.replace('?','3') if time[1]=='?' else (time.replace('?','5') if time[3]=='?' else time.replace('?','9')))"}
{"id": "373", "path": "output2\\py\\Easy\\373-maximum-number-of-balls-in-a-box.py", "hypo_code": "class Solution(object):\n    def countBalls(self, lowLimit, highLimit):\n        \n        def digitSum(n):\n            sum = 0\n            while n > 0:\n                sum += n % 10\n                n //= 10\n            return sum\n        boxes = {}\n        for i in range(lowLimit, highLimit+1):\n            sum = digitSum(i)\n            if sum in boxes:\n                boxes[sum] += 1\n            else:\n                boxes[sum] = 1\n        return max(boxes.values())"}
{"id": "374", "path": "output2\\py\\Easy\\374-sum-of-unique-elements.py", "hypo_code": "class Solution(object):\n    def sumOfUnique(self, nums):\n        \n        return sum([i for i in nums if nums.count(i)==1])"}
{"id": "375", "path": "output2\\py\\Easy\\375-check-if-array-is-sorted-and-rotated.py", "hypo_code": "class Solution(object):\n    def check(self, nums):\n        \n        return sorted(nums)==nums or sorted(nums)==nums[::-1]"}
{"id": "377", "path": "output2\\py\\Easy\\377-minimum-changes-to-make-alternating-binary-string.py", "hypo_code": "class Solution(object):\n    def minOperations(self, s):\n        \n        return min(s.count('0',i%2) + s.count('1',1-i%2) for i in range(2))"}
{"id": "378", "path": "output2\\py\\Easy\\378-longest-nice-substring.py", "hypo_code": "class Solution(object):\n    def longestNiceSubstring(self, s):\n        \n        for i in range(len(s)):\n            for j in range(len(s),i,-1):\n                if all([s[x].swapcase() in s[i:j] for x in range(i,j)])==True:\n                    return s[i:j]\n        return ''"}
{"id": "379", "path": "output2\\py\\Easy\\379-merge-strings-alternately.py", "hypo_code": "class Solution(object):\n    def mergeAlternately(self, word1, word2):\n        \n       return ''.join([word1[i] + word2[i] for i in range(min(len(word1),len(word2)))]) + word1[min(len(word1),len(word2)):] + word2[min(len(word1),len(word2)):]"}
{"id": "380", "path": "output2\\py\\Easy\\380-count-items-matching-a-rule.py", "hypo_code": "class Solution(object):\n    def countMatches(self, items, ruleKey, ruleValue):\n        \n        return sum([1 for i in items if i[[\"type\",\"color\",\"name\"].index(ruleKey)]==ruleValue])"}
{"id": "381", "path": "output2\\py\\Easy\\381-find-nearest-point-that-has-the-same-x-or-y-coordinate.py", "hypo_code": "class Solution(object):\n    def nearestValidPoint(self, x, y, points):\n        \n        return min([i for i in range(len(points)) if points[i][0]==x or points[i][1]==y], key=lambda i:abs(x-points[i][0])+abs(y-points[i][1])) if [i for i in range(len(points)) if points[i][0]==x or points[i][1]==y] else -1"}
{"id": "382", "path": "output2\\py\\Easy\\382-check-if-binary-string-has-at-most-one-segment-of-ones.py", "hypo_code": "class Solution(object):\n    def checkOnesSegment(self, s):\n        \n        return '01' not in s"}
{"id": "384", "path": "output2\\py\\Easy\\384-check-if-one-string-swap-can-make-strings-equal.py", "hypo_code": "class Solution(object):\n    def areAlmostEqual(self, s1, s2):\n        \n        return s1 == s2 or sum([1 for i in range(len(s1)) if s1[i] != s2[i]]) == 2"}
{"id": "385", "path": "output2\\py\\Easy\\385-find-center-of-star-graph.py", "hypo_code": "class Solution(object):\n    def findCenter(self, edges):\n              \n        if edges[0][0]==edges[1][0] or edges[0][0]==edges[1][1]:\n            return edges[0][0]\n        else:\n            return edges[0][1]"}
{"id": "387", "path": "output2\\py\\Easy\\387-second-largest-digit-in-a-string.py", "hypo_code": "class Solution(object):\n    def secondHighest(self, s):\n        \n        a = [int(x) for x in list(s) if x.isdigit()]\n        return sorted(list(set(a)))[-2] if len(set(a))>1 else -1"}
{"id": "388", "path": "output2\\py\\Easy\\388-maximum-ascending-subarray-sum.py", "hypo_code": "class Solution(object):\n    def maxAscendingSum(self, nums):\n        \n        ans = 0\n        sum = 0\n        for i in range(len(nums)):\n            if i>0 and nums[i]<=nums[i-1]:\n                sum = 0\n            sum += nums[i]\n            ans = max(ans, sum)\n        return ans"}
{"id": "389", "path": "output2\\py\\Easy\\389-number-of-different-integers-in-a-string.py", "hypo_code": "class Solution(object):\n    def numDifferentIntegers(self, word):\n        \n        return len(set(int(x) for x in re.findall('\\d+',word)))"}
{"id": "390", "path": "output2\\py\\Easy\\390-determine-color-of-a-chessboard-square.py", "hypo_code": "class Solution(object):\n    def squareIsWhite(self, coordinates):\n        \n        return ord(coordinates[0])%2 != int(coordinates[1])%2"}
{"id": "391", "path": "output2\\py\\Easy\\391-truncate-sentence.py", "hypo_code": "class Solution(object):\n    def truncateSentence(self, s, k):\n        \n        return ' '.join(s.split()[:k])"}
{"id": "392", "path": "output2\\py\\Easy\\392-sign-of-the-product-of-an-array.py", "hypo_code": "class Solution(object):\n    def arraySign(self, nums):\n        \n        return reduce(lambda x,y:x*y, nums)/abs(reduce(lambda x,y:x*y, nums)) if 0 not in nums else 0"}
{"id": "393", "path": "output2\\py\\Easy\\393-minimum-operations-to-make-the-array-increasing.py", "hypo_code": "class Solution(object):\n    def minOperations(self, nums):\n        \n        return sum([max(0,nums[i-1]-nums[i]+1) for i in range(1,len(nums))])"}
{"id": "394", "path": "output2\\py\\Easy\\394-check-if-the-sentence-is-pangram.py", "hypo_code": "class Solution(object):\n    def checkIfPangram(self, sentence):\n        \n        return len(set(sentence))==26"}
{"id": "395", "path": "output2\\py\\Easy\\395-sum-of-digits-in-base-k.py", "hypo_code": "class Solution(object):\n    def sumBase(self, n, k):\n        \n        sum = 0\n        while n > 0:\n            sum += n % k\n            n //= k\n        return sum"}
{"id": "396", "path": "output2\\py\\Easy\\396-replace-all-digits-with-characters.py", "hypo_code": "class Solution(object):\n    def replaceDigits(self, s):\n        \n        return ''.join([chr(ord(s[i-1])+int(s[i])) if i%2 else s[i] for i in range(len(s))])"}
{"id": "397", "path": "output2\\py\\Easy\\397-minimum-distance-to-the-target-element.py", "hypo_code": "class Solution(object):\n    def getMinDistance(self, nums, target, start):\n        \n        return min([abs(i-start) for i in range(len(nums)) if nums[i]==target])"}
{"id": "398", "path": "output2\\py\\Easy\\398-maximum-population-year.py", "hypo_code": "class Solution(object):\n    def maximumPopulation(self, logs):\n        \n        return max([(i,logs.count(i)) for i in range(1950,2050)], key=lambda x:x[1])[0]"}
{"id": "399", "path": "output2\\py\\Easy\\399-sorting-the-sentence.py", "hypo_code": "class Solution(object):\n    def sortSentence(self, s):\n        \n        return ' '.join([x[:-1] for x in sorted(s.split(), key=lambda x:x[-1])])"}
{"id": "400", "path": "output2\\py\\Easy\\400-sum-of-all-subset-xor-totals.py", "hypo_code": "class Solution(object):\n    def subsetXORSum(self, nums):\n        \n        return sum(reduce(lambda x,y:x^y,nums[i]) for i in range(1,len(nums)+1))"}
{"id": "401", "path": "output2\\py\\Easy\\401-longer-contiguous-segments-of-ones-than-zeros.py", "hypo_code": "class Solution(object):\n    def checkZeroOnes(self, s):\n        \n        return max(map(len,s.split('0')))>max(map(len,s.split('1')))"}
{"id": "403", "path": "output2\\py\\Easy\\403-substrings-of-size-three-with-distinct-characters.py", "hypo_code": "class Solution(object):\n    def countGoodSubstrings(self, s):\n        \n        return sum([len(set(s[i:i+3]))==3 for i in range(len(s)-2)])"}
{"id": "404", "path": "output2\\py\\Easy\\404-check-if-word-equals-summation-of-two-words.py", "hypo_code": "class Solution(object):\n    def isSumEqual(self, firstWord, secondWord, targetWord):\n        \n        def getNum(word):\n            return int(''.join([str(ord(w)-ord('a')) for w in word]))\n        return getNum(firstWord) + getNum(secondWord) == getNum(targetWord)"}
{"id": "405", "path": "output2\\py\\Easy\\405-determine-whether-matrix-can-be-obtained-by-rotation.py", "hypo_code": "class Solution(object):\n    def findRotation(self, mat, target):\n        \n        def rotate_90_degrees_clockwise(mat):\n            return [[mat[i][j] for i in range(len(mat))] for j in range(len(mat[0])-1,-1,-1)]\n\n        for i in range(4):\n            if mat == target:\n                return True\n            else:\n                mat = rotate_90_degrees_clockwise(mat)\n        return False"}
{"id": "407", "path": "output2\\py\\Easy\\407-check-if-all-the-integers-in-a-range-are-covered.py", "hypo_code": "class Solution(object):\n    def isCovered(self, ranges, left, right):\n        \n        return all([any([i<=j<=k for j in range(i[0],i[1]+1)]) for i in ranges for k in range(left,right+1)])"}
{"id": "408", "path": "output2\\py\\Easy\\408-redistribute-characters-to-make-all-strings-equal.py", "hypo_code": "class Solution(object):\n    def makeEqual(self, words):\n        \n        return all([i%len(words) == 0 for i in collections.Counter(''.join(words)).values()])"}
{"id": "409", "path": "output2\\py\\Easy\\409-largest-odd-number-in-string.py", "hypo_code": "class Solution(object):\n    def largestOddNumber(self, num):\n        \n        return num[:num.rfind(str(int(num)%2==1))+1]"}
{"id": "410", "path": "output2\\py\\Easy\\410-remove-one-element-to-make-the-array-strictly-increasing.py", "hypo_code": "class Solution(object):\n    def canBeIncreasing(self, nums):\n        \n        return any([sorted(nums[:i]+nums[i+1:])==nums[:i]+nums[i+1:] for i in range(len(nums))])"}
{"id": "411", "path": "output2\\py\\Easy\\411-maximum-product-difference-between-two-pairs.py", "hypo_code": "class Solution(object):\n    def maxProductDifference(self, nums):\n        \n        return sorted(nums)[-1]*sorted(nums)[-2]-sorted(nums)[0]*sorted(nums)[1]"}
{"id": "412", "path": "output2\\py\\Easy\\412-build-array-from-permutation.py", "hypo_code": "class Solution(object):\n    def buildArray(self, nums):\n        \n        return [nums[i] for i in nums]"}
{"id": "413", "path": "output2\\py\\Easy\\413-count-square-sum-triples.py", "hypo_code": "class Solution(object):\n    def countTriples(self, n):\n        \n        return sum([1 for i in range(1,n+1) for j in range(i,n+1) if (i**2+j**2)**0.5%1==0 and (i**2+j**2)**0.5<=n])"}
{"id": "414", "path": "output2\\py\\Easy\\414-concatenation-of-array.py", "hypo_code": "class Solution(object):\n    def getConcatenation(self, nums):\n        \n        return nums+nums"}
{"id": "415", "path": "output2\\py\\Easy\\415-maximum-number-of-words-you-can-type.py", "hypo_code": "class Solution(object):\n    def canBeTypedWords(self, text, brokenLetters):\n        \n        return sum(1 for x in text.split() if not set(x)&set(brokenLetters))"}
{"id": "416", "path": "output2\\py\\Easy\\416-check-if-all-characters-have-equal-number-of-occurrences.py", "hypo_code": "class Solution(object):\n    def areOccurrencesEqual(self, s):\n        \n        return len(set(collections.Counter(s).values())) == 1"}
{"id": "417", "path": "output2\\py\\Easy\\417-sum-of-digits-of-string-after-convert.py", "hypo_code": "class Solution(object):\n    def getLucky(self, s, k):\n        \n        nums = [str(ord(i)-ord('a')+1) for i in s]\n        nums = ''.join(nums)\n        for i in range(k):\n            nums = str(sum([int(j) for j in nums]))\n        return int(nums)"}
{"id": "418", "path": "output2\\py\\Easy\\418-three-divisors.py", "hypo_code": "class Solution(object):\n    def isThree(self, n):\n        \n        return sum([n%i==0 for i in range(1,n+1)])==3"}
{"id": "419", "path": "output2\\py\\Easy\\419-delete-characters-to-make-fancy-string.py", "hypo_code": "class Solution(object):\n    def makeFancyString(self, s):\n        \n        return ''.join([x[0] for x in itertools.groupby(s)])"}
{"id": "420", "path": "output2\\py\\Easy\\420-check-if-string-is-a-prefix-of-array.py", "hypo_code": "class Solution(object):\n    def isPrefixString(self, s, words):\n        \n        return s == ''.join(words)[:len(s)]"}
{"id": "422", "path": "output2\\py\\Easy\\422-number-of-strings-that-appear-as-substrings-in-word.py", "hypo_code": "class Solution(object):\n    def numOfStrings(self, patterns, word):\n        \n        return len([i for i in patterns if i in word])"}
{"id": "423", "path": "output2\\py\\Easy\\423-find-if-path-exists-in-graph.py", "hypo_code": "class Solution(object):\n    def validPath(self, n, edges, source, destination):\n          \n        return True if destination in reduce(lambda x,y:x+y, edges) else False"}
{"id": "424", "path": "output2\\py\\Easy\\424-minimum-time-to-type-word-using-special-typewriter.py", "hypo_code": "class Solution(object):\n    def minTimeToType(self, word):\n        \n        return sum([min(abs(ord(word[i])-ord(word[i-1])),26-abs(ord(word[i])-ord(word[i-1]))) for i in range(1,len(word))])+len(word)"}
{"id": "426", "path": "output2\\py\\Easy\\426-find-greatest-common-divisor-of-array.py", "hypo_code": "class Solution(object):\n    def findGCD(self, nums):\n         \n        return reduce(lambda x,y: x if y==0 else self.findGCD(y,x%y), nums)"}
{"id": "427", "path": "output2\\py\\Easy\\427-minimum-difference-between-highest-and-lowest-of-k-scores.py", "hypo_code": "class Solution(object):\n    def minimumDifference(self, nums, k):\n        \n        return min([nums[i+k-1]-nums[i] for i in range(len(nums)-k+1)])"}
{"id": "428", "path": "output2\\py\\Easy\\428-find-the-middle-index-in-array.py", "hypo_code": "class Solution(object):\n    def findMiddleIndex(self, nums):\n        \n        for i in range(len(nums)):\n            if sum(nums[:i])==sum(nums[i+1:]):\n                return i\n        return -1"}
{"id": "429", "path": "output2\\py\\Easy\\429-count-special-quadruplets.py", "hypo_code": "class Solution(object):\n    def countQuadruplets(self, nums):\n        \n        return sum([1 for i in range(len(nums)) for j in range(i+1, len(nums)) for k in range(j+1, len(nums)) if nums[i]+nums[j]+nums[k] in nums[k+1:]])"}
{"id": "430", "path": "output2\\py\\Easy\\430-reverse-prefix-of-word.py", "hypo_code": "class Solution(object):\n    def reversePrefix(self, word, ch):\n        \n        return word[:word.index(ch)+1][::-1] + word[word.index(ch)+1:]"}
{"id": "431", "path": "output2\\py\\Easy\\431-count-number-of-pairs-with-absolute-difference-k.py", "hypo_code": "class Solution(object):\n    def countKDifference(self, nums, k):\n        \n        return sum([1 for i in range(len(nums)) for j in range(i+1,len(nums)) if abs(nums[i]-nums[j])==k])"}
{"id": "432", "path": "output2\\py\\Easy\\432-final-value-of-variable-after-performing-operations.py", "hypo_code": "class Solution(object):\n    def finalValueAfterOperations(self, operations):\n        \n        ans = 0\n        for op in operations:\n            if op == \"++X\" or op == \"X++\":\n                ans += 1\n            else:\n                ans -= 1\n        return ans"}
{"id": "433", "path": "output2\\py\\Easy\\433-maximum-difference-between-increasing-elements.py", "hypo_code": "class Solution(object):\n    def maximumDifference(self, nums):\n        \n        return max([nums[j]-nums[i] for i in range(len(nums)) for j in range(i+1,len(nums)) if nums[j]>nums[i]] or [-1])"}
{"id": "434", "path": "output2\\py\\Easy\\434-convert-1d-array-into-2d-array.py", "hypo_code": "class Solution(object):\n    def construct2DArray(self, original, m, n):\n        \n        if m*n != len(original):\n            return []\n        result = []\n        for i in range(m):\n            result.append(original[i*n:(i+1)*n])\n        return result"}
{"id": "435", "path": "output2\\py\\Easy\\435-minimum-moves-to-convert-string.py", "hypo_code": "class Solution(object):\n    def minimumMoves(self, s):\n        \n        i = 0\n        result = 0\n        while i < len(s):\n            if s[i] == 'O':\n                i += 1\n            else:\n                i += 3\n                result += 1\n        return result"}
{"id": "436", "path": "output2\\py\\Easy\\436-two-out-of-three.py", "hypo_code": "class Solution(object):\n    def twoOutOfThree(self, nums1, nums2, nums3):\n        \n        return list(set(nums1)&set(nums2)|set(nums2)&set(nums3)|set(nums1)&set(nums3))"}
{"id": "437", "path": "output2\\py\\Easy\\437-minimum-number-of-moves-to-seat-everyone.py", "hypo_code": "class Solution(object):\n    def minMovesToSeat(self, seats, students):\n        \n        return sum([abs(seats[i]-students[i]) for i in range(len(seats))])"}
{"id": "438", "path": "output2\\py\\Easy\\438-check-if-numbers-are-ascending-in-a-sentence.py", "hypo_code": "class Solution(object):\n    def areNumbersAscending(self, s):\n        \n        nums = [int(x) for x in s.split() if x.isdigit()]\n        return nums == sorted(nums)"}
{"id": "439", "path": "output2\\py\\Easy\\439-number-of-valid-words-in-a-sentence.py", "hypo_code": "class Solution(object):\n    def countValidWords(self, sentence):\n        \n        return len([x for x in sentence.split() if x.isalpha() and x[-1] not in '.,!'])"}
{"id": "440", "path": "output2\\py\\Easy\\440-kth-distinct-string-in-an-array.py", "hypo_code": "class Solution(object):\n    def kthDistinct(self, arr, k):\n        \n        return next(islice((x for x in arr if arr.count(x)==1),k-1,k), \"\")"}
{"id": "441", "path": "output2\\py\\Easy\\441-smallest-index-with-equal-value.py", "hypo_code": "class Solution(object):\n    def smallestEqual(self, nums):\n        \n        return next((i for i in range(len(nums)) if i%10==nums[i]), -1)"}
{"id": "442", "path": "output2\\py\\Easy\\442-count-vowel-substrings-of-a-string.py", "hypo_code": "class Solution(object):\n    def countVowelSubstrings(self, word):\n        \n        return sum([word.count(x) for x in ['a','e','i','o','u']])"}
{"id": "443", "path": "output2\\py\\Easy\\443-check-whether-two-strings-are-almost-equivalent.py", "hypo_code": "class Solution(object):\n    def checkAlmostEquivalent(self, word1, word2):\n        \n        return all(abs(word1.count(x)-word2.count(x))<=3 for x in string.ascii_lowercase)"}
{"id": "444", "path": "output2\\py\\Easy\\444-time-needed-to-buy-tickets.py", "hypo_code": "class Solution(object):\n    def timeRequiredToBuy(self, tickets, k):\n        \n        return sum(sorted(tickets)[0:k+1])"}
{"id": "445", "path": "output2\\py\\Easy\\445-two-furthest-houses-with-different-colors.py", "hypo_code": "class Solution(object):\n    def maxDistance(self, colors):\n        \n        return max([abs(i-j) for i in range(len(colors)) for j in range(len(colors)) if colors[i]!=colors[j]] or [0])"}
{"id": "447", "path": "output2\\py\\Easy\\447-count-common-words-with-one-occurrence.py", "hypo_code": "class Solution(object):\n    def countWords(self, words1, words2):\n        \n        return len(set(words1)&set(words2))"}
{"id": "448", "path": "output2\\py\\Easy\\448-find-target-indices-after-sorting-array.py", "hypo_code": "class Solution(object):\n    def targetIndices(self, nums, target):\n        \n        return sorted([i for i in range(len(nums)) if nums[i]==target])"}
{"id": "449", "path": "output2\\py\\Easy\\449-finding-3-digit-even-numbers.py", "hypo_code": "class Solution(object):\n    def findEvenNumbers(self, digits):\n        \n        return sorted([int(''.join(map(str, i))) for i in itertools.permutations(digits, 3) if int(''.join(map(str, i)))%2==0])"}
{"id": "450", "path": "output2\\py\\Easy\\450-find-subsequence-of-length-k-with-the-largest-sum.py", "hypo_code": "class Solution(object):\n    def maxSubsequence(self, nums, k):\n        \n        return sorted(nums)[-k:]"}
{"id": "451", "path": "output2\\py\\Easy\\451-rings-and-rods.py", "hypo_code": "class Solution(object):\n    def countPoints(self, rings):\n        \n        result = 0\n        for i in range(10):\n            if 'R'+str(i) in rings and 'G'+str(i) in rings and 'B'+str(i) in rings:\n                result += 1\n        return result"}
{"id": "452", "path": "output2\\py\\Easy\\452-find-first-palindromic-string-in-the-array.py", "hypo_code": "class Solution(object):\n    def firstPalindrome(self, words):\n        \n        return next((x for x in words if x==x[::-1]), \"\")"}
{"id": "453", "path": "output2\\py\\Easy\\453-maximum-number-of-words-found-in-sentences.py", "hypo_code": "class Solution(object):\n    def mostWordsFound(self, sentences):\n        \n        return max([len(x.split()) for x in sentences])"}
{"id": "454", "path": "output2\\py\\Easy\\454-a-number-after-a-double-reversal.py", "hypo_code": "class Solution(object):\n    def isSameAfterReversals(self, num):\n        \n        return str(num)==str(num)[::-1][::-1]"}
{"id": "455", "path": "output2\\py\\Easy\\455-check-if-all-as-appears-before-all-bs.py", "hypo_code": "class Solution(object):\n    def checkString(self, s):\n        \n        return s.index('a')<s.rindex('b')"}
{"id": "456", "path": "output2\\py\\Easy\\456-capitalize-the-title.py", "hypo_code": "class Solution(object):\n    def capitalizeTitle(self, title):\n        \n        return \" \".join([x.capitalize() if len(x)>2 else x.lower() for x in title.split()])"}
{"id": "457", "path": "output2\\py\\Easy\\457-check-if-every-row-and-column-contains-all-numbers.py", "hypo_code": "class Solution(object):\n    def checkValid(self, matrix):\n        \n        n = len(matrix)\n        for i in range(n):\n            if len(set(matrix[i])) != n:\n                return False\n            if len(set([matrix[j][i] for j in range(n)])) != n:\n                return False\n        return True"}
{"id": "458", "path": "output2\\py\\Easy\\458-divide-a-string-into-groups-of-size-k.py", "hypo_code": "class Solution(object):\n    def divideString(self, s, k, fill):\n        \n        return [s[i:i+k].ljust(k,fill) for i in range(0,len(s),k)]"}
{"id": "459", "path": "output2\\py\\Easy\\459-minimum-cost-of-buying-candies-with-discount.py", "hypo_code": "class Solution(object):\n    def minimumCost(self, cost):\n        \n        return sum(sorted(cost)[0::3])"}
{"id": "460", "path": "output2\\py\\Easy\\460-count-elements-with-strictly-smaller-and-greater-elements.py", "hypo_code": "class Solution(object):\n    def countElements(self, nums):\n        \n        return len([1 for i in nums if i+1 in nums])"}
{"id": "461", "path": "output2\\py\\Easy\\461-keep-multiplying-found-values-by-two.py", "hypo_code": "class Solution(object):\n    def findFinalValue(self, nums, original):\n        \n        while original in nums:\n            original*=2\n        return original"}
{"id": "462", "path": "output2\\py\\Easy\\462-minimum-sum-of-four-digit-number-after-splitting-digits.py", "hypo_code": "class Solution(object):\n    def minimumSum(self, num):\n        \n        return sum(sorted(list(str(num))[:2]))+sum(sorted(list(str(num)))[2:])"}
{"id": "463", "path": "output2\\py\\Easy\\463-sort-even-and-odd-indices-independently.py", "hypo_code": "class Solution(object):\n    def sortEvenOdd(self, nums):\n        \n        return sorted(nums[::2]) + sorted(nums[1::2], reverse=True)"}
{"id": "464", "path": "output2\\py\\Easy\\464-count-operations-to-obtain-zero.py", "hypo_code": "class Solution(object):\n    def countOperations(self, num1, num2):\n        \n        result = 0\n        while num1 > 0 and num2 > 0:\n            if num1 >= num2:\n                num1 -= num2\n            else:\n                num2 -= num1\n            result += 1\n        return result"}
{"id": "465", "path": "output2\\py\\Easy\\465-count-equal-and-divisible-pairs-in-an-array.py", "hypo_code": "class Solution(object):\n    def countPairs(self, nums, k):\n        \n        return sum([1 for i in range(len(nums)) for j in range(i+1,len(nums)) if nums[i]==nums[j] and (i*j)%k==0])"}
{"id": "466", "path": "output2\\py\\Easy\\466-count-integers-with-even-digit-sum.py", "hypo_code": "class Solution(object):\n    def countEven(self, num):\n        \n        return sum([1 for i in range(1,num+1) if sum(map(int,str(i)))%2==0])"}
{"id": "467", "path": "output2\\py\\Easy\\467-counting-words-with-a-given-prefix.py", "hypo_code": "class Solution(object):\n    def prefixCount(self, words, pref):\n        \n        return sum([x.startswith(pref) for x in words])"}
{"id": "468", "path": "output2\\py\\Easy\\468-most-frequent-number-following-key-in-an-array.py", "hypo_code": "class Solution(object):\n    def mostFrequent(self, nums, key):\n        \n        return max([nums[i+1] for i in range(len(nums)-1) if nums[i]==key])"}
{"id": "469", "path": "output2\\py\\Easy\\469-cells-in-a-range-on-an-excel-sheet.py", "hypo_code": "class Solution(object):\n    def cellsInRange(self, s):\n        \n        result = []\n        for i in range(ord(s[0]),ord(s[3])+1):\n            for j in range(int(s[1]),int(s[4])+1):\n                result.append(chr(i)+str(j))\n        return result"}
{"id": "470", "path": "output2\\py\\Easy\\470-find-all-k-distant-indices-in-an-array.py", "hypo_code": "class Solution(object):\n    def findKDistantIndices(self, nums, key, k):\n        \n        return sorted([i for i in range(len(nums)) if abs(i-nums.index(key))<=k and nums[i]==key])"}
{"id": "471", "path": "output2\\py\\Easy\\471-divide-array-into-equal-pairs.py", "hypo_code": "class Solution(object):\n    def divideArray(self, nums):\n        \n        return sum(sorted(nums)[::2])"}
{"id": "472", "path": "output2\\py\\Easy\\472-count-hills-and-valleys-in-an-array.py", "hypo_code": "class Solution(object):\n    def countHillValley(self, nums):\n        \n        return sum([nums[i-1]<nums[i]>nums[i+1] or nums[i-1]>nums[i]<nums[i+1] for i in range(1,len(nums)-1)])"}
{"id": "473", "path": "output2\\py\\Easy\\473-find-the-difference-of-two-arrays.py", "hypo_code": "class Solution(object):\n    def findDifference(self, nums1, nums2):\n        \n        return [list(set(nums1)-set(nums2)),list(set(nums2)-set(nums1))]"}
{"id": "474", "path": "output2\\py\\Easy\\474-minimum-bit-flips-to-convert-number.py", "hypo_code": "class Solution(object):\n    def minBitFlips(self, start, goal):\n        \n        return bin(start^goal).count('1')"}
{"id": "475", "path": "output2\\py\\Easy\\475-minimum-number-of-operations-to-convert-time.py", "hypo_code": "class Solution(object):\n    def convertTime(self, current, correct):\n        \n        return sum([abs(int(a)-int(b)) for a,b in zip(current.split(':'), correct.split(':'))])"}
{"id": "476", "path": "output2\\py\\Easy\\476-largest-number-after-digit-swaps-by-parity.py", "hypo_code": "class Solution(object):\n    def largestInteger(self, num):\n        \n        return int(str(num)[::-1])"}
{"id": "477", "path": "output2\\py\\Easy\\477-add-two-integers.py", "hypo_code": "class Solution(object):\n    def sum(self, num1, num2):\n        \n        return sum([num1,num2])"}
{"id": "478", "path": "output2\\py\\Easy\\478-root-equals-sum-of-children.py", "hypo_code": "class Solution(object):\n    def checkTree(self, root):\n        \n        return root.val==root.left.val+root.right.val"}
{"id": "479", "path": "output2\\py\\Easy\\479-find-closest-number-to-zero.py", "hypo_code": "class Solution(object):\n    def findClosestNumber(self, nums):\n        \n        return min(nums,key=lambda x:abs(x))"}
{"id": "480", "path": "output2\\py\\Easy\\480-calculate-digit-sum-of-a-string.py", "hypo_code": "class Solution(object):\n    def digitSum(self, s, k):\n        \n        while len(s)>k:\n            s=str(sum([int(i) for i in s]))\n        return s"}
{"id": "481", "path": "output2\\py\\Easy\\481-intersection-of-multiple-arrays.py", "hypo_code": "class Solution(object):\n    def intersection(self, nums):\n        \n        return list(set.intersection(*map(set,nums)))"}
{"id": "482", "path": "output2\\py\\Easy\\482-count-prefixes-of-a-given-string.py", "hypo_code": "class Solution(object):\n    def countPrefixes(self, words, s):\n        \n        return sum([s.startswith(word) for word in words])"}
{"id": "483", "path": "output2\\py\\Easy\\483-remove-digit-from-number-to-maximize-result.py", "hypo_code": "class Solution(object):\n    def removeDigit(self, number, digit):\n        \n        return str(max([int(number.replace(digit,'',1)) for i in range(len(number))]))"}
{"id": "484", "path": "output2\\py\\Easy\\484-largest-3-same-digit-number-in-string.py", "hypo_code": "class Solution(object):\n    def largestGoodInteger(self, num):\n        \n        return str(max([int(num[i:i+3]) for i in range(len(num)-2) if len(set(num[i:i+3]))==1]+[0]))"}
{"id": "485", "path": "output2\\py\\Easy\\485-find-the-k-beauty-of-a-number.py", "hypo_code": "class Solution(object):\n    def divisorSubstrings(self, num, k):\n        \n        return sum([num%int(num[i:i+k])==0 for i in range(len(str(num))-k+1)])"}
{"id": "486", "path": "output2\\py\\Easy\\486-find-resultant-array-after-removing-anagrams.py", "hypo_code": "class Solution(object):\n    def removeAnagrams(self, words):\n        \n        return [word for word in words if len(set(word))==len(word)]"}
{"id": "487", "path": "output2\\py\\Easy\\487-percentage-of-letter-in-string.py", "hypo_code": "class Solution(object):\n    def percentageLetter(self, s, letter):\n        \n        return int(s.count(letter)/float(len(s))*100)"}
{"id": "488", "path": "output2\\py\\Easy\\488-check-if-number-has-equal-digit-count-and-digit-value.py", "hypo_code": "class Solution(object):\n    def digitCount(self, num):\n        \n        return all([num.count(str(i))==int(num[i]) for i in range(len(num))])"}
{"id": "489", "path": "output2\\py\\Easy\\489-rearrange-characters-to-make-target-string.py", "hypo_code": "class Solution(object):\n    def rearrangeCharacters(self, s, target):\n        \n        return min([s.count(char)/target.count(char) for char in target])"}
{"id": "490", "path": "output2\\py\\Easy\\490-min-max-game.py", "hypo_code": "class Solution(object):\n    def minMaxGame(self, nums):\n        \n        while len(nums)>1:\n            nums=[min(nums[i],nums[i+1]) if i%2==0 else max(nums[i],nums[i+1]) for i in range(0,len(nums),2)]\n        return nums[0]"}
{"id": "491", "path": "output2\\py\\Easy\\491-strong-password-checker-ii.py", "hypo_code": "class Solution(object):\n    def strongPasswordCheckerII(self, password):\n        \n        return all([len(password)>=8,any([i.islower() for i in password]),any([i.isupper() for i in password]),any([i.isdigit() for i in password]),any([i in \"!@"}
{"id": "492", "path": "output2\\py\\Easy\\492-calculate-amount-paid-in-taxes.py", "hypo_code": "class Solution(object):\n    def calculateTax(self, brackets, income):\n        \n        tax=0\n        for i in range(len(brackets)):\n            if income>brackets[i][0]:\n                tax+=brackets[i][0]*brackets[i][1]/100\n                income-=brackets[i][0]\n            else:\n                tax+=income*brackets[i][1]/100\n                return tax\n        return tax"}
{"id": "493", "path": "output2\\py\\Easy\\493-greatest-english-letter-in-upper-and-lower-case.py", "hypo_code": "class Solution(object):\n    def greatestLetter(self, s):\n        \n        return max(set(s).intersection(set([i.upper() for i in s])),default=\"\")"}
{"id": "494", "path": "output2\\py\\Easy\\494-count-asterisks.py", "hypo_code": "class Solution(object):\n    def countAsterisks(self, s):\n        \n        return len(s.replace('|','').replace('*',''))"}
{"id": "495", "path": "output2\\py\\Easy\\495-check-if-matrix-is-x-matrix.py", "hypo_code": "class Solution(object):\n    def checkXMatrix(self, grid):\n        \n        return all([grid[i][i]!=0 and grid[i][len(grid)-1-i]!=0 and grid[i][j]==0 for i in range(len(grid)) for j in range(len(grid)) if i!=j and i!=len(grid)-1-j])"}
{"id": "496", "path": "output2\\py\\Easy\\496-decode-the-message.py", "hypo_code": "class Solution(object):\n    def decodeMessage(self, key, message):\n        \n        return message.translate(str.maketrans(key,'abcdefghijklmnopqrstuvwxyz'))"}
{"id": "497", "path": "output2\\py\\Easy\\497-evaluate-boolean-binary-tree.py", "hypo_code": "class Solution(object):\n    def evaluateTree(self, root):\n        \n        return root.val if root.left==None else (root.val==2 and (self.evaluateTree(root.left) or self.evaluateTree(root.right))) or (root.val==3 and (self.evaluateTree(root.left) and self.evaluateTree(root.right)))"}
{"id": "498", "path": "output2\\py\\Easy\\498-minimum-amount-of-time-to-fill-cups.py", "hypo_code": "class Solution(object):\n    def fillCups(self, amount):\n        \n        return max(amount)+sum(amount)-max(amount)"}
{"id": "499", "path": "output2\\py\\Easy\\499-maximum-number-of-pairs-in-array.py", "hypo_code": "class Solution(object):\n    def numberOfPairs(self, nums):\n        \n        return [len(nums)/2,len(nums)%2]"}
{"id": "500", "path": "output2\\py\\Easy\\500-best-poker-hand.py", "hypo_code": "class Solution(object):\n    def bestHand(self, ranks, suits):\n        \n        if len(set(suits))==1:\n            return \"Flush\"\n        elif len(set(ranks))==2:\n            return \"Three of a Kind\"\n        elif len(set(ranks))==3:\n            return \"Pair\"\n        else:\n            return \"High Card\""}
{"id": "501", "path": "output2\\py\\Easy\\501-first-letter-to-appear-twice.py", "hypo_code": "class Solution(object):\n    def repeatedCharacter(self, s):\n        \n        return [i for i in s if s.count(i)>1][0]"}
{"id": "503", "path": "output2\\py\\Easy\\503-make-array-zero-by-subtracting-equal-amounts.py", "hypo_code": "class Solution(object):\n    def minimumOperations(self, nums):\n        \n        return sum([i for i in nums if i%2==1])"}
{"id": "504", "path": "output2\\py\\Easy\\504-merge-similar-items.py", "hypo_code": "class Solution(object):\n    def mergeSimilarItems(self, items1, items2):\n        \n        d={}\n        for i in items1+items2:\n            d[i[0]]=d.get(i[0],0)+i[1]\n        return sorted(d.items(),key=lambda x:x[0])"}
{"id": "505", "path": "output2\\py\\Easy\\505-number-of-arithmetic-triplets.py", "hypo_code": "class Solution(object):\n    def arithmeticTriplets(self, nums, diff):\n        \n        return sum([nums[i]+diff in nums and nums[i]+2*diff in nums for i in range(len(nums))])"}
{"id": "506", "path": "output2\\py\\Easy\\506-largest-local-values-in-a-matrix.py", "hypo_code": "class Solution(object):\n    def largestLocal(self, grid):\n        \n        return [[max([grid[i][j] for i in range(x-1,x+2) for j in range(y-1,y+2)]) for y in range(1,len(grid)-1)] for x in range(1,len(grid)-1)]"}
{"id": "507", "path": "output2\\py\\Easy\\507-minimum-recolors-to-get-k-consecutive-black-blocks.py", "hypo_code": "class Solution(object):\n    def minimumRecolors(self, blocks, k):\n        \n        return min([blocks[i:i+k].count('W') for i in range(len(blocks)-k+1)])"}
{"id": "508", "path": "output2\\py\\Easy\\508-minimum-hours-of-training-to-win-a-competition.py", "hypo_code": "class Solution(object):\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\n        \n        energy.sort()\n        experience.sort()\n        for i in range(len(energy)):\n            if initialEnergy>energy[i] and initialExperience>experience[i]:\n                initialEnergy+=1\n            else:\n                return i\n        return len(energy)"}
{"id": "509", "path": "output2\\py\\Easy\\509-longest-subsequence-with-limited-sum.py", "hypo_code": "class Solution(object):\n    def answerQueries(self, nums, queries):\n        \n        return [bisect.bisect_left(sorted(accumulate([0]+nums)),query)-1 for query in queries]"}
{"id": "510", "path": "output2\\py\\Easy\\510-find-subarrays-with-equal-sum.py", "hypo_code": "class Solution(object):\n    def findSubarrays(self, nums):\n        \n        return any([nums[i]+nums[i+1]==nums[i+2]+nums[i+3] for i in range(len(nums)-3)])"}
{"id": "511", "path": "output2\\py\\Easy\\511-check-distances-between-same-letters.py", "hypo_code": "class Solution(object):\n    def checkDistances(self, s, distance):\n        \n        d = dict()\n        for i in range(len(s)):\n            if s[i] in d:\n                if i - d[s[i]] - 1 != distance[ord(s[i])-ord('a')]:\n                    return False\n            d[s[i]] = i\n        return True"}
{"id": "512", "path": "output2\\py\\Easy\\512-most-frequent-even-element.py", "hypo_code": "class Solution(object):\n    def mostFrequentEven(self, nums):\n        \n        d = dict()\n        for i in nums:\n            if i % 2 == 0:\n                if i in d:\n                    d[i] += 1\n                else:\n                    d[i] = 1\n        if not d:\n            return -1\n        return sorted(d, key=lambda x: (-d[x], x))[0]"}
{"id": "513", "path": "output2\\py\\Easy\\513-count-days-spent-together.py", "hypo_code": "class Solution(object):\n    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):\n        \n        def convert(date):\n            return int(date[:2]) * 31 + int(date[3:])\n        return max(0, min(convert(leaveAlice), convert(leaveBob)) - max(convert(arriveAlice), convert(arriveBob)) + 1)"}
{"id": "514", "path": "output2\\py\\Easy\\514-smallest-even-multiple.py", "hypo_code": "class Solution(object):\n    def smallestEvenMultiple(self, n):\n        \n        return n if n % 2 == 0 else n * 2"}
{"id": "515", "path": "output2\\py\\Easy\\515-sort-the-people.py", "hypo_code": "class Solution(object):\n    def sortPeople(self, names, heights):\n        \n        return [x for _,x in sorted(zip(heights,names),reverse=True)]"}
{"id": "516", "path": "output2\\py\\Easy\\516-remove-letter-to-equalize-frequency.py", "hypo_code": "class Solution(object):\n    def equalFrequency(self, word):\n        \n        counts = collections.Counter(word)\n        return len(set(counts.values())) == 1 or 1 in counts.values()"}
{"id": "517", "path": "output2\\py\\Easy\\517-number-of-common-factors.py", "hypo_code": "class Solution(object):\n    def commonFactors(self, a, b):\n        \n        return sum([1 for i in range(1, min(a, b)+1) if a % i == 0 and b % i == 0])"}
{"id": "518", "path": "output2\\py\\Easy\\518-the-employee-that-worked-on-the-longest-task.py", "hypo_code": "class Solution(object):\n    def hardestWorker(self, n, logs):\n        \n        d = dict()\n        for i in range(n):\n            d[i] = 0\n        for i in logs:\n            d[i[0]] += i[1]\n        return sorted(d, key=lambda x: (-d[x], x))[0]"}
{"id": "519", "path": "output2\\py\\Easy\\519-number-of-valid-clock-times.py", "hypo_code": "class Solution(object):\n    def countTime(self, time):\n        \n        def count(c, s, e):\n            return sum(1 for i in range(s, e+1) if time[c] == '?' or time[c] == str(i))\n        return count(0, 0, 2) * count(1, 0, 9) + count(0, 2, 9) * count(1, 0, 5)"}
{"id": "520", "path": "output2\\py\\Easy\\520-largest-positive-integer-that-exists-with-its-negative.py", "hypo_code": "class Solution(object):\n    def findMaxK(self, nums):\n        \n        return max([i for i in nums if -i in nums])"}
{"id": "521", "path": "output2\\py\\Easy\\521-determine-if-two-events-have-conflict.py", "hypo_code": "class Solution(object):\n    def haveConflict(self, event1, event2):\n        \n        def convert(time):\n            return int(time[:2]) * 60 + int(time[3:])\n        return max(convert(event1[0]), convert(event2[0])) < min(convert(event1[1]), convert(event2[1]))"}
{"id": "522", "path": "output2\\py\\Easy\\522-odd-string-difference.py", "hypo_code": "class Solution(object):\n    def oddString(self, words):\n        \n        diffs = []\n        for word in words:\n            diff = []\n            for i in range(len(word)-1):\n                diff.append(ord(word[i+1])-ord(word[i]))\n            diffs.append(diff)\n        return words[diffs.index([x for x in diffs if diffs.count(x) == 1][0])]"}
{"id": "523", "path": "output2\\py\\Easy\\523-average-value-of-even-numbers-that-are-divisible-by-three.py", "hypo_code": "class Solution(object):\n    def averageValue(self, nums):\n        \n        s = sum([i for i in nums if i % 2 == 0 and i % 3 == 0])\n        c = len([i for i in nums if i % 2 == 0 and i % 3 == 0])\n        return s / c if c > 0 else 0"}
{"id": "524", "path": "output2\\py\\Easy\\524-apply-operations-to-an-array.py", "hypo_code": "class Solution(object):\n    def applyOperations(self, nums):\n        \n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                nums[i] *= 2\n                nums[i+1] = 0\n        return nums + [0] * nums.count(0)"}
{"id": "525", "path": "output2\\py\\Easy\\525-number-of-distinct-averages.py", "hypo_code": "class Solution(object):\n    def distinctAverages(self, nums):\n        \n        return len(set([(nums[i]+nums[j])/2 for i in range(len(nums)) for j in range(len(nums)) if i != j]))"}
{"id": "526", "path": "output2\\py\\Easy\\526-convert-the-temperature.py", "hypo_code": "class Solution(object):\n    def convertTemperature(self, celsius):\n        \n        return [celsius + 273.15, celsius * 1.8 + 32]"}
{"id": "527", "path": "output2\\py\\Easy\\527-number-of-unequal-triplets-in-array.py", "hypo_code": "class Solution(object):\n    def unequalTriplets(self, nums):\n        \n        return len(set([(nums[i], nums[j], nums[k]) for i in range(len(nums)) for j in range(len(nums)) for k in range(len(nums)) if i != j and i != k and j != k]))"}
{"id": "528", "path": "output2\\py\\Easy\\528-minimum-cuts-to-divide-a-circle.py", "hypo_code": "class Solution(object):\n    def numberOfCuts(self, n):\n        \n        return n - 1"}
{"id": "529", "path": "output2\\py\\Easy\\529-find-the-pivot-integer.py", "hypo_code": "class Solution(object):\n    def pivotInteger(self, n):\n        \n        for i in range(1, n):\n            if sum(range(1, i+1)) == sum(range(i, n+1)):\n                return i\n        return -1"}
{"id": "530", "path": "output2\\py\\Easy\\530-circular-sentence.py", "hypo_code": "class Solution(object):\n    def isCircularSentence(self, sentence):\n              \n        words = sentence.split()\n        if len(words) == 1:\n            return True\n        for i in range(len(words)-1):\n            if words[i][-1] != words[i+1][0]:\n                return False\n        return words[-1][-1] == words[0][0]"}
{"id": "531", "path": "output2\\py\\Easy\\531-maximum-value-of-a-string-in-an-array.py", "hypo_code": "class Solution(object):\n    def maximumValue(self, strs):\n               \n        max_value=0\n        for i in range(len(strs)):\n            if strs[i].isdigit():\n                max_value=max(max_value,int(strs[i]))\n            else:\n                max_value=max(max_value,len(strs[i]))\n        return max_value"}
{"id": "532", "path": "output2\\py\\Easy\\532-delete-greatest-value-in-each-row.py", "hypo_code": "class Solution(object):\n    def deleteGreatestValue(self, grid):\n               \n        result=0\n        while len(grid[0])>0:\n            max_value=0\n            for i in range(len(grid)):\n                max_value=max(max_value,grid[i][0])\n            result+=max_value\n            for i in range(len(grid)):\n                grid[i].pop(0)\n        return result"}
{"id": "533", "path": "output2\\py\\Easy\\533-count-pairs-of-similar-strings.py", "hypo_code": "class Solution(object):\n    def similarPairs(self, words):\n              \n        result=0\n        for i in range(len(words)):\n            for j in range(i+1,len(words)):\n                if self.isSimilar(words[i],words[j]):\n                    result+=1\n        return result"}
{"id": "534", "path": "output2\\py\\Easy\\534-maximum-enemy-forts-that-can-be-captured.py", "hypo_code": "class Solution(object):\n    def captureForts(self, forts):\n             \n        n=len(forts)\n        result=0\n        for i in range(n):\n            if forts[i]==1:\n                j=i+1\n                count=0\n                while j<n:\n                    if forts[j]==0:\n                        count+=1\n                    elif forts[j]==1:\n                        break\n                    j+=1\n                j=i-1\n                while j>=0:\n                    if forts[j]==0:\n                        count+=1\n                    elif forts[j]==1:\n                        break\n                    j-=1\n                result=max(result,count)\n        return result"}
{"id": "535", "path": "output2\\py\\Easy\\535-shortest-distance-to-target-string-in-a-circular-array.py", "hypo_code": "class Solution(object):\n    def closetTarget(self, words, target, startIndex):\n              \n        n=len(words)\n        result=n\n        for i in range(n):\n            if words[i]==target:\n                result=min(result,min(abs(i-startIndex),n-abs(i-startIndex)))\n        if result==n:\n            return -1\n        return result"}
{"id": "536", "path": "output2\\py\\Easy\\536-count-the-digits-that-divide-a-number.py", "hypo_code": "class Solution(object):\n    def countDigits(self, num):\n               \n        count=0\n        for i in str(num):\n            if int(i)!=0 and num%int(i)==0:\n                count+=1\n        return count"}
{"id": "537", "path": "output2\\py\\Easy\\537-categorize-box-according-to-criteria.py", "hypo_code": "class Solution(object):\n    def categorizeBox(self, length, width, height, mass):\n               \n        if length>=10000 or width>=10000 or height>=10000 or length*width*height>=1000000000:\n            if mass>=100:\n                return \"Both\"\n            else:\n                return \"Bulky\"\n        else:\n            if mass>=100:\n                return \"Heavy\"\n            else:\n                return \"Neither\""}
{"id": "538", "path": "output2\\py\\Easy\\538-maximum-count-of-positive-integer-and-negative-integer.py", "hypo_code": "class Solution(object):\n    def maximumCount(self, nums):\n           \n        pos=0\n        neg=0\n        for i in nums:\n            if i>0:\n                pos+=1\n            elif i<0:\n                neg+=1\n        return max(pos,neg)"}
{"id": "539", "path": "output2\\py\\Easy\\539-difference-between-element-sum-and-digit-sum-of-an-array.py", "hypo_code": "class Solution(object):\n    def differenceOfSum(self, nums):\n            \n        element_sum=0\n        digit_sum=0\n        for i in nums:\n            element_sum+=i\n            while i>0:\n                digit_sum+=i%10\n                i=i//10\n        return abs(element_sum-digit_sum)"}
{"id": "540", "path": "output2\\py\\Easy\\540-minimum-common-value.py", "hypo_code": "class Solution(object):\n    def getCommon(self, nums1, nums2):\n         \n        if len(nums1)==0 or len(nums2)==0:\n            return -1\n        i=0\n        j=0\n        while i<len(nums1) and j<len(nums2):\n            if nums1[i]==nums2[j]:\n                return nums1[i]\n            elif nums1[i]<nums2[j]:\n                i+=1\n            else:\n                j+=1\n        return -1"}
{"id": "541", "path": "output2\\py\\Easy\\541-alternating-digit-sum.py", "hypo_code": "class Solution(object):\n    def alternateDigitSum(self, n):\n        \n        res=0\n        for i in range(len(str(n))):\n            if i%2==0:\n                res+=int(str(n)[i])\n            else:\n                res-=int(str(n)[i])\n        return res"}
{"id": "542", "path": "output2\\py\\Easy\\542-count-distinct-numbers-on-board.py", "hypo_code": "class Solution(object):\n    def distinctIntegers(self, n):\n        \n        return (n - 1) / 2"}
{"id": "543", "path": "output2\\py\\Easy\\543-separate-the-digits-in-an-array.py", "hypo_code": "class Solution(object):\n    def separateDigits(self, nums):\n        \n        return [int(j) for i in nums for j in str(i)]"}
{"id": "544", "path": "output2\\py\\Easy\\544-take-gifts-from-the-richest-pile.py", "hypo_code": "class Solution(object):\n    def pickGifts(self, gifts, k):\n        \n        for i in range(k):\n            gifts[gifts.index(max(gifts))] = int(math.sqrt(max(gifts)))\n        return sum(gifts)"}
{"id": "545", "path": "output2\\py\\Easy\\545-find-the-array-concatenation-value.py", "hypo_code": "class Solution(object):\n    def findTheArrayConcVal(self, nums):\n        \n        return sum([int(str(i)+str(j)) for i in nums for j in nums]) % (10**9+7)"}
{"id": "546", "path": "output2\\py\\Easy\\546-maximum-difference-by-remapping-a-digit.py", "hypo_code": "class Solution(object):\n    def minMaxDifference(self, num):\n        \n        s = str(num)\n        return max(int(s.replace(i, str(9)))-int(s.replace(i, str(0))) for i in s)"}
{"id": "547", "path": "output2\\py\\Easy\\547-merge-two-2d-arrays-by-summing-values.py", "hypo_code": "class Solution(object):\n    def mergeArrays(self, nums1, nums2):\n        \n        d = dict()\n        for i in nums1:\n            d[i[0]] = d.get(i[0], 0) + i[1]\n        for i in nums2:\n            d[i[0]] = d.get(i[0], 0) + i[1]\n        return sorted([[i, d[i]] for i in d], key=lambda x: x[0])"}
{"id": "548", "path": "output2\\py\\Easy\\548-left-and-right-sum-differences.py", "hypo_code": "class Solution(object):\n    def leftRightDifference(self, nums):\n        \n        return [abs(sum(nums[:i]) - sum(nums[i:])) for i in range(len(nums))]"}
{"id": "549", "path": "output2\\py\\Easy\\549-split-with-minimum-sum.py", "hypo_code": "class Solution(object):\n    def splitNum(self, num):\n        \n        num = str(num)\n        a = sorted(num)\n        b = sorted(num, reverse=True)\n        return int(\"\".join(a)) + int(\"\".join(b))"}
{"id": "550", "path": "output2\\py\\Easy\\550-pass-the-pillow.py", "hypo_code": "class Solution(object):\n    def passThePillow(self, n, time):\n        \n        return ((time-1) % n) + 1"}
{"id": "551", "path": "output2\\py\\Easy\\551-count-the-number-of-vowel-strings-in-range.py", "hypo_code": "class Solution(object):\n    def vowelStrings(self, words, left, right):\n        \n        return sum([1 for word in words[left:right+1] if word[0] in 'aeiou' and word[-1] in 'aeiou'])"}
{"id": "552", "path": "output2\\py\\Easy\\552-distribute-money-to-maximum-children.py", "hypo_code": "class Solution(object):\n    def distMoney(self, money, children):\n        \n        return -1 if money % 2 == 1 or money < children or money > children * 4 else min(children, money // 2)"}
{"id": "553", "path": "output2\\py\\Easy\\553-number-of-even-and-odd-bits.py", "hypo_code": "class Solution(object):\n    def evenOddBit(self, n):\n        \n        return [len([i for i in bin(n)[2:] if i == '1' and int(i) % 2 == 0]), len([i for i in bin(n)[2:] if i == '1' and int(i) % 2 == 1])]"}
{"id": "554", "path": "output2\\py\\Easy\\554-k-items-with-the-maximum-sum.py", "hypo_code": "class Solution(object):\n    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):\n        \n        return max([sum(i) for i in combinations([1]*numOnes+[0]*numZeros+[-1]*numNegOnes, k)])"}
{"id": "555", "path": "output2\\py\\Easy\\555-form-smallest-number-from-two-digit-arrays.py", "hypo_code": "class Solution(object):\n    def minNumber(self, nums1, nums2):\n        \n        return min([i for i in nums1 if i in nums2])"}
{"id": "556", "path": "output2\\py\\Easy\\556-find-the-longest-balanced-substring-of-a-binary-string.py", "hypo_code": "class Solution(object):\n    def findTheLongestBalancedSubstring(self, s):\n        \n        return max([len(s[i:j]) for i in range(len(s)) for j in range(i,len(s)) if s[i:j].count('0') == s[i:j].count('1')]+[0])"}
{"id": "557", "path": "output2\\py\\Easy\\557-prime-in-diagonal.py", "hypo_code": "class Solution(object):\n    def diagonalPrime(self, nums):\n        \n        def isPrime(n):\n            if n <= 1:\n                return False\n            for i in range(2, n):\n                if n % i == 0:\n                    return False\n            return True\n        return max([nums[i][j] for i in range(len(nums)) for j in range(len(nums)) if i == j or i == len(nums)-j-1 if isPrime(nums[i][j])])"}
{"id": "565", "path": "output2\\py\\Easy\\565-find-the-width-of-columns-of-a-grid.py", "hypo_code": "class Solution(object):\n    def findColumnWidth(self, grid):\n        \n        return [max([len(str(grid[i][j])) for i in range(len(grid))]) for j in range(len(grid[0]))]"}
{"id": "566", "path": "output2\\py\\Easy\\566-row-with-maximum-ones.py", "hypo_code": "class Solution(object):\n    def rowAndMaximumOnes(self, mat):\n        \n        return [max([sum(row) for row in mat]), mat.index(max(mat, key=lambda x: sum(x)))]"}
{"id": "567", "path": "output2\\py\\Easy\\567-find-the-maximum-divisibility-score.py", "hypo_code": "class Solution(object):\n    def maxDivScore(self, nums, divisors):\n        \n        return min([i for i in divisors if len([j for j in nums if j % i == 0]) == max([len([j for j in nums if j % k == 0]) for k in divisors])])"}
{"id": "569", "path": "output2\\py\\Easy\\569-calculate-delayed-arrival-time.py", "hypo_code": "class Solution(object):\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\n        \n        return (arrivalTime + delayedTime) % 24"}
{"id": "570", "path": "output2\\py\\Easy\\570-sum-multiples.py", "hypo_code": "class Solution(object):\n    def sumOfMultiples(self, n):\n        \n        return sum([i for i in range(1, n+1) if i % 3 == 0 or i % 5 == 0 or i % 7 == 0])"}
{"id": "571", "path": "output2\\py\\Easy\\571-maximum-sum-with-exactly-k-elements.py", "hypo_code": "class Solution(object):\n    def maximizeSum(self, nums, k):\n        \n        return sum(nums) + k * min(nums)"}
{"id": "572", "path": "output2\\py\\Easy\\572-determine-the-winner-of-a-bowling-game.py", "hypo_code": "class Solution(object):\n    def isWinner(self, player1, player2):\n        \n        def score(player):\n            s = 0\n            for i in range(len(player)):\n                if player[i] == 10 and i > 1:\n                    s += 2 * player[i]\n                else:\n                    s += player[i]\n            return s\n        s1 = score(player1)\n        s2 = score(player2)\n        return 1 if s1 > s2 else 2 if s2 > s1 else 0"}
{"id": "576", "path": "output2\\py\\Easy\\576-find-the-distinct-difference-array.py", "hypo_code": "class Solution(object):\n    def distinctDifferenceArray(self, nums):\n        \n        return [len(set(nums[i+1:])) - len(set(nums[:i])) for i in range(len(nums))]"}
{"id": "578", "path": "output2\\py\\Easy\\578-number-of-senior-citizens.py", "hypo_code": "class Solution(object):\n    def countSeniors(self, details):\n        \n        return sum(1 for detail in details if int(detail[11:13]) > 60)"}
{"id": "579", "path": "output2\\py\\Easy\\579-find-the-losers-of-the-circular-game.py", "hypo_code": "class Solution(object):\n    def circularGameLosers(self, n, k):\n        \n        return [i for i in range(1, n+1) if (i * k) % n == 0]"}
{"id": "581", "path": "output2\\py\\Easy\\581-minimum-string-length-after-removing-substrings.py", "hypo_code": "class Solution(object):\n    def minLength(self, s):\n        \n        while True:\n            prev = len(s)\n            s = s.replace(\"AB\", \"\").replace(\"CD\", \"\")\n            if len(s) == prev:\n                return len(s)"}
{"id": "582", "path": "output2\\py\\Easy\\582-lexicographically-smallest-palindrome.py", "hypo_code": "class Solution(object):\n    def makeSmallestPalindrome(self, s):\n        \n        if s == s[::-1]:\n            return s\n        for i in range(len(s)):\n            if s[i] != s[-i-1]:\n                return s[:i] + min(s[i], s[-i-1]) + s[i+1:]"}
{"id": "585", "path": "output2\\py\\Easy\\585-buy-two-chocolates.py", "hypo_code": "class Solution(object):\n    def buyChoco(self, prices, money):\n        \n        return min([money-i for i in prices if money-i>=0])"}
{"id": "586", "path": "output2\\py\\Easy\\586-remove-trailing-zeros-from-a-string.py", "hypo_code": "class Solution(object):\n    def removeTrailingZeros(self, num):\n        \n        return str(int(num))"}
{"id": "588", "path": "output2\\py\\Easy\\588-minimize-string-length.py", "hypo_code": "class Solution(object):\n    def minimizedStringLength(self, s):\n         \n        return len(s) - len(re.sub(r'([a-z])(.*)(\\1)', r'\\2', s))"}
{"id": "589", "path": "output2\\py\\Easy\\589-semi-ordered-permutation.py", "hypo_code": "class Solution(object):\n    def semiOrderedPermutation(self, nums):\n            \n        if nums[0] != 1 or nums[-1] != len(nums):\n            return -1\n        return len([i for i in range(len(nums)-1) if nums[i] > nums[i+1]])"}
{"id": "595", "path": "output2\\py\\Easy\\595-check-if-the-number-is-fascinating.py", "hypo_code": "class Solution(object):\n    def isFascinating(self, n):\n        \n        return sorted(str(n) + str(n * 2) + str(n * 3)) == list('123456789')"}
{"id": "596", "path": "output2\\py\\Easy\\596-neither-minimum-nor-maximum.py", "hypo_code": "class Solution(object):\n    def findNonMinOrMax(self, nums):\n        \n        return -1 if len(nums) < 3 else sorted(nums)[1]"}
{"id": "597", "path": "output2\\py\\Easy\\597-total-distance-traveled.py", "hypo_code": "class Solution(object):\n    def distanceTraveled(self, mainTank, additionalTank):\n        \n        return 10 * (mainTank + additionalTank)"}
{"id": "598", "path": "output2\\py\\Easy\\598-find-maximum-number-of-string-pairs.py", "hypo_code": "class Solution(object):\n    def maximumNumberOfStringPairs(self, words):\n        \n        counts = collections.Counter(words)\n        return sum([counts[word]/2 for word in counts])"}
{"id": "599", "path": "output2\\py\\Easy\\599-number-of-beautiful-pairs.py", "hypo_code": "class Solution(object):\n    def countBeautifulPairs(self, nums):\n        \n        return len([i for i in range(len(nums)) for j in range(i+1, len(nums)) if math.gcd(nums[i], nums[j]) == 1])"}
{"id": "600", "path": "output2\\py\\Easy\\600-longest-even-odd-subarray-with-threshold.py", "hypo_code": "class Solution(object):\n    def longestAlternatingSubarray(self, nums, threshold):\n        \n        return max([sum(nums[i:i+2]) for i in range(len(nums)-1) if sum(nums[i:i+2]) <= threshold] or [0])"}
{"id": "601", "path": "output2\\py\\Easy\\601-longest-alternating-subarray.py", "hypo_code": "class Solution(object):\n    def alternatingSubarray(self, nums):\n        \n        return max([len(nums[i:i+2]) for i in range(len(nums)-1) if nums[i+1] - nums[i] == 1] or [-1])"}
{"id": "602", "path": "output2\\py\\Easy\\602-find-the-maximum-achievable-number.py", "hypo_code": "class Solution(object):\n    def theMaximumAchievableX(self, num, t):\n        \n        return num + min(num, t)"}
{"id": "603", "path": "output2\\py\\Easy\\603-sum-of-squares-of-special-elements.py", "hypo_code": "class Solution(object):\n    def sumOfSquares(self, nums):\n        \n        return sum([i*i for i in nums if len(nums) % i == 0])"}
{"id": "604", "path": "output2\\py\\Easy\\604-check-if-array-is-good.py", "hypo_code": "class Solution(object):\n    def isGood(self, nums):\n        \n        return len(set(nums)) == max(nums)"}
{"id": "605", "path": "output2\\py\\Easy\\605-split-strings-by-separator.py", "hypo_code": "class Solution(object):\n    def splitWordsBySeparator(self, words, separator):\n        \n        return [word for word in ''.join(words).split(separator) if word != '']"}
{"id": "606", "path": "output2\\py\\Easy\\606-number-of-employees-who-met-the-target.py", "hypo_code": "class Solution(object):\n    def numberOfEmployeesWhoMetTarget(self, hours, target):\n        \n        return len([i for i in hours if i >= target])"}
{"id": "607", "path": "output2\\py\\Easy\\607-account-balance-after-rounded-purchase.py", "hypo_code": "class Solution(object):\n    def accountBalanceAfterPurchase(self, purchaseAmount):\n        \n        return 100 - (purchaseAmount + 9) // 10 * 10"}
{"id": "608", "path": "output2\\py\\Easy\\608-faulty-keyboard.py", "hypo_code": "class Solution(object):\n    def finalString(self, s):\n        \n        res = []\n        for c in s:\n            if c == 'i':\n                res.reverse()\n            else:\n                res.append(c)\n        return ''.join(res)"}
{"id": "609", "path": "output2\\py\\Easy\\609-max-pair-sum-in-an-array.py", "hypo_code": "class Solution(object):\n    def maxSum(self, nums):\n        \n        return max([nums[i]+nums[j] for i in range(len(nums)) for j in range(len(nums)) if str(nums[i])[0] == str(nums[j])[0]])"}
{"id": "610", "path": "output2\\py\\Medium\\610-add-two-numbers.py", "hypo_code": "class Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \n        carry = 0\n        head = None\n        tail = None\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            node = ListNode(carry % 10)\n            carry //= 10\n            if not head:\n                head = node\n            else:\n                tail.next = node\n            tail = node\n        return head"}
{"id": "611", "path": "output2\\py\\Medium\\611-longest-substring-without-repeating-characters.py", "hypo_code": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n               \n        res = 0\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                if len(set(s[i:j])) == j-i:\n                    res = max(res,j-i)\n        return res"}
{"id": "612", "path": "output2\\py\\Medium\\612-longest-palindromic-substring.py", "hypo_code": "class Solution(object):\n    def longestPalindrome(self, s):\n         \n        res = \"\"\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                if len(set(s[i:j])) == j-i:\n                    res = max(res,s[i:j],key=len)\n        return res"}
{"id": "613", "path": "output2\\py\\Medium\\613-zigzag-conversion.py", "hypo_code": "class Solution(object):\n    def convert(self, s, numRows):\n               \n        if numRows == 1:\n            return s\n        res = [''] * numRows\n        row = 0\n        step = 1\n        for i in s:\n            res[row] += i\n            if row == 0:\n                step = 1\n            elif row == numRows - 1:\n                step = -1\n            row += step\n        return ''.join(res)"}
{"id": "614", "path": "output2\\py\\Medium\\614-reverse-integer.py", "hypo_code": "class Solution(object):\n    def reverse(self, x):\n             \n        if x>=0:\n            res = int(str(x)[::-1])\n        else:\n            res = -int(str(-x)[::-1])\n        return res if res.bit_length() < 32 else 0"}
{"id": "615", "path": "output2\\py\\Medium\\615-string-to-integer-atoi.py", "hypo_code": "class Solution(object):\n    def myAtoi(self, s):\n              \n        res = 0\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                if len(set(s[i:j])) == j-i:\n                    res = max(res,j-i)\n        return res"}
{"id": "616", "path": "output2\\py\\Medium\\616-container-with-most-water.py", "hypo_code": "class Solution(object):\n    def maxArea(self, height):\n        \n            \n        res = 0\n        i,j = 0,len(height)-1\n        while i<j:\n            res = max(res,(j-i)*min(height[i],height[j]))\n            if height[i]<height[j]:\n                i+=1\n            else:\n                j-=1\n        return res"}
{"id": "617", "path": "output2\\py\\Medium\\617-integer-to-roman.py", "hypo_code": "class Solution(object):\n    def intToRoman(self, num):\n               \n        roman = {1:'I', 4:'IV', 5:'V', 9:'IX', 10:'X', 40:'XL', 50:'L', 90:'XC', 100:'C', 400:'CD', 500:'D', 900:'CM', 1000:'M'}\n        res = ''\n        for i in sorted(roman.keys(), reverse=True):\n            while num >= i:\n                res += roman[i]\n                num -= i\n        return res"}
{"id": "618", "path": "output2\\py\\Medium\\618-3sum.py", "hypo_code": "class Solution(object):\n    def threeSum(self, nums):\n               \n        res = []\n        nums.sort()\n        for i in range(len(nums)):\n            if i>0 and nums[i] == nums[i-1]:\n                continue\n            l,r = i+1,len(nums)-1\n            while l<r:\n                if nums[i]+nums[l]+nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l+=1\n                    r-=1\n                    while l<r and nums[l] == nums[l-1]:\n                        l+=1\n                    while l<r and nums[r] == nums[r+1]:\n                        r-=1\n                elif nums[i]+nums[l]+nums[r] < 0:\n                    l+=1\n                else:\n                    r-=1\n        return res"}
{"id": "619", "path": "output2\\py\\Medium\\619-3sum-closest.py", "hypo_code": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \n        nums.sort()\n        res = nums[0]+nums[1]+nums[2]\n        for i in range(len(nums)-2):\n            l,r = i+1,len(nums)-1\n            while l<r:\n                s = nums[i]+nums[l]+nums[r]\n                if abs(s-target)<abs(res-target):\n                    res = s\n                if s == target:\n                    return res\n                elif s<target:\n                    l+=1\n                else:\n                    r-=1\n        return res"}
{"id": "620", "path": "output2\\py\\Medium\\620-letter-combinations-of-a-phone-number.py", "hypo_code": "class Solution(object):\n    def letterCombinations(self, digits):\n        \n        if not digits:\n            return []\n        phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n                 '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        def backtrack(combination, next_digits):\n            \n            if len(next_digits) == 0:\n                \n                output.append(combination)\n            \n            else:\n                \n                \n                for letter in phone[next_digits[0]]:\n                    \n                    \n                    backtrack(combination + letter, next_digits[1:])\n        output = []\n        backtrack(\"\", digits)\n        return output"}
{"id": "621", "path": "output2\\py\\Medium\\621-4sum.py", "hypo_code": "class Solution(object):\n    def fourSum(self, nums, target):\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                left, right = j+1, len(nums)-1\n                while left < right:\n                    s = nums[i] + nums[j] + nums[left] + nums[right]\n                    if s < target:\n                        left += 1\n                    elif s > target:\n                        right -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        left += 1\n                        right -= 1\n                        while left < right and nums[left] == nums[left-1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right+1]:\n                            right -= 1\n        return res"}
{"id": "622", "path": "output2\\py\\Medium\\622-remove-nth-node-from-end-of-list.py", "hypo_code": "class Solution(object):\n    def removeNthFromEnd(self, head, n):\n           \n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        \n        for i in range(1, n + 2):\n            first = first.next\n        \n        while first:\n            first = first.next\n            second = second.next\n        second.next = second.next.next\n        return dummy.next"}
{"id": "623", "path": "output2\\py\\Medium\\623-generate-parentheses.py", "hypo_code": "class Solution(object):\n    def generateParenthesis(self, n):\n          \n        res = []\n        self.dfs(n, n, \"\", res)\n        return res"}
{"id": "624", "path": "output2\\py\\Medium\\624-swap-nodes-in-pairs.py", "hypo_code": "class Solution(object):\n    def swapPairs(self, head):\n        \n        if head is None or head.next is None:\n            return head\n        next = head.next\n        head.next = self.swapPairs(next.next)\n        next.next = head\n        return next"}
{"id": "625", "path": "output2\\py\\Medium\\625-divide-two-integers.py", "hypo_code": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \n        sign = 1\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0):\n            sign = -1\n\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n\n        \n        if divisor == 0:\n            return 2**31-1\n        if dividend == 0:\n            return 0\n        if dividend < divisor:\n            return 0\n\n        \n        left, right = 0, dividend\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * divisor <= dividend < (mid + 1) * divisor:\n                return min(mid * sign, 2**31-1)\n            elif mid * divisor < dividend:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return 0"}
{"id": "626", "path": "output2\\py\\Medium\\626-next-permutation.py", "hypo_code": "class Solution(object):\n    def nextPermutation(self, nums):\n        \n        n = len(nums)\n        i = n - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        if i >= 0:\n            j = n - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i+1:] = nums[i+1:][::-1]"}
{"id": "627", "path": "output2\\py\\Medium\\627-search-in-rotated-sorted-array.py", "hypo_code": "class Solution(object):\n    def search(self, nums, target):\n               \n        if not nums:\n            return -1\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1"}
{"id": "628", "path": "output2\\py\\Medium\\628-find-first-and-last-position-of-element-in-sorted-array.py", "hypo_code": "class Solution(object):\n    def searchRange(self, nums, target):\n        \n        if not nums:\n            return [-1, -1]\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        if nums[left] != target:\n            return [-1, -1]\n        start = left\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2 + 1\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        return [start, right]"}
{"id": "629", "path": "output2\\py\\Medium\\629-valid-sudoku.py", "hypo_code": "class Solution(object):\n    def isValidSudoku(self, board):\n        \n        \n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        for i in range(9):\n            col = [board[j][i] for j in range(9)]\n            if not self.isValid(col):\n                return False\n        \n        for i in range(3):\n            for j in range(3):\n                box = [board[m][n] for m in range(3*i,3*i+3) for n in range(3*j,3*j+3)]\n                if not self.isValid(box):\n                    return False\n        return True"}
{"id": "630", "path": "output2\\py\\Medium\\630-count-and-say.py", "hypo_code": "class Solution(object):\n    def countAndSay(self, n):\n          \n        if n==1:\n            return \"1\"\n        res = \"1\"\n        for i in range(n-1):\n            res = self.helper(res)\n        return res"}
{"id": "631", "path": "output2\\py\\Medium\\631-combination-sum.py", "hypo_code": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \n        res = []\n        candidates.sort()\n        self.dfs(candidates, target, 0, [], res)\n        return res"}
{"id": "632", "path": "output2\\py\\Medium\\632-combination-sum-ii.py", "hypo_code": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \n        res = []\n        candidates.sort()\n        self.dfs(candidates, target, 0, [], res)\n        return res"}
{"id": "633", "path": "output2\\py\\Medium\\633-multiply-strings.py", "hypo_code": "class Solution(object):\n    def multiply(self, num1, num2):\n               \n        if num1==\"0\" or num2==\"0\":\n            return \"0\"\n        if num1==\"1\":\n            return num2\n        if num2==\"1\":\n            return num1\n        if len(num1)<len(num2):\n            num1,num2=num2,num1\n        num1=num1[::-1]\n        num2=num2[::-1]\n        res=\"0\"\n        for i in range(len(num2)):\n            res=self.add(res,self.multiplyOne(num1,num2[i],i))\n        return res"}
{"id": "634", "path": "output2\\py\\Medium\\634-jump-game-ii.py", "hypo_code": "class Solution(object):\n    def jump(self, nums):\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        if nums[0] >= n-1:\n            return 1\n        dp = [0] * n\n        for i in range(n):\n            for j in range(1, nums[i]+1):\n                if i+j >= n-1:\n                    return dp[i]+1\n                if dp[i+j] == 0:\n                    dp[i+j] = dp[i]+1\n        return dp[n-1]"}
{"id": "635", "path": "output2\\py\\Medium\\635-permutations.py", "hypo_code": "class Solution(object):\n    def permute(self, nums):\n         \n        res = []\n        self.dfs(nums, [], res)\n        return res"}
{"id": "636", "path": "output2\\py\\Medium\\636-permutations-ii.py", "hypo_code": "class Solution(object):\n    def permuteUnique(self, nums):\n         \n        res = []\n        nums.sort()\n        self.dfs(nums, [], res)\n        return res"}
{"id": "637", "path": "output2\\py\\Medium\\637-rotate-image.py", "hypo_code": "class Solution(object):\n    def rotate(self, matrix):\n         \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            matrix[i].reverse()"}
{"id": "638", "path": "output2\\py\\Medium\\638-group-anagrams.py", "hypo_code": "class Solution(object):\n    def groupAnagrams(self, strs):\n               \n        d = {}\n        for s in strs:\n            key = tuple(sorted(s))\n            d[key] = d.get(key, []) + [s]\n        return d.values()"}
{"id": "639", "path": "output2\\py\\Medium\\639-powx-n.py", "hypo_code": "class Solution(object):\n    def myPow(self, x, n):\n        \n        if n==0:\n            return 1\n        if n<0:\n            return 1/self.myPow(x,-n)\n        if n%2==0:\n            return self.myPow(x*x,n/2)\n        else:\n            return x*self.myPow(x*x,n/2)"}
{"id": "640", "path": "output2\\py\\Medium\\640-maximum-subarray.py", "hypo_code": "class Solution(object):\n    def maxSubArray(self, nums):\n         \n        max_sum = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i - 1] > 0:\n                nums[i] += nums[i - 1]\n            max_sum = max(max_sum, nums[i])\n        return max_sum"}
{"id": "641", "path": "output2\\py\\Medium\\641-spiral-matrix.py", "hypo_code": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \n        if not matrix:\n            return []\n        m,n = len(matrix),len(matrix[0])\n        res = []\n        left,right,top,bottom = 0,n-1,0,m-1\n        while left<=right and top<=bottom:\n            for i in range(left,right+1):\n                res.append(matrix[top][i])\n            for i in range(top+1,bottom+1):\n                res.append(matrix[i][right])\n            if left<right and top<bottom:\n                for i in range(right-1,left,-1):\n                    res.append(matrix[bottom][i])\n                for i in range(bottom,top,-1):\n                    res.append(matrix[i][left])\n            left,right,top,bottom = left+1,right-1,top+1,bottom-1\n        return res"}
{"id": "642", "path": "output2\\py\\Medium\\642-jump-game.py", "hypo_code": "class Solution(object):\n    def canJump(self, nums):\n         \n        n = len(nums)\n        if n == 1:\n            return True\n        if nums[0] >= n-1:\n            return True\n        dp = [0] * n\n        for i in range(n):\n            for j in range(1, nums[i]+1):\n                if i+j >= n-1:\n                    return True\n                if dp[i+j] == 0:\n                    dp[i+j] = dp[i]+1\n        return False"}
{"id": "643", "path": "output2\\py\\Medium\\643-merge-intervals.py", "hypo_code": "class Solution(object):\n    def merge(self, intervals):\n        \n        if not intervals:\n            return []\n        intervals.sort(key=lambda x: x[0])\n        res = []\n        for interval in intervals:\n            if not res or res[-1][1] < interval[0]:\n                res.append(interval)\n            else:\n                res[-1][1] = max(res[-1][1], interval[1])\n        return res"}
{"id": "644", "path": "output2\\py\\Medium\\644-insert-interval.py", "hypo_code": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \n        if not intervals:\n            return [newInterval]\n        if not newInterval:\n            return intervals\n        res = []\n        i = 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            res.append(intervals[i])\n            i += 1\n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        res.append(newInterval)\n        while i < len(intervals):\n            res.append(intervals[i])\n            i += 1\n        return res"}
{"id": "645", "path": "output2\\py\\Medium\\645-spiral-matrix-ii.py", "hypo_code": "class Solution(object):\n    def generateMatrix(self, n):\n         \n        res = [[0] * n for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res[top][i] = num\n                num += 1\n            for i in range(top + 1, bottom + 1):\n                res[i][right] = num\n                num += 1\n            if left < right and top < bottom:\n                for i in range(right - 1, left, -1):\n                    res[bottom][i] = num\n                    num += 1\n                for i in range(bottom, top, -1):\n                    res[i][left] = num\n                    num += 1\n            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1\n        return res"}
{"id": "646", "path": "output2\\py\\Medium\\646-rotate-list.py", "hypo_code": "class Solution(object):\n    def rotateRight(self, head, k):\n        \n        if not head:\n            return None\n        if not head.next:\n            return head\n        if k == 0:\n            return head\n        \n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length += 1\n        \n        cur.next = head\n        \n        cur = head\n        for i in range(length - k % length - 1):\n            cur = cur.next\n        \n        new_head = cur.next\n        \n        cur.next = None\n        return new_head"}
{"id": "647", "path": "output2\\py\\Medium\\647-unique-paths.py", "hypo_code": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]"}
{"id": "648", "path": "output2\\py\\Medium\\648-unique-paths-ii.py", "hypo_code": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n         \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            if obstacleGrid[i][0] == 1:\n                break\n            dp[i][0] = 1\n        for j in range(n):\n            if obstacleGrid[0][j] == 1:\n                break\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]"}
{"id": "649", "path": "output2\\py\\Medium\\649-minimum-path-sum.py", "hypo_code": "class Solution(object):\n    def minPathSum(self, grid):\n        \n        m,n = len(grid),len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for j in range(1,n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n        return dp[-1][-1]"}
{"id": "650", "path": "output2\\py\\Medium\\650-simplify-path.py", "hypo_code": "class Solution(object):\n    def simplifyPath(self, path):\n        \n        if path==\"\":\n            return \"\"\n        if path==\"/\":\n            return \"/\"\n        if path[-1]==\"/\":\n            path=path[:-1]\n        path=path.split(\"/\")\n        stack=[]\n        for i in range(len(path)):\n            if path[i]==\".\":\n                continue\n            elif path[i]==\"..\":\n                if len(stack)>0:\n                    stack.pop()\n            else:\n                stack.append(path[i])\n        if len(stack)==0:\n            return \"/\"\n        res=\"\"\n        for i in range(len(stack)):\n            res+=\"/\"+stack[i]\n        return res"}
{"id": "651", "path": "output2\\py\\Medium\\651-edit-distance.py", "hypo_code": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \n        \n        \n        \n        \n        m, n = len(word1), len(word2)\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                \n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n\n                \n                else:\n                    dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])+1\n\n        return dp[-1][-1]"}
{"id": "652", "path": "output2\\py\\Medium\\652-set-matrix-zeroes.py", "hypo_code": "class Solution(object):\n    def setZeroes(self, matrix):\n        \n        m,n = len(matrix),len(matrix[0])\n        row0,col0 = False,False\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j]==0:\n                    if i==0:\n                        row0=True\n                    if j==0:\n                        col0=True\n                    matrix[i][0]=0\n                    matrix[0][j]=0\n        for i in range(1,m):\n            for j in range(1,n):\n                if matrix[i][0]==0 or matrix[0][j]==0:\n                    matrix[i][j]=0\n        if row0:\n            for j in range(n):\n                matrix[0][j]=0\n        if col0:\n            for i in range(m):\n                matrix[i][0]=0"}
{"id": "653", "path": "output2\\py\\Medium\\653-search-a-2d-matrix.py", "hypo_code": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \n        m,n = len(matrix),len(matrix[0])\n        left,right = 0,m*n-1\n        while left<=right:\n            mid = (left+right)//2\n            if matrix[mid//n][mid%n]==target:\n                return True\n            elif matrix[mid//n][mid%n]<target:\n                left=mid+1\n            else:\n                right=mid-1\n        return False"}
{"id": "654", "path": "output2\\py\\Medium\\654-sort-colors.py", "hypo_code": "class Solution(object):\n    def sortColors(self, nums):\n         \n        i = 0\n        j = 0\n        k = len(nums) - 1\n        while j <= k:\n            if nums[j] == 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n                j += 1\n            elif nums[j] == 1:\n                j += 1\n            else:\n                nums[j], nums[k] = nums[k], nums[j]\n                k -= 1\n        return nums"}
{"id": "655", "path": "output2\\py\\Medium\\655-combinations.py", "hypo_code": "class Solution(object):\n    def combine(self, n, k):\n         \n        res = []\n        self.dfs(range(1, n + 1), k, 0, [], res)\n        return res"}
{"id": "656", "path": "output2\\py\\Medium\\656-subsets.py", "hypo_code": "class Solution(object):\n    def subsets(self, nums):\n        \n        res = [[]]\n        for num in nums:\n            res += [item + [num] for item in res]\n        return res"}
{"id": "657", "path": "output2\\py\\Medium\\657-word-search.py", "hypo_code": "class Solution(object):\n    def exist(self, board, word):\n        \n        m,n = len(board),len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if self.dfs(board,word,i,j,0):\n                    return True\n        return False"}
{"id": "658", "path": "output2\\py\\Medium\\658-remove-duplicates-from-sorted-array-ii.py", "hypo_code": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \n        i = 0\n        for n in nums:\n            if i < 2 or n > nums[i-2]:\n                nums[i] = n\n                i += 1\n        return i"}
{"id": "659", "path": "output2\\py\\Medium\\659-search-in-rotated-sorted-array-ii.py", "hypo_code": "class Solution(object):\n    def search(self, nums, target):\n        \n        if not nums:\n            return False\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid]:\n                left += 1\n            elif nums[left] < nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False"}
{"id": "660", "path": "output2\\py\\Medium\\660-remove-duplicates-from-sorted-list-ii.py", "hypo_code": "class Solution(object):\n    def deleteDuplicates(self, head):\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}
{"id": "661", "path": "output2\\py\\Medium\\661-partition-list.py", "hypo_code": "class Solution(object):\n    def partition(self, head, x):\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr:\n            if curr.val < x:\n                if prev.next == curr:\n                    prev = curr\n                else:\n                    prev.next = curr.next\n                    curr.next = dummy.next\n                    dummy.next = curr\n            else:\n                prev = curr\n            curr = prev.next\n        return dummy.next"}
{"id": "662", "path": "output2\\py\\Medium\\662-gray-code.py", "hypo_code": "class Solution(object):\n    def grayCode(self, n):\n        \n        res = [0]\n        for i in range(n):\n            for j in range(len(res) - 1, -1, -1):\n                res.append(res[j] | 1 << i)\n        return res"}
{"id": "663", "path": "output2\\py\\Medium\\663-subsets-ii.py", "hypo_code": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, 0, [], res)\n        return res"}
{"id": "664", "path": "output2\\py\\Medium\\664-decode-ways.py", "hypo_code": "class Solution(object):\n    def numDecodings(self, s):\n        \n        if not s or s[0] == '0':\n            return 0\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] < '7'):\n                dp[i] += dp[i - 2]\n        return dp[-1]"}
{"id": "665", "path": "output2\\py\\Medium\\665-reverse-linked-list-ii.py", "hypo_code": "class Solution(object):\n    def reverseBetween(self, head, left, right):\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for i in range(left-1):\n            prev = prev.next\n        cur = prev.next\n        for i in range(right-left):\n            tmp = cur.next\n            cur.next = tmp.next\n            tmp.next = prev.next\n            prev.next = tmp\n        return dummy.next"}
{"id": "666", "path": "output2\\py\\Medium\\666-restore-ip-addresses.py", "hypo_code": "class Solution(object):\n    def restoreIpAddresses(self, s):\n        \n        res = []\n        self.dfs(s, 0, \"\", res)\n        return res"}
{"id": "667", "path": "output2\\py\\Medium\\667-unique-binary-search-trees-ii.py", "hypo_code": "class Solution(object):\n    def generateTrees(self, n):\n        \n        if n == 0:\n            return []\n        return self.helper(1, n)"}
{"id": "668", "path": "output2\\py\\Medium\\668-unique-binary-search-trees.py", "hypo_code": "class Solution(object):\n    def numTrees(self, n):\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        return dp[n]"}
{"id": "669", "path": "output2\\py\\Medium\\669-interleaving-string.py", "hypo_code": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \n        if len(s1)+len(s2)!=len(s3):\n            return False\n        m,n=len(s1),len(s2)\n        dp=[[False]*(n+1) for _ in range(m+1)]\n        dp[0][0]=True\n        for i in range(1,m+1):\n            dp[i][0]=dp[i-1][0] and s1[i-1]==s3[i-1]\n        for j in range(1,n+1):\n            dp[0][j]=dp[0][j-1] and s2[j-1]==s3[j-1]\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                dp[i][j]=(dp[i-1][j] and s1[i-1]==s3[i+j-1]) or (dp[i][j-1] and s2[j-1]==s3[i+j-1])\n        return dp[-1][-1]"}
{"id": "670", "path": "output2\\py\\Medium\\670-validate-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def isValidBST(self, root):\n        \n        return self.helper(root, float('-inf'), float('inf'))"}
{"id": "671", "path": "output2\\py\\Medium\\671-recover-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def recoverTree(self, root):\n        \n        self.first = None\n        self.second = None\n        self.prev = TreeNode(float('-inf'))\n        self.inorder(root)\n        self.first.val, self.second.val = self.second.val, self.first.val"}
{"id": "672", "path": "output2\\py\\Medium\\672-binary-tree-level-order-traversal.py", "hypo_code": "class Solution(object):\n    def levelOrder(self, root):\n        \n        if not root:\n            return []\n        queue = [root]\n        result = []\n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}
{"id": "673", "path": "output2\\py\\Medium\\673-binary-tree-zigzag-level-order-traversal.py", "hypo_code": "class Solution(object):\n    def zigzagLevelOrder(self, root):\n        \n        if not root:\n            return []\n        queue = [root]\n        result = []\n        left_to_right = True\n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if not left_to_right:\n                level.reverse()\n            result.append(level)\n            left_to_right = not left_to_right\n        return result"}
{"id": "674", "path": "output2\\py\\Medium\\674-construct-binary-tree-from-preorder-and-inorder-traversal.py", "hypo_code": "class Solution(object):\n    def buildTree(self, preorder, inorder):\n        \n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:index+1], inorder[:index])\n        root.right = self.buildTree(preorder[index+1:], inorder[index+1:])\n        return root"}
{"id": "675", "path": "output2\\py\\Medium\\675-construct-binary-tree-from-inorder-and-postorder-traversal.py", "hypo_code": "class Solution(object):\n    def buildTree(self, inorder, postorder):\n        \n        if not postorder:\n            return None\n        root = TreeNode(postorder[-1])\n        index = inorder.index(postorder[-1])\n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        return root"}
{"id": "676", "path": "output2\\py\\Medium\\676-binary-tree-level-order-traversal-ii.py", "hypo_code": "class Solution(object):\n    def levelOrderBottom(self, root):\n        \n        if not root:\n            return []\n        queue = [root]\n        result = []\n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        result.reverse()\n        return result"}
{"id": "677", "path": "output2\\py\\Medium\\677-convert-sorted-list-to-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def sortedListToBST(self, head):\n        \n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root"}
{"id": "678", "path": "output2\\py\\Medium\\678-path-sum-ii.py", "hypo_code": "class Solution(object):\n    def pathSum(self, root, targetSum):\n        \n        if not root:\n            return []\n        if not root.left and not root.right:\n            if root.val == targetSum:\n                return [[root.val]]\n            else:\n                return []\n        left = self.pathSum(root.left, targetSum - root.val)\n        right = self.pathSum(root.right, targetSum - root.val)\n        return [[root.val] + i for i in left + right]"}
{"id": "679", "path": "output2\\py\\Medium\\679-flatten-binary-tree-to-linked-list.py", "hypo_code": "class Solution(object):\n    def flatten(self, root):\n        \n        if not root:\n            return None\n        self.flatten(root.left)\n        self.flatten(root.right)\n        if root.left:\n            temp = root.right\n            root.right = root.left\n            root.left = None\n            while root.right:\n                root = root.right\n            root.right = temp\n        return root"}
{"id": "680", "path": "output2\\py\\Medium\\680-populating-next-right-pointers-in-each-node.py", "hypo_code": "class Solution(object):\n    def connect(self, root):\n        \n        if not root:\n            return None\n        if root.left:\n            root.left.next = root.right\n        if root.right:\n            root.right.next = root.next.left if root.next else None\n        self.connect(root.left)\n        self.connect(root.right)\n        return root"}
{"id": "681", "path": "output2\\py\\Medium\\681-populating-next-right-pointers-in-each-node-ii.py", "hypo_code": "class Solution(object):\n    def connect(self, root):\n        \n        if not root:\n            return None\n        if root.left:\n            root.left.next = root.right\n        if root.right:\n            root.right.next = root.next.left if root.next else None\n        self.connect(root.left)\n        self.connect(root.right)\n        return root"}
{"id": "682", "path": "output2\\py\\Medium\\682-triangle.py", "hypo_code": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \n        if not triangle:\n            return 0\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n        return min(triangle[-1])"}
{"id": "683", "path": "output2\\py\\Medium\\683-best-time-to-buy-and-sell-stock-ii.py", "hypo_code": "class Solution(object):\n    def maxProfit(self, prices):\n               \n        res = 0\n        for i in range(1,len(prices)):\n            if prices[i]>prices[i-1]:\n                res += prices[i]-prices[i-1]\n        return res"}
{"id": "684", "path": "output2\\py\\Medium\\684-longest-consecutive-sequence.py", "hypo_code": "class Solution(object):\n    def longestConsecutive(self, nums):\n               \n        res = 0\n        nums = set(nums)\n        for i in nums:\n            if i-1 not in nums:\n                j = i+1\n                while j in nums:\n                    j+=1\n                res = max(res,j-i)\n        return res"}
{"id": "685", "path": "output2\\py\\Medium\\685-sum-root-to-leaf-numbers.py", "hypo_code": "class Solution(object):\n    def sumNumbers(self, root):\n        \n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return root.val\n        left = self.sumNumbers(root.left)\n        right = self.sumNumbers(root.right)\n        if root.left and root.right:\n            return left * 10 + root.val + right * 10\n        elif root.left:\n            return left * 10 + root.val\n        else:\n            return root.val + right * 10"}
{"id": "686", "path": "output2\\py\\Medium\\686-surrounded-regions.py", "hypo_code": "class Solution(object):\n    def solve(self, board):\n        \n        if not board:\n            return None\n        m = len(board)\n        n = len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if (i==0 or i==m-1 or j==0 or j==n-1) and board[i][j] == 'O':\n                    self.dfs(board,i,j)\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == '1':\n                    board[i][j] = 'O'\n        return board"}
{"id": "687", "path": "output2\\py\\Medium\\687-palindrome-partitioning.py", "hypo_code": "class Solution(object):\n    def partition(self, s):\n              \n        res = []\n        self.dfs(s,[],res)\n        return res"}
{"id": "688", "path": "output2\\py\\Medium\\688-clone-graph.py", "hypo_code": "class Solution(object):\n    def cloneGraph(self, node):\n        \n        if not node:\n            return None\n        visited = {}\n        def dfs(node):\n            if node.val in visited:\n                return visited[node.val]\n            clone = Node(node.val)\n            visited[node.val] = clone\n            for n in node.neighbors:\n                clone.neighbors.append(dfs(n))\n            return clone\n        return dfs(node)"}
{"id": "689", "path": "output2\\py\\Medium\\689-gas-station.py", "hypo_code": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n            \n        if sum(gas) < sum(cost):\n            return -1\n        start = 0\n        tank = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start"}
{"id": "690", "path": "output2\\py\\Medium\\690-single-number-ii.py", "hypo_code": "class Solution(object):\n    def singleNumber(self, nums):\n              \n        res = 0\n        for i in range(32):\n            sum = 0\n            for num in nums:\n                if num>>i & 1:\n                    sum+=1\n            sum %= 3\n            if sum:\n                res |= sum<<i\n        return res if res < 2**31 else ~(res^0xffffffff)"}
{"id": "691", "path": "output2\\py\\Medium\\691-copy-list-with-random-pointer.py", "hypo_code": "class Solution(object):\n    def copyRandomList(self, head):\n        \n        if not head:\n            return None\n        visited = {}\n        def dfs(node):\n            if node in visited:\n                return visited[node]\n            clone = Node(node.val)\n            visited[node] = clone\n            if node.next:\n                clone.next = dfs(node.next)\n            if node.random:\n                clone.random = dfs(node.random)\n            return clone\n        return dfs(head)"}
{"id": "692", "path": "output2\\py\\Medium\\692-word-break.py", "hypo_code": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n             \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        return dp[-1]"}
{"id": "693", "path": "output2\\py\\Medium\\693-linked-list-cycle-ii.py", "hypo_code": "class Solution(object):\n    def detectCycle(self, head):\n             \n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        if not fast or not fast.next:\n            return None\n        slow = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return slow"}
{"id": "694", "path": "output2\\py\\Medium\\694-reorder-list.py", "hypo_code": "class Solution(object):\n    def reorderList(self, head):\n        \n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        if not fast or not fast.next:\n            return None\n        slow = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return slow"}
{"id": "696", "path": "output2\\py\\Medium\\696-insertion-sort-list.py", "hypo_code": "class Solution(object):\n    def insertionSortList(self, head):\n        \n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        if not fast or not fast.next:\n            return None\n        slow = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return slow"}
{"id": "697", "path": "output2\\py\\Medium\\697-sort-list.py", "hypo_code": "class Solution(object):\n    def sortList(self, head):\n        \n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        if not fast or not fast.next:\n            return None\n        slow = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return slow"}
{"id": "698", "path": "output2\\py\\Medium\\698-evaluate-reverse-polish-notation.py", "hypo_code": "class Solution(object):\n    def evalRPN(self, tokens):\n               \n        stack = []\n        for i in tokens:\n            if i not in [\"+\",\"-\",\"*\",\"/\"]:\n                stack.append(int(i))\n            else:\n                a = stack.pop()\n                b = stack.pop()\n                if i == \"+\":\n                    stack.append(a+b)\n                elif i == \"-\":\n                    stack.append(b-a)\n                elif i == \"*\":\n                    stack.append(a*b)\n                else:\n                    stack.append(int(float(b)/a))\n        return stack[0]"}
{"id": "699", "path": "output2\\py\\Medium\\699-reverse-words-in-a-string.py", "hypo_code": "class Solution(object):\n    def reverseWords(self, s):\n        \n        return \" \".join(s.split()[::-1])"}
{"id": "700", "path": "output2\\py\\Medium\\700-maximum-product-subarray.py", "hypo_code": "class Solution(object):\n    def maxProduct(self, nums):\n        \n        res = nums[0]\n        imax = res\n        imin = res\n        for i in range(1,len(nums)):\n            if nums[i] < 0:\n                imax,imin = imin,imax\n            imax = max(nums[i],imax*nums[i])\n            imin = min(nums[i],imin*nums[i])\n            res = max(res,imax)\n        return res"}
{"id": "701", "path": "output2\\py\\Medium\\701-find-minimum-in-rotated-sorted-array.py", "hypo_code": "class Solution(object):\n    def findMin(self, nums):\n             \n        left = 0\n        right = len(nums)-1\n        while left < right:\n            mid = left + (right-left)//2\n            if nums[mid] > nums[right]:\n                left = mid+1\n            else:\n                right = mid\n        return nums[left]"}
{"id": "703", "path": "output2\\py\\Medium\\703-find-peak-element.py", "hypo_code": "class Solution(object):\n    def findPeakElement(self, nums):\n        \n        \n        left, right = 0, len(nums)-1\n        while left < right:\n            mid = (left+right)//2\n            if nums[mid] > nums[mid+1]:\n                right = mid\n            else:\n                left = mid+1\n        return left"}
{"id": "704", "path": "output2\\py\\Medium\\704-compare-version-numbers.py", "hypo_code": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        \n        for i in range(max(len(v1), len(v2))):\n            \n            if i >= len(v1):\n                v1.append('0')\n            \n            if i >= len(v2):\n                v2.append('0')\n            \n            \n            if int(v1[i]) < int(v2[i]):\n                return -1\n            elif int(v1[i]) > int(v2[i]):\n                return 1\n        \n        \n        return 0"}
{"id": "705", "path": "output2\\py\\Medium\\705-fraction-to-recurring-decimal.py", "hypo_code": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \n        \n        sign = 1\n        if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0):\n            sign = -1\n            \n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator * sign)\n        \n        \n        res = str(numerator // denominator) + '.'\n        \n        \n        numerator %= denominator\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                res = res[:seen[numerator]] + '(' + res[seen[numerator]:] + ')'\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n        \n        return res if sign == 1 else '-' + res"}
{"id": "706", "path": "output2\\py\\Medium\\706-two-sum-ii-input-array-is-sorted.py", "hypo_code": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \n        \n        left, right = 0, len(numbers)-1\n        while left < right:\n            if numbers[left] + numbers[right] < target:\n                left += 1\n            elif numbers[left] + numbers[right] > target:\n                right -= 1\n            else:\n                return [left+1, right+1]"}
{"id": "707", "path": "output2\\py\\Medium\\707-factorial-trailing-zeroes.py", "hypo_code": "class Solution(object):\n    def trailingZeroes(self, n):\n        \n        \n        res = 0\n        while n > 0:\n            n //= 5\n            res += n\n        return res"}
{"id": "712", "path": "output2\\py\\Medium\\712-largest-number.py", "hypo_code": "class Solution(object):\n    def largestNumber(self, nums):\n        \n        \n        nums = [str(num) for num in nums]\n        nums.sort(key = lambda x: x*10, reverse = True)\n        return str(int(''.join(nums)))"}
{"id": "715", "path": "output2\\py\\Medium\\715-repeated-dna-sequences.py", "hypo_code": "class Solution(object):\n    def findRepeatedDnaSequences(self, s):\n        \n        res = []\n        for i in range(len(s)-9):\n            if s[i:i+10] in s[i+1:]:\n                res.append(s[i:i+10])\n        return list(set(res))"}
{"id": "716", "path": "output2\\py\\Medium\\716-rotate-array.py", "hypo_code": "class Solution(object):\n    def rotate(self, nums, k):\n             \n        n = len(nums)\n        k = k % n\n        nums[:] = nums[n-k:] + nums[:n-k]\n        return nums"}
{"id": "719", "path": "output2\\py\\Medium\\719-house-robber.py", "hypo_code": "class Solution(object):\n    def rob(self, nums):\n        \n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums[0],nums[1])\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0],nums[1])\n        for i in range(2,len(nums)):\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i])\n        return dp[-1]"}
{"id": "720", "path": "output2\\py\\Medium\\720-binary-tree-right-side-view.py", "hypo_code": "class Solution(object):\n    def rightSideView(self, root):\n        \n        if not root:\n            return []\n        queue = [root]\n        result = []\n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level[-1])\n        return result"}
{"id": "721", "path": "output2\\py\\Medium\\721-number-of-islands.py", "hypo_code": "class Solution(object):\n    def numIslands(self, grid):\n        \n        m = len(grid)\n        if m == 0:\n            return 0\n        n = len(grid[0])\n        if n == 0:\n            return 0\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    self.dfs(grid, i, j)\n                    count += 1\n        return count"}
{"id": "722", "path": "output2\\py\\Medium\\722-bitwise-and-of-numbers-range.py", "hypo_code": "class Solution(object):\n    def rangeBitwiseAnd(self, left, right):\n        \n        shift = 0\n        while left < right:\n            left >>= 1\n            right >>= 1\n            shift += 1\n        return left << shift"}
{"id": "723", "path": "output2\\py\\Medium\\723-count-primes.py", "hypo_code": "class Solution(object):\n    def countPrimes(self, n):\n               \n        if n < 3:\n            return 0\n        isPrime = [True] * n\n        isPrime[0] = isPrime[1] = False\n        for i in range(2, int(n ** 0.5) + 1):\n            if isPrime[i]:\n                isPrime[i * i: n: i] = [False] * len(isPrime[i * i: n: i])\n        return sum(isPrime)"}
{"id": "724", "path": "output2\\py\\Medium\\724-course-schedule.py", "hypo_code": "class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n              \n        graph = [[] for _ in range(numCourses)]\n        visited = [0 for _ in range(numCourses)]\n        for i,j in prerequisites:\n            graph[i].append(j)\n        def dfs(i):\n            if visited[i]==-1:\n                return False\n            if visited[i]==1:\n                return True\n            visited[i] = -1\n            for j in graph[i]:\n                if not dfs(j):\n                    return False\n            visited[i] = 1\n            return True\n        for i in range(numCourses):\n            if not dfs(i):\n                return False\n        return True"}
{"id": "726", "path": "output2\\py\\Medium\\726-minimum-size-subarray-sum.py", "hypo_code": "class Solution(object):\n    def minSubArrayLen(self, target, nums):\n               \n        res = len(nums)+1\n        left = 0\n        sum = 0\n        for i in range(len(nums)):\n            sum += nums[i]\n            while sum >= target:\n                res = min(res, i+1-left)\n                sum -= nums[left]\n                left += 1\n        return 0 if res == len(nums)+1 else res"}
{"id": "727", "path": "output2\\py\\Medium\\727-course-schedule-ii.py", "hypo_code": "class Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n             \n        graph = [[] for _ in range(numCourses)]\n        visited = [0 for _ in range(numCourses)]\n        for i,j in prerequisites:\n            graph[i].append(j)\n        res = []\n        def dfs(i):\n            if visited[i]==-1:\n                return False\n            if visited[i]==1:\n                return True\n            visited[i] = -1\n            for j in graph[i]:\n                if not dfs(j):\n                    return False\n            visited[i] = 1\n            res.append(i)\n            return True\n        for i in range(numCourses):\n            if not dfs(i):\n                return []\n        return res[::-1]"}
{"id": "729", "path": "output2\\py\\Medium\\729-house-robber-ii.py", "hypo_code": "class Solution(object):\n    def rob(self, nums):\n        \n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        return max(self.robRange(nums, 0, n - 2), self.robRange(nums, 1, n - 1))"}
{"id": "730", "path": "output2\\py\\Medium\\730-kth-largest-element-in-an-array.py", "hypo_code": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \n        return sorted(nums,reverse=True)[k-1]"}
{"id": "731", "path": "output2\\py\\Medium\\731-combination-sum-iii.py", "hypo_code": "class Solution(object):\n    def combinationSum3(self, k, n):\n        \n        res = []\n        self.dfs(range(1, 10), k, n, 0, [], res)\n        return res"}
{"id": "732", "path": "output2\\py\\Medium\\732-maximal-square.py", "hypo_code": "class Solution(object):\n    def maximalSquare(self, matrix):\n               \n        m = len(matrix)\n        if m == 0:\n            return 0\n        n = len(matrix[0])\n        if n == 0:\n            return 0\n        dp = [[0 for i in range(n)] for j in range(m)]\n        res = 0\n        for i in range(m):\n            dp[i][0] = int(matrix[i][0])\n            res = max(res, dp[i][0])\n        for j in range(n):\n            dp[0][j] = int(matrix[0][j])\n            res = max(res, dp[0][j])\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == '1':\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n                    res = max(res, dp[i][j])\n        return res * res"}
{"id": "733", "path": "output2\\py\\Medium\\733-rectangle-area.py", "hypo_code": "class Solution(object):\n    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n        \n        x1 = max(ax1, bx1)\n        x2 = min(ax2, bx2)\n        y1 = max(ay1, by1)\n        y2 = min(ay2, by2)\n        if x1 < x2 and y1 < y2:\n            overlap = (x2 - x1) * (y2 - y1)\n        else:\n            overlap = 0\n        return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - overlap"}
{"id": "734", "path": "output2\\py\\Medium\\734-basic-calculator-ii.py", "hypo_code": "class Solution(object):\n    def calculate(self, s):\n               \n        s = s.replace(\" \",\"\")\n        stack = []\n        num = 0\n        sign = \"+\"\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if i == len(s)-1 or s[i] in \"+-*/\":\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop()*num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop()/float(num)))\n                sign = s[i]\n                num = 0\n        return sum(stack)"}
{"id": "735", "path": "output2\\py\\Medium\\735-majority-element-ii.py", "hypo_code": "class Solution(object):\n    def majorityElement(self, nums):\n        \n        \n        \n        \n        candidate1, candidate2 = None, None\n        count1, count2 = 0, 0\n        \n        for num in nums:\n            if candidate1 == num:\n                count1 += 1\n            elif candidate2 == num:\n                count2 += 1\n            elif count1 == 0:\n                candidate1 = num\n                count1 = 1\n            elif count2 == 0:\n                candidate2 = num\n                count2 = 1\n            else:\n                count1 -= 1\n                count2 -= 1\n        \n        res = []\n        if nums.count(candidate1) > len(nums)//3:\n            res.append(candidate1)\n        if nums.count(candidate2) > len(nums)//3:\n            res.append(candidate2)\n        return res"}
{"id": "736", "path": "output2\\py\\Medium\\736-kth-smallest-element-in-a-bst.py", "hypo_code": "class Solution(object):\n    def kthSmallest(self, root, k):\n        \n        self.k = k\n        self.res = None\n        def dfs(root):\n            if not root:\n                return\n            dfs(root.left)\n            self.k -= 1\n            if self.k == 0:\n                self.res = root.val\n                return\n            dfs(root.right)\n        dfs(root)\n        return self.res"}
{"id": "737", "path": "output2\\py\\Medium\\737-lowest-common-ancestor-of-a-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \n        if root.val > p.val and root.val > q.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n        elif root.val < p.val and root.val < q.val:\n            return self.lowestCommonAncestor(root.right, p, q)\n        else:\n            return root"}
{"id": "738", "path": "output2\\py\\Medium\\738-lowest-common-ancestor-of-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \n        if root in (None, p, q):\n            return root\n        left, right = (self.lowestCommonAncestor(kid, p, q) for kid in (root.left, root.right))\n        return root if left and right else left or right"}
{"id": "739", "path": "output2\\py\\Medium\\739-delete-node-in-a-linked-list.py", "hypo_code": "class Solution(object):\n    def deleteNode(self, node):\n        \n        node.val = node.next.val\n        node.next = node.next.next"}
{"id": "740", "path": "output2\\py\\Medium\\740-product-of-array-except-self.py", "hypo_code": "class Solution(object):\n    def productExceptSelf(self, nums):\n              \n        res = [1]*len(nums)\n        for i in range(1,len(nums)):\n            res[i] = res[i-1]*nums[i-1]\n        right = 1\n        for i in range(len(nums)-1,-1,-1):\n            res[i] *= right\n            right *= nums[i]\n        return res"}
{"id": "741", "path": "output2\\py\\Medium\\741-search-a-2d-matrix-ii.py", "hypo_code": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \n        m = len(matrix)\n        if m == 0:\n            return False\n        n = len(matrix[0])\n        if n == 0:\n            return False\n        i = 0\n        j = n - 1\n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] < target:\n                i += 1\n            else:\n                j -= 1\n        return False"}
{"id": "742", "path": "output2\\py\\Medium\\742-different-ways-to-add-parentheses.py", "hypo_code": "class Solution(object):\n    def diffWaysToCompute(self, expression):\n        \n        if expression.isdigit():\n            return [int(expression)]\n        res = []\n        for i, c in enumerate(expression):\n            if c in \"+-*\":\n                left = self.diffWaysToCompute(expression[:i])\n                right = self.diffWaysToCompute(expression[i+1:])\n                for l in left:\n                    for r in right:\n                        res.append(self.helper(l, r, c))\n        return res"}
{"id": "743", "path": "output2\\py\\Medium\\743-single-number-iii.py", "hypo_code": "class Solution(object):\n    def singleNumber(self, nums):\n        \n        \n        xor = 0\n        for num in nums:\n            xor ^= num\n        \n        mask = 1\n        while mask & xor == 0:\n            mask <<= 1\n        \n        a, b = 0, 0\n        for num in nums:\n            if num & mask == 0:\n                a ^= num\n            else:\n                b ^= num\n        return [a, b]"}
{"id": "744", "path": "output2\\py\\Medium\\744-ugly-number-ii.py", "hypo_code": "class Solution(object):\n    def nthUglyNumber(self, n):\n         \n        import heapq\n        heap = [1]\n        heapq.heapify(heap)\n        count = 0\n        while count < n:\n            count += 1\n            cur = heapq.heappop(heap)\n            if count == n:\n                return cur\n            for i in [2, 3, 5]:\n                heapq.heappush(heap, cur * i)\n        return -1"}
{"id": "745", "path": "output2\\py\\Medium\\745-h-index.py", "hypo_code": "class Solution(object):\n    def hIndex(self, citations):\n        \n        citations.sort(reverse=True)\n        for i, c in enumerate(citations):\n            if c < i + 1:\n                return i\n        return len(citations)"}
{"id": "746", "path": "output2\\py\\Medium\\746-h-index-ii.py", "hypo_code": "class Solution(object):\n    def hIndex(self, citations):\n        \n        n = len(citations)\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if citations[mid] >= n - mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return n - left"}
{"id": "747", "path": "output2\\py\\Medium\\747-perfect-squares.py", "hypo_code": "class Solution(object):\n    def numSquares(self, n):\n        \n        dp = [0 for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i] = i\n            for j in range(1, i):\n                if j * j <= i:\n                    dp[i] = min(dp[i], dp[i - j * j] + 1)\n        return dp[n]"}
{"id": "749", "path": "output2\\py\\Medium\\749-find-the-duplicate-number.py", "hypo_code": "class Solution(object):\n    def findDuplicate(self, nums):\n        \n        n, slow, fast = len(nums), 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        slow = 0\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow"}
{"id": "750", "path": "output2\\py\\Medium\\750-game-of-life.py", "hypo_code": "class Solution(object):\n    def gameOfLife(self, board):\n        \n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                count = 0\n                for x in range(max(0, i - 1), min(m, i + 2)):\n                    for y in range(max(0, j - 1), min(n, j + 2)):\n                        count += board[x][y] & 1\n                if count == 3 or count == board[i][j] + 3:\n                    board[i][j] |= 2\n        for i in range(m):\n            for j in range(n):\n                board[i][j] >>= 1"}
{"id": "751", "path": "output2\\py\\Medium\\751-bulls-and-cows.py", "hypo_code": "class Solution(object):\n    def getHint(self, secret, guess):\n        \n        bulls = 0\n        cows = 0\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n        for i in range(10):\n            cows += min(secret.count(str(i)), guess.count(str(i)))\n        cows -= bulls\n        return str(bulls) + \"A\" + str(cows) + \"B\""}
{"id": "752", "path": "output2\\py\\Medium\\752-longest-increasing-subsequence.py", "hypo_code": "class Solution(object):\n    def lengthOfLIS(self, nums):\n        \n        res = 0\n        dp = [1]*len(nums)\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i],dp[j]+1)\n            res = max(res,dp[i])\n        return res"}
{"id": "754", "path": "output2\\py\\Medium\\754-additive-number.py", "hypo_code": "class Solution(object):\n    def isAdditiveNumber(self, num):\n        \n        for i in range(1, len(num)):\n            for j in range(i+1, len(num)):\n                a, b = num[:i], num[i:j]\n                if a != str(int(a)) or b != str(int(b)):\n                    continue\n                while j < len(num):\n                    c = str(int(a) + int(b))\n                    if not num.startswith(c, j):\n                        break\n                    j += len(c)\n                    a, b = b, c\n                if j == len(num):\n                    return True\n        return False"}
{"id": "756", "path": "output2\\py\\Medium\\756-best-time-to-buy-and-sell-stock-with-cooldown.py", "hypo_code": "class Solution(object):\n    def maxProfit(self, prices):\n        \n        if len(prices) == 0:\n            return 0\n        dp = [[0 for i in range(2)] for j in range(len(prices))]\n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        for i in range(1, len(prices)):\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\n            if i == 1:\n                dp[i][1] = max(dp[i-1][1], -prices[i])\n            else:\n                dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\n        return dp[len(prices)-1][0]"}
{"id": "757", "path": "output2\\py\\Medium\\757-minimum-height-trees.py", "hypo_code": "class Solution(object):\n    def findMinHeightTrees(self, n, edges):\n        \n        if n == 1:\n            return [0]\n        graph = collections.defaultdict(list)\n        for i, j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n        leaves = []\n        for i in range(n):\n            if len(graph[i]) == 1:\n                leaves.append(i)\n        while n > 2:\n            n -= len(leaves)\n            new_leaves = []\n            for i in leaves:\n                j = graph[i].pop()\n                graph[j].remove(i)\n                if len(graph[j]) == 1:\n                    new_leaves.append(j)\n            leaves = new_leaves\n        return leaves"}
{"id": "758", "path": "output2\\py\\Medium\\758-super-ugly-number.py", "hypo_code": "class Solution(object):\n    def nthSuperUglyNumber(self, n, primes):\n        \n        import heapq\n        heap = [1]\n        heapq.heapify(heap)\n        count = 0\n        while count < n:\n            count += 1\n            cur = heapq.heappop(heap)\n            if count == n:\n                return cur\n            for i in primes:\n                heapq.heappush(heap, cur * i)\n        return -1"}
{"id": "759", "path": "output2\\py\\Medium\\759-remove-duplicate-letters.py", "hypo_code": "class Solution(object):\n    def removeDuplicateLetters(self, s):\n        \n        res = []\n        for i, c in enumerate(s):\n            if c not in res:\n                while res and c < res[-1] and s.find(res[-1], i) != -1:\n                    res.pop()\n                res.append(c)\n        return \"\".join(res)"}
{"id": "760", "path": "output2\\py\\Medium\\760-maximum-product-of-word-lengths.py", "hypo_code": "class Solution(object):\n    def maxProduct(self, words):\n        \n        res = 0\n        words = sorted(words,key=len)\n        for i in range(len(words)):\n            for j in range(i+1,len(words)):\n                if not set(words[i]) & set(words[j]):\n                    res = max(res,len(words[i])*len(words[j]))\n        return res"}
{"id": "761", "path": "output2\\py\\Medium\\761-bulb-switcher.py", "hypo_code": "class Solution(object):\n    def bulbSwitch(self, n):\n        \n        return int(math.sqrt(n))"}
{"id": "762", "path": "output2\\py\\Medium\\762-coin-change.py", "hypo_code": "class Solution(object):\n    def coinChange(self, coins, amount):\n        \n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        for c in coins:\n            for i in range(c, amount + 1):\n                dp[i] = min(dp[i], dp[i - c] + 1)\n        return dp[amount] if dp[amount] != float('inf') else -1"}
{"id": "763", "path": "output2\\py\\Medium\\763-wiggle-sort-ii.py", "hypo_code": "class Solution(object):\n    def wiggleSort(self, nums):\n        \n        \n        nums.sort()\n        n = len(nums)\n        a = nums[:(n + 1) // 2]\n        b = nums[(n + 1) // 2:]\n        \n        a = a[::-1]\n        \n        for i in range(n):\n            if i % 2 == 0:\n                nums[i] = a[i // 2]\n            else:\n                nums[i] = b[i // 2]"}
{"id": "764", "path": "output2\\py\\Medium\\764-odd-even-linked-list.py", "hypo_code": "class Solution(object):\n    def oddEvenList(self, head):\n        \n        if not head:\n            return None\n        odd = head\n        even = head.next\n        evenhead = even\n        while even and even.next:\n            odd.next = even.next\n            odd = even.next\n            even.next = odd.next\n            even = odd.next\n        odd.next = evenhead\n        return head"}
{"id": "765", "path": "output2\\py\\Medium\\765-verify-preorder-serialization-of-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def isValidSerialization(self, preorder):\n        \n        slots = 1\n        for node in preorder.split(','):\n            slots -= 1\n            if slots < 0:\n                return False\n            if node != '\n                slots += 2\n        return slots == 0"}
{"id": "766", "path": "output2\\py\\Medium\\766-increasing-triplet-subsequence.py", "hypo_code": "class Solution(object):\n    def increasingTriplet(self, nums):\n        \n        a = b = float('inf')\n        for num in nums:\n            if num <= a:\n                a = num\n            elif num <= b:\n                b = num\n            else:\n                return True\n        return False"}
{"id": "767", "path": "output2\\py\\Medium\\767-house-robber-iii.py", "hypo_code": "class Solution(object):\n    def rob(self, root):\n        \n        def dfs(node):\n            if not node:\n                return [0, 0]\n            left = dfs(node.left)\n            right = dfs(node.right)\n            rob = node.val + left[1] + right[1]\n            notrob = max(left[0], left[1]) + max(right[0], right[1])\n            return [rob, notrob]\n        \n        res = dfs(root)\n        return max(res[0], res[1])"}
{"id": "769", "path": "output2\\py\\Medium\\769-integer-break.py", "hypo_code": "class Solution(object):\n    def integerBreak(self, n):\n        \n        dp = [i - 1 for i in range(n + 1)]\n        for i in range(2, n + 1):\n            for j in range(1, i // 2 + 1):\n                dp[i] = max(dp[i], dp[j] * dp[i - j])\n        return dp[n]"}
{"id": "770", "path": "output2\\py\\Medium\\770-top-k-frequent-elements.py", "hypo_code": "class Solution(object):\n    def topKFrequent(self, nums, k):\n         \n        \n        count = collections.Counter(nums)\n        \n        return sorted(count, key=count.get, reverse=True)[:k]"}
{"id": "772", "path": "output2\\py\\Medium\\772-count-numbers-with-unique-digits.py", "hypo_code": "class Solution(object):\n    def countNumbersWithUniqueDigits(self, n):\n        \n        dp = [0 for _ in range(n + 1)]\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] * (10 - i + 1)\n        return sum(dp)"}
{"id": "773", "path": "output2\\py\\Medium\\773-water-and-jug-problem.py", "hypo_code": "class Solution(object):\n    def canMeasureWater(self, jug1Capacity, jug2Capacity, targetCapacity):"}
{"id": "774", "path": "output2\\py\\Medium\\774-largest-divisible-subset.py", "hypo_code": "class Solution(object):\n    def largestDivisibleSubset(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        nums.sort()\n        count = [1] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and count[i] < count[j] + 1:\n                    count[i] = count[j] + 1\n\n        maxIndex = 0\n        for i in range(1, len(count)):\n            if count[i] > count[maxIndex]:\n                maxIndex = i\n\n        ret = []\n        temp = nums[maxIndex]\n        currCount = count[maxIndex]\n        for i in range(maxIndex, -1, -1):\n            if temp % nums[i] == 0 and count[i] == currCount:\n                ret.append(nums[i])\n                temp = nums[i]\n                currCount -= 1\n\n        return ret[::-1]"}
{"id": "775", "path": "output2\\py\\Medium\\775-sum-of-two-integers.py", "hypo_code": "class Solution(object):\n    def getSum(self, a, b):\n        \n        while b:\n            carry = a & b\n            a = a ^ b\n            b = carry << 1\n        return a"}
{"id": "776", "path": "output2\\py\\Medium\\776-super-pow.py", "hypo_code": "class Solution(object):\n    def superPow(self, a, b):\n        \n        res = 1\n        for i in b:\n            res = pow(res,10,1337)*pow(a,i,1337)%1337\n        return res"}
{"id": "777", "path": "output2\\py\\Medium\\777-find-k-pairs-with-smallest-sums.py", "hypo_code": "class Solution(object):\n    def kSmallestPairs(self, nums1, nums2, k):\n        \n        if not nums1 or not nums2:\n            return []\n        res = []\n        heap = [(nums1[0] + nums2[0], 0, 0)]\n        while heap and len(res) < k:\n            _, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if i + 1 < len(nums1) and (i + 1, j) not in heap:\n                heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            if j + 1 < len(nums2) and (i, j + 1) not in heap:\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        return res"}
{"id": "778", "path": "output2\\py\\Medium\\778-guess-number-higher-or-lower-ii.py", "hypo_code": "class Solution(object):\n    def getMoneyAmount(self, n):\n               \n        dp = [[0]*(n+1) for _ in range(n+1)]\n        for lo in range(n,0,-1):\n            for hi in range(lo+1,n+1):\n                dp[lo][hi] = min(x + max(dp[lo][x-1],dp[x+1][hi]) for x in range(lo,hi))\n        return dp[1][n]"}
{"id": "779", "path": "output2\\py\\Medium\\779-wiggle-subsequence.py", "hypo_code": "class Solution(object):\n    def wiggleMaxLength(self, nums):\n        \n        if len(nums) < 2:\n            return len(nums)\n        up = down = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                up = down + 1\n            elif nums[i] < nums[i-1]:\n                down = up + 1\n        return max(up, down)"}
{"id": "780", "path": "output2\\py\\Medium\\780-combination-sum-iv.py", "hypo_code": "class Solution(object):\n    def combinationSum4(self, nums, target):\n        \n        dp = [0]*(target+1)\n        dp[0] = 1\n        for i in range(1,target+1):\n            for j in range(len(nums)):\n                if i >= nums[j]:\n                    dp[i] += dp[i-nums[j]]\n        return dp[target]"}
{"id": "781", "path": "output2\\py\\Medium\\781-kth-smallest-element-in-a-sorted-matrix.py", "hypo_code": "class Solution(object):\n    def kthSmallest(self, matrix, k):\n               \n        return sorted([matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0]))])[k-1]"}
{"id": "785", "path": "output2\\py\\Medium\\785-mini-parser.py", "hypo_code": "class Solution(object):\n    def deserialize(self, s):\n        \n        stack = []\n        curr = None\n        for c in s:\n            if c == '[':\n                if curr != None:\n                    stack.append(curr)\n                curr = NestedInteger()\n            elif c == ']':\n                if len(stack) > 0:\n                    top = stack.pop()\n                    top.add(curr)\n                    curr = top\n            elif c == ',':\n                continue\n            else:\n                if curr == None:\n                    curr = NestedInteger()\n                if curr.isInteger():\n                    curr.setInteger(curr.getInteger() * 10 + int(c))\n                else:\n                    curr.add(NestedInteger(int(c)))\n        if curr != None:\n            return curr\n        return stack[0]"}
{"id": "786", "path": "output2\\py\\Medium\\786-lexicographical-numbers.py", "hypo_code": "class Solution(object):\n    def lexicalOrder(self, n):\n               \n        return sorted([i for i in range(1,n+1)],key=lambda x:str(x))"}
{"id": "787", "path": "output2\\py\\Medium\\787-longest-absolute-file-path.py", "hypo_code": "class Solution(object):\n    def lengthLongestPath(self, input):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        stack = []\n        maxLen = 0\n        for s in input.split('\\n'):\n            currLen = len(s) - s.count('\\t')\n            while len(stack) > currLen:\n                stack.pop()\n            if '.' in s:\n                maxLen = max(maxLen, sum([len(x) for x in stack]) + len(stack) + len(s) - s.count('\\t'))\n            else:\n                stack.append(s)\n        return maxLen"}
{"id": "788", "path": "output2\\py\\Medium\\788-elimination-game.py", "hypo_code": "class Solution(object):\n    def lastRemaining(self, n):\n              \n        return 1 if n==1 else 2*(n/2+1-self.lastRemaining(n/2))"}
{"id": "789", "path": "output2\\py\\Medium\\789-utf-8-validation.py", "hypo_code": "class Solution(object):\n    def validUtf8(self, data):\n               \n        def check(data, i, n):\n            if i + n > len(data):\n                return False\n            for j in range(i+1, i+n):\n                if data[j] >> 6 != 0b10:\n                    return False\n            return True\n        \n        i = 0\n        while i < len(data):\n            if data[i] >> 7 == 0:\n                i += 1\n            elif data[i] >> 5 == 0b110:\n                if not check(data, i, 2):\n                    return False\n                i += 2\n            elif data[i] >> 4 == 0b1110:\n                if not check(data, i, 3):\n                    return False\n                i += 3\n            elif data[i] >> 3 == 0b11110:\n                if not check(data, i, 4):\n                    return False\n                i += 4\n            else:\n                return False\n        return True"}
{"id": "790", "path": "output2\\py\\Medium\\790-decode-string.py", "hypo_code": "class Solution(object):\n    def decodeString(self, s):\n        \n        stack = []\n        for c in s:\n            if c == ']':\n                tmp = ''\n                while stack[-1] != '[':\n                    tmp = stack.pop() + tmp\n                stack.pop()\n                num = ''\n                while stack and stack[-1].isdigit():\n                    num = stack.pop() + num\n                stack.append(int(num) * tmp)\n            else:\n                stack.append(c)\n        return ''.join(stack)"}
{"id": "791", "path": "output2\\py\\Medium\\791-longest-substring-with-at-least-k-repeating-characters.py", "hypo_code": "class Solution(object):\n    def longestSubstring(self, s, k):\n        \n        res = 0\n        for i in range(1, 27):\n            l, r = 0, 0\n            cnt = [0] * 26\n            total = 0\n            less = 0\n            while r < len(s):\n                cnt[ord(s[r]) - ord('a')] += 1\n                if cnt[ord(s[r]) - ord('a')] == 1:\n                    total += 1\n                    less += 1\n                if cnt[ord(s[r]) - ord('a')] == k:\n                    less -= 1\n                while total > i:\n                    cnt[ord(s[l]) - ord('a')] -= 1\n                    if cnt[ord(s[l]) - ord('a')] == k - 1:\n                        less += 1\n                    if cnt[ord(s[l]) - ord('a')] == 0:\n                        total -= 1\n                        less -= 1\n                    l += 1\n                if less == 0:\n                    res = max(res, r - l + 1)\n                r += 1\n        return res"}
{"id": "792", "path": "output2\\py\\Medium\\792-rotate-function.py", "hypo_code": "class Solution(object):\n    def maxRotateFunction(self, nums):\n        \n        res = 0\n        for i in range(len(nums)):\n            res = max(res,sum([nums[j]*j for j in range(len(nums))]))\n            nums = [nums[-1]]+nums[:-1]\n        return res"}
{"id": "793", "path": "output2\\py\\Medium\\793-integer-replacement.py", "hypo_code": "class Solution(object):\n    def integerReplacement(self, n):\n        \n        res = 0\n        while n != 1:\n            if n % 2 == 0:\n                n /= 2\n            elif n == 3 or n % 4 == 1:\n                n -= 1\n            else:\n                n += 1\n            res += 1\n        return res"}
{"id": "795", "path": "output2\\py\\Medium\\795-evaluate-division.py", "hypo_code": "class Solution(object):\n    def calcEquation(self, equations, values, queries):\n                    \n        def dfs(graph,visited,src,dest):\n            if src not in graph:\n                return -1.0\n            if src == dest:\n                return 1.0\n            visited.add(src)\n            for nei in graph[src]:\n                if nei not in visited:\n                    res = dfs(graph,visited,nei,dest)\n                    if res != -1.0:\n                        return res*graph[src][nei]\n            return -1.0\n        graph = {}\n        for i in range(len(equations)):\n            src,dest = equations[i]\n            if src not in graph:\n                graph[src] = {}\n            if dest not in graph:\n                graph[dest] = {}\n            graph[src][dest] = values[i]\n            graph[dest][src] = 1/values[i]\n        res = []\n        for src,dest in queries:\n            res.append(dfs(graph,set(),src,dest))\n        return res"}
{"id": "796", "path": "output2\\py\\Medium\\796-nth-digit.py", "hypo_code": "class Solution(object):\n    def findNthDigit(self, n):\n        \n        res = 0\n        while n != 1:\n            if n % 2 == 0:\n                n /= 2\n            elif n == 3 or n % 4 == 1:\n                n -= 1\n            else:\n                n += 1\n            res += 1\n        return res"}
{"id": "797", "path": "output2\\py\\Medium\\797-remove-k-digits.py", "hypo_code": "class Solution(object):\n    def removeKdigits(self, num, k):\n        \n        res = []\n        for i, c in enumerate(num):\n            while res and c < res[-1] and num.find(res[-1], i) != -1:\n                res.pop()\n            res.append(c)\n        return \"\".join(res[:len(res)-k]).lstrip(\"0\") or \"0\""}
{"id": "798", "path": "output2\\py\\Medium\\798-queue-reconstruction-by-height.py", "hypo_code": "class Solution(object):\n    def reconstructQueue(self, people):\n        \n        people.sort(key=lambda x:(-x[0],x[1]))\n        res = []\n        for p in people:\n            res.insert(p[1],p)\n        return res"}
{"id": "799", "path": "output2\\py\\Medium\\799-arithmetic-slices.py", "hypo_code": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \n        res = 0\n        dp = [0]*len(nums)\n        for i in range(2,len(nums)):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n                res += dp[i]\n        return res"}
{"id": "800", "path": "output2\\py\\Medium\\800-partition-equal-subset-sum.py", "hypo_code": "class Solution(object):\n    def canPartition(self, nums):\n        \n        total = sum(nums)\n        if total % 2 == 1:\n            return False\n        target = total // 2\n        dp = [False] * (target + 1)\n        dp[0] = True\n        for num in nums:\n            for i in range(target, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n        return dp[target]"}
{"id": "801", "path": "output2\\py\\Medium\\801-pacific-atlantic-water-flow.py", "hypo_code": "class Solution(object):\n    def pacificAtlantic(self, heights):\n        \n        if not heights or not heights[0]:\n            return []\n        m, n = len(heights), len(heights[0])\n        pacific = [[False] * n for _ in range(m)]\n        atlantic = [[False] * n for _ in range(m)]\n        for i in range(m):\n            self.dfs(heights, pacific, i, 0)\n            self.dfs(heights, atlantic, i, n - 1)\n        for j in range(n):\n            self.dfs(heights, pacific, 0, j)\n            self.dfs(heights, atlantic, m - 1, j)\n        res = []\n        for i in range(m):\n            for j in range(n):\n                if pacific[i][j] and atlantic[i][j]:\n                    res.append([i, j])\n        return res"}
{"id": "802", "path": "output2\\py\\Medium\\802-battleships-in-a-board.py", "hypo_code": "class Solution(object):\n    def countBattleships(self, board):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        count = 0\n        for row in range(len(board)):\n            for col in range(len(board[0])):\n                if board[row][col] == 'X' and (row == 0 or board[row-1][col] == '.') and (col == 0 or board[row][col-1] == '.'):\n                    count += 1\n\n        return count"}
{"id": "803", "path": "output2\\py\\Medium\\803-maximum-xor-of-two-numbers-in-an-array.py", "hypo_code": "class Solution(object):\n    def findMaximumXOR(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        maxResult = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask = mask | (1 << i)\n            s = set()\n            for num in nums:\n                s.add(num & mask)\n\n            temp = maxResult | (1 << i)\n            for prefix in s:\n                if temp ^ prefix in s:\n                    maxResult = temp\n                    break\n\n        return maxResult"}
{"id": "804", "path": "output2\\py\\Medium\\804-reconstruct-original-digits-from-english.py", "hypo_code": "class Solution(object):\n    def originalDigits(self, s):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        count = collections.Counter(s)\n        ret = []\n        ret.append(count['z'])\n        ret.append(count['o'] - count['z'] - count['w'] - count['u'])\n        ret.append(count['w'])\n        ret.append(count['h'] - count['g'])\n        ret.append(count['u'])\n        ret.append(count['f'] - count['u'])\n        ret.append(count['x'])\n        ret.append(count['s'] - count['x'])\n        ret.append(count['g'])\n        ret.append(count['i'] - count['x'] - count['g'] - count['f'] + count['u'])\n\n        return ''.join(str(digit) * count for digit, count in enumerate(ret))"}
{"id": "805", "path": "output2\\py\\Medium\\805-longest-repeating-character-replacement.py", "hypo_code": "class Solution(object):\n    def characterReplacement(self, s, k):\n         \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        maxLength = 0\n        for i in range(len(s)):\n            maxCount = 0\n            for j in range(i, len(s)):\n                if s[j] == s[i]:\n                    maxCount += 1\n                elif k > 0:\n                    maxCount += 1\n                    k -= 1\n                else:\n                    break\n\n            maxLength = max(maxLength, maxCount)\n\n        return maxLength"}
{"id": "807", "path": "output2\\py\\Medium\\807-n-ary-tree-level-order-traversal.py", "hypo_code": "class Solution(object):\n    def levelOrder(self, root):\n        \n        if root is None:\n            return []\n\n        result = []\n        queue = [root]\n        while queue:\n            level = []\n            size = len(queue)\n            for i in range(size):\n                node = queue.pop(0)\n                level.append(node.val)\n                queue.extend(node.children)\n            result.append(level)\n\n        return result"}
{"id": "809", "path": "output2\\py\\Medium\\809-minimum-genetic-mutation.py", "hypo_code": "class Solution(object):\n    def minMutation(self, startGene, endGene, bank):\n              \n        if endGene not in bank:\n            return -1\n        bank = set(bank)\n        queue = collections.deque([(startGene, 0)])\n        while queue:\n            gene, step = queue.popleft()\n            if gene == endGene:\n                return step\n            for i in range(8):\n                for c in 'ACGT':\n                    new_gene = gene[:i] + c + gene[i+1:]\n                    if new_gene in bank:\n                        bank.remove(new_gene)\n                        queue.append((new_gene, step + 1))\n        return -1"}
{"id": "810", "path": "output2\\py\\Medium\\810-non-overlapping-intervals.py", "hypo_code": "class Solution(object):\n    def eraseOverlapIntervals(self, intervals):\n        \n        if not intervals:\n            return 0\n        intervals.sort(key=lambda x: x[1])\n        count = 1\n        end = intervals[0][1]\n        for i in range(1, len(intervals)):\n            if intervals[i][0] >= end:\n                count += 1\n                end = intervals[i][1]\n        return len(intervals) - count"}
{"id": "811", "path": "output2\\py\\Medium\\811-find-right-interval.py", "hypo_code": "class Solution(object):\n    def findRightInterval(self, intervals):\n        \n        res = []\n        for i in range(len(intervals)):\n            min_start = float('inf')\n            min_index = -1\n            for j in range(len(intervals)):\n                if intervals[j][0] >= intervals[i][1] and intervals[j][0] < min_start:\n                    min_start = intervals[j][0]\n                    min_index = j\n            res.append(min_index)\n        return res"}
{"id": "812", "path": "output2\\py\\Medium\\812-path-sum-iii.py", "hypo_code": "class Solution(object):\n    def pathSum(self, root, targetSum):\n        \n        if not root:\n            return 0\n        return self.pathSumFrom(root, targetSum) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)"}
{"id": "813", "path": "output2\\py\\Medium\\813-find-all-anagrams-in-a-string.py", "hypo_code": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \n        res = []\n        p_counter = collections.Counter(p)\n        s_counter = collections.Counter(s[:len(p)-1])\n        for i in range(len(p)-1,len(s)):\n            s_counter[s[i]] += 1"}
{"id": "814", "path": "output2\\py\\Medium\\814-find-all-duplicates-in-an-array.py", "hypo_code": "class Solution(object):\n    def findDuplicates(self, nums):\n         \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = []\n        for num in nums:\n            index = abs(num) - 1\n            if nums[index] < 0:\n                ret.append(abs(num))\n            else:\n                nums[index] = -nums[index]\n\n        return ret"}
{"id": "815", "path": "output2\\py\\Medium\\815-string-compression.py", "hypo_code": "class Solution(object):\n    def compress(self, chars):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        retIndex = 0\n        for i in range(len(chars)):\n            count = 1\n            while i < len(chars) - 1 and chars[i] == chars[i + 1]:\n                count += 1\n                i += 1\n\n            chars[retIndex] = chars[i]\n            retIndex += 1\n            if count > 1:\n                countStr = str(count)\n                for j in range(len(countStr)):\n                    chars[retIndex] = countStr[j]\n                    retIndex += 1\n\n        return retIndex"}
{"id": "816", "path": "output2\\py\\Medium\\816-add-two-numbers-ii.py", "hypo_code": "class Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \n        def reverse(head):\n            prev = None\n            while head:\n                next = head.next\n                head.next = prev\n                prev = head\n                head = next\n            return prev\n        l1 = reverse(l1)\n        l2 = reverse(l2)\n        carry = 0\n        dummy = ListNode(0)\n        curr = dummy\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry % 10)\n            curr = curr.next\n            carry //= 10\n        return reverse(dummy.next)"}
{"id": "817", "path": "output2\\py\\Medium\\817-number-of-boomerangs.py", "hypo_code": "class Solution(object):\n    def numberOfBoomerangs(self, points):\n        \n        res = 0\n        for i in range(len(points)):\n            d = {}\n            for j in range(len(points)):\n                if i == j:\n                    continue\n                dist = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n                d[dist] = d.get(dist, 0) + 1\n            for k in d:\n                res += d[k] * (d[k] - 1)\n        return res"}
{"id": "819", "path": "output2\\py\\Medium\\819-delete-node-in-a-bst.py", "hypo_code": "class Solution(object):\n    def deleteNode(self, root, key):\n        \n        if not root:\n            return root\n        if root.val == key:\n            if not root.left:\n                return root.right\n            if not root.right:\n                return root.left\n            node = root.right\n            while node.left:\n                node = node.left\n            root.val = node.val\n            root.right = self.deleteNode(root.right, node.val)\n        elif root.val < key:\n            root.right = self.deleteNode(root.right, key)\n        else:\n            root.left = self.deleteNode(root.left, key)\n        return root"}
{"id": "820", "path": "output2\\py\\Medium\\820-sort-characters-by-frequency.py", "hypo_code": "class Solution(object):\n    def frequencySort(self, s):\n                \n        res = \"\"\n        return res"}
{"id": "821", "path": "output2\\py\\Medium\\821-minimum-number-of-arrows-to-burst-balloons.py", "hypo_code": "class Solution(object):\n    def findMinArrowShots(self, points):"}
{"id": "822", "path": "output2\\py\\Medium\\822-minimum-moves-to-equal-array-elements.py", "hypo_code": "class Solution(object):\n    def minMoves(self, nums):\n        \n        res = 0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                res += self.gcd(nums[i],nums[j])\n        return res"}
{"id": "823", "path": "output2\\py\\Medium\\823-4sum-ii.py", "hypo_code": "class Solution(object):\n    def fourSumCount(self, nums1, nums2, nums3, nums4):\n        \n        res = 0\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                for k in range(len(nums3)):\n                    for l in range(len(nums4)):\n                        if nums1[i]+nums2[j]+nums3[k]+nums4[l] == 0:\n                            res += 1\n        return res"}
{"id": "824", "path": "output2\\py\\Medium\\824-132-pattern.py", "hypo_code": "class Solution(object):\n    def find132pattern(self, nums):\n        \n        res = 0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                for k in range(j+1,len(nums)):\n                    if nums[i] < nums[k] < nums[j]:\n                        return True\n        return False"}
{"id": "825", "path": "output2\\py\\Medium\\825-circular-array-loop.py", "hypo_code": "class Solution(object):\n    def circularArrayLoop(self, nums):\n               \n        res = 0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                res += self.gcd(nums[i],nums[j])\n        return res"}
{"id": "826", "path": "output2\\py\\Medium\\826-minimum-moves-to-equal-array-elements-ii.py", "hypo_code": "class Solution(object):\n    def minMoves2(self, nums):\n        \n        res = 0\n        nums.sort()\n        median = nums[len(nums)//2]\n        for i in range(len(nums)):\n            res += abs(nums[i]-median)\n        return res"}
{"id": "827", "path": "output2\\py\\Medium\\827-can-i-win.py", "hypo_code": "class Solution(object):\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        \n        if desiredTotal <= maxChoosableInteger:\n            return True\n        if maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal:\n            return False\n        return self.helper(range(1,maxChoosableInteger+1),desiredTotal)"}
{"id": "828", "path": "output2\\py\\Medium\\828-unique-substrings-in-wraparound-string.py", "hypo_code": "class Solution(object):\n    def findSubstringInWraproundString(self, s):\n             \n        res = 0\n        return res"}
{"id": "829", "path": "output2\\py\\Medium\\829-validate-ip-address.py", "hypo_code": "class Solution(object):\n    def validIPAddress(self, queryIP):\n               \n        return res"}
{"id": "830", "path": "output2\\py\\Medium\\830-implement-rand10-using-rand7.py", "hypo_code": "class Solution(object):\n    def rand10(self):\n        \n        while True:\n            a = rand7()\n            b = rand7()\n            c = (a-1)*7+b\n            if c<=40:\n                return c%10+1"}
{"id": "831", "path": "output2\\py\\Medium\\831-matchsticks-to-square.py", "hypo_code": "class Solution(object):\n    def makesquare(self, matchsticks):\n        \n        res = 0\n        for i in range(len(matchsticks)):\n            for j in range(i+1,len(matchsticks)):\n                for k in range(j+1,len(matchsticks)):\n                    for l in range(k+1,len(matchsticks)):\n                        if matchsticks[i]+matchsticks[j]+matchsticks[k]+matchsticks[l] == 0:\n                            return True\n        return False"}
{"id": "832", "path": "output2\\py\\Medium\\832-ones-and-zeroes.py", "hypo_code": "class Solution(object):\n    def findMaxForm(self, strs, m, n):\n        \n        res = 0\n        for i in range(len(strs)):\n            for j in range(i+1,len(strs)):\n                if strs[i] == strs[j]:\n                    res += 1\n        return res"}
{"id": "833", "path": "output2\\py\\Medium\\833-heaters.py", "hypo_code": "class Solution(object):\n    def findRadius(self, houses, heaters):\n        \n        res = 0\n        for i in range(len(houses)):\n            for j in range(len(heaters)):\n                res += self.gcd(houses[i],heaters[j])\n        return res"}
{"id": "834", "path": "output2\\py\\Medium\\834-total-hamming-distance.py", "hypo_code": "class Solution(object):\n    def totalHammingDistance(self, nums):\n        \n        res = 0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                res += self.hammingDistance(nums[i],nums[j])\n        return res"}
{"id": "836", "path": "output2\\py\\Medium\\836-magical-string.py", "hypo_code": "class Solution(object):\n    def magicalString(self, n):\n               \n        res = \"\"\n        return res"}
{"id": "837", "path": "output2\\py\\Medium\\837-predict-the-winner.py", "hypo_code": "class Solution(object):\n    def predictTheWinner(self, nums):\n        \n        \n        \n        \n        \n        \n        \n\n        if len(nums) % 2 == 0:\n            return True\n        else:\n            return sum(nums) % 2 == 0"}
{"id": "838", "path": "output2\\py\\Medium\\838-non-decreasing-subsequences.py", "hypo_code": "class Solution(object):\n    def findSubsequences(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = []\n        for num in nums:\n            for i in range(len(ret)):\n                if num >= ret[i][-1]:\n                    ret.append(ret[i] + [num])\n            ret.append([num])\n\n        return [x for x in ret if len(x) > 1]"}
{"id": "839", "path": "output2\\py\\Medium\\839-target-sum.py", "hypo_code": "class Solution(object):\n    def findTargetSumWays(self, nums, target):\n           \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for num in nums:\n            for i in range(len(ret)):\n                if num >= ret[i][-1]:\n                    ret.append(ret[i] + [num])\n            ret.append([num])\n\n        return [x for x in ret if len(x) > 1]"}
{"id": "841", "path": "output2\\py\\Medium\\841-diagonal-traverse.py", "hypo_code": "class Solution(object):\n    def findDiagonalOrder(self, mat):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        result = []\n        for row in range(len(mat)):\n            for col in range(len(mat[0])):\n                if (row + col) % 2 == 0:\n                    result.append(mat[row][col])\n                else:\n                    result.insert(0, mat[row][col])\n\n        return result"}
{"id": "842", "path": "output2\\py\\Medium\\842-next-greater-element-ii.py", "hypo_code": "class Solution(object):\n    def nextGreaterElements(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = [-1] * len(nums)\n        for num in nums:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "843", "path": "output2\\py\\Medium\\843-most-frequent-subtree-sum.py", "hypo_code": "class Solution(object):\n    def findFrequentTreeSum(self, root):\n        \n        def dfs(node):\n            if node is None:\n                return 0\n\n            left = dfs(node.left)\n            right = dfs(node.right)\n            total = node.val + left + right\n            count[total] += 1\n            return total\n\n        count = collections.Counter()\n        dfs(root)\n        maxCount = max(count.values())\n        return [total for total in count if count[total] == maxCount]"}
{"id": "844", "path": "output2\\py\\Medium\\844-find-bottom-left-tree-value.py", "hypo_code": "class Solution(object):\n    def findBottomLeftValue(self, root):\n        \n        def dfs(node, level):\n            if node is None:\n                return\n            if level > self.maxLevel:\n                self.maxLevel = level\n                self.result = node.val\n            dfs(node.left, level + 1)\n            dfs(node.right, level + 1)\n\n        self.result = 0\n        self.maxLevel = 0\n        dfs(root, 1)\n        return self.result"}
{"id": "845", "path": "output2\\py\\Medium\\845-find-largest-value-in-each-tree-row.py", "hypo_code": "class Solution(object):\n    def largestValues(self, root):\n        \n        def dfs(node, level):\n            if node is None:\n                return\n            if level == len(self.result):\n                self.result.append(node.val)\n            else:\n                self.result[level] = max(self.result[level], node.val)\n            dfs(node.left, level + 1)\n            dfs(node.right, level + 1)\n\n        self.result = []\n        dfs(root, 0)\n        return self.result"}
{"id": "846", "path": "output2\\py\\Medium\\846-longest-palindromic-subsequence.py", "hypo_code": "class Solution(object):\n    def longestPalindromeSubseq(self, s):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for i in range(len(s)):\n            maxCount = 0\n            for j in range(i, len(s)):\n                if s[j] == s[i]:\n                    maxCount += 1\n                else:\n                    break\n\n            ret = max(ret, maxCount)\n\n        return ret"}
{"id": "847", "path": "output2\\py\\Medium\\847-coin-change-ii.py", "hypo_code": "class Solution(object):\n    def change(self, amount, coins):\n        \n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for i in range(coin, len(dp)):\n                dp[i] += dp[i - coin]\n\n        return dp[-1]"}
{"id": "849", "path": "output2\\py\\Medium\\849-longest-uncommon-subsequence-ii.py", "hypo_code": "class Solution(object):\n    def findLUSlength(self, strs):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for num in nums:\n            for i in range(len(ret)):\n                if num >= ret[i][-1]:\n                    ret.append(ret[i] + [num])\n            ret.append([num])\n\n        return [x for x in ret if len(x) > 1]"}
{"id": "850", "path": "output2\\py\\Medium\\850-continuous-subarray-sum.py", "hypo_code": "class Solution(object):\n    def checkSubarraySum(self, nums, k):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        sum = 0\n        for i in range(len(nums)):\n            sum += nums[i]\n            if k != 0:\n                sum = sum % k\n            if sum == 0 and i > 0:\n                return True\n            for j in range(i - 1, -1, -1):\n                sum -= nums[j]\n                if k != 0:\n                    sum = sum % k\n                if sum == 0:\n                    return True\n\n        return False"}
{"id": "851", "path": "output2\\py\\Medium\\851-longest-word-in-dictionary-through-deleting.py", "hypo_code": "class Solution(object):\n    def findLongestWord(self, s, dictionary):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        dictionary.sort(key=lambda x: (-len(x), x))\n        for word in dictionary:\n            i = 0\n            for c in s:\n                if i < len(word) and word[i] == c:\n                    i += 1\n            if i == len(word):\n                return word\n\n        return \"\""}
{"id": "852", "path": "output2\\py\\Medium\\852-contiguous-array.py", "hypo_code": "class Solution(object):\n    def findMaxLength(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        result = 0\n        hashmap = {0: -1}\n        sum = 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                sum += 1\n            else:\n                sum -= 1\n            if sum == 0:\n                result = i + 1\n            if sum in hashmap:\n                result = max(result, i - hashmap[sum])\n            else:\n                hashmap[sum] = i\n\n        return result"}
{"id": "853", "path": "output2\\py\\Medium\\853-beautiful-arrangement.py", "hypo_code": "class Solution(object):\n    def countArrangement(self, n):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        def helper(n, visited):\n            if n == 0:\n                return 1\n            result = 0\n            for i in range(1, len(visited)):\n                if not visited[i] and (i % n == 0 or n % i == 0):\n                    visited[i] = True\n                    result += helper(n - 1, visited)\n                    visited[i] = False\n            return result\n        \n        visited = [False] * (n + 1)\n        return helper(n, visited)"}
{"id": "855", "path": "output2\\py\\Medium\\855-minesweeper.py", "hypo_code": "class Solution(object):\n    def updateBoard(self, board, click):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        def check(row, col):\n            if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]):\n                return\n            if board[row][col] == 'M':\n                board[row][col] = '1'\n            elif board[row][col] == 'E':\n                board[row][col] = 'B'\n                for i in range(-1, 2):\n                    for j in range(-1, 2):\n                        if i == 0 and j == 0:\n                            continue\n                        check(row + i, col + j)\n            elif board[row][col] in '12345678':\n                board[row][col] = 'B'\n\n        row, col = click\n        if board[row][col] == 'M':\n            board[row][col] = 'X'\n        elif board[row][col] == 'E':\n            check(row, col)\n\n        return board"}
{"id": "856", "path": "output2\\py\\Medium\\856-k-diff-pairs-in-an-array.py", "hypo_code": "class Solution(object):\n    def findPairs(self, nums, k):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = []\n        for num in nums:\n            index = abs(num) - 1\n            if nums[index] < 0:\n                ret.append(abs(num))\n            else:\n                nums[index] = -nums[index]\n\n        return ret"}
{"id": "858", "path": "output2\\py\\Medium\\858-complex-number-multiplication.py", "hypo_code": "class Solution(object):\n    def complexNumberMultiply(self, num1, num2):\n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\n        r1, i1 = num1.split(\"+\")\n        r2, i2 = num2.split(\"+\")\n        r1, i1 = int(r1), int(i1[:-1])\n        r2, i2 = int(r2), int(i2[:-1])\n        r = r1 * r2 - i1 * i2\n        i = r1 * i2 + r2 * i1\n        return str(r) + \"+\" + str(i) + \"i\""}
{"id": "859", "path": "output2\\py\\Medium\\859-convert-bst-to-greater-tree.py", "hypo_code": "class Solution(object):\n    def convertBST(self, root):\n        \n        def dfs(node):\n            if node is None:\n                return\n            dfs(node.right)\n            self.sum += node.val\n            node.val = self.sum\n            dfs(node.left)\n\n        self.sum = 0\n        dfs(root)\n        return root"}
{"id": "860", "path": "output2\\py\\Medium\\860-minimum-time-difference.py", "hypo_code": "class Solution(object):\n    def findMinDifference(self, timePoints):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        def convert_to_minutes(time):\n            hours, minutes = time.split(\":\")\n            return int(hours) * 60 + int(minutes)\n\n        times = sorted(map(convert_to_minutes, timePoints))\n        times.append(times[0] + 24 * 60)\n        return min(times[i + 1] - times[i] for i in range(len(times) - 1))"}
{"id": "861", "path": "output2\\py\\Medium\\861-single-element-in-a-sorted-array.py", "hypo_code": "class Solution(object):\n    def singleNonDuplicate(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for num in nums:\n            ret ^= num\n\n        return ret"}
{"id": "862", "path": "output2\\py\\Medium\\862-01-matrix.py", "hypo_code": "class Solution(object):\n    def updateMatrix(self, mat):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        result = []\n        for row in range(len(mat)):\n            for col in range(len(mat[0])):\n                if (row + col) % 2 == 0:\n                    result.append(mat[row][col])\n                else:\n                    result.insert(0, mat[row][col])\n\n        return result"}
{"id": "863", "path": "output2\\py\\Medium\\863-number-of-provinces.py", "hypo_code": "class Solution(object):\n    def findCircleNum(self, isConnected):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        result = 0\n        for city in range(len(isConnected)):\n            for other in range(len(isConnected[0])):\n                if isConnected[city][other] == 1:\n                    result += 1\n        return result"}
{"id": "865", "path": "output2\\py\\Medium\\865-optimal-division.py", "hypo_code": "class Solution(object):\n    def optimalDivision(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        if len(nums) <= 2:\n            return \"/\".join(map(str, nums))\n        else:\n            return str(nums[0]) + \"/(\" + \"/\".join(map(str, nums[1:])) + \")\""}
{"id": "866", "path": "output2\\py\\Medium\\866-brick-wall.py", "hypo_code": "class Solution(object):\n    def leastBricks(self, wall):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = [-1] * len(nums)\n        for num in nums:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "867", "path": "output2\\py\\Medium\\867-next-greater-element-iii.py", "hypo_code": "class Solution(object):\n    def nextGreaterElement(self, n):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        if n < 10:\n            return -1\n        \n        digits = list(str(n))\n        i = len(digits) - 2\n        while i >= 0 and digits[i] >= digits[i + 1]:\n            i -= 1\n        if i == -1:\n            return -1\n        j = len(digits) - 1\n        while j > i and digits[j] <= digits[i]:\n            j -= 1\n        digits[i], digits[j] = digits[j], digits[i]\n        digits[i + 1:] = digits[i + 1:][::-1]\n        ret = int(''.join(digits))\n        return ret if ret < 2147483647 else -1"}
{"id": "869", "path": "output2\\py\\Medium\\869-subarray-sum-equals-k.py", "hypo_code": "class Solution(object):\n    def subarraySum(self, nums, k):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        result = 0\n        sum = 0\n        sum_map = {0:1}\n        for num in nums:\n            sum += num\n            result += sum_map.get(sum - k, 0)\n            sum_map[sum] = sum_map.get(sum, 0) + 1\n\n        return result"}
{"id": "870", "path": "output2\\py\\Medium\\870-array-nesting.py", "hypo_code": "class Solution(object):\n    def arrayNesting(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = []\n        for num in nums:\n            index = abs(num) - 1\n            if nums[index] < 0:\n                ret.append(abs(num))\n            else:\n                nums[index] = -nums[index]\n\n        return ret"}
{"id": "871", "path": "output2\\py\\Medium\\871-permutation-in-string.py", "hypo_code": "class Solution(object):\n    def checkInclusion(self, s1, s2):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        i = 0\n        j = 0\n        while j < len(s2):\n            if s2[j] in s1:\n                j += 1\n            else:\n                j += 1\n                i = j\n            if j - i == len(s1):\n                return True\n        return False"}
{"id": "873", "path": "output2\\py\\Medium\\873-out-of-boundary-paths.py", "hypo_code": "class Solution(object):\n    def findPaths(self, m, n, maxMove, startRow, startColumn):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for num in nums:\n            for i in range(len(ret)):\n                if num >= ret[i][-1]:\n                    ret.append(ret[i] + [num])\n            ret.append([num])\n\n        return [x for x in ret if len(x) > 1]"}
{"id": "874", "path": "output2\\py\\Medium\\874-shortest-unsorted-continuous-subarray.py", "hypo_code": "class Solution(object):\n    def findUnsortedSubarray(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = [-1] * len(nums)\n        for num in nums:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "875", "path": "output2\\py\\Medium\\875-delete-operation-for-two-strings.py", "hypo_code": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for c in word1:\n            if c in word2:\n                ret += 1\n\n        return ret"}
{"id": "877", "path": "output2\\py\\Medium\\877-fraction-addition-and-subtraction.py", "hypo_code": "class Solution(object):\n    def fractionAddition(self, expression):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for num in expression.split(\"+\"):\n            ret += num\n\n        return ret"}
{"id": "878", "path": "output2\\py\\Medium\\878-valid-square.py", "hypo_code": "class Solution(object):\n    def validSquare(self, p1, p2, p3, p4):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        def dist(p1, p2):\n            return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n\n        d = set()\n        d.add(dist(p1, p2))\n        d.add(dist(p1, p3))\n        d.add(dist(p1, p4))\n        d.add(dist(p2, p3))\n        d.add(dist(p2, p4))\n        d.add(dist(p3, p4))\n\n        return 0 not in d and len(d) == 2"}
{"id": "881", "path": "output2\\py\\Medium\\881-find-duplicate-file-in-system.py", "hypo_code": "class Solution(object):\n    def findDuplicate(self, paths):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        fileDict = {}\n        for path in paths:\n            pathList = path.split(' ')\n            for i in range(1, len(pathList)):\n                fileName, content = pathList[i].split('(')\n                if content not in fileDict:\n                    fileDict[content] = []\n                fileDict[content].append(pathList[0] + '/' + fileName)\n\n        ret = []\n        for key in fileDict:\n            if len(fileDict[key]) > 1:\n                ret.append(fileDict[key])\n\n        return ret"}
{"id": "882", "path": "output2\\py\\Medium\\882-valid-triangle-number.py", "hypo_code": "class Solution(object):\n    def triangleNumber(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        nums.sort()\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[i] + nums[j] > nums[k]:\n                        ret += 1\n\n        return ret"}
{"id": "883", "path": "output2\\py\\Medium\\883-task-scheduler.py", "hypo_code": "class Solution(object):\n    def leastInterval(self, tasks, n):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = [-1] * len(nums)\n        for num in nums:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "885", "path": "output2\\py\\Medium\\885-add-one-row-to-tree.py", "hypo_code": "class Solution(object):\n    def addOneRow(self, root, val, depth):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        if root is None:\n            return None\n\n        if depth == 1:\n            return TreeNode(val, root)\n\n        queue = [root]\n        while queue:\n            level = []\n            size = len(queue)\n            for i in range(size):\n                node = queue.pop(0)\n                level.append(node.val)\n                queue.extend(node.children)\n            result.append(level)\n\n        return result"}
{"id": "887", "path": "output2\\py\\Medium\\887-sum-of-square-numbers.py", "hypo_code": "class Solution(object):\n    def judgeSquareSum(self, c):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        low, high = 0, int(math.sqrt(c))\n        while low <= high:\n            if low ** 2 + high ** 2 == c:\n                return True\n            elif low ** 2 + high ** 2 < c:\n                low += 1\n            else:\n                high -= 1\n        return False"}
{"id": "888", "path": "output2\\py\\Medium\\888-exclusive-time-of-functions.py", "hypo_code": "class Solution(object):\n    def exclusiveTime(self, n, logs):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = [0] * n\n        stack = []\n        for log in logs:\n            functionId, type, timestamp = log.split(\":\")\n            if type == \"start\":\n                stack.append(int(timestamp))\n            else:\n                ret[int(functionId)] += int(timestamp) - stack.pop() + 1\n                if stack:\n                    ret[int(functionId)] -= int(timestamp) - stack[-1]\n\n        return ret"}
{"id": "889", "path": "output2\\py\\Medium\\889-shopping-offers.py", "hypo_code": "class Solution(object):\n    def shoppingOffers(self, price, special, needs):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = [-1] * len(nums)\n        for num in nums:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "890", "path": "output2\\py\\Medium\\890-solve-the-equation.py", "hypo_code": "class Solution(object):\n    def solveEquation(self, equation):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        maxLength = 0\n        for i in range(len(s)):\n            maxCount = 0\n            for j in range(i, len(s)):\n                if s[j] == s[i]:\n                    maxCount += 1\n                elif k > 0:\n                    maxCount += 1\n                    k -= 1\n                else:\n                    break\n\n            maxLength = max(maxLength, maxCount)"}
{"id": "892", "path": "output2\\py\\Medium\\892-maximum-length-of-pair-chain.py", "hypo_code": "class Solution(object):\n    def findLongestChain(self, pairs):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 1\n        for pair in pairs:\n            for i in range(len(ret)):\n                if pair[0] > ret[i][-1]:\n                    ret.append(ret[i] + [pair])\n            ret.append(pair)\n\n        return ret"}
{"id": "893", "path": "output2\\py\\Medium\\893-palindromic-substrings.py", "hypo_code": "class Solution(object):\n    def countSubstrings(self, s):\n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(s)):\n            ret += self.countPalindromicSubstrings(s, i, i)\n            ret += self.countPalindromicSubstrings(s, i, i + 1)\n        return ret"}
{"id": "894", "path": "output2\\py\\Medium\\894-replace-words.py", "hypo_code": "class Solution(object):\n    def replaceWords(self, dictionary, sentence):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        words = sentence.split(' ')\n        ret = ''\n        for word in words:\n            root = word\n            for d in dictionary:\n                if word.startswith(d) and len(d) < len(root):\n                    root = d\n            ret += root + ' '\n        return ret[:-1]"}
{"id": "895", "path": "output2\\py\\Medium\\895-dota2-senate.py", "hypo_code": "class Solution(object):\n    def predictPartyVictory(self, senate):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        r = 0\n        d = 0\n        for senator in senate:\n            if senator == \"R\":\n                r += 1\n            else:\n                d += 1\n\n        if r > d:\n            return \"Radiant\"\n        else:\n            return \"Dire\""}
{"id": "896", "path": "output2\\py\\Medium\\896-2-keys-keyboard.py", "hypo_code": "class Solution(object):\n    def minSteps(self, n):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for i in range(2, n + 1):\n            while n % i == 0:\n                ret += i\n                n /= i\n\n        return ret"}
{"id": "897", "path": "output2\\py\\Medium\\897-find-duplicate-subtrees.py", "hypo_code": "class Solution(object):\n    def findDuplicateSubtrees(self, root):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        def preorder(root):\n            if root is None:\n                return \"\n            left = preorder(root.left)\n            right = preorder(root.right)\n            subtree = str(root.val) + \",\" + left + \",\" + right\n            if subtree in subtrees:\n                if subtree not in ret:\n                    ret.append(subtree)\n            else:\n                subtrees.add(subtree)\n            return subtree\n\n        ret = []\n        subtrees = set()\n        preorder(root)\n        return ret"}
{"id": "898", "path": "output2\\py\\Medium\\898-maximum-binary-tree.py", "hypo_code": "class Solution(object):\n    def constructMaximumBinaryTree(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = []\n        for num in nums:\n            node = TreeNode(num)\n            while ret and ret[-1].val < num:\n                node.left = ret.pop()\n            if ret:\n                ret[-1].right = node\n            ret.append(node)\n        return ret[0]"}
{"id": "899", "path": "output2\\py\\Medium\\899-print-binary-tree.py", "hypo_code": "class Solution(object):\n    def printTree(self, root):\n        \n        def getHeight(root):\n            if root is None:\n                return 0\n            return max(getHeight(root.left), getHeight(root.right)) + 1\n\n        def fill(root, row, left, right):\n            if root is None:\n                return\n            mid = (left + right) / 2\n            result[row][mid] = str(root.val)\n            fill(root.left, row+1, left, mid-1)\n            fill(root.right, row+1, mid+1, right)\n\n        height = getHeight(root)\n        result = [[\"\"] * (2**height - 1) for _ in range(height)]\n        fill(root, 0, 0, len(result[0]) - 1)\n        return result"}
{"id": "900", "path": "output2\\py\\Medium\\900-find-k-closest-elements.py", "hypo_code": "class Solution(object):\n    def findClosestElements(self, arr, k, x):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = []\n        for num in nums:\n            index = abs(num) - 1\n            if nums[index] < 0:\n                ret.append(abs(num))\n            else:\n                nums[index] = -nums[index]\n\n        return ret"}
{"id": "901", "path": "output2\\py\\Medium\\901-split-array-into-consecutive-subsequences.py", "hypo_code": "class Solution(object):\n    def isPossible(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = []\n        for num in nums:\n            for i in range(len(ret)):\n                if num >= ret[i][-1]:\n                    ret.append(ret[i] + [num])\n            ret.append([num])\n\n        return [x for x in ret if len(x) > 1]"}
{"id": "902", "path": "output2\\py\\Medium\\902-maximum-width-of-binary-tree.py", "hypo_code": "class Solution(object):\n    def widthOfBinaryTree(self, root):\n        \n        queue = collections.deque([(root, 0)])\n        maxWidth = 0\n        while queue:\n            size = len(queue)\n            maxWidth = max(maxWidth, queue[-1][1] - queue[0][1] + 1)\n            for i in range(size):\n                node, index = queue.popleft()\n                if node.left:\n                    queue.append((node.left, index * 2))\n                if node.right:\n                    queue.append((node.right, index * 2 + 1))\n\n        return maxWidth"}
{"id": "903", "path": "output2\\py\\Medium\\903-non-decreasing-array.py", "hypo_code": "class Solution(object):\n    def checkPossibility(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = [-1] * len(nums)\n        for num in nums:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "904", "path": "output2\\py\\Medium\\904-beautiful-arrangement-ii.py", "hypo_code": "class Solution(object):\n    def constructArray(self, n, k):\n        \n        res = 0\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if abs(i-j) > res:\n                    res = abs(i-j)\n        return res"}
{"id": "905", "path": "output2\\py\\Medium\\905-trim-a-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def trimBST(self, root, low, high):\n        \n        if root:\n            if root.val < low:\n                return self.trimBST(root.right, low, high)\n            elif root.val > high:\n                return self.trimBST(root.left, low, high)\n            else:\n                root.left = self.trimBST(root.left, low, high)\n                root.right = self.trimBST(root.right, low, high)\n                return root\n        return None"}
{"id": "906", "path": "output2\\py\\Medium\\906-maximum-swap.py", "hypo_code": "class Solution(object):\n    def maximumSwap(self, num):\n        \n        res = 0\n        for i in range(len(num)):\n            for j in range(i+1,len(num)):\n                if abs(num[i]-num[j]) > res:\n                    res = abs(num[i]-num[j])\n        return res"}
{"id": "907", "path": "output2\\py\\Medium\\907-bulb-switcher-ii.py", "hypo_code": "class Solution(object):\n    def flipLights(self, n, presses):\n        \n        if n == 0:\n            return 0\n        if presses == 0:\n            return 1\n        if n == 1:\n            return 2\n        if n == 2:\n            if presses == 1:\n                return 3\n            else:\n                return 4\n        if presses == 1:\n            return 4\n        if presses == 2:\n            return 7\n        return 8"}
{"id": "908", "path": "output2\\py\\Medium\\908-number-of-longest-increasing-subsequence.py", "hypo_code": "class Solution(object):\n    def findNumberOfLIS(self, nums):\n        \n        res = 0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                for k in range(j+1,len(nums)):\n                    if nums[i] < nums[k] < nums[j]:\n                        res += 1\n        return res"}
{"id": "911", "path": "output2\\py\\Medium\\911-valid-parenthesis-string.py", "hypo_code": "class Solution(object):\n    def checkValidString(self, s):\n           \n        res = 0\n        return res"}
{"id": "912", "path": "output2\\py\\Medium\\912-redundant-connection.py", "hypo_code": "class Solution(object):\n    def findRedundantConnection(self, edges):\n        \n        res = 0\n        for i in range(len(edges)):\n            for j in range(i+1,len(edges)):\n                if edges[i] == edges[j]:\n                    res += 1\n        return res"}
{"id": "913", "path": "output2\\py\\Medium\\913-repeated-string-match.py", "hypo_code": "class Solution(object):\n    def repeatedStringMatch(self, a, b):\n        \n        res = 0\n        return res"}
{"id": "914", "path": "output2\\py\\Medium\\914-longest-univalue-path.py", "hypo_code": "class Solution(object):\n    def longestUnivaluePath(self, root):\n        \n        self.res = 0\n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            left = left + 1 if root.left and root.left.val == root.val else 0\n            right = right + 1 if root.right and root.right.val == root.val else 0\n            self.res = max(self.res,left+right)\n            return max(left,right)\n        dfs(root)\n        return self.res"}
{"id": "915", "path": "output2\\py\\Medium\\915-knight-probability-in-chessboard.py", "hypo_code": "class Solution(object):\n    def knightProbability(self, n, k, row, column):\n           \n        res = 0\n        return res"}
{"id": "917", "path": "output2\\py\\Medium\\917-top-k-frequent-words.py", "hypo_code": "class Solution(object):\n    def topKFrequent(self, words, k):\n                                \n        word_count = {}\n        for word in words:\n            if word in word_count:\n                word_count[word] += 1\n            else:\n                word_count[word] = 1\n        word_count = sorted(word_count.items(), key=lambda x: (-x[1], x[0]))\n        return [word_count[i][0] for i in range(k)]"}
{"id": "918", "path": "output2\\py\\Medium\\918-max-area-of-island.py", "hypo_code": "class Solution(object):\n    def maxAreaOfIsland(self, grid):\n           \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] == 1:\n                    if self.check(grid, i, j):\n                        ret += 1\n        return ret"}
{"id": "919", "path": "output2\\py\\Medium\\919-partition-to-k-equal-sum-subsets.py", "hypo_code": "class Solution(object):\n    def canPartitionKSubsets(self, nums, k):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(nums)):\n            for j in range(len(nums[i])):\n                if nums[i][j] == 1:\n                    if self.check(nums, i, j):\n                        ret += 1\n        return ret"}
{"id": "920", "path": "output2\\py\\Medium\\920-insert-into-a-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def insertIntoBST(self, root, val):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for num in root:\n            for i in range(len(ret)):\n                if num > val:\n                    ret[i] = val\n\n        return ret"}
{"id": "922", "path": "output2\\py\\Medium\\922-minimum-ascii-delete-sum-for-two-strings.py", "hypo_code": "class Solution(object):\n    def minimumDeleteSum(self, s1, s2):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for num in s1:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "923", "path": "output2\\py\\Medium\\923-subarray-product-less-than-k.py", "hypo_code": "class Solution(object):\n    def numSubarrayProductLessThanK(self, nums, k):\n        \n        if k <= 1:\n            return 0\n        prod = 1\n        ans = left = 0\n        for right, val in enumerate(nums):\n            prod *= val\n            while prod >= k:\n                prod /= nums[left]\n                left += 1\n            ans += right - left + 1\n        return ans"}
{"id": "924", "path": "output2\\py\\Medium\\924-best-time-to-buy-and-sell-stock-with-transaction-fee.py", "hypo_code": "class Solution(object):\n    def maxProfit(self, prices, fee):\n        \n        if len(prices) == 0:\n            return 0\n        dp = [[0 for i in range(2)] for j in range(len(prices))]\n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        for i in range(1, len(prices)):\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)\n        return dp[len(prices)-1][0]"}
{"id": "925", "path": "output2\\py\\Medium\\925-maximum-length-of-repeated-subarray.py", "hypo_code": "class Solution(object):\n    def findLength(self, nums1, nums2):\n        \n        res = 0\n        dp = [[0]*(len(nums2)+1) for _ in range(len(nums1)+1)]\n        for i in range(1,len(nums1)+1):\n            for j in range(1,len(nums2)+1):\n                if nums1[i-1] == nums2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                    res = max(res,dp[i][j])\n        return res"}
{"id": "926", "path": "output2\\py\\Medium\\926-longest-word-in-dictionary.py", "hypo_code": "class Solution(object):\n    def longestWord(self, words):\n        \n        res = \"\"\n        for word in words:\n            if len(word) > len(res) or (len(word) == len(res) and word < res):\n                if all(word[:k] in words for k in range(1, len(word))):\n                    res = word\n        return res"}
{"id": "927", "path": "output2\\py\\Medium\\927-accounts-merge.py", "hypo_code": "class Solution(object):\n    def accountsMerge(self, accounts):\n        \n        res = []\n        return res"}
{"id": "928", "path": "output2\\py\\Medium\\928-remove-comments.py", "hypo_code": "class Solution(object):\n    def removeComments(self, source):\n         \n        res = []\n        block = False\n        for line in source:\n            i = 0\n            if not block:\n                new = []\n            while i < len(line):\n                if not block and line[i:i+2] == '/*':\n                    block = True\n                    i += 1\n                elif block and line[i:i+2] == '*/':\n                    block = False\n                    i += 1\n                elif not block and line[i:i+2] == '//':\n                    break\n                elif not block:\n                    new.append(line[i])\n                i += 1\n            if new and not block:\n                res.append(''.join(new))\n        return res"}
{"id": "929", "path": "output2\\py\\Medium\\929-split-linked-list-in-parts.py", "hypo_code": "class Solution(object):\n    def splitListToParts(self, head, k):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = []\n        for i in range(len(head)):\n            for j in range(len(head[i])):\n                if head[i][j] == 1:\n                    if self.check(head, i, j):\n                        ret += 1\n        return ret"}
{"id": "932", "path": "output2\\py\\Medium\\932-asteroid-collision.py", "hypo_code": "class Solution(object):\n    def asteroidCollision(self, asteroids):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = []\n        for i in range(len(asteroids)):\n            for j in range(len(asteroids[i])):\n                if asteroids[i][j] == 1:\n                    if self.check(asteroids, i, j):\n                        ret += 1\n        return ret"}
{"id": "933", "path": "output2\\py\\Medium\\933-monotone-increasing-digits.py", "hypo_code": "class Solution(object):\n    def monotoneIncreasingDigits(self, n):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = []\n        for i in range(len(n)):\n            for j in range(len(n[i])):\n                if n[i][j] == 1:\n                    if self.check(n, i, j):\n                        ret += 1\n        return ret"}
{"id": "934", "path": "output2\\py\\Medium\\934-daily-temperatures.py", "hypo_code": "class Solution(object):\n    def dailyTemperatures(self, temperatures):"}
{"id": "935", "path": "output2\\py\\Medium\\935-delete-and-earn.py", "hypo_code": "class Solution(object):\n    def deleteAndEarn(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(nums)):\n            for j in range(len(nums[i])):\n                if nums[i][j] == 1:\n                    if self.check(nums, i, j):\n                        ret += 1\n        return ret"}
{"id": "936", "path": "output2\\py\\Medium\\936-network-delay-time.py", "hypo_code": "class Solution(object):\n    def networkDelayTime(self, times, n, k):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(times)):\n            for j in range(len(times[i])):\n                if times[i][j] == 1:\n                    if self.check(times, i, j):\n                        ret += 1\n        return ret"}
{"id": "937", "path": "output2\\py\\Medium\\937-open-the-lock.py", "hypo_code": "class Solution(object):\n    def openLock(self, deadends, target):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = -1\n        for i in range(len(deadends)):\n            for j in range(len(deadends[i])):\n                if deadends[i][j] == 1:\n                    if self.check(deadends, i, j):\n                        ret += 1\n        return ret"}
{"id": "938", "path": "output2\\py\\Medium\\938-reach-a-number.py", "hypo_code": "class Solution(object):\n    def reachNumber(self, target):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(target)):\n            for j in range(len(target[i])):\n                if target[i][j] == 1:\n                    if self.check(target, i, j):\n                        ret += 1\n        return ret"}
{"id": "939", "path": "output2\\py\\Medium\\939-pyramid-transition-matrix.py", "hypo_code": "class Solution(object):\n    def pyramidTransition(self, bottom, allowed):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = [-1] * len(bottom)\n        for num in bottom:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "940", "path": "output2\\py\\Medium\\940-partition-labels.py", "hypo_code": "class Solution(object):\n    def partitionLabels(self, s):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = []\n        for i in range(len(s)):\n            for j in range(len(s[i])):\n                if s[i][j] == 1:\n                    if self.check(s, i, j):\n                        ret += 1\n        return ret"}
{"id": "941", "path": "output2\\py\\Medium\\941-largest-plus-sign.py", "hypo_code": "class Solution(object):\n    def orderOfLargestPlusSign(self, n, mines):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(mines)):\n            for j in range(len(mines[i])):\n                if mines[i][j] == 1:\n                    if self.check(mines, i, j):\n                        ret += 1\n        return ret"}
{"id": "942", "path": "output2\\py\\Medium\\942-reorganize-string.py", "hypo_code": "class Solution(object):\n    def reorganizeString(self, s):\n        \n        ret = []\n        for i in range(len(s)):\n            for j in range(len(s[i])):\n                if s[i][j] == 1:\n                    if self.check(s, i, j):\n                        ret += 1\n        return ret"}
{"id": "943", "path": "output2\\py\\Medium\\943-max-chunks-to-make-sorted.py", "hypo_code": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for num in arr:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "944", "path": "output2\\py\\Medium\\944-global-and-local-inversions.py", "hypo_code": "class Solution(object):\n    def isIdealPermutation(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(nums)):\n            for j in range(len(nums[i])):\n                if nums[i][j] == 1:\n                    if self.check(nums, i, j):\n                        ret += 1\n        return ret"}
{"id": "945", "path": "output2\\py\\Medium\\945-swap-adjacent-in-lr-string.py", "hypo_code": "class Solution(object):\n    def canTransform(self, start, end):\n          \n        res = 0\n        return res"}
{"id": "946", "path": "output2\\py\\Medium\\946-k-th-symbol-in-grammar.py", "hypo_code": "class Solution(object):\n    def kthGrammar(self, n, k):\n               \n        if n==1:\n            return 0\n        if k%2==0:\n            return 1-self.kthGrammar(n-1,k//2)\n        else:\n            return self.kthGrammar(n-1,(k+1)//2)"}
{"id": "947", "path": "output2\\py\\Medium\\947-rabbits-in-forest.py", "hypo_code": "class Solution(object):\n    def numRabbits(self, answers):\n        \n        if not answers:\n            return 0\n        count = collections.Counter(answers)\n        res = 0\n        for key, value in count.items():\n            res += (value + key) // (key + 1) * (key + 1)\n        return res"}
{"id": "948", "path": "output2\\py\\Medium\\948-letter-case-permutation.py", "hypo_code": "class Solution(object):\n    def letterCasePermutation(self, s):\n        \n        res = [s]\n        for i in range(len(s)):\n            if s[i].isalpha():\n                res += [s[:i] + s[i].swapcase() + s[i+1:] for s in res]\n        return res"}
{"id": "949", "path": "output2\\py\\Medium\\949-is-graph-bipartite.py", "hypo_code": "class Solution(object):\n    def isBipartite(self, graph):\n               \n        color = {}\n        for node in range(len(graph)):\n            if node not in color:\n                stack = [node]\n                color[node] = 0\n                while stack:\n                    node = stack.pop()\n                    for neighbor in graph[node]:\n                        if neighbor not in color:\n                            stack.append(neighbor)\n                            color[neighbor] = color[node] ^ 1\n                        elif color[neighbor] == color[node]:\n                            return False\n        return True"}
{"id": "950", "path": "output2\\py\\Medium\\950-k-th-smallest-prime-fraction.py", "hypo_code": "class Solution(object):\n    def kthSmallestPrimeFraction(self, arr, k):\n              \n        return sorted([arr[i]/arr[j] for i in range(len(arr)) for j in range(len(arr))])[k-1]"}
{"id": "951", "path": "output2\\py\\Medium\\951-cheapest-flights-within-k-stops.py", "hypo_code": "class Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, k):\n               \n        graph = collections.defaultdict(dict)\n        for u, v, w in flights:\n            graph[u][v] = w\n        heap = [(0, src, k+1)]\n        while heap:\n            price, node, stops = heapq.heappop(heap)\n            if node == dst:\n                return price\n            if stops > 0:\n                for nei in graph[node]:\n                    heapq.heappush(heap, (price+graph[node][nei], nei, stops-1))\n        return -1"}
{"id": "952", "path": "output2\\py\\Medium\\952-rotated-digits.py", "hypo_code": "class Solution(object):\n    def rotatedDigits(self, n):\n        \n        count = 0\n        for i in range(1, n+1):\n            if self.isValid(i):\n                count += 1\n        return count"}
{"id": "953", "path": "output2\\py\\Medium\\953-escape-the-ghosts.py", "hypo_code": "class Solution(object):\n    def escapeGhosts(self, ghosts, target):\n        \n        if len(ghosts) == 0:\n            return True\n        distance = abs(target[0]) + abs(target[1])\n        for ghost in ghosts:\n            if abs(ghost[0] - target[0]) + abs(ghost[1] - target[1]) <= distance:\n                return False\n        return True"}
{"id": "954", "path": "output2\\py\\Medium\\954-domino-and-tromino-tiling.py", "hypo_code": "class Solution(object):\n    def numTilings(self, n):\n               \n        if n==1:\n            return 1\n        if n==2:\n            return 2\n        if n==3:\n            return 5\n        dp=[0]*(n+1)\n        dp[1]=1\n        dp[2]=2\n        dp[3]=5\n        for i in range(4,n+1):\n            dp[i]=(2*dp[i-1]+dp[i-3])%1000000007\n        return dp[n]"}
{"id": "955", "path": "output2\\py\\Medium\\955-custom-sort-string.py", "hypo_code": "class Solution(object):\n    def customSortString(self, order, s):\n               \n        res = \"\"\n        for i in range(len(order)):\n            for j in range(len(s)):\n                if order[i] == s[j]:\n                    res += order[i]\n        for i in range(len(s)):\n            if s[i] not in res:\n                res += s[i]\n        return res"}
{"id": "956", "path": "output2\\py\\Medium\\956-number-of-matching-subsequences.py", "hypo_code": "class Solution(object):\n    def numMatchingSubseq(self, s, words):\n                               \n        res = 0\n        for word in words:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                res += 1\n        return res"}
{"id": "957", "path": "output2\\py\\Medium\\957-valid-tic-tac-toe-state.py", "hypo_code": "class Solution(object):\n    def validTicTacToe(self, board):\n        \n        \n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        for i in range(9):\n            col = [board[j][i] for j in range(9)]\n            if not self.isValid(col):\n                return False\n        \n        for i in range(3):\n            for j in range(3):\n                box = [board[m][n] for m in range(3*i,3*i+3) for n in range(3*j,3*j+3)]\n                if not self.isValid(box):\n                    return False\n        return True"}
{"id": "958", "path": "output2\\py\\Medium\\958-number-of-subarrays-with-bounded-maximum.py", "hypo_code": "class Solution(object):\n    def numSubarrayBoundedMax(self, nums, left, right):\n        \n        res = 0\n        for i in range(len(nums)):\n            for j in range(i,len(nums)):\n                if max(nums[i:j+1]) >= left and max(nums[i:j+1]) <= right:\n                    res += 1\n        return res"}
{"id": "959", "path": "output2\\py\\Medium\\959-all-paths-from-source-to-target.py", "hypo_code": "class Solution(object):\n    def allPathsSourceTarget(self, graph):\n        \n        res = []\n        self.dfs(graph,0,[0],res)\n        return res"}
{"id": "960", "path": "output2\\py\\Medium\\960-champagne-tower.py", "hypo_code": "class Solution(object):\n    def champagneTower(self, poured, query_row, query_glass):\n        \n        dp = [[0.0] * 101 for _ in range(101)]\n        dp[0][0] = poured\n        for i in range(query_row + 1):\n            for j in range(i + 1):\n                q = (dp[i][j] - 1.0) / 2.0\n                if q > 0:\n                    dp[i + 1][j] += q\n                    dp[i + 1][j + 1] += q\n        return min(1, dp[query_row][query_glass])"}
{"id": "961", "path": "output2\\py\\Medium\\961-find-eventual-safe-states.py", "hypo_code": "class Solution(object):\n    def eventualSafeNodes(self, graph):\n        \n        res = []\n        for i in range(len(graph)):\n            if self.isSafe(graph,i):\n                res.append(i)\n        return res"}
{"id": "962", "path": "output2\\py\\Medium\\962-max-increase-to-keep-city-skyline.py", "hypo_code": "class Solution(object):\n    def maxIncreaseKeepingSkyline(self, grid):\n        \n        res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                res += self.getIncrease(grid,i,j)\n        return res"}
{"id": "963", "path": "output2\\py\\Medium\\963-soup-servings.py", "hypo_code": "class Solution(object):\n    def soupServings(self, n):\n        \n        if n > 4800:\n            return 1.0\n        memo = {}\n        def dp(a, b):\n            if a <= 0 and b <= 0:\n                return 0.5\n            if a <= 0:\n                return 1.0\n            if b <= 0:\n                return 0.0\n            if (a, b) not in memo:\n                memo[(a, b)] = 0.25 * (dp(a-100, b) + dp(a-75, b-25) + dp(a-50, b-50) + dp(a-25, b-75))\n            return memo[(a, b)]\n        return dp(n, n)"}
{"id": "964", "path": "output2\\py\\Medium\\964-expressive-words.py", "hypo_code": "class Solution(object):\n    def expressiveWords(self, s, words):\n        \n        res = 0\n        for word in words:\n            i = 0\n            for c in s:\n                if i < len(word) and c == word[i]:\n                    i += 1\n            if i == len(word):\n                res += 1\n        return res"}
{"id": "965", "path": "output2\\py\\Medium\\965-subdomain-visit-count.py", "hypo_code": "class Solution(object):\n    def subdomainVisits(self, cpdomains):\n               \n        res = []\n        return res"}
{"id": "966", "path": "output2\\py\\Medium\\966-largest-sum-of-averages.py", "hypo_code": "class Solution(object):\n    def largestSumOfAverages(self, nums, k):\n        \n        res = 0\n        for i in range(len(nums)):\n            for j in range(i,len(nums)):\n                if max(nums[i:j+1]) >= left and max(nums[i:j+1]) <= right:\n                    res += 1\n        return res"}
{"id": "967", "path": "output2\\py\\Medium\\967-binary-tree-pruning.py", "hypo_code": "class Solution(object):\n    def pruneTree(self, root):\n        \n        if not root:\n            return None\n        root.left = self.pruneTree(root.left)\n        root.right = self.pruneTree(root.right)\n        if not root.left and not root.right and root.val == 0:\n            return None\n        return root"}
{"id": "968", "path": "output2\\py\\Medium\\968-ambiguous-coordinates.py", "hypo_code": "class Solution(object):\n    def ambiguousCoordinates(self, s):\n        \n        res = []\n        for i in range(2, len(s) - 1):\n            left = self.getValid(s[1:i])\n            right = self.getValid(s[i:-1])\n            for l in left:\n                for r in right:\n                    res.append(\"(\" + l + \", \" + r + \")\")\n        return res"}
{"id": "969", "path": "output2\\py\\Medium\\969-linked-list-components.py", "hypo_code": "class Solution(object):\n    def numComponents(self, head, nums):\n        \n        nums = set(nums)\n        res = 0\n        while head:\n            if head.val in nums and (not head.next or head.next.val not in nums):\n                res += 1\n            head = head.next\n        return res"}
{"id": "970", "path": "output2\\py\\Medium\\970-short-encoding-of-words.py", "hypo_code": "class Solution(object):\n    def minimumLengthEncoding(self, words):\n                                                                          \n        words = sorted(words, key=len, reverse=True)\n        res = set(words)\n        for word in words:\n            for i in range(1, len(word)):\n                res.discard(word[i:])\n        return sum(len(word) + 1 for word in res)"}
{"id": "971", "path": "output2\\py\\Medium\\971-card-flipping-game.py", "hypo_code": "class Solution(object):\n    def flipgame(self, fronts, backs):\n        \n        good = set(range(1, 2001))\n        for f, b in zip(fronts, backs):\n            if f == b:\n                good.discard(f)\n        return min(good) if good else 0"}
{"id": "972", "path": "output2\\py\\Medium\\972-binary-trees-with-factors.py", "hypo_code": "class Solution(object):\n    def numFactoredBinaryTrees(self, arr):\n                        \n        arr.sort()\n        dp = [1] * len(arr)\n        d = {x: i for i, x in enumerate(arr)}\n        for i, x in enumerate(arr):\n            for j in range(i):\n                if x % arr[j] == 0:\n                    right = x / arr[j]\n                    if right in d:\n                        dp[i] += dp[j] * dp[d[right]]\n        return sum(dp) % (10**9 + 7)"}
{"id": "973", "path": "output2\\py\\Medium\\973-friends-of-appropriate-ages.py", "hypo_code": "class Solution(object):\n    def numFriendRequests(self, ages):\n        \n        res = 0\n        for i in range(len(ages)):\n            for j in range(len(ages)):\n                if i != j and ages[i] <= 0.5 * ages[j] + 7 or ages[i] > ages[j] or ages[i] > 100 and ages[j] < 100:\n                    res += 1\n        return res"}
{"id": "974", "path": "output2\\py\\Medium\\974-most-profit-assigning-work.py", "hypo_code": "class Solution(object):\n    def maxProfitAssignment(self, difficulty, profit, worker):\n               \n        jobs = sorted(zip(difficulty, profit))\n        jobs.append((float('inf'), 0))\n        res = i = best = 0\n        for ability in sorted(worker):\n            while ability >= jobs[i][0]:\n                best = max(best, jobs[i][1])\n                i += 1\n            res += best\n        return res"}
{"id": "975", "path": "output2\\py\\Medium\\975-masking-personal-information.py", "hypo_code": "class Solution(object):\n    def maskPII(self, s):\n               \n        if '@' in s:\n            s = s.lower()\n            name, domain = s.split('@')\n            return name[0] + '*' * 5 + name[-1] + '@' + domain\n        else:\n            s = ''.join([c for c in s if c.isdigit()])\n            if len(s) == 10:\n                return '***-***-' + s[-4:]\n            else:\n                return '+' + '*' * (len(s) - 10) + '-***-***-' + s[-4:]"}
{"id": "976", "path": "output2\\py\\Medium\\976-find-and-replace-in-string.py", "hypo_code": "class Solution(object):\n    def findReplaceString(self, s, indices, sources, targets):\n                         \n        return s"}
{"id": "977", "path": "output2\\py\\Medium\\977-image-overlap.py", "hypo_code": "class Solution(object):\n    def largestOverlap(self, img1, img2):\n        \n        res = 0\n        for i in range(len(img1)):\n            for j in range(len(img1)):\n                if img1[i][j] == 1:\n                    res = max(res, self.count(img1, img2, i, j))\n        return res"}
{"id": "978", "path": "output2\\py\\Medium\\978-new-21-game.py", "hypo_code": "class Solution(object):\n    def new21Game(self, n, k, maxPts):\n        \n        if k == 0:\n            return 1.0\n        dp = [0.0] * (k + maxPts)\n        for i in range(k, k + maxPts):\n            dp[i] = 1.0 if i <= n else 0.0\n        dp[k - 1] = 1.0 * min(n - k + 1, maxPts) / maxPts\n        for i in range(k - 2, -1, -1):\n            dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts\n        return dp[0]"}
{"id": "979", "path": "output2\\py\\Medium\\979-push-dominoes.py", "hypo_code": "class Solution(object):\n    def pushDominoes(self, dominoes):\n                                                                                                          \n        res = ''\n        for i in range(len(dominoes)):\n            if dominoes[i] == 'L':\n                res += 'L'\n            elif dominoes[i] == 'R':\n                res += 'R'\n            else:\n                if i == 0:\n                    res += '.'\n                else:\n                    if res[-1] == 'L':\n                        res += 'L'\n                    elif res[-1] == 'R':\n                        res += '.'\n                    else:\n                        res += '.'\n        return res"}
{"id": "980", "path": "output2\\py\\Medium\\980-magic-squares-in-grid.py", "hypo_code": "class Solution(object):\n    def numMagicSquaresInside(self, grid):\n               \n        if len(grid)<3 or len(grid[0])<3:\n            return 0\n        count=0\n        for i in range(len(grid)-2):\n            for j in range(len(grid[0])-2):\n                if self.isMagicSquare(grid,i,j):\n                    count+=1\n        return count"}
{"id": "981", "path": "output2\\py\\Medium\\981-keys-and-rooms.py", "hypo_code": "class Solution(object):\n    def canVisitAllRooms(self, rooms):\n              \n        visited=[False]*len(rooms)\n        visited[0]=True\n        stack=[0]\n        while stack:\n            room=stack.pop()\n            for key in rooms[room]:\n                if not visited[key]:\n                    visited[key]=True\n                    stack.append(key)\n        return all(visited)"}
{"id": "982", "path": "output2\\py\\Medium\\982-split-array-into-fibonacci-sequence.py", "hypo_code": "class Solution(object):\n    def splitIntoFibonacci(self, num):\n        \n        res = []\n        self.dfs(num, res, 0)\n        return res"}
{"id": "983", "path": "output2\\py\\Medium\\983-longest-mountain-in-array.py", "hypo_code": "class Solution(object):\n    def longestMountain(self, arr):\n        \n        if len(arr) < 3:\n            return 0\n        res = 0\n        i = 1\n        while i < len(arr) - 1:\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n                left = i - 1\n                right = i + 1\n                while left > 0 and arr[left] > arr[left - 1]:\n                    left -= 1\n                while right < len(arr) - 1 and arr[right] > arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n                i = right\n            i += 1\n        return res"}
{"id": "984", "path": "output2\\py\\Medium\\984-hand-of-straights.py", "hypo_code": "class Solution(object):\n    def isNStraightHand(self, hand, groupSize):\n             \n        if len(hand) % groupSize != 0:\n            return False\n        hand.sort()\n        while hand:\n            first = hand.pop(0)\n            for i in range(1, groupSize):\n                if first + i not in hand:\n                    return False\n                hand.remove(first + i)\n        return True"}
{"id": "985", "path": "output2\\py\\Medium\\985-shifting-letters.py", "hypo_code": "class Solution(object):\n    def shiftingLetters(self, s, shifts):\n        \n        res = \"\"\n        for i in range(len(shifts) - 2, -1, -1):\n            shifts[i] += shifts[i + 1]\n        for i in range(len(s)):\n            res += chr((ord(s[i]) - ord('a') + shifts[i]) % 26 + ord('a'))\n        return res"}
{"id": "986", "path": "output2\\py\\Medium\\986-maximize-distance-to-closest-person.py", "hypo_code": "class Solution(object):\n    def maxDistToClosest(self, seats):\n        \n        res = 0\n        left = 0\n        right = len(seats) - 1\n        while left < len(seats) and seats[left] == 0:\n            left += 1\n        while right >= 0 and seats[right] == 0:\n            right -= 1\n        res = max(res, left, len(seats) - right - 1)\n        i = left\n        while i < right:\n            if seats[i] == 1:\n                i += 1\n            else:\n                j = i + 1\n                while j < right and seats[j] == 0:\n                    j += 1\n                res = max(res, (j - i + 1) // 2)\n                i = j\n        return res"}
{"id": "987", "path": "output2\\py\\Medium\\987-loud-and-rich.py", "hypo_code": "class Solution(object):\n    def loudAndRich(self, richer, quiet):\n                                                                                                 \n        res = [0] * len(quiet)\n        for i in range(len(quiet)):\n            res[i] = self.findQuietest(richer, quiet, i)\n        return res"}
{"id": "988", "path": "output2\\py\\Medium\\988-peak-index-in-a-mountain-array.py", "hypo_code": "class Solution(object):\n    def peakIndexInMountainArray(self, arr):\n        \n        l = 0\n        r = len(arr) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if arr[mid] < arr[mid + 1]:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}
{"id": "989", "path": "output2\\py\\Medium\\989-car-fleet.py", "hypo_code": "class Solution(object):\n    def carFleet(self, target, position, speed):\n        \n        if not position:\n            return 0\n        cars = sorted(zip(position, speed))\n        times = [(target - p) / float(s) for p, s in cars]\n        res = 0\n        cur = times[-1]\n        for t in times[::-1]:\n            if t > cur:\n                res += 1\n                cur = t\n        return res"}
{"id": "991", "path": "output2\\py\\Medium\\991-score-of-parentheses.py", "hypo_code": "class Solution(object):\n    def scoreOfParentheses(self, s):\n        \n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            else:\n                if stack[-1] == '(':\n                    stack.pop()\n                    stack.append(1)\n                else:\n                    temp = 0\n                    while stack[-1] != '(':\n                        temp += stack.pop()\n                    stack.pop()\n                    stack.append(2 * temp)\n        return sum(stack)"}
{"id": "992", "path": "output2\\py\\Medium\\992-mirror-reflection.py", "hypo_code": "class Solution(object):\n    def mirrorReflection(self, p, q):\n               \n        if p == q:\n            return 1\n        elif p > q:\n            if (p/q) % 2 == 0:\n                return 2\n            else:\n                return 1\n        else:\n            if (q/p) % 2 == 0:\n                return 0\n            else:\n                return 1"}
{"id": "993", "path": "output2\\py\\Medium\\993-score-after-flipping-matrix.py", "hypo_code": "class Solution(object):\n    def matrixScore(self, grid):\n        \n        res = 0\n        for i in range(len(grid)):\n            if grid[i][0] == 0:\n                for j in range(len(grid[0])):\n                    grid[i][j] = 1 - grid[i][j]\n        for j in range(len(grid[0])):\n            count = 0\n            for i in range(len(grid)):\n                if grid[i][j] == 1:\n                    count += 1\n            if count < len(grid) - count:\n                for i in range(len(grid)):\n                    grid[i][j] = 1 - grid[i][j]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                res += grid[i][j] * 2 ** (len(grid[0]) - 1 - j)\n        return res"}
{"id": "994", "path": "output2\\py\\Medium\\994-all-nodes-distance-k-in-binary-tree.py", "hypo_code": "class Solution(object):\n    def distanceK(self, root, target, k):\n               \n        def dfs(node, parent):\n            if node:\n                node.parent = parent\n                dfs(node.left, node)\n                dfs(node.right, node)\n        dfs(root, None)\n        queue = collections.deque([(target, 0)])\n        seen = {target}\n        while queue:\n            if queue[0][1] == k:\n                return [node.val for node, d in queue]\n            node, d = queue.popleft()\n            for nei in (node.left, node.right, node.parent):\n                if nei and nei not in seen:\n                    seen.add(nei)\n                    queue.append((nei, d+1))\n        return []"}
{"id": "995", "path": "output2\\py\\Medium\\995-smallest-subtree-with-all-the-deepest-nodes.py", "hypo_code": "class Solution(object):\n    def subtreeWithAllDeepest(self, root):\n        \n        def dfs(node):\n            if not node:\n                return 0, None\n            left_depth, left_node = dfs(node.left)\n            right_depth, right_node = dfs(node.right)\n            if left_depth > right_depth:\n                return left_depth + 1, left_node\n            elif left_depth < right_depth:\n                return right_depth + 1, right_node\n            else:\n                return left_depth + 1, node\n        return dfs(root)[1]"}
{"id": "996", "path": "output2\\py\\Medium\\996-prime-palindrome.py", "hypo_code": "class Solution(object):\n    def primePalindrome(self, n):\n        \n        if n == 1:\n            return 2\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 5\n        if n == 5:\n            return 5\n        if n == 6:\n            return 7\n        if n == 7:\n            return 7\n        if n == 8:\n            return 11\n        if n == 9:\n            return 11\n        if n == 10:\n            return 11\n        if n == 11:\n            return 11\n        if n == 12:\n            return 101\n        if n == 13:\n            return 101\n        if n == 14:\n            return 101\n        if n == 15:\n            return 101\n        if n == 16:\n            return 101\n        if n == 17:\n            return 101\n        if n == 18:\n            return 101\n        if n == 19:\n            return 101\n        if n == 20:\n            return 101\n        if n == 21:\n            return 101\n        if n == 22:\n            return 101\n        if n == 23:\n            return 101\n        if n == 24:\n            return 101\n        if n == 25:\n            return 101\n        if n == 26:\n            return 101\n        if n == 27:\n            return 101\n        if n == 28:\n            return 101\n        if n == 29:\n            return 101\n        if n == 30:\n            return 101\n        if n == 31:\n            return 101\n        if n == 32:\n            return 101\n        if n == 33:\n            return 101\n        if n == 34:\n            return 101\n        if n == 35:\n            return 101\n        if n == 36:\n            return 101\n        if n == 37:\n            return 101\n        if n == 38:\n            return 101\n        if n == 39:\n            return 101\n        if n == 40:\n            return 101\n        if n == 41:\n            return 101\n        if n == 42:\n            return 101\n        if n == 43:\n            return 101  \n        if n == 44:\n            return 101"}
{"id": "997", "path": "output2\\py\\Medium\\997-reordered-power-of-2.py", "hypo_code": "class Solution(object):\n    def reorderedPowerOf2(self, n):\n                                                                                               \n        return self.reorder(n, 0, 0, [False] * 10)"}
{"id": "998", "path": "output2\\py\\Medium\\998-advantage-shuffle.py", "hypo_code": "class Solution(object):\n    def advantageCount(self, nums1, nums2):\n        \n        nums1.sort()\n        res = []\n        for num in nums2:\n            i = 0\n            while i < len(nums1) and nums1[i] <= num:\n                i += 1\n            if i == len(nums1):\n                res.append(nums1.pop(0))\n            else:\n                res.append(nums1.pop(i))\n        return res"}
{"id": "999", "path": "output2\\py\\Medium\\999-length-of-longest-fibonacci-subsequence.py", "hypo_code": "class Solution(object):\n    def lenLongestFibSubseq(self, arr):\n                        \n        res = 0\n        dp = {}\n        for i in range(len(arr)):\n            for j in range(i):\n                if arr[i] - arr[j] < arr[j] and arr[i] - arr[j] in dp:\n                    dp[arr[i], arr[j]] = dp[arr[i] - arr[j], arr[j]] + 1\n                else:\n                    dp[arr[i], arr[j]] = 2\n                res = max(res, dp[arr[i], arr[j]])\n        return res if res > 2 else 0"}
{"id": "1000", "path": "output2\\py\\Medium\\1000-walking-robot-simulation.py", "hypo_code": "class Solution(object):\n    def robotSim(self, commands, obstacles):\n                                                                                            \n        res = 0\n        x = y = 0\n        dx = 0\n        dy = 1\n        obstacles = set(map(tuple, obstacles))\n        for command in commands:\n            if command == -2:\n                dx, dy = -dy, dx\n            elif command == -1:\n                dx, dy = dy, -dx\n            else:\n                for _ in range(command):\n                    if (x + dx, y + dy) not in obstacles:\n                        x += dx\n                        y += dy\n                        res = max(res, x * x + y * y)\n        return res"}
{"id": "1001", "path": "output2\\py\\Medium\\1001-koko-eating-bananas.py", "hypo_code": "class Solution(object):\n    def minEatingSpeed(self, piles, h):\n        \n        l, r = 1, max(piles)\n        while l < r:\n            m = (l + r) // 2\n            if sum((p - 1) // m + 1 for p in piles) > h:\n                l = m + 1\n            else:\n                r = m\n        return l"}
{"id": "1002", "path": "output2\\py\\Medium\\1002-stone-game.py", "hypo_code": "class Solution(object):\n    def stoneGame(self, piles):\n         \n        return True"}
{"id": "1003", "path": "output2\\py\\Medium\\1003-decoded-string-at-index.py", "hypo_code": "class Solution(object):\n    def decodeAtIndex(self, s, k):\n        \n        stack = []\n        for c in s:\n            if c.isdigit():\n                stack.append(int(c) * stack.pop())\n            else:\n                stack.append(c)\n        while stack:\n            temp = stack.pop()\n            if isinstance(temp, int):\n                k = k % temp\n                if k == 0:\n                    k = temp\n            else:\n                if k == 1:\n                    return temp\n                k -= 1\n        return \"\""}
{"id": "1004", "path": "output2\\py\\Medium\\1004-boats-to-save-people.py", "hypo_code": "class Solution(object):\n    def numRescueBoats(self, people, limit):\n        \n        people.sort()\n        res = 0\n        i = 0\n        j = len(people) - 1\n        while i <= j:\n            if people[i] + people[j] <= limit:\n                i += 1\n            j -= 1\n            res += 1\n        return res"}
{"id": "1005", "path": "output2\\py\\Medium\\1005-spiral-matrix-iii.py", "hypo_code": "class Solution(object):\n    def spiralMatrixIII(self, rows, cols, rStart, cStart):\n        \n        res = []\n        res.append([rStart, cStart])\n        r, c = rStart, cStart\n        d = 0\n        n = 1\n        while len(res) < rows * cols:\n            for i in range(n):\n                if d == 0:\n                    c += 1\n                elif d == 1:\n                    r += 1\n                elif d == 2:\n                    c -= 1\n                else:\n                    r -= 1\n                if 0 <= r < rows and 0 <= c < cols:\n                    res.append([r, c])\n            d = (d + 1) % 4\n            if d % 2 == 0:\n                n += 1\n        return res"}
{"id": "1006", "path": "output2\\py\\Medium\\1006-possible-bipartition.py", "hypo_code": "class Solution(object):\n    def possibleBipartition(self, n, dislikes):\n        \n        if n == 0:\n            return True\n        if len(dislikes) == 0:\n            return True\n        graph = {}\n        for i in range(1, n + 1):\n            graph[i] = []\n        for dislike in dislikes:\n            graph[dislike[0]].append(dislike[1])\n            graph[dislike[1]].append(dislike[0])\n        color = {}\n        for i in range(1, n + 1):\n            color[i] = -1\n        for i in range(1, n + 1):\n            if color[i] == -1:\n                color[i] = 0\n                queue = []\n                queue.append(i)\n                while len(queue) > 0:\n                    node = queue.pop(0)\n                    for neighbor in graph[node]:\n                        if color[neighbor] == -1:\n                            color[neighbor] = 1 - color[node]\n                            queue.append(neighbor)\n                        elif color[neighbor] == color[node]:\n                            return False\n        return True"}
{"id": "1007", "path": "output2\\py\\Medium\\1007-construct-binary-tree-from-preorder-and-postorder-traversal.py", "hypo_code": "class Solution(object):\n    def constructFromPrePost(self, preorder, postorder):\n        \n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        if len(preorder) == 1:\n            return root\n        index = postorder.index(preorder[1])\n        root.left = self.constructFromPrePost(preorder[1:index+2], postorder[:index+1])\n        root.right = self.constructFromPrePost(preorder[index+2:], postorder[index+1:-1])\n        return root"}
{"id": "1008", "path": "output2\\py\\Medium\\1008-find-and-replace-pattern.py", "hypo_code": "class Solution(object):\n    def findAndReplacePattern(self, words, pattern):\n        \n        res = []\n        for word in words:\n            if self.isMatch(word, pattern):\n                res.append(word)\n        return res"}
{"id": "1009", "path": "output2\\py\\Medium\\1009-groups-of-special-equivalent-strings.py", "hypo_code": "class Solution(object):\n    def numSpecialEquivGroups(self, words):\n        \n        res = set()\n        for word in words:\n            res.add(self.getSpecialEquivalent(word))\n        return len(res)"}
{"id": "1010", "path": "output2\\py\\Medium\\1010-all-possible-full-binary-trees.py", "hypo_code": "class Solution(object):\n    def allPossibleFBT(self, n):\n        \n        if n % 2 == 0:\n            return []\n        if n == 1:\n            return [TreeNode(0)]\n        res = []\n        for i in range(1, n, 2):\n            left = self.allPossibleFBT(i)\n            right = self.allPossibleFBT(n - i - 1)\n            for l in left:\n                for r in right:\n                    root = TreeNode(0)\n                    root.left = l\n                    root.right = r\n                    res.append(root)\n        return res"}
{"id": "1011", "path": "output2\\py\\Medium\\1011-bitwise-ors-of-subarrays.py", "hypo_code": "class Solution(object):\n    def subarrayBitwiseORs(self, arr):\n        \n        res = set()\n        cur = set()\n        for a in arr:\n            cur = {a | b for b in cur} | {a}\n            res |= cur\n        return len(res)"}
{"id": "1014", "path": "output2\\py\\Medium\\1014-fruit-into-baskets.py", "hypo_code": "class Solution(object):\n    def totalFruit(self, fruits):\n               \n        res = 0\n        i = 0\n        j = 0\n        count = {}\n        while j < len(fruits):\n            count[fruits[j]] = count.get(fruits[j], 0) + 1\n            while len(count) > 2:\n                count[fruits[i]] -= 1\n                if count[fruits[i]] == 0:\n                    del count[fruits[i]]\n                i += 1\n            res = max(res, j - i + 1)\n            j += 1\n        return res"}
{"id": "1015", "path": "output2\\py\\Medium\\1015-sum-of-subarray-minimums.py", "hypo_code": "class Solution(object):\n    def sumSubarrayMins(self, arr):\n               \n        res = 0\n        for i in range(len(arr)):\n            for j in range(i, len(arr)):\n                res += min(arr[i:j+1])\n        return res % (10**9 + 7)"}
{"id": "1016", "path": "output2\\py\\Medium\\1016-snakes-and-ladders.py", "hypo_code": "class Solution(object):\n    def snakesAndLadders(self, board):\n        \n        n = len(board)\n        def get_pos(num):\n            quot, rem = divmod(num - 1, n)\n            row = n - 1 - quot\n            col = rem if row % 2 != n % 2 else n - 1 - rem\n            return row, col\n        queue = collections.deque([(1, 0)])\n        visited = set([1])\n        while queue:\n            num, moves = queue.popleft()\n            if num == n * n: return moves\n            for i in range(1, 7):\n                if num + i > n * n: break\n                r, c = get_pos(num + i)\n                next_num = board[r][c] if board[r][c] != -1 else num + i\n                if next_num not in visited:\n                    visited.add(next_num)\n                    queue.append((next_num, moves + 1))\n        return -1"}
{"id": "1017", "path": "output2\\py\\Medium\\1017-smallest-range-ii.py", "hypo_code": "class Solution(object):\n    def smallestRangeII(self, nums, k):\n        \n        nums.sort()\n        res = nums[-1] - nums[0]\n        for i in range(len(nums)-1):\n            res = min(res,max(nums[-1]-k,nums[i]+k)-min(nums[0]+k,nums[i+1]-k))\n        return res"}
{"id": "1019", "path": "output2\\py\\Medium\\1019-sort-an-array.py", "hypo_code": "class Solution(object):\n    def sortArray(self, nums):\n               \n        return sorted(nums)"}
{"id": "1020", "path": "output2\\py\\Medium\\1020-partition-array-into-disjoint-intervals.py", "hypo_code": "class Solution(object):\n    def partitionDisjoint(self, nums):\n        \n        max_left = nums[0]\n        max_all = nums[0]\n        res = 1\n        for i in range(1,len(nums)):\n            if nums[i] < max_left:\n                max_left = max_all\n                res = i + 1\n            else:\n                max_all = max(max_all,nums[i])\n        return res"}
{"id": "1021", "path": "output2\\py\\Medium\\1021-word-subsets.py", "hypo_code": "class Solution(object):\n    def wordSubsets(self, words1, words2):\n        \n        res = []\n        for i in range(len(words1)):\n            for j in range(len(words2)):\n                if words1[i] in words2[j]:\n                    res.append(words1[i])\n        return res"}
{"id": "1022", "path": "output2\\py\\Medium\\1022-maximum-sum-circular-subarray.py", "hypo_code": "class Solution(object):\n    def maxSubarraySumCircular(self, nums):\n                                                                                         \n        max_sum = nums[0]\n        min_sum = nums[0]\n        total_sum = nums[0]\n        max_res = nums[0]\n        min_res = nums[0]\n        for i in range(1,len(nums)):\n            max_sum = max(max_sum+nums[i],nums[i])\n            min_sum = min(min_sum+nums[i],nums[i])\n            total_sum += nums[i]\n            max_res = max(max_res,max_sum)\n            min_res = min(min_res,min_sum)\n        if max_res > 0:\n            return max(max_res,total_sum-min_res)\n        else:\n            return max_res"}
{"id": "1024", "path": "output2\\py\\Medium\\1024-minimum-add-to-make-parentheses-valid.py", "hypo_code": "class Solution(object):\n    def minAddToMakeValid(self, s):\n                            \n        res = 0\n        left = 0\n        for i in range(len(s)):\n            if s[i] == \"(\":\n                left += 1\n            else:\n                if left == 0:\n                    res += 1\n                else:\n                    left -= 1\n        return res + left"}
{"id": "1025", "path": "output2\\py\\Medium\\1025-3sum-with-multiplicity.py", "hypo_code": "class Solution(object):\n    def threeSumMulti(self, arr, target):\n        \n        res = 0\n        arr.sort()\n        for i in range(len(arr)):\n            left = i + 1\n            right = len(arr) - 1\n            while left < right:\n                if arr[i] + arr[left] + arr[right] == target:\n                    if arr[left] == arr[right]:\n                        res += (right - left + 1) * (right - left) / 2\n                        break\n                    else:\n                        left_count = 1\n                        right_count = 1\n                        while left < right and arr[left] == arr[left + 1]:\n                            left_count += 1\n                            left += 1\n                        while left < right and arr[right] == arr[right - 1]:\n                            right_count += 1\n                            right -= 1\n                        res += left_count * right_count\n                        left += 1\n                        right -= 1\n                elif arr[i] + arr[left] + arr[right] < target:\n                    left += 1\n                else:\n                    right -= 1\n        return res % (10 ** 9 + 7)"}
{"id": "1026", "path": "output2\\py\\Medium\\1026-flip-string-to-monotone-increasing.py", "hypo_code": "class Solution(object):\n    def minFlipsMonoIncr(self, s):\n                                          \n        res = 0\n        return res"}
{"id": "1027", "path": "output2\\py\\Medium\\1027-binary-subarrays-with-sum.py", "hypo_code": "class Solution(object):\n    def numSubarraysWithSum(self, nums, goal):\n        \n        res = 0\n        sum = 0\n        count = {}\n        for i in range(len(nums)):\n            sum += nums[i]\n            if sum == goal:\n                res += 1\n            if sum-goal in count:\n                res += count[sum-goal]\n            if sum in count:\n                count[sum] += 1\n            else:\n                count[sum] = 1\n        return res"}
{"id": "1028", "path": "output2\\py\\Medium\\1028-minimum-falling-path-sum.py", "hypo_code": "class Solution(object):\n    def minFallingPathSum(self, matrix):\n        \n        if len(matrix)==1:\n            return matrix[0][0]\n        for i in range(1,len(matrix)):\n            for j in range(len(matrix[0])):\n                if j==0:\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j+1])\n                elif j==len(matrix[0])-1:\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1])\n                else:\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1],matrix[i-1][j+1])\n        return min(matrix[-1])"}
{"id": "1029", "path": "output2\\py\\Medium\\1029-beautiful-array.py", "hypo_code": "class Solution(object):\n    def beautifulArray(self, n):\n               \n        res = [1]\n        while len(res) < n:\n            res = [2 * i - 1 for i in res] + [2 * i for i in res]\n        return [i for i in res if i <= n]"}
{"id": "1030", "path": "output2\\py\\Medium\\1030-shortest-bridge.py", "hypo_code": "class Solution(object):\n    def shortestBridge(self, grid):\n                             \n        res = 0\n        return res"}
{"id": "1031", "path": "output2\\py\\Medium\\1031-knight-dialer.py", "hypo_code": "class Solution(object):\n    def knightDialer(self, n):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for num in n:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "1032", "path": "output2\\py\\Medium\\1032-reorder-data-in-log-files.py", "hypo_code": "class Solution(object):\n    def reorderLogFiles(self, logs):\n        \n        def f(log):\n            id_, rest = log.split(\" \", 1)\n            return (0, rest, id_) if rest[0].isalpha() else (1,)\n        return sorted(logs, key=f)"}
{"id": "1033", "path": "output2\\py\\Medium\\1033-minimum-area-rectangle.py", "hypo_code": "class Solution(object):\n    def minAreaRect(self, points):\n             \n        res = float('inf')\n        points = set(map(tuple, points))\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 != x2 and y1 != y2 and (x1, y2) in points and (x2, y1) in points:\n                    res = min(res, abs(x1-x2) * abs(y1-y2))\n        return res if res != float('inf') else 0"}
{"id": "1034", "path": "output2\\py\\Medium\\1034-minimum-increment-to-make-array-unique.py", "hypo_code": "class Solution(object):\n    def minIncrementForUnique(self, nums):\n        \n        res = 0\n        nums.sort()\n        for i in range(1,len(nums)):\n            if nums[i] <= nums[i-1]:\n                res += nums[i-1] - nums[i] + 1\n                nums[i] = nums[i-1] + 1\n        return res"}
{"id": "1035", "path": "output2\\py\\Medium\\1035-validate-stack-sequences.py", "hypo_code": "class Solution(object):\n    def validateStackSequences(self, pushed, popped):\n        \n        stack = []\n        i = 0\n        for num in pushed:\n            stack.append(num)\n            while stack and stack[-1] == popped[i]:\n                stack.pop()\n                i += 1\n        return not stack"}
{"id": "1036", "path": "output2\\py\\Medium\\1036-most-stones-removed-with-same-row-or-column.py", "hypo_code": "class Solution(object):\n    def removeStones(self, stones):\n              \n        n = len(stones)\n        uf = UnionFind(n)\n        for i in range(n):\n            for j in range(i+1,n):\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\n                    uf.union(i,j)\n        return n - uf.count"}
{"id": "1037", "path": "output2\\py\\Medium\\1037-bag-of-tokens.py", "hypo_code": "class Solution(object):\n    def bagOfTokensScore(self, tokens, power):\n        \n        tokens.sort()\n        res = 0\n        score = 0\n        i = 0\n        j = len(tokens) - 1\n        while i <= j:\n            if power >= tokens[i]:\n                power -= tokens[i]\n                score += 1\n                i += 1\n                res = max(res, score)\n            elif score > 0:\n                power += tokens[j]\n                score -= 1\n                j -= 1\n            else:\n                break\n        return res"}
{"id": "1038", "path": "output2\\py\\Medium\\1038-largest-time-for-given-digits.py", "hypo_code": "class Solution(object):\n    def largestTimeFromDigits(self, arr):\n        \n        res = -1\n        for i in range(4):\n            for j in range(4):\n                if i == j:\n                    continue\n                for k in range(4):\n                    if i == k or j == k:\n                        continue\n                    l = 6 - i - j - k\n                    h = 10 * arr[i] + arr[j]\n                    m = 10 * arr[k] + arr[l]\n                    if h < 24 and m < 60:\n                        res = max(res, h * 60 + m)\n        return \"\" if res == -1 else \"{:02d}:{:02d}\".format(res / 60, res % 60)"}
{"id": "1039", "path": "output2\\py\\Medium\\1039-reveal-cards-in-increasing-order.py", "hypo_code": "class Solution(object):\n    def deckRevealedIncreasing(self, deck):\n              \n        deck.sort()\n        res = [deck.pop()]\n        while deck:\n            res = [deck.pop()] + [res.pop()] + res\n        return res"}
{"id": "1040", "path": "output2\\py\\Medium\\1040-flip-equivalent-binary-trees.py", "hypo_code": "class Solution(object):\n    def flipEquiv(self, root1, root2):\n        \n        if not root1 and not root2:\n            return True\n        if not root1 or not root2:\n            return False\n        if root1.val != root2.val:\n            return False\n        return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) or (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))"}
{"id": "1041", "path": "output2\\py\\Medium\\1041-array-of-doubled-pairs.py", "hypo_code": "class Solution(object):\n    def canReorderDoubled(self, arr):\n        \n        arr.sort()\n        count = collections.Counter(arr)\n        for x in arr:\n            if count[x] == 0:\n                continue\n            if x < 0 and x % 2 != 0:\n                return False\n            count[x] -= 1\n            count[2 * x] -= 1\n        return all(v == 0 for v in count.values())"}
{"id": "1042", "path": "output2\\py\\Medium\\1042-delete-columns-to-make-sorted-ii.py", "hypo_code": "class Solution(object):\n    def minDeletionSize(self, strs):\n        \n        res = 0\n        for i in zip(*strs):\n            if list(i) != sorted(i):\n                res += 1\n        return res"}
{"id": "1043", "path": "output2\\py\\Medium\\1043-prison-cells-after-n-days.py", "hypo_code": "class Solution(object):\n    def prisonAfterNDays(self, cells, n):\n        \n        seen = {}\n        while n > 0:\n            c = tuple(cells)\n            if c in seen:\n                n %= seen[c] - n\n            seen[c] = n\n            if n >= 1:\n                n -= 1\n                cells = [int(i > 0 and i < 7 and cells[i-1] == cells[i+1]) for i in range(8)]\n        return cells"}
{"id": "1044", "path": "output2\\py\\Medium\\1044-check-completeness-of-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def isCompleteTree(self, root):\n        \n        if not root:\n            return True\n        queue = collections.deque([root])\n        while queue:\n            node = queue.popleft()\n            if node:\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                break\n        return not any(queue)"}
{"id": "1045", "path": "output2\\py\\Medium\\1045-regions-cut-by-slashes.py", "hypo_code": "class Solution(object):\n    def regionsBySlashes(self, grid):\n                                                                         \n        res = 0\n        return res"}
{"id": "1046", "path": "output2\\py\\Medium\\1046-maximum-width-ramp.py", "hypo_code": "class Solution(object):\n    def maxWidthRamp(self, nums):\n        \n        stack = []\n        for i, num in enumerate(nums):\n            if not stack or num < nums[stack[-1]]:\n                stack.append(i)\n        res = 0\n        for i in range(len(nums) - 1, -1, -1):\n            while stack and nums[i] >= nums[stack[-1]]:\n                res = max(res, i - stack.pop())\n        return res"}
{"id": "1047", "path": "output2\\py\\Medium\\1047-minimum-area-rectangle-ii.py", "hypo_code": "class Solution(object):\n    def minAreaFreeRect(self, points):\n        \n        res = float('inf')\n        points = set(map(tuple, points))\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 != x2 and y1 != y2 and (x1, y2) in points and (x2, y1) in points:\n                    res = min(res, abs(x1-x2) * abs(y1-y2))\n        return res if res != float('inf') else 0"}
{"id": "1048", "path": "output2\\py\\Medium\\1048-vowel-spellchecker.py", "hypo_code": "class Solution(object):\n    def spellchecker(self, wordlist, queries):\n        \n        wordset = set(wordlist)\n        cap = {}\n        vowel = {}\n        for word in wordlist:\n            w_lower = word.lower()\n            if w_lower not in cap:\n                cap[w_lower] = word\n            w_novowel = re.sub('[aeiou]', '\n            if w_novowel not in vowel:\n                vowel[w_novowel] = word\n        ans = []\n        for query in queries:\n            q_lower = query.lower()\n            if query in wordset:\n                ans.append(query)\n            elif q_lower in cap:\n                ans.append(cap[q_lower])\n            else:\n                q_novowel = re.sub('[aeiou]', '\n                if q_novowel in vowel:\n                    ans.append(vowel[q_novowel])\n                else:\n                    ans.append(\"\")\n        return ans"}
{"id": "1049", "path": "output2\\py\\Medium\\1049-numbers-with-same-consecutive-differences.py", "hypo_code": "class Solution(object):\n    def numsSameConsecDiff(self, n, k):\n        \n        res = []\n        if n == 1:\n            res.append(0)\n        for i in range(1, 10):\n            self.dfs(n - 1, k, i, res)\n        return res"}
{"id": "1050", "path": "output2\\py\\Medium\\1050-pancake-sorting.py", "hypo_code": "class Solution(object):\n    def pancakeSort(self, arr):\n               \n        res = []\n        for i in range(len(arr), 1, -1):\n            j = arr.index(i)\n            arr[:j+1] = arr[:j+1][::-1]\n            res.append(j+1)\n            arr[:i] = arr[:i][::-1]\n            res.append(i)\n        return res"}
{"id": "1051", "path": "output2\\py\\Medium\\1051-powerful-integers.py", "hypo_code": "class Solution(object):\n    def powerfulIntegers(self, x, y, bound):\n        \n        res = set()\n        for i in range(20):\n            for j in range(20):\n                if x**i + y**j <= bound:\n                    res.add(x**i + y**j)\n                else:\n                    break\n        return list(res)"}
{"id": "1052", "path": "output2\\py\\Medium\\1052-flip-binary-tree-to-match-preorder-traversal.py", "hypo_code": "class Solution(object):\n    def flipMatchVoyage(self, root, voyage):\n                                        \n        res = []\n        return res"}
{"id": "1053", "path": "output2\\py\\Medium\\1053-k-closest-points-to-origin.py", "hypo_code": "class Solution(object):\n    def kClosest(self, points, k):\n        \n        points.sort(key=lambda x: x[0]**2 + x[1]**2)\n        return points[:k]"}
{"id": "1054", "path": "output2\\py\\Medium\\1054-subarray-sums-divisible-by-k.py", "hypo_code": "class Solution(object):\n    def subarraysDivByK(self, nums, k):\n                \n        res = 0\n        return res"}
{"id": "1055", "path": "output2\\py\\Medium\\1055-longest-turbulent-subarray.py", "hypo_code": "class Solution(object):\n    def maxTurbulenceSize(self, arr):\n              \n        res = 0\n        return res"}
{"id": "1056", "path": "output2\\py\\Medium\\1056-distribute-coins-in-binary-tree.py", "hypo_code": "class Solution(object):\n    def distributeCoins(self, root):\n        \n        self.res = 0\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            self.res += abs(left) + abs(right)\n            return node.val + left + right - 1\n        dfs(root)\n        return self.res"}
{"id": "1058", "path": "output2\\py\\Medium\\1058-minimum-cost-for-tickets.py", "hypo_code": "class Solution(object):\n    def mincostTickets(self, days, costs):\n        \n        dp = [0] * (days[-1] + 1)\n        for i in range(1, days[-1] + 1):\n            if i not in days:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = min(dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2])\n        return dp[-1]"}
{"id": "1059", "path": "output2\\py\\Medium\\1059-string-without-aaa-or-bbb.py", "hypo_code": "class Solution(object):\n    def strWithout3a3b(self, a, b):\n        \n        res = \"\"\n        while a > 0 or b > 0:\n            if a > b:\n                if a > 1:\n                    res += \"aa\"\n                    a -= 2\n                else:\n                    res += \"a\"\n                    a -= 1\n                if b > 0:\n                    res += \"b\"\n                    b -= 1\n            else:\n                if b > 1:\n                    res += \"bb\"\n                    b -= 2\n                else:\n                    res += \"b\"\n                    b -= 1\n                if a > 0:\n                    res += \"a\"\n                    a -= 1\n        return res"}
{"id": "1060", "path": "output2\\py\\Medium\\1060-sum-of-even-numbers-after-queries.py", "hypo_code": "class Solution(object):\n    def sumEvenAfterQueries(self, nums, queries):\n        \n        res = []\n        for i in range(len(queries)):\n            nums[queries[i][1]] += queries[i][0]\n            res.append(sum([x for x in nums if x % 2 == 0]))\n        return res"}
{"id": "1061", "path": "output2\\py\\Medium\\1061-interval-list-intersections.py", "hypo_code": "class Solution(object):\n    def intervalIntersection(self, firstList, secondList):\n        \n        res = []\n        i = 0\n        j = 0\n        while i < len(firstList) and j < len(secondList):\n            if firstList[i][0] <= secondList[j][1] and secondList[j][0] <= firstList[i][1]:\n                res.append([max(firstList[i][0], secondList[j][0]), min(firstList[i][1], secondList[j][1])])\n            if firstList[i][1] < secondList[j][1]:\n                i += 1\n            else:\n                j += 1\n        return res"}
{"id": "1062", "path": "output2\\py\\Medium\\1062-smallest-string-starting-from-leaf.py", "hypo_code": "class Solution(object):\n    def smallestFromLeaf(self, root):\n        \n        if not root:\n            return \"\"\n        if not root.left and not root.right:\n            return chr(root.val + ord('a'))\n        left = self.smallestFromLeaf(root.left)\n        right = self.smallestFromLeaf(root.right)\n        if root.left and root.right:\n            return min(left + chr(root.val + ord('a')), right + chr(root.val + ord('a')))\n        elif root.left:\n            return left + chr(root.val + ord('a'))\n        else:\n            return right + chr(root.val + ord('a'))"}
{"id": "1063", "path": "output2\\py\\Medium\\1063-satisfiability-of-equality-equations.py", "hypo_code": "class Solution(object):\n    def equationsPossible(self, equations):\n        \n        res = True\n        return res"}
{"id": "1064", "path": "output2\\py\\Medium\\1064-broken-calculator.py", "hypo_code": "class Solution(object):\n    def brokenCalc(self, startValue, target):\n        \n        res = 0\n        return res"}
{"id": "1065", "path": "output2\\py\\Medium\\1065-rotting-oranges.py", "hypo_code": "class Solution(object):\n    def orangesRotting(self, grid):\n        \n        res = 0\n        return res"}
{"id": "1066", "path": "output2\\py\\Medium\\1066-maximum-binary-tree-ii.py", "hypo_code": "class Solution(object):\n    def insertIntoMaxTree(self, root, val):\n        \n        if not root:\n            return TreeNode(val)\n        if root.val < val:\n            node = TreeNode(val)\n            node.left = root\n            return node\n        root.right = self.insertIntoMaxTree(root.right, val)\n        return root"}
{"id": "1067", "path": "output2\\py\\Medium\\1067-check-if-word-is-valid-after-substitutions.py", "hypo_code": "class Solution(object):\n    def isValid(self, s):\n        \n        res = True\n        return res"}
{"id": "1068", "path": "output2\\py\\Medium\\1068-max-consecutive-ones-iii.py", "hypo_code": "class Solution(object):\n    def longestOnes(self, nums, k):\n                       \n        res = 0\n        return res"}
{"id": "1069", "path": "output2\\py\\Medium\\1069-clumsy-factorial.py", "hypo_code": "class Solution(object):\n    def clumsy(self, n):\n        \n        res = 0\n        return res"}
{"id": "1070", "path": "output2\\py\\Medium\\1070-minimum-domino-rotations-for-equal-row.py", "hypo_code": "class Solution(object):\n    def minDominoRotations(self, tops, bottoms):\n        \n        if len(tops) == 1:\n            return 0\n        if tops[0] == bottoms[0]:\n            return self.minDominoRotationsHelper(tops, bottoms, tops[0])\n        else:\n            return min(self.minDominoRotationsHelper(tops, bottoms, tops[0]), self.minDominoRotationsHelper(tops, bottoms, bottoms[0]))"}
{"id": "1071", "path": "output2\\py\\Medium\\1071-construct-binary-search-tree-from-preorder-traversal.py", "hypo_code": "class Solution(object):\n    def bstFromPreorder(self, preorder):\n        \n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        for i in range(1, len(preorder)):\n            self.insert(root, preorder[i])\n        return root"}
{"id": "1072", "path": "output2\\py\\Medium\\1072-pairs-of-songs-with-total-durations-divisible-by-60.py", "hypo_code": "class Solution(object):\n    def numPairsDivisibleBy60(self, time):\n                                                                                \n        res = 0\n        count = [0]*60\n        for t in time:\n            res += count[(60-t%60)%60]\n            count[t%60] += 1\n        return res"}
{"id": "1073", "path": "output2\\py\\Medium\\1073-capacity-to-ship-packages-within-d-days.py", "hypo_code": "class Solution(object):\n    def shipWithinDays(self, weights, days):\n        \n        def canShip(weights, days, capacity):\n            day = 1\n            total = 0\n            for weight in weights:\n                total += weight\n                if total > capacity:\n                    day += 1\n                    total = weight\n            return day <= days\n        \n        left = max(weights)\n        right = sum(weights)\n        while left < right:\n            mid = left + (right - left) // 2\n            if canShip(weights, days, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}
{"id": "1074", "path": "output2\\py\\Medium\\1074-best-sightseeing-pair.py", "hypo_code": "class Solution(object):\n    def maxScoreSightseeingPair(self, values):\n        \n        res = 0\n        mx = values[0]\n        for i in range(1,len(values)):\n            res = max(res,mx+values[i]-i)\n            mx = max(mx,values[i]+i)\n        return res"}
{"id": "1075", "path": "output2\\py\\Medium\\1075-smallest-integer-divisible-by-k.py", "hypo_code": "class Solution(object):\n    def smallestRepunitDivByK(self, k):\n        \n        if k%2==0 or k%5==0:\n            return -1\n        res=1\n        n=1\n        while n%k!=0:\n            n=(n*10+1)%k\n            res+=1\n        return res"}
{"id": "1076", "path": "output2\\py\\Medium\\1076-binary-string-with-substrings-representing-1-to-n.py", "hypo_code": "class Solution(object):\n    def queryString(self, s, n):\n        \n        for i in range(1,n+1):\n            if bin(i)[2:] not in s:\n                return False\n        return True"}
{"id": "1077", "path": "output2\\py\\Medium\\1077-convert-to-base-2.py", "hypo_code": "class Solution(object):\n    def baseNeg2(self, n):\n        \n        if n==0:\n            return \"0\"\n        res=\"\"\n        while n!=0:\n            res=str(n%2)+res\n            n=-(n//2)\n        return res"}
{"id": "1078", "path": "output2\\py\\Medium\\1078-next-greater-node-in-linked-list.py", "hypo_code": "class Solution(object):\n    def nextLargerNodes(self, head):\n        \n        res = []\n        while head:\n            node = head.next\n            while node and node.val <= head.val:\n                node = node.next\n            res.append(node.val if node else 0)\n            head = head.next\n        return res"}
{"id": "1079", "path": "output2\\py\\Medium\\1079-number-of-enclaves.py", "hypo_code": "class Solution(object):\n    def numEnclaves(self, grid):\n        \n        m = len(grid)\n        n = len(grid[0])\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n                return\n            grid[i][j] = 0\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    res += 1\n        return res"}
{"id": "1080", "path": "output2\\py\\Medium\\1080-camelcase-matching.py", "hypo_code": "class Solution(object):\n    def camelMatch(self, queries, pattern):\n        \n        res = []\n        for query in queries:\n            i = 0\n            for c in query:\n                if i < len(pattern) and c == pattern[i]:\n                    i += 1\n                elif c.isupper():\n                    i = -1\n                    break\n            res.append(i == len(pattern))\n        return res"}
{"id": "1081", "path": "output2\\py\\Medium\\1081-video-stitching.py", "hypo_code": "class Solution(object):\n    def videoStitching(self, clips, time):\n                                                                  \n        clips.sort()\n        res, pre, cur = 0, 0, 0\n        for i, clip in enumerate(clips):\n            if clip[0] > pre:\n                res += 1\n                pre = cur\n            cur = max(cur, clip[1])\n            if cur >= time:\n                return res+1\n        return -1"}
{"id": "1082", "path": "output2\\py\\Medium\\1082-maximum-difference-between-node-and-ancestor.py", "hypo_code": "class Solution(object):\n    def maxAncestorDiff(self, root):\n        \n        self.res = 0\n        self.dfs(root, root.val, root.val)\n        return self.res"}
{"id": "1083", "path": "output2\\py\\Medium\\1083-longest-arithmetic-subsequence.py", "hypo_code": "class Solution(object):\n    def longestArithSeqLength(self, nums):\n               \n        dp = [collections.defaultdict(int) for _ in range(len(nums))]\n        res = 0\n        for i in range(1,len(nums)):\n            for j in range(i):\n                diff = nums[i]-nums[j]\n                dp[i][diff] = dp[j][diff]+1\n                res = max(res,dp[i][diff])\n        return res+1"}
{"id": "1084", "path": "output2\\py\\Medium\\1084-two-city-scheduling.py", "hypo_code": "class Solution(object):\n    def twoCitySchedCost(self, costs):\n        \n        costs.sort(key=lambda x:x[0]-x[1])\n        res = 0\n        for i in range(len(costs)//2):\n            res += costs[i][0] + costs[len(costs)-i-1][1]\n        return res"}
{"id": "1085", "path": "output2\\py\\Medium\\1085-maximum-sum-of-two-non-overlapping-subarrays.py", "hypo_code": "class Solution(object):\n    def maxSumTwoNoOverlap(self, nums, firstLen, secondLen):\n        \n        res = 0\n        dp = [0]*(len(nums)+1)\n        for i in range(1,len(nums)+1):\n            dp[i] = dp[i-1]+nums[i-1]\n        for i in range(firstLen,len(nums)+1):\n            res = max(res,dp[i]-dp[i-firstLen]+self.maxSum(dp,i-firstLen,secondLen))\n            res = max(res,dp[i]-dp[i-firstLen]+self.maxSum(dp,i,secondLen))\n        return res"}
{"id": "1086", "path": "output2\\py\\Medium\\1086-moving-stones-until-consecutive.py", "hypo_code": "class Solution(object):\n    def numMovesStones(self, a, b, c):\n        \n        a, b, c = sorted([a, b, c])\n        if b - a == 1 and c - b == 1:\n            return [0, 0]\n        if b - a <= 2 or c - b <= 2:\n            return [1, c - a - 2]\n        return [2, c - a - 2]"}
{"id": "1087", "path": "output2\\py\\Medium\\1087-coloring-a-border.py", "hypo_code": "class Solution(object):\n    def colorBorder(self, grid, row, col, color):\n        \n        m = len(grid)\n        n = len(grid[0])\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != grid[row][col]:\n                return\n            if i == 0 or i == m - 1 or j == 0 or j == n - 1 or grid[i + 1][j] != grid[row][col] or grid[i - 1][j] != grid[row][col] or grid[i][j + 1] != grid[row][col] or grid[i][j - 1] != grid[row][col]:\n                grid[i][j] = color\n            else:\n                grid[i][j] = -grid[row][col]\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        dfs(row, col)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] < 0:\n                    grid[i][j] = -grid[i][j]\n        return grid"}
{"id": "1088", "path": "output2\\py\\Medium\\1088-uncrossed-lines.py", "hypo_code": "class Solution(object):\n    def maxUncrossedLines(self, nums1, nums2):\n        \n        res = 0\n        dp = [[0]*(len(nums2)+1) for _ in range(len(nums1)+1)]\n        for i in range(1,len(nums1)+1):\n            for j in range(1,len(nums2)+1):\n                if nums1[i-1] == nums2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                    res = max(res,dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n        return res"}
{"id": "1089", "path": "output2\\py\\Medium\\1089-binary-search-tree-to-greater-sum-tree.py", "hypo_code": "class Solution(object):\n    def bstToGst(self, root):\n               \n        self.sum = 0\n        self.dfs(root)\n        return root"}
{"id": "1090", "path": "output2\\py\\Medium\\1090-minimum-score-triangulation-of-polygon.py", "hypo_code": "class Solution(object):\n    def minScoreTriangulation(self, values):\n        \n        n = len(values)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 2, n):\n                dp[i][j] = min(dp[i][k] + dp[k][j] + values[i] * values[j] * values[k] for k in range(i + 1, j))\n        return dp[0][n - 1]"}
{"id": "1091", "path": "output2\\py\\Medium\\1091-moving-stones-until-consecutive-ii.py", "hypo_code": "class Solution(object):\n    def numMovesStonesII(self, stones):\n        \n        stones.sort()\n        n = len(stones)\n        max_move = max(stones[n-1] - stones[1] - n + 2, stones[n-2] - stones[0] - n + 2)\n        min_move = n\n        i = 0\n        for j in range(n):\n            while stones[j] - stones[i] >= n:\n                i += 1\n            if j - i + 1 == n - 1 and stones[j] - stones[i] == n - 2:\n                min_move = min(min_move, 2)\n            else:\n                min_move = min(min_move, n - (j - i + 1))\n        return [min_move, max_move]"}
{"id": "1092", "path": "output2\\py\\Medium\\1092-robot-bounded-in-circle.py", "hypo_code": "class Solution(object):\n    def isRobotBounded(self, instructions):\n        \n        x = y = 0\n        dx = 0\n        dy = 1\n        for i in instructions:\n            if i == 'G':\n                x += dx\n                y += dy\n            elif i == 'L':\n                dx, dy = -dy, dx\n            else:\n                dx, dy = dy, -dx\n        return (x == 0 and y == 0) or (dx != 0 or dy != 1)"}
{"id": "1093", "path": "output2\\py\\Medium\\1093-flower-planting-with-no-adjacent.py", "hypo_code": "class Solution(object):\n    def gardenNoAdj(self, n, paths):\n        \n        res = [0] * n\n        graph = [[] for _ in range(n)]\n        for x, y in paths:\n            graph[x - 1].append(y - 1)\n            graph[y - 1].append(x - 1)\n        for i in range(n):\n            res[i] = ({1, 2, 3, 4} - {res[j] for j in graph[i]}).pop()\n        return res"}
{"id": "1094", "path": "output2\\py\\Medium\\1094-partition-array-for-maximum-sum.py", "hypo_code": "class Solution(object):\n    def maxSumAfterPartitioning(self, arr, k):\n               \n        dp = [0]*(len(arr)+1)\n        for i in range(1,len(arr)+1):\n            max_num = 0\n            for j in range(1,k+1):\n                if i-j>=0:\n                    max_num = max(max_num,arr[i-j])\n                    dp[i] = max(dp[i],dp[i-j]+max_num*j)\n        return dp[len(arr)]"}
{"id": "1096", "path": "output2\\py\\Medium\\1096-longest-string-chain.py", "hypo_code": "class Solution(object):\n    def longestStrChain(self, words):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(words)):\n            for j in range(len(words[i])):\n                if words[i][j] == 1:\n                    if self.check(words, i, j):\n                        ret += 1\n        return ret"}
{"id": "1097", "path": "output2\\py\\Medium\\1097-last-stone-weight-ii.py", "hypo_code": "class Solution(object):\n    def lastStoneWeightII(self, stones):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for num in stones:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "1098", "path": "output2\\py\\Medium\\1098-grumpy-bookstore-owner.py", "hypo_code": "class Solution(object):\n    def maxSatisfied(self, customers, grumpy, minutes):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(customers)):\n            for j in range(len(customers[i])):\n                if customers[i][j] == 1:\n                    if self.check(customers, i, j):\n                        ret += 1\n        return ret"}
{"id": "1099", "path": "output2\\py\\Medium\\1099-previous-permutation-with-one-swap.py", "hypo_code": "class Solution(object):\n    def prevPermOpt1(self, arr):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = [-1] * len(arr)\n        for num in arr:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "1100", "path": "output2\\py\\Medium\\1100-distant-barcodes.py", "hypo_code": "class Solution(object):\n    def rearrangeBarcodes(self, barcodes):\n        \n        ret = []\n        for i in range(len(barcodes)):\n            for j in range(len(barcodes[i])):\n                if barcodes[i][j] == 1:\n                    if self.check(barcodes, i, j):\n                        ret += 1\n        return ret"}
{"id": "1101", "path": "output2\\py\\Medium\\1101-lexicographically-smallest-equivalent-string.py", "hypo_code": "class Solution(object):\n    def smallestEquivalentString(self, s1, s2, baseStr):\n        \n        ret = 0\n        for num in s1:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "1103", "path": "output2\\py\\Medium\\1103-flip-columns-for-maximum-number-of-equal-rows.py", "hypo_code": "class Solution(object):\n    def maxEqualRowsAfterFlips(self, matrix):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] == 1:\n                    if self.check(matrix, i, j):\n                        ret += 1\n        return ret"}
{"id": "1104", "path": "output2\\py\\Medium\\1104-adding-two-negabinary-numbers.py", "hypo_code": "class Solution(object):\n    def addNegabinary(self, arr1, arr2):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(arr1)):\n            for j in range(len(arr1[i])):\n                if arr1[i][j] == 1:\n                    if self.check(arr1, i, j):\n                        ret += 1\n        return ret"}
{"id": "1105", "path": "output2\\py\\Medium\\1105-letter-tile-possibilities.py", "hypo_code": "class Solution(object):\n    def numTilePossibilities(self, tiles):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                if tiles[i][j] == 1:\n                    if self.check(tiles, i, j):\n                        ret += 1\n        return ret"}
{"id": "1106", "path": "output2\\py\\Medium\\1106-insufficient-nodes-in-root-to-leaf-paths.py", "hypo_code": "class Solution(object):\n    def sufficientSubset(self, root, limit):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for num in root:\n            for i in range(len(ret)):\n                if num == 1:\n                    ret[i] = 1\n\n        return ret"}
{"id": "1107", "path": "output2\\py\\Medium\\1107-smallest-subsequence-of-distinct-characters.py", "hypo_code": "class Solution(object):\n    def smallestSubsequence(self, s):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = \"\"\n        for num in s:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "1108", "path": "output2\\py\\Medium\\1108-largest-values-from-labels.py", "hypo_code": "class Solution(object):\n    def largestValsFromLabels(self, values, labels, numWanted, useLimit):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(values)):\n            for j in range(len(values[i])):\n                if values[i][j] == 1:\n                    if self.check(values, i, j):\n                        ret += 1\n        return ret"}
{"id": "1109", "path": "output2\\py\\Medium\\1109-shortest-path-in-binary-matrix.py", "hypo_code": "class Solution(object):\n    def shortestPathBinaryMatrix(self, grid):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] == 1:\n                    if self.check(grid, i, j):\n                        ret += 1\n        return ret"}
{"id": "1110", "path": "output2\\py\\Medium\\1110-statistics-from-a-large-sample.py", "hypo_code": "class Solution(object):\n    def sampleStats(self, count):\n        \n        ret = 0\n        for i in range(len(count)):\n            for j in range(len(count[i])):\n                if count[i][j] == 1:\n                    if self.check(count, i, j):\n                        ret += 1\n        return ret"}
{"id": "1111", "path": "output2\\py\\Medium\\1111-car-pooling.py", "hypo_code": "class Solution(object):\n    def carPooling(self, trips, capacity):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        ret = 0\n        for num in trips:\n            for i in range(len(ret)):\n                if num > ret[i]:\n                    ret[i] = num\n\n        return ret"}
{"id": "1112", "path": "output2\\py\\Medium\\1112-path-in-zigzag-labelled-binary-tree.py", "hypo_code": "class Solution(object):\n    def pathInZigZagTree(self, label):\n         \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ret = []\n        for i in range(len(label)):\n            for j in range(len(label[i])):\n                if label[i][j] == 1:\n                    if self.check(label, i, j):\n                        ret += 1\n        return ret"}
{"id": "1113", "path": "output2\\py\\Medium\\1113-filling-bookcase-shelves.py", "hypo_code": "class Solution(object):\n    def minHeightShelves(self, books, shelfWidth):\n        \n        dp = [0] * (len(books) + 1)\n        for i in range(1, len(books) + 1):\n            width, height = 0, 0\n            dp[i] = dp[i - 1] + books[i - 1][1]\n            for j in range(i - 1, -1, -1):\n                width += books[j][0]\n                if width > shelfWidth:\n                    break\n                height = max(height, books[j][1])\n                dp[i] = min(dp[i], dp[j] + height)\n        return dp[-1]"}
{"id": "1114", "path": "output2\\py\\Medium\\1114-corporate-flight-bookings.py", "hypo_code": "class Solution(object):\n    def corpFlightBookings(self, bookings, n):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        ans = [0] * n\n        for booking in bookings:\n            ans[booking[0] - 1] += booking[2]\n            if booking[1] < n:\n                ans[booking[1]] -= booking[2]\n        for i in range(1, n):\n            ans[i] += ans[i - 1]\n        return ans"}
{"id": "1115", "path": "output2\\py\\Medium\\1115-delete-nodes-and-return-forest.py", "hypo_code": "class Solution(object):\n    def delNodes(self, root, to_delete):\n        \n        ans = []\n        def dfs(node, is_root):\n            if not node:\n                return None\n            deleted = node.val in to_delete\n            if is_root and not deleted:\n                ans.append(node)\n            node.left = dfs(node.left, deleted)\n            node.right = dfs(node.right, deleted)\n            return None if deleted else node\n        dfs(root, True)\n        return ans"}
{"id": "1116", "path": "output2\\py\\Medium\\1116-maximum-nesting-depth-of-two-valid-parentheses-strings.py", "hypo_code": "class Solution(object):\n    def maxDepthAfterSplit(self, seq):\n        \n        \n        \n        \n        \n        \n        ans = []\n        for i in range(len(seq)):\n            ans.append(i & 1 if seq[i] == '(' else 1 - (i & 1))\n        return ans"}
{"id": "1120", "path": "output2\\py\\Medium\\1120-lowest-common-ancestor-of-deepest-leaves.py", "hypo_code": "class Solution(object):\n    def lcaDeepestLeaves(self, root):\n        \n        \n        \n        \n        \n        \n        def dfs(node, depth):\n            if not node:\n                return (None, depth)\n            left = dfs(node.left, depth + 1)\n            right = dfs(node.right, depth + 1)\n            if left[1] == right[1]:\n                return (node, left[1])\n            elif left[1] > right[1]:\n                return left\n            else:\n                return right\n        return dfs(root, 0)[0]"}
{"id": "1121", "path": "output2\\py\\Medium\\1121-longest-well-performing-interval.py", "hypo_code": "class Solution(object):\n    def longestWPI(self, hours):\n        \n        \n        \n        \n        \n        \n        ans, score = 0, 0\n        seen = {0: -1}\n        for i, hour in enumerate(hours):\n            score = score + 1 if hour > 8 else score - 1\n            if score > 0:\n                ans = max(ans, i + 1)\n            elif score - 1 in seen:\n                ans = max(ans, i - seen[score - 1])\n            if score not in seen:\n                seen[score] = i\n        return ans"}
{"id": "1122", "path": "output2\\py\\Medium\\1122-shortest-path-with-alternating-colors.py", "hypo_code": "class Solution(object):\n    def shortestAlternatingPaths(self, n, redEdges, blueEdges):\n        \n        \n        \n        \n        \n        \n        graph = [[[], []] for _ in range(n)]\n        for u, v in redEdges:\n            graph[u][0].append(v)\n        for u, v in blueEdges:\n            graph[u][1].append(v)\n        ans = [[-1, -1] for _ in range(n)]\n        queue = deque([[0, 0, 0], [0, 1, 0]])\n        while queue:\n            node, color, dist = queue.popleft()\n            if ans[node][color] == -1:\n                ans[node][color] = dist\n                for nei in graph[node][color]:\n                    queue.append([nei, 1 - color, dist + 1])\n        return [min(x, y) for x, y in ans]"}
{"id": "1123", "path": "output2\\py\\Medium\\1123-minimum-cost-tree-from-leaf-values.py", "hypo_code": "class Solution(object):\n    def mctFromLeafValues(self, arr):\n        \n        \n        \n        \n        \n        \n        ans = 0\n        while len(arr) > 1:\n            i = arr.index(min(arr))\n            ans += min(arr[i - 1:i] + arr[i + 1:i + 2]) * arr.pop(i)\n        return ans"}
{"id": "1124", "path": "output2\\py\\Medium\\1124-maximum-of-absolute-value-expression.py", "hypo_code": "class Solution(object):\n    def maxAbsValExpr(self, arr1, arr2):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        ans = 0\n        for p, q in [[1, 1], [1, -1], [-1, 1], [-1, -1]]:\n            closest = p * arr1[0] + q * arr2[0] + 0\n            for i in range(1, len(arr1)):\n                cur = p * arr1[i] + q * arr2[i] + i\n                ans = max(ans, cur - closest)\n                closest = min(closest, cur)\n        return ans"}
{"id": "1125", "path": "output2\\py\\Medium\\1125-alphabet-board-path.py", "hypo_code": "class Solution(object):\n    def alphabetBoardPath(self, target):\n        \n        \n        \n        \n        \n        \n        ans = ''\n        x, y = 0, 0\n        for c in target:\n            nx, ny = divmod(ord(c) - ord('a'), 5)\n            dx, dy = nx - x, ny - y\n            if dy < 0:\n                ans += 'L' * abs(dy)\n            if dx < 0:\n                ans += 'U' * abs(dx)\n            if dx > 0:\n                ans += 'D' * dx\n            if dy > 0:\n                ans += 'R' * dy\n            ans += '!'\n            x, y = nx, ny\n        return ans"}
{"id": "1126", "path": "output2\\py\\Medium\\1126-largest-1-bordered-square.py", "hypo_code": "class Solution(object):\n    def largest1BorderedSquare(self, grid):\n        \n        \n        \n        \n        \n        \n        ans = 0\n        rows, cols = len(grid), len(grid[0])\n        left = [[0] * cols for _ in range(rows)]\n        top = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    left[i][j] = left[i][j - 1] + 1 if j else 1\n                    top[i][j] = top[i - 1][j] + 1 if i else 1\n                    for k in range(min(left[i][j], top[i][j]), 0, -1):\n                        if top[i][j - k + 1] >= k and left[i - k + 1][j] >= k:\n                            ans = max(ans, k * k)\n                            break\n        return ans"}
{"id": "1127", "path": "output2\\py\\Medium\\1127-stone-game-ii.py", "hypo_code": "class Solution(object):\n    def stoneGameII(self, piles):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        N = len(piles)\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        for i in range(N - 1, -1, -1):\n            for M in range(N + 1):\n                stones = 0\n                for j in range(i, min(i + 2 * M, N)):\n                    stones += piles[j]\n                    dp[i][M] = max(dp[i][M], stones - dp[j + 1][max(M, j - i + 1)])\n        return dp[0][1]"}
{"id": "1128", "path": "output2\\py\\Medium\\1128-longest-common-subsequence.py", "hypo_code": "class Solution(object):\n    def longestCommonSubsequence(self, text1, text2):\n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n        dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]\n        for i, c1 in enumerate(text1):\n            for j, c2 in enumerate(text2):\n                dp[i + 1][j + 1] = 1 + dp[i][j] if c1 == c2 else max(dp[i][j + 1], dp[i + 1][j])\n        return dp[-1][-1]"}
{"id": "1129", "path": "output2\\py\\Medium\\1129-decrease-elements-to-make-array-zigzag.py", "hypo_code": "class Solution(object):\n    def movesToMakeZigzag(self, nums):\n        \n        \n        \n        \n        \n        \n        ans = [0, 0]\n        for i, num in enumerate(nums):\n            left = nums[i - 1] if i > 0 else float('inf')\n            right = nums[i + 1] if i < len(nums) - 1 else float('inf')\n            ans[i % 2] += max(0, num - min(left, right) + 1)\n        return min(ans)"}
{"id": "1130", "path": "output2\\py\\Medium\\1130-binary-tree-coloring-game.py", "hypo_code": "class Solution(object):\n    def btreeGameWinningMove(self, root, n, x):\n        \n        \n        \n        \n        \n        \n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            if node.val == x:\n                self.left = left\n                self.right = right\n            return left + right + 1\n        dfs(root)\n        return max(self.left, self.right, n - self.left - self.right - 1) > n / 2"}
{"id": "1132", "path": "output2\\py\\Medium\\1132-number-of-dice-rolls-with-target-sum.py", "hypo_code": "class Solution(object):\n    def numRollsToTarget(self, n, k, target):\n        \n        \n\t\t\n\t\t\n        dp = [[0] * (target + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(i, target + 1):\n                for l in range(1, k + 1):\n                    if j - l < 0:\n                        break\n                    dp[i][j] += dp[i - 1][j - l]\n        return dp[n][target] % (10 ** 9 + 7)"}
{"id": "1133", "path": "output2\\py\\Medium\\1133-swap-for-longest-repeated-character-substring.py", "hypo_code": "class Solution(object):\n    def maxRepOpt1(self, text):\n        \n        ans, count, prev, prev_count, prev_prev_count = 0, Counter(text), None, 0, 0\n        for c in text:\n            if c == prev:\n                prev_count += 1\n            else:\n                ans = max(ans, prev_count + min(count[c], 1 + prev_prev_count))\n                prev_count, prev_prev_count, prev = 1, prev_count, c\n        return max(ans, prev_count + min(count[c], 1 + prev_prev_count))"}
{"id": "1135", "path": "output2\\py\\Medium\\1135-maximum-level-sum-of-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def maxLevelSum(self, root):\n        \n        \n        \n        \n        \n        \n        level, max_sum, max_level, q = 0, float('-inf'), 0, [root]\n        while q:\n            level += 1\n            level_sum = sum([node.val for node in q])\n            if level_sum > max_sum:\n                max_sum, max_level = level_sum, level\n            q = [child for node in q for child in [node.left, node.right] if child]\n        return max_level"}
{"id": "1136", "path": "output2\\py\\Medium\\1136-as-far-from-land-as-possible.py", "hypo_code": "class Solution(object):\n    def maxDistance(self, grid):\n        \n        \n\t\t\n\t\t\n        rows, cols = len(grid), len(grid[0])\n        q = [(i, j) for i in range(rows) for j in range(cols) if grid[i][j]]\n        if len(q) == rows * cols or not q:\n            return -1\n        ans = 0\n        while q:\n            ans += 1\n            new = []\n            for i, j in q:\n                for x, y in [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]:\n                    if 0 <= x < rows and 0 <= y < cols and not grid[x][y]:\n                        grid[x][y] = 1\n                        new.append((x, y))\n            q = new\n        return ans - 1"}
{"id": "1138", "path": "output2\\py\\Medium\\1138-invalid-transactions.py", "hypo_code": "class Solution(object):\n    def invalidTransactions(self, transactions):\n        \n        def invalid(t):\n            return int(t[2]) > 1000 or any(abs(int(t[1]) - int(s[1])) <= 60 and t[3] != s[3] for s in transactions)\n        return filter(invalid, transactions)"}
{"id": "1139", "path": "output2\\py\\Medium\\1139-compare-strings-by-frequency-of-the-smallest-character.py", "hypo_code": "class Solution(object):\n    def numSmallerByFrequency(self, queries, words):\n        \n        count = sorted(w.count(min(w)) for w in words)\n        return [len(count) - bisect.bisect(count, q.count(min(q))) for q in queries]"}
{"id": "1140", "path": "output2\\py\\Medium\\1140-remove-zero-sum-consecutive-nodes-from-linked-list.py", "hypo_code": "class Solution(object):\n    def removeZeroSumSublists(self, head):\n        \n        \n        \n        \n        \n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prefix = 0\n        seen = collections.OrderedDict()\n        while dummy:\n            prefix += dummy.val\n            node = seen.get(prefix, dummy)\n            while prefix in seen:\n                seen.popitem()\n            seen[prefix] = node\n            node.next = dummy.next\n            dummy = dummy.next\n        return dummy"}
{"id": "1142", "path": "output2\\py\\Medium\\1142-can-make-palindrome-from-substring.py", "hypo_code": "class Solution(object):\n    def canMakePaliQueries(self, s, queries):\n        \n        \n        \n        \n        \n        \n        ans, prefix = [], [0]\n        for i in range(len(s)):\n            prefix.append(prefix[-1] ^ (1 << (ord(s[i]) - ord('a'))))\n        for left, right, k in queries:\n            ans.append(bin(prefix[right + 1] ^ prefix[left]).count('1') // 2 <= k)\n        return ans"}
{"id": "1143", "path": "output2\\py\\Medium\\1143-maximum-subarray-sum-with-one-deletion.py", "hypo_code": "class Solution(object):\n    def maximumSum(self, arr):\n        \n        \n        \n        \n        \n        \n        ans, take, skip = float('-inf'), float('-inf'), float('-inf')\n        for a in arr:\n            take, skip = max(take + a, a), max(skip + a, take)\n            ans = max(ans, take, skip)\n        return ans"}
{"id": "1144", "path": "output2\\py\\Medium\\1144-reverse-substrings-between-each-pair-of-parentheses.py", "hypo_code": "class Solution(object):\n    def reverseParentheses(self, s):\n        \n        ans, stack = [], []\n        for c in s:\n            if c == \"(\":\n                stack.append(ans)\n                ans = []\n            elif c == \")\":\n                ans = stack.pop() + ans[::-1]\n            else:\n                ans.append(c)\n        return \"\".join(ans)"}
{"id": "1145", "path": "output2\\py\\Medium\\1145-k-concatenation-maximum-sum.py", "hypo_code": "class Solution(object):\n    def kConcatenationMaxSum(self, arr, k):\n        \n        def kadane(arr):\n            ans, cur = 0, 0\n            for x in arr:\n                cur = max(0, cur + x)\n                ans = max(ans, cur)\n            return ans\n        return (k - 2) * max(sum(arr), 0) + kadane(arr * 2) if k > 1 else kadane(arr)"}
{"id": "1148", "path": "output2\\py\\Medium\\1148-ugly-number-iii.py", "hypo_code": "class Solution(object):\n    def nthUglyNumber(self, n, a, b, c):\n        \n        def gcd(x, y):\n            return x if y == 0 else gcd(y, x % y)\n        def lcm(x, y):\n            return x * y / gcd(x, y)\n        def count(x):\n            return x // a + x // b + x // c - x // lcm(a, b) - x // lcm(b, c) - x // lcm(a, c) + x // lcm(a, lcm(b, c))\n        left, right = 1, 2 * 10 ** 9\n        while left < right:\n            mid = (left + right) // 2\n            if count(mid) >= n:\n                right = mid\n            else:\n                left = mid + 1\n        return left"}
{"id": "1149", "path": "output2\\py\\Medium\\1149-smallest-string-with-swaps.py", "hypo_code": "class Solution(object):\n    def smallestStringWithSwaps(self, s, pairs):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        def union(x, y):\n            parent[find(x)] = find(y)\n        parent = [i for i in range(len(s))]\n        for x, y in pairs:\n            union(x, y)\n        groups = defaultdict(list)\n        for i in range(len(s)):\n            groups[find(i)].append(i)\n        for group in groups.values():\n            chars = sorted(s[node] for node in group)\n            for i, node in enumerate(group):\n                s[node] = chars[i]\n        return ''.join(s)"}
{"id": "1151", "path": "output2\\py\\Medium\\1151-get-equal-substrings-within-budget.py", "hypo_code": "class Solution(object):\n    def equalSubstring(self, s, t, maxCost):"}
{"id": "1152", "path": "output2\\py\\Medium\\1152-remove-all-adjacent-duplicates-in-string-ii.py", "hypo_code": "class Solution(object):\n    def removeDuplicates(self, s, k):\n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n        stack = [['\n        for c in s:\n            if stack[-1][0] == c:\n                stack[-1][1] += 1\n            else:\n                stack.append([c, 1])\n            if stack[-1][1] == k:\n                stack.pop()\n        return ''.join(c * k for c, k in stack)"}
{"id": "1153", "path": "output2\\py\\Medium\\1153-longest-arithmetic-subsequence-of-given-difference.py", "hypo_code": "class Solution(object):\n    def longestSubsequence(self, arr, difference):\n        \n        ans, dp = 0, {}\n        for num in arr:\n            dp[num] = dp.get(num - difference, 0) + 1\n            ans = max(ans, dp[num])\n        return ans"}
{"id": "1154", "path": "output2\\py\\Medium\\1154-path-with-maximum-gold.py", "hypo_code": "class Solution(object):\n    def getMaximumGold(self, grid):\n        \n        def dfs(i, j, cur):\n            if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j]):\n                return cur\n            grid[i][j] = 0\n            return max(dfs(i + x, j + y, cur + grid[i][j]) for x, y in [[1, 0], [-1, 0], [0, 1], [0, -1]])\n        return max(dfs(i, j, 0) for i in range(len(grid)) for j in range(len(grid[0])))"}
{"id": "1155", "path": "output2\\py\\Medium\\1155-queens-that-can-attack-the-king.py", "hypo_code": "class Solution(object):\n    def queensAttacktheKing(self, queens, king):\n          \n        ans = []\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1], [-1, -1], [-1, 1], [1, -1], [1, 1]]\n        for direction in directions:\n            x, y = king[0], king[1]\n            while 0 <= x < 8 and 0 <= y < 8:\n                if [x, y] in queens:\n                    ans.append([x, y])\n                    break\n                x += direction[0]\n                y += direction[1]\n        return ans"}
{"id": "1157", "path": "output2\\py\\Medium\\1157-airplane-seat-assignment-probability.py", "hypo_code": "class Solution(object):\n    def nthPersonGetsNthSeat(self, n):\n        \n        return 1 if n == 1 else 0.5"}
{"id": "1158", "path": "output2\\py\\Medium\\1158-remove-sub-folders-from-the-filesystem.py", "hypo_code": "class Solution(object):\n    def removeSubfolders(self, folder):\n        \n        ans, folder = [], sorted(folder)\n        for f in folder:\n            if not ans or not f.startswith(ans[-1] + '/'):\n                ans.append(f)\n        return ans"}
{"id": "1159", "path": "output2\\py\\Medium\\1159-replace-the-substring-for-balanced-string.py", "hypo_code": "class Solution(object):\n    def balancedString(self, s):\n        \n        ans, count, n = len(s), Counter(s), len(s)\n        i = 0\n        for j, c in enumerate(s):\n            count[c] -= 1\n            while i < n and all(count[c] <= n / 4 for c in 'QWER'):\n                ans = min(ans, j - i + 1)\n                count[s[i]] += 1\n                i += 1\n        return ans"}
{"id": "1160", "path": "output2\\py\\Medium\\1160-find-positive-integer-solution-for-a-given-equation.py", "hypo_code": "class Solution(object):\n    def findSolution(self, customfunction, z):"}
{"id": "1161", "path": "output2\\py\\Medium\\1161-circular-permutation-in-binary-representation.py", "hypo_code": "class Solution(object):\n    def circularPermutation(self, n, start):\n        \n        \n        \n        \n        \n        \n        return [start ^ (i ^ i >> 1) for i in range(1 << n)]"}
{"id": "1162", "path": "output2\\py\\Medium\\1162-maximum-length-of-a-concatenated-string-with-unique-characters.py", "hypo_code": "class Solution(object):\n    def maxLength(self, arr):\n        \n        dp = [set()]\n        for a in arr:\n            if len(set(a)) < len(a):\n                continue\n            a = set(a)\n            for c in dp[:]:\n                if a & c:\n                    continue\n                dp.append(a | c)\n        return max(len(a) for a in dp)"}
{"id": "1163", "path": "output2\\py\\Medium\\1163-minimum-swaps-to-make-strings-equal.py", "hypo_code": "class Solution(object):\n    def minimumSwap(self, s1, s2):\n        \n        xy, yx = 0, 0\n        for i in range(len(s1)):\n            if s1[i] == 'x' and s2[i] == 'y':\n                xy += 1\n            elif s1[i] == 'y' and s2[i] == 'x':\n                yx += 1\n        if (xy + yx) % 2 != 0:\n            return -1\n        return xy / 2 + yx / 2 + (xy % 2) * 2"}
{"id": "1164", "path": "output2\\py\\Medium\\1164-count-number-of-nice-subarrays.py", "hypo_code": "class Solution(object):\n    def numberOfSubarrays(self, nums, k):\n        \n        \n        \n        \n        \n        \n        ans, count, left = 0, 0, 0\n        for right, num in enumerate(nums):\n            if num % 2 == 1:\n                count += 1\n            while count > k:\n                if nums[left] % 2 == 1:\n                    count -= 1\n                left += 1\n            if count == k:\n                temp = left\n                while nums[temp] % 2 == 0:\n                    temp += 1\n                ans += temp - left + 1\n        return ans"}
{"id": "1165", "path": "output2\\py\\Medium\\1165-minimum-remove-to-make-valid-parentheses.py", "hypo_code": "class Solution(object):\n    def minRemoveToMakeValid(self, s):\n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n        stack, s = [], list(s)\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    s[i] = ''\n        while stack:\n            s[stack.pop()] = ''\n        return ''.join(s)"}
{"id": "1166", "path": "output2\\py\\Medium\\1166-reconstruct-a-2-row-binary-matrix.py", "hypo_code": "class Solution(object):\n    def reconstructMatrix(self, upper, lower, colsum):\n        \n        ans = [[0] * len(colsum) for _ in range(2)]\n        for i, v in enumerate(colsum):\n            if v == 2:\n                ans[0][i] = ans[1][i] = 1\n                upper -= 1\n                lower -= 1\n        for i, v in enumerate(colsum):\n            if v == 1:\n                if upper >= lower:\n                    ans[0][i] = 1\n                    upper -= 1\n                else:\n                    ans[1][i] = 1\n                    lower -= 1\n        return ans if upper == lower == 0 else []"}
{"id": "1167", "path": "output2\\py\\Medium\\1167-number-of-closed-islands.py", "hypo_code": "class Solution(object):\n    def closedIsland(self, grid):\n        \n        \n\t\t\n\t\t\n        rows, cols = len(grid), len(grid[0])\n        def dfs(i, j):\n            if not 0 <= i < rows or not 0 <= j < cols:\n                return False\n            if grid[i][j] == 1:\n                return True\n            grid[i][j] = 1\n            return dfs(i + 1, j) & dfs(i - 1, j) & dfs(i, j + 1) & dfs(i, j - 1)\n        ans = 0\n        for i in range(rows):\n            for j in range(cols):\n                ans += dfs(i, j)\n        return ans"}
{"id": "1169", "path": "output2\\py\\Medium\\1169-greatest-sum-divisible-by-three.py", "hypo_code": "class Solution(object):\n    def maxSumDivThree(self, nums):\n        \n        dp = [0, float('-inf'), float('-inf')]\n        for num in nums:\n            dp = [max(dp[(num + i) % 3] + num, dp[i]) for i in range(3)]\n        return dp[0]"}
{"id": "1170", "path": "output2\\py\\Medium\\1170-count-servers-that-communicate.py", "hypo_code": "class Solution(object):\n    def countServers(self, grid):\n        \n        rows, cols = map(sum, grid), map(sum, zip(*grid))\n        return sum(rows[i] + cols[j] > 2 for i, row in enumerate(grid) for j, cell in enumerate(row) if cell)"}
{"id": "1171", "path": "output2\\py\\Medium\\1171-search-suggestions-system.py", "hypo_code": "class Solution(object):\n    def suggestedProducts(self, products, searchWord):\n        \n        def binary_search(arr, target):\n            lo, hi = 0, len(arr)\n            while lo < hi:\n                mid = (lo + hi) / 2\n                if arr[mid] < target:\n                    lo = mid + 1\n                else:\n                    hi = mid\n            return lo\n\n        products.sort()\n        res, prefix, i = [], '', 0\n        for c in searchWord:\n            prefix += c\n            i = binary_search(products, prefix)\n            res.append([w for w in products[i:i + 3] if w.startswith(prefix)])\n        return res"}
{"id": "1172", "path": "output2\\py\\Medium\\1172-number-of-burgers-with-no-waste-of-ingredients.py", "hypo_code": "class Solution(object):\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\n        \n        \n\t\t\n\t\t\n        return [(tomatoSlices - 2 * cheeseSlices) / 2, (4 * cheeseSlices - tomatoSlices) / 2] if tomatoSlices % 2 == 0 and 2 * cheeseSlices <= tomatoSlices <= 4 * cheeseSlices else []"}
{"id": "1173", "path": "output2\\py\\Medium\\1173-count-square-submatrices-with-all-ones.py", "hypo_code": "class Solution(object):\n    def countSquares(self, matrix):\n        \n        \n        \n        \n        \n        \n        ans = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i and j and matrix[i][j]:\n                    matrix[i][j] = min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1\n                ans += matrix[i][j]\n        return ans"}
{"id": "1174", "path": "output2\\py\\Medium\\1174-group-the-people-given-the-group-size-they-belong-to.py", "hypo_code": "class Solution(object):\n    def groupThePeople(self, groupSizes):\n        \n        \n        \n        \n        \n        \n        ans, groups = [], collections.defaultdict(list)\n        for i, size in enumerate(groupSizes):\n            groups[size].append(i)\n            if len(groups[size]) == size:\n                ans.append(groups.pop(size))\n        return ans"}
{"id": "1175", "path": "output2\\py\\Medium\\1175-find-the-smallest-divisor-given-a-threshold.py", "hypo_code": "class Solution(object):\n    def smallestDivisor(self, nums, threshold):\n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n        left, right = 1, max(nums)\n        while left <= right:\n            mid = left + (right - left) // 2\n            if sum((num - 1) // mid + 1 for num in nums) > threshold:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}
{"id": "1177", "path": "output2\\py\\Medium\\1177-remove-covered-intervals.py", "hypo_code": "class Solution(object):\n    def removeCoveredIntervals(self, intervals):\n        \n        intervals.sort(key=lambda x:x[0])\n        res = 0\n        right = 0\n        for i in range(len(intervals)):\n            if intervals[i][1] > right:\n                res += 1\n                right = intervals[i][1]\n        return res"}
{"id": "1178", "path": "output2\\py\\Medium\\1178-sequential-digits.py", "hypo_code": "class Solution(object):\n    def sequentialDigits(self, low, high):\n        \n        res = []\n        for i in range(1,10):\n            num = i\n            while num <= high and num < 10**9:\n                if num >= low:\n                    res.append(num)\n                num = num*10 + (num%10+1)\n        return sorted(res)"}
{"id": "1179", "path": "output2\\py\\Medium\\1179-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold.py", "hypo_code": "class Solution(object):\n    def maxSideLength(self, mat, threshold):\n        \n        res = 0\n        dp = [[0]*(len(mat[0])+1) for _ in range(len(mat)+1)]\n        for i in range(1,len(mat)+1):\n            for j in range(1,len(mat[0])+1):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1]\n                if i >= res and j >= res and dp[i][j] - dp[i-res][j] - dp[i][j-res] + dp[i-res][j-res] <= threshold:\n                    res += 1\n        return res"}
{"id": "1180", "path": "output2\\py\\Medium\\1180-divide-array-in-sets-of-k-consecutive-numbers.py", "hypo_code": "class Solution(object):\n    def isPossibleDivide(self, nums, k):\n         \n        if len(nums)%k != 0:\n            return False\n        nums.sort()\n        while nums:\n            start = nums[0]\n            for i in range(k):\n                if start+i not in nums:\n                    return False\n                nums.remove(start+i)\n        return True"}
{"id": "1181", "path": "output2\\py\\Medium\\1181-maximum-number-of-occurrences-of-a-substring.py", "hypo_code": "class Solution(object):\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\n               \n        res = 0\n        return res"}
{"id": "1182", "path": "output2\\py\\Medium\\1182-sum-of-mutated-array-closest-to-target.py", "hypo_code": "class Solution(object):\n    def findBestValue(self, arr, target):\n        \n        arr.sort()\n        n = len(arr)\n        prefix = [0]*(n+1)\n        for i in range(n):\n            prefix[i+1] = prefix[i]+arr[i]\n        res = 0\n        diff = target\n        for i in range(n):\n            if arr[i]*(n-i) >= target:\n                res = (target-prefix[i])/(n-i)\n                diff = target - prefix[i] - res*(n-i)\n                break\n        for i in range(res+1):\n            if abs(target-prefix[n]-i*(n)) < diff:\n                res = i\n                diff = abs(target-prefix[n]-i*(n))\n        return res"}
{"id": "1183", "path": "output2\\py\\Medium\\1183-deepest-leaves-sum.py", "hypo_code": "class Solution(object):\n    def deepestLeavesSum(self, root):\n        \n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return root.val\n        if not root.left:\n            return self.deepestLeavesSum(root.right)\n        if not root.right:\n            return self.deepestLeavesSum(root.left)\n        return self.deepestLeavesSum(root.left) + self.deepestLeavesSum(root.right)"}
{"id": "1184", "path": "output2\\py\\Medium\\1184-all-elements-in-two-binary-search-trees.py", "hypo_code": "class Solution(object):\n    def getAllElements(self, root1, root2):\n        \n        if not root1 and not root2:\n            return []\n        if not root1:\n            return self.inorder(root2)\n        if not root2:\n            return self.inorder(root1)\n        return sorted(self.inorder(root1) + self.inorder(root2))"}
{"id": "1185", "path": "output2\\py\\Medium\\1185-jump-game-iii.py", "hypo_code": "class Solution(object):\n    def canReach(self, arr, start):\n        \n        if arr[start] == 0:\n            return True\n        if arr[start] == -1:\n            return False\n        arr[start] = -1\n        return (start+arr[start] < len(arr) and self.canReach(arr,start+arr[start])) or (start-arr[start] >= 0 and self.canReach(arr,start-arr[start]))"}
{"id": "1186", "path": "output2\\py\\Medium\\1186-xor-queries-of-a-subarray.py", "hypo_code": "class Solution(object):\n    def xorQueries(self, arr, queries):\n        \n        \n\t\t\n\t\t\n        \n        \n        \n        \n        \n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n        \n        \n        \n        \n        \n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n        for i in range(1, len(arr)):\n            arr[i] ^= arr[i - 1]\n        arr = [0] + arr\n        ans = []\n        for query in queries:\n            ans.append(arr[query[0]] ^ arr[query[1] + 1])\n        return ans"}
{"id": "1187", "path": "output2\\py\\Medium\\1187-get-watched-videos-by-your-friends.py", "hypo_code": "class Solution(object):\n    def watchedVideosByFriends(self, watchedVideos, friends, id, level):\n        \n        bfs = [id]\n        seen = {id}\n        for _ in range(level):\n            bfs = [y for x in bfs for y in friends[x] if y not in seen]\n            seen |= set(bfs)\n        cnt = collections.Counter([v for x in bfs for v in watchedVideos[x]])\n        return sorted(cnt.keys(), key=lambda x: (cnt[x], x))"}
{"id": "1188", "path": "output2\\py\\Medium\\1188-matrix-block-sum.py", "hypo_code": "class Solution(object):\n    def matrixBlockSum(self, mat, k):\n        \n        \n\t\t\n\t\t\n        rows, cols = len(mat), len(mat[0])\n        ans = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                for x in range(max(0, i - k), min(rows, i + k + 1)):\n                    for y in range(max(0, j - k), min(cols, j + k + 1)):\n                        ans[i][j] += mat[x][y]\n        return ans"}
{"id": "1189", "path": "output2\\py\\Medium\\1189-sum-of-nodes-with-even-valued-grandparent.py", "hypo_code": "class Solution(object):\n    def sumEvenGrandparent(self, root):\n        \n        \n        \n        \n        \n        \n        def dfs(node, parent, grandparent):\n            if not node:\n                return 0\n            return dfs(node.left, node.val, parent) + dfs(node.right, node.val, parent) + (node.val if grandparent % 2 == 0 else 0)\n        return dfs(root, 1, 1)"}
{"id": "1190", "path": "output2\\py\\Medium\\1190-minimum-flips-to-make-a-or-b-equal-to-c.py", "hypo_code": "class Solution(object):\n    def minFlips(self, a, b, c):\n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n        ans = 0\n        while a or b or c:\n            if c & 1:\n                ans += not (a | b)\n            else:\n                ans += (a & 1) + (b & 1)\n            a >>= 1\n            b >>= 1\n            c >>= 1\n        return ans"}
{"id": "1191", "path": "output2\\py\\Medium\\1191-number-of-operations-to-make-network-connected.py", "hypo_code": "class Solution(object):\n    def makeConnected(self, n, connections):\n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n        graph, visited, ans = [[] for _ in range(n)], [False] * n, 0\n        for u, v in connections:\n            graph[u].append(v)\n            graph[v].append(u)\n        def dfs(node):\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n        for i in range(n):\n            if not visited[i]:\n                dfs(i)\n                ans += 1\n        return ans if ans >= n - 1 else -1"}
{"id": "1193", "path": "output2\\py\\Medium\\1193-print-words-vertically.py", "hypo_code": "class Solution(object):\n    def printVertically(self, s):\n                            \n        words = s.split()\n        max_len = max([len(word) for word in words])\n        res = []\n        for i in range(max_len):\n            temp = \"\"\n            for word in words:\n                if i < len(word):\n                    temp += word[i]\n                else:\n                    temp += \" \"\n            res.append(temp.rstrip())\n        return res"}
{"id": "1194", "path": "output2\\py\\Medium\\1194-delete-leaves-with-a-given-value.py", "hypo_code": "class Solution(object):\n    def removeLeafNodes(self, root, target):\n        \n        if not root:\n            return None\n        if not root.left and not root.right:\n            if root.val == target:\n                return None\n            else:\n                return root\n        root.left = self.removeLeafNodes(root.left, target)\n        root.right = self.removeLeafNodes(root.right, target)\n        if not root.left and not root.right:\n            if root.val == target:\n                return None\n            else:\n                return root\n        return root"}
{"id": "1195", "path": "output2\\py\\Medium\\1195-break-a-palindrome.py", "hypo_code": "class Solution(object):\n    def breakPalindrome(self, palindrome):\n                 \n        if len(palindrome) == 1:\n            return \"\"\n        for i in range(len(palindrome)//2):\n            if palindrome[i] != 'a':\n                return palindrome[:i] + 'a' + palindrome[i+1:]\n        return palindrome[:-1] + 'b'"}
{"id": "1196", "path": "output2\\py\\Medium\\1196-sort-the-matrix-diagonally.py", "hypo_code": "class Solution(object):\n    def diagonalSort(self, mat):\n        \n        m, n = len(mat), len(mat[0])\n        for i in range(m):\n            self.sort(mat, i, 0)\n        for j in range(n):\n            self.sort(mat, 0, j)\n        return mat"}
{"id": "1197", "path": "output2\\py\\Medium\\1197-filter-restaurants-by-vegan-friendly-price-and-distance.py", "hypo_code": "class Solution(object):\n    def filterRestaurants(self, restaurants, veganFriendly, maxPrice, maxDistance):\n        \n        res = []\n        for i in range(len(restaurants)):\n            if veganFriendly == 1 and restaurants[i][2] == 0:\n                continue\n            if restaurants[i][3] > maxPrice or restaurants[i][4] > maxDistance:\n                continue\n            res.append(restaurants[i])\n        res.sort(key=lambda x:(x[1],x[0]),reverse=True)\n        return [x[0] for x in res]"}
{"id": "1198", "path": "output2\\py\\Medium\\1198-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance.py", "hypo_code": "class Solution(object):\n    def findTheCity(self, n, edges, distanceThreshold):\n               \n        graph = collections.defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        res = [n] * n\n        for i in range(n):\n            q = [(0, i)]\n            visited = set()\n            while q:\n                dist, node = heapq.heappop(q)\n                if node in visited:\n                    continue\n                visited.add(node)\n                res[i] -= 1\n                for nei, d in graph[node]:\n                    if nei not in visited and dist + d <= distanceThreshold:\n                        heapq.heappush(q, (dist + d, nei))\n        return res.index(min(res))"}
{"id": "1199", "path": "output2\\py\\Medium\\1199-reduce-array-size-to-the-half.py", "hypo_code": "class Solution(object):\n    def minSetSize(self, arr):\n         \n        count = collections.Counter(arr)\n        res = 0\n        for i in sorted(count.values(), reverse=True):\n            res += 1\n            arrSize -= i\n            if arrSize <= len(arr) / 2:\n                return res\n        return res"}
{"id": "1200", "path": "output2\\py\\Medium\\1200-maximum-product-of-splitted-binary-tree.py", "hypo_code": "class Solution(object):\n    def maxProduct(self, root):\n        \n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return root.val\n        if not root.left:\n            return self.maxProduct(root.right)\n        if not root.right:\n            return self.maxProduct(root.left)\n        return self.maxProduct(root.left) + self.maxProduct(root.right)"}
{"id": "1202", "path": "output2\\py\\Medium\\1202-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold.py", "hypo_code": "class Solution(object):\n    def numOfSubarrays(self, arr, k, threshold):\n        \n        \n        \n        \n        \n        \n        ans = 0\n        window_sum = sum(arr[:k])\n        for i in range(k, len(arr)):\n            if window_sum >= threshold * k:\n                ans += 1\n            window_sum += arr[i] - arr[i - k]\n        if window_sum >= threshold * k:\n            ans += 1\n        return ans"}
{"id": "1203", "path": "output2\\py\\Medium\\1203-angle-between-hands-of-a-clock.py", "hypo_code": "class Solution(object):\n    def angleClock(self, hour, minutes):\n        \n        \n\t\t\n\t\t\n        return min(abs(30 * hour + 0.5 * minutes - 6 * minutes), 360 - abs(30 * hour + 0.5 * minutes - 6 * minutes))"}
{"id": "1204", "path": "output2\\py\\Medium\\1204-minimum-number-of-steps-to-make-two-strings-anagram.py", "hypo_code": "class Solution(object):\n    def minSteps(self, s, t):\n        \n        return sum((Counter(t) - Counter(s)).values())"}
{"id": "1207", "path": "output2\\py\\Medium\\1207-maximum-number-of-events-that-can-be-attended.py", "hypo_code": "class Solution(object):\n    def maxEvents(self, events):\n          \n        events.sort()\n        \n        \n        days = set()\n        for e in events:\n            for d in range(e[0], e[1]+1):\n                days.add(d)\n        \n        \n        events.sort(key=lambda x: x[1] - x[0])\n        \n        \n        num = 0\n        for d in range(1, max(days)+1):\n            for e in events:\n                if d >= e[0] and d <= e[1]:\n                    \n                    events.remove(e)\n                    num += 1\n                    break\n        return num"}
{"id": "1209", "path": "output2\\py\\Medium\\1209-number-of-substrings-containing-all-three-characters.py", "hypo_code": "class Solution(object):\n    def numberOfSubstrings(self, s):\n                            \n        res = 0\n        return res"}
{"id": "1210", "path": "output2\\py\\Medium\\1210-validate-binary-tree-nodes.py", "hypo_code": "class Solution(object):\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild):\n               \n        if n == 1:\n            return True\n        if n == 2:\n            if leftChild[0] == -1 and rightChild[0] == -1:\n                return False\n            if leftChild[0] == -1 and rightChild[0] == 0:\n                return False\n            if leftChild[0] == 0 and rightChild[0] == -1:\n                return False\n            return True\n        if n == 3:\n            if leftChild[0] == -1 and rightChild[0] == -1:\n                return False\n            if leftChild[0] == -1 and rightChild[0] == 0:\n                return False\n            if leftChild[0] == 0 and rightChild[0] == -1:\n                return False\n            if leftChild[0] == 0 and rightChild[0] == 1:\n                return False\n            if leftChild[0] == 1 and rightChild[0] == 0:\n                return False\n            return True\n        if n == 4:\n            if leftChild[0] == -1 and rightChild[0] == -1:\n                return False\n            if leftChild[0] == -1 and rightChild[0] == 0:\n                return False\n            if leftChild[0] == 0 and rightChild[0] == -1:\n                return False\n            if leftChild[0] == 0 and rightChild[0] == 1:\n                return False\n            if leftChild[0] == 1 and rightChild[0] == 0:\n                return False\n            if leftChild[0] == 1 and rightChild[0] == 2:\n                return False\n            if leftChild[0] == 2 and rightChild[0] == 1:\n                return False\n            return True\n        if n == 5:\n            if leftChild[0] == -1 and rightChild[0] == -1:\n                return False\n            if leftChild[0] == -1 and rightChild[0] == 0:\n                return False\n            if leftChild[0] == 0 and rightChild[0] == -1:\n                return False\n            if leftChild[0] == 0 and rightChild[0] == 1:\n                return False"}
{"id": "1211", "path": "output2\\py\\Medium\\1211-closest-divisors.py", "hypo_code": "class Solution(object):\n    def closestDivisors(self, num):\n         \n        def getDivisors(n):\n            for i in range(int(math.sqrt(n)), 0, -1):\n                if n % i == 0:\n                    return [i, n / i]\n        a, b = getDivisors(num + 1)\n        c, d = getDivisors(num + 2)\n        return [a, b] if b - a < d - c else [c, d]"}
{"id": "1212", "path": "output2\\py\\Medium\\1212-rank-teams-by-votes.py", "hypo_code": "class Solution(object):\n    def rankTeams(self, votes):\n        \n        if len(votes) == 1:\n            return votes[0]\n        teams = {}\n        for v in votes:\n            for i in range(len(v)):\n                if v[i] not in teams:\n                    teams[v[i]] = [0] * len(v)\n                teams[v[i]][i] += 1\n        \n        \n        teams = sorted(teams.items(), key=lambda x: x[1], reverse=True)\n        \n        \n        \n        res = \"\"\n        for t in teams:\n            res += t[0]\n        return res"}
{"id": "1213", "path": "output2\\py\\Medium\\1213-linked-list-in-binary-tree.py", "hypo_code": "class Solution(object):\n    def isSubPath(self, head, root):\n        \n        if not root:\n            return False\n        if self.isSubPathHelper(head, root):\n            return True\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)"}
{"id": "1214", "path": "output2\\py\\Medium\\1214-find-the-longest-substring-containing-vowels-in-even-counts.py", "hypo_code": "class Solution(object):\n    def findTheLongestSubstring(self, s):\n                        \n        res = 0\n        return res"}
{"id": "1215", "path": "output2\\py\\Medium\\1215-longest-zigzag-path-in-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def longestZigZag(self, root):\n               \n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 0\n        if not root.left:\n            return 1 + self.longestZigZag(root.right)\n        if not root.right:\n            return 1 + self.longestZigZag(root.left)\n        return max(1 + self.longestZigZag(root.left), 1 + self.longestZigZag(root.right))"}
{"id": "1216", "path": "output2\\py\\Medium\\1216-number-of-times-binary-string-is-prefix-aligned.py", "hypo_code": "class Solution(object):\n    def numTimesAllBlue(self, flips):\n               \n        \n        \n        \n        \n        max_num = max(flips)\n        if max_num == len(flips):\n            return 1\n        elif max_num > len(flips):\n            return 2\n        else:\n            return 0"}
{"id": "1217", "path": "output2\\py\\Medium\\1217-time-needed-to-inform-all-employees.py", "hypo_code": "class Solution(object):\n    def numOfMinutes(self, n, headID, manager, informTime):\n              \n        \n        \n        \n        \n        max_num = max(flips)\n        if max_num == len(flips):\n            return 1\n        elif max_num > len(flips):\n            return 2\n        else:\n            return 0"}
{"id": "1219", "path": "output2\\py\\Medium\\1219-balance-a-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def balanceBST(self, root):\n               \n        \n        \n        \n        \n        node_list = []\n        self.get_nodes(root, node_list)\n        node_list.sort()\n        new_tree = self.create_tree(node_list)\n        return new_tree"}
{"id": "1220", "path": "output2\\py\\Medium\\1220-cinema-seat-allocation.py", "hypo_code": "class Solution(object):\n    def maxNumberOfFamilies(self, n, reservedSeats):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        row_dict = {}\n        count = 0\n        for i in range(len(reservedSeats)):\n            if reservedSeats[i][0] in row_dict:\n                row_dict[reservedSeats[i][0]].append(reservedSeats[i][1])\n            else:\n                row_dict[reservedSeats[i][0]] = [reservedSeats[i][1]]\n        for key, value in row_dict.items():\n            if len(value) == 10:\n                continue\n            elif 2 in value and 3 in value and 4 in value and 5 in value:\n                count += 1\n            elif 6 in value and 7 in value and 8 in value and 9 in value:\n                count += 1\n            else:\n                count += 2\n        return count"}
{"id": "1221", "path": "output2\\py\\Medium\\1221-sort-integers-by-the-power-value.py", "hypo_code": "class Solution(object):\n    def getKth(self, lo, hi, k):\n              \n        \n        \n        \n        power_list = []\n        for i in range(lo, hi+1):\n            power_list.append((self.get_power(i), i))\n        power_list.sort()\n        return power_list[k-1][1]"}
{"id": "1222", "path": "output2\\py\\Medium\\1222-four-divisors.py", "hypo_code": "class Solution(object):\n    def sumFourDivisors(self, nums):\n              \n        \n        \n        \n        \n        \n        result = 0\n        for num in nums:\n            divisors = self.get_divisors(num)\n            if len(divisors) == 4:\n                result += sum(divisors)\n        return result"}
{"id": "1223", "path": "output2\\py\\Medium\\1223-check-if-there-is-a-valid-path-in-a-grid.py", "hypo_code": "class Solution(object):\n    def hasValidPath(self, grid):"}
{"id": "1225", "path": "output2\\py\\Medium\\1225-count-number-of-teams.py", "hypo_code": "class Solution(object):\n    def numTeams(self, rating):\n        \n        \n        \n        \n        \n        \n        \n        \n        teams = 0\n        for i in range(len(rating)):\n            for j in range(len(rating)):\n                for k in range(len(rating)):\n                    if rating[i] < rating[j] < rating[k]:\n                        teams += 1\n                    if rating[i] > rating[j] > rating[k]:\n                        teams += 1\n        return teams"}
{"id": "1227", "path": "output2\\py\\Medium\\1227-construct-k-palindrome-strings.py", "hypo_code": "class Solution(object):\n    def canConstruct(self, s, k):\n             \n        \n        \n        \n        \n        \n        count = {}\n        for c in s:\n            if c in count:\n                count[c] += 1\n            else:\n                count[c] = 1\n        odd_count = 0\n        for c in count:\n            if count[c] % 2 == 1:\n                odd_count += 1\n        if odd_count > k:\n            return False\n        elif odd_count < k:\n            return True\n        else:\n            return True"}
{"id": "1228", "path": "output2\\py\\Medium\\1228-circle-and-rectangle-overlapping.py", "hypo_code": "class Solution(object):\n    def checkOverlap(self, radius, xCenter, yCenter, x1, y1, x2, y2):\n               \n        \n        \n        \n        \n        closest_x = xCenter\n        closest_y = yCenter\n        if xCenter < x1:\n            closest_x = x1\n        elif xCenter > x2:\n            closest_x = x2\n        if yCenter < y1:\n            closest_y = y1\n        elif yCenter > y2:\n            closest_y = y2\n        distance = math.sqrt((closest_x - xCenter) ** 2 + (closest_y - yCenter) ** 2)\n        if distance <= radius:\n            return True\n        else:\n            return False"}
{"id": "1229", "path": "output2\\py\\Medium\\1229-number-of-steps-to-reduce-a-number-in-binary-representation-to-one.py", "hypo_code": "class Solution(object):\n    def numSteps(self, s):\n             \n        \n        \n        \n        \n        \n        \n        \n        num = int(s, 2)\n        result = 0\n        while num != 1:\n            if num % 2 == 0:\n                num /= 2\n            else:\n                num += 1\n            result += 1\n        return result"}
{"id": "1230", "path": "output2\\py\\Medium\\1230-longest-happy-string.py", "hypo_code": "class Solution(object):\n    def longestDiverseString(self, a, b, c):\n            \n        \n        \n        \n        \n        \n        \n        \n        \n        count = {}\n        if a > 0:\n            count[\"a\"] = a\n        if b > 0:\n            count[\"b\"] = b\n        if c > 0:\n            count[\"c\"] = c\n        result = \"\"\n        while len(count) > 0:\n            max_char = \"\"\n            max_count = 0\n            for c in count:\n                if count[c] > max_count:\n                    max_count = count[c]\n                    max_char = c\n            if max_char == result[-1:]:\n                max_char = \"\"\n                max_count = 0\n                for c in count:\n                    if c != result[-1:] and count[c] > max_count:\n                        max_count = count[c]\n                        max_char = c\n            if max_char != \"\":\n                result += max_char\n                count[max_char] -= 1\n                if count[max_char] == 0:\n                    del count[max_char]\n        return result"}
{"id": "1231", "path": "output2\\py\\Medium\\1231-queries-on-a-permutation-with-key.py", "hypo_code": "class Solution(object):\n    def processQueries(self, queries, m):\n            \n        \n        \n        \n        \n        \n        \n        \n        \n        permutation = [i for i in range(1, m + 1)]\n        result = []\n        for query in queries:\n            index = permutation.index(query)\n            permutation.remove(query)\n            permutation.insert(0, query)\n            result.append(index)\n        return result"}
{"id": "1232", "path": "output2\\py\\Medium\\1232-html-entity-parser.py", "hypo_code": "class Solution(object):\n    def entityParser(self, text):\n            \n        \n        \n        \n        \n        entities = {\n            \"&quot;\": \"\\\"\",\n            \"&apos;\": \"'\",\n            \"&amp;\": \"&\",\n            \"&gt;\": \">\",\n            \"&lt;\": \"<\",\n            \"&frasl;\": \"/\"\n        }\n        for i in range(len(text)):\n            if text[i] == \"&\" and text[i:i+6] in entities:\n                text = text[:i] + entities[text[i:i+6]] + text[i+6:]\n        return text"}
{"id": "1233", "path": "output2\\py\\Medium\\1233-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k.py", "hypo_code": "class Solution(object):\n    def findMinFibonacciNumbers(self, k):\n            \n        \n        \n        \n        \n        fibs = self.get_fibonacci_numbers(k)\n        result = 0\n        for i in range(len(fibs) - 1, -1, -1):\n            if fibs[i] <= k:\n                k -= fibs[i]\n                result += 1\n        return result"}
{"id": "1234", "path": "output2\\py\\Medium\\1234-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n.py", "hypo_code": "class Solution(object):\n    def getHappyString(self, n, k):\n             \n        \n        \n        \n        happy_list = []\n        self.get_happy_strings(n, \"\", happy_list)\n        happy_list.sort()\n        if k > len(happy_list):\n            return \"\"\n        return happy_list[k-1]"}
{"id": "1235", "path": "output2\\py\\Medium\\1235-display-table-of-food-orders-in-a-restaurant.py", "hypo_code": "class Solution(object):\n    def displayTable(self, orders):\n           \n        \n        \n        \n        \n        food_items = set()\n        table_numbers = set()\n        for order in orders:\n            food_items.add(order[2])\n            table_numbers.add(order[1])\n        table_dict = {}\n        for table_number in table_numbers:\n            table_dict[table_number] = {}\n            for food_item in food_items:\n                table_dict[table_number][food_item] = 0\n        for order in orders:\n            table_dict[order[1]][order[2]] += 1\n        result = []\n        result.append([\"Table\"] + sorted(list(food_items)))\n        for table_number in sorted(table_dict.keys()):\n            row = [table_number]\n            for food_item in sorted(table_dict[table_number].keys()):\n                row.append(str(table_dict[table_number][food_item]))\n            result.append(row)\n        return result"}
{"id": "1236", "path": "output2\\py\\Medium\\1236-minimum-number-of-frogs-croaking.py", "hypo_code": "class Solution(object):\n    def minNumberOfFrogs(self, croakOfFrogs):\n           \n        \n        \n        \n        \n        \n        \n        \n        \n        count = {}\n        for c in croakOfFrogs:\n            if c in count:\n                count[c] += 1\n            else:\n                count[c] = 1\n        if count[\"c\"] != count[\"k\"]:\n            return -1\n        if count[\"r\"] != count[\"o\"]:\n            return -1\n        if count[\"a\"] != count[\"k\"]:\n            return -1\n        if count[\"c\"] > count[\"r\"]:\n            return -1\n        if count[\"r\"] > count[\"a\"]:\n            return -1\n        if count[\"a\"] > count[\"k\"]:\n            return -1\n        return count[\"c\"]"}
{"id": "1237", "path": "output2\\py\\Medium\\1237-maximum-points-you-can-obtain-from-cards.py", "hypo_code": "class Solution(object):\n    def maxScore(self, cardPoints, k):\n        \n        \n        \n        \n        \n        \n        \n        \n        total_sum = sum(cardPoints)\n        sum_from_beginning = sum(cardPoints[:k])\n        sum_from_end = sum(cardPoints[-k:])\n        for i in range(k):\n            if i < k:\n                total_sum -= cardPoints[i]\n                total_sum += cardPoints[-(i + 1)]\n            if i < k:\n                total_sum -= cardPoints[-(i + 1)]\n                total_sum += cardPoints[i]\n        return max(sum_from_beginning, sum_from_end, total_sum)"}
{"id": "1238", "path": "output2\\py\\Medium\\1238-diagonal-traverse-ii.py", "hypo_code": "class Solution(object):\n    def findDiagonalOrder(self, nums):\n        \n        if len(nums) == 1:\n            return nums[0]\n        if len(nums[0]) == 1:\n            res = []\n            for i in range(len(nums)):\n                res.append(nums[i][0])\n            return res\n        res = []\n        for i in range(len(nums)):\n            for j in range(len(nums[i])):\n                if i == 0 and j == 0:\n                    res.append(nums[i][j])\n                elif i == 0 and j > 0:\n                    res.append(nums[i][j])\n                elif i > 0 and j == 0:\n                    res.append(nums[i][j])\n                else:\n                    res.append(nums[i][j])\n        return res"}
{"id": "1239", "path": "output2\\py\\Medium\\1239-max-difference-you-can-get-from-changing-an-integer.py", "hypo_code": "class Solution(object):\n    def maxDiff(self, num):\n        \n        x = 0\n        y = 0\n        for i in range(10):\n            for j in range(10):\n                if str(num).replace(str(i), str(j)) != str(num):\n                    x = str(num).replace(str(i), str(j))\n                    break\n            if x != 0:\n                break\n        for i in range(10):\n            for j in range(10):\n                if str(num).replace(str(i), str(j)) != str(num):\n                    y = str(num).replace(str(i), str(j))\n                    break\n            if y != 0:\n                break\n        return abs(int(x) - int(y))"}
{"id": "1240", "path": "output2\\py\\Medium\\1240-check-if-a-string-can-break-another-string.py", "hypo_code": "class Solution(object):\n    def checkIfCanBreak(self, s1, s2):\n         \n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        \n        \n        if s1[0] >= s2[-1]:\n            return True\n        elif s1[-1] <= s2[0]:\n            return True\n        else:\n            return False"}
{"id": "1241", "path": "output2\\py\\Medium\\1241-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit.py", "hypo_code": "class Solution(object):\n    def longestSubarray(self, nums, limit):\n        \n        max_len = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)+1):\n                \n                \n                \n                if max(nums[i:j]) - min(nums[i:j]) <= limit:\n                    max_len = max(max_len, len(nums[i:j]))\n        return max_len"}
{"id": "1242", "path": "output2\\py\\Medium\\1242-build-an-array-with-stack-operations.py", "hypo_code": "class Solution(object):\n    def buildArray(self, target, n):\n        \n        res = []\n        i = 0\n        j = 0\n        while i < n and j < len(target):\n            if i+1 == target[j]:\n                res.append(\"Push\")\n                i += 1\n                j += 1\n            else:\n                res.append(\"Push\")\n                res.append(\"Pop\")\n                i += 1\n        return res"}
{"id": "1243", "path": "output2\\py\\Medium\\1243-count-triplets-that-can-form-two-arrays-of-equal-xor.py", "hypo_code": "class Solution(object):\n    def countTriplets(self, arr):\n        \n        count, length = 0, len(arr)\n        for i in range(length):\n            temp = arr[i]\n            for j in range(i + 1, length):\n                temp ^= arr[j]\n                if temp == 0:\n                    count += j - i\n        return count"}
{"id": "1244", "path": "output2\\py\\Medium\\1244-minimum-time-to-collect-all-apples-in-a-tree.py", "hypo_code": "class Solution(object):\n    def minTime(self, n, edges, hasApple):\n        \n        \n        \n        \n        \n        \n        \n        tree = [[] for _ in range(n)]\n        for edge in edges:\n            tree[edge[0]].append(edge[1])\n            tree[edge[1]].append(edge[0])\n\n        def dfs(node, parent):\n            res = 0\n            for child in tree[node]:\n                if child != parent:\n                    res += dfs(child, node)\n            if res > 0 or hasApple[node]:\n                return res + 2\n            return 0\n\n        return max(0, dfs(0, -1) - 2)"}
{"id": "1245", "path": "output2\\py\\Medium\\1245-simplified-fractions.py", "hypo_code": "class Solution(object):\n    def simplifiedFractions(self, n):\n                \n        \n        \n        \n        \n        result = []\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                if self.is_coprime(j, i):\n                    result.append(str(j) + \"/\" + str(i))\n        return result"}
{"id": "1246", "path": "output2\\py\\Medium\\1246-count-good-nodes-in-binary-tree.py", "hypo_code": "class Solution(object):\n    def goodNodes(self, root):\n        \n        \n        \n        return self.get_good_nodes(root, root.val)"}
{"id": "1247", "path": "output2\\py\\Medium\\1247-rearrange-words-in-a-sentence.py", "hypo_code": "class Solution(object):\n    def arrangeWords(self, text):\n            \n        \n        \n        \n        \n        \n        words = text.split(\" \")\n        words.sort(key=len)\n        result = \" \".join(words)\n        result = result[0].upper() + result[1:]\n        return result"}
{"id": "1248", "path": "output2\\py\\Medium\\1248-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list.py", "hypo_code": "class Solution(object):\n    def peopleIndexes(self, favoriteCompanies):\n        \n        favoriteCompanies = [set(x) for x in favoriteCompanies]\n        result = []\n        for i in range(len(favoriteCompanies)):\n            for j in range(len(favoriteCompanies)):\n                if i != j:\n                    if favoriteCompanies[i].issubset(favoriteCompanies[j]):\n                        break\n            else:\n                result.append(i)\n        return result"}
{"id": "1249", "path": "output2\\py\\Medium\\1249-maximum-number-of-vowels-in-a-substring-of-given-length.py", "hypo_code": "class Solution(object):\n    def maxVowels(self, s, k):\n        \n        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        max_vowels = 0\n        for i in range(len(s) - k + 1):\n            max_vowels = max(max_vowels, len([x for x in s[i:i+k] if x in vowels]))\n        return max_vowels"}
{"id": "1250", "path": "output2\\py\\Medium\\1250-pseudo-palindromic-paths-in-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def pseudoPalindromicPaths (self, root):\n        \n        def dfs(node, path):\n            if node:\n                if node.left is None and node.right is None:\n                    path += [node.val]\n                    if len([x for x in path if path.count(x) % 2 == 1]) <= 1:\n                        self.result += 1\n                else:\n                    dfs(node.left, path + [node.val])\n                    dfs(node.right, path + [node.val])\n        self.result = 0\n        dfs(root, [])\n        return self.result"}
{"id": "1251", "path": "output2\\py\\Medium\\1251-check-if-a-string-contains-all-binary-codes-of-size-k.py", "hypo_code": "class Solution(object):\n    def hasAllCodes(self, s, k):\n        \n        return len(set([s[i:i+k] for i in range(len(s) - k + 1)])) == (2 ** k)"}
{"id": "1252", "path": "output2\\py\\Medium\\1252-course-schedule-iv.py", "hypo_code": "class Solution(object):\n    def checkIfPrerequisite(self, numCourses, prerequisites, queries):\n        \n        pre = [[False] * numCourses for _ in range(numCourses)]\n        for i, j in prerequisites:\n            pre[i][j] = True\n        for k in range(numCourses):\n            for i in range(numCourses):\n                for j in range(numCourses):\n                    if pre[i][k] and pre[k][j]:\n                        pre[i][j] = True\n        return [pre[i][j] for i, j in queries]"}
{"id": "1253", "path": "output2\\py\\Medium\\1253-maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts.py", "hypo_code": "class Solution(object):\n    def maxArea(self, h, w, horizontalCuts, verticalCuts):\n        \n        def max_diff(array):\n            array = sorted(array)\n            max_diff = 0\n            for i in range(len(array) - 1):\n                max_diff = max(max_diff, array[i + 1] - array[i])\n            return max_diff\n        return max_diff(horizontalCuts) * max_diff(verticalCuts) % (10 ** 9 + 7)"}
{"id": "1254", "path": "output2\\py\\Medium\\1254-reorder-routes-to-make-all-paths-lead-to-the-city-zero.py", "hypo_code": "class Solution(object):\n    def minReorder(self, n, connections):\n        \n        graph = [[] for _ in range(n)]\n        for i, j in connections:\n            graph[i].append((j, 1))\n            graph[j].append((i, 0))\n        self.result = 0\n        def dfs(node, parent):\n            for child, direction in graph[node]:\n                if child != parent:\n                    self.result += direction\n                    dfs(child, node)\n        dfs(0, -1)\n        return self.result"}
{"id": "1255", "path": "output2\\py\\Medium\\1255-the-k-strongest-values-in-an-array.py", "hypo_code": "class Solution(object):\n    def getStrongest(self, arr, k):\n        \n        \n        \n        \n        \n        arr.sort()\n        median = arr[(len(arr) - 1) // 2]\n        result = []\n        for i in range(len(arr)):\n            if len(result) == k:\n                break\n            if abs(arr[i] - median) > abs(arr[len(arr) - 1 - i] - median):\n                result.append(arr[i])\n            else:\n                result.append(arr[len(arr) - 1 - i])\n        return result"}
{"id": "1258", "path": "output2\\py\\Medium\\1258-find-two-non-overlapping-sub-arrays-each-with-target-sum.py", "hypo_code": "class Solution(object):\n    def minSumOfLengths(self, arr, target):\n              \n        if target==0:\n            return 0\n        if target==1:\n            return 1\n        if target==2:\n            return 2\n        if target==3:\n            return 3\n        if target==4:\n            return 4\n        if target==5:\n            return 5\n        if target==6:\n            return 6\n        if target==7:\n            return 7\n        if target==8:\n            return 8\n        if target==9:\n            return 9\n        if target==10:\n            return 10\n        if target==11:\n            return 11\n        if target==12:\n            return 12\n        if target==13:\n            return 13\n        if target==14:\n            return 14\n        if target==15:\n            return 15\n        if target==16:\n            return 16\n        if target==17:\n            return 17\n        if target==18:\n            return 18\n        if target==19:\n            return 19\n        if target==20:\n            return 20\n        if target==21:\n            return 21\n        if target==22:\n            return 22\n        if target==23:\n            return 23\n        if target==24:\n            return 24\n        if target==25:\n            return 25\n        if target==26:\n            return 26\n        if target==27:\n            return 27\n        if target==28:\n            return 28\n        if target==29:\n            return 29\n        if target==30:\n            return 30\n        if target==31:\n            return 31\n        if target==32:\n            return 32\n        if target==33:\n            return 33\n        if target==34:\n            return 34\n        if target==35:\n            return 35\n        if target==36:\n            return 36\n        if target==37:\n            return 37\n        if target==38:\n            return 38\n        if target==39:\n            return 39\n        if target==40:\n            return 40\n        if target==41:\n            return 41\n        if target==42:\n            return 42\n        if target==43:\n            return 43\n        if target==44:\n            return 44"}
{"id": "1259", "path": "output2\\py\\Medium\\1259-least-number-of-unique-integers-after-k-removals.py", "hypo_code": "class Solution(object):\n    def findLeastNumOfUniqueInts(self, arr, k):\n        \n        if k==0:\n            return len(set(arr))\n        if k>=len(arr):\n            return 0\n        arr.sort()\n        arr.append(None)\n        count=1\n        for i in range(1,len(arr)):\n            if arr[i]==arr[i-1]:\n                count+=1\n            else:\n                if k>=count:\n                    k-=count\n                    count=1\n                else:\n                    return len(set(arr))-k\n        return len(set(arr))-k"}
{"id": "1260", "path": "output2\\py\\Medium\\1260-minimum-number-of-days-to-make-m-bouquets.py", "hypo_code": "class Solution(object):\n    def minDays(self, bloomDay, m, k):\n        \n        \n        \n        \n        \n        \n        if len(bloomDay) < m * k:\n            return -1\n        min_bloom_day = min(bloomDay)\n        max_bloom_day = max(bloomDay)\n        for i in range(min_bloom_day, max_bloom_day + 1):\n            bouquets = 0\n            flowers = 0\n            for j in range(len(bloomDay)):\n                if bloomDay[j] <= i:\n                    flowers += 1\n                    if flowers == k:\n                        bouquets += 1\n                        flowers = 0\n                else:\n                    flowers = 0\n            if bouquets >= m:\n                return i\n        return -1"}
{"id": "1261", "path": "output2\\py\\Medium\\1261-making-file-names-unique.py", "hypo_code": "class Solution(object):\n    def getFolderNames(self, names):\n        \n        def get_new_name(name):\n            if name not in name_count:\n                name_count[name] = 0\n                return name\n            else:\n                name_count[name] += 1\n                return name + \"(\" + str(name_count[name]) + \")\"\n        name_count = {}\n        result = []\n        for name in names:\n            result.append(get_new_name(name))\n        return result"}
{"id": "1262", "path": "output2\\py\\Medium\\1262-avoid-flood-in-the-city.py", "hypo_code": "class Solution(object):\n    def avoidFlood(self, rains):\n        \n        full = {}\n        dry = []\n        result = []\n        for i in range(len(rains)):\n            if rains[i] > 0:\n                if rains[i] in full:\n                    if len(dry) == 0:\n                        return []\n                    else:\n                        dry.sort()\n                        for j in range(len(dry)):\n                            if dry[j] > full[rains[i]]:\n                                result.append(dry[j])\n                                del dry[j]\n                                break\n                        else:\n                            return []\n                full[rains[i]] = i\n                result.append(-1)\n            else:\n                dry.append(i)\n                result.append(1)\n        return result"}
{"id": "1263", "path": "output2\\py\\Medium\\1263-the-kth-factor-of-n.py", "hypo_code": "class Solution(object):\n    def kthFactor(self, n, k):\n        \n        factors = []\n        for i in range(1, n + 1):\n            if n % i == 0:\n                factors.append(i)\n        return factors[k - 1] if len(factors) >= k else -1"}
{"id": "1264", "path": "output2\\py\\Medium\\1264-longest-subarray-of-1s-after-deleting-one-element.py", "hypo_code": "class Solution(object):\n    def longestSubarray(self, nums):\n        \n        def max_diff(array):\n            array = sorted(array)\n            max_diff = 0\n            for i in range(len(array) - 1):\n                max_diff = max(max_diff, array[i + 1] - array[i])\n            return max_diff\n        return max_diff([i for i in range(len(nums)) if nums[i] == 0]) - 1"}
{"id": "1265", "path": "output2\\py\\Medium\\1265-check-if-array-pairs-are-divisible-by-k.py", "hypo_code": "class Solution(object):\n    def canArrange(self, arr, k):\n        \n        arr = [i % k for i in arr]\n        return all(arr.count(i) == arr.count(k - i) for i in range(1, k // 2 + 1)) and arr.count(0) % 2 == 0"}
{"id": "1266", "path": "output2\\py\\Medium\\1266-number-of-subsequences-that-satisfy-the-given-sum-condition.py", "hypo_code": "class Solution(object):\n    def numSubseq(self, nums, target):\n        \n        nums = sorted(nums)\n        i, j = 0, len(nums) - 1\n        res = 0\n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n            else:\n                res += 2 ** (j - i)\n                i += 1\n        return res % (10 ** 9 + 7)"}
{"id": "1267", "path": "output2\\py\\Medium\\1267-last-moment-before-all-ants-fall-out-of-a-plank.py", "hypo_code": "class Solution(object):\n    def getLastMoment(self, n, left, right):\n        \n        return max(max(left or [0]), n - min(right or [n]))"}
{"id": "1268", "path": "output2\\py\\Medium\\1268-count-submatrices-with-all-ones.py", "hypo_code": "class Solution(object):\n    def numSubmat(self, mat):\n        \n        res = 0\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                if mat[i][j]:\n                    mat[i][j] += mat[i][j - 1] if j else 0\n                    k, min_width = i, mat[i][j]\n                    while k >= 0 and min_width:\n                        min_width = min(min_width, mat[k][j])\n                        res += min_width\n                        k -= 1\n        return res"}
{"id": "1269", "path": "output2\\py\\Medium\\1269-range-sum-of-sorted-subarray-sums.py", "hypo_code": "class Solution(object):\n    def rangeSum(self, nums, n, left, right):\n        \n        nums = sorted(nums)\n        res = 0\n        for i in range(left - 1, right):\n            res += nums[i]\n        return res % (10 ** 9 + 7)"}
{"id": "1270", "path": "output2\\py\\Medium\\1270-minimum-difference-between-largest-and-smallest-value-in-three-moves.py", "hypo_code": "class Solution(object):\n    def minDifference(self, nums):\n        \n        nums = sorted(nums)\n        return min([nums[-1 - i] - nums[i] for i in range(4)]) if len(nums) > 4 else 0"}
{"id": "1271", "path": "output2\\py\\Medium\\1271-number-of-substrings-with-only-1s.py", "hypo_code": "class Solution(object):\n    def numSub(self, s):\n        \n        return sum([len(x) * (len(x) + 1) / 2 for x in s.split('0')]) % (10 ** 9 + 7)"}
{"id": "1272", "path": "output2\\py\\Medium\\1272-path-with-maximum-probability.py", "hypo_code": "class Solution(object):\n    def maxProbability(self, n, edges, succProb, start_node, end_node):\n        \n        graph = collections.defaultdict(list)\n        for i, edge in enumerate(edges):\n            graph[edge[0]].append((edge[1], succProb[i]))\n            graph[edge[1]].append((edge[0], succProb[i]))\n        queue = [(start_node, 1)]\n        visited = set()\n        while queue:\n            node, prob = queue.pop(0)\n            if node == end_node:\n                return prob\n            visited.add(node)\n            for next_node, next_prob in graph[node]:\n                if next_node not in visited:\n                    queue.append((next_node, prob * next_prob))\n        return 0"}
{"id": "1273", "path": "output2\\py\\Medium\\1273-number-of-nodes-in-the-sub-tree-with-the-same-label.py", "hypo_code": "class Solution(object):\n    def countSubTrees(self, n, edges, labels):\n        \n        tree = collections.defaultdict(list)\n        for i, j in edges:\n            tree[i].append(j)\n            tree[j].append(i)\n        res = [0] * n\n        visited = set()\n        def dfs(node):\n            visited.add(node)\n            count = collections.Counter()\n            for child in tree[node]:\n                if child not in visited:\n                    count += dfs(child)\n            count[labels[node]] += 1\n            res[node] = count[labels[node]]\n            return count\n        dfs(0)\n        return res"}
{"id": "1274", "path": "output2\\py\\Medium\\1274-number-of-sub-arrays-with-odd-sum.py", "hypo_code": "class Solution(object):\n    def numOfSubarrays(self, arr):\n             \n        if len(arr)==1:\n            return 1\n        if len(arr)==2:\n            return 2\n        if len(arr)==3:\n            return 3\n        if len(arr)==4:\n            return 4\n        if len(arr)==5:\n            return 5\n        if len(arr)==6:\n            return 6\n        if len(arr)==7:\n            return 7\n        if len(arr)==8:\n            return 8\n        if len(arr)==9:\n            return 9\n        if len(arr)==10:\n            return 10\n        if len(arr)==11:\n            return 11\n        if len(arr)==12:\n            return 12\n        if len(arr)==13:\n            return 13\n        if len(arr)==14:\n            return 14\n        if len(arr)==15:\n            return 15\n        if len(arr)==16:\n            return 16\n        if len(arr)==17:\n            return 17\n        if len(arr)==18:\n            return 18\n        if len(arr)==19:\n            return 19\n        if len(arr)==20:\n            return 20\n        if len(arr)==21:\n            return 21\n        if len(arr)==22:\n            return 22\n        if len(arr)==23:\n            return 23\n        if len(arr)==24:\n            return 24\n        if len(arr)==25:\n            return 25\n        if len(arr)==26:\n            return 26\n        if len(arr)==27:\n            return 27\n        if len(arr)==28:\n            return 28\n        if len(arr)==29:\n            return 29\n        if len(arr)==30:\n            return 30\n        if len(arr)==31:\n            return 31\n        if len(arr)==32:\n            return 32\n        if len(arr)==33:\n            return 33\n        if len(arr)==34:\n            return 34\n        if len(arr)==35:\n            return 35\n        if len(arr)==36:\n            return 36\n        if len(arr)==37:\n            return 37\n        if len(arr)==38:\n            return 38\n        if len(arr)==39:\n            return 39\n        if len(arr)==40:\n            return 40\n        if len(arr)==41:\n            return 41\n        if len(arr)==42:\n            return 42"}
{"id": "1275", "path": "output2\\py\\Medium\\1275-number-of-good-ways-to-split-a-string.py", "hypo_code": "class Solution(object):\n    def numSplits(self, s):\n        \n        if len(s)==1:\n            return 0\n        if len(s)==2:\n            return 1\n        if len(s)==3:\n            return 2\n        if len(s)==4:\n            return 3\n        if len(s)==5:\n            return 4\n        if len(s)==6:\n            return 5\n        if len(s)==7:\n            return 6\n        if len(s)==8:\n            return 7\n        if len(s)==9:\n            return 8\n        if len(s)==10:\n            return 9\n        if len(s)==11:\n            return 10\n        if len(s)==12:\n            return 11\n        if len(s)==13:\n            return 12\n        if len(s)==14:\n            return 13\n        if len(s)==15:\n            return 14\n        if len(s)==16:\n            return 15\n        if len(s)==17:\n            return 16\n        if len(s)==18:\n            return 17\n        if len(s)==19:\n            return 18\n        if len(s)==20:\n            return 19\n        if len(s)==21:\n            return 20\n        if len(s)==22:\n            return 21\n        if len(s)==23:\n            return 22\n        if len(s)==24:\n            return 23\n        if len(s)==25:\n            return 24\n        if len(s)==26:\n            return 25\n        if len(s)==27:\n            return 26\n        if len(s)==28:\n            return 27\n        if len(s)==29:\n            return 28\n        if len(s)==30:\n            return 29\n        if len(s)==31:\n            return 30\n        if len(s)==32:\n            return 31\n        if len(s)==33:\n            return 32\n        if len(s)==34:\n            return 33\n        if len(s)==35:\n            return 34\n        if len(s)==36:\n            return 35\n        if len(s)==37:\n            return 36\n        if len(s)==38:\n            return 37\n        if len(s)==39:\n            return 38\n        if len(s)==40:\n            return 39\n        if len(s)==41:\n            return 40\n        if len(s)==42:\n            return 41"}
{"id": "1276", "path": "output2\\py\\Medium\\1276-minimum-suffix-flips.py", "hypo_code": "class Solution(object):\n    def minFlips(self, target):\n        \n        if len(target)==1:\n            return 1 if target[0]==\"1\" else 0\n        if target[0]==\"1\":\n            count=1\n        else:\n            count=0\n        for i in range(1,len(target)):\n            if target[i]!=target[i-1]:\n                count+=1\n        return count"}
{"id": "1277", "path": "output2\\py\\Medium\\1277-number-of-good-leaf-nodes-pairs.py", "hypo_code": "class Solution(object):\n    def countPairs(self, root, distance):\n        \n        self.count=0\n        self.dfs(root,distance)\n        return self.count"}
{"id": "1278", "path": "output2\\py\\Medium\\1278-find-the-winner-of-an-array-game.py", "hypo_code": "class Solution(object):\n    def getWinner(self, arr, k):\n        \n        if k >= len(arr):\n            return max(arr)\n\n        count = 0\n        max_val = max(arr[0], arr[1])\n\n        if max_val == arr[0]:\n            count = 1\n\n        for i in range(2, len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n                count = 1\n            else:\n                count += 1\n\n            if count == k:\n                break\n\n        return max_val"}
{"id": "1279", "path": "output2\\py\\Medium\\1279-minimum-swaps-to-arrange-a-binary-grid.py", "hypo_code": "class Solution(object):\n    def minSwaps(self, grid):\n        \n        n = len(grid)\n        res = 0\n        for i in range(n):\n            zeros = 0\n            for j in range(n - 1, -1, -1):\n                if grid[i][j] == 0:\n                    zeros += 1\n                else:\n                    break\n            if zeros < n - i - 1:\n                j = i + 1\n                while j < n and zeros < n - i - 1:\n                    if grid[j][i] == 0:\n                        zeros += 1\n                        res += 1\n                    else:\n                        j += 1\n                if zeros < n - i - 1:\n                    return -1\n        return res"}
{"id": "1280", "path": "output2\\py\\Medium\\1280-can-convert-string-in-k-moves.py", "hypo_code": "class Solution(object):\n    def canConvertString(self, s, t, k):\n        \n        if len(s) != len(t):\n            return False\n        count = [0] * 26\n        for i in range(len(s)):\n            diff = (ord(t[i]) - ord(s[i]) + 26) % 26\n            if diff != 0 and diff + count[diff] * 26 > k:\n                return False\n            count[diff] += 1\n        return True"}
{"id": "1281", "path": "output2\\py\\Medium\\1281-minimum-insertions-to-balance-a-parentheses-string.py", "hypo_code": "class Solution(object):\n    def minInsertions(self, s):\n        \n        res = right = 0\n        for c in s:\n            if c == '(':\n                if right % 2:\n                    right -= 1\n                    res += 1\n                right += 2\n            else:\n                right -= 1\n                if right < 0:\n                    right += 2\n                    res += 1\n        return res + right"}
{"id": "1282", "path": "output2\\py\\Medium\\1282-find-kth-bit-in-nth-binary-string.py", "hypo_code": "class Solution(object):\n    def findKthBit(self, n, k):\n        \n        def invert(s):\n            return ''.join(['1' if c == '0' else '0' for c in s])\n\n        if n == 1:\n            return '0'\n\n        s = '0'\n        for i in range(2, n + 1):\n            s = s + '1' + invert(s[::-1])\n\n        return s[k - 1]"}
{"id": "1283", "path": "output2\\py\\Medium\\1283-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target.py", "hypo_code": "class Solution(object):\n    def maxNonOverlapping(self, nums, target):\n        \n        res = 0\n        cur = 0\n        visited = set()\n        visited.add(0)\n        for num in nums:\n            cur += num\n            if cur - target in visited:\n                res += 1\n                visited = set()\n            visited.add(cur)\n        return res"}
{"id": "1284", "path": "output2\\py\\Medium\\1284-minimum-operations-to-make-array-equal.py", "hypo_code": "class Solution(object):\n    def minOperations(self, n):\n        \n        return n * n / 4"}
{"id": "1285", "path": "output2\\py\\Medium\\1285-magnetic-force-between-two-balls.py", "hypo_code": "class Solution(object):\n    def maxDistance(self, position, m):\n        \n        position.sort()\n        n = len(position)\n        l = 1\n        r = position[-1] - position[0]\n        while l < r:\n            mid = (l + r + 1) / 2\n            count = 1\n            cur = position[0]\n            for i in range(1, n):\n                if position[i] - cur >= mid:\n                    cur = position[i]\n                    count += 1\n            if count >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l"}
{"id": "1286", "path": "output2\\py\\Medium\\1286-minimum-number-of-vertices-to-reach-all-nodes.py", "hypo_code": "class Solution(object):\n    def findSmallestSetOfVertices(self, n, edges):\n        \n        in_degree=[0]*n\n        for edge in edges:\n            in_degree[edge[1]]+=1\n        return [i for i in range(n) if in_degree[i]==0]"}
{"id": "1287", "path": "output2\\py\\Medium\\1287-minimum-numbers-of-function-calls-to-make-target-array.py", "hypo_code": "class Solution(object):\n    def minOperations(self, nums):\n        \n        res = 0\n        max_bit = 0\n        for num in nums:\n            bit = 0\n            while num:\n                if num & 1:\n                    res += 1\n                num >>= 1\n                bit += 1\n            max_bit = max(max_bit, bit)\n        return res + max_bit - 1"}
{"id": "1288", "path": "output2\\py\\Medium\\1288-detect-cycles-in-2d-grid.py", "hypo_code": "class Solution(object):\n    def containsCycle(self, grid):\n        \n        \n        \n        \n        visited = {}\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if (i, j) not in visited:\n                    if self.dfs(grid, i, j, visited, None):\n                        return True\n        return False"}
{"id": "1289", "path": "output2\\py\\Medium\\1289-maximum-number-of-coins-you-can-get.py", "hypo_code": "class Solution(object):\n    def maxCoins(self, piles):\n        \n        piles.sort()\n        return sum(piles[len(piles)//3::2])"}
{"id": "1290", "path": "output2\\py\\Medium\\1290-find-latest-group-of-size-m.py", "hypo_code": "class Solution(object):\n    def findLatestStep(self, arr, m):\n        \n        if m==len(arr):\n            return m\n        if m==1:\n            return len(arr)\n        if m==0:\n            return -1\n        arr.sort()\n        arr.append(None)\n        count=1\n        for i in range(1,len(arr)):\n            if arr[i]==arr[i-1]+1:\n                count+=1\n            else:\n                if count==m:\n                    return len(arr)-i\n                count=1\n        return -1"}
{"id": "1291", "path": "output2\\py\\Medium\\1291-maximum-length-of-subarray-with-positive-product.py", "hypo_code": "class Solution(object):\n    def getMaxLen(self, nums):\n        \n        res = 0\n        pos = 0\n        neg = 0\n        for num in nums:\n            if num > 0:\n                pos += 1\n                if neg:\n                    neg += 1\n            elif num < 0:\n                pos, neg = neg + 1, pos + 1\n            else:\n                pos, neg = 0, 0\n            res = max(res, pos)\n        return res"}
{"id": "1292", "path": "output2\\py\\Medium\\1292-number-of-ways-to-split-a-string.py", "hypo_code": "class Solution(object):\n    def numWays(self, s):\n        \n        if len(s)==1:\n            return 0\n        if len(s)==2:\n            return 0\n        if len(s)==3:\n            return 0\n        if len(s)==4:\n            return 0\n        if len(s)==5:\n            return 0\n        if len(s)==6:\n            return 0\n        if len(s)==7:\n            return 0\n        if len(s)==8:\n            return 0\n        if len(s)==9:\n            return 0\n        if len(s)==10:\n            return 0\n        if len(s)==11:\n            return 0\n        if len(s)==12:\n            return 0\n        if len(s)==13:\n            return 0\n        if len(s)==14:\n            return 0\n        if len(s)==15:\n            return 0\n        if len(s)==16:\n            return 0\n        if len(s)==17:\n            return 0\n        if len(s)==18:\n            return 0\n        if len(s)==19:\n            return 0\n        if len(s)==20:\n            return 0\n        if len(s)==21:\n            return 0\n        if len(s)==22:\n            return 0\n        if len(s)==23:\n            return 0\n        if len(s)==24:\n            return 0\n        if len(s)==25:\n            return 0\n        if len(s)==26:\n            return 0\n        if len(s)==27:\n            return 0\n        if len(s)==28:\n            return 0\n        if len(s)==29:\n            return 0\n        if len(s)==30:\n            return 0\n        if len(s)==31:\n            return 0\n        if len(s)==32:\n            return 0\n        if len(s)==33:\n            return 0\n        if len(s)==34:\n            return 0\n        if len(s)==35:\n            return 0\n        if len(s)==36:\n            return 0\n        if len(s)==37:\n            return 0\n        if len(s)==38:\n            return 0\n        if len(s)==39:\n            return 0\n        if len(s)==40:\n            return 0\n        if len(s)==41:\n            return 0\n        if len(s)==42:\n            return 0"}
{"id": "1293", "path": "output2\\py\\Medium\\1293-shortest-subarray-to-be-removed-to-make-array-sorted.py", "hypo_code": "class Solution(object):\n    def findLengthOfShortestSubarray(self, arr):\n        \n        if len(arr)==1:\n            return 0\n        if len(arr)==2:\n            if arr[0]<=arr[1]:\n                return 0\n            else:\n                return 1\n        arr.sort()\n        arr.append(None)\n        count=1\n        for i in range(1,len(arr)):\n            if arr[i]==arr[i-1]+1:\n                count+=1\n            else:\n                if count==len(arr)-1:\n                    return 0\n                count=1\n        return len(arr)-1-count"}
{"id": "1294", "path": "output2\\py\\Medium\\1294-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers.py", "hypo_code": "class Solution(object):\n    def numTriplets(self, nums1, nums2):\n               \n        count=0\n        for i in range(len(nums1)):\n            for j in range(len(nums2)-1):\n                for k in range(j+1,len(nums2)):\n                    if nums1[i]*nums1[i]==nums2[j]*nums2[k]:\n                        count+=1\n        for i in range(len(nums2)):\n            for j in range(len(nums1)-1):\n                for k in range(j+1,len(nums1)):\n                    if nums2[i]*nums2[i]==nums1[j]*nums1[k]:\n                        count+=1\n        return count"}
{"id": "1295", "path": "output2\\py\\Medium\\1295-minimum-time-to-make-rope-colorful.py", "hypo_code": "class Solution(object):\n    def minCost(self, colors, neededTime):\n        \n        if len(colors)==1:\n            return neededTime[0]\n        if len(colors)==2:\n            if colors[0]==colors[1]:\n                return min(neededTime[0],neededTime[1])\n            else:\n                return neededTime[0]+neededTime[1]\n        if colors[0]==colors[1]:\n            return min(neededTime[0]+self.minCost(colors[1:],neededTime[1:]),self.minCost(colors[1:],neededTime[1:]))\n        else:\n            return neededTime[0]+self.minCost(colors[1:],neededTime[1:])"}
{"id": "1296", "path": "output2\\py\\Medium\\1296-count-unhappy-friends.py", "hypo_code": "class Solution(object):\n    def unhappyFriends(self, n, preferences, pairs):\n        \n        res = 0\n        d = {}\n        for i, j in pairs:\n            d[i] = j\n            d[j] = i\n        for i in range(n):\n            for j in preferences[i]:\n                if j == d[i]:\n                    break\n                if i in preferences[j]:\n                    res += 1\n                    break\n        return res"}
{"id": "1297", "path": "output2\\py\\Medium\\1297-min-cost-to-connect-all-points.py", "hypo_code": "class Solution(object):\n    def minCostConnectPoints(self, points):\n        \n        dist = lambda x, y: abs(points[x][0] - points[y][0]) + abs(points[x][1] - points[y][1])\n        res = 0\n        n = len(points)\n        visited = set()\n        visited.add(0)\n        pq = []\n        for i in range(1, n):\n            heapq.heappush(pq, (dist(0, i), i))\n        while len(visited) < n:\n            d, i = heapq.heappop(pq)\n            if i in visited:\n                continue\n            visited.add(i)\n            res += d\n            for j in range(n):\n                if j in visited:\n                    continue\n                heapq.heappush(pq, (dist(i, j), j))\n        return res"}
{"id": "1298", "path": "output2\\py\\Medium\\1298-maximum-sum-obtained-of-any-permutation.py", "hypo_code": "class Solution(object):\n    def maxSumRangeQuery(self, nums, requests):\n        \n        mod = 10 ** 9 + 7\n        n = len(nums)\n        count = [0] * (n + 1)\n        for start, end in requests:\n            count[start] += 1\n            count[end + 1] -= 1\n        for i in range(1, n):\n            count[i] += count[i - 1]\n        count.pop()\n        nums.sort()\n        count.sort()\n        return sum(num * c for num, c in zip(nums, count)) % mod"}
{"id": "1299", "path": "output2\\py\\Medium\\1299-make-sum-divisible-by-p.py", "hypo_code": "class Solution(object):\n    def minSubarray(self, nums, p):\n        \n        mod = sum(nums) % p\n        if mod == 0:\n            return 0\n        res = len(nums)\n        cur = 0\n        count = {0: -1}\n        for i, num in enumerate(nums):\n            cur += num\n            count[cur % p] = i\n            if (cur - mod) % p in count:\n                res = min(res, i - count[(cur - mod) % p])\n        return res if res < len(nums) else -1"}
{"id": "1300", "path": "output2\\py\\Medium\\1300-split-a-string-into-the-max-number-of-unique-substrings.py", "hypo_code": "class Solution(object):\n    def maxUniqueSplit(self, s):\n        \n        res = 0\n        def dfs(s, visited):\n            nonlocal res\n            if not s:\n                res = max(res, len(visited))\n                return\n            for i in range(1, len(s) + 1):\n                if s[:i] not in visited:\n                    dfs(s[i:], visited | {s[:i]})\n        dfs(s, set())\n        return res"}
{"id": "1301", "path": "output2\\py\\Medium\\1301-maximum-non-negative-product-in-a-matrix.py", "hypo_code": "class Solution(object):\n    def maxProductPath(self, grid):\n        \n        m, n = len(grid), len(grid[0])\n        mod = 10 ** 9 + 7\n        dp = [[[0, 0] for j in range(n)] for i in range(m)]\n        dp[0][0] = [grid[0][0], grid[0][0]]\n        for i in range(1, m):\n            dp[i][0] = [dp[i - 1][0][0] * grid[i][0], dp[i - 1][0][1] * grid[i][0]]\n        for j in range(1, n):\n            dp[0][j] = [dp[0][j - 1][0] * grid[0][j], dp[0][j - 1][1] * grid[0][j]]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = [max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j], min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j]]\n        return dp[m - 1][n - 1][0] % mod if dp[m - 1][n - 1][0] >= 0 else -1"}
{"id": "1302", "path": "output2\\py\\Medium\\1302-maximum-profit-of-operating-a-centennial-wheel.py", "hypo_code": "class Solution(object):\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\n        \n        res = 0\n        wait = 0\n        profit = 0\n        max_profit = 0\n        i = 0\n        while wait or i < len(customers):\n            if i < len(customers):\n                wait += customers[i]\n            board = min(wait, 4)\n            wait -= board\n            profit += board * boardingCost - runningCost\n            if profit > max_profit:\n                max_profit = profit\n                res = i + 1\n            i += 1\n        return res if max_profit else -1"}
{"id": "1304", "path": "output2\\py\\Medium\\1304-alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.py", "hypo_code": "class Solution(object):\n    def alertNames(self, keyName, keyTime):\n        \n        d = collections.defaultdict(list)\n        for i, j in zip(keyName, keyTime):\n            h, m = j.split(':')\n            d[i].append(int(h) * 60 + int(m))\n        res = []\n        for i in d:\n            times = sorted(d[i])\n            for j in range(2, len(times)):\n                if times[j] - times[j - 2] <= 60:\n                    res.append(i)\n                    break\n        return sorted(res)"}
{"id": "1305", "path": "output2\\py\\Medium\\1305-find-valid-matrix-given-row-and-column-sums.py", "hypo_code": "class Solution(object):\n    def restoreMatrix(self, rowSum, colSum):\n        \n        m, n = len(rowSum), len(colSum)\n        res = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                res[i][j] = min(rowSum[i], colSum[j])\n                rowSum[i] -= res[i][j]\n                colSum[j] -= res[i][j]\n        return res"}
{"id": "1306", "path": "output2\\py\\Medium\\1306-even-odd-tree.py", "hypo_code": "class Solution(object):\n    def isEvenOddTree(self, root):\n        \n        level = [root]\n        even = True\n        while level:\n            if even:\n                if any(node.val % 2 == 0 or (i and node.val <= level[i - 1].val) for i, node in enumerate(level)):\n                    return False\n            else:\n                if any(node.val % 2 == 1 or (i and node.val >= level[i - 1].val) for i, node in enumerate(level)):\n                    return False\n            even = not even\n            level = [child for node in level for child in (node.left, node.right) if child]\n        return True"}
{"id": "1307", "path": "output2\\py\\Medium\\1307-maximal-network-rank.py", "hypo_code": "class Solution(object):\n    def maximalNetworkRank(self, n, roads):\n        \n        res = 0\n        adj = collections.defaultdict(set)\n        for u, v in roads:\n            adj[u].add(v)\n            adj[v].add(u)\n        for i in range(n):\n            for j in range(i + 1, n):\n                res = max(res, len(adj[i]) + len(adj[j]) - (i in adj[j]))\n        return res"}
{"id": "1308", "path": "output2\\py\\Medium\\1308-split-two-strings-to-make-palindrome.py", "hypo_code": "class Solution(object):\n    def checkPalindromeFormation(self, a, b):"}
{"id": "1309", "path": "output2\\py\\Medium\\1309-coordinate-with-maximum-network-quality.py", "hypo_code": "class Solution(object):\n    def bestCoordinate(self, towers, radius):\n        \n        def dist(x,y):\n            return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\n        \n        ans = [0,0]\n        maxq = 0\n        for i in range(51):\n            for j in range(51):\n                q = 0\n                for t in towers:\n                    if dist([i,j],t) <= radius:\n                        q += t[2]/(1+dist([i,j],t))\n                if q > maxq:\n                    maxq = q\n                    ans = [i,j]\n        return ans"}
{"id": "1310", "path": "output2\\py\\Medium\\1310-number-of-sets-of-k-non-overlapping-line-segments.py", "hypo_code": "class Solution(object):\n    def numberOfSets(self, n, k):\n        \n        def C(n,k):\n            if k > n:\n                return 0\n            if k == 0 or k == n:\n                return 1\n            return C(n-1,k)+C(n-1,k-1)\n        ans = 1\n        for i in range(1,k+1):\n            ans *= C(n-1,i)\n        return ans%(10**9+7)"}
{"id": "1311", "path": "output2\\py\\Medium\\1311-lexicographically-smallest-string-after-applying-operations.py", "hypo_code": "class Solution(object):\n    def findLexSmallestString(self, s, a, b):\n        \n        def rotate(s, b):\n            return s[-b:]+s[:-b]\n\n        def add(s, a):\n            res = ''\n            for i in range(len(s)):\n                if i % 2 == 1:\n                    res += str((int(s[i])+a)%10)\n                else:\n                    res += s[i]\n            return res\n\n        def dfs(s):\n            if s in visited:\n                return\n            visited.add(s)\n            nonlocal res\n            res = min(res, s)\n            dfs(rotate(s, b))\n            dfs(add(s, a))\n\n        res = s\n        visited = set()\n        dfs(s)\n        return res"}
{"id": "1312", "path": "output2\\py\\Medium\\1312-best-team-with-no-conflicts.py", "hypo_code": "class Solution(object):\n    def bestTeamScore(self, scores, ages):\n        \n        data = sorted(zip(ages, scores))\n        dp = [0] * len(data)\n        for i in range(len(data)):\n            dp[i] = data[i][1]\n            for j in range(i):\n                if data[j][1] <= data[i][1]:\n                    dp[i] = max(dp[i], dp[j] + data[i][1])\n        return max(dp)"}
{"id": "1313", "path": "output2\\py\\Medium\\1313-arithmetic-subarrays.py", "hypo_code": "class Solution(object):\n    def checkArithmeticSubarrays(self, nums, l, r):\n        \n        def check(nums):\n            nums.sort()\n            diff = nums[1] - nums[0]\n            for i in range(2, len(nums)):\n                if nums[i] - nums[i-1] != diff:\n                    return False\n            return True\n        \n        res = []\n        for i in range(len(l)):\n            res.append(check(nums[l[i]:r[i]+1]))\n        return res"}
{"id": "1314", "path": "output2\\py\\Medium\\1314-path-with-minimum-effort.py", "hypo_code": "class Solution(object):\n    def minimumEffortPath(self, heights):\n        \n        def find(x):\n            if x != uf[x]:\n                uf[x] = find(uf[x])\n            return uf[x]\n        \n        def union(x, y):\n            uf[find(x)] = find(y)\n        \n        m, n = len(heights), len(heights[0])\n        edges = []\n        for i in range(m):\n            for j in range(n):\n                idx = i*n+j\n                if i > 0:\n                    edges.append((idx-n, idx, abs(heights[i][j]-heights[i-1][j])))\n                if j > 0:\n                    edges.append((idx-1, idx, abs(heights[i][j]-heights[i][j-1])))\n        edges.sort(key=lambda x: x[2])\n        uf = range(m*n)\n        for edge in edges:\n            union(edge[0], edge[1])\n            if find(0) == find(m*n-1):\n                return edge[2]\n        return 0"}
{"id": "1315", "path": "output2\\py\\Medium\\1315-widest-vertical-area-between-two-points-containing-no-points.py", "hypo_code": "class Solution(object):\n    def maxWidthOfVerticalArea(self, points):\n        \n        points.sort()\n        res = 0\n        for i in range(1, len(points)):\n            res = max(res, points[i][0] - points[i-1][0])\n        return res"}
{"id": "1316", "path": "output2\\py\\Medium\\1316-count-substrings-that-differ-by-one-character.py", "hypo_code": "class Solution(object):\n    def countSubstrings(self, s, t):\n        \n        def check(s, t):\n            res = 0\n            for i in range(len(s)):\n                if s[i] != t[i]:\n                    res += 1\n            return res == 1\n        \n        res = 0\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if check(s[i:], t[j:]):\n                    res += 1\n        return res"}
{"id": "1317", "path": "output2\\py\\Medium\\1317-count-sorted-vowel-strings.py", "hypo_code": "class Solution(object):\n    def countVowelStrings(self, n):\n        \n        return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24"}
{"id": "1318", "path": "output2\\py\\Medium\\1318-furthest-building-you-can-reach.py", "hypo_code": "class Solution(object):\n    def furthestBuilding(self, heights, bricks, ladders):\n          \n        heap = []\n        for i in range(len(heights)-1):\n            diff = heights[i+1] - heights[i]\n            if diff > 0:\n                heapq.heappush(heap, diff)\n                if len(heap) > ladders:\n                    bricks -= heapq.heappop(heap)\n                if bricks < 0:\n                    return i\n        return len(heights) - 1"}
{"id": "1319", "path": "output2\\py\\Medium\\1319-minimum-deletions-to-make-character-frequencies-unique.py", "hypo_code": "class Solution(object):\n    def minDeletions(self, s):\n        \n        cnt = collections.Counter(s)\n        res = 0\n        seen = set()\n        for c in cnt:\n            while cnt[c] in seen:\n                cnt[c] -= 1\n                res += 1\n            seen.add(cnt[c])\n        return res"}
{"id": "1320", "path": "output2\\py\\Medium\\1320-sell-diminishing-valued-colored-balls.py", "hypo_code": "class Solution(object):\n    def maxProfit(self, inventory, orders):\n        \n        l, r = 0, max(inventory)\n        while l < r:\n            mid = (l + r + 1) / 2\n            if sum(max(0, x - mid) for x in inventory) < orders:\n                r = mid - 1\n            else:\n                l = mid\n        res = 0\n        for x in inventory:\n            if x > l:\n                orders -= x - l\n                res += (x + l + 1) * (x - l) / 2\n        res += orders * l\n        return res % (10**9 + 7)"}
{"id": "1321", "path": "output2\\py\\Medium\\1321-minimum-deletions-to-make-string-balanced.py", "hypo_code": "class Solution(object):\n    def minimumDeletions(self, s):\n        \n        a, b = 0, 0\n        for c in s:\n            if c == 'a':\n                a += 1\n            else:\n                b = min(a, b+1)\n        return b"}
{"id": "1322", "path": "output2\\py\\Medium\\1322-minimum-jumps-to-reach-home.py", "hypo_code": "class Solution(object):\n    def minimumJumps(self, forbidden, a, b, x):\n        \n        forbidden = set(forbidden)\n        q = collections.deque()\n        q.append((0, 0, False))\n        visited = set()\n        visited.add((0, False))\n        while q:\n            cur, step, backward = q.popleft()\n            if cur == x:\n                return step\n            if cur + a <= 6000 and (cur + a, False) not in visited and cur + a not in forbidden:\n                visited.add((cur + a, False))\n                q.append((cur + a, step + 1, False))\n            if cur - b > 0 and (cur - b, True) not in visited and cur - b not in forbidden and not backward:\n                visited.add((cur - b, True))\n                q.append((cur - b, step + 1, True))\n        return -1"}
{"id": "1323", "path": "output2\\py\\Medium\\1323-determine-if-two-strings-are-close.py", "hypo_code": "class Solution(object):\n    def closeStrings(self, word1, word2):\n        \n        if len(word1) != len(word2):\n            return False\n        cnt1 = collections.Counter(word1)\n        cnt2 = collections.Counter(word2)\n        return set(cnt1.keys()) == set(cnt2.keys()) and sorted(cnt1.values()) == sorted(cnt2.values())"}
{"id": "1324", "path": "output2\\py\\Medium\\1324-minimum-operations-to-reduce-x-to-zero.py", "hypo_code": "class Solution(object):\n    def minOperations(self, nums, x):\n        \n        target = sum(nums) - x\n        if target == 0:\n            return len(nums)\n        if target < 0:\n            return -1\n        res = -1\n        l, r, s = 0, 0, 0\n        while r < len(nums):\n            s += nums[r]\n            while s > target and l <= r:\n                s -= nums[l]\n                l += 1\n            if s == target:\n                res = max(res, r - l + 1)\n            r += 1\n        return len(nums) - res if res != -1 else -1"}
{"id": "1325", "path": "output2\\py\\Medium\\1325-smallest-string-with-a-given-numeric-value.py", "hypo_code": "class Solution(object):\n    def getSmallestString(self, n, k):\n        \n        res = ''\n        while k > 0:\n            if k - 26 >= n - len(res) - 1:\n                res += 'z'\n                k -= 26\n            else:\n                res += chr(ord('a') + k - n + len(res))\n                k = n - len(res)\n        return res[::-1]"}
{"id": "1326", "path": "output2\\py\\Medium\\1326-ways-to-make-a-fair-array.py", "hypo_code": "class Solution(object):\n    def waysToMakeFair(self, nums):\n        \n        res = 0\n        l, r = [0, 0], [sum(nums[::2]), sum(nums[1::2])]\n        for i, x in enumerate(nums):\n            r[i%2] -= x\n            res += l[0] + r[1] == l[1] + r[0]\n            l[i%2] += x\n        return res"}
{"id": "1327", "path": "output2\\py\\Medium\\1327-merge-in-between-linked-lists.py", "hypo_code": "class Solution(object):\n    def mergeInBetween(self, list1, a, b, list2):\n        \n        before = after = list1\n        for i in range(b+1):\n            if i == a-1:\n                before = before.next\n            after = after.next\n        before.next = list2\n        while list2.next:\n            list2 = list2.next\n        list2.next = after\n        return list1"}
{"id": "1329", "path": "output2\\py\\Medium\\1329-find-the-most-competitive-subsequence.py", "hypo_code": "class Solution(object):\n    def mostCompetitive(self, nums, k):\n        \n        if k==1:\n            return [min(nums)]\n        if k==len(nums):\n            return nums\n        nums.append(None)\n        count=1\n        for i in range(1,len(nums)):\n            if nums[i]==nums[i-1]:\n                count+=1\n            else:\n                if count==k:\n                    return nums[i-k:i]\n                count=1\n        return nums[len(nums)-k-1:len(nums)-1]"}
{"id": "1330", "path": "output2\\py\\Medium\\1330-minimum-moves-to-make-array-complementary.py", "hypo_code": "class Solution(object):\n    def minMoves(self, nums, limit):\n        \n        if len(nums)==2:\n            return min(nums[0],nums[1])\n        if len(nums)==4:\n            return min(nums[0]+nums[1],nums[2]+nums[3])\n        if nums[0]+nums[-1]==limit:\n            return self.minMoves(nums[1:-1],limit)\n        else:\n            return min(nums[0]+nums[-1]+self.minMoves(nums[1:-1],limit),limit+self.minMoves(nums[1:-1],limit))"}
{"id": "1331", "path": "output2\\py\\Medium\\1331-max-number-of-k-sum-pairs.py", "hypo_code": "class Solution(object):\n    def maxOperations(self, nums, k):\n        \n        res = 0\n        d = collections.Counter(nums)\n        for x in nums:\n            if d[x] and d[k - x]:\n                d[x] -= 1\n                d[k - x] -= 1\n                res += 1\n        return res"}
{"id": "1332", "path": "output2\\py\\Medium\\1332-concatenation-of-consecutive-binary-numbers.py", "hypo_code": "class Solution(object):\n    def concatenatedBinary(self, n):\n        \n        res = 0\n        for i in range(1, n + 1):\n            res = ((res << len(bin(i)) - 2) + i) % (10 ** 9 + 7)\n        return res"}
{"id": "1333", "path": "output2\\py\\Medium\\1333-sum-of-absolute-differences-in-a-sorted-array.py", "hypo_code": "class Solution(object):\n    def getSumAbsoluteDifferences(self, nums):\n               \n        result=[]\n        for i in range(len(nums)):\n            result.append(sum([abs(nums[i]-nums[j]) for j in range(len(nums)) if i!=j]))\n        return result"}
{"id": "1334", "path": "output2\\py\\Medium\\1334-stone-game-vi.py", "hypo_code": "class Solution(object):\n    def stoneGameVI(self, aliceValues, bobValues):\n              \n        aliceValues = sorted(aliceValues, reverse=True)\n        bobValues = sorted(bobValues, reverse=True)\n        aliceScore = 0\n        bobScore = 0\n        for i in range(len(aliceValues)):\n            if i%2==0:\n                aliceScore += aliceValues[i]\n            else:\n                bobScore += bobValues[i]\n        if aliceScore > bobScore:\n            return 1\n        elif aliceScore < bobScore:\n            return -1\n        else:\n            return 0"}
{"id": "1335", "path": "output2\\py\\Medium\\1335-partitioning-into-minimum-number-of-deci-binary-numbers.py", "hypo_code": "class Solution(object):\n    def minPartitions(self, n):\n             \n        return max([int(i) for i in n])"}
{"id": "1336", "path": "output2\\py\\Medium\\1336-stone-game-vii.py", "hypo_code": "class Solution(object):\n    def stoneGameVII(self, stones):\n            \n        return self.stoneGameVIIHelper(stones, 0, len(stones)-1, 0, 0, True)"}
{"id": "1337", "path": "output2\\py\\Medium\\1337-maximum-erasure-value.py", "hypo_code": "class Solution(object):\n    def maximumUniqueSubarray(self, nums):\n        \n        result=0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)+1):\n                if len(set(nums[i:j]))==len(nums[i:j]):\n                    result=max(result,sum(nums[i:j]))\n        return result"}
{"id": "1338", "path": "output2\\py\\Medium\\1338-jump-game-vi.py", "hypo_code": "class Solution(object):\n    def maxResult(self, nums, k):\n        \n        result=0\n        for i in range(len(nums)):\n            for j in range(i+1,min(len(nums),i+k)+1):\n                if len(set(nums[i:j]))==len(nums[i:j]):\n                    result=max(result,sum(nums[i:j]))\n        return result"}
{"id": "1339", "path": "output2\\py\\Medium\\1339-average-waiting-time.py", "hypo_code": "class Solution(object):\n    def averageWaitingTime(self, customers):\n        \n        result=0\n        for i in range(len(customers)):\n            if i==0:\n                result+=customers[i][1]\n            else:\n                if customers[i][0]>=customers[i-1][0]+customers[i-1][1]:\n                    result+=customers[i][1]\n                else:\n                    result+=customers[i][1]+customers[i-1][0]+customers[i-1][1]-customers[i][0]\n        return result/len(customers)"}
{"id": "1340", "path": "output2\\py\\Medium\\1340-maximum-binary-string-after-change.py", "hypo_code": "class Solution(object):\n    def maximumBinaryString(self, binary):\n        \n        result=0\n        for i in range(len(binary)):\n            for j in range(i+1,len(binary)+1):\n                if len(set(binary[i:j]))==len(binary[i:j]):\n                    result=max(result,sum(binary[i:j]))\n        return result"}
{"id": "1341", "path": "output2\\py\\Medium\\1341-maximum-number-of-eaten-apples.py", "hypo_code": "class Solution(object):\n    def eatenApples(self, apples, days):\n        \n        result = 0\n        for i in range(len(apples)):\n            if apples[i] > 0:\n                for j in range(i, i+days[i]):\n                    if j < len(apples) and apples[j] > 0:\n                        apples[j] -= 1\n                        result += 1\n                        break\n        return result"}
{"id": "1342", "path": "output2\\py\\Medium\\1342-where-will-the-ball-fall.py", "hypo_code": "class Solution(object):\n    def findBall(self, grid):\n        \n        result=[]\n        for i in range(len(grid[0])):\n            result.append(self.findBallHelper(grid,i))\n        return result"}
{"id": "1343", "path": "output2\\py\\Medium\\1343-count-good-meals.py", "hypo_code": "class Solution(object):\n    def countPairs(self, deliciousness):\n        \n        res = 0\n        d = collections.Counter()\n        for x in deliciousness:\n            for i in range(22):\n                res += d[(1 << i) - x]\n            d[x] += 1\n        return res % (10 ** 9 + 7)"}
{"id": "1344", "path": "output2\\py\\Medium\\1344-ways-to-split-array-into-three-subarrays.py", "hypo_code": "class Solution(object):\n    def waysToSplit(self, nums):\n        \n        res = 0\n        l, r = [0, 0], [sum(nums[::2]), sum(nums[1::2])]\n        for i, x in enumerate(nums):\n            r[i%2] -= x\n            res += l[0] <= l[1] <= r[0]\n            l[i%2] += x\n        return res % (10 ** 9 + 7)"}
{"id": "1345", "path": "output2\\py\\Medium\\1345-maximum-score-from-removing-substrings.py", "hypo_code": "class Solution(object):\n    def maximumGain(self, s, x, y):\n        \n        result=0\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                if len(set(s[i:j]))==len(s[i:j]):\n                    result=max(result,sum(s[i:j]))\n        return result"}
{"id": "1346", "path": "output2\\py\\Medium\\1346-construct-the-lexicographically-largest-valid-sequence.py", "hypo_code": "class Solution(object):\n    def constructDistancedSequence(self, n):\n               \n        result = [0] * (2*n-1)\n        self.constructDistancedSequenceHelper(n, result, 0)\n        return result"}
{"id": "1347", "path": "output2\\py\\Medium\\1347-swapping-nodes-in-a-linked-list.py", "hypo_code": "class Solution(object):\n    def swapNodes(self, head, k):\n        \n        result=[]\n        while head:\n            result.append(head.val)\n            head=head.next\n        result[k-1],result[len(result)-k]=result[len(result)-k],result[k-1]\n        return result"}
{"id": "1348", "path": "output2\\py\\Medium\\1348-minimize-hamming-distance-after-swap-operations.py", "hypo_code": "class Solution(object):\n    def minimumHammingDistance(self, source, target, allowedSwaps):\n               \n        result = 0\n        for i in range(len(source)):\n            if source[i] != target[i]:\n                for j in range(i+1, len(source)):\n                    if source[j] == target[i]:\n                        source[i], source[j] = source[j], source[i]\n                        result += 1\n                        break\n        return result"}
{"id": "1349", "path": "output2\\py\\Medium\\1349-tuple-with-same-product.py", "hypo_code": "class Solution(object):\n    def tupleSameProduct(self, nums):\n        \n        result=0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                for k in range(j+1,len(nums)):\n                    for l in range(k+1,len(nums)):\n                        if nums[i]*nums[j]==nums[k]*nums[l]:\n                            result+=1\n        return result*8"}
{"id": "1350", "path": "output2\\py\\Medium\\1350-largest-submatrix-with-rearrangements.py", "hypo_code": "class Solution(object):\n    def largestSubmatrix(self, matrix):\n        \n        result=0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j]==1:\n                    matrix[i][j]=matrix[i-1][j]+1\n        for i in range(len(matrix)):\n            matrix[i].sort(reverse=True)\n            for j in range(len(matrix[0])):\n                result=max(result,matrix[i][j]*(j+1))\n        return result"}
{"id": "1351", "path": "output2\\py\\Medium\\1351-minimum-number-of-people-to-teach.py", "hypo_code": "class Solution(object):\n    def minimumTeachings(self, n, languages, friendships):\n                                                                                                       \n        \n        \n        \n        \n        users = self.get_users(languages)\n        needs = self.get_needs(users, friendships)\n        counts = self.get_counts(needs)\n        return self.get_min(counts)"}
{"id": "1352", "path": "output2\\py\\Medium\\1352-decode-xored-permutation.py", "hypo_code": "class Solution(object):\n    def decode(self, encoded):\n        \n        n=len(encoded)+1\n        total=0\n        for i in range(1,n+1):\n            total^=i\n        odd=0\n        for i in range(1,n-1,2):\n            odd^=encoded[i]\n        perm=[total^odd]\n        for i in range(n-1):\n            perm.append(perm[-1]^encoded[i])\n        return perm"}
{"id": "1353", "path": "output2\\py\\Medium\\1353-change-minimum-characters-to-satisfy-one-of-three-conditions.py", "hypo_code": "class Solution(object):\n    def minCharacters(self, a, b):\n               \n        \n        \n        \n        a_freq = self.get_freq(a)\n        b_freq = self.get_freq(b)\n        return min(self.get_operations(a_freq, b_freq), self.get_operations(b_freq, a_freq), self.get_operations_same(a_freq, b_freq))"}
{"id": "1354", "path": "output2\\py\\Medium\\1354-find-kth-largest-xor-coordinate-value.py", "hypo_code": "class Solution(object):\n    def kthLargestValue(self, matrix, k):\n        \n        result=[]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i==0 and j==0:\n                    matrix[i][j]=matrix[i][j]\n                elif i==0:\n                    matrix[i][j]=matrix[i][j-1]^matrix[i][j]\n                elif j==0:\n                    matrix[i][j]=matrix[i-1][j]^matrix[i][j]\n                else:\n                    matrix[i][j]=matrix[i-1][j-1]^matrix[i-1][j]^matrix[i][j-1]^matrix[i][j]\n                result.append(matrix[i][j])\n        result.sort(reverse=True)\n        return result[k-1]"}
{"id": "1355", "path": "output2\\py\\Medium\\1355-restore-the-array-from-adjacent-pairs.py", "hypo_code": "class Solution(object):\n    def restoreArray(self, adjacentPairs):\n        \n        d = collections.defaultdict(list)\n        for x, y in adjacentPairs:\n            d[x].append(y)\n            d[y].append(x)\n        for x in d:\n            if len(d[x]) == 1:\n                res = [x]\n                break\n        while len(res) < len(adjacentPairs) + 1:\n            for x in d[res[-1]]:\n                if x not in res:\n                    res.append(x)\n                    break\n        return res"}
{"id": "1356", "path": "output2\\py\\Medium\\1356-can-you-eat-your-favorite-candy-on-your-favorite-day.py", "hypo_code": "class Solution(object):\n    def canEat(self, candiesCount, queries):\n        \n        res = []\n        \n        pre = [0]\n        for c in candiesCount:\n            pre.append(pre[-1] + c)\n        \n        for t, d, c in queries:\n            res.append(pre[t] // c <= d < pre[t+1])\n        return res"}
{"id": "1357", "path": "output2\\py\\Medium\\1357-maximum-absolute-sum-of-any-subarray.py", "hypo_code": "class Solution(object):\n    def maxAbsoluteSum(self, nums):\n        \n        res, s, t = 0, 0, 0\n        for x in nums:\n            s = max(s + x, x)\n            t = min(t + x, x)\n            res = max(res, s, abs(t))\n        return res"}
{"id": "1358", "path": "output2\\py\\Medium\\1358-minimum-length-of-string-after-deleting-similar-ends.py", "hypo_code": "class Solution(object):\n    def minimumLength(self, s):\n        \n        i, j = 0, len(s)-1\n        while i < j and s[i] == s[j]:\n            c = s[i]\n            while i <= j and s[i] == c:\n                i += 1\n            while i <= j and s[j] == c:\n                j -= 1\n        return j-i+1"}
{"id": "1359", "path": "output2\\py\\Medium\\1359-maximum-score-from-removing-stones.py", "hypo_code": "class Solution(object):\n    def maximumScore(self, a, b, c):\n         \n        return min((a+b+c)/2, a+b, b+c, c+a)"}
{"id": "1360", "path": "output2\\py\\Medium\\1360-largest-merge-of-two-strings.py", "hypo_code": "class Solution(object):\n    def largestMerge(self, word1, word2):\n        \n        res = []\n        while word1 or word2:\n            if word1 > word2:\n                res.append(word1[0])\n                word1 = word1[1:]\n            else:\n                res.append(word2[0])\n                word2 = word2[1:]\n        return ''.join(res)"}
{"id": "1361", "path": "output2\\py\\Medium\\1361-count-number-of-homogenous-substrings.py", "hypo_code": "class Solution(object):\n    def countHomogenous(self, s):\n        \n        res = 0\n        l = 0\n        for r in range(len(s)):\n            if s[r] != s[l]:\n                l = r\n            res += r - l + 1\n        return res % (10**9 + 7)"}
{"id": "1362", "path": "output2\\py\\Medium\\1362-minimum-limit-of-balls-in-a-bag.py", "hypo_code": "class Solution(object):\n    def minimumSize(self, nums, maxOperations):\n        \n        l, r = 1, max(nums)\n        while l < r:\n            mid = (l + r) / 2\n            if sum((x - 1) / mid for x in nums) > maxOperations:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}
{"id": "1363", "path": "output2\\py\\Medium\\1363-form-array-by-concatenating-subarrays-of-another-array.py", "hypo_code": "class Solution(object):\n    def canChoose(self, groups, nums):\n        \n        n, i = len(groups), 0\n        for j in range(len(nums)):\n            if nums[j] == groups[i][0]:\n                if nums[j:j+len(groups[i])] == groups[i]:\n                    i += 1\n                    if i == n:\n                        return True\n        return False"}
{"id": "1364", "path": "output2\\py\\Medium\\1364-map-of-highest-peak.py", "hypo_code": "class Solution(object):\n    def highestPeak(self, isWater):\n        \n        m, n = len(isWater), len(isWater[0])\n        res = [[-1]*n for _ in range(m)]\n        q = collections.deque()\n        for i in range(m):\n            for j in range(n):\n                if isWater[i][j] == 1:\n                    q.append((i,j))\n                    res[i][j] = 0\n        while q:\n            i, j = q.popleft()\n            for x, y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\n                if 0<=x<m and 0<=y<n and res[x][y] == -1:\n                    res[x][y] = res[i][j] + 1\n                    q.append((x,y))\n        return res"}
{"id": "1365", "path": "output2\\py\\Medium\\1365-minimum-number-of-operations-to-move-all-balls-to-each-box.py", "hypo_code": "class Solution(object):\n    def minOperations(self, boxes):\n        \n        res = [0] * len(boxes)\n        for i in range(len(boxes)):\n            for j in range(len(boxes)):\n                if boxes[j] == '1':\n                    res[i] += abs(i - j)\n        return res"}
{"id": "1366", "path": "output2\\py\\Medium\\1366-closest-dessert-cost.py", "hypo_code": "class Solution(object):\n    def closestCost(self, baseCosts, toppingCosts, target):\n        \n        def dfs(i, s):\n            if i == len(toppingCosts):\n                return s\n            return min(dfs(i + 1, s), dfs(i + 1, s + toppingCosts[i]), dfs(i + 1, s + toppingCosts[i] * 2), key=lambda x: (abs(x - target), x))\n        return min(dfs(0, x) for x in baseCosts)"}
{"id": "1367", "path": "output2\\py\\Medium\\1367-equal-sum-arrays-with-minimum-number-of-operations.py", "hypo_code": "class Solution(object):\n    def minOperations(self, nums1, nums2):\n        \n        s1, s2 = sum(nums1), sum(nums2)\n        if s1 > s2:\n            return self.minOperations(nums2, nums1)\n        if s1 == s2:\n            return 0\n        d = collections.Counter(6 - x for x in nums1) + collections.Counter(x - 1 for x in nums2)\n        res = 0\n        for x in range(5, 0, -1):\n            if s2 - s1 <= 0:\n                return res\n            if d[x]:\n                res += d[x]\n                s2 -= d[x] * x\n        return -1"}
{"id": "1368", "path": "output2\\py\\Medium\\1368-check-if-number-is-a-sum-of-powers-of-three.py", "hypo_code": "class Solution(object):\n    def checkPowersOfThree(self, n):\n        \n        while n:\n            if n % 3 == 2:\n                return False\n            n /= 3\n        return True"}
{"id": "1369", "path": "output2\\py\\Medium\\1369-sum-of-beauty-of-all-substrings.py", "hypo_code": "class Solution(object):\n    def beautySum(self, s):\n        \n        res = 0\n        for i in range(len(s)):\n            cnt = collections.Counter()\n            for j in range(i, len(s)):\n                cnt[s[j]] += 1\n                res += max(cnt.values()) - min(cnt.values())\n        return res"}
{"id": "1370", "path": "output2\\py\\Medium\\1370-minimum-elements-to-add-to-form-a-given-sum.py", "hypo_code": "class Solution(object):\n    def minElements(self, nums, limit, goal):\n        \n        return (abs(goal - sum(nums)) + limit - 1) // limit"}
{"id": "1371", "path": "output2\\py\\Medium\\1371-number-of-restricted-paths-from-first-to-last-node.py", "hypo_code": "class Solution(object):\n    def countRestrictedPaths(self, n, edges):\n           \n        g = collections.defaultdict(list)\n        for u, v, w in edges:\n            g[u].append((v, w))\n            g[v].append((u, w))\n        d = [float('inf')] * (n + 1)\n        d[n] = 0\n        q = collections.deque([n])\n        while q:\n            u = q.popleft()\n            for v, w in g[u]:\n                if d[v] > d[u] + w:\n                    d[v] = d[u] + w\n                    q.append(v)\n        dp = [0] * (n + 1)\n        dp[n] = 1\n        for _, u, v in sorted((d[i], i, j) for i in range(1, n + 1) for j, _ in g[i]):\n            dp[u] = (dp[u] + dp[v]) % (10**9 + 7)\n        return dp[1]"}
{"id": "1372", "path": "output2\\py\\Medium\\1372-maximum-average-pass-ratio.py", "hypo_code": "class Solution(object):\n    def maxAverageRatio(self, classes, extraStudents):\n        \n        def profit(a, b):\n            return float(a+1)/(b+1) - float(a)/b\n        heap = []\n        for a, b in classes:\n            heapq.heappush(heap, (-profit(a, b), a, b))\n        for _ in xrange(extraStudents):\n            _, a, b = heapq.heappop(heap)\n            heapq.heappush(heap, (-profit(a+1, b+1), a+1, b+1))\n        return sum(float(a)/b for _, a, b in heap) / len(heap)"}
{"id": "1374", "path": "output2\\py\\Medium\\1374-maximum-number-of-consecutive-values-you-can-make.py", "hypo_code": "class Solution(object):\n    def getMaximumConsecutive(self, coins):\n        \n        res = 1\n        for x in sorted(coins):\n            if x > res:\n                break\n            res += x\n        return res"}
{"id": "1375", "path": "output2\\py\\Medium\\1375-number-of-orders-in-the-backlog.py", "hypo_code": "class Solution(object):\n    def getNumberOfBacklogOrders(self, orders):\n         \n        buy = []\n        sell = []\n        for price, amount, orderType in orders:\n            if orderType == 0:\n                heapq.heappush(buy, (-price, amount))\n            else:\n                heapq.heappush(sell, (price, amount))\n            while buy and sell and -buy[0][0] >= sell[0][0]:\n                b = heapq.heappop(buy)\n                s = heapq.heappop(sell)\n                if b[1] > s[1]:\n                    heapq.heappush(buy, (b[0], b[1] - s[1]))\n                elif b[1] < s[1]:\n                    heapq.heappush(sell, (s[0], s[1] - b[1]))\n        return sum(amount for _, amount in buy + sell) % (10**9 + 7)"}
{"id": "1376", "path": "output2\\py\\Medium\\1376-maximum-value-at-a-given-index-in-a-bounded-array.py", "hypo_code": "class Solution(object):\n    def maxValue(self, n, index, maxSum):\n        \n        def f(x):\n            if x <= index:\n                return (x + 1) * x // 2 + index - x\n            else:\n                return (n - x + 1 + n - index) * (x - index) // 2\n        maxSum -= n\n        l, r = 0, maxSum + 1\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if f(mid) <= maxSum:\n                l = mid\n            else:\n                r = mid - 1\n        return l + 1"}
{"id": "1377", "path": "output2\\py\\Medium\\1377-minimum-number-of-operations-to-reinitialize-a-permutation.py", "hypo_code": "class Solution(object):\n    def reinitializePermutation(self, n):\n        \n        res = 0\n        i = 1\n        while True:\n            i = i * 2 % (n - 1)\n            res += 1\n            if i == 1:\n                break\n        return res"}
{"id": "1378", "path": "output2\\py\\Medium\\1378-evaluate-the-bracket-pairs-of-a-string.py", "hypo_code": "class Solution(object):\n    def evaluate(self, s, knowledge):\n        \n        d = dict(knowledge)\n        res = ''\n        i = 0\n        while i < len(s):\n            if s[i] == '(':\n                j = i + 1\n                while j < len(s) and s[j] != ')':\n                    j += 1\n                res += d.get(s[i+1:j], '?')\n                i = j + 1\n            else:\n                res += s[i]\n                i += 1\n        return res"}
{"id": "1379", "path": "output2\\py\\Medium\\1379-sentence-similarity-iii.py", "hypo_code": "class Solution(object):\n    def areSentencesSimilar(self, sentence1, sentence2):\n        \n        if len(sentence1) < len(sentence2):\n            sentence1, sentence2 = sentence2, sentence1\n        s1 = sentence1.split()\n        s2 = sentence2.split()\n        if len(s1) < len(s2):\n            return False\n        i = 0\n        while i < len(s2) and s1[i] == s2[i]:\n            i += 1\n        j = 0\n        while j < len(s2) and s1[-j-1] == s2[-j-1]:\n            j += 1\n        return i + j >= len(s2)"}
{"id": "1380", "path": "output2\\py\\Medium\\1380-count-nice-pairs-in-an-array.py", "hypo_code": "class Solution(object):\n    def countNicePairs(self, nums):\n               \n        from collections import Counter\n        cnt = Counter()\n        for num in nums:\n            cnt[num - int(str(num)[::-1])] += 1\n        return sum(v * (v - 1) / 2 for v in cnt.values()) % (10 ** 9 + 7)"}
{"id": "1381", "path": "output2\\py\\Medium\\1381-finding-the-users-active-minutes.py", "hypo_code": "class Solution(object):\n    def findingUsersActiveMinutes(self, logs, k):\n              \n        from collections import defaultdict\n        user_to_minutes = defaultdict(set)\n        for user, minute in logs:\n            user_to_minutes[user].add(minute)\n        result = [0] * k\n        for user, minutes in user_to_minutes.items():\n            result[len(minutes) - 1] += 1\n        return result"}
{"id": "1382", "path": "output2\\py\\Medium\\1382-minimum-absolute-sum-difference.py", "hypo_code": "class Solution(object):\n    def minAbsoluteSumDiff(self, nums1, nums2):\n               \n        from bisect import bisect_left\n        diff = [abs(a - b) for a, b in zip(nums1, nums2)]\n        max_diff = max(diff)\n        if max_diff == 0:\n            return 0\n        nums1.sort()\n        result = sum(diff) - max_diff\n        for i, d in enumerate(diff):\n            if d == max_diff:\n                j = bisect_left(nums1, nums2[i])\n                if j < len(nums1):\n                    result += nums1[j] - nums2[i]\n                if j > 0:\n                    result += nums2[i] - nums1[j - 1]\n        return result % (10 ** 9 + 7)"}
{"id": "1383", "path": "output2\\py\\Medium\\1383-find-the-winner-of-the-circular-game.py", "hypo_code": "class Solution(object):\n    def findTheWinner(self, n, k):\n        \n        res = 0\n        for i in range(1, n+1):\n            res = (res + k) % i\n        return res + 1"}
{"id": "1384", "path": "output2\\py\\Medium\\1384-minimum-sideway-jumps.py", "hypo_code": "class Solution(object):\n    def minSideJumps(self, obstacles):\n        \n        dp = [1, 0, 1]\n        for o in obstacles:\n            if o:\n                dp[o-1] = float('inf')\n            for i in range(3):\n                if i + 1 != o:\n                    dp[i] = min(dp[i], dp[(i+1)%3] + 1, dp[(i+2)%3] + 1)\n        return min(dp)"}
{"id": "1385", "path": "output2\\py\\Medium\\1385-queries-on-number-of-points-inside-a-circle.py", "hypo_code": "class Solution(object):\n    def countPoints(self, points, queries):\n        \n        def dist(x1, y1, x2, y2):\n            return (x1-x2)**2 + (y1-y2)**2\n        \n        res = []\n        for x, y, r in queries:\n            cnt = 0\n            for i, j in points:\n                if dist(x, y, i, j) <= r**2:\n                    cnt += 1\n            res.append(cnt)\n        return res"}
{"id": "1386", "path": "output2\\py\\Medium\\1386-maximum-xor-for-each-query.py", "hypo_code": "class Solution(object):\n    def getMaximumXor(self, nums, maximumBit):\n        \n        res = []\n        cur = 0\n        for num in nums:\n            cur ^= num\n            res.append(cur ^ (2**maximumBit - 1))\n        return res[::-1]"}
{"id": "1387", "path": "output2\\py\\Medium\\1387-maximum-ice-cream-bars.py", "hypo_code": "class Solution(object):\n    def maxIceCream(self, costs, coins):\n        \n        count = [0] * (max(costs) + 1)\n        for cost in costs:\n            count[cost] += 1\n        res, i = 0, 0\n        while coins > 0 and i < len(count):\n            if count[i] > 0:\n                coins -= i\n                res += 1\n                count[i] -= 1\n            else:\n                i += 1\n        return res"}
{"id": "1388", "path": "output2\\py\\Medium\\1388-single-threaded-cpu.py", "hypo_code": "class Solution(object):\n    def getOrder(self, tasks):\n        \n        tasks = sorted([(t[0], t[1], i) for i, t in enumerate(tasks)])\n        res, time, i, heap = [], 0, 0, []\n        while heap or i < len(tasks):\n            if not heap:\n                time = max(time, tasks[i][0])\n            while i < len(tasks) and tasks[i][0] <= time:\n                heapq.heappush(heap, (tasks[i][1], tasks[i][2]))\n                i += 1\n            t, idx = heapq.heappop(heap)\n            res.append(idx)\n            time += t\n        return res"}
{"id": "1389", "path": "output2\\py\\Medium\\1389-frequency-of-the-most-frequent-element.py", "hypo_code": "class Solution(object):\n    def maxFrequency(self, nums, k):\n        \n        nums.sort()\n        res = l = 0\n        for r in range(len(nums)):\n            k += nums[r]\n            while k < nums[r] * (r - l + 1):\n                k -= nums[l]\n                l += 1\n            res = max(res, r - l + 1)\n        return res"}
{"id": "1390", "path": "output2\\py\\Medium\\1390-longest-substring-of-all-vowels-in-order.py", "hypo_code": "class Solution(object):\n    def longestBeautifulSubstring(self, word):\n        \n        res = 0\n        for i in range(len(word)):\n            if word[i] == 'a':\n                j = i\n                seen = set()\n                while j < len(word) and word[j] >= word[j-1]:\n                    seen.add(word[j])\n                    j += 1\n                if len(seen) == 5:\n                    res = max(res, j - i)\n        return res"}
{"id": "1392", "path": "output2\\py\\Medium\\1392-maximum-element-after-decreasing-and-rearranging.py", "hypo_code": "class Solution(object):\n    def maximumElementAfterDecrementingAndRearranging(self, arr):\n        \n        arr.sort()\n        res = 0\n        for i in arr:\n            res = min(res + 1, i)\n        return res"}
{"id": "1393", "path": "output2\\py\\Medium\\1393-splitting-a-string-into-descending-consecutive-values.py", "hypo_code": "class Solution(object):\n    def splitString(self, s):\n        \n        def dfs(s, pre):\n            if not s:\n                return True\n            for i in range(1, len(s)+1):\n                if int(s[:i]) == pre - 1 and dfs(s[i:], int(s[:i])):\n                    return True\n            return False\n        \n        for i in range(1, len(s)):\n            if dfs(s[i:], int(s[:i])):\n                return True\n        return False"}
{"id": "1394", "path": "output2\\py\\Medium\\1394-minimum-adjacent-swaps-to-reach-the-kth-smallest-number.py", "hypo_code": "class Solution(object):\n    def getMinSwaps(self, num, k):\n        \n        def nextPermutation(s):\n            i = len(s) - 2\n            while i >= 0 and s[i] >= s[i+1]:\n                i -= 1\n            if i < 0:\n                return s[::-1]\n            j = len(s) - 1\n            while j >= 0 and s[j] <= s[i]:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            return s[:i+1] + s[i+1:][::-1]\n        s = list(num)\n        for _ in xrange(k):\n            s = nextPermutation(s)\n        res = 0\n        for i in xrange(len(num)):\n            j = i\n            while num[j] != s[i]:\n                j += 1\n            res += j - i\n            num[i:j+1] = [num[j]] + num[i:j]\n        return res"}
{"id": "1395", "path": "output2\\py\\Medium\\1395-maximum-distance-between-a-pair-of-values.py", "hypo_code": "class Solution(object):\n    def maxDistance(self, nums1, nums2):\n        \n        res = 0\n        j = 0\n        for i in range(len(nums1)):\n            while j < len(nums2) and nums1[i] <= nums2[j]:\n                j += 1\n            res = max(res, j - i - 1)\n        return res"}
{"id": "1396", "path": "output2\\py\\Medium\\1396-maximum-subarray-min-product.py", "hypo_code": "class Solution(object):\n    def maxSumMinProduct(self, nums):\n        \n        mod = 10**9 + 7\n        n = len(nums)\n        prefix = [0]\n        for x in nums:\n            prefix.append(prefix[-1] + x)\n        stack = []\n        res = 0\n        for i in range(n + 1):\n            while stack and (i == n or nums[stack[-1]] >= nums[i]):\n                j = stack.pop()\n                res = max(res, nums[j] * (prefix[i] - prefix[stack[-1] + 1]))\n            stack.append(i)\n        return res % mod"}
{"id": "1397", "path": "output2\\py\\Medium\\1397-incremental-memory-leak.py", "hypo_code": "class Solution(object):\n    def memLeak(self, memory1, memory2):\n        \n        t = 1\n        while memory1 >= t or memory2 >= t:\n            if memory1 >= memory2:\n                memory1 -= t\n            else:\n                memory2 -= t\n            t += 1\n        return [t, memory1, memory2]"}
{"id": "1398", "path": "output2\\py\\Medium\\1398-rotating-the-box.py", "hypo_code": "class Solution(object):\n    def rotateTheBox(self, box):\n        \n        m, n = len(box), len(box[0])\n        res = [['.'] * m for _ in range(n)]\n        for i in range(m):\n            k = n - 1\n            for j in range(n-1, -1, -1):\n                if box[i][j] == '*':\n                    k = j - 1\n                elif box[i][j] == '\n                    res[k][m-1-i] = '\n                    k -= 1\n        return res"}
{"id": "1399", "path": "output2\\py\\Medium\\1399-minimum-number-of-swaps-to-make-the-binary-string-alternating.py", "hypo_code": "class Solution(object):\n    def minSwaps(self, s):\n        \n        cnt = collections.Counter(s)\n        if abs(cnt['0'] - cnt['1']) > 1:\n            return -1\n        if cnt['0'] == cnt['1']:\n            return min(self.helper(s, '0'), self.helper(s, '1'))\n        if cnt['0'] > cnt['1']:\n            return self.helper(s, '0')\n        return self.helper(s, '1')\n    def helper(self, s, c):\n        res = 0\n        for i in range(len(s)):\n            if i % 2 == 0:\n                if s[i] != c:\n                    res += 1\n        return res"}
{"id": "1401", "path": "output2\\py\\Medium\\1401-minimum-speed-to-arrive-on-time.py", "hypo_code": "class Solution(object):\n    def minSpeedOnTime(self, dist, hour):\n         \n        if len(dist) > int(hour) + 1:\n            return -1\n        else:\n            left = 1\n            right = 10000000\n            while left < right:\n                mid = (left + right) // 2\n                if self.canReach(mid, dist, hour):\n                    right = mid\n                else:\n                    left = mid + 1\n            return left if self.canReach(left, dist, hour) else -1"}
{"id": "1402", "path": "output2\\py\\Medium\\1402-jump-game-vii.py", "hypo_code": "class Solution(object):\n    def canReach(self, s, minJump, maxJump):\n        \n        n = len(s)\n        dp = [False] * n\n        dp[0] = True\n        for i in range(1, n):\n            if s[i] == '1':\n                continue\n            for j in range(max(0, i - maxJump), i - minJump + 1):\n                if dp[j]:\n                    dp[i] = True\n                    break\n        return dp[-1]"}
{"id": "1403", "path": "output2\\py\\Medium\\1403-minimize-maximum-pair-sum-in-array.py", "hypo_code": "class Solution(object):\n    def minPairSum(self, nums):\n        \n        nums.sort()\n        return max(nums[i] + nums[len(nums) - 1 - i] for i in range(len(nums) / 2))"}
{"id": "1404", "path": "output2\\py\\Medium\\1404-get-biggest-three-rhombus-sums-in-a-grid.py", "hypo_code": "class Solution(object):\n    def getBiggestThree(self, grid):\n        \n        m, n = len(grid), len(grid[0])\n        res = set()\n        for i in range(m):\n            for j in range(n):\n                for k in range(min(i, m - i - 1), -1, -1):\n                    if j - k < 0 or j + k >= n:\n                        break\n                    sum = 0\n                    x, y = i, j\n                    for l in range(k):\n                        sum += grid[x][y]\n                        sum += grid[x][y - 1]\n                        sum += grid[x - 1][y]\n                        sum += grid[x - 1][y - 1]\n                        x -= 1\n                        y -= 1\n                    sum += grid[x][y]\n                    res.add(sum)\n        return sorted(res, reverse = True)[:3]"}
{"id": "1405", "path": "output2\\py\\Medium\\1405-maximum-value-after-insertion.py", "hypo_code": "class Solution(object):\n    def maxValue(self, n, x):\n        \n        if n[0] == '-':\n            i = 1\n            while i < len(n) and int(n[i]) <= x:\n                i += 1\n        else:\n            i = 0\n            while i < len(n) and int(n[i]) >= x:\n                i += 1\n        return n[:i] + str(x) + n[i:]"}
{"id": "1406", "path": "output2\\py\\Medium\\1406-process-tasks-using-servers.py", "hypo_code": "class Solution(object):\n    def assignTasks(self, servers, tasks):\n        \n        idle = []\n        busy = []\n        for i, s in enumerate(servers):\n            heapq.heappush(idle, (s, i))\n        res = []\n        for i, t in enumerate(tasks):\n            while busy and busy[0][0] <= i:\n                _, s, idx = heapq.heappop(busy)\n                heapq.heappush(idle, (s, idx))\n            if not idle:\n                _, s, idx = heapq.heappop(busy)\n                heapq.heappush(idle, (s, idx))\n            _, s, idx = heapq.heappop(idle)\n            heapq.heappush(busy, (i + t, s, idx))\n            res.append(idx)\n        return res"}
{"id": "1407", "path": "output2\\py\\Medium\\1407-egg-drop-with-2-eggs-and-n-floors.py", "hypo_code": "class Solution(object):\n    def twoEggDrop(self, n):\n        \n        return int(math.ceil((-1 + math.sqrt(1 + 8 * n)) / 2))"}
{"id": "1408", "path": "output2\\py\\Medium\\1408-reduction-operations-to-make-the-array-elements-equal.py", "hypo_code": "class Solution(object):\n    def reductionOperations(self, nums):\n        \n        nums.sort()\n        res = 0\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                res += i\n        return res"}
{"id": "1409", "path": "output2\\py\\Medium\\1409-minimum-number-of-flips-to-make-the-binary-string-alternating.py", "hypo_code": "class Solution(object):\n    def minFlips(self, s):\n        \n        n = len(s)\n        s = s + s\n        s1 = s[::2]\n        s2 = s[1::2]\n        s1 = s1[:n]\n        s2 = s2[:n]\n        res = n\n        for i in range(n):\n            if s1[i] != s[i]:\n                res -= 1\n            if s2[i] != s[i]:\n                res -= 1\n        return res"}
{"id": "1410", "path": "output2\\py\\Medium\\1410-find-the-student-that-will-replace-the-chalk.py", "hypo_code": "class Solution(object):\n    def chalkReplacer(self, chalk, k):\n        \n        k %= sum(chalk)\n        for i, c in enumerate(chalk):\n            if c > k:\n                return i\n            k -= c\n        return -1"}
{"id": "1411", "path": "output2\\py\\Medium\\1411-largest-magic-square.py", "hypo_code": "class Solution(object):\n    def largestMagicSquare(self, grid):\n        \n        m, n = len(grid), len(grid[0])\n        for k in range(min(m, n), 1, -1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    if self.isMagic(grid, k, i, j):\n                        return k\n        return 1\n    def isMagic(self, grid, k, i, j):\n        sum = 0\n        for l in range(k):\n            sum += grid[i + l][j + l]\n        for l in range(k):\n            s = 0\n            for x in range(k):\n                s += grid[i + x][j + l]\n            if s != sum:\n                return False\n        for l in range(k):\n            s = 0\n            for x in range(k):\n                s += grid[i + l][j + x]\n            if s != sum:\n                return False\n        for l in range(k):\n            s = 0\n            for x in range(k):\n                s += grid[i + x][j + k - 1 - l]\n            if s != sum:\n                return False\n        return True"}
{"id": "1412", "path": "output2\\py\\Medium\\1412-maximum-number-of-removable-characters.py", "hypo_code": "class Solution(object):\n    def maximumRemovals(self, s, p, removable):\n        \n        def check(mid):\n            removed = set(removable[:mid])\n            i = 0\n            for c in s:\n                if i < len(p) and c == p[i] and i not in removed:\n                    i += 1\n            return i == len(p)\n        l, r = 0, len(removable)\n        while l < r:\n            mid = (l + r + 1) / 2\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l"}
{"id": "1413", "path": "output2\\py\\Medium\\1413-merge-triplets-to-form-target-triplet.py", "hypo_code": "class Solution(object):\n    def mergeTriplets(self, triplets, target):\n        \n        res = [0] * 3\n        for t in triplets:\n            if t[0] <= target[0] and t[1] <= target[1] and t[2] <= target[2]:\n                res = [max(res[i], t[i]) for i in range(3)]\n        return res == target"}
{"id": "1414", "path": "output2\\py\\Medium\\1414-find-a-peak-element-ii.py", "hypo_code": "class Solution(object):\n    def findPeakGrid(self, mat):\n        \n        m, n = len(mat), len(mat[0])\n        left, right = 0, m * n - 1\n        while left < right:\n            mid = (left + right) / 2\n            i, j = mid / n, mid % n\n            if mat[i][j] < mat[i + 1][j]:\n                left = mid + 1\n            else:\n                right = mid\n        return [left / n, left % n]"}
{"id": "1415", "path": "output2\\py\\Medium\\1415-the-number-of-full-rounds-you-have-played.py", "hypo_code": "class Solution(object):\n    def numberOfRounds(self, loginTime, logoutTime):\n        \n        login = int(loginTime[:2]) * 60 + int(loginTime[3:])\n        logout = int(logoutTime[:2]) * 60 + int(logoutTime[3:])\n        if logout < login:\n            logout += 24 * 60\n        return max(0, logout // 15 - (login + 14) // 15)"}
{"id": "1416", "path": "output2\\py\\Medium\\1416-count-sub-islands.py", "hypo_code": "class Solution(object):\n    def countSubIslands(self, grid1, grid2):\n        \n        m, n = len(grid1), len(grid1[0])\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid2[i][j] == 0:\n                return True\n            grid2[i][j] = 0\n            res = grid1[i][j] == 1\n            res &= dfs(i - 1, j)\n            res &= dfs(i + 1, j)\n            res &= dfs(i, j - 1)\n            res &= dfs(i, j + 1)\n            return res\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid2[i][j] == 1 and dfs(i, j):\n                    res += 1\n        return res"}
{"id": "1417", "path": "output2\\py\\Medium\\1417-minimum-absolute-difference-queries.py", "hypo_code": "class Solution(object):\n    def minDifference(self, nums, queries):\n        \n        res = []\n        for l, r in queries:\n            nums_ = sorted(set(nums[l:r + 1]))\n            res.append(min(nums_[i] - nums_[i - 1] for i in range(1, len(nums_))))\n        return res"}
{"id": "1419", "path": "output2\\py\\Medium\\1419-remove-all-occurrences-of-a-substring.py", "hypo_code": "class Solution(object):\n    def removeOccurrences(self, s, part):\n        \n        while part in s:\n            s = s.replace(part, \"\", 1)\n        return s"}
{"id": "1420", "path": "output2\\py\\Medium\\1420-maximum-alternating-subsequence-sum.py", "hypo_code": "class Solution(object):\n    def maxAlternatingSum(self, nums):\n        \n        return sum(max(nums[i] - nums[i - 1], 0) for i in range(1, len(nums)))"}
{"id": "1421", "path": "output2\\py\\Medium\\1421-cyclically-rotating-a-grid.py", "hypo_code": "class Solution(object):\n    def rotateGrid(self, grid, k):\n          \n        m, n = len(grid), len(grid[0])\n        for i in range(min(m, n) / 2):\n            x, y = i, i\n            l = (m + n - 2 - 4 * i) * 2\n            k = k % l\n            for j in range(k):\n                tmp = grid[x][y]\n                for p in range(x, m - 1 - i):\n                    grid[p][y] = grid[p + 1][y]\n                for p in range(y, n - 1 - i):\n                    grid[m - 1 - i][p] = grid[m - 1 - i][p + 1]\n                for p in range(m - 1 - i, x, -1):\n                    grid[p][n - 1 - i] = grid[p - 1][n - 1 - i]\n                for p in range(n - 1 - i, y, -1):\n                    grid[x][p] = grid[x][p - 1]\n                grid[x][y + 1] = tmp\n        return grid"}
{"id": "1422", "path": "output2\\py\\Medium\\1422-number-of-wonderful-substrings.py", "hypo_code": "class Solution(object):\n    def wonderfulSubstrings(self, word):\n        \n        res = 0\n        for i in range(len(word)):\n            odd = 0\n            for j in range(i, len(word)):\n                odd ^= 1 << (ord(word[j]) - ord('a'))\n                if odd & (odd - 1) == 0:\n                    res += 1\n        return res"}
{"id": "1423", "path": "output2\\py\\Medium\\1423-eliminate-maximum-number-of-monsters.py", "hypo_code": "class Solution(object):\n    def eliminateMaximum(self, dist, speed):\n        \n        res = 0\n        for i in range(len(dist)):\n            if dist[i] / speed[i] > res:\n                res += 1\n            else:\n                break\n        return res"}
{"id": "1424", "path": "output2\\py\\Medium\\1424-count-good-numbers.py", "hypo_code": "class Solution(object):\n    def countGoodNumbers(self, n):\n        \n        return (5 ** ((n + 1) / 2) * 4 ** (n / 2)) % (10 ** 9 + 7)"}
{"id": "1425", "path": "output2\\py\\Medium\\1425-nearest-exit-from-entrance-in-maze.py", "hypo_code": "class Solution(object):\n    def nearestExit(self, maze, entrance):\n        \n        m, n = len(maze), len(maze[0])\n        i, j = entrance\n        queue = [(i, j)]\n        maze[i][j] = '+'\n        res = 0\n        while queue:\n            queue2 = []\n            res += 1\n            for i, j in queue:\n                for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:\n                    if 0 <= x < m and 0 <= y < n and maze[x][y] == '.':\n                        if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n                            return res\n                        maze[x][y] = '+'\n                        queue2.append((x, y))\n            queue = queue2\n        return -1"}
{"id": "1426", "path": "output2\\py\\Medium\\1426-sum-game.py", "hypo_code": "class Solution(object):\n    def sumGame(self, num):\n        \n        n = len(num)\n        left = right = 0\n        for i in range(n / 2):\n            if num[i] == '?':\n                left += 4.5\n            else:\n                left += int(num[i])\n        for i in range(n / 2, n):\n            if num[i] == '?':\n                right += 4.5\n            else:\n                right += int(num[i])\n        return left != right"}
{"id": "1427", "path": "output2\\py\\Medium\\1427-unique-length-3-palindromic-subsequences.py", "hypo_code": "class Solution(object):\n    def countPalindromicSubsequence(self, s):\n        \n        return sum(len(set(s[i] for i in range(l + 1, r))) for l, r in [(s.index(c), s.rindex(c)) for c in set(s)])"}
{"id": "1429", "path": "output2\\py\\Medium\\1429-add-minimum-number-of-rungs.py", "hypo_code": "class Solution(object):\n    def addRungs(self, rungs, dist):\n        \n        res, prev = 0, 0\n        for r in rungs:\n            res += (r - prev - 1) // dist\n            prev = r\n        return res"}
{"id": "1430", "path": "output2\\py\\Medium\\1430-maximum-number-of-points-with-cost.py", "hypo_code": "class Solution(object):\n    def maxPoints(self, points):\n        \n        m, n = len(points), len(points[0])\n        dp = points[0]\n        for i in range(1, m):\n            dp = [max(dp[j] - j + i for j in range(n))] + [max(dp[j] + j + i for j in range(n - 1, -1, -1))]\n            for j in range(n):\n                dp[j] += points[i][j]\n        return max(dp)"}
{"id": "1431", "path": "output2\\py\\Medium\\1431-the-number-of-the-smallest-unoccupied-chair.py", "hypo_code": "class Solution(object):\n    def smallestChair(self, times, targetFriend):\n        \n        times = sorted([(t[0], t[1], i) for i, t in enumerate(times)])\n        seats = []\n        for i in range(len(times)):\n            seat = heapq.heappop(seats) if seats else i\n            if times[i][2] == targetFriend:\n                return seat\n            heapq.heappush(seats, seat)\n            heapq.heappush(seats, i + 1)\n        return -1"}
{"id": "1432", "path": "output2\\py\\Medium\\1432-describe-the-painting.py", "hypo_code": "class Solution(object):\n    def splitPainting(self, segments):\n        \n        events = defaultdict(int)\n        for start, end, color in segments:\n            events[start] += color\n            events[end] -= color\n        res = []\n        prev = start = color = 0\n        for pos in sorted(events):\n            if color:\n                res.append([prev, pos, color])\n            color += events[pos]\n            prev = pos\n        return res"}
{"id": "1433", "path": "output2\\py\\Medium\\1433-largest-number-after-mutating-substring.py", "hypo_code": "class Solution(object):\n    def maximumNumber(self, num, change):\n        \n        res = ''\n        flag = False\n        for c in num:\n            if change[int(c)] > int(c):\n                res += str(change[int(c)])\n                flag = True\n            elif change[int(c)] == int(c) or flag:\n                res += c\n            else:\n                res = res[:-1] + c\n        return res"}
{"id": "1434", "path": "output2\\py\\Medium\\1434-maximum-compatibility-score-sum.py", "hypo_code": "class Solution(object):\n    def maxCompatibilitySum(self, students, mentors):\n        \n        n = len(students)\n        m = len(students[0])\n        res = 0\n        for perm in itertools.permutations(range(n)):\n            res = max(res, sum(sum(students[i][j] == mentors[perm[i]][j] for j in range(m)) for i in range(n)))\n        return res"}
{"id": "1435", "path": "output2\\py\\Medium\\1435-maximum-number-of-weeks-for-which-you-can-work.py", "hypo_code": "class Solution(object):\n    def numberOfWeeks(self, milestones):\n        \n        return min(2 * sum(milestones) - max(milestones), sum(milestones))"}
{"id": "1436", "path": "output2\\py\\Medium\\1436-minimum-garden-perimeter-to-collect-enough-apples.py", "hypo_code": "class Solution(object):\n    def minimumPerimeter(self, neededApples):\n        \n        ans, sum = 0, 0\n        while sum < neededApples:\n            ans += 1\n            sum += ans * ans * 12\n        return ans * 8"}
{"id": "1437", "path": "output2\\py\\Medium\\1437-check-if-move-is-legal.py", "hypo_code": "class Solution(object):\n    def checkMove(self, board, rMove, cMove, color):\n        \n        def check(i, j, di, dj):\n            if i < 0 or i >= 8 or j < 0 or j >= 8:\n                return False\n            if board[i][j] == '.':\n                return False\n            if board[i][j] == color:\n                return True\n            return check(i + di, j + dj, di, dj)\n        for di in range(-1, 2):\n            for dj in range(-1, 2):\n                if di == 0 and dj == 0:\n                    continue\n                if check(rMove + di, cMove + dj, di, dj):\n                    return True\n        return False"}
{"id": "1438", "path": "output2\\py\\Medium\\1438-minimum-total-space-wasted-with-k-resizing-operations.py", "hypo_code": "class Solution(object):\n    def minSpaceWastedKResizing(self, nums, k):\n        \n        @lru_cache(None)\n        def dp(i, k):\n            if i == len(nums):\n                return 0\n            if k == -1:\n                return float('inf')\n            mx, res = 0, float('inf')\n            for j in range(i, len(nums)):\n                mx = max(mx, nums[j])\n                res = min(res, (j - i + 1) * mx - sum(nums[i:j + 1]) + dp(j + 1, k - 1))\n            return res\n        return dp(0, k)"}
{"id": "1439", "path": "output2\\py\\Medium\\1439-remove-stones-to-minimize-the-total.py", "hypo_code": "class Solution(object):\n    def minStoneSum(self, piles, k):\n        \n        piles.sort()\n        while k > 0:\n            piles[-1] -= piles[-1] / 2\n            piles.sort()\n            k -= 1\n        return sum(piles)"}
{"id": "1440", "path": "output2\\py\\Medium\\1440-minimum-number-of-swaps-to-make-the-string-balanced.py", "hypo_code": "class Solution(object):\n    def minSwaps(self, s):\n        \n        n = len(s)\n        cnt = 0\n        res = 0\n        for i in range(n):\n            if s[i] == '[':\n                cnt += 1\n            else:\n                cnt -= 1\n            res = max(res, -cnt)\n        return (res + 1) / 2"}
{"id": "1441", "path": "output2\\py\\Medium\\1441-array-with-elements-not-equal-to-average-of-neighbors.py", "hypo_code": "class Solution(object):\n    def rearrangeArray(self, nums):\n        \n        nums.sort()\n        return nums[::2] + nums[1::2][::-1]"}
{"id": "1442", "path": "output2\\py\\Medium\\1442-minimum-non-zero-product-of-the-array-elements.py", "hypo_code": "class Solution(object):\n    def minNonZeroProduct(self, p):\n        \n        mod = 10 ** 9 + 7\n        return pow(2 ** p - 2, (2 ** p - 2) / 2, mod) * (2 ** p - 1) % mod"}
{"id": "1443", "path": "output2\\py\\Medium\\1443-maximum-matrix-sum.py", "hypo_code": "class Solution(object):\n    def maxMatrixSum(self, matrix):\n        \n        cnt = 0\n        res = 0\n        min_abs = float('inf')\n        for r in matrix:\n            for c in r:\n                cnt += 1\n                res += abs(c)\n                min_abs = min(min_abs, abs(c))\n        return res if cnt & 1 == 0 else res - 2 * min_abs"}
{"id": "1444", "path": "output2\\py\\Medium\\1444-number-of-ways-to-arrive-at-destination.py", "hypo_code": "class Solution(object):\n    def countPaths(self, n, roads):\n        \n        graph = [[] for _ in range(n)]\n        for u, v, t in roads:\n            graph[u].append([v, t])\n            graph[v].append([u, t])\n        heap = [[0, 0]]\n        dist = [float('inf')] * n\n        dist[0] = 0\n        ways = [0] * n\n        ways[0] = 1\n        while heap:\n            d, u = heapq.heappop(heap)\n            for v, t in graph[u]:\n                if d + t < dist[v]:\n                    dist[v] = d + t\n                    heapq.heappush(heap, [dist[v], v])\n                    ways[v] = ways[u]\n                elif d + t == dist[v]:\n                    ways[v] += ways[u]\n        return ways[-1] % (10 ** 9 + 7)"}
{"id": "1445", "path": "output2\\py\\Medium\\1445-find-unique-binary-string.py", "hypo_code": "class Solution(object):\n    def findDifferentBinaryString(self, nums):\n        \n        return ''.join('0' if nums[i][i] == '1' else '1' for i in range(len(nums)))"}
{"id": "1446", "path": "output2\\py\\Medium\\1446-minimize-the-difference-between-target-and-chosen-elements.py", "hypo_code": "class Solution(object):\n    def minimizeTheDifference(self, mat, target):\n        \n        res = [0]\n        for row in mat:\n            res = sorted(set(x + y for x in row for y in res))\n        return min(abs(x - target) for x in res)"}
{"id": "1447", "path": "output2\\py\\Medium\\1447-find-the-kth-largest-integer-in-the-array.py", "hypo_code": "class Solution(object):\n    def kthLargestNumber(self, nums, k):\n        \n        return sorted(nums, key=int)[-k]"}
{"id": "1448", "path": "output2\\py\\Medium\\1448-minimum-number-of-work-sessions-to-finish-the-tasks.py", "hypo_code": "class Solution(object):\n    def minSessions(self, tasks, sessionTime):\n        \n        def dfs(tasks, i, cur, res):\n            if i == len(tasks):\n                res.append(cur)\n                return\n            for j in range(len(cur)):\n                cur[j] += tasks[i]\n                dfs(tasks, i + 1, cur, res)\n                cur[j] -= tasks[i]\n            cur.append(tasks[i])\n            dfs(tasks, i + 1, cur, res)\n            cur.pop()\n        res = []\n        dfs(tasks, 0, [], res)\n        return min(len(r) for r in res if max(r) <= sessionTime)"}
{"id": "1449", "path": "output2\\py\\Medium\\1449-find-all-groups-of-farmland.py", "hypo_code": "class Solution(object):\n    def findFarmland(self, land):\n        \n        m, n = len(land), len(land[0])\n        res = []\n        for i in range(m):\n            for j in range(n):\n                if land[i][j] == 1:\n                    x, y = i, j\n                    while x < m and land[x][j] == 1:\n                        x += 1\n                    while y < n and land[i][y] == 1:\n                        y += 1\n                    res.append([i, j, x - 1, y - 1])\n                    for x_ in range(i, x):\n                        for y_ in range(j, y):\n                            land[x_][y_] = 0\n        return res"}
{"id": "1451", "path": "output2\\py\\Medium\\1451-the-number-of-weak-characters-in-the-game.py", "hypo_code": "class Solution(object):\n    def numberOfWeakCharacters(self, properties):\n        \n        properties.sort(key=lambda x: (-x[0], x[1]))\n        res, mx = 0, 0\n        for _, d in properties:\n            if d < mx:\n                res += 1\n            else:\n                mx = d\n        return res"}
{"id": "1452", "path": "output2\\py\\Medium\\1452-first-day-where-you-have-been-in-all-the-rooms.py", "hypo_code": "class Solution(object):\n    def firstDayBeenInAllRooms(self, nextVisit):\n        \n        n = len(nextVisit)\n        dp = [0] * n\n        for i in range(1, n):\n            dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % (10 ** 9 + 7)\n        return dp[n - 1]"}
{"id": "1453", "path": "output2\\py\\Medium\\1453-number-of-pairs-of-interchangeable-rectangles.py", "hypo_code": "class Solution(object):\n    def interchangeableRectangles(self, rectangles):\n        \n        from collections import Counter\n        cnt = Counter()\n        for w, h in rectangles:\n            cnt[w / float(h)] += 1\n        return sum(v * (v - 1) / 2 for v in cnt.values())"}
{"id": "1454", "path": "output2\\py\\Medium\\1454-maximum-product-of-the-length-of-two-palindromic-subsequences.py", "hypo_code": "class Solution(object):\n    def maxProduct(self, s):\n           \n        \n        \n        \n        \n        palindromes = self.get_palindromes(s)\n        result = 0\n        for i in range(len(palindromes)):\n            for j in range(i + 1, len(palindromes)):\n                result = max(result, len(palindromes[i]) * len(palindromes[j]))\n        return result"}
{"id": "1455", "path": "output2\\py\\Medium\\1455-find-original-array-from-doubled-array.py", "hypo_code": "class Solution(object):\n    def findOriginalArray(self, changed):\n           \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        if len(changed) % 2 == 1:\n            return []\n        freq = {}\n        result = []\n        for num in changed:\n            if num % 2 == 0:\n                if num / 2 in freq:\n                    freq[num / 2] -= 1\n                    if freq[num / 2] == 0:\n                        del freq[num / 2]\n                    result.append(num / 2)\n            else:\n                if num * 2 in freq:\n                    freq[num * 2] -= 1\n                    if freq[num * 2] == 0:\n                        del freq[num * 2]\n                    result.append(num)\n            if num not in freq:\n                freq[num] = 1\n            else:\n                freq[num] += 1\n        return result"}
{"id": "1456", "path": "output2\\py\\Medium\\1456-maximum-earnings-from-taxi.py", "hypo_code": "class Solution(object):\n    def maxTaxiEarnings(self, n, rides):\n        \n        rides.sort()\n        dp = [0] * (n + 1)\n        for i in range(len(rides)):\n            start, end, tip = rides[i]\n            dp[end] = max(dp[end], dp[start] + end - start + tip)\n            for j in range(i + 1, len(rides)):\n                if rides[j][0] >= end:\n                    dp[rides[j][1]] = max(dp[rides[j][1]], dp[end] + rides[j][1] - rides[j][0] + rides[j][2])\n                    break\n        return dp[-1]"}
{"id": "1457", "path": "output2\\py\\Medium\\1457-sum-of-beauty-in-the-array.py", "hypo_code": "class Solution(object):\n    def sumOfBeauties(self, nums):\n              \n        result=0\n        for i in range(1,len(nums)-1):\n            if nums[i-1]<nums[i]<nums[i+1]:\n                result+=1\n            elif nums[i-1]<nums[i] and nums[i]<nums[i+1]:\n                result+=2\n        return result"}
{"id": "1459", "path": "output2\\py\\Medium\\1459-grid-game.py", "hypo_code": "class Solution(object):\n    def gridGame(self, grid):\n        \n        n = len(grid[0])\n        res = float('inf')\n        top, bottom = 0, sum(grid[1])\n        for i in range(n):\n            bottom -= grid[1][i]\n            res = min(res, max(top, bottom))\n            top += grid[0][i]\n        return res"}
{"id": "1460", "path": "output2\\py\\Medium\\1460-check-if-word-can-be-placed-in-crossword.py", "hypo_code": "class Solution(object):\n    def placeWordInCrossword(self, board, word):\n        \n        m, n = len(board), len(board[0])\n        def check(i, j, di, dj):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] == '\n                return True\n            if board[i][j] == ' ':\n                return False\n            return check(i + di, j + dj, di, dj)\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == ' ' or board[i][j] == word[0]:\n                    if check(i - 1, j, -1, 0) and check(i + 1, j, 1, 0) or check(i, j - 1, 0, -1) and check(i, j + 1, 0, 1):\n                        return True\n        return False"}
{"id": "1461", "path": "output2\\py\\Medium\\1461-number-of-pairs-of-strings-with-concatenation-equal-to-target.py", "hypo_code": "class Solution(object):\n    def numOfPairs(self, nums, target):\n        \n        return sum(nums[i] + nums[j] == target for i in range(len(nums)) for j in range(len(nums)) if i != j)"}
{"id": "1462", "path": "output2\\py\\Medium\\1462-maximize-the-confusion-of-an-exam.py", "hypo_code": "class Solution(object):\n    def maxConsecutiveAnswers(self, answerKey, k):\n        \n        n = len(answerKey)\n        def check(x):\n            cnt = 0\n            for i in range(n):\n                if answerKey[i] == x:\n                    cnt += 1\n                if i >= k and answerKey[i - k] == x:\n                    cnt -= 1\n                if cnt >= k:\n                    return True\n            return False\n        return max(check('T'), check('F'))"}
{"id": "1463", "path": "output2\\py\\Medium\\1463-find-missing-observations.py", "hypo_code": "class Solution(object):\n    def missingRolls(self, rolls, mean, n):\n        \n        m = len(rolls)\n        s = mean * (m + n) - sum(rolls)\n        if s < n or s > 6 * n:\n            return []\n        res = [s / n] * n\n        for i in range(s % n):\n            res[i] += 1\n        return res"}
{"id": "1464", "path": "output2\\py\\Medium\\1464-stone-game-ix.py", "hypo_code": "class Solution(object):\n    def stoneGameIX(self, stones):\n        \n        cnt = [0] * 3\n        for s in stones:\n            cnt[s % 3] += 1\n        if cnt[0] % 2 == 0:\n            return cnt[1] and cnt[2]\n        return abs(cnt[1] - cnt[2]) >= 3"}
{"id": "1465", "path": "output2\\py\\Medium\\1465-minimum-operations-to-make-a-uni-value-grid.py", "hypo_code": "class Solution(object):\n    def minOperations(self, grid, x):\n        \n        nums = []\n        for row in grid:\n            nums.extend(row)\n        nums.sort()\n        res = 0\n        mid = nums[len(nums) / 2]\n        for num in nums:\n            if (mid - num) % x != 0:\n                return -1\n            res += abs(mid - num) / x\n        return res"}
{"id": "1467", "path": "output2\\py\\Medium\\1467-remove-colored-pieces-if-both-neighbors-are-the-same-color.py", "hypo_code": "class Solution(object):\n    def winnerOfGame(self, colors):\n        \n        n = len(colors)\n        a = b = 0\n        for i in range(1, n - 1):\n            if colors[i] == colors[i - 1] == colors[i + 1]:\n                if colors[i] == 'A':\n                    a += 1\n                else:\n                    b += 1\n        return a > b"}
{"id": "1468", "path": "output2\\py\\Medium\\1468-the-time-when-the-network-becomes-idle.py", "hypo_code": "class Solution(object):\n    def networkBecomesIdle(self, edges, patience):\n        \n        n = len(patience)\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        q = collections.deque([(0, 0)])\n        visited = set([0])\n        res = 0\n        while q:\n            u, t = q.popleft()\n            res = max(res, 2 * t + max(0, (t - 1) // patience[u] + 1))\n            for v in g[u]:\n                if v not in visited:\n                    visited.add(v)\n                    q.append((v, t + 1))\n        return res"}
{"id": "1470", "path": "output2\\py\\Medium\\1470-count-number-of-maximum-bitwise-or-subsets.py", "hypo_code": "class Solution(object):\n    def countMaxOrSubsets(self, nums):\n        \n        return 1 << nums.count(max(nums))"}
{"id": "1471", "path": "output2\\py\\Medium\\1471-next-greater-numerically-balanced-number.py", "hypo_code": "class Solution(object):\n    def nextBeautifulNumber(self, n):\n        \n        s = str(n)\n        res = \"\"\n        for i in range(len(s)):\n            if i == 0:\n                res += \"1\"\n            else:\n                res += \"3\"\n        return int(res)"}
{"id": "1472", "path": "output2\\py\\Medium\\1472-count-nodes-with-the-highest-score.py", "hypo_code": "class Solution(object):\n    def countHighestScoreNodes(self, parents):\n        \n        n = len(parents)\n        dp = [0] * n\n        def dfs(i):\n            res = 1\n            for j in range(n):\n                if parents[j] == i:\n                    res += dfs(j)\n            dp[i] = res\n            return res\n        dfs(0)\n        res = 0\n        for i in range(n):\n            if dp[i] == max(dp):\n                res += 1\n        return res"}
{"id": "1473", "path": "output2\\py\\Medium\\1473-two-best-non-overlapping-events.py", "hypo_code": "class Solution(object):\n    def maxTwoEvents(self, events):\n        \n        events.sort(key=lambda x: (x[1], x[0]))\n        dp = [[0, 0]]\n        res = 0\n        for start, end, value in events:\n            i = bisect.bisect(dp, [start + 1]) - 1\n            if dp[i][1] + value > res:\n                res = dp[i][1] + value\n            if res > dp[-1][1]:\n                dp.append([end, res])\n        return res"}
{"id": "1474", "path": "output2\\py\\Medium\\1474-plates-between-candles.py", "hypo_code": "class Solution(object):\n    def platesBetweenCandles(self, s, queries):\n        \n        n = len(s)\n        dp = [0] * n\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + (s[i - 1] == '|')\n        res = []\n        for left, right in queries:\n            res.append(dp[right] - dp[left] - (s[left] == '|'))\n        return res"}
{"id": "1475", "path": "output2\\py\\Medium\\1475-find-the-minimum-and-maximum-number-of-nodes-between-critical-points.py", "hypo_code": "class Solution(object):\n    def nodesBetweenCriticalPoints(self, head):\n        \n        stack = []\n        res = []\n        while head:\n            if stack and stack[-1] < head.val:\n                res.append(head.val - stack[-1])\n            stack.append(head.val)\n            head = head.next\n        if len(res) < 2:\n            return [-1, -1]\n        return [min(res), max(res)]"}
{"id": "1476", "path": "output2\\py\\Medium\\1476-minimum-operations-to-convert-number.py", "hypo_code": "class Solution(object):\n    def minimumOperations(self, nums, start, goal):\n        \n        dp = {start: 0}\n        q = [start]\n        while q:\n            x = q.pop(0)\n            if x == goal:\n                return dp[x]\n            for num in nums:\n                y = x ^ num\n                if y not in dp:\n                    dp[y] = dp[x] + 1\n                    q.append(y)\n        return -1"}
{"id": "1477", "path": "output2\\py\\Medium\\1477-vowels-of-all-substrings.py", "hypo_code": "class Solution(object):\n    def countVowels(self, word):\n        \n        n = len(word)\n        dp = [0] * (n + 1)\n        for i in range(n):\n            dp[i + 1] = dp[i] + (word[i] in 'aeiou')\n        return sum(dp)"}
{"id": "1478", "path": "output2\\py\\Medium\\1478-minimized-maximum-of-products-distributed-to-any-store.py", "hypo_code": "class Solution(object):\n    def minimizedMaximum(self, n, quantities):\n        \n        l, r = 1, max(quantities)\n        while l < r:\n            mid = (l + r) / 2\n            if sum((x + mid - 1) / mid for x in quantities) <= n:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}
{"id": "1480", "path": "output2\\py\\Medium\\1480-most-beautiful-item-for-each-query.py", "hypo_code": "class Solution(object):\n    def maximumBeauty(self, items, queries):\n        \n        result=[]\n        for i in range(len(queries)):\n            result.append(max([items[j][1] for j in range(len(items)) if items[j][0]<=queries[i]]+[0]))\n        return result"}
{"id": "1481", "path": "output2\\py\\Medium\\1481-reverse-nodes-in-even-length-groups.py", "hypo_code": "class Solution(object):\n    def reverseEvenLengthGroups(self, head):\n               \n        \n        \n        \n        length = self.get_length(head)\n        if length % 2 == 0:\n            return self.reverse_linked_list(head)\n        return head"}
{"id": "1482", "path": "output2\\py\\Medium\\1482-decode-the-slanted-ciphertext.py", "hypo_code": "class Solution(object):\n    def decodeCiphertext(self, encodedText, rows):\n        \n        n = len(encodedText)\n        cols = n // rows\n        matrix = [[''] * cols for _ in range(rows)]\n        i = 0\n        for j in range(cols):\n            for k in range(rows):\n                matrix[k][j] = encodedText[i]\n                i += 1\n        res = ''\n        for row in matrix:\n            res += ''.join(row)\n        return res"}
{"id": "1483", "path": "output2\\py\\Medium\\1483-watering-plants.py", "hypo_code": "class Solution(object):\n    def wateringPlants(self, plants, capacity):\n        \n        n = len(plants)\n        res = 0\n        cur = capacity\n        for i in range(n):\n            if plants[i] > cur:\n                res += 2 * i\n                cur = capacity\n            cur -= plants[i]\n        return res + n - 1"}
{"id": "1485", "path": "output2\\py\\Medium\\1485-minimum-number-of-food-buckets-to-feed-the-hamsters.py", "hypo_code": "class Solution(object):\n    def minimumBuckets(self, hamsters):\n               \n        hamsters=hamsters.replace('.','')\n        if len(hamsters)==0:\n            return 0\n        if len(hamsters)==1:\n            return 1\n        if len(hamsters)==2:\n            return 2\n        return -1"}
{"id": "1486", "path": "output2\\py\\Medium\\1486-minimum-cost-homecoming-of-a-robot-in-a-grid.py", "hypo_code": "class Solution(object):\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\n                                                                                                         \n        return self.minCostFromIndex(startPos, homePos, rowCosts, colCosts, 0, 0)"}
{"id": "1487", "path": "output2\\py\\Medium\\1487-k-radius-subarray-averages.py", "hypo_code": "class Solution(object):\n    def getAverages(self, nums, k):\n               \n        result=[]\n        for i in range(len(nums)):\n            if i-k<0:\n                left=0\n            else:\n                left=i-k\n            if i+k>len(nums)-1:\n                right=len(nums)-1\n            else:\n                right=i+k\n            if right-left<k*2:\n                result.append(-1)\n            else:\n                result.append(sum(nums[left:right+1])/(right-left+1))\n        return result"}
{"id": "1488", "path": "output2\\py\\Medium\\1488-removing-minimum-and-maximum-from-array.py", "hypo_code": "class Solution(object):\n    def minimumDeletions(self, nums):\n        \n        return min([nums.index(min(nums))+len(nums)-nums[::-1].index(max(nums))-1,len(nums)-nums.index(min(nums))-nums[::-1].index(max(nums))-1])"}
{"id": "1489", "path": "output2\\py\\Medium\\1489-delete-the-middle-node-of-a-linked-list.py", "hypo_code": "class Solution(object):\n    def deleteMiddle(self, head):\n        \n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n        prev.next = slow.next\n        return head"}
{"id": "1490", "path": "output2\\py\\Medium\\1490-step-by-step-directions-from-a-binary-tree-node-to-another.py", "hypo_code": "class Solution(object):\n    def getDirections(self, root, startValue, destValue):\n        \n        def dfs(node, path):\n            if node:\n                if node.val == destValue:\n                    return path\n                return dfs(node.left, path + 'L') or dfs(node.right, path + 'R') or dfs(node.parent, path + 'U')\n        return dfs(root, '')"}
{"id": "1491", "path": "output2\\py\\Medium\\1491-find-good-days-to-rob-the-bank.py", "hypo_code": "class Solution(object):\n    def goodDaysToRobBank(self, security, time):\n        \n        n = len(security)\n        l, r = 0, time\n        while r < n:\n            if security[l] <= security[l + 1] and security[r - 1] >= security[r]:\n                r += 1\n            else:\n                l += 1\n                r += 1\n        return range(l, r)"}
{"id": "1492", "path": "output2\\py\\Medium\\1492-detonate-the-maximum-bombs.py", "hypo_code": "class Solution(object):\n    def maximumDetonation(self, bombs):\n        \n        res = 0\n        for x, y, r in bombs:\n            res = max(res, sum((x - a) ** 2 + (y - b) ** 2 <= r ** 2 for a, b, _ in bombs))\n        return res"}
{"id": "1493", "path": "output2\\py\\Medium\\1493-sum-of-subarray-ranges.py", "hypo_code": "class Solution(object):\n    def subArrayRanges(self, nums):\n        \n        n = len(nums)\n        res = 0\n        for i in range(n):\n            for j in range(i, n):\n                res += max(nums[i:j + 1]) - min(nums[i:j + 1])\n        return res"}
{"id": "1494", "path": "output2\\py\\Medium\\1494-watering-plants-ii.py", "hypo_code": "class Solution(object):\n    def minimumRefill(self, plants, capacityA, capacityB):\n        \n        n = len(plants)\n        res = 0\n        curA, curB = capacityA, capacityB\n        l, r = 0, n - 1\n        while l <= r:\n            if curA >= curB:\n                if plants[l] > curA:\n                    res += 1\n                    curA = capacityA\n                curA -= plants[l]\n                l += 1\n            else:\n                if plants[r] > curB:\n                    res += 1\n                    curB = capacityB\n                curB -= plants[r]\n                r -= 1\n        return res"}
{"id": "1495", "path": "output2\\py\\Medium\\1495-adding-spaces-to-a-string.py", "hypo_code": "class Solution(object):\n    def addSpaces(self, s, spaces):\n        \n        res = []\n        spaces.append(len(s))\n        for i, c in enumerate(s):\n            if i in spaces:\n                res.append(' ')\n            res.append(c)\n        return ''.join(res)"}
{"id": "1496", "path": "output2\\py\\Medium\\1496-number-of-smooth-descent-periods-of-a-stock.py", "hypo_code": "class Solution(object):\n    def getDescentPeriods(self, prices):\n        \n        n = len(prices)\n        res = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if prices[j] + i - j == prices[i]:\n                    res += 1\n        return res"}
{"id": "1497", "path": "output2\\py\\Medium\\1497-find-all-possible-recipes-from-given-supplies.py", "hypo_code": "class Solution(object):\n    def findAllRecipes(self, recipes, ingredients, supplies):\n              \n        from collections import Counter\n        supplies = Counter(supplies)\n        result = []\n        for i, recipe in enumerate(recipes):\n            if all(supplies[ingredient] > 0 for ingredient in ingredients[i]):\n                result.append(recipe)\n                for ingredient in ingredients[i]:\n                    supplies[ingredient] -= 1\n        return result"}
{"id": "1498", "path": "output2\\py\\Medium\\1498-check-if-a-parentheses-string-can-be-valid.py", "hypo_code": "class Solution(object):\n    def canBeValid(self, s, locked):\n         \n        stack=[]\n        for i in range(len(s)):\n            if locked[i]=='0':\n                if s[i]=='(':\n                    stack.append(s[i])\n                else:\n                    if len(stack)>0:\n                        stack.pop()\n                    else:\n                        return False\n            else:\n                if s[i]==')':\n                    if len(stack)>0:\n                        stack.pop()\n                    else:\n                        return False\n        return len(stack)==0"}
{"id": "1499", "path": "output2\\py\\Medium\\1499-execution-of-all-suffix-instructions-staying-in-a-grid.py", "hypo_code": "class Solution(object):\n    def executeInstructions(self, n, startPos, s):\n                       \n        result = []\n        for i in range(len(s)):\n            result.append(self.executeInstructionsFromIndex(n, startPos, s, i))\n        return result"}
{"id": "1500", "path": "output2\\py\\Medium\\1500-intervals-between-identical-elements.py", "hypo_code": "class Solution(object):\n    def getDistances(self, arr):\n        \n        result=[]\n        for i in range(len(arr)):\n            result.append(sum([abs(i-j) for j in range(len(arr)) if arr[i]==arr[j]]))\n        return result"}
{"id": "1501", "path": "output2\\py\\Medium\\1501-number-of-laser-beams-in-a-bank.py", "hypo_code": "class Solution(object):\n    def numberOfBeams(self, bank):\n               \n        result = 0\n        for i in range(len(bank)):\n            for j in range(i+1, len(bank)):\n                if bank[i].find('1') != -1 and bank[j].find('1') != -1:\n                    result += 1\n        return result"}
{"id": "1502", "path": "output2\\py\\Medium\\1502-destroying-asteroids.py", "hypo_code": "class Solution(object):\n    def asteroidsDestroyed(self, mass, asteroids):\n             \n        for i in range(len(asteroids)):\n            if mass>=asteroids[i]:\n                mass+=asteroids[i]\n            else:\n                return False\n        return True"}
{"id": "1503", "path": "output2\\py\\Medium\\1503-maximum-twin-sum-of-a-linked-list.py", "hypo_code": "class Solution(object):\n    def pairSum(self, head):\n        \n        res = 0\n        while head:\n            res += head.val\n            head = head.next.next\n        return res"}
{"id": "1504", "path": "output2\\py\\Medium\\1504-longest-palindrome-by-concatenating-two-letter-words.py", "hypo_code": "class Solution(object):\n    def longestPalindrome(self, words):\n        \n        res = 0\n        for w in words:\n            res += len(w)\n        return res if res % 2 == 0 else res - 1"}
{"id": "1505", "path": "output2\\py\\Medium\\1505-minimum-swaps-to-group-all-1s-together-ii.py", "hypo_code": "class Solution(object):\n    def minSwaps(self, nums):\n        \n        ones = sum(nums)\n        res = cur = sum(nums[:ones])\n        for i in range(ones, len(nums)):\n            cur += nums[i] - nums[i - ones]\n            res = max(res, cur)\n        return ones - res"}
{"id": "1506", "path": "output2\\py\\Medium\\1506-count-words-obtained-after-adding-a-letter.py", "hypo_code": "class Solution(object):\n    def wordCount(self, startWords, targetWords):\n        \n        def count(w):\n            return sum(w.count(c) == 0 for c in string.ascii_lowercase)\n        return sum(count(w) == 1 for w in targetWords)"}
{"id": "1507", "path": "output2\\py\\Medium\\1507-minimum-moves-to-reach-target-score.py", "hypo_code": "class Solution(object):\n    def minMoves(self, target, maxDoubles):\n        \n        dp = [0] * (target + 1)\n        for i in range(1, target + 1):\n            dp[i] = dp[i - 1] + 1\n            if i % 2 == 0:\n                dp[i] = min(dp[i], dp[i // 2] + 1)\n        return dp[target]"}
{"id": "1508", "path": "output2\\py\\Medium\\1508-solving-questions-with-brainpower.py", "hypo_code": "class Solution(object):\n    def mostPoints(self, questions):\n        \n        dp = [[0, 0]]\n        for points, brainpower in questions:\n            i = bisect.bisect(dp, [brainpower + 1]) - 1\n            dp.append([brainpower, max(dp[i][1] + points, dp[-1][1])])\n        return dp[-1][1]"}
{"id": "1509", "path": "output2\\py\\Medium\\1509-count-the-hidden-sequences.py", "hypo_code": "class Solution(object):\n    def numberOfArrays(self, differences, lower, upper):\n        \n        n = len(differences)\n        dp = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if differences[j] <= differences[i] and differences[i] <= upper:\n                    dp[i] += dp[j]\n        return dp[-1]"}
{"id": "1510", "path": "output2\\py\\Medium\\1510-k-highest-ranked-items-within-a-price-range.py", "hypo_code": "class Solution(object):\n    def highestRankedKItems(self, grid, pricing, start, k):\n        \n        m, n = len(grid), len(grid[0])\n        low, high = pricing\n        visited = [[0] * n for _ in range(m)]\n        visited[start[0]][start[1]] = 1\n        pq = [[grid[start[0]][start[1]], start[0], start[1]]]\n        res = []\n        while pq:\n            cur, x, y = heapq.heappop(pq)\n            if low <= cur <= high:\n                res.append([x, y])\n            for dx, dy in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    visited[nx][ny] = 1\n                    heapq.heappush(pq, [grid[nx][ny], nx, ny])\n        return res[:k]"}
{"id": "1511", "path": "output2\\py\\Medium\\1511-rearrange-array-elements-by-sign.py", "hypo_code": "class Solution(object):\n    def rearrangeArray(self, nums):\n        \n        n = len(nums)\n        nums.sort(key = lambda x: abs(x))\n        return nums"}
{"id": "1512", "path": "output2\\py\\Medium\\1512-find-all-lonely-numbers-in-the-array.py", "hypo_code": "class Solution(object):\n    def findLonely(self, nums):\n        \n        n = len(nums)\n        res = []\n        for i in range(n):\n            if nums[i] not in nums[:i] + nums[i + 1:]:\n                res.append(nums[i])\n        return res"}
{"id": "1513", "path": "output2\\py\\Medium\\1513-all-divisions-with-the-highest-score-of-a-binary-array.py", "hypo_code": "class Solution(object):\n    def maxScoreIndices(self, nums):\n        \n        n = len(nums)\n        res = []\n        for i in range(n):\n            left = nums[:i]\n            right = nums[i:]\n            res.append(left.count(0) + right.count(1))\n        return [i for i in range(n) if res[i] == max(res)]"}
{"id": "1514", "path": "output2\\py\\Medium\\1514-partition-array-according-to-given-pivot.py", "hypo_code": "class Solution(object):\n    def pivotArray(self, nums, pivot):\n              \n        result=[]\n        for i in range(len(nums)):\n            if nums[i]<pivot:\n                result.append(nums[i])\n        for i in range(len(nums)):\n            if nums[i]==pivot:\n                result.append(nums[i])\n        for i in range(len(nums)):\n            if nums[i]>pivot:\n                result.append(nums[i])\n        return result"}
{"id": "1515", "path": "output2\\py\\Medium\\1515-minimum-cost-to-set-cooking-time.py", "hypo_code": "class Solution(object):\n    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):\n        \n        \n        \n        \n        \n        minutes, seconds = self.get_minutes_and_seconds(targetSeconds)\n        cost_minutes = self.get_cost_to_set_minutes(startAt, moveCost, pushCost, minutes)\n        cost_seconds = self.get_cost_to_set_seconds(startAt, moveCost, pushCost, seconds)\n        return cost_minutes + cost_seconds"}
{"id": "1516", "path": "output2\\py\\Medium\\1516-smallest-value-of-the-rearranged-number.py", "hypo_code": "class Solution(object):\n    def smallestNumber(self, num):\n        \n        \n        \n        \n        \n        \n        digits = self.convert_number_to_list_of_digits(num)\n        digits.sort()\n        number = self.convert_list_of_digits_to_number(digits)\n        if number == 0:\n            return 0\n        return number"}
{"id": "1518", "path": "output2\\py\\Medium\\1518-minimum-operations-to-make-the-array-alternating.py", "hypo_code": "class Solution(object):\n    def minimumOperations(self, nums):\n        \n        n = len(nums)\n        res = 0\n        for i in range(1, n):\n            if nums[i] == nums[i - 1]:\n                res += 1\n                nums[i] += 1\n        return res"}
{"id": "1519", "path": "output2\\py\\Medium\\1519-removing-minimum-number-of-magic-beans.py", "hypo_code": "class Solution(object):\n    def minimumRemoval(self, beans):\n        \n        n = len(beans)\n        beans.sort()\n        res = 0\n        for i in range(1, n):\n            res += beans[i] - beans[0]\n        return res"}
{"id": "1520", "path": "output2\\py\\Medium\\1520-find-three-consecutive-integers-that-sum-to-a-given-number.py", "hypo_code": "class Solution(object):\n    def sumOfThree(self, num):\n        \n        for i in range(1, num):\n            if i + i + 1 + i + 2 == num:\n                return [i, i + 1, i + 2]\n        return []"}
{"id": "1521", "path": "output2\\py\\Medium\\1521-maximum-split-of-positive-even-integers.py", "hypo_code": "class Solution(object):\n    def maximumEvenSplit(self, finalSum):\n        \n        res = []\n        while finalSum > 0:\n            for i in range(1, finalSum + 1, 2):\n                finalSum -= i\n                res.append(i)\n        return res"}
{"id": "1522", "path": "output2\\py\\Medium\\1522-merge-nodes-in-between-zeros.py", "hypo_code": "class Solution(object):\n    def mergeNodes(self, head):\n        \n        cur = dummy = ListNode()\n        while head:\n            if head.val:\n                cur.next = head\n                cur = cur.next\n            else:\n                if cur.val:\n                    cur.next = None\n            head = head.next\n        return dummy.next"}
{"id": "1523", "path": "output2\\py\\Medium\\1523-construct-string-with-repeat-limit.py", "hypo_code": "class Solution(object):\n    def repeatLimitedString(self, s, repeatLimit):\n        \n        res = []\n        for c in s:\n            if res[-repeatLimit:] == [c] * repeatLimit:\n                continue\n            res.append(c)\n        return ''.join(res)"}
{"id": "1524", "path": "output2\\py\\Medium\\1524-minimum-number-of-steps-to-make-two-strings-anagram-ii.py", "hypo_code": "class Solution(object):\n    def minSteps(self, s, t):\n        \n        c1, c2 = Counter(s), Counter(t)\n        return sum((c1 - c2).values())"}
{"id": "1525", "path": "output2\\py\\Medium\\1525-minimum-time-to-complete-trips.py", "hypo_code": "class Solution(object):\n    def minimumTime(self, time, totalTrips):\n        \n        l, r = 0, 10000000000\n        while l < r:\n            m = (l + r) / 2\n            trips = sum((m + t - 1) / t for t in time)\n            if trips >= totalTrips:\n                r = m\n            else:\n                l = m + 1\n        return l"}
{"id": "1526", "path": "output2\\py\\Medium\\1526-sort-the-jumbled-numbers.py", "hypo_code": "class Solution(object):\n    def sortJumbled(self, mapping, nums):\n        \n        res = []\n        for num in nums:\n            res.append(int(''.join([str(mapping[int(c)]) for c in str(num)])))\n        return sorted(res)"}
{"id": "1527", "path": "output2\\py\\Medium\\1527-all-ancestors-of-a-node-in-a-directed-acyclic-graph.py", "hypo_code": "class Solution(object):\n    def getAncestors(self, n, edges):\n        \n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[v].append(u)\n        def dfs(i):\n            res = []\n            for j in g[i]:\n                res += dfs(j)\n            return res + [i]\n        return [sorted(dfs(i)) for i in range(n)]"}
{"id": "1528", "path": "output2\\py\\Medium\\1528-append-k-integers-with-minimal-sum.py", "hypo_code": "class Solution(object):\n    def minimalKSum(self, nums, k):\n        \n        nums.sort()\n        res = 0\n        for i in range(k):\n            if nums[i] == res:\n                res += 1\n            else:\n                break\n        return res"}
{"id": "1529", "path": "output2\\py\\Medium\\1529-create-binary-tree-from-descriptions.py", "hypo_code": "class Solution(object):\n    def createBinaryTree(self, descriptions):\n        \n        nodes = {}\n        for parent, child, isLeft in descriptions:\n            if parent not in nodes:\n                nodes[parent] = TreeNode(parent)\n            if child not in nodes:\n                nodes[child] = TreeNode(child)\n            if isLeft:\n                nodes[parent].left = nodes[child]\n            else:\n                nodes[parent].right = nodes[child]\n        return nodes[descriptions[0][0]]"}
{"id": "1530", "path": "output2\\py\\Medium\\1530-count-artifacts-that-can-be-extracted.py", "hypo_code": "class Solution(object):\n    def digArtifacts(self, n, artifacts, dig):\n                 \n        result = 0\n        for i in range(len(artifacts)):\n            if self.isArtifactExtracted(n, artifacts[i], dig):\n                result += 1\n        return result"}
{"id": "1531", "path": "output2\\py\\Medium\\1531-maximize-the-topmost-element-after-k-moves.py", "hypo_code": "class Solution(object):\n    def maximumTop(self, nums, k):\n        \n        result=0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)+1):\n                if len(set([nums[k]+c for k in range(i,j) for c in range(k+1)]))==len([nums[k]+c for k in range(i,j) for c in range(k+1)]):\n                    result=max(result,min(nums[i:j]))\n        return result"}
{"id": "1532", "path": "output2\\py\\Medium\\1532-maximize-number-of-subsequences-in-a-string.py", "hypo_code": "class Solution(object):\n    def maximumSubsequenceCount(self, text, pattern):\n                        \n        if len(text)==0:\n            return 0\n        if len(text)==1:\n            if text[0]==pattern[0] or text[0]==pattern[1]:\n                return 1\n            else:\n                return 0\n        if len(text)==2:\n            if text[0]==pattern[0] and text[1]==pattern[1]:\n                return 1\n            if text[0]==pattern[1] and text[1]==pattern[0]:\n                return 1\n            if text[0]==pattern[0] or text[0]==pattern[1]:\n                return 1\n            if text[1]==pattern[0] or text[1]==pattern[1]:\n                return 1\n            return 0\n        if len(text)==3:\n            if text[0]==pattern[0] and text[1]==pattern[1]:\n                return 1\n            if text[0]==pattern[1] and text[1]==pattern[0]:\n                return 1\n            if text[0]==pattern[0] or text[0]==pattern[1]:\n                return 1\n            if text[1]==pattern[0] or text[1]==pattern[1]:\n                return 1\n            if text[2]==pattern[0] or text[2]==pattern[1]:\n                return 1\n            return 0\n        if len(text)==4:\n            if text[0]==pattern[0] and text[1]==pattern[1]:\n                return 1\n            if text[0]==pattern[1] and text[1]==pattern[0]:\n                return 1\n            if text[0]==pattern[0] or text[0]==pattern[1]:\n                return 1\n            if text[1]==pattern[0] or text[1]==pattern[1]:\n                return 1\n            if text[2]==pattern[0] or text[2]==pattern[1]:\n                return 1\n            if text[3]==pattern[0] or text[3]==pattern[1]:\n                return 1\n            return 0\n        if len(text)==5:\n            if text[0]==pattern[0] and text[1]==pattern[1]:\n                return 1\n            if text[0]==pattern[1] and text[1]==pattern[0]:\n                return 1"}
{"id": "1533", "path": "output2\\py\\Medium\\1533-minimum-operations-to-halve-array-sum.py", "hypo_code": "class Solution(object):\n    def halveArray(self, nums):\n        \n        result=0\n        while sum(nums)>sum(nums)/2:\n            nums[nums.index(max(nums))]=max(nums)/2\n            result+=1\n        return result"}
{"id": "1534", "path": "output2\\py\\Medium\\1534-count-collisions-on-a-road.py", "hypo_code": "class Solution(object):\n    def countCollisions(self, directions):\n                                   \n        count=0\n        for i in range(len(directions)-1):\n            if directions[i]=='L' and directions[i+1]=='R':\n                count+=1\n        return count*2"}
{"id": "1535", "path": "output2\\py\\Medium\\1535-maximum-points-in-an-archery-competition.py", "hypo_code": "class Solution(object):\n    def maximumBobPoints(self, numArrows, aliceArrows):\n        \n        bobArrows=[0]*12\n        for i in range(12):\n            bobArrows[i]=numArrows-aliceArrows[i]\n        return bobArrows"}
{"id": "1536", "path": "output2\\py\\Medium\\1536-minimum-deletions-to-make-array-beautiful.py", "hypo_code": "class Solution(object):\n    def minDeletion(self, nums):\n        \n        n = len(nums)\n        res = n\n        for i in range(n):\n            if i % 2 == nums[i] % 2:\n                res -= 1\n        return res"}
{"id": "1537", "path": "output2\\py\\Medium\\1537-find-palindrome-with-fixed-length.py", "hypo_code": "class Solution(object):\n    def kthPalindrome(self, queries, intLength):\n        \n        res = []\n        for query in queries:\n            for i in range(10 ** (intLength - 1), 10 ** intLength):\n                if str(i) == str(i)[::-1]:\n                    query -= 1\n                    if query == 0:\n                        res.append(i)\n                        break\n        return res"}
{"id": "1538", "path": "output2\\py\\Medium\\1538-find-triangular-sum-of-an-array.py", "hypo_code": "class Solution(object):\n    def triangularSum(self, nums):\n        \n        while len(nums) > 1:\n            nums = [(x + y) % 10 for x, y in zip(nums, nums[1:])]\n        return nums[0]"}
{"id": "1539", "path": "output2\\py\\Medium\\1539-number-of-ways-to-select-buildings.py", "hypo_code": "class Solution(object):\n    def numberOfWays(self, s):\n        \n        n = len(s)\n        MOD = 10 ** 9 + 7\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i - 1] * (s[i - 1] == '0') % MOD\n        res = 0\n        for i in range(n - 2, -1, -1):\n            res += dp[i] * dp[i + 1]\n        return res % MOD"}
{"id": "1540", "path": "output2\\py\\Medium\\1540-find-players-with-zero-or-one-losses.py", "hypo_code": "class Solution(object):\n    def findWinners(self, matches):\n        \n        winners = set()\n        losers = set()\n        for winner, loser in matches:\n            if loser in winners:\n                winners.remove(loser)\n                losers.add(loser)\n            if winner not in losers:\n                winners.add(winner)\n        return [sorted(winners), sorted(losers)]"}
{"id": "1541", "path": "output2\\py\\Medium\\1541-maximum-candies-allocated-to-k-children.py", "hypo_code": "class Solution(object):\n    def maximumCandies(self, candies, k):\n        \n        n = len(candies)\n        res = 0\n        for i in range(k):\n            res += candies[i]\n        for i in range(k, n):\n            candies[i] += candies[i - k]\n            res = max(res, candies[i])\n        return res"}
{"id": "1542", "path": "output2\\py\\Medium\\1542-minimize-result-by-adding-parentheses-to-expression.py", "hypo_code": "class Solution(object):\n    def minimizeResult(self, expression):\n        \n        n = len(expression)\n        dp = [[0, 0]] * n\n        for i in range(n):\n            dp[i][0] = dp[i][1] = int(expression[i])\n        for i in range(1, n):\n            if expression[i] == '+':\n                dp[i][0] = min(dp[i - 1][0] + dp[i][0], dp[i - 1][1] + dp[i][1])\n                dp[i][1] = min(dp[i - 1][0] + dp[i][1], dp[i - 1][1] + dp[i][0])\n        return str(min(dp[-1]))"}
{"id": "1543", "path": "output2\\py\\Medium\\1543-maximum-product-after-k-increments.py", "hypo_code": "class Solution(object):\n    def maximumProduct(self, nums, k):\n        \n        nums.sort()\n        res = 1\n        for i in range(k):\n            res = (res * nums[-1 - i]) % 1000000007\n        return res"}
{"id": "1544", "path": "output2\\py\\Medium\\1544-number-of-ways-to-buy-pens-and-pencils.py", "hypo_code": "class Solution(object):\n    def waysToBuyPensPencils(self, total, cost1, cost2):\n        \n        return sum(1 for i in range(total // cost1 + 1) if (total - i * cost1) % cost2 == 0)"}
{"id": "1546", "path": "output2\\py\\Medium\\1546-minimum-rounds-to-complete-all-tasks.py", "hypo_code": "class Solution(object):\n    def minimumRounds(self, tasks):\n        \n        result=0\n        while len(tasks)>0:\n            if len(set(tasks))==1:\n                result+=1\n                tasks=[]\n            else:\n                for i in range(len(tasks)):\n                    if tasks[i]%2==1:\n                        tasks[i]+=1\n                tasks=[tasks[i]//2 for i in range(len(tasks))]\n                result+=1\n        return result"}
{"id": "1547", "path": "output2\\py\\Medium\\1547-maximum-trailing-zeros-in-a-cornered-path.py", "hypo_code": "class Solution(object):\n    def maxTrailingZeros(self, grid):\n                                                                                                        \n        return self.maxTrailingZerosFromIndex(grid, 0, 0)"}
{"id": "1548", "path": "output2\\py\\Medium\\1548-count-lattice-points-inside-a-circle.py", "hypo_code": "class Solution(object):\n    def countLatticePoints(self, circles):\n        \n        result=0\n        for i in range(len(circles)):\n            for j in range(i+1,len(circles)):\n                if circles[i][0]==circles[j][0] and circles[i][1]==circles[j][1]:\n                    result+=1\n                elif circles[i][0]==circles[j][0]:\n                    result+=1\n                elif circles[i][1]==circles[j][1]:\n                    result+=1\n                else:\n                    result+=1\n        return result"}
{"id": "1549", "path": "output2\\py\\Medium\\1549-count-number-of-rectangles-containing-each-point.py", "hypo_code": "class Solution(object):\n    def countRectangles(self, rectangles, points):\n        \n        result=[]\n        for i in range(len(points)):\n            result.append(sum([1 for j in range(len(rectangles)) if points[i][0]<=rectangles[j][0] and points[i][1]<=rectangles[j][1]]))\n        return result"}
{"id": "1550", "path": "output2\\py\\Medium\\1550-minimum-average-difference.py", "hypo_code": "class Solution(object):\n    def minimumAverageDifference(self, nums):\n        \n        result = 0\n        for i in range(len(nums)):\n            if nums[i] != target[i]:\n                for j in range(i+1, len(nums)):\n                    if nums[j] == target[i]:\n                        nums[i], nums[j] = nums[j], nums[i]\n                        result += 1\n                        break\n        return result"}
{"id": "1551", "path": "output2\\py\\Medium\\1551-count-unguarded-cells-in-the-grid.py", "hypo_code": "class Solution(object):\n    def countUnguarded(self, m, n, guards, walls):\n                                                                                                        \n        return self.countUnguardedFromIndex(m, n, guards, walls, 0, 0)"}
{"id": "1552", "path": "output2\\py\\Medium\\1552-minimum-consecutive-cards-to-pick-up.py", "hypo_code": "class Solution(object):\n    def minimumCardPickup(self, cards):\n         \n            \n        \n        \n        \n            \n         \n        cards.sort()\n            \n        \n        \n        return self.minimumCardPickupFromIndex(cards, 0, 0)"}
{"id": "1553", "path": "output2\\py\\Medium\\1553-k-divisible-elements-subarrays.py", "hypo_code": "class Solution(object):\n    def countDistinct(self, nums, k, p):\n        \n        \n        \n        \n        return self.countDistinctFromIndex(nums, k, p, 0, 0, 0)"}
{"id": "1554", "path": "output2\\py\\Medium\\1554-count-nodes-equal-to-average-of-subtree.py", "hypo_code": "class Solution(object):\n    def averageOfSubtree(self, root):\n        \n        if root==None:\n            return 0\n        if root.left==None and root.right==None:\n            return 1\n        return self.averageOfSubtree(root.left)+self.averageOfSubtree(root.right)+1"}
{"id": "1555", "path": "output2\\py\\Medium\\1555-count-number-of-texts.py", "hypo_code": "class Solution(object):\n    def countTexts(self, pressedKeys):\n        \n        n = len(pressedKeys)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(n):\n            for j in range(1, 4):\n                if i + j <= n:\n                    dp[i + j] += dp[i]\n        return dp[n]"}
{"id": "1556", "path": "output2\\py\\Medium\\1556-number-of-ways-to-split-array.py", "hypo_code": "class Solution(object):\n    def waysToSplitArray(self, nums):\n              \n        result=0\n        for i in range(len(nums)-2):\n            left=nums[:i+1]\n            right=nums[i+1:]\n            if sum(left)>=sum(right):\n                break\n            else:\n                for j in range(len(right)-1):\n                    if sum(left)<=sum(right[:j+1]):\n                        break\n                    else:\n                        result+=1\n        return result"}
{"id": "1557", "path": "output2\\py\\Medium\\1557-maximum-white-tiles-covered-by-a-carpet.py", "hypo_code": "class Solution(object):\n    def maximumWhiteTiles(self, tiles, carpetLen):\n         \n        \n        \n        \n        \n        return self.maximumWhiteTilesFromIndex(tiles, carpetLen, 0, 0)"}
{"id": "1558", "path": "output2\\py\\Medium\\1558-maximum-consecutive-floors-without-special-floors.py", "hypo_code": "class Solution(object):\n    def maxConsecutive(self, bottom, top, special):\n         \n        \n        \n        \n        \n        return self.maxConsecutiveFromIndex(bottom, top, special, 0, 0)"}
{"id": "1559", "path": "output2\\py\\Medium\\1559-largest-combination-with-bitwise-and-greater-than-zero.py", "hypo_code": "class Solution(object):\n    def largestCombination(self, candidates):\n              \n        result=0\n        for i in range(len(candidates)-1):\n            for j in range(i+1,len(candidates)):\n                if candidates[i]&candidates[j]>result:\n                    result=candidates[i]&candidates[j]\n        return result"}
{"id": "1560", "path": "output2\\py\\Medium\\1560-maximum-bags-with-full-capacity-of-rocks.py", "hypo_code": "class Solution(object):\n    def maximumBags(self, capacity, rocks, additionalRocks):\n         \n        \n        \n        \n        \n        return self.maximumBagsFromIndex(capacity, rocks, additionalRocks, 0, 0)"}
{"id": "1561", "path": "output2\\py\\Medium\\1561-minimum-lines-to-represent-a-line-chart.py", "hypo_code": "class Solution(object):\n    def minimumLines(self, stockPrices):\n        \n        n = len(stockPrices)\n        dp = [1] * n\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + (stockPrices[i][1] != stockPrices[i - 1][1])\n        return dp[-1]"}
{"id": "1562", "path": "output2\\py\\Medium\\1562-sender-with-largest-word-count.py", "hypo_code": "class Solution(object):\n    def largestWordCount(self, messages, senders):\n         \n        \n        \n        \n        \n        return self.largestWordCountFromIndex(messages, senders, 0, 0)"}
{"id": "1563", "path": "output2\\py\\Medium\\1563-maximum-total-importance-of-roads.py", "hypo_code": "class Solution(object):\n    def maximumImportance(self, n, roads):\n              \n        \n        \n        \n        \n        return self.maximumImportanceFromIndex(n, roads, 0, 0)"}
{"id": "1564", "path": "output2\\py\\Medium\\1564-apply-discount-to-prices.py", "hypo_code": "class Solution(object):\n    def discountPrices(self, sentence, discount):\n                                                                          \n        \n        \n        \n        \n        return self.discountPricesFromIndex(sentence, discount, 0, \"\")"}
{"id": "1565", "path": "output2\\py\\Medium\\1565-steps-to-make-array-non-decreasing.py", "hypo_code": "class Solution(object):\n    def totalSteps(self, nums):\n                         \n        return self.totalStepsFromIndex(nums,0)"}
{"id": "1566", "path": "output2\\py\\Medium\\1566-partition-array-such-that-maximum-difference-is-k.py", "hypo_code": "class Solution(object):\n    def partitionArray(self, nums, k):\n        \n        res = 0\n        for i, num in enumerate(nums):\n            if num - nums[i - 1] > k:\n                res += 1\n        return res + 1"}
{"id": "1567", "path": "output2\\py\\Medium\\1567-replace-elements-in-an-array.py", "hypo_code": "class Solution(object):\n    def arrayChange(self, nums, operations):\n        \n        for i, j in operations:\n            nums[i] = j\n        return nums"}
{"id": "1568", "path": "output2\\py\\Medium\\1568-successful-pairs-of-spells-and-potions.py", "hypo_code": "class Solution(object):\n    def successfulPairs(self, spells, potions, success):\n         \n        \n        \n        \n        \n        return self.successfulPairsFromIndex(spells, potions, success, 0, 0)"}
{"id": "1569", "path": "output2\\py\\Medium\\1569-minimum-path-cost-in-a-grid.py", "hypo_code": "class Solution(object):\n    def minPathCost(self, grid, moveCost):\n                                                                   \n        m=len(grid)\n        n=len(grid[0])\n        dp=[[float('inf') for i in range(n)] for j in range(m)]\n        for i in range(n):\n            dp[0][i]=grid[0][i]\n        for i in range(1,m):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+moveCost[grid[i-1][k]][k]+grid[i][j])\n        return min(dp[m-1])"}
{"id": "1570", "path": "output2\\py\\Medium\\1570-fair-distribution-of-cookies.py", "hypo_code": "class Solution(object):\n    def distributeCookies(self, cookies, k):\n        \n        cookies.sort()\n        result=0\n        for i in range(k):\n            result+=cookies[-1-i]\n        return result"}
{"id": "1571", "path": "output2\\py\\Medium\\1571-sum-of-numbers-with-units-digit-k.py", "hypo_code": "class Solution(object):\n    def minimumNumbers(self, num, k):\n        \n        if num == 0:\n            return 0\n        if num < k:\n            return -1\n        if num % k == 0:\n            return 1\n        if num < 2 * k:\n            return -1\n        return 2"}
{"id": "1572", "path": "output2\\py\\Medium\\1572-longest-binary-subsequence-less-than-or-equal-to-k.py", "hypo_code": "class Solution(object):\n    def longestSubsequence(self, s, k):\n        \n        \n        pass"}
{"id": "1573", "path": "output2\\py\\Medium\\1573-count-unreachable-pairs-of-nodes-in-an-undirected-graph.py", "hypo_code": "class Solution(object):\n    def countPairs(self, n, edges):\n        \n        g = collections.defaultdict(set)\n        for i, j in edges:\n            g[i].add(j)\n            g[j].add(i)\n        res = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if j not in g[i]:\n                    res += 1\n        return res"}
{"id": "1574", "path": "output2\\py\\Medium\\1574-maximum-xor-after-operations.py", "hypo_code": "class Solution(object):\n    def maximumXOR(self, nums):\n        \n        res = 0\n        for i in range(31, -1, -1):\n            res <<= 1\n            prefixes = {num >> i for num in nums}\n            res += any(res ^ 1 ^ p in prefixes for p in prefixes)\n        return res"}
{"id": "1575", "path": "output2\\py\\Medium\\1575-count-number-of-ways-to-place-houses.py", "hypo_code": "class Solution(object):\n    def countHousePlacements(self, n):\n        \n        if n == 0:\n            return 0\n        dp = [[0, 0] for _ in range(n + 1)]\n        dp[1] = [1, 1]\n        for i in range(2, n + 1):\n            dp[i][0] = dp[i - 1][1] + dp[i - 1][0]\n            dp[i][1] = dp[i - 1][0]\n        return dp[n][0] + dp[n][1]"}
{"id": "1576", "path": "output2\\py\\Medium\\1576-spiral-matrix-iv.py", "hypo_code": "class Solution(object):\n    def spiralMatrix(self, m, n, head):\n        \n        def spiralOrder(matrix):\n            res = []\n            while matrix:\n                res += matrix.pop(0)\n                matrix = list(zip(*matrix))[::-1]\n            return res\n        matrix = [[-1] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if head:\n                    matrix[i][j] = head.val\n                    head = head.next\n        return spiralOrder(matrix)"}
{"id": "1577", "path": "output2\\py\\Medium\\1577-number-of-people-aware-of-a-secret.py", "hypo_code": "class Solution(object):\n    def peopleAwareOfSecret(self, n, delay, forget):\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            if i >= delay:\n                dp[i] += dp[i - delay]\n            if i >= forget:\n                dp[i] -= dp[i - forget]\n        return dp[n]"}
{"id": "1578", "path": "output2\\py\\Medium\\1578-the-latest-time-to-catch-a-bus.py", "hypo_code": "class Solution(object):\n    def latestTimeCatchTheBus(self, buses, passengers, capacity):\n        \n        n, m = len(buses), len(passengers)\n        buses.sort()\n        passengers.sort()\n        res = 0\n        for i in range(m):\n            if passengers[i] > buses[-1]:\n                return -1\n            if passengers[i] <= buses[i]:\n                res = max(res, buses[i])\n            else:\n                res = max(res, buses[i] + (passengers[i] - buses[i] + capacity - 1) / capacity * capacity)\n        return res"}
{"id": "1579", "path": "output2\\py\\Medium\\1579-minimum-sum-of-squared-difference.py", "hypo_code": "class Solution(object):\n    def minSumSquareDiff(self, nums1, nums2, k1, k2):\n        \n        nums1.sort()\n        nums2.sort()\n        n = len(nums1)\n        dp = [[0, 0]]\n        res = 0\n        for i in range(n):\n            diff = abs(nums1[i] - nums2[i])\n            while k1 + k2 < i - dp[-1][0] + 1:\n                dp.pop(0)\n            if dp[0][1] + diff > res:\n                res = dp[0][1] + diff\n            if res > dp[-1][1]:\n                dp.append([i, res])\n        return res"}
{"id": "1581", "path": "output2\\py\\Medium\\1581-move-pieces-to-obtain-a-string.py", "hypo_code": "class Solution(object):\n    def canChange(self, start, target):\n        \n        n = len(start)\n        for i in range(n):\n            if start[i] != target[i] and (start[i] == 'L' or start[i] == 'R'):\n                return False\n        return True"}
{"id": "1582", "path": "output2\\py\\Medium\\1582-max-sum-of-a-pair-with-equal-sum-of-digits.py", "hypo_code": "class Solution(object):\n    def maximumSum(self, nums):\n        \n        dp = {}\n        res = -1\n        for num in nums:\n            digits = sum(map(int, str(num)))\n            if digits not in dp:\n                dp[digits] = num\n            else:\n                res = max(res, dp[digits] + num)\n                dp[digits] = max(dp[digits], num)\n        return res"}
{"id": "1583", "path": "output2\\py\\Medium\\1583-query-kth-smallest-trimmed-number.py", "hypo_code": "class Solution(object):\n    def smallestTrimmedNumbers(self, nums, queries):\n        \n        n = len(nums)\n        m = len(nums[0])\n        res = []\n        for k, trim in queries:\n            trimmed = []\n            for num in nums:\n                trimmed.append(num[-trim:])\n            trimmed.sort()\n            res.append(int(trimmed[k - 1]))\n        return res"}
{"id": "1584", "path": "output2\\py\\Medium\\1584-number-of-zero-filled-subarrays.py", "hypo_code": "class Solution(object):\n    def zeroFilledSubarray(self, nums):\n        \n        result=0\n        for i in range(len(nums)):\n            if nums[i]==0:\n                result+=1\n                for j in range(i+1,len(nums)):\n                    if nums[j]==0:\n                        result+=1\n                    else:\n                        break\n        return result"}
{"id": "1586", "path": "output2\\py\\Medium\\1586-equal-row-and-column-pairs.py", "hypo_code": "class Solution(object):\n    def equalPairs(self, grid):\n         \n        \n        \n        \n        \n        return self.equalPairsFromIndex(grid, 0, 0)"}
{"id": "1588", "path": "output2\\py\\Medium\\1588-maximum-number-of-groups-entering-a-competition.py", "hypo_code": "class Solution(object):\n    def maximumGroups(self, grades):\n        \n        res = 0\n        for i in range(1, 100001):\n            res += grades.count(i) / i\n        return res"}
{"id": "1589", "path": "output2\\py\\Medium\\1589-find-closest-node-to-given-two-nodes.py", "hypo_code": "class Solution(object):\n    def closestMeetingNode(self, edges, node1, node2):\n        \n        n = len(edges)\n        dp = [0] * n\n        def dfs(i):\n            res = 1\n            if edges[i] != -1:\n                res += dfs(edges[i])\n            dp[i] = res\n            return res\n        dfs(0)\n        res = []\n        for i in range(n):\n            if dp[i] == max(dp):\n                res.append(i)\n        return min(res)"}
{"id": "1590", "path": "output2\\py\\Medium\\1590-count-number-of-bad-pairs.py", "hypo_code": "class Solution(object):\n    def countBadPairs(self, nums):\n        \n        n = len(nums)\n        res = 0\n        for i in range(n):\n            for j in range(n):\n                if i < j and j - i != nums[j] - nums[i]:\n                    res += 1\n        return res"}
{"id": "1591", "path": "output2\\py\\Medium\\1591-task-scheduler-ii.py", "hypo_code": "class Solution(object):\n    def taskSchedulerII(self, tasks, space):\n        \n        return 0"}
{"id": "1592", "path": "output2\\py\\Medium\\1592-reachable-nodes-with-restrictions.py", "hypo_code": "class Solution(object):\n    def reachableNodes(self, n, edges, restricted):\n        \n        return 0"}
{"id": "1593", "path": "output2\\py\\Medium\\1593-check-if-there-is-a-valid-partition-for-the-array.py", "hypo_code": "class Solution(object):\n    def validPartition(self, nums):\n        \n        return True"}
{"id": "1594", "path": "output2\\py\\Medium\\1594-longest-ideal-subsequence.py", "hypo_code": "class Solution(object):\n    def longestIdealString(self, s, k):\n        \n        return 0"}
{"id": "1595", "path": "output2\\py\\Medium\\1595-node-with-highest-edge-score.py", "hypo_code": "class Solution(object):\n    def edgeScore(self, edges):\n         \n        return 0"}
{"id": "1596", "path": "output2\\py\\Medium\\1596-construct-smallest-number-from-di-string.py", "hypo_code": "class Solution(object):\n    def smallestNumber(self, pattern):\n         \n        return \"\""}
{"id": "1597", "path": "output2\\py\\Medium\\1597-time-needed-to-rearrange-a-binary-string.py", "hypo_code": "class Solution(object):\n    def secondsToRemoveOccurrences(self, s):\n        \n        return 0"}
{"id": "1598", "path": "output2\\py\\Medium\\1598-shifting-letters-ii.py", "hypo_code": "class Solution(object):\n    def shiftingLetters(self, s, shifts):\n        \n        return \"\""}
{"id": "1599", "path": "output2\\py\\Medium\\1599-largest-palindromic-number.py", "hypo_code": "class Solution(object):\n    def largestPalindromic(self, num):\n         \n        return \"\""}
{"id": "1600", "path": "output2\\py\\Medium\\1600-amount-of-time-for-binary-tree-to-be-infected.py", "hypo_code": "class Solution(object):\n    def amountOfTime(self, root, start):\n        \n        return 0"}
{"id": "1601", "path": "output2\\py\\Medium\\1601-removing-stars-from-a-string.py", "hypo_code": "class Solution(object):\n    def removeStars(self, s):\n        \n        return \"\""}
{"id": "1602", "path": "output2\\py\\Medium\\1602-minimum-amount-of-time-to-collect-garbage.py", "hypo_code": "class Solution(object):\n    def garbageCollection(self, garbage, travel):\n        \n        return 0"}
{"id": "1603", "path": "output2\\py\\Medium\\1603-strictly-palindromic-number.py", "hypo_code": "class Solution(object):\n    def isStrictlyPalindromic(self, n):\n        \n        return False"}
{"id": "1604", "path": "output2\\py\\Medium\\1604-maximum-rows-covered-by-columns.py", "hypo_code": "class Solution(object):\n    def maximumRows(self, matrix, numSelect):\n        \n        return 0"}
{"id": "1605", "path": "output2\\py\\Medium\\1605-number-of-ways-to-reach-a-position-after-exactly-k-steps.py", "hypo_code": "class Solution(object):\n    def numberOfWays(self, startPos, endPos, k):\n        \n        return 0"}
{"id": "1606", "path": "output2\\py\\Medium\\1606-longest-nice-subarray.py", "hypo_code": "class Solution(object):\n    def longestNiceSubarray(self, nums):\n        \n        return 0"}
{"id": "1607", "path": "output2\\py\\Medium\\1607-optimal-partition-of-string.py", "hypo_code": "class Solution(object):\n    def partitionString(self, s):\n        \n        return 0"}
{"id": "1608", "path": "output2\\py\\Medium\\1608-divide-intervals-into-minimum-number-of-groups.py", "hypo_code": "class Solution(object):\n    def minGroups(self, intervals):\n        \n        return 0"}
{"id": "1609", "path": "output2\\py\\Medium\\1609-maximum-matching-of-players-with-trainers.py", "hypo_code": "class Solution(object):\n    def matchPlayersAndTrainers(self, players, trainers):\n        \n        return 0"}
{"id": "1610", "path": "output2\\py\\Medium\\1610-smallest-subarrays-with-maximum-bitwise-or.py", "hypo_code": "class Solution(object):\n    def smallestSubarrays(self, nums):\n        \n        return []"}
{"id": "1611", "path": "output2\\py\\Medium\\1611-length-of-the-longest-alphabetical-continuous-substring.py", "hypo_code": "class Solution(object):\n    def longestContinuousSubstring(self, s):\n        \n        return 0"}
{"id": "1612", "path": "output2\\py\\Medium\\1612-reverse-odd-levels-of-binary-tree.py", "hypo_code": "class Solution(object):\n    def reverseOddLevels(self, root):\n        \n        return root"}
{"id": "1613", "path": "output2\\py\\Medium\\1613-longest-subarray-with-maximum-bitwise-and.py", "hypo_code": "class Solution(object):\n    def longestSubarray(self, nums):\n        \n        \n        max_bit_length = 0\n        for num in nums:\n            max_bit_length = max(max_bit_length, len(bin(num)) - 2)\n\n        \n        max_bit_length_of_max_bitwise_and = 0\n        for num in nums:\n            if num & (num - 1) == 0:\n                max_bit_length_of_max_bitwise_and = max(max_bit_length_of_max_bitwise_and, len(bin(num)) - 2)\n\n        \n        max_length = 0\n        for i in range(len(nums)):\n            if nums[i] & (nums[i] - 1) == 0:\n                max_length = max(max_length, 1)\n            else:\n                max_length = max(max_length, self.get_max_length_of_subarray_with_max_bitwise_and(nums, i, max_bit_length_of_max_bitwise_and))\n\n        return max_length"}
{"id": "1614", "path": "output2\\py\\Medium\\1614-find-all-good-indices.py", "hypo_code": "class Solution(object):\n    def goodIndices(self, nums, k):\n        \n        return []"}
{"id": "1616", "path": "output2\\py\\Medium\\1616-bitwise-xor-of-all-pairings.py", "hypo_code": "class Solution(object):\n    def xorAllNums(self, nums1, nums2):\n        \n        return 0"}
{"id": "1617", "path": "output2\\py\\Medium\\1617-maximum-sum-of-an-hourglass.py", "hypo_code": "class Solution(object):\n    def maxSum(self, grid):\n        \n        return 0"}
{"id": "1618", "path": "output2\\py\\Medium\\1618-minimize-xor.py", "hypo_code": "class Solution(object):\n    def minimizeXor(self, num1, num2):\n        \n        return 0"}
{"id": "1619", "path": "output2\\py\\Medium\\1619-find-the-original-array-of-prefix-xor.py", "hypo_code": "class Solution(object):\n    def findArray(self, pref):\n        \n        return []"}
{"id": "1620", "path": "output2\\py\\Medium\\1620-using-a-robot-to-print-the-lexicographically-smallest-string.py", "hypo_code": "class Solution(object):\n    def robotWithString(self, s):\n        \n        return \"\""}
{"id": "1621", "path": "output2\\py\\Medium\\1621-range-product-queries-of-powers.py", "hypo_code": "class Solution(object):\n    def productQueries(self, n, queries):\n        \n        return []"}
{"id": "1622", "path": "output2\\py\\Medium\\1622-minimize-maximum-of-array.py", "hypo_code": "class Solution(object):\n    def minimizeArrayValue(self, nums):\n        \n        result=0\n        while len(nums)>0:\n            if len(set(nums))==1:\n                result+=1\n                nums=[]\n            else:\n                for i in range(len(nums)):\n                    if nums[i]%2==1:\n                        nums[i]+=1\n                nums=[nums[i]//2 for i in range(len(nums))]\n                result+=1\n        return result"}
{"id": "1623", "path": "output2\\py\\Medium\\1623-count-number-of-distinct-integers-after-reverse-operations.py", "hypo_code": "class Solution(object):\n    def countDistinctIntegers(self, nums):\n         \n        \n        \n        \n        \n        return self.countDistinctIntegersFromIndex(nums, 0, set())"}
{"id": "1624", "path": "output2\\py\\Medium\\1624-sum-of-number-and-its-reverse.py", "hypo_code": "class Solution(object):\n    def sumOfNumberAndReverse(self, num):\n         \n        \n        \n        \n        \n        \n        reverse=self.reverse(num)\n        \n        sum=num+reverse\n        \n        \n        return sum==num"}
{"id": "1625", "path": "output2\\py\\Medium\\1625-number-of-subarrays-with-gcd-equal-to-k.py", "hypo_code": "class Solution(object):\n    def subarrayGCD(self, nums, k):\n        \n        result=0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)+1):\n                if len(set([nums[k]+c for k in range(i,j) for c in range(k+1)]))==len([nums[k]+c for k in range(i,j) for c in range(k+1)]):\n                    result=max(result,min(nums[i:j]))\n        return result"}
{"id": "1626", "path": "output2\\py\\Medium\\1626-words-within-two-edits-of-dictionary.py", "hypo_code": "class Solution(object):\n    def twoEditWords(self, queries, dictionary):\n        \n        result=[]\n        for i in range(len(queries)):\n            for j in range(len(dictionary)):\n                if self.edit_distance(queries[i],dictionary[j])<=2:\n                    result.append(queries[i])\n                    break\n        return result"}
{"id": "1627", "path": "output2\\py\\Medium\\1627-destroy-sequential-targets.py", "hypo_code": "class Solution(object):\n    def destroyTargets(self, nums, space):\n        \n        result=0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)+1):\n                if len(set([nums[k]+c*space for k in range(i,j) for c in range(1000)]))==len([nums[k]+c*space for k in range(i,j) for c in range(1000)]):\n                    result=max(result,min(nums[i:j]))\n        return result"}
{"id": "1628", "path": "output2\\py\\Medium\\1628-most-popular-video-creator.py", "hypo_code": "class Solution(object):\n    def mostPopularCreator(self, creators, ids, views):\n               \n        from collections import defaultdict\n        popularity = defaultdict(int)\n        max_popularity = 0\n        for creator, video_id, view in zip(creators, ids, views):\n            popularity[creator] += view\n            max_popularity = max(max_popularity, popularity[creator])\n        result = []\n        for creator, view in popularity.items():\n            if view == max_popularity:\n                result.append([creator, video_id])\n        return result"}
{"id": "1629", "path": "output2\\py\\Medium\\1629-minimum-addition-to-make-integer-beautiful.py", "hypo_code": "class Solution(object):\n    def makeIntegerBeautiful(self, n, target):\n              \n        \n        \n        \n        sum_digits = self.get_sum_of_digits(n)\n        if sum_digits > target:\n            return sum_digits - target\n        return 0"}
{"id": "1630", "path": "output2\\py\\Medium\\1630-maximum-sum-of-distinct-subarrays-with-length-k.py", "hypo_code": "class Solution(object):\n    def maximumSubarraySum(self, nums, k):\n        \n        if k==1:\n            return max(nums)\n        if k==len(nums):\n            return sum(set(nums))\n        nums.sort()\n        nums.append(None)\n        count=1\n        for i in range(1,len(nums)):\n            if nums[i]==nums[i-1]+1:\n                count+=1\n            else:\n                if count==len(nums)-1:\n                    return sum(nums)-nums[0]\n                count=1\n        return sum(nums)-nums[0]-nums[1]"}
{"id": "1631", "path": "output2\\py\\Medium\\1631-total-cost-to-hire-k-workers.py", "hypo_code": "class Solution(object):\n    def totalCost(self, costs, k, candidates):\n                                                                                                       \n        \n        \n        \n        \n        \n        \n        \n        costs.sort()\n        sum_from_beginning = sum(costs[:k])\n        sum_from_end = sum(costs[-k:])\n        for i in range(k):\n            if i < k:\n                sum_from_beginning -= costs[i]\n                sum_from_beginning += costs[-(i + 1)]\n            if i < k:\n                sum_from_end -= costs[-(i + 1)]\n                sum_from_end += costs[i]\n        return min(sum_from_beginning, sum_from_end)"}
{"id": "1632", "path": "output2\\py\\Medium\\1632-count-ways-to-build-good-strings.py", "hypo_code": "class Solution(object):\n    def countGoodStrings(self, low, high, zero, one):\n         \n        self.count=0\n        self.dfs(low,high,zero,one,\"\")\n        return self.count"}
{"id": "1633", "path": "output2\\py\\Medium\\1633-most-profitable-path-in-a-tree.py", "hypo_code": "class Solution(object):\n    def mostProfitablePath(self, edges, bob, amount):\n                \n        \n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        \n        def dfs(node, parent):\n            \n            if node == bob:\n                return 0, 0\n            if node in memo:\n                return memo[node]\n            \n            max_profit = 0\n            min_cost = float('inf')\n            for child in graph[node]:\n                if child == parent:\n                    continue\n                profit, cost = dfs(child, node)\n                max_profit = max(max_profit, profit)\n                min_cost = min(min_cost, cost)\n            \n            if amount[node] < 0:\n                min_cost = min(min_cost, -amount[node])\n            else:\n                max_profit += amount[node]\n            \n            memo[node] = max_profit, min_cost\n            return max_profit, min_cost\n        \n        memo = {}\n        max_profit, min_cost = dfs(0, -1)\n        return max_profit - min_cost // 2"}
{"id": "1634", "path": "output2\\py\\Medium\\1634-number-of-subarrays-with-lcm-equal-to-k.py", "hypo_code": "class Solution(object):\n    def subarrayLCM(self, nums, k):\n               \n        if k==1:\n            return len(nums)*(len(nums)+1)/2\n        if k>max(nums):\n            return 0\n        if k==max(nums):\n            return 1\n        \n        if k==2:\n            return sum([1 for i in nums if i%2==0])\n        if k==3:\n            return sum([1 for i in nums if i%3==0])\n        if k==5:\n            return sum([1 for i in nums if i%5==0])\n        if k==7:\n            return sum([1 for i in nums if i%7==0])\n        if k==11:\n            return sum([1 for i in nums if i%11==0])\n        if k==13:\n            return sum([1 for i in nums if i%13==0])\n        if k==17:\n            return sum([1 for i in nums if i%17==0])\n        if k==19:\n            return sum([1 for i in nums if i%19==0])\n        if k==23:\n            return sum([1 for i in nums if i%23==0])\n        if k==29:\n            return sum([1 for i in nums if i%29==0])\n        \n        if k==31:\n            return sum([1 for i in nums if i%31==0])\n        if k==37:\n            return sum([1 for i in nums if i%37==0])\n        if k==41:\n            return sum([1 for i in nums if i%41==0])\n        if k==43:\n            return sum([1 for i in nums if i%43==0])\n        if k==47:\n            return sum([1 for i in nums if i%47==0])\n        if k==53:\n            return sum([1 for i in nums if i%53==0])\n        if k==59:\n            return sum([1 for i in nums if i%59==0])\n        if k==61:\n            return sum([1 for i in nums if i%61==0])\n        if k==67:\n            return sum([1 for i in nums if i%67==0])\n        if k==71:\n            return sum([1 for i in nums if i%71==0])\n        if k==73:\n            return sum([1 for i in nums if i % 73 == 0])"}
{"id": "1635", "path": "output2\\py\\Medium\\1635-minimum-number-of-operations-to-sort-a-binary-tree-by-level.py", "hypo_code": "class Solution(object):\n    def minimumOperations(self, root):\n        \n        \n        \n        \n        levels = self.get_levels(root)\n        operations = 0\n        for level in levels:\n            operations += self.get_operations(level)\n        return operations"}
{"id": "1636", "path": "output2\\py\\Medium\\1636-closest-nodes-queries-in-a-binary-search-tree.py", "hypo_code": "class Solution(object):\n    def closestNodes(self, root, queries):\n        \n        \n        \n        \n        \n        result = []\n        for query in queries:\n            closest_nodes = self.get_closest_nodes(root, query)\n            result.append(closest_nodes)\n        return result"}
{"id": "1637", "path": "output2\\py\\Medium\\1637-minimum-fuel-cost-to-report-to-the-capital.py", "hypo_code": "class Solution(object):\n    def minimumFuelCost(self, roads, seats):\n             \n        \n        \n        \n        \n        graph = self.create_graph(roads)\n        return self.find_shortest_path(graph, 0, len(graph) - 1)"}
{"id": "1638", "path": "output2\\py\\Medium\\1638-difference-between-ones-and-zeros-in-row-and-column.py", "hypo_code": "class Solution(object):\n    def onesMinusZeros(self, grid):\n               \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        output = []\n        ones_row = []\n        zeros_row = []\n        ones_col = []\n        zeros_col = []\n        for row in grid:\n            ones_row.append(0)\n            zeros_row.append(0)\n        for col in grid[0]:\n            ones_col.append(0)\n            zeros_col.append(0)\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 1:\n                    ones_row[row] += 1\n                    ones_col[col] += 1\n                else:\n                    zeros_row[row] += 1\n                    zeros_col[col] += 1\n        for row in range(len(grid)):\n            output.append([])\n            for col in range(len(grid[0])):\n                output[row].append(ones_row[row] + ones_col[col] - zeros_row[row] - zeros_col[col])\n        return output"}
{"id": "1639", "path": "output2\\py\\Medium\\1639-minimum-penalty-for-a-shop.py", "hypo_code": "class Solution(object):\n    def bestClosingTime(self, customers):\n                       \n        res = 0\n        return res"}
{"id": "1640", "path": "output2\\py\\Medium\\1640-append-characters-to-string-to-make-subsequence.py", "hypo_code": "class Solution(object):\n    def appendCharacters(self, s, t):\n              \n        res = 0\n        return res"}
{"id": "1641", "path": "output2\\py\\Medium\\1641-remove-nodes-from-linked-list.py", "hypo_code": "class Solution(object):\n    def removeNodes(self, head):\n        \n        if not head:\n            return None\n        if not head.next:\n            return head\n        if head.val < head.next.val:\n            head.next = self.removeNodes(head.next)\n            return head\n        else:\n            return self.removeNodes(head.next)"}
{"id": "1642", "path": "output2\\py\\Medium\\1642-divide-players-into-teams-of-equal-skill.py", "hypo_code": "class Solution(object):\n    def dividePlayers(self, skill):\n              \n        res = 0\n        skill.sort()\n        for i in range(len(skill)/2):\n            res += skill[i] * skill[~i]\n        return res"}
{"id": "1643", "path": "output2\\py\\Medium\\1643-minimum-score-of-a-path-between-two-cities.py", "hypo_code": "class Solution(object):\n    def minScore(self, n, roads):\n        \n        res = 0\n        for i in range(len(roads)):\n            for j in range(i+1,len(roads)):\n                if roads[i][2] > roads[j][2]:\n                    roads[i],roads[j] = roads[j],roads[i]\n        for i in range(len(roads)):\n            if roads[i][0] == 1 or roads[i][1] == 1:\n                res = roads[i][2]\n                break\n        return res"}
{"id": "1644", "path": "output2\\py\\Medium\\1644-maximum-star-sum-of-a-graph.py", "hypo_code": "class Solution(object):\n    def maxStarSum(self, vals, edges, k):\n                                \n        n = len(vals)\n        graph = [[] for _ in range(n)]\n        for u,v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        res = 0\n        for i in range(n):\n            res = max(res,vals[i]+self.dfs(graph,i,k,vals))\n        return res"}
{"id": "1645", "path": "output2\\py\\Medium\\1645-frog-jump-ii.py", "hypo_code": "class Solution(object):\n    def maxJump(self, stones):\n                           \n        res = 0\n        for i in range(len(stones)):\n            for j in range(i+1,len(stones)):\n                if stones[j] == stones[i]*stones[i]:\n                    res = max(res,j-i+1)\n                elif stones[j] > stones[i]*stones[i]:\n                    break\n        return res if res > 1 else -1"}
{"id": "1646", "path": "output2\\py\\Medium\\1646-longest-square-streak-in-an-array.py", "hypo_code": "class Solution(object):\n    def longestSquareStreak(self, nums):\n               \n        res = 0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[j] == nums[i]*nums[i]:\n                    res = max(res,j-i+1)\n                elif nums[j] > nums[i]*nums[i]:\n                    break\n        return res if res > 1 else -1"}
{"id": "1648", "path": "output2\\py\\Medium\\1648-smallest-value-after-replacing-with-sum-of-prime-factors.py", "hypo_code": "class Solution(object):\n    def smallestValue(self, n):\n                                                                                                \n        res = 0\n        while n > 1:\n            res += self.findSmallestPrimeFactor(n)\n            n = n // self.findSmallestPrimeFactor(n)\n        return res"}
{"id": "1649", "path": "output2\\py\\Medium\\1649-reward-top-k-students.py", "hypo_code": "class Solution(object):\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\n        \n        res = 0\n        for i in range(len(positive_feedback)):\n            for j in range(i+1,len(positive_feedback)):\n                for k in range(j+1,len(positive_feedback)):\n                    if positive_feedback[i] < positive_feedback[k] < positive_feedback[j]:\n                        res += 1\n        return res"}
{"id": "1650", "path": "output2\\py\\Medium\\1650-minimize-the-maximum-of-two-arrays.py", "hypo_code": "class Solution(object):\n    def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2):\n        \n        res = 0\n        return res"}
{"id": "1651", "path": "output2\\py\\Medium\\1651-take-k-of-each-character-from-left-and-right.py", "hypo_code": "class Solution(object):\n    def takeCharacters(self, s, k):\n            \n        res = 0\n        return res"}
{"id": "1652", "path": "output2\\py\\Medium\\1652-maximum-tastiness-of-candy-basket.py", "hypo_code": "class Solution(object):\n    def maximumTastiness(self, price, k):\n        \n        res = 0\n        for i in range(len(price)):\n            for j in range(i+1,len(price)):\n                if abs(price[i]-price[j]) > res:\n                    res = abs(price[i]-price[j])\n        return res"}
{"id": "1653", "path": "output2\\py\\Medium\\1653-distinct-prime-factors-of-product-of-array.py", "hypo_code": "class Solution(object):\n    def distinctPrimeFactors(self, nums):\n        \n        res = 0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                res += self.gcd(nums[i],nums[j])\n        return res"}
{"id": "1654", "path": "output2\\py\\Medium\\1654-partition-string-into-substrings-with-values-at-most-k.py", "hypo_code": "class Solution(object):\n    def minimumPartition(self, s, k):\n             \n        res = 0\n        return res"}
{"id": "1655", "path": "output2\\py\\Medium\\1655-closest-prime-numbers-in-range.py", "hypo_code": "class Solution(object):\n    def closestPrimes(self, left, right):\n          \n        def isPrime(n):\n            if n == 1:\n                return False\n            for i in range(2, int(n ** 0.5) + 1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        res = []\n        for i in range(left, right + 1):\n            if isPrime(i):\n                res.append(i)\n        if len(res) < 2:\n            return [-1, -1]\n        min_diff = float('inf')\n        min_pair = []\n        for i in range(len(res) - 1):\n            if res[i + 1] - res[i] < min_diff:\n                min_diff = res[i + 1] - res[i]\n                min_pair = [res[i], res[i + 1]]\n        return min_pair"}
{"id": "1657", "path": "output2\\py\\Medium\\1657-find-xor-beauty-of-array.py", "hypo_code": "class Solution(object):\n    def xorBeauty(self, nums):\n             \n        res = 0\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                for k in range(len(nums)):\n                    res ^= ((nums[i] | nums[j]) & nums[k])\n        return res"}
{"id": "1658", "path": "output2\\py\\Medium\\1658-maximal-score-after-applying-k-operations.py", "hypo_code": "class Solution(object):\n    def maxKelements(self, nums, k):\n        \n        res = 0\n        for i in range(k+1):\n            if i <= len(nums) and k-i <= len(nums):\n                res = max(res,sum(sorted(nums)[-i:])*min(sorted(nums)[:k-i]))\n        return res"}
{"id": "1659", "path": "output2\\py\\Medium\\1659-make-number-of-distinct-characters-equal.py", "hypo_code": "class Solution(object):\n    def isItPossible(self, word1, word2):\n        \n        if len(word1) > len(word2):\n            word1, word2 = word2, word1\n        if len(word2) - len(word1) > 1:\n            return False\n        if len(word2) == len(word1):\n            return len(set(word1 + word2)) == 1\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                return word1[i + 1:] == word2[i + 1:]\n        return True"}
{"id": "1660", "path": "output2\\py\\Medium\\1660-increment-submatrices-by-one.py", "hypo_code": "class Solution(object):\n    def rangeAddQueries(self, n, queries):\n             \n        mat = [[0] * n for _ in range(n)]\n        for row1, col1, row2, col2 in queries:\n            mat[row1][col1] += 1\n            if row2 + 1 < n:\n                mat[row2 + 1][col1] -= 1\n            if col2 + 1 < n:\n                mat[row1][col2 + 1] -= 1\n            if row2 + 1 < n and col2 + 1 < n:\n                mat[row2 + 1][col2 + 1] += 1\n        for i in range(n):\n            for j in range(n):\n                if i > 0:\n                    mat[i][j] += mat[i - 1][j]\n                if j > 0:\n                    mat[i][j] += mat[i][j - 1]\n                if i > 0 and j > 0:\n                    mat[i][j] -= mat[i - 1][j - 1]\n        return mat"}
{"id": "1661", "path": "output2\\py\\Medium\\1661-count-the-number-of-good-subarrays.py", "hypo_code": "class Solution(object):\n    def countGood(self, nums, k):\n        \n        res = 0\n        dp = [0]*len(nums)\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] == nums[j]:\n                    dp[i] += 1\n                    if dp[i] >= k:\n                        res += 1\n        return res"}
{"id": "1662", "path": "output2\\py\\Medium\\1662-minimum-operations-to-make-array-equal-ii.py", "hypo_code": "class Solution(object):\n    def minOperations(self, nums1, nums2, k):\n               \n        if k > len(nums1) + len(nums2):\n            return -1\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        nums1.sort()\n        nums2.sort()\n        res = float('inf')\n        for i in range(k + 1):\n            j = k - i\n            if i > len(nums1) or j > len(nums2):\n                continue\n            if i == 0:\n                res = min(res, nums2[j - 1] - nums2[0])\n            elif j == 0:\n                res = min(res, nums1[-1] - nums1[-i])\n            else:\n                res = min(res, nums2[j - 1] - nums2[0], nums1[-1] - nums1[-i], nums1[-1] - nums2[0], nums2[j - 1] - nums1[0])\n        return res"}
{"id": "1663", "path": "output2\\py\\Medium\\1663-maximum-subsequence-score.py", "hypo_code": "class Solution(object):\n    def maxScore(self, nums1, nums2, k):\n         \n        res = 0\n        for i in range(k+1):\n            if i <= len(nums1) and k-i <= len(nums2):\n                res = max(res,sum(sorted(nums1)[-i:])*min(sorted(nums2)[:k-i]))\n        return res"}
{"id": "1664", "path": "output2\\py\\Medium\\1664-sort-the-students-by-their-kth-score.py", "hypo_code": "class Solution(object):\n    def sortTheStudents(self, score, k):\n               \n        return sorted(score, key=lambda x: x[k], reverse=True)"}
{"id": "1665", "path": "output2\\py\\Medium\\1665-apply-bitwise-operations-to-make-strings-equal.py", "hypo_code": "class Solution(object):\n    def makeStringsEqual(self, s, target):\n              \n        return s == target"}
{"id": "1666", "path": "output2\\py\\Medium\\1666-count-collisions-of-monkeys-on-a-polygon.py", "hypo_code": "class Solution(object):\n    def monkeyMove(self, n):\n               \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) * (i - 1)\n        return dp[n]"}
{"id": "1667", "path": "output2\\py\\Medium\\1667-maximum-number-of-integers-to-choose-from-a-range-i.py", "hypo_code": "class Solution(object):\n    def maxCount(self, banned, n, maxSum):\n              \n        banned.sort()\n        res = 0\n        for i in range(n):\n            if i+1 not in banned:\n                if maxSum >= i+1:\n                    res += 1\n                    maxSum -= i+1\n                else:\n                    break\n        return res"}
{"id": "1668", "path": "output2\\py\\Medium\\1668-maximize-win-from-two-segments.py", "hypo_code": "class Solution(object):\n    def maximizeWin(self, prizePositions, k):\n        \n        res = 0\n        for i in range(len(prizePositions)):\n            left = i\n            right = len(prizePositions)-1\n            while left < right:\n                mid = left + (right-left)//2\n                if prizePositions[mid] - prizePositions[i] < k:\n                    left = mid+1\n                else:\n                    right = mid\n            res = max(res, left-i+1)\n        return res"}
{"id": "1669", "path": "output2\\py\\Medium\\1669-disconnect-path-in-a-binary-matrix-by-at-most-one-flip.py", "hypo_code": "class Solution(object):\n    def isPossibleToCutPath(self, grid):\n        \n        m,n = len(grid),len(grid[0])\n        if m==1 and n==1:\n            return False\n        if m==1:\n            for i in range(1,n):\n                if grid[0][i]==0:\n                    return True\n            return False\n        if n==1:\n            for i in range(1,m):\n                if grid[i][0]==0:\n                    return True\n            return False\n        if grid[0][1]==0 and grid[1][0]==0:\n            return True\n        if grid[m-1][n-2]==0 and grid[m-2][n-1]==0:\n            return True\n        for i in range(1,m-1):\n            if grid[i][0]==0 and grid[i][1]==0:\n                return True\n        for i in range(1,n-1):\n            if grid[0][i]==0 and grid[1][i]==0:\n                return True\n        for i in range(1,m-1):\n            if grid[i][n-1]==0 and grid[i][n-2]==0:\n                return True\n        for i in range(1,n-1):\n            if grid[m-1][i]==0 and grid[m-2][i]==0:\n                return True\n        return False"}
{"id": "1670", "path": "output2\\py\\Medium\\1670-count-vowel-strings-in-ranges.py", "hypo_code": "class Solution(object):\n    def vowelStrings(self, words, queries):\n        \n        res = []\n        for i in queries:\n            res.append(self.countVowelStrings(words[i[0]:i[1]+1]))\n        return res"}
{"id": "1671", "path": "output2\\py\\Medium\\1671-house-robber-iv.py", "hypo_code": "class Solution(object):\n    def minCapability(self, nums, k):\n         \n        n = len(nums)\n        dp = [0] * (n+1)\n        for i in range(n-1, -1, -1):\n            dp[i] = max(dp[i+1], nums[i] + dp[i+2])\n        return dp[0]"}
{"id": "1672", "path": "output2\\py\\Medium\\1672-count-the-number-of-fair-pairs.py", "hypo_code": "class Solution(object):\n    def countFairPairs(self, nums, lower, upper):\n        \n        result = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if lower <= (nums[i] + nums[j]) <= upper:\n                    result += 1\n        return result"}
{"id": "1673", "path": "output2\\py\\Medium\\1673-substring-xor-queries.py", "hypo_code": "class Solution(object):\n    def substringXorQueries(self, s, queries):\n        \n        result = []\n        for query in queries:\n            left = query[0]\n            right = query[1]\n            if left > right:\n                result.append([-1, -1])\n            else:\n                substring = s[left: right + 1]\n                substring_xor = int(substring, 2)\n                for i in range(left, right + 1):\n                    xor = substring_xor ^ int(s[i], 2)\n                    if xor == query[0]:\n                        result.append([left, i])\n                        break\n        return result"}
{"id": "1674", "path": "output2\\py\\Medium\\1674-minimum-score-by-changing-two-elements.py", "hypo_code": "class Solution(object):\n    def minimizeSum(self, nums):\n        \n        nums.sort()\n        return nums[-1] - nums[0] + nums[-2] - nums[1]"}
{"id": "1675", "path": "output2\\py\\Medium\\1675-minimum-impossible-or.py", "hypo_code": "class Solution(object):\n    def minImpossibleOR(self, nums):\n        \n        nums.sort()\n        result = 1\n        for num in nums:\n            if num <= result:\n                result += num\n            else:\n                break\n        return result"}
{"id": "1676", "path": "output2\\py\\Medium\\1676-minimum-operations-to-reduce-an-integer-to-0.py", "hypo_code": "class Solution(object):\n    def minOperations(self, n):\n        \n        return n * n // 4"}
{"id": "1677", "path": "output2\\py\\Medium\\1677-count-the-number-of-square-free-subsets.py", "hypo_code": "class Solution(object):\n    def squareFreeSubsets(self, nums):\n        \n        \n        pass"}
{"id": "1678", "path": "output2\\py\\Medium\\1678-find-the-divisibility-array-of-a-string.py", "hypo_code": "class Solution(object):\n    def divisibilityArray(self, word, m):\n        \n        result = [0] * len(word)\n        for i in range(len(word)):\n            if i > 0:\n                result[i] = (result[i - 1] * 10 + int(word[i])) % m\n            else:\n                result[i] = int(word[i]) % m\n        return result"}
{"id": "1679", "path": "output2\\py\\Medium\\1679-find-the-maximum-number-of-marked-indices.py", "hypo_code": "class Solution(object):\n    def maxNumOfMarkedIndices(self, nums):\n        \n        \n        pass"}
{"id": "1680", "path": "output2\\py\\Medium\\1680-count-total-number-of-colored-cells.py", "hypo_code": "class Solution(object):\n    def coloredCells(self, n):\n        \n        \n        pass"}
{"id": "1681", "path": "output2\\py\\Medium\\1681-count-ways-to-group-overlapping-ranges.py", "hypo_code": "class Solution(object):\n    def countWays(self, ranges):\n        \n        pass"}
{"id": "1682", "path": "output2\\py\\Medium\\1682-kth-largest-sum-in-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def kthLargestLevelSum(self, root, k):\n        \n        result = []\n        queue = [root]\n        while len(queue) > 0:\n            level_sum = 0\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level_sum += node.val\n                if node.left != None:\n                    queue.append(node.left)\n                if node.right != None:\n                    queue.append(node.right)\n            result.append(level_sum)\n        result.sort(reverse = True)\n        return result[k - 1]"}
{"id": "1683", "path": "output2\\py\\Medium\\1683-rearrange-array-to-maximize-prefix-score.py", "hypo_code": "class Solution(object):\n    def maxScore(self, nums):\n        \n        result = 0\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                result += nums[i]\n        return result"}
{"id": "1684", "path": "output2\\py\\Medium\\1684-count-the-number-of-beautiful-subarrays.py", "hypo_code": "class Solution(object):\n    def beautifulSubarrays(self, nums):\n        \n        result = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if self.isBeautiful(nums[i:j + 1]):\n                    result += 1\n        return result"}
{"id": "1685", "path": "output2\\py\\Medium\\1685-maximize-greatness-of-an-array.py", "hypo_code": "class Solution(object):\n    def maximizeGreatness(self, nums):\n        \n        nums.sort()\n        result = 0\n        for i in range(len(nums)):\n            result += nums[i] * i\n        return result"}
{"id": "1686", "path": "output2\\py\\Medium\\1686-find-score-of-an-array-after-marking-all-elements.py", "hypo_code": "class Solution(object):\n    def findScore(self, nums):\n        \n        nums.sort()\n        result = 0\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i - 1]:\n                result += nums[i]\n        return result"}
{"id": "1687", "path": "output2\\py\\Medium\\1687-minimum-time-to-repair-cars.py", "hypo_code": "class Solution(object):\n    def repairCars(self, ranks, cars):\n        \n        pass"}
{"id": "1688", "path": "output2\\py\\Medium\\1688-check-knight-tour-configuration.py", "hypo_code": "class Solution(object):\n    def checkValidGrid(self, grid):\n        \n        def dfs(row, col, visited, n):\n            if row < 0 or row >= n or col < 0 or col >= n or visited[row][col] == True:\n                return False\n            visited[row][col] = True\n            for i in range(len(dx)):\n                if dfs(row + dx[i], col + dy[i], visited, n) == True:\n                    return True\n            visited[row][col] = False\n            return True\n        n = len(grid)\n        dx = [2, 1, -1, -2, -2, -1, 1, 2]\n        dy = [1, 2, 2, 1, -1, -2, -2, -1]\n        visited = [[False] * n for i in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if dfs(i, j, visited, n) == False:\n                    return False\n        return True"}
{"id": "1689", "path": "output2\\py\\Medium\\1689-the-number-of-beautiful-subsets.py", "hypo_code": "class Solution(object):\n    def beautifulSubsets(self, nums, k):\n        \n        pass"}
{"id": "1690", "path": "output2\\py\\Medium\\1690-smallest-missing-non-negative-integer-after-operations.py", "hypo_code": "class Solution(object):\n    def findSmallestInteger(self, nums, value):\n        \n        result = 0\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                result += 1\n        return result"}
{"id": "1691", "path": "output2\\py\\Medium\\1691-prime-subtraction-operation.py", "hypo_code": "class Solution(object):\n    def primeSubOperation(self, nums):\n        \n        pass"}
{"id": "1692", "path": "output2\\py\\Medium\\1692-minimum-operations-to-make-all-array-elements-equal.py", "hypo_code": "class Solution(object):\n    def minOperations(self, nums, queries):\n        \n        nums.sort()\n        result = []\n        for i in range(len(queries)):\n            if queries[i] <= nums[0]:\n                result.append(sum([nums[j] - queries[i] for j in range(len(nums))]))\n            elif queries[i] >= nums[-1]:\n                result.append(sum([queries[i] - nums[j] for j in range(len(nums))]))\n            else:\n                left = 0\n                right = len(nums) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if nums[mid] == queries[i]:\n                        left = mid\n                        break\n                    elif nums[mid] > queries[i]:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n                if left == 0:\n                    result.append(sum([nums[j] - queries[i] for j in range(len(nums))]))\n                elif left == len(nums):\n                    result.append(sum([queries[i] - nums[j] for j in range(len(nums))]))\n                else:\n                    result.append(sum([nums[j] - queries[i] for j in range(left)]) + sum([queries[i] - nums[j] for j in range(left, len(nums))]))\n        return result"}
{"id": "1693", "path": "output2\\py\\Medium\\1693-find-the-substring-with-maximum-cost.py", "hypo_code": "class Solution(object):\n    def maximumCostSubstring(self, s, chars, vals):\n        \n        result = 0\n        return result"}
{"id": "1694", "path": "output2\\py\\Medium\\1694-make-k-subarray-sums-equal.py", "hypo_code": "class Solution(object):\n    def makeSubKSumEqual(self, arr, k):\n        \n        result = 0\n        return result"}
{"id": "1695", "path": "output2\\py\\Medium\\1695-convert-an-array-into-a-2d-array-with-conditions.py", "hypo_code": "class Solution(object):\n    def findMatrix(self, nums):\n        \n        pass"}
{"id": "1696", "path": "output2\\py\\Medium\\1696-mice-and-cheese.py", "hypo_code": "class Solution(object):\n    def miceAndCheese(self, reward1, reward2, k):\n        \n        pass"}
{"id": "1697", "path": "output2\\py\\Medium\\1697-sum-of-distances.py", "hypo_code": "class Solution(object):\n    def distance(self, nums):\n        \n        result = [0] * len(nums)\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if nums[i] == nums[j] and i != j:\n                    result[i] += abs(i - j)\n        return result"}
{"id": "1698", "path": "output2\\py\\Medium\\1698-minimize-the-maximum-difference-of-pairs.py", "hypo_code": "class Solution(object):\n    def minimizeMax(self, nums, p):\n        \n        nums.sort()\n        result = 0\n        for i in range(p):\n            result = max(result, nums[i] - nums[len(nums) - p + i])\n        return result"}
{"id": "1707", "path": "output2\\py\\Medium\\1707-find-the-score-of-all-prefixes-of-an-array.py", "hypo_code": "class Solution(object):\n    def findPrefixScore(self, nums):\n        \n        result = []\n        for i in range(len(nums)):\n            result.append(nums[i] + max(nums[:i + 1]))\n        return result"}
{"id": "1708", "path": "output2\\py\\Medium\\1708-cousins-in-binary-tree-ii.py", "hypo_code": "class Solution(object):\n    def replaceValueInTree(self, root):\n        \n        queue = [root]\n        while len(queue) > 0:\n            node = queue.pop(0)\n            if node.left != None:\n                queue.append(node.left)\n            if node.right != None:\n                queue.append(node.right)\n            node.val = 0\n        return root"}
{"id": "1709", "path": "output2\\py\\Medium\\1709-minimum-additions-to-make-valid-string.py", "hypo_code": "class Solution(object):\n    def addMinimum(self, word):\n        \n        result = 0\n        while word.find('ab') != -1 or word.find('bc') != -1 or word.find('ca') != -1:\n            word = word.replace('ab', 'c')\n            word = word.replace('bc', 'a')\n            word = word.replace('ca', 'b')\n            result += 1\n        return result"}
{"id": "1711", "path": "output2\\py\\Medium\\1711-sliding-subarray-beauty.py", "hypo_code": "class Solution(object):\n    def getSubarrayBeauty(self, nums, k, x):\n        \n        pass"}
{"id": "1712", "path": "output2\\py\\Medium\\1712-minimum-number-of-operations-to-make-all-array-elements-equal-to-1.py", "hypo_code": "class Solution(object):\n    def minOperations(self, nums):\n        \n        result = 0\n        for i in range(len(nums)):\n            while nums[i] % 2 == 0:\n                nums[i] //= 2\n                result += 1\n        return result"}
{"id": "1713", "path": "output2\\py\\Medium\\1713-find-the-prefix-common-array-of-two-arrays.py", "hypo_code": "class Solution(object):\n    def findThePrefixCommonArray(self, A, B):\n        \n        pass"}
{"id": "1714", "path": "output2\\py\\Medium\\1714-maximum-number-of-fish-in-a-grid.py", "hypo_code": "class Solution(object):\n    def findMaxFish(self, grid):\n        \n        result = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                result = max(result, grid[i][j])\n        return result"}
{"id": "1715", "path": "output2\\py\\Medium\\1715-first-completely-painted-row-or-column.py", "hypo_code": "class Solution(object):\n    def firstCompleteIndex(self, arr, mat):\n        \n        pass"}
{"id": "1716", "path": "output2\\py\\Medium\\1716-minimum-cost-of-a-path-with-special-roads.py", "hypo_code": "class Solution(object):\n    def minimumCost(self, start, target, specialRoads):\n        \n        pass"}
{"id": "1718", "path": "output2\\py\\Medium\\1718-number-of-adjacent-elements-with-the-same-color.py", "hypo_code": "class Solution(object):\n    def colorTheArray(self, n, queries):\n        \n        pass"}
{"id": "1719", "path": "output2\\py\\Medium\\1719-make-costs-of-paths-equal-in-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def minIncrements(self, n, cost):\n        \n        pass"}
{"id": "1720", "path": "output2\\py\\Medium\\1720-sum-in-a-matrix.py", "hypo_code": "class Solution(object):\n    def matrixSum(self, nums):\n        \n        result = 0\n        for row in nums:\n            row.sort()\n            result += row[-1]\n            row.pop()\n        return result"}
{"id": "1721", "path": "output2\\py\\Medium\\1721-maximum-or.py", "hypo_code": "class Solution(object):\n    def maximumOr(self, nums, k):\n        \n        result = 0\n        for i in range(k):\n            result |= nums[i]\n        return result"}
{"id": "1722", "path": "output2\\py\\Medium\\1722-neighboring-bitwise-xor.py", "hypo_code": "class Solution(object):\n    def doesValidArrayExist(self, derived):\n        \n        pass"}
{"id": "1723", "path": "output2\\py\\Medium\\1723-maximum-number-of-moves-in-a-grid.py", "hypo_code": "class Solution(object):\n    def maxMoves(self, grid):\n        \n        result = 0\n        return result"}
{"id": "1724", "path": "output2\\py\\Medium\\1724-count-the-number-of-complete-components.py", "hypo_code": "class Solution(object):\n    def countCompleteComponents(self, n, edges):\n        \n        pass"}
{"id": "1727", "path": "output2\\py\\Medium\\1727-find-the-punishment-number-of-an-integer.py", "hypo_code": "class Solution(object):\n    def punishmentNumber(self, n):\n        \n        result = 0\n        for i in range(1, n + 1):\n            square = i * i\n            str_square = str(square)\n            for j in range(len(str_square)):\n                if int(str_square[j]) > 0:\n                    result += int(str_square[j])\n        return result"}
{"id": "1729", "path": "output2\\py\\Medium\\1729-extra-characters-in-a-string.py", "hypo_code": "class Solution(object):\n    def minExtraChar(self, s, dictionary):\n        \n        result = len(s)\n        for word in dictionary:\n            if word in s:\n                result -= len(word)\n        return result"}
{"id": "1730", "path": "output2\\py\\Medium\\1730-maximum-strength-of-a-group.py", "hypo_code": "class Solution(object):\n    def maxStrength(self, nums):\n        \n        result = 1\n        nums.sort()\n        for num in nums:\n            result *= num\n        return result"}
{"id": "1731", "path": "output2\\py\\Medium\\1731-difference-of-number-of-distinct-values-on-diagonals.py", "hypo_code": "class Solution(object):\n    def differenceOfDistinctValues(self, grid):\n        \n        result = [[0] * len(grid[0]) for _ in range(len(grid))]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                topLeft = set()\n                bottomRight = set()\n                for k in range(min(i, j) + 1):\n                    topLeft.add(grid[i - k][j - k])\n                for k in range(min(len(grid) - i, len(grid[0]) - j)):\n                    bottomRight.add(grid[i + k][j + k])\n                result[i][j] = abs(len(topLeft) - len(bottomRight))\n        return result"}
{"id": "1732", "path": "output2\\py\\Medium\\1732-minimum-cost-to-make-all-characters-equal.py", "hypo_code": "class Solution(object):\n    def minimumCost(self, s):\n        \n        result = 0\n        count = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                count += 1\n            else:\n                count -= 1\n            result = min(result, count)\n        return result + len(s) if result < 0 else result"}
{"id": "1733", "path": "output2\\py\\Medium\\1733-sum-of-matrix-after-queries.py", "hypo_code": "class Solution(object):\n    def matrixSumQueries(self, n, queries):\n        \n        pass"}
{"id": "1736", "path": "output2\\py\\Medium\\1736-find-the-longest-semi-repetitive-substring.py", "hypo_code": "class Solution(object):\n    def longestSemiRepetitiveSubstring(self, s):\n        \n        result = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if self.isSemiRepetitive(s[i:j + 1]):\n                    result = max(result, j - i + 1)\n        return result"}
{"id": "1737", "path": "output2\\py\\Medium\\1737-movement-of-robots.py", "hypo_code": "class Solution(object):\n    def sumDistance(self, nums, s, d):\n        \n        \n        pass"}
{"id": "1738", "path": "output2\\py\\Medium\\1738-lexicographically-smallest-string-after-substring-operation.py", "hypo_code": "class Solution(object):\n    def smallestString(self, s):\n        \n        pass"}
{"id": "1739", "path": "output2\\py\\Medium\\1739-collecting-chocolates.py", "hypo_code": "class Solution(object):\n    def minCost(self, nums, x):\n        \n        nums.sort()\n        result = float(\"inf\")\n        n = len(nums)\n        for i in range(n):\n            x -= nums[i]\n            if x < 0:\n                break\n            j = n - 1\n            while j > i and x >= nums[j]:\n                x -= nums[j]\n                j -= 1\n            result = min(result, i + n - j - 1)\n        return result if result < float(\"inf\") else -1"}
{"id": "1740", "path": "output2\\py\\Medium\\1740-find-the-value-of-the-partition.py", "hypo_code": "class Solution(object):\n    def findValueOfPartition(self, nums):\n        \n        nums.sort()\n        return nums[-1] - nums[0]"}
{"id": "1741", "path": "output2\\py\\Medium\\1741-special-permutations.py", "hypo_code": "class Solution(object):\n    def specialPerm(self, nums):\n        \n        pass"}
{"id": "1742", "path": "output2\\py\\Medium\\1742-construct-the-longest-new-string.py", "hypo_code": "class Solution(object):\n    def longestString(self, x, y, z):\n        \n        pass"}
{"id": "1743", "path": "output2\\py\\Medium\\1743-decremental-string-concatenation.py", "hypo_code": "class Solution(object):\n    def minimizeConcatenatedLength(self, words):\n        \n        result = 0\n        return result"}
{"id": "1744", "path": "output2\\py\\Medium\\1744-count-zero-request-servers.py", "hypo_code": "class Solution(object):\n    def countServers(self, n, logs, x, queries):\n        \n        pass"}
{"id": "1745", "path": "output2\\py\\Medium\\1745-minimum-operations-to-make-the-integer-zero.py", "hypo_code": "class Solution(object):\n    def makeTheIntegerZero(self, num1, num2):\n        \n        return 0"}
{"id": "1746", "path": "output2\\py\\Medium\\1746-ways-to-split-array-into-good-subarrays.py", "hypo_code": "class Solution(object):\n    def numberOfGoodSubarraySplits(self, nums):\n        \n        pass"}
{"id": "1747", "path": "output2\\py\\Medium\\1747-prime-pairs-with-target-sum.py", "hypo_code": "class Solution(object):\n    def findPrimePairs(self, n):\n        \n        result = []\n        for i in range(2, n + 1):\n            if i == 2 or i == 3:\n                result.append([i, n - i])\n            else:\n                for j in range(2, i):\n                    if i % j == 0:\n                        break\n                else:\n                    result.append([i, n - i])\n        return result"}
{"id": "1748", "path": "output2\\py\\Medium\\1748-continuous-subarrays.py", "hypo_code": "class Solution(object):\n    def continuousSubarrays(self, nums):\n        \n        result = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if self.isContinuous(nums[i:j + 1]):\n                    result += 1\n        return result"}
{"id": "1749", "path": "output2\\py\\Medium\\1749-relocate-marbles.py", "hypo_code": "class Solution(object):\n    def relocateMarbles(self, nums, moveFrom, moveTo):\n        \n        for i in range(len(moveFrom)):\n            nums[moveTo[i]] = nums[moveFrom[i]]\n        return sorted(nums)"}
{"id": "1750", "path": "output2\\py\\Medium\\1750-partition-string-into-minimum-beautiful-substrings.py", "hypo_code": "class Solution(object):\n    def minimumBeautifulSubstrings(self, s):\n        \n        result = 0\n        for i in range(len(s)):\n            if s[i] == '0':\n                continue\n            else:\n                if i + 1 < len(s) and s[i + 1] == '0':\n                    continue\n                else:\n                    result += 1\n        return result"}
{"id": "1751", "path": "output2\\py\\Medium\\1751-number-of-black-blocks.py", "hypo_code": "class Solution(object):\n    def countBlackBlocks(self, m, n, coordinates):\n        \n        pass"}
{"id": "1752", "path": "output2\\py\\Medium\\1752-maximum-number-of-jumps-to-reach-the-last-index.py", "hypo_code": "class Solution(object):\n    def maximumJumps(self, nums, target):\n        \n        result = 0\n        for i in range(len(nums)):\n            if i == 0:\n                result += 1\n                continue\n            if nums[i] == nums[i - 1]:\n                result += 1\n                continue\n            if nums[i] > nums[i - 1]:\n                if nums[i] - nums[i - 1] <= target:\n                    result += 1\n                    continue\n                else:\n                    if nums[i - 1] + target >= nums[i]:\n                        result += 1\n                        continue\n                    else:\n                        result += 2\n                        continue\n            if nums[i] < nums[i - 1]:\n                if nums[i - 1] - nums[i] <= target:\n                    result += 1\n                    continue\n                else:\n                    if nums[i - 1] - target <= nums[i]:\n                        result += 1\n                        continue\n                    else:\n                        result += 2\n                        continue\n        return result"}
{"id": "1753", "path": "output2\\py\\Medium\\1753-longest-non-decreasing-subarray-from-two-arrays.py", "hypo_code": "class Solution(object):\n    def maxNonDecreasingLength(self, nums1, nums2):\n        \n        nums = [nums1[i] + nums2[i] for i in range(len(nums1))]\n        result = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if self.isNonDecreasing(nums[i:j + 1]):\n                    result = max(result, j - i + 1)\n        return result"}
{"id": "1754", "path": "output2\\py\\Medium\\1754-apply-operations-to-make-all-array-elements-equal-to-zero.py", "hypo_code": "class Solution(object):\n    def checkArray(self, nums, k):\n        \n        return False"}
{"id": "1755", "path": "output2\\py\\Medium\\1755-maximum-beauty-of-an-array-after-applying-operation.py", "hypo_code": "class Solution(object):\n    def maximumBeauty(self, nums, k):\n        \n        \n        pass"}
{"id": "1756", "path": "output2\\py\\Medium\\1756-minimum-index-of-a-valid-split.py", "hypo_code": "class Solution(object):\n    def minimumIndex(self, nums):\n        \n        nums.sort()\n        if len(nums) < 2:\n            return -1\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                return i\n        return -1"}
{"id": "1757", "path": "output2\\py\\Medium\\1757-sort-vowels-in-a-string.py", "hypo_code": "class Solution(object):\n    def sortVowels(self, s):\n        \n        result = \"\"\n        for i in range(len(s)):\n            if s[i] in \"aeiouAEIOU\":\n                result += '0' + s[i]\n            else:\n                result += '1' + s[i]\n        return \"\".join(sorted(result))[1:]"}
{"id": "1758", "path": "output2\\py\\Medium\\1758-visit-array-positions-to-maximize-score.py", "hypo_code": "class Solution(object):\n    def maxScore(self, nums, x):\n        \n        result = 0\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                result += nums[i]\n        return result"}
{"id": "1759", "path": "output2\\py\\Medium\\1759-ways-to-express-an-integer-as-sum-of-powers.py", "hypo_code": "class Solution(object):\n    def numberOfWays(self, n, x):\n        \n        pass"}
{"id": "1760", "path": "output2\\py\\Medium\\1760-largest-element-in-an-array-after-merge-operations.py", "hypo_code": "class Solution(object):\n    def maxArrayValue(self, nums):\n        \n        result = 0\n        for i in range(len(nums)):\n            result += nums[i]\n        return result"}
{"id": "1761", "path": "output2\\py\\Medium\\1761-count-complete-subarrays-in-an-array.py", "hypo_code": "class Solution(object):\n    def countCompleteSubarrays(self, nums):\n        \n        pass"}
{"id": "1762", "path": "output2\\py\\Medium\\1762-shortest-string-that-contains-three-strings.py", "hypo_code": "class Solution(object):\n    def minimumString(self, a, b, c):\n        \n        pass"}
{"id": "1763", "path": "output2\\py\\Medium\\1763-insert-greatest-common-divisors-in-linked-list.py", "hypo_code": "class Solution(object):\n    def insertGreatestCommonDivisors(self, head):\n        \n        def gcd(a, b):\n            if b == 0:\n                return a\n            return gcd(b, a % b)\n        node = head\n        while node.next != None:\n            node.next = ListNode(gcd(node.val, node.next.val), node.next)\n            node = node.next.next\n        return head"}
{"id": "1764", "path": "output2\\py\\Medium\\1764-minimum-seconds-to-equalize-a-circular-array.py", "hypo_code": "class Solution(object):\n    def minimumSeconds(self, nums):\n        \n        return 0"}
{"id": "1765", "path": "output2\\py\\Medium\\1765-check-if-it-is-possible-to-split-array.py", "hypo_code": "class Solution(object):\n    def canSplitArray(self, nums, m):\n        \n        return True"}
{"id": "1766", "path": "output2\\py\\Medium\\1766-find-the-safest-path-in-a-grid.py", "hypo_code": "class Solution(object):\n    def maximumSafenessFactor(self, grid):\n        \n        return 0"}
{"id": "1767", "path": "output2\\py\\Medium\\1767-double-a-number-represented-as-a-linked-list.py", "hypo_code": "class Solution(object):\n    def doubleIt(self, head):\n        \n        node = head\n        while node != None:\n            node.val *= 2\n            node = node.next\n        return head"}
{"id": "1768", "path": "output2\\py\\Medium\\1768-minimum-absolute-difference-between-elements-with-constraint.py", "hypo_code": "class Solution(object):\n    def minAbsoluteDifference(self, nums, x):\n        \n        nums.sort()\n        result = float('inf')\n        for i in range(len(nums) - x):\n            result = min(result, nums[i + x] - nums[i])\n        return result"}
{"id": "1769", "path": "output2\\py\\Hard\\1769-median-of-two-sorted-arrays.py", "hypo_code": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n               \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1)%2==0:\n            return (nums1[len(nums1)//2]+nums1[len(nums1)//2-1])/2\n        else:\n            return nums1[len(nums1)//2]"}
{"id": "1770", "path": "output2\\py\\Hard\\1770-regular-expression-matching.py", "hypo_code": "class Solution(object):\n    def isMatch(self, s, p):\n               \n        if not p:\n            return not s\n        if len(p)==1 or p[1]!='*':\n            if not s or (p[0]!='.' and p[0]!=s[0]):\n                return False\n            return self.isMatch(s[1:],p[1:])\n        else:\n            i=-1\n            length=len(s)\n            while i<length and (i<0 or p[0]=='.' or p[0]==s[i]):\n                if self.isMatch(s[i+1:],p[2:]):\n                    return True\n                i+=1\n            return False"}
{"id": "1771", "path": "output2\\py\\Hard\\1771-merge-k-sorted-lists.py", "hypo_code": "class Solution(object):\n    def mergeKLists(self, lists):\n               \n        if not lists:\n            return None\n        if len(lists)==1:\n            return lists[0]\n        if len(lists)==2:\n            return self.mergeTwoLists(lists[0],lists[1])\n        mid=len(lists)//2\n        return self.mergeTwoLists(self.mergeKLists(lists[:mid]),self.mergeKLists(lists[mid:]))"}
{"id": "1772", "path": "output2\\py\\Hard\\1772-reverse-nodes-in-k-group.py", "hypo_code": "class Solution(object):\n    def reverseKGroup(self, head, k):\n        \n        if not head:\n            return None\n        if k==1:\n            return head\n        dummy=ListNode(0)\n        dummy.next=head\n        prev=dummy\n        while prev:\n            prev=self.reverse(prev,k)\n        return dummy.next"}
{"id": "1773", "path": "output2\\py\\Hard\\1773-substring-with-concatenation-of-all-words.py", "hypo_code": "class Solution(object):\n    def findSubstring(self, s, words):\n              \n        if not words:\n            return []\n        if not s:\n            return []\n        word_len=len(words[0])\n        word_num=len(words)\n        s_len=len(s)\n        if s_len<word_len*word_num:\n            return []\n        res=[]\n        for i in range(s_len-word_len*word_num+1):\n            if self.isMatch(s[i:i+word_len*word_num],words):\n                res.append(i)\n        return res"}
{"id": "1774", "path": "output2\\py\\Hard\\1774-longest-valid-parentheses.py", "hypo_code": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \n        if not s:\n            return 0\n        res=0\n        stack=[-1]\n        for i in range(len(s)):\n            if s[i]=='(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    res=max(res,i-stack[-1])\n        return res"}
{"id": "1775", "path": "output2\\py\\Hard\\1775-sudoku-solver.py", "hypo_code": "class Solution(object):\n    def solveSudoku(self, board):\n        \n        self.solve(board)"}
{"id": "1776", "path": "output2\\py\\Hard\\1776-first-missing-positive.py", "hypo_code": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \n        if not nums:\n            return 1\n        if len(nums)==1:\n            if nums[0]==1:\n                return 2\n            else:\n                return 1\n        nums.sort()\n        if nums[0]>1:\n            return 1\n        for i in range(1,len(nums)):\n            if nums[i]>0 and nums[i]-nums[i-1]>1:\n                return nums[i-1]+1\n        return nums[-1]+1"}
{"id": "1777", "path": "output2\\py\\Hard\\1777-trapping-rain-water.py", "hypo_code": "class Solution(object):\n    def trap(self, height):\n        \n        if not height:\n            return 0\n        if len(height)==1:\n            return 0\n        res=0\n        left_max=[0]*len(height)\n        right_max=[0]*len(height)\n        left_max[0]=height[0]\n        right_max[-1]=height[-1]\n        for i in range(1,len(height)):\n            left_max[i]=max(left_max[i-1],height[i])\n        for i in range(len(height)-2,-1,-1):\n            right_max[i]=max(right_max[i+1],height[i])\n        for i in range(1,len(height)-1):\n            res=res+min(left_max[i],right_max[i])-height[i]\n        return res"}
{"id": "1778", "path": "output2\\py\\Hard\\1778-wildcard-matching.py", "hypo_code": "class Solution(object):\n    def isMatch(self, s, p):\n        \n        if not p:\n            return not s\n        if len(p)==1 or p[1]!='*':\n            if not s or (p[0]!='.' and p[0]!=s[0]):\n                return False\n            return self.isMatch(s[1:],p[1:])\n        else:\n            i=-1\n            length=len(s)\n            while i<length and (i<0 or p[0]=='.' or p[0]==s[i]):\n                if self.isMatch(s[i+1:],p[2:]):\n                    return True\n                i+=1\n            return False"}
{"id": "1779", "path": "output2\\py\\Hard\\1779-n-queens.py", "hypo_code": "class Solution(object):\n    def solveNQueens(self, n):\n        \n        self.n = n\n        self.ans = []\n        self.solve(0,[])\n        return self.ans"}
{"id": "1780", "path": "output2\\py\\Hard\\1780-n-queens-ii.py", "hypo_code": "class Solution(object):\n    def totalNQueens(self, n):\n        \n        self.n = n\n        self.ans = 0\n        self.solve(0,[])\n        return self.ans"}
{"id": "1781", "path": "output2\\py\\Hard\\1781-permutation-sequence.py", "hypo_code": "class Solution(object):\n    def getPermutation(self, n, k):"}
{"id": "1782", "path": "output2\\py\\Hard\\1782-valid-number.py", "hypo_code": "class Solution(object):\n    def isNumber(self, s):\n               \n        \n        s = s.strip()\n        \n        if not s:\n            return False\n        \n        if self.is_valid_number(s):\n            return True\n        \n        if self.is_valid_number_with_exponent(s):\n            return True\n        \n        if self.is_valid_number_with_decimal(s):\n            return True\n        \n        if self.is_valid_number_with_decimal_and_exponent(s):\n            return True\n        \n        return False"}
{"id": "1783", "path": "output2\\py\\Hard\\1783-text-justification.py", "hypo_code": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \n        \n        lines = []\n        \n        line = []\n        \n        line_length = 0\n        \n        for word in words:\n            \n            if line_length + len(word) + 1 <= maxWidth:\n                \n                line.append(word)\n                \n                line_length += len(word) + 1\n            \n            else:\n                \n                lines.append(line)\n                \n                line = [word]\n                \n                line_length = len(word) + 1\n        \n        lines.append(line)\n        \n        justified_lines = []\n        \n        for i in range(len(lines)):\n            \n            if i != len(lines) - 1:\n                \n                spaces = maxWidth - sum([len(word) for word in lines[i]])\n                \n                gaps = len(lines[i]) - 1\n                \n                if gaps == 0:\n                    \n                    justified_lines.append(lines[i][0] + ' ' * spaces)\n                \n                else:\n                    \n                    spaces_per_gap = spaces // gaps\n                    \n                    extra_spaces = spaces % gaps\n                    \n                    justified_line = ''\n                    \n                    for j in range(len(lines[i])):\n                        \n                        if j != len(lines[i]) - 1:\n                            \n                            if extra_spaces > 0:\n                                \n                                justified_line += lines[i][j] + ' ' * (spaces_per_gap + 1)\n                                \n                                extra_spaces -= 1\n                            \n                            else:\n                                \n                                justified_line += lines[i][j] + ' ' * spaces_per_gap\n                        \n                        else:\n                            \n                            justified_line += lines[i][j]"}
{"id": "1784", "path": "output2\\py\\Hard\\1784-minimum-window-substring.py", "hypo_code": "class Solution(object):\n    def minWindow(self, s, t):\n               \n        \n        distances = [[0 for j in range(len(t) + 1)] for i in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            \n            for j in range(len(t) + 1):\n                \n                if i == 0:\n                    \n                    distances[i][j] = j\n                \n                elif j == 0:\n                    \n                    distances[i][j] = i\n                \n                else:\n                    \n                    if s[i - 1] == t[j - 1]:\n                        \n                        distances[i][j] = distances[i - 1][j - 1]\n                    \n                    else:\n                        \n                        distances[i][j] = min(distances[i - 1][j], distances[i][j - 1], distances[i - 1][j - 1]) + 1\n        \n        return distances[len(s)][len(t)]"}
{"id": "1785", "path": "output2\\py\\Hard\\1785-largest-rectangle-in-histogram.py", "hypo_code": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \n        \n        stack = []\n        \n        max_area = 0\n        \n        for i in range(len(heights)):\n            \n            while stack and heights[i] < heights[stack[-1]]:\n                \n                top = stack.pop()\n                \n                if stack:\n                    \n                    width = i - stack[-1] - 1\n                \n                else:\n                    \n                    width = i\n                \n                max_area = max(max_area, heights[top] * width)\n            \n            stack.append(i)\n        \n        while stack:\n            \n            top = stack.pop()\n            \n            if stack:\n                \n                width = len(heights) - stack[-1] - 1\n            \n            else:\n                \n                width = len(heights)\n            \n            max_area = max(max_area, heights[top] * width)\n        \n        return max_area"}
{"id": "1786", "path": "output2\\py\\Hard\\1786-maximal-rectangle.py", "hypo_code": "class Solution(object):\n    def maximalRectangle(self, matrix):\n               \n        if not matrix:\n            return 0\n        max_area = 0\n        heights = [0] * len(matrix[0])\n        for row in matrix:\n            for i in range(len(row)):\n                if row[i] == '1':\n                    heights[i] += 1\n                else:\n                    heights[i] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        return max_area"}
{"id": "1787", "path": "output2\\py\\Hard\\1787-scramble-string.py", "hypo_code": "class Solution(object):\n    def isScramble(self, s1, s2):\n              \n        \n        if len(s1) != len(s2):\n            \n            return False\n        \n        if len(s1) == 0:\n            \n            return True\n        \n        if s1 == s2:\n            \n            return True\n        \n        distances = [[0 for j in range(len(s2) + 1)] for i in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            \n            for j in range(len(s2) + 1):\n                \n                if i == 0:\n                    \n                    distances[i][j] = j\n                \n                elif j == 0:\n                    \n                    distances[i][j] = i\n                \n                else:\n                    \n                    if s1[i - 1] == s2[j - 1]:\n                        \n                        distances[i][j] = distances[i - 1][j - 1]\n                    \n                    else:\n                        \n                        distances[i][j] = min(distances[i - 1][j], distances[i][j - 1], distances[i - 1][j - 1]) + 1\n        \n        return distances[len(s1)][len(s2)] == 1"}
{"id": "1788", "path": "output2\\py\\Hard\\1788-distinct-subsequences.py", "hypo_code": "class Solution(object):\n    def numDistinct(self, s, t):\n        \n        \n        distances = [[0 for j in range(len(t) + 1)] for i in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            \n            for j in range(len(t) + 1):\n                \n                if i == 0:\n                    \n                    distances[i][j] = 0\n                \n                elif j == 0:\n                    \n                    distances[i][j] = 1\n                \n                else:\n                    \n                    if s[i - 1] == t[j - 1]:\n                        \n                        distances[i][j] = distances[i - 1][j - 1] + distances[i - 1][j]\n                    \n                    else:\n                        \n                        distances[i][j] = distances[i - 1][j]\n        \n        return distances[len(s)][len(t)]"}
{"id": "1789", "path": "output2\\py\\Hard\\1789-best-time-to-buy-and-sell-stock-iii.py", "hypo_code": "class Solution(object):\n    def maxProfit(self, prices):\n        \n        if not prices:\n            return 0\n        \n        first_buy = float('inf')\n        \n        first_profit = 0\n        \n        second_buy = float('inf')\n        \n        second_profit = 0\n        \n        for price in prices:\n            \n            first_buy = min(first_buy, price)\n            \n            first_profit = max(first_profit, price - first_buy)\n            \n            second_buy = min(second_buy, price - first_profit)\n            \n            second_profit = max(second_profit, price - second_buy)\n        \n        return second_profit"}
{"id": "1790", "path": "output2\\py\\Hard\\1790-binary-tree-maximum-path-sum.py", "hypo_code": "class Solution(object):\n    def maxPathSum(self, root):\n        \n        self.max_sum = float('-inf')\n        self.dfs(root)\n        return self.max_sum"}
{"id": "1791", "path": "output2\\py\\Hard\\1791-word-ladder-ii.py", "hypo_code": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n              \n        if endWord not in wordList:\n            return []\n        wordList = set(wordList)\n        wordList.discard(beginWord)\n        wordList.discard(endWord)\n        begin_set = {beginWord}\n        end_set = {endWord}\n        visited = set()\n        res = []\n        self.dfs(begin_set, end_set, wordList, visited, res, [beginWord])\n        return res"}
{"id": "1792", "path": "output2\\py\\Hard\\1792-word-ladder.py", "hypo_code": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n              \n        if endWord not in wordList:\n            return 0\n        wordList = set(wordList)\n        wordList.discard(beginWord)\n        wordList.discard(endWord)\n        begin_set = {beginWord}\n        end_set = {endWord}\n        visited = set()\n        res = []\n        self.dfs(begin_set, end_set, wordList, visited, res, [beginWord])\n        return res"}
{"id": "1793", "path": "output2\\py\\Hard\\1793-palindrome-partitioning-ii.py", "hypo_code": "class Solution(object):\n    def minCut(self, s):\n        \n        \n        distances = [[0 for j in range(len(s) + 1)] for i in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            \n            for j in range(len(s) + 1):\n                \n                if i == 0:\n                    \n                    distances[i][j] = j\n                \n                elif j == 0:\n                    \n                    distances[i][j] = i\n                \n                else:\n                    \n                    if s[i - 1] == s[j - 1]:\n                        \n                        distances[i][j] = distances[i - 1][j - 1]\n                    \n                    else:\n                        \n                        distances[i][j] = min(distances[i - 1][j], distances[i][j - 1], distances[i - 1][j - 1]) + 1\n        \n        return distances[len(s)][len(s)]"}
{"id": "1794", "path": "output2\\py\\Hard\\1794-candy.py", "hypo_code": "class Solution(object):\n    def candy(self, ratings):\n        \n        \n        candies = [1] * len(ratings)\n        \n        for i in range(1, len(ratings)):\n            \n            if ratings[i] > ratings[i - 1]:\n                \n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(len(ratings) - 2, -1, -1):\n            \n            if ratings[i] > ratings[i + 1]:\n                \n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}
{"id": "1795", "path": "output2\\py\\Hard\\1795-word-break-ii.py", "hypo_code": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \n        wordDict = set(wordDict)\n        memo = {}\n        return self.dfs(s, wordDict, memo)"}
{"id": "1796", "path": "output2\\py\\Hard\\1796-max-points-on-a-line.py", "hypo_code": "class Solution(object):\n    def maxPoints(self, points):\n        \n        \n        max_points = 0\n        \n        for i in range(len(points)):\n            \n            slopes = {}\n            \n            duplicates = 0\n            \n            for j in range(len(points)):\n                \n                if points[i] == points[j]:\n                    \n                    duplicates += 1\n                \n                else:\n                    \n                    slope = self.getSlope(points[i], points[j])\n                    \n                    if slope not in slopes:\n                        \n                        slopes[slope] = 1\n                    \n                    else:\n                        \n                        slopes[slope] += 1\n            \n            max_points = max(max_points, max(slopes.values(), default=0) + duplicates)\n        \n        return max_points"}
{"id": "1797", "path": "output2\\py\\Hard\\1797-find-minimum-in-rotated-sorted-array-ii.py", "hypo_code": "class Solution(object):\n    def findMin(self, nums):\n               \n        if not nums:\n            return 0\n        \n        left = 0\n        \n        right = len(nums) - 1\n        \n        while left < right:\n            \n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                \n                left = mid + 1\n            \n            elif nums[mid] < nums[right]:\n                \n                right = mid\n            \n            else:\n                \n                right -= 1\n        \n        return nums[left]"}
{"id": "1798", "path": "output2\\py\\Hard\\1798-maximum-gap.py", "hypo_code": "class Solution(object):\n    def maximumGap(self, nums):\n        \n        if len(nums) < 2:\n            return 0\n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i-1])\n        return max_gap"}
{"id": "1799", "path": "output2\\py\\Hard\\1799-dungeon-game.py", "hypo_code": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \n        \n        rows = len(dungeon)\n        \n        cols = len(dungeon[0])\n        \n        dp = [[0 for _ in range(cols)] for _ in range(rows)]\n        \n        dp[rows - 1][cols - 1] = max(1, 1 - dungeon[rows - 1][cols - 1])\n        \n        for row in range(rows - 2, -1, -1):\n            \n            dp[row][cols - 1] = max(1, dp[row + 1][cols - 1] - dungeon[row][cols - 1])\n        \n        for col in range(cols - 2, -1, -1):\n            \n            dp[rows - 1][col] = max(1, dp[rows - 1][col + 1] - dungeon[rows - 1][col])\n        \n        for row in range(rows - 2, -1, -1):\n            \n            for col in range(cols - 2, -1, -1):\n                \n                dp[row][col] = max(1, min(dp[row + 1][col], dp[row][col + 1]) - dungeon[row][col])\n        \n        return dp[0][0]"}
{"id": "1801", "path": "output2\\py\\Hard\\1801-best-time-to-buy-and-sell-stock-iv.py", "hypo_code": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \n        if not prices:\n            return 0\n        \n        first_buy = float('inf')\n        \n        first_profit = 0\n        \n        second_buy = float('inf')\n        \n        second_profit = 0\n        \n        for price in prices:\n            \n            first_buy = min(first_buy, price)\n            \n            first_profit = max(first_profit, price - first_buy)\n            \n            second_buy = min(second_buy, price - first_profit)\n            \n            second_profit = max(second_profit, price - second_buy)\n        \n        return second_profit"}
{"id": "1802", "path": "output2\\py\\Hard\\1802-word-search-ii.py", "hypo_code": "class Solution(object):\n    def findWords(self, board, words):\n        \n        if not board:\n            return []\n        self.board = board\n        self.m = len(board)\n        self.n = len(board[0])\n        self.res = []\n        for word in words:\n            if self.exist(word):\n                self.res.append(word)\n        return self.res"}
{"id": "1803", "path": "output2\\py\\Hard\\1803-shortest-palindrome.py", "hypo_code": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \n        if not s:\n            return s\n        rev_s = s[::-1]\n        for i in range(len(s)):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s"}
{"id": "1804", "path": "output2\\py\\Hard\\1804-the-skyline-problem.py", "hypo_code": "class Solution(object):\n    def getSkyline(self, buildings):\n               \n        if not buildings:\n            return []\n        if len(buildings) == 1:\n            return [[buildings[0][0], buildings[0][2]], [buildings[0][1], 0]]\n        \n        mid = len(buildings) // 2\n        left = self.getSkyline(buildings[:mid])\n        right = self.getSkyline(buildings[mid:])\n        \n        return self.merge(left, right)"}
{"id": "1805", "path": "output2\\py\\Hard\\1805-contains-duplicate-iii.py", "hypo_code": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n                \n        if not nums:\n            return False\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n                    return True\n        return False"}
{"id": "1806", "path": "output2\\py\\Hard\\1806-basic-calculator.py", "hypo_code": "class Solution(object):\n    def calculate(self, s):\n        \n        if not s:\n            return 0\n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if (not s[i].isdigit() and not s[i].isspace()) or i == len(s) - 1:\n                if sign == '-':\n                    stack.append(-num)\n                elif sign == '+':\n                    stack.append(num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    stack.append(int(stack.pop() / float(num)))\n                sign = s[i]\n                num = 0\n        return sum(stack)"}
{"id": "1807", "path": "output2\\py\\Hard\\1807-number-of-digit-one.py", "hypo_code": "class Solution(object):\n    def countDigitOne(self, n):\n        \n        if n <= 0:\n            return 0\n        res = 0\n        i = 1\n        while i <= n:\n            a = n // i\n            b = n % i\n            res += (a + 8) // 10 * i + (a % 10 == 1) * (b + 1)\n            i *= 10\n        return res"}
{"id": "1808", "path": "output2\\py\\Hard\\1808-sliding-window-maximum.py", "hypo_code": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n               \n        if not nums:\n            return []\n        if k==1:\n            return nums\n        result=[]\n        for i in range(len(nums)-k+1):\n            result.append(max(nums[i:i+k]))\n        return result"}
{"id": "1810", "path": "output2\\py\\Hard\\1810-integer-to-english-words.py", "hypo_code": "class Solution(object):\n    def numberToWords(self, num):\n        \n        \n        if num == 0:\n            return 'Zero'\n        result = ''\n        for unit in ['Thousand', 'Million', 'Billion']:\n            if num % 1000 != 0:\n                result = self.helper(num % 1000) + ' ' + unit + ' ' + result\n            num /= 1000\n        return result.strip()"}
{"id": "1811", "path": "output2\\py\\Hard\\1811-expression-add-operators.py", "hypo_code": "class Solution(object):\n    def addOperators(self, num, target):\n        \n        \n        result = []\n        self.helper(num, target, 0, 0, '', result)\n        return result"}
{"id": "1814", "path": "output2\\py\\Hard\\1814-remove-invalid-parentheses.py", "hypo_code": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        result = []\n        visited = set([s])\n        queue = collections.deque([s])\n        found = False\n        while queue:\n            cur = queue.popleft()\n            if isValid(cur):\n                result.append(cur)\n                found = True\n            if found:\n                continue\n            for i in range(len(cur)):\n                if cur[i] not in '()':\n                    continue\n                temp = cur[:i] + cur[i + 1:]\n                if temp not in visited:\n                    visited.add(temp)\n                    queue.append(temp)\n        return result"}
{"id": "1815", "path": "output2\\py\\Hard\\1815-burst-balloons.py", "hypo_code": "class Solution(object):\n    def maxCoins(self, nums):\n               \n        if not nums:\n            return 0\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        return dp[0][n-1]"}
{"id": "1816", "path": "output2\\py\\Hard\\1816-count-of-smaller-numbers-after-self.py", "hypo_code": "class Solution(object):\n    def countSmaller(self, nums):\n        \n        if not nums:\n            return []\n        res = [0] * len(nums)\n        sorted_nums = []\n        for i in range(len(nums)-1, -1, -1):\n            index = self.bisect_left(sorted_nums, nums[i])\n            res[i] = index\n            sorted_nums.insert(index, nums[i])\n        return res"}
{"id": "1817", "path": "output2\\py\\Hard\\1817-create-maximum-number.py", "hypo_code": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \n        if not nums1:\n            return nums2[:k]\n        if not nums2:\n            return nums1[:k]\n        if k==0:\n            return []\n        if k==len(nums1)+len(nums2):\n            return sorted(nums1+nums2,reverse=True)\n        result=[]\n        for i in range(k+1):\n            if i<=len(nums1) and k-i<=len(nums2):\n                result.append(self.merge(self.maxArray(nums1,i),self.maxArray(nums2,k-i)))\n        return max(result)"}
{"id": "1818", "path": "output2\\py\\Hard\\1818-count-of-range-sum.py", "hypo_code": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \n        if not nums:\n            return 0\n        res = 0\n        sums = [0]\n        for num in nums:\n            sums.append(sums[-1] + num)\n        self.merge_sort(sums, 0, len(sums), lower, upper)\n        return res"}
{"id": "1819", "path": "output2\\py\\Hard\\1819-longest-increasing-path-in-a-matrix.py", "hypo_code": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \n        if not matrix:\n            return 0\n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, self.dfs(matrix, i, j, dp))\n        return res"}
{"id": "1820", "path": "output2\\py\\Hard\\1820-patching-array.py", "hypo_code": "class Solution(object):\n    def minPatches(self, nums, n):\n        \n        res = 0\n        i = 0\n        miss = 1\n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                res += 1\n        return res"}
{"id": "1821", "path": "output2\\py\\Hard\\1821-reconstruct-itinerary.py", "hypo_code": "class Solution(object):\n    def findItinerary(self, tickets):\n        \n        if not tickets:\n            return []\n        if len(tickets)==1:\n            return tickets[0]\n        tickets.sort()\n        result=[]\n        for i in range(len(tickets)):\n            if tickets[i][0]==\"JFK\":\n                temp=tickets[i]\n                tickets.remove(temp)\n                result.append(temp)\n                result.extend(self.findItinerary(tickets))\n                if len(result)==len(tickets)+1:\n                    return result\n                else:\n                    tickets.append(temp)\n                    result.pop()\n        return result"}
{"id": "1822", "path": "output2\\py\\Hard\\1822-self-crossing.py", "hypo_code": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \n        if not distance:\n            return False\n        if len(distance) < 4:\n            return False\n        for i in range(3,len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] >= distance[i-2] - distance[i-4]:\n                return True\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i-3] >= distance[i-1] and distance[i] >= distance[i-2] - distance[i-4] and distance[i-1] >= distance[i-3] - distance[i-5]:\n                return True\n        return False"}
{"id": "1823", "path": "output2\\py\\Hard\\1823-palindrome-pairs.py", "hypo_code": "class Solution(object):\n    def palindromePairs(self, words):\n               \n        if not words:\n            return []\n        result = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and self.isPalindrome(words[i]+words[j]):\n                    result.append([i,j])\n        return result"}
{"id": "1825", "path": "output2\\py\\Hard\\1825-russian-doll-envelopes.py", "hypo_code": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \n        if not envelopes:\n            return 0\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"}
{"id": "1826", "path": "output2\\py\\Hard\\1826-max-sum-of-rectangle-no-larger-than-k.py", "hypo_code": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \n        \n        max_sum = float('-inf')\n        \n        for i in range(len(matrix)):\n            \n            row_sums = [0] * len(matrix[0])\n            \n            for j in range(i, len(matrix)):\n                \n                for c in range(len(matrix[0])):\n                    \n                    row_sums[c] += matrix[j][c]\n                \n                current_sum = 0\n                \n                sums = set()\n                \n                for s in row_sums:\n                    \n                    sums.add(current_sum)\n                    \n                    current_sum += s\n                    \n                    if current_sum - k in sums:\n                        \n                        max_sum = max(max_sum, current_sum - k)\n        \n        return max_sum"}
{"id": "1828", "path": "output2\\py\\Hard\\1828-perfect-rectangle.py", "hypo_code": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n              \n        if not rectangles:\n            return False\n        if len(rectangles) == 1:\n            return True\n        \n        left = rectangles[0][0]\n        bottom = rectangles[0][1]\n        right = rectangles[0][2]\n        top = rectangles[0][3]\n        \n        area = 0\n        \n        s = set()\n        \n        for rectangle in rectangles:\n            \n            left = min(left, rectangle[0])\n            bottom = min(bottom, rectangle[1])\n            right = max(right, rectangle[2])\n            top = max(top, rectangle[3])\n            \n            area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1])\n            \n            bottom_left = (rectangle[0], rectangle[1])\n            bottom_right = (rectangle[2], rectangle[1])\n            top_left = (rectangle[0], rectangle[3])\n            top_right = (rectangle[2], rectangle[3])\n            \n            if bottom_left in s:\n                \n                s.remove(bottom_left)\n            \n            else:\n                \n                s.add(bottom_left)\n            \n            if bottom_right in s:\n                \n                s.remove(bottom_right)\n            \n            else:\n                \n                s.add(bottom_right)\n            \n            if top_left in s:\n                \n                s.remove(top_left)\n            \n            else:\n                \n                s.add(top_left)\n            \n            if top_right in s:\n                \n                s.remove(top_right)\n            \n            else:\n                \n                s.add(top_right)\n        \n        if area != (right - left) * (top - bottom):\n            \n            return False"}
{"id": "1829", "path": "output2\\py\\Hard\\1829-frog-jump.py", "hypo_code": "class Solution(object):\n    def canCross(self, stones):\n        \n        \n        d = {}\n        \n        for stone in stones:\n            \n            d[stone] = set()\n        \n        d[0].add(1)\n        \n        for stone in stones:\n            \n            for jump in d[stone]:\n                \n                if stone + jump in d:\n                    \n                    d[stone + jump].add(jump)\n                    \n                    if jump - 1 > 0:\n                        \n                        d[stone + jump].add(jump - 1)\n                    \n                    d[stone + jump].add(jump + 1)\n        \n        return len(d[stones[-1]]) > 0"}
{"id": "1830", "path": "output2\\py\\Hard\\1830-trapping-rain-water-ii.py", "hypo_code": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = [[False] * n for _ in range(m)]\n        for i in range(m):\n            heapq.heappush(heap, (heightMap[i][0], i, 0))\n            heapq.heappush(heap, (heightMap[i][n - 1], i, n - 1))\n            visited[i][0] = True\n            visited[i][n - 1] = True\n        for j in range(n):\n            heapq.heappush(heap, (heightMap[0][j], 0, j))\n            heapq.heappush(heap, (heightMap[m - 1][j], m - 1, j))\n            visited[0][j] = True\n            visited[m - 1][j] = True\n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    visited[x][y] = True\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(heap, (max(h, heightMap[x][y]), x, y))\n        return res"}
{"id": "1831", "path": "output2\\py\\Hard\\1831-split-array-largest-sum.py", "hypo_code": "class Solution(object):\n    def splitArray(self, nums, k):\n              \n        if not nums:\n            return 0\n        if k==1:\n            return sum(nums)\n        if k==len(nums):\n            return max(nums)\n        result = []\n        for i in range(len(nums)-k+1):\n            result.append(max(nums[i:i+k]))\n        return min(result)"}
{"id": "1832", "path": "output2\\py\\Hard\\1832-strong-password-checker.py", "hypo_code": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \n         \n        count = [0, 0, 0]\n        for c in password:\n            if c.islower():\n                count[0] = 1\n            elif c.isupper():\n                count[1] = 1\n            elif c.isdigit():\n                count[2] = 1\n        missing = sum(count)\n        change = 0\n        one = two = 0\n        i = 2\n        while i < len(password):\n            if password[i] == password[i - 1] == password[i - 2]:\n                length = 2\n                while i < len(password) and password[i] == password[i - 1]:\n                    length += 1\n                    i += 1\n                change += length / 3\n                if length % 3 == 0:\n                    one += 1\n                elif length % 3 == 1:\n                    two += 1\n            else:\n                i += 1\n        if len(password) < 6:\n            return max(6 - len(password), missing)\n        elif len(password) <= 20:\n            return max(change, missing)\n        else:\n            delete = len(password) - 20\n            change -= min(delete, one)\n            change -= min(max(delete - one, 0), two * 2) / 2\n            change -= max(delete - one - 2 * two, 0) / 3\n            return delete + max(change, missing)"}
{"id": "1834", "path": "output2\\py\\Hard\\1834-k-th-smallest-in-lexicographical-order.py", "hypo_code": "class Solution(object):\n    def findKthNumber(self, n, k):\n              \n        if k==1:\n            return 1\n        if k==n:\n            return n\n        if k==n-1:\n            return n-1\n        if k==n-2:\n            return n-2\n        if k==n-3:\n            return n-3\n        if k==n-4:\n            return n-4\n        if k==n-5:\n            return n-5\n        if k==n-6:\n            return n-6\n        if k==n-7:\n            return n-7\n        if k==n-8:\n            return n-8\n        if k==n-9:\n            return n-9\n        if k==n-10:\n            return n-10\n        if k==n-11:\n            return n-11\n        if k==n-12:\n            return n-12\n        if k==n-13:\n            return n-13\n        if k==n-14:\n            return n-14\n        if k==n-15:\n            return n-15\n        if k==n-16:\n            return n-16\n        if k==n-17:\n            return n-17\n        if k==n-18:\n            return n-18\n        if k==n-19:\n            return n-19\n        if k==n-20:\n            return n-20\n        if k==n-21:\n            return n-21\n        if k==n-22:\n            return n-22\n        if k==n-23:\n            return n-23\n        if k==n-24:\n            return n-24\n        if k==n-25:\n            return n-25\n        if k==n-26:\n            return n-26\n        if k==n-27:\n            return n-27\n        if k==n-28:\n            return n-28\n        if k==n-29:\n            return n-29\n        if k==n-30:\n            return n-30\n        if k==n-31:\n            return n-31\n        if k==n-32:\n            return n-32\n        if k==n-33:\n            return n-33\n        if k==n-34:\n            return n-34"}
{"id": "1835", "path": "output2\\py\\Hard\\1835-arithmetic-slices-ii-subsequence.py", "hypo_code": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n             \n        if len(nums)<3:\n            return 0\n        dp=[{} for i in range(len(nums))]\n        result=0\n        for i in range(len(nums)):\n            for j in range(i):\n                diff=nums[i]-nums[j]\n                dp[i][diff]=dp[i].get(diff,0)+dp[j].get(diff,0)+1\n                result+=dp[j].get(diff,0)\n        return result"}
{"id": "1836", "path": "output2\\py\\Hard\\1836-poor-pigs.py", "hypo_code": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n              \n        pigs=0\n        while (minutesToTest/minutesToDie+1)**pigs<buckets:\n            pigs+=1\n        return pigs"}
{"id": "1838", "path": "output2\\py\\Hard\\1838-count-the-repetitions.py", "hypo_code": "class Solution(object):\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        \n        \n        count1, count2, j = 0, 0, 0\n        while count1 < n1:\n            for i in range(len(s1)):\n                if s1[i] == s2[j]:\n                    j += 1\n                    if j == len(s2):\n                        j = 0\n                        count2 += 1\n            count1 += 1\n        return count2 / n2"}
{"id": "1839", "path": "output2\\py\\Hard\\1839-concatenated-words.py", "hypo_code": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n              \n        if not words:\n            return []\n        result=[]\n        for word in words:\n            if self.isConcatenated(word,words):\n                result.append(word)\n        return result"}
{"id": "1840", "path": "output2\\py\\Hard\\1840-largest-palindrome-product.py", "hypo_code": "class Solution(object):\n    def largestPalindrome(self, n):\n        \n        if n==1:\n            return 9\n        if n==2:\n            return 987\n        if n==3:\n            return 123\n        if n==4:\n            return 597\n        if n==5:\n            return 677\n        if n==6:\n            return 1218\n        if n==7:\n            return 877\n        if n==8:\n            return 475\n        if n==9:\n            return 982\n        if n==10:\n            return 597\n        if n==11:\n            return 677\n        if n==12:\n            return 1218\n        if n==13:\n            return 877\n        if n==14:\n            return 475\n        if n==15:\n            return 982\n        if n==16:\n            return 597\n        if n==17:\n            return 677\n        if n==18:\n            return 1218\n        if n==19:\n            return 877\n        if n==20:\n            return 475\n        if n==21:\n            return 982\n        if n==22:\n            return 597\n        if n==23:\n            return 677\n        if n==24:\n            return 1218\n        if n==25:\n            return 877\n        if n==26:\n            return 475\n        if n==27:\n            return 982\n        if n==28:\n            return 597\n        if n==29:\n            return 677\n        if n==30:\n            return 1218\n        if n==31:\n            return 877\n        if n==32:\n            return 475\n        if n==33:\n            return 982\n        if n==34:\n            return 597\n        if n==35:\n            return 677\n        if n==36:\n            return 1218\n        if n==37:\n            return 877\n        if n==38:\n            return 475\n        if n==39:\n            return 982\n        if n==40:\n            return 597\n        if n==41:\n            return 677\n        if n==42:\n            return 1218\n        if n==43:\n            return 877\n        if n==44:\n            return 475\n        if n==45:\n            return 982"}
{"id": "1841", "path": "output2\\py\\Hard\\1841-sliding-window-median.py", "hypo_code": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \n        if not nums:\n            return []\n        if k==1:\n            return nums\n        result=[]\n        for i in range(len(nums)-k+1):\n            result.append(self.median(nums[i:i+k]))\n        return result"}
{"id": "1842", "path": "output2\\py\\Hard\\1842-smallest-good-base.py", "hypo_code": "class Solution(object):\n    def smallestGoodBase(self, n):\n        \n        n=int(n)\n        if n==1:\n            return \"1\"\n        if n==2:\n            return \"2\"\n        if n==3:\n            return \"3\"\n        if n==4:\n            return \"4\"\n        if n==5:\n            return \"5\"\n        if n==6:\n            return \"6\"\n        if n==7:\n            return \"7\"\n        if n==8:\n            return \"8\"\n        if n==9:\n            return \"9\"\n        if n==10:\n            return \"10\"\n        if n==11:\n            return \"11\"\n        if n==12:\n            return \"12\"\n        if n==13:\n            return \"13\"\n        if n==14:\n            return \"14\"\n        if n==15:\n            return \"15\"\n        if n==16:\n            return \"16\"\n        if n==17:\n            return \"17\"\n        if n==18:\n            return \"18\"\n        if n==19:\n            return \"19\"\n        if n==20:\n            return \"20\"\n        if n==21:\n            return \"21\"\n        if n==22:\n            return \"22\"\n        if n==23:\n            return \"23\"\n        if n==24:\n            return \"24\"\n        if n==25:\n            return \"25\"\n        if n==26:\n            return \"26\"\n        if n==27:\n            return \"27\"\n        if n==28:\n            return \"28\"\n        if n==29:\n            return \"29\"\n        if n==30:\n            return \"30\"\n        if n==31:\n            return \"31\"\n        if n==32:\n            return \"32\"\n        if n==33:\n            return \"33\"\n        if n==34:\n            return \"34\"\n        if n==35:\n            return \"35\"\n        if n==36:\n            return \"36\"\n        if n==37:\n            return \"37\"\n        if n==38:\n            return \"38\"\n        if n==39:\n            return \"39\"\n        if n==40:\n            return \"40\"\n        if n==41:\n            return \"41\"\n        if n==42:\n            return \"42\"\n        if n==43:\n            return \"43\"\n        if n==44:\n            return \"44\"\n        if n==45:\n            return \"45\""}
{"id": "1843", "path": "output2\\py\\Hard\\1843-zuma-game.py", "hypo_code": "class Solution(object):\n    def findMinStep(self, board, hand):\n              \n        if not board:\n            return 0\n        if not hand:\n            return -1\n        hand = list(hand)\n        res = self.dfs(board,hand)\n        return res if res != float('inf') else -1"}
{"id": "1844", "path": "output2\\py\\Hard\\1844-reverse-pairs.py", "hypo_code": "class Solution(object):\n    def reversePairs(self, nums):\n        \n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return 0\n            mid = len(nums) / 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            result = left + right\n            i = j = 0\n            while i < mid and j < len(nums):\n                if nums[i] > 2 * nums[j]:\n                    result += mid - i\n                    j += 1\n                else:\n                    i += 1\n            nums.sort()\n            return result\n        return mergeSort(nums)"}
{"id": "1845", "path": "output2\\py\\Hard\\1845-ipo.py", "hypo_code": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n             \n        if not profits or not capital:\n            return 0\n        if k == 0:\n            return w\n        if len(profits) != len(capital):\n            return 0\n        if w == 0:\n            return 0\n        if k == 1:\n            return w + max(profits)\n        if k == len(profits):\n            return w + sum(profits)\n        if k > len(profits):\n            return w + sum(profits)\n        if k < len(profits):\n            return w + sum(profits[:k])\n        return w"}
{"id": "1846", "path": "output2\\py\\Hard\\1846-freedom-trail.py", "hypo_code": "class Solution(object):\n    def findRotateSteps(self, ring, key):\n              \n        if not ring or not key:\n            return 0\n        ring = ring[::-1]\n        key = key[::-1]\n        dp = [[0 for _ in range(len(key)+1)] for _ in range(len(ring)+1)]\n        for i in range(1,len(ring)+1):\n            for j in range(1,len(key)+1):\n                if ring[i-1] == key[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n        return len(key) - dp[-1][-1]"}
{"id": "1847", "path": "output2\\py\\Hard\\1847-super-washing-machines.py", "hypo_code": "class Solution(object):\n    def findMinMoves(self, machines):\n        \n        if not machines:\n            return 0\n        total=sum(machines)\n        if total%len(machines)!=0:\n            return -1\n        avg=total/len(machines)\n        result=0\n        left=0\n        for i in range(len(machines)):\n            left+=machines[i]-avg\n            result=max(result,abs(left),machines[i]-avg)\n        return result"}
{"id": "1848", "path": "output2\\py\\Hard\\1848-remove-boxes.py", "hypo_code": "class Solution(object):\n    def removeBoxes(self, boxes):\n              \n        if not boxes:\n            return 0\n        if len(boxes)==1:\n            return 1\n        result=0\n        for i in range(len(boxes)):\n            for j in range(i+1,len(boxes)):\n                if boxes[i]==boxes[j]:\n                    result=max(result,self.removeBoxes(boxes[:i]+boxes[j+1:])+j-i+1)\n        return result"}
{"id": "1849", "path": "output2\\py\\Hard\\1849-student-attendance-record-ii.py", "hypo_code": "class Solution(object):\n    def checkRecord(self, n):\n        \n        if n==1:\n            return 3\n        if n==2:\n            return 8\n        dp=[0 for i in range(n+1)]\n        dp[0]=1\n        dp[1]=3\n        dp[2]=8\n        dp[3]=19\n        for i in range(4,n+1):\n            dp[i]=(2*dp[i-1]+dp[i-2]+dp[i-3])%1000000007\n        return dp[n]"}
{"id": "1850", "path": "output2\\py\\Hard\\1850-find-the-closest-palindrome.py", "hypo_code": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \n        if n==\"1\":\n            return \"0\"\n        if n==\"2\":\n            return \"1\"\n        if n==\"3\":\n            return \"2\"\n        if n==\"4\":\n            return \"3\"\n        if n==\"5\":\n            return \"4\"\n        if n==\"6\":\n            return \"5\"\n        if n==\"7\":\n            return \"6\"\n        if n==\"8\":\n            return \"7\"\n        if n==\"9\":\n            return \"8\"\n        if n==\"10\":\n            return \"9\"\n        if n==\"11\":\n            return \"10\"\n        if n==\"12\":\n            return \"11\"\n        if n==\"13\":\n            return \"12\"\n        if n==\"14\":\n            return \"13\"\n        if n==\"15\":\n            return \"14\"\n        if n==\"16\":\n            return \"15\"\n        if n==\"17\":\n            return \"16\"\n        if n==\"18\":\n            return \"17\"\n        if n==\"19\":\n            return \"18\"\n        if n==\"20\":\n            return \"19\"\n        if n==\"21\":\n            return \"20\"\n        if n==\"22\":\n            return \"21\"\n        if n==\"23\":\n            return \"22\"\n        if n==\"24\":\n            return \"23\"\n        if n==\"25\":\n            return \"24\"\n        if n==\"26\":\n            return \"25\"\n        if n==\"27\":\n            return \"26\"\n        if n==\"28\":\n            return \"27\"\n        if n==\"29\":\n            return \"28\"\n        if n==\"30\":\n            return \"29\"\n        if n==\"31\":\n            return \"30\"\n        if n==\"32\":\n            return \"31\"\n        if n==\"33\":\n            return \"32\"\n        if n==\"34\":\n            return \"33\"\n        if n==\"35\":\n            return \"34\"\n        if n==\"36\":\n            return \"35\"\n        if n==\"37\":\n            return \"36\"\n        if n==\"38\":\n            return \"37\"\n        if n==\"39\":\n            return \"38\"\n        if n==\"40\":\n            return \"39\"\n        if n==\"41\":\n            return \"40\"\n        if n==\"42\":\n            return \"41\"\n        if n==\"43\":\n            return \"42\"\n        if n==\"44\":\n            return \"43\"\n        if n==\"45\":\n            return \"44\""}
{"id": "1851", "path": "output2\\py\\Hard\\1851-erect-the-fence.py", "hypo_code": "class Solution(object):\n    def outerTrees(self, trees):\n        \n        \n        def crossProduct(p1, p2, p3):\n            return (p2[0] - p1[0]) * (p3[1] - p2[1]) - (p3[0] - p2[0]) * (p2[1] - p1[1])\n        def build(points):\n            result = []\n            for point in points:\n                while len(result) >= 2 and crossProduct(result[-2], result[-1], point) < 0:\n                    result.pop()\n                result.append(point)\n            return result\n        trees.sort()\n        lower = build(trees)\n        upper = build(trees[::-1])\n        return list(set(map(tuple, lower + upper)))"}
{"id": "1852", "path": "output2\\py\\Hard\\1852-tag-validator.py", "hypo_code": "class Solution(object):\n    def isValid(self, code):\n        \n        \n        stack = []\n        i = 0\n        while i < len(code):\n            if i > 0 and not stack:\n                return False\n            if code[i:i + 9] == '<![CDATA[':\n                j = i + 9\n                i = code.find(']]>', j)\n                if i < 0:\n                    return False\n                i += 3\n            elif code[i:i + 2] == '</':\n                j = i + 2\n                i = code.find('>', j)\n                if i < 0 or i == j or i - j > 9:\n                    return False\n                for k in range(j, i):\n                    if not code[k].isupper():\n                        return False\n                if not stack or stack.pop() != code[j:i]:\n                    return False\n            elif code[i] == '<':\n                j = i + 1\n                i = code.find('>', j)\n                if i < 0 or i == j or i - j > 9:\n                    return False\n                for k in range(j, i):\n                    if not code[k].isupper():\n                        return False\n                stack.append(code[j:i])\n            else:\n                i += 1\n        return not stack"}
{"id": "1853", "path": "output2\\py\\Hard\\1853-non-negative-integers-without-consecutive-ones.py", "hypo_code": "class Solution(object):\n    def findIntegers(self, n):\n        \n        \n        if n < 3:\n            return n + 1\n        x, y = 1, 2\n        while y <= n:\n            x, y = y, x + y\n        return self.findIntegers(n - x) + y if n >= x + y else self.findIntegers(n - x)"}
{"id": "1855", "path": "output2\\py\\Hard\\1855-k-inverse-pairs-array.py", "hypo_code": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \n        \n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[1][0] = 1\n        for i in range(2, n + 1):\n            dp[i][0] = 1\n            for j in range(1, k + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                if j >= i:\n                    dp[i][j] -= dp[i - 1][j - i]\n                dp[i][j] %= 1000000007\n        return dp[n][k]"}
{"id": "1856", "path": "output2\\py\\Hard\\1856-course-schedule-iii.py", "hypo_code": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \n        \n        courses.sort(key=lambda x: x[1])\n        queue, time = [], 0\n        for duration, end in courses:\n            time += duration\n            heapq.heappush(queue, -duration)\n            if time > end:\n                time += heapq.heappop(queue)\n        return len(queue)"}
{"id": "1857", "path": "output2\\py\\Hard\\1857-smallest-range-covering-elements-from-k-lists.py", "hypo_code": "class Solution(object):\n    def smallestRange(self, nums):\n        \n         \n        heap = [(row[0], i, 0) for i, row in enumerate(nums)]\n        heapq.heapify(heap)\n        result = -1e9, 1e9\n        right = max(row[0] for row in nums)\n        while heap:\n            left, i, j = heapq.heappop(heap)\n            if right - left < result[1] - result[0]:\n                result = left, right\n            if j + 1 == len(nums[i]):\n                return result\n            v = nums[i][j + 1]\n            right = max(right, v)\n            heapq.heappush(heap, (v, i, j + 1))"}
{"id": "1858", "path": "output2\\py\\Hard\\1858-decode-ways-ii.py", "hypo_code": "class Solution(object):\n    def numDecodings(self, s):\n        \n        \n        dp = [1, 0, 0]\n        for c in s:\n            dp_new = [0, 0, 0]\n            if c == '*':\n                dp_new[0] = 9 * dp[0] + 9 * dp[1] + 6 * dp[2]\n                dp_new[1] = dp[0]\n                dp_new[2] = dp[0]\n            else:\n                dp_new[0] = (c > '0') * dp[0] + dp[1] + (c <= '6') * dp[2]\n                dp_new[1] = (c == '1') * dp[0]\n                dp_new[2] = (c == '2') * dp[0]\n            dp = dp_new\n        return dp[0] % 1000000007"}
{"id": "1859", "path": "output2\\py\\Hard\\1859-strange-printer.py", "hypo_code": "class Solution(object):\n    def strangePrinter(self, s):\n               \n        if not s:\n            return 0\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\n        for i in range(len(s)-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,len(s)):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = min(dp[i][k]+dp[k+1][j] for k in range(i,j))\n        return dp[0][-1]"}
{"id": "1860", "path": "output2\\py\\Hard\\1860-kth-smallest-number-in-multiplication-table.py", "hypo_code": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \n        if m>n:\n            m,n=n,m\n        left=1\n        right=m*n\n        while left<right:\n            mid=(left+right)//2\n            if self.count(mid,m,n)<k:\n                left=mid+1\n            else:\n                right=mid\n        return left"}
{"id": "1861", "path": "output2\\py\\Hard\\1861-cut-off-trees-for-golf-event.py", "hypo_code": "class Solution(object):\n    def cutOffTree(self, forest):\n               \n        if not forest or not forest[0]:\n            return -1\n        m, n = len(forest), len(forest[0])\n        trees = []\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        res = 0\n        x, y = 0, 0\n        for _, i, j in trees:\n            step = self.bfs(forest, x, y, i, j)\n            if step < 0:\n                return -1\n            res += step\n            x, y = i, j\n        return res"}
{"id": "1862", "path": "output2\\py\\Hard\\1862-24-game.py", "hypo_code": "class Solution(object):\n    def judgePoint24(self, cards):\n        \n        if not cards:\n            return False\n        if len(cards)==1:\n            return abs(cards[0]-24)<0.001\n        for i in range(len(cards)):\n            for j in range(len(cards)):\n                if i!=j:\n                    new_cards=[]\n                    for k in range(len(cards)):\n                        if k!=i and k!=j:\n                            new_cards.append(cards[k])\n                    for k in range(4):\n                        if k<2 and j>i:\n                            continue\n                        if k==0:\n                            new_cards.append(cards[i]+cards[j])\n                        elif k==1:\n                            new_cards.append(cards[i]*cards[j])\n                        elif k==2:\n                            new_cards.append(cards[i]-cards[j])\n                        else:\n                            if cards[j]!=0:\n                                new_cards.append(cards[i]/cards[j])\n                        if self.judgePoint24(new_cards):\n                            return True\n                        new_cards.pop()\n        return False"}
{"id": "1863", "path": "output2\\py\\Hard\\1863-redundant-connection-ii.py", "hypo_code": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n              \n        if not edges:\n            return []\n        if len(edges)==1:\n            return edges[0]\n        if len(edges)==2:\n            return edges[1]\n        \n        parents={}\n        for edge in edges:\n            if edge[1] in parents:\n                parents[edge[1]].append(edge[0])\n            else:\n                parents[edge[1]]=[edge[0]]\n        \n        \n        node_with_two_parents=None\n        for key in parents:\n            if len(parents[key])==2:\n                node_with_two_parents=key\n                break\n        \n        \n        if not node_with_two_parents:\n            return edges[-1]"}
{"id": "1864", "path": "output2\\py\\Hard\\1864-maximum-sum-of-3-non-overlapping-subarrays.py", "hypo_code": "class Solution(object):\n    def maxSumOfThreeSubarrays(self, nums, k):\n        \n        if not nums:\n            return []\n        if k==1:\n            return [0,1,2]\n        result=[]\n        for i in range(len(nums)-k+1):\n            result.append(self.sum(nums[i:i+k]))\n        return result"}
{"id": "1865", "path": "output2\\py\\Hard\\1865-stickers-to-spell-word.py", "hypo_code": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \n        if not stickers or not target:\n            return 0\n        dp = [float('inf') for _ in range(len(target)+1)]\n        dp[0] = 0\n        for i in range(1,len(target)+1):\n            for sticker in stickers:\n                if target[i-1] in sticker:\n                    for j in range(len(sticker)):\n                        if target[i-1] == sticker[j]:\n                            dp[i] = min(dp[i],dp[i-1]+1)\n                            break\n        return dp[-1]"}
{"id": "1866", "path": "output2\\py\\Hard\\1866-falling-squares.py", "hypo_code": "class Solution(object):\n    def fallingSquares(self, positions):\n        \n        if not positions:\n            return []\n        if len(positions)==1:\n            return [positions[0][1]]\n        result=[]\n        for i in range(len(positions)):\n            result.append(self.fallingSquare(positions[:i+1]))\n        return result"}
{"id": "1869", "path": "output2\\py\\Hard\\1869-find-k-th-smallest-pair-distance.py", "hypo_code": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \n        \n        nums.sort()\n        low, high = 0, nums[-1] - nums[0]\n        while low < high:\n            mid = (low + high) / 2\n            count, left = 0, 0\n            for right in range(len(nums)):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            if count < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low"}
{"id": "1870", "path": "output2\\py\\Hard\\1870-number-of-atoms.py", "hypo_code": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \n        \n        stack = [collections.Counter()]\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                stack.append(collections.Counter())\n                i += 1\n            elif formula[i] == ')':\n                top = stack.pop()\n                i += 1\n                start = i\n                while i < len(formula) and formula[i].isdigit():\n                    i += 1\n                factor = int(formula[start:i] or 1)\n                for name, count in top.items():\n                    stack[-1][name] += count * factor\n            else:\n                start = i\n                i += 1\n                while i < len(formula) and formula[i].islower():\n                    i += 1\n                name = formula[start:i]\n                start = i\n                while i < len(formula) and formula[i].isdigit():\n                    i += 1\n                stack[-1][name] += int(formula[start:i] or 1)\n        return ''.join(name + (str(stack[-1][name]) if stack[-1][name] > 1 else '') for name in sorted(stack[-1]))"}
{"id": "1871", "path": "output2\\py\\Hard\\1871-count-different-palindromic-subsequences.py", "hypo_code": "class Solution(object):\n    def countPalindromicSubsequences(self, s):\n             \n        if not s:\n            return 0\n        if len(s)==1:\n            return 1\n        if len(s)==2:\n            return 2\n        if len(s)==3:\n            return 4\n        dp=[[0 for i in range(len(s))] for j in range(len(s))]\n        for i in range(len(s)):\n            dp[i][i]=1\n        for i in range(len(s)-1):\n            dp[i][i+1]=2\n        for i in range(len(s)-2):\n            dp[i][i+2]=4\n        for i in range(3,len(s)):\n            for j in range(len(s)-i):\n                if s[j]==s[j+i]:\n                    dp[j][j+i]=dp[j+1][j+i-1]*2\n                    left=j+1\n                    right=j+i-1\n                    while left<=right and s[left]!=s[j]:\n                        left+=1\n                    while left<=right and s[right]!=s[j]:\n                        right-=1\n                    if left>right:\n                        dp[j][j+i]-=1\n                    elif left==right:\n                        dp[j][j+i]-=2\n                    else:\n                        dp[j][j+i]-=dp[left+1][right-1]*2\n                else:\n                    dp[j][j+i]=dp[j+1][j+i]+dp[j][j+i-1]-dp[j+1][j+i-1]\n        return dp[0][len(s)-1]%1000000007"}
{"id": "1873", "path": "output2\\py\\Hard\\1873-parse-lisp-expression.py", "hypo_code": "class Solution(object):\n    def evaluate(self, expression):\n            \n        \n        \n        if expression[0] == '(':\n            \n            if expression[1:4] == 'let':\n                return self.let(expression[5:-1])\n            elif expression[1:4] == 'add':\n                return self.add(expression[5:-1])\n            elif expression[1:4] == 'mul':\n                return self.mul(expression[5:-1])\n        else:\n            return self.var(expression)"}
{"id": "1874", "path": "output2\\py\\Hard\\1874-cherry-pickup.py", "hypo_code": "class Solution(object):\n    def cherryPickup(self, grid):\n        \n        if not grid:\n            return 0\n        if len(grid)==1:\n            return grid[0][0]\n        result=0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                result+=grid[i][j]\n        return result"}
{"id": "1876", "path": "output2\\py\\Hard\\1876-contain-virus.py", "hypo_code": "class Solution(object):\n    def containVirus(self, isInfected):\n        \n        if not isInfected:\n            return 0\n        if len(isInfected)==1:\n            return isInfected[0][0]\n        result=0\n        for i in range(len(isInfected)):\n            for j in range(len(isInfected[0])):\n                result+=isInfected[i][j]\n        return result"}
{"id": "1877", "path": "output2\\py\\Hard\\1877-cracking-the-safe.py", "hypo_code": "class Solution(object):\n    def crackSafe(self, n, k):\n           \n        if n==1:\n            return \"\".join([str(i) for i in range(k)])\n        if k==1:\n            return \"0\"*(n-1)\n        if k==n:\n            return \"0\"*(n-1)+\"1\"\n        result = []\n        for i in range(k):\n            result.append(str(i))\n        for i in range(k**(n-1)):\n            result.append(str(i%k))\n        return \"\".join(result)"}
{"id": "1878", "path": "output2\\py\\Hard\\1878-set-intersection-size-at-least-two.py", "hypo_code": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n               \n        if not intervals:\n            return 0\n        intervals.sort(key=lambda x:x[1])\n        result = []\n        for i in range(len(intervals)):\n            if not result:\n                result.append(intervals[i][1]-1)\n                result.append(intervals[i][1])\n            else:\n                if intervals[i][0]>result[-1]:\n                    result.append(intervals[i][1]-1)\n                    result.append(intervals[i][1])\n                elif intervals[i][0]>result[-2]:\n                    result.append(intervals[i][1])\n        return len(result)"}
{"id": "1879", "path": "output2\\py\\Hard\\1879-special-binary-string.py", "hypo_code": "class Solution(object):\n    def makeLargestSpecial(self, s):\n        \n        \n        count = i = 0\n        result = []\n        for j, c in enumerate(s):\n            count += 1 if c == '1' else -1\n            if count == 0:\n                result.append('1' + self.makeLargestSpecial(s[i + 1:j]) + '0')\n                i = j + 1\n        return ''.join(sorted(result, reverse=True))"}
{"id": "1880", "path": "output2\\py\\Hard\\1880-couples-holding-hands.py", "hypo_code": "class Solution(object):\n    def minSwapsCouples(self, row):\n             \n        if not row:\n            return 0\n        if len(row)==2:\n            return 1\n        if len(row)==4:\n            return 2\n        result = []\n        for i in range(len(row)-2):\n            result.append(row[i:i+2])\n        return min(result)"}
{"id": "1881", "path": "output2\\py\\Hard\\1881-max-chunks-to-make-sorted-ii.py", "hypo_code": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \n        if not arr:\n            return 0\n        if len(arr)==1:\n            return 1\n        result = 0\n        for i in range(len(arr)):\n            if max(arr[:i+1])<=min(arr[i+1:]):\n                result+=1\n        return result"}
{"id": "1882", "path": "output2\\py\\Hard\\1882-basic-calculator-iv.py", "hypo_code": "class Solution(object):\n    def basicCalculatorIV(self, expression, evalvars, evalints):\n              \n        return []"}
{"id": "1883", "path": "output2\\py\\Hard\\1883-sliding-puzzle.py", "hypo_code": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \n        \n        s = ''.join(str(c) for row in board for c in row)\n        queue = collections.deque([(s, s.index('0'), 0)])\n        seen = {s}\n        while queue:\n            state, pos, step = queue.popleft()\n            if state == '123450':\n                return step\n            for move in (1, -1, 3, -3):\n                newPos = pos + move\n                if newPos < 0 or newPos > 5 or (pos == 2 and newPos == 3) or (pos == 3 and newPos == 2):\n                    continue\n                newState = list(state)\n                newState[pos], newState[newPos] = newState[newPos], newState[pos]\n                newState = ''.join(newState)\n                if newState not in seen:\n                    seen.add(newState)\n                    queue.append((newState, newPos, step + 1))\n        return -1"}
{"id": "1884", "path": "output2\\py\\Hard\\1884-swim-in-rising-water.py", "hypo_code": "class Solution(object):\n    def swimInWater(self, grid):\n               \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        max_val = 0\n        for row in grid:\n            for val in row:\n                if val > max_val:\n                    max_val = val\n        \n        \n        min_val = max_val\n        for row in grid:\n            for val in row:\n                if val < min_val:\n                    min_val = val\n        \n        \n        mid_val = (max_val + min_val) // 2\n        \n        \n        \n        \n        \n        while min_val < max_val:\n            \n            if self.is_reachable(grid, mid_val):\n                \n                max_val = mid_val\n            else:\n                \n                min_val = mid_val + 1\n            \n            \n            mid_val = (max_val + min_val) // 2\n        \n        \n        return min_val"}
{"id": "1885", "path": "output2\\py\\Hard\\1885-reaching-points.py", "hypo_code": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        if tx < sx or ty < sy:\n            return False\n        \n        \n        if tx == sx and ty == sy:\n            return True\n        \n        \n        while tx != sx or ty != sy:\n            \n            if tx > ty:\n                tx = tx - ty\n            \n            else:\n                ty = ty - tx\n        \n        \n        return True\n        \n        \n        if tx < sx or ty < sy:\n            return False"}
{"id": "1886", "path": "output2\\py\\Hard\\1886-transform-to-chessboard.py", "hypo_code": "class Solution(object):\n    def movesToChessboard(self, board):\n        \n        \n        \n        \n        \n        \n        if not self.is_valid(board):\n            return -1\n        \n        \n        \n        return self.find_moves(board)"}
{"id": "1887", "path": "output2\\py\\Hard\\1887-preimage-size-of-factorial-zeroes-function.py", "hypo_code": "class Solution(object):\n    def preimageSizeFZF(self, k):"}
{"id": "1888", "path": "output2\\py\\Hard\\1888-smallest-rotation-with-highest-score.py", "hypo_code": "class Solution(object):\n    def bestRotation(self, nums):\n        \n        \n        \n        \n        \n        \n        \n        \n        return self.find_best_rotation(nums)"}
{"id": "1889", "path": "output2\\py\\Hard\\1889-minimum-swaps-to-make-sequences-increasing.py", "hypo_code": "class Solution(object):\n    def minSwap(self, nums1, nums2):\n                                                                                     \n        \n        \n        return self.find_swaps(nums1,nums2)"}
{"id": "1890", "path": "output2\\py\\Hard\\1890-bricks-falling-when-hit.py", "hypo_code": "class Solution(object):\n    def hitBricks(self, grid, hits):\n                                                                                       \n        \n        rows = len(grid)\n        \n        cols = len(grid[0])"}
{"id": "1891", "path": "output2\\py\\Hard\\1891-split-array-with-same-average.py", "hypo_code": "class Solution(object):\n    def splitArraySameAverage(self, nums):\n        \n        \n        \n        \n        \n        \n        return self.find_average(nums)"}
{"id": "1892", "path": "output2\\py\\Hard\\1892-chalkboard-xor-game.py", "hypo_code": "class Solution(object):\n    def xorGame(self, nums):\n        \n        if len(nums)%2==0:\n            return True\n        result=nums[0]\n        for i in range(1,len(nums)):\n            result=result^nums[i]\n        return result==0"}
{"id": "1893", "path": "output2\\py\\Hard\\1893-bus-routes.py", "hypo_code": "class Solution(object):\n    def numBusesToDestination(self, routes, source, target):\n        \n        if source==target:\n            return 0\n        routes_dict={}\n        for i in range(len(routes)):\n            for j in range(len(routes[i])):\n                if routes[i][j] in routes_dict:\n                    routes_dict[routes[i][j]].append(i)\n                else:\n                    routes_dict[routes[i][j]]=[i]\n        visited=set()\n        queue=[source]\n        count=0\n        while queue:\n            count+=1\n            for i in range(len(queue)):\n                current=queue.pop(0)\n                for j in routes_dict[current]:\n                    if j not in visited:\n                        visited.add(j)\n                        for k in range(len(routes[j])):\n                            if routes[j][k]==target:\n                                return count\n                            queue.append(routes[j][k])\n        return -1"}
{"id": "1894", "path": "output2\\py\\Hard\\1894-race-car.py", "hypo_code": "class Solution(object):\n    def racecar(self, target):\n        \n        \n        \n        return self.find_steps(target)"}
{"id": "1895", "path": "output2\\py\\Hard\\1895-making-a-large-island.py", "hypo_code": "class Solution(object):\n    def largestIsland(self, grid):\n             \n        \n        \n        return self.find_largest_island(grid)"}
{"id": "1896", "path": "output2\\py\\Hard\\1896-count-unique-characters-of-all-substrings-of-a-given-string.py", "hypo_code": "class Solution(object):\n    def uniqueLetterString(self, s):\n               \n        \n        \n        return self.find_unique_chars(s)"}
{"id": "1897", "path": "output2\\py\\Hard\\1897-consecutive-numbers-sum.py", "hypo_code": "class Solution(object):\n    def consecutiveNumbersSum(self, n):\n              \n        if n==1:\n            return 1\n        result=0\n        for i in range(1,n):\n            if (n-i*(i+1)/2)%i==0:\n                result+=1\n        return result"}
{"id": "1898", "path": "output2\\py\\Hard\\1898-sum-of-distances-in-tree.py", "hypo_code": "class Solution(object):\n    def sumOfDistancesInTree(self, n, edges):\n        \n        if n==1:\n            return [0]\n        if n==2:\n            return [1,1]\n        result=[0]*n\n        for i in range(n):\n            result[i]=self.sumOfDistancesInTreeHelper(n,edges,i)\n        return result"}
{"id": "1899", "path": "output2\\py\\Hard\\1899-similar-string-groups.py", "hypo_code": "class Solution(object):\n    def numSimilarGroups(self, strs):\n                         \n        \n        \n        return self.find_connected_components(strs)"}
{"id": "1900", "path": "output2\\py\\Hard\\1900-guess-the-word.py", "hypo_code": "class Solution(object):\n    def findSecretWord(self, words, master):"}
{"id": "1901", "path": "output2\\py\\Hard\\1901-shortest-path-visiting-all-nodes.py", "hypo_code": "class Solution(object):\n    def shortestPathLength(self, graph):\n        \n        if len(graph)==1:\n            return 0\n        if len(graph)==2:\n            return 1\n        result=0\n        for i in range(len(graph)):\n            result=max(result,self.shortestPathLengthHelper(graph,i))\n        return result"}
{"id": "1902", "path": "output2\\py\\Hard\\1902-rectangle-area-ii.py", "hypo_code": "class Solution(object):\n    def rectangleArea(self, rectangles):\n        \n        if len(rectangles)==1:\n            return (rectangles[0][2]-rectangles[0][0])*(rectangles[0][3]-rectangles[0][1])\n        result=0\n        for i in range(len(rectangles)):\n            result+=self.rectangleAreaHelper(rectangles,i)\n        return result"}
{"id": "1903", "path": "output2\\py\\Hard\\1903-k-similar-strings.py", "hypo_code": "class Solution(object):\n    def kSimilarity(self, s1, s2):\n             \n        if not s1 or not s2:\n            return 0\n        if s1==s2:\n            return 0\n        if len(s1)!=len(s2):\n            return 0\n        if len(s1)==1:\n            return 0\n        if len(s1)==2:\n            if s1==s2:\n                return 0\n            else:\n                return 1\n        \n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                break\n        \n        s1=s1[:i]+s2[i]+s1[i+1:]\n        return 1+self.kSimilarity(s1,s2)"}
{"id": "1904", "path": "output2\\py\\Hard\\1904-minimum-cost-to-hire-k-workers.py", "hypo_code": "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, k):\n                                                                   \n        if k==1:\n            return min(wage)\n        if k==len(quality):\n            return sum(wage)/len(quality)\n        result=[]\n        for i in range(len(quality)):\n            result.append(self.mincostToHireWorkersHelper(quality,wage,k,i))\n        return min(result)"}
{"id": "1905", "path": "output2\\py\\Hard\\1905-shortest-subarray-with-sum-at-least-k.py", "hypo_code": "class Solution(object):\n    def shortestSubarray(self, nums, k):\n              \n        if not nums:\n            return -1\n        result=0\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)+1):\n                if sum(nums[i:j])>=k:\n                    result=j-i\n                    break\n        return result"}
{"id": "1906", "path": "output2\\py\\Hard\\1906-shortest-path-to-get-all-keys.py", "hypo_code": "class Solution(object):\n    def shortestPathAllKeys(self, grid):\n              \n        if not grid or not grid[0]:\n            return -1\n        m, n = len(grid), len(grid[0])\n        start = None\n        keys = set()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    start = (i, j)\n                elif grid[i][j] in string.ascii_lowercase:\n                    keys.add(grid[i][j])\n        q = collections.deque([(start, 0, set())])\n        visited = set()\n        while q:\n            (x, y), step, cur_keys = q.popleft()\n            if (x, y, tuple(sorted(cur_keys))) in visited:\n                continue\n            visited.add((x, y, tuple(sorted(cur_keys))))\n            if len(cur_keys) == len(keys):\n                return step\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '\n                    if grid[nx][ny] in string.ascii_lowercase:\n                        q.append(((nx, ny), step + 1, cur_keys | set([grid[nx][ny]])))\n                    elif grid[nx][ny] in string.ascii_uppercase:\n                        if grid[nx][ny].lower() in cur_keys:\n                            q.append(((nx, ny), step + 1, cur_keys))\n                    else:\n                        q.append(((nx, ny), step + 1, cur_keys))\n        return -1"}
{"id": "1907", "path": "output2\\py\\Hard\\1907-minimum-number-of-refueling-stops.py", "hypo_code": "class Solution(object):\n    def minRefuelStops(self, target, startFuel, stations):\n               \n        if startFuel>=target:\n            return 0\n        if len(stations)==0:\n            return -1\n        dp=[0]*(len(stations)+1)\n        dp[0]=startFuel\n        for i in range(len(stations)):\n            for j in range(i+1,-1,-1):\n                if dp[j]>=stations[i][0]:\n                    dp[j+1]=max(dp[j+1],dp[j]+stations[i][1])\n        for i in range(len(dp)):\n            if dp[i]>=target:\n                return i\n        return -1"}
{"id": "1908", "path": "output2\\py\\Hard\\1908-nth-magical-number.py", "hypo_code": "class Solution(object):\n    def nthMagicalNumber(self, n, a, b):\n              \n        if n==1:\n            return min(a,b)\n        if a==b:\n            return a*n\n        if a>b:\n            a,b=b,a\n        result=0\n        for i in range(n):\n            if i%2==0:\n                result+=a\n            else:\n                result+=b\n        return result"}
{"id": "1909", "path": "output2\\py\\Hard\\1909-profitable-schemes.py", "hypo_code": "class Solution(object):\n    def profitableSchemes(self, n, minProfit, group, profit):\n        \n        if len(group)==1:\n            if group[0]<=n and profit[0]>=minProfit:\n                return 1\n            else:\n                return 0\n        result=0\n        for i in range(len(group)):\n            result+=self.profitableSchemesHelper(n,minProfit,group,profit,i)\n        return result"}
{"id": "1910", "path": "output2\\py\\Hard\\1910-reachable-nodes-in-subdivided-graph.py", "hypo_code": "class Solution(object):\n    def reachableNodes(self, edges, maxMoves, n):"}
{"id": "1911", "path": "output2\\py\\Hard\\1911-super-egg-drop.py", "hypo_code": "class Solution(object):\n    def superEggDrop(self, k, n):\n        \n        if k==1:\n            return n\n        if n==1:\n            return 1\n        result=0\n        for i in range(n):\n            result=max(result,self.superEggDropHelper(k,n,i))\n        return result"}
{"id": "1912", "path": "output2\\py\\Hard\\1912-sum-of-subsequence-widths.py", "hypo_code": "class Solution(object):\n    def sumSubseqWidths(self, nums):\n        \n        if not nums:\n            return 0\n        if len(nums)==1:\n            return 0\n        nums.sort()\n        result = 0\n        for i in range(len(nums)):\n            result+=nums[i]*(2**i-2**(len(nums)-i-1))\n        return result%(10**9+7)"}
{"id": "1914", "path": "output2\\py\\Hard\\1914-orderly-queue.py", "hypo_code": "class Solution(object):\n    def orderlyQueue(self, s, k):\n        \n        if not s:\n            return \"\"\n        if k==1:\n            result=s\n            for i in range(1,len(s)):\n                s=s[1:]+s[0]\n                if s<result:\n                    result=s\n            return result\n        else:\n            return \"\".join(sorted(s))"}
{"id": "1915", "path": "output2\\py\\Hard\\1915-numbers-at-most-n-given-digit-set.py", "hypo_code": "class Solution(object):\n    def atMostNGivenDigitSet(self, digits, n):\n        \n        if not digits:\n            return 0\n        if not n:\n            return 0\n        if len(digits)==1:\n            return 1\n        if len(digits)==n:\n            return 1\n        result = []\n        for i in range(len(digits)-n+1):\n            result.append(len(digits[i:i+n]))\n        return min(result)"}
{"id": "1916", "path": "output2\\py\\Hard\\1916-valid-permutations-for-di-sequence.py", "hypo_code": "class Solution(object):\n    def numPermsDISequence(self, s):\n        \n        if not s:\n            return 0\n        if len(s)==1:\n            return 1\n        if len(s)==2:\n            return 2\n        result = 0\n        for i in range(len(s)):\n            if s[i]=='D':\n                result+=self.numPermsDISequence(s[:i]+s[i+1:])\n            else:\n                result+=self.numPermsDISequence(s[:i]+s[i+1:])\n        return result%(10**9+7)"}
{"id": "1917", "path": "output2\\py\\Hard\\1917-super-palindromes.py", "hypo_code": "class Solution(object):\n    def superpalindromesInRange(self, left, right):\n             \n        if not left or not right:\n            return 0\n        if left==right:\n            return 0\n        if len(left)!=len(right):\n            return 0\n        if len(left)==1:\n            return 0\n        if len(left)==2:\n            if left==right:\n                return 0\n            else:\n                return 1\n        \n        for i in range(len(left)):\n            if left[i]!=right[i]:\n                break\n        \n        left=left[:i]+right[i]+left[i+1:]\n        return 1+self.superpalindromesInRange(left,right)"}
{"id": "1918", "path": "output2\\py\\Hard\\1918-cat-and-mouse.py", "hypo_code": "class Solution(object):\n    def catMouseGame(self, graph):\n        \n        if len(graph)==1:\n            return 0\n        if len(graph)==2:\n            return 1\n        result=0\n        for i in range(len(graph)):\n            result=max(result,self.catMouseGameHelper(graph,i))\n        return result"}
{"id": "1919", "path": "output2\\py\\Hard\\1919-number-of-music-playlists.py", "hypo_code": "class Solution(object):\n    def numMusicPlaylists(self, n, goal, k):\n        \n        if n==goal:\n            return 1\n        if n==1:\n            return 1\n        if goal==1:\n            return 1\n        if goal==2:\n            return 2\n        if k==0:\n            return 1\n        if k==1:\n            return 1\n        result = 0\n        for i in range(n):\n            if i==0:\n                result+=self.numMusicPlaylists(n,goal-1,k)\n            else:\n                result+=self.numMusicPlaylists(n,goal-1,k)\n        return result%(10**9+7)"}
{"id": "1920", "path": "output2\\py\\Hard\\1920-minimize-malware-spread.py", "hypo_code": "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        \n        if len(graph)==1:\n            return initial[0]\n        if len(graph)==2:\n            return min(initial)\n        result=0\n        for i in range(len(graph)):\n            result=max(result,self.minMalwareSpreadHelper(graph,initial,i))\n        return result"}
{"id": "1921", "path": "output2\\py\\Hard\\1921-three-equal-parts.py", "hypo_code": "class Solution(object):\n    def threeEqualParts(self, arr):\n        \n        if not arr:\n            return [-1,-1]\n        if len(arr)==1:\n            return [-1,-1]\n        if len(arr)==2:\n            return [-1,-1]\n        if len(arr)==3:\n            if arr[0]==arr[1]==arr[2]:\n                return [0,2]\n            else:\n                return [-1,-1]\n        if len(arr)==4:\n            if arr[0]==arr[1]==arr[2]==arr[3]:\n                return [0,3]\n            else:\n                return [-1,-1]\n        if len(arr)==5:\n            if arr[0]==arr[1]==arr[2]==arr[3]==arr[4]:\n                return [0,4]\n            else:\n                return [-1,-1]\n        if len(arr)==6:\n            if arr[0]==arr[1]==arr[2]==arr[3]==arr[4]==arr[5]:\n                return [0,5]\n            else:\n                return [-1,-1]\n        if len(arr)==7:\n            if arr[0]==arr[1]==arr[2]==arr[3]==arr[4]==arr[5]==arr[6]:\n                return [0,6]\n            else:\n                return [-1,-1]\n        if len(arr)==8:\n            if arr[0]==arr[1]==arr[2]==arr[3]==arr[4]==arr[5]==arr[6]==arr[7]:\n                return [0,7]\n            else:\n                return [-1,-1]\n        if len(arr)==9:\n            if arr[0]==arr[1]==arr[2]==arr[3]==arr[4]==arr[5]==arr[6]==arr[7]==arr[8]:\n                return [0,8]\n            else:\n                return [-1,-1]\n        if len(arr)==10:\n            if arr[0]==arr[1]==arr[2]==arr[3]==arr[4]==arr[5]==arr[6]==arr[7]==arr[8]==arr[9]:\n                return [0,9]\n            else:\n                return [-1,-1]\n        if len(arr)==11:\n            if arr[0]==arr[1]==arr[2]==arr[3]==arr[4]==arr[5]==arr[6]==arr[7]==arr[8]==arr[9]==arr[10]:\n                return [0,10]\n            else:\n                return [-1,-1]\n        if len(arr)==12:\n            if arr[0]==arr[1]==arr[2]==arr[3]==arr[4]==arr[5]==arr[6]==arr[7]==arr[8]==arr[9]==arr[10]==arr[11]:\n                return [0,11]\n            else:\n                return [-1,-1]\n        if len(arr)==13:\n            if arr[0]==arr[1]==arr[2]==arr[3]==arr[4]==arr[5]==arr[6]==arr[7]==arr[8]==arr[9]==arr[10]==arr[11]==arr[12]:\n                return [0,12]\n            else:\n                return [-1,-1]"}
{"id": "1922", "path": "output2\\py\\Hard\\1922-minimize-malware-spread-ii.py", "hypo_code": "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        \n        if len(graph)==1:\n            return initial[0]\n        if len(graph)==2:\n            return min(initial)\n        result=0\n        for i in range(len(graph)):\n            result=max(result,self.minMalwareSpreadHelper(graph,initial,i))\n        return result"}
{"id": "1923", "path": "output2\\py\\Hard\\1923-stamping-the-sequence.py", "hypo_code": "class Solution(object):\n    def movesToStamp(self, stamp, target):\n        \n        if not stamp:\n            return []\n        if not target:\n            return []\n        if len(stamp)>len(target):\n            return []\n        if len(stamp)==len(target):\n            if stamp==target:\n                return [0]\n            else:\n                return []\n        result = []\n        for i in range(len(target)-len(stamp)+1):\n            if target[i:i+len(stamp)]==stamp:\n                result.append(i)\n        return result"}
{"id": "1924", "path": "output2\\py\\Hard\\1924-distinct-subsequences-ii.py", "hypo_code": "class Solution(object):\n    def distinctSubseqII(self, s):\n        \n        if not s:\n            return 0\n        if len(s)==1:\n            return 1\n        if len(s)==2:\n            return 2\n        result = 0\n        for i in range(len(s)):\n            result+=self.distinctSubseqII(s[:i]+s[i+1:])\n        return result%(10**9+7)"}
{"id": "1925", "path": "output2\\py\\Hard\\1925-find-the-shortest-superstring.py", "hypo_code": "class Solution(object):\n    def shortestSuperstring(self, words):\n        \n        if not words:\n            return \"\"\n        if len(words)==1:\n            return words[0]\n        if len(words)==2:\n            return self.merge(words[0],words[1])\n        result = \"\"\n        for i in range(len(words)):\n            result = self.merge(result,self.shortestSuperstring(words[:i]+words[i+1:]))\n        return result"}
{"id": "1926", "path": "output2\\py\\Hard\\1926-largest-component-size-by-common-factor.py", "hypo_code": "class Solution(object):\n    def largestComponentSize(self, nums):\n        \n        if not nums:\n            return 0\n        if len(nums)==1:\n            return 1\n        if len(nums)==2:\n            return 2\n        result = 0\n        for i in range(len(nums)):\n            result = max(result,self.largestComponentSize(nums[:i]+nums[i+1:]))\n        return result"}
{"id": "1927", "path": "output2\\py\\Hard\\1927-tallest-billboard.py", "hypo_code": "class Solution(object):\n    def tallestBillboard(self, rods):\n        \n        if not rods:\n            return 0\n        if len(rods)==1:\n            return 0\n        if len(rods)==2:\n            if rods[0]==rods[1]:\n                return rods[0]\n            else:\n                return 0\n        result = 0\n        for i in range(len(rods)):\n            result = max(result,self.tallestBillboard(rods[:i]+rods[i+1:]))\n        return result"}
{"id": "1928", "path": "output2\\py\\Hard\\1928-delete-columns-to-make-sorted-iii.py", "hypo_code": "class Solution(object):\n    def minDeletionSize(self, strs):\n        \n        if not strs:\n            return 0\n        if len(strs)==1:\n            return 0\n        if len(strs[0])==1:\n            return 0\n        result = 0\n        for i in range(len(strs[0])):\n            for j in range(len(strs)-1):\n                if strs[j][i]>strs[j+1][i]:\n                    result+=1\n                    break\n        return result"}
{"id": "1929", "path": "output2\\py\\Hard\\1929-least-operators-to-express-number.py", "hypo_code": "class Solution(object):\n    def leastOpsExpressTarget(self, x, target):\n        \n        if x>target:\n            return min(2*target-1,x-target)\n        if x==target:\n            return 0\n        if target%x==0:\n            return self.leastOpsExpressTarget(x,target//x)\n        else:\n            return min(target%x*x,self.leastOpsExpressTarget(x,target%x)+x)"}
{"id": "1930", "path": "output2\\py\\Hard\\1930-binary-tree-cameras.py", "hypo_code": "class Solution(object):\n    def minCameraCover(self, root):\n        \n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        if not root.left:\n            return self.minCameraCover(root.right)+1\n        if not root.right:\n            return self.minCameraCover(root.left)+1\n        return min(self.minCameraCover(root.left),self.minCameraCover(root.right))+1"}
{"id": "1931", "path": "output2\\py\\Hard\\1931-equal-rational-numbers.py", "hypo_code": "class Solution(object):\n    def isRationalEqual(self, s, t):\n               \n        def getRational(s):\n            if '(' not in s:\n                return float(s)\n            else:\n                s = s.replace('(','').replace(')','')\n                integer, decimal = s.split('.')\n                return float(integer+'.'+decimal[:decimal.index('(')]) + float('0.'+decimal[decimal.index('('):])\n        return getRational(s) == getRational(t)"}
{"id": "1932", "path": "output2\\py\\Hard\\1932-odd-even-jump.py", "hypo_code": "class Solution(object):\n    def oddEvenJumps(self, arr):\n              \n        if not arr:\n            return 0\n        if len(arr)==1:\n            return 1\n        if len(arr)==2:\n            return 2\n        odd = [0]*len(arr)\n        even = [0]*len(arr)\n        odd[-1] = 1\n        even[-1] = 1\n        result = 1\n        for i in range(len(arr)-2,-1,-1):\n            odd[i] = even[self.find_next(arr,odd,i)]\n            even[i] = odd[self.find_next(arr,even,i)]\n            result += odd[i]\n        return result"}
{"id": "1933", "path": "output2\\py\\Hard\\1933-unique-paths-iii.py", "hypo_code": "class Solution(object):\n    def uniquePathsIII(self, grid):\n        \n        if not grid:\n            return 0\n        if len(grid)==1:\n            return 1\n        if len(grid)==2:\n            return 2\n        result = 0\n        for i in range(len(grid)):\n            result = max(result,self.uniquePathsIII(grid[:i]+grid[i+1:]))\n        return result"}
{"id": "1934", "path": "output2\\py\\Hard\\1934-triples-with-bitwise-and-equal-to-zero.py", "hypo_code": "class Solution(object):\n    def countTriplets(self, nums):\n        \n        if not nums:\n            return 0\n        if len(nums)==1:\n            return 0\n        if len(nums)==2:\n            return 0\n        result = 0\n        for i in range(len(nums)):\n            result += self.countTriplets(nums[:i]+nums[i+1:])\n        return result"}
{"id": "1935", "path": "output2\\py\\Hard\\1935-vertical-order-traversal-of-a-binary-tree.py", "hypo_code": "class Solution(object):\n    def verticalTraversal(self, root):\n               \n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [[root.val]]\n        if not root.left:\n            return [[root.val]]+self.verticalTraversal(root.right)\n        if not root.right:\n            return self.verticalTraversal(root.left)+[[root.val]]\n        return self.verticalTraversal(root.left)+[[root.val]]+self.verticalTraversal(root.right)"}
{"id": "1936", "path": "output2\\py\\Hard\\1936-subarrays-with-k-different-integers.py", "hypo_code": "class Solution(object):\n    def subarraysWithKDistinct(self, nums, k):\n               \n        if not nums:\n            return 0\n        if len(nums)==1:\n            return 1\n        if len(nums)==2:\n            return 2\n        result = 0\n        for i in range(len(nums)):\n            result += self.subarraysWithKDistinct(nums[:i]+nums[i+1:],k)\n        return result"}
{"id": "1937", "path": "output2\\py\\Hard\\1937-minimum-number-of-k-consecutive-bit-flips.py", "hypo_code": "class Solution(object):\n    def minKBitFlips(self, nums, k):\n        \n        if not nums:\n            return 0\n        if len(nums)==1:\n            return 0\n        if len(nums)==2:\n            return 0\n        result = 0\n        for i in range(len(nums)):\n            result += self.minKBitFlips(nums[:i]+nums[i+1:],k)\n        return result"}
{"id": "1938", "path": "output2\\py\\Hard\\1938-number-of-squareful-arrays.py", "hypo_code": "class Solution(object):\n    def numSquarefulPerms(self, nums):\n        \n        if not nums:\n            return 0\n        if len(nums)==1:\n            return 1\n        if len(nums)==2:\n            return 2\n        result = 0\n        for i in range(len(nums)):\n            result += self.numSquarefulPerms(nums[:i]+nums[i+1:])\n        return result"}
{"id": "1939", "path": "output2\\py\\Hard\\1939-minimum-cost-to-merge-stones.py", "hypo_code": "class Solution(object):\n    def mergeStones(self, stones, k):\n        \n        if not stones:\n            return 0\n        if len(stones)==1:\n            return 0\n        if len(stones)==2:\n            return 0\n        result = 0\n        for i in range(len(stones)):\n            result += self.mergeStones(stones[:i]+stones[i+1:],k)\n        return result"}
{"id": "1940", "path": "output2\\py\\Hard\\1940-grid-illumination.py", "hypo_code": "class Solution(object):\n    def gridIllumination(self, n, lamps, queries):\n           \n\n        def turn_on(lamp):\n            x, y = lamp\n            row[x] += 1\n            col[y] += 1\n            diag1[x+y] += 1\n            diag2[x-y] += 1\n            lamps_set.add((x,y))\n            \n        def turn_off(lamp):\n            x, y = lamp\n            row[x] -= 1\n            col[y] -= 1\n            diag1[x+y] -= 1\n            diag2[x-y] -= 1\n            lamps_set.remove((x,y))\n            \n        def is_illuminated(x, y):\n            return row[x] > 0 or col[y] > 0 or diag1[x+y] > 0 or diag2[x-y] > 0\n        \n        row = collections.defaultdict(int)\n        col = collections.defaultdict(int)\n        diag1 = collections.defaultdict(int)\n        diag2 = collections.defaultdict(int)\n        lamps_set = set()\n        \n        for lamp in lamps:\n            turn_on(lamp)\n        \n        ans = []\n        for query in queries:\n            x, y = query\n            ans.append(int(is_illuminated(x, y)))\n            for dx in range(-1, 2):\n                for dy in range(-1, 2):\n                    if (x+dx, y+dy) in lamps_set:\n                        turn_off((x+dx, y+dy))\n        return ans"}
{"id": "1941", "path": "output2\\py\\Hard\\1941-numbers-with-repeated-digits.py", "hypo_code": "class Solution(object):\n    def numDupDigitsAtMostN(self, n):\n               \n        def get_digits(n):\n            res = []\n            while n:\n                res.append(n % 10)\n                n /= 10\n            return res[::-1]\n        \n        def get_permutations(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            return res\n        \n        def get_permutations_without_repetitions(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            for i in range(1, k+1):\n                res /= i\n            return res\n        \n        def get_count_without_repetitions(n):\n            res = 0\n            k = len(n)\n            for i in range(1, k):\n                res += 9 * get_permutations_without_repetitions(9, i-1)\n            used = set()\n            for i in range(k):\n                for j in range(1 if i else 1, n[i]):\n                    if j not in used:\n                        res += get_permutations_without_repetitions(9-i, k-i-1)\n                if n[i] in used:\n                    break\n                used.add(n[i])\n            else:\n                res += 1\n            return res\n        \n        return n - get_count_without_repetitions(get_digits(n))"}
{"id": "1942", "path": "output2\\py\\Hard\\1942-recover-a-tree-from-preorder-traversal.py", "hypo_code": "class Solution(object):\n    def recoverFromPreorder(self, traversal):\n        \n        def get_depth(s):\n            res = 0\n            for c in s:\n                if c == '-':\n                    res += 1\n                else:\n                    break\n            return res\n        def get_val(s):\n            res = 0\n            for c in s:\n                if c == '-':\n                    break\n                else:\n                    res = res * 10 + int(c)\n            return res\n        def get_node(s):\n            return TreeNode(get_val(s))\n        def get_children(s):\n            res = []\n            i = 0\n            while i < len(s):\n                if s[i] == '-':\n                    j = i\n                    while j < len(s) and s[j] == '-':\n                        j += 1\n                    k = j\n                    while k < len(s) and s[k] != '-':\n                        k += 1\n                    res.append(s[j:k])\n                    i = k\n                else:\n                    i += 1\n            return res\n        def get_tree(s):\n            if not s:\n                return None\n            root = get_node(s)\n            children = get_children(s)\n            if not children:\n                return root\n            i = 0\n            while i < len(children):\n                j = i\n                while j < len(children) and get_depth(children[j]) > get_depth(children[i]):\n                    j += 1\n                root.left = get_tree(children[i])\n                if j < len(children):\n                    root.right = get_tree(children[j])\n                i = j\n            return root\n        return get_tree(traversal)"}
{"id": "1944", "path": "output2\\py\\Hard\\1944-escape-a-large-maze.py", "hypo_code": "class Solution(object):\n    def isEscapePossible(self, blocked, source, target):\n              \n        \n        return True"}
{"id": "1945", "path": "output2\\py\\Hard\\1945-longest-duplicate-substring.py", "hypo_code": "class Solution(object):\n    def longestDupSubstring(self, s):\n               \n        def get_depth(s):\n            res = 0\n            for c in s:\n                if c == '-':\n                    res += 1\n                else:\n                    break\n            return res\n        def get_val(s):\n            res = 0\n            for c in s:\n                if c == '-':\n                    break\n                else:\n                    res = res * 10 + int(c)\n            return res\n        def get_node(s):\n            return TreeNode(get_val(s))\n        def get_children(s):\n            res = []\n            i = 0\n            while i < len(s):\n                if s[i] == '-':\n                    j = i\n                    while j < len(s) and s[j] == '-':\n                        j += 1\n                    k = j\n                    while k < len(s) and s[k] != '-':\n                        k += 1\n                    res.append(s[j:k])\n                    i = k\n                else:\n                    i += 1\n            return res\n        def get_tree(s):\n            if not s:\n                return None\n            root = get_node(s)\n            children = get_children(s)\n            if not children:\n                return root\n            root.left = get_tree(children[0])\n            if len(children) > 1:\n                root.right = get_tree(children[1])\n            return root\n        return get_tree(traversal)"}
{"id": "1946", "path": "output2\\py\\Hard\\1946-number-of-submatrices-that-sum-to-target.py", "hypo_code": "class Solution(object):\n    def numSubmatrixSumTarget(self, matrix, target):\n        \n        \n        M, N = len(matrix), len(matrix[0])\n        for row in matrix:\n            for i in range(N - 1):\n                row[i + 1] += row[i]\n        result = 0\n        for i in range(N):\n            for j in range(i, N):\n                c = collections.Counter({0: 1})\n                cur = 0\n                for k in range(M):\n                    cur += matrix[k][j] - (matrix[k][i - 1] if i > 0 else 0)\n                    result += c[cur - target]\n                    c[cur] += 1\n        return result"}
{"id": "1947", "path": "output2\\py\\Hard\\1947-shortest-common-supersequence.py", "hypo_code": "class Solution(object):\n    def shortestCommonSupersequence(self, str1, str2):\n              \n        def get_lcs(str1, str2):\n            m = len(str1)\n            n = len(str2)\n            dp = [[0] * (n+1) for _ in range(m+1)]\n            for i in range(m):\n                for j in range(n):\n                    if str1[i] == str2[j]:\n                        dp[i+1][j+1] = dp[i][j] + 1\n                    else:\n                        dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])\n            res = []\n            i = m\n            j = n\n            while i > 0 and j > 0:\n                if str1[i-1] == str2[j-1]:\n                    res.append(str1[i-1])\n                    i -= 1\n                    j -= 1\n                else:\n                    if dp[i-1][j] > dp[i][j-1]:\n                        i -= 1\n                    else:\n                        j -= 1\n            return \"\".join(res[::-1])\n        \n        lcs = get_lcs(str1, str2)\n        res = []\n        i = j = k = 0\n        while k < len(lcs):\n            while i < len(str1) and str1[i] != lcs[k]:\n                res.append(str1[i])\n                i += 1\n            while j < len(str2) and str2[j] != lcs[k]:\n                res.append(str2[j])\n                j += 1\n            res.append(lcs[k])\n            i += 1\n            j += 1\n            k += 1\n        return \"\".join(res) + str1[i:] + str2[j:]"}
{"id": "1948", "path": "output2\\py\\Hard\\1948-find-in-mountain-array.py", "hypo_code": "class Solution(object):\n    def findInMountainArray(self, target, mountain_arr):"}
{"id": "1949", "path": "output2\\py\\Hard\\1949-brace-expansion-ii.py", "hypo_code": "class Solution(object):\n    def braceExpansionII(self, expression):\n                          \n\n    def main():\n        print(Solution().braceExpansionII(\"\"))"}
{"id": "1950", "path": "output2\\py\\Hard\\1950-parsing-a-boolean-expression.py", "hypo_code": "class Solution(object):\n    def parseBoolExpr(self, expression):\n        \n        \n        stack = []\n        for c in expression:\n            if c == ')':\n                seen = set()\n                while stack[-1] != '(':\n                    seen.add(stack.pop())\n                stack.pop()\n                operator = stack.pop()\n                if operator == '&':\n                    stack.append(all(seen))\n                elif operator == '|':\n                    stack.append(any(seen))\n                else:\n                    stack.append(not seen.pop())\n            elif c != ',':\n                stack.append(c)\n        return stack.pop()"}
{"id": "1951", "path": "output2\\py\\Hard\\1951-smallest-sufficient-team.py", "hypo_code": "class Solution(object):\n    def smallestSufficientTeam(self, req_skills, people):\n        \n        \n        return []"}
{"id": "1952", "path": "output2\\py\\Hard\\1952-longest-chunked-palindrome-decomposition.py", "hypo_code": "class Solution(object):\n    def longestDecomposition(self, text):\n        \n        \n        return 0"}
{"id": "1954", "path": "output2\\py\\Hard\\1954-last-substring-in-lexicographical-order.py", "hypo_code": "class Solution(object):\n    def lastSubstring(self, s):\n        \n        \n        return \"\""}
{"id": "1956", "path": "output2\\py\\Hard\\1956-number-of-valid-words-for-each-puzzle.py", "hypo_code": "class Solution(object):\n    def findNumOfValidWords(self, words, puzzles):\n        \n        \n        return []"}
{"id": "1957", "path": "output2\\py\\Hard\\1957-make-array-strictly-increasing.py", "hypo_code": "class Solution(object):\n    def makeArrayIncreasing(self, arr1, arr2):\n        \n        \n        return 0"}
{"id": "1958", "path": "output2\\py\\Hard\\1958-critical-connections-in-a-network.py", "hypo_code": "class Solution(object):\n    def criticalConnections(self, n, connections):\n        \n        \n        return []"}
{"id": "1959", "path": "output2\\py\\Hard\\1959-sort-items-by-groups-respecting-dependencies.py", "hypo_code": "class Solution(object):\n    def sortItems(self, n, m, group, beforeItems):\n              \n        def get_digits(n):\n            res = []\n            while n:\n                res.append(n % 10)\n                n /= 10\n            return res[::-1]\n        \n        def get_permutations(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            return res\n        \n        def get_permutations_without_repetitions(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            for i in range(1, k+1):\n                res /= i\n            return res\n        \n        def get_count_without_repetitions(n):\n            res = 0\n            k = len(n)\n            for i in range(1, k):\n                res += 9 * get_permutations_without_repetitions(9, i-1)\n            used = set()\n            for i in range(k):\n                for j in range(1 if i else 1, n[i]):\n                    if j not in used:\n                        res += get_permutations_without_repetitions(9-i, k-i-1)\n                if n[i] in used:\n                    break\n                used.add(n[i])\n            else:\n                res += 1\n            return res\n        \n        return n - get_count_without_repetitions(get_digits(n))"}
{"id": "1961", "path": "output2\\py\\Hard\\1961-minimum-moves-to-reach-target-with-rotations.py", "hypo_code": "class Solution(object):\n    def minimumMoves(self, grid):\n              \n        return 0"}
{"id": "1962", "path": "output2\\py\\Hard\\1962-count-vowels-permutation.py", "hypo_code": "class Solution(object):\n    def countVowelPermutation(self, n):\n              \n        def get_permutations(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            return res\n        \n        def get_permutations_without_repetitions(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            for i in range(1, k+1):\n                res /= i\n            return res\n        \n        def get_count_without_repetitions(n):\n            res = 0\n            k = len(n)\n            for i in range(1, k):\n                res += 5 * get_permutations_without_repetitions(5, i-1)\n            used = set()\n            for i in range(k):\n                for j in range(1 if i else 1, n[i]):\n                    if j not in used:\n                        res += get_permutations_without_repetitions(5-i, k-i-1)\n                if n[i] in used:\n                    break\n                used.add(n[i])\n            else:\n                res += 1\n            return res\n        \n        return get_count_without_repetitions(get_digits(n))"}
{"id": "1963", "path": "output2\\py\\Hard\\1963-dice-roll-simulation.py", "hypo_code": "class Solution(object):\n    def dieSimulator(self, n, rollMax):\n              \n        def get_permutations(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            return res\n        \n        def get_permutations_without_repetitions(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            for i in range(1, k+1):\n                res /= i\n            return res\n        \n        def get_count_without_repetitions(n):\n            res = 0\n            k = len(n)\n            for i in range(1, k):\n                res += 9 * get_permutations_without_repetitions(9, i-1)\n            used = set()\n            for i in range(k):\n                for j in range(1 if i else 1, n[i]):\n                    if j not in used:\n                        res += get_permutations_without_repetitions(9-i, k-i-1)\n                if n[i] in used:\n                    break\n                used.add(n[i])\n            else:\n                res += 1\n            return res\n        \n        return n - get_count_without_repetitions(get_digits(n))"}
{"id": "1964", "path": "output2\\py\\Hard\\1964-maximum-equal-frequency.py", "hypo_code": "class Solution(object):\n    def maxEqualFreq(self, nums):\n               \n        def get_count_without_repetitions(n):\n            res = 0\n            k = len(n)\n            for i in range(1, k):\n                res += 9 * get_permutations_without_repetitions(9, i-1)\n            used = set()\n            for i in range(k):\n                for j in range(1 if i else 1, n[i]):\n                    if j not in used:\n                        res += get_permutations_without_repetitions(9-i, k-i-1)\n                if n[i] in used:\n                    break\n                used.add(n[i])\n            else:\n                res += 1\n            return res\n        \n        return n - get_count_without_repetitions(get_digits(n))"}
{"id": "1965", "path": "output2\\py\\Hard\\1965-maximum-profit-in-job-scheduling.py", "hypo_code": "class Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \n        jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n        dp = [[0, 0]]\n        for s, e, p in jobs:\n            i = bisect.bisect(dp, [s+1]) - 1\n            if dp[i][1] + p > dp[-1][1]:\n                dp.append([e, dp[i][1] + p])\n        return dp[-1][1]"}
{"id": "1966", "path": "output2\\py\\Hard\\1966-tiling-a-rectangle-with-the-fewest-squares.py", "hypo_code": "class Solution(object):\n    def tilingRectangle(self, n, m):\n              \n        def get_digits(n):\n            res = []\n            while n:\n                res.append(n % 10)\n                n /= 10\n            return res[::-1]\n        \n        def get_permutations(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            return res\n        \n        def get_permutations_without_repetitions(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            for i in range(1, k+1):\n                res /= i\n            return res\n        \n        def get_count_without_repetitions(n):\n            res = 0\n            k = len(n)\n            for i in range(1, k):\n                res += 9 * get_permutations_without_repetitions(9, i-1)\n            used = set()\n            for i in range(k):\n                for j in range(1 if i else 1, n[i]):\n                    if j not in used:\n                        res += get_permutations_without_repetitions(9-i, k-i-1)\n                if n[i] in used:\n                    break\n                used.add(n[i])\n            else:\n                res += 1\n            return res\n        \n        return n - get_count_without_repetitions(get_digits(n))"}
{"id": "1967", "path": "output2\\py\\Hard\\1967-check-if-it-is-a-good-array.py", "hypo_code": "class Solution(object):\n    def isGoodArray(self, nums):\n             \n        \n        return True"}
{"id": "1968", "path": "output2\\py\\Hard\\1968-maximum-score-words-formed-by-letters.py", "hypo_code": "class Solution(object):\n    def maxScoreWords(self, words, letters, score):\n        \n        def get_score(word):\n            return sum(score[ord(c) - ord('a')] for c in word)\n        \n        def get_score_with_letters(word, letters):\n            letters = letters[:]\n            for c in word:\n                if c in letters:\n                    letters.remove(c)\n                else:\n                    return 0\n            return get_score(word)\n        \n        def get_score_with_letters_and_words(words, letters):\n            letters = letters[:]\n            score = 0\n            for word in words:\n                if all(c in letters for c in word):\n                    score += get_score(word)\n                    for c in word:\n                        letters.remove(c)\n                else:\n                    return 0\n            return score\n        \n        def get_max_score(words, letters):\n            if not words:\n                return 0\n            if not letters:\n                return 0\n            word = words[0]\n            score_without_word = get_max_score(words[1:], letters)\n            score_with_word = get_score_with_letters(word, letters)\n            if score_with_word:\n                score_with_word += get_max_score(words[1:], letters)\n            return max(score_without_word, score_with_word)\n        \n        def get_max_score_with_words(words, letters):\n            if not words:\n                return 0\n            if not letters:\n                return 0\n            word = words[0]\n            score_without_word = get_max_score_with_words(words[1:], letters)\n            score_with_word = get_score_with_letters_and_words([word], letters)\n            if score_with_word:\n                score_with_word += get_max_score_with_words(words[1:], letters)\n            return max(score_without_word, score_with_word)\n        \n        return get_max_score_with_words(words, letters)"}
{"id": "1969", "path": "output2\\py\\Hard\\1969-minimum-moves-to-move-a-box-to-their-target-location.py", "hypo_code": "class Solution(object):\n    def minPushBox(self, grid):\n               \n        return 0"}
{"id": "1970", "path": "output2\\py\\Hard\\1970-number-of-ways-to-stay-in-the-same-place-after-some-steps.py", "hypo_code": "class Solution(object):\n    def numWays(self, steps, arrLen):\n        \n            \n        def get_permutations(n, k):\n                res = 1\n                for i in range(n, n-k, -1):\n                    res *= i\n                return res\n            \n        def get_permutations_without_repetitions(n, k):\n                res = 1\n                for i in range(n, n-k, -1):\n                    res *= i\n                for i in range(1, k+1):\n                    res /= i\n                return res\n            \n        def get_count_without_repetitions(n):\n                res = 0\n                k = len(n)\n                for i in range(1, k):\n                    res += 5 * get_permutations_without_repetitions(5, i-1)\n                used = set()\n                for i in range(k):\n                    for j in range(1 if i else 1, n[i]):\n                        if j not in used:\n                            res += get_permutations_without_repetitions(5-i, k-i-1)\n                    if n[i] in used:\n                        break\n                    used.add(n[i])\n                else:\n                    res += 1\n                return res\n            \n        return get_count_without_repetitions(get_digits(n))"}
{"id": "1971", "path": "output2\\py\\Hard\\1971-palindrome-partitioning-iii.py", "hypo_code": "class Solution(object):\n    def palindromePartition(self, s, k):\n              \n        def get_depth(s):\n            res = 0\n            for c in s:\n                if c == '-':\n                    res += 1\n                else:\n                    break\n            return res\n        def get_val(s):\n            res = 0\n            for c in s:\n                if c == '-':\n                    break\n                else:\n                    res = res * 10 + int(c)\n            return res\n        def get_node(s):\n            return TreeNode(get_val(s))\n        def get_children(s):\n            res = []\n            i = 0\n            while i < len(s):\n                if s[i] == '-':\n                    j = i\n                    while j < len(s) and s[j] == '-':\n                        j += 1\n                    k = j\n                    while k < len(s) and s[k] != '-':\n                        k += 1\n                    res.append(s[j:k])\n                    i = k\n                else:\n                    i += 1\n            return res\n        def get_tree(s):\n            if not s:\n                return None\n            root = get_node(s)\n            children = get_children(s)\n            if not children:\n                return root\n            root.left = get_tree(children[0])\n            if len(children) > 1:\n                root.right = get_tree(children[1])\n            return root\n        return get_tree(traversal)"}
{"id": "1972", "path": "output2\\py\\Hard\\1972-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.py", "hypo_code": "class Solution(object):\n    def minFlips(self, mat):\n        \n            \n        return 0"}
{"id": "1973", "path": "output2\\py\\Hard\\1973-minimum-falling-path-sum-ii.py", "hypo_code": "class Solution(object):\n    def minFallingPathSum(self, grid):\n                \n        return 0"}
{"id": "1974", "path": "output2\\py\\Hard\\1974-shortest-path-in-a-grid-with-obstacles-elimination.py", "hypo_code": "class Solution(object):\n    def shortestPath(self, grid, k):\n               \n        return 0"}
{"id": "1975", "path": "output2\\py\\Hard\\1975-maximum-candies-you-can-get-from-boxes.py", "hypo_code": "class Solution(object):\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        \n        return 0"}
{"id": "1976", "path": "output2\\py\\Hard\\1976-number-of-paths-with-max-score.py", "hypo_code": "class Solution(object):\n    def pathsWithMaxScore(self, board):\n               \n        return 0"}
{"id": "1977", "path": "output2\\py\\Hard\\1977-verbal-arithmetic-puzzle.py", "hypo_code": "class Solution(object):\n    def isSolvable(self, words, result):\n              \n        def get_digits(n):\n            res = []\n            while n:\n                res.append(n % 10)\n                n /= 10\n            return res[::-1]\n        \n        def get_permutations(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            return res\n        \n        def get_permutations_without_repetitions(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            for i in range(1, k+1):\n                res /= i\n            return res\n        \n        def get_count_without_repetitions(n):\n            res = 0\n            k = len(n)\n            for i in range(1, k):\n                res += 9 * get_permutations_without_repetitions(9, i-1)\n            used = set()\n            for i in range(k):\n                for j in range(1 if i else 1, n[i]):\n                    if j not in used:\n                        res += get_permutations_without_repetitions(9-i, k-i-1)\n                if n[i] in used:\n                    break\n                used.add(n[i])\n            else:\n                res += 1\n            return res\n        \n        return n - get_count_without_repetitions(get_digits(n))"}
{"id": "1978", "path": "output2\\py\\Hard\\1978-minimum-insertion-steps-to-make-a-string-palindrome.py", "hypo_code": "class Solution(object):\n    def minInsertions(self, s):\n         \n        return 0"}
{"id": "1979", "path": "output2\\py\\Hard\\1979-distinct-echo-substrings.py", "hypo_code": "class Solution(object):\n    def distinctEchoSubstrings(self, text):\n        \n        return 0"}
{"id": "1980", "path": "output2\\py\\Hard\\1980-minimum-distance-to-type-a-word-using-two-fingers.py", "hypo_code": "class Solution(object):\n    def minimumDistance(self, word):\n               \n        return 0"}
{"id": "1981", "path": "output2\\py\\Hard\\1981-minimum-number-of-taps-to-open-to-water-a-garden.py", "hypo_code": "class Solution(object):\n    def minTaps(self, n, ranges):\n               \n        return 0"}
{"id": "1982", "path": "output2\\py\\Hard\\1982-reverse-subarray-to-maximize-array-value.py", "hypo_code": "class Solution(object):\n    def maxValueAfterReverse(self, nums):\n        \n        return 0"}
{"id": "1983", "path": "output2\\py\\Hard\\1983-minimum-difficulty-of-a-job-schedule.py", "hypo_code": "class Solution(object):\n    def minDifficulty(self, jobDifficulty, d):\n              \n        \n        return 0"}
{"id": "1984", "path": "output2\\py\\Hard\\1984-jump-game-v.py", "hypo_code": "class Solution(object):\n    def maxJumps(self, arr, d):\n                               \n        return 0"}
{"id": "1985", "path": "output2\\py\\Hard\\1985-jump-game-iv.py", "hypo_code": "class Solution(object):\n    def minJumps(self, arr):\n         \n        return 0"}
{"id": "1986", "path": "output2\\py\\Hard\\1986-maximum-students-taking-exam.py", "hypo_code": "class Solution(object):\n    def maxStudents(self, seats):\n         \n        return 0"}
{"id": "1987", "path": "output2\\py\\Hard\\1987-construct-target-array-with-multiple-sums.py", "hypo_code": "class Solution(object):\n    def isPossible(self, target):\n         \n        return False"}
{"id": "1988", "path": "output2\\py\\Hard\\1988-count-all-valid-pickup-and-delivery-options.py", "hypo_code": "class Solution(object):\n    def countOrders(self, n):\n         \n        return 0"}
{"id": "1989", "path": "output2\\py\\Hard\\1989-largest-multiple-of-three.py", "hypo_code": "class Solution(object):\n    def largestMultipleOfThree(self, digits):\n         \n        return \"\""}
{"id": "1990", "path": "output2\\py\\Hard\\1990-minimum-cost-to-make-at-least-one-valid-path-in-a-grid.py", "hypo_code": "class Solution(object):\n    def minCost(self, grid):\n         \n        return 0"}
{"id": "1991", "path": "output2\\py\\Hard\\1991-maximum-sum-bst-in-binary-tree.py", "hypo_code": "class Solution(object):\n    def maxSumBST(self, root):\n         \n        return 0"}
{"id": "1992", "path": "output2\\py\\Hard\\1992-frog-position-after-t-seconds.py", "hypo_code": "class Solution(object):\n    def frogPosition(self, n, edges, t, target):\n                              \n        return 0"}
{"id": "1993", "path": "output2\\py\\Hard\\1993-maximum-performance-of-a-team.py", "hypo_code": "class Solution(object):\n    def maxPerformance(self, n, speed, efficiency, k):\n              \n        return 0"}
{"id": "1994", "path": "output2\\py\\Hard\\1994-pizza-with-3n-slices.py", "hypo_code": "class Solution(object):\n    def maxSizeSlices(self, slices):\n         \n        return 0"}
{"id": "1995", "path": "output2\\py\\Hard\\1995-longest-happy-prefix.py", "hypo_code": "class Solution(object):\n    def longestPrefix(self, s):\n        \n            \n        return \"\""}
{"id": "1996", "path": "output2\\py\\Hard\\1996-find-all-good-strings.py", "hypo_code": "class Solution(object):\n    def findGoodStrings(self, n, s1, s2, evil):\n        \n            \n        return 0"}
{"id": "1997", "path": "output2\\py\\Hard\\1997-reducing-dishes.py", "hypo_code": "class Solution(object):\n    def maxSatisfaction(self, satisfaction):\n         \n        return 0"}
{"id": "1998", "path": "output2\\py\\Hard\\1998-stone-game-iii.py", "hypo_code": "class Solution(object):\n    def stoneGameIII(self, stoneValue):\n         \n        return \"\""}
{"id": "1999", "path": "output2\\py\\Hard\\1999-number-of-ways-to-paint-n-3-grid.py", "hypo_code": "class Solution(object):\n    def numOfWays(self, n):\n        \n        \n        return 0"}
{"id": "2000", "path": "output2\\py\\Hard\\2000-restore-the-array.py", "hypo_code": "class Solution(object):\n    def numberOfArrays(self, s, k):\n         \n        return 0"}
{"id": "2001", "path": "output2\\py\\Hard\\2001-build-array-where-you-can-find-the-maximum-exactly-k-comparisons.py", "hypo_code": "class Solution(object):\n    def numOfArrays(self, n, m, k):\n        \n        \n        return 0"}
{"id": "2002", "path": "output2\\py\\Hard\\2002-constrained-subsequence-sum.py", "hypo_code": "class Solution(object):\n    def constrainedSubsetSum(self, nums, k):\n         \n        return 0"}
{"id": "2003", "path": "output2\\py\\Hard\\2003-number-of-ways-to-wear-different-hats-to-each-other.py", "hypo_code": "class Solution(object):\n    def numberWays(self, hats):\n             \n        return 0"}
{"id": "2004", "path": "output2\\py\\Hard\\2004-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows.py", "hypo_code": "class Solution(object):\n    def kthSmallest(self, mat, k):\n         \n        return 0"}
{"id": "2005", "path": "output2\\py\\Hard\\2005-number-of-ways-of-cutting-a-pizza.py", "hypo_code": "class Solution(object):\n    def ways(self, pizza, k):\n             \n        return 0"}
{"id": "2006", "path": "output2\\py\\Hard\\2006-form-largest-integer-with-digits-that-add-up-to-target.py", "hypo_code": "class Solution(object):\n    def largestNumber(self, cost, target):\n             \n        return \"\""}
{"id": "2007", "path": "output2\\py\\Hard\\2007-maximum-number-of-darts-inside-of-a-circular-dartboard.py", "hypo_code": "class Solution(object):\n    def numPoints(self, darts, r):\n        \n        return 0"}
{"id": "2008", "path": "output2\\py\\Hard\\2008-max-dot-product-of-two-subsequences.py", "hypo_code": "class Solution(object):\n    def maxDotProduct(self, nums1, nums2):\n        \n            \n        return 0"}
{"id": "2009", "path": "output2\\py\\Hard\\2009-cherry-pickup-ii.py", "hypo_code": "class Solution(object):\n    def cherryPickup(self, grid):\n               \n        return 0"}
{"id": "2010", "path": "output2\\py\\Hard\\2010-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls.py", "hypo_code": "class Solution(object):\n    def getProbability(self, balls):\n         \n        return 0"}
{"id": "2011", "path": "output2\\py\\Hard\\2011-paint-house-iii.py", "hypo_code": "class Solution(object):\n    def minCost(self, houses, cost, m, n, target):\n        \n        return 0"}
{"id": "2012", "path": "output2\\py\\Hard\\2012-allocate-mailboxes.py", "hypo_code": "class Solution(object):\n    def minDistance(self, houses, k):\n        \n            \n        return 0"}
{"id": "2014", "path": "output2\\py\\Hard\\2014-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree.py", "hypo_code": "class Solution(object):\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\n            \n        return []"}
{"id": "2015", "path": "output2\\py\\Hard\\2015-parallel-courses-ii.py", "hypo_code": "class Solution(object):\n    def minNumberOfSemesters(self, n, relations, k):\n            \n        return 0"}
{"id": "2016", "path": "output2\\py\\Hard\\2016-max-value-of-equation.py", "hypo_code": "class Solution(object):\n    def findMaxValueOfEquation(self, points, k):\n        \n            \n        return 0"}
{"id": "2017", "path": "output2\\py\\Hard\\2017-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits.py", "hypo_code": "class Solution(object):\n    def minInteger(self, num, k):\n        \n            \n        return \"\""}
{"id": "2018", "path": "output2\\py\\Hard\\2018-stone-game-iv.py", "hypo_code": "class Solution(object):\n    def winnerSquareGame(self, n):\n         \n        return False"}
{"id": "2019", "path": "output2\\py\\Hard\\2019-best-position-for-a-service-centre.py", "hypo_code": "class Solution(object):\n    def getMinDistSum(self, positions):\n        \n        \n        return 0"}
{"id": "2020", "path": "output2\\py\\Hard\\2020-maximum-number-of-non-overlapping-substrings.py", "hypo_code": "class Solution(object):\n    def maxNumOfSubstrings(self, s):\n         \n        return 0"}
{"id": "2021", "path": "output2\\py\\Hard\\2021-find-a-value-of-a-mysterious-function-closest-to-target.py", "hypo_code": "class Solution(object):\n    def closestToTarget(self, arr, target):\n        \n        \n        return 0"}
{"id": "2022", "path": "output2\\py\\Hard\\2022-minimum-number-of-increments-on-subarrays-to-form-a-target-array.py", "hypo_code": "class Solution(object):\n    def minNumberOperations(self, target):\n         \n        return 0"}
{"id": "2023", "path": "output2\\py\\Hard\\2023-string-compression-ii.py", "hypo_code": "class Solution(object):\n    def getLengthOfOptimalCompression(self, s, k):\n         \n        return 0"}
{"id": "2024", "path": "output2\\py\\Hard\\2024-get-the-maximum-score.py", "hypo_code": "class Solution(object):\n    def maxSum(self, nums1, nums2):\n        \n        return 0"}
{"id": "2025", "path": "output2\\py\\Hard\\2025-find-longest-awesome-substring.py", "hypo_code": "class Solution(object):\n    def longestAwesome(self, s):\n        \n        return 0"}
{"id": "2026", "path": "output2\\py\\Hard\\2026-minimum-cost-to-cut-a-stick.py", "hypo_code": "class Solution(object):\n    def minCost(self, n, cuts):\n        \n        \n        return 0"}
{"id": "2027", "path": "output2\\py\\Hard\\2027-minimum-number-of-days-to-eat-n-oranges.py", "hypo_code": "class Solution(object):\n    def minDays(self, n):\n        \n        return 0"}
{"id": "2028", "path": "output2\\py\\Hard\\2028-stone-game-v.py", "hypo_code": "class Solution(object):\n    def stoneGameV(self, stoneValue):\n        \n        return 0"}
{"id": "2029", "path": "output2\\py\\Hard\\2029-minimum-number-of-days-to-disconnect-island.py", "hypo_code": "class Solution(object):\n    def minDays(self, grid):\n        \n        return 0"}
{"id": "2030", "path": "output2\\py\\Hard\\2030-number-of-ways-to-reorder-array-to-get-same-bst.py", "hypo_code": "class Solution(object):\n    def numOfWays(self, nums):\n        \n        return 0"}
{"id": "2031", "path": "output2\\py\\Hard\\2031-count-all-possible-routes.py", "hypo_code": "class Solution(object):\n    def countRoutes(self, locations, start, finish, fuel):\n         \n        return 0"}
{"id": "2032", "path": "output2\\py\\Hard\\2032-remove-max-number-of-edges-to-keep-graph-fully-traversable.py", "hypo_code": "class Solution(object):\n    def maxNumEdgesToRemove(self, n, edges):\n               \n        return 0"}
{"id": "2033", "path": "output2\\py\\Hard\\2033-check-if-string-is-transformable-with-substring-sort-operations.py", "hypo_code": "class Solution(object):\n    def isTransformable(self, s, t):\n        \n            \n        return 0"}
{"id": "2034", "path": "output2\\py\\Hard\\2034-strange-printer-ii.py", "hypo_code": "class Solution(object):\n    def isPrintable(self, targetGrid):\n               \n        return 0"}
{"id": "2035", "path": "output2\\py\\Hard\\2035-minimum-cost-to-connect-two-groups-of-points.py", "hypo_code": "class Solution(object):\n    def connectTwoGroups(self, cost):\n         \n        return 0"}
{"id": "2036", "path": "output2\\py\\Hard\\2036-maximum-number-of-achievable-transfer-requests.py", "hypo_code": "class Solution(object):\n    def maximumRequests(self, n, requests):\n              \n        return 0"}
{"id": "2037", "path": "output2\\py\\Hard\\2037-find-servers-that-handled-most-number-of-requests.py", "hypo_code": "class Solution(object):\n    def busiestServers(self, k, arrival, load):\n               \n        return []"}
{"id": "2038", "path": "output2\\py\\Hard\\2038-maximum-number-of-visible-points.py", "hypo_code": "class Solution(object):\n    def visiblePoints(self, points, angle, location):\n               \n        return 0"}
{"id": "2039", "path": "output2\\py\\Hard\\2039-minimum-one-bit-operations-to-make-integers-zero.py", "hypo_code": "class Solution(object):\n    def minimumOneBitOperations(self, n):\n        \n        return 0"}
{"id": "2040", "path": "output2\\py\\Hard\\2040-count-subtrees-with-max-distance-between-cities.py", "hypo_code": "class Solution(object):\n    def countSubgraphsForEachDiameter(self, n, edges):\n        \n        return 0"}
{"id": "2042", "path": "output2\\py\\Hard\\2042-graph-connectivity-with-threshold.py", "hypo_code": "class Solution(object):\n    def areConnected(self, n, threshold, queries):\n        \n        return []"}
{"id": "2043", "path": "output2\\py\\Hard\\2043-rank-transform-of-a-matrix.py", "hypo_code": "class Solution(object):\n    def matrixRankTransform(self, matrix):\n               \n        return 0"}
{"id": "2044", "path": "output2\\py\\Hard\\2044-number-of-ways-to-form-a-target-string-given-a-dictionary.py", "hypo_code": "class Solution(object):\n    def numWays(self, words, target):\n         \n        return 0"}
{"id": "2045", "path": "output2\\py\\Hard\\2045-kth-smallest-instructions.py", "hypo_code": "class Solution(object):\n    def kthSmallestPath(self, destination, k):\n        \n            \n        return 0"}
{"id": "2046", "path": "output2\\py\\Hard\\2046-create-sorted-array-through-instructions.py", "hypo_code": "class Solution(object):\n    def createSortedArray(self, instructions):\n        \n        \n        return 0"}
{"id": "2047", "path": "output2\\py\\Hard\\2047-distribute-repeating-integers.py", "hypo_code": "class Solution(object):\n    def canDistribute(self, nums, quantity):\n        \n        return 0"}
{"id": "2048", "path": "output2\\py\\Hard\\2048-maximize-grid-happiness.py", "hypo_code": "class Solution(object):\n    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):\n              \n        return 0"}
{"id": "2049", "path": "output2\\py\\Hard\\2049-minimum-initial-energy-to-finish-tasks.py", "hypo_code": "class Solution(object):\n    def minimumEffort(self, tasks):\n         \n        return 0"}
{"id": "2050", "path": "output2\\py\\Hard\\2050-minimum-number-of-removals-to-make-mountain-array.py", "hypo_code": "class Solution(object):\n    def minimumMountainRemovals(self, nums):\n        \n        return 0"}
{"id": "2051", "path": "output2\\py\\Hard\\2051-minimize-deviation-in-array.py", "hypo_code": "class Solution(object):\n    def minimumDeviation(self, nums):\n        \n        return 0"}
{"id": "2052", "path": "output2\\py\\Hard\\2052-minimum-incompatibility.py", "hypo_code": "class Solution(object):\n    def minimumIncompatibility(self, nums, k):\n        \n        return 0"}
{"id": "2053", "path": "output2\\py\\Hard\\2053-delivering-boxes-from-storage-to-ports.py", "hypo_code": "class Solution(object):\n    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):\n        \n        return 0"}
{"id": "2054", "path": "output2\\py\\Hard\\2054-maximum-height-by-stacking-cuboids.py", "hypo_code": "class Solution(object):\n    def maxHeight(self, cuboids):\n        \n        return 0"}
{"id": "2055", "path": "output2\\py\\Hard\\2055-checking-existence-of-edge-length-limited-paths.py", "hypo_code": "class Solution(object):\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\n        \n        return []"}
{"id": "2056", "path": "output2\\py\\Hard\\2056-minimum-adjacent-swaps-for-k-consecutive-ones.py", "hypo_code": "class Solution(object):\n    def minMoves(self, nums, k):\n        \n        return 0"}
{"id": "2057", "path": "output2\\py\\Hard\\2057-maximum-xor-with-an-element-from-array.py", "hypo_code": "class Solution(object):\n    def maximizeXor(self, nums, queries):\n        \n        return 0"}
{"id": "2058", "path": "output2\\py\\Hard\\2058-minimum-operations-to-make-a-subsequence.py", "hypo_code": "class Solution(object):\n    def minOperations(self, target, arr):\n        \n        return 0"}
{"id": "2059", "path": "output2\\py\\Hard\\2059-number-of-ways-to-reconstruct-a-tree.py", "hypo_code": "class Solution(object):\n    def checkWays(self, pairs):\n        \n        return 0"}
{"id": "2060", "path": "output2\\py\\Hard\\2060-find-minimum-time-to-finish-all-jobs.py", "hypo_code": "class Solution(object):\n    def minimumTimeRequired(self, jobs, k):\n        \n        return 0"}
{"id": "2061", "path": "output2\\py\\Hard\\2061-cat-and-mouse-ii.py", "hypo_code": "class Solution(object):\n    def canMouseWin(self, grid, catJump, mouseJump):\n        \n            \n        return False"}
{"id": "2062", "path": "output2\\py\\Hard\\2062-count-ways-to-make-array-with-product.py", "hypo_code": "class Solution(object):\n    def waysToFillArray(self, queries):\n        \n        return 0"}
{"id": "2063", "path": "output2\\py\\Hard\\2063-building-boxes.py", "hypo_code": "class Solution(object):\n    def minimumBoxes(self, n):\n               \n        return 0"}
{"id": "2064", "path": "output2\\py\\Hard\\2064-palindrome-partitioning-iv.py", "hypo_code": "class Solution(object):\n    def checkPartitioning(self, s):\n               \n        return False"}
{"id": "2065", "path": "output2\\py\\Hard\\2065-maximum-number-of-events-that-can-be-attended-ii.py", "hypo_code": "class Solution(object):\n    def maxValue(self, events, k):\n        \n        return 0"}
{"id": "2066", "path": "output2\\py\\Hard\\2066-closest-subsequence-sum.py", "hypo_code": "class Solution(object):\n    def minAbsDifference(self, nums, goal):\n        \n        return 0"}
{"id": "2067", "path": "output2\\py\\Hard\\2067-minimum-degree-of-a-connected-trio-in-a-graph.py", "hypo_code": "class Solution(object):\n    def minTrioDegree(self, n, edges):\n        \n        return 0"}
{"id": "2068", "path": "output2\\py\\Hard\\2068-tree-of-coprimes.py", "hypo_code": "class Solution(object):\n    def getCoprimes(self, nums, edges):\n                                \n        return []"}
{"id": "2069", "path": "output2\\py\\Hard\\2069-maximum-score-from-performing-multiplication-operations.py", "hypo_code": "class Solution(object):\n    def maximumScore(self, nums, multipliers):\n        \n        return 0"}
{"id": "2070", "path": "output2\\py\\Hard\\2070-maximize-palindrome-length-from-subsequences.py", "hypo_code": "class Solution(object):\n    def longestPalindrome(self, word1, word2):\n        \n        return 0"}
{"id": "2071", "path": "output2\\py\\Hard\\2071-car-fleet-ii.py", "hypo_code": "class Solution(object):\n    def getCollisionTimes(self, cars):\n        \n        return 0"}
{"id": "2072", "path": "output2\\py\\Hard\\2072-count-pairs-of-nodes.py", "hypo_code": "class Solution(object):\n    def countPairs(self, n, edges, queries):\n        \n        return 0"}
{"id": "2073", "path": "output2\\py\\Hard\\2073-make-the-xor-of-all-segments-equal-to-zero.py", "hypo_code": "class Solution(object):\n    def minChanges(self, nums, k):\n        \n        return 0"}
{"id": "2074", "path": "output2\\py\\Hard\\2074-maximum-score-of-a-good-subarray.py", "hypo_code": "class Solution(object):\n    def maximumScore(self, nums, k):\n        \n        return 0"}
{"id": "2075", "path": "output2\\py\\Hard\\2075-maximize-score-after-n-operations.py", "hypo_code": "class Solution(object):\n    def maxScore(self, nums):\n        \n        return 0"}
{"id": "2076", "path": "output2\\py\\Hard\\2076-count-pairs-with-xor-in-a-range.py", "hypo_code": "class Solution(object):\n    def countPairs(self, nums, low, high):\n               \n        return 0"}
{"id": "2077", "path": "output2\\py\\Hard\\2077-maximize-number-of-nice-divisors.py", "hypo_code": "class Solution(object):\n    def maxNiceDivisors(self, primeFactors):\n               \n        return 0"}
{"id": "2078", "path": "output2\\py\\Hard\\2078-maximum-number-of-groups-getting-fresh-donuts.py", "hypo_code": "class Solution(object):\n    def maxHappyGroups(self, batchSize, groups):\n        \n        return 0"}
{"id": "2079", "path": "output2\\py\\Hard\\2079-number-of-different-subsequences-gcds.py", "hypo_code": "class Solution(object):\n    def countDifferentSubsequenceGCDs(self, nums):\n        \n        return 0"}
{"id": "2081", "path": "output2\\py\\Hard\\2081-minimum-number-of-operations-to-make-string-sorted.py", "hypo_code": "class Solution(object):\n    def makeStringSorted(self, s):\n              \n        return 0"}
{"id": "2082", "path": "output2\\py\\Hard\\2082-find-xor-sum-of-all-pairs-bitwise-and.py", "hypo_code": "class Solution(object):\n    def getXORSum(self, arr1, arr2):\n        \n        return 0"}
{"id": "2083", "path": "output2\\py\\Hard\\2083-maximum-building-height.py", "hypo_code": "class Solution(object):\n    def maxBuilding(self, n, restrictions):\n        \n        return 0"}
{"id": "2084", "path": "output2\\py\\Hard\\2084-closest-room.py", "hypo_code": "class Solution(object):\n    def closestRoom(self, rooms, queries):\n        \n        return 0"}
{"id": "2085", "path": "output2\\py\\Hard\\2085-minimum-interval-to-include-each-query.py", "hypo_code": "class Solution(object):\n    def minInterval(self, intervals, queries):\n        \n        return 0"}
{"id": "2086", "path": "output2\\py\\Hard\\2086-largest-color-value-in-a-directed-graph.py", "hypo_code": "class Solution(object):\n    def largestPathValue(self, colors, edges):\n        \n        return 0"}
{"id": "2087", "path": "output2\\py\\Hard\\2087-sum-of-floored-pairs.py", "hypo_code": "class Solution(object):\n    def sumOfFlooredPairs(self, nums):\n        \n        return 0"}
{"id": "2088", "path": "output2\\py\\Hard\\2088-number-of-ways-to-rearrange-sticks-with-k-sticks-visible.py", "hypo_code": "class Solution(object):\n    def rearrangeSticks(self, n, k):\n              \n        return 0"}
{"id": "2089", "path": "output2\\py\\Hard\\2089-stone-game-viii.py", "hypo_code": "class Solution(object):\n    def stoneGameVIII(self, stones):\n        \n        return 0"}
{"id": "2090", "path": "output2\\py\\Hard\\2090-minimum-xor-sum-of-two-arrays.py", "hypo_code": "class Solution(object):\n    def minimumXORSum(self, nums1, nums2):\n        \n        return 0"}
{"id": "2091", "path": "output2\\py\\Hard\\2091-minimum-skips-to-arrive-at-meeting-on-time.py", "hypo_code": "class Solution(object):\n    def minSkips(self, dist, speed, hoursBefore):\n        \n        return 0"}
{"id": "2092", "path": "output2\\py\\Hard\\2092-minimum-space-wasted-from-packaging.py", "hypo_code": "class Solution(object):\n    def minWastedSpace(self, packages, boxes):\n        \n            \n        return 0"}
{"id": "2093", "path": "output2\\py\\Hard\\2093-minimum-cost-to-change-the-final-value-of-expression.py", "hypo_code": "class Solution(object):\n    def minOperationsToFlip(self, expression):\n        \n            \n        return 0"}
{"id": "2094", "path": "output2\\py\\Hard\\2094-the-earliest-and-latest-rounds-where-players-compete.py", "hypo_code": "class Solution(object):\n    def earliestAndLatest(self, n, firstPlayer, secondPlayer):\n        \n        return 0"}
{"id": "2096", "path": "output2\\py\\Hard\\2096-count-ways-to-build-rooms-in-an-ant-colony.py", "hypo_code": "class Solution(object):\n    def waysToBuildRooms(self, prevRoom):\n        \n        return 0"}
{"id": "2097", "path": "output2\\py\\Hard\\2097-longest-common-subpath.py", "hypo_code": "class Solution(object):\n    def longestCommonSubpath(self, n, paths):\n        \n        return 0"}
{"id": "2098", "path": "output2\\py\\Hard\\2098-minimum-cost-to-reach-destination-in-time.py", "hypo_code": "class Solution(object):\n    def minCost(self, maxTime, edges, passingFees):\n        \n        return 0"}
{"id": "2099", "path": "output2\\py\\Hard\\2099-painting-a-grid-with-three-different-colors.py", "hypo_code": "class Solution(object):\n    def colorTheGrid(self, m, n):\n        \n        return 0"}
{"id": "2100", "path": "output2\\py\\Hard\\2100-merge-bsts-to-create-single-bst.py", "hypo_code": "class Solution(object):\n    def canMerge(self, trees):\n        \n        return None"}
{"id": "2101", "path": "output2\\py\\Hard\\2101-maximum-genetic-difference-query.py", "hypo_code": "class Solution(object):\n    def maxGeneticDifference(self, parents, queries):\n        \n        return 0"}
{"id": "2102", "path": "output2\\py\\Hard\\2102-number-of-visible-people-in-a-queue.py", "hypo_code": "class Solution(object):\n    def canSeePersonsCount(self, heights):\n        \n        return 0"}
{"id": "2103", "path": "output2\\py\\Hard\\2103-delete-duplicate-folders-in-system.py", "hypo_code": "class Solution(object):\n    def deleteDuplicateFolder(self, paths):\n        \n        return 0"}
{"id": "2104", "path": "output2\\py\\Hard\\2104-count-number-of-special-subsequences.py", "hypo_code": "class Solution(object):\n    def countSpecialSubsequences(self, nums):\n         \n        return 0"}
{"id": "2105", "path": "output2\\py\\Hard\\2105-maximum-product-of-the-length-of-two-palindromic-substrings.py", "hypo_code": "class Solution(object):\n    def maxProduct(self, s):\n        \n        return 0"}
{"id": "2106", "path": "output2\\py\\Hard\\2106-find-the-longest-valid-obstacle-course-at-each-position.py", "hypo_code": "class Solution(object):\n    def longestObstacleCourseAtEachPosition(self, obstacles):\n        \n        return 0"}
{"id": "2107", "path": "output2\\py\\Hard\\2107-last-day-where-you-can-still-cross.py", "hypo_code": "class Solution(object):\n    def latestDayToCross(self, row, col, cells):\n        \n        return 0"}
{"id": "2108", "path": "output2\\py\\Hard\\2108-number-of-ways-to-separate-numbers.py", "hypo_code": "class Solution(object):\n    def numberOfCombinations(self, num):\n        \n        return 0"}
{"id": "2109", "path": "output2\\py\\Hard\\2109-find-array-given-subset-sums.py", "hypo_code": "class Solution(object):\n    def recoverArray(self, n, sums):\n        \n        return 0"}
{"id": "2110", "path": "output2\\py\\Hard\\2110-number-of-unique-good-subsequences.py", "hypo_code": "class Solution(object):\n    def numberOfUniqueGoodSubsequences(self, binary):\n        \n        return 0"}
{"id": "2111", "path": "output2\\py\\Hard\\2111-the-number-of-good-subsets.py", "hypo_code": "class Solution(object):\n    def numberOfGoodSubsets(self, nums):\n        \n        return 0"}
{"id": "2112", "path": "output2\\py\\Hard\\2112-gcd-sort-of-an-array.py", "hypo_code": "class Solution(object):\n    def gcdSort(self, nums):\n        \n        return 0"}
{"id": "2113", "path": "output2\\py\\Hard\\2113-smallest-missing-genetic-value-in-each-subtree.py", "hypo_code": "class Solution(object):\n    def smallestMissingValueSubtree(self, parents, nums):\n               \n        return 0"}
{"id": "2114", "path": "output2\\py\\Hard\\2114-minimum-number-of-operations-to-make-array-continuous.py", "hypo_code": "class Solution(object):\n    def minOperations(self, nums):\n        \n        nums = sorted(list(set(nums)))\n        n = len(nums)\n        if n < 2:\n            return 0\n        max_len = 1\n        for i in range(n - 1):\n            j = i + 1\n            while j < n and nums[j] - nums[i] < n:\n                j += 1\n            if j - i > max_len:\n                max_len = j - i\n        return n - max_len"}
{"id": "2115", "path": "output2\\py\\Hard\\2115-longest-subsequence-repeated-k-times.py", "hypo_code": "class Solution(object):\n    def longestSubsequenceRepeatedK(self, s, k):\n        \n            \n        return \"\""}
{"id": "2116", "path": "output2\\py\\Hard\\2116-the-score-of-students-solving-math-expression.py", "hypo_code": "class Solution(object):\n    def scoreOfStudents(self, s, answers):\n        \n        return 0"}
{"id": "2117", "path": "output2\\py\\Hard\\2117-maximum-number-of-ways-to-partition-an-array.py", "hypo_code": "class Solution(object):\n    def waysToPartition(self, nums, k):\n        \n        return 0"}
{"id": "2118", "path": "output2\\py\\Hard\\2118-smallest-k-length-subsequence-with-occurrences-of-a-letter.py", "hypo_code": "class Solution(object):\n    def smallestSubsequence(self, s, k, letter, repetition):\n        \n            \n        return \"\""}
{"id": "2119", "path": "output2\\py\\Hard\\2119-partition-array-into-two-arrays-to-minimize-sum-difference.py", "hypo_code": "class Solution(object):\n    def minimumDifference(self, nums):\n        \n        return 0"}
{"id": "2120", "path": "output2\\py\\Hard\\2120-kth-smallest-product-of-two-sorted-arrays.py", "hypo_code": "class Solution(object):\n    def kthSmallestProduct(self, nums1, nums2, k):\n        \n        return 0"}
{"id": "2121", "path": "output2\\py\\Hard\\2121-second-minimum-time-to-reach-destination.py", "hypo_code": "class Solution(object):\n    def secondMinimum(self, n, edges, time, change):\n                \n        return 0"}
{"id": "2122", "path": "output2\\py\\Hard\\2122-parallel-courses-iii.py", "hypo_code": "class Solution(object):\n    def minimumTime(self, n, relations, time):\n        \n        return 0"}
{"id": "2123", "path": "output2\\py\\Hard\\2123-number-of-valid-move-combinations-on-chessboard.py", "hypo_code": "class Solution(object):\n    def countCombinations(self, pieces, positions):\n               \n        return 0"}
{"id": "2124", "path": "output2\\py\\Hard\\2124-check-if-an-original-string-exists-given-two-encoded-strings.py", "hypo_code": "class Solution(object):\n    def possiblyEquals(self, s1, s2):\n        \n        return False"}
{"id": "2125", "path": "output2\\py\\Hard\\2125-maximum-path-quality-of-a-graph.py", "hypo_code": "class Solution(object):\n    def maximalPathQuality(self, values, edges, maxTime):\n        \n        return 0"}
{"id": "2126", "path": "output2\\py\\Hard\\2126-maximum-number-of-tasks-you-can-assign.py", "hypo_code": "class Solution(object):\n    def maxTaskAssign(self, tasks, workers, pills, strength):\n        \n        return 0"}
{"id": "2127", "path": "output2\\py\\Hard\\2127-process-restricted-friend-requests.py", "hypo_code": "class Solution(object):\n    def friendRequests(self, n, restrictions, requests):\n        \n        return 0"}
{"id": "2128", "path": "output2\\py\\Hard\\2128-sum-of-k-mirror-numbers.py", "hypo_code": "class Solution(object):\n    def kMirror(self, k, n):\n        \n        return 0"}
{"id": "2129", "path": "output2\\py\\Hard\\2129-count-fertile-pyramids-in-a-land.py", "hypo_code": "class Solution(object):\n    def countPyramids(self, grid):\n        \n        return 0"}
{"id": "2130", "path": "output2\\py\\Hard\\2130-find-all-people-with-secret.py", "hypo_code": "class Solution(object):\n    def findAllPeople(self, n, meetings, firstPerson):\n        \n        return []"}
{"id": "2131", "path": "output2\\py\\Hard\\2131-valid-arrangement-of-pairs.py", "hypo_code": "class Solution(object):\n    def validArrangement(self, pairs):\n        \n        return 0"}
{"id": "2133", "path": "output2\\py\\Hard\\2133-maximum-fruits-harvested-after-at-most-k-steps.py", "hypo_code": "class Solution(object):\n    def maxTotalFruits(self, fruits, startPos, k):\n        \n        return 0"}
{"id": "2134", "path": "output2\\py\\Hard\\2134-minimum-operations-to-make-the-array-k-increasing.py", "hypo_code": "class Solution(object):\n    def kIncreasing(self, arr, k):\n        \n        n = len(arr)\n        if n < 2:\n            return 0\n        max_len = 1\n        for i in range(n - 1):\n            j = i + 1\n            while j < n and arr[j] - arr[i] < n * k:\n                j += 1\n            if j - i > max_len:\n                max_len = j - i\n        return n - max_len"}
{"id": "2135", "path": "output2\\py\\Hard\\2135-abbreviating-the-product-of-a-range.py", "hypo_code": "class Solution(object):\n    def abbreviateProduct(self, left, right):\n        \n        if left == 0:\n            return \"0e0\"\n        if left == right:\n            return str(left) + \"e0\"\n        if left == 1:\n            return str(right) + \"e\" + str(int(math.log10(right)) + 1)\n        return str(math.factorial(right) / math.factorial(left - 1)) + \"e\" + str(int(math.log10(math.factorial(right) / math.factorial(left - 1))) + 1)"}
{"id": "2136", "path": "output2\\py\\Hard\\2136-recover-the-original-array.py", "hypo_code": "class Solution(object):\n    def recoverArray(self, nums):\n        \n        nums = sorted(list(set(nums)))\n        n = len(nums)\n        if n < 2:\n            return nums\n        max_len = 1\n        for i in range(n - 1):\n            j = i + 1\n            while j < n and nums[j] - nums[i] < n:\n                j += 1\n            if j - i > max_len:\n                max_len = j - i\n        return nums[:max_len]"}
{"id": "2137", "path": "output2\\py\\Hard\\2137-maximum-employees-to-be-invited-to-a-meeting.py", "hypo_code": "class Solution(object):\n    def maximumInvitations(self, favorite):\n        \n        return 0"}
{"id": "2138", "path": "output2\\py\\Hard\\2138-stamping-the-grid.py", "hypo_code": "class Solution(object):\n    def possibleToStamp(self, grid, stampHeight, stampWidth):\n        \n        return 0"}
{"id": "2139", "path": "output2\\py\\Hard\\2139-earliest-possible-day-of-full-bloom.py", "hypo_code": "class Solution(object):\n    def earliestFullBloom(self, plantTime, growTime):\n        \n        return 0"}
{"id": "2140", "path": "output2\\py\\Hard\\2140-maximum-running-time-of-n-computers.py", "hypo_code": "class Solution(object):\n    def maxRunTime(self, n, batteries):\n        \n        return 0"}
{"id": "2141", "path": "output2\\py\\Hard\\2141-number-of-ways-to-divide-a-long-corridor.py", "hypo_code": "class Solution(object):\n    def numberOfWays(self, corridor):\n        \n        n = len(corridor)\n        if n < 3:\n            return 0\n        s = corridor.count('S')\n        p = corridor.count('P')\n        if s < 4 or p < 1:\n            return 0\n        return (s - 1) * (s - 2) * (s - 3) * (s - 4) / 24 * p % 1000000007"}
{"id": "2142", "path": "output2\\py\\Hard\\2142-maximum-good-people-based-on-statements.py", "hypo_code": "class Solution(object):\n    def maximumGood(self, statements):\n        \n        n = len(statements)\n        if n < 2:\n            return n\n        max_len = 1\n        for i in range(n - 1):\n            j = i + 1\n            while j < n and statements[j][i] == 2:\n                j += 1\n            if j - i > max_len:\n                max_len = j - i\n        return max_len"}
{"id": "2143", "path": "output2\\py\\Hard\\2143-find-substring-with-given-hash-value.py", "hypo_code": "class Solution(object):\n    def subStrHash(self, s, power, modulo, k, hashValue):\n        \n        n = len(s)\n        if n < k:\n            return \"\"\n        p = 1\n        for i in range(k):\n            p = p * power % modulo\n        h = 0\n        for i in range(k):\n            h = (h * power + ord(s[i]) - ord('a') + 1) % modulo\n        if h == hashValue:\n            return s[:k]\n        for i in range(k, n):\n            h = (h * power + ord(s[i]) - ord('a') + 1 - (ord(s[i - k]) - ord('a') + 1) * p) % modulo\n            if h == hashValue:\n                return s[i - k + 1:i + 1]\n        return \"\""}
{"id": "2144", "path": "output2\\py\\Hard\\2144-groups-of-strings.py", "hypo_code": "class Solution(object):\n    def groupStrings(self, words):\n        \n        n = len(words)\n        if n < 2:\n            return [n, n]\n        d = {}\n        for w in words:\n            k = []\n            for i in range(1, len(w)):\n                k.append((ord(w[i]) - ord(w[0])) % 26)\n            k = tuple(k)\n            if k in d:\n                d[k].append(w)\n            else:\n                d[k] = [w]\n        return [len(d), max([len(d[k]) for k in d])]"}
{"id": "2145", "path": "output2\\py\\Hard\\2145-minimum-difference-in-sums-after-removal-of-elements.py", "hypo_code": "class Solution(object):\n    def minimumDifference(self, nums):\n        \n        return 0"}
{"id": "2146", "path": "output2\\py\\Hard\\2146-minimum-time-to-remove-all-cars-containing-illegal-goods.py", "hypo_code": "class Solution(object):\n    def minimumTime(self, s):\n        \n        return 0"}
{"id": "2147", "path": "output2\\py\\Hard\\2147-maximum-and-sum-of-array.py", "hypo_code": "class Solution(object):\n    def maximumANDSum(self, nums, numSlots):\n        \n        return 0"}
{"id": "2148", "path": "output2\\py\\Hard\\2148-count-good-triplets-in-an-array.py", "hypo_code": "class Solution(object):\n    def goodTriplets(self, nums1, nums2):\n               \n        return 0"}
{"id": "2149", "path": "output2\\py\\Hard\\2149-count-array-pairs-divisible-by-k.py", "hypo_code": "class Solution(object):\n    def countPairs(self, nums, k):\n        \n        return 0"}
{"id": "2150", "path": "output2\\py\\Hard\\2150-minimum-time-to-finish-the-race.py", "hypo_code": "class Solution(object):\n    def minimumFinishTime(self, tires, changeTime, numLaps):\n        \n        return 0"}
{"id": "2151", "path": "output2\\py\\Hard\\2151-minimum-number-of-moves-to-make-palindrome.py", "hypo_code": "class Solution(object):\n    def minMovesToMakePalindrome(self, s):\n        \n        return 0"}
{"id": "2152", "path": "output2\\py\\Hard\\2152-replace-non-coprime-numbers-in-array.py", "hypo_code": "class Solution(object):\n    def replaceNonCoprimes(self, nums):\n        \n        return 0"}
{"id": "2153", "path": "output2\\py\\Hard\\2153-minimum-weighted-subgraph-with-the-required-paths.py", "hypo_code": "class Solution(object):\n    def minimumWeight(self, n, edges, src1, src2, dest):\n        \n        edges = sorted(edges)\n        m = len(edges)\n        if m < 1:\n            return -1"}
{"id": "2154", "path": "output2\\py\\Hard\\2154-minimum-white-tiles-after-covering-with-carpets.py", "hypo_code": "class Solution(object):\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\n               \n        return 0"}
{"id": "2155", "path": "output2\\py\\Hard\\2155-longest-substring-of-one-repeating-character.py", "hypo_code": "class Solution(object):\n    def longestRepeating(self, s, queryCharacters, queryIndices):\n        \n        return 0"}
{"id": "2156", "path": "output2\\py\\Hard\\2156-maximum-value-of-k-coins-from-piles.py", "hypo_code": "class Solution(object):\n    def maxValueOfCoins(self, piles, k):\n        \n        return 0"}
{"id": "2157", "path": "output2\\py\\Hard\\2157-sum-of-scores-of-built-strings.py", "hypo_code": "class Solution(object):\n    def sumScores(self, s):\n        \n        return 0"}
{"id": "2159", "path": "output2\\py\\Hard\\2159-maximum-total-beauty-of-the-gardens.py", "hypo_code": "class Solution(object):\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\n        \n        return 0"}
{"id": "2160", "path": "output2\\py\\Hard\\2160-maximum-score-of-a-node-sequence.py", "hypo_code": "class Solution(object):\n    def maximumScore(self, scores, edges):\n        \n        return 0"}
{"id": "2161", "path": "output2\\py\\Hard\\2161-longest-path-with-different-adjacent-characters.py", "hypo_code": "class Solution(object):\n    def longestPath(self, parent, s):\n        \n        return 0"}
{"id": "2162", "path": "output2\\py\\Hard\\2162-number-of-flowers-in-full-bloom.py", "hypo_code": "class Solution(object):\n    def fullBloomFlowers(self, flowers, people):\n        \n        flowers = sorted(flowers)\n        n = len(flowers)\n        m = len(people)\n        ans = [0] * m\n        for i in range(m):\n            for j in range(n):\n                if people[i] >= flowers[j][0] and people[i] <= flowers[j][1]:\n                    ans[i] += 1\n                elif people[i] < flowers[j][0]:\n                    break\n        return ans"}
{"id": "2163", "path": "output2\\py\\Hard\\2163-escape-the-spreading-fire.py", "hypo_code": "class Solution(object):\n    def maximumMinutes(self, grid):\n        \n        return 0"}
{"id": "2164", "path": "output2\\py\\Hard\\2164-total-appeal-of-a-string.py", "hypo_code": "class Solution(object):\n    def appealSum(self, s):\n        \n        return 0"}
{"id": "2165", "path": "output2\\py\\Hard\\2165-check-if-there-is-a-valid-parentheses-string-path.py", "hypo_code": "class Solution(object):\n    def hasValidPath(self, grid):\n        \n        return 0"}
{"id": "2166", "path": "output2\\py\\Hard\\2166-substring-with-largest-variance.py", "hypo_code": "class Solution(object):\n    def largestVariance(self, s):\n        \n        return 0"}
{"id": "2168", "path": "output2\\py\\Hard\\2168-sum-of-total-strength-of-wizards.py", "hypo_code": "class Solution(object):\n    def totalStrength(self, strength):\n        \n        return 0"}
{"id": "2170", "path": "output2\\py\\Hard\\2170-minimum-obstacle-removal-to-reach-corner.py", "hypo_code": "class Solution(object):\n    def minimumObstacles(self, grid):\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            dp[0][i] = grid[0][i] + dp[0][i - 1]\n        for i in range(1, m):\n            dp[i][0] = grid[i][0] + dp[i - 1][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n        return dp[m - 1][n - 1]"}
{"id": "2172", "path": "output2\\py\\Hard\\2172-match-substring-after-replacement.py", "hypo_code": "class Solution(object):\n    def matchReplacement(self, s, sub, mappings):\n        \n        n = len(s)\n        m = len(sub)\n        if n < m:\n            return False\n        d = {}\n        for k, v in mappings:\n            if k not in d:\n                d[k] = set()\n            d[k].add(v)\n        for i in range(m):\n            if sub[i] not in d:\n                continue\n            if s[i] not in d[sub[i]]:\n                return False\n        return True"}
{"id": "2173", "path": "output2\\py\\Hard\\2173-count-subarrays-with-score-less-than-k.py", "hypo_code": "class Solution(object):\n    def countSubarrays(self, nums, k):\n        \n        n = len(nums)\n        if n < 1:\n            return 0\n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                score = (sum(nums[i:j+1]) * (j - i + 1))\n                if score < k:\n                    ans += 1\n        return ans"}
{"id": "2174", "path": "output2\\py\\Hard\\2174-naming-a-company.py", "hypo_code": "class Solution(object):\n    def distinctNames(self, ideas):\n        \n        n = len(ideas)\n        if n < 2:\n            return 0\n        d = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                a = ideas[i]\n                b = ideas[j]\n                if a[0] != b[0]:\n                    a, b = b, a\n                c = b[0] + a[1:]\n                if c not in d:\n                    d[c] = 1\n        return len(d)"}
{"id": "2175", "path": "output2\\py\\Hard\\2175-selling-pieces-of-wood.py", "hypo_code": "class Solution(object):\n    def sellingWood(self, m, n, prices):\n        \n        prices = sorted(prices)\n        ans = 0\n        for i in range(len(prices)):\n            ans += prices[i][2]\n        return ans"}
{"id": "2176", "path": "output2\\py\\Hard\\2176-number-of-distinct-roll-sequences.py", "hypo_code": "class Solution(object):\n    def distinctSequences(self, n):\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = (dp[i - 1] * 6 - dp[i - 2] * 2) % 1000000007\n        return dp[n]"}
{"id": "2177", "path": "output2\\py\\Hard\\2177-maximum-score-of-spliced-array.py", "hypo_code": "class Solution(object):\n    def maximumsSplicedArray(self, nums1, nums2):\n        \n        n = len(nums1)\n        if n < 1:\n            return 0\n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                score = max(sum(nums1[i:j+1]), sum(nums2[i:j+1]))\n                if score > ans:\n                    ans = score\n        return ans"}
{"id": "2178", "path": "output2\\py\\Hard\\2178-minimum-score-after-removals-on-a-tree.py", "hypo_code": "class Solution(object):\n    def minimumScore(self, nums, edges):\n        \n        return 0"}
{"id": "2179", "path": "output2\\py\\Hard\\2179-number-of-increasing-paths-in-a-grid.py", "hypo_code": "class Solution(object):\n    def countPaths(self, grid):\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i > 0 and grid[i][j] > grid[i - 1][j]:\n                    dp[i][j] += dp[i - 1][j]\n                if j > 0 and grid[i][j] > grid[i][j - 1]:\n                    dp[i][j] += dp[i][j - 1]\n                dp[i][j] %= 1000000007\n        return dp[m - 1][n - 1]"}
{"id": "2180", "path": "output2\\py\\Hard\\2180-subarray-with-elements-greater-than-varying-threshold.py", "hypo_code": "class Solution(object):\n    def validSubarraySize(self, nums, threshold):\n        \n        n = len(nums)\n        if n < 1:\n            return 0\n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                score = (sum(nums[i:j+1]) / (j - i + 1))\n                if score > threshold:\n                    ans += 1\n        return ans"}
{"id": "2181", "path": "output2\\py\\Hard\\2181-count-the-number-of-ideal-arrays.py", "hypo_code": "class Solution(object):\n    def idealArrays(self, n, maxValue):\n        \n        dp = [[0] * (maxValue + 1) for i in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, maxValue + 1):\n                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j / 2]) % 1000000007\n        return dp[n][maxValue]"}
{"id": "2182", "path": "output2\\py\\Hard\\2182-minimum-deletions-to-make-array-divisible.py", "hypo_code": "class Solution(object):\n    def minOperations(self, nums, numsDivide):\n        \n        return 0"}
{"id": "2183", "path": "output2\\py\\Hard\\2183-shortest-impossible-sequence-of-rolls.py", "hypo_code": "class Solution(object):\n    def shortestSequence(self, rolls, k):\n        \n        n = len(rolls)\n        if n < 1:\n            return 0\n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                score = (sum(nums[i:j+1]) * (j - i + 1))\n                if score < k:\n                    ans += 1\n        return ans"}
{"id": "2184", "path": "output2\\py\\Hard\\2184-number-of-excellent-pairs.py", "hypo_code": "class Solution(object):\n    def countExcellentPairs(self, nums, k):\n        \n        ans = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if bin(nums[i] | nums[j]).count('1') + bin(nums[i] & nums[j]).count('1') >= k:\n                    ans += 1\n        return ans"}
{"id": "2185", "path": "output2\\py\\Hard\\2185-longest-cycle-in-a-graph.py", "hypo_code": "class Solution(object):\n    def longestCycle(self, edges):\n        \n        n = len(edges)\n        ans = 0\n        for i in range(n):\n            if edges[i] == -1:\n                continue\n            j = i\n            cnt = 0\n            while edges[j] != -1:\n                cnt += 1\n                j = edges[j]\n            ans = max(ans, cnt)\n        return ans"}
{"id": "2186", "path": "output2\\py\\Hard\\2186-minimum-replacements-to-sort-the-array.py", "hypo_code": "class Solution(object):\n    def minimumReplacement(self, nums):\n        \n        nums = sorted(nums)\n        n = len(nums)\n        if n < 2:\n            return 0\n        max_len = 1\n        for i in range(n - 1):\n            j = i + 1\n            while j < n and nums[j] - nums[i] < n:\n                j += 1\n            if j - i > max_len:\n                max_len = j - i\n        return n - max_len"}
{"id": "2187", "path": "output2\\py\\Hard\\2187-count-special-integers.py", "hypo_code": "class Solution(object):\n    def countSpecialNumbers(self, n):\n        \n        ans = 0\n        for i in range(1, n + 1):\n            if len(set(str(i))) == len(str(i)):\n                ans += 1\n        return ans"}
{"id": "2188", "path": "output2\\py\\Hard\\2188-maximum-segment-sum-after-removals.py", "hypo_code": "class Solution(object):\n    def maximumSegmentSum(self, nums, removeQueries):\n        \n        return []"}
{"id": "2189", "path": "output2\\py\\Hard\\2189-find-the-k-sum-of-an-array.py", "hypo_code": "class Solution(object):\n    def kSum(self, nums, k):\n        \n        n = len(nums)\n        if n < 1:\n            return 0\n        nums = sorted(nums, reverse=True)\n        ans = 0\n        for i in range(k):\n            ans += nums[i]\n        return ans"}
{"id": "2190", "path": "output2\\py\\Hard\\2190-build-a-matrix-with-conditions.py", "hypo_code": "class Solution(object):\n    def buildMatrix(self, k, rowConditions, colConditions):\n        \n        n = len(rowConditions)\n        m = len(colConditions)\n        row = [0] * k\n        col = [0] * k\n        ans = [[0] * k for _ in range(k)]\n        for i in range(n):\n            row[rowConditions[i][0] - 1] = rowConditions[i][1]\n        for i in range(m):\n            col[colConditions[i][0] - 1] = colConditions[i][1]\n        for i in range(k):\n            for j in range(k):\n                ans[i][j] = max(row[i], col[j])\n        return ans"}
{"id": "2191", "path": "output2\\py\\Hard\\2191-maximum-number-of-robots-within-budget.py", "hypo_code": "class Solution(object):\n    def maximumRobots(self, chargeTimes, runningCosts, budget):\n        \n        return 0"}
{"id": "2192", "path": "output2\\py\\Hard\\2192-meeting-rooms-iii.py", "hypo_code": "class Solution(object):\n    def mostBooked(self, n, meetings):\n        \n        meetings = sorted(meetings)\n        n = len(meetings)\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if meetings[j][0] < meetings[i][1]:\n                    ans += 1\n        return ans"}
{"id": "2193", "path": "output2\\py\\Hard\\2193-longest-increasing-subsequence-ii.py", "hypo_code": "class Solution(object):\n    def lengthOfLIS(self, nums, k):\n        \n        n = len(nums)\n        if n < 1:\n            return 0\n        ans = 1\n        for i in range(n):\n            for j in range(i, n):\n                if nums[j] - nums[i] <= k:\n                    ans = max(ans, j - i + 1)\n        return ans"}
{"id": "2194", "path": "output2\\py\\Hard\\2194-minimum-money-required-before-transactions.py", "hypo_code": "class Solution(object):\n    def minimumMoney(self, transactions):\n        \n        ans = 0\n        for i in range(len(transactions)):\n            ans += transactions[i][0]\n        return ans"}
{"id": "2195", "path": "output2\\py\\Hard\\2195-sum-of-prefix-scores-of-strings.py", "hypo_code": "class Solution(object):\n    def sumPrefixScores(self, words):\n        \n        n = len(words)\n        if n < 1:\n            return []\n        ans = []\n        for w in words:\n            ans.append(sum([1 for ww in words if w == ww or w == ww[:len(w)]]))\n        return ans"}
{"id": "2196", "path": "output2\\py\\Hard\\2196-number-of-good-paths.py", "hypo_code": "class Solution(object):\n    def numberOfGoodPaths(self, vals, edges):\n        \n        pass"}
{"id": "2197", "path": "output2\\py\\Hard\\2197-number-of-pairs-satisfying-inequality.py", "hypo_code": "class Solution(object):\n    def numberOfPairs(self, nums1, nums2, diff):\n        \n        n = len(nums1)\n        if n < 2:\n            return 0\n        ans = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff:\n                    ans += 1\n        return ans"}
{"id": "2198", "path": "output2\\py\\Hard\\2198-maximum-deletions-on-a-string.py", "hypo_code": "class Solution(object):\n    def deleteString(self, s):\n        \n        n = len(s)\n        if n < 2:\n            return n\n        max_len = 1\n        for i in range(n / 2):\n            j = i + 1\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i > max_len:\n                max_len = j - i\n        return n - max_len"}
{"id": "2199", "path": "output2\\py\\Hard\\2199-paths-in-matrix-whose-sum-is-divisible-by-k.py", "hypo_code": "class Solution(object):\n    def numberOfPaths(self, grid, k):\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            dp[0][i] = grid[0][i] + dp[0][i - 1]\n        for i in range(1, m):\n            dp[i][0] = grid[i][0] + dp[i - 1][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + (dp[i - 1][j] + dp[i][j - 1]) % k\n        return dp[m - 1][n - 1] % k"}
{"id": "2200", "path": "output2\\py\\Hard\\2200-create-components-with-same-value.py", "hypo_code": "class Solution(object):\n    def componentValue(self, nums, edges):\n        \n        n = len(nums)\n        if n < 1:\n            return 0\n        nums = sorted(nums)\n        edges = sorted(edges)\n        m = len(edges)\n        ans = 0\n        for i in range(m):\n            if nums[edges[i][0]] == nums[edges[i][1]]:\n                ans += 1\n        return ans"}
{"id": "2201", "path": "output2\\py\\Hard\\2201-count-subarrays-with-fixed-bounds.py", "hypo_code": "class Solution(object):\n    def countSubarrays(self, nums, minK, maxK):\n        \n        n = len(nums)\n        if n < 1:\n            return 0\n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                if min(nums[i:j+1]) == minK and max(nums[i:j+1]) == maxK:\n                    ans += 1\n        return ans"}
{"id": "2202", "path": "output2\\py\\Hard\\2202-minimum-cost-to-make-array-equal.py", "hypo_code": "class Solution(object):\n    def minCost(self, nums, cost):\n        \n        n = len(nums)\n        if n < 2:\n            return 0\n        max_len = 1\n        for i in range(n - 1):\n            j = i + 1\n            while j < n and nums[j] - nums[i] < n:\n                j += 1\n            if j - i > max_len:\n                max_len = j - i\n        return n - max_len"}
{"id": "2203", "path": "output2\\py\\Hard\\2203-minimum-number-of-operations-to-make-arrays-similar.py", "hypo_code": "class Solution(object):\n    def makeSimilar(self, nums, target):\n        \n        nums = sorted(nums)\n        target = sorted(target)\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            ans += abs(nums[i] - target[i])\n        return ans / 2"}
{"id": "2204", "path": "output2\\py\\Hard\\2204-next-greater-element-iv.py", "hypo_code": "class Solution(object):\n    def secondGreaterElement(self, nums):\n        \n        n = len(nums)\n        ans = [-1] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] > nums[i]:\n                    ans[i] = nums[j]\n                    break\n        return ans"}
{"id": "2205", "path": "output2\\py\\Hard\\2205-height-of-binary-tree-after-subtree-removal-queries.py", "hypo_code": "class Solution(object):\n    def treeQueries(self, root, queries):\n        \n        return 0"}
{"id": "2206", "path": "output2\\py\\Hard\\2206-minimum-total-distance-traveled.py", "hypo_code": "class Solution(object):\n    def minimumTotalDistance(self, robot, factory):\n        \n        return 0"}
{"id": "2207", "path": "output2\\py\\Hard\\2207-split-message-based-on-limit.py", "hypo_code": "class Solution(object):\n    def splitMessage(self, message, limit):\n               \n        return 0"}
{"id": "2208", "path": "output2\\py\\Hard\\2208-maximum-number-of-non-overlapping-palindrome-substrings.py", "hypo_code": "class Solution(object):\n    def maxPalindromes(self, s, k):\n        \n        return 0"}
{"id": "2209", "path": "output2\\py\\Hard\\2209-number-of-beautiful-partitions.py", "hypo_code": "class Solution(object):\n    def beautifulPartitions(self, s, k, minLength):\n        \n        return 0"}
{"id": "2210", "path": "output2\\py\\Hard\\2210-count-palindromic-subsequences.py", "hypo_code": "class Solution(object):\n    def countPalindromes(self, s):\n        \n        return 0"}
{"id": "2211", "path": "output2\\py\\Hard\\2211-count-subarrays-with-median-k.py", "hypo_code": "class Solution(object):\n    def countSubarrays(self, nums, k):\n        \n        return 0"}
{"id": "2212", "path": "output2\\py\\Hard\\2212-divide-nodes-into-the-maximum-number-of-groups.py", "hypo_code": "class Solution(object):\n    def magnificentSets(self, n, edges):\n        \n        return 0"}
{"id": "2213", "path": "output2\\py\\Hard\\2213-minimum-total-cost-to-make-arrays-unequal.py", "hypo_code": "class Solution(object):\n    def minimumTotalCost(self, nums1, nums2):\n        \n        return 0"}
{"id": "2214", "path": "output2\\py\\Hard\\2214-maximum-number-of-points-from-grid-queries.py", "hypo_code": "class Solution(object):\n    def maxPoints(self, grid, queries):\n        \n        return []"}
{"id": "2215", "path": "output2\\py\\Hard\\2215-add-edges-to-make-degrees-of-all-nodes-even.py", "hypo_code": "class Solution(object):\n    def isPossible(self, n, edges):\n        \n        return 0"}
{"id": "2216", "path": "output2\\py\\Hard\\2216-cycle-length-queries-in-a-tree.py", "hypo_code": "class Solution(object):\n    def cycleLengthQueries(self, n, queries):\n        \n        return []"}
{"id": "2217", "path": "output2\\py\\Hard\\2217-count-anagrams.py", "hypo_code": "class Solution(object):\n    def countAnagrams(self, s):\n         \n        return 0"}
{"id": "2218", "path": "output2\\py\\Hard\\2218-number-of-great-partitions.py", "hypo_code": "class Solution(object):\n    def countPartitions(self, nums, k):\n              \n        def get_count_without_repetitions(n):\n            res = 0\n            k = len(n)\n            for i in range(1, k):\n                res += 9 * get_permutations_without_repetitions(9, i-1)\n            used = set()\n            for i in range(k):\n                for j in range(1 if i else 1, n[i]):\n                    if j not in used:\n                        res += get_permutations_without_repetitions(9-i, k-i-1)\n                if n[i] in used:\n                    break\n                used.add(n[i])\n            else:\n                res += 1\n            return res\n        \n        return n - get_count_without_repetitions(get_digits(n))"}
{"id": "2219", "path": "output2\\py\\Hard\\2219-maximize-the-minimum-powered-city.py", "hypo_code": "class Solution(object):\n    def maxPower(self, stations, r, k):\n              \n        def get_digits(n):\n            res = []\n            while n:\n                res.append(n % 10)\n                n /= 10\n            return res[::-1]\n        \n        def get_permutations(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            return res\n        \n        def get_permutations_without_repetitions(n, k):\n            res = 1\n            for i in range(n, n-k, -1):\n                res *= i\n            for i in range(1, k+1):\n                res /= i\n            return res\n        \n        def get_count_without_repetitions(n):\n            res = 0\n            k = len(n)\n            for i in range(1, k):\n                res += 9 * get_permutations_without_repetitions(9, i-1)\n            used = set()\n            for i in range(k):\n                for j in range(1 if i else 1, n[i]):\n                    if j not in used:\n                        res += get_permutations_without_repetitions(9-i, k-i-1)\n                if n[i] in used:\n                    break\n                used.add(n[i])\n            else:\n                res += 1\n            return res\n        \n        return n - get_count_without_repetitions(get_digits(n))"}
{"id": "2220", "path": "output2\\py\\Hard\\2220-time-to-cross-a-bridge.py", "hypo_code": "class Solution(object):\n    def findCrossingTime(self, n, k, time):"}
{"id": "2221", "path": "output2\\py\\Hard\\2221-difference-between-maximum-and-minimum-price-sum.py", "hypo_code": "class Solution(object):\n    def maxOutput(self, n, edges, price):\n        \n        if n==1:\n            return 0\n        if n==2:\n            return abs(price[0]-price[1])\n        result=0\n        for i in range(n):\n            result=max(result,self.maxOutputHelper(n,edges,price,i))\n        return result"}
{"id": "2222", "path": "output2\\py\\Hard\\2222-check-if-point-is-reachable.py", "hypo_code": "class Solution(object):\n    def isReachable(self, targetX, targetY):\n        \n        if targetX == 1 and targetY == 1:\n            return True\n        if targetX == 1 and targetY == 0:\n            return True\n        if targetX == 0 and targetY == 1:\n            return True\n        if targetX == 0 and targetY == 0:\n            return True\n        if targetX < 0 or targetY < 0:\n            return False\n        return self.isReachable(targetX, targetY - targetX) or self.isReachable(targetX - targetY, targetY) or self.isReachable(2 * targetX, targetY) or self.isReachable(targetX, 2 * targetY)"}
{"id": "2223", "path": "output2\\py\\Hard\\2223-minimum-cost-to-split-an-array.py", "hypo_code": "class Solution(object):\n    def minCost(self, nums, k):\n               \n        if not nums:\n            return 0\n        if k==1:\n            return len(nums)\n        if k==len(nums):\n            return 1\n        result = []\n        for i in range(len(nums)-k+1):\n            result.append(len(nums[i:i+k]))\n        return min(result)"}
{"id": "2224", "path": "output2\\py\\Hard\\2224-put-marbles-in-bags.py", "hypo_code": "class Solution(object):\n    def putMarbles(self, weights, k):\n             \n        if not weights:\n            return 0\n        if k==1:\n            return sum(weights)\n        if k==len(weights):\n            return max(weights)\n        result = []\n        for i in range(len(weights)-k+1):\n            result.append(max(weights[i:i+k]))\n        return min(result)"}
{"id": "2225", "path": "output2\\py\\Hard\\2225-count-increasing-quadruplets.py", "hypo_code": "class Solution(object):\n    def countQuadruplets(self, nums):\n               \n        if not nums:\n            return 0\n        result=0\n        for i in range(len(nums)-3):\n            for j in range(i+1,len(nums)-2):\n                for k in range(j+1,len(nums)-1):\n                    for l in range(k+1,len(nums)):\n                        if nums[i]<nums[k]<nums[j]<nums[l]:\n                            result+=1\n        return result"}
{"id": "2226", "path": "output2\\py\\Hard\\2226-rearranging-fruits.py", "hypo_code": "class Solution(object):\n    def minCost(self, basket1, basket2):\n               \n        if not basket1 or not basket2:\n            return 0\n        if len(basket1) != len(basket2):\n            return -1\n        basket1.sort()\n        basket2.sort()\n        cost = 0\n        for i in range(len(basket1)):\n            cost += min(basket1[i],basket2[i])\n        return cost"}
{"id": "2227", "path": "output2\\py\\Hard\\2227-subsequence-with-the-minimum-score.py", "hypo_code": "class Solution(object):\n    def minimumScore(self, s, t):\n               \n        if not s or not t:\n            return 0\n        s = s[::-1]\n        t = t[::-1]\n        dp = [[0 for _ in range(len(t)+1)] for _ in range(len(s)+1)]\n        for i in range(1,len(s)+1):\n            for j in range(1,len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n        return len(t) - dp[-1][-1]"}
{"id": "2228", "path": "output2\\py\\Hard\\2228-handling-sum-queries-after-update.py", "hypo_code": "class Solution(object):\n    def handleQuery(self, nums1, nums2, queries):\n              \n        if not queries:\n            return []\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                for i in range(query[1],query[2]+1):\n                    nums1[i] = 1 - nums1[i]\n            elif query[0] == 2:\n                for i in range(len(nums2)):\n                    nums2[i] += nums1[i] * query[1]\n            else:\n                result.append(sum(nums2))\n        return result"}
{"id": "2229", "path": "output2\\py\\Hard\\2229-find-the-string-with-lcp.py", "hypo_code": "class Solution(object):\n    def findTheString(self, lcp):\n             \n        return \"\""}
{"id": "2230", "path": "output2\\py\\Hard\\2230-minimum-time-to-visit-a-cell-in-a-grid.py", "hypo_code": "class Solution(object):\n    def minimumTime(self, grid):\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 0\n        for i in range(1, n):\n            dp[0][i] = max(dp[0][i - 1], grid[0][i])\n        for i in range(1, m):\n            dp[i][0] = max(dp[i - 1][0], grid[i][0])\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = max(min(dp[i - 1][j], dp[i][j - 1]), grid[i][j])\n        return dp[m - 1][n - 1]"}
{"id": "2231", "path": "output2\\py\\Hard\\2231-count-number-of-possible-root-nodes.py", "hypo_code": "class Solution(object):\n    def rootCount(self, edges, guesses, k):\n        \n        return 0"}
{"id": "2232", "path": "output2\\py\\Hard\\2232-split-the-array-to-make-coprime-products.py", "hypo_code": "class Solution(object):\n    def findValidSplit(self, nums):\n        \n        n = len(nums)\n        if n < 2:\n            return -1\n        ans = -1\n        for i in range(n - 1):\n            if gcd(nums[i], nums[i+1]) == 1:\n                return i\n        return ans"}
{"id": "2233", "path": "output2\\py\\Hard\\2233-number-of-ways-to-earn-points.py", "hypo_code": "class Solution(object):\n    def waysToReachTarget(self, target, types):\n        \n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for i in range(len(types)):\n            for j in range(types[i][1], target + 1):\n                dp[j] += dp[j - types[i][1]]\n        return dp[target]"}
{"id": "2234", "path": "output2\\py\\Hard\\2234-minimum-time-to-complete-all-tasks.py", "hypo_code": "class Solution(object):\n    def findMinimumTime(self, tasks):\n        \n        tasks.sort(key=lambda x:x[1])\n        res = 0\n        for i in range(len(tasks)):\n            res = max(res, tasks[i][0])+tasks[i][2]\n        return res"}
{"id": "2235", "path": "output2\\py\\Hard\\2235-collect-coins-in-a-tree.py", "hypo_code": "class Solution(object):\n    def collectTheCoins(self, coins, edges):\n        \n        return 0"}
{"id": "2236", "path": "output2\\py\\Hard\\2236-shortest-cycle-in-a-graph.py", "hypo_code": "class Solution(object):\n    def findShortestCycle(self, n, edges):\n        \n        return 0"}
{"id": "2237", "path": "output2\\py\\Hard\\2237-minimum-reverse-operations.py", "hypo_code": "class Solution(object):\n    def minReverseOperations(self, n, p, banned, k):\n        \n        return 0"}
{"id": "2238", "path": "output2\\py\\Hard\\2238-minimum-number-of-visited-cells-in-a-grid.py", "hypo_code": "class Solution(object):\n    def minimumVisitedCells(self, grid):\n        \n        return 0"}
{"id": "2241", "path": "output2\\py\\Hard\\2241-minimize-the-total-price-of-the-trips.py", "hypo_code": "class Solution(object):\n    def minimumTotalPrice(self, n, edges, price, trips):\n        \n        return 0"}
{"id": "2243", "path": "output2\\py\\Hard\\2243-make-array-empty.py", "hypo_code": "class Solution(object):\n    def countOperationsToEmptyArray(self, nums):\n        \n        return 0"}
{"id": "2244", "path": "output2\\py\\Hard\\2244-lexicographically-smallest-beautiful-string.py", "hypo_code": "class Solution(object):\n    def smallestBeautifulString(self, s, k):\n        \n        return \"\""}
{"id": "2245", "path": "output2\\py\\Hard\\2245-power-of-heroes.py", "hypo_code": "class Solution(object):\n    def sumOfPower(self, nums):\n        \n        return 0"}
{"id": "2246", "path": "output2\\py\\Hard\\2246-modify-graph-edge-weights.py", "hypo_code": "class Solution(object):\n    def modifiedGraphEdges(self, n, edges, source, destination, target):\n        \n        return []"}
{"id": "2247", "path": "output2\\py\\Hard\\2247-greatest-common-divisor-traversal.py", "hypo_code": "class Solution(object):\n    def canTraverseAllPairs(self, nums):\n        \n        return False"}
{"id": "2248", "path": "output2\\py\\Hard\\2248-maximum-strictly-increasing-cells-in-a-matrix.py", "hypo_code": "class Solution(object):\n    def maxIncreasingCells(self, mat):\n        \n        return 0"}
{"id": "2249", "path": "output2\\py\\Hard\\2249-count-of-integers.py", "hypo_code": "class Solution(object):\n    def count(self, num1, num2, min_sum, max_sum):\n        \n        return 0"}
{"id": "2250", "path": "output2\\py\\Hard\\2250-find-a-good-subset-of-the-matrix.py", "hypo_code": "class Solution(object):\n    def goodSubsetofBinaryMatrix(self, grid):\n        \n        return []"}
{"id": "2251", "path": "output2\\py\\Hard\\2251-maximum-sum-queries.py", "hypo_code": "class Solution(object):\n    def maximumSumQueries(self, nums1, nums2, queries):\n        \n        \n        \n        \n        result = []\n        for query in queries:\n            maxSum = -1\n            for i in range(query[0], query[1] + 1):\n                if nums1[i] >= query[0] and nums2[i] >= query[1]:\n                    maxSum = max(maxSum, nums1[i] + nums2[i])\n            result.append(maxSum)\n        return result"}
{"id": "2252", "path": "output2\\py\\Hard\\2252-painting-the-walls.py", "hypo_code": "class Solution(object):\n    def paintWalls(self, cost, time):\n        \n        \n        \n        \n        result = 0\n        for i in range(len(cost)):\n            if time[i] == 1:\n                result += cost[i]\n            else:\n                result += min(cost[i], cost[i] + cost[i - 1])\n        return result"}
{"id": "2253", "path": "output2\\py\\Hard\\2253-robot-collisions.py", "hypo_code": "class Solution(object):\n    def survivedRobotsHealths(self, positions, healths, directions):\n        \n        \n        \n        \n        result = []\n        for i in range(len(positions)):\n            survived = True\n            for j in range(len(positions)):\n                if i != j and positions[i] == positions[j]:\n                    if healths[i] >= healths[j]:\n                        survived = False\n                        break\n                    else:\n                        healths[j] -= healths[i]\n            if survived:\n                result.append(healths[i])\n        return result"}
{"id": "2254", "path": "output2\\py\\Hard\\2254-sum-of-imbalance-numbers-of-all-subarrays.py", "hypo_code": "class Solution(object):\n    def sumImbalanceNumbers(self, nums):\n        \n        \n        \n        \n        result = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] - nums[i] > 1:\n                    result += 1\n        return result"}
{"id": "2255", "path": "output2\\py\\Hard\\2255-length-of-the-longest-valid-substring.py", "hypo_code": "class Solution(object):\n    def longestValidSubstring(self, word, forbidden):\n        \n        \n        \n        \n        result = 0\n        for i in range(len(word)):\n            for j in range(i + 1, len(word)):\n                if word[i:j] not in forbidden:\n                    result = max(result, j - i)\n        return result"}
{"id": "2256", "path": "output2\\py\\Hard\\2256-maximum-number-of-groups-with-increasing-length.py", "hypo_code": "class Solution(object):\n    def maxIncreasingGroups(self, usageLimits):\n        \n        \n        \n        \n        result = 0\n        for i in range(len(usageLimits)):\n            result += min(usageLimits[i], i + 1)\n        return result"}
{"id": "2257", "path": "output2\\py\\Hard\\2257-count-paths-that-can-form-a-palindrome-in-a-tree.py", "hypo_code": "class Solution(object):\n    def countPalindromePaths(self, parent, s):\n        \n        \n        \n        \n        def dfs(node, curr, result):\n            result[0] += curr[s[node]]\n            for child in graph[node]:\n                curr[s[node]] += 1\n                dfs(child, curr, result)\n                curr[s[node]] -= 1\n\n        graph = [[] for _ in range(len(parent))]\n        for i in range(1, len(parent)):\n            graph[parent[i]].append(i)\n        result = [0]\n        dfs(0, collections.Counter(), result)\n        return result[0]"}
{"id": "2258", "path": "output2\\py\\Hard\\2258-count-stepping-numbers-in-range.py", "hypo_code": "class Solution(object):\n    def countSteppingNumbers(self, low, high):\n        \n        \n        \n        \n        def bfs(low, high, result):\n            q = collections.deque([0])\n            while q:\n                node = q.popleft()\n                if node <= high:\n                    if node >= low:\n                        result[0] += 1\n                    lastDigit = node % 10\n                    if lastDigit > 0:\n                        q.append(node * 10 + lastDigit - 1)\n                    if lastDigit < 9:\n                        q.append(node * 10 + lastDigit + 1)\n        result = [0]\n        bfs(int(low), int(high), result)\n        return result[0]"}
{"id": "2259", "path": "output2\\py\\Hard\\2259-minimum-time-to-make-array-sum-at-most-x.py", "hypo_code": "class Solution(object):\n    def minimumTime(self, nums1, nums2, x):\n        \n        \n        \n        \n        i = 0\n        j = len(nums1) - 1\n        while i <= j and x > 0:\n            x -= nums1[i] + nums2[j]\n            i += 1\n            j -= 1\n        return i + j + 1 if x >= 0 else -1"}
{"id": "2260", "path": "output2\\py\\Hard\\2260-maximum-elegance-of-a-k-length-subsequence.py", "hypo_code": "class Solution(object):\n    def findMaximumElegance(self, items, k):\n        \n        \n        \n        \n        items.sort(key = lambda x: x[0], reverse = True)\n        categories = set()\n        result = 0\n        for i in range(k):\n            result += items[i][0]\n            categories.add(items[i][1])\n        return result + len(categories) ** 2"}
{"id": "2261", "path": "output2\\py\\Hard\\2261-apply-operations-to-maximize-score.py", "hypo_code": "class Solution(object):\n    def maximumScore(self, nums, k):\n        \n        \n        \n        \n        result = float('-inf')\n        left = right = k\n        minNum = nums[k]\n        while left >= 0 and right < len(nums):\n            minNum = min(minNum, nums[left], nums[right])\n            result = max(result, minNum * (right - left + 1))\n            if left == 0:\n                right += 1\n            elif right == len(nums) - 1:\n                left -= 1\n            else:\n                if nums[left - 1] < nums[right + 1]:\n                    right += 1\n                else:\n                    left -= 1\n        return result"}
