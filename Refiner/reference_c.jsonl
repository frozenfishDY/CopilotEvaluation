{"id": "1", "ref_c": [["int* twoSum(int* nums, int numsSize, int target, int* returnSize){\\n\\n*returnSize=2;// der zu returnende array hat 2 elemente\\n\\nint *array = malloc(2*sizeof(int) ); // Output array max 2 elemente\\n\\nfor (int i=0; i<numsSize;i++)\\n{\\n    for( int j=1+i;j<numsSize;j++)\\n    {\\n        if(nums[i] + nums[j] == target)\\n        {\\n        array[0]=i;\\n        array[1]=j;\\n        return array;\\n        }"], ["int* twoSum(int* nums, int numsSize, int target, int* returnSize) {\\n    int* result = (int*)malloc(2 * sizeof(int)); // Allocate memory for the result array\\n    if (result == NULL) {\\n        *returnSize = 0;\\n        return NULL; // Return NULL if memory allocation fails\\n    }"], ["int* twoSum(int* nums, int numsSize, int target, int* returnSize){\\n\\n*returnSize=2;// der zu returnende array hat 2 elemente\\n\\nint *array = malloc(2*sizeof(int) ); // Output array max 2 elemente\\n\\nfor (int i=0; i<numsSize;i++)\\n{\\n    for( int j=1+i;j<numsSize;j++)\\n    {\\n        if(nums[i] + nums[j] == target)\\n        {\\n        array[0]=i;\\n        array[1]=j;\\n        return array;\\n        }"]]}
{"id": "2", "ref_c": [["bool isPalindrome(int x){\\n    if(x<0 || x!=0 && x%10 ==0 ) return false;\\n    int check=0;\\n    while(x>check){\\n        check = check*10 + x%10;\\n        x/=10;\\n    }"], ["bool isPalindrome(int x) {\\n        long int reverse=0,temp=x;\\n        while(temp>0)\\n        {\\n            int rem=temp%10;\\n            reverse=reverse*10+rem;\\n            temp=temp/10;\\n        }", "bool isPalindrome(int x) {\\n        long int reverse=0,temp=x;\\n        while(temp>0)\\n        {\\n            int rem=temp%10;\\n            reverse=reverse*10+rem;\\n            temp=temp/10;\\n        }"], ["bool isPalindrome(int x) {\\n        // If x is negative or ends with 0 but is not 0 itself, it cannot be a palindrome.\\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\\n            return false;\\n        }"]]}
{"id": "3", "ref_c": [["int romanToInt(char * s)\\n{\\n    int t[\\'X\\' + 1] = {\\n        [\\'I\\'] = 1,\\n        [\\'V\\'] = 5,\\n        [\\'X\\'] = 10,\\n        [\\'L\\'] = 50,\\n        [\\'C\\'] = 100,\\n        [\\'D\\'] = 500,\\n        [\\'M\\'] = 1000,\\n    }"], ["int romanToInt(char * s)\\n{\\n    int t[\\'X\\' + 1] = {\\n        [\\'I\\'] = 1,\\n        [\\'V\\'] = 5,\\n        [\\'X\\'] = 10,\\n        [\\'L\\'] = 50,\\n        [\\'C\\'] = 100,\\n        [\\'D\\'] = 500,\\n        [\\'M\\'] = 1000,\\n    }"], ["int romanToInt(char * s)\\n{\\n    int t[\\'X\\' + 1] = {\\n        [\\'I\\'] = 1,\\n        [\\'V\\'] = 5,\\n        [\\'X\\'] = 10,\\n        [\\'L\\'] = 50,\\n        [\\'C\\'] = 100,\\n        [\\'D\\'] = 500,\\n        [\\'M\\'] = 1000,\\n    }"]]}
{"id": "4", "ref_c": ["\nchar *longestCommonPrefix(char **strs, int strsSize)\n{\n\tfor(int c=0;; ++c)\n\t{\n\t\tif(strs[0][c] == '\u0000') // the longest common prefix is the first string\n\t\t\treturn strs[0];\n\t\tfor(int s=1; s<strsSize; ++s)\n\t\t{\n\t\t\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\n\t\t\t{\n\t\t\t\tstrs[0][c] = '\u0000'; // replace the current character with '\u0000'\n\t\t\t\treturn strs[0];\n\t\t\t}\n\t\t}\n\t}\n}\n", "\nchar *longestCommonPrefix(char **strs, int strsSize)\n{\n\tfor(int c=0;; ++c)\n\t{\n\t\tif(strs[0][c] == '\u0000') // the longest common prefix is the first string\n\t\t\treturn strs[0];\n\t\tfor(int s=1; s<strsSize; ++s)\n\t\t{\n\t\t\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\n\t\t\t{\n\t\t\t\tstrs[0][c] = '\u0000'; // replace the current character with '\u0000'\n\t\t\t\treturn strs[0];\n\t\t\t}\n\t\t}\n\t}\n}\n", "\nchar *longestCommonPrefix(char **strs, int strsSize)\n{\n\tfor(int c=0;; ++c)\n\t{\n\t\tif(strs[0][c] == '\u0000') // the longest common prefix is the first string\n\t\t\treturn strs[0];\n\t\tfor(int s=1; s<strsSize; ++s)\n\t\t{\n\t\t\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\n\t\t\t{\n\t\t\t\tstrs[0][c] = '\u0000'; // replace the current character with '\u0000'\n\t\t\t\treturn strs[0];\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
{"id": "5", "ref_c": ["\nbool isValid(char * s){\n    int top = -1;\n    char c;\n    for(int i = 0; s[i] != '\u0000'; i++){\n        c = s[i];\n        switch(c) {\n            case '(': s[++top] = c + 1; break;\n            case '{':\n            case '[': s[++top] = c + 2; break;\n            default: if (top == -1 || c != s[top--]) return false;\n        }\n    }\n    return top == -1;\n}\n", "\nbool isValid(char * s){\n    int top = -1;\n    char c;\n    for(int i = 0; s[i] != '\u0000'; i++){\n        c = s[i];\n        switch(c) {\n            case '(': s[++top] = c + 1; break;\n            case '{':\n            case '[': s[++top] = c + 2; break;\n            default: if (top == -1 || c != s[top--]) return false;\n        }\n    }\n    return top == -1;\n}\n", "\nbool isValid(char * s){\n    int top = -1;\n    char c;\n    for(int i = 0; s[i] != '\u0000'; i++){\n        c = s[i];\n        switch(c) {\n            case '(': s[++top] = c + 1; break;\n            case '{':\n            case '[': s[++top] = c + 2; break;\n            default: if (top == -1 || c != s[top--]) return false;\n        }\n    }\n    return top == -1;\n}\n"]}
{"id": "6", "ref_c": [["struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){\\n    if(!list1) return list2;\\n    if(!list2) return list1;\\n    struct ListNode* itteratorl1,* backOfNewList;\\n    if(list1->val > list2->val){\\n        backOfNewList = list2;\\n        list2 = list1;\\n        list1 = backOfNewList;\\n    }"], ["struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){\\n    if(list1==NULL&&list2==NULL)\\n    return NULL;\\n    if(list1==NULL)\\n    return list2;\\n    if(list2==NULL)\\n    return list1;\\n    struct ListNode* last, *third;\\n    if(list1->val<list2->val)\\n    {\\n        third=list1;\\n        last=list1;\\n        list1=list1->next;\\n        last->next=NULL;\\n    }"], ["struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){\\n    if(list1==NULL&&list2==NULL)\\n    return NULL;\\n    if(list1==NULL)\\n    return list2;\\n    if(list2==NULL)\\n    return list1;\\n    struct ListNode* last, *third;\\n    if(list1->val<list2->val)\\n    {\\n        third=list1;\\n        last=list1;\\n        list1=list1->next;\\n        last->next=NULL;\\n    }"]]}
{"id": "7", "ref_c": [["int removeDuplicates(int* nums, int numsSize) {\\n    if (numsSize == 0) {\\n        return 0;\\n    }"], ["int removeDuplicates(int* nums, int numsSize) {\\n    if (numsSize == 0) {\\n        return 0;\\n    }"], ["int removeDuplicates(int* nums, int numsSize) {\\n    if (numsSize == 0) {\\n        return 0;\\n    }"]]}
{"id": "8", "ref_c": [["int removeElement(int* nums, int numsSize, int val){\\n    \\n    int appendIndex = 0;\\n    bool find = false;\\n    int k = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == val && !find) {\\n            appendIndex = i;\\n            find = true;\\n        }"], ["int removeElement(int* nums, int numsSize, int val){\\n    \\n    int appendIndex = 0;\\n    bool find = false;\\n    int k = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == val && !find) {\\n            appendIndex = i;\\n            find = true;\\n        }"], ["int removeElement(int* nums, int numsSize, int val){\\n    \\n    int appendIndex = 0;\\n    bool find = false;\\n    int k = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == val && !find) {\\n            appendIndex = i;\\n            find = true;\\n        }"]]}
{"id": "9", "ref_c": [["int strStr(char * haystack, char * needle){\\n    char *occurence = strstr(haystack, needle);\\n    if (occurence) return occurence - haystack;\\n    else return -1;\\n}", "int strStr(char * haystack, char * needle){\\n    for(int l = 0, r = strlen(needle); r <= strlen(haystack); l++, r++){\\n        char temp = haystack[r];\\n        haystack[r] = \\'\\\\0\\';\\n        if (strstr( haystack+l, needle )){\\n            return l;\\n        }"], ["int strStr(char * haystack, char * needle){\\n    char *occurence = strstr(haystack, needle);\\n    if (occurence) return occurence - haystack;\\n    else return -1;\\n}", "int strStr(char * haystack, char * needle){\\n    for(int l = 0, r = strlen(needle); r <= strlen(haystack); l++, r++){\\n        char temp = haystack[r];\\n        haystack[r] = \\'\\\\0\\';\\n        if (strstr( haystack+l, needle )){\\n            return l;\\n        }"], ["int strStr(char * haystack, char * needle){\\n    char *occurence = strstr(haystack, needle);\\n    if (occurence) return occurence - haystack;\\n    else return -1;\\n}", "int strStr(char * haystack, char * needle){\\n    for(int l = 0, r = strlen(needle); r <= strlen(haystack); l++, r++){\\n        char temp = haystack[r];\\n        haystack[r] = \\'\\\\0\\';\\n        if (strstr( haystack+l, needle )){\\n            return l;\\n        }"]]}
{"id": "10", "ref_c": [["int searchInsert(int* nums, int numsSize, int target){\\n    int index1 = -1;\\n    int index2 = -1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            index1 = i;\\n            break;\\n        }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"]]}
{"id": "11", "ref_c": [["int lengthOfLastWord(char * s){\\n    int count  = 0;\\n    int length = 0;\\n    for (int i = 0; i < strlen(s); i++) {\\n        if (s[i] != \\' \\') {\\n            count++;\\n            length = count;\\n        }"], ["int lengthOfLastWord(char * s){\\n    int c=0;\\n    for(int i=strlen(s)-1;i>=0;i--){\\n        if(s[i]==\\' \\'){\\n            c++;\\n        }"], ["int lengthOfLastWord(char * s){\\n    int count  = 0;\\n    int length = 0;\\n    for (int i = 0; i < strlen(s); i++) {\\n        if (s[i] != \\' \\') {\\n            count++;\\n            length = count;\\n        }"]]}
{"id": "12", "ref_c": ["\nint * plusOne(int *digits, int digitsSize, int *returnSize){\n    for (int i = digitsSize-1; i >= 0; i--) {\n        if (digits[i] != 9) {\n            digits[i] += 1;\n            break;\n        } else {\n            digits[i] = 0;\n        }\n    }\n\n    // If first digit is 0\n    if (digits[0] == 0) {\n        // To prepend 1\n        int size = digitsSize + 1;\n        int *result = (int*)malloc(sizeof(int) * size);\n        result[0] = 1;\n\n        // Concat old arr with \"[1]\"\n        for (int i = 0; i < digitsSize; i++)\n            result[i+1] = digits[i];\n            \n        *returnSize = size;\n        return result;\n    } else {\n        *returnSize = digitsSize;\n        return digits;\n    }\n}\n", "\nint * plusOne(int *digits, int digitsSize, int *returnSize){\n    for (int i = digitsSize-1; i >= 0; i--) {\n        if (digits[i] != 9) {\n            digits[i] += 1;\n            break;\n        } else {\n            digits[i] = 0;\n        }\n    }\n\n    // If first digit is 0\n    if (digits[0] == 0) {\n        // To prepend 1\n        int size = digitsSize + 1;\n        int *result = (int*)malloc(sizeof(int) * size);\n        result[0] = 1;\n\n        // Concat old arr with \"[1]\"\n        for (int i = 0; i < digitsSize; i++)\n            result[i+1] = digits[i];\n            \n        *returnSize = size;\n        return result;\n    } else {\n        *returnSize = digitsSize;\n        return digits;\n    }\n}\n", "\nint * plusOne(int *digits, int digitsSize, int *returnSize){\n    for (int i = digitsSize-1; i >= 0; i--) {\n        if (digits[i] != 9) {\n            digits[i] += 1;\n            break;\n        } else {\n            digits[i] = 0;\n        }\n    }\n\n    // If first digit is 0\n    if (digits[0] == 0) {\n        // To prepend 1\n        int size = digitsSize + 1;\n        int *result = (int*)malloc(sizeof(int) * size);\n        result[0] = 1;\n\n        // Concat old arr with \"[1]\"\n        for (int i = 0; i < digitsSize; i++)\n            result[i+1] = digits[i];\n            \n        *returnSize = size;\n        return result;\n    } else {\n        *returnSize = digitsSize;\n        return digits;\n    }\n}\n"]}
{"id": "13", "ref_c": [["char * addBinary(char * a, char * b){\\n    int sizeA = strlen(a);\\n    int sizeB = strlen(b);\\n    int sizeOutput = (sizeA > sizeB ? sizeA : sizeB) + 1;\\n    char * output = (char *)malloc(sizeOutput + 1);\\n    int sum = 0;\\n    \\n    output[sizeOutput] = \\'\\\\0\\';\\n    \\n    while(sizeA > 0 || sizeB > 0 || sum > 0) {\\n        \\n        if(sizeA > 0) {\\n            sum += a[--sizeA] - \\'0\\';\\n        }"], ["char * addBinary(char * a, char * b){\\n    int sizeA = strlen(a);\\n    int sizeB = strlen(b);\\n    int sizeOutput = (sizeA > sizeB ? sizeA : sizeB) + 1;\\n    char * output = (char *)malloc(sizeOutput + 1);\\n    int sum = 0;\\n    \\n    output[sizeOutput] = \\'\\\\0\\';\\n    \\n    while(sizeA > 0 || sizeB > 0 || sum > 0) {\\n        \\n        if(sizeA > 0) {\\n            sum += a[--sizeA] - \\'0\\';\\n        }"], ["char * addBinary(char * a, char * b){\\n    int sizeA = strlen(a);\\n    int sizeB = strlen(b);\\n    int sizeOutput = (sizeA > sizeB ? sizeA : sizeB) + 1;\\n    char * output = (char *)malloc(sizeOutput + 1);\\n    int sum = 0;\\n    \\n    output[sizeOutput] = \\'\\\\0\\';\\n    \\n    while(sizeA > 0 || sizeB > 0 || sum > 0) {\\n        \\n        if(sizeA > 0) {\\n            sum += a[--sizeA] - \\'0\\';\\n        }"]]}
{"id": "14", "ref_c": [["int mySqrt(int x) {\\n        if(x == 0) // To avoid division by 0\\n            return 0;\\n        int start = 1, end = x / 2 + 1; // The squareroot can only lie in this range\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(mid == x / mid) // Not multiplying as the product for a large number may be greater than the max value of int\\n                return mid;\\n            else if(mid < x / mid) \\n                start = mid + 1;\\n            else\\n                end = mid - 1;\\n        }"], ["int mySqrt(int x) {\\n        // Initialise beg and end values as 1 and x / 2 respectively...\\n        int beg = 1 , end = x / 2 , mid;\\n        // Initialize variable res to store the result\\n        int res = 0;\\n        long tmp;\\n        // If the number is less than 2, return itself...\\n        if(x <= 1)\\n            return x;\\n        while(beg <= end) {\\n            // Find middle of this range...\\n            mid = (beg + (end - beg) / 2);\\n            tmp = (long)mid * (long)mid;      // mid * mid can be large, so use long...\\n            // If square of mid is equal to x...\\n            // return it as it is the square root...\\n            if(tmp == x)\\n                return mid;\\n            // If square of mid is less than x...\\n            // jump to the end half by setting beg = mid + 1...\\n            if(tmp < x) {\\n                res = mid;\\n                beg = mid + 1;\\n            }", "int mySqrt(int x) {\\n        //If the number is less than or equal to 1, return itself...\\n        if(x <= 1)\\n            return x;\\n        // Call the sqrt() function & Floor the value obtained...\\n        return floor(sqrt(x));      // Apply floor() to avoid any decimal value.\\n    }", "int mySqrt(int x){\\n    long int i = 1, res;\\n    if(x == 0)\\n        return 0;\\n    for(i; i*i <= x; i++) {\\n        res = i;\\n    }"], ["int mySqrt(int x) {\\n        if(x == 0) // To avoid division by 0\\n            return 0;\\n        int start = 1, end = x / 2 + 1; // The squareroot can only lie in this range\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(mid == x / mid) // Not multiplying as the product for a large number may be greater than the max value of int\\n                return mid;\\n            else if(mid < x / mid) \\n                start = mid + 1;\\n            else\\n                end = mid - 1;\\n        }"]]}
{"id": "15", "ref_c": [["int climbStairs(int n) {\\n        \\n        if(n <= 2) return n;\\n\\n        int prev2 = 1;\\n        int prev1 = 2;\\n        int curr;\\n\\n        for(int i = 3; i <= n; i++)\\n        {\\n            curr = prev1 + prev2;\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }"], ["int climbStairs(int n) {\\nconstexpr double sqrt5plus1over2 = 1.6180339887499;\\nconstexpr double one_minus_sqrt5over2 = -0.6180339887499;\\nconstexpr double sqrt5 = 2.2360679774997897;\\nreturn int(round((pow (sqrt5plus1over2, n + 1) - pow (one_minus_sqrt5over2, n + 1)) / sqrt5));\\n}"], ["int climbStairs(int n) {\\n        \\n        if(n <= 2) return n;\\n\\n        int prev2 = 1;\\n        int prev1 = 2;\\n        int curr;\\n\\n        for(int i = 3; i <= n; i++)\\n        {\\n            curr = prev1 + prev2;\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }"]]}
{"id": "16", "ref_c": [["struct ListNode* deleteDuplicates(struct ListNode* head) {\\n    struct ListNode* temp=head;\\n    while (temp&&temp->next)\\n    {\\n        if (temp->next->val==temp->val)\\n        {\\n            temp->next=temp->next->next;\\n            continue;\\n        }"], ["struct ListNode* deleteDuplicates(struct ListNode* head)\\n{\\n    struct ListNode*k=head;\\n    struct ListNode*z;\\n    if(head==NULL)\\n    return head;\\n    int i;\\n    for(i=0;i<5;i++)\\n    {while(k->next!=NULL)\\n    {\\n        z=k;\\n        k=k->next;\\n        if(z->val==k->val)\\n        {\\n            z->next=k->next;\\n        }"], ["struct ListNode* deleteDuplicates(struct ListNode* head){\\n    \\n    struct ListNode* current = head;\\n    struct ListNode* new_list = head;\\n\\n    \\n    while(current !=NULL && current->next!=NULL)\\n    {\\n        if(current->val == current->next->val)\\n        {\\n            current->next = current->next->next;\\n}"]]}
{"id": "17", "ref_c": [["void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){\\n    // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n    int i = m - 1;\\n    int j = n -1;\\n    // Create a loop until either of i or j becomes zero...\\n    while(i>=0 && j>=0) {\\n        if(nums1[i] > nums2[j]) {\\n            nums1[i+j+1] = nums1[i];\\n            i--;\\n        }"], ["void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)\\n{\\n    int i = nums1Size-1;\\n    while (n > 0)\\n    {\\n        if (m == 0 || nums2[n-1] > nums1[m-1])\\n        {\\n            nums1[i] = nums2[n-1];\\n            --n;\\n        }"], ["void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){\\n    // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n    int i = m - 1;\\n    int j = n -1;\\n    // Create a loop until either of i or j becomes zero...\\n    while(i>=0 && j>=0) {\\n        if(nums1[i] > nums2[j]) {\\n            nums1[i+j+1] = nums1[i];\\n            i--;\\n        }"]]}
{"id": "18", "ref_c": [["int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int* res = (int*)malloc(100 * sizeof(int));  // Vector to store inorder traversal result\\n    struct StackNode* st = NULL;                 // Stack to assist in traversal\\n    struct TreeNode* curr = root;                // Pointer to track the current node\\n    int index = 0;                               // Index to track the position in the result array\\n\\n    // Traverse the tree until current node is not null or stack is not empty\\n    while (curr != NULL || !isEmpty(st)) {\\n        // Traverse to the leftmost node of the current subtree\\n        while (curr != NULL) {\\n            push(&st, curr);          // Push current node to stack\\n            curr = curr->left;        // Move to the left child\\n        }"], ["int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = (int *)malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n\\n    if (root == NULL) {\\n        return result;\\n    }"], ["int* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    inorder(root);\\n    int* ans=malloc(i*sizeof(int));\\n    for(int j=0;j<i;j++) ans[j]=arr[j];\\n    *(returnSize)=i;\\n    i=0;\\n    return ans;\\n}"]]}
{"id": "19", "ref_c": [["bool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) // Same Tree\\n            return true;\\n        if(p == NULL || q == NULL) // Different Size\\n            return false;\\n        if(p->val != q->val) // Different Nodes\\n            return false;\\n        return isSameTree(p->left,q->left) &&// check left subtree\\n               isSameTree(p->right,q->right);// check right subtree\\n}", "bool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) return true;\\n        if(p == NULL || q == NULL) return false;\\n        if(p->val != q->val) return false;\\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n}"], ["bool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}"], ["bool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}"]]}
{"id": "20", "ref_c": ["\nbool parallel_traverse(struct TreeNode* a, struct TreeNode* b)\n{\n    if (a == NULL && b == NULL)\n        return true;\n \n    if (a == NULL || b == NULL)\n        return false;\n\n    if (a->val != b->val)\n        return false;\n    \n    return parallel_traverse(a->left, b->right) && parallel_traverse(a->right, b->left);\n}\n\nbool isSymmetric(struct TreeNode* root)\n{\n    if (root == NULL)\n        return true;\n    return parallel_traverse(root->left, root->right);\n}\n", "\nbool parallel_traverse(struct TreeNode* a, struct TreeNode* b)\n{\n    if (a == NULL && b == NULL)\n        return true;\n \n    if (a == NULL || b == NULL)\n        return false;\n\n    if (a->val != b->val)\n        return false;\n    \n    return parallel_traverse(a->left, b->right) && parallel_traverse(a->right, b->left);\n}\n\nbool isSymmetric(struct TreeNode* root)\n{\n    if (root == NULL)\n        return true;\n    return parallel_traverse(root->left, root->right);\n}\n", "\nbool parallel_traverse(struct TreeNode* a, struct TreeNode* b)\n{\n    if (a == NULL && b == NULL)\n        return true;\n \n    if (a == NULL || b == NULL)\n        return false;\n\n    if (a->val != b->val)\n        return false;\n    \n    return parallel_traverse(a->left, b->right) && parallel_traverse(a->right, b->left);\n}\n\nbool isSymmetric(struct TreeNode* root)\n{\n    if (root == NULL)\n        return true;\n    return parallel_traverse(root->left, root->right);\n}\n"]}
{"id": "21", "ref_c": [["int maxDepth(struct TreeNode* root){\\n    if(root == NULL)\\n        return 0;\\n    else {\\n        int leftDepth = maxDepth(root->left);\\n        int rightDepth = maxDepth(root->right);\\n        if(leftDepth > rightDepth)\\n            return leftDepth + 1;\\n        else\\n            return rightDepth + 1;\\n    }"], ["int maxDepth(struct TreeNode* root){\\n    if(root == NULL)\\n        return 0;\\n    else {\\n        int leftDepth = maxDepth(root->left);\\n        int rightDepth = maxDepth(root->right);\\n        if(leftDepth > rightDepth)\\n            return leftDepth + 1;\\n        else\\n            return rightDepth + 1;\\n    }"], ["int maxDepth(struct TreeNode* root){\\n    if(root == NULL)\\n        return 0;\\n    else {\\n        int leftDepth = maxDepth(root->left);\\n        int rightDepth = maxDepth(root->right);\\n        if(leftDepth > rightDepth)\\n            return leftDepth + 1;\\n        else\\n            return rightDepth + 1;\\n    }"]]}
{"id": "22", "ref_c": [["struct TreeNode* sortedArrayToBST(int* nums, int numsSize){\\n    if(numsSize <= 0)\\n        return NULL;\\n    else\\n        return ConvToBST(nums, 0, numsSize-1);\\n}"], ["struct TreeNode* sortedArrayToBST(int* nums, int numsSize){\\n    \\n    //When array is empty\\n    if(numsSize <= 0)\\n        return NULL;\\n    else\\n        return bst(nums, 0, numsSize-1);\\n    \\n    \\n}"], ["struct TreeNode* sortedArrayToBST(int* nums, int numsSize){\\n    \\n    //When array is empty\\n    if(numsSize <= 0)\\n        return NULL;\\n    else\\n        return bst(nums, 0, numsSize-1);\\n    \\n    \\n}"]]}
{"id": "23", "ref_c": [["bool isBalanced(struct TreeNode* root){\\n    int result = balance(root);\\n    if(result == -1)\\n        return false;\\n    else \\n        return true;\\n}"], ["bool isBalanced(struct TreeNode* root){\\n    int result = balance(root);\\n    if(result == -1)\\n        return false;\\n    else \\n        return true;\\n}"], ["bool isBalanced(struct TreeNode* root){\\n    int result = balance(root);\\n    if(result == -1)\\n        return false;\\n    else \\n        return true;\\n}"]]}
{"id": "24", "ref_c": [["int minDepth(struct TreeNode* root){\\n    if(root == NULL)\\n        return 0;\\n    else {\\n        int leftDepth = minDepth(root->left);\\n        int rightDepth = minDepth(root->right);\\n        if(leftDepth > rightDepth)\\n            return rightDepth + 1;\\n        else\\n            return leftDepth + 1;\\n    }"], ["int minDepth(struct TreeNode* root){\\n    if(root == NULL)\\n        return 0;\\n    else {\\n        int leftDepth = minDepth(root->left);\\n        int rightDepth = minDepth(root->right);\\n        if(leftDepth > rightDepth)\\n            return rightDepth + 1;\\n        else\\n            return leftDepth + 1;\\n    }"], ["int minDepth(struct TreeNode* root){\\n    int x,y;\\n    if(root == NULL)\\n        return 0;\\n    else{\\n    x=minDepth(root->left);\\n    y=minDepth(root->right);\\n    if ((x==0) ^ (y==0)) \\n    return (x>y?x:y)+1 ;\\n    if(x > y)\\n    return y + 1;\\n    else\\n    return x + 1;\\n    }"]]}
{"id": "25", "ref_c": ["\nbool hasPathSum(struct TreeNode *root, int targetSum)\n{\n  if(!root)\n    return 0;\n  targetSum -= root->val;\n  return (!targetSum && !root->right && !root->left) ||\n    hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum);\n}\n", "\nbool hasPathSum(struct TreeNode *root, int targetSum)\n{\n  if(!root)\n    return 0;\n  targetSum -= root->val;\n  return (!targetSum && !root->right && !root->left) ||\n    hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum);\n}\n", "\nbool hasPathSum(struct TreeNode *root, int targetSum)\n{\n  if(!root)\n    return 0;\n  targetSum -= root->val;\n  return (!targetSum && !root->right && !root->left) ||\n    hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum);\n}\n"]}
{"id": "26", "ref_c": [["int** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    // *returnSize is a pointer to an integer\\n    // **returnColumnSizes is a pointer to an array of integers\\n\\n    *returnSize = numRows;\\n    \\n    *returnColumnSizes = (int*)malloc(numRows * sizeof(int));\\n\\n    // create a 2D-array\\n    int** triangle = (int**)malloc(numRows * sizeof(int*));\\n    \\n    // allocate memory and populate the rows\\n    for(int i = 0; i < numRows; i++){\\n        \\n        (*returnColumnSizes)[i] = i+1;\\n\\n        triangle[i] = (int*)malloc( (i+1) * sizeof(int));\\n\\n        for(int j = 0; j <= i; j++){\\n\\n            if(j == 0 || j == i){\\n                triangle[i][j] = 1;\\n            }"], ["int** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    *returnSize=numRows;\\n    int s=0;\\n    int **p=(int**)malloc(numRows*sizeof(int*));\\n    *returnColumnSizes = (int*) malloc(numRows*sizeof(int));\\n    for(int i=0;i<numRows;i++)\\n    {\\n        p[i]=(int*)malloc(sizeof(int)*(i+1));\\n        (*returnColumnSizes)[i]=i+1;\\n        p[i][0]=1;\\n        p[i][i]=1;\\n        for(int j=1;j<i;j++)\\n        {\\n            p[i][j]=p[i-1][j-1]+p[i-1][j];\\n        }"], ["int** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    *returnSize = numRows;\\n    *returnColumnSizes = (int*)malloc(sizeof(int)*numRows);\\n    for(int i = 0;i < numRows;i++){\\n        (*returnColumnSizes)[i] = i+1;\\n    }"]]}
{"id": "27", "ref_c": [["int* getRow(int rowIndex, int* returnSize) {\\n    // Initialize a 2D array to represent Pascal\\'s Triangle\\n    int** pascalTriangle = (int**)malloc((rowIndex + 1) * sizeof(int*));\\n    \\n    for (int i = 0; i <= rowIndex; i++) {\\n        pascalTriangle[i] = (int*)malloc((i + 1) * sizeof(int));\\n    }", "int* getRow(int rowIndex, int* returnSize) {\\n    // Initialize a 2D array to represent Pascal\\'s Triangle\\n    int** pascalTriangle = (int**)malloc(2 * sizeof(int*));\\n    for (int i = 0; i < 2; i++) {\\n        pascalTriangle[i] = (int*)malloc((rowIndex + 1) * sizeof(int));\\n    }", "int* getRow(int rowIndex, int* returnSize) {\\n    // Initialize an array to represent the last row\\n    int* lastRow = (int*)malloc((rowIndex + 1) * sizeof(int));\\n\\n    for (int j = 0; j <= rowIndex; j++) {\\n        // Calculate and insert the binomial coefficient (nCr) into the row\\n        lastRow[j] = (int)calculateCombination(rowIndex, j);\\n    }"], ["int* getRow(int rowIndex, int* returnSize) {\\n    // Initialize a 2D array to represent Pascal\\'s Triangle\\n    int** pascalTriangle = (int**)malloc((rowIndex + 1) * sizeof(int*));\\n    \\n    for (int i = 0; i <= rowIndex; i++) {\\n        pascalTriangle[i] = (int*)malloc((i + 1) * sizeof(int));\\n    }", "int* getRow(int rowIndex, int* returnSize) {\\n    // Initialize a 2D array to represent Pascal\\'s Triangle\\n    int** pascalTriangle = (int**)malloc(2 * sizeof(int*));\\n    for (int i = 0; i < 2; i++) {\\n        pascalTriangle[i] = (int*)malloc((rowIndex + 1) * sizeof(int));\\n    }", "int* getRow(int rowIndex, int* returnSize) {\\n    // Initialize an array to represent the last row\\n    int* lastRow = (int*)malloc((rowIndex + 1) * sizeof(int));\\n\\n    for (int j = 0; j <= rowIndex; j++) {\\n        // Calculate and insert the binomial coefficient (nCr) into the row\\n        lastRow[j] = (int)calculateCombination(rowIndex, j);\\n    }"], ["int* getRow(int rowIndex, int* returnSize) {\\n    // Initialize a 2D array to represent Pascal\\'s Triangle\\n    int** pascalTriangle = (int**)malloc((rowIndex + 1) * sizeof(int*));\\n    \\n    for (int i = 0; i <= rowIndex; i++) {\\n        pascalTriangle[i] = (int*)malloc((i + 1) * sizeof(int));\\n    }", "int* getRow(int rowIndex, int* returnSize) {\\n    // Initialize a 2D array to represent Pascal\\'s Triangle\\n    int** pascalTriangle = (int**)malloc(2 * sizeof(int*));\\n    for (int i = 0; i < 2; i++) {\\n        pascalTriangle[i] = (int*)malloc((rowIndex + 1) * sizeof(int));\\n    }", "int* getRow(int rowIndex, int* returnSize) {\\n    // Initialize an array to represent the last row\\n    int* lastRow = (int*)malloc((rowIndex + 1) * sizeof(int));\\n\\n    for (int j = 0; j <= rowIndex; j++) {\\n        // Calculate and insert the binomial coefficient (nCr) into the row\\n        lastRow[j] = (int)calculateCombination(rowIndex, j);\\n    }"]]}
{"id": "28", "ref_c": [["int maxProfit(int* prices, int pricesSize) {\\n    int minPrice = 10000;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < pricesSize; i++) {\\n        if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n            continue; // cannot have new minPrice \\n                      // and new maxProfit at the same time\\n        }"], ["int maxProfit(int* prices, int pricesSize) {\\n    int minPrice = 10000;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < pricesSize; i++) {\\n        if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n            continue; // cannot have new minPrice \\n                      // and new maxProfit at the same time\\n        }"], ["int maxProfit(int* prices, int pricesSize) {\\n    int minPrice = 10000;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < pricesSize; i++) {\\n        if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n            continue; // cannot have new minPrice \\n                      // and new maxProfit at the same time\\n        }"]]}
{"id": "29", "ref_c": [["bool isPalindrome(char * s){\\n    int len, flag;\\n    \\n    len = strlen(s);\\n    flag = 1;\\n    if(len == 1)\\n        return 1;\\n\\n    for(int i = 0, k = len - 1; i <= k; i++, k--){\\n        flag = 1;\\n        char sym1, sym2;\\n        sym1 = sym2 = -1;\\n        while(flag && i <= k){\\n            if(\\'A\\' <= s[i]&& s[i]<= \\'Z\\'){\\n                sym1 = s[i] + 32;\\n                flag = 0;\\n            }"], ["bool isPalindrome(char * s){\\n    char* j = s + strlen(s) - 1;\\n    \\n    while(j > s) \\n    {  \\n        if (isalnum(*s) && isalnum(*j))\\n        {\\n            if (tolower(*s++) != tolower(*j--)) return false;\\n        }"], ["bool isPalindrome(char * s){\\n    char* j = s + strlen(s) - 1;\\n    \\n    while(j > s) \\n    {  \\n        if (isalnum(*s) && isalnum(*j))\\n        {\\n            if (tolower(*s++) != tolower(*j--)) return false;\\n        }"]]}
{"id": "30", "ref_c": [["int singleNumber(int* nums, int numsSize){\\n    // Initialize the unique number...\\n    int uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (int idx = 0; idx < numsSize; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    }"], ["int singleNumber(int* nums, int numsSize){\\n    // Initialize the unique number...\\n    int uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (int idx = 0; idx < numsSize; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    }"], ["int singleNumber(int* nums, int numsSize){\\n    int uniqNum = 0;\\n    for (int idx = 0; idx < numsSize; idx++) {\\n        uniqNum = uniqNum ^ nums[idx];\\n    }"]]}
{"id": "31", "ref_c": [["bool hasCycle(struct ListNode *head) {\\n    struct ListNode*p=head,*q=head;\\n    if(head==NULL)\\n        return false;\\n    if(head->next==NULL)\\n        return false;\\n    do\\n    {\\n        p=p->next;\\n        q=q->next;\\n        if(q)\\n            q=q->next;\\n        else\\n            q=NULL;\\n    }"], ["bool hasCycle(struct ListNode *head) {\\n    if(head == NULL)    return NULL;\\n    if(head->next == NULL)    return 0;\\n    struct ListNode *slow = head , *fast = head;\\n    \\n    while(fast != NULL && fast->next != NULL)\\n    {\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow)    return 1;\\n    }"], ["bool hasCycle(struct ListNode *head) {\\n    if(head == NULL)    return NULL;\\n    if(head->next == NULL)    return 0;\\n    struct ListNode *slow = head , *fast = head;\\n    \\n    while(fast != NULL && fast->next != NULL)\\n    {\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        if(fast == slow)    return 1;\\n    }"]]}
{"id": "32", "ref_c": [["int* preorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    struct TreeNode* stack[100] = {NULL}", "int* preorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    int size = 0;\\n    preorder(root, res, &size);\\n    *returnSize = size;\\n    return res;\\n}"], ["int* preorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    struct TreeNode* stack[100] = {NULL}", "int* preorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    int size = 0;\\n    preorder(root, res, &size);\\n    *returnSize = size;\\n    return res;\\n}"], ["int* preorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    struct TreeNode* stack[100] = {NULL}", "int* preorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    int size = 0;\\n    preorder(root, res, &size);\\n    *returnSize = size;\\n    return res;\\n}"]]}
{"id": "33", "ref_c": [["int* postorderTraversal(struct TreeNode* root, int* returnSize){\\n    int* ans = malloc(101*sizeof(int));\\n    *returnSize = 0;\\n    post(root,returnSize,ans);\\n    return ans;\\n}"], ["int* postorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    struct TreeNode* stack[100] = {NULL}"], ["int* postorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int* Stack = (int*)malloc(sizeof(int)*100);\\n    int Stack_Cnt = 0;\\n\\n    SearchTree_POT(root, Stack, &Stack_Cnt);\\n\\n    *returnSize = Stack_Cnt;\\n    return Stack;\\n}"]]}
{"id": "34", "ref_c": [["struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n \\n    // 1. Traverse A and B to find their lengths\\n    int countA = 0, countB = 0;\\n    for (struct ListNode *thisA = headA; thisA != NULL; thisA = thisA->next) {\\n        ++countA;\\n    }"], ["struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (headA == NULL || headB == NULL)\\n        return NULL;\\n\\n    struct ListNode* A = headA;\\n    struct ListNode* B = headB;\\n\\n    while (A != B) {\\n        A = A == NULL ? headB : A->next;\\n        B = B == NULL ? headA : B->next;\\n    }"], ["struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n \\n    // 1. Traverse A and B to find their lengths\\n    int countA = 0, countB = 0;\\n    for (struct ListNode *thisA = headA; thisA != NULL; thisA = thisA->next) {\\n        ++countA;\\n    }"]]}
{"id": "35", "ref_c": [["char * convertToTitle(int columnNumber){\\n\\n    char* ans = malloc(8);\\n    char index = 0;\\n    char i, j, tempVar;\\n\\n    while(columnNumber)\\n    {\\n        if(columnNumber>26)\\n        {\\n            tempVar = columnNumber%26;\\n\\n            if(tempVar == 0)\\n            {\\n                ans[index++] = \\'Z\\';\\n                columnNumber /= 26;\\n                columnNumber--;\\n            }"], ["char * convertToTitle(int columnNumber){\\n\\n    char* ans = malloc(8);\\n    char index = 0;\\n    char i, j, tempVar;\\n\\n    while(columnNumber)\\n    {\\n        if(columnNumber>26)\\n        {\\n            tempVar = columnNumber%26;\\n\\n            if(tempVar == 0)\\n            {\\n                ans[index++] = \\'Z\\';\\n                columnNumber /= 26;\\n                columnNumber--;\\n            }"], ["char * convertToTitle(int columnNumber){\\n\\n    char* ans = malloc(8);\\n    char index = 0;\\n    char i, j, tempVar;\\n\\n    while(columnNumber)\\n    {\\n        if(columnNumber>26)\\n        {\\n            tempVar = columnNumber%26;\\n\\n            if(tempVar == 0)\\n            {\\n                ans[index++] = \\'Z\\';\\n                columnNumber /= 26;\\n                columnNumber--;\\n            }"]]}
{"id": "36", "ref_c": [["int majorityElement(int* nums, int numsSize){\\n    int vote=0;\\n    int candidate=-1;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(vote==0)\\n        {\\n            candidate=nums[i];\\n            vote=1;\\n        }"], ["int majorityElement(int* nums, int numsSize){\\n    int sol = nums[0],\\n    cnt = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (cnt == 0) {\\n            sol = nums[i];\\n        }"], ["int majorityElement(int* nums, int numsSize){\\n    int j=0,u=0;\\nfor(int i=0;i<numsSize;i++){\\n    if(j==0)\\n        u=nums[i];\\n    if(u==nums[i])\\n        j++;\\n    else\\n        j--;\\n}"]]}
{"id": "37", "ref_c": [["int titleToNumber(char * columnTitle){\\n    int output = 0;\\n    for(int i = 0; i < strlen(columnTitle); i++){\\n        output *= 26;\\n        output += (columnTitle[i] - \\'A\\' + 1);\\n    }"], ["int titleToNumber(char * columnTitle){\\n    int output = 0;\\n    for(int i = 0; i < strlen(columnTitle); i++){\\n        output *= 26;\\n        output += (columnTitle[i] - \\'A\\' + 1);\\n    }"], ["int titleToNumber(char * columnTitle){\\n    int output = 0;\\n    for(int i = 0; i < strlen(columnTitle); i++){\\n        output *= 26;\\n        output += (columnTitle[i] - \\'A\\' + 1);\\n    }"]]}
{"id": "42", "ref_c": [["int i = 0; i < 32; i++) ans |= (1 | (n >> i)) << (32 - i);\\n    return ans;\\n}"], ["int i = 0; i < 32; i++) ans |= (1 | (n >> i)) << (32 - i);\\n    return ans;\\n}"], ["int i = 0; i < 32; i++) ans |= (1 | (n >> i)) << (32 - i);\\n    return ans;\\n}"]]}
{"id": "43", "ref_c": [["int hammingWeight(uint32_t n) {\\n        uint32_t bitMask = 1;\\n        uint32_t count = 0;\\n        while(n)\\n        {\\n            if(n & bitMask)\\n                count++;\\n            n = n >> bitMask;\\n        }", "int hammingWeight(uint32_t n) {\\n    uint32_t bitMask = 1;\\n    uint32_t count = 0;\\n    while(n)\\n    {\\n        if(n & bitMask)\\n            count++;\\n        n >>= bitMask;\\n    }"], ["int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n != 0) {\\n            n &= (n - 1);\\n            count++;\\n        }", "int hammingWeight(uint32_t n) {\\n    int count = 0;\\n    while (n != 0) {\\n        n &= (n - 1);\\n        count++;\\n    }", "int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        while (n != 0) {\\n            count += n & 1;\\n            n >>= 1;\\n        }", "int hammingWeight(uint32_t n) {\\n    int count = 0;\\n    while (n != 0) {\\n        count += n & 1;\\n        n >>= 1;\\n    }", "int hammingWeight(uint32_t n) {\\n        int count = 0;\\n        string binaryString = bitset<32>(n).to_string();\\n        for (char c : binaryString) {\\n            if (c == \\'1\\') {\\n                count++;\\n            }", "int hammingWeight(uint32_t n) {\\n    int count = 0;\\n    for (int i = 0; i < 32; i++) {\\n        if ((n >> i) & 1) {\\n            count++;\\n        }"], ["int hammingWeight(uint32_t n) {\\n        int count = 0;  // Initialize a counter to store the count of set bits\\n        \\n        // Loop through each bit of the number until the entire number becomes 0\\n        while (n != 0) {\\n            if (n & 1) {  // Check if the least significant bit (LSB) is set (equal to 1) using bitwise AND operation\\n                count++; // If the LSB is set, increment the count\\n            }", "int hammingWeight(uint32_t n) {\\n    int count = 0;  // Initialize a counter to store the count of set bits\\n    \\n    // Loop through each bit of the number until the entire number becomes 0\\n    while (n != 0) {\\n        if (n & 1) {  // Check if the least significant bit (LSB) is set (equal to 1) using bitwise AND operation\\n            count++; // If the LSB is set, increment the count\\n        }"]]}
{"id": "48", "ref_c": [["bool isHappy(int n) {\\n        int sum = 0, digit;\\n\\t\\t//If n starts with 1 return true.\\n        if(n==1) return true;\\n\\t\\t//If n == 0,2,3,4. It is not happy.\\n        while(n>4){\\n\\t\\t\\t//Finding sum of digits^2 inside of n.\\n            while(n!=0){\\n                digit = n%10;\\n                n/=10;\\n                sum += digit * digit;\\n            }"], ["bool isHappy(int n) {\\n    int slowPointer = n;\\n    int fastPointer = nextNumber(n);\\n\\n    while (fastPointer != 1 && fastPointer != slowPointer) {\\n        slowPointer = nextNumber(slowPointer);\\n        fastPointer = nextNumber(nextNumber(fastPointer));\\n    }"], ["bool isHappy(int num){\\n    int result = num;\\n    while (1)\\n    {\\n        result = Sum(result);\\n        if(result == 1) return true;\\n        if(result == 89) return false;\\n    }"]]}
{"id": "49", "ref_c": [["struct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode *prev, *curr;\\n    //deal with leading \\'val\\'s\\n    // If the head node is not null and the value of the head node is same as the target val...\\n    while(head != NULL && head->val == val)\\n        // Skip the value and keep updating head node...\\n        head = head->next;\\n    // Deal with \\'val\\'s not in head of list...\\n    // curr node points to the head node...\\n    curr = head;\\n    // Loop till curr not null...\\n    while(curr != NULL){\\n        // If we find the target val same as the value of curr...\\n        if(curr->val == val){\\n            // Skip that value and keep updating...\\n            prev->next = curr->next;\\n        }"], ["struct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode* temp;\\n\\n    while(head && head->val == val) {\\n        temp = head;\\n        head = head->next;\\n        free(temp);\\n    }"], ["struct ListNode* removeElements(struct ListNode* head, int val)\\n{\\n      struct ListNode *th = head;\\n       struct ListNode *prev = NULL;\\n\\n      while(th!=NULL)\\n      {\\n          if(th->val == val)\\n           {\\n              if(prev == NULL)\\n              {\\n                  head = th->next;\\n                  free(th);\\n                  th=head;\\n              }"]]}
{"id": "50", "ref_c": [["bool isIsomorphic(char * s, char * t){\\n    char f2s[128]={0}"], ["bool isIsomorphic(char * s, char * t){\\n    char f2s[128]={0}"], ["bool isIsomorphic(char * s, char * t){\\n    char f2s[128]={0}"]]}
{"id": "51", "ref_c": [["struct ListNode* reverseList(struct ListNode* head){\\n    // Special case...\\n    if(head == NULL || head->next == NULL)  return head;\\n    // Initialize prev pointer as the head...\\n    struct ListNode* prev = head;\\n    // Initialize curr pointer as the next pointer of prev...\\n    struct ListNode* curr = prev->next;\\n    // Initialize next of head pointer as NULL...\\n    head->next = NULL;\\n    // Run a loop till curr and prev points to NULL...\\n    while(prev != NULL && curr != NULL){\\n        // Initialize next pointer as the next pointer of curr...\\n        struct ListNode* next = curr->next;\\n        // Now assign the prev pointer to curr\\u2019s next pointer.\\n        curr->next = prev;\\n        // Assign curr to prev, next to curr...\\n        prev = curr;\\n        curr = next;\\n    }"], ["struct ListNode* reverseList(struct ListNode* head){\\n\\n    struct ListNode* temp=NULL;\\n    struct ListNode* previous=NULL;\\n\\n    while(head!=NULL)\\n    {\\n        temp=head->next;\\n        head->next=previous;\\n        previous=head;\\n        head=temp;\\n    }"], ["struct ListNode* reverseList(struct ListNode* head){\\n    // Special case...\\n    if(head == NULL || head->next == NULL)  return head;\\n    // Initialize prev pointer as the head...\\n    struct ListNode* prev = head;\\n    // Initialize curr pointer as the next pointer of prev...\\n    struct ListNode* curr = prev->next;\\n    // Initialize next of head pointer as NULL...\\n    head->next = NULL;\\n    // Run a loop till curr and prev points to NULL...\\n    while(prev != NULL && curr != NULL){\\n        // Initialize next pointer as the next pointer of curr...\\n        struct ListNode* next = curr->next;\\n        // Now assign the prev pointer to curr\\u2019s next pointer.\\n        curr->next = prev;\\n        // Assign curr to prev, next to curr...\\n        prev = curr;\\n        curr = next;\\n    }"]]}
{"id": "52", "ref_c": [["bool containsDuplicate(int* nums, int numsSize)\\n{\\n    qsort(nums, numsSize, sizeof(int), cmp); \\n\\n    for (int i = 1; i < numsSize; i++)\\n        if (nums[i] == nums[i-1])\\n            return true;\\n\\n    return false;\\n}"], ["bool containsDuplicate(int* nums, int numsSize)\\n{\\n    qsort(nums, numsSize, sizeof(int), cmp); \\n\\n    for (int i = 1; i < numsSize; i++)\\n        if (nums[i] == nums[i-1])\\n            return true;\\n\\n    return false;\\n}"], ["bool containsDuplicate(int* nums, int numsSize)\\n{\\n    qsort(nums, numsSize, sizeof(int), cmp); \\n\\n    for (int i = 1; i < numsSize; i++)\\n        if (nums[i] == nums[i-1])\\n            return true;\\n\\n    return false;\\n}"]]}
{"id": "53", "ref_c": [["bool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    \\n    struct node dict[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n            dict[i].val = nums[i];\\n            dict[i].index = i;\\n    }"], ["bool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    \\n    struct node dict[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n            dict[i].val = nums[i];\\n            dict[i].index = i;\\n    }"], ["bool containsNearbyDuplicate(int* nums, int numsSize, int k) {\\n    \\n    struct node dict[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n            dict[i].val = nums[i];\\n            dict[i].index = i;\\n    }"]]}
{"id": "54", "ref_c": [["int countNodes(struct TreeNode* root){\\n    if(root==NULL){\\n        return 0;\\n    }"], ["int countNodes(struct TreeNode* root) {\\n    int ans = counter(root);\\n    i = 0;\\n    return ans;\\n}"], ["int countNodes(struct TreeNode* root) {\\n    if(root==NULL)\\n    {\\n        return 0;\\n    }"]]}
{"id": "56", "ref_c": [["struct TreeNode* invertTree(struct TreeNode* root){\\n    // Base case...\\n    if(root == NULL){\\n        return root;\\n    }"], ["struct TreeNode* invertTree(struct TreeNode* root){\\n    // Base case...\\n    if(root == NULL){\\n        return root;\\n    }"], ["struct TreeNode* invertTree(struct TreeNode* root){\\n    // Base case...\\n    if(root == NULL){\\n        return root;\\n    }"]]}
{"id": "57", "ref_c": [["char ** summaryRanges(int* nums, int numsSize, int* returnSize){\\n    int start = 0;\\n    char** final_arr = (char**)malloc(20*sizeof(char*));\\n    int count =0;\\n        for (int k=0;k<numsSize;k++){\\n            if (k==0 || nums[k]-1 > nums[k-1]){ // did \"-1\" here, since the number will not be stored (too large)\\n                start=nums[k];\\n            }"], ["char ** summaryRanges(int* nums, int numsSize, int* returnSize){\\n    int start = 0;\\n    char** final_arr = (char**)malloc(20*sizeof(char*));\\n    int count =0;\\n        for (int k=0;k<numsSize;k++){\\n            if (k==0 || nums[k]-1 > nums[k-1]){ // did \"-1\" here, since the number will not be stored (too large)\\n                start=nums[k];\\n            }"], ["char ** summaryRanges(int* nums, int numsSize, int* returnSize){\\n    int start = 0;\\n    char** final_arr = (char**)malloc(20*sizeof(char*));\\n    int count =0;\\n        for (int k=0;k<numsSize;k++){\\n            if (k==0 || nums[k]-1 > nums[k-1]){ // did \"-1\" here, since the number will not be stored (too large)\\n                start=nums[k];\\n            }"]]}
{"id": "58", "ref_c": [["bool isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        while(n%2==0) n/=2;\\n        return n==1;\\n    }", "bool isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        return ((n==1) || (n%2==0 && isPowerOfTwo(n/2)));\\n    }", "bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        return ((n&(n-1))==0);\\n    }", "bool isPowerOfTwo(int n) {\\n        if(n <= 0) return false;\\n        return ceil(log2(n)) == floor(log2(n));\\n    }", "bool isPowerOfTwo(int n) {\\n        if(n<0)return false;\\n        \\n        int bits=__builtin_popcount(n);\\n        \\n        if(bits==1)\\n            return true;\\n        return false;\\n    }", "bool isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        return (n>0)&&(1073741824%n==0);\\n    }"], ["bool isPowerOfTwo(int n) {\\n        int i=1;\\n        int x =n%2;\\n        int y=n;\\n       \\n        if(n==1)\\n        return true;\\n      for(i=1;i<y/2+1;i++)\\n       {  \\n         \\n         \\n          if(n%2==0)\\n          {  n =n/2;\\n             if(n==1)\\n         { return true;}"], ["bool isPowerOfTwo(int n) {\\n        // If n <= 0 that means its a negative hence not a power of 2...\\n        if (n <= 0){\\n            return false;\\n        }", "bool isPowerOfTwo(int n){\\n    if(n == 1)\\n        return true;\\n    else if(n == 0)\\n        return false;\\n    else if(n % 2 != 0)\\n        return false;\\n    return isPowerOfTwo(n/2);\\n}"]]}
{"id": "60", "ref_c": [["bool isPalindrome(struct ListNode* head){\\n        if(!head)   return false;\\n        if(!head->next) return true;\\n\\n        struct ListNode *rev_head = NULL , *ptr = head;\\n        while(ptr != NULL)\\n        {\\n            struct ListNode *temp = (struct ListNode*)malloc(sizeof(struct ListNode));\\n            temp->val = ptr->val;\\n            temp->next = rev_head;\\n            rev_head = temp;\\n            ptr = ptr->next;\\n        }"], ["bool isPalindrome(struct ListNode* head){\\n        if(!head)   return false;\\n        if(!head->next) return true;\\n\\n        struct ListNode *rev_head = NULL , *ptr = head;\\n        while(ptr != NULL)\\n        {\\n            struct ListNode *temp = (struct ListNode*)malloc(sizeof(struct ListNode));\\n            temp->val = ptr->val;\\n            temp->next = rev_head;\\n            rev_head = temp;\\n            ptr = ptr->next;\\n        }"], ["bool isPalindrome(struct ListNode* head){\\n        if(!head)   return false;\\n        if(!head->next) return true;\\n\\n        struct ListNode *rev_head = NULL , *ptr = head;\\n        while(ptr != NULL)\\n        {\\n            struct ListNode *temp = (struct ListNode*)malloc(sizeof(struct ListNode));\\n            temp->val = ptr->val;\\n            temp->next = rev_head;\\n            rev_head = temp;\\n            ptr = ptr->next;\\n        }"]]}
{"id": "61", "ref_c": ["\nbool isAnagram(char* s, char* t) {\n    int f[26]={0};\n    register int i;\n    for(i=0; s[i]!='\u0000' && t[i]!='\u0000'; i++){\n        f[s[i]-'a']++; \n        f[t[i]-'a']--;\n    }\n    if (s[i]!='\u0000' || t[i]!='\u0000') \n        return 0;\n    for(register i=0; i<26; i++)\n        if (f[i]!=0) return 0;\n    return 1;\n}\n", "\nbool isAnagram(char* s, char* t) {\n    int f[26]={0};\n    register int i;\n    for(i=0; s[i]!='\u0000' && t[i]!='\u0000'; i++){\n        f[s[i]-'a']++; \n        f[t[i]-'a']--;\n    }\n    if (s[i]!='\u0000' || t[i]!='\u0000') \n        return 0;\n    for(register i=0; i<26; i++)\n        if (f[i]!=0) return 0;\n    return 1;\n}\n", "\nbool isAnagram(char* s, char* t) {\n    int f[26]={0};\n    register int i;\n    for(i=0; s[i]!='\u0000' && t[i]!='\u0000'; i++){\n        f[s[i]-'a']++; \n        f[t[i]-'a']--;\n    }\n    if (s[i]!='\u0000' || t[i]!='\u0000') \n        return 0;\n    for(register i=0; i<26; i++)\n        if (f[i]!=0) return 0;\n    return 1;\n}\n"]}
{"id": "62", "ref_c": [["char ** binaryTreePaths(struct TreeNode* root, int* returnSize){\\n\\tchar** paths=(char**)malloc(sizeof(char*)*37);//1+2+4+8+16+32+\"37\" = 100 => 37 is the max number of leaf nodes, which implies max path num is 37.\\n\\tchar* path=(char*)malloc(sizeof(char)*599); // 100*4(\"-100\")+99*2(\"->\")+1(\\'\\\\0)\\n\\t*returnSize = 0;\\n\\t\\n\\tdfs(root, paths, path, 0, returnSize);\\n\\t\\n\\tfree(path);\\n\\treturn paths;\\n}"], ["char ** binaryTreePaths(struct TreeNode* root, int* returnSize){\\n\\tchar** paths=(char**)malloc(sizeof(char*)*37);//1+2+4+8+16+32+\"37\" = 100 => 37 is the max number of leaf nodes, which implies max path num is 37.\\n\\tchar* path=(char*)malloc(sizeof(char)*599); // 100*4(\"-100\")+99*2(\"->\")+1(\\'\\\\0)\\n\\t*returnSize = 0;\\n\\t\\n\\tdfs(root, paths, path, 0, returnSize);\\n\\t\\n\\tfree(path);\\n\\treturn paths;\\n}"], ["char ** binaryTreePaths(struct TreeNode* root, int* returnSize){\\n\\tchar** paths=(char**)malloc(sizeof(char*)*37);//1+2+4+8+16+32+\"37\" = 100 => 37 is the max number of leaf nodes, which implies max path num is 37.\\n\\tchar* path=(char*)malloc(sizeof(char)*599); // 100*4(\"-100\")+99*2(\"->\")+1(\\'\\\\0)\\n\\t*returnSize = 0;\\n\\t\\n\\tdfs(root, paths, path, 0, returnSize);\\n\\t\\n\\tfree(path);\\n\\treturn paths;\\n}"]]}
{"id": "63", "ref_c": [["int addDigits(int num)\\n{\\n    int sum = 0;\\n    while(num!=0)\\n    {\\n        sum += num%10;\\n        num /=10;\\n    }"], ["int addDigits(int num) {\\n        // If num == 0, then result will be 0...\\n        if(num == 0)\\n            return 0;\\n        // If is divisible by 9, result will be 9...\\n        else if(num % 9 == 0)\\n            return 9;\\n        // if the num is not 0 and is not divisible by 9,\\n        // the result will always num % 9...\\n        else\\n            return num % 9;\\n    }", "int addDigits(int num) {\\n        //  Variable to store the digit sum...\\n        int sum = 0;\\n        // Converts num value into string...\\n        String s = String.valueOf(num);\\n        // Calculation of digit sum...\\n        for(int i = 0; i < s.length(); i++){\\n            sum = sum + (s.charAt(i) - \\'0\\');\\n        }", "int addDigits(int num){\\n    //  Variable to store the digit.\\n    int ans = 0;\\n    // Calculation of digit sum.\\n    while(num) {\\n        ans += (num % 10);\\n        num /= 10;\\n    }"], ["int addDigits(int num) \\n    {\\n        int sum=0;\\n        while(num>0)\\n        {\\n            sum+=num%10;\\n            num/=10;\\n        }"]]}
{"id": "64", "ref_c": [["bool isUgly(int n){\\n    \\n    while(n % 2 == 0 && (n = n / 2));\\n    while(n % 3 == 0 && (n = n / 3));\\n    while(n % 5 == 0 && (n = n / 5));\\n\\n    return n==1;\\n\\n}", "bool isUgly(int n) {\\n        \\n        while(n % 2 == 0 && (n = n / 2));\\n        while(n % 3 == 0 && (n = n / 3));\\n        while(n % 5 == 0 && (n = n / 5));\\n\\n        return n==1;\\n    }"], ["bool isUgly(int n){\\n    if(n < 1) return false;\\n    for(int i=2; i<6  ; i++)\\n        while(n %i == 0)\\n            n/=i;\\n    return n==1;\\n}"], ["bool isUgly(int n) {\\n   if(n<1)  \\n  return false;\\n    while(n%2==0 || n%3==0 || n%5==0)\\n    {\\n        if(n%2==0) n=n/2;\\n        if(n%3==0) n=n/3;\\n        if(n%5==0) n=n/5;\\n    }"]]}
{"id": "65", "ref_c": [["int missingNumber(int* nums, int numsSize){\\n    int res = numsSize;\\n    for(int i=0; i!=numsSize; i++){\\n        res = res + i - nums[i];\\n    }"], ["int missingNumber(int* nums, int numsSize){\\n    int res = numsSize;\\n    for(int i=0; i!=numsSize; i++){\\n        res = res + i - nums[i];\\n    }"], ["int missingNumber(int* nums, int numsSize){\\n    int res = numsSize;\\n    for(int i=0; i!=numsSize; i++){\\n        res = res + i - nums[i];\\n    }"]]}
{"id": "66", "ref_c": [["int firstBadVersion(int n) \\n{\\n    if(!isBadVersion(n))     return n+1;\\n    return firstBadVersion(n-1);\\n}"], ["int firstBadVersion(int n) {\\n   long int f=1,mid;\\n    while(f<n) {\\n        mid = (f+n) / 2;\\n        if(isBadVersion(mid) == true) {\\n            n=mid;\\n        }"], ["int firstBadVersion(int n) {\\n    long int l = 0;\\n    long int r = n-1;\\n    long int prev;\\n    while(l <= r){\\n        prev = (l+r)/2;\\n        if(!isBadVersion(prev)){\\n            if(isBadVersion(prev) != isBadVersion(prev+1)){\\n                return prev+1;\\n            }"]]}
{"id": "67", "ref_c": [["void moveZeroes(int* nums, int numsSize){\\n    int j=0;\\n        for(int i=0;i<numsSize;i++){\\n            if(nums[i]!=0){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j++;\\n            }"], ["void moveZeroes(int* nums, int numsSize){\\n    int j=0;\\n        for(int i=0;i<numsSize;i++){\\n            if(nums[i]!=0){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j++;\\n            }"], ["void moveZeroes(int* nums, int numsSize){\\n    int j=0;\\n        for(int i=0;i<numsSize;i++){\\n            if(nums[i]!=0){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j++;\\n            }"]]}
{"id": "68", "ref_c": [["bool wordPattern(char * pattern, char * s){\\n    // 8 bytes * 26 = 208 bytes\\n    uint64_t m[26] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}"], ["bool wordPattern(char * pattern, char * s){\\n    // 8 bytes * 26 = 208 bytes\\n    uint64_t m[26] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}"], ["bool wordPattern(char * pattern, char * s){\\n    // 8 bytes * 26 = 208 bytes\\n    uint64_t m[26] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}"]]}
{"id": "69", "ref_c": [["bool canWinNim(int n){\\n    return n % 4 != 0 ? true : false;\\n}"], ["bool canWinNim(int n) {\\n    return n % 4 != 0;\\n}"], ["bool canWinNim(int n) {\\n    return n % 4 != 0;\\n}"]]}
{"id": "71", "ref_c": [["bool isPowerOfThree(int n){\\n    if(n==0)\\n    return false;\\n    while(n!=1){\\nif((n>0) && n%3== 0)\\nn=n/3;\\nelse break;\\n    }"], ["bool isPowerOfThree(int n){\\n    return (n > 0) && (1162261467 % n == 0);\\n```\\n\\n\\n2. **Loop solution** (Easy to understand):\\n\\t* This is two simple loop solution.\\n\\t* We can keep mutiply a new variable`x` by 3.\\n\\t* or keep divide `n` by 3\\n\\n**Python code:**\\n\\n1.\\n```\\nclass Solution:\\n    def isPowerOfThree(self, n: int) -> bool:\\n        \\n        #loop solution\\n        x = 1\\n        while x <= n:\\n            if x != n:\\n                x = x * 3\\n            else:\\n                return True\\n        return False\\n```\\n2.\\n```\\nclass Solution:\\n    def isPowerOfThree(self, n: int) -> bool:\\n        if n < 1:\\n            return False\\n        while(n % 3 == 0):\\n            n /= 3\\n        return n == 1\\n```\\n\\n**C code:**\\n\\n1.\\n```\\nbool isPowerOfThree(int n){ \\n    long x = 1; \\n    while(x <= n){ \\n        if (x != n) x = x * 3; \\n        else return true; \\n    }", "bool isPowerOfThree(int n){ \\n    if (n < 1) return false; \\n    while(n % 3 == 0) n = n / 3; \\n    return (n == 1);\\n}"], ["bool isPowerOfThree(int n) {\\n        return fmod((log10(n) / log10(3)), 1) == 0;\\n    }"]]}
{"id": "72", "ref_c": ["\nint* countBits(int n, int* returnSize){\n    *returnSize = n + 1;\n    int* ret = (int*) malloc(*returnSize * sizeof(int));\n    ret[0] = 0;\n    for (int i = 1; i < *returnSize; i++) {\n        ret[i] = (i & 1) + ret[i >> 1];\n    }\n    return ret;\n}\n", "\nint* countBits(int n, int* returnSize){\n    *returnSize = n + 1;\n    int* ret = (int*) malloc(*returnSize * sizeof(int));\n    ret[0] = 0;\n    for (int i = 1; i < *returnSize; i++) {\n        ret[i] = (i & 1) + ret[i >> 1];\n    }\n    return ret;\n}\n", "\nint* countBits(int n, int* returnSize){\n    *returnSize = n + 1;\n    int* ret = (int*) malloc(*returnSize * sizeof(int));\n    ret[0] = 0;\n    for (int i = 1; i < *returnSize; i++) {\n        ret[i] = (i & 1) + ret[i >> 1];\n    }\n    return ret;\n}\n"]}
{"id": "73", "ref_c": [["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if((n - 1) % 3 == 0){\\n\\n\\n        return true; \\n        }", "bool isPowerOfFour(int n) {\\n    if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if ((n - 1) % 3 == 0) {\\n            return true;\\n        }", "bool isPowerOfFour(int n) {\\n       return n>0 && (n&(n-1))==0 && (n % 10 ==1|| n% 10==4|| n%10==6);\\n    }", "bool isPowerOfFour(int n) {\\n    return n > 0 && (n & (n - 1)) == 0 && (n % 10 == 1 || n % 10 == 4 || n % 10 == 6);\\n}"], ["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the logarithm of \\'n\\' with base 4\\n        double logarithmBase4 = log(n) / log(4);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (logarithmBase4 == (int)logarithmBase4);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the logarithm of \\'n\\' with base 4\\n    double logarithmBase4 = log(n) / log(4);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (logarithmBase4 == (int)logarithmBase4);\\n}", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the square root of \\'n\\'\\n        double sqrtN = sqrt(n);\\n\\n        // Take the logarithm base 2 of the square root\\n        double log2SqrtN = log2(sqrtN);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (log2SqrtN == (int)log2SqrtN);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the square root of \\'n\\'\\n    double sqrtN = sqrt(n);\\n\\n    // Take the logarithm base 2 of the square root\\n    double log2SqrtN = log2(sqrtN);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (log2SqrtN == (int)log2SqrtN);\\n}"], ["bool isPowerOfFour(int n){\\n\\n    if(n==1)\\n        return true;\\n    return (n&0x55555554) && !(n&n-1);\\n}"]]}
{"id": "74", "ref_c": [["void reverseString(char* s, int sSize){\\n    char* left = s;\\n    char* right = s + sSize - 1;\\n\\n    while (left < right) {\\n        char temp = *right;\\n        *right-- = *left;\\n        *left++ = temp;\\n    }"], ["void reverseString(char* s, int sSize){\\n    int starting = 0, ending = sSize - 1;\\n    while (starting < ending){\\n        swap(&s[starting++], &s[ending--]);\\n    }"], ["void reverseString(char* s, int sSize){\\n        for(int i=(0x0000000000000000 + 0x0000000000000200 +0x0000000000000800 - 0x0000000000000A00);(i <sSize / (0x0000000000000004 + 0x0000000000000202 +0x0000000000000802 - 0x0000000000000A06)) & !!(i <sSize / (0x0000000000000004 + 0x0000000000000202 +0x0000000000000802 - 0x0000000000000A06));i++)\\n{\\n        char temp=s[i];\\n\\n        s[i] = s[sSize- (0x0000000000000002 + 0x0000000000000201 + 0x0000000000000801 -0x0000000000000A03) -i];\\n\\n        s[sSize - (0x0000000000000002 + 0x0000000000000201 + 0x0000000000000801 -0x0000000000000A03) -i] = temp;\\n\\n        \\n        }"]]}
{"id": "75", "ref_c": ["\nchar *reverseVowels(char *s) {\n    int len = strlen(s);\n    int p1 = 0, p2 = len - 1, b1, b2;\n    char tmp = 0;\n    // bitmap of 'a''e''i''o''u'\n    unsigned long bitvec = 0x104111;\n\n    while (p1 < p2) {\n        int b1 = toBit(s[p2]);\n        if (isAlpha(b1) && bitvec >> b1 & 1) {\n            while (p1 < p2) {\n                b2 = toBit(s[p1]);\n                if (isAlpha(b2) && (bitvec >> b2 & 1)) {\n                    break;\n                }\n                p1++;\n            }\n            tmp = s[p2];\n            s[p2] = s[p1];\n            s[p1] = tmp;\n            /* Ensure we don't visit it again */\n            p1++;\n        }\n        p2--;\n    }\n\n    return s;\n}\n", "\nchar *reverseVowels(char *s) {\n    int len = strlen(s);\n    int p1 = 0, p2 = len - 1, b1, b2;\n    char tmp = 0;\n    // bitmap of 'a''e''i''o''u'\n    unsigned long bitvec = 0x104111;\n\n    while (p1 < p2) {\n        int b1 = toBit(s[p2]);\n        if (isAlpha(b1) && bitvec >> b1 & 1) {\n            while (p1 < p2) {\n                b2 = toBit(s[p1]);\n                if (isAlpha(b2) && (bitvec >> b2 & 1)) {\n                    break;\n                }\n                p1++;\n            }\n            tmp = s[p2];\n            s[p2] = s[p1];\n            s[p1] = tmp;\n            /* Ensure we don't visit it again */\n            p1++;\n        }\n        p2--;\n    }\n\n    return s;\n}\n", "\nchar *reverseVowels(char *s) {\n    int len = strlen(s);\n    int p1 = 0, p2 = len - 1, b1, b2;\n    char tmp = 0;\n    // bitmap of 'a''e''i''o''u'\n    unsigned long bitvec = 0x104111;\n\n    while (p1 < p2) {\n        int b1 = toBit(s[p2]);\n        if (isAlpha(b1) && bitvec >> b1 & 1) {\n            while (p1 < p2) {\n                b2 = toBit(s[p1]);\n                if (isAlpha(b2) && (bitvec >> b2 & 1)) {\n                    break;\n                }\n                p1++;\n            }\n            tmp = s[p2];\n            s[p2] = s[p1];\n            s[p1] = tmp;\n            /* Ensure we don't visit it again */\n            p1++;\n        }\n        p2--;\n    }\n\n    return s;\n}\n"]}
{"id": "76", "ref_c": [["int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false}"], ["int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false}"], ["int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false}"]]}
{"id": "77", "ref_c": [["int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n\\n    qsort(nums1, nums1Size, sizeof(int), cmp);\\n    qsort(nums2, nums2Size, sizeof(int), cmp);\\n\\n    int i=0, j=0, count=0;\\n\\n    while (i<nums1Size && j<nums2Size)\\n    {\\n        if (nums1[i]>nums2[j]) j++;\\n\\n        else if (nums1[i]<nums2[j]) i++;\\n        \\n        else if(nums1[i]==nums2[j])\\n        {\\n            nums1[count] = nums1[i];\\n            count++;\\n            i++;\\n            j++;\\n        }"], ["int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n\\n    qsort(nums1, nums1Size, sizeof(int), cmp);\\n    qsort(nums2, nums2Size, sizeof(int), cmp);\\n\\n    int i=0, j=0, count=0;\\n\\n    while (i<nums1Size && j<nums2Size)\\n    {\\n        if (nums1[i]>nums2[j]) j++;\\n\\n        else if (nums1[i]<nums2[j]) i++;\\n        \\n        else if(nums1[i]==nums2[j])\\n        {\\n            nums1[count] = nums1[i];\\n            count++;\\n            i++;\\n            j++;\\n        }"], ["int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int count1[1001] = {0}"]]}
{"id": "78", "ref_c": [["bool isPerfectSquare(int num){\\n    int count=0;\\n    double x=1;\\n    while(count!=20)\\n    {\\n        x=(x+num/x)*0.5;\\n        count++;\\n    }"], ["bool isPerfectSquare(int num) {\\n    if (num < 0) {\\n        return false;\\n    }"], ["bool isPerfectSquare(int num) {\\n        unsigned int i = 1;\\n        while(i*i<num) i++;\\n        return (i*i == num);\\n    }"]]}
{"id": "79", "ref_c": [["int guessNumber(int n){\\n    int left = 1;\\n    int right = n;\\n\\n        while (left <= right){\\n            int mid = left + (right - left) / 2;\\n            int result = guess(mid);\\n\\n            if (result == 0){\\n                return mid;\\n            }"], ["int guessNumber(int n){\\n    long result,sp,ep,mid;\\n    for(sp=1,ep=n;sp<=ep;)\\n    {\\n        mid=(sp+ep)/2;\\n        result=guess(mid);\\n        if(result==0) return mid;\\n        else if(result==-1) ep=mid-1;\\n        else sp=mid+1;\\n    }"], ["int guessNumber(int n){\\n\\tint beg=1,end=n,mid=beg+(end-beg)/2;\\n    while(beg<=end)\\n    {\\n        if(guess(mid)==0)\\n        break;\\n        else if(guess(mid)==1)\\n        {\\n            beg=mid+1;\\n        }"]]}
{"id": "80", "ref_c": [["bool canConstruct(char * ransomNote, char * magazine){\\n    \\n    // create a map to store the frequency of char in ransomNote\\n    int map[26] = {0}"], ["bool canConstruct(char * ransomNote, char * magazine){\\n    \\n    // create a map to store the frequency of char in ransomNote\\n    int map[26] = {0}"], ["bool canConstruct(char * ransomNote, char * magazine){\\n    \\n    // create a map to store the frequency of char in ransomNote\\n    int map[26] = {0}"]]}
{"id": "81", "ref_c": [["int firstUniqChar(char * s){\\n    int i = 0, map[26], sSize = strlen(s);\\n    \\n    for(i; i < 26; i++)\\n        map[i] = 0;\\n    \\n    for(i=0; i < sSize; i++)\\n        map[s[i] - \\'a\\']++;\\n    \\n    for(i=0; i < sSize; i++)\\n        if (map[s[i] - \\'a\\'] == 1)\\n            return i;\\n    \\n    return -1;\\n}"], ["int firstUniqChar(char * s){\\n    int i = 0, map[26], sSize = strlen(s);\\n    \\n    for(i; i < 26; i++)\\n        map[i] = 0;\\n    \\n    for(i=0; i < sSize; i++)\\n        map[s[i] - \\'a\\']++;\\n    \\n    for(i=0; i < sSize; i++)\\n        if (map[s[i] - \\'a\\'] == 1)\\n            return i;\\n    \\n    return -1;\\n}"], ["int firstUniqChar(char * s){\\n    int i = 0, map[26], sSize = strlen(s);\\n    \\n    for(i; i < 26; i++)\\n        map[i] = 0;\\n    \\n    for(i=0; i < sSize; i++)\\n        map[s[i] - \\'a\\']++;\\n    \\n    for(i=0; i < sSize; i++)\\n        if (map[s[i] - \\'a\\'] == 1)\\n            return i;\\n    \\n    return -1;\\n}"]]}
{"id": "82", "ref_c": [["char findTheDifference(char * s, char * t){\\n    int i = strlen(s);\\n    char t_sum = t[i--];\\n    for(; i >- 1; i--)\\n        t_sum ^= (t[i] ^ s[i]);\\n    return t_sum;\\n}"], ["char findTheDifference(char * s, char * t){\\n    int i = strlen(s);\\n    char t_sum = t[i--];\\n    for(; i >- 1; i--)\\n        t_sum ^= (t[i] ^ s[i]);\\n    return t_sum;\\n}"], ["char findTheDifference(char * s, char * t){\\n    int i = strlen(s);\\n    char t_sum = t[i--];\\n    for(; i >- 1; i--)\\n        t_sum ^= (t[i] ^ s[i]);\\n    return t_sum;\\n}"]]}
{"id": "83", "ref_c": [["bool isSubsequence(char * s, char * t){\\n    int length = strlen(s);\\n    if (length == 0)    return true;\\n    int c = 0;\\n\\n    for (int i = 0; i < strlen(t); i++){\\n        if (t[i] == s[c])   c++;\\n    }"], ["bool isSubsequence(char * s, char * t){\\n    // Initialize two pointers i and j storing the last indices of both the strings...\\n        int i = strlen(s) , j = strlen(t);\\n        i-- , j--;\\n        // Iterate until either of them becomes zero...\\n        while(i >= 0 && j >= 0) {\\n            // Compare characters...\\n            if(s[i] == t[j])\\n                i-- , j--;\\n            else\\n                j--;\\n        }"], ["bool isSubsequence(char * s, char * t){\\n    int length = strlen(s);\\n    if (length == 0)    return true;\\n    int c = 0;\\n\\n    for (int i = 0; i < strlen(t); i++){\\n        if (t[i] == s[c])   c++;\\n    }"]]}
{"id": "84", "ref_c": [["char ** readBinaryWatch(int turnedOn, int* returnSize){\\n     char** final_arr = (char**)malloc(190*sizeof(char*));\\n    int count =0;\\n    for (int k=0;k<720;k++){ // 720 hours a day\\n        unsigned char h = k/60; // unsigned char from 0 to 255\\n        unsigned char m = k%60;\\n        int count_bit = 0;\\n        while(h>0){\\n            if (h%2==1){\\n                count_bit++;\\n            }"], ["char ** readBinaryWatch(int turnedOn, int* returnSize){\\n  char **result = (char **)malloc(190 * sizeof(char *)); // Maximum possible combinations\\n    *returnSize = 0;\\n\\n    for (int hour = 0; hour < 12; hour++)\\n    {\\n        for (int minute = 0; minute < 60; minute++)\\n        {\\n            int totalOnBits = __builtin_popcount(hour) + __builtin_popcount(minute);\\n\\n            if (totalOnBits == turnedOn)\\n            {\\n                // Format the time as \"hour:minute\" and add it to the result\\n                result[*returnSize] = (char *)malloc(8 * sizeof(char));\\n                snprintf(result[*returnSize], 8, \"%d:%02d\", hour, minute);\\n                (*returnSize)++;\\n            }"], ["char ** readBinaryWatch(int turnedOn, int* returnSize)\\n{\\n    int m;\\n    pos = 0;\\n    result = (char**) malloc (sizeof(char*) * 1024);\\n    for (int h = 0; h < 12; h++)\\n    {\\n        m = 0;\\n        if (get_bitcount (h, turnedOn) > turnedOn)\\n            continue;\\n        for (int m = 0; m < 60; m++)\\n        {\\n            if (get_bitcount((h << 6) + m, turnedOn) == turnedOn)\\n            {\\n                result[pos] = to_str (h, m);\\n                pos++;\\n            }"]]}
{"id": "85", "ref_c": [["int sumOfLeftLeaves(struct TreeNode* root){\\n    if (!root)\\n        return 0;\\n\\n    int sum = 0;\\n    if (root->left && !root->left->left && !root->left->right)\\n        sum += root->left->val;\\n    \\n    sum+=sumOfLeftLeaves(root->left);\\n    sum+=sumOfLeftLeaves(root->right);\\n\\n    return sum;\\n}"], ["int sumOfLeftLeaves(struct TreeNode* root){\\n    if (!root)\\n        return 0;\\n\\n    int sum = 0;\\n    if (root->left && !root->left->left && !root->left->right)\\n        sum += root->left->val;\\n    \\n    sum+=sumOfLeftLeaves(root->left);\\n    sum+=sumOfLeftLeaves(root->right);\\n\\n    return sum;\\n}"], ["int sumOfLeftLeaves(struct TreeNode* root){\\n    if (!root)\\n        return 0;\\n\\n    int sum = 0;\\n    if (root->left && !root->left->left && !root->left->right)\\n        sum += root->left->val;\\n    \\n    sum+=sumOfLeftLeaves(root->left);\\n    sum+=sumOfLeftLeaves(root->right);\\n\\n    return sum;\\n}"]]}
{"id": "86", "ref_c": [["char * toHex(int num)\\n{\\n    char* hex = (char*) malloc (sizeof(char) * 10);\\n    char nib;\\n    int i = 0;\\n    unsigned int x = num;\\n    hex[9] = \\'\\\\0\\';\\n    while (1)\\n    {\\n        nib = (x & 0xF); \\n        hex[8-i] = (nib > 9) ? (\\'a\\' + nib - 10) : (\\'0\\' + nib);\\n        x >>= 4;\\n        if (!x)\\n            break;\\n        i++;\\n    }"], ["char * toHex(int num){\\n    \\n    if(num == 0 )\\n        return \"0\"; \\n    if (num == -1)\\n        return (\"ffffffff\");\\n    if( num == INT_MAX) \\n        return \"7fffffff\";\\n  if( num == INT_MIN) \\n        return \"80000000\";\\n    \\n    char* result = NULL;\\n    int i =0; \\n    bool isNeg= false; \\n    \\n    \\n    if(num < 0) {\\n      isNeg = true;\\n      num = INT_MAX + (num + 1); ///This portion is done in a way that still INT_MAX representation should be maintained. \\n    /*\\n        Trying to trick the number representation in hex format\\n    */\\n     }"], ["char * toHex(int num){\\n\\nchar *add = (char*)malloc(9*sizeof(char));\\n\\n\\nchar *ptr = add+8; \\n*ptr-- = \\'\\\\0\\';\\n\\nfor(int i=0;i<8;i++)\\n{\\n int value = num&15;\\n  if(value<10)\\n    *ptr-- = value + 48;\\n  else if(value>9)\\n    *ptr-- = value - 10 + 97;\\n  num = num>>4;\\n }"]]}
{"id": "87", "ref_c": [["int longestPalindrome(char * s) {\\n    char *set[128] = {0}"], ["int longestPalindrome(char * s) {\\n    char *set[128] = {0}"], ["int longestPalindrome(char * s) {\\n    char *set[128] = {0}"]]}
{"id": "88", "ref_c": [["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n; // since n = number of elements to be returned\\n    char **answer; // the string of strings where the right elements will be copied\\n    char str[5]; // every string contains at most 5 character (max number is 10000 => 5 characters)\\n    \\n    i = 1; // first number we want to return is 1\\n    answer = NULL;\\n    answer = malloc(sizeof(*answer) * n); // our string of strings will have the same number of element than the returning one (n)\\n    if (!answer)\\n        return (answer); // securizing our malloc => returning NULL if something went wrong\\n    while (i <= n)\\n    {\\n        if (i % 15 == 0)\\n            answer[i - 1] = strdup(\"FizzBuzz\"); // NB we need to start duplicating from position 0 => (i - 1)\\n        else if (i % 3 == 0)\\n            answer[i - 1] = strdup(\"Fizz\");\\n        else if (i % 5 == 0)\\n            answer[i - 1] = strdup(\"Buzz\");\\n        else\\n        {\\n            sprintf(str, \"%d\", i); // converting integer i into char and storing it in str\\n            answer[i - 1] = strdup(str);\\n        }"], ["char ** fizzBuzz(int n, int* returnSize){\\n    *returnSize = n;\\n    char **T = (char**)malloc(sizeof(char*)*n);\\n    for(int i=0;i<n;i++){\\n        T[i]=(char*)malloc(9*sizeof(char));\\n        sprintf(T[i], \"%d\", i+1);  // Convert \\'i\\' to char \\n        if( (i+1) % 3 == 0 && (i+1) % 5 == 0){T[i] = \"FizzBuzz\";}"], ["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    char**arr = malloc(n*sizeof(char*));\\n    *returnSize = n;\\n    for(int i=1;i<=n;i++)\\n    {\\n        arr[i - 1] = malloc(9 * sizeof(char));\\n        if(i%15==0)\\n        arr[i-1] = \"FizzBuzz\";\\n        else if(i%3==0)\\n        arr[i-1]=\"Fizz\";\\n        else if(i%5==0)\\n        arr[i-1]=\"Buzz\";\\n        else\\n        sprintf(arr[i-1], \"%d\", i);\\n    }"]]}
{"id": "89", "ref_c": [["int thirdMax(int* nums, int numsSize)\\n{\\n\\n    int n=numsSize,temp;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i+1;j<n;j++)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n            }"], ["int thirdMax(int* nums, int numsSize){\\n    \\n    int max_1 = nums[0];\\n    long max_2 = LONG_MIN;\\n    long max_3 = LONG_MIN;\\n    \\n    for (int i = 1; i < numsSize; i++){\\n        if (nums[i] > max_1){\\n            max_3 = max_2;\\n            max_2 = max_1;\\n            max_1 = nums[i];\\n        }"], ["int thirdMax(int* nums, int numsSize){\\n    long first = ((long)INT_MIN)-1, second = ((long)INT_MIN)-1, third = ((long)INT_MIN)-1;\\n    int i = 0;\\n    \\n    while(i < numsSize){\\n        if(nums[i] > first){\\n            third = second;\\n            second = first;\\n            first = nums[i];\\n        }"]]}
{"id": "90", "ref_c": ["\nvoid reverseString(char *str)\n{\n    int len = strlen(str);\n    char temp;\n\n    for (int i=0; i<len/2; i++) {\n        temp = str[i];\n        str[i] = str[len-i-1];\n        str[len-i-1] = temp;    \n    }   \n}\n\n#define MAX(a,b) ((a > b) ? a : b)\n\nchar * addStrings(char * num1, char * num2)\n{\n    int sz = MAX(strlen(num1), strlen(num2)) + 2;\n    char* strSum = (char*)malloc(sz);\n\n    reverseString(num1);\n    reverseString(num2);\n\n    int carry = 0, i=0;\n\n    while(*num1 || *num2 || carry) {\n        int sum = 0;\n\n        if(*num1) {\n            sum += (int)(*num1) - '0';\n            num1++;\n        }\n\n        if(*num2) {\n            sum += (int)(*num2) - '0';\n            num2++;\n        }\n\n        sum += carry;\n        carry = sum / 10; \n    \n        strSum[i] = ((char)(sum%10) + '0');\n        i++;\n    }   \n    strSum[i] = '\u0000';\n    reverseString(strSum);\n    return strSum;\n}\n", "\nvoid reverseString(char *str)\n{\n    int len = strlen(str);\n    char temp;\n\n    for (int i=0; i<len/2; i++) {\n        temp = str[i];\n        str[i] = str[len-i-1];\n        str[len-i-1] = temp;    \n    }   \n}\n\n#define MAX(a,b) ((a > b) ? a : b)\n\nchar * addStrings(char * num1, char * num2)\n{\n    int sz = MAX(strlen(num1), strlen(num2)) + 2;\n    char* strSum = (char*)malloc(sz);\n\n    reverseString(num1);\n    reverseString(num2);\n\n    int carry = 0, i=0;\n\n    while(*num1 || *num2 || carry) {\n        int sum = 0;\n\n        if(*num1) {\n            sum += (int)(*num1) - '0';\n            num1++;\n        }\n\n        if(*num2) {\n            sum += (int)(*num2) - '0';\n            num2++;\n        }\n\n        sum += carry;\n        carry = sum / 10; \n    \n        strSum[i] = ((char)(sum%10) + '0');\n        i++;\n    }   \n    strSum[i] = '\u0000';\n    reverseString(strSum);\n    return strSum;\n}\n", "\nvoid reverseString(char *str)\n{\n    int len = strlen(str);\n    char temp;\n\n    for (int i=0; i<len/2; i++) {\n        temp = str[i];\n        str[i] = str[len-i-1];\n        str[len-i-1] = temp;    \n    }   \n}\n\n#define MAX(a,b) ((a > b) ? a : b)\n\nchar * addStrings(char * num1, char * num2)\n{\n    int sz = MAX(strlen(num1), strlen(num2)) + 2;\n    char* strSum = (char*)malloc(sz);\n\n    reverseString(num1);\n    reverseString(num2);\n\n    int carry = 0, i=0;\n\n    while(*num1 || *num2 || carry) {\n        int sum = 0;\n\n        if(*num1) {\n            sum += (int)(*num1) - '0';\n            num1++;\n        }\n\n        if(*num2) {\n            sum += (int)(*num2) - '0';\n            num2++;\n        }\n\n        sum += carry;\n        carry = sum / 10; \n    \n        strSum[i] = ((char)(sum%10) + '0');\n        i++;\n    }   \n    strSum[i] = '\u0000';\n    reverseString(strSum);\n    return strSum;\n}\n"]}
{"id": "91", "ref_c": ["\nint countSegments(char * s) {\n\n\tif(strlen(s) == 0) {\n\t\treturn 0;\n\t}\n\tif(strlen(s) == 1) {\n\t\tif(isspace(s[0])) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tregister unsigned short i = 1, seg = 0;\n\twhile(s[i] != '\u0000') {\n\t\tif( (!isspace(s[i-1]) && isspace(s[i]))\n        ||  (!isspace(s[i]) && s[i+1] == '\u0000') ) {\n\t\t\tseg++;\n\t\t}\n\t\ti++;\n\t}\n    \n\treturn seg;\n}\n", "\nint countSegments(char * s) {\n\n\tif(strlen(s) == 0) {\n\t\treturn 0;\n\t}\n\tif(strlen(s) == 1) {\n\t\tif(isspace(s[0])) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tregister unsigned short i = 1, seg = 0;\n\twhile(s[i] != '\u0000') {\n\t\tif( (!isspace(s[i-1]) && isspace(s[i]))\n        ||  (!isspace(s[i]) && s[i+1] == '\u0000') ) {\n\t\t\tseg++;\n\t\t}\n\t\ti++;\n\t}\n    \n\treturn seg;\n}\n", "\nint countSegments(char * s) {\n\n\tif(strlen(s) == 0) {\n\t\treturn 0;\n\t}\n\tif(strlen(s) == 1) {\n\t\tif(isspace(s[0])) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tregister unsigned short i = 1, seg = 0;\n\twhile(s[i] != '\u0000') {\n\t\tif( (!isspace(s[i-1]) && isspace(s[i]))\n        ||  (!isspace(s[i]) && s[i+1] == '\u0000') ) {\n\t\t\tseg++;\n\t\t}\n\t\ti++;\n\t}\n    \n\treturn seg;\n}\n"]}
{"id": "92", "ref_c": [["int arrangeCoins(int n) {\\n        int start = 1, end = n;\\n        long long int mid = start + (end-start)/2;\\n        \\n        int ans =-1;\\n        \\n        \\n        while(start<=end){\\n            if((mid*(mid+1))/2 == n ){\\n                return mid;\\n            }"], ["int arrangeCoins(int n){\\n    int i;\\n    for(i=1; i<=n; i++){\\n        if(n-i >= 0) n = n-i;\\n        else break;\\n    }", "int arrangeCoins(int n) {\\n        int i;\\n        for(i=1; i<=n; i++){\\n            if(n-i >= 0) n = n-i;\\n            else break;\\n        }"], ["int arrangeCoins(int n) {\\n    int low = 0, high = n;\\n    unsigned long tmp, mid;\\n    while (low <= high){\\n        mid = low + (high - low) / 2;\\n        tmp = mid * (mid + 1) / 2;\\n\\n        if (tmp == n){\\n            return mid;\\n        }"]]}
{"id": "93", "ref_c": [["int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n\\n    int temp = 0;\\n    \\n    for (int index = 0; index < numsSize; ++index) {\\n        temp = abs(nums[index]) - 1;\\n        nums[temp] = abs(nums[temp]) * -1;\\n    }"], ["int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n\\n    int temp = 0;\\n    \\n    for (int index = 0; index < numsSize; ++index) {\\n        temp = abs(nums[index]) - 1;\\n        nums[temp] = abs(nums[temp]) * -1;\\n    }"], ["int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n\\n    int temp = 0;\\n    \\n    for (int index = 0; index < numsSize; ++index) {\\n        temp = abs(nums[index]) - 1;\\n        nums[temp] = abs(nums[temp]) * -1;\\n    }"]]}
{"id": "94", "ref_c": [["int findContentChildren(int* g, int gSize, int* s, int sSize) {\\n    // Sort the children\\'s and cookie\\'s sizes in non-decreasing order\\n    qsort(g, gSize, sizeof(int), cmp);\\n    qsort(s, sSize, sizeof(int), cmp);\\n    \\n    // Initialize variables for the current child and cookie indices\\n    int i = 0, j = 0;\\n    \\n    // Iterate through the children and try to assign cookies to them\\n    while (i < gSize && j < sSize) {\\n        // If the current cookie is big enough to satisfy the current child, move to the next child and cookie\\n        if (s[j] >= g[i]) {\\n            i++;\\n            j++;\\n        }"], ["int findContentChildren(int* g, int gSize, int* s, int sSize) {\\n    // Sort the children\\'s and cookie\\'s sizes in non-decreasing order\\n    qsort(g, gSize, sizeof(int), cmp);\\n    qsort(s, sSize, sizeof(int), cmp);\\n    \\n    // Initialize variables for the current child and cookie indices\\n    int i = 0, j = 0;\\n    \\n    // Iterate through the children and try to assign cookies to them\\n    while (i < gSize && j < sSize) {\\n        // If the current cookie is big enough to satisfy the current child, move to the next child and cookie\\n        if (s[j] >= g[i]) {\\n            i++;\\n            j++;\\n        }"], ["int findContentChildren(int* g, int gSize, int* s, int sSize){  \\nint sum = 0;\\n for (int a = 0; a < gSize; ++a) {\\n    for (int b = 0; b < a; ++b) {\\n      if (g[b] > g[a]) {\\n        int temp = g[b];\\n        g[b] = g[a];\\n        g[a] = temp;\\n      }"]]}
{"id": "95", "ref_c": [["bool repeatedSubstringPattern(char * s){\\n    int i = 1;\\n    int l = strlen(s);\\n    int x = 0;\\n    while(i <= l/2){\\n        x =0;\\n        if(l%i == 0){\\n            while(x < l){\\n                if(s[x%i] != s[x]){\\n                    break;\\n                }"], ["bool repeatedSubstringPattern(char * s){\\n    int i = 1;\\n    int l = strlen(s);\\n    int x = 0;\\n    while(i <= l/2){\\n        x =0;\\n        if(l%i == 0){\\n            while(x < l){\\n                if(s[x%i] != s[x]){\\n                    break;\\n                }"], ["bool repeatedSubstringPattern(char * s){\\n    int i = 1;\\n    int l = strlen(s);\\n    int x = 0;\\n    while(i <= l/2){\\n        x =0;\\n        if(l%i == 0){\\n            while(x < l){\\n                if(s[x%i] != s[x]){\\n                    break;\\n                }"]]}
{"id": "96", "ref_c": [["int hammingDistance(int x, int y)\\n{\\n    int n,count=0;\\n    n = x^y;\\n    while(n!=0)\\n    {\\n        count++;\\n        n = n&(n-1);\\n    }"], ["int hammingDistance(int x, int y) {\\n        int count=0;\\n\\t\\t\\n\\t\\t//do xor between x and y\\n        int num=x^y;\\n        \\n        while(num!=0){\\n\\t\\t\\t\\n\\t\\t\\t//AND operation is done to check the presence of \\'1\\' bit in num. if no \\'1\\' bit\\'s are there then it will be zero and if condition will become false.  \\n            if((1 & num)!=0)\\n                count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t//Right shift operation to remove the last bit\\n            num=num>>1;\\n        }"], ["int hammingDistance(int x, int y){\\n    int d=0,n=x^y;\\n    while(n){\\n        n&=n-1;\\n        d++;\\n    }"]]}
{"id": "97", "ref_c": [["int islandPerimeter(int** grid, int gridSize, int* gridColSize) {\\n\\n\\tint length = 0;\\n\\tfor (int i = 0; i < gridSize; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < *(gridColSize+i); j++)\\n\\t\\t{\\n\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlength += 4;\\n\\t\\t\\t\\tif ((i - 1) >= 0 && grid[i - 1][j] == 1)//up\\n\\t\\t\\t\\t\\tlength -= 1;\\n\\t\\t\\t\\tif ((i + 1) < gridSize && grid[i + 1][j] == 1)//down\\n\\t\\t\\t\\t\\tlength -= 1;\\n\\t\\t\\t\\tif ((j - 1) >= 0 && grid[i][j - 1] == 1)//left\\n\\t\\t\\t\\t\\tlength -= 1;\\n\\t\\t\\t\\tif ((j + 1) < *(gridColSize + i) && grid[i][j + 1] == 1)//right\\n\\t\\t\\t\\t\\tlength -= 1;\\n\\t\\t\\t}"], ["int islandPerimeter(int** grid, int gridSize, int* gridColSize) {\\n\\n\\tint length = 0;\\n\\tfor (int i = 0; i < gridSize; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < *(gridColSize+i); j++)\\n\\t\\t{\\n\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlength += 4;\\n\\t\\t\\t\\tif ((i - 1) >= 0 && grid[i - 1][j] == 1)//up\\n\\t\\t\\t\\t\\tlength -= 1;\\n\\t\\t\\t\\tif ((i + 1) < gridSize && grid[i + 1][j] == 1)//down\\n\\t\\t\\t\\t\\tlength -= 1;\\n\\t\\t\\t\\tif ((j - 1) >= 0 && grid[i][j - 1] == 1)//left\\n\\t\\t\\t\\t\\tlength -= 1;\\n\\t\\t\\t\\tif ((j + 1) < *(gridColSize + i) && grid[i][j + 1] == 1)//right\\n\\t\\t\\t\\t\\tlength -= 1;\\n\\t\\t\\t}"], ["int islandPerimeter(int** grid, int gridSize, int* gridColSize){\\n    int sum = 0;\\n\\n    for(int i = 0; i < gridSize; i ++){\\n        for(int j = 0; j < gridColSize[i]; j ++){\\n            if(grid[i][j] == 0)continue;\\n                sum += 4;\\n                sum -= (i > 0 && grid[i-1][j]==1)?1:0;\\n                sum -= (j > 0 && grid[i][j-1]==1)?1:0;\\n                sum -= (i < gridSize - 1 && grid[i+1][j]==1)?1:0;\\n                sum -= (j < gridColSize[i] - 1 && grid[i][j+1]==1)?1:0;\\n        }"]]}
{"id": "98", "ref_c": [["int findComplement(int num){\\n    return pow(2, (int)(log2(num) / log2(2)) + 1) - 1 - num;\\n}"], ["int findComplement(int num) {\\n        int mask = 1;\\n        \\n        while((mask & num) != num){\\n            mask = mask << 1;\\n            mask += 1;\\n        }"], ["int findComplement(int num){\\n    return pow(2, (int)(log2(num) / log2(2)) + 1) - 1 - num;\\n}"]]}
{"id": "99", "ref_c": [["char * licenseKeyFormatting(char * s, int k){\\n    int len = strlen(s), size = len + len / k + 1, counter = 0;\\n    char* ans = (char*)calloc(size, sizeof(char));\\n    ans[--size] = \\'\\\\0\\';\\n    for(int i = len - 1; i >= 0; i--){\\n        if(s[i] == \\'-\\')\\n            continue;\\n        ans[--size] = convert(s[i]);\\n        counter++;\\n        if(counter == k && i != 0){\\n            ans[--size] = \\'-\\';\\n            counter = 0;\\n        }"], ["char * licenseKeyFormatting(char * s, int k){\\n    int alphaNumer = 0;\\n\\n    for (int i = 0; s[i]; i++) {\\n        if (isalnum(s[i]))                      //can\\'t directly add isalnum, returns 8 or 0 not 1 or 0...\\n            alphaNumer += 1;\\n    }"], ["char * licenseKeyFormatting(char * s, int k){\\n\\n    /*\\n     * Input:\\n     *  s, string\\n     *  k, \\n     */\\n\\n    int len = strlen(s);\\n    int j = 100000;\\n\\n    buf[100000] = 0;\\n\\n    for (int i = len - 1, cnt = 0; i >= 0; i--) {\\n\\n        /* alphanumeric */\\n        if (s[i] != \\'-\\') {\\n\\n            j--;\\n\\n            if (cnt == k) {\\n                buf[j] = \\'-\\';\\n                j--;\\n                cnt = 0;\\n            }"]]}
{"id": "100", "ref_c": [["int findMaxConsecutiveOnes(int* nums, int numsSize)\\n{int i=0,k=0,max=0;\\nfor(i=0;i<numsSize;i++)\\n{\\n    if(nums[i]==1)\\n    {\\n        k++;\\n        if(k>max)\\n        {\\n            max=k;\\n        }"], ["int findMaxConsecutiveOnes(int* nums, int numsSize)\\n{int i=0,k=0,max=0;\\nfor(i=0;i<numsSize;i++)\\n{\\n    if(nums[i]==1)\\n    {\\n        k++;\\n        if(k>max)\\n        {\\n            max=k;\\n        }"], ["int findMaxConsecutiveOnes(int* nums, int numsSize)\\n{int i=0,k=0,max=0;\\nfor(i=0;i<numsSize;i++)\\n{\\n    if(nums[i]==1)\\n    {\\n        k++;\\n        if(k>max)\\n        {\\n            max=k;\\n        }"]]}
{"id": "101", "ref_c": [["int* constructRectangle(int area, int* returnSize){\\n    int* arr = (int*)malloc(2*sizeof(int));\\n    int width = sqrt(area);\\n    while(area % width != 0) \\n      width--;\\n    arr[0] = area/width;\\n    arr[1] = width;\\n    *returnSize = 2;\\n    return arr;\\n}"], ["int* constructRectangle(int area, int* returnSize){\\n    int* arr = (int*)malloc(2*sizeof(int));\\n    int width = sqrt(area);\\n    while(area % width != 0) \\n      width--;\\n    arr[0] = area/width;\\n    arr[1] = width;\\n    *returnSize = 2;\\n    return arr;\\n}"], ["int* constructRectangle(int area, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  area\\n     */\\n\\n    int length = sqrt(area), width = length;\\n    int *ans = (int *)malloc(sizeof(int) * 2);\\n\\n    *returnSize = 2;\\n\\n    /*\\n     * Set length = sqrt(area), width = sqrt(area) \\n     *  if L * W is smaller than area, increase length\\n     *  if L * W is larger than area, decrease width\\n     */\\n    do {\\n        if (length * width < area) {\\n            length++;\\n        }"]]}
{"id": "102", "ref_c": [["int findPoisonedDuration(int* timeSeries, int timeSeriesSize, int duration) {\\n\\n    int ans=0;\\n\\n    for(int i=0; i<timeSeriesSize-1; i++){\\n        \\n        if(timeSeries[i]+duration<timeSeries[i+1])\\n            ans+=duration;\\n        else\\n            ans+=timeSeries[i+1]-timeSeries[i];\\n    }"], ["int findPoisonedDuration(int* timeSeries, int timeSeriesSize, int duration){\\n\\n    /*\\n     * Input:\\n     *  timeSeries\\n     *  timeSeriesSize\\n     *  duration\\n     */\\n\\n    int ans = 0;\\n\\n    for (int i = 0; i < timeSeriesSize; i++) {\\n\\n        if (i != timeSeriesSize - 1) {\\n            /* Non-overlap, add all poison effect duration */\\n            if (timeSeries[i] + duration < timeSeries[i + 1]) {\\n                ans += duration;\\n            }"], ["int findPoisonedDuration(int* timeSeries, int timeSeriesSize, int duration){\\n\\n    /*\\n     * Input:\\n     *  timeSeries\\n     *  timeSeriesSize\\n     *  duration\\n     */\\n\\n    int ans = 0;\\n\\n    for (int i = 0; i < timeSeriesSize; i++) {\\n\\n        if (i != timeSeriesSize - 1) {\\n            /* Non-overlap, add all poison effect duration */\\n            if (timeSeries[i] + duration < timeSeries[i + 1]) {\\n                ans += duration;\\n            }"]]}
{"id": "103", "ref_c": ["\ntypedef struct {\nint val; \nint key;\nint num;\nint pos;\nUT_hash_handle hh;\n}hash_table;\nhash_table* hash = NULL,*elem,*temp;\nint* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\nint* retarr = malloc(nums1Size * sizeof(int));\n*returnSize = nums1Size;\nfor (int i = 0; i < nums2Size; ++i) {\nHASH_FIND_INT(hash,&nums2[i],elem);\nif (!elem) {\n    elem = malloc(sizeof(hash_table));\n    elem->val = 1;\n    elem->key = nums2[i];\n    elem->num = nums2[i];\n    elem->pos = i;\n    HASH_ADD_INT(hash,key,elem);\n}\nelse {\n    elem->val++;\n}\n}\nfor (int i = 0; i < nums1Size; ++i) {\nint found = 0;\nHASH_FIND_INT(hash,&nums1[i],elem);\nif (elem != NULL) {\nfor (int j = elem->pos + 1; j < nums2Size; ++j) {\nif (nums2[j] > nums1[i]) {\n    retarr[i] = nums2[j];\n    found = 1;\n    break;\n}\n}\n}\nif (!found) {\nretarr[i] = -1;\n}\n}\nHASH_CLEAR(hh,hash);\nreturn retarr;\n}\n", "\ntypedef struct {\nint val; \nint key;\nint num;\nint pos;\nUT_hash_handle hh;\n}hash_table;\nhash_table* hash = NULL,*elem,*temp;\nint* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\nint* retarr = malloc(nums1Size * sizeof(int));\n*returnSize = nums1Size;\nfor (int i = 0; i < nums2Size; ++i) {\nHASH_FIND_INT(hash,&nums2[i],elem);\nif (!elem) {\n    elem = malloc(sizeof(hash_table));\n    elem->val = 1;\n    elem->key = nums2[i];\n    elem->num = nums2[i];\n    elem->pos = i;\n    HASH_ADD_INT(hash,key,elem);\n}\nelse {\n    elem->val++;\n}\n}\nfor (int i = 0; i < nums1Size; ++i) {\nint found = 0;\nHASH_FIND_INT(hash,&nums1[i],elem);\nif (elem != NULL) {\nfor (int j = elem->pos + 1; j < nums2Size; ++j) {\nif (nums2[j] > nums1[i]) {\n    retarr[i] = nums2[j];\n    found = 1;\n    break;\n}\n}\n}\nif (!found) {\nretarr[i] = -1;\n}\n}\nHASH_CLEAR(hh,hash);\nreturn retarr;\n}\n", "\ntypedef struct {\nint val; \nint key;\nint num;\nint pos;\nUT_hash_handle hh;\n}hash_table;\nhash_table* hash = NULL,*elem,*temp;\nint* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\nint* retarr = malloc(nums1Size * sizeof(int));\n*returnSize = nums1Size;\nfor (int i = 0; i < nums2Size; ++i) {\nHASH_FIND_INT(hash,&nums2[i],elem);\nif (!elem) {\n    elem = malloc(sizeof(hash_table));\n    elem->val = 1;\n    elem->key = nums2[i];\n    elem->num = nums2[i];\n    elem->pos = i;\n    HASH_ADD_INT(hash,key,elem);\n}\nelse {\n    elem->val++;\n}\n}\nfor (int i = 0; i < nums1Size; ++i) {\nint found = 0;\nHASH_FIND_INT(hash,&nums1[i],elem);\nif (elem != NULL) {\nfor (int j = elem->pos + 1; j < nums2Size; ++j) {\nif (nums2[j] > nums1[i]) {\n    retarr[i] = nums2[j];\n    found = 1;\n    break;\n}\n}\n}\nif (!found) {\nretarr[i] = -1;\n}\n}\nHASH_CLEAR(hh,hash);\nreturn retarr;\n}\n"]}
{"id": "104", "ref_c": [["char ** findWords(char ** words, int wordsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  words,\\n     *  wordsSize\\n     */\\n\\n    char **ans = (char **)malloc(sizeof(char *) * 20);\\n\\n    *returnSize = 0;\\n\\n    for (int i = 0, row, len; i < wordsSize; i++) {\\n\\n        /* Get the row position of first character */\\n        row = lookup[tolower(words[i][0]) - \\'a\\'];\\n        len = 0;\\n\\n        /* Check if all the characters are in same row */\\n        for (int j = 0; words[i][j]; j++) {\\n            if (lookup[tolower(words[i][j]) - \\'a\\'] != row) {\\n                break;\\n            }"], ["char ** findWords(char ** words, int wordsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  words,\\n     *  wordsSize\\n     */\\n\\n    char **ans = (char **)malloc(sizeof(char *) * 20);\\n\\n    *returnSize = 0;\\n\\n    for (int i = 0, row, len; i < wordsSize; i++) {\\n\\n        /* Get the row position of first character */\\n        row = lookup[tolower(words[i][0]) - \\'a\\'];\\n        len = 0;\\n\\n        /* Check if all the characters are in same row */\\n        for (int j = 0; words[i][j]; j++) {\\n            if (lookup[tolower(words[i][j]) - \\'a\\'] != row) {\\n                break;\\n            }"], ["char ** findWords(char ** words, int wordsSize, int* returnSize){\\n  int Third = 0; // or make life easier 22790416\\n  int Second = 0; // or 265961 \\n  int First = 0; // or 44052486 \\n  Third |= 1<<\\'Q\\'-\\'A\\';\\n  Third |= 1<<\\'W\\'-\\'A\\';\\n  Third |= 1<<\\'E\\'-\\'A\\';\\n  Third |= 1<<\\'R\\'-\\'A\\';\\n  Third |= 1<<\\'T\\'-\\'A\\';\\n  Third |= 1<<\\'Y\\'-\\'A\\';\\n  Third |= 1<<\\'U\\'-\\'A\\';\\n  Third |= 1<<\\'I\\'-\\'A\\';\\n  Third |= 1<<\\'O\\'-\\'A\\';\\n  Third |= 1<<\\'P\\'-\\'A\\';\\n  Second |= 1<<\\'A\\'-\\'A\\';\\n  Second |= 1<<\\'S\\'-\\'A\\';\\n  Second |= 1<<\\'D\\'-\\'A\\';\\n  Second |= 1<<\\'F\\'-\\'A\\';\\n  Second |= 1<<\\'G\\'-\\'A\\';\\n  Second |= 1<<\\'H\\'-\\'A\\';\\n  Second |= 1<<\\'J\\'-\\'A\\';\\n  Second |= 1<<\\'K\\'-\\'A\\';\\n  Second |= 1<<\\'L\\'-\\'A\\';\\n  First |= 1<<\\'Z\\'-\\'A\\';\\n  First |= 1<<\\'X\\'-\\'A\\';\\n  First |= 1<<\\'C\\'-\\'A\\';\\n  First |= 1<<\\'V\\'-\\'A\\';\\n  First |= 1<<\\'B\\'-\\'A\\';\\n  First |= 1<<\\'N\\'-\\'A\\';\\n  First |= 1<<\\'M\\'-\\'A\\';\\n\\n  int temp[wordsSize];\\n  int count = 0;\\n  memset(temp, 0, sizeof(temp));\\n  for(int i=0;i<wordsSize;i++){\\n    int check = 0;\\n    for(int j=0;j<strlen(words[i]);j++){\\n      if(words[i][j] >= \\'a\\' && words[i][j] <= \\'z\\')\\n        check |= 1<<words[i][j] - \\'a\\';\\n      else\\n        check |= 1<<words[i][j] - \\'A\\';\\n    }"]]}
{"id": "105", "ref_c": [["int* findMode(struct TreeNode* root, int* returnSize){\\n    \\n    int *arr = calloc(10000, sizeof(int)), size = 0;\\n    inorder(root, arr, &size);\\n    \\n    int *ret = malloc(sizeof(int) * size);\\n    int max = 0, idx = 0, len = 0, cur = arr[0];\\n    \\n    for (int i = 0; i < size; i++){\\n        if (arr[i] == cur)\\n            len++;\\n        else{\\n            if (len > max){\\n                idx = 0;\\n                ret[idx++] = cur;\\n                max = len;\\n            }"], ["int* findMode(struct TreeNode* root, int* returnSize) {\\n    int* b = (int*)malloc(100000 * sizeof(int));\\n    int count = 0;  \\n\\n\\n    inorder(root, b, &count);\\n\\n    int maxFrequency = 0;\\n    for (int i = 1; i < count; i += 2) {\\n        if (b[i] > maxFrequency) {\\n            maxFrequency = b[i];\\n        }"], ["int* findMode(struct TreeNode* root, int* returnSize) {\\n    int* b = (int*)malloc(100000 * sizeof(int));\\n    int count = 0;  \\n\\n\\n    inorder(root, b, &count);\\n\\n    int maxFrequency = 0;\\n    for (int i = 1; i < count; i += 2) {\\n        if (b[i] > maxFrequency) {\\n            maxFrequency = b[i];\\n        }"]]}
{"id": "106", "ref_c": [["char * convertToBase7(int num){\\n\\n    int res=0;\\n    int digit=1;\\n\\n    while(num!=0){\\n        res+=digit*(num%7);\\n        num=num/7;\\n        digit*=10;\\n\\n    }"], ["char * convertToBase7(int num){\\n\\n    int res=0;\\n    int digit=1;\\n\\n    while(num!=0){\\n        res+=digit*(num%7);\\n        num=num/7;\\n        digit*=10;\\n\\n    }"], ["char * convertToBase7(int num){\\n\\n    int res=0;\\n    int digit=1;\\n\\n    while(num!=0){\\n        res+=digit*(num%7);\\n        num=num/7;\\n        digit*=10;\\n\\n    }"]]}
{"id": "107", "ref_c": [["char ** findRelativeRanks(int* score, int scoreSize, int* returnSize){\\n\\n    char **result = (char **)malloc(scoreSize * sizeof(char *));                         //step 0 initialize result\\n    if (result == NULL)\\n        exit(1);\\n\\n    int *sortedScore = (int *)malloc(scoreSize * sizeof(int));\\n    if (sortedScore == NULL)\\n        exit(1);\\n\\n    for (int i = 0; i < scoreSize; i++)                 //step 1: Copy array\\n        sortedScore[i] = score[i];\\n\\n    qsort(sortedScore, scoreSize, sizeof(int), cmpfunc);    //step 2: sort the copy => sortedcopy\\n\\n    for (int i = 0; i < scoreSize; i++)     //step 3:  (for every s in score) -> (binary search for s in sortedcopy.  Store index of s in sortedcopy in result)\\n    {\\n        int theFuckingNumber = score[i];\\n        int place = -1;\\n\\n        int first = 0;\\n        int last = scoreSize - 1;\\n\\n        while (first <= last) { //NESTED LOOPS LETS GO!!!\\n            int middle = first + (last -  first) / 2;\\n\\n            if (sortedScore[middle] == theFuckingNumber) {\\n                place = middle;\\n                break;\\n            }"], ["char ** findRelativeRanks(int* score, int scoreSize, int* returnSize){\\n\\n    char **result = (char **)malloc(scoreSize * sizeof(char *));                         //step 0 initialize result\\n    if (result == NULL)\\n        exit(1);\\n\\n    int *sortedScore = (int *)malloc(scoreSize * sizeof(int));\\n    if (sortedScore == NULL)\\n        exit(1);\\n\\n    for (int i = 0; i < scoreSize; i++)                 //step 1: Copy array\\n        sortedScore[i] = score[i];\\n\\n    qsort(sortedScore, scoreSize, sizeof(int), cmpfunc);    //step 2: sort the copy => sortedcopy\\n\\n    for (int i = 0; i < scoreSize; i++)     //step 3:  (for every s in score) -> (binary search for s in sortedcopy.  Store index of s in sortedcopy in result)\\n    {\\n        int theFuckingNumber = score[i];\\n        int place = -1;\\n\\n        int first = 0;\\n        int last = scoreSize - 1;\\n\\n        while (first <= last) { //NESTED LOOPS LETS GO!!!\\n            int middle = first + (last -  first) / 2;\\n\\n            if (sortedScore[middle] == theFuckingNumber) {\\n                place = middle;\\n                break;\\n            }"], ["char ** findRelativeRanks(int* score, int scoreSize, int* returnSize){\\n\\n    char **result = (char **)malloc(scoreSize * sizeof(char *));                         //step 0 initialize result\\n    if (result == NULL)\\n        exit(1);\\n\\n    int *sortedScore = (int *)malloc(scoreSize * sizeof(int));\\n    if (sortedScore == NULL)\\n        exit(1);\\n\\n    for (int i = 0; i < scoreSize; i++)                 //step 1: Copy array\\n        sortedScore[i] = score[i];\\n\\n    qsort(sortedScore, scoreSize, sizeof(int), cmpfunc);    //step 2: sort the copy => sortedcopy\\n\\n    for (int i = 0; i < scoreSize; i++)     //step 3:  (for every s in score) -> (binary search for s in sortedcopy.  Store index of s in sortedcopy in result)\\n    {\\n        int theFuckingNumber = score[i];\\n        int place = -1;\\n\\n        int first = 0;\\n        int last = scoreSize - 1;\\n\\n        while (first <= last) { //NESTED LOOPS LETS GO!!!\\n            int middle = first + (last -  first) / 2;\\n\\n            if (sortedScore[middle] == theFuckingNumber) {\\n                place = middle;\\n                break;\\n            }"]]}
{"id": "108", "ref_c": [["bool checkPerfectNumber(int num){\\nint sum=0;\\nfor(int i=1;i<=num/2;i++)\\n{\\n         if(num%i==0)\\n         {\\n            sum+=i;\\n         }"], ["bool checkPerfectNumber(int num) {\\n        if(num == 1) return false;\\n        int sum = 1;\\n        for(int i=2; i<=sqrt(num); i++)\\n            if(num%i == 0)\\n                sum+=i + num/i;\\n        return sum == num;\\n    }", "bool checkPerfectNumber(int num){\\n    if(num == 1) return false;\\n    int sum = 1;\\n    for(int i=2; i<=sqrt(num); i++)\\n        if(num%i == 0)\\n            sum+=i + num/i;\\n    return sum == num;\\n}"], ["bool checkPerfectNumber(int num) {\\n    if(num & 1) return false;\\n        else {\\n            int n = num/2;\\n            int sum = 0;\\n            for(int i=1; i<=n; i++) {\\n                if(num%i == 0) {\\n                    sum += i;\\n                }"]]}
{"id": "109", "ref_c": [["int fib(int n) {\\n        int a=0;\\n        int b=1;\\n        if(n==0)\\n            return a;\\n        if(n==1)\\n            return b;\\n        if(n==2)\\n            return a+b;\\n        int c=a+b;\\n        for(int i=2;i<n;i++)\\n        {\\n            a=b;\\n            b=c;\\n            c=a+b;\\n        }"], ["int fib(int n) {\\n        \\n        // 1. Create DP Array\\n        // vector<int> dp(n+1,-1);\\n\\n        // return topDown(n,dp);\\n\\n        // return bottomUp(n);\\n\\n        return fibSpace(n);\\n    }"], ["int fib(int n){\\n    \\n    if (n == 0 || n == 1)\\n        return n;\\n    \\n    int first = 0;\\n    int second = 1;\\n    int result;\\n    \\n    for (int i = 2; i <= n; i++) {\\n        result = first + second;\\n        first = second;\\n        second = result;\\n    }"]]}
{"id": "111", "ref_c": [["bool detectCapitalUse(char * word){\\n    int i=0,first=0,second=0;\\n    if(strlen(word) == 1) return true;\\n    if(isupper(word[i++])) first=1;\\n    if(isupper(word[i])) second=1;\\n    while(word[i] != \\'\\\\0\\'){\\n        if(isupper(word[i]) && first == 0) return false; // first is not upper but any other is\\n        if(isupper(word[i]) && second == 0) return false; // second is not upper but any other is\\n        if(!isupper(word[i]) && first == 1 && second == 1) return false; // first & second are upper but any other is not\\n        i++;\\n    }"], ["bool detectCapitalUse(char * word){\\n    int x=strlen(word);\\n    if(word[0]>=\\'A\\'&&word[0]<=\\'Z\\')\\n    {\\n        if(word[1]>=\\'A\\'&&word[1]<=\\'Z\\')\\n        {\\n            for(int i=2;i<x;i++)\\n            {\\n                if(word[i]>=\\'a\\'&&word[i]<=\\'z\\')\\n                return false;\\n            }"], ["bool detectCapitalUse(char * word){\\n    int x=strlen(word);\\n    if(word[0]>=\\'A\\'&&word[0]<=\\'Z\\')\\n    {\\n        if(word[1]>=\\'A\\'&&word[1]<=\\'Z\\')\\n        {\\n            for(int i=2;i<x;i++)\\n            {\\n                if(word[i]>=\\'a\\'&&word[i]<=\\'z\\')\\n                return false;\\n            }"]]}
{"id": "112", "ref_c": [["int findLUSlength(char * a, char * b){\\n    if(strcmp(a,b) == 0)\\n        return -1;\\n    return strlen(a)<strlen(b)?strlen(b):strlen(a);\\n}"], ["int findLUSlength(char * a, char * b){\\n    if(strlen(a) == strlen(b)){\\n        for(int i=0; i<strlen(a); i++){\\n            if(a[i] != b[i]){\\n                return strlen(a);\\n            }"], ["int findLUSlength(char * a, char * b){\\n    if(strcmp(a,b) == 0)\\n        return -1;\\n    return strlen(a)<strlen(b)?strlen(b):strlen(a);\\n}"]]}
{"id": "113", "ref_c": [["int getMinimumDifference(struct TreeNode* root){\\n    int minDiff = INT_MAX; // Initialize the minimum difference.\\n    int prevVal = -1;      // Initialize the previous node\\'s value.\\n\\n    // Helper function for in-order traversal.\\n    void inOrder(struct TreeNode* node) {\\n        if (node == NULL) {\\n            return;\\n        }"], ["int getMinimumDifference(struct TreeNode* root){\\n    int minDiff = INT_MAX; // Initialize the minimum difference.\\n    int prevVal = -1;      // Initialize the previous node\\'s value.\\n\\n    // Helper function for in-order traversal.\\n    void inOrder(struct TreeNode* node) {\\n        if (node == NULL) {\\n            return;\\n        }"], ["int getMinimumDifference(struct TreeNode* root){\\n    int minDiff = INT_MAX; // Initialize the minimum difference.\\n    int prevVal = -1;      // Initialize the previous node\\'s value.\\n\\n    // Helper function for in-order traversal.\\n    void inOrder(struct TreeNode* node) {\\n        if (node == NULL) {\\n            return;\\n        }"]]}
{"id": "114", "ref_c": [["char * reverseStr(char * s, int k){\\n    //Time complexity: O(n), where n is the length of s\\n    //Space complexity: O(1), work is done in-place \\n    int stringLength = strlen(s);\\n\\n    for(int i = 0; i < stringLength - 1; i += 2*k)\\n    {\\n        int left = i;\\n        //we need to make sure we don\\'t assign right to be greater than\\n        //the largest index of s\\n        int right = (i + k - 1) > stringLength - 1 ? stringLength - 1 : i + k - 1;\\n        //make the appropriate reversale\\n        while(left < right)\\n        {\\n            char temp = s[left];\\n            s[left++] = s[right];\\n            s[right--] = temp;\\n        }"], ["char * reverseStr(char * s, int k){\\n    //Time complexity: O(n), where n is the length of s\\n    //Space complexity: O(1), work is done in-place \\n    int stringLength = strlen(s);\\n\\n    for(int i = 0; i < stringLength - 1; i += 2*k)\\n    {\\n        int left = i;\\n        //we need to make sure we don\\'t assign right to be greater than\\n        //the largest index of s\\n        int right = (i + k - 1) > stringLength - 1 ? stringLength - 1 : i + k - 1;\\n        //make the appropriate reversale\\n        while(left < right)\\n        {\\n            char temp = s[left];\\n            s[left++] = s[right];\\n            s[right--] = temp;\\n        }"], ["char * reverseStr(char * s, int k){\\n    //Time complexity: O(n), where n is the length of s\\n    //Space complexity: O(1), work is done in-place \\n    int stringLength = strlen(s);\\n\\n    for(int i = 0; i < stringLength - 1; i += 2*k)\\n    {\\n        int left = i;\\n        //we need to make sure we don\\'t assign right to be greater than\\n        //the largest index of s\\n        int right = (i + k - 1) > stringLength - 1 ? stringLength - 1 : i + k - 1;\\n        //make the appropriate reversale\\n        while(left < right)\\n        {\\n            char temp = s[left];\\n            s[left++] = s[right];\\n            s[right--] = temp;\\n        }"]]}
{"id": "115", "ref_c": [["int diameterOfBinaryTree(struct TreeNode* root){\\n\\n    int diameter = 0;\\n    get_diameter(root, &diameter);\\n\\n    return diameter;\\n}"], ["int diameterOfBinaryTree(struct TreeNode* root){\\n\\n    int diameter = 0;\\n    get_diameter(root, &diameter);\\n\\n    return diameter;\\n}"], ["int diameterOfBinaryTree(struct TreeNode* root){\\n    ans=0;\\n    input(root);\\n    return ans;\\n}"]]}
{"id": "116", "ref_c": ["\nbool checkRecord(char *s) {\n    int absum = 0, lasum = 0;\n\n    for (int i = 0; s[i] != '\u0000'; i++) {\n        if (s[i] == 'A') {\n            absum++;\n            if (absum >= 2)\n                return false;\n        }\n        if (s[i] == 'L') {\n            lasum++;\n            if (lasum >= 3)\n                return false;\n        } else {\n            lasum = 0; \n        }\n    }\n    return true;\n}\n", "\nbool checkRecord(char *s) {\n    int absum = 0, lasum = 0;\n\n    for (int i = 0; s[i] != '\u0000'; i++) {\n        if (s[i] == 'A') {\n            absum++;\n            if (absum >= 2)\n                return false;\n        }\n        if (s[i] == 'L') {\n            lasum++;\n            if (lasum >= 3)\n                return false;\n        } else {\n            lasum = 0; \n        }\n    }\n    return true;\n}\n", "\nbool checkRecord(char *s) {\n    int absum = 0, lasum = 0;\n\n    for (int i = 0; s[i] != '\u0000'; i++) {\n        if (s[i] == 'A') {\n            absum++;\n            if (absum >= 2)\n                return false;\n        }\n        if (s[i] == 'L') {\n            lasum++;\n            if (lasum >= 3)\n                return false;\n        } else {\n            lasum = 0; \n        }\n    }\n    return true;\n}\n"]}
{"id": "117", "ref_c": [["char * reverseWords(char * s){\\n    int n=strlen(s);\\n    int prev=0;\\n    for(int i=0; i<n; i++){\\n        if (s[i]==\\' \\'){//All the words in s are separated by a single space.\\n            reverse(prev, i-1, s);\\n            prev=i+1;\\n        }"], ["char * reverseWords(char * s){\\n    int n=strlen(s);\\n    int prev=0;\\n    for(int i=0; i<n; i++){\\n        if (s[i]==\\' \\'){//All the words in s are separated by a single space.\\n            reverse(prev, i-1, s);\\n            prev=i+1;\\n        }"], ["char * reverseWords(char * s){\\n    int n=strlen(s);\\n    int prev=0;\\n    for(int i=0; i<n; i++){\\n        if (s[i]==\\' \\'){//All the words in s are separated by a single space.\\n            reverse(prev, i-1, s);\\n            prev=i+1;\\n        }"]]}
{"id": "118", "ref_c": [["int maxDepth(struct Node* root) {\\n    if (root == NULL) {\\n        return 0;\\n    }"], ["int maxDepth(struct Node* root) {\\n    if (root == NULL) {\\n        return 0;\\n    }"], ["int maxDepth(struct Node* root) {\\n    return depth(root);\\n}"]]}
{"id": "119", "ref_c": [["int arrayPairSum(int* nums, int numsSize){\\nqsort(nums,numsSize,sizeof(int),cmp);\\nint sum=0;\\nfor(int i=0;i<numsSize;i=i+2){\\n    sum += nums[i];\\n}"], ["int arrayPairSum(int* nums, int numsSize){\\nqsort(nums,numsSize,sizeof(int),cmp);\\nint sum=0;\\nfor(int i=0;i<numsSize;i=i+2){\\n    sum += nums[i];\\n}"], ["int arrayPairSum(int* nums, int numsSize){\\n    int sum = 0;\\n    qsort(nums, numsSize, sizeof(int), comparator);\\n    for (int i = 0; i < numsSize; i+=2)\\n    {\\n        /* code */\\n        sum += nums[i];\\n    }"]]}
{"id": "120", "ref_c": [["int findTilt(struct TreeNode* root){\\n    res = 0;\\n    rec(root);\\n    return res;\\n}"], ["int findTilt(struct TreeNode* root){\\n    res = 0;\\n    rec(root);\\n    return res;\\n}"], ["int findTilt(struct TreeNode* root){\\n    res = 0;\\n    rec(root);\\n    return res;\\n}"]]}
{"id": "121", "ref_c": ["\nint** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes) {\n    \n    int totalElements = 0;\n    for (int i = 0; i < matSize; i++) {\n        totalElements += matColSize[i];\n    }\n\n    if (r * c != totalElements) {\n       \n        *returnSize = matSize;\n        *returnColumnSizes = matColSize;\n        return mat;\n    }\n\n    int* temp = (int*)malloc(totalElements * sizeof(int));\n    int k = 0;\n\n    int** newMat = (int**)malloc(r * sizeof(int*));\n\n    for (int i = 0; i < r; i++) {\n        newMat[i] = (int*)malloc(c * sizeof(int));\n    }\n\n    for (int i = 0; i < matSize; i++) {\n        for (int j = 0; j < matColSize[i]; j++) {\n            temp[k++] = mat[i][j];\n        }\n    }\n\n    k = 0;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            newMat[i][j] = temp[k++];\n        }\n    }\n\n    free(temp);\n\n    *returnSize = r;\n    *returnColumnSizes = (int*)malloc(r * sizeof(int));\n\n    for (int i = 0; i < r; i++) {\n        (*returnColumnSizes)[i] = c;\n    }\n\n    return newMat;\n}\n", "\nint** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes) {\n    \n    int totalElements = 0;\n    for (int i = 0; i < matSize; i++) {\n        totalElements += matColSize[i];\n    }\n\n    if (r * c != totalElements) {\n       \n        *returnSize = matSize;\n        *returnColumnSizes = matColSize;\n        return mat;\n    }\n\n    int* temp = (int*)malloc(totalElements * sizeof(int));\n    int k = 0;\n\n    int** newMat = (int**)malloc(r * sizeof(int*));\n\n    for (int i = 0; i < r; i++) {\n        newMat[i] = (int*)malloc(c * sizeof(int));\n    }\n\n    for (int i = 0; i < matSize; i++) {\n        for (int j = 0; j < matColSize[i]; j++) {\n            temp[k++] = mat[i][j];\n        }\n    }\n\n    k = 0;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            newMat[i][j] = temp[k++];\n        }\n    }\n\n    free(temp);\n\n    *returnSize = r;\n    *returnColumnSizes = (int*)malloc(r * sizeof(int));\n\n    for (int i = 0; i < r; i++) {\n        (*returnColumnSizes)[i] = c;\n    }\n\n    return newMat;\n}\n", "\nint** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes) {\n    \n    int totalElements = 0;\n    for (int i = 0; i < matSize; i++) {\n        totalElements += matColSize[i];\n    }\n\n    if (r * c != totalElements) {\n       \n        *returnSize = matSize;\n        *returnColumnSizes = matColSize;\n        return mat;\n    }\n\n    int* temp = (int*)malloc(totalElements * sizeof(int));\n    int k = 0;\n\n    int** newMat = (int**)malloc(r * sizeof(int*));\n\n    for (int i = 0; i < r; i++) {\n        newMat[i] = (int*)malloc(c * sizeof(int));\n    }\n\n    for (int i = 0; i < matSize; i++) {\n        for (int j = 0; j < matColSize[i]; j++) {\n            temp[k++] = mat[i][j];\n        }\n    }\n\n    k = 0;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            newMat[i][j] = temp[k++];\n        }\n    }\n\n    free(temp);\n\n    *returnSize = r;\n    *returnColumnSizes = (int*)malloc(r * sizeof(int));\n\n    for (int i = 0; i < r; i++) {\n        (*returnColumnSizes)[i] = c;\n    }\n\n    return newMat;\n}\n"]}
{"id": "122", "ref_c": [["bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot) {\\n     if(root == NULL) {\\n                 return false;\\n                     }"], ["bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot) {\\n     if(root == NULL) {\\n                 return false;\\n                     }"], ["bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot) {\\n     if(root == NULL) {\\n                 return false;\\n                     }"]]}
{"id": "123", "ref_c": [["int distributeCandies(int* candyType, int candyTypeSize){\\n\\n    /*\\n     * Input:\\n     *  candyType\\n     *  candyTypeSize\\n     */\\n\\n    int type = 0;\\n    int prev = INT_MIN;\\n\\n    /* Sort the candies by value */\\n    qsort(candyType, candyTypeSize, sizeof(int), cmp);\\n    \\n    /* Check the different types of candies */\\n    for (int i = 0; i < candyTypeSize; i++) {\\n        if (prev != candyType[i]) {\\n            type++;\\n            prev= candyType[i];\\n        }"], ["int distributeCandies(int* candyType, int candyTypeSize){\\n\\n    /*\\n     * Input:\\n     *  candyType\\n     *  candyTypeSize\\n     */\\n\\n    int type = 0;\\n    int prev = INT_MIN;\\n\\n    /* Sort the candies by value */\\n    qsort(candyType, candyTypeSize, sizeof(int), cmp);\\n    \\n    /* Check the different types of candies */\\n    for (int i = 0; i < candyTypeSize; i++) {\\n        if (prev != candyType[i]) {\\n            type++;\\n            prev= candyType[i];\\n        }"], ["int distributeCandies(int* candyType, int candyTypeSize){\\n\\n    /*\\n     * Input:\\n     *  candyType\\n     *  candyTypeSize\\n     */\\n\\n    int type = 0;\\n    int prev = INT_MIN;\\n\\n    /* Sort the candies by value */\\n    qsort(candyType, candyTypeSize, sizeof(int), cmp);\\n    \\n    /* Check the different types of candies */\\n    for (int i = 0; i < candyTypeSize; i++) {\\n        if (prev != candyType[i]) {\\n            type++;\\n            prev= candyType[i];\\n        }"]]}
{"id": "127", "ref_c": [["int* preorder(struct Node* root, int* returnSize) {\\n    int* arr = (int*) malloc(10000 * sizeof(int));\\n    int idx = 0;\\n    search(root, arr, &idx);\\n    *returnSize = idx;\\n    return arr;\\n}"], ["int* preorder(struct Node* root, int* returnSize) \\n{\\n    no_of_nodes = 0;\\n    \\n    nodes(root);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * no_of_nodes);\\n    int ret_arr_index = 0;\\n    \\n    preorder_trav(root, ret_arr, &ret_arr_index);\\n    *returnSize = ret_arr_index;\\n    return ret_arr;\\n    \\n    \\n}"], ["int* preorder(struct Node* root, int* returnSize) \\n{\\n    no_of_nodes = 0;\\n    \\n    nodes(root);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * no_of_nodes);\\n    int ret_arr_index = 0;\\n    \\n    preorder_trav(root, ret_arr, &ret_arr_index);\\n    *returnSize = ret_arr_index;\\n    return ret_arr;\\n    \\n    \\n}"]]}
{"id": "128", "ref_c": [["int* postorder(struct Node* root, int* returnSize) {\\n    *returnSize=0;\\n    int *v=(int*)malloc(sizeof(int)*10000);\\n    postordertravel(root, returnSize,v);\\n    return v;\\n}"], ["int* postorder(struct Node* root, int* returnSize) {\\n   if (!root){\\n        *returnSize = 0;\\n        return 0;\\n    }"], ["int* postorder(struct Node* root, int* returnSize) {\\n   if (!root){\\n        *returnSize = 0;\\n        return 0;\\n    }"]]}
{"id": "129", "ref_c": [["int findLHS(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int max = 0, count = 1, temp = nums[0], preCount = 0;\\n    for(int i=1; i<numsSize; i++)\\n    {\\n        if(nums[i] == temp) count++;\\n        else \\n        {\\n            if(preCount != 0 && max < preCount + count) max = preCount + count; \\n            if(nums[i] - nums[i-1] == 1) preCount = count;\\n            else preCount = 0;\\n            temp = nums[i];\\n            count = 1;\\n        }"], ["int findLHS(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int max = 0, count = 1, temp = nums[0], preCount = 0;\\n    for(int i=1; i<numsSize; i++)\\n    {\\n        if(nums[i] == temp) count++;\\n        else \\n        {\\n            if(preCount != 0 && max < preCount + count) max = preCount + count; \\n            if(nums[i] - nums[i-1] == 1) preCount = count;\\n            else preCount = 0;\\n            temp = nums[i];\\n            count = 1;\\n        }"], ["int findLHS(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int max = 0, count = 1, temp = nums[0], preCount = 0;\\n    for(int i=1; i<numsSize; i++)\\n    {\\n        if(nums[i] == temp) count++;\\n        else \\n        {\\n            if(preCount != 0 && max < preCount + count) max = preCount + count; \\n            if(nums[i] - nums[i-1] == 1) preCount = count;\\n            else preCount = 0;\\n            temp = nums[i];\\n            count = 1;\\n        }"]]}
{"id": "132", "ref_c": [["int maxCount(int m, int n, int** ops, int opsSize, int* opsColSize){\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<opsSize; i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }"], ["int maxCount(int m, int n, int** ops, int opsSize, int* opsColSize){\\n    int res_l = m;\\n    int res_h = n;\\n    for(int i = 0; i < opsSize; i ++){\\n        if(ops[i][0] < res_l) res_l = ops[i][0];\\n        if(ops[i][1] < res_h) res_h = ops[i][1];\\n    }"], ["int maxCount(int m, int n, int** ops, int opsSize, int* opsColSize){\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<opsSize; i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }"]]}
{"id": "133", "ref_c": [["char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){\\n\\n    int i, min_sum = INT_MAX;\\n    myHashTable_t *words = NULL;\\n    myHashTable_t *element;\\n\\n    for (i=0; i<list1Size; i++)\\n    {\\n        element = (myHashTable_t*)malloc(sizeof(*element));\\n        strcpy(element->word, list1[i]);\\n        element->index_1 = i;\\n        HASH_ADD_STR(words, word, element);\\n    }"], ["char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){\\n\\n    int i, min_sum = INT_MAX;\\n    myHashTable_t *words = NULL;\\n    myHashTable_t *element;\\n\\n    for (i=0; i<list1Size; i++)\\n    {\\n        element = (myHashTable_t*)malloc(sizeof(*element));\\n        strcpy(element->word, list1[i]);\\n        element->index_1 = i;\\n        HASH_ADD_STR(words, word, element);\\n    }"], ["char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){\\n\\n    int i, min_sum = INT_MAX;\\n    myHashTable_t *words = NULL;\\n    myHashTable_t *element;\\n\\n    for (i=0; i<list1Size; i++)\\n    {\\n        element = (myHashTable_t*)malloc(sizeof(*element));\\n        strcpy(element->word, list1[i]);\\n        element->index_1 = i;\\n        HASH_ADD_STR(words, word, element);\\n    }"]]}
{"id": "134", "ref_c": [["bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n){\\n    for (int i = 0; i < flowerbedSize; i++) {\\n        if (flowerbed[i] == 0) {\\n            if (i == 0 && flowerbedSize < 3 || \\n                i == 0  && (i + 1) < flowerbedSize && flowerbed[i + 1] == 0 ||\\n                i == (flowerbedSize - 1) && (i - 1) >= 0 && flowerbed[i - 1] == 0 ||\\n                (i - 1) >= 0 && (i + 1) < flowerbedSize && flowerbed[i- 1] == 0 && flowerbed[i] == 0 && flowerbed[i + 1] == 0) {\\n                    n--;\\n                    flowerbed[i] = 1;\\n                }"], ["bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n){\\n    for (int i = 0; i < flowerbedSize; i++) {\\n        if (flowerbed[i] == 0) {\\n            if (i == 0 && flowerbedSize < 3 || \\n                i == 0  && (i + 1) < flowerbedSize && flowerbed[i + 1] == 0 ||\\n                i == (flowerbedSize - 1) && (i - 1) >= 0 && flowerbed[i - 1] == 0 ||\\n                (i - 1) >= 0 && (i + 1) < flowerbedSize && flowerbed[i- 1] == 0 && flowerbed[i] == 0 && flowerbed[i + 1] == 0) {\\n                    n--;\\n                    flowerbed[i] = 1;\\n                }"], ["bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n){\\n    for (int i = 0; i < flowerbedSize; i++) {\\n        if (flowerbed[i] == 0) {\\n            if (i == 0 && flowerbedSize < 3 || \\n                i == 0  && (i + 1) < flowerbedSize && flowerbed[i + 1] == 0 ||\\n                i == (flowerbedSize - 1) && (i - 1) >= 0 && flowerbed[i - 1] == 0 ||\\n                (i - 1) >= 0 && (i + 1) < flowerbedSize && flowerbed[i- 1] == 0 && flowerbed[i] == 0 && flowerbed[i + 1] == 0) {\\n                    n--;\\n                    flowerbed[i] = 1;\\n                }"]]}
{"id": "135", "ref_c": ["\nvoid inorder(struct TreeNode* root, char* pRetVal, int* returnSize) {\n    if (root == NULL) {\n        return;\n    }\n\n    snprintf(pRetVal + strlen(pRetVal), (*returnSize), \"%d\", root->val);\n\n    if (root->left != NULL) {\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->left, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n\n    if (root->right != NULL) {\n        if (root->left == NULL) {\n            pRetVal[strlen(pRetVal)] = '(';\n            pRetVal[strlen(pRetVal)] = ')';\n        }\n\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->right, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n}\n\nchar* tree2str(struct TreeNode* root) {\nchar* pRetVal = NULL;\n\n    int returnSize = 1e5;\n    pRetVal = (char*)calloc(returnSize, sizeof(char));\n    if (pRetVal == NULL) {\n        perror(\"calloc\");\n        return pRetVal;\n    }\n    inorder(root, pRetVal, &returnSize);\n    pRetVal[strlen(pRetVal)] = '\u0000';\n\n    return pRetVal;   \n}\n", "\nvoid inorder(struct TreeNode* root, char* pRetVal, int* returnSize) {\n    if (root == NULL) {\n        return;\n    }\n\n    snprintf(pRetVal + strlen(pRetVal), (*returnSize), \"%d\", root->val);\n\n    if (root->left != NULL) {\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->left, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n\n    if (root->right != NULL) {\n        if (root->left == NULL) {\n            pRetVal[strlen(pRetVal)] = '(';\n            pRetVal[strlen(pRetVal)] = ')';\n        }\n\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->right, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n}\n\nchar* tree2str(struct TreeNode* root) {\nchar* pRetVal = NULL;\n\n    int returnSize = 1e5;\n    pRetVal = (char*)calloc(returnSize, sizeof(char));\n    if (pRetVal == NULL) {\n        perror(\"calloc\");\n        return pRetVal;\n    }\n    inorder(root, pRetVal, &returnSize);\n    pRetVal[strlen(pRetVal)] = '\u0000';\n\n    return pRetVal;   \n}\n", "\nvoid inorder(struct TreeNode* root, char* pRetVal, int* returnSize) {\n    if (root == NULL) {\n        return;\n    }\n\n    snprintf(pRetVal + strlen(pRetVal), (*returnSize), \"%d\", root->val);\n\n    if (root->left != NULL) {\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->left, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n\n    if (root->right != NULL) {\n        if (root->left == NULL) {\n            pRetVal[strlen(pRetVal)] = '(';\n            pRetVal[strlen(pRetVal)] = ')';\n        }\n\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->right, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n}\n\nchar* tree2str(struct TreeNode* root) {\nchar* pRetVal = NULL;\n\n    int returnSize = 1e5;\n    pRetVal = (char*)calloc(returnSize, sizeof(char));\n    if (pRetVal == NULL) {\n        perror(\"calloc\");\n        return pRetVal;\n    }\n    inorder(root, pRetVal, &returnSize);\n    pRetVal[strlen(pRetVal)] = '\u0000';\n\n    return pRetVal;   \n}\n"]}
{"id": "138", "ref_c": [["struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if (root1 != NULL && root2 != NULL)\\n        root1->val += root2->val;\\n    else if (root1 == NULL)\\n        return root2;\\n    else\\n        return root1;\\n\\n    root1->left = mergeTrees(root1->left, root2->left);\\n    root1->right = mergeTrees(root1->right, root2->right); \\n    return root1;\\n}"], ["struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if (root1 != NULL && root2 != NULL)\\n        root1->val += root2->val;\\n    else if (root1 == NULL)\\n        return root2;\\n    else\\n        return root1;\\n\\n    root1->left = mergeTrees(root1->left, root2->left);\\n    root1->right = mergeTrees(root1->right, root2->right); \\n    return root1;\\n}"], ["struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if (root1 != NULL && root2 != NULL)\\n        root1->val += root2->val;\\n    else if (root1 == NULL)\\n        return root2;\\n    else\\n        return root1;\\n\\n    root1->left = mergeTrees(root1->left, root2->left);\\n    root1->right = mergeTrees(root1->right, root2->right); \\n    return root1;\\n}"]]}
{"id": "142", "ref_c": [["int maximumProduct(int* nums, int numsSize) {\\n    int min1 = INT_MAX, min2 = INT_MAX;\\n    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;\\n\\n    for (int i = 0; i < numsSize; ++i) {\\n        updateMinMax(nums[i], &min1, &min2, &max1, &max2, &max3);\\n    }"], ["int maximumProduct(int* nums, int numsSize) {\\n    int min1 = INT_MAX, min2 = INT_MAX;\\n    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;\\n\\n    for (int i = 0; i < numsSize; ++i) {\\n        updateMinMax(nums[i], &min1, &min2, &max1, &max2, &max3);\\n    }"], ["int maximumProduct(int* nums, int numsSize) {\\n    int min1 = INT_MAX, min2 = INT_MAX;\\n    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;\\n\\n    for (int i = 0; i < numsSize; ++i) {\\n        updateMinMax(nums[i], &min1, &min2, &max1, &max2, &max3);\\n    }"]]}
{"id": "143", "ref_c": [["double* averageOfLevels(struct TreeNode* root, int* returnSize){\\n    double *result = calloc(10000,  sizeof(double));\\n    struct TreeNode* queue[10010];\\n    int front = 0, back = 0;\\n    *returnSize = 0;\\n    queue[back++] = root;\\n    while(front < back) {\\n        double sum = 0.0;\\n        int len = back - front;\\n        int cur_back = back;\\n        while(front < cur_back) {\\n            struct TreeNode* node = queue[front++];\\n            if(node->left)\\n                queue[back++] = node->left;\\n            if(node->right)\\n                queue[back++] = node->right;\\n            sum += node->val;\\n        }"], ["double* averageOfLevels(struct TreeNode* root, int* returnSize) {\\n    // maxmimum possible depth is 14\\n    long *sumSet = (long *)calloc(10000, sizeof(long)); \\n    int *occurrence = (int *)calloc(10000, sizeof(int)); \\n\\n    helperDepth(root, 1, sumSet, occurrence); \\n\\n    int index = 9999; \\n    while (occurrence[index] == 0){\\n        index--; \\n    }"], ["double* averageOfLevels(struct TreeNode* root, int* returnSize){\\n    double *vals = calloc(1001, sizeof(double));\\n    int *count = calloc(1001, sizeof(int));\\n\\n    fillVals(root, vals, count, 0);\\n    *returnSize = 0;\\n    int i = 0;\\n        while (count[i] > 0)\\n        {   \\n            (*returnSize)++;\\n            vals[i] /= count[i];\\n            i++;\\n        }"]]}
{"id": "144", "ref_c": [["double findMaxAverage(int* nums, int numsSize, int k) {\\n    if (numsSize < k) return -1;\\n\\n    int l = 0;\\n    int r = 0;\\n    double max_avg = INT_MIN;\\n    double avg = 0.0;\\n    double sum = 0;\\n\\n    while (r < k) {\\n        sum += nums[r];\\n        r++;\\n    }"], ["double findMaxAverage(int* nums, int numsSize, int k) {\\n    if (numsSize < k) return -1;\\n\\n    int l = 0;\\n    int r = 0;\\n    double max_avg = INT_MIN;\\n    double avg = 0.0;\\n    double sum = 0;\\n\\n    while (r < k) {\\n        sum += nums[r];\\n        r++;\\n    }"], ["double findMaxAverage(int* nums, int numsSize, int k){        \\n        if (k > numsSize) {\\n            return -1;\\n        }"]]}
{"id": "145", "ref_c": [["int* findErrorNums(int* nums, int numsSize, int* returnSize){\\r\\n    *returnSize = 2;\\r\\n    int rep = 0;\\r\\n    int init_sum;\\r\\n    int half;\\r\\n    init_sum = ((numsSize)*((2*1)+(numsSize-1)*1))/2;\\r\\n    int act_sum = 0;\\r\\n    int *a = malloc(sizeof(int)*(*returnSize));\\r\\n\\r\\n    for (int i = 0; i < numsSize; i++)\\r\\n    {\\r\\n        for (int j = 0; j < numsSize; j++)\\r\\n        {\\r\\n            half = i;\\r\\n            if (nums[i]==nums[j]&&i!=j)\\r\\n            {\\r\\n                rep = nums[i];\\r\\n                goto quit;\\r\\n            }"], ["int* findErrorNums(int* nums, int numsSize, int* returnSize){\\r\\n    *returnSize = 2;\\r\\n    int rep = 0;\\r\\n    int init_sum;\\r\\n    int half;\\r\\n    init_sum = ((numsSize)*((2*1)+(numsSize-1)*1))/2;\\r\\n    int act_sum = 0;\\r\\n    int *a = malloc(sizeof(int)*(*returnSize));\\r\\n\\r\\n    for (int i = 0; i < numsSize; i++)\\r\\n    {\\r\\n        for (int j = 0; j < numsSize; j++)\\r\\n        {\\r\\n            half = i;\\r\\n            if (nums[i]==nums[j]&&i!=j)\\r\\n            {\\r\\n                rep = nums[i];\\r\\n                goto quit;\\r\\n            }"], ["int* findErrorNums(int* nums, int numsSize, int* returnSize){\\n    int* res = (int *)(malloc(sizeof(int) * 2));\\n    *returnSize = 2;\\n    int xorAcc = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        xorAcc ^= nums[i];\\n        xorAcc ^= i + 1;\\n    }"]]}
{"id": "146", "ref_c": [["bool findTarget(struct TreeNode* root, int k){\\n    bool res = false;\\n    \\n    help(root, root, k, &res);\\n\\n    return res;\\n}"], ["bool findTarget(struct TreeNode* root, int k){\\n    /*\\n     * Input:\\n     *  root, root of BST\\n     *  k, target number k\\n     */\\n     \\n    /*\\n     * Output:\\n     *  return true if there exist two elements in the BST such that \\n     *  their sum is equal to the given target.\\n     */\\n     \\n    return dfs(root, root, k);\\n}"], ["bool findTarget(struct TreeNode* root, int k){\\n    /*\\n     * Input:\\n     *  root, root of BST\\n     *  k, target number k\\n     */\\n     \\n    /*\\n     * Output:\\n     *  return true if there exist two elements in the BST such that \\n     *  their sum is equal to the given target.\\n     */\\n     \\n    return dfs(root, root, k);\\n}"]]}
{"id": "147", "ref_c": [["bool judgeCircle(char * moves){\\n    int a=0,b=0,c=0,d=0;\\n    for(int i=0;i<strlen(moves);i++){\\n        if(moves[i]==\\'U\\'){\\n            a++;\\n        }"], ["bool judgeCircle(char * moves){\\n    int a=0,b=0,c=0,d=0;\\n    for(int i=0;i<strlen(moves);i++){\\n        if(moves[i]==\\'U\\'){\\n            a++;\\n        }"], ["bool judgeCircle(char * moves){\\n    int a=0,b=0,c=0,d=0;\\n    for(int i=0;i<strlen(moves);i++){\\n        if(moves[i]==\\'U\\'){\\n            a++;\\n        }"]]}
{"id": "148", "ref_c": [["int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes) {\\n    int rows = imgSize;\\n    int cols = imgColSize[0];\\n\\n    /* Allocate the memory for output result */\\n    int **result = (int **)calloc(rows, sizeof(int *));\\n    if (result == NULL) {\\n        return NULL;\\n    }"], ["int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes) {\\n    int rows = imgSize;\\n    int cols = imgColSize[0];\\n\\n    /* Allocate the memory for output result */\\n    int **result = (int **)calloc(rows, sizeof(int *));\\n    if (result == NULL) {\\n        return NULL;\\n    }"], ["int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes) {\\n    int** Smoother = (int**)malloc(sizeof(int*) * imgSize);\\n    int row, col, exist_entry;\\n\\n    *returnSize = imgSize;\\n    *returnColumnSizes = (int*)malloc(sizeof(int) * imgSize);\\n    for(row =0; row< imgSize; row++)\\n    {\\n        Smoother[row] = (int*)calloc((*imgColSize), sizeof(int));\\n        (*returnColumnSizes)[row] = imgColSize[row];\\n    }"]]}
{"id": "149", "ref_c": [["int findSecondMinimumValue(struct TreeNode* root){\\n    if(root->left == NULL && root->right == NULL)\\n        return -1;\\n    int*array = malloc(sizeof(int)*26);\\n    int index = 0;\\n    inorder(&array,&index,root);\\n    array = realloc(array,sizeof(int)*index);\\n    qsort(array,index,sizeof(int),f);\\n    int max = array[0];\\n    int p = 1;\\n    while(p < index && array[p] == max)\\n        p++;\\n    if(p >= index)\\n        return -1;\\n    return array[p];\\n}"], ["int findSecondMinimumValue(struct TreeNode* root){\\n    if(root->left == NULL && root->right == NULL)\\n        return -1;\\n    int*array = malloc(sizeof(int)*26);\\n    int index = 0;\\n    inorder(&array,&index,root);\\n    array = realloc(array,sizeof(int)*index);\\n    qsort(array,index,sizeof(int),f);\\n    int max = array[0];\\n    int p = 1;\\n    while(p < index && array[p] == max)\\n        p++;\\n    if(p >= index)\\n        return -1;\\n    return array[p];\\n}"], ["int findSecondMinimumValue(struct TreeNode* root){\\n\\tassert(root != NULL);\\n\\n\\tconst int min = root->val;\\n\\n\\tbool secondMinExist = false;\\n\\tint secondMin = INT_MAX;\\n\\n\\tstruct TreeNode * bfsQueue[MAX_NODE];\\n\\tint first = 0, nextOfLast = 0;\\n\\n\\tbfsQueue[nextOfLast] = root;\\n\\tnextOfLast += 1;\\n\\n\\tdo {\\n\\t\\tstruct TreeNode * const pCur = bfsQueue[first];\\n\\t\\tfirst += 1;\\n\\n\\t\\tif (pCur->val == min){\\n\\t\\t\\tif (pCur->left != NULL){\\n\\t\\t\\t\\tbfsQueue[nextOfLast] = pCur->left;\\n\\t\\t\\t\\tnextOfLast += 1;\\n\\t\\t\\t}"]]}
{"id": "150", "ref_c": [["int findLengthOfLCIS(int* nums, int numsSize)\\n{\\n    int counter = 1, max = 1;\\n    for (int i = 0; i < numsSize - 1; i++)\\n    {\\n        if (nums[i + 1] > nums[i])\\n        {\\n            counter++;\\n            if (counter > max)\\n            {\\n                max = counter;\\n            }"], ["int findLengthOfLCIS(int* nums, int numsSize)\\n{\\n    int counter = 1, max = 1;\\n    for (int i = 0; i < numsSize - 1; i++)\\n    {\\n        if (nums[i + 1] > nums[i])\\n        {\\n            counter++;\\n            if (counter > max)\\n            {\\n                max = counter;\\n            }"], ["int findLengthOfLCIS(int* nums, int numsSize){\\n     int max=0,res=0;\\n     for(int i=0;i<numsSize-1;i++)\\n     {\\n         if(nums[i]<nums[i+1])\\n         {\\n             max++;\\n             res=max>res?max:res;\\n         }"]]}
{"id": "151", "ref_c": [["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"]]}
{"id": "152", "ref_c": [["int calPoints(char ** operations, int operationsSize){\\n    \\n    int* arry = (int*) calloc(operationsSize,sizeof(int));\\n    int curr = 0;\\n    int sum = 0;\\n    \\n    for(int i = 0; i < operationsSize; ++i)\\n    {\\n        switch(*(*(operations+i)))\\n        {\\n            case \\'C\\':\\n                *(arry + (--curr)) = 0;\\n                break;\\n            case \\'D\\':\\n                *(arry + (curr++)) = *(arry + curr - 1) * 2;\\n                break;\\n            case \\'+\\':\\n                *(arry + (curr++)) = *(arry + curr - 1) + *(arry + curr - 2);\\n                break;\\n            default:\\n                *(arry + (curr++)) = atoi(*(operations+i));\\n                break;\\n        }"], ["int calPoints(char ** operations, int operationsSize){\\n    \\n    int* arry = (int*) calloc(operationsSize,sizeof(int));\\n    int curr = 0;\\n    int sum = 0;\\n    \\n    for(int i = 0; i < operationsSize; ++i)\\n    {\\n        switch(*(*(operations+i)))\\n        {\\n            case \\'C\\':\\n                *(arry + (--curr)) = 0;\\n                break;\\n            case \\'D\\':\\n                *(arry + (curr++)) = *(arry + curr - 1) * 2;\\n                break;\\n            case \\'+\\':\\n                *(arry + (curr++)) = *(arry + curr - 1) + *(arry + curr - 2);\\n                break;\\n            default:\\n                *(arry + (curr++)) = atoi(*(operations+i));\\n                break;\\n        }"], ["int calPoints(char ** operations, int operationsSize){\\n    \\n    int* arry = (int*) calloc(operationsSize,sizeof(int));\\n    int curr = 0;\\n    int sum = 0;\\n    \\n    for(int i = 0; i < operationsSize; ++i)\\n    {\\n        switch(*(*(operations+i)))\\n        {\\n            case \\'C\\':\\n                *(arry + (--curr)) = 0;\\n                break;\\n            case \\'D\\':\\n                *(arry + (curr++)) = *(arry + curr - 1) * 2;\\n                break;\\n            case \\'+\\':\\n                *(arry + (curr++)) = *(arry + curr - 1) + *(arry + curr - 2);\\n                break;\\n            default:\\n                *(arry + (curr++)) = atoi(*(operations+i));\\n                break;\\n        }"]]}
{"id": "153", "ref_c": [["bool hasAlternatingBits(int n){\\n    \\n    int size = (sizeof(int) * 8);\\n\\n    bool atEndOfSequence = false;\\n    \\n    int prevVal = n & 1;\\n    int bitVal;\\n\\n    for (int i=1; i<size; i++) {\\n        bitVal = (n >> i) & 1;\\n\\n        if (atEndOfSequence && bitVal == 1) return false;\\n        if ((bitVal  ^ prevVal) != 1){\\n            if (bitVal == 0 && prevVal == 0) {\\n                atEndOfSequence = true;\\n            }"], ["bool hasAlternatingBits(int n) {\\n    int flag,flag2,bit;\\n    while(n!=0){\\n        bit = n & 1;\\n        if(bit==1)\\n            flag=1;\\n        else\\n            flag=0;\\n        n >>= 1;\\n        \\n        bit = n & 1;\\n        if(bit==1)\\n            flag2=1;\\n        else\\n            flag2=0;\\n        \\n        if(flag==flag2)\\n            return false;\\n   }"], ["bool hasAlternatingBits(int n) {\\n        long x=1;                     // 1 = 1\\n        while(x<=n){                  // 2 = 10\\n            if(x==n)                  // 5 = 101\\n                return true;          //10 = 1010\\n            else if(x%2==0)           //21 = 10101\\n                x=2*x+1;              //42 = 101010\\n            else                      //85 = 1010101\\n                x=2*x;\\n        }", "bool hasAlternatingBits(int n) {\\n        int flag1,flag2;\\n        while(n){\\n            flag1=n&1;\\n            if(flag1==flag2)\\n                return 0;\\n            n=n>>1;\\n            flag2=flag1;\\n        }"]]}
{"id": "154", "ref_c": [["int countBinarySubstrings(char * s)\\n{\\n    int n = strlen(s);\\n    int Count  = 0;\\n    int prevCount = 0;\\n    int currCount = 1;\\n\\n    for(int i = 1; i < n; i++)\\n    {\\n        if(s[i] == s[i-1])\\n            currCount++;\\n        else\\n        {\\n            prevCount = currCount;\\n            currCount = 1;\\n        }"], ["int countBinarySubstrings(char * s){\\n    int * temp = (int *)malloc(strlen(s)*sizeof(int));\\n    temp[0] = 1;\\n    int idx = 0, sum = 0;\\n    for(int i=1; i<strlen(s); i++)\\n        if(s[i] == s[i-1])          \\n            temp[idx]++;\\n        else temp[++idx] = 1;\\n    for(int i=0; i<idx; i++)\\n        sum += temp[i] < temp[i+1] ? temp[i] : temp[i+1];\\n    free(temp);\\n    return sum;\\n}"], ["int countBinarySubstrings(char * s){\\n    size_t len = strlen(s);\\n    int count = 0;\\n    int i = 0;\\n    int j = 0;\\n    \\n    for (int i = 0; i < len && j < len;) {\\n        char c1 = s[i];\\n        int j = i + 1;\\n        int lptr = 1; // Left counter (keep track of how many chars are on the lhs).\\n        int rptr = 0; // Right counter (\" \" but for the rhs).\\n        bool changeFlag = false;\\n        int changeIndex = -1;\\n        \\n        while (rptr <= lptr) {\\n            char c2 = s[j];\\n            // Once we reach the end of the string, just break out.\\n            if (c2 == \\'\\\\0\\') {\\n                return count;\\n            }"]]}
{"id": "155", "ref_c": [["int findShortestSubArray(int* nums, int numsSize){\\n    int freq[50000],beg[50000],end[50000];\\n    memset(freq,0,sizeof(freq));\\n    int n = numsSize;\\n    for(int i=0; i<n; i++){\\n        if(freq[nums[i]]==0){\\n            beg[nums[i]] = i;\\n        }"], ["int findShortestSubArray(int* nums, int numsSize) {\\n\\n    int finaldegree=1;\\n    int finaldistance=1;\\n    int distance;\\n    int spot;\\n    int degree = 0;\\n    int memo[numsSize];\\n    int counter = 0;\\n    bool check;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        spot = nums[i];\\n        distance = 1;\\n        degree = 1;\\n        check = true;\\n        for(int z=0; z<counter;z++)\\n        {\\n            if(nums[i]==memo[z])\\n            {\\n                check = false;\\n            }"], ["int findShortestSubArray(int* nums, int numsSize) {\\n\\n    int finaldegree=1;\\n    int finaldistance=1;\\n    int distance;\\n    int spot;\\n    int degree = 0;\\n    int memo[numsSize];\\n    int counter = 0;\\n    bool check;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        spot = nums[i];\\n        distance = 1;\\n        degree = 1;\\n        check = true;\\n        for(int z=0; z<counter;z++)\\n        {\\n            if(nums[i]==memo[z])\\n            {\\n                check = false;\\n            }"]]}
{"id": "156", "ref_c": [["struct TreeNode* searchBST(struct TreeNode* root, int val) {\\n    if(root == NULL) {\\n        return NULL;\\n    }"], ["struct TreeNode* searchBST(struct TreeNode* root, int val) {\\n    if(root == NULL) {\\n        return NULL;\\n    }"], ["struct TreeNode* searchBST(struct TreeNode* root, int val) {\\n    if(root == NULL) {\\n        return NULL;\\n    }"]]}
{"id": "158", "ref_c": [["int search(int* nums, int numsSize, int target){\\n    int start = 0, end = numsSize - 1;\\n    while(start <= end){\\n        int mid = start + (end - start)/2;\\n        if(nums[mid] == target){\\n            return mid;\\n        }"], ["int search(int* nums, int numsSize, int target){\\n    int start = 0, end = numsSize - 1;\\n    while(start <= end){\\n        int mid = start + (end - start)/2;\\n        if(nums[mid] == target){\\n            return mid;\\n        }"], ["int search(int* nums, int numsSize, int target){\\n    int L=0;\\n    int U=numsSize-1;\\n    while(L<=U)\\n    {\\n        int mid=(L+U)/2;\\n        if(nums[mid]==target)\\n        {\\n            return mid;\\n        }", "int search(int* nums, int numsSize, int target){\\n    int k=binarysearch(nums,0,numsSize-1,target); \\nreturn k;\\n}"]]}
{"id": "161", "ref_c": [["char * toLowerCase(char * s){\\n   char *lower=s;\\n    while(*lower){\\n        if(*lower>=\\'A\\' && *lower<=\\'Z\\') *lower+=32;\\n        lower++;\\n    }"], ["char * toLowerCase(char * s){\\n   char *lower=s;\\n    while(*lower){\\n        if(*lower>=\\'A\\' && *lower<=\\'Z\\') *lower+=32;\\n        lower++;\\n    }"], ["char * toLowerCase(char * s){\\n   char *lower=s;\\n    while(*lower){\\n        if(*lower>=\\'A\\' && *lower<=\\'Z\\') *lower+=32;\\n        lower++;\\n    }"]]}
{"id": "162", "ref_c": [["bool isOneBitCharacter(int* bits, int bitsSize) {\\n    int i=0;\\n    while(i<bitsSize){\\n        if(bits[i] == 0)\\n            i++;\\n        else if(bits[i] == 1 && (bits[i+1]==1 || bits[i+1]==0) && i <bitsSize-2)\\n            i+=2;\\n        else if(bits[i] == 1 && bits[i+1] == 0)\\n            return false;\\n\\n    }"], ["bool isOneBitCharacter(int* bits, int bitsSize){\\n    int pair = 0;\\n    for (int i = 0; i < bitsSize; bits[i] ? i += 2 : i++) pair = bits[i];\\n    return !pair;\\n}"], ["bool isOneBitCharacter(int* bits, int bitsSize) {\\n    int i = 0;\\n    while(i < bitsSize - 1)\\n    {\\n        i = (bits[i] == 0)?(i+1):(i+2);\\n    }"]]}
{"id": "163", "ref_c": ["\nint pivotIndex(int* nums, int numsSize){\n    int left, right;\n    left = right = 0;\n    for(int i = 0; i < numsSize ;i++){\n        right+=nums[i];\n    }\n    for(int i = 0; i < numsSize; i++){\n        right-=nums[i];\n        if(left == right){\n            return i;\n        }\n        left+=nums[i];\n    }\n    return -1;\n}\n", "\nint pivotIndex(int* nums, int numsSize){\n    int left, right;\n    left = right = 0;\n    for(int i = 0; i < numsSize ;i++){\n        right+=nums[i];\n    }\n    for(int i = 0; i < numsSize; i++){\n        right-=nums[i];\n        if(left == right){\n            return i;\n        }\n        left+=nums[i];\n    }\n    return -1;\n}\n", "\nint pivotIndex(int* nums, int numsSize){\n    int left, right;\n    left = right = 0;\n    for(int i = 0; i < numsSize ;i++){\n        right+=nums[i];\n    }\n    for(int i = 0; i < numsSize; i++){\n        right-=nums[i];\n        if(left == right){\n            return i;\n        }\n        left+=nums[i];\n    }\n    return -1;\n}\n"]}
{"id": "164", "ref_c": [["int* selfDividingNumbers(int left, int right, int* returnSize)\\n{\\n    int*arr = malloc((right-left+1)*sizeof(int));\\n    int index = 0;\\n    for(int i = left;i<=right;i++)\\n    {\\n        int digits=0,n=i,m=i;\\n        while(m!=0)\\n        {\\n            digits++;\\n            m/=10;\\n        }"], ["int* selfDividingNumbers(int left, int right, int* returnSize)\\n{\\n    int*arr = malloc((right-left+1)*sizeof(int));\\n    int index = 0;\\n    for(int i = left;i<=right;i++)\\n    {\\n        int digits=0,n=i,m=i;\\n        while(m!=0)\\n        {\\n            digits++;\\n            m/=10;\\n        }"], ["int* selfDividingNumbers(int left, int right, int* returnSize) {\\n    int*arr = malloc((right-left+1)*sizeof(int));\\n    int index = 0;\\n    for(int i = left;i<=right;i++)\\n    {\\n        int digits=0,n=i,m=i;\\n        while(m!=0)\\n        {\\n            digits++;\\n            m/=10;\\n        }"]]}
{"id": "165", "ref_c": ["\nvoid recursion(int **image, int x, int y, int color, int temp, int length, int height) {\n    if (x < 0 || x >= length || y < 0 || y >= height) {\n        return;\n    }\n    if (image[y][x] == temp){\n        image[y][x] = color;\n        recursion(image, x, y - 1, color, temp, length, height);\n        recursion(image, x + 1, y, color, temp, length, height);\n        recursion(image, x, y + 1, color, temp, length, height);\n        recursion(image, x - 1, y, color, temp, length, height);\n    }\n}\n\nint** floodFill(int** image, int imageSize, int *imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes) {\n    int temp = image[sr][sc];\n    *returnSize = imageSize;\n    *returnColumnSizes = (int *)malloc(imageSize * sizeof(int));\n    for (int i=0; i<imageSize; i++){\n        (*returnColumnSizes)[i] = imageColSize[i];\n    }\n    if (temp == color) {\n        return image;\n    }\n    int height = imageSize;\n    int length = *imageColSize;\n    recursion(image, sc, sr, color, temp, length, height);\n    return image;\n}\n", "\nvoid recursion(int **image, int x, int y, int color, int temp, int length, int height) {\n    if (x < 0 || x >= length || y < 0 || y >= height) {\n        return;\n    }\n    if (image[y][x] == temp){\n        image[y][x] = color;\n        recursion(image, x, y - 1, color, temp, length, height);\n        recursion(image, x + 1, y, color, temp, length, height);\n        recursion(image, x, y + 1, color, temp, length, height);\n        recursion(image, x - 1, y, color, temp, length, height);\n    }\n}\n\nint** floodFill(int** image, int imageSize, int *imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes) {\n    int temp = image[sr][sc];\n    *returnSize = imageSize;\n    *returnColumnSizes = (int *)malloc(imageSize * sizeof(int));\n    for (int i=0; i<imageSize; i++){\n        (*returnColumnSizes)[i] = imageColSize[i];\n    }\n    if (temp == color) {\n        return image;\n    }\n    int height = imageSize;\n    int length = *imageColSize;\n    recursion(image, sc, sr, color, temp, length, height);\n    return image;\n}\n", "\nvoid recursion(int **image, int x, int y, int color, int temp, int length, int height) {\n    if (x < 0 || x >= length || y < 0 || y >= height) {\n        return;\n    }\n    if (image[y][x] == temp){\n        image[y][x] = color;\n        recursion(image, x, y - 1, color, temp, length, height);\n        recursion(image, x + 1, y, color, temp, length, height);\n        recursion(image, x, y + 1, color, temp, length, height);\n        recursion(image, x - 1, y, color, temp, length, height);\n    }\n}\n\nint** floodFill(int** image, int imageSize, int *imageColSize, int sr, int sc, int color, int* returnSize, int** returnColumnSizes) {\n    int temp = image[sr][sc];\n    *returnSize = imageSize;\n    *returnColumnSizes = (int *)malloc(imageSize * sizeof(int));\n    for (int i=0; i<imageSize; i++){\n        (*returnColumnSizes)[i] = imageColSize[i];\n    }\n    if (temp == color) {\n        return image;\n    }\n    int height = imageSize;\n    int length = *imageColSize;\n    recursion(image, sc, sr, color, temp, length, height);\n    return image;\n}\n"]}
{"id": "166", "ref_c": [["char nextGreatestLetter(char* letters, int lettersSize, char target) {\\n    int left = 0, right = lettersSize - 1;\\n    int ans = 0;\\n    while (left <= right){\\n        int mid = left + (right - left) / 2;\\n        if (letters[mid] > target){\\n            ans = mid;\\n            right = mid - 1;\\n        }"], ["char nextGreatestLetter(char* letters, int lettersSize, char target) {\\n    int left = 0, right = lettersSize - 1;\\n    int ans = 0;\\n    while (left <= right){\\n        int mid = left + (right - left) / 2;\\n        if (letters[mid] > target){\\n            ans = mid;\\n            right = mid - 1;\\n        }"], ["char nextGreatestLetter(char* letters, int lettersSize, char target) {\\n    int left = 0, right = lettersSize - 1;\\n    int ans = 0;\\n    while (left <= right){\\n        int mid = left + (right - left) / 2;\\n        if (letters[mid] > target){\\n            ans = mid;\\n            right = mid - 1;\\n        }"]]}
{"id": "167", "ref_c": [["int minCostClimbingStairs(int* cost, int costSize){\\n    int minus_1_cost = 0;\\n    int minus_2_cost = 0;\\n    int cur_cost = 0;\\n    int i = 2;\\n    for(;i<costSize;i++) {\\n        cur_cost = min(minus_1_cost + cost[i-1], minus_2_cost + cost[i-2]);\\n        minus_2_cost = minus_1_cost;\\n        minus_1_cost = cur_cost;\\n    }"], ["int minCostClimbingStairs(int* cost, int costSize) {\\n    int n = costSize;\\n    int dp[n + 1];\\n\\n    dp[0] = 0;\\n    dp[1] = 0;\\n\\n    for (int i = 2; i <= n; i++) {\\n        dp[i] = fmin(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\\n    }", "int minCostClimbingStairs(int* cost, int costSize) {\\n    int n = costSize;\\n    int dp[n + 1];\\n    dp[0] = cost[0];\\n    dp[1] = cost[1];\\n    \\n    // Calculate the minimum cost for each stair starting from the third stair\\n    for(int i = 2; i < n; i++) {\\n        dp[i] = fmin(dp[i - 1], dp[i - 2]) + cost[i];\\n    }", "int minCostClimbingStairs(int* cost, int costSize) {\\n    int n = costSize;\\n    int prev1 = 0, prev2 = 0;\\n\\n    for (int i = 2; i <= n; i++) {\\n        int currentCost = fmin(prev1 + cost[i - 1], prev2 + cost[i - 2]);\\n        prev2 = prev1;\\n        prev1 = currentCost;\\n    }"], ["int minCostClimbingStairs(int* cost, int costSize){\\n    int minus_1_cost = 0;\\n    int minus_2_cost = 0;\\n    int cur_cost = 0;\\n    int i = 2;\\n    for(;i<costSize;i++) {\\n        cur_cost = min(minus_1_cost + cost[i-1], minus_2_cost + cost[i-2]);\\n        minus_2_cost = minus_1_cost;\\n        minus_1_cost = cur_cost;\\n    }"]]}
{"id": "168", "ref_c": [["int dominantIndex(int* nums, int numsSize){\\n    int max = INT_MIN, secondMax = INT_MIN, maxIndex = -1;\\n    for(int i = 0; i < numsSize; i++) {\\n        if(nums[i] > max) {\\n            secondMax = max;\\n            max = nums[i];\\n            maxIndex = i;\\n        }"], ["int dominantIndex(int* nums, int numsSize){\\n    int max = INT_MIN, secondMax = INT_MIN, maxIndex = -1;\\n    for(int i = 0; i < numsSize; i++) {\\n        if(nums[i] > max) {\\n            secondMax = max;\\n            max = nums[i];\\n            maxIndex = i;\\n        }"], ["int dominantIndex(int* nums, int numsSize){\\n    int max = INT_MIN, secondMax = INT_MIN, maxIndex = -1;\\n    for(int i = 0; i < numsSize; i++) {\\n        if(nums[i] > max) {\\n            secondMax = max;\\n            max = nums[i];\\n            maxIndex = i;\\n        }"]]}
{"id": "169", "ref_c": [["char * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize){\\nchar str[wordsSize][50];\\n\\nchar ch[strlen(licensePlate)+1];\\n\\nint i=0;\\nwhile(*licensePlate)\\n{\\n    if(*licensePlate>=97 && *licensePlate<=122)\\n    {\\n      ch[i++] = *licensePlate;\\n    }"], ["char * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize){\\n    int temp[26] = {0}"], ["char * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize){\\n    int temp[26] = {0}"]]}
{"id": "170", "ref_c": [["int countPrimeSetBits(int left, int right){\\n    int primes[] = {0,0,2,3,0,5,0,7,0,0,0,11,0,13,0,0,0,17,0,19}"], ["int countPrimeSetBits(int left, int right){\\n\\n    int cnt = 0;\\n\\n    for(int i=left; i<=right; i++)\\n    {\\n        if(isPrime(Find1s(i)))\\n            cnt++;   \\n    }"], ["int countPrimeSetBits(int left, int right)\\n{\\n    int res = 0;\\n    for (int i = left; i <= right; i++)\\n    {\\n        int num = __builtin_popcount(i);\\n\\n        switch (num)\\n        {\\n        case 2:\\n        case 3:\\n        case 5:\\n        case 7:\\n        case 11:\\n        case 13:\\n        case 17:\\n        case 19:\\n            res++;\\n            break;\\n\\n        default:\\n            break;\\n        }"]]}
{"id": "171", "ref_c": [["bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){\\n    if (*matrixColSize > 1) for (int i = 1, width = *matrixColSize - 1; i < matrixSize; ++i) if (memcmp(matrix[i - 1], matrix[i] + 1, sizeof(int) * width)) return false;\\n    return true;\\n}"], ["bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize) {\\n    for(int i=1; i<matrixSize; i++)\\n    {\\n        for(int j=1; j<*matrixColSize; j++)\\n        {\\n            if(matrix[i][j]!=matrix[i-1][j-1])\\n                return false;\\n        }"], ["bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){\\n    bool check = true;\\n    if(matrixSize == 1)\\n    {\\n        return true;\\n    }"]]}
{"id": "172", "ref_c": [["int numJewelsInStones(char * jewels, char * stones)\\n{\\n    int c=0;\\n    for(int i=0;i<strlen(jewels);i++)\\n    {\\n        for(int j=0;j<strlen(stones);j++)\\n        {\\n            if(jewels[i]==stones[j])\\n            c++;\\n        }"], ["int numJewelsInStones(char * jewels, char * stones)\\n{\\n    int c=0;\\n    for(int i=0;i<strlen(jewels);i++)\\n    {\\n        for(int j=0;j<strlen(stones);j++)\\n        {\\n            if(jewels[i]==stones[j])\\n            c++;\\n        }"], ["int numJewelsInStones(char * jewels, char * stones)\\n{\\n    int c=0;\\n    for(int i=0;i<strlen(jewels);i++)\\n    {\\n        for(int j=0;j<strlen(stones);j++)\\n        {\\n            if(jewels[i]==stones[j])\\n            c++;\\n        }"]]}
{"id": "173", "ref_c": [["int minDiffInBST(struct TreeNode* root){\\n    int minDiff = INT_MAX;\\n    struct TreeNode *prev = NULL;\\n    minDiffInBSTUtil(root, &prev, &minDiff);\\n    return minDiff;\\n}"], ["int minDiffInBST(struct TreeNode* root){\\n    int minDiff = INT_MAX;\\n    struct TreeNode *prev = NULL;\\n    minDiffInBSTUtil(root, &prev, &minDiff);\\n    return minDiff;\\n}"], ["int minDiffInBST(struct TreeNode* root){\\n     int *inorder_list = (int*) calloc(10000,sizeof(int));\\n       int index = 0;\\n       inorder(root,inorder_list,&index);\\n       int min = INT_MAX;\\n       for(int i=0;i<index-1;i++) {\\n           if(min>(inorder_list[i+1]-inorder_list[i]))\\n                      min  = inorder_list[i+1]-inorder_list[i];\\n       }"]]}
{"id": "174", "ref_c": [["bool rotateString(char * s, char * goal){\\n   if(strlen(s)!=strlen(goal))\\n        return false;\\n    char temp[strlen(s)*2+1];\\n    strcpy(temp,s);\\n    strcat(temp,s);\\n    return strstr(temp,goal)?true:false;\\n}"], ["bool rotateString(char * s, char * goal){\\n   if(strlen(s)!=strlen(goal))\\n        return false;\\n    char temp[strlen(s)*2+1];\\n    strcpy(temp,s);\\n    strcat(temp,s);\\n    return strstr(temp,goal)?true:false;\\n}"], ["bool rotateString(char * s, char * goal){\\n   if(strlen(s)!=strlen(goal))\\n        return false;\\n    char temp[strlen(s)*2+1];\\n    strcpy(temp,s);\\n    strcat(temp,s);\\n    return strstr(temp,goal)?true:false;\\n}"]]}
{"id": "175", "ref_c": [["int uniqueMorseRepresentations(char ** words, int wordsSize){\\n    \\n    if (wordsSize == 1) return 1;\\n    \\n    char** trans = (char**)malloc(wordsSize * sizeof(char*));   // create 2D array \\n    \\n    for(int i=0; i < wordsSize; i++){\\n        int len = strlen(words[i]);\\n        trans[i] = (char*) calloc((len * 4 + 1), sizeof(char)); // create space for each morse code\\n        for(int j=0; j < len; j++)\\n            strcat(trans[i], morse[words[i][j] - \\'a\\']);     // convert english to morse code\\n    }"], ["int uniqueMorseRepresentations(char ** words, int wordsSize){\\n    int c = 1;\\n\\t\\n\\t// Morse code alphabet\\n    const char* Malph[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}"], ["int uniqueMorseRepresentations(char ** words, int wordsSize)\\n{\\n\\n    int transNum = 0 ;\\n    int indx = -1 ;\\n    \\n    char ** transArr = (char **) malloc( wordsSize * sizeof(char *) ) ;\\n\\n    char * morseArr[26] = { \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\\n                            \"....\",\"..\",\".---\",\"-.-\", \".-..\",\"--\",\"-.\",\\n                            \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\\n                            \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\" }"]]}
{"id": "176", "ref_c": [["int* numberOfLines(int* widths, int widthsSize, char * s, int* returnSize){\\n    int st = \\'a\\' -1;\\n    int *ret = malloc(sizeof(int)*2);\\n    int l = 0, sum =0,i;\\n    for(i=0;i<strlen(s);i++) {\\n        int n = widths[s[i] -\\'a\\'];\\n        if (sum+n >100) {\\n            l++;\\n            sum =n;\\n        }"], ["int* numberOfLines(int* widths, int widthsSize, char * s, int* returnSize){\\nint w=widthsSize;\\nint *result=(int *)malloc(2*sizeof(int));\\nint count = 1;\\nint ls=0;\\nint i;\\n\\n    while(*s != \\'\\\\0\\' )\\n    {     \\n        i=(int)*s -97;\\n        ls = ls + widths[i];\\n        if(ls>100)\\n        {\\n            count++;\\n            ls=0;\\n        }"], ["int* numberOfLines(int* widths, int widthsSize, char * s, int* returnSize){\\n\\n    *returnSize=2;\\n    int total=0;\\n    int *arr=calloc(2,sizeof(int));\\n    arr[0]=1;\\n    while(*s){\\n\\n        total+=widths[*s-\\'a\\'];\\n        if(total>100){\\n            total=widths[*s-\\'a\\'];\\n            arr[0]++;\\n        }"]]}
{"id": "177", "ref_c": [["double largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n  double maxArea = 0;\\n  double area = 0;\\n  \\n  for (int i = 0; i < pointsSize; i++) {\\n    for (int j = i + 1; j < pointsSize; j++) {\\n      for (int k = j + 1; k < pointsSize; k++) {\\n        area = getArea(points[i], points[j], points[k]);\\n        \\n        if (area > maxArea) {\\n          maxArea = area;\\n        }"], ["double largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n    double result = 0;\\n    for (int i = 0; i < pointsSize; i++)\\n        for (int j = i + 1; j < pointsSize; j++)\\n            for (int k = j + 1; k < pointsSize; k++) {\\n                int x1 = points[i][0], y1 = points[i][1];\\n                int x2 = points[j][0], y2 = points[j][1];\\n                int x3 = points[k][0], y3 = points[k][1];\\n                double area = fabs(0.50000 * (x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3));\\n                result = result > area ? result : area;\\n            }"], ["double largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n\\n\\nint i,j,k;\\nlong double s1=0,s2=0,s3=0,max=0,max1=0,max2=0,max3=0,ans=0,d=0;\\n  \\nfor(i=0;i<pointsSize-2;i++)\\n{\\nfor(j=i+1;j<pointsSize-1;j++)\\n{\\nfor(k=j+1;k<pointsSize;k++)\\n{\\n    \\ns1=(points[j][0]-points[i][0])*(points[j][0]-points[i][0]);\\ns1+=(points[j][1]-points[i][1])*(points[j][1]-points[i][1]);\\ns1=sqrt(s1);\\n\\ns2=(points[k][0]-points[i][0])*(points[k][0]-points[i][0]);\\ns2+=(points[k][1]-points[i][1])*(points[k][1]-points[i][1]);\\ns2=sqrt(s2);\\n\\ns3=(points[j][0]-points[k][0])*(points[j][0]-points[k][0]);\\ns3+=(points[j][1]-points[k][1])*(points[j][1]-points[k][1]);\\ns3=sqrt(s3);\\n    \\nif(((s1+s2)>s3)&&((s2+s3)>s1)&&((s1+s3)>s2))\\n{\\n    \\nd=(s1+s2+s3)/2;\\ns1=d-s1;\\ns2=d-s2;\\ns3=d-s3;\\nans=d*s1*s2*s3;\\nans=sqrt(ans);\\n\\nif(ans>max)\\nmax=ans;\\n}"]]}
{"id": "178", "ref_c": ["\nstruct words { char *w, n; };\n\ninline char *lwstr(char *s){\n    for (char *p = s - 1 ; *++p ; *p = tolower(*p));\n    return s;\n}\n\ninline bool isbnd(char *w, char **banned, int sz){\n    int i;\n    for (i = 0 ; i < sz && strcmp(w, banned[i]) ; i++);\n    return i < sz;\n}\n\ninline void insw(struct words *ws, int *n, char *w, char **mw, int *mx, char **b, int sz){\n    if (isbnd(w, b, sz))\n        return;\n    int i;\n    for (i = 0 ; i < *n && ws[i].w && strcmp(ws[i].w, w) ; i++);\n    *n += i >= *n;\n    ws[i].w = w;\n    ws[i].n++;\n    *mx < ws[i].n ? *mw = w, *mx = ws[i].n : 0;\n}\n\nchar * mostCommonWord(char * paragraph, char ** banned, int bannedSize){\n    struct words m[100] = { { NULL } };\n    int i = 0, mx = -1;\n    char *mw = NULL, **b = banned, bsz = bannedSize, *p = paragraph, *pr = p - 1;\n    while (*++pr)\n        !isalpha(*pr) ? p ? *pr = 0, insw(m, &i, lwstr(p), &mw, &mx, b, bsz) : 0, p = NULL :\n        !p ? p = pr : 0;\n    return mw ? mw : lwstr(p);\n}\n", "\nstruct words { char *w, n; };\n\ninline char *lwstr(char *s){\n    for (char *p = s - 1 ; *++p ; *p = tolower(*p));\n    return s;\n}\n\ninline bool isbnd(char *w, char **banned, int sz){\n    int i;\n    for (i = 0 ; i < sz && strcmp(w, banned[i]) ; i++);\n    return i < sz;\n}\n\ninline void insw(struct words *ws, int *n, char *w, char **mw, int *mx, char **b, int sz){\n    if (isbnd(w, b, sz))\n        return;\n    int i;\n    for (i = 0 ; i < *n && ws[i].w && strcmp(ws[i].w, w) ; i++);\n    *n += i >= *n;\n    ws[i].w = w;\n    ws[i].n++;\n    *mx < ws[i].n ? *mw = w, *mx = ws[i].n : 0;\n}\n\nchar * mostCommonWord(char * paragraph, char ** banned, int bannedSize){\n    struct words m[100] = { { NULL } };\n    int i = 0, mx = -1;\n    char *mw = NULL, **b = banned, bsz = bannedSize, *p = paragraph, *pr = p - 1;\n    while (*++pr)\n        !isalpha(*pr) ? p ? *pr = 0, insw(m, &i, lwstr(p), &mw, &mx, b, bsz) : 0, p = NULL :\n        !p ? p = pr : 0;\n    return mw ? mw : lwstr(p);\n}\n", "\nstruct words { char *w, n; };\n\ninline char *lwstr(char *s){\n    for (char *p = s - 1 ; *++p ; *p = tolower(*p));\n    return s;\n}\n\ninline bool isbnd(char *w, char **banned, int sz){\n    int i;\n    for (i = 0 ; i < sz && strcmp(w, banned[i]) ; i++);\n    return i < sz;\n}\n\ninline void insw(struct words *ws, int *n, char *w, char **mw, int *mx, char **b, int sz){\n    if (isbnd(w, b, sz))\n        return;\n    int i;\n    for (i = 0 ; i < *n && ws[i].w && strcmp(ws[i].w, w) ; i++);\n    *n += i >= *n;\n    ws[i].w = w;\n    ws[i].n++;\n    *mx < ws[i].n ? *mw = w, *mx = ws[i].n : 0;\n}\n\nchar * mostCommonWord(char * paragraph, char ** banned, int bannedSize){\n    struct words m[100] = { { NULL } };\n    int i = 0, mx = -1;\n    char *mw = NULL, **b = banned, bsz = bannedSize, *p = paragraph, *pr = p - 1;\n    while (*++pr)\n        !isalpha(*pr) ? p ? *pr = 0, insw(m, &i, lwstr(p), &mw, &mx, b, bsz) : 0, p = NULL :\n        !p ? p = pr : 0;\n    return mw ? mw : lwstr(p);\n}\n"]}
{"id": "179", "ref_c": [["int* shortestToChar(char * s, char c, int* returnSize){\\nint *arr=(int*)malloc(strlen(s)*sizeof(int));\\n*returnSize=strlen(s);\\nint c1,c2;\\nfor(int i=0;i<strlen(s);i++)\\n{\\n    if(s[i]==c)\\n    {\\n        arr[i]=0;\\n    }"], ["int* shortestToChar(char * s, char c, int* returnSize){\\nint *arr=(int*)malloc(strlen(s)*sizeof(int));\\n*returnSize=strlen(s);\\nint c1,c2;\\nfor(int i=0;i<strlen(s);i++)\\n{\\n    if(s[i]==c)\\n    {\\n        arr[i]=0;\\n    }"], ["int* shortestToChar(char * s, char c, int* returnSize){\\n    int len=strlen(s);\\n\\nint *p=(int *)malloc(sizeof(int)*len);\\nint k=0;\\nint i=0;\\nwhile(i<len-1){\\n    if(*(s+i)==c){\\n        *(p+k)=0;\\n        k++;\\n        i++;\\n        continue;\\n    }"]]}
{"id": "180", "ref_c": [["char * toGoatLatin(char * sentence){\\n    \\n    char *counter = sentence;\\n    int word_nums = 0;\\n    int sentence_length = strlen(sentence);\\n    while( *sentence != \\'\\\\0\\')\\n    {\\n        if (*sentence == \\' \\')\\n        {\\n            word_nums++;    \\n        }"], ["char * toGoatLatin(char * sentence){\\n    \\n    char *counter = sentence;\\n    int word_nums = 0;\\n    int sentence_length = strlen(sentence);\\n    while( *sentence != \\'\\\\0\\')\\n    {\\n        if (*sentence == \\' \\')\\n        {\\n            word_nums++;    \\n        }"], ["char * toGoatLatin(char * sentence){\\n    \\n    int sLen = strlen(sentence);\\n    \\n    char *p = sentence;\\n    \\n    char ma_string[] = {\\'m\\', \\'a\\', \\'\\\\0\\'}"]]}
{"id": "181", "ref_c": [["int** largeGroupPositions(char * s, int* returnSize, int** returnColumnSizes){\\n    int ** result = (int **)malloc(340*sizeof(int *));\\n    char cDup = s[0];\\n    int idx = 0, start = 0, stop = 0, count = 0;\\n    for(int i=1; i<strlen(s); i++)\\n    {\\n        if(cDup == s[i])\\n        {\\n            stop = i;\\n            if(i == strlen(s)-1 && stop - start + 1 >= 3)\\n            {\\n                if(stop - start + 1 >= 3)\\n                {\\n                    result[idx] = (int *)malloc(2*sizeof(int));\\n                    result[idx][0] = start;\\n                    result[idx][1] = stop;\\n                    count++;\\n                }"], ["int** largeGroupPositions(char * s, int* returnSize, int** returnColumnSizes){\\n    /*\\n     * Input:\\n     *  s, string\\n     */\\n     \\n    /*\\n     * Algorithm:\\n     *  s = \"aabbbcccdddd\"\\n     *  (1) Scan every character, find out the start and end position of groups\\n     */\\n     \\n    int len = strlen(s);\\n    int **ans = (int **)malloc(sizeof(int *) * len);\\n    int start = 0, end = 0;\\n    char prev;\\n    \\n    *returnSize = 0;\\n    *returnColumnSizes = malloc(sizeof(int) * len);\\n\\n    /*\\n     * Dry run:\\n     *  (1) s = \"a\", prev = \\'a\\'\\n     *      process \\'a\\', prev = \\'a\\', start = 0, end = 1\\n     *      end - start = 1 < 3\\n     *      => ans = 0\\n     *  (2) s = \"abbbc\", prev = \\'a\\'\\n     *      process \\'a\\', prev = \\'a\\', start = 0, end = 1\\n     *      process \\'b\\', prev = \\'a\\', \\n     *          end - start = 1, do nothing, start = 1, end = 1\\n     *      process \\'b\\', prev = \\'b\\', do nothing, end = 2\\n     *      process \\'b\\', prev = \\'b\\', do nothing, end = 3\\n     *      process \\'c\\', prev = \\'b\\', start = 1, end = 4\\n     *          end - start = 3, store [1,4-1] = [1,3]\\n     *          start = 4, end = 5\\n     *      check last group, end - start = 1, do nothing\\n     */\\n\\n    prev = *s;\\n     \\n    while (*s) {\\n    \\n        if (*s != prev) {\\n            \\n            /* Store the start and end position of group */\\n            if (end - start >= 3) {\\n                ans[*returnSize] = (int *)malloc(sizeof(int) * 2);\\n                ans[*returnSize][0] = start;\\n                ans[*returnSize][1] = end - 1;\\n                (*returnColumnSizes)[*returnSize] = 2;\\n                (*returnSize)++;\\n            }"], ["int** largeGroupPositions(char * s, int* returnSize, int** returnColumnSizes){\\n\\n    int **arr = (int **) calloc((strlen(s)/3)+1, sizeof(int *));\\n    int idx = 0;\\n    int i=0, j=0,count=0;\\n    \\n    for(i=0;i<strlen(s)-1;)\\n    {\\n        count = 1;\\n        for(j=i+1;j<strlen(s);j++)\\n        {\\n            if(s[i] == s[j])\\n                count++;\\n            else\\n                break;\\n        }"]]}
{"id": "182", "ref_c": [["int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = imageSize;\\n    *returnColumnSizes = imageColSize;\\n    for(int i=0; i<imageSize; i++){\\n        for(int j=0; j<*imageColSize/2; j++){\\n            int temp = image[i][j];\\n            image[i][j] = image[i][*imageColSize-j-1];\\n            image[i][*imageColSize-j-1] = temp;\\n        }"], ["int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes) {\\n\\n  int **ret = (int **)malloc(sizeof(int *) * imageSize);\\n\\n  for (int i = 0; i < imageSize; i++) {\\n    ret[i] = (int *)malloc(sizeof(int)*imageSize);\\n  }"], ["int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = imageSize;\\n    *returnColumnSizes = imageColSize;\\n    int temp =0,i,j;\\n\\n    for( i = 0; i < imageSize; i++)\\n    {\\n        for(j = 0; j < *imageColSize / 2; j ++){\\n            temp = image[i][j];\\n            image[i][j] = image[i][*imageColSize - 1 - j];\\n            image[i][*imageColSize - 1 - j] = temp;\\n        }"]]}
{"id": "183", "ref_c": [["bool isRectangleOverlap(int* rec1, int rec1Size, int* rec2, int rec2Size){\\n    if((rec1[0] >= rec2[2]) || (rec1[2] <= rec2[0]) || (rec1[1] >= rec2[3]) || (rec1[3] <= rec2[1])) return false;\\n    return true;\\n}"], ["bool isRectangleOverlap(int* rec1, int rec1Size, int* rec2, int rec2Size){\\n    if((rec1[0] >= rec2[2]) || (rec1[2] <= rec2[0]) || (rec1[1] >= rec2[3]) || (rec1[3] <= rec2[1])) return false;\\n    return true;\\n}"], ["bool isRectangleOverlap(int* rec1, int rec1Size, int* rec2, int rec2Size){\\n    if((rec1[0] >= rec2[2]) || (rec1[2] <= rec2[0]) || (rec1[1] >= rec2[3]) || (rec1[3] <= rec2[1])) return false;\\n    return true;\\n}"]]}
{"id": "184", "ref_c": [["bool backspaceCompare(char * s, char * t){\\n    int nS=0, nT=0;\\n    register int i, j;\\n    for(i=strlen(s)-1, j=strlen(t)-1; i>=0||j>=0; i--, j--){\\n        while(i>=0){\\n            if (s[i]==\\'#\\') nS++, i--;\\n            else if (nS>0) nS--, i--;\\n            else break;\\n        }"], ["bool backspaceCompare(char * s, char * t){\\n    int len1 = strlen(s);\\n    int len2 = strlen(t);\\n    char arr1[200] = {0}"], ["bool backspaceCompare(char * s, char * t){\\n    int nS=0, nT=0;\\n    register int i, j;\\n    for(i=strlen(s)-1, j=strlen(t)-1; i>=0||j>=0; i--, j--){\\n        while(i>=0){\\n            if (s[i]==\\'#\\') nS++, i--;\\n            else if (nS>0) nS--, i--;\\n            else break;\\n        }"]]}
{"id": "185", "ref_c": [["bool buddyStrings(char * s, char * goal){\\n    int strS=strlen(s);\\n    if(strS!=strlen(goal))return false;\\n    int i,j;\\n    if(strcmp(s,goal)==0){\\n        for(i=0;i<strS-1;i++){\\n            for(j=i+1;j<strS;j++){\\n                if(s[i]==s[j])return true;\\n            }"], ["bool buddyStrings(char * s, char * goal){\\n    int strS=strlen(s);\\n    if(strS!=strlen(goal))return false;\\n    int i,j;\\n    if(strcmp(s,goal)==0){\\n        for(i=0;i<strS-1;i++){\\n            for(j=i+1;j<strS;j++){\\n                if(s[i]==s[j])return true;\\n            }"], ["bool buddyStrings(char * s, char * goal){\\n    int strS=strlen(s);\\n    if(strS!=strlen(goal))return false;\\n    int i,j;\\n    if(strcmp(s,goal)==0){\\n        for(i=0;i<strS-1;i++){\\n            for(j=i+1;j<strS;j++){\\n                if(s[i]==s[j])return true;\\n            }"]]}
{"id": "186", "ref_c": [["bool lemonadeChange(int* bills, int billsSize){\\n    int sum5 = 0;\\n    int sum10 = 0;\\nfor(int i=0;i<billsSize;){\\n    if(bills[i] == 5){\\n        sum5 += 1;\\n        i++;\\n    }"], ["bool lemonadeChange(int* bills, int billsSize){\\nint five=0, ten=0;\\nfor(int i=0; i<billsSize ; i++){\\n    if(bills[i]==5){\\n        five++;\\n    }"], ["bool lemonadeChange(int* bills, int billsSize){\\nint five=0, ten=0;\\nfor(int i=0; i<billsSize ; i++){\\n    if(bills[i]==5){\\n        five++;\\n    }"]]}
{"id": "187", "ref_c": [["int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes) {\\n    int row = matrixSize;        // Get the number of rows in the original matrix\\n    int col = *matrixColSize;    // Get the number of columns in the original matrix\\n\\n    // Create a new matrix to store the transposed elements\\n    int** ans = (int**)malloc(col * sizeof(int*)); // Allocate memory for rows\\n    *returnSize = col;  // Set returnSize to the number of columns in the transposed matrix\\n\\n    // Create and initialize the returnColumnSizes array\\n    *returnColumnSizes = (int*)malloc(col * sizeof(int));\\n    for (int i = 0; i < col; i++) {\\n        (*returnColumnSizes)[i] = row;  // Each column will have \\'row\\' elements\\n        ans[i] = (int*)malloc(row * sizeof(int)); // Allocate memory for each row\\n    }"], ["int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes) {\\n    int row = matrixSize;        // Get the number of rows in the original matrix\\n    int col = *matrixColSize;    // Get the number of columns in the original matrix\\n\\n    // Create a new matrix to store the transposed elements\\n    int** ans = (int**)malloc(col * sizeof(int*)); // Allocate memory for rows\\n    *returnSize = col;  // Set returnSize to the number of columns in the transposed matrix\\n\\n    // Create and initialize the returnColumnSizes array\\n    *returnColumnSizes = (int*)malloc(col * sizeof(int));\\n    for (int i = 0; i < col; i++) {\\n        (*returnColumnSizes)[i] = row;  // Each column will have \\'row\\' elements\\n        ans[i] = (int*)malloc(row * sizeof(int)); // Allocate memory for each row\\n    }"], ["int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes) {\\n    int row = matrixSize;        // Get the number of rows in the original matrix\\n    int col = *matrixColSize;    // Get the number of columns in the original matrix\\n\\n    // Create a new matrix to store the transposed elements\\n    int** ans = (int**)malloc(col * sizeof(int*)); // Allocate memory for rows\\n    *returnSize = col;  // Set returnSize to the number of columns in the transposed matrix\\n\\n    // Create and initialize the returnColumnSizes array\\n    *returnColumnSizes = (int*)malloc(col * sizeof(int));\\n    for (int i = 0; i < col; i++) {\\n        (*returnColumnSizes)[i] = row;  // Each column will have \\'row\\' elements\\n        ans[i] = (int*)malloc(row * sizeof(int)); // Allocate memory for each row\\n    }"]]}
{"id": "188", "ref_c": [["int binaryGap(int n) {\\n    \\n    int max = 0;\\n    int mask = 0;\\n    for(int i=0; i<sizeof(int)*8 -1 ; i++){\\n        mask |= 1<<i;\\n        if(n & (1<<i)){\\n            int tmp = 0;\\n            if( !(n & (~mask)) ){\\n                return max;\\n            }"], ["int binaryGap(int n){\\n    short maxCount = 0;\\n    int rightMostSetBit = n & -n;\\n    short prevPos = log2(rightMostSetBit);\\n    n &= n - 1;\\n    while (n) {\\n        int rightMostSetBit = n & -n;\\n        int pos = log2(rightMostSetBit);\\n        if (maxCount < pos - prevPos) {\\n            maxCount = pos - prevPos;\\n        }"], ["int binaryGap(int n){\\n    int max = 0 , cnt = 0, flag = 0;\\n    while ( n > 0){\\n        if ( ( n & 1) == 1 ){\\n            if ( flag == 1 ){\\n                if ( max < cnt){\\n                    max  = cnt;\\n                }"]]}
{"id": "189", "ref_c": [["bool leafSimilar(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    int arr1[200], arr2[200];\\n\\n    int top1 = -1, top2 = -1;\\n    \\n    search1(root1, arr1, &top1);\\n    \\n    search2(root2, arr2, &top2);\\n    \\n    if (top1 != top2) return false;\\n    \\n    for (int i = 0; i <= top1; i++) {\\n        if (arr1[i] != arr2[i])\\n            return false;\\n    }"], ["bool leafSimilar(struct TreeNode* root1, struct TreeNode* root2) {\\n    int *arr1=(int *)malloc(sizeof(int)*200);\\n    int *arr2=(int *)malloc(sizeof(int)*200);\\n    int l1=0,l2=0;\\n    leaf(root1,arr1,&l1);\\n    leaf(root2,arr2,&l2);\\n    if(l1!=l2)\\n    return false;\\n    else\\n    {\\n        for(int i=0;i<=l1;i++)\\n        {\\n            if(arr1[i]!=arr2[i])\\n            return false;\\n        }"], ["bool leafSimilar(struct TreeNode* root1, struct TreeNode* root2){\\n\\n    SEQUENCE* tree1_seq = createSEQUENCE();\\n    SEQUENCE* tree2_seq = createSEQUENCE();\\n\\n    getLeafSequence(root1, tree1_seq);\\n    getLeafSequence(root2, tree2_seq);\\n\\n    if(tree1_seq->idx != tree2_seq->idx){\\n        deleteSequence(tree1_seq);\\n        deleteSequence(tree2_seq);\\n        return false;\\n    }"]]}
{"id": "190", "ref_c": [["struct ListNode* middleNode(struct ListNode* head){\\n    // Initialize two pointers p1 and p2 pointing to the head...\\n    struct ListNode* p1 = head;\\n    struct ListNode* p2 = head;\\n    // Base case...\\n    if(head == NULL) return NULL;\\n    else {\\n        while(p2 != NULL && p2->next != NULL) {\\n            // In each iteration, we move p1 one node forward and we move p2 two nodes forward...\\n            p2 = p2->next->next;\\n            p1 = p1->next;\\n        }"], ["struct ListNode* middleNode(struct ListNode* head) {\\n    struct ListNode* first_ptr = head;\\n    struct ListNode* second_ptr = head;\\n    while(first_ptr != NULL && first_ptr -> next != NULL){\\n        second_ptr = second_ptr -> next;\\n        first_ptr = first_ptr -> next -> next;\\n    }"], ["struct ListNode* middleNode(struct ListNode* head){\\n        struct ListNode *slow, *fast, *new_head;\\n        slow  = fast = head;\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }"]]}
{"id": "191", "ref_c": [["int projectionArea(int** grid, int gridSize, int* gridColSize){\\n    int sum=0;\\n    // find x-y plane, y-z plane , x-z plane\\n    for(int row=0;row<gridSize;row++){\\n        int x_z_plane=0,y_z_plane=0;\\n        for(int col=0;col<*gridColSize;col++){\\n            x_z_plane=max(x_z_plane,grid[row][col]);\\n            y_z_plane=max(y_z_plane,grid[col][row]);\\n            if(grid[row][col]) ++sum; // x-y plane\\n        }"], ["int projectionArea(int** grid, int gridSize, int* gridColSize) {\\n    int numsOfXY = gridSize * gridColSize[0];\\n    int numsOfXZ = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        int max = grid[i][0];\\n        for (int j = 0; j < gridColSize[0]; j++) {\\n            max = MAX(max, grid[i][j]);\\n            if (!grid[i][j]) numsOfXY--;\\n        }"], ["int projectionArea(int** grid, int gridSize, int* gridColSize){\\n    int sum = 0, maxInCol = 0, maxInRow = 0;\\n    for(int i=0; i<gridSize; i++)\\n    {\\n        for(int j=0; j<*gridColSize; j++)\\n        {\\n            if(grid[i][j] != 0)\\n                sum += 1;\\n            maxInCol = maxInCol < grid[i][j] ? grid[i][j] : maxInCol;\\n        }"]]}
{"id": "192", "ref_c": [["char ** uncommonFromSentences(char * s1, char * s2, int* returnSize){\\n    WordHash* h = NULL;\\n    WordHash* m = NULL;\\n    char* s;\\n    int len = 0, startIdx = 0, idx = 0, cnt = 0;\\n    for(int i = 0; i < 2; i++)\\n    {\\n        s = (i == 0)?s1 : s2;\\n        len = strlen(s);\\n        startIdx = 0; \\n        idx = 0;\\n        do\\n        {\\n            if(s[idx] == \\' \\' || idx == (len - 1)){\\n                cnt = idx - startIdx;\\n                if(idx == (len - 1)) cnt++;\\n                char* c = (char*)calloc(cnt+1, sizeof(char));\\n                strncpy(c, &s[startIdx], cnt);\\n                c[cnt] = \\'\\\\0\\';\\n                HASH_FIND_STR(h, c, m);\\n                if(!m){\\n                    m = (WordHash*)calloc(1, sizeof(WordHash));\\n                    strncpy(m->string, c, cnt);\\n                    HASH_ADD_STR(h, string, m);\\n                }"], ["char ** uncommonFromSentences(char * s1, char * s2, int* returnSize){\\n    WordHash* h = NULL;\\n    WordHash* m = NULL;\\n    char* s;\\n    int len = 0, startIdx = 0, idx = 0, cnt = 0;\\n    for(int i = 0; i < 2; i++)\\n    {\\n        s = (i == 0)?s1 : s2;\\n        len = strlen(s);\\n        startIdx = 0; \\n        idx = 0;\\n        do\\n        {\\n            if(s[idx] == \\' \\' || idx == (len - 1)){\\n                cnt = idx - startIdx;\\n                if(idx == (len - 1)) cnt++;\\n                char* c = (char*)calloc(cnt+1, sizeof(char));\\n                strncpy(c, &s[startIdx], cnt);\\n                c[cnt] = \\'\\\\0\\';\\n                HASH_FIND_STR(h, c, m);\\n                if(!m){\\n                    m = (WordHash*)calloc(1, sizeof(WordHash));\\n                    strncpy(m->string, c, cnt);\\n                    HASH_ADD_STR(h, string, m);\\n                }"], ["char ** uncommonFromSentences(char * s1, char * s2, int* returnSize){\\n    WordHash* h = NULL;\\n    WordHash* m = NULL;\\n    char* s;\\n    int len = 0, startIdx = 0, idx = 0, cnt = 0;\\n    for(int i = 0; i < 2; i++)\\n    {\\n        s = (i == 0)?s1 : s2;\\n        len = strlen(s);\\n        startIdx = 0; \\n        idx = 0;\\n        do\\n        {\\n            if(s[idx] == \\' \\' || idx == (len - 1)){\\n                cnt = idx - startIdx;\\n                if(idx == (len - 1)) cnt++;\\n                char* c = (char*)calloc(cnt+1, sizeof(char));\\n                strncpy(c, &s[startIdx], cnt);\\n                c[cnt] = \\'\\\\0\\';\\n                HASH_FIND_STR(h, c, m);\\n                if(!m){\\n                    m = (WordHash*)calloc(1, sizeof(WordHash));\\n                    strncpy(m->string, c, cnt);\\n                    HASH_ADD_STR(h, string, m);\\n                }"]]}
{"id": "193", "ref_c": [["int* fairCandySwap(int* aliceSizes, int aliceSizesSize, int* bobSizes, int bobSizesSize, int* returnSize){\\n    int a1 = 0, b1 = 0;\\n    int*p=(int*)malloc(2*sizeof(int));\\n    * returnSize=2;\\n    for(int i = 0; i < aliceSizesSize; i++){\\n        a1 = a1 + aliceSizes[i] ;\\n    }"], ["int* fairCandySwap(int* aliceSizes, int aliceSizesSize, int* bobSizes, int bobSizesSize, int* returnSize){\\n    int*p=(int*)malloc(2*sizeof(int));\\n    int asum=0,bsum=0;\\n    * returnSize=2;\\n\\n    for(int i=0;i<aliceSizesSize;i++)\\n        asum+=aliceSizes[i];\\n    for(int i=0;i<bobSizesSize;i++)\\n        bsum+=bobSizes[i];\\n    \\n    for(int i=0;i<aliceSizesSize;i++){\\n        for(int j=0;j<bobSizesSize;j++){\\n            if((asum-aliceSizes[i]+bobSizes[j])==(bsum-bobSizes[j]+aliceSizes[i])){\\n                p[0]=aliceSizes[i];\\n                p[1]=bobSizes[j];\\n                return p;}"], ["int* fairCandySwap(int* aliceSizes, int aliceSizesSize, int* bobSizes, int bobSizesSize, int* returnSize) {\\n    int* arr1 = (int*) calloc(100001, sizeof(int));\\n    int* arr2 = (int*) calloc(100001, sizeof(int));\\n    int sumOfalice = sum(aliceSizes, aliceSizesSize, arr1), sumOfbobs = sum(bobSizes, bobSizesSize, arr2);\\n    int tar = (sumOfalice + sumOfbobs) / 2;\\n    int* res = (int*) malloc(2 * sizeof(int));\\n    if (aliceSizesSize > bobSizesSize) {\\n        for (int i = 0; i < aliceSizesSize; i++) {\\n            res[0] = aliceSizes[i];\\n            int tmp = tar - (sumOfalice - res[0]);\\n            if (tmp > 0 && tmp < 100001 && arr2[tmp] != 0) {\\n                res[1] = tmp;\\n                break;\\n            }"]]}
{"id": "194", "ref_c": [["int surfaceArea(int** grid, int gridSize, int* gridColSize){\\n    int area = 0;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] !=0)\\n                area += grid[i][j]*4 + 2; //Full surface\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize-1; j++)\\n        {\\n            if(grid[i][j] != 0 && grid[i][j+1] != 0)\\n                area -= grid[i][j] < grid[i][j+1] ? 2*grid[i][j] : 2*grid[i][j+1]; //reduce common surface in row\\n        }"], ["int surfaceArea(int** grid, int gridSize, int* gridColSize)\\n{\\n    int totalArea = 0, currentArea;\\n\\n    // Neighbouring areas\\n    int areaLeft, areaRight, areaUp, areaDown;\\n\\n    // Neighbouring cubes\\n    int cubeLeft, cubeRight, cubeUp, cubeDown;\\n\\n\\n    for(int i = 0; i < gridSize; i++)\\n    {\\n        for(int j = 0; j < gridColSize[i]; j++)\\n        {\\n            if(grid[i][j] == 0) continue;\\n            \\n            areaLeft = (j - 1 < 0) ? 0 : CUBE_AREA(grid[i][j - 1]);\\n            cubeLeft = (j - 1 < 0) ? 0 : grid[i][j - 1];\\n            areaRight = (j + 1 < gridColSize[i]) ? CUBE_AREA(grid[i][j + 1]) : 0;\\n            cubeRight = (j + 1 < gridColSize[i]) ? grid[i][j + 1] : 0;\\n            areaUp = (i - 1 < 0) ? 0 : CUBE_AREA(grid[i - 1][j]);\\n            cubeUp = (i - 1 < 0) ? 0 : grid[i - 1][j];\\n            areaDown = (i + 1 < gridSize) ? CUBE_AREA(grid[i + 1][j]) : 0;\\n            cubeDown = (i + 1 < gridSize) ? grid[i + 1][j] : 0;\\n\\n            currentArea = CUBE_AREA(grid[i][j]);\\n            totalArea += CUBE_AREA(grid[i][j]);\\n\\n            totalArea -= (currentArea > areaLeft ? cubeLeft : grid[i][j])\\n                             + (currentArea > areaRight ? cubeRight : grid[i][j]) \\n                             + (currentArea > areaUp ? cubeUp : grid[i][j]) \\n                             + (currentArea > areaDown ? cubeDown : grid[i][j]);\\n\\n        }"], ["int surfaceArea(int** grid, int gridSize, int* gridColSize)\\n{\\n    int totalArea = 0, currentArea;\\n\\n    // Neighbouring areas\\n    int areaLeft, areaRight, areaUp, areaDown;\\n\\n    // Neighbouring cubes\\n    int cubeLeft, cubeRight, cubeUp, cubeDown;\\n\\n\\n    for(int i = 0; i < gridSize; i++)\\n    {\\n        for(int j = 0; j < gridColSize[i]; j++)\\n        {\\n            if(grid[i][j] == 0) continue;\\n            \\n            areaLeft = (j - 1 < 0) ? 0 : CUBE_AREA(grid[i][j - 1]);\\n            cubeLeft = (j - 1 < 0) ? 0 : grid[i][j - 1];\\n            areaRight = (j + 1 < gridColSize[i]) ? CUBE_AREA(grid[i][j + 1]) : 0;\\n            cubeRight = (j + 1 < gridColSize[i]) ? grid[i][j + 1] : 0;\\n            areaUp = (i - 1 < 0) ? 0 : CUBE_AREA(grid[i - 1][j]);\\n            cubeUp = (i - 1 < 0) ? 0 : grid[i - 1][j];\\n            areaDown = (i + 1 < gridSize) ? CUBE_AREA(grid[i + 1][j]) : 0;\\n            cubeDown = (i + 1 < gridSize) ? grid[i + 1][j] : 0;\\n\\n            currentArea = CUBE_AREA(grid[i][j]);\\n            totalArea += CUBE_AREA(grid[i][j]);\\n\\n            totalArea -= (currentArea > areaLeft ? cubeLeft : grid[i][j])\\n                             + (currentArea > areaRight ? cubeRight : grid[i][j]) \\n                             + (currentArea > areaUp ? cubeUp : grid[i][j]) \\n                             + (currentArea > areaDown ? cubeDown : grid[i][j]);\\n\\n        }"]]}
{"id": "195", "ref_c": [["bool isMonotonic(int* nums, int numsSize) {\\n    // Initialize two boolean flags to track if the sequence is increasing or decreasing.\\n    bool inc = false;  // Flag for increasing\\n    bool dec = false;  // Flag for decreasing\\n\\n    // Iterate through the array starting from the second element.\\n    for (int i = 1; i < numsSize; i++) {\\n        // If the current element is equal to the previous one, continue to the next element.\\n        if (nums[i] == nums[i - 1]) {\\n            continue;\\n        }"], ["bool isMonotonic(int* nums, int numsSize) {\\n    bool increasing = true;\\n    bool decreasing = true;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        }"], ["bool isMonotonic(int* nums, int numsSize) {\\n    // Initialize two boolean flags to track if the sequence is increasing or decreasing.\\n    bool inc = false;  // Flag for increasing\\n    bool dec = false;  // Flag for decreasing\\n\\n    // Iterate through the array starting from the second element.\\n    for (int i = 1; i < numsSize; i++) {\\n        // If the current element is equal to the previous one, continue to the next element.\\n        if (nums[i] == nums[i - 1]) {\\n            continue;\\n        }"]]}
{"id": "196", "ref_c": [["struct TreeNode* increasingBST(struct TreeNode* root) {\\n    if(root==NULL) return NULL;\\n    struct TreeNode* head=NULL;\\n    struct TreeNode* p=root;\\n    dfs(root,&head,&p);\\n    p->left=NULL;\\n    return head;\\n}"], ["struct TreeNode* increasingBST(struct TreeNode* root) {\\n    if(root==NULL) return NULL;\\n    struct TreeNode* head=NULL;\\n    struct TreeNode* p=root;\\n    dfs(root,&head,&p);\\n    p->left=NULL;\\n    return head;\\n}"], ["struct TreeNode* increasingBST(struct TreeNode* root) {\\n    return increasingBSTHelper(root, NULL);\\n}"]]}
{"id": "197", "ref_c": [["int* sortArrayByParity(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(numsSize * sizeof(int));\\n    int evenIndex = 0;\\n    int oddIndex = numsSize - 1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] % 2 == 0) {\\n            result[evenIndex] = nums[i];\\n            evenIndex++;\\n        }"], ["int* sortArrayByParity(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(numsSize * sizeof(int));\\n    int evenIndex = 0;\\n    int oddIndex = numsSize - 1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] % 2 == 0) {\\n            result[evenIndex] = nums[i];\\n            evenIndex++;\\n        }"], ["int* sortArrayByParity(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(numsSize * sizeof(int));\\n    int evenIndex = 0;\\n    int oddIndex = numsSize - 1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] % 2 == 0) {\\n            result[evenIndex] = nums[i];\\n            evenIndex++;\\n        }"]]}
{"id": "198", "ref_c": [["int smallestRangeI(int* nums, int numsSize, int k)\\n{\\n    int max = INT_MIN;\\n    int min = INT_MAX;\\n    int ret = 0;\\n    int i=0;\\n    for(i=0; i<numsSize; i++)\\n    {\\n        if(nums[i] <= min)\\n        {\\n            min = nums[i];\\n        }"], ["int smallestRangeI(int* nums, int numsSize, int k) {\\n    int min = nums[0], max = nums[0];\\n    for (int i = 1; i < numsSize; i++) {\\n        min = MIN(min, nums[i]);\\n        max = MAX(max, nums[i]);\\n    }"], ["int smallestRangeI(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    if((nums[numsSize-1] - nums[0]) > 2*k){ return (nums[numsSize-1] - nums[0] - 2*k); }", "int smallestRangeI(int* nums, int numsSize, int k){\\n    int minValue = INT_MAX, maxValue = INT_MIN;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        minValue = MIN(minValue, nums[i]);\\n        maxValue = MAX(maxValue, nums[i]);\\n    }"]]}
{"id": "199", "ref_c": [["bool hasGroupsSizeX(int* deck, int deckSize){\\n    int* freq = (int*) calloc(10000, sizeof(int)); \\n\\n    for(int i=0; i<deckSize; i++){\\n        freq[deck[i]]++; \\n    }"], ["bool hasGroupsSizeX(int* deck, int deckSize){\\n    int* freq = (int*) calloc(10000, sizeof(int)); \\n\\n    for(int i=0; i<deckSize; i++){\\n        freq[deck[i]]++; \\n    }"], ["bool hasGroupsSizeX(int* deck, int deckSize){\\n    int* freq = (int*) calloc(10000, sizeof(int)); \\n\\n    for(int i=0; i<deckSize; i++){\\n        freq[deck[i]]++; \\n    }"]]}
{"id": "200", "ref_c": ["\nchar * reverseOnlyLetters(char * s) {\n\n\tregister unsigned char j = strlen(s) - 1;\n\tchar res[101] = \"\";\n\n\tstrcpy(res, s);\n\n\tregister unsigned char i = 0, temp;\n\twhile(i < j) {\n\t\tif(isalpha(s[i]) && isalpha(s[j])) {\n\t\t\ttemp = s[i];\n\t\t\tres[i] = s[j];\n\t\t\tres[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t} else if(!isalpha(s[i]) && !isalpha(s[j])) {\n\t\t\ti++;\n\t\t\tj--;\n\t\t} else if(isalpha(s[i]) && !isalpha(s[j])) {\n\t\t\tj--;\n\t\t} else if(!isalpha(s[i]) && isalpha(s[j])) {\n\t\t\ti++;\n\t\t}\n\t}\n\n\tstrcpy(s, res);\n\n\treturn s;\n}\n", "\nchar * reverseOnlyLetters(char * s) {\n\n\tregister unsigned char j = strlen(s) - 1;\n\tchar res[101] = \"\";\n\n\tstrcpy(res, s);\n\n\tregister unsigned char i = 0, temp;\n\twhile(i < j) {\n\t\tif(isalpha(s[i]) && isalpha(s[j])) {\n\t\t\ttemp = s[i];\n\t\t\tres[i] = s[j];\n\t\t\tres[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t} else if(!isalpha(s[i]) && !isalpha(s[j])) {\n\t\t\ti++;\n\t\t\tj--;\n\t\t} else if(isalpha(s[i]) && !isalpha(s[j])) {\n\t\t\tj--;\n\t\t} else if(!isalpha(s[i]) && isalpha(s[j])) {\n\t\t\ti++;\n\t\t}\n\t}\n\n\tstrcpy(s, res);\n\n\treturn s;\n}\n", "\nchar * reverseOnlyLetters(char * s) {\n\n\tregister unsigned char j = strlen(s) - 1;\n\tchar res[101] = \"\";\n\n\tstrcpy(res, s);\n\n\tregister unsigned char i = 0, temp;\n\twhile(i < j) {\n\t\tif(isalpha(s[i]) && isalpha(s[j])) {\n\t\t\ttemp = s[i];\n\t\t\tres[i] = s[j];\n\t\t\tres[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t} else if(!isalpha(s[i]) && !isalpha(s[j])) {\n\t\t\ti++;\n\t\t\tj--;\n\t\t} else if(isalpha(s[i]) && !isalpha(s[j])) {\n\t\t\tj--;\n\t\t} else if(!isalpha(s[i]) && isalpha(s[j])) {\n\t\t\ti++;\n\t\t}\n\t}\n\n\tstrcpy(s, res);\n\n\treturn s;\n}\n"]}
{"id": "201", "ref_c": [["int* sortArrayByParityII(int* nums, int numsSize, int* returnSize) \\n{\\n    *returnSize = numsSize;\\n    int i = 0, j = numsSize - 1, k = numsSize - 1;\\n    while(i < j || i < k)\\n    {\\n        if((i % 2 == 0 && nums[i] % 2 == 0) || (i % 2 != 0 && nums[i] % 2 != 0))\\n        {\\n            i++;\\n        }"], ["int* sortArrayByParityII(int* nums, int numsSize, int* returnSize) \\n{\\n    *returnSize = numsSize;\\n    int i = 0, j = numsSize - 1, k = numsSize - 1;\\n    while(i < j || i < k)\\n    {\\n        if((i % 2 == 0 && nums[i] % 2 == 0) || (i % 2 != 0 && nums[i] % 2 != 0))\\n        {\\n            i++;\\n        }"], ["int* sortArrayByParityII(int* nums, int numsSize, int* returnSize) \\n{\\n    *returnSize = numsSize;\\n    int i = 0, j = numsSize - 1, k = numsSize - 1;\\n    while(i < j || i < k)\\n    {\\n        if((i % 2 == 0 && nums[i] % 2 == 0) || (i % 2 != 0 && nums[i] % 2 != 0))\\n        {\\n            i++;\\n        }"]]}
{"id": "202", "ref_c": [["bool isLongPressedName(char * name, char * typed) {\\n\\n\\tif(strlen(name) > strlen(typed))\\n\\t\\treturn false;\\n\\n\\tif(strcmp(name, typed) == 0)\\n\\t\\treturn true;\\n\\n\\tregister unsigned short i = 0, j = 0;\\n\\tchar prev = \\'\\\\0\\';\\n\\twhile(name[i] != \\'\\\\0\\') {\\n\\t\\tif(name[i] == typed[j]) {\\n\\t\\t\\tprev = name[i];\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}"], ["bool isLongPressedName(char * name, char * typed) {\\n\\n\\tif(strlen(name) > strlen(typed))\\n\\t\\treturn false;\\n\\n\\tif(strcmp(name, typed) == 0)\\n\\t\\treturn true;\\n\\n\\tregister unsigned short i = 0, j = 0;\\n\\tchar prev = \\'\\\\0\\';\\n\\twhile(name[i] != \\'\\\\0\\') {\\n\\t\\tif(name[i] == typed[j]) {\\n\\t\\t\\tprev = name[i];\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}"], ["bool isLongPressedName(char * name, char * typed) {\\n\\n\\tif(strlen(name) > strlen(typed))\\n\\t\\treturn false;\\n\\n\\tif(strcmp(name, typed) == 0)\\n\\t\\treturn true;\\n\\n\\tregister unsigned short i = 0, j = 0;\\n\\tchar prev = \\'\\\\0\\';\\n\\twhile(name[i] != \\'\\\\0\\') {\\n\\t\\tif(name[i] == typed[j]) {\\n\\t\\t\\tprev = name[i];\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}"]]}
{"id": "203", "ref_c": [["int numUniqueEmails(char ** emails, int emailsSize)\\n{\\n    int result = 0;\\n    char cleanEmail[emailsSize][100];\\n    int clean=0;\\n    \\n    for(int i = 0; i < emailsSize; i++)\\n    {\\n        int index = 0; clean=0;\\n        while(emails[i][index] != \\'+\\' && emails[i][index] != \\'@\\')\\n        {\\n            if(emails[i][index] == \\'.\\')\\n                    index++;\\n            else\\n                {\\n                    cleanEmail[i][clean]=emails[i][index];\\n                    clean++;\\n                    index++;  \\n                }"], ["int numUniqueEmails(char ** emails, int emailsSize){\\n\\n    /*\\n     * Input:\\n     *  emails,\\n     *  emailsSize\\n     */\\n    node_t head = {0}"], ["int numUniqueEmails(char ** emails, int emailsSize){\\n\\n    /*\\n     * Input:\\n     *  emails,\\n     *  emailsSize\\n     */\\n    node_t head = {0}"]]}
{"id": "205", "ref_c": [["int rangeSumBST(struct TreeNode* root, int low, int high) {\\n    if (root == NULL) {\\n                return 0;\\n                    }"], ["int rangeSumBST(struct TreeNode* root, int low, int high) {\\n    int sum=0;\\n    if(root == NULL)\\n        return 0;\\n    if(root->val >= low && root->val <= high)\\n        sum+=root->val;\\n     if(root->val > low)\\n        sum+= rangeSumBST(root->left,low,high);\\n     if(root->val < high)\\n        sum+= rangeSumBST(root->right,low,high);\\n    return sum;\\n}"], ["int rangeSumBST(struct TreeNode* root, int low, int high){\\n    if(root==NULL){\\n        return 0;\\n    }"]]}
{"id": "206", "ref_c": [["bool validMountainArray(int* arr, int arrSize)\\n{\\n    if(arrSize < 3)\\n    {\\n        return false;\\n    }"], ["bool validMountainArray(int* arr, int arrSize){\\n    if (arrSize < 3) {return 0;}"], ["bool validMountainArray(int* arr, int arrSize){\\n    if (arrSize < 3) {return 0;}"]]}
{"id": "207", "ref_c": [["int* diStringMatch(char * s, int* returnSize)\\n{\\n\\n    int StrLen = strlen( s ) ;\\n\\n    int * permuArray = (int *) calloc( StrLen + 1, sizeof( int ) ) ;\\n    *returnSize = StrLen + 1 ;\\n\\n    int I = 0 ;\\n    int D = StrLen ;\\n\\n    int i = 0 ;\\n\\n    for( i = 0; i < StrLen; i++ )\\n    {\\n        \\n        if( s[i] == \\'D\\' )\\n        {\\n            permuArray[i] = D-- ;\\n        }"], ["int* diStringMatch(char * s, int* returnSize)\\n{\\n\\n    int StrLen = strlen( s ) ;\\n\\n    int * permuArray = (int *) calloc( StrLen + 1, sizeof( int ) ) ;\\n    *returnSize = StrLen + 1 ;\\n\\n    int I = 0 ;\\n    int D = StrLen ;\\n\\n    int i = 0 ;\\n\\n    for( i = 0; i < StrLen; i++ )\\n    {\\n        \\n        if( s[i] == \\'D\\' )\\n        {\\n            permuArray[i] = D-- ;\\n        }"], ["int* diStringMatch(char * s, int* returnSize)\\n{\\n\\n    int StrLen = strlen( s ) ;\\n\\n    int * permuArray = (int *) calloc( StrLen + 1, sizeof( int ) ) ;\\n    *returnSize = StrLen + 1 ;\\n\\n    int I = 0 ;\\n    int D = StrLen ;\\n\\n    int i = 0 ;\\n\\n    for( i = 0; i < StrLen; i++ )\\n    {\\n        \\n        if( s[i] == \\'D\\' )\\n        {\\n            permuArray[i] = D-- ;\\n        }"]]}
{"id": "208", "ref_c": [["int minDeletionSize(char ** strs, int strsSize){\\n    int remove = 0;\\n    for(int i=0 ; i<strlen(strs[0]);++i)\\n        for(int j=0;j<strsSize-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }"], ["int minDeletionSize(char ** strs, int strsSize){\\n    int remove = 0;\\n    for(int i=0 ; i<strlen(strs[0]);++i)\\n        for(int j=0;j<strsSize-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }"], ["int minDeletionSize(char ** strs, int strsSize){\\n    int remove = 0;\\n    for(int i=0 ; i<strlen(strs[0]);++i)\\n        for(int j=0;j<strsSize-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }"]]}
{"id": "209", "ref_c": [["bool isAlienSorted(char ** words, int wordsSize, char * order)\\n{\\n    int map[26];\\n    for(int i = 0; order[i] != \\'\\\\0\\'; i++)\\n        map[order[i] - \\'a\\'] = i;\\n\\n    for(int i = 1; i < wordsSize; i++)\\n    {\\n        for(int j = 0; words[i - 1][j] != \\'\\\\0\\'; j++)\\n        {\\n            char c1 = words[i - 1][j];\\n            char c2 = words[i][j];\\n            if(c2 == \\'\\\\0\\') return false; //previous word is longer\\n            if(c1 != c2)\\n            {   //if previous word\\'s char is greater, return false\\n                if(map[c1 - \\'a\\'] > map[c2 - \\'a\\']) return false;\\n                else break;//otherwise, continue to next set of words\\n            }"], ["bool isAlienSorted(char ** words, int wordsSize, char * order){\\n    int i;\\n    bool sortFlag;\\n    char * alphabet = translateAlphabet(order);\\n    for (i = 0; i < wordsSize; ++i) {\\n        translateWord(words[i],alphabet);\\n    }"], ["bool isAlienSorted(char ** words, int wordsSize, char * order){\\n    int i;\\n    bool sortFlag;\\n    char * alphabet = translateAlphabet(order);\\n    for (i = 0; i < wordsSize; ++i) {\\n        translateWord(words[i],alphabet);\\n    }"]]}
{"id": "210", "ref_c": [["int repeatedNTimes(int* nums, int numsSize)\\n{\\n    int n=0;\\n    for(int i=0;i<numsSize-1;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            {\\n                n=nums[i];\\n                break;\\n            }"], ["int repeatedNTimes(int* nums, int numsSize)\\n{\\n    int n=0;\\n    for(int i=0;i<numsSize-1;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            {\\n                n=nums[i];\\n                break;\\n            }"], ["int repeatedNTimes(int* nums, int numsSize)\\n{\\n    int n=0;\\n    for(int i=0;i<numsSize-1;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            {\\n                n=nums[i];\\n                break;\\n            }"]]}
{"id": "211", "ref_c": [["bool isUnivalTree(struct TreeNode* root) {\\n    printf(\"%d\", root->val);\\n    return isUniValue(root, root->val);\\n}"], ["bool isUnivalTree(struct TreeNode* root) \\n{\\n  if(root->left == NULL && root->right == NULL)\\n  {\\n    return true;\\n  }"], ["bool isUnivalTree(struct TreeNode* root) {\\n    return check(root,root->val);\\n}"]]}
{"id": "212", "ref_c": [["int largestPerimeter(int* nums, int numsSize) \\n{\\n  qsort(nums, numsSize, sizeof(int), compare);\\n  int largest_perimeter = 0;\\n  for(int i = 2; i < numsSize; i++)\\n  {\\n    bool isTriangle = (nums[i - 2] + nums[i - 1] > nums[i]) &&\\n                      (nums[i - 2] + nums[i] > nums[i - 1]) && \\n                      (nums[i - 1] + nums[i] > nums[i - 2]);\\n    int perimeter = nums[i - 2] + nums[i - 1] + nums[i];                  \\n    if(isTriangle && largest_perimeter < perimeter)\\n    {\\n      largest_perimeter = perimeter;  \\n    }"], ["int largestPerimeter(int* nums, int numsSize) \\n{\\n  qsort(nums, numsSize, sizeof(int), compare);\\n  int largest_perimeter = 0;\\n  for(int i = 2; i < numsSize; i++)\\n  {\\n    bool isTriangle = (nums[i - 2] + nums[i - 1] > nums[i]) &&\\n                      (nums[i - 2] + nums[i] > nums[i - 1]) && \\n                      (nums[i - 1] + nums[i] > nums[i - 2]);\\n    int perimeter = nums[i - 2] + nums[i - 1] + nums[i];                  \\n    if(isTriangle && largest_perimeter < perimeter)\\n    {\\n      largest_perimeter = perimeter;  \\n    }"], ["int largestPerimeter(int* nums, int numsSize) \\n{\\n  qsort(nums, numsSize, sizeof(int), compare);\\n  int largest_perimeter = 0;\\n  for(int i = 2; i < numsSize; i++)\\n  {\\n    bool isTriangle = (nums[i - 2] + nums[i - 1] > nums[i]) &&\\n                      (nums[i - 2] + nums[i] > nums[i - 1]) && \\n                      (nums[i - 1] + nums[i] > nums[i - 2]);\\n    int perimeter = nums[i - 2] + nums[i - 1] + nums[i];                  \\n    if(isTriangle && largest_perimeter < perimeter)\\n    {\\n      largest_perimeter = perimeter;  \\n    }"]]}
{"id": "213", "ref_c": [["int* sortedSquares(int* nums, int numsSize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(nums[0]) * numsSize);\\n    int start = 0;\\n    int end = numsSize - 1;\\n    for (int i = numsSize - 1; start <= end; i--) {\\n        int a = nums[start] * nums[start];\\n        int b = nums[end] * nums[end];\\n        if (a > b) {\\n            res[i] = a;\\n            start++;\\n        }"], ["int* sortedSquares(int* nums, int numsSize, int* returnSize){\\n\\n    *returnSize = numsSize;\\n\\n    for (int i=0; i<numsSize; i++) {\\n        nums[i] = nums[i]*nums[i];\\n    }"], ["int* sortedSquares(int* nums, int numsSize, int* returnSize) {\\n    int *returnedArray = (int*)(malloc(numsSize * sizeof(int)));\\n    *returnSize = numsSize;\\n    int index = -1;\\n    int lowest = 999999;\\n    for (int i = 0; i <numsSize; i += 1) {\\n        if (nums[i] < 0) {\\n            nums[i] *= - 1;\\n        }"]]}
{"id": "214", "ref_c": [["int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\\n    int car = 0; int* returnNum;\\n    *returnSize = numSize;\\n    \\n    for (int i = numSize - 1; i > -1; i--)\\n    {\\n        num[i] += ((k % 10) + car);\\n        k /= 10;\\n        \\n        if (num[i] > 9)\\n        {\\n            car = 1;\\n            num[i] %= 10;\\n        }"], ["int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\\n    int car = 0; int* returnNum;\\n    *returnSize = numSize;\\n    \\n    for (int i = numSize - 1; i > -1; i--)\\n    {\\n        num[i] += ((k % 10) + car);\\n        k /= 10;\\n        \\n        if (num[i] > 9)\\n        {\\n            car = 1;\\n            num[i] %= 10;\\n        }"], ["int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\\n    int car = 0; int* returnNum;\\n    *returnSize = numSize;\\n    \\n    for (int i = numSize - 1; i > -1; i--)\\n    {\\n        num[i] += ((k % 10) + car);\\n        k /= 10;\\n        \\n        if (num[i] > 9)\\n        {\\n            car = 1;\\n            num[i] %= 10;\\n        }"]]}
{"id": "215", "ref_c": [["bool isCousins(struct TreeNode* root, int x, int y) \\n{\\n   int x_depth = getDepth(root, x);\\n   int y_depth = getDepth(root, y);\\n   struct TreeNode *x_parent = getParent(root, x);\\n   struct TreeNode *y_parent = getParent(root, y);\\n   return x_parent != y_parent && x_depth == y_depth;     \\n}"], ["bool isCousins(struct TreeNode* root, int x, int y) \\n{\\n   int x_depth = getDepth(root, x);\\n   int y_depth = getDepth(root, y);\\n   struct TreeNode *x_parent = getParent(root, x);\\n   struct TreeNode *y_parent = getParent(root, y);\\n   return x_parent != y_parent && x_depth == y_depth;     \\n}"], ["bool isCousins(struct TreeNode* root, int x, int y) \\n{\\n   int x_depth = getDepth(root, x);\\n   int y_depth = getDepth(root, y);\\n   struct TreeNode *x_parent = getParent(root, x);\\n   struct TreeNode *y_parent = getParent(root, y);\\n   return x_parent != y_parent && x_depth == y_depth;     \\n}"]]}
{"id": "216", "ref_c": [["int findJudge(int n, int** trust, int trustSize, int* trustColSize){\\n    int t[1001];\\n    bool tr[1001];\\n    if (n == 1 && trustSize == 0) return 1;\\n    for (int i = 0; i < 1001; i++) {\\n        t[i] = 0;\\n        tr[i] = false;\\n    }"], ["int findJudge(int n, int** trust, int trustSize, int* trustColSize){\\n    int t[1001];\\n    bool tr[1001];\\n    if (n == 1 && trustSize == 0) return 1;\\n    for (int i = 0; i < 1001; i++) {\\n        t[i] = 0;\\n        tr[i] = false;\\n    }"], ["int findJudge(int n, int** trust, int trustSize, int* trustColSize){\\n    int t[1001];\\n    bool tr[1001];\\n    if (n == 1 && trustSize == 0) return 1;\\n    for (int i = 0; i < 1001; i++) {\\n        t[i] = 0;\\n        tr[i] = false;\\n    }"]]}
{"id": "217", "ref_c": [["int numRookCaptures(char** board, int boardSize, int* boardColSize) \\n{\\n    int row_rook, col_rook;\\n    for(int i = 0; i < boardSize; i++)\\n    {\\n        for(int j = 0; j < *boardColSize; j++)\\n        {\\n            if(board[i][j] == \\'R\\')\\n            {\\n                row_rook = i;\\n                col_rook = j;\\n                break;\\n            }"], ["int numRookCaptures(char** board, int boardSize, int* boardColSize){\\n    for (int row_idx = 0; row_idx < boardSize; row_idx ++) {\\n        for (int col_idx = 0; col_idx < 8; col_idx ++) {\\n            if (board[row_idx][col_idx] == \\'R\\') {\\n                int count = 0;\\n                for (int top_row = 1; top_row <= row_idx; top_row ++) {\\n                    int row = row_idx - top_row;\\n                    char value = board[row][col_idx];\\n                    if (value == \\'p\\') {\\n                        count ++;\\n                        break;\\n                    }"], ["int numRookCaptures(char** board, int boardSize, int* boardColSize){\\n    for (int row_idx = 0; row_idx < boardSize; row_idx ++) {\\n        for (int col_idx = 0; col_idx < 8; col_idx ++) {\\n            if (board[row_idx][col_idx] == \\'R\\') {\\n                int count = 0;\\n                for (int top_row = 1; top_row <= row_idx; top_row ++) {\\n                    int row = row_idx - top_row;\\n                    char value = board[row][col_idx];\\n                    if (value == \\'p\\') {\\n                        count ++;\\n                        break;\\n                    }"]]}
{"id": "218", "ref_c": [["char ** commonChars(char ** words, int wordsSize, int* returnSize){\\nint i,j,k,count=0,d_arr_size=strlen(words[0]),index=0,chr=97,min_count=0,flag=0;\\nchar ar[26];\\nfor(i=0;i<26;i++)\\nar[i]=(char)chr++;\\nchar **d_arr=malloc(d_arr_size*sizeof(char*));\\nfor(i=0;i<d_arr_size;i++)\\nd_arr[i]=malloc(2*sizeof(char));\\n//printf(\"%d\",d_arr_size);\\n\\nfor(int g=0; g<26;g++){\\n    count=0;\\n    flag=0;\\n    min_count=0;\\n    for(i=0;i<wordsSize;i++){\\n        count=0;\\n        for(j=0;words[i][j]!=\\'\\\\0\\';j++){\\n            //printf(\"chcking 4 %c\\\\n\",ar[g]);\\n            if(words[i][j]==ar[g]){\\n            count++;\\n            //printf(\"cn= %d\\\\n\",count);\\n            }"], ["char ** commonChars(char ** words, int wordsSize, int* returnSize){\\n    char** ac=malloc(100*sizeof(char*));\\n    char abc[26],abc2[26];\\n    int i=0,j;\\n    //\\u521D\\u59CB\\u5316\\u9663\\u5217\\n    for(j=0;j<26;j++){\\n        abc[j]=100;\\n    }"], ["char ** commonChars(char ** words, int wordsSize, int* returnSize) {\\n    int** hashMap = malloc (sizeof (int*) * wordsSize * NumberAlphabet);\\n    int minHashMap[NumberAlphabet];\\n    char** ansHashMap = malloc (sizeof (char*) * wordsSize);\\n    int i = 0, j = 0, k = 0;\\n    \\n    // Allocate a 26 integer-size hash map for every word.\\n    for (i = 0; i < wordsSize; i++) {\\n        hashMap[i] = malloc (sizeof (int) * NumberAlphabet);\\n    }"]]}
{"id": "219", "ref_c": [["int largestSumAfterKNegations(int* nums, int numsSize, int k){\\n    while(k > 0){\\n    int min = 101;\\n    for(int i =0; i<numsSize; i++){\\n        if(nums[i] < min){\\n            min = nums[i];\\n        }"], ["int largestSumAfterKNegations(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), cmpfunc);\\n\\n    int i = 0, sum = 0;\\n\\n    while (k--) {\\n        nums[i] = -nums[i];\\n\\n        if (i == numsSize - 1)\\n            continue;\\n\\n        if (nums[i] > nums[i + 1])\\n            i++;\\n    }"], ["int largestSumAfterKNegations(int* nums, int numsSize, int k){\\n    // Sort the array first. \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int i, N = numsSize, j = 0, sum = 0;\\n    \\n    // Concept: Flip the smallest element at each round. If it becomes larger than the next smallest element, don\\'t flip it in later rounds and switch to the next element. \\n    for(; k > 0; k--){  \\n        nums[j] = -nums[j];\\n        if(j == N - 1){\\n            continue;\\n        }"]]}
{"id": "220", "ref_c": [["int bitwiseComplement(int n) {\\n        int m = n;\\n        if(m==0)return 1;\\n        int mask = 0 ;\\n        while(m!=0)\\n        {\\n            mask = (mask << 1) | 1;\\n            m = m >> 1;\\n        }"], ["int bitwiseComplement(int n) {\\n        int mask = 1;\\n        \\n        while((mask & n) != n){\\n            mask = mask << 1;\\n            mask += 1;\\n        }"], ["int bitwiseComplement(int n) {\\n        if (n == 0) return 1;\\n        \\n        int mask =  (1 << (31 - __builtin_clz(n))) - 1;\\n        return (n ^ -0x1) & mask;\\n    }"]]}
{"id": "221", "ref_c": [["bool canThreePartsEqualSum(int* arr, int arrSize)\\n{\\n    int currentSum = 0;\\n    int count = 0;\\n    int targetSum = 0;\\n\\n    for(int i = 0; i < arrSize; i++)\\n        currentSum += arr[i];\\n\\n    if(currentSum % 3 == 0)\\n    {\\n        currentSum /= 3;\\n        for(int i = 0; i < arrSize; i++)\\n        {\\n            targetSum += arr[i];\\n            if(currentSum == targetSum)\\n            {\\n                targetSum = 0;\\n                count++;\\n            }"], ["bool canThreePartsEqualSum(int* arr, int arrSize) \\n{\\n    if(arrSize < 3)\\n    {\\n        return false;\\n    }"], ["bool canThreePartsEqualSum(int* arr, int arrSize)\\n{\\n    int currentSum = 0;\\n    int count = 0;\\n    int targetSum = 0;\\n\\n    for(int i = 0; i < arrSize; i++)\\n        currentSum += arr[i];\\n\\n    if(currentSum % 3 == 0)\\n    {\\n        currentSum /= 3;\\n        for(int i = 0; i < arrSize; i++)\\n        {\\n            targetSum += arr[i];\\n            if(currentSum == targetSum)\\n            {\\n                targetSum = 0;\\n                count++;\\n            }"]]}
{"id": "222", "ref_c": [["bool* prefixesDivBy5(int* nums, int numsSize, int* returnSize)\\n{\\n    *returnSize=numsSize;\\n    int q=0;\\n\\t\\n\\t//Using `answer`, as `int array` is different from demanded `bool array`\\n    bool* answer=(bool *)malloc(numsSize*sizeof(bool));\\n\\t\\n    for(register int i=0 ; i<numsSize; i++)\\n    {\\n        q = ((q<<1) | nums[i]) % 5;\\n        answer[i] = (q==0);\\n    }"], ["bool* prefixesDivBy5(int* nums, int numsSize, int* returnSize){\\n    bool *res=malloc(sizeof(bool)*numsSize);\\n    int sum=0;\\n    for(int i=0;i<numsSize;i++){\\n        sum=sum*2+nums[i];\\n        sum%=10;\\n        if(sum==0 || sum==5) res[i]=true;\\n        else res[i]=false;\\n    }"], ["bool* prefixesDivBy5(int* nums, int numsSize, int* returnSize){\\n  bool* result = (bool*)malloc(numsSize*sizeof(bool));\\n  *returnSize = numsSize;\\n  int val = 0;\\n  for(int i =0; i<numsSize; i++){\\n      val = (val*2 + nums[i]) %5;\\n      result[i] = (val == 0)?true:false;\\n  }"]]}
{"id": "223", "ref_c": ["\nchar* removeOuterParentheses(char* s) {\n    int count = 0;\n    int length = strlen(s);\n    char* result = (char*)malloc(length + 1);\n    int resultIndex = 0;\n\n    for (int i = 0; i < length; i++) {\n        if (count == 0) {\n            count += (s[i] == '(' ? 1 : -1);\n        } else {\n            count += (s[i] == '(' ? 1 : -1);\n            if (count != 0) {\n                result[resultIndex] = s[i];\n                resultIndex++;\n            }\n        }\n    }\n\n    result[resultIndex] = '\u0000'; // Null-terminate the result string\n    return result;\n\n}\n\n", "\nchar* removeOuterParentheses(char* s) {\n    int count = 0;\n    int length = strlen(s);\n    char* result = (char*)malloc(length + 1);\n    int resultIndex = 0;\n\n    for (int i = 0; i < length; i++) {\n        if (count == 0) {\n            count += (s[i] == '(' ? 1 : -1);\n        } else {\n            count += (s[i] == '(' ? 1 : -1);\n            if (count != 0) {\n                result[resultIndex] = s[i];\n                resultIndex++;\n            }\n        }\n    }\n\n    result[resultIndex] = '\u0000'; // Null-terminate the result string\n    return result;\n\n}\n\n", "\nchar* removeOuterParentheses(char* s) {\n    int count = 0;\n    int length = strlen(s);\n    char* result = (char*)malloc(length + 1);\n    int resultIndex = 0;\n\n    for (int i = 0; i < length; i++) {\n        if (count == 0) {\n            count += (s[i] == '(' ? 1 : -1);\n        } else {\n            count += (s[i] == '(' ? 1 : -1);\n            if (count != 0) {\n                result[resultIndex] = s[i];\n                resultIndex++;\n            }\n        }\n    }\n\n    result[resultIndex] = '\u0000'; // Null-terminate the result string\n    return result;\n\n}\n\n"]}
{"id": "224", "ref_c": [["int sumRootToLeaf(struct TreeNode* root){\\n    int num=0;\\n    dfs(root,&num,0);\\n    return num;\\n}"], ["int sumRootToLeaf(struct TreeNode* root){\\n    int i = 0, s = 0;\\n    trav(root, &i, &s);\\n    return s;\\n}"], ["int sumRootToLeaf(struct TreeNode* root){\\n    int res = 0;\\n    if(!root) return res;\\n    bool *arr = NULL;\\n    dfs(root,1,&arr,&res);\\n    return res;\\n}", "int sumRootToLeaf(struct TreeNode* root){\\n    int res = 0;\\n    if(!root) return res;\\n    bool *arr = NULL;\\n    int cur_number = 0;\\n    dfs(root,cur_number,&res);\\n    return res;\\n}"]]}
{"id": "225", "ref_c": [["bool divisorGame(int n){\\nreturn !(n%2);\\n}"], ["bool divisorGame(int n){\\n    return (n&1)==0;\\n}", "bool divisorGame(int n) {\\n        return (n&1)==0;\\n    }"], ["bool divisorGame(int n) {\\n    return n % 2 == 0;\\n}", "bool divisorGame(int n) {\\n        return n % 2 == 0;\\n    }"]]}
{"id": "226", "ref_c": [["int** allCellsDistOrder(int rows, int cols, int rCenter, int cCenter, int* returnSize, int** returnColumnSizes){\\n    //create a new 2D array\\n    const int cellCnt = rows * cols;\\n    *returnColumnSizes = (int *)malloc(sizeof (int) * cellCnt);\\n    int ** rets = (int **)malloc(sizeof (int *) * cellCnt);\\n    *returnSize = 0;\\n\\n    //add {rCenter, cCenter}"], ["int** allCellsDistOrder(int rows, int cols, int rCenter, int cCenter, int* returnSize, int** returnColumnSizes){\\n    int** ans = (int**)calloc(rows * cols, sizeof(int*));\\n    int* col = (int*)calloc(rows * cols, sizeof(int));    \\n    int wIdx = 0, rIdx = 0;\\n    bool** m = (int**)calloc(rows, sizeof(int*));/* record visit or not */\\n    for(int i = 0; i < rows; i++)\\n        m[i] = (int*)calloc(cols, sizeof(int));\\n    \\n    checkBoundary(rCenter, cCenter, rows, cols, m, ans, col, &wIdx);\\n    while(wIdx != rIdx){\\n        int rr = ans[rIdx][0];\\n        int cc = ans[rIdx++][1];\\n\\t\\t/* chek the 4 directions */\\n        checkBoundary(rr+1, cc, rows, cols, m, ans, col, &wIdx);\\n        checkBoundary(rr-1, cc, rows, cols, m, ans, col, &wIdx);\\n        checkBoundary(rr, cc+1, rows, cols, m, ans, col, &wIdx);\\n        checkBoundary(rr, cc-1, rows, cols, m, ans, col, &wIdx);        \\n    }"], ["int** allCellsDistOrder(int rows, int cols, int rCenter, int cCenter, int* returnSize, int** returnColumnSizes) {\\n    int arrSize = rows * cols;\\n    *returnSize = arrSize;\\n    *returnColumnSizes = (int*) malloc((*returnSize) * sizeof(int));\\n    for(int i = 0; i < (*returnSize); i++) {\\n        (*returnColumnSizes)[i] = 2;\\n    }"]]}
{"id": "227", "ref_c": [["bool isBoomerang(int** points, int pointsSize, int* pointsColSize){\\n    const int\\n        x1 = points[0][0],\\n        y1 = points[0][1],\\n\\n        x2 = points[1][0],\\n        y2 = points[1][1],\\n\\n        x3 = points[2][0],\\n        y3 = points[2][1]\\n    ;\\n    return (y3 - y1) * (x2 - x1) != (x3 - x1) * (y2 - y1);\\n}"], ["bool isBoomerang(int** points, int pointsSize, int* pointsColSize){\\n    const int\\n        x1 = points[0][0],\\n        y1 = points[0][1],\\n\\n        x2 = points[1][0],\\n        y2 = points[1][1],\\n\\n        x3 = points[2][0],\\n        y3 = points[2][1]\\n    ;\\n    return (y3 - y1) * (x2 - x1) != (x3 - x1) * (y2 - y1);\\n}"], ["bool isBoomerang(int** points, int pointsSize, int* pointsColSize){\\n    return (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]) !=\\n        (points[2][1] - points[1][1]) * (points[1][0] - points[0][0]);\\n}"]]}
{"id": "228", "ref_c": [["int lastStoneWeight(int* stones, int stonesSize)\\n{\\n    if (stonesSize == 1)\\n        return stones[0];\\n\\t\\t\\n    qsort(stones, stonesSize, sizeof(int), cmp);\\n    stones[stonesSize - 2] = stones[stonesSize - 1] - stones[stonesSize - 2];\\n\\n    return lastStoneWeight(stones, stonesSize - 1);\\n}"], ["int lastStoneWeight(int* stones, int stonesSize) {\\n    if(stonesSize < 2) return stones[0];\\n    while(true) {\\n        qsort(stones, stonesSize, sizeof(int), cmp);\\n        int first = stones[0], second = stones[1];\\n        stones[0] = stones[1] = 0;\\n        if(first != second) stones[0] = first - second;\\n        if(second == 0) return first;\\n    }"], ["int lastStoneWeight(int* stones, int stonesSize) {\\n    if(stonesSize < 2) return stones[0];\\n    while(true) {\\n        qsort(stones, stonesSize, sizeof(int), cmp);\\n        int first = stones[0], second = stones[1];\\n        stones[0] = stones[1] = 0;\\n        if(first != second) stones[0] = first - second;\\n        if(second == 0) return first;\\n    }"]]}
{"id": "229", "ref_c": ["\nchar* removeDuplicates(char* s) {\n    int length = strlen(s);\n    char* output = (char*)malloc((length + 1) * sizeof(char));\n    int top = -1;\n\n    for (int i = i; i<length; i++){\n        if (top == -1){\n            output[++top] = s[i];  \n        }\n        else if(s[i] == output[top]){\n            top --;\n        }\n        else{\n            output[++top] = s[i];  \n        }\n    }\n    output[++top] = '\u0000';\n    return output;\n}\n", "\nchar* removeDuplicates(char* s) {\n    int length = strlen(s);\n    char* output = (char*)malloc((length + 1) * sizeof(char));\n    int top = -1;\n\n    for (int i = i; i<length; i++){\n        if (top == -1){\n            output[++top] = s[i];  \n        }\n        else if(s[i] == output[top]){\n            top --;\n        }\n        else{\n            output[++top] = s[i];  \n        }\n    }\n    output[++top] = '\u0000';\n    return output;\n}\n", "\nchar* removeDuplicates(char* s) {\n    int length = strlen(s);\n    char* output = (char*)malloc((length + 1) * sizeof(char));\n    int top = -1;\n\n    for (int i = i; i<length; i++){\n        if (top == -1){\n            output[++top] = s[i];  \n        }\n        else if(s[i] == output[top]){\n            top --;\n        }\n        else{\n            output[++top] = s[i];  \n        }\n    }\n    output[++top] = '\u0000';\n    return output;\n}\n"]}
{"id": "231", "ref_c": [["int heightChecker(int* heights, int heightsSize){\\n    int expec[heightsSize],temp,i,j,c=0;\\n    int h[heightsSize];\\n    for( i=0;i<heightsSize;i++)\\n{\\n    h[i]=heights[i];\\n}"], ["int heightChecker(int* heights, int heightsSize){\\n    int result = 0;\\n\\n    int max_height = 102;\\n    int* counter = (int*) calloc(max_height, sizeof(int));\\n\\n    // int expected[heightsSize];\\n\\n    for(int i=0; i<heightsSize; i++)\\n        counter[heights[i]]++;\\n\\n    int pos = 1;\\n    for(int i=0; i<heightsSize; i++)\\n    {\\n        while(counter[pos]==0)\\n            pos++;\\n\\n        if(heights[i] != pos)\\n            result++;\\n\\n        counter[pos]--;\\n    }"], ["int heightChecker(int* heights, int heightsSize){\\n    int expec[heightsSize],temp,i,j,c=0;\\n    int h[heightsSize];\\n    for( i=0;i<heightsSize;i++)\\n{\\n    h[i]=heights[i];\\n}"]]}
{"id": "233", "ref_c": ["\nunsigned short int gcd(unsigned short int a, unsigned short int b)\n{\n    if (b == 0) return a;\n\n    return gcd(b, a % b);\n}\n\n\nchar* strconcat(char* strbase, char* strconcat)\n{\n    size_t size = strlen(strbase) + strlen(strconcat) + 1;\n    char* result = calloc(size, sizeof(char));\n\n    strcpy(result, strbase);\n    strcat(result, strconcat);\n\n    return result;\n}\n\n\nunsigned short int strcompare(char* a, char* b)\n{\n    unsigned short int equal = strcmp(a, b);\n\n    free(a);\n    free(b);\n\n    return equal;\n}\n\n\nchar* gcdOfStrings(char* str1, char* str2)\n{\n    char* a = strconcat(str1, str2);\n    char* b = strconcat(str2, str1);\n\n    if (strcompare(a, b) != 0)\n    {\n        char* empty = calloc(1, sizeof(char));\n        return calloc(1, sizeof(char));\n    }\n\n    unsigned short int largest_index = gcd(strlen(str1), strlen(str2));\n    char* result = calloc(largest_index + 1, sizeof(char));\n    strncpy(result, str1, largest_index);\n\n    return result;\n}\n", "\nunsigned short int gcd(unsigned short int a, unsigned short int b)\n{\n    if (b == 0) return a;\n\n    return gcd(b, a % b);\n}\n\n\nchar* strconcat(char* strbase, char* strconcat)\n{\n    size_t size = strlen(strbase) + strlen(strconcat) + 1;\n    char* result = calloc(size, sizeof(char));\n\n    strcpy(result, strbase);\n    strcat(result, strconcat);\n\n    return result;\n}\n\n\nunsigned short int strcompare(char* a, char* b)\n{\n    unsigned short int equal = strcmp(a, b);\n\n    free(a);\n    free(b);\n\n    return equal;\n}\n\n\nchar* gcdOfStrings(char* str1, char* str2)\n{\n    char* a = strconcat(str1, str2);\n    char* b = strconcat(str2, str1);\n\n    if (strcompare(a, b) != 0)\n    {\n        char* empty = calloc(1, sizeof(char));\n        return calloc(1, sizeof(char));\n    }\n\n    unsigned short int largest_index = gcd(strlen(str1), strlen(str2));\n    char* result = calloc(largest_index + 1, sizeof(char));\n    strncpy(result, str1, largest_index);\n\n    return result;\n}\n", "\nunsigned short int gcd(unsigned short int a, unsigned short int b)\n{\n    if (b == 0) return a;\n\n    return gcd(b, a % b);\n}\n\n\nchar* strconcat(char* strbase, char* strconcat)\n{\n    size_t size = strlen(strbase) + strlen(strconcat) + 1;\n    char* result = calloc(size, sizeof(char));\n\n    strcpy(result, strbase);\n    strcat(result, strconcat);\n\n    return result;\n}\n\n\nunsigned short int strcompare(char* a, char* b)\n{\n    unsigned short int equal = strcmp(a, b);\n\n    free(a);\n    free(b);\n\n    return equal;\n}\n\n\nchar* gcdOfStrings(char* str1, char* str2)\n{\n    char* a = strconcat(str1, str2);\n    char* b = strconcat(str2, str1);\n\n    if (strcompare(a, b) != 0)\n    {\n        char* empty = calloc(1, sizeof(char));\n        return calloc(1, sizeof(char));\n    }\n\n    unsigned short int largest_index = gcd(strlen(str1), strlen(str2));\n    char* result = calloc(largest_index + 1, sizeof(char));\n    strncpy(result, str1, largest_index);\n\n    return result;\n}\n"]}
{"id": "235", "ref_c": [["char ** findOcurrences(char * text, char * first, char * second, int* returnSize){\\n    char** ans = (char**)calloc(50, sizeof(char*));\\n    int ansIdx = 0, idx = 0, len = strlen(text), fLen = strlen(first), sLen = strlen(second);\\n    int totalLen = fLen + sLen;\\n    int stage = 0;\\n    while(idx < len){\\n        int cIdx = 0;\\n        char* s = (char*)calloc(50, sizeof(char));\\n\\n        while(text[idx]!=\\' \\' && text[idx]!=\\'\\\\0\\')\\n            s[cIdx++] = text[idx++];\\n        \\n        switch(stage){\\n            case 0:\\n                if(cIdx == fLen && !strncmp(s, first, fLen))\\n                    stage = 1;\\n                break;\\n            case 1:\\n                if(cIdx == sLen && !strncmp(s, second, sLen))\\n                    stage = 2;\\n                else {\\n                    stage = 0;\\n                    idx -= (cIdx+1); /* move to the first word to check again */\\n                }"], ["char ** findOcurrences(char * text, char * first, char * second, int* returnSize){\\n    char** out = (char *) malloc(sizeof(out) * 333); // max_text_size / 3 is maximum amount occurences we will need to store\\n    *returnSize = 0;\\n    \\n    char *p, *f, *s;         // current token, first token, second token\\n    p = strtok(text, \" \");  // set current token using strtok() which returns a pointer to word up to delimiter \" \" (space)\\n\\tf = s = NULL;          // set first/second tokens to NULL\\n    while (p)    // while another token in the string exists\\n    {   \\n\\t    // if f and s tokens exist and are equal to first/second cstrings respectively\\n\\t\\t// then store the current token pointer in the last index of pointer array and increment last index (returnSize)\\n        if (stringEqualsToken(first, f) && stringEqualsToken(second, s))\\n            out[(*returnSize)++] = p;    \\n\\t\\t// updates: \\n        f = s;  // firstToken stores old secondToken,\\n\\t\\ts = p; // secondToken stores old current\\n\\t\\tp = strtok(NULL, \" \"); // current is next strtok() value\\n    }", "char ** findOcurrences(char * text, char * first, char * second, int* returnSize){\\n    *returnSize = 0;\\n    char **out = (char *) malloc(sizeof(out) * 333), *p = strtok(text, \" \"), *f  = NULL, *s = NULL;       \\n    while (p) {\\n        if (f && strcmp(first, f) == 0 && s && strcmp(second, s) == 0)\\n           out[(*returnSize)++] = p; \\n        f = s, s = p, p = strtok(NULL, \" \");\\n\\t}"], ["char ** findOcurrences(char * text, char * first, char * second, int* returnSize){\\n    /*\\n     * Input:\\n     *  text, string\\n     *  first, string\\n     *  second, string\\n     */\\n     \\n    char *words[1000];\\n    int wordsSize = 0;\\n    char **ans = (char **)malloc(sizeof(char *) * 1000);\\n    \\n    *returnSize = 0;\\n    \\n    /* \\n     * Extract words from text \\n     *  Dry run: text = \"aaa bb c\"\\n     *      start = 0, end = 0 ~ 3\\n     *          words[0] = \"aaa\"\\n     *      start = 4, end = 6\\n     *          words[1] = \"bb\"\\n     *      start = 7, end = 7,\\n     *          words[2] = ?\\n     */\\n    for (int start = 0, end = 0; ; end++) {\\n        if (text[end] == \\' \\' || text[end] == 0) {\\n            words[wordsSize] = (&text[start]);\\n            wordsSize++;\\n\\n            if (text[end] != 0) {\\n                /* Set termination of this word */\\n                text[end] = 0; \\n                start = end + 1;\\n            }"]]}
{"id": "237", "ref_c": [["void duplicateZeros(int* arr, int arrSize) \\n{\\n   int j =0;\\n   int arr2[arrSize+2];\\n\\n    for ( int i=0;i<arrSize;i++)\\n    {       \\n            if ( arr[i]==0 && j <arrSize)\\n             {\\n             arr2[j]=0;\\n             j++;\\n             arr2[j]=0;\\n  \\n            }"], ["void duplicateZeros(int* arr, int arrSize) {\\n    int p=0;\\n    int temp[arrSize+2];\\n    for(int i=0;i<arrSize&&p<arrSize;i++,p++){\\n        if(arr[i]==0){\\n        temp[p]=0;\\n        p++;\\n        temp[p]=0;\\n        }"], ["void duplicateZeros(int* arr, int arrSize) \\n{\\n   int j =0;\\n   int arr2[arrSize+2];\\n\\n    for ( int i=0;i<arrSize;i++)\\n    {       \\n            if ( arr[i]==0 && j <arrSize)\\n             {\\n             arr2[j]=0;\\n             j++;\\n             arr2[j]=0;\\n  \\n            }"]]}
{"id": "238", "ref_c": [["int* distributeCandies(int candies, int num_people, int* returnSize){\\n    *returnSize = num_people;\\n    int x[num_people];\\n    int y = 1;\\n    int *res=(int*)calloc(num_people,sizeof(int));\\n    while(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }"], ["int* distributeCandies(int candies, int num_people, int* returnSize){\\n    *returnSize = num_people;\\n    int x[num_people];\\n    int y = 1;\\n    int *res=(int*)calloc(num_people,sizeof(int));\\n    while(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }"], ["int* distributeCandies(int candies, int num_people, int* returnSize){\\n    //Initialize dinamic candiesDistribution array and set to 0:\\n    int *candiesDistribution = malloc(sizeof(int)*num_people);\\n    for(int i=0;i<num_people;i++) candiesDistribution[i]=0;\\n    //Turn count:\\n    int turn=0,i;\\n\\n    //(n*(n+1))/2: Sumatory 1+2+..+n\\n    for(i=1;(i*(i+1))/2<=candies;i++){\\n        //turn%num_people: turn between 0 and num_people-1\\n        candiesDistribution[turn%num_people]+=i;\\n        turn++;\\n    }"]]}
{"id": "239", "ref_c": [["char * defangIPaddr(char * address){\\n    char *b=(char*)malloc(100000*sizeof(char));\\n    int j=0;\\n    int size=strlen(address);\\n    for(int i=0;i<size;i++){\\n        if(address[i]==\\'.\\'){\\n            b[j++]=\\'[\\';\\n            b[j++]=address[i];\\n            b[j++]=\\']\\';\\n        }"], ["char * defangIPaddr(char * address){\\n    char *b=(char*)malloc(100000*sizeof(char));\\n    int j=0;\\n    int size=strlen(address);\\n    for(int i=0;i<size;i++){\\n        if(address[i]==\\'.\\'){\\n            b[j++]=\\'[\\';\\n            b[j++]=address[i];\\n            b[j++]=\\']\\';\\n        }"], ["char * defangIPaddr(char * address){\\n    char *b=(char*)malloc(100000*sizeof(char));\\n    int j=0;\\n    int size=strlen(address);\\n    for(int i=0;i<size;i++){\\n        if(address[i]==\\'.\\'){\\n            b[j++]=\\'[\\';\\n            b[j++]=address[i];\\n            b[j++]=\\']\\';\\n        }"]]}
{"id": "241", "ref_c": [["int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize) {\\n    *returnSize=arr1Size;\\n    int *array,n=0,c=0,m=0;\\n    for(int j=0; j<arr2Size; j++){\\n    for(int i=0; i<arr1Size; i++){\\n        if(arr1[i]==arr2[j]){\\n        c=arr1[i];\\n        arr1[i]=arr1[n];\\n        arr1[n]=c;\\n        n++;\\n        }"], ["int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize) {\\n    *returnSize=arr1Size;\\n    int *array,n=0,c=0,m=0;\\n    for(int j=0; j<arr2Size; j++){\\n    for(int i=0; i<arr1Size; i++){\\n        if(arr1[i]==arr2[j]){\\n        c=arr1[i];\\n        arr1[i]=arr1[n];\\n        arr1[n]=c;\\n        n++;\\n        }"], ["int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize) {\\n    *returnSize=arr1Size;\\n    int *array,n=0,c=0,m=0;\\n    for(int j=0; j<arr2Size; j++){\\n    for(int i=0; i<arr1Size; i++){\\n        if(arr1[i]==arr2[j]){\\n        c=arr1[i];\\n        arr1[i]=arr1[n];\\n        arr1[n]=c;\\n        n++;\\n        }"]]}
{"id": "242", "ref_c": [["int numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\\n    HashTable* table = NULL;\\n    HashTable* result = (HashTable*) malloc(sizeof(HashTable));\\n    int temp, pairs = 0;\\n\\n    for (int i=0; i<dominoesSize; i++) {\\n        char key[3];\\n        // swap so that smallest always comes first!\\n        if(dominoes[i][0] > dominoes[i][1]) {\\n            temp = dominoes[i][0];\\n            dominoes[i][0] = dominoes[i][1];\\n            dominoes[i][1] = temp;\\n        }"], ["int numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\\n    int dominoCnts[10][10];\\n    memset( &dominoCnts, 0, sizeof (dominoCnts) );\\n    for (int i = 0; i < dominoesSize; i += 1){\\n        if (dominoes[i][0] >= dominoes[i][1]){\\n            dominoCnts[ dominoes[i][0] ][ dominoes[i][1] ] += 1;\\n        }"], ["int numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\\n    int arr[ARR_SIZE] = {0}"]]}
{"id": "243", "ref_c": [["int tribonacci(int n){\\n    if(n==0) return 0;\\n    if(n==1 ||n==2)  return 1;\\n    int f[n+1];\\n    f[0]=0;\\n    f[1]=1;\\n    f[2]=1;\\n    for(int i=3;i<=n;i++){\\n        f[i] = f[i-1]+f[i-2]+f[i-3];\\n    }"], ["int tribonacci(int n) {\\n\\t\\t\\tif( n == 0)  return 0;\\n\\t\\t\\telse if ( n== 1 || n == 2)  return 1;\\n\\t\\t\\telse return tribonacci ( n - 1 )+tribonacci ( n - 2 )+tribonacci ( n - 3 );\\n    }", "int tribonacci(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve(n,dp);\\n    }"], ["int tribonacci(int n)\\n{\\n    int tr[n + 1];\\n    int i = 3;\\n\\n    if (n == 0)\\n        return (0);\\n    if (n == 1 || n == 2)\\n        return (1);\\n    tr[0] = 0;\\n    tr[1] = 1;\\n\\ttr[2] = 1;\\n    while (i <= n)\\n    {\\n        tr[i] = tr[i - 3] + tr[i - 2] + tr[i - 1];\\n        i++;\\n    }"]]}
{"id": "246", "ref_c": [["int dayOfYear(char * date){\\n    int year,month,day;\\n    int map[12]={31,28,31,30,31,30,31,31,30,31,30,31}"], ["int dayOfYear(char * date){\\n    int year,month,day;\\n    int map[12]={31,28,31,30,31,30,31,31,30,31,30,31}"], ["int dayOfYear(char * date){\\n    int year,month,day;\\n    int map[12]={31,28,31,30,31,30,31,31,30,31,30,31}"]]}
{"id": "247", "ref_c": ["\nbool wordsIsThere(char* word1,char* word2)\n{\n    int wordList1[127] = {0};\n    int wordList2[127] = {0};\n    int i;\n    for(i= 0; word1[i]; i++)wordList1[(int)word1[i]]++;\n    for(i= 0; word2[i]; i++)wordList2[(int)word2[i]]++;\n    for(i = 0; word1[i]; i++)\n    {\n        if(wordList1[(int)word1[i]] > wordList2[(int)word1[i]])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\nint countCharacters(char** words, int wordsSize, char* chars) {\n    int c = 0;\n    for(int i = 0; i < wordsSize; i++)\n    {\n        if(wordsIsThere(words[i],chars))c+= strlen(words[i]);\n    }\n    return c;\n}\n", "\nbool wordsIsThere(char* word1,char* word2)\n{\n    int wordList1[127] = {0};\n    int wordList2[127] = {0};\n    int i;\n    for(i= 0; word1[i]; i++)wordList1[(int)word1[i]]++;\n    for(i= 0; word2[i]; i++)wordList2[(int)word2[i]]++;\n    for(i = 0; word1[i]; i++)\n    {\n        if(wordList1[(int)word1[i]] > wordList2[(int)word1[i]])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\nint countCharacters(char** words, int wordsSize, char* chars) {\n    int c = 0;\n    for(int i = 0; i < wordsSize; i++)\n    {\n        if(wordsIsThere(words[i],chars))c+= strlen(words[i]);\n    }\n    return c;\n}\n", "\nbool wordsIsThere(char* word1,char* word2)\n{\n    int wordList1[127] = {0};\n    int wordList2[127] = {0};\n    int i;\n    for(i= 0; word1[i]; i++)wordList1[(int)word1[i]]++;\n    for(i= 0; word2[i]; i++)wordList2[(int)word2[i]]++;\n    for(i = 0; word1[i]; i++)\n    {\n        if(wordList1[(int)word1[i]] > wordList2[(int)word1[i]])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\nint countCharacters(char** words, int wordsSize, char* chars) {\n    int c = 0;\n    for(int i = 0; i < wordsSize; i++)\n    {\n        if(wordsIsThere(words[i],chars))c+= strlen(words[i]);\n    }\n    return c;\n}\n"]}
{"id": "249", "ref_c": [["int numPrimeArrangements(int n){\\n    int i;\\n    int prime[25] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}"], ["int numPrimeArrangements(int n){\\n    int i;\\n    int prime[25] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}"], ["int numPrimeArrangements(int n){\\n    int i;\\n    int prime[25] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}"]]}
{"id": "251", "ref_c": [["int distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){\\n    int dist1 = distance[start],dist2 = 0,counter = 0;\\n    for(int i = ((start + 1)%distanceSize) ; i != start ; i = ((i+1)%distanceSize))\\n    {\\n        if((i != destination) && (!(counter)))\\n            dist1 += distance[i];\\n        else\\n        {\\n            counter = 1;\\n            dist2 += distance[i];\\n        }"], ["int distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){\\n    int s1=0,s2=0;\\n    if(start>destination)\\n    {\\n        int temp=start;\\n        start=destination;\\n        destination=temp;\\n    }"], ["int distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination) {\\n    int tmpstart = start > destination ? destination : start;\\n    int tmpdes = tmpstart == start ? destination : start;\\n    int sum = 0, rangesum = 0;\\n    for(int i = 0; i < distanceSize; i++) {\\n        sum += distance[i];\\n        if(i >= tmpstart && i < tmpdes) rangesum += distance[i];\\n    }"]]}
{"id": "252", "ref_c": [["char * dayOfTheWeek(int day, int month, int year){\\n    char *ans = malloc(10);\\n    struct tm tm;\\n    char buff[80];\\n    sprintf(buff, \"%d-%02d-%02d\", year, month, day);\\n    strptime(buff, \"%Y-%m-%d\", &tm);\\n    strftime(ans, 10, \"%A\", &tm);\\n    return ans;\\n}"], ["char * dayOfTheWeek(int day, int month, int year){\\n    char *ans = malloc(10);\\n    struct tm tm;\\n    char buff[80];\\n    sprintf(buff, \"%d-%02d-%02d\", year, month, day);\\n    strptime(buff, \"%Y-%m-%d\", &tm);\\n    strftime(ans, 10, \"%A\", &tm);\\n    return ans;\\n}"], ["char * dayOfTheWeek(int day, int month, int year){\\n    char *ans = malloc(10);\\n    struct tm tm;\\n    char buff[80];\\n    sprintf(buff, \"%d-%02d-%02d\", year, month, day);\\n    strptime(buff, \"%Y-%m-%d\", &tm);\\n    strftime(ans, 10, \"%A\", &tm);\\n    return ans;\\n}"]]}
{"id": "253", "ref_c": [["int maxNumberOfBalloons(char * text){\\n    int map[N]={0}"], ["int maxNumberOfBalloons(char * text){\\n    int map[N]={0}"], ["int maxNumberOfBalloons(char * text){\\n    int map[N]={0}"]]}
{"id": "254", "ref_c": [["int** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes) {\\n    // Sort the array in ascending order\\n    qsort(arr, arrSize, sizeof(int), compare);\\n\\n    int minDiff = INT_MAX;  // Initialize the minimum absolute difference\\n    int pairCount = 0;      // Count of pairs with the minimum absolute difference\\n\\n    // Find the minimum absolute difference\\n    for (int i = 1; i < arrSize; i++) {\\n        int diff = arr[i] - arr[i - 1];\\n        if (diff < minDiff) {\\n            minDiff = diff;\\n            pairCount = 1;  // Reset the pair count\\n        }"], ["int** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes){\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    int **result = (int **)malloc(arrSize*sizeof(int *));\\n    *returnSize = 0;\\n    int min = INT_MAX;\\n    for(int i = 1; i < arrSize; i++)\\n        min = min < arr[i] - arr[i - 1] ? min : arr[i] - arr[i - 1];\\n    (*returnColumnSizes) = (int *)malloc(arrSize*sizeof(int));\\n    for(int i = 1; i < arrSize; i++)\\n        if(arr[i] - arr[i - 1] == min)\\n        {\\n            (*returnColumnSizes)[*returnSize] = 2;\\n            result[*returnSize] = (int *)malloc(2*sizeof(int));\\n            result[*returnSize][0] = arr[i - 1];\\n            result[(*returnSize)++][1] = arr[i]; \\n        }"], ["int** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes){\\n    qsort(arr, arrSize, sizeof(int), compare);\\n    int len = 0;\\n    int** res = calloc(arrSize, sizeof(int*));\\n    *returnColumnSizes = (int*)malloc(arrSize * sizeof(int));\\n    int diff = INT_MAX;\\n    int refer = INT_MAX;\\n    res[0] = (int*)malloc(2 * sizeof(int));\\n    for(int i = 0; i < arrSize - 1; i++){\\n        if(arr[i + 1] - arr[i] < diff){\\n            diff = arr[i + 1] - arr[i];\\n            len = 1;\\n            res[0][0] = arr[i];\\n            res[0][1] = arr[i + 1];\\n            returnColumnSizes[0][0] = 2;\\n            refer = arr[i];\\n        }"]]}
{"id": "255", "ref_c": ["\nbool uniqueOccurrences(int* arr, int arrSize){\n    int a[1001]={0},c=0;\n    for(int i=0;i<arrSize;i++){\n        for(int j=i+1;j<arrSize;j++){\n            if(arr[i]>arr[j]){\n                int t=arr[i];\n                arr[i]=arr[j];\n                arr[j]=t;\n            }\n        }\n    }\n    for(int i=0;i<arrSize-1;i++){\n        if(arr[i]==arr[i+1])c++;\n        else{\n            printf(\"%d %d\n\",arr[i],c);\n            if(a[c]==1)return false;\n            a[c]=1;\n            c=0;\n        }\n    }\n    if(arr[arrSize-2]!=arr[arrSize-1]){\n        if(a[c]==1)return false;\n    }\n    return true;\n}\n", "\nbool uniqueOccurrences(int* arr, int arrSize){\n    int a[1001]={0},c=0;\n    for(int i=0;i<arrSize;i++){\n        for(int j=i+1;j<arrSize;j++){\n            if(arr[i]>arr[j]){\n                int t=arr[i];\n                arr[i]=arr[j];\n                arr[j]=t;\n            }\n        }\n    }\n    for(int i=0;i<arrSize-1;i++){\n        if(arr[i]==arr[i+1])c++;\n        else{\n            printf(\"%d %d\n\",arr[i],c);\n            if(a[c]==1)return false;\n            a[c]=1;\n            c=0;\n        }\n    }\n    if(arr[arrSize-2]!=arr[arrSize-1]){\n        if(a[c]==1)return false;\n    }\n    return true;\n}\n", "\nbool uniqueOccurrences(int* arr, int arrSize){\n    int a[1001]={0},c=0;\n    for(int i=0;i<arrSize;i++){\n        for(int j=i+1;j<arrSize;j++){\n            if(arr[i]>arr[j]){\n                int t=arr[i];\n                arr[i]=arr[j];\n                arr[j]=t;\n            }\n        }\n    }\n    for(int i=0;i<arrSize-1;i++){\n        if(arr[i]==arr[i+1])c++;\n        else{\n            printf(\"%d %d\n\",arr[i],c);\n            if(a[c]==1)return false;\n            a[c]=1;\n            c=0;\n        }\n    }\n    if(arr[arrSize-2]!=arr[arrSize-1]){\n        if(a[c]==1)return false;\n    }\n    return true;\n}\n"]}
{"id": "257", "ref_c": [["int minCostToMoveChips(int* position, int positionSize)\\n{\\n    int oddPosCounter = 0, evenPosCounter = 0;\\n    for(int i = 0; i < positionSize; i++)\\n    {\\n        if(position[i] % 2 == 0)\\n        {\\n            evenPosCounter++;\\n        }"], ["int minCostToMoveChips(int* position, int positionSize)\\n{\\n    int oddPosCounter = 0, evenPosCounter = 0;\\n    for(int i = 0; i < positionSize; i++)\\n    {\\n        if(position[i] % 2 == 0)\\n        {\\n            evenPosCounter++;\\n        }"], ["int minCostToMoveChips(int* position, int positionSize)\\n{\\n    int oddPosCounter = 0, evenPosCounter = 0;\\n    for(int i = 0; i < positionSize; i++)\\n    {\\n        if(position[i] % 2 == 0)\\n        {\\n            evenPosCounter++;\\n        }"]]}
{"id": "258", "ref_c": [["int balancedStringSplit(char * s){\\n    int16_t subStr = 0;\\n    int counter[2] = {}", "int balancedStringSplit(char * s){\\n    int16_t subStr = 0;\\n    for (int16_t i = 0; *(s+i) != \\'\\\\0\\'; i++) {\\n        if (check(s+i, \\'R\\') == check(s+i, \\'L\\')) subStr++;\\n    }"], ["int balancedStringSplit(char * s){\\n  unsigned count = 0,cR = 0,cL = 0;\\n  for(unsigned i = 0; s[i]; i++)\\n  {\\n    (s[i] == \\'R\\') ? cR++: cL ++;\\n \\n    if(cR == cL)\\n        count++;\\n    \\n  }"], ["int balancedStringSplit(char * s){\\n    int16_t subStr = 0;\\n    int counter[2] = {}", "int balancedStringSplit(char * s){\\n    int16_t subStr = 0;\\n    for (int16_t i = 0; *(s+i) != \\'\\\\0\\'; i++) {\\n        if (check(s+i, \\'R\\') == check(s+i, \\'L\\')) subStr++;\\n    }"]]}
{"id": "259", "ref_c": [["bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize) {\\n    if(coordinatesSize <= 2){\\n        return true;\\n    }"], ["bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize) {\\n    if(coordinatesSize <= 2){\\n        return true;\\n    }"], ["bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize){\\n    /*\\n     * Input:\\n     *  **coordinates, 2D integer array contains coordinates\\n     *  coordinatesSize, row number of given array\\n     *  *coordinatesColSize, column number of given array\\n     */\\n     \\n    float slope1, x, y;\\n     \\n    if (coordinatesSize > 2) {\\n    \\n        /* Slope of first 2 coordinates */\\n        \\n        x = (float)coordinates[0][0];\\n        y = (float)coordinates[0][1];\\n        \\n        slope1 = getSlope(x, y, (float)coordinates[1][0], (float)coordinates[1][1]);\\n\\n        for (int i = 2; i < coordinatesSize; i++) {\\n        \\n            /* \\n             * The slope of each line segment should be the same \\n             * if the points are on the same straight line\\n             */\\n            if (slope1 != getSlope(x, y, (float)coordinates[i][0],  (float)coordinates[i][1])) {\\n                return false;\\n            }"]]}
{"id": "261", "ref_c": [["int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize){\\n    int matrix[m][n], count=0;\\n    for(int i=0; i<m; i++){\\n        for(int j=0; j<n; j++)\\n            matrix[i][j]=0;\\n    }"], ["int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize){\\nint arr[m][n];\\nfor(int i=0;i<m;i++)\\n{\\n    for(int j=0;j<n;j++)\\n    arr[i][j]=0;\\n}"], ["int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize){\\n    int matrix[m][n], count=0;\\n    for(int i=0; i<m; i++){\\n        for(int j=0; j<n; j++)\\n            matrix[i][j]=0;\\n    }"]]}
{"id": "262", "ref_c": [["int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes) {\\n    int RowSize = gridSize, ColSize = gridColSize[0], totalSize = RowSize * ColSize, shift = k % totalSize;\\n    *returnSize = gridSize;\\n    *returnColumnSizes = gridColSize;\\n    if(shift == 0) return grid;\\n    \\n    int arridx = 0;\\n    int* arr = (int*) malloc(2 * totalSize * sizeof(int));\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            arr[arridx] = grid[i][j];\\n            arr[arridx + totalSize] = grid[i][j];\\n            arridx++;\\n        }"], ["int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n    for (int i = 0; i < gridSize; i++)\\n        *((*returnColumnSizes) + i) = *gridColSize;\\n\\n    if (k == gridSize * *gridColSize || (1 == gridSize && 1 == *gridColSize))\\n        return grid;\\n    \\n    k %= gridSize * *gridColSize;\\n    int *shifted = calloc(gridSize * *gridColSize, sizeof(int));\\n    int ptr = k;\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            *(shifted + ptr) = *(*(grid + i) + j);\\n            if (gridSize * *gridColSize == ++ptr)\\n                ptr = 0;\\n        }"], ["int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = gridSize;\\n    *returnColumnSizes = malloc(sizeof(int) * gridSize);\\n    for (int i = 0; i < gridSize; i++)\\n        (*returnColumnSizes)[i] = *gridColSize;\\n    \\n    if (gridSize * *gridColSize == k)\\n        return grid;\\n    \\n    int prev;\\n    for (int l = 0; l < k; l++) {\\n        for (int i = 0; i < gridSize; i++) {\\n            for (int j = 0; j < *gridColSize; j++) {\\n                if (i == 0 && j == 0) {\\n                    prev = grid[i][j];\\n                    grid[i][j] = grid[gridSize - 1][*gridColSize - 1];\\n                }"]]}
{"id": "263", "ref_c": [["int minTimeToVisitAllPoints(int** points, int pointsSize, int* pointsColSize) {\\n    int ans = 0;\\n    int n = pointsSize;\\n\\n    for (int i = 1; i < n; ++i) {\\n        int diffx = abs(points[i][0] - points[i - 1][0]);\\n        int diffy = abs(points[i][1] - points[i - 1][1]);\\n\\n        ans += diffx > diffy ? diffx : diffy;\\n    }"], ["int minTimeToVisitAllPoints(int** points, int pointsSize, int* pointsColSize) {\\n    int ans = 0;\\n    int n = pointsSize;\\n\\n    for (int i = 1; i < n; ++i) {\\n        int diffx = abs(points[i][0] - points[i - 1][0]);\\n        int diffy = abs(points[i][1] - points[i - 1][1]);\\n\\n        ans += diffx > diffy ? diffx : diffy;\\n    }"], ["int minTimeToVisitAllPoints(int** points, int pointsSize, int* pointsColSize) {\\n    int i=0;\\n    int current[2] = {points[0][0],points[0][1]}"]]}
{"id": "264", "ref_c": [["char * tictactoe(int** moves, int movesSize, int* movesColSize){\\n    int winCase[8] = {7, 7<<3, 7<<6, 0x124, 0x124>>1, 0x124>>2, 0x111, 0x54}"], ["char * tictactoe(int** moves, int movesSize, int* movesColSize){\\n    //this 0 ms problem bouta become a 0.0 ms problem\\n    if (movesSize<3){\\n        moves[0]=29113321536775504ll;//\"Pending\" (we have fun here)\\n        return moves;\\n    }"], ["char * tictactoe(int** moves, int movesSize, int* movesColSize){\\n    int winCase[8] = {7, 7<<3, 7<<6, 0x124, 0x124>>1, 0x124>>2, 0x111, 0x54}"]]}
{"id": "266", "ref_c": [["int subtractProductAndSum(int n){\\n    int sum=0,pro=1;\\n    while(n!=0)\\n    {\\n        sum+=n%10;\\n        pro*=n%10;\\n        n/=10;\\n    }"], ["int subtractProductAndSum(int n){\\nint rem,prod=1,sum=0;\\n       while(n!=0)\\n       {\\n        rem=n%10;\\n        prod=prod*rem;\\n        sum=sum+rem;\\n        n=n/10;\\n       }"], ["int subtractProductAndSum(int n)\\n{\\n    int r, p = 1, s = 0;\\n    while (n != 0)\\n    {\\n        r = n % 10;\\n        p = p * r;\\n        s = s + r;\\n        n = n / 10;\\n    }"]]}
{"id": "267", "ref_c": [["int findSpecialInteger(int* arr, int arrSize) {\\n\\n    int i = 0, j = 1;\\n\\n    while (j < arrSize) {\\n\\n        if (arr[i] != arr[j]) {\\n            i = j;\\n        }"], ["int findSpecialInteger(int* arr, int arrSize) {\\n    int temp = arrSize/4;\\n    for(int i=0; i<arrSize-temp; i++){\\n        if(arr[i] == arr[i+temp]) return arr[i];\\n    }"], ["int findSpecialInteger(int* arr, int arrSize) {\\n\\n    int i = 0, j = 1;\\n\\n    while (j < arrSize) {\\n\\n        if (arr[i] != arr[j]) {\\n            i = j;\\n        }"]]}
{"id": "268", "ref_c": [["int getDecimalValue(struct ListNode* head){\\n    int number = 0;\\n    int twos = 1;\\n    struct ListNode* p = head;\\n    while (p->next != NULL){\\n        p = p->next;\\n        twos *= 2;\\n    }"], ["int getDecimalValue(struct ListNode* head){\\n    int number = 0;\\n    int twos = 1;\\n    struct ListNode* p = head;\\n    while (p->next != NULL){\\n        p = p->next;\\n        twos *= 2;\\n    }"], ["int getDecimalValue(struct ListNode* head){\\n    int a[31]={0}"]]}
{"id": "269", "ref_c": [["int findNumbers(int* nums, int numsSize) {\\n    int c = 0;    \\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        c += (Log10(nums[i]) & 1);\\n    }"], ["int findNumbers(int* nums, int numsSize) {\\n    int ecount = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = 10; j <= 100000; j *= 100) {\\n            if (nums[i] >= j && nums[i] < j * 10) {\\n                ecount++;\\n            }"], ["int findNumbers(int* nums, int numsSize){\\n    int count1=0,num=0;\\nfor(int i=0;i<numsSize;i++){\\n    num=nums[i];\\n    int count=0;\\n     while(num>0){\\n         count++;\\n         num/=10;\\n     }"]]}
{"id": "270", "ref_c": [["int* replaceElements(int* arr, int arrSize, int* returnSize){\\n\\n    *returnSize = arrSize;\\n    int max=-1,temp;\\n    \\n\\n    for(int i=arrSize - 1;i >= 0;i--){\\n        if(arr[i]>max)\\n            temp = arr[i];\\n        arr[i]=max;\\n        max = temp;\\n    }"], ["int* replaceElements(int* arr, int arrSize, int* returnSize) {\\n    *returnSize = arrSize;\\n    int* result = malloc(*returnSize * sizeof(int));\\n\\n    int max = -1;\\n    int current;\\n    \\n    for (int i = *returnSize - 1; i >= 0; i--) {\\n        current = arr[i];\\n        result[i] = max;\\n        if (current > max) max = current;\\n    }"], ["int* replaceElements(int* arr, int arrSize, int* returnSize) \\n{\\n    *returnSize = arrSize;\\n    int lastVal = arr[arrSize - 1];\\n    arr[arrSize - 1] = -1;\\n    for(int i = arrSize - 2; i >= 0; i--)\\n    {\\n        int tmp = arr[i];\\n        arr[i] = (arr[i + 1] >= lastVal)? arr[i + 1] : lastVal;\\n        lastVal = tmp;\\n    }"]]}
{"id": "271", "ref_c": [["int* sumZero(int n, int* returnSize){\\n    * returnSize=n;\\n    int *p=(int*)malloc(n*sizeof(int));\\n    for(int i=0,j=n-1;i<=j;i++,j--){\\n        p[i]=-1*n;\\n        p[j]=n;\\n        if(i==j) p[i]=0;\\n        n--;\\n    }"], ["int* sumZero(int n, int* returnSize){\\n    int*arr= malloc(n*sizeof(int));\\n    *returnSize = n;\\n    for(int i = 0;i<n/2;i++){\\n        arr[i] = i+1;\\n        arr[n/2 + i] = (-1)*(i+1);\\n    }"], ["int* sumZero(int n, int* returnSize){\\n    * returnSize=n;\\n    int *p=(int*)malloc(n*sizeof(int));\\n    for(int i=0,j=n-1;i<=j;i++,j--){\\n        p[i]=-1*n;\\n        p[j]=n;\\n        if(i==j) p[i]=0;\\n        n--;\\n    }"]]}
{"id": "272", "ref_c": [["char * freqAlphabets(char * s){\\n    size_t i = 0, j = 0, c;\\n    while (s[i]) {\\n        c = s[i] - \\'0\\';        \\n        if (s[i] && s[i + 1] && s[i + 2] == \\'#\\')\\n            c = c * 10 + s[i + 1] - \\'0\\';\\n        i += c >= 10 ? 3 : 1;\\n        s[j++] = \\'a\\' + c - 1;       \\n    }"], ["char * freqAlphabets(char * s){\\n    size_t i = 0, j = 0, c;\\n    while (s[i]) {\\n        c = s[i] - \\'0\\';        \\n        if (s[i] && s[i + 1] && s[i + 2] == \\'#\\')\\n            c = c * 10 + s[i + 1] - \\'0\\';\\n        i += c >= 10 ? 3 : 1;\\n        s[j++] = \\'a\\' + c - 1;       \\n    }"], ["char * freqAlphabets(char * s){\\n    size_t i = 0, j = 0, c;\\n    while (s[i]) {\\n        c = s[i] - \\'0\\';        \\n        if (s[i] && s[i + 1] && s[i + 2] == \\'#\\')\\n            c = c * 10 + s[i + 1] - \\'0\\';\\n        i += c >= 10 ? 3 : 1;\\n        s[j++] = \\'a\\' + c - 1;       \\n    }"]]}
{"id": "273", "ref_c": [["int* decompressRLElist(int* nums, int numsSize, int* returnSize){\\n    int prev = 0; *returnSize = 0;\\n    \\n    for (int i = 0; i < numsSize; i += 2) *returnSize += nums[i];\\n    int* returnNums = (int*) malloc(sizeof(int) * (*returnSize));\\n    \\n    for (int i = 0; i < numsSize; i += 2) for (int j = 0; j < nums[i]; j++) returnNums[prev++] = nums[i + 1];\\n    return returnNums;\\n}"], ["int* decompressRLElist(int* nums, int numsSize, int* returnSize) {\\n    int output_size = 0;\\n    for(int i = 0; i < numsSize; i=i+2){\\n        output_size += nums[i];\\n    }"], ["int* decompressRLElist(int* nums, int numsSize, int* returnSize) {\\n    int output_size = 0;\\n    for(int i = 0; i < numsSize; i=i+2){\\n        output_size += nums[i];\\n    }"]]}
{"id": "274", "ref_c": [["int* getNoZeroIntegers(int n, int* returnSize)\\n{\\n        *returnSize=2;\\n        int *a=malloc(sizeof(int)*(*returnSize));\\n        int i=1,j=n-1;\\n        while(i<=j)\\n        {\\n                if(check0(i) && check0(j))\\n                {\\n                \\n                        a[0]=i;\\n                        a[1]=j;\\n                        break;\\n                }"], ["int* getNoZeroIntegers(int n, int* returnSize){\\n    int i;\\n    int *output = (int*)malloc(2 * sizeof(int));\\n    *returnSize = 2;\\n    \\n    char s1[6], s2[6];\\n    for(i = 1; i <= n / 2; i++){\\n        // sprintf() can convert any data type to a string. \\n        sprintf(s1, \"%d\", i);\\n        sprintf(s2, \"%d\", n - i);\\n        // strchr(str, ch) returns a pointer to the first ch character (if present) in str. Else, return NULL. \\n        if(!strchr(s1, \\'0\\') && !strchr(s2, \\'0\\')){\\n            output[0] = i;\\n            output[1] = n - i;\\n            break;\\n        }"], ["int* getNoZeroIntegers(int n, int* returnSize)\\n{\\n        *returnSize=2;\\n        int *a=malloc(sizeof(int)*(*returnSize));\\n        int i=1,j=n-1;\\n        while(i<=j)\\n        {\\n                if(check0(i) && check0(j))\\n                {\\n                \\n                        a[0]=i;\\n                        a[1]=j;\\n                        break;\\n                }"]]}
{"id": "275", "ref_c": [["int maximum69Number (int num) {\\n        string s=to_string(num);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'6\\'){\\n                s[i]=\\'9\\';\\n                break;\\n            }"], ["int maximum69Number (int num){\\n    int diff = 10000 - num;\\n    if (num % 10 == 6) diff--;\\n\\n    int POW10 = 1000;\\n    for (int i = 3; i >= 0; i--) {\\n        if ((diff / POW10) % 10 & 2) return 3 * POW10 + num;\\n        POW10 /= 10;\\n    }"], ["int maximum69Number (int num) {\\nint i;\\nint* arr;\\nint a = ceil(log(num)/log(10));\\narr = malloc(a * sizeof(int));\\nint cpy = num;\\ni = a -1;\\nwhile (cpy > 0) {\\narr[i] = cpy % 10;\\ncpy/=10;\\ni--;\\n}"]]}
{"id": "277", "ref_c": [["int* arrayRankTransform(int* arr, int arrSize, int* returnSize){\\n    *returnSize = arrSize;  \\n    if (arrSize == 0)\\n        return arr;\\n\\n    int* arrInd = malloc(arrSize * sizeof(int)), i;\\n    int* sorted = malloc(arrSize * sizeof(int));\\n    for (i = 0; i < arrSize; i++){\\n        arrInd[i] = i;\\n        sorted[i] = arr[i];\\n    }"], ["int* arrayRankTransform(int* arr, int arrSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  arr,\\n     *  arrSize\\n     */\\n\\n    item_t *item;\\n    int *ans;\\n\\n    *returnSize = arrSize;\\n\\n    if (arrSize == 0) {\\n        return NULL;\\n    }"], ["int* arrayRankTransform(int* arr, int arrSize, int* returnSize){\\n    *returnSize = arrSize;  \\n    if (arrSize == 0)\\n        return arr;\\n\\n    int* arrInd = malloc(arrSize * sizeof(int)), i;\\n    int* sorted = malloc(arrSize * sizeof(int));\\n    for (i = 0; i < arrSize; i++){\\n        arrInd[i] = i;\\n        sorted[i] = arr[i];\\n    }"]]}
{"id": "278", "ref_c": [["int removePalindromeSub(char * s){\\n    \\n    if(strlen(s) ==0) return 0;\\n    \\n    int i=0; \\n    int j=strlen(s)-1;\\n    \\n    while(i<j){\\n        \\n        if(s[i]!=s[j]) return 2;\\n        \\n        i++;\\n        j--;\\n    }"], ["int removePalindromeSub(char * s){\\n        int len=strlen(s);\\n        if(len==0)return 0;\\n        int i=0,j=len-1;\\n        while(i<j){\\n                if(s[i++]!=s[j--]) return 2;\\n        }"], ["int removePalindromeSub(char * s){\\n        int len=strlen(s);\\n        if(len==0)return 0;\\n        int i=0,j=len-1;\\n        while(i<j){\\n                if(s[i++]!=s[j--]) return 2;\\n        }"]]}
{"id": "279", "ref_c": [["int* kWeakestRows(int** mat, int matSize, int* matColSize, int k, int* returnSize) {\\n    struct RowInfo* rows = (struct RowInfo*)malloc(matSize * sizeof(struct RowInfo));\\n    for (int i = 0; i < matSize; i++) {\\n        rows[i].index = i;\\n        rows[i].count = 0;\\n        for (int j = 0; j < *matColSize; j++) {\\n            rows[i].count += mat[i][j];\\n        }"], ["int* kWeakestRows(int** mat, int matSize, int* matColSize, int k, int* returnSize){\\n    int *p=(int*)malloc((matSize+1)*sizeof(int)),i,j,s,*q=(int*)malloc((matSize+1)*sizeof(int));\\n    for(i=0;i<matSize;i++){\\n        for(j=0;j<matColSize[0] && mat[i][j];j++);\\n        p[i]=j; \\n        q[i]=i;\\n    }"], ["int* kWeakestRows(int** mat, int matSize, int* matColSize, int k, int* returnSize) {\\n    *returnSize = k;\\n    struct pair* arr = (struct pair*) malloc(matSize * sizeof(struct pair));\\n    for(int i = 0; i < matSize; i++) {\\n        int tmp = 0;\\n        for(int j = 0; j < matColSize[0]; j++) {\\n            tmp = (mat[i][j] == 1) ? tmp+1 : tmp;\\n        }"]]}
{"id": "280", "ref_c": [["int numberOfSteps(int num){\\n    int s=0;\\n    while(num!=0){\\n        if(num%2==0)\\n            num/=2;\\n        else\\n            num-=1;\\n        s++;\\n    }"], ["int numberOfSteps(int num) {\\n        int c=0 ;\\n        return reduce(num ,c) ;\\n        }", "int numberOfSteps(int num) {\\n        int count=0 ;\\n        while(num>0)\\n        {\\n            if(num%2==0)\\n            {\\n                num=num/2 ;\\n                count++ ;\\n            }"], ["int numberOfSteps(int num) {\\n        int c=0 ;\\n        return reduce(num ,c) ;\\n        }", "int numberOfSteps(int num) {\\n        int count=0 ;\\n        while(num>0)\\n        {\\n            if(num%2==0)\\n            {\\n                num=num/2 ;\\n                count++ ;\\n            }"]]}
{"id": "281", "ref_c": [["bool checkIfExist(int* arr, int arrSize){\\n    for(int i=0;i<arrSize;i++){\\n        for(int j=i+1;j<arrSize;j++){\\n            if(*(arr+i)*2==*(arr+j) || *(arr+i)==*(arr+j)*2)\\n                return true;\\n        }"], ["bool checkIfExist(int* arr, int arrSize){\\n    int* hash = (int*)calloc(2001, sizeof(int));/* -1000 - 0 - 1000 */\\n    int curr, process;\\n    for(int i = 0; i < arrSize; i++)\\n    {\\n        curr = arr[i];\\n        \\n        if(curr & 1) /* odd */\\n        {\\n            process = curr * 2;\\n            if((process <= 1000) && (process >= -1000) && hash[1000+process])\\n                return true;\\n        }"], ["bool checkIfExist(int* arr, int arrSize){\\n    short* n = (short*) calloc(1001,sizeof(short));\\n    short* p = (short*) calloc(1001,sizeof(short));\\n    for(int i=0;i<arrSize;i++){\\n        if(arr[i]>=0) p[arr[i]]++;\\n        else n[-arr[i]]++;\\n    }"]]}
{"id": "282", "ref_c": [["int countNegatives(int** grid, int gridSize, int* gridColSize){\\n    /* sorted so used binary search */\\n    int ans = 0;\\n    for(int i = 0; i < gridSize; i++){\\n        ans += searchCnt(grid[i], *gridColSize);\\n    }"], ["int countNegatives(int** grid, int gridSize, int* gridColSize){\\n    /*\\n        if num[rx,cx] is negative , all num[rx, cx : n] will be negative\\n        and all num[rx:n, cx] will be negative\\n\\n         4  3 2 -1 -2 -3 -4 \\n         3  2 1 -1 -2 -3 -4\\n         1  1 -1 -2 -3 -4 -5\\n        -1 -1 -2 -3 -4 -5 -6\\n    */\\n    int rows = gridSize;\\n    int cols = gridColSize[0];\\n    \\n    // first row\\n    int cidx = bs_func(grid[0],cols);\\n    int count = (cols - cidx) * rows;\\n    \\n    for(int r = 1; r < rows; r++)\\n    {\\n        int pidx = bs_func(grid[r], cidx);\\n\\n        if(pidx < cidx) // another colum with negative values\\n            count += (rows - r)*(cidx - pidx);\\n        \\n        if(pidx == 0) // all rows after this have negative values\\n            break;\\n\\n        cidx = pidx;\\n\\n    }"], ["int countNegatives(int** grid, int gridSize, int* gridColSize){\\n    /*\\n        if num[rx,cx] is negative , all num[rx, cx : n] will be negative\\n        and all num[rx:n, cx] will be negative\\n\\n         4  3 2 -1 -2 -3 -4 \\n         3  2 1 -1 -2 -3 -4\\n         1  1 -1 -2 -3 -4 -5\\n        -1 -1 -2 -3 -4 -5 -6\\n    */\\n    int rows = gridSize;\\n    int cols = gridColSize[0];\\n    \\n    // first row\\n    int cidx = bs_func(grid[0],cols);\\n    int count = (cols - cidx) * rows;\\n    \\n    for(int r = 1; r < rows; r++)\\n    {\\n        int pidx = bs_func(grid[r], cidx);\\n\\n        if(pidx < cidx) // another colum with negative values\\n            count += (rows - r)*(cidx - pidx);\\n        \\n        if(pidx == 0) // all rows after this have negative values\\n            break;\\n\\n        cidx = pidx;\\n\\n    }"]]}
{"id": "283", "ref_c": [["int* sortByBits(int* arr, int arrSize, int* returnSize) {\\n    qsort(arr, arrSize, sizeof(int), compare);\\n    *returnSize = arrSize;\\n    return arr;\\n}"], ["int* sortByBits(int* arr, int arrSize, int* returnSize) {\\n    qsort(arr, arrSize, sizeof(int), compare);\\n    *returnSize = arrSize;\\n    return arr;\\n}"], ["int* sortByBits(int* arr, int arrSize, int* returnSize) {\\n    // Allocate memory for the sorted array\\n    int* sortedArr = (int*)malloc(arrSize * sizeof(int));\\n\\n    if (sortedArr == NULL) {\\n        // Memory allocation failed\\n        *returnSize = 0; // Set the size to 0 to indicate an error\\n        return NULL;\\n    }"]]}
{"id": "284", "ref_c": [["int daysBetweenDates(char * date1, char * date2){\\n    int *date1D=dateToArr(date1);\\n    int *date2D=dateToArr(date2);\\n    if(differentDay(date1D,date2D))return abs(date1D[2]-date2D[2]);\\n    if(compairDates(date1D,date2D))swap(&date1D,&date2D);\\n    int days=0;\\n    days-=getDays(date1D);\\n    while(date1D[0]<date2D[0])days+=getDaysYear(date1D[0]++);\\n    days+=getDays(date2D);\\n   \\n   return days;\\n}"], ["int daysBetweenDates(char * date1, char * date2){\\n    return abs( convertDateToOrdinal(date2) - convertDateToOrdinal(date1) );\\n}"], ["int daysBetweenDates(char * date1, char * date2){\\n    int *date1D=dateToArr(date1);\\n    int *date2D=dateToArr(date2);\\n    if(differentDay(date1D,date2D))return abs(date1D[2]-date2D[2]);\\n    if(compairDates(date1D,date2D))swap(&date1D,&date2D);\\n    int days=0;\\n    days-=getDays(date1D);\\n    while(date1D[0]<date2D[0])days+=getDaysYear(date1D[0]++);\\n    days+=getDays(date2D);\\n   \\n   return days;\\n}"]]}
{"id": "285", "ref_c": [["int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize)\\n{   \\n    int*arr = malloc(numsSize*sizeof(int));\\n    *returnSize = numsSize;\\n    int i,j,c;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        c =0;\\n        for(j=0;j<numsSize;j++)\\n        {\\n            if(nums[i]>nums[j])\\n            c++;\\n        }"], ["int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){\\n    \\n    int *answer = (int *)malloc(sizeof(int) * numsSize); \\n    int i = 0, j = 0;\\n    \\n    *returnSize = numsSize;\\n    \\n    for(i=0; i<numsSize; i++) {\\n        answer[i] = 0;\\n    }"], ["int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){\\n    \\n    int *answer = (int *)malloc(sizeof(int) * numsSize); \\n    int i = 0, j = 0;\\n    \\n    *returnSize = numsSize;\\n    \\n    for(i=0; i<numsSize; i++) {\\n        answer[i] = 0;\\n    }"]]}
{"id": "286", "ref_c": [["char * sortString(char * s){\\n    int dict[26]={0}"], ["char * sortString(char * s){\\n    int dict[26]={0}"], ["char * sortString(char * s){\\n    int dict[26]={0}"]]}
{"id": "287", "ref_c": [["char * generateTheString(int n){\\n    char *res=(char*)malloc(sizeof(char)*(n+1));\\n    int num1=0;\\n    int num2=0;\\n    if(n%2==1){ // odd \\n        num1=n;\\n    }"], ["char * generateTheString(int n){\\n//     char *str = (char *)malloc(sizeof(char *)*(n+1));\\n//     str[n] = \\'\\\\n\\';\\n   \\n//     int i=0;\\n//     if(n%2 == 0){\\n//         while(n>0){\\n//         str[i] = \\'a\\';\\n//         n--;\\n//         }", "char * generateTheString(int n){\\n    char* ans = malloc( ( n + 1 )* sizeof(char) ) ;\\n    ans[n] = \\'\\\\0\\' ;\\n    if(n % 2){\\n        for(int i = 0; i < n ;i++){\\n            ans[i] = \\'a\\' ;\\n        }"], ["char * generateTheString(int n){\\n    char *result = (char *)malloc((n+1) * sizeof(char));\\n    if(n % 2 == 1)\\n        for(int i = 0; i < n; i++)\\n            result[i] = \\'a\\';\\n    else{\\n        for(int i = 0; i < n-1; i++)\\n            result[i] = \\'a\\';\\n        result[n-1] = \\'b\\';\\n    }"]]}
{"id": "290", "ref_c": [["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    int *lucky;\\n    int i,j,k,x,check;\\n    int minRow,maxCol;\\n    coordinates cor[matrixSize];\\n    \\n    lucky = (int *)malloc(sizeof(int) * matrixSize);\\n    \\n    k = 0;\\n    for(i = 0; i < matrixSize; i++){\\n        minRow = INT_MAX;\\n        for(j = 0; j < *matrixColSize; j++){\\n            if(matrix[i][j] < minRow){\\n                minRow = matrix[i][j];\\n                cor[i].row = i;\\n                cor[i].col = j;\\n            }"], ["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\\n     int *ans=malloc(sizeof(int)*50);\\n     int min;\\n     int max;\\n     int idx;\\n     int m=0;\\n     for(int i=0;i<matrixSize;i++)\\n     {\\n         min=1000000;\\n         for(int j=0;j<(*matrixColSize);j++)\\n         {\\n             if(min>matrix[i][j]) \\n             {\\n                 min=matrix[i][j];\\n                 idx=j;\\n             }"], ["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    int* returnValue = (int*)malloc(matrixSize * sizeof(int));\\n    int returnValueIndex = 0;\\n\\n    // for each row...\\n    int columnIndex = 0;\\n    int rowIndex = 0;\\n    for (int row = 0; row < matrixSize; row++) {\\n        // find the minimum value on the row and return it\\'s column index...\\n        columnIndex = matrix_minimum_in_row(matrix, row, *matrixColSize);\\n\\n        // find the maximum value on the column and return it\\'s row index...\\n        rowIndex = matrix_maximum_in_column(matrix, matrixSize, columnIndex);\\n\\n        // ...remember the solutions\\n        if (row == rowIndex) {\\n            returnValue[returnValueIndex] = matrix[rowIndex][columnIndex];\\n            returnValueIndex++;\\n        }"]]}
{"id": "291", "ref_c": [["int findTheDistanceValue(int* arr1, int arr1Size, int* arr2, int arr2Size, int d){\\n    int count=0;\\n    int i,j;\\n    for(i=0;i<arr1Size;i++){\\n        for(j=0;j<arr2Size;j++)\\n            if(abs(arr1[i]-arr2[j])<=d)\\n                break;\\n        if(j==arr2Size)\\n            count++;\\n    }"], ["int findTheDistanceValue(int* arr1, int arr1Size, int* arr2, int arr2Size, int d){\\n    int count=0;\\n    int i,j;\\n    for(i=0;i<arr1Size;i++){\\n        for(j=0;j<arr2Size;j++)\\n            if(abs(arr1[i]-arr2[j])<=d)\\n                break;\\n        if(j==arr2Size)\\n            count++;\\n    }"], ["int findTheDistanceValue(int* arr1, int arr1Size, int* arr2, int arr2Size, int d){\\n    int count=0;\\n    int i,j;\\n    for(i=0;i<arr1Size;i++){\\n        for(j=0;j<arr2Size;j++)\\n            if(abs(arr1[i]-arr2[j])<=d)\\n                break;\\n        if(j==arr2Size)\\n            count++;\\n    }"]]}
{"id": "292", "ref_c": [["int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize) {\\n\\n    int *output = (int *)malloc(numsSize * (sizeof(int)));\\n    for(int i=0; i<numsSize; i++){\\n        output[i] = -1;\\n    }"], ["int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize){\\n    int* arr = (int*)malloc(numsSize*sizeof(int));\\n    *returnSize = numsSize;\\n    for(int i = 0 ; i < numsSize ; i++){\\n        arr[i] = -1;\\n    }"], ["int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize) {\\n\\n    int *output = (int *)malloc(numsSize * (sizeof(int)));\\n    for(int i=0; i<numsSize; i++){\\n        output[i] = -1;\\n    }"]]}
{"id": "293", "ref_c": [["int findLucky(int* arr, int arrSize) {\\n\\n int   b[501]={0}"], ["int findLucky(int* arr, int arrSize) {\\n\\n int   b[501]={0}"], ["int findLucky(int* arr, int arrSize) {\\n\\n int   b[501]={0}"]]}
{"id": "294", "ref_c": [["int countLargestGroup(int n) {\\n        map<int,int>p;\\n        for(int i=1;i<=n;i++){\\n            int k=get_digit_sum(i);\\n            p[k]++;\\n        }"], ["int countLargestGroup(int n){\\n    int sizeGroups[37] = {0}", "int countLargestGroup(int n){\\n    int sizeGroups[37] = {0}"], ["int countLargestGroup(int n) {\\n    if (n < 10) return n;\\n    int max = 0, cnt = 0;\\n    int* arr = (int*) calloc(37, sizeof(int));\\n    for (int i = 1; i <= n; i++) {\\n        int idx = check(i, &max);\\n        arr[idx]++;\\n        cnt = MAX(cnt, arr[idx]);\\n    }"]]}
{"id": "295", "ref_c": [["int* minSubsequence(int* nums, int numsSize, int* returnSize)\\n{\\n    int s1=0,s2=0,s=0,i=0;\\n    for(i=0;i<numsSize-1;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]<=nums[j])\\n            {\\n                s=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=s;\\n            }"], ["int* minSubsequence(int* nums, int numsSize, int* returnSize)\\n{\\n    int s1=0,s2=0,s=0,i=0;\\n    for(i=0;i<numsSize-1;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]<=nums[j])\\n            {\\n                s=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=s;\\n            }"], ["int* minSubsequence(int* nums, int numsSize, int* returnSize)\\n{\\n    int s1=0,s2=0,s=0,i=0;\\n    for(i=0;i<numsSize-1;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]<=nums[j])\\n            {\\n                s=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=s;\\n            }"]]}
{"id": "297", "ref_c": [["char ** stringMatching(char ** words, int wordsSize, int* returnSize){\\n    char **a = malloc(sizeof(char *[wordsSize])), **w = words;\\n    int k = 0;\\n    for (int i = 0 ; i < wordsSize ; i++)\\n        for (int j = i + 1, x, y ; j < wordsSize ; j++)\\n                if (w[j] && w[i] && ((x = !!strstr(w[i], w[j])) || (y = !!strstr(w[j], w[i])))) {\\n                    a[k++] = x ? w[j] : w[i];\\n                    x ? w[j] = NULL : (w[i] = NULL);\\n                }"], ["char ** stringMatching(char ** words, int wordsSize, int* returnSize){\\n    char **a = malloc(sizeof(char *[wordsSize])), **w = words;\\n    int k = 0;\\n    for (int i = 0 ; i < wordsSize ; i++)\\n        for (int j = i + 1, x, y ; j < wordsSize ; j++)\\n                if (w[j] && w[i] && ((x = !!strstr(w[i], w[j])) || (y = !!strstr(w[j], w[i])))) {\\n                    a[k++] = x ? w[j] : w[i];\\n                    x ? w[j] = NULL : (w[i] = NULL);\\n                }"], ["char ** stringMatching(char ** words, int wordsSize, int* returnSize){\\n    int i,j,index = 0;;\\n    char **arr;\\n    arr = (char **)malloc(sizeof(char *) * (wordsSize-1));\\n    \\n    for(i = 0; i < wordsSize-1; i++)\\n        arr[i] = (char *)malloc(sizeof(char) * 31);\\n    \\n    i = 0;\\n    while(i < wordsSize){\\n        j = 0;\\n        while(j < wordsSize){\\n            while(j < wordsSize && strlen(words[i]) <= strlen(words[j]))\\n                j++;\\n            if(j < wordsSize && isValid(words[i],words[j])){\\n                if(index != 0){\\n                    if(isUnique(arr,index,words[j]))\\n                        arr[index++] = words[j];       \\n                }"]]}
{"id": "298", "ref_c": [["int minStartValue(int* nums, int numsSize) \\n{\\n  int prefix_sum = 0, min_prefix_sum = INT_MAX;\\n  for(int i = 0; i < numsSize; i++)\\n  {\\n    prefix_sum += nums[i];\\n    if(min_prefix_sum > prefix_sum)\\n    {\\n      min_prefix_sum = prefix_sum;\\n    }"], ["int minStartValue(int* nums, int numsSize) {\\n    int left = 1; \\n    int sum = 0;\\n    int min = INT_MAX;\\n    for(int i = 0; i < numsSize; i++) {\\n       sum += nums[i];\\n       if(min > sum) {\\n           min = sum;\\n       }"], ["int minStartValue(int* nums, int numsSize) \\n{\\n  int prefix_sum = 0, min_prefix_sum = INT_MAX;\\n  for(int i = 0; i < numsSize; i++)\\n  {\\n    prefix_sum += nums[i];\\n    if(min_prefix_sum > prefix_sum)\\n    {\\n      min_prefix_sum = prefix_sum;\\n    }"]]}
{"id": "299", "ref_c": [["char * reformat(char * s){\\n    int n[64] = { 0 }"], ["char * reformat(char * s){\\n    if(strlen(s) == 1){\\n        return s;\\n    }"], ["char * reformat(char * s){\\n    int n[64] = { 0 }"]]}
{"id": "300", "ref_c": ["\nint maxScore(char* s) \n{\n  int len_s = strlen(s), sum_zeros = 0, sum_ones = 0, score, max_score = 0;\n  for(int i = 0; i < len_s; i++)\n  {\n      sum_ones += s[i] - '0';\n  }\n  for(int i = 0; i < len_s - 1; i++)\n  {\n      sum_zeros += (s[i] - '0' + 1) % 2;\n      sum_ones -= s[i] - '0';\n      score = sum_zeros + sum_ones;\n      if(max_score < score)\n      {\n          max_score = score;\n      }\n  }\n  return max_score;\n}\n", "\nint maxScore(char* s) \n{\n  int len_s = strlen(s), sum_zeros = 0, sum_ones = 0, score, max_score = 0;\n  for(int i = 0; i < len_s; i++)\n  {\n      sum_ones += s[i] - '0';\n  }\n  for(int i = 0; i < len_s - 1; i++)\n  {\n      sum_zeros += (s[i] - '0' + 1) % 2;\n      sum_ones -= s[i] - '0';\n      score = sum_zeros + sum_ones;\n      if(max_score < score)\n      {\n          max_score = score;\n      }\n  }\n  return max_score;\n}\n", "\nint maxScore(char* s) \n{\n  int len_s = strlen(s), sum_zeros = 0, sum_ones = 0, score, max_score = 0;\n  for(int i = 0; i < len_s; i++)\n  {\n      sum_ones += s[i] - '0';\n  }\n  for(int i = 0; i < len_s - 1; i++)\n  {\n      sum_zeros += (s[i] - '0' + 1) % 2;\n      sum_ones -= s[i] - '0';\n      score = sum_zeros + sum_ones;\n      if(max_score < score)\n      {\n          max_score = score;\n      }\n  }\n  return max_score;\n}\n"]}
{"id": "301", "ref_c": [["bool* kidsWithCandies(int* candies, int candiesSize, int extraCandies, int* returnSize){\\n    bool* result = (bool*)malloc(sizeof(bool)*candiesSize);\\n    *returnSize = candiesSize;\\n    int greatestAmount_WithoutExtra = 0;\\n    int greatestCandiesAmount_CurrKid = 0;\\n    int maxValue_Without_ExtraCandies = candies[0];\\n    for (int i = 1; i < candiesSize; i++) { // first for loop to compute the max value without any extra candies in the candies array\\n        if (candies[i] > maxValue_Without_ExtraCandies) {\\n            maxValue_Without_ExtraCandies = candies[i];\\n        }"], ["bool* kidsWithCandies(int* candies, int candiesSize, int extraCandies, int* returnSize){\\n    bool* result = (bool*)malloc(sizeof(bool)*candiesSize);\\n    *returnSize = candiesSize;\\n    int greatestAmount_WithoutExtra = 0;\\n    int greatestCandiesAmount_CurrKid = 0;\\n    int maxValue_Without_ExtraCandies = candies[0];\\n    for (int i = 1; i < candiesSize; i++) { // first for loop to compute the max value without any extra candies in the candies array\\n        if (candies[i] > maxValue_Without_ExtraCandies) {\\n            maxValue_Without_ExtraCandies = candies[i];\\n        }"], ["bool* kidsWithCandies(int* candies, int candiesSize, int extraCandies, int* returnSize){\\n    bool* result = (bool*)malloc(sizeof(bool)*candiesSize);\\n    *returnSize = candiesSize;\\n    int greatestAmount_WithoutExtra = 0;\\n    int greatestCandiesAmount_CurrKid = 0;\\n    int maxValue_Without_ExtraCandies = candies[0];\\n    for (int i = 1; i < candiesSize; i++) { // first for loop to compute the max value without any extra candies in the candies array\\n        if (candies[i] > maxValue_Without_ExtraCandies) {\\n            maxValue_Without_ExtraCandies = candies[i];\\n        }"]]}
{"id": "302", "ref_c": ["\nchar* destCity(char*** paths, int pathsSize, int* pathsColSize) {\n    char* ris = (char*)malloc(100 * sizeof(char));\n    strcpy(ris, paths[0][1]); \n\n    for (int i = 1; i < pathsSize; i++) {\n        if (strcmp(ris, paths[i][0]) == 0) {\n            strcpy(ris, paths[i][1]);\n            i=0;\n        }\n    }\n    return ris;\n}\n", "\nchar* destCity(char*** paths, int pathsSize, int* pathsColSize) {\n    char* ris = (char*)malloc(100 * sizeof(char));\n    strcpy(ris, paths[0][1]); \n\n    for (int i = 1; i < pathsSize; i++) {\n        if (strcmp(ris, paths[i][0]) == 0) {\n            strcpy(ris, paths[i][1]);\n            i=0;\n        }\n    }\n    return ris;\n}\n", "\nchar* destCity(char*** paths, int pathsSize, int* pathsColSize) {\n    char* ris = (char*)malloc(100 * sizeof(char));\n    strcpy(ris, paths[0][1]); \n\n    for (int i = 1; i < pathsSize; i++) {\n        if (strcmp(ris, paths[i][0]) == 0) {\n            strcpy(ris, paths[i][1]);\n            i=0;\n        }\n    }\n    return ris;\n}\n"]}
{"id": "303", "ref_c": [["bool kLengthApart(int* nums, int numsSize, int k){\\nint count=k;\\nfor(int i=0;i<numsSize;i++){\\n    if(nums[i]==1){\\n        if(count<k){\\n            return false;\\n        }"], ["bool kLengthApart(int* nums, int numsSize, int k){\\n\\t\\tint dist = k;\\n\\t\\tfor(int i = 0; i < numsSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif (nums[i] == 0) ++dist;\\n\\t\\t\\telse if (dist < k) return false;\\n\\t\\t\\telse dist = 0;\\n\\t\\t}"], ["bool kLengthApart(int* nums, int numsSize, int k){\\n\\t\\tint dist = k;\\n\\t\\tfor(int i = 0; i < numsSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif (nums[i] == 0) ++dist;\\n\\t\\t\\telse if (dist < k) return false;\\n\\t\\t\\telse dist = 0;\\n\\t\\t}"]]}
{"id": "304", "ref_c": [["int maxPower(char * s){\\n    if(strlen(s)==1)\\n    {\\n        return 1;\\n    }"], ["int maxPower(char * s){\\n    int curr_pow=1, max_pow=1;\\n    for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n        if(s[i] == s[i+1])\\n            curr_pow++;\\n        else{\\n            max_pow=(curr_pow>max_pow)?curr_pow:max_pow;\\n            curr_pow=1;\\n        }"], ["int maxPower(char * s){\\n    if(strlen(s)==1)\\n    {\\n        return 1;\\n    }"]]}
{"id": "305", "ref_c": [["int busyStudent(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int queryTime) {\\n    int result=0;\\n    for(int i=0;i<startTimeSize;i++){\\n        if(queryTime>=*(startTime+i) && queryTime<=*(endTime+i)){\\n            result++;\\n        }"], ["int busyStudent(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int queryTime) {\\n    int i,count=0;\\n    for(i=0;i< startTimeSize && i< endTimeSize;i++)\\n    {\\n        if(queryTime>=startTime[i] && queryTime <=endTime[i])\\n            count++;\\n    }"], ["int busyStudent(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int queryTime) {\\n    int result=0;\\n    for(int i=0;i<startTimeSize;i++){\\n        if(queryTime>=*(startTime+i) && queryTime<=*(endTime+i)){\\n            result++;\\n        }"]]}
{"id": "306", "ref_c": [["int isPrefixOfWord(char * sentence, char * searchWord){\\nchar* words[1000];\\nint start=0,end=0,x=0;\\nfor(start=0,end=0;;end++){\\nif(sentence[end]==\\' \\'||sentence[end]==0){\\nwords[x++]=(&sentence[start]);\\nif(sentence[end]!=0){\\n    start=end+1;\\n    sentence[end]=0;\\n}"], ["int isPrefixOfWord(char * sentence, char * searchWord){\\nchar* words[1000];\\nint start=0,end=0,x=0;\\nfor(start=0,end=0;;end++){\\nif(sentence[end]==\\' \\'||sentence[end]==0){\\nwords[x++]=(&sentence[start]);\\nif(sentence[end]!=0){\\n    start=end+1;\\n    sentence[end]=0;\\n}"], ["int isPrefixOfWord(char * sentence, char * searchWord){\\n    int wordIdx = 1;\\n    \\n    char * searchPtr;\\n    \\n    while(*sentence != \\'\\\\0\\'){\\n        searchPtr = searchWord;\\n        \\n        while(*sentence == *searchPtr && *searchPtr != \\'\\\\0\\'){\\n            ++sentence;\\n            ++searchPtr;\\n        }"]]}
{"id": "307", "ref_c": [["bool canBeEqual(int* target, int targetSize, int* arr, int arrSize) {\\n        \\n    bool possible = true;\\n    int resArr[arrSize];\\n\\n    //initialize all values in reservedIndex to 0\\n    for(int i = 0; i < arrSize; i++){\\n        resArr[i] = 0;\\n    }"], ["bool canBeEqual(int* target, int targetSize, int* arr, int arrSize){\\n    int *map=calloc(1001,sizeof(int));\\n    for(int i=0;i<targetSize;i++){\\n        map[target[i]]++;\\n        map[arr[i]]--;\\n    }"], ["bool canBeEqual(int* target, int targetSize, int* arr, int arrSize){\\n    int *map=calloc(1001,sizeof(int));\\n    for(int i=0;i<targetSize;i++){\\n        map[target[i]]++;\\n        map[arr[i]]--;\\n    }"]]}
{"id": "308", "ref_c": [["int maxProduct(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    int x = nums[numsSize - 1];\\n    int y = nums[numsSize - 2];\\n\\n    return (x - 1) * (y - 1);\\n}", "int maxProduct(int* nums, int numsSize) {\\n    int biggest = INT_MIN; // Variable to store the largest number in \\'nums\\'\\n    int secondBiggest = INT_MIN; // Variable to store the second largest number in \\'nums\\'\\n\\n    for (int i = 0; i < numsSize; i++) { // Iterating through each number in \\'nums\\'\\n        if (nums[i] > biggest) {\\n            // If the current number is greater than \\'biggest\\',\\n            // update \\'secondBiggest\\' and \\'biggest\\'\\n            secondBiggest = biggest;\\n            biggest = nums[i];\\n        }"], ["int maxProduct(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    return (nums[numsSize - 2] - 1) * (nums[numsSize - 1] - 1);\\n}"], ["int maxProduct(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    return (nums[numsSize - 2] - 1) * (nums[numsSize - 1] - 1);\\n}"]]}
{"id": "309", "ref_c": [["int* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    int start=0;\\n    int mid=n;\\n    int* shuf=(int*)malloc(2*n*sizeof(int));\\n    int a=0;\\n    int i=0;\\n    while(i<n){\\n        shuf[a++]=nums[i++];\\n        shuf[a++]=nums[mid++];\\n    }"], ["int* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    int start=0;\\n    int mid=n;\\n    int* shuf=(int*)malloc(2*n*sizeof(int));\\n    int a=0;\\n    int i=0;\\n    while(i<n){\\n        shuf[a++]=nums[i++];\\n        shuf[a++]=nums[mid++];\\n    }"], ["int* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    int start=0;\\n    int mid=n;\\n    int* shuf=(int*)malloc(2*n*sizeof(int));\\n    int a=0;\\n    int i=0;\\n    while(i<n){\\n        shuf[a++]=nums[i++];\\n        shuf[a++]=nums[mid++];\\n    }"]]}
{"id": "310", "ref_c": [["int* finalPrices(int* prices, int pricesSize, int* returnSize) \\n{\\n  struct stack Stack;\\n  Stack.top = -1;\\n  Stack.size = pricesSize;\\n  Stack.stack_arr = (int *)malloc(sizeof(int) * Stack.size);\\n\\n  int * ret_arr = (int *)malloc(sizeof(int) * (pricesSize));\\n\\n  /* Push the indexes into the monotonic decreasing stack */\\n  int i=0;\\n  for(i=0; i<pricesSize; i++)\\n  {\\n    if(isStackEmpty(&Stack))\\n    {\\n      push(&Stack, i);\\n    }"], ["int* finalPrices(int* prices, int pricesSize, int* returnSize){\\n    int*answer = (int *)malloc(sizeof(int)*pricesSize);\\n    for (int i=0; i<pricesSize;i++){\\n        if (i==(pricesSize-1)){\\n            answer[i] = prices[i];\\n            break;\\n        }"], ["int* finalPrices(int* prices, int pricesSize, int* returnSize){\\n    int*ans=(int *)malloc(pricesSize*sizeof(int));\\n    *returnSize=pricesSize;\\n    for(int i=0;i<pricesSize;i++)\\n    {\\n        *(ans+i)=prices[i];\\n        for(int j=i+1;j<pricesSize;j++)\\n        {\\n            if(prices[j]<=prices[i])\\n            {\\n                *(ans+i)=(prices[i])-(prices[j]);\\n                break;\\n            }"]]}
{"id": "311", "ref_c": [["int* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=1;i<numsSize;i++)\\n    {\\n        nums[i]+=nums[i-1];\\n    }"], ["int* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=0;i<numsSize;i++)\\n    {\\n       sum=sum+nums[i];\\n        nums[i]=sum;\\n    }"], ["int* runningSum(int* nums, int numsSize, int* returnSize){\\n    // int *result = (int *)calloc(numsSize , sizeof(int));\\n    \\n    for(int i=1; i<numsSize; i++){\\n        nums[i] = nums[i-1] + nums[i];\\n    }"]]}
{"id": "313", "ref_c": [["int xorOperation(int n, int start){\\n   int ans[n];\\n    int sum=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        ans[i]=start+2*i;\\n    }"], ["int xorOperation(int n, int start)\\n{\\n    int arr[n],x=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        arr[i] = start + 2*i;\\n        x = x^arr[i];\\n    }"], ["int xorOperation(int n, int start){\\n    int xor = start;\\n    for (int i = 1; i < n; i++){\\n        xor ^= (start + 2 * i);\\n    }"]]}
{"id": "314", "ref_c": [["double average(int* salary, int salarySize){\\n\\n    int total = 0;\\n    int max = salary[0];\\n    int min = salary[0];\\n\\n    for(int i = 0; i < salarySize; i++){\\n        total += salary[i];\\n        if(max < salary[i])\\n            max = salary[i];\\n        else if(min > salary[i])\\n            min = salary[i];\\n    }"], ["double average(int* salary, int salarySize){\\n\\n    int total = 0;\\n    int max = salary[0];\\n    int min = salary[0];\\n\\n    for(int i = 0; i < salarySize; i++){\\n        total += salary[i];\\n        if(max < salary[i])\\n            max = salary[i];\\n        else if(min > salary[i])\\n            min = salary[i];\\n    }"], ["double average(int* salary, int salarySize){\\n\\n    int total = 0;\\n    int max = salary[0];\\n    int min = salary[0];\\n\\n    for(int i = 0; i < salarySize; i++){\\n        total += salary[i];\\n        if(max < salary[i])\\n            max = salary[i];\\n        else if(min > salary[i])\\n            min = salary[i];\\n    }"]]}
{"id": "315", "ref_c": ["\nbool isPathCrossing(char* p) {\n   int a=strlen(p),i,j;\n   for(i=0;i<a;i=i+1){\n       int sum=0,c=0;\n       for(j=i;j<a;j=j+1){\n         if(p[j]=='N'){\n           sum=sum+1;\n         }\n         if(p[j]=='S'){\n             sum=sum-1;\n         }\n         if(p[j]=='E'){\n             c=c+1;\n         }\n         if(p[j]=='W'){\n             c=c-1;\n         }\n       \n       if(sum==0&&c==0){\n           return 1;\n       }\n    }\n  }\n   return 0;\n}\n", "\nbool isPathCrossing(char* p) {\n   int a=strlen(p),i,j;\n   for(i=0;i<a;i=i+1){\n       int sum=0,c=0;\n       for(j=i;j<a;j=j+1){\n         if(p[j]=='N'){\n           sum=sum+1;\n         }\n         if(p[j]=='S'){\n             sum=sum-1;\n         }\n         if(p[j]=='E'){\n             c=c+1;\n         }\n         if(p[j]=='W'){\n             c=c-1;\n         }\n       \n       if(sum==0&&c==0){\n           return 1;\n       }\n    }\n  }\n   return 0;\n}\n", "\nbool isPathCrossing(char* p) {\n   int a=strlen(p),i,j;\n   for(i=0;i<a;i=i+1){\n       int sum=0,c=0;\n       for(j=i;j<a;j=j+1){\n         if(p[j]=='N'){\n           sum=sum+1;\n         }\n         if(p[j]=='S'){\n             sum=sum-1;\n         }\n         if(p[j]=='E'){\n             c=c+1;\n         }\n         if(p[j]=='W'){\n             c=c-1;\n         }\n       \n       if(sum==0&&c==0){\n           return 1;\n       }\n    }\n  }\n   return 0;\n}\n"]}
{"id": "316", "ref_c": [["bool canMakeArithmeticProgression(int* arr, int arrSize){\\n    int i, commonDifference, nodePtr = 0;\\n    int min = INT_MAX, max = INT_MIN;\\n    iNode *ht[MOD], nodes[1000];\\n    memset(ht, 0, sizeof(ht));\\n    for (i = 0; i < arrSize; ++i) {\\n        insertht(ht, arr[i], &nodes[nodePtr++]);\\n        if(arr[i] < min) {\\n            min = arr[i];\\n        }"], ["bool canMakeArithmeticProgression(int* arr, int arrSize) {\\n    int firstTerm = arr[0];\\n    // first term of AP which is assumed to be minimum.\\n\\n    /*The first check is if all terms are same*/\\n    bool allEqual = true;\\n    for (int i = 1; i < arrSize; ++i) {\\n        if (firstTerm != arr[i]) {\\n            allEqual = false;\\n            break;\\n        }"], ["bool canMakeArithmeticProgression(int* arr, int arrSize){\\nint temp, i, j, index = 0;\\nfor(int i = 0 ; i <= arrSize - 1 ; i++){\\n    index = i;\\n    for(j = i + 1; j < arrSize ; j++){\\n        if( arr[j] < arr[index]){\\n            index = j;\\n        }"]]}
{"id": "317", "ref_c": [["char * reformatDate(char * date){\\n    static char res[] = \"YYYY-MM-DD\";\\n\\n    if (date[1] >= \\'0\\' && date[1] <= \\'9\\')\\n    {\\n        res[8] = date[0];\\n        res[9] = date[1];\\n\\n        res[0] = date[9];\\n        res[1] = date[10];\\n        res[2] = date[11];\\n        res[3] = date[12];\\n\\n        res[5] = \\'0\\';\\n\\n        if (date[5] == \\'J\\' && date[6] == \\'a\\')\\n        res[6] = \\'1\\';\\n        \\n        else if(date[5] == \\'F\\')\\n        res[6] = \\'2\\';\\n        \\n        else if (date[5] == \\'M\\' && date[7] == \\'r\\')\\n        res[6] = \\'3\\';\\n        \\n        else if (date[5] == \\'A\\' && date[7] == \\'r\\')\\n        res[6] = \\'4\\';\\n        \\n        else if (date[5] == \\'M\\' && date[7] == \\'y\\')\\n        res[6] = \\'5\\';\\n        \\n        else if (date[5] == \\'J\\' && date[7] == \\'n\\')\\n        res[6] = \\'6\\';\\n        \\n        else if (date[5] == \\'J\\' && date[7] == \\'l\\')\\n        res[6] = \\'7\\';\\n        \\n        else if (date[5] == \\'A\\' && date[7] == \\'g\\')\\n        res[6] = \\'8\\';\\n        \\n        else if (date[5] == \\'S\\')\\n        res[6] = \\'9\\';\\n        \\n        else if (date[5] == \\'O\\')\\n        {\\n            res[5] = \\'1\\';\\n            res[6] = \\'0\\';\\n        }"], ["char * reformatDate(char * date){\\n    static char res[] = \"YYYY-MM-DD\";\\n\\n    if (date[1] >= \\'0\\' && date[1] <= \\'9\\')\\n    {\\n        res[8] = date[0];\\n        res[9] = date[1];\\n\\n        res[0] = date[9];\\n        res[1] = date[10];\\n        res[2] = date[11];\\n        res[3] = date[12];\\n\\n        res[5] = \\'0\\';\\n\\n        if (date[5] == \\'J\\' && date[6] == \\'a\\')\\n        res[6] = \\'1\\';\\n        \\n        else if(date[5] == \\'F\\')\\n        res[6] = \\'2\\';\\n        \\n        else if (date[5] == \\'M\\' && date[7] == \\'r\\')\\n        res[6] = \\'3\\';\\n        \\n        else if (date[5] == \\'A\\' && date[7] == \\'r\\')\\n        res[6] = \\'4\\';\\n        \\n        else if (date[5] == \\'M\\' && date[7] == \\'y\\')\\n        res[6] = \\'5\\';\\n        \\n        else if (date[5] == \\'J\\' && date[7] == \\'n\\')\\n        res[6] = \\'6\\';\\n        \\n        else if (date[5] == \\'J\\' && date[7] == \\'l\\')\\n        res[6] = \\'7\\';\\n        \\n        else if (date[5] == \\'A\\' && date[7] == \\'g\\')\\n        res[6] = \\'8\\';\\n        \\n        else if (date[5] == \\'S\\')\\n        res[6] = \\'9\\';\\n        \\n        else if (date[5] == \\'O\\')\\n        {\\n            res[5] = \\'1\\';\\n            res[6] = \\'0\\';\\n        }"], ["char * reformatDate(char * date){\\n    static char res[] = \"YYYY-MM-DD\";\\n\\n    if (date[1] >= \\'0\\' && date[1] <= \\'9\\')\\n    {\\n        res[8] = date[0];\\n        res[9] = date[1];\\n\\n        res[0] = date[9];\\n        res[1] = date[10];\\n        res[2] = date[11];\\n        res[3] = date[12];\\n\\n        res[5] = \\'0\\';\\n\\n        if (date[5] == \\'J\\' && date[6] == \\'a\\')\\n        res[6] = \\'1\\';\\n        \\n        else if(date[5] == \\'F\\')\\n        res[6] = \\'2\\';\\n        \\n        else if (date[5] == \\'M\\' && date[7] == \\'r\\')\\n        res[6] = \\'3\\';\\n        \\n        else if (date[5] == \\'A\\' && date[7] == \\'r\\')\\n        res[6] = \\'4\\';\\n        \\n        else if (date[5] == \\'M\\' && date[7] == \\'y\\')\\n        res[6] = \\'5\\';\\n        \\n        else if (date[5] == \\'J\\' && date[7] == \\'n\\')\\n        res[6] = \\'6\\';\\n        \\n        else if (date[5] == \\'J\\' && date[7] == \\'l\\')\\n        res[6] = \\'7\\';\\n        \\n        else if (date[5] == \\'A\\' && date[7] == \\'g\\')\\n        res[6] = \\'8\\';\\n        \\n        else if (date[5] == \\'S\\')\\n        res[6] = \\'9\\';\\n        \\n        else if (date[5] == \\'O\\')\\n        {\\n            res[5] = \\'1\\';\\n            res[6] = \\'0\\';\\n        }"]]}
{"id": "318", "ref_c": [["int numIdenticalPairs(int* nums, int numsSize) {\\n    int count = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = i + 1; j < numsSize; j++) {\\n            if (nums[i] == nums[j]) {\\n                count++;\\n            }", "int numIdenticalPairs(int* nums, int numsSize) {\\n    int count = 0;\\n    int num_count[numsSize];\\n    memset(num_count, 0, sizeof(num_count));\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        if (num_count[nums[i]]) {\\n            count += num_count[nums[i]];\\n            num_count[nums[i]]++;\\n        }", "int numIdenticalPairs(int* nums, int numsSize) {\\n    int freq[101] = {0}", "int numIdenticalPairs(int* nums, int numsSize) {\\n    int count = 0;\\n    int max_num = 0; // Variable to store the maximum element in nums\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] > max_num) {\\n            max_num = nums[i];\\n        }"], ["int numIdenticalPairs(int* nums, int numsSize) {\\n    int count = 0;\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = i + 1; j < numsSize; j++) {\\n            if (nums[i] == nums[j]) {\\n                count++;\\n            }"], ["int numIdenticalPairs(int* nums, int numsSize) {\\n    int count = 0;\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        for (int j = i + 1; j < numsSize; j++) {\\n            if (nums[i] == nums[j]) {\\n                count++;\\n            }"]]}
{"id": "320", "ref_c": [["int numWaterBottles(int numBottles, int numExchange) {\\n\\n    int a=numBottles,b;\\n\\n    while(numBottles>=numExchange)\\n    {  \\n        a=a+(numBottles/numExchange);\\n        b=numBottles%numExchange;\\n        numBottles=numBottles/numExchange;\\n        numBottles+=b;\\n    }"], ["int numWaterBottles(int numBottles, int numExchange) \\n{\\n    int numBottlesConsumed = numBottles;\\n    while(numBottles / numExchange != 0)\\n    {\\n        numBottlesConsumed += numBottles / numExchange;\\n        numBottles = (numBottles / numExchange) + (numBottles % numExchange);\\n    }"], ["int numWaterBottles(int numBottles, int numExchange) {\\n    int drink=numBottles,throw=numBottles;\\n    while(throw>=numExchange){\\n        drink=drink+throw/numExchange;\\n        throw=throw%numExchange+throw/numExchange;\\n    }"]]}
{"id": "321", "ref_c": [["int countOdds(int low, int high){\\n    return (high - low) / 2 + (high & 1 || low & 1);\\n}"], ["int countOdds(int low, int high)\\n{\\n    if(high%2==0 && low%2 == 0)\\n    return (high - low)/2;\\n    else\\n    return (high - low)/2 + 1;\\n}"], ["int countOdds(int low, int high) {\\n        // if both are even.\\n        if(low%2 == 0 && high%2 == 0)\\n        return (high-low)/2;\\n        // if low = even , high = odd.\\n        else if((low%2 == 0 && high%2!=0) || (low%2 != 0 && high%2 == 0))\\n        return ((high-low-1)/2)+1;\\n\\n        // if low = odd , high = odd.\\n        else return ((high-low-2)/2) + 2;\\n    }"]]}
{"id": "323", "ref_c": [["char * restoreString(char * s, int* indices, int indicesSize) {\\n    char * res = malloc(indicesSize + 1);\\n    strcpy(res, s);\\n    for (int i = 0 ; i < indicesSize; i++) {\\n        res[indices[i]] = s[i];\\n    }"], ["char * restoreString(char * s, int* indices, int indicesSize) {\\n    char * res = malloc(indicesSize + 1);\\n    strcpy(res, s);\\n    for (int i = 0 ; i < indicesSize; i++) {\\n        res[indices[i]] = s[i];\\n    }"], ["char * restoreString(char * s, int* indices, int indicesSize) {\\n    char * res = malloc(indicesSize + 1);\\n    strcpy(res, s);\\n    for (int i = 0 ; i < indicesSize; i++) {\\n        res[indices[i]] = s[i];\\n    }"]]}
{"id": "324", "ref_c": [["int countGoodTriplets(int* arr, int arrSize, int a, int b, int c){\\n    int count=0;\\nfor(int i=0;i<arrSize-2;i++){\\n    for(int j=i+1;j<arrSize-1;j++){\\n        if(abs(arr[i]-arr[j])<=a){\\n            for(int k=j+1;k<arrSize;k++){\\n                if(abs(arr[j]-arr[k])<=b){\\n                    if(abs(arr[i]-arr[k])<=c)\\n                    count++;\\n                }"], ["int countGoodTriplets(int* arr, int arrSize, int a, int b, int c){\\n    int count=0;\\nfor(int i=0;i<arrSize-2;i++){\\n    for(int j=i+1;j<arrSize-1;j++){\\n        if(abs(arr[i]-arr[j])<=a){\\n            for(int k=j+1;k<arrSize;k++){\\n                if(abs(arr[j]-arr[k])<=b){\\n                    if(abs(arr[i]-arr[k])<=c)\\n                    count++;\\n                }"], ["int countGoodTriplets(int* arr, int arrSize, int a, int b, int c){\\n    int count = 0;\\n\\n    for(int i  = 0 ;i < arrSize - 2; i++){\\n\\n        for(int j = i + 1; j < arrSize-1; j++)\\n            for(int k = j + 1; k < arrSize; k++)\\n                if(abs(arr[i] - arr[j]) <= a && abs(arr[j] - arr[k]) <=b && abs(arr[i] -  arr[k]) <= c )count++;\\n            \\n    }"]]}
{"id": "325", "ref_c": [["int findKthPositive(int* arr, int arrSize, int k) \\n{\\n   if(k <= arr[0] - 1)\\n   {\\n      return k;\\n   }"], ["int findKthPositive(int* arr, int arrSize, int k) \\n{\\n   if(k <= arr[0] - 1)\\n   {\\n      return k;\\n   }"], ["int findKthPositive(int* arr, int arrSize, int k) \\n{\\n   if(k <= arr[0] - 1)\\n   {\\n      return k;\\n   }"]]}
{"id": "326", "ref_c": [["char * makeGood(char * s){\\n    int j = 0;\\n    for (int i = 0; s[i]; i++) {\\n        if (j == 0) {\\n            s[j++] = s[i];\\n        }"], ["char * makeGood(char * s){\\n    int j = 0;\\n    for (int i = 0; s[i]; i++) {\\n        if (j == 0) {\\n            s[j++] = s[i];\\n        }"], ["char * makeGood(char * s){\\n    int j = 0;\\n    for (int i = 0; s[i]; i++) {\\n        if (j == 0) {\\n            s[j++] = s[i];\\n        }"]]}
{"id": "327", "ref_c": [["bool threeConsecutiveOdds(int* arr, int arrSize) {\\n    int i;\\n\\n    for(i=0;i<arrSize-2;i++)\\n    {\\n        printf(\"%d\",arrSize);\\n        if(arr[i] % 2 != 0 && arr[i+1] % 2 != 0 && arr[i+2] % 2 != 0)\\n        {\\n            return true;\\n        }"], ["bool threeConsecutiveOdds(int* arr, int arrSize) {\\nint count = 0;\\n    for(int i = 0; i < arrSize; i++){\\n        if(arr[i]%2 == 1 ){\\n            count++;\\n        if(count >= 3){\\n            return 1;\\n    }"], ["bool threeConsecutiveOdds(int* arr, int arrSize) {\\n    int i;\\n\\n    for(i=0;i<arrSize-2;i++)\\n    {\\n        printf(\"%d\",arrSize);\\n        if(arr[i] % 2 != 0 && arr[i+1] % 2 != 0 && arr[i+2] % 2 != 0)\\n        {\\n            return true;\\n        }"]]}
{"id": "328", "ref_c": ["\nint length(const char *s) {\n    int i;\n    for (i = 0; s[i] != '\u0000'; i++) {\n        \n    }\n    return i;\n}\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid reverse(char *s) {\n    int len = length(s);\n    int i = 0, j = len - 1;\n\n    for (i = 0; i <= j; i++, j--)\n        swap(&s[i], &s[j]);\n}\n\nchar* thousandSeparator(int n) {\n    int count = 0, i = 0, rem, rev = 0;\n    char* H = (char*)malloc(20 * sizeof(char));\n    if(n==0)\n    {\n        H[0] = '0';\n        H[1] = '\u0000';\n        return H;\n    }\n    while (n != 0) {\n        if (count == 3) {\n            H[i++] = '.';\n            count = 0;\n        }\n        rem = n % 10;\n        H[i++] = rem + '0';\n        rev = rev * 10 + rem;\n        count++;\n        n /= 10;\n    }\n    H[i] = '\u0000';\n    \n    reverse(H);\n    \n    return H;\n}\n", "\nint length(const char *s) {\n    int i;\n    for (i = 0; s[i] != '\u0000'; i++) {\n        \n    }\n    return i;\n}\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid reverse(char *s) {\n    int len = length(s);\n    int i = 0, j = len - 1;\n\n    for (i = 0; i <= j; i++, j--)\n        swap(&s[i], &s[j]);\n}\n\nchar* thousandSeparator(int n) {\n    int count = 0, i = 0, rem, rev = 0;\n    char* H = (char*)malloc(20 * sizeof(char));\n    if(n==0)\n    {\n        H[0] = '0';\n        H[1] = '\u0000';\n        return H;\n    }\n    while (n != 0) {\n        if (count == 3) {\n            H[i++] = '.';\n            count = 0;\n        }\n        rem = n % 10;\n        H[i++] = rem + '0';\n        rev = rev * 10 + rem;\n        count++;\n        n /= 10;\n    }\n    H[i] = '\u0000';\n    \n    reverse(H);\n    \n    return H;\n}\n", "\nint length(const char *s) {\n    int i;\n    for (i = 0; s[i] != '\u0000'; i++) {\n        \n    }\n    return i;\n}\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid reverse(char *s) {\n    int len = length(s);\n    int i = 0, j = len - 1;\n\n    for (i = 0; i <= j; i++, j--)\n        swap(&s[i], &s[j]);\n}\n\nchar* thousandSeparator(int n) {\n    int count = 0, i = 0, rem, rev = 0;\n    char* H = (char*)malloc(20 * sizeof(char));\n    if(n==0)\n    {\n        H[0] = '0';\n        H[1] = '\u0000';\n        return H;\n    }\n    while (n != 0) {\n        if (count == 3) {\n            H[i++] = '.';\n            count = 0;\n        }\n        rem = n % 10;\n        H[i++] = rem + '0';\n        rev = rev * 10 + rem;\n        count++;\n        n /= 10;\n    }\n    H[i] = '\u0000';\n    \n    reverse(H);\n    \n    return H;\n}\n"]}
{"id": "329", "ref_c": [["int* mostVisited(int n, int* rounds, int roundsSize, int* returnSize)\\n{\\n    memset(hashtable, 0x00, sizeof(hashtable));\\n    \\n    int i=0;\\n    for(i=1; i<roundsSize; i++)\\n    {\\n        int start_sector = rounds[i-1];\\n        int end_sector   = rounds[i];\\n        \\n        if(i == 1)\\n        {\\n            start_sector -= 1;\\n        }"], ["int* mostVisited(int n, int* rounds, int roundsSize, int* returnSize)\\n{\\n    memset(hashtable, 0x00, sizeof(hashtable));\\n    \\n    int i=0;\\n    for(i=1; i<roundsSize; i++)\\n    {\\n        int start_sector = rounds[i-1];\\n        int end_sector   = rounds[i];\\n        \\n        if(i == 1)\\n        {\\n            start_sector -= 1;\\n        }"], ["int* mostVisited(int n, int* rounds, int roundsSize, int* returnSize)\\n{\\n    memset(hashtable, 0x00, sizeof(hashtable));\\n    \\n    int i=0;\\n    for(i=1; i<roundsSize; i++)\\n    {\\n        int start_sector = rounds[i-1];\\n        int end_sector   = rounds[i];\\n        \\n        if(i == 1)\\n        {\\n            start_sector -= 1;\\n        }"]]}
{"id": "330", "ref_c": [["bool containsPattern(int* arr, int arrSize, int m, int k){\\n\\n    int cnt = 0;\\n    for(int i = 0; i+m < arrSize; i++){\\n        if(arr[i] != arr[i+m]) cnt = 0;\\n        else cnt++;\\n        if(cnt == (k-1)*m) return true;\\n    }"], ["bool containsPattern(int* arr, int arrSize, int m, int k){\\n\\n    int cnt = 0;\\n    for(int i = 0; i+m < arrSize; i++){\\n        if(arr[i] != arr[i+m]) cnt = 0;\\n        else cnt++;\\n        if(cnt == (k-1)*m) return true;\\n    }"], ["bool containsPattern(int* arr, int arrSize, int m, int k){\\n\\n    int cnt = 0;\\n    for(int i = 0; i+m < arrSize; i++){\\n        if(arr[i] != arr[i+m]) cnt = 0;\\n        else cnt++;\\n        if(cnt == (k-1)*m) return true;\\n    }"]]}
{"id": "331", "ref_c": [["int diagonalSum(int** mat, int matSize, int* matColSize){\\n    long int s=0;\\n    for(int i=0;i<matSize;i++){\\n        for(int j=0;j<matSize;j++){\\n            if(i==j || (i+j==matSize-1)) s+=mat[i][j];\\n        }"], ["int diagonalSum(int** mat, int matSize, int* matColSize){\\n    long int s=0;\\n    for(int i=0;i<matSize;i++){\\n        for(int j=0;j<matSize;j++){\\n            if(i==j || (i+j==matSize-1)) s+=mat[i][j];\\n        }"], ["int diagonalSum(int** mat, int matSize, int* matColSize){\\nint sum=0;\\nfor(int i=0;i<matSize;i++)\\n{\\n    for(int j=0;j<matSize;j++)\\n    {\\n        if(i==j)\\n        {\\n            sum=sum+mat[i][j];\\n        }"]]}
{"id": "332", "ref_c": ["\nchar * modifyString(char * s){\n    for(int i=0;s[i]!='\u0000';i++)\n        if(s[i] == '?') \n            for(s[i]='a'; (i>0 && s[i]==s[i-1]) || (s[i+1]!='\u0000' && s[i]==s[i+1]); s[i]++);      \n    return s;\n}\n", "\nchar * modifyString(char * s){\n    for(int i=0;s[i]!='\u0000';i++)\n        if(s[i] == '?') \n            for(s[i]='a'; (i>0 && s[i]==s[i-1]) || (s[i+1]!='\u0000' && s[i]==s[i+1]); s[i]++);      \n    return s;\n}\n", "\nchar * modifyString(char * s){\n    for(int i=0;s[i]!='\u0000';i++)\n        if(s[i] == '?') \n            for(s[i]='a'; (i>0 && s[i]==s[i-1]) || (s[i+1]!='\u0000' && s[i]==s[i+1]); s[i]++);      \n    return s;\n}\n"]}
{"id": "334", "ref_c": [["int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int ans = 0;\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 0) {\\n                continue; // If the element is 0, continue to the next iteration\\n            }", "int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    // Array to store counts of \\'1\\'s in each row and column\\n    int* rowCount = (int*)calloc(m, sizeof(int)); // Initialize row count array with 0s\\n    int* colCount = (int*)calloc(n, sizeof(int)); // Initialize column count array with 0s\\n\\n    // Counting \\'1\\'s in each row and column\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 1) {\\n                rowCount[row]++; // Increment row count when \\'1\\' is encountered in the row\\n                colCount[col]++; // Increment column count when \\'1\\' is encountered in the column\\n            }"], ["int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int ans = 0;\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 0) {\\n                continue; // If the element is 0, continue to the next iteration\\n            }", "int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    // Array to store counts of \\'1\\'s in each row and column\\n    int* rowCount = (int*)calloc(m, sizeof(int)); // Initialize row count array with 0s\\n    int* colCount = (int*)calloc(n, sizeof(int)); // Initialize column count array with 0s\\n\\n    // Counting \\'1\\'s in each row and column\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 1) {\\n                rowCount[row]++; // Increment row count when \\'1\\' is encountered in the row\\n                colCount[col]++; // Increment column count when \\'1\\' is encountered in the column\\n            }"], ["int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int result = 0;\\n\\n    // Arrays to store the sums of elements in each row and column\\n    int* rowSums = (int*)malloc(matSize * sizeof(int));\\n    int* colSums = (int*)malloc(matColSize[0] * sizeof(int));\\n\\n    // Initialize rowSums and colSums to zeros\\n    for (int i = 0; i < matSize; i++) {\\n        rowSums[i] = 0;\\n    }"]]}
{"id": "336", "ref_c": [["int sumOddLengthSubarrays(int* arr, int arrSize){\\n    int sum=0;\\n    for(int i=0;i<arrSize;i++){\\n        int n=arrSize-i;\\n        int t=i+1;\\n        n=n*t;\\n        n=n%2==0?n/2:(n+1)/2;\\n        sum+=n*arr[i];\\n    }"], ["int sumOddLengthSubarrays(int* arr, int arrSize){\\n    int sum=0;\\n    for(int i=0;i<arrSize;i++){\\n        int n=arrSize-i;\\n        int t=i+1;\\n        n=n*t;\\n        n=n%2==0?n/2:(n+1)/2;\\n        sum+=n*arr[i];\\n    }"], ["int sumOddLengthSubarrays(int* arr, int arrSize)\\n{\\n    int size = 1;\\n    int sum = 0;\\n    while(size <= arrSize) {\\n        for (int i = 0; i < arrSize; i++) {\\n            for (int j = i; j < size + i && size+i <= arrSize; j++) {\\n                sum += arr[j]; \\n            }"]]}
{"id": "337", "ref_c": [["char * reorderSpaces(char * text){\\n\\tchar tmp[100];\\n\\tmemset(tmp,0,sizeof(tmp));\\n\\tint i, j, k , index = 0, space_count = 0, word_count = 0, interspace = 0;\\n\\tint first = 0;\\n\\tfor(i = 0; i < strlen(text); i++)\\n\\t{\\n\\t\\tif(text[i] == \\' \\'){\\n\\t\\t\\tspace_count++;\\n\\t\\t}"], ["char * reorderSpaces(char * text){\\n    int len = strlen(text);\\n    int spaceCnt = 0, wordCnt = 0, charCnt= 0;\\n    for(int i = 0; i < len; i++){\\n        if(text[i]==\\' \\'){\\n            spaceCnt++;\\n            if(charCnt){\\n                wordCnt++;\\n                charCnt = 0;\\n            }"], ["char * reorderSpaces(char * text){\\n\\tchar tmp[100];\\n\\tmemset(tmp,0,sizeof(tmp));\\n\\tint i, j, k , index = 0, space_count = 0, word_count = 0, interspace = 0;\\n\\tint first = 0;\\n\\tfor(i = 0; i < strlen(text); i++)\\n\\t{\\n\\t\\tif(text[i] == \\' \\'){\\n\\t\\t\\tspace_count++;\\n\\t\\t}"]]}
{"id": "338", "ref_c": ["\ntypedef struct\n{\n    int top;\n    int size;\n    char * stack_arr;\n}stack;\n\nbool isStackEmpty(stack * Stack)\n{\n    if(Stack->top == -1)\n        return true;\n    else\n        return false;\n}\n\nbool isStackFull(stack * Stack)\n{\n    if(Stack->top == Stack->size - 1)\n        return true;\n    else\n        return false;\n}\n\nvoid push(stack * Stack, char val)\n{\n    if(isStackFull(Stack))\n        return;\n\n    Stack->stack_arr[++Stack->top] = val;\n}\n\nchar pop(stack * Stack)\n{\n    char ret_val = '\u0000';\n    if(isStackEmpty(Stack))\n        return ret_val;\n\n    ret_val = Stack->stack_arr[Stack->top--];\n    return ret_val;\n}\n\nint minOperations(char** logs, int logsSize) \n{\n    stack Stack;\n    Stack.top = -1;\n    Stack.size = STACK_SIZE;\n    Stack.stack_arr = (char *)malloc(sizeof(char) * Stack.size);\n\n    int i=0;\n    for(i=0; i<logsSize; i++)\n    {\n        if(strcmp(logs[i],\"./\") == 0)\n        {\n            //Do Nothing\n        }\n        else if(strcmp(logs[i],\"../\") == 0)\n        {\n            pop(&Stack);\n        }\n        else\n        {\n            push(&Stack, 'c');\n        }\n    }\n\n    int count = 0;\n    while(isStackEmpty(&Stack) == false)\n    {\n        pop(&Stack);\n        count++;\n    }\n    return count;\n}\n", "\ntypedef struct\n{\n    int top;\n    int size;\n    char * stack_arr;\n}stack;\n\nbool isStackEmpty(stack * Stack)\n{\n    if(Stack->top == -1)\n        return true;\n    else\n        return false;\n}\n\nbool isStackFull(stack * Stack)\n{\n    if(Stack->top == Stack->size - 1)\n        return true;\n    else\n        return false;\n}\n\nvoid push(stack * Stack, char val)\n{\n    if(isStackFull(Stack))\n        return;\n\n    Stack->stack_arr[++Stack->top] = val;\n}\n\nchar pop(stack * Stack)\n{\n    char ret_val = '\u0000';\n    if(isStackEmpty(Stack))\n        return ret_val;\n\n    ret_val = Stack->stack_arr[Stack->top--];\n    return ret_val;\n}\n\nint minOperations(char** logs, int logsSize) \n{\n    stack Stack;\n    Stack.top = -1;\n    Stack.size = STACK_SIZE;\n    Stack.stack_arr = (char *)malloc(sizeof(char) * Stack.size);\n\n    int i=0;\n    for(i=0; i<logsSize; i++)\n    {\n        if(strcmp(logs[i],\"./\") == 0)\n        {\n            //Do Nothing\n        }\n        else if(strcmp(logs[i],\"../\") == 0)\n        {\n            pop(&Stack);\n        }\n        else\n        {\n            push(&Stack, 'c');\n        }\n    }\n\n    int count = 0;\n    while(isStackEmpty(&Stack) == false)\n    {\n        pop(&Stack);\n        count++;\n    }\n    return count;\n}\n", "\ntypedef struct\n{\n    int top;\n    int size;\n    char * stack_arr;\n}stack;\n\nbool isStackEmpty(stack * Stack)\n{\n    if(Stack->top == -1)\n        return true;\n    else\n        return false;\n}\n\nbool isStackFull(stack * Stack)\n{\n    if(Stack->top == Stack->size - 1)\n        return true;\n    else\n        return false;\n}\n\nvoid push(stack * Stack, char val)\n{\n    if(isStackFull(Stack))\n        return;\n\n    Stack->stack_arr[++Stack->top] = val;\n}\n\nchar pop(stack * Stack)\n{\n    char ret_val = '\u0000';\n    if(isStackEmpty(Stack))\n        return ret_val;\n\n    ret_val = Stack->stack_arr[Stack->top--];\n    return ret_val;\n}\n\nint minOperations(char** logs, int logsSize) \n{\n    stack Stack;\n    Stack.top = -1;\n    Stack.size = STACK_SIZE;\n    Stack.stack_arr = (char *)malloc(sizeof(char) * Stack.size);\n\n    int i=0;\n    for(i=0; i<logsSize; i++)\n    {\n        if(strcmp(logs[i],\"./\") == 0)\n        {\n            //Do Nothing\n        }\n        else if(strcmp(logs[i],\"../\") == 0)\n        {\n            pop(&Stack);\n        }\n        else\n        {\n            push(&Stack, 'c');\n        }\n    }\n\n    int count = 0;\n    while(isStackEmpty(&Stack) == false)\n    {\n        pop(&Stack);\n        count++;\n    }\n    return count;\n}\n"]}
{"id": "340", "ref_c": [["int specialArray(int* nums, int numsSize) {\\n    int res=-1;\\n    for(int i=0;i<=numsSize;i++)\\n    {\\n        int  count=0;\\n        for(int j=0;j<numsSize;j++)\\n        {\\n            if(nums[j]>=i)\\n            {\\n                count++;\\n            }"], ["int specialArray(int* nums, int numsSize){\\n  \\n   for(int i=0;i<=100;i++){ \\n       int count = 0;\\n       for(int j=0;j<numsSize;j++){\\n           if(nums[j] >= i){\\n               count++;\\n           }"], ["int specialArray(int* nums, int numsSize)\\n{\\n    int max = nums[0];\\n    for(int i = 1; i < numsSize; i++)\\n        if(max < nums[i])\\n            max = nums[i];\\n\\n    int outputNum = 1, count = 0, j = 0;\\n    \\n    while(outputNum <= max)\\n    {\\n        if(outputNum <= nums[j])\\n            count++;\\n        \\n        if(count > outputNum)\\n        {\\n            j = 0;\\n            count = 0;\\n            outputNum++;\\n            continue;\\n        }"]]}
{"id": "341", "ref_c": [["int maxDepth(char * s){\\n    char*C;\\n    C=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0,count=0;\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        if(s[i]==\\'(\\'){\\n            C[k++]=s[i];\\n        }"], ["int maxDepth(char * s){\\n    char*C;\\n    C=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0,count=0;\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        if(s[i]==\\'(\\'){\\n            C[k++]=s[i];\\n        }"], ["int maxDepth(char * s){\\n    char*C;\\n    C=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0,count=0;\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        if(s[i]==\\'(\\'){\\n            C[k++]=s[i];\\n        }"]]}
{"id": "342", "ref_c": [["double trimMean(int* arr, int arrSize){\\n    qsort(arr,arrSize,sizeof(int),compare);\\n    int trim=arrSize*0.05;\\n    double sum=0.0;\\n    for(int i=trim;i<arrSize-trim;i++){\\n        sum+=arr[i];\\n    }"], ["double trimMean(int* arr, int arrSize) {\\nint five = 0.05*arrSize;\\nint* arrcpy = arr;\\nqsort(arr,arrSize,sizeof(int),sort);\\nfor (int i = 0; i < five; ++i){ \\n    arr[i] = -1;\\n}"], ["double trimMean(int* arr, int arrSize){\\n    qsort(arr,arrSize,sizeof(int),compare);\\n    int trim=arrSize*0.05;\\n    double sum=0.0;\\n    for(int i=trim;i<arrSize-trim;i++){\\n        sum+=arr[i];\\n    }"]]}
{"id": "343", "ref_c": [["int maxLengthBetweenEqualCharacters(char * s){\\n    int len=-1,max_len=-1;\\n    for(int i=0;i< strlen(s);i++){\\n        for(int j=i;j< strlen(s);j++){\\n            if(s[i]==s[j])\\n                len = j-i-1;\\n            if(len>max_len)\\n                max_len = len;\\n        }"], ["int maxLengthBetweenEqualCharacters(char * s){\\n    int len=-1,max_len=-1;\\n    for(int i=0;i< strlen(s);i++){\\n        for(int j=i;j< strlen(s);j++){\\n            if(s[i]==s[j])\\n                len = j-i-1;\\n            if(len>max_len)\\n                max_len = len;\\n        }"], ["int maxLengthBetweenEqualCharacters(char * s){\\n    int len=-1,max_len=-1;\\n    for(int i=0;i< strlen(s);i++){\\n        for(int j=i;j< strlen(s);j++){\\n            if(s[i]==s[j])\\n                len = j-i-1;\\n            if(len>max_len)\\n                max_len = len;\\n        }"]]}
{"id": "344", "ref_c": [["char slowestKey(int* releaseTimes, int releaseTimesSize, char * keysPressed)\\n{\\n    char max_key = 0;\\n    int max_duration = 0;\\n    \\n    int i=0;\\n    \\n    for(i=0; i<releaseTimesSize; i++)\\n    {\\n        int cur_duration;\\n        if(i==0)\\n        {\\n            cur_duration = releaseTimes[i] - 0;\\n        }"], ["char slowestKey(int* releaseTimes, int releaseTimesSize, char * keysPressed){\\n    int maxTime = releaseTimes[0];\\n    char result = keysPressed[0];\\n    for(int i=1; i<releaseTimesSize; i++)\\n        if(releaseTimes[i]-releaseTimes[i-1] > maxTime)\\n        {\\n            maxTime = releaseTimes[i]-releaseTimes[i-1];\\n            result = keysPressed[i]; \\n        }"], ["char slowestKey(int* releaseTimes, int releaseTimesSize, char * keysPressed)\\n{\\n    char max_key = 0;\\n    int max_duration = 0;\\n    \\n    int i=0;\\n    \\n    for(i=0; i<releaseTimesSize; i++)\\n    {\\n        int cur_duration;\\n        if(i==0)\\n        {\\n            cur_duration = releaseTimes[i] - 0;\\n        }"]]}
{"id": "346", "ref_c": [["int* frequencySort(int* nums, int numsSize, int* returnSize){\\n    int i, l = numsSize;\\n    memset(count, 0, sizeof(count));\\n    \\n    for(i = 0; i < l; i++){\\n        count[nums[i] + 100]++;\\n    }"], ["int* frequencySort(int* nums, int numsSize, int* returnSize) { \\n    int arr_freq_size = 201;\\n    val_comp* val_comp_arr = calloc(numsSize, sizeof(val_comp));\\n\\n    int *result_buf = calloc(arr_freq_size,sizeof(int)); \\n    int result_buf_counter = 0;\\n\\n    for(int i=0, j=100; i<numsSize; i++){\\n        *(result_buf + nums[i] + j) += 1;\\n    }"], ["int* frequencySort(int* nums, int numsSize, int* returnSize) { \\n    int arr_freq_size = 201;\\n    val_comp* val_comp_arr = calloc(numsSize, sizeof(val_comp));\\n\\n    int *result_buf = calloc(arr_freq_size,sizeof(int)); \\n    int result_buf_counter = 0;\\n\\n    for(int i=0, j=100; i<numsSize; i++){\\n        *(result_buf + nums[i] + j) += 1;\\n    }"]]}
{"id": "347", "ref_c": [["bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\\n\\n    int pmap[101];    \\n    for(int i=0; i<piecesSize; ++i){\\n        int j=0;\\n        while(j<piecesColSize[i]){\\n            if(j-1<0){\\n                // First (and possibly only) value, has no previous neighbour\\n                pmap[pieces[i][j]] = -1;\\n            }"], ["bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\\n\\n    int pmap[101];    \\n    for(int i=0; i<piecesSize; ++i){\\n        int j=0;\\n        while(j<piecesColSize[i]){\\n            if(j-1<0){\\n                // First (and possibly only) value, has no previous neighbour\\n                pmap[pieces[i][j]] = -1;\\n            }"], ["bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\\n    int ans = false;\\n    int* mapping = (int*)calloc(101, sizeof(int));\\n    /* record indx into mapping array */\\n    for(int i = 0; i < arrSize; i++)\\n        mapping[arr[i]] = i + 1;\\n    int startIdx;\\n    /* read the first element of piece then \\n        check the index correct or not*/\\n    for(int i = 0; i < piecesSize; i++){\\n        startIdx = mapping[pieces[i][0]];\\n        if(!startIdx) return false; /* index isn\\'t exist */\\n        for(int j = 0; j < piecesColSize[i]; j++)\\n            if(mapping[pieces[i][j]] != (startIdx + j))\\n                return false;   \\n    }"]]}
{"id": "348", "ref_c": [["int getMaximumGenerated(int n) {\\nint* arr = malloc((n+1)*sizeof(int));\\nif (n == 0) {\\n    return 0;\\n}"], ["int getMaximumGenerated(int n){\\n  if(n<=1) return n;\\n  int nums[n+1];\\n  int i=1;\\n  int max=1;\\n  nums[0]=0;\\n  nums[1]=1;\\n  for(int i=1;i<=n/2;i++){\\n    if(i*2<=n){\\n    nums[i*2]=nums[i];\\n    }"], ["int getMaximumGenerated(int n){\\n    int nums[n+1];\\nif(n==0)\\nreturn 0;\\nelse if(n==1)\\nreturn 1;\\nelse{\\n    for(int i=1;i<=n;i++){\\n      nums[0]=0;\\n      nums[1]=1;\\n      if(n>=2*i)\\n      nums[2*i]=nums[i];\\n      if(n>=(2*i) +1)\\n      nums[(2*i)+ 1]=nums[i]+nums[i+1];\\n    }"]]}
{"id": "349", "ref_c": [["int* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }"], ["int* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }"], ["int* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    *returnSize = codeSize;\\n\\n    int *res = (int *) malloc(codeSize * sizeof(int));\\n    int *doubled = (int *) malloc(codeSize * 2 * sizeof(int));\\n\\n    if(k == 0) {\\n        for(int i = 0; i < codeSize; i++) {\\n            res[i] = 0;\\n        }"]]}
{"id": "352", "ref_c": ["\nbool arrayStringsAreEqual(char** word1, int word1Size, char** word2, int word2Size) {\n    int m=0, n=0, i=0, j=0;\n    do {\n        if (word1[m][i] == '\u0000') {\n            ++m;\n            i = 0;\n        }\n        if (word2[n][j] == '\u0000') {\n            ++n;\n            j = 0;\n        }\n        if (m >= word1Size || n >= word2Size) {\n            break;\n        }\n        if (word1[m][i] != word2[n][j]) {\n            return false;\n        }\n        ++i;\n        ++j;\n    } while (1);\n    return m >= word1Size && n >= word2Size;\n}\n", "\nbool arrayStringsAreEqual(char** word1, int word1Size, char** word2, int word2Size) {\n    int m=0, n=0, i=0, j=0;\n    do {\n        if (word1[m][i] == '\u0000') {\n            ++m;\n            i = 0;\n        }\n        if (word2[n][j] == '\u0000') {\n            ++n;\n            j = 0;\n        }\n        if (m >= word1Size || n >= word2Size) {\n            break;\n        }\n        if (word1[m][i] != word2[n][j]) {\n            return false;\n        }\n        ++i;\n        ++j;\n    } while (1);\n    return m >= word1Size && n >= word2Size;\n}\n", "\nbool arrayStringsAreEqual(char** word1, int word1Size, char** word2, int word2Size) {\n    int m=0, n=0, i=0, j=0;\n    do {\n        if (word1[m][i] == '\u0000') {\n            ++m;\n            i = 0;\n        }\n        if (word2[n][j] == '\u0000') {\n            ++n;\n            j = 0;\n        }\n        if (m >= word1Size || n >= word2Size) {\n            break;\n        }\n        if (word1[m][i] != word2[n][j]) {\n            return false;\n        }\n        ++i;\n        ++j;\n    } while (1);\n    return m >= word1Size && n >= word2Size;\n}\n"]}
{"id": "354", "ref_c": [["int maxRepeating(char * sequence, char * word){\\n    char *c = word;\\n    char *found = 0;\\n    int count = 0;\\n    int max = 0;\\n    \\n    while (*c) ++c;\\n    const int wordLength = c - word;\\n    c = word;\\n    \\n    while (*sequence) {\\n        // printf(\"%c and %c at \\\\t%i\\\\n\", *sequence, *c, sequence);\\n        if (*sequence == *c) {\\n            ++c;\\n            if (!found)\\n                found = sequence;\\n            if (!*c) {\\n                c = word;\\n                ++count;\\n                if (max < count)\\n                    max = count;\\n            }"], ["int maxRepeating(char * sequence, char * word){\\n\\n    int wlen = strlen(word);\\n    int slen = strlen(sequence);\\n    int maxk = (int)(slen/wlen); // max possible return value\\n    char curstring[100]; // max length of 100 characters\\n    int max = 0;\\n    \\n    for (int i = 1; i <= maxk; i++){\\n        if (i == 1) {\\n            strcpy(curstring, word); // initialze curstring with one occurance of word\\n        }"], ["int maxRepeating(char * sequence, char * word){\\n    int sLen=strlen(sequence);\\n    int wLen=strlen(word);\\n    int x=0;\\n    int max=0;\\n    \\n    while(x<sLen){\\n        int count=0;\\n        int i=x;\\n        while(i+wLen<=sLen&&strncmp(sequence+i,word,wLen)==0){count++;x=i;i+=wLen;}"]]}
{"id": "355", "ref_c": [["int maximumWealth(int** accounts, int accountsSize, int* accountsColSize){\\n        int res = 0;\\n        for(int i =0;i<accountsSize;i++){\\n            int temp = 0;\\n            for(int j = 0;j<*accountsColSize;j++){\\n                temp+=accounts[i][j];\\n            }"], ["int maximumWealth(int** accounts, int accountsSize, int* accountsColSize)\\n{\\n    //accountsSize = m , accountsColSize = n\\n    int sum = 0, max=0;\\n    for(int i=0; i<accountsSize; i++)\\n    {\\n       sum = 0;\\n       for(int j=0; j<accountsColSize[i]; j++)\\n       {\\n          sum += accounts[i][j];\\n       }"], ["int maximumWealth(int** accounts, int accountsSize, int* accountsColSize){\\n        int max_wealth = -1;\\n        int wealth = 0;\\n        for(int i = 0; i < accountsSize; i++){\\n            for(int j = 0; j <accountsColSize[i]; j++){\\n                wealth += accounts[i][j];\\n            }"]]}
{"id": "356", "ref_c": [["char * interpret(char * command){\\n    int size = strlen(command) + 1;\\n    char * res = (char*)malloc(size * sizeof(char));\\n    int x = 0;\\n    for(int i = 0; i < size; i++){\\n        if(command[i] == \\'G\\'){\\n            res[x++] = \\'G\\';\\n        }"], ["char * interpret(char * command){\\n    int size = strlen(command) + 1;\\n    char * res = (char*)malloc(size * sizeof(char));\\n    int x = 0;\\n    for(int i = 0; i < size; i++){\\n        if(command[i] == \\'G\\'){\\n            res[x++] = \\'G\\';\\n        }"], ["char * interpret(char * command){\\n\\tint i, count = 0;\\n\\tchar *arr = (int*)calloc(10000, sizeof(int));\\n\\t\\n\\tfor(i = 0; i < strlen(command); i++)\\n\\t{\\n\\t\\tif(command[i] == \\'G\\')\\n\\t\\t{\\n\\t\\t\\tarr[count++] = \\'G\\';\\n\\t\\t}"]]}
{"id": "358", "ref_c": [["int countConsistentStrings(char * allowed, char ** words, int wordsSize){\\n    int cnt=0,finalcnt=0;\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        for(int j=0;j<strlen(words[i]);j++)\\n        {\\n            cnt=0;\\n            for(int k=0;k<strlen(allowed);k++)\\n            {\\n                if(words[i][j]==allowed[k])\\n                cnt++;\\n            }"], ["int countConsistentStrings(char * allowed, char ** words, int wordsSize){\\n    int allowedSize=strlen(allowed), count=0, m;    // length of allowed String\\n    bool flag=true;\\n    for ( int i=0;i<wordsSize;i++){                 // To check till end of words array\\n        for (int j=0; words[i][j]!=\\'\\\\0\\'; j++){      // To check every character in words array\\n            for (int k=0;k<allowedSize;k++){        // To check every character in allowed array\\n                if (words[i][j]==allowed[k]){       // If characters are same, exit k loop making flag=true\\n                    flag=true;\\n                    goto endKLoop;                  // goto used to to jump unconditionally from loop\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// endKLoop is name/Label for goto to where it\\'ll jump\\n                }"], ["int countConsistentStrings(char * allowed, char ** words, int wordsSize){\\n    int cnt=0,finalcnt=0;\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        for(int j=0;j<strlen(words[i]);j++)\\n        {\\n            cnt=0;\\n            for(int k=0;k<strlen(allowed);k++)\\n            {\\n                if(words[i][j]==allowed[k])\\n                cnt++;\\n            }"]]}
{"id": "359", "ref_c": [["int numberOfMatches(int n) {\\n        return n - 1;\\n    }", "int numberOfMatches(int n) {\\n        return n - 1;\\n    }", "int numberOfMatches(int n) {\\n    return n - 1;\\n}", "int numberOfMatches(int n) {\\n        int matches = 0;\\n        while (n > 1) {\\n            matches += n / 2;\\n            n = (n + 1) / 2;\\n        }", "int numberOfMatches(int n) {\\n        int matches = 0;\\n        while (n > 1) {\\n            matches += n / 2;\\n            n = (n + 1) / 2;\\n        }", "int numberOfMatches(int n) {\\n    int matches = 0;\\n    while (n > 1) {\\n        matches += n / 2;\\n        n = (n + 1) / 2;\\n    }", "int numberOfMatches(int n) {\\n        if (n == 1) {\\n            return 0;\\n        }", "int numberOfMatches(int n) {\\n        if (n == 1) {\\n            return 0;\\n        }", "int numberOfMatches(int n) {\\n    if (n == 1) {\\n        return 0;\\n    }"], ["int numberOfMatches(int n) {\\n        if(n == 1) return 0;\\n        if( n % 2 == 0)\\n            return n/2 + numberOfMatches(n/2);\\n        else\\n            return (n-1)/2 + numberOfMatches((n-1)/2 + 1);\\n    }", "int numberOfMatches(int n){\\n        if(n == 1) return 0;\\n        if( n % 2 == 0)\\n            return n/2 + numberOfMatches(n/2);\\n        else\\n            return (n-1)/2 + numberOfMatches((n-1)/2 + 1);\\n}", "int numberOfMatches(int n) {\\n        if(n == 1) return 0;\\n        if( n % 2 == 0)\\n            return n/2 + numberOfMatches(n/2);\\n        else\\n            return (n-1)/2 + numberOfMatches((n-1)/2 + 1);\\n    }"], ["int numberOfMatches(int n) {\\n        int ans = 0;  // Variable to store the number of matches\\n        \\n        while(n != 1) {  // Continue the loop until \\'n\\' becomes 1 (end of matches)\\n            if(n % 2 != 0) {  // If \\'n\\' is odd\\n                ans += (n - 1) / 2;  // Increment \\'ans\\' by (n - 1) / 2\\n                n = (n - 1) / 2 + 1;  // Update \\'n\\' to ((n - 1) / 2) + 1\\n            }", "int numberOfMatches(int n) {\\n    int ans = 0;  // Variable to store the number of matches\\n    \\n    while (n != 1) {  // Continue the loop until \\'n\\' becomes 1 (end of matches)\\n        if (n % 2 != 0) {  // If \\'n\\' is odd\\n            ans += (n - 1) / 2;  // Increment \\'ans\\' by (n - 1) / 2\\n            n = (n - 1) / 2 + 1;  // Update \\'n\\' to ((n - 1) / 2) + 1\\n        }", "int numberOfMatches(int n) {\\n        int ans = 0;  // Variable to store the number of matches\\n        \\n        while (n != 1) {  // Continue the loop until \\'n\\' becomes 1 (end of matches)\\n            if (n % 2 != 0) {  // If \\'n\\' is odd\\n                ans += (n - 1) / 2;  // Increment \\'ans\\' by (n - 1) / 2\\n                n = (n - 1) / 2 + 1;  // Update \\'n\\' to ((n - 1) / 2) + 1\\n            }", "int numberOfMatches(int n) {\\n        return n - 1;\\n    }", "int numberOfMatches(int n) {\\n    return n - 1;\\n}", "int numberOfMatches(int n) {\\n        return n - 1;\\n    }"]]}
{"id": "361", "ref_c": [["char * reformatNumber(char * number){\\n  char *ans = calloc(strlen(number)+(strlen(number)/3)+1, sizeof(char));\\n  int i, ptr = 0;\\n  int dashes = 0;\\n\\n  for (i=0; i<strlen(number); i++) {\\n    char ch = number[i];\\n    if (ch != \\' \\' && ch != \\'-\\') {\\n      if (((ptr-dashes) != 0) && ((ptr-dashes) % 3 == 0)) {\\n        ans[ptr] = \\'-\\';\\n        dashes++;\\n        ptr++;\\n      }"], ["char * reformatNumber(char * number){\\n    int idx = 0, len = strlen(number);\\n    /* pick number out */\\n    for(int i = 0; i < len; i++){\\n        if(number[i]>=\\'0\\' && number[i]<=\\'9\\')\\n            number[idx++] = number[i];\\n    }"], ["char * reformatNumber(char * number){\\n    int len=0;\\n    char temp[strlen(number)];\\n    while(*number!=\\'\\\\0\\'){\\n        if(*number-\\'0\\' >=0 && *number-\\'0\\' <=9){\\n            temp[len]=*number;\\n            len++;\\n        }"]]}
{"id": "362", "ref_c": [["int countStudents(int* students, int studentsSize, int* sandwiches, int sandwichesSize){\\n    int i, ctr[2] = {0, 0}"], ["int countStudents(int* students, int studentsSize, int* sandwiches, int sandwichesSize) {\\n    /*if st gets sw shift front to next in st queue and sw queue\\n    if st not gets sw shift front to next in st queue but front \\n    remains same in sw queue. Limiting case- count can be used.*/\\n    int f1=0,f2=0,i,count;\\n    \\n    while(f2!=sandwichesSize)\\n    {\\n        if(students[f1]==sandwiches[f2])\\n        {\\n            if(f1==studentsSize-1)\\n            {\\n                f1=0;\\n            }"], ["int countStudents(int* students, int studentsSize, int* sandwiches, int sandwichesSize)\\n{\\n    int i=0;\\n    int no_of_students_prefer_circular = 0;\\n    int no_of_students_prefer_square = 0;\\n\\n    for(i=0; i<studentsSize; i++)\\n    {\\n        if(students[i] == 0)\\n            no_of_students_prefer_circular++;\\n        else\\n            no_of_students_prefer_square++;\\n    }"]]}
{"id": "363", "ref_c": [["bool halvesAreAlike(char * s){\\n\\nint a=0,b=0;\\nfor(int i=0;i<strlen(s);i++)\\n{\\n    if(isVowel(s[i]))\\n    {\\n        if(i<strlen(s)/2) a++;\\n        else b++;\\n    }"], ["bool halvesAreAlike(char * s){\\n\\nint a=0,b=0;\\nfor(int i=0;i<strlen(s);i++)\\n{\\n    if(isVowel(s[i]))\\n    {\\n        if(i<strlen(s)/2) a++;\\n        else b++;\\n    }"], ["bool halvesAreAlike(char * s){\\n\\nint a=0,b=0;\\nfor(int i=0;i<strlen(s);i++)\\n{\\n    if(isVowel(s[i]))\\n    {\\n        if(i<strlen(s)/2) a++;\\n        else b++;\\n    }"]]}
{"id": "364", "ref_c": ["\nstruct Box {\n    int numBoxes;\n    int unitsPerBox;\n};\n\nint compare(const void *a, const void *b) {\n    return ((struct Box *)b)->unitsPerBox - ((struct Box *)a)->unitsPerBox;\n}\n\nint minimum(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize) {\n    int ans = 0;\n    int numOfBoxes = boxTypesSize;\n\n    struct Box* boxes = (struct Box*)malloc(numOfBoxes * sizeof(struct Box));\n\n    // Populate the boxes array\n    for (int i = 0; i < numOfBoxes; ++i) {\n        boxes[i].numBoxes = boxTypes[i][0];\n        boxes[i].unitsPerBox = boxTypes[i][1];\n    }\n\n    qsort(boxes, numOfBoxes, sizeof(struct Box), compare);\n\n    for (int i = 0; i < numOfBoxes; ++i) {\n        ans += minimum(truckSize, boxes[i].numBoxes) * boxes[i].unitsPerBox;\n        truckSize -= minimum(truckSize, boxes[i].numBoxes);\n    }\n\n    free(boxes);\n\n    return ans;\n}\n", "\nstruct Box {\n    int numBoxes;\n    int unitsPerBox;\n};\n\nint compare(const void *a, const void *b) {\n    return ((struct Box *)b)->unitsPerBox - ((struct Box *)a)->unitsPerBox;\n}\n\nint minimum(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize) {\n    int ans = 0;\n    int numOfBoxes = boxTypesSize;\n\n    struct Box* boxes = (struct Box*)malloc(numOfBoxes * sizeof(struct Box));\n\n    // Populate the boxes array\n    for (int i = 0; i < numOfBoxes; ++i) {\n        boxes[i].numBoxes = boxTypes[i][0];\n        boxes[i].unitsPerBox = boxTypes[i][1];\n    }\n\n    qsort(boxes, numOfBoxes, sizeof(struct Box), compare);\n\n    for (int i = 0; i < numOfBoxes; ++i) {\n        ans += minimum(truckSize, boxes[i].numBoxes) * boxes[i].unitsPerBox;\n        truckSize -= minimum(truckSize, boxes[i].numBoxes);\n    }\n\n    free(boxes);\n\n    return ans;\n}\n", "\nstruct Box {\n    int numBoxes;\n    int unitsPerBox;\n};\n\nint compare(const void *a, const void *b) {\n    return ((struct Box *)b)->unitsPerBox - ((struct Box *)a)->unitsPerBox;\n}\n\nint minimum(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize) {\n    int ans = 0;\n    int numOfBoxes = boxTypesSize;\n\n    struct Box* boxes = (struct Box*)malloc(numOfBoxes * sizeof(struct Box));\n\n    // Populate the boxes array\n    for (int i = 0; i < numOfBoxes; ++i) {\n        boxes[i].numBoxes = boxTypes[i][0];\n        boxes[i].unitsPerBox = boxTypes[i][1];\n    }\n\n    qsort(boxes, numOfBoxes, sizeof(struct Box), compare);\n\n    for (int i = 0; i < numOfBoxes; ++i) {\n        ans += minimum(truckSize, boxes[i].numBoxes) * boxes[i].unitsPerBox;\n        truckSize -= minimum(truckSize, boxes[i].numBoxes);\n    }\n\n    free(boxes);\n\n    return ans;\n}\n"]}
{"id": "365", "ref_c": [["int totalMoney(int n) {\\n       int week=n/7;\\n       int ans=solve(week);\\n       int day=n%7;\\n       if(day==0){\\n           return ans;\\n       }", "int totalMoney(int n) {\\n        int week = n / 7;\\n        int ans = solve(week);\\n        int day = n % 7;\\n        if (day == 0) {\\n            return ans;\\n        }"], ["int totalMoney(int n) {\\n        int ans = 0;        // Variable to store the total money earned\\n        int monday = 1;     // Represents the amount earned on Monday\\n        \\n        while (n > 0) {     // Continue the loop until \\'n\\' days are exhausted\\n            for (int day = 0; day < min(n, 7); day++) {  // Iterate for each day of the week or until \\'n\\' days are left\\n                ans += monday + day;  // Increment \\'ans\\' by the amount earned on the current day (monday + day)\\n            }", "int totalMoney(int n) {\\n    int ans = 0;        // Variable to store the total money earned\\n    int monday = 1;     // Represents the amount earned on Monday\\n    \\n    while (n > 0) {     // Continue the loop until \\'n\\' days are exhausted\\n        for (int day = 0; day < (n < 7 ? n : 7); day++) {  // Iterate for each day of the week or until \\'n\\' days are left\\n            ans += monday + day;  // Increment \\'ans\\' by the amount earned on the current day (monday + day)\\n        }", "int totalMoney(int n) {\\n        int ans = 0;\\n        int monday = 1;\\n        \\n        while (n > 0) {\\n            for (int day = 0; day < Math.min(n, 7); day++) {\\n                ans += monday + day;\\n            }", "int totalMoney(int n) {\\n        int ans = 0;\\n        int weeks = n / 7;  // Calculate the number of complete weeks\\n        int days = n % 7;   // Calculate the remaining days\\n        \\n        // Calculate the total money earned from complete weeks\\n        // Using the formula for an arithmetic series: sum = n * (a1 + an) / 2\\n        ans += 28 * weeks + 7 * (weeks - 1) * weeks / 2; // 28 + 35 + 42 + ... + (28 + 7 * (weeks - 1))\\n        \\n        // Calculate the total money earned from remaining days\\n        // Starting from the next day after the last complete week\\n        int startMoney = weeks + 1; // Money earned on the first day of the remaining days\\n        ans += (startMoney + startMoney + days - 1) * days / 2; // a1 + an = (a1 + an) * n / 2\\n\\n        return ans;\\n    }", "int totalMoney(int n) {\\n    int ans = 0;\\n    int weeks = n / 7;  // Calculate the number of complete weeks\\n    int days = n % 7;   // Calculate the remaining days\\n    \\n    // Calculate the total money earned from complete weeks\\n    // Using the formula for an arithmetic series: sum = n * (a1 + an) / 2\\n    ans += 28 * weeks + 7 * (weeks - 1) * weeks / 2; // 28 + 35 + 42 + ... + (28 + 7 * (weeks - 1))\\n    \\n    // Calculate the total money earned from remaining days\\n    // Starting from the next day after the last complete week\\n    int startMoney = weeks + 1; // Money earned on the first day of the remaining days\\n    ans += (startMoney + startMoney + days - 1) * days / 2; // a1 + an = (a1 + an) * n / 2\\n\\n    return ans;\\n}", "int totalMoney(int n) {\\n        int ans = 0;\\n        int weeks = n / 7;  // Calculate the number of complete weeks\\n        int days = n % 7;   // Calculate the remaining days\\n        \\n        // Calculate the total money earned from complete weeks\\n        // Using the formula for an arithmetic series: sum = n * (a1 + an) / 2\\n        ans += 28 * weeks + 7 * (weeks - 1) * weeks / 2; // 28 + 35 + 42 + ... + (28 + 7 * (weeks - 1))\\n        \\n        // Calculate the total money earned from remaining days\\n        // Starting from the next day after the last complete week\\n        int startMoney = weeks + 1; // Money earned on the first day of the remaining days\\n        ans += (startMoney + startMoney + days - 1) * days / 2; // a1 + an = (a1 + an) * n / 2\\n\\n        return ans;\\n    }", "int totalMoney(int n) {\\n        int k = n / 7;      // Calculate the number of complete weeks\\n        int F = 28;         // Initial earning for the first week\\n        int L = 28 + (k - 1) * 7;  // Earning for the last week\\n        int arithmeticSum = k * (F + L) / 2;  // Calculate the total earnings from complete weeks using arithmetic series formula\\n        \\n        int monday = 1 + k;  // Earnings on Monday for the final week\\n        int finalWeek = 0;\\n        \\n        // Calculate earnings for the final incomplete week\\n        for (int day = 0; day < n % 7; day++) {\\n            finalWeek += monday + day;  // Increment earnings for each day of the final incomplete week\\n        }", "int totalMoney(int n) {\\n    int k = n / 7;      // Calculate the number of complete weeks\\n    int F = 28;         // Initial earning for the first week\\n    int L = 28 + (k - 1) * 7;  // Earning for the last week\\n    int arithmeticSum = k * (F + L) / 2;  // Calculate the total earnings from complete weeks using arithmetic series formula\\n    \\n    int monday = 1 + k;  // Earnings on Monday for the final week\\n    int finalWeek = 0;\\n    \\n    // Calculate earnings for the final incomplete week\\n    for (int day = 0; day < n % 7; day++) {\\n        finalWeek += monday + day;  // Increment earnings for each day of the final incomplete week\\n    }", "int totalMoney(int n) {\\n        int k = n / 7;\\n        int F = 28;\\n        int L = 28 + (k - 1) * 7;\\n        int arithmeticSum = k * (F + L) / 2;\\n        \\n        int monday = 1 + k;\\n        int finalWeek = 0;\\n        for (int day = 0; day < n % 7; day++) {\\n            finalWeek += monday + day;\\n        }"], ["int totalMoney(int n) {\\n  int sum = 0;\\n  int current_value = 1;\\n  for (int i = 1; i <= n; ++i) {\\n    sum += current_value;\\n\\n    if (i % 7 == 0 && i != 0) {\\n      current_value -= 5;\\n    }", "int totalMoney(int n) {\\n  int sum = 0;\\n  int current_value = 1;\\n  for (int i = 1; i <= n; ++i) {\\n    sum += current_value;\\n\\n    if (i % 7 == 0 && i != 0) {\\n      current_value -= 5;\\n    }", "int totalMoney(int n) {\\n    int sum = 0;\\n    int currentValue = 1;\\n    for (int i = 1; i <= n; i++) {\\n      sum += currentValue;\\n\\n      if (i % 7 == 0 && i != 0) {\\n        currentValue -= 5;\\n      }", "int totalMoney(int n) {\\n    int weeks = n / 7;\\n    int remaining_days = n % 7;\\n\\n    // Calculate the sum of full weeks\\n    int sum = 28 * weeks + 7 * (weeks - 1) * weeks / 2;\\n\\n    // Add the sum of remaining days\\n    sum += remaining_days * (remaining_days + 1) / 2 + weeks * remaining_days;\\n\\n    return sum;\\n}", "int totalMoney(int n) {\\n  int weeks = n / 7;\\n  int remaining_days = n % 7;\\n\\n  // Calculate the sum of full weeks\\n  int sum = 28 * weeks + 7 * (weeks - 1) * weeks / 2;\\n\\n  // Add the sum of remaining days\\n  sum += remaining_days * (remaining_days + 1) / 2 + weeks * remaining_days;\\n\\n  return sum;\\n}", "int totalMoney(int n) {\\n        int weeks = n / 7;\\n        int remainingDays = n % 7;\\n\\n        // Calculate the sum of full weeks\\n        int sum = 28 * weeks + 7 * (weeks - 1) * weeks / 2;\\n\\n        // Add the sum of remaining days\\n        sum += remainingDays * (remainingDays + 1) / 2 + weeks * remainingDays;\\n\\n        return sum;\\n    }"]]}
{"id": "366", "ref_c": [["int* decode(int* encoded, int encodedSize, int first, int* returnSize) {\\n    int *arr = (int *)malloc((encodedSize + 1) * sizeof(int));\\n    if (arr == NULL) {\\n        return NULL;\\n    }"], ["int* decode(int* encoded, int encodedSize, int first, int* returnSize) {\\n    int index=0;\\n    int *arr = (int *)malloc((encodedSize+1)*sizeof(int));\\n    arr[index] = first;\\n    index++;\\n    for(int i=0; i<encodedSize; i++){\\n            arr[index] = arr[index-1]^encoded[i];\\n            index++;\\n    }"], ["int* decode(int* encoded, int encodedSize, int first, int* returnSize) {\\n    *returnSize  = encodedSize + 1;\\n    int *arr = (int *)malloc(sizeof(int) * (encodedSize + 1));\\n    arr[0] = first;\\n    for(int i = 0; i < encodedSize; i++){\\n        arr[i + 1] = arr[i] ^ encoded[i];\\n    }"]]}
{"id": "367", "ref_c": [["int countGoodRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize){\\n    int maxSide = 0;\\n    int amt = 0;\\n    for(int i = 0; i < rectanglesSize; i++){\\n        if(rectangles[i][0] < rectangles[i][1]){\\n            if(rectangles[i][0] == maxSide){\\n                amt++;\\n            }"], ["int countGoodRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize){\\n    int maxSide = 0;\\n    int amt = 0;\\n    for(int i = 0; i < rectanglesSize; i++){\\n        if(rectangles[i][0] < rectangles[i][1]){\\n            if(rectangles[i][0] == maxSide){\\n                amt++;\\n            }"], ["int countGoodRectangles(int** rectangles, int rectanglesSize, int* rectanglesColSize){\\n    int maxLen = 0;\\n    int c = 0;\\n    int* squares = malloc(rectanglesSize * sizeof(int));\\n\\n    for(int i = 0 ; i < rectanglesSize ; i++)\\n    {\\n        if (rectangles[i][0] > rectangles[i][1])\\n        {\\n            squares[i] = rectangles[i][1];\\n        }"]]}
{"id": "370", "ref_c": [["int largestAltitude(int* gain, int gainSize)\\n{\\n    int maxal=0;\\n    int sum=0;\\n    for(int i=0;i<gainSize;i++)\\n    {\\n        sum = sum + gain[i];\\n        if(sum>maxal)\\n        {\\n            maxal = sum;\\n        }"], ["int largestAltitude(int* gain, int gainSize){\\n    int max = 0;\\n    int temp = 0;\\n    for(int i=0;i<gainSize;i++){\\n        temp += gain[i];\\n        if(temp > max){\\n            max = temp;\\n        }"], ["int largestAltitude(int* gain, int gainSize){\\n    int G[gainSize+1];\\n    G[0]=0;\\n    for(int i=0;i<gainSize;i++)\\n        G[i+1]=G[i]+gain[i];\\n    int M=G[0];\\n    for(int i=0;i<gainSize+1;i++){\\n        if(M<G[i])\\n            M=G[i];\\n    }"]]}
{"id": "371", "ref_c": [["char * maximumTime(char * time){\\n    \\n    for (int i = 0; time[i] != \\'\\\\0\\'; i++) {\\n        if (i == 0 && time[i] == \\'?\\') {\\n            if (time[i+1] == \\'1\\' || time[i+1] == \\'2\\' || time[i+1] == \\'3\\' || time[i+1] == \\'0\\' || time[i+1] == \\'?\\')\\n                time[i] = \\'2\\';\\n            else \\n                time[i] = \\'1\\';\\n        }"], ["char * maximumTime(char * time){\\nif (time[0] == \\'?\\' && time[1] == \\'?\\') {\\n        time[0] = \\'2\\';\\n        time[1] = \\'3\\';\\n    }"], ["char * maximumTime(char * time){\\n    \\n    for (int i = 0; time[i] != \\'\\\\0\\'; i++) {\\n        if (i == 0 && time[i] == \\'?\\') {\\n            if (time[i+1] == \\'1\\' || time[i+1] == \\'2\\' || time[i+1] == \\'3\\' || time[i+1] == \\'0\\' || time[i+1] == \\'?\\')\\n                time[i] = \\'2\\';\\n            else \\n                time[i] = \\'1\\';\\n        }"]]}
{"id": "373", "ref_c": [["int countBalls(int lowLimit, int highLimit) {\\n    int i,j,k=0,sum,rem;\\n    int n=highLimit-lowLimit + 1;\\n    int b[n];\\n    for(i=lowLimit;i<=highLimit;i++)\\n    {\\n        int temp=i;\\n        sum=0;\\n        while(temp>0)\\n        {\\n            rem=temp%10;\\n            sum=sum+rem;\\n            temp=temp/10;\\n        }", "int countBalls(int lowLimit, int highLimit) {\\n    int count[55]={0}"], ["int countBalls(int lowLimit, int highLimit) {\\n  int n, sum = 0;\\n  int p[46] = {\\n    0\\n  }"], ["int countBalls(int lowLimit, int highLimit){\\n\\n    int freqArr[10001] = {0,}"]]}
{"id": "374", "ref_c": [["int sumOfUnique(int* nums, int numsSize){\\nint i,j,sum=0;\\n   int A[101]={0}"], ["int sumOfUnique(int* nums, int numsSize) {\\nint count = 0;  \\nfor (int i = 0; i < numsSize; ++i) {\\nHASH_FIND_INT(hash,&nums[i],elem);\\nif (!elem) {\\n    elem = malloc(sizeof(hash_table));\\n    elem->val = 1;\\n    elem->key = nums[i];\\n    HASH_ADD_INT(hash,key,elem);\\n}"], ["int sumOfUnique(int* nums, int numsSize) {\\n    int hash[101] = { 0 }"]]}
{"id": "375", "ref_c": ["\nbool check(int* nums, int numsSize) {\n    int count=0;\nfor(int i=1;i<numsSize;i++){\n    if(nums[i]<nums[i-1])\n   count++;\n} \nif(nums[0]<nums[numsSize-1])\ncount++;\nif(count<=1)\nreturn true;\nelse\nreturn false;\n}\n", "\nbool check(int* nums, int numsSize) {\n    int count=0;\nfor(int i=1;i<numsSize;i++){\n    if(nums[i]<nums[i-1])\n   count++;\n} \nif(nums[0]<nums[numsSize-1])\ncount++;\nif(count<=1)\nreturn true;\nelse\nreturn false;\n}\n", "\nbool check(int* nums, int numsSize) {\n    int count=0;\nfor(int i=1;i<numsSize;i++){\n    if(nums[i]<nums[i-1])\n   count++;\n} \nif(nums[0]<nums[numsSize-1])\ncount++;\nif(count<=1)\nreturn true;\nelse\nreturn false;\n}\n"]}
{"id": "377", "ref_c": ["\nint minOperations(char *s){\n    int count1=0,count2=0;\n    for(int i=0;s[i];i++)\n    {\n        if(s[i]!=('0'+i%2))\n        {\n            count1++;\n        }\n        if(s[i]!=('1'-i%2))\n        {\n            count2++;\n        }\n    }\n    count1=count1<=count2?count1:count2;\n    return count1;\n}\n", "\nint minOperations(char *s){\n    int count1=0,count2=0;\n    for(int i=0;s[i];i++)\n    {\n        if(s[i]!=('0'+i%2))\n        {\n            count1++;\n        }\n        if(s[i]!=('1'-i%2))\n        {\n            count2++;\n        }\n    }\n    count1=count1<=count2?count1:count2;\n    return count1;\n}\n", "\nint minOperations(char *s){\n    int count1=0,count2=0;\n    for(int i=0;s[i];i++)\n    {\n        if(s[i]!=('0'+i%2))\n        {\n            count1++;\n        }\n        if(s[i]!=('1'-i%2))\n        {\n            count2++;\n        }\n    }\n    count1=count1<=count2?count1:count2;\n    return count1;\n}\n"]}
{"id": "378", "ref_c": [["char * longestNiceSubstring(char * s){\\n    int max_len = 0, idx = -1, n = strlen(s); // max_len: the length of result, idx: the start position\\n    int lower_case, upper_case; // record the position of upper case and lower case respectively\\n    for (int i = 0; i < n; i++) {\\n        lower_case = 0;\\n        upper_case = 0;\\n        for (int j = i; j < n; j++) {\\n            // find letter\\'s position using c & 31 for both lower and upper case\\n            if (s[j] >= \\'A\\' && s[j] <= \\'Z\\') {\\n                upper_case |= (1 << (s[j] & 31));\\n            }"], ["char * longestNiceSubstring(char * s){\\n    int len = strlen(s);\\n\\n    //find the begin & end index.\\n    struct body pair = findLongestNiceS(s,0,len);\\n\\n    //copy the answer\\n    char* res = (char*)malloc(sizeof(char) * ((pair.tail - pair.head)+1));\\n    res[(pair.tail - pair.head)] = \\'\\\\0\\';\\n    memcpy(res,&(s[pair.head]),(pair.tail - pair.head) * sizeof(char));\\n    return res;\\n}"], ["char * longestNiceSubstring(char * s){\\n    int max_len = 0, idx = -1, n = strlen(s); // max_len: the length of result, idx: the start position\\n    int lower_case, upper_case; // record the position of upper case and lower case respectively\\n    for (int i = 0; i < n; i++) {\\n        lower_case = 0;\\n        upper_case = 0;\\n        for (int j = i; j < n; j++) {\\n            // find letter\\'s position using c & 31 for both lower and upper case\\n            if (s[j] >= \\'A\\' && s[j] <= \\'Z\\') {\\n                upper_case |= (1 << (s[j] & 31));\\n            }"]]}
{"id": "379", "ref_c": [["char * mergeAlternately(char * word1, char * word2){\\n    int len1 = strlen(word1);\\n    int len2 = strlen(word2);\\n    int returnSize = len1+len2;\\n    char* result = malloc((returnSize+1)*sizeof(char));\\n    int i=0,j=0,k=0;\\n    while(i<len1 || j<len2)\\n    {\\n        if(i<len1)\\n        {\\n            result[k++] = word1[i++];\\n        }"], ["char * mergeAlternately(char * word1, char * word2){\\nint n1=strlen(word1);\\nint n2=strlen(word2);\\n    char *w3=malloc((n1+n2+1)*sizeof(char));\\n    int i=0,j=0,idx=0;\\n    while(word1[i]!=\\'\\\\0\\' || word2[j]!=\\'\\\\0\\')\\n    {\\n        if(word1[i]==\\'\\\\0\\')\\n        {\\n            w3[idx++]=word2[j++];\\n        }"], ["char * mergeAlternately(char * word1, char * word2){\\nint n1=strlen(word1);\\nint n2=strlen(word2);\\n    char *w3=malloc((n1+n2+1)*sizeof(char));\\n    int i=0,j=0,idx=0;\\n    while(word1[i]!=\\'\\\\0\\' || word2[j]!=\\'\\\\0\\')\\n    {\\n        if(word1[i]==\\'\\\\0\\')\\n        {\\n            w3[idx++]=word2[j++];\\n        }"]]}
{"id": "380", "ref_c": [["int countMatches(char *** items, int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue){\\n    int matches = 0;\\n    int i, c = 0;\\n    \\n    switch(ruleKey[0]) {\\n        case \\'t\\': c = TYPE; break;\\n        case \\'c\\': c = COLOR; break;\\n        case \\'n\\': c = NAME; break;\\n        default: return -1;\\n    }"], ["int countMatches(char *** items, int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue){\\n    int matches = 0;\\n    int i, c = 0;\\n    \\n    switch(ruleKey[0]) {\\n        case \\'t\\': c = TYPE; break;\\n        case \\'c\\': c = COLOR; break;\\n        case \\'n\\': c = NAME; break;\\n        default: return -1;\\n    }"], ["int countMatches(char *** items, int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue){\\n    int matches = 0;\\n    int i, c = 0;\\n    \\n    switch(ruleKey[0]) {\\n        case \\'t\\': c = TYPE; break;\\n        case \\'c\\': c = COLOR; break;\\n        case \\'n\\': c = NAME; break;\\n        default: return -1;\\n    }"]]}
{"id": "381", "ref_c": [["int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){\\n    int dist=99999,index=-1;\\n    for(int i=0;i<pointsSize;i++){\\n        if(points[i][0]==x || points[i][1]==y){\\n            if(abs(points[i][0]-x)+abs(points[i][1]-y)<dist){\\n                dist=abs(points[i][0]-x)+abs(points[i][1]-y);\\n                index=i;\\n            }"], ["int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){\\n    int retIndex = -1;\\n    int min = INT_MAX;\\n    for(int i = 0; i < pointsSize; i++){\\n        if(x == points[i][0] || y == points[i][1]){\\n            int dist = abs(x - points[i][0]) + abs(y - points[i][1]);\\n            if(min > dist){\\n                min = dist; \\n                retIndex = i;\\n            }"], ["int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){\\n    int index = -1;\\n    int Manhattan_distance = 0;\\n    int DIstance = 0;\\n    for(int i=0;i<pointsSize;i++)\\n    {\\n        if(points[i][0]==x||points[i][1]==y)\\n        {\\n           DIstance = abs(points[i][0]-x)+abs(points[i][1]-y);\\n           index = i;\\n           break;\\n        }"]]}
{"id": "382", "ref_c": [["bool checkOnesSegment(char * s){\\n    return !strstr(s, \"01\");\\n}"], ["bool checkOnesSegment(char * s){\\n    if(s[0]==1) {\\n        return true;\\n        }"], ["bool checkOnesSegment(char * s){\\n    if(s[0]==1) {\\n        return true;\\n        }"]]}
{"id": "384", "ref_c": ["\nbool areAlmostEqual(char* s1, char* s2) \n{\n    int j = -1, k = -1, len = strlen(s1), count_unequal = 0;\n    for(int i = 0; i < len; i++)\n    {\n        if(s1[i] != s2[i])\n        {\n            count_unequal++;\n            if(j == -1)\n            {\n                j = i;\n            }\n            else if(k == -1)\n            {\n                k = i;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    return (count_unequal == 0) || (count_unequal == 2 && s1[j] == s2[k] && s1[k] == s2[j]);  \n}\n", "\nbool areAlmostEqual(char* s1, char* s2) \n{\n    int j = -1, k = -1, len = strlen(s1), count_unequal = 0;\n    for(int i = 0; i < len; i++)\n    {\n        if(s1[i] != s2[i])\n        {\n            count_unequal++;\n            if(j == -1)\n            {\n                j = i;\n            }\n            else if(k == -1)\n            {\n                k = i;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    return (count_unequal == 0) || (count_unequal == 2 && s1[j] == s2[k] && s1[k] == s2[j]);  \n}\n", "\nbool areAlmostEqual(char* s1, char* s2) \n{\n    int j = -1, k = -1, len = strlen(s1), count_unequal = 0;\n    for(int i = 0; i < len; i++)\n    {\n        if(s1[i] != s2[i])\n        {\n            count_unequal++;\n            if(j == -1)\n            {\n                j = i;\n            }\n            else if(k == -1)\n            {\n                k = i;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    return (count_unequal == 0) || (count_unequal == 2 && s1[j] == s2[k] && s1[k] == s2[j]);  \n}\n"]}
{"id": "385", "ref_c": [["int findCenter(int** edges, int edgesSize, int* edgesColSize){\\n    return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]? edges[0][0]: edges[0][1];\\n}"], ["int findCenter(int** edges, int edgesSize, int* edgesColSize){\\n    int centro;\\n    int coluna = 0; \\n    int candidato = edges[0][coluna];\\n    int n = 0;\\n    for(int l = 0; l < edgesSize; l++){\\n        for(int c = 0; c < edgesColSize[l]; c++){\\n            if(candidato == edges[l][c]){\\n                centro = edges[l][c];\\n                n++;\\n            }"], ["int findCenter(int** edges, int edgesSize, int* edgesColSize){\\n    int centro;\\n    int coluna = 0; \\n    int candidato = edges[0][coluna];\\n    int n = 0;\\n    for(int l = 0; l < edgesSize; l++){\\n        for(int c = 0; c < edgesColSize[l]; c++){\\n            if(candidato == edges[l][c]){\\n                centro = edges[l][c];\\n                n++;\\n            }"]]}
{"id": "387", "ref_c": [["int secondHighest(char * s){\\n    int largest=-1;\\n    int larger=-1;\\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]-\\'0\\'>=0 && s[i]-\\'0\\'<=9){\\n            int num=s[i]-\\'0\\';\\n            if(num>largest){\\n                larger=largest;\\n                largest=num;\\n            }"], ["int secondHighest(char * s){\\n    int largest = -1, second_largest = -1;\\n    for (size_t i = 0; s[i] != \\'\\\\0\\'; i++)\\n    {\\n        if (isdigit(s[i]))\\n        {\\n            int digit = s[i] - \\'0\\';\\n            if (digit > largest)\\n            {\\n                second_largest = largest;\\n                largest = digit;\\n            }"], ["int secondHighest(char * s){\\nint max = -1, smax = -1;\\n\\nfor(int i =0; i < strlen(s); i++){\\n    if(isdigit(s[i])){\\n        int num = s[i] - \\'0\\';\\n        if(num > max){\\n            smax = max;\\n            max = num;\\n        }"]]}
{"id": "388", "ref_c": [["int maxAscendingSum(int* nums, int numsSize){\\n    int i=1,s1 = nums[0],s2 = 0;\\n        for(;i<numsSize;i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                s1 += nums[i];\\n            }"], ["int maxAscendingSum(int* nums, int numsSize){\\n    int maxSum = 0;\\n    int i = 0;\\n    while (i < numsSize) {\\n        int j = i + 1;\\n        int ascendingSum = nums[i];\\n        while (j < numsSize && nums[j] > nums[j-1]) {\\n            ascendingSum += nums[j];\\n            j++;\\n        }"], ["int maxAscendingSum(int* nums, int numsSize){\\n    int maxSum = 0;\\n    int i = 0;\\n    while (i < numsSize) {\\n        int j = i + 1;\\n        int ascendingSum = nums[i];\\n        while (j < numsSize && nums[j] > nums[j-1]) {\\n            ascendingSum += nums[j];\\n            j++;\\n        }"]]}
{"id": "389", "ref_c": [["int numDifferentIntegers(char * word){\\n    int i, num, j = 0, flag;\\n    char *str;\\n    char **reg = (char**)malloc(1000 * sizeof(char*));\\n    \\n    str = strtok(word, \"abcdefghijklmnopqrstuvwxyz\");\\n    while(str != NULL){\\n        \\n        // Delete leading zeros. \\n        while(*str == \\'0\\') \\n            str++;\\n        \\n        // Check if str exists in reg. \\n        for(i = 0, flag = 1; i < j; i++){\\n            if(!strcmp(reg[i], str)){\\n                flag = 0;\\n                break;\\n            }"], ["int numDifferentIntegers(char * word){\\n    int i, num, j = 0, flag;\\n    char *str;\\n    char **reg = (char**)malloc(1000 * sizeof(char*));\\n    \\n    str = strtok(word, \"abcdefghijklmnopqrstuvwxyz\");\\n    while(str != NULL){\\n        \\n        // Delete leading zeros. \\n        while(*str == \\'0\\') \\n            str++;\\n        \\n        // Check if str exists in reg. \\n        for(i = 0, flag = 1; i < j; i++){\\n            if(!strcmp(reg[i], str)){\\n                flag = 0;\\n                break;\\n            }"], ["int numDifferentIntegers(char * word){\\n    int i, num, j = 0, flag;\\n    char *str;\\n    char **reg = (char**)malloc(1000 * sizeof(char*));\\n    \\n    str = strtok(word, \"abcdefghijklmnopqrstuvwxyz\");\\n    while(str != NULL){\\n        \\n        // Delete leading zeros. \\n        while(*str == \\'0\\') \\n            str++;\\n        \\n        // Check if str exists in reg. \\n        for(i = 0, flag = 1; i < j; i++){\\n            if(!strcmp(reg[i], str)){\\n                flag = 0;\\n                break;\\n            }"]]}
{"id": "390", "ref_c": [["bool squareIsWhite(char * coordinates){\\n    // assume that the letter always is A and shift ranks and files\\n    if ((coordinates[1] + coordinates[0] - 1) % 2 == 0) return true; return false;\\n}"], ["bool squareIsWhite(char * coordinates){\\n    if((coordinates[1]-\\'1\\' + (int)coordinates[0]-(int)\\'a\\')%2==0)\\n    return false;\\n    else\\n    return true;\\n\\n}"], ["bool squareIsWhite(char * coordinates){\\n    // assume that the letter always is A and shift ranks and files\\n    if ((coordinates[1] + coordinates[0] - 1) % 2 == 0) return true; return false;\\n}"]]}
{"id": "391", "ref_c": [["char * truncateSentence(char * s, int k){\\n    int i,spaces=0;\\n    for(i=0; i<strlen(s) ;i++){\\n        if(s[i]==\\' \\')\\n            spaces++;\\n        if(spaces==k)\\n            break;\\n    }"], ["char * truncateSentence(char * s, int k){\\n    int i,spaces=0;\\n    for(i=0; i<strlen(s) ;i++){\\n        if(s[i]==\\' \\')\\n            spaces++;\\n        if(spaces==k)\\n            break;\\n    }"], ["char * truncateSentence(char * s, int k){\\n    int i,spaces=0;\\n    for(i=0; i<strlen(s) ;i++){\\n        if(s[i]==\\' \\')\\n            spaces++;\\n        if(spaces==k)\\n            break;\\n    }"]]}
{"id": "392", "ref_c": [["int arraySign(int* nums, int numsSize)\\n{\\n    int i,a=1;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        a *= signFunc(nums[i]);\\n    }"], ["int arraySign(int* nums, int numsSize)\\n{\\n    int i,a=1;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        a *= signFunc(nums[i]);\\n    }"], ["int arraySign(int* nums, int numsSize)\\n{\\n    int i,a=1;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        a *= signFunc(nums[i]);\\n    }"]]}
{"id": "393", "ref_c": [["int minOperations(int* nums, int numsSize){\\n    int ops = 0;\\n    for (int i = 0; i < numsSize - 1; i++) {\\n        if (nums[i] >= nums[i+1]) {\\n            const int d = nums[i] - nums[i+1] + 1;\\n            nums[i+1] += d;\\n            ops += d;\\n        }"], ["int minOperations(int* nums, int numsSize){\\n    int count=0,i;\\n    for(i=0;i<numsSize-1;i++){\\n        if(nums[i]>=nums[i+1]){\\n            int val=(nums[i]-nums[i+1]+1);\\n            nums[i+1]=nums[i+1]+val;\\n            count+=val;\\n        }"], ["int minOperations(int* nums, int numsSize){\\n    int count = 0;\\n    for(int i = 0; i < numsSize-1; i++)\\n    {\\n        if(nums[i] >= nums[i+1])\\n        {\\n            count  +=  nums[i]+1 - nums[i+1];\\n            nums[i+1] = nums[i]+1;\\n        }"]]}
{"id": "394", "ref_c": [["bool checkIfPangram(char * sentence)\\n{\\n    int n = strlen(sentence);\\n    int ans = 0;//The number in bit with :  i\\'th bit =1 <=> the i\\'th letter has been seen\\n    for (int i=0;i<n;i++)\\n    {\\n        int char_act = sentence[i]; //set the ASCII code of sentence[i] to char_act\\n        int base = \\'a\\';\\n        ans|= (1<<(char_act-base)); //when we see the i\\'th letter we set the i\\'th bit of ans to 1\\n\\t\\t//example of a|= b (in bit) : 1001|0100 = 1101 , 1001|1000 = 1001 because 1 or 1 =1 \\n\\t\\t//1<<2 = 100  , 1<<a = 100000 (the number of 0 is a) \\n    }"], ["bool checkIfPangram(char * sentence)\\n{\\n    int n = strlen(sentence);\\n    int ans = 0;//The number in bit with :  i\\'th bit =1 <=> the i\\'th letter has been seen\\n    for (int i=0;i<n;i++)\\n    {\\n        int char_act = sentence[i]; //set the ASCII code of sentence[i] to char_act\\n        int base = \\'a\\';\\n        ans|= (1<<(char_act-base)); //when we see the i\\'th letter we set the i\\'th bit of ans to 1\\n\\t\\t//example of a|= b (in bit) : 1001|0100 = 1101 , 1001|1000 = 1001 because 1 or 1 =1 \\n\\t\\t//1<<2 = 100  , 1<<a = 100000 (the number of 0 is a) \\n    }"], ["bool checkIfPangram(char * sentence)\\n{\\n    int n = strlen(sentence);\\n    int ans = 0;//The number in bit with :  i\\'th bit =1 <=> the i\\'th letter has been seen\\n    for (int i=0;i<n;i++)\\n    {\\n        int char_act = sentence[i]; //set the ASCII code of sentence[i] to char_act\\n        int base = \\'a\\';\\n        ans|= (1<<(char_act-base)); //when we see the i\\'th letter we set the i\\'th bit of ans to 1\\n\\t\\t//example of a|= b (in bit) : 1001|0100 = 1101 , 1001|1000 = 1001 because 1 or 1 =1 \\n\\t\\t//1<<2 = 100  , 1<<a = 100000 (the number of 0 is a) \\n    }"]]}
{"id": "395", "ref_c": [["int sumBase(int n, int k) {\\n    int sum=0;\\n    while(n!=0){\\n        sum=sum+n%k;\\n        n/=k;\\n       \\n    }"], ["int sumBase(int n, int k){\\nint sum=0;\\nwhile(n!=0)\\n{\\n    sum+=(n%k);\\n    n/=k;\\n}"], ["int sumBase(int n, int k) {\\n        int ans = 0;\\n        while(n!=0){\\n            ans += n%k;\\n            n = n / k;\\n        }"]]}
{"id": "396", "ref_c": ["\nint str_length(char *s)\n{\n    int Result = 0;\n    for(char *c = s; *c != '\u0000'; c++)\n    {\n        Result++;\n    }\n    return(Result);\n}\n\nint char_to_digit(char c)\n{\n    switch(c)\n    {\n        case '0':\n        {\n            return(0);\n        } break;\n        case '1':\n        {\n            return(1);\n        } break;\n        case '2':\n        {\n            return(2);\n        } break;\n        case '3':\n        {\n            return(3);\n        } break;\n        case '4':\n        {\n            return(4);\n        } break;\n        case '5':\n        {\n            return(5);\n        } break;\n        case '6':\n        {\n            return(6);\n        } break;\n        case '7':\n        {\n            return(7);\n        } break;\n        case '8':\n        {\n            return(8);\n        } break;\n        case '9':\n        {\n            return(9);\n        } break;\n        default:\n        {\n            return(0);\n        }\n    }\n}\n\nchar shift(char c, int amount)\n{\n   char Result = c + amount;\n   return(Result);\n}\nchar* replaceDigits(char* s) {\n    char *Result = s;\n\n    int length = str_length(s);\n    for(int char_index = 0; char_index < length / 2; char_index++)\n    {\n       char *at = s + (2 * char_index);  \n       char *next = s + (2 * char_index + 1);\n       \n       int digit = char_to_digit(*next);\n\n       *next = shift(*at, digit);\n    }\n    return(Result);\n}\n", "\nint str_length(char *s)\n{\n    int Result = 0;\n    for(char *c = s; *c != '\u0000'; c++)\n    {\n        Result++;\n    }\n    return(Result);\n}\n\nint char_to_digit(char c)\n{\n    switch(c)\n    {\n        case '0':\n        {\n            return(0);\n        } break;\n        case '1':\n        {\n            return(1);\n        } break;\n        case '2':\n        {\n            return(2);\n        } break;\n        case '3':\n        {\n            return(3);\n        } break;\n        case '4':\n        {\n            return(4);\n        } break;\n        case '5':\n        {\n            return(5);\n        } break;\n        case '6':\n        {\n            return(6);\n        } break;\n        case '7':\n        {\n            return(7);\n        } break;\n        case '8':\n        {\n            return(8);\n        } break;\n        case '9':\n        {\n            return(9);\n        } break;\n        default:\n        {\n            return(0);\n        }\n    }\n}\n\nchar shift(char c, int amount)\n{\n   char Result = c + amount;\n   return(Result);\n}\nchar* replaceDigits(char* s) {\n    char *Result = s;\n\n    int length = str_length(s);\n    for(int char_index = 0; char_index < length / 2; char_index++)\n    {\n       char *at = s + (2 * char_index);  \n       char *next = s + (2 * char_index + 1);\n       \n       int digit = char_to_digit(*next);\n\n       *next = shift(*at, digit);\n    }\n    return(Result);\n}\n", "\nint str_length(char *s)\n{\n    int Result = 0;\n    for(char *c = s; *c != '\u0000'; c++)\n    {\n        Result++;\n    }\n    return(Result);\n}\n\nint char_to_digit(char c)\n{\n    switch(c)\n    {\n        case '0':\n        {\n            return(0);\n        } break;\n        case '1':\n        {\n            return(1);\n        } break;\n        case '2':\n        {\n            return(2);\n        } break;\n        case '3':\n        {\n            return(3);\n        } break;\n        case '4':\n        {\n            return(4);\n        } break;\n        case '5':\n        {\n            return(5);\n        } break;\n        case '6':\n        {\n            return(6);\n        } break;\n        case '7':\n        {\n            return(7);\n        } break;\n        case '8':\n        {\n            return(8);\n        } break;\n        case '9':\n        {\n            return(9);\n        } break;\n        default:\n        {\n            return(0);\n        }\n    }\n}\n\nchar shift(char c, int amount)\n{\n   char Result = c + amount;\n   return(Result);\n}\nchar* replaceDigits(char* s) {\n    char *Result = s;\n\n    int length = str_length(s);\n    for(int char_index = 0; char_index < length / 2; char_index++)\n    {\n       char *at = s + (2 * char_index);  \n       char *next = s + (2 * char_index + 1);\n       \n       int digit = char_to_digit(*next);\n\n       *next = shift(*at, digit);\n    }\n    return(Result);\n}\n"]}
{"id": "397", "ref_c": [["int getMinDistance(int* nums, int numsSize, int target, int start) \\n{\\n    int minDistance = INT_MAX;\\n\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        if (nums[i] == target)\\n        {\\n            int currentDistance = (abs(i - start));\\n            if (minDistance > currentDistance)\\n                minDistance = currentDistance;\\n        }"], ["int getMinDistance(int* nums, int numsSize, int target, int start){\\n    int x,minimum=INT_MAX;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==target){\\n            x=abs(i-start);\\n            if(x<minimum)\\n                minimum=x;\\n        }"], ["int getMinDistance(int* nums, int numsSize, int target, int start){\\n    int x,minimum=INT_MAX;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==target){\\n            x=abs(i-start);\\n            if(x<minimum)\\n                minimum=x;\\n        }"]]}
{"id": "398", "ref_c": [["int maximumPopulation(int** logs, int logsSize, int* logsColSize) {\\n    int map[101] = {0}"], ["int maximumPopulation(int** logs, int logsSize, int* logsColSize){\\n    int arr[102]={0}", "int maximumPopulation(int** logs, int logsSize, int* logsColSize){\\n  \\n    int *arrB=(int*)malloc(sizeof(int)*(logsSize));\\n    int *arrD=(int*)malloc(sizeof(int)*(logsSize));\\n    for(int x=0;x<logsSize;x++){\\n        arrB[x]=logs[x][0];\\n        arrD[x]=logs[x][1]-1;\\n    }"], ["int maximumPopulation(int** logs, int logsSize, int* logsColSize)\\n{\\n    memset(hashtable, 0x00, sizeof(hashtable));\\n    \\n    int i=0;\\n    for(i=0; i<logsSize; i++)\\n    {\\n        int birth_year = logs[i][0];\\n        int death_year = logs[i][1];\\n        \\n        int j=0;\\n        for(j=birth_year; j<death_year; j++)\\n        {\\n            hashtable[j - 1950] += 1;\\n        }"]]}
{"id": "399", "ref_c": ["\nchar * sortSentence(char * s){\n\n    int len=strlen(s);\n    char* p=(char*)malloc(len*sizeof(char));\n    int index=0;\n    int count=0;\n\n    for(char i='1';i<='9';i++){\n        count=0;\n        for(int j=0;j<len;j++){\n            count++;\n            if(s[j]==' ') count=0;\n            if(s[j]==i){\n                for(int k=j-count+1;k<j;k++)\n                    p[index++]=s[k];\n                p[index++]=' ';\n            }\n        }\n    }\n    p[index-1]='\u0000';\n    return p;\n}\n", "\nchar * sortSentence(char * s){\n\n    int len=strlen(s);\n    char* p=(char*)malloc(len*sizeof(char));\n    int index=0;\n    int count=0;\n\n    for(char i='1';i<='9';i++){\n        count=0;\n        for(int j=0;j<len;j++){\n            count++;\n            if(s[j]==' ') count=0;\n            if(s[j]==i){\n                for(int k=j-count+1;k<j;k++)\n                    p[index++]=s[k];\n                p[index++]=' ';\n            }\n        }\n    }\n    p[index-1]='\u0000';\n    return p;\n}\n", "\nchar * sortSentence(char * s){\n\n    int len=strlen(s);\n    char* p=(char*)malloc(len*sizeof(char));\n    int index=0;\n    int count=0;\n\n    for(char i='1';i<='9';i++){\n        count=0;\n        for(int j=0;j<len;j++){\n            count++;\n            if(s[j]==' ') count=0;\n            if(s[j]==i){\n                for(int k=j-count+1;k<j;k++)\n                    p[index++]=s[k];\n                p[index++]=' ';\n            }\n        }\n    }\n    p[index-1]='\u0000';\n    return p;\n}\n"]}
{"id": "400", "ref_c": [["int subsetXORSum(int* nums, int numsSize){\\n    int res=0;\\n    for(int i =0;i<numsSize;i++){\\n        res|=nums[i];\\n    }"], ["int subsetXORSum(int* nums, int numsSize){\\n    int i = 0;\\n    for(int j = 0;j < numsSize;j++){\\n        i = i | nums[j];\\n    }"], ["int subsetXORSum(int* nums, int numsSize){\\n    int ret = 0;\\n    for(int i=0;i<numsSize;i++){\\n        ret |= nums[i];\\n    }"]]}
{"id": "401", "ref_c": [["bool checkZeroOnes(char * s){\\n    int k=0,l=0;\\n    int maxof0=0,maxof1=0;\\n    int x=strlen(s);\\n    for(int i=0;i<x;i++)\\n    {\\n        if(s[i]==\\'1\\')\\n        {\\n            l=0;\\n            k++;\\n        }"], ["bool checkZeroOnes(char * s){\\n    int k=0,l=0;\\n    int maxof0=0,maxof1=0;\\n    int x=strlen(s);\\n    for(int i=0;i<x;i++)\\n    {\\n        if(s[i]==\\'1\\')\\n        {\\n            l=0;\\n            k++;\\n        }"], ["bool checkZeroOnes(char * s){\\n    size_t max_0 = 0;\\n    size_t max_1 = 0;\\n    size_t cur_len = 0;\\n    while (true) {\\n        if (*s == \\'\\\\0\\') {\\n            return true;\\n        }"]]}
{"id": "403", "ref_c": ["\nint countGoodSubstrings(char * s){\n    \n    int len = strlen(s);\n    int result =0;\n    if(len<3) return result;\n    for(int l =0, r =2; r < len; l++, r++)\n        if(s[l]!=s[l+1] && s[l]!=s[r] && s[r]!=s[l+1])\n            result++;\n    \n    return result;\n}\n", "\nint countGoodSubstrings(char * s){\n    \n    int len = strlen(s);\n    int result =0;\n    if(len<3) return result;\n    for(int l =0, r =2; r < len; l++, r++)\n        if(s[l]!=s[l+1] && s[l]!=s[r] && s[r]!=s[l+1])\n            result++;\n    \n    return result;\n}\n", "\nint countGoodSubstrings(char * s){\n    \n    int len = strlen(s);\n    int result =0;\n    if(len<3) return result;\n    for(int l =0, r =2; r < len; l++, r++)\n        if(s[l]!=s[l+1] && s[l]!=s[r] && s[r]!=s[l+1])\n            result++;\n    \n    return result;\n}\n"]}
{"id": "404", "ref_c": [["bool isSumEqual(char * firstWord, char * secondWord, char * targetWord){       \\n        int first = 0;\\n        int second = 0;\\n        int third = 0;\\n        int i = 0;\\n        while(firstWord[i]!=\\'\\\\0\\'){\\n            first= first*10 + firstWord[i] - \\'a\\' ;\\n            i++;\\n        }"], ["bool isSumEqual(char * firstWord, char * secondWord, char * targetWord){       \\n        int first = 0;\\n        int second = 0;\\n        int third = 0;\\n        int i = 0;\\n        while(firstWord[i]!=\\'\\\\0\\'){\\n            first= first*10 + firstWord[i] - \\'a\\' ;\\n            i++;\\n        }"], ["bool isSumEqual(char * firstWord, char * secondWord, char * targetWord){       \\n        int first = 0;\\n        int second = 0;\\n        int third = 0;\\n        int i = 0;\\n        while(firstWord[i]!=\\'\\\\0\\'){\\n            first= first*10 + firstWord[i] - \\'a\\' ;\\n            i++;\\n        }"]]}
{"id": "405", "ref_c": [["bool findRotation(int** mat, int matSize, int* matColSize, int** target, int targetSize, int* targetColSize){\\n    if (matSize != targetSize || *matColSize != *targetColSize){\\n        return false;\\n    }"], ["bool findRotation(int** mat, int matSize, int* matColSize, int** target, int targetSize, int* targetColSize){\\n    if (matSize != targetSize || *matColSize != *targetColSize){\\n        return false;\\n    }"], ["bool findRotation(int** mat, int matSize, int* matColSize, int** target, int targetSize, int* targetColSize){\\n    if (matSize != targetSize || *matColSize != *targetColSize){\\n        return false;\\n    }"]]}
{"id": "407", "ref_c": [["bool isCovered(int** ranges, int rangesSize, int* rangesColSize, int left, int right){\\n    int count=0;\\n    int diff = right-left+1;\\n    for (int i = left; i <= right; i++) {\\n        for (int j = 0; j < rangesSize; j++) {\\n            if (i >= ranges[j][0] && i <= ranges[j][1]) {\\n                count++;\\n                break;\\n            }"], ["bool isCovered(int** ranges, int rangesSize, int* rangesColSize, int left, int right){\\n    int count=0;\\n    int diff = right-left+1;\\n    for (int i = left; i <= right; i++) {\\n        for (int j = 0; j < rangesSize; j++) {\\n            if (i >= ranges[j][0] && i <= ranges[j][1]) {\\n                count++;\\n                break;\\n            }"], ["bool isCovered(int** ranges, int rangesSize, int* rangesColSize, int left, int right){\\n    int count=0;\\n    int diff = right-left+1;\\n    for (int i = left; i <= right; i++) {\\n        for (int j = 0; j < rangesSize; j++) {\\n            if (i >= ranges[j][0] && i <= ranges[j][1]) {\\n                count++;\\n                break;\\n            }"]]}
{"id": "408", "ref_c": [["bool makeEqual(char ** words, int wordsSize){\\n    int i,j;\\n    int arr[26]={0}"], ["bool makeEqual(char ** words, int wordsSize){\\n    int i,j;\\n    int arr[26]={0}"], ["bool makeEqual(char ** words, int wordsSize){\\n    int i,j;\\n    int arr[26]={0}"]]}
{"id": "409", "ref_c": ["\nchar *largestOddNumber(char *num) {\n    int right = strlen(num) - 1;\n    while (right >= 0) {\n        if ((num[right] - '0') % 2 == 0) {\n            right--;\n        } else {\n            num[right + 1] = '\u0000';\n            return num;\n        }\n    }\n    return \"\";\n}\n", "\nchar *largestOddNumber(char *num) {\n    int right = strlen(num) - 1;\n    while (right >= 0) {\n        if ((num[right] - '0') % 2 == 0) {\n            right--;\n        } else {\n            num[right + 1] = '\u0000';\n            return num;\n        }\n    }\n    return \"\";\n}\n", "\nchar *largestOddNumber(char *num) {\n    int right = strlen(num) - 1;\n    while (right >= 0) {\n        if ((num[right] - '0') % 2 == 0) {\n            right--;\n        } else {\n            num[right + 1] = '\u0000';\n            return num;\n        }\n    }\n    return \"\";\n}\n"]}
{"id": "410", "ref_c": [["bool canBeIncreasing(int* nums, int numsSize) {\\n    int removed = 0;  // Count of removed elements\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] <= nums[i - 1]) {\\n            if (removed > 0) {\\n                return false;  // More than one element needs to be removed\\n            }"], ["bool canBeIncreasing(int* nums, int numsSize) {\\n    int removed = 0;  // Count of removed elements\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] <= nums[i - 1]) {\\n            if (removed > 0) {\\n                return false;  // More than one element needs to be removed\\n            }"], ["bool canBeIncreasing(int* nums, int numsSize) {\\n    int removed = 0;  // Count of removed elements\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] <= nums[i - 1]) {\\n            if (removed > 0) {\\n                return false;  // More than one element needs to be removed\\n            }"]]}
{"id": "411", "ref_c": [["int maxProductDifference(int* nums, int numsSize){\\n    int i,j,temp,pro=0;\\n    for (i=0;i<numsSize;i++)\\n    {\\n        for(j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]>nums[j])\\n            {\\n                 temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }"], ["int maxProductDifference(int* nums, int numsSize){\\n    int i,j,temp,pro=0;\\n    for (i=0;i<numsSize;i++)\\n    {\\n        for(j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]>nums[j])\\n            {\\n                 temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }"], ["int maxProductDifference(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    return nums[numsSize - 1] * nums[numsSize - 2] - nums[0] * nums[1];\\n}"]]}
{"id": "412", "ref_c": [["int* buildArray(int* nums, int numsSize, int* returnSize) {\\n   int *nums2;\\n    nums2 = (int*)malloc(sizeof(int) * numsSize);\\n  for(int i = 0 ; i < numsSize ; i++){\\n    nums2[i] = nums[nums[i]];\\n  }"], ["int* buildArray(int* nums, int numsSize, int* returnSize) {\\n   int *nums2;\\n    nums2 = (int*)malloc(sizeof(int) * numsSize);\\n  for(int i = 0 ; i < numsSize ; i++){\\n    nums2[i] = nums[nums[i]];\\n  }"], ["int* buildArray(int* nums, int numsSize, int* returnSize) {\\n   int *nums2;\\n    nums2 = (int*)malloc(sizeof(int) * numsSize);\\n  for(int i = 0 ; i < numsSize ; i++){\\n    nums2[i] = nums[nums[i]];\\n  }"]]}
{"id": "413", "ref_c": [["int countTriples(int n) {\\n    int count = 0;\\n\\n    for (int i = 1; i < n; i++) {\\n\\n        // j starting from i+1, because we don\\'t have to check same pairs again\\n        for (int j = i + 1; j <= n; j++) {\\n            double sumSqrt = sqrt(i * i + j * j);\\n\\n            // if sumSqrt starts to exceed n, we can safely break.\\n            if (sumSqrt > n) break;\\n\\n            // if square root is an integer, increment count\\n            // counting two times, because if a^2 + b^2 = c^2, then b^2 + a^2 = c^2\\n            if (sumSqrt == floor(sumSqrt)) count += 2;\\n        }"], ["int countTriples(int n) \\n{\\n    int count_square_triples = 0;\\n    for(int a = 1; a <= n; a++)\\n    {\\n        for(int b = a; b <= n; b++)\\n        {\\n            int c, first = 1, last = n, flag = 0;\\n            while(first <= last)\\n            {\\n                c = (first + last) / 2;\\n                if(a * a + b * b == c * c)\\n                {\\n                    flag = 1;\\n                    break;\\n                }"], ["int countTriples(int n) {\\n        int ans=0;\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            for(int j=i+1; j<=n; j++)\\n            {\\n                int square = i*i + j*j;\\n                int root = sqrt(square);\\n\\n                if(root<=n && root*root==square)\\n                    ans+=2;\\n            }"]]}
{"id": "414", "ref_c": [["int* getConcatenation(int* nums, int numsSize, int* returnSize){\\n    int *ans;\\n    ans = (int*)malloc(sizeof(int)*2*numsSize);\\n    for (int i=0; i<numsSize; i++ )\\n    {\\n        ans[i] = nums[i];\\n        ans[i+numsSize]=nums[i];\\n    }"], ["int* getConcatenation(int* nums, int numsSize, int* returnSize){\\n    int *ans;\\n    ans = (int*)malloc(sizeof(int)*2*numsSize);\\n    for (int i=0; i<numsSize; i++ )\\n    {\\n        ans[i] = nums[i];\\n        ans[i+numsSize]=nums[i];\\n    }"], ["int* getConcatenation(int* nums, int numsSize, int* returnSize){\\n    int* res = (int*)malloc(sizeof(int) * numsSize*2);\\n    *returnSize = 2 * numsSize;\\n    for (int i = 0; i < numsSize; i++) {\\n        res[i] = res[i+numsSize] = nums[i];\\n    }"]]}
{"id": "415", "ref_c": [["int canBeTypedWords(char * text, char * brokenLetters) {\\n    int broken[26] = {0}"], ["int canBeTypedWords(char * text, char * brokenLetters){\\n\\n    int alphabets[26] = {0}"], ["int canBeTypedWords(char * text, char * brokenLetters) {\\n\\n\\tbool alpha[26] = {0}"]]}
{"id": "416", "ref_c": [["bool areOccurrencesEqual(char * s){\\n    int freq[26] = {0}"], ["bool areOccurrencesEqual(char * s){\\nint eng[26]={0}"], ["bool areOccurrencesEqual(char * s){\\nint eng[26]={0}"]]}
{"id": "417", "ref_c": [["int getLucky(char * s, int k){\\nint i,p,sum=0,tempsum=0,j=0,nums[100];\\nfor(i=0;s[i];i++)\\n{\\n p=s[i]-96;\\n if(p<=9) sum+=p;\\n else\\n {\\n     while(p!=0)\\n     {\\n         sum+=p%10;\\n         p=p/10;\\n     }"], ["int getLucky(char * s, int k){\\nint i,p,sum=0,tempsum=0,j=0,nums[100];\\nfor(i=0;s[i];i++)\\n{\\n p=s[i]-96;\\n if(p<=9) sum+=p;\\n else\\n {\\n     while(p!=0)\\n     {\\n         sum+=p%10;\\n         p=p/10;\\n     }"], ["int getLucky(char * s, int k){\\nint i,p,sum=0,tempsum=0,j=0,nums[100];\\nfor(i=0;s[i];i++)\\n{\\n p=s[i]-96;\\n if(p<=9) sum+=p;\\n else\\n {\\n     while(p!=0)\\n     {\\n         sum+=p%10;\\n         p=p/10;\\n     }"]]}
{"id": "418", "ref_c": [["bool isThree(int n)\\n{\\n    int c = 0;\\n    for(int i=1;i<=n;i++)\\n    {\\n        if(n%i==0)\\n        c++;\\n    }"], ["bool isThree(int n) {\\n        int count = 1;\\n        for(int i=2;i<=n;i++){\\n            if(n%i==0) count++;\\n        }"], ["bool isThree(int n) {\\n    int sqrt = 0;\\n    \\n    sqrt = squareRoot(n);\\n    \\n    int count = 0;\\n    for(int i = 1; i<= sqrt; i++)\\n    {\\n        if(n%i == 0){\\n            if(n/i == i) count++;\\n            else count += 2;\\n        }"]]}
{"id": "419", "ref_c": [["char * makeFancyString(char * s){\\n    int len = strlen(s), idx = 2;\\n    while(idx < len)\\n    {\\n        if(s[idx-2]==s[idx] && s[idx-1]==s[idx])\\n        {\\n            /* more than 3 consecutive */\\n            int cutHere = idx - 1;\\n            /* set to space if we wnat to remove it */\\n            /* lee eeee tcode */\\n            while(s[idx]==s[cutHere])\\n                s[idx++] = \\' \\';\\n            /* remove 4*\\'e\\' and that idx point to \\'o\\' for next loop */\\n            idx++;\\n        }"], ["char * makeFancyString(char * s){\\n    int n=strlen(s);\\n    int j=0;\\n    for(int i=0;i<n;){\\n        if(i<n && s[i]==s[i+1]){\\n            int len=2;\\n            while(i<n && s[i]==s[i+len]) len++;\\n            if(len>=2){\\n                s[j++]=s[i];\\n                s[j++]=s[i];\\n                i+=len;\\n            }"], ["char * makeFancyString(char * s){\\n    int len = strlen(s), idx = 2;\\n    while(idx < len)\\n    {\\n        if(s[idx-2]==s[idx] && s[idx-1]==s[idx])\\n        {\\n            /* more than 3 consecutive */\\n            int cutHere = idx - 1;\\n            /* set to space if we wnat to remove it */\\n            /* lee eeee tcode */\\n            while(s[idx]==s[cutHere])\\n                s[idx++] = \\' \\';\\n            /* remove 4*\\'e\\' and that idx point to \\'o\\' for next loop */\\n            idx++;\\n        }"]]}
{"id": "420", "ref_c": [["bool isPrefixString(char * s, char ** words, int wordsSize){\\n    int i = 0;\\n    char *pch;\\n    while (i < wordsSize && *s) {\\n        for (pch = words[i]; *pch; pch++) {\\n            if (*pch != *s++) {\\n                return false;\\n            }"], ["bool isPrefixString(char * s, char ** words, int wordsSize){\\n    int i = 0;\\n    char *pch;\\n    while (i < wordsSize && *s) {\\n        for (pch = words[i]; *pch; pch++) {\\n            if (*pch != *s++) {\\n                return false;\\n            }"], ["bool isPrefixString(char * s, char ** words, int wordsSize){\\n    int i = 0;\\n    char *pch;\\n    while (i < wordsSize && *s) {\\n        for (pch = words[i]; *pch; pch++) {\\n            if (*pch != *s++) {\\n                return false;\\n            }"]]}
{"id": "422", "ref_c": [["int numOfStrings(char ** patterns, int patternsSize, char * word){\\n    int res = 0;\\n    for (int i = 0; i < patternsSize; i++)\\n        if (strstr(word, patterns[i])) res++;\\n    return res;\\n}"], ["int numOfStrings(char ** patterns, int patternsSize, char * word){\\n    int res = 0;\\n    for (int i = 0; i < patternsSize; i++)\\n        if (strstr(word, patterns[i])) res++;\\n    return res;\\n}"], ["int numOfStrings(char ** patterns, int patternsSize, char * word){\\n    int i = 0,j,same;\\n    int count = 0;\\n    \\n    while(i < patternsSize)\\n    {\\n        j = 0;\\n        same = 0;\\n        char *tmp = patterns[i];\\n        while(*tmp && word[j] && strlen(tmp) <= strlen(word))\\n        {\\n            if(*tmp == word[j]){\\n                tmp++;\\n                same++;\\n            }"]]}
{"id": "423", "ref_c": [["bool validPath(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination){\\n    if (source == destination) return true;\\n    \\n    bool visited_map[n], stk_map[n];\\n    for (int i = 0; i < n; i++){\\n        stk_map[i] = false;     // To record element(s) we had in stack\\n        visited_map[i] = false; // To record vertex(es) we had visited\\n    }"], ["bool validPath(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination){\\n    if (source == destination) return true;\\n    \\n    bool visited_map[n], stk_map[n];\\n    for (int i = 0; i < n; i++){\\n        stk_map[i] = false;     // To record element(s) we had in stack\\n        visited_map[i] = false; // To record vertex(es) we had visited\\n    }"], ["bool validPath(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination){\\n    if (source == destination) return true;\\n    \\n    bool visited_map[n], stk_map[n];\\n    for (int i = 0; i < n; i++){\\n        stk_map[i] = false;     // To record element(s) we had in stack\\n        visited_map[i] = false; // To record vertex(es) we had visited\\n    }"]]}
{"id": "424", "ref_c": [["int minTimeToType(char * word){\\n      char ini=\\'a\\';\\n      int ans=0;\\n      for(int i=0;word[i]!=\\'\\\\0\\';i++){\\n          int cw=word[i]-ini;\\n          if(cw<0){\\n              cw=cw+26;\\n          }"], ["int minTimeToType(char * word){\\n      char ini=\\'a\\';\\n      int ans=0;\\n      for(int i=0;word[i]!=\\'\\\\0\\';i++){\\n          int cw=word[i]-ini;\\n          if(cw<0){\\n              cw=cw+26;\\n          }"], ["int minTimeToType(char * word){\\n      char ini=\\'a\\';\\n      int ans=0;\\n      for(int i=0;word[i]!=\\'\\\\0\\';i++){\\n          int cw=word[i]-ini;\\n          if(cw<0){\\n              cw=cw+26;\\n          }"]]}
{"id": "426", "ref_c": [["int findGCD(int* nums, int numsSize){\\n  int max=0, min =1001;\\n  for (int i=0; i<numsSize; i++){\\n    if (nums[i]>max){\\n      max=nums[i];\\n    }"], ["int findGCD(int* nums, int numsSize)\\n{\\n    int min = nums[0],max = nums[0];\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(min>nums[i])\\n        min = nums[i];\\n        if(max<nums[i])\\n        max = nums[i];\\n    }"], ["int findGCD(int* nums, int numsSize){\\nint min=nums[0],max=nums[0],gcd,i;\\nfor( i=0;i<numsSize;i++){\\n    if(nums[i]<min)\\n    min=nums[i];\\n    if(nums[i]>max)\\n    max=nums[i];\\n}"]]}
{"id": "427", "ref_c": [["int minimumDifference(int* nums, int numsSize, int k){\\n    if (k == 1) return 0;\\n\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    int result = 1000000;\\n    for (int i = 0; i <= numsSize - k; i++) {\\n        result = min(nums[i + k - 1] - nums[i], result);\\n    }"], ["int minimumDifference(int* nums, int numsSize, int k){\\n  if(numsSize == 1)\\n    return 0;\\n  quickSort(nums, 0, numsSize - 1);\\n  int returnValue = nums[k - 1] - nums[0];\\n  for (size_t i = 1; i < numsSize - k + 1; i++)\\n  {\\n    if(returnValue > nums[i + k - 1] - nums[i])\\n      returnValue = nums[i + k - 1] - nums[i];\\n  }"], ["int minimumDifference(int* nums, int numsSize, int k){\\n  if(numsSize == 1)\\n    return 0;\\n  quickSort(nums, 0, numsSize - 1);\\n  int returnValue = nums[k - 1] - nums[0];\\n  for (size_t i = 1; i < numsSize - k + 1; i++)\\n  {\\n    if(returnValue > nums[i + k - 1] - nums[i])\\n      returnValue = nums[i + k - 1] - nums[i];\\n  }"]]}
{"id": "428", "ref_c": [["int findMiddleIndex(int* nums, int numsSize) \\n{\\n  int sum = 0;\\n  for(int i = 0; i < numsSize; i++)\\n  {\\n    sum += nums[i];\\n  }"], ["int findMiddleIndex(int* nums, int numsSize) {\\n    for(int i=0; i<numsSize; i++){\\n        int sum1=0,sum2=0;\\n        int n=i;\\n        for(int j=0; j<n; j++){\\n            sum1+=nums[j];\\n        }"], ["int findMiddleIndex(int* nums, int numsSize){\\n    int sum = 0, leftSum = 0;\\n    for(int i = 0; i < numsSize; i++) sum += nums[i];\\n    for(int i = 0; i < numsSize; i++) {\\n        if (leftSum == sum - leftSum - nums[i]) return i;\\n        /*else*/ leftSum += nums[i];\\n    }"]]}
{"id": "429", "ref_c": [["int countQuadruplets(int* nums, int numsSize){\\n    int ans = 0;\\n    for(int i = 0; i<numsSize; i++){\\n        for(int j=i+1; j<numsSize; j++){\\n            for(int k = j+1; k<numsSize; k++){\\n                for(int l = k+1; l<numsSize; l++){\\n                    if(nums[i] + nums[j] + nums[k] == nums[l]){\\n                        ans ++;\\n                    }"], ["int countQuadruplets(int* nums, int numsSize){\\n    int ans = 0;\\n    for(int i = 0; i<numsSize; i++){\\n        for(int j=i+1; j<numsSize; j++){\\n            for(int k = j+1; k<numsSize; k++){\\n                for(int l = k+1; l<numsSize; l++){\\n                    if(nums[i] + nums[j] + nums[k] == nums[l]){\\n                        ans ++;\\n                    }"], ["int countQuadruplets(int* nums, int numsSize){\\n    int* hashCnt = (int*)calloc(101, sizeof(int));\\n    int sum = 0, ansCnt = 0;\\n    \\n    hashCnt[nums[numsSize-1]]++;\\n    for(int i = numsSize-2; i >= 2; i--){\\n        sum = nums[i];\\n        for(int j = i-1; j >= 1; j--){\\n            sum += nums[j];\\n            for(int k = j-1; k >= 0 ; k--){\\n                sum += nums[k];\\n                if(sum <= 100 && hashCnt[sum])\\n                    ansCnt += hashCnt[sum];\\n                sum -= nums[k];\\n            }"]]}
{"id": "430", "ref_c": [["char * reversePrefix(char * word, char ch) {\\n    char temp;\\n    int left, right;\\n    int index;\\n\\n    for (index = 0; word[index] != ch && word[index] != \\'\\\\0\\'; index++);\\n\\n    if (word[index] == \\'\\\\0\\') {\\n        return word;\\n    }"], ["char * reversePrefix(char * word, char ch){\\n    char *location,*beginning;\\n    char tmp;\\n\\n    beginning = word;\\n    location = strchr(word,ch);\\n    if (location == NULL)\\n        return word;\\n\\n    while (beginning <= location){\\n        tmp = *(beginning);\\n        *(beginning++) = *(location);\\n        *(location--) = tmp;\\n    }"], ["char * reversePrefix(char * word, char ch){\\n    char *location,*beginning;\\n    char tmp;\\n\\n    beginning = word;\\n    location = strchr(word,ch);\\n    if (location == NULL)\\n        return word;\\n\\n    while (beginning <= location){\\n        tmp = *(beginning);\\n        *(beginning++) = *(location);\\n        *(location--) = tmp;\\n    }"]]}
{"id": "431", "ref_c": [["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0;\\n    for (int i = 0; i != numsSize; i++)\\n    {\\n        for (int j = 0; j != numsSize; j++)\\n        {\\n            if (i != j && (nums[i] - nums[j]) == k)\\n            {\\n                count++;\\n            }"], ["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0; \\n\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = i+1; j < numsSize; j++){\\n            if(abs(nums[i] - nums[j]) == k){\\n                count += 1; \\n            }"], ["int countKDifference(int* nums, int numsSize, int k){\\n    int count = 0;\\n    for(int i = 0; i < numsSize; i++)\\n        for(int j = i; j  < numsSize; j++)\\n            if(nums[i] - nums[j] == k || nums[j]  - nums[i] == k)\\n                count++;\\n\\n    \\n    return count;\\n}"]]}
{"id": "432", "ref_c": [["int finalValueAfterOperations(char ** operations, int operationsSize) {\\n    int x = 0;\\n\\n    for (int i = 0; i < operationsSize; i++) {\\n        if (operations[i][0] == \\'-\\' || operations[i][2] == \\'-\\' ) x--;\\n        else x++;\\n    }"], ["int finalValueAfterOperations(char ** operations, int operationsSize) {\\n    int x = 0;\\n\\n    for (int i = 0; i < operationsSize; i++) {\\n        if (operations[i][0] == \\'-\\' || operations[i][2] == \\'-\\' ) x--;\\n        else x++;\\n    }"], ["int finalValueAfterOperations(char ** operations, int operationsSize) {\\n    int x = 0;\\n\\n    for (int i = 0; i < operationsSize; i++) {\\n        if (operations[i][0] == \\'-\\' || operations[i][2] == \\'-\\' ) x--;\\n        else x++;\\n    }"]]}
{"id": "433", "ref_c": [["int maximumDifference(int* nums, int numsSize){\\nint i,s,max=-1;\\nfor(i=0;i<numsSize-1;i++){\\n    for(s=i+1;s<numsSize;s++){\\n        if(nums[i]==nums[s]){\\n            continue;\\n        }"], ["int maximumDifference(int* nums, int numsSize) \\n{\\n    int max_diff = 0, min_val = nums[0];\\n    for(int i = 1; i < numsSize; i++)\\n    {\\n        if(max_diff < nums[i] - min_val)\\n        {\\n            max_diff = nums[i] - min_val;\\n        }"], ["int maximumDifference(int* nums, int numsSize){\\nint i,s,max=-1;\\nfor(i=0;i<numsSize-1;i++){\\n    for(s=i+1;s<numsSize;s++){\\n        if(nums[i]==nums[s]){\\n            continue;\\n        }"]]}
{"id": "434", "ref_c": [["int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes){\\n    int** result = (int**)malloc(m*sizeof(int*));\\n    if(m*n!=originalSize){\\n        *returnSize=0;\\n        **returnColumnSizes=0;\\n        return result;\\n    }"], ["int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes){\\n\\n    int** p = (int**)malloc(m*sizeof(int*));\\n\\n    if(m*n!=originalSize) {\\n        *returnSize=0;\\n        return p;\\n    }"], ["int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes){\\n\\n    int** p = (int**)malloc(m*sizeof(int*));\\n\\n    if(m*n!=originalSize) {\\n        *returnSize=0;\\n        return p;\\n    }"]]}
{"id": "435", "ref_c": [["int minimumMoves(char * string){\\n  int i = 0, out = 0;\\n  while (!(string[i]==\\'\\\\0\\') && ((string[i] == \\'O\\' && ++i) ||\\n        (string[i] == \\'\\\\0\\' ||\\n         ((++out && (string[i++] = \\'O\\')) &&\\n          (string[i] == \\'\\\\0\\' ||\\n           ((string[i++] = \\'O\\') &&\\n            (string[i] == \\'\\\\0\\' || ((string[i++] = \\'O\\'))))))))) {\\n  }"], ["int minimumMoves(char * string){\\n  int i = 0, out = 0;\\n  while (!(string[i]==\\'\\\\0\\') && ((string[i] == \\'O\\' && ++i) ||\\n        (string[i] == \\'\\\\0\\' ||\\n         ((++out && (string[i++] = \\'O\\')) &&\\n          (string[i] == \\'\\\\0\\' ||\\n           ((string[i++] = \\'O\\') &&\\n            (string[i] == \\'\\\\0\\' || ((string[i++] = \\'O\\'))))))))) {\\n  }"], ["int minimumMoves(char * string){\\n  int i = 0, out = 0;\\n  while (!(string[i]==\\'\\\\0\\') && ((string[i] == \\'O\\' && ++i) ||\\n        (string[i] == \\'\\\\0\\' ||\\n         ((++out && (string[i++] = \\'O\\')) &&\\n          (string[i] == \\'\\\\0\\' ||\\n           ((string[i++] = \\'O\\') &&\\n            (string[i] == \\'\\\\0\\' || ((string[i++] = \\'O\\'))))))))) {\\n  }"]]}
{"id": "436", "ref_c": [["int* twoOutOfThree(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* returnSize){\\n    int *arr;\\n    int count[101] = {0}"], ["int* twoOutOfThree(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* returnSize){\\n\\n    short int * h = (short int*) calloc(sizeof(short int),101),i=0,p=0;\\n    int * res = (int* )malloc(sizeof(int)*(300));\\n    for(;i<nums1Size;i++)\\n    h[ nums1[i] ] |=  1 ;\\n    for(i=0;i<nums2Size;i++)\\n    h[ nums2[i] ] |=  2 ;\\n    for(i=0;i<nums3Size;i++)\\n    h[ nums3[i] ] |=  4 ; \\n    for(i=1;i<=100;i++)\\n    if(h[i]==3 || h[i]==5 || h[i]==6 || h[i]==7)\\n    res[p++]=i;\\n    *returnSize=p;\\n    return res;\\n\\n\\n}"], ["int* twoOutOfThree(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* returnSize){\\n\\n    short int * h = (short int*) calloc(sizeof(short int),101),i=0,p=0;\\n    int * res = (int* )malloc(sizeof(int)*(300));\\n    for(;i<nums1Size;i++)\\n    h[ nums1[i] ] |=  1 ;\\n    for(i=0;i<nums2Size;i++)\\n    h[ nums2[i] ] |=  2 ;\\n    for(i=0;i<nums3Size;i++)\\n    h[ nums3[i] ] |=  4 ; \\n    for(i=1;i<=100;i++)\\n    if(h[i]==3 || h[i]==5 || h[i]==6 || h[i]==7)\\n    res[p++]=i;\\n    *returnSize=p;\\n    return res;\\n\\n\\n}"]]}
{"id": "437", "ref_c": [["int minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize) {\\n    int numMoves = 0 ;\\n    bubbleSort(seats,students, seatsSize);\\n    for(int i = 0 ; i < studentsSize ; i++){\\n        if(seats[i] > students[i]){\\n            numMoves = numMoves + (seats[i] - students[i]);\\n        }"], ["int minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize){\\n    int sum = 0,i,j;\\n    for( i = 0; i < seatsSize; i++)\\n    {\\n        for( j = i + 1; j < seatsSize; j++){\\n            if(seats[i] > seats[j])\\n                swap(&seats[i],&seats[j]);\\n            if(students[i] > students[j])\\n                swap(&students[i],&students[j]);\\n        }"], ["int minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize){\\nint x;\\nfor(int i=0;i<seatsSize;i++)\\n{\\n    for(int j=i+1;j<seatsSize;j++)\\n    {\\n\\n        if(seats[i]>seats[j])\\n        {\\n          x=seats[i];\\n          seats[i]=seats[j];\\n          seats[j]=x;\\n        }", "int minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize){\\n\\n    qsort(seats , seatsSize , sizeof(int) ,compare);\\n    qsort(students , studentsSize , sizeof(int) ,compare);\\n    int move = 0 ;\\n\\n    for(int i = 0 ; i < seatsSize ; i++) move += abs(seats[i] - students[i]); \\n\\n    return move;\\n}"]]}
{"id": "438", "ref_c": [["bool areNumbersAscending(char * s){ \\n    int value = 0,tmp;\\n    \\n    for(int i = 0; s[i]; i++)\\n    {\\n        if(isNumber(s[i]))\\n        {\\n            if(s[i+1] && isNumber(s[i+1]))  //numberOfDigits == 2\\n            {     \\n                tmp = value;\\n                value = 0;\\n                value = value*10 + (s[i] - \\'0\\');\\n                i++;\\n                value = value*10 + (s[i] - \\'0\\');\\n                if(value <= tmp)\\n                    return false;\\n            }"], ["bool areNumbersAscending(char * s){ \\n    int value = 0,tmp;\\n    \\n    for(int i = 0; s[i]; i++)\\n    {\\n        if(isNumber(s[i]))\\n        {\\n            if(s[i+1] && isNumber(s[i+1]))  //numberOfDigits == 2\\n            {     \\n                tmp = value;\\n                value = 0;\\n                value = value*10 + (s[i] - \\'0\\');\\n                i++;\\n                value = value*10 + (s[i] - \\'0\\');\\n                if(value <= tmp)\\n                    return false;\\n            }"], ["bool areNumbersAscending(char * s){ \\n    int value = 0,tmp;\\n    \\n    for(int i = 0; s[i]; i++)\\n    {\\n        if(isNumber(s[i]))\\n        {\\n            if(s[i+1] && isNumber(s[i+1]))  //numberOfDigits == 2\\n            {     \\n                tmp = value;\\n                value = 0;\\n                value = value*10 + (s[i] - \\'0\\');\\n                i++;\\n                value = value*10 + (s[i] - \\'0\\');\\n                if(value <= tmp)\\n                    return false;\\n            }"]]}
{"id": "439", "ref_c": [["int countValidWords(char * sentence){\\n    char tok[2]=\" \";\\n    char* token=strtok(sentence,tok);\\n    int cnt=0;\\n    while(token){\\n        if(isValid(token))cnt++;\\n        token=strtok(NULL,tok);\\n    }"], ["int countValidWords(char * sentence){\\n    char tok[2]=\" \";\\n    char* token=strtok(sentence,tok);\\n    int cnt=0;\\n    while(token){\\n        if(isValid(token))cnt++;\\n        token=strtok(NULL,tok);\\n    }"], ["int countValidWords(char * sentence){\\n    char tok[2]=\" \";\\n    char* token=strtok(sentence,tok);\\n    int cnt=0;\\n    while(token){\\n        if(isValid(token))cnt++;\\n        token=strtok(NULL,tok);\\n    }"]]}
{"id": "440", "ref_c": [["char * kthDistinct(char ** arr, int arrSize, int k)\\n{\\n\\n    char * distStr = \"\" ;\\n    int distCntr   = 0  ;\\n    int i ;\\n    int j ;\\n\\n    for( i = 0; i < arrSize; i++ )\\n    {\\n\\n        for( j = 0; j < arrSize; j++ )\\n        {\\n\\n            if( i == j )\\n            {\\n                continue ;\\n            }"], ["char * kthDistinct(char ** arr, int arrSize, int k)\\n{\\n\\n    char * distStr = \"\" ;\\n    int distCntr   = 0  ;\\n    int i ;\\n    int j ;\\n\\n    for( i = 0; i < arrSize; i++ )\\n    {\\n\\n        for( j = 0; j < arrSize; j++ )\\n        {\\n\\n            if( i == j )\\n            {\\n                continue ;\\n            }"], ["char * kthDistinct(char ** arr, int arrSize, int k)\\n{\\n\\n    char * distStr = \"\" ;\\n    int distCntr   = 0  ;\\n    int i ;\\n    int j ;\\n\\n    for( i = 0; i < arrSize; i++ )\\n    {\\n\\n        for( j = 0; j < arrSize; j++ )\\n        {\\n\\n            if( i == j )\\n            {\\n                continue ;\\n            }"]]}
{"id": "441", "ref_c": [["int smallestEqual(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(i%10==nums[i])\\n        {\\n            return i;\\n        }"], ["int smallestEqual(int* nums, int numsSize) {\\n    int i;\\n    for( i=0;i<numsSize;i++){\\n        if(i%10==nums[i]){\\n            break;\\n        }"], ["int smallestEqual(int* nums, int numsSize) \\n{\\n    for (int i = 0; i < numsSize; i++) \\n    {\\n        if (i % 10 == nums[i]) \\n        {\\n            return i;\\n        }"]]}
{"id": "442", "ref_c": [["int countVowelSubstrings(char * word){\\n    int idx = 0, len = strlen(word);\\n    int ansCnt = 0, mask;\\n    for(int i = 0; i < len-4; i++)\\n    {\\n        idx = i; \\n        mask = (1 << (word[idx]-\\'a\\'));\\n        while(idx < len && mask & vowel)\\n        {\\n            mask |= (1 << (word[idx++]-\\'a\\'));\\n            if(mask == vowel)\\n                ansCnt++;\\n            else if(mask & ~vowel)\\n                break;\\n        }"], ["int countVowelSubstrings(char * word){\\n    int idx = 0, len = strlen(word);\\n    int ansCnt = 0, mask;\\n    for(int i = 0; i < len-4; i++)\\n    {\\n        idx = i; \\n        mask = (1 << (word[idx]-\\'a\\'));\\n        while(idx < len && mask & vowel)\\n        {\\n            mask |= (1 << (word[idx++]-\\'a\\'));\\n            if(mask == vowel)\\n                ansCnt++;\\n            else if(mask & ~vowel)\\n                break;\\n        }"], ["int countVowelSubstrings(char * word){\\n    uint8_t arr[26] = {0}"]]}
{"id": "443", "ref_c": [["bool checkAlmostEquivalent(char * word1, char * word2){\\n    int V_w1[26]={0}"], ["bool checkAlmostEquivalent(char * word1, char * word2){\\n    int V_w1[26]={0}"], ["bool checkAlmostEquivalent(char * word1, char * word2){\\n    char table[26] = {0}"]]}
{"id": "444", "ref_c": [["int timeRequiredToBuy(int* tickets, int ticketsSize, int k) {\\n    int time=0,i=0;\\n    while(tickets[k]!=0)\\n    {\\n        if(tickets[i]!=0)\\n        {\\n            tickets[i]--;\\n            time++;\\n        }"], ["int timeRequiredToBuy(int* tickets, int ticketsSize, int k){\\n    int time=0;\\n    for(int itr=0; itr<ticketsSize; itr++) {\\n        enqueue(itr);\\n    }"], ["int timeRequiredToBuy(int* tickets, int ticketsSize, int k) {\\n    int time=0,i=0;\\n    while(tickets[k]!=0)\\n    {\\n        if(tickets[i]!=0)\\n        {\\n            tickets[i]--;\\n            time++;\\n        }"]]}
{"id": "445", "ref_c": [["int maxDistance(int* colors, int colorsSize){\\n\\n    // Get the max from left and right\\n    int max_from_left = 0;\\n    int max_from_right = 0;\\n\\n    // Two pointers\\n    int *start = colors;\\n    int *end = colors + colorsSize - 1;\\n\\n    // Loop from left to right\\n    while (start < end) {\\n        // Return if colors are different\\n        if (*start != *end) {\\n            max_from_right = abs(start - end);\\n            break;\\n        }"], ["int maxDistance(int* colors, int colorsSize){\\n\\n    int left = 0;\\n    int right = colorsSize - 1;\\n    int maxDistance1 = 0;\\n    int maxDistance2 = 0;\\n\\n    while (left < right)\\n    {\\n        if (colors[left] != colors[right])\\n        {\\n            if (maxDistance1 < (right - left))\\n            {\\n                maxDistance1 = right - left;\\n            }"], ["int maxDistance(int* colors, int colorsSize){\\n\\n    // Get the max from left and right\\n    int max_from_left = 0;\\n    int max_from_right = 0;\\n\\n    // Two pointers\\n    int *start = colors;\\n    int *end = colors + colorsSize - 1;\\n\\n    // Loop from left to right\\n    while (start < end) {\\n        // Return if colors are different\\n        if (*start != *end) {\\n            max_from_right = abs(start - end);\\n            break;\\n        }"]]}
{"id": "447", "ref_c": [["int countWords(char ** words1, int words1Size, char ** words2, int words2Size){\\n  HashTable table = {0}"], ["int countWords(char ** words1, int words1Size, char ** words2, int words2Size){\\n  HashTable table = {0}"], ["int countWords(char ** words1, int words1Size, char ** words2, int words2Size){\\n  HashTable table = {0}"]]}
{"id": "448", "ref_c": [["int* targetIndices(int* nums, int numsSize, int target, int* returnSize){\\n    int small=0,same=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i] < target) small++;\\n        if(nums[i] == target) same++;\\n    }"], ["int* targetIndices(int* nums, int numsSize, int target, int* returnSize) \\n{\\n    int i,j,k,s=0,l=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        for(j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]>nums[j])\\n            {\\n               k= nums[i];\\n               nums[i]=nums[j];\\n               nums[j]=k;\\n               \\n           }"], ["int* targetIndices(int* nums, int numsSize, int target, int* returnSize){\\n    int small=0,same=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i] < target) small++;\\n        if(nums[i] == target) same++;\\n    }"]]}
{"id": "449", "ref_c": [["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    int *lucky;\\n    int i,j,k,x,check;\\n    int minRow,maxCol;\\n    coordinates cor[matrixSize];\\n    \\n    lucky = (int *)malloc(sizeof(int) * matrixSize);\\n    \\n    k = 0;\\n    for(i = 0; i < matrixSize; i++){\\n        minRow = INT_MAX;\\n        for(j = 0; j < *matrixColSize; j++){\\n            if(matrix[i][j] < minRow){\\n                minRow = matrix[i][j];\\n                cor[i].row = i;\\n                cor[i].col = j;\\n            }"], ["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\\n     int *ans=malloc(sizeof(int)*50);\\n     int min;\\n     int max;\\n     int idx;\\n     int m=0;\\n     for(int i=0;i<matrixSize;i++)\\n     {\\n         min=1000000;\\n         for(int j=0;j<(*matrixColSize);j++)\\n         {\\n             if(min>matrix[i][j]) \\n             {\\n                 min=matrix[i][j];\\n                 idx=j;\\n             }"], ["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    int* returnValue = (int*)malloc(matrixSize * sizeof(int));\\n    int returnValueIndex = 0;\\n\\n    // for each row...\\n    int columnIndex = 0;\\n    int rowIndex = 0;\\n    for (int row = 0; row < matrixSize; row++) {\\n        // find the minimum value on the row and return it\\'s column index...\\n        columnIndex = matrix_minimum_in_row(matrix, row, *matrixColSize);\\n\\n        // find the maximum value on the column and return it\\'s row index...\\n        rowIndex = matrix_maximum_in_column(matrix, matrixSize, columnIndex);\\n\\n        // ...remember the solutions\\n        if (row == rowIndex) {\\n            returnValue[returnValueIndex] = matrix[rowIndex][columnIndex];\\n            returnValueIndex++;\\n        }"]]}
{"id": "450", "ref_c": [["int* maxSubsequence(int* nums, int numsSize, int k, int* returnSize){\\n    struct pair * pairs = malloc(sizeof(struct pair)*numsSize);\\n    for (int i = 0; i < numsSize; i++){\\n        pairs[i].idx = i;\\n        pairs[i].val = nums[i];\\n    }"], ["int* maxSubsequence(int* nums, int numsSize, int k, int* returnSize){\\n    q = (struct pq *)malloc(sizeof(struct pq));\\n    memset(q, 0, sizeof(struct pq));\\n    q->heap = (struct elem *)malloc(sizeof(struct elem) * k);\\n    memset(q->heap, 0, sizeof(struct elem) * k);\\n    *returnSize = k;\\n    int *ret = (int *)malloc(sizeof(int) * k);\\n    g_k = k;\\n    \\n    for (int i = 0; i < numsSize; i++) // O(N * logN)\\n        add_num(q->heap, q->heap_size, nums[i], i);\\n    \\n    build_heap(q->heap, q->heap_size, compare_idx); // O(N)\\n    for (int i = 0; i < k; i++) // O(K * logN)\\n        ret[i] = heap_pop(q->heap, compare_idx).val;\\n    return ret;\\n}"], ["int* maxSubsequence(int* nums, int numsSize, int k, int* returnSize){\\n    int i, j, l = numsSize, dup_count = 0;\\n    int *sorted = (int*)malloc(l * sizeof(int));\\n    int *ans = (int*)malloc(k * sizeof(int));\\n    *returnSize = k;\\n    \\n    memcpy(sorted, nums, l * sizeof(int));\\n    qsort(sorted, l, sizeof(int), cmp);\\n    int kthMax = sorted[k - 1];\\n    \\n    // Find possible occurrence(s) of other element(s) of value kthMax before sorted[k - 1]. \\n    for(i = k - 1; i >= 0; i--){\\n        if(sorted[i] == kthMax)\\n            dup_count++;\\n        else\\n            break;\\n    }"]]}
{"id": "451", "ref_c": [["int countPoints(char * rings){\\n    int count = 0 ;\\n    for(int i = 0 ; i <10 ; i++)\\n    {\\n        int r = 0 ;\\n        int b = 0;\\n        int g = 0;\\n        for(int j = 1 ; j < strlen(rings) ; j = j + 2)\\n        {\\n            if(rings[j-1]==\\'R\\' && (rings[j]== \\'0\\' + i) )\\n                r = 1;\\n            else if(rings[j-1]==\\'B\\'  && (rings[j]== \\'0\\' + i))\\n                b = 1;\\n            else if(rings[j-1]==\\'G\\'  && (rings[j]== \\'0\\' + i))\\n                g = 1;\\n        }"], ["int countPoints(char * rings){\\n    int count = 0 ;\\n    for(int i = 0 ; i <10 ; i++)\\n    {\\n        int r = 0 ;\\n        int b = 0;\\n        int g = 0;\\n        for(int j = 1 ; j < strlen(rings) ; j = j + 2)\\n        {\\n            if(rings[j-1]==\\'R\\' && (rings[j]== \\'0\\' + i) )\\n                r = 1;\\n            else if(rings[j-1]==\\'B\\'  && (rings[j]== \\'0\\' + i))\\n                b = 1;\\n            else if(rings[j-1]==\\'G\\'  && (rings[j]== \\'0\\' + i))\\n                g = 1;\\n        }"], ["int countPoints(char * rings){\\n    int count = 0 ;\\n    for(int i = 0 ; i <10 ; i++)\\n    {\\n        int r = 0 ;\\n        int b = 0;\\n        int g = 0;\\n        for(int j = 1 ; j < strlen(rings) ; j = j + 2)\\n        {\\n            if(rings[j-1]==\\'R\\' && (rings[j]== \\'0\\' + i) )\\n                r = 1;\\n            else if(rings[j-1]==\\'B\\'  && (rings[j]== \\'0\\' + i))\\n                b = 1;\\n            else if(rings[j-1]==\\'G\\'  && (rings[j]== \\'0\\' + i))\\n                g = 1;\\n        }"]]}
{"id": "452", "ref_c": ["\nshort palidrom_string(const char *str)\n{\n    int len = strlen(str);\n\n    for(int i = 0;  i < len/2; i++)\n        if(str[i] != str[len - 1- i])return 0;\n    \n    return 1;\n}\n\n\nchar * firstPalindrome(char ** words, int wordsSize){\n    \n    for(int i = 0; i < wordsSize; i++)\n    {\n        if(palidrom_string(words[i]))return words[i];\n    }\n\n    return \"\";\n}\n", "\nshort palidrom_string(const char *str)\n{\n    int len = strlen(str);\n\n    for(int i = 0;  i < len/2; i++)\n        if(str[i] != str[len - 1- i])return 0;\n    \n    return 1;\n}\n\n\nchar * firstPalindrome(char ** words, int wordsSize){\n    \n    for(int i = 0; i < wordsSize; i++)\n    {\n        if(palidrom_string(words[i]))return words[i];\n    }\n\n    return \"\";\n}\n", "\nshort palidrom_string(const char *str)\n{\n    int len = strlen(str);\n\n    for(int i = 0;  i < len/2; i++)\n        if(str[i] != str[len - 1- i])return 0;\n    \n    return 1;\n}\n\n\nchar * firstPalindrome(char ** words, int wordsSize){\n    \n    for(int i = 0; i < wordsSize; i++)\n    {\n        if(palidrom_string(words[i]))return words[i];\n    }\n\n    return \"\";\n}\n"]}
{"id": "453", "ref_c": [["int mostWordsFound(char ** sentences, int sentencesSize){\\n    int word_count = 0;\\n\\n    for (int i = 0; i < sentencesSize; i++) {\\n        int counter = 0;\\n        for (int count = 0; sentences[i][count] != \\'\\\\0\\'; count++) {\\n            if (sentences[i][count] == \\' \\') {\\n                counter++;\\n            }"], ["int mostWordsFound(char ** sentences, int sentencesSize){\\n    int word_count = 0;\\n\\n    for (int i = 0; i < sentencesSize; i++) {\\n        int counter = 0;\\n        for (int count = 0; sentences[i][count] != \\'\\\\0\\'; count++) {\\n            if (sentences[i][count] == \\' \\') {\\n                counter++;\\n            }"], ["int mostWordsFound(char ** sentences, int sentencesSize){\\n    int word_count = 0;\\n\\n    for (int i = 0; i < sentencesSize; i++) {\\n        int counter = 0;\\n        for (int count = 0; sentences[i][count] != \\'\\\\0\\'; count++) {\\n            if (sentences[i][count] == \\' \\') {\\n                counter++;\\n            }"]]}
{"id": "454", "ref_c": [["bool isSameAfterReversals(int num){\\n    if(num==0)return true;\\n  return !(num%10==0);\\n}"], ["bool isSameAfterReversals(int num){\\n    if(num==0)return true;\\n  return !(num%10==0);\\n}"], ["bool isSameAfterReversals(int num){\\n\\nif(num==0)\\n    return true;\\nelse if(num%10==0)\\n    return false;\\n    else\\n        return true;\\n}"]]}
{"id": "455", "ref_c": [["bool checkString(char * s){\\n    int i;\\n    \\n    for(i = 0; i < strlen(s) - 1; i++){\\n        if(s[i] == \\'b\\' && s[i + 1] == \\'a\\')\\n            return 0;\\n    }"], ["bool checkString(char * s){\\n    int i;\\n    \\n    for(i = 0; i < strlen(s) - 1; i++){\\n        if(s[i] == \\'b\\' && s[i + 1] == \\'a\\')\\n            return 0;\\n    }"], ["bool checkString(char * s){\\n    bool flag=true;\\nfor(int i=0;i<strlen(s)-1;i++){\\n    if(s[i+1]<s[i])\\n    {\\n        flag=false;\\n        break;\\n    }"]]}
{"id": "456", "ref_c": [["char * capitalizeTitle(char * title)\\n{\\n int i,j,len=0;\\n len = strlen(title);\\n\\n for(i=0,j=0;i<=len;i++)\\n {\\n     if(i==len || title[i]== \\' \\')\\n     {\\n     if(i-j > 2)\\n     title[j] = toupper(title[j]);\\n     j=i+1;\\n     }"], ["char * capitalizeTitle(char * title){\\n    char *ptrBeg = title, *ptrEnd=ptrBeg;\\n    while (*ptrBeg != \\'\\\\0\\') {\\n        ptrEnd++;\\n        // find word margins\\n        while (*ptrEnd != \\' \\' && *ptrEnd != \\'\\\\0\\')\\n            toLower(ptrEnd++);\\n\\n        // Cap first letter if needed\\n        if ((ptrEnd - ptrBeg) > 2)\\n            toUpper(ptrBeg);\\n        else\\n            toLower(ptrBeg);\\n\\n        // Decide to continue or not\\n        if (*ptrEnd == \\'\\\\0\\')\\n            break;\\n        ptrBeg = ++ptrEnd;\\n    }"], ["char * capitalizeTitle(char * title)\\n{\\n int i,j,len=0;\\n len = strlen(title);\\n\\n for(i=0,j=0;i<=len;i++)\\n {\\n     if(i==len || title[i]== \\' \\')\\n     {\\n     if(i-j > 2)\\n     title[j] = toupper(title[j]);\\n     j=i+1;\\n     }"]]}
{"id": "457", "ref_c": [["bool checkValid(int** matrix, int matrixSize, int* matrixColSize){\\n    int i,j;\\n    flag128_t flags;\\n    for (i = 0; i < matrixSize; ++i) {\\n        // check ith row\\n        clearFlags(&flags);\\n        for (j = 0; j < matrixSize; ++j) {\\n            if (getFlag(&flags,matrix[i][j])) {\\n                return false;\\n            }"], ["bool checkValid(int** matrix, int matrixSize, int* matrixColSize){\\n    int* mem = calloc(matrixSize+1, sizeof(int));\\n    if (checkRows(matrix, matrixSize, mem))\\n        return 0;\\n    if (checkCols(matrix, matrixSize, mem))\\n        return 0;\\n    return 1;\\n}"], ["bool checkValid(int** matrix, int matrixSize, int* matrixColSize) {\\n    int n = matrixSize;\\n    \\n    // Check rows\\n    for (int i = 0; i < n; i++) {\\n        int rowSet[n + 1]; // Using an array as a set to keep track of unique values\\n        for (int j = 0; j <= n; j++) {\\n            rowSet[j] = 0;\\n        }"]]}
{"id": "458", "ref_c": [["char ** divideString(char * s, int k, char fill, int* returnSize){\\n    int i,count = 0,row = 0,col = 0;\\n    int len = (strlen(s) / k) + 1;\\n    char **arr = malloc(sizeof(char *) * len);      //** allocating\\n    \\n    for(i = 0; i < len; i++)\\n        arr[i] = malloc(sizeof(char) * (k+1));      //* allocating\\n    \\n    i = 0;\\n    while(i < strlen(s) + 1 && count <= k){\\n        if(!count && count % k == 0){\\n            arr[row][col] = \\'\\\\0\\';\\n            row++;\\n            col = 0;\\n            count = 0;\\n            i--;\\n        }"], ["char ** divideString(char * s, int k, char fill, int* returnSize){\\n    int i,count = 0,row = 0,col = 0;\\n    int len = (strlen(s) / k) + 1;\\n    char **arr = malloc(sizeof(char *) * len);      //** allocating\\n    \\n    for(i = 0; i < len; i++)\\n        arr[i] = malloc(sizeof(char) * (k+1));      //* allocating\\n    \\n    i = 0;\\n    while(i < strlen(s) + 1 && count <= k){\\n        if(!count && count % k == 0){\\n            arr[row][col] = \\'\\\\0\\';\\n            row++;\\n            col = 0;\\n            count = 0;\\n            i--;\\n        }"], ["char ** divideString(char * s, int k, char fill, int* returnSize){\\n    int i,count = 0,row = 0,col = 0;\\n    int len = (strlen(s) / k) + 1;\\n    char **arr = malloc(sizeof(char *) * len);      //** allocating\\n    \\n    for(i = 0; i < len; i++)\\n        arr[i] = malloc(sizeof(char) * (k+1));      //* allocating\\n    \\n    i = 0;\\n    while(i < strlen(s) + 1 && count <= k){\\n        if(!count && count % k == 0){\\n            arr[row][col] = \\'\\\\0\\';\\n            row++;\\n            col = 0;\\n            count = 0;\\n            i--;\\n        }"]]}
{"id": "459", "ref_c": [["int minimumCost(int* cost, int costSize)\\n{\\n  int final_price = 0;\\n\\n  // Trivial case\\n  if (costSize == 1 || costSize == 2)\\n  {\\n    for (int i = 0; i < costSize; i++) final_price += cost[i];\\n    return final_price;\\n  }"], ["int minimumCost(int* cost, int costSize)\\n{\\n  int final_price = 0;\\n\\n  // Trivial case\\n  if (costSize == 1 || costSize == 2)\\n  {\\n    for (int i = 0; i < costSize; i++) final_price += cost[i];\\n    return final_price;\\n  }"], ["int minimumCost(int* cost, int costSize)\\n{\\n  int final_price = 0;\\n\\n  // Trivial case\\n  if (costSize == 1 || costSize == 2)\\n  {\\n    for (int i = 0; i < costSize; i++) final_price += cost[i];\\n    return final_price;\\n  }"]]}
{"id": "460", "ref_c": [["int countElements(int* nums, int numsSize) {\\n    int count = 0;\\n    for(int i = 0; i < numsSize; i++) {\\n        bool is_small = false, is_big = false;\\n        for(int j = 0; j < numsSize; j++) {\\n            if (nums[i] < nums[j]) {\\n                is_small = true;\\n            }"], ["int countElements(int* nums, int numsSize){\\n   int count = 0;\\n\\n   for(int i = 0; i < numsSize; i++) {\\n       int flag_smaller = 0;\\n       int flag_greater = 0;\\n       \\n       for(int j = 0; j < numsSize; j++) {\\n           if (i != j) {\\n               if (nums[i] > nums[j]) {\\n                   flag_greater = 1;  \\n               }"], ["int countElements(int* nums, int numsSize){\\n   int count = 0;\\n\\n   for(int i = 0; i < numsSize; i++) {\\n       int flag_smaller = 0;\\n       int flag_greater = 0;\\n       \\n       for(int j = 0; j < numsSize; j++) {\\n           if (i != j) {\\n               if (nums[i] > nums[j]) {\\n                   flag_greater = 1;  \\n               }"]]}
{"id": "461", "ref_c": [["int findFinalValue(int* nums, int numsSize, int original) {\\n    while(true) {\\n        bool is_found = false;\\n        for(int i = 0; i < numsSize; i++) {\\n            if (nums[i] == original) {\\n                is_found = true;\\n                original = original * 2;\\n                break;\\n            }"], ["int findFinalValue(int* nums, int numsSize, int original) {\\nfor (int i = 0; i < numsSize; ++i) {\\n    if (nums[i] == original) {\\n        original *= 2;\\n        i = -1;\\n    }"], ["int findFinalValue(int* nums, int numsSize, int original) {\\n    while(true) {\\n        bool is_found = false;\\n        for(int i = 0; i < numsSize; i++) {\\n            if (nums[i] == original) {\\n                is_found = true;\\n                original = original * 2;\\n                break;\\n            }"]]}
{"id": "462", "ref_c": [["int minimumSum(int num) \\n{\\n    int digits[4];\\n    for(int i = 0; i < 4; i++)\\n    {\\n        digits[i] = num % 10;\\n        num /= 10;\\n    }"], ["int minimumSum(int num){\\n    int arr[4];\\n\\n    int i;\\n    for (i = 0; i < 4; ++i) {\\n        arr[i] = num % 10;\\n        num = num / 10;\\n    }"], ["int minimumSum(int num) {\\n        vector<int> temp;\\n        for (int i = 0; i < 4; i++)\\n        {\\n           temp.push_back(num%10);\\n           num/=10;\\n        }"]]}
{"id": "463", "ref_c": [["int* sortEvenOdd(int* nums, int numsSize, int* returnSize){\\n    int * a=(int *)malloc(sizeof(int) * numsSize);\\n    int i,j=0,temp=0;\\n    *returnSize=numsSize;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        a[i]=nums[i];\\n    }"], ["int* sortEvenOdd(int* nums, int numsSize, int* returnSize){\\n    int * a=(int *)malloc(sizeof(int) * numsSize);\\n    int i,j=0,temp=0;\\n    *returnSize=numsSize;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        a[i]=nums[i];\\n    }"], ["int* sortEvenOdd(int* nums, int numsSize, int* returnSize){\\n        *returnSize = numsSize;\\n        for(int i = 0; i < numsSize; i+=2){\\n            int min_value = i;\\n            for(int j = i+2; j < numsSize; j+=2){\\n                if(nums[min_value] > nums[j]) min_value = j;\\n            }"]]}
{"id": "464", "ref_c": [["int countOperations(int num1, int num2)\\n{\\n    int count = 0;\\n    while(num1>0 && num2>0)\\n    {\\n        if(num1>=num2)\\n        num1 -= num2;\\n        else\\n        num2 -= num1;\\n        count++;\\n    }"], ["int countOperations(int num1, int num2) {\\n        if (num1 == 0 or num2 == 0){ //base case\\n            return count_op;\\n        }"], ["int countOperations(int num1, int num2){\\n    int ops=0;\\n    while(num1 && num2){\\n        if(num1>=num2){\\n            num1-=num2;\\n        }"]]}
{"id": "465", "ref_c": [["int countPairs(int* nums, int numsSize, int k) {\\n    int counter=0;\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n           if(nums[i]==nums[j]&&(i*j)%k==0){\\n                counter++;\\n            }"], ["int countPairs(int* nums, int numsSize, int k) {\\n    int c=0;\\n    for(int i=0 ;i <numsSize ;i++){\\n        for(int j=i+1 ; j<numsSize ;j++){\\n            if(nums[i]==nums[j]&& i*j%k == 0){\\n                c++;\\n            }"], ["int countPairs(int* nums, int numsSize, int k) {\\n    int count=0;\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]&&(i*j)%k==0)\\n            count++;\\n\\n        }"]]}
{"id": "466", "ref_c": [["int countEven(int num)\\n{\\n    int count = 0;\\n    for(int i = 1;i<=num;i++)\\n    {\\n        if(digsum(i)%2==0)\\n        count++;\\n    }"], ["int countEven(int num) \\n{\\n    int count = 0;\\n    for(int n = 1; n <= num; n++)\\n    {\\n        count += (getSumOfDigits(n) % 2)? 0 : 1;\\n    }"], ["int countEven(int num) {\\n    int count=0;\\n    int dgsum;\\n    for(int i=2;i<=num;i++){\\n        if(i<9&&i%2==0)\\n        count++;\\n        else{\\n               int temp=i;\\n               dgsum=0;\\n               while(temp){\\n                   dgsum+=temp%10;\\n                   temp/=10;\\n               }"]]}
{"id": "467", "ref_c": [["int prefixCount(char ** words, int wordsSize, char * pref)\\n{\\n    int l=0,c=0,c1=0;\\n    for(int i=0;pref[i]!=\\'\\\\0\\';i++)l++;\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        while(c<l)\\n        {\\n            if(words[i][c]==pref[c])\\n            {\\n                c++;\\n                continue;\\n            }"], ["int prefixCount(char ** words, int wordsSize, char * pref)\\n{\\n    int l=0,c=0,c1=0;\\n    for(int i=0;pref[i]!=\\'\\\\0\\';i++)l++;\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        while(c<l)\\n        {\\n            if(words[i][c]==pref[c])\\n            {\\n                c++;\\n                continue;\\n            }"], ["int prefixCount(char ** words, int wordsSize, char * pref)\\n{\\n    int l=0,c=0,c1=0;\\n    for(int i=0;pref[i]!=\\'\\\\0\\';i++)l++;\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        while(c<l)\\n        {\\n            if(words[i][c]==pref[c])\\n            {\\n                c++;\\n                continue;\\n            }"]]}
{"id": "468", "ref_c": [["int mostFrequent(int* nums, int numsSize, int key) {\\n    int arr[1001] = {0}"], ["int mostFrequent(int* nums, int numsSize, int key) {\\n    int arr[1001] = {0}"], ["int mostFrequent(int* nums, int numsSize, int key) {\\n    int arr[1001] = {0}"]]}
{"id": "469", "ref_c": [["char ** cellsInRange(char * s, int* returnSize){\\n    unsigned len = (s[3] + 1) - s[0], i =0,index = 0;\\n    len = len * ((s[4] - \\'0\\')  - (s[1] - \\'0\\') + 1);\\n  \\n    *returnSize = len;\\n    char cstart = s[1];\\n  \\n    char** arr = (char**)malloc(len * sizeof(char*));\\n\\n    for(i = 0; i < len; i++)\\n        arr[i] = (char*)malloc(3 * sizeof(char));\\n    \\n    for(i = 0; i < len; i ++)\\n        arr[i][2] = \\'\\\\0\\';\\n    \\n\\n    for(i = 0; i < len; i++)\\n    {\\n       if(cstart > s[4])\\n       {\\n        s[index]++;\\n        cstart = s[1];\\n       }"], ["char ** cellsInRange(char * s, int* returnSize){\\n    int row = s[4] - s[1] + 1;\\n    int col = s[3] - s[0] + 1;\\n    char **res = (char **)calloc(row * col, sizeof(char *));\\n\\n    *returnSize = row * col;\\n    for (int i = 0; i < col; i++) {\\n        for (int j = 0; j < row; j++) {\\n            res[i * row + j] = (char *)calloc(3, sizeof(char));\\n            res[i * row + j][0] = s[0] + i;\\n            res[i * row + j][1] = s[1] + j;\\n        }"], ["char ** cellsInRange(char * s, int* returnSize){\\n    if(!s)\\n        return NULL;\\n    int l_size = s[3] - s[0] + 1;\\n    int d_size = s[4] - s[1] + 1;\\n    *returnSize = l_size*d_size;\\n    char** ret = malloc(sizeof(char*)*l_size*d_size);\\n    for(int i=0;i<l_size;i++){\\n        for(int j=0;j<d_size;j++){\\n            ret[i*d_size+j] = malloc(sizeof(char)*3);\\n            ret[i*d_size+j][0] = s[0] + i;\\n            ret[i*d_size+j][1] = s[1] + j;\\n            ret[i*d_size+j][2] = \\'\\\\0\\';\\n        }"]]}
{"id": "470", "ref_c": [["int* findKDistantIndices(int* nums, int numsSize, int key, int k, int* returnSize) {\\n\\n  *returnSize = 0;\\n  int *result = NULL;\\n  int n = 0;\\n  \\n  for (int i = 0, l = 0; i < numsSize; ++i) {\\n    if (nums[i] == key) {\\n      l = max(l, i - k);\\n\\n      *returnSize += ((2 * k + 1) - (l > i - k ? (l - (i - k)) : 0) -\\n                      (i + k > numsSize - 1 ? i + k - (numsSize - 1) : 0));\\n      result = realloc(result, *returnSize * sizeof(*result));\\n      while (l < numsSize && l <= i + k) {\\n        result[n++] = l++;\\n      }"], ["int* findKDistantIndices(int* nums, int numsSize, int key, int k, int* returnSize) {\\n\\n  *returnSize = 0;\\n  int *result = NULL;\\n  int n = 0;\\n  \\n  for (int i = 0, l = 0; i < numsSize; ++i) {\\n    if (nums[i] == key) {\\n      l = max(l, i - k);\\n\\n      *returnSize += ((2 * k + 1) - (l > i - k ? (l - (i - k)) : 0) -\\n                      (i + k > numsSize - 1 ? i + k - (numsSize - 1) : 0));\\n      result = realloc(result, *returnSize * sizeof(*result));\\n      while (l < numsSize && l <= i + k) {\\n        result[n++] = l++;\\n      }"], ["int* findKDistantIndices(int* nums, int numsSize, int key, int k, int* returnSize) {\\n\\n  *returnSize = 0;\\n  int *result = NULL;\\n  int n = 0;\\n  \\n  for (int i = 0, l = 0; i < numsSize; ++i) {\\n    if (nums[i] == key) {\\n      l = max(l, i - k);\\n\\n      *returnSize += ((2 * k + 1) - (l > i - k ? (l - (i - k)) : 0) -\\n                      (i + k > numsSize - 1 ? i + k - (numsSize - 1) : 0));\\n      result = realloc(result, *returnSize * sizeof(*result));\\n      while (l < numsSize && l <= i + k) {\\n        result[n++] = l++;\\n      }"]]}
{"id": "471", "ref_c": [["bool divideArray(int* nums, int numsSize)\\n{\\n    int c=0;\\n    int *h=(int*)malloc(501*sizeof(int));\\n    for(int i=0;i<501;i++)h[i]=0;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        h[nums[i]]++;\\n    }"], ["bool divideArray(int* nums, int numsSize){\\n    int pairs = numsSize/2;\\n    int res=0;\\n    int h[501]={0}"], ["bool divideArray(int* nums, int numsSize){\\n    int pairs = numsSize/2;\\n    int res=0;\\n    int h[501]={0}"]]}
{"id": "472", "ref_c": [["int countHillValley(int* nums, int numsSize) \\n{\\n  int i = 1, flag = 0, count = 0;\\n  while(i < numsSize)\\n  {\\n    if(nums[i - 1] < nums[i])\\n    {\\n      if(flag == -1)\\n      {\\n        count++;\\n      }"], ["int countHillValley(int* nums, int numsSize) \\n{\\n  int i = 1, flag = 0, count = 0;\\n  while(i < numsSize)\\n  {\\n    if(nums[i - 1] < nums[i])\\n    {\\n      if(flag == -1)\\n      {\\n        count++;\\n      }"], ["int countHillValley(int* nums, int numsSize){\\n    int sameHill;\\n    int i, before, after;\\n    int valley = 0;\\n    int hill = 0;\\n\\n    for (i = 1 ; i < (numsSize - 1) ; i++){\\n        before = i - 1;\\n        after = i + 1;\\n        sameHill = false;\\n\\n        if (nums[before] == nums[i]){       //test if the number is the same valley/hill\\n            sameHill = true;\\n        }"]]}
{"id": "473", "ref_c": [["int** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes){\\n    //\\u4E8C\\u7DAD\\u9663\\u5217\\n    int **ans;\\n    ans = (int**)malloc(2*sizeof(int*));\\n    for(int i = 0; i < 2; i++){\\n        ans[i]=(int*)malloc(sizeof(int)*max) ;\\n        memset(ans[i],0,max*sizeof(int));\\n    }"], ["int** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes){\\n    //\\u4E8C\\u7DAD\\u9663\\u5217\\n    int **ans;\\n    ans = (int**)malloc(2*sizeof(int*));\\n    for(int i = 0; i < 2; i++){\\n        ans[i]=(int*)malloc(sizeof(int)*max) ;\\n        memset(ans[i],0,max*sizeof(int));\\n    }"], ["int** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes){\\n    //\\u4E8C\\u7DAD\\u9663\\u5217\\n    int **ans;\\n    ans = (int**)malloc(2*sizeof(int*));\\n    for(int i = 0; i < 2; i++){\\n        ans[i]=(int*)malloc(sizeof(int)*max) ;\\n        memset(ans[i],0,max*sizeof(int));\\n    }"]]}
{"id": "474", "ref_c": [["int minBitFlips(int start, int goal){\\n    int DifferentBits = start ^ goal,count=0; // DifferentBits hold how many bits are different\\n    while (DifferentBits != 0) {\\n        if (DifferentBits & 1) // if DifferentBits = 1, these bits are different. So, count++\\n            count++;\\n        DifferentBits >>= 1;\\n    }"], ["int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        \\n        // # Here we get he number if set bits which are required for getting our goal number\\n        int set=start^goal;\\n        \\n        // # kernighan\\'s algo for finding no of set bits\\n        while(set!=0){\\n            \\n            // # a mask in which only right most bit is set\\n            int rsb=(set&(-set));\\n            set=set-rsb;\\n            cnt++;\\n        }"], ["int minBitFlips(int start, int goal) {\\n        int c=0, i=0;\\n        while(start != goal){\\n            int mask=1<<i;\\n            if((start & mask) == (goal & mask))\\n                i++;\\n            else{\\n                start=start ^ mask;\\n                c++;\\n                i++;\\n            }", "int minBitFlips(int start, int goal) {\\n        int res = start ^ goal;\\n        int c=0;\\n        while(res!=0){\\n            res = res & (res-1);\\n            c++;\\n        }"]]}
{"id": "475", "ref_c": [["int convertTime(char * current, char * correct){\\n    int timeNow = ((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60 + (current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n    int timeCorr = ((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60 + (correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n    int d = timeCorr - timeNow;\\n    return d/60+(d%60)/15+((d%60)%15)/5+(((d%60)%15)%5)/1;\\n}"], ["int convertTime(char * current, char * correct){\\n    int timeNow = ((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60 + (current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n    int timeCorr = ((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60 + (correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n    int d = timeCorr - timeNow;\\n    return d/60+(d%60)/15+((d%60)%15)/5+(((d%60)%15)%5)/1;\\n}"], ["int convertTime(char * current, char * correct){\\n    int timeNow = ((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60 + (current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n    int timeCorr = ((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60 + (correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n    int d = timeCorr - timeNow;\\n    return d/60+(d%60)/15+((d%60)%15)/5+(((d%60)%15)%5)/1;\\n}"]]}
{"id": "476", "ref_c": [["int largestInteger(int num) {\\n        vector<int>v;\\n        long long int temp=num;\\n        while(num){\\n            v.push_back(num%10);\\n            num/=10;\\n        }"], ["int largestInteger(int num) {\\n        vector<int>nums;\\n        int q = num;\\n        priority_queue<int>odd;\\n        priority_queue<int>even;\\n        while(q){\\n            int rem = q % 10;\\n            if(rem % 2 != 0)odd.push(rem);\\n            else even.push(rem);\\n            nums.push_back(rem);\\n            q = q / 10;\\n        }"], ["int largestInteger(int num) {\\n        priority_queue<int> even;\\n        priority_queue<int> odd;\\n        vector<int> nums;\\n\\n        int rem = 0;\\n\\n        while(num!=0)\\n        {\\n            rem = num%10;\\n            \\n            // store every digin in \\'nums\\' vector\\n            nums.push_back(rem);\\n\\n            if(rem%2 == 0)\\n                even.push(rem);\\n            else\\n                odd.push(rem);\\n\\n            num /= 10;\\n        }"]]}
{"id": "477", "ref_c": [["int sum(int num1, int num2){\\n    return num1+num2;}"], ["int sum(int num1, int num2) {\\n        return num1+num2;\\n    }", "int sum(int num1, int num2){\\nreturn num1+num2;\\n}", "int sum(int num1, int num2) {\\n        return num1+num2;\\n    }"], ["int sum(int num1, int num2) {\\n        return num1 + num2;\\n    }", "int sum(int num1, int num2) {\\n        return num1 + num2;\\n    }", "int sum(int num1, int num2){\\n    return num1 + num2;\\n}", "int sum(int num1, int num2) {\\n    return num1 + num2;\\n  }"]]}
{"id": "478", "ref_c": [["bool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}"], ["bool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}"], ["bool checkTree(struct TreeNode* root){\\n    return root->val == (root->left->val + root->right->val);\\n}", "bool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}"]]}
{"id": "479", "ref_c": [["int findClosestNumber(int* nums, int numsSize) \\n{\\n    int closest = nums[0];\\n    int current;\\n    int absClosest;\\n    int absCurrent;\\n\\n    for (int i = 1; i < numsSize; i++) \\n    {\\n        current = nums[i];\\n        // you can use funtion \"abs()\" defined in <stdlib.h>\\n        if(closest < 0)\\n        {\\n            absClosest = -closest;\\n        }"], ["int findClosestNumber(int* nums, int numsSize)\\n{\\n    int min = INT_MAX;\\n    int val = INT_MAX;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (abs(nums[i]) <= min) {\\n            min = abs(nums[i]);\\n            if (abs(val) == abs(nums[i]))\\n                val = val > nums[i] ? val : nums[i];\\n            else\\n                val = nums[i];\\n            printf(\"%d \", val);\\n        }"], ["int findClosestNumber(int* nums, int numsSize) \\n{\\n    int closest = nums[0];\\n    int current;\\n    int absClosest;\\n    int absCurrent;\\n\\n    for (int i = 1; i < numsSize; i++) \\n    {\\n        current = nums[i];\\n        // you can use funtion \"abs()\" defined in <stdlib.h>\\n        if(closest < 0)\\n        {\\n            absClosest = -closest;\\n        }"]]}
{"id": "480", "ref_c": [["char * digitSum(char * s, int k) {\\n    int cur = 0;\\n    int sum = 0;\\n    for (int i = 0; strlen(s) > k; i++) {\\n        if (i != 0 && i % k == 0 || i == strlen(s)) {\\n                char buff[16];\\n                sprintf(buff, \"%d\", sum);\\n                for (int i = 0; buff[i]; i++, cur++)\\n                    s[cur] = buff[i];\\n                sum = 0;\\n            }"], ["char * digitSum(char * s, int k){\\n    \\n\\t\\t//base case\\n\\t\\tif (strlen(s) <= k)\\n\\t\\t\\treturn s;\\n\\n\\t\\t//iterate through s using sPtr\\n\\t\\tint j = 0;\\n\\t\\tchar *sPtr = s;\\n\\t\\twhile (*sPtr != \\'\\\\0\\')\\n\\t\\t{\\n\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\t//calculating the sum of groups of k\\n\\t\\t\\tfor (int i = 0; (i < k) && (*sPtr!=\\'\\\\0\\'); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum += *sPtr - \\'0\\';\\n\\t\\t\\t\\tsPtr++;\\n\\t\\t\\t}"], ["char * digitSum(char * s, int k){\\n    \\n\\t\\t//base case\\n\\t\\tif (strlen(s) <= k)\\n\\t\\t\\treturn s;\\n\\n\\t\\t//iterate through s using sPtr\\n\\t\\tint j = 0;\\n\\t\\tchar *sPtr = s;\\n\\t\\twhile (*sPtr != \\'\\\\0\\')\\n\\t\\t{\\n\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\t//calculating the sum of groups of k\\n\\t\\t\\tfor (int i = 0; (i < k) && (*sPtr!=\\'\\\\0\\'); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum += *sPtr - \\'0\\';\\n\\t\\t\\t\\tsPtr++;\\n\\t\\t\\t}"]]}
{"id": "481", "ref_c": [["int* intersection(int** nums, int numsSize, int* numsColSize, int* returnSize)\\n{\\n    int hash[1001] = {0}"], ["int* intersection(int** nums, int numsSize, int* numsColSize, int* returnSize)\\n{\\n    int hash[1001] = {0}"], ["int* intersection(int** nums, int numsSize, int* numsColSize, int* returnSize)\\n{\\n    int hash[1001] = {0}"]]}
{"id": "482", "ref_c": [["int countPrefixes(char ** words, int wordsSize, char * s){\\n\\n    int count = 0; \\n    int sLen = strlen(s); \\n    for(int i=0; i<wordsSize; i++)\\n    {\\n        int wordLen = strlen(words[i]);\\n        if (wordLen > sLen)\\n        {\\n            continue; \\n        }"], ["int countPrefixes(char ** words, int wordsSize, char * s)\\n{\\n    int c=0;\\n    int j=0;\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        while(words[i][j]!=\\'\\\\0\\')\\n        {\\n            if(words[i][j]!=s[j])\\n            break;\\n            j++;\\n        }"], ["int countPrefixes(char ** words, int wordsSize, char * s){\\n\\n    int count = 0; \\n    int sLen = strlen(s); \\n    for(int i=0; i<wordsSize; i++)\\n    {\\n        int wordLen = strlen(words[i]);\\n        if (wordLen > sLen)\\n        {\\n            continue; \\n        }"]]}
{"id": "483", "ref_c": [["char * removeDigit(char * number, char digit) {\\n    int len = strlen(number);\\n    int to_remove;\\n    for (int i=0; i<len; i++) {\\n        if (number[i] == digit) {\\n            to_remove = i;\\n            if (i==len-1 || digit < number[i+1])  break;\\n        }"], ["char * removeDigit(char * number, char digit){\\n    static char result[100];  // Declare a static character array to store the resulting string\\n    int len = strlen(number); // Find the length of the input number string\\n    int i, j = 0;\\n    int index_to_remove = -1; // Initialize the index to remove as -1\\n\\n    // Iterate through the input number string and find the first digit that is smaller than its successor\\n    for (i = 0; i < len - 1; i++) {\\n        if (number[i] == digit && number[i] < number[i + 1]) {\\n            index_to_remove = i;\\n            break;\\n        }"], ["char * removeDigit(char * number, char digit){\\n    int len = strlen(number);\\n    int indexDigit = 0;\\n    int i=0, k=0, l=0;\\n    for(i=0; i<len; i++){\\n    \\tif(number[i] != digit){\\n    \\t\\tcontinue;\\n    \\t}"]]}
{"id": "484", "ref_c": ["\nchar* largestGoodInteger(char* num) {\n    int left = 0, length = strlen(num);\n    char *maxGoodInteger = calloc(4, sizeof(char));\n    char auxSubstring[4];\n    while (left + 2 < length) {\n        memcpy(auxSubstring, &num[left], 3);\n        if (num[left] == num[left+1] && num[left] == num[left+2] && strcmp(auxSubstring, maxGoodInteger) > 0) {\n            memcpy(maxGoodInteger, auxSubstring, 3);\n        }\n        left++;\n    }\n    return maxGoodInteger;\n}\n", "\nchar* largestGoodInteger(char* num) {\n    int left = 0, length = strlen(num);\n    char *maxGoodInteger = calloc(4, sizeof(char));\n    char auxSubstring[4];\n    while (left + 2 < length) {\n        memcpy(auxSubstring, &num[left], 3);\n        if (num[left] == num[left+1] && num[left] == num[left+2] && strcmp(auxSubstring, maxGoodInteger) > 0) {\n            memcpy(maxGoodInteger, auxSubstring, 3);\n        }\n        left++;\n    }\n    return maxGoodInteger;\n}\n", "\nchar* largestGoodInteger(char* num) {\n    int left = 0, length = strlen(num);\n    char *maxGoodInteger = calloc(4, sizeof(char));\n    char auxSubstring[4];\n    while (left + 2 < length) {\n        memcpy(auxSubstring, &num[left], 3);\n        if (num[left] == num[left+1] && num[left] == num[left+2] && strcmp(auxSubstring, maxGoodInteger) > 0) {\n            memcpy(maxGoodInteger, auxSubstring, 3);\n        }\n        left++;\n    }\n    return maxGoodInteger;\n}\n"]}
{"id": "485", "ref_c": [["int divisorSubstrings(int num, int k) {\\n    char string_num[20];  // Assuming a maximum of 20 digits for the number\\n    sprintf(string_num, \"%d\", num);\\n    int k_beauty = 0;\\n\\n    for (int i = 0; i <= strlen(string_num) - k; i++) {\\n        char sub_num_str[20];\\n        strncpy(sub_num_str, string_num + i, k);\\n        sub_num_str[k] = \\'\\\\0\\';\\n        int sub_num = atoi(sub_num_str);\\n\\n        if (sub_num && num % sub_num == 0) {\\n            k_beauty++;\\n        }"], ["int divisorSubstrings(int num, int k) {\\n\\n        int head=0;\\n        int tail=0;\\n        int ans=0;\\n        string numstr=to_string(num);//convert to string so that we can iterate on number\\n        for(head=0;head<numstr.size();head++)//iterate on the number which was converted to string\\n        {\\n            if(head-tail+1==k)//check if window size is met\\n            {\\n                string temp=numstr.substr(tail,k);//take the substring from tail to k length\\n                int n=stoi(temp);//convert into integer for division\\n                if(n!=0)//as 0 should not be the divisor check of n is 0\\n                {\\n                    int res=num%n;//if not 0 then save the remainder\\n                    if(res==0)//if remainder is 0 then it is a divisor\\n                    {\\n                        ans++;//if it is a divisor increment the count\\n                    }"], ["int divisorSubstrings(int num, int k) {\\n        int count = 0;\\n        long long slide = pow(10,k);\\n        long long limit = slide/10;\\n        int n = num;\\n        while(num >= limit)\\n        {\\n            int r = num % slide;\\n            if(r != 0 && n % r == 0)\\n            count++;\\n            num = num / 10;\\n        }"]]}
{"id": "486", "ref_c": [["char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    (*returnSize) = 1;\\n\\n    int len;\\n    int i;\\n    for (i=1; i<wordsSize; ++i)\\n    {\\n        if (isAnagrams(words[(*returnSize)-1], words[i]) == true)\\n        {\\n            continue;\\n        }"], ["char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    int i = 0 , j =0 , size  = 1;\\n    char** ret = (char**)malloc(wordsSize*sizeof(char*));\\n    ret[size-1] = words[0];\\n    for(i = 1 ; i < wordsSize ; ++i)\\n    {\\n        if(isAng(ret[size-1] , words[i]))\\n            continue;\\n        else\\n        {\\n            ++size;\\n            ret[size-1] = words[i];\\n        }"], ["char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    int i = 0 , j =0;\\n    char** ret = NULL;\\n    int size = 0;\\n    for( j = 0 ,i = 1 ; i < wordsSize ; )\\n    {\\n        if(words[j] && words[i]  && (isAng(words[i] , words[j])))\\n        {\\n            words[i] = NULL;\\n            ++i;\\n        }"]]}
{"id": "487", "ref_c": ["\nint percentageLetter(char * s, char letter){\n   int l=strlen(s),c=0;\n   for(int i=0;i<strlen(s);i++)\n   {\n       if(s[i]==letter)\n       {\n           c++;\n       }\n   }\n   int val=(double)c/l *100.0;\n   return val;\n}\n", "\nint percentageLetter(char * s, char letter){\n   int l=strlen(s),c=0;\n   for(int i=0;i<strlen(s);i++)\n   {\n       if(s[i]==letter)\n       {\n           c++;\n       }\n   }\n   int val=(double)c/l *100.0;\n   return val;\n}\n", "\nint percentageLetter(char * s, char letter){\n   int l=strlen(s),c=0;\n   for(int i=0;i<strlen(s);i++)\n   {\n       if(s[i]==letter)\n       {\n           c++;\n       }\n   }\n   int val=(double)c/l *100.0;\n   return val;\n}\n"]}
{"id": "488", "ref_c": [["bool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }"], ["bool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }"], ["bool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }"]]}
{"id": "489", "ref_c": [["int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}", "int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}"], ["int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}", "int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}"], ["int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}", "int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}"]]}
{"id": "490", "ref_c": [["int minMaxGame(int* nums, int numsSize) {\\n    \\n\\t\\tint left = 0,\\n\\t\\tright = numsSize - 1,\\n\\t\\tindex = 0;\\n\\n\\t\\twhile (left <= right) {\\n\\n\\t\\t\\tif (left == right) {\\n\\t\\t\\t\\treturn nums[0];\\n\\t\\t\\t}"], ["int minMaxGame(int* nums, int numsSize){\\n    int i;\\nif (numsSize == 1)\\n{\\n    return nums[0];\\n}"], ["int minMaxGame(int* nums, int numsSize){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     */\\n\\n    while (numsSize > 2) {\\n    \\n        for (int i = 0, j = 0; i < numsSize; i += 4, j += 2) {\\n            nums[j] = MIN(nums[i], nums[i + 1]);\\n            nums[j + 1] = MAX(nums[i + 2], nums[i + 3]);\\n        }"]]}
{"id": "491", "ref_c": [["bool strongPasswordCheckerII(char * password){\\n    bool lowercase=false;\\n    bool uppercase=false;\\n    bool digit=false;\\n    bool specialchr=false;\\n    int n=strlen(password);\\n    if(n<8) return false;\\n    for(int i=0;i<n;i++){\\n        if(i>0 && password[i]==password[i-1]){\\n            return false;\\n        }"], ["bool strongPasswordCheckerII(char * password){\\n    bool lowercase=false;\\n    bool uppercase=false;\\n    bool digit=false;\\n    bool specialchr=false;\\n    int n=strlen(password);\\n    if(n<8) return false;\\n    for(int i=0;i<n;i++){\\n        if(i>0 && password[i]==password[i-1]){\\n            return false;\\n        }"], ["bool strongPasswordCheckerII(char * password){\\n    bool lowercase=false;\\n    bool uppercase=false;\\n    bool digit=false;\\n    bool specialchr=false;\\n    int n=strlen(password);\\n    if(n<8) return false;\\n    for(int i=0;i<n;i++){\\n        if(i>0 && password[i]==password[i-1]){\\n            return false;\\n        }"]]}
{"id": "492", "ref_c": [["double calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income) \\n{\\n    // *bracketsColSize == 2\\n    int money = (brackets[0][0] <= income)? brackets[0][0] : income;\\n    double amount = money * brackets[0][1] * 0.01;\\n    income -= money;\\n    int i = 1;\\n    while(i < bracketsSize && income > 0)\\n    {\\n        money = (brackets[i][0] - brackets[i - 1][0] <= income)?\\n                                    brackets[i][0] - brackets[i - 1][0] : income; \\n        amount += money * brackets[i][1] * 0.01;\\n        income -= money;\\n        i++;    \\n    }"], ["double calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income){\\n\\n    int lb = 0;\\n    double r = 0;\\n    \\n    for(int i = 0; i < bracketsSize; ++i)\\n    {\\n        double val = max(0, min(income, *(*(brackets + i))) - lb);\\n        r += (*(*(brackets + i)+1) * val)/100;\\n        lb = *(*(brackets + i));\\n    }"], ["double calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income){\\n\\n    int lb = 0;\\n    double r = 0;\\n    \\n    for(int i = 0; i < bracketsSize; ++i)\\n    {\\n        double val = max(0, min(income, *(*(brackets + i))) - lb);\\n        r += (*(*(brackets + i)+1) * val)/100;\\n        lb = *(*(brackets + i));\\n    }"]]}
{"id": "493", "ref_c": ["\nchar * greatestLetter(char * s){\n    int upper[26] = {0};\n    int lower[26] = {0};\n    int i = 0;\n    char *res;\n\n    res = (char *)malloc(sizeof(char) * 2);\n\n    while(s[i])\n    {\n        if(s[i] >= 'a' && s[i] <= 'z')\n            lower[s[i] - 'a']++;\n        else\n            upper[s[i] - 'A']++;\n        i++;\n    }\n    i = 25;\n    while(i >= 0)  //greatest English letter('z' to 'a')\n    {\n        if(lower[i] && upper[i])\n        {\n            *res = i + 'A';\n            res++;\n            *res = '\u0000';\n            res--;\n            return res;\n        }\n            \n        i--;\n    }\n    return \"\";\n}\n", "\nchar * greatestLetter(char * s){\n    int upper[26] = {0};\n    int lower[26] = {0};\n    int i = 0;\n    char *res;\n\n    res = (char *)malloc(sizeof(char) * 2);\n\n    while(s[i])\n    {\n        if(s[i] >= 'a' && s[i] <= 'z')\n            lower[s[i] - 'a']++;\n        else\n            upper[s[i] - 'A']++;\n        i++;\n    }\n    i = 25;\n    while(i >= 0)  //greatest English letter('z' to 'a')\n    {\n        if(lower[i] && upper[i])\n        {\n            *res = i + 'A';\n            res++;\n            *res = '\u0000';\n            res--;\n            return res;\n        }\n            \n        i--;\n    }\n    return \"\";\n}\n", "\nchar * greatestLetter(char * s){\n    int upper[26] = {0};\n    int lower[26] = {0};\n    int i = 0;\n    char *res;\n\n    res = (char *)malloc(sizeof(char) * 2);\n\n    while(s[i])\n    {\n        if(s[i] >= 'a' && s[i] <= 'z')\n            lower[s[i] - 'a']++;\n        else\n            upper[s[i] - 'A']++;\n        i++;\n    }\n    i = 25;\n    while(i >= 0)  //greatest English letter('z' to 'a')\n    {\n        if(lower[i] && upper[i])\n        {\n            *res = i + 'A';\n            res++;\n            *res = '\u0000';\n            res--;\n            return res;\n        }\n            \n        i--;\n    }\n    return \"\";\n}\n"]}
{"id": "494", "ref_c": [["int countAsterisks(char * s){\\n    bool in=true;\\n    int len=strlen( s), out=0;\\n    for( int i=0; i<len; i++){\\n        if( s[i]==\\'|\\'){\\n            in=true^in;\\n        }"], ["int countAsterisks(char * s){\\n    bool in=true;\\n    int len=strlen( s), out=0;\\n    for( int i=0; i<len; i++){\\n        if( s[i]==\\'|\\'){\\n            in=true^in;\\n        }"], ["int countAsterisks(char * s){\\n    bool in=true;\\n    int len=strlen( s), out=0;\\n    for( int i=0; i<len; i++){\\n        if( s[i]==\\'|\\'){\\n            in=true^in;\\n        }"]]}
{"id": "495", "ref_c": [["bool checkXMatrix(int** grid, int gridSize, int* gridColSize) {\\n    int a=gridSize-1;\\n    for(int i=0;i<gridSize;i++){\\n        for(int j=0;j<gridSize;j++){\\n            if(i==j || i+j==a){\\n                if(grid[i][j]==0){\\n                    return false;\\n                }"], ["bool checkXMatrix(int** grid, int gridSize, int* gridColSize) {\\n    int a=gridSize-1;\\n    for(int i=0;i<gridSize;i++){\\n        for(int j=0;j<gridSize;j++){\\n            if(i==j || i+j==a){\\n                if(grid[i][j]==0){\\n                    return false;\\n                }"], ["bool checkXMatrix(int** grid, int gridSize, int* gridColSize) {\\n    int a=gridSize-1;\\n    for(int i=0;i<gridSize;i++){\\n        for(int j=0;j<gridSize;j++){\\n            if(i==j || i+j==a){\\n                if(grid[i][j]==0){\\n                    return false;\\n                }"]]}
{"id": "496", "ref_c": [["char * decodeMessage(char * key, char * message){\\n    int array[26] ;\\n    memset(array, -1, sizeof(array));\\n    int p = 0 ;\\n    for(int i = 0 ; i < strlen(key) ; i++)\\n    {\\n        if(key[i] != \\' \\')\\n        {\\n            if(array[key[i]-\\'a\\'] == -1 )\\n            {\\n                array[key[i]-\\'a\\'] = p;\\n                p++;\\n            }"], ["char * decodeMessage(char * key, char * message){\\n    int array[26] ;\\n    memset(array, -1, sizeof(array));\\n    int p = 0 ;\\n    for(int i = 0 ; i < strlen(key) ; i++)\\n    {\\n        if(key[i] != \\' \\')\\n        {\\n            if(array[key[i]-\\'a\\'] == -1 )\\n            {\\n                array[key[i]-\\'a\\'] = p;\\n                p++;\\n            }"], ["char * decodeMessage(char * key, char * message){\\n    int array[26] ;\\n    memset(array, -1, sizeof(array));\\n    int p = 0 ;\\n    for(int i = 0 ; i < strlen(key) ; i++)\\n    {\\n        if(key[i] != \\' \\')\\n        {\\n            if(array[key[i]-\\'a\\'] == -1 )\\n            {\\n                array[key[i]-\\'a\\'] = p;\\n                p++;\\n            }"]]}
{"id": "497", "ref_c": [["bool evaluateTree(struct TreeNode* root){\\n    if(edgeCases(root))\\n        return root->val==1;\\n\\n    int result=evaluateTreeInt(root);\\n    //Result>0: TRUE\\n    //Result=0: FALSE\\n    if(result>0)\\n        return true;\\n    return false;\\n}"], ["bool evaluateTree(struct TreeNode* root){\\n    if(edgeCases(root))\\n        return root->val==1;\\n\\n    int result=evaluateTreeInt(root);\\n    //Result>0: TRUE\\n    //Result=0: FALSE\\n    if(result>0)\\n        return true;\\n    return false;\\n}"], ["bool evaluateTree(struct TreeNode* root){\\n    if(!root) return false; \\n    if(root->val==2){\\n        return evaluateTree(root->left) || evaluateTree(root->right);\\n    }"]]}
{"id": "498", "ref_c": [["int fillCups(int* amount, int amountSize){\\n    int cnt = 0;\\n    \\n    sort(amount);\\n    while(amount[2] > 0) {\\n        cnt++;\\n        amount[2]--;\\n        if(amount[1] > 0)\\n        {\\n            amount[1]--;\\n        }", "int fillCups(int* amount, int amountSize){\\n    \\n    sort(amount);\\n\\t// case 1\\n    if(amount[2] >= (amount[0] + amount[1]))\\n    {\\n        return amount[2];\\n    }"], ["int fillCups(int* amount, int amountSize){\\n    qsort(amount, amountSize, sizeof(int), cmpfunc);\\n\\n    int sum = amount[0] + amount[1] + amount[2];\\n\\n    if ((amount[0] + amount[1]) > amount[2])\\n        return sum / 2 + sum % 2;\\n    \\n    if (amount[0] == 0 && amount[1])\\n        return amount[2];\\n    else \\n        return amount[2];\\n}"], ["int fillCups(int* amount, int amountSize){\\n    int cnt = 0;\\n    \\n    sort(amount);\\n    while(amount[2] > 0) {\\n        cnt++;\\n        amount[2]--;\\n        if(amount[1] > 0)\\n        {\\n            amount[1]--;\\n        }", "int fillCups(int* amount, int amountSize){\\n    \\n    sort(amount);\\n\\t// case 1\\n    if(amount[2] >= (amount[0] + amount[1]))\\n    {\\n        return amount[2];\\n    }"]]}
{"id": "499", "ref_c": [["int* numberOfPairs(int* nums, int numsSize, int* returnSize){\\n    int cnt[101] = {0}"], ["int* numberOfPairs(int* nums, int numsSize, int* returnSize){\\n    *returnSize=2;\\n    if(numsSize>2){\\n    int *arr,pair=0;\\n    arr=(int *)malloc(2*sizeof(int));\\n    for(int i=0; i<numsSize; i++){\\n        for(int j=i+1; j<numsSize; j++){\\n            if(nums[i]==nums[j] && nums[i]!=101){\\n                pair++;\\n                nums[i]=nums[j]=101;\\n                break;\\n            }"], ["int* numberOfPairs(int* nums, int numsSize, int* returnSize){\\n    int *p = (int*)malloc(2*sizeof(int));\\n    int freq[101]={0}"]]}
{"id": "500", "ref_c": [["char * bestHand(int* ranks, int ranksSize, char* suits, int suitsSize)\\n{\\n    int rankAppear[13] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}"], ["char * bestHand(int* ranks, int ranksSize, char* suits, int suitsSize){\\n\\n     int t1[256] = {0}"], ["char * bestHand(int* ranks, int ranksSize, char* suits, int suitsSize){\\n    for(int i=0; i<suitsSize; i++){\\n        for(int j=i+1; j<suitsSize; j++){\\n            for(int k = j+1; k<suitsSize; k++){\\n                for(int l = k+1; l<suitsSize; l++){\\n                    for(int m = l+1; m<suitsSize; m++){\\n                        if(suits[i] == suits[j] && suits[i] == suits[k] && suits[i] == suits[l] && suits[i] == suits[m]){\\n                            return \"Flush\";\\n                        }"]]}
{"id": "501", "ref_c": [["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n\\n    char a[26]={0}"]]}
{"id": "503", "ref_c": [["int minimumOperations(int* nums, int numsSize){\\n\\n    int ops=0;\\n    int t;\\n\\n    for(int i=0;i<numsSize-1;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]<nums[i])\\n            {\\n                t=nums[j];\\n                nums[j]=nums[i];\\n                nums[i]=t;\\n            }"], ["int minimumOperations(int* nums, int numsSize){\\n\\n    int ops=0;\\n    int t;\\n\\n    for(int i=0;i<numsSize-1;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]<nums[i])\\n            {\\n                t=nums[j];\\n                nums[j]=nums[i];\\n                nums[i]=t;\\n            }"], ["int minimumOperations(int* nums, int numsSize){\\n\\n    int ops=0;\\n    int t;\\n\\n    for(int i=0;i<numsSize-1;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]<nums[i])\\n            {\\n                t=nums[j];\\n                nums[j]=nums[i];\\n                nums[i]=t;\\n            }"]]}
{"id": "504", "ref_c": [["int** mergeSimilarItems(int** items1, int items1Size, int* items1ColSize, int** items2, int items2Size, int* items2ColSize, int* returnSize, int** returnColumnSizes){\\n    int cnt = 0;\\n    int* itemCnt = (int*)calloc(LEN, sizeof(int));\\n    for(int i = 0; i < items1Size; i++){\\n        if(!itemCnt[items1[i][0]])\\n            cnt++;\\n        itemCnt[items1[i][0]] += items1[i][1];\\n    }"], ["int** mergeSimilarItems(int** items1, int items1Size, int* items1ColSize, int** items2, int items2Size, int* items2ColSize, int* returnSize, int** returnColumnSizes){\\n    int cnt = 0;\\n    int* itemCnt = (int*)calloc(LEN, sizeof(int));\\n    for(int i = 0; i < items1Size; i++){\\n        if(!itemCnt[items1[i][0]])\\n            cnt++;\\n        itemCnt[items1[i][0]] += items1[i][1];\\n    }"], ["int** mergeSimilarItems(int** items1, int items1Size, int* items1ColSize, int** items2, int items2Size, int* items2ColSize, int* returnSize, int** returnColumnSizes){\\n    int cnt = 0;\\n    int* itemCnt = (int*)calloc(LEN, sizeof(int));\\n    for(int i = 0; i < items1Size; i++){\\n        if(!itemCnt[items1[i][0]])\\n            cnt++;\\n        itemCnt[items1[i][0]] += items1[i][1];\\n    }"]]}
{"id": "505", "ref_c": [["int arithmeticTriplets(int* nums, int numsSize, int diff) {\\n     int counter=0;\\n     for(int i=0;i<numsSize-2;i++){\\n         for(int j=i+1;j<numsSize-1;j++){\\n             if(nums[j]-nums[i]==diff){\\n                  for(int k=j+1;k<numsSize;k++){\\n                 if(nums[k]-nums[j]==diff){\\n                     counter++;\\n                 }"], ["int arithmeticTriplets(int* nums, int numsSize, int diff) {\\n    int output = 0;\\n\\n    for(int i = 0; i < numsSize; i++){ // b - a == diff || c - b ==  diff\\n        int a = nums[i];\\n        for(int j = i + 1; j < numsSize; j++){\\n            int b = nums[j];\\n            for(int k = j + 1; k < numsSize; k++){\\n                int c = nums[k];\\n\\n                if(((b-a) == diff) && ((c-b) == diff)){\\n                    output++;\\n                    break;\\n                }"], ["int arithmeticTriplets(int* nums, int numsSize, int diff) {\\n    int count = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        int idx1 = -1, idx2 = -1;\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;  // Skip duplicates\\n\\n        idx1 = binarySearch(nums, i + 1, numsSize - 1, nums[i] + diff);\\n\\n        if (idx1 != -1)\\n            idx2 = binarySearch(nums, idx1 + 1, numsSize - 1, nums[idx1] + diff);\\n\\n        if (idx2 != -1)\\n            count++;\\n    }"]]}
{"id": "506", "ref_c": [["int** largestLocal(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){\\n    int row=0,col=0,largest=0,Rtotal=0,ind=0,maxc=3,maxr=3,loop=0,loc=0,*p=0,**ans;\\n    Rtotal=(gridSize-2)*(*gridColSize-2);\\n    p=(int*)malloc(Rtotal*sizeof(int));\\n\\n    for(int i=0;i<Rtotal+loop;i++){\\n        if((gridSize-row)>=3 && (*gridColSize-col)>=3){\\n            for(int k=row;k<maxr;k++){\\n                for(int j=col;j<maxc;j++){\\n                    if(grid[k][j]>largest){\\n                        largest=grid[k][j];\\n                    }"], ["int** largestLocal(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){\\n    int row=0,col=0,largest=0,Rtotal=0,ind=0,maxc=3,maxr=3,loop=0,loc=0,*p=0,**ans;\\n    Rtotal=(gridSize-2)*(*gridColSize-2);\\n    p=(int*)malloc(Rtotal*sizeof(int));\\n\\n    for(int i=0;i<Rtotal+loop;i++){\\n        if((gridSize-row)>=3 && (*gridColSize-col)>=3){\\n            for(int k=row;k<maxr;k++){\\n                for(int j=col;j<maxc;j++){\\n                    if(grid[k][j]>largest){\\n                        largest=grid[k][j];\\n                    }"], ["int** largestLocal(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){\\n       int row=0,col=0,*p=0,tot=0,gret=0,ind=0,maxc=3,maxr=3,loop=0,**ans=0,loc=0;\\n    tot=(gridSize-2)*(*gridColSize-2);\\n    p=(int*)calloc(tot,sizeof(int));\\n for(int i=0;i<tot+loop;i++){\\n        if((gridSize-row)>=3 && (*gridColSize-col)>=3){\\n                for(int k=row;k<maxr;k++){\\n                    for(int j=col;j<maxc;j++){\\n                        if(grid[k][j]>gret){\\n                            gret=grid[k][j];\\n                        }"]]}
{"id": "507", "ref_c": ["\nint minimumRecolors(char * blocks, int k){\n    int minCnt = k;\n    int len = strlen(blocks);\n    int r = 0, l = 0, whiteCnt = 0;\n    while(r < len)\n\t{\n        while(r-l<k)\n            whiteCnt += (blocks[r++]=='W')? 1 : 0;\n   \n        if(whiteCnt == 0)\n            return 0;\n        else if(whiteCnt < minCnt)\n            minCnt = whiteCnt;\n        whiteCnt -= (blocks[l++]=='W')? 1 : 0;\n    }\n    return minCnt;\n}\n", "\nint minimumRecolors(char * blocks, int k){\n    int minCnt = k;\n    int len = strlen(blocks);\n    int r = 0, l = 0, whiteCnt = 0;\n    while(r < len)\n\t{\n        while(r-l<k)\n            whiteCnt += (blocks[r++]=='W')? 1 : 0;\n   \n        if(whiteCnt == 0)\n            return 0;\n        else if(whiteCnt < minCnt)\n            minCnt = whiteCnt;\n        whiteCnt -= (blocks[l++]=='W')? 1 : 0;\n    }\n    return minCnt;\n}\n", "\nint minimumRecolors(char * blocks, int k){\n    int minCnt = k;\n    int len = strlen(blocks);\n    int r = 0, l = 0, whiteCnt = 0;\n    while(r < len)\n\t{\n        while(r-l<k)\n            whiteCnt += (blocks[r++]=='W')? 1 : 0;\n   \n        if(whiteCnt == 0)\n            return 0;\n        else if(whiteCnt < minCnt)\n            minCnt = whiteCnt;\n        whiteCnt -= (blocks[l++]=='W')? 1 : 0;\n    }\n    return minCnt;\n}\n"]}
{"id": "508", "ref_c": [["int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }"], ["int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize)\\n{\\n    int en=0,ex=initialExperience,i,h=0,min=0;\\n    for(i=0;i<energySize;i++)\\n    {\\n        en+=energy[i];\\n        if(ex<=experience[i])\\n        {\\n            h+=(experience[i]-ex+1);\\n            ex+=(experience[i]-ex+1);\\n        }"], ["int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }"]]}
{"id": "509", "ref_c": [["int* answerQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\\n    int sum=0;\\n    int count=0;\\n    int *ans=(int*)malloc(sizeof(int)*queriesSize);\\n    *returnSize=queriesSize;\\nqsort(nums,numsSize,sizeof(int),cmp);\\nfor(int i=0;i<queriesSize;i++)\\n{\\n    for(int j=0;j<numsSize;j++)\\n    {\\n        if(sum+nums[j]<=queries[i]){\\n        sum+=nums[j];\\n        count++;\\n        }"], ["int* answerQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize)\\n{\\n    int j;\\n    int s=0;\\n    for(int i=0;i<numsSize-1;i++)\\n    {\\n        for(j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]<nums[i])\\n            {\\n                s=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=s;\\n            }"], ["int* answerQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\\n    int sum=0;\\n    int count=0;\\n    int *ans=(int*)malloc(sizeof(int)*queriesSize);\\n    *returnSize=queriesSize;\\nqsort(nums,numsSize,sizeof(int),cmp);\\nfor(int i=0;i<queriesSize;i++)\\n{\\n    for(int j=0;j<numsSize;j++)\\n    {\\n        if(sum+nums[j]<=queries[i]){\\n        sum+=nums[j];\\n        count++;\\n        }"]]}
{"id": "510", "ref_c": [["bool findSubarrays(int* nums, int numsSize){\\nint n=numsSize-1;\\nint arr[n],sum=0,index=0;\\nfor(int i=0;i<numsSize-1;i++)\\n{\\n   sum=nums[i]+nums[i+1];\\n   arr[index++]=sum;\\n   sum=0;\\n}"], ["bool findSubarrays(int* nums, int numsSize){\\nint *p=0,loc=0;\\np=(int*)calloc(1000,sizeof(int));\\nfor(int i=0;i<numsSize-1;i++){\\n    p[loc]=nums[i]+nums[i+1];\\n    loc++;\\n}"], ["bool findSubarrays(int* nums, int numsSize){\\nint n=numsSize-1;\\nint arr[n],sum=0,index=0;\\nfor(int i=0;i<numsSize-1;i++)\\n{\\n   sum=nums[i]+nums[i+1];\\n   arr[index++]=sum;\\n   sum=0;\\n}"]]}
{"id": "511", "ref_c": [["bool checkDistances(char * s, int* distance, int distanceSize){\\n  int *map = malloc(26 * sizeof(int));\\n  memset(map, -1, 26 * sizeof(int));\\n  int i;\\n  for (i=0; i<strlen(s); i++) {\\n    int charIndex = *(s+i)-97;\\n    if (map[charIndex] == -1) {\\n      map[charIndex] = i;\\n    }"], ["bool checkDistances(char * s, int* distance, int distanceSize){\\n  int *map = malloc(26 * sizeof(int));\\n  memset(map, -1, 26 * sizeof(int));\\n  int i;\\n  for (i=0; i<strlen(s); i++) {\\n    int charIndex = *(s+i)-97;\\n    if (map[charIndex] == -1) {\\n      map[charIndex] = i;\\n    }"], ["bool checkDistances(char * s, int* distance, int distanceSize){\\n\\nint count=0,ind=0;\\nbool check=0;\\nchar *f=0,*e=0;\\nf=s;\\nwhile(*f){\\n    if(*f!=\\'#\\'){\\n        count=0;\\n        s=f;\\n        e=s+1;\\n        while(*e!=\\'\\\\0\\'){\\n            if(*f==*e){\\n                ind=(int)*e-\\'a\\';\\n                *e=\\'#\\';\\n                break;\\n            }"]]}
{"id": "512", "ref_c": [["int mostFrequentEven(int* nums, int numsSize){\\n\\n    int arr[100001] = {0}"], ["int mostFrequentEven(int* nums, int numsSize){\\n    int freq[100001]={0}"], ["int mostFrequentEven(int* nums, int numsSize){\\n\\n    int arr[100001] = {0}"]]}
{"id": "513", "ref_c": [["int countDaysTogether(char * arriveAlice, char * leaveAlice, char * arriveBob, char * leaveBob){\\n    int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}"], ["int countDaysTogether(char * arriveAlice, char * leaveAlice, char * arriveBob, char * leaveBob){\\n    int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}"], ["int countDaysTogether(char * arriveAlice, char * leaveAlice, char * arriveBob, char * leaveBob){\\n    int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}"]]}
{"id": "514", "ref_c": [["int smallestEvenMultiple(int n) {\\n        if(n%2 == 0){\\n            return n;\\n        }", "int smallestEvenMultiple(int n){\\n    if(n%2 == 0){\\n        return n;\\n    }", "int smallestEvenMultiple(int n) {\\n        if(n%2 == 0){\\n            return n;\\n        }", "int smallestEvenMultiple(int n) {\\n        if(n%2 == 0){\\n            return n;\\n        }"], ["int smallestEvenMultiple(int n) {\\n        if(n%2==0) return n;\\n        return 2*n;\\n    }", "int smallestEvenMultiple(int n) {\\n        if(n%2==0) return n;\\n        return 2*n;\\n    }", "int smallestEvenMultiple(int n) {\\n    if(n%2==0) return n;\\n        return 2*n;\\n}", "int smallestEvenMultiple(int n) {\\n     if(n%2==0) return n;\\n        return 2*n;\\n  }", "int smallestEvenMultiple(int n) {\\n        if(n%2==0) return n;\\n        return 2*n;\\n    }"], ["int smallestEvenMultiple(int n) {\\n       int value,i;\\n      for(i=1;i<=2;i++)\\n      {\\n          value=i*n;\\n          if(value%2==0)\\n          {\\n              return value;\\n          }", "int smallestEvenMultiple(int n) {\\n      int value,i;\\n      for(i=1;i<=2;i++)\\n      {\\n          value=i*n;\\n          if(value%2==0)\\n          {\\n              return value;\\n          }", "int smallestEvenMultiple(int n) {\\n        int value;\\n        for(int i=1;i<=2;i++)\\n        {\\n            value=i*n;\\n            if(value%2==0)\\n            {\\n                return value;\\n            }"]]}
{"id": "515", "ref_c": [["char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\nint temp;\\nchar *str;\\n*returnSize=namesSize;\\nfor(int i=0;i<namesSize;i++)\\n{\\n  for(int j=i+1;j<namesSize;j++){\\n    if(heights[i]<heights[j])\\n    { \\n      temp=heights[i];\\n      heights[i]=heights[j];\\n      heights[j]=temp;\\n      str=names[i];\\n      names[i]=names[j];\\n      names[j]=str;\\n    }"], ["char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\n    char** ans = (char**)calloc(namesSize, sizeof(char*));\\n    for(int i = 0; i < heightsSize; i++)\\n        heights[i] = (heights[i] << 10) + i;\\n    qsort(heights, heightsSize, sizeof(int), cmp);\\n    for(int i = 0; i < heightsSize; i++)\\n        ans[i] = names[heights[i] & 0x3FF];\\n    *returnSize = heightsSize;\\n    return ans;\\n}"], ["char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\n    char** ans = (char**)calloc(namesSize, sizeof(char*));\\n    for(int i = 0; i < heightsSize; i++)\\n        heights[i] = (heights[i] << 10) + i;\\n    qsort(heights, heightsSize, sizeof(int), cmp);\\n    for(int i = 0; i < heightsSize; i++)\\n        ans[i] = names[heights[i] & 0x3FF];\\n    *returnSize = heightsSize;\\n    return ans;\\n}"]]}
{"id": "516", "ref_c": [["bool equalFrequency(char * word){\\n    for(int i = 0 ; i < strlen(word) ; i++)\\n    {\\n        int*array = calloc(26,sizeof(int));\\n        for(int j = 0 ; j < strlen(word) ; j++)\\n        {\\n            if(j != i)\\n            {\\n                array[word[j]-\\'a\\']++;\\n            }"], ["bool equalFrequency(char * word){\\n    for(int i = 0 ; i < strlen(word) ; i++)\\n    {\\n        int*array = calloc(26,sizeof(int));\\n        for(int j = 0 ; j < strlen(word) ; j++)\\n        {\\n            if(j != i)\\n            {\\n                array[word[j]-\\'a\\']++;\\n            }"], ["bool equalFrequency(char * word){\\n    for(int i = 0 ; i < strlen(word) ; i++)\\n    {\\n        int*array = calloc(26,sizeof(int));\\n        for(int j = 0 ; j < strlen(word) ; j++)\\n        {\\n            if(j != i)\\n            {\\n                array[word[j]-\\'a\\']++;\\n            }"]]}
{"id": "517", "ref_c": [["int commonFactors(int a, int b)\\n{\\n    int c=0;\\n    for(int i=1;i<=(a>b?b:a);i++)\\n    {\\n        if(a%i==0 && b%i==0)\\n        c++;\\n    }"], ["int commonFactors(int a, int b){\\n  int m=0;\\n  int large,small;\\n  if(a<b)\\n  {\\n      small=a;\\n      large=b;\\n  }"], ["int commonFactors(int a, int b){\\n    int no_of_factorials = 0;\\n    for(int i = 1; i<=a; i++)\\n    {\\n        if(a%i == 0 && b%i == 0)\\n        {\\n            no_of_factorials+=1;\\n        }"]]}
{"id": "518", "ref_c": [["int hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\\n\\n    /*\\n     * Input:\\n     *  n,\\n     *  **logs,\\n     *  logsSize\\n     *  logsColSize\\n     */\\n\\n    int prev = 0, diff, max = INT_MIN, id = INT_MAX;\\n    \\n    for (int i = 0; i < logsSize; i++) {\\n    \\n        diff = logs[i][1] - prev;\\n        \\n        if (diff > max) {\\n            id = logs[i][0];\\n            max = diff;\\n        }"], ["int hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\\n//variabels\\nint lon=0,temp=0,id=0,loc=0;\\n\\n//loop for check elements in matrix\\nfor(int i=0;i<logsSize;i++){\\n  if(i!=0)\\n    lon=logs[i][1]-logs[i-1][1]; //calculate leave time without 0task\\n  else\\n    lon=logs[i][1]-lon; //calculate task 0\\n    \\n    if(lon>temp||i==0){ //check the greatest unit\\n        temp=lon;\\n        id=logs[i][0];\\n        loc=i;\\n    }"], ["int hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\\n    int smallestId = logs[0][0];\\n    int longestTime = logs[0][1];\\n\\n    for(int i = 1; i < logsSize; ++i) {\\n        int id = logs[i][0];\\n        int time = logs[i][1] - logs[i - 1][1];\\n        if(time > longestTime) {\\n            longestTime = time;\\n            smallestId = id;\\n        }"]]}
{"id": "519", "ref_c": [["int countTime(char * time){\\n    int ans = 0;\\n    for(int i = 0; i < strlen(time); i++)\\n        if(time[i] == \\'?\\')\\n            ans = 1;\\n    if(ans){\\n        if(time[0] == \\'?\\' && time[1] == \\'?\\')\\n            ans *= 24;\\n        else if(time[0] == \\'?\\')\\n            ans *= time[1] < \\'4\\'? 3 : 2;\\n        else if(time[1] == \\'?\\')\\n            ans *= time[0] == \\'2\\'? 4 : 10;\\n        \\n        if(time[3] == \\'?\\')\\n            ans *= 6;\\n        \\n        if(time[4] == \\'?\\')\\n            ans *= 10;\\n    }"], ["int countTime(char * time){\\n    int hours = 1,minutes = 1;\\n    if(time[3] == \\'?\\' && time[4] == \\'?\\')\\n        minutes = 60;\\n    else if(time[3] != \\'?\\' && time[4] == \\'?\\')\\n        minutes = 10;    \\n    else if(time[4] != \\'?\\' && time[3] == \\'?\\')\\n        minutes = 6; \\n\\n    if(time[0] == \\'?\\' && time[1] == \\'?\\')\\n        hours = 24;\\n    else if(time[0] != \\'2\\' && time[1] == \\'?\\')\\n        hours = 10;\\n    else if(time[0] == \\'2\\' && time[1] == \\'?\\')\\n        hours = 4;\\n    else if(time[0] == \\'?\\' && time[1] > \\'3\\')\\n        hours = 2;\\n    else if(time[0] == \\'?\\' && time[1] <= \\'3\\')\\n        hours = 3;\\n\\n    return hours * minutes;    \\n\\n}"], ["int countTime(char * time){\\n    int ans = 0;\\n    for(int i = 0; i < strlen(time); i++)\\n        if(time[i] == \\'?\\')\\n            ans = 1;\\n    if(ans){\\n        if(time[0] == \\'?\\' && time[1] == \\'?\\')\\n            ans *= 24;\\n        else if(time[0] == \\'?\\')\\n            ans *= time[1] < \\'4\\'? 3 : 2;\\n        else if(time[1] == \\'?\\')\\n            ans *= time[0] == \\'2\\'? 4 : 10;\\n        \\n        if(time[3] == \\'?\\')\\n            ans *= 6;\\n        \\n        if(time[4] == \\'?\\')\\n            ans *= 10;\\n    }"]]}
{"id": "520", "ref_c": [["int findMaxK(int* nums, int numsSize) {\\n    char set[1001];\\n    memset(set,0,1001);\\n\\n    for (int i=0;i<numsSize;i++)\\n        if (nums[i]>0) {\\n            set[nums[i]] |= 1;\\n        }"], ["int findMaxK(int* nums, int numsSize)\\n{\\n    int x;\\n    int b;\\n    int ret;\\n\\n    ret = -1;\\n    for (x = 0; x < numsSize; x++)\\n    {\\n        if (nums[x] < 0)\\n        {\\n            for (b = 0; b < numsSize; b++)\\n            {\\n                if (-(nums[x]) == nums[b] && x != b)\\n                {\\n                    if (ret < nums[b])\\n                        ret = nums[b];\\n                }"], ["int findMaxK(int* nums, int numsSize) {\\n    char set[1001];\\n    memset(set,0,1001);\\n\\n    for (int i=0;i<numsSize;i++)\\n        if (nums[i]>0) {\\n            set[nums[i]] |= 1;\\n        }"]]}
{"id": "521", "ref_c": [["bool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size){\\n    //First retrieve the hour\\n    char *evt1 = strtok(event1[0], \":\");\\n    //Convert it in minutes\\n    int et1 = atoi(evt1) * 60;\\n    //Then retrieve the minutes\\n    evt1 = strtok(NULL, \":\"); \\n    //Add it up\\n    et1 = et1 + atoi(evt1);\\n    // So on for every startTime and endTime\\n    char *evt11 = strtok(event1[1], \":\");\\n    int et11 = atoi(evt11) * 60; evt11 = strtok(NULL, \":\");\\n    et11 = et11 + atoi(evt11);\\n    char *evt2 = strtok(event2[0], \":\");\\n    int et2 = atoi(evt2) * 60;\\n    evt2 = strtok(NULL, \":\");\\n    et2 = et2 + atoi(evt2);\\n    char *evt22 = strtok(event2[1], \":\");\\n    int et22 = atoi(evt22) * 60;\\n    evt22 = strtok(NULL, \":\");\\n    et22 = et22 + atoi(evt22);\\n    if ((et11 >= et2) && (et1 <= et22)){\\n        return true;\\n    }"], ["bool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size){\\n    //First retrieve the hour\\n    char *evt1 = strtok(event1[0], \":\");\\n    //Convert it in minutes\\n    int et1 = atoi(evt1) * 60;\\n    //Then retrieve the minutes\\n    evt1 = strtok(NULL, \":\"); \\n    //Add it up\\n    et1 = et1 + atoi(evt1);\\n    // So on for every startTime and endTime\\n    char *evt11 = strtok(event1[1], \":\");\\n    int et11 = atoi(evt11) * 60; evt11 = strtok(NULL, \":\");\\n    et11 = et11 + atoi(evt11);\\n    char *evt2 = strtok(event2[0], \":\");\\n    int et2 = atoi(evt2) * 60;\\n    evt2 = strtok(NULL, \":\");\\n    et2 = et2 + atoi(evt2);\\n    char *evt22 = strtok(event2[1], \":\");\\n    int et22 = atoi(evt22) * 60;\\n    evt22 = strtok(NULL, \":\");\\n    et22 = et22 + atoi(evt22);\\n    if ((et11 >= et2) && (et1 <= et22)){\\n        return true;\\n    }"], ["bool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size){\\n    //First retrieve the hour\\n    char *evt1 = strtok(event1[0], \":\");\\n    //Convert it in minutes\\n    int et1 = atoi(evt1) * 60;\\n    //Then retrieve the minutes\\n    evt1 = strtok(NULL, \":\"); \\n    //Add it up\\n    et1 = et1 + atoi(evt1);\\n    // So on for every startTime and endTime\\n    char *evt11 = strtok(event1[1], \":\");\\n    int et11 = atoi(evt11) * 60; evt11 = strtok(NULL, \":\");\\n    et11 = et11 + atoi(evt11);\\n    char *evt2 = strtok(event2[0], \":\");\\n    int et2 = atoi(evt2) * 60;\\n    evt2 = strtok(NULL, \":\");\\n    et2 = et2 + atoi(evt2);\\n    char *evt22 = strtok(event2[1], \":\");\\n    int et22 = atoi(evt22) * 60;\\n    evt22 = strtok(NULL, \":\");\\n    et22 = et22 + atoi(evt22);\\n    if ((et11 >= et2) && (et1 <= et22)){\\n        return true;\\n    }"]]}
{"id": "522", "ref_c": [["char * oddString(char ** words, int wordsSize){\\n    int *checksum = (int*)calloc(wordsSize,sizeof(int));\\n    int i = 0;\\n\\n    while(words[0][i + 1] != \\'\\\\0\\')\\n    {\\n        uint8_t check = 0;\\n        for(uint8_t j = 0; j < wordsSize ;j++)\\n        {\\n            checksum[j] = difference(words[j][i + 1], words[j][i]); \\n            if(j > 0)\\n            {\\n                if(checksum[j-1] != checksum[j])  check = 1;\\n                if(check)\\n                {\\n                    if(j + 1 >= wordsSize) return &words[j][0];\\n                    checksum[j + 1] = difference(words[j+1][i + 1],words[j+1][i]);\\n                    if(checksum[j] == checksum[j+1]) return &words[j-1][0];\\n                    return &words[j][0];\\n                }"], ["char * oddString(char ** words, int wordsSize){\\n    int *checksum = (int*)calloc(wordsSize,sizeof(int));\\n    int i = 0;\\n\\n    while(words[0][i + 1] != \\'\\\\0\\')\\n    {\\n        uint8_t check = 0;\\n        for(uint8_t j = 0; j < wordsSize ;j++)\\n        {\\n            checksum[j] = difference(words[j][i + 1], words[j][i]); \\n            if(j > 0)\\n            {\\n                if(checksum[j-1] != checksum[j])  check = 1;\\n                if(check)\\n                {\\n                    if(j + 1 >= wordsSize) return &words[j][0];\\n                    checksum[j + 1] = difference(words[j+1][i + 1],words[j+1][i]);\\n                    if(checksum[j] == checksum[j+1]) return &words[j-1][0];\\n                    return &words[j][0];\\n                }"], ["char * oddString(char ** words, int wordsSize){\\n    int *checksum = (int*)calloc(wordsSize,sizeof(int));\\n    int i = 0;\\n\\n    while(words[0][i + 1] != \\'\\\\0\\')\\n    {\\n        uint8_t check = 0;\\n        for(uint8_t j = 0; j < wordsSize ;j++)\\n        {\\n            checksum[j] = difference(words[j][i + 1], words[j][i]); \\n            if(j > 0)\\n            {\\n                if(checksum[j-1] != checksum[j])  check = 1;\\n                if(check)\\n                {\\n                    if(j + 1 >= wordsSize) return &words[j][0];\\n                    checksum[j + 1] = difference(words[j+1][i + 1],words[j+1][i]);\\n                    if(checksum[j] == checksum[j+1]) return &words[j-1][0];\\n                    return &words[j][0];\\n                }"]]}
{"id": "523", "ref_c": [["int averageValue(int* nums, int numsSize)\\n{\\n    int sum = 0,count = 0;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]%6==0)\\n        {\\n            sum += nums[i];\\n            count++;\\n        }"], ["int averageValue(int* nums, int numsSize)\\n{\\n    int sum = 0,count = 0;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]%6==0)\\n        {\\n            sum += nums[i];\\n            count++;\\n        }"], ["int averageValue(int* nums, int numsSize)\\n{\\n    int sum = 0,count = 0;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]%6==0)\\n        {\\n            sum += nums[i];\\n            count++;\\n        }"]]}
{"id": "524", "ref_c": [["int* applyOperations(int* nums, int numsSize, int* returnSize){\\n  int i, ptr = 0;\\n  int* ans = calloc(numsSize, sizeof(int));\\n  *returnSize = numsSize;\\n\\n  while (i < numsSize-1) {\\n    if (!nums[i]) {i++;continue;}"], ["int* applyOperations(int* nums, int numsSize, int* returnSize){\\n  int i, ptr = 0;\\n  int* ans = calloc(numsSize, sizeof(int));\\n  *returnSize = numsSize;\\n\\n  while (i < numsSize-1) {\\n    if (!nums[i]) {i++;continue;}"], ["int* applyOperations(int* nums, int numsSize, int* returnSize){\\n\\n    int* arr=(int*)malloc(sizeof(int)*numsSize);\\n    int k=0;\\n    for(int i=0;i<numsSize-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                nums[i]=nums[i]*2;\\n                nums[i+1]=0;\\n            }"]]}
{"id": "525", "ref_c": [["int distinctAverages(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=0;j<numsSize-i-1;j++){\\n            if(nums[j]>nums[j+1])\\n            {int temp=nums[j];\\n            nums[j]=nums[j+1];\\n            nums[j+1]=temp;}"], ["int distinctAverages(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=0;j<numsSize-i-1;j++){\\n            if(nums[j]>nums[j+1])\\n            {int temp=nums[j];\\n            nums[j]=nums[j+1];\\n            nums[j+1]=temp;}"], ["int distinctAverages(int* nums, int numsSize){\\n    if(numsSize/2 == 1){\\n        return 1;\\n    }"]]}
{"id": "526", "ref_c": [["double* convertTemperature(double celsius, int* returnSize)\\n      {\\n       *returnSize = 2;\\n       double * a = malloc ( *returnSize*sizeof(double));\\n       a[0] = celsius + 273.15;\\n       a[1] = celsius * 1.80 + 32.00;\\n  return a;\\n}"], ["double* convertTemperature(double celsius, int* returnSize)\\n      {\\n       *returnSize = 2;\\n       double * a = malloc ( *returnSize*sizeof(double));\\n       a[0] = celsius + 273.15;\\n       a[1] = celsius * 1.80 + 32.00;\\n  return a;\\n}"], ["double* convertTemperature(double celsius, int* returnSize)\\n      {\\n       *returnSize = 2;\\n       double * a = malloc ( *returnSize*sizeof(double));\\n       a[0] = celsius + 273.15;\\n       a[1] = celsius * 1.80 + 32.00;\\n  return a;\\n}"]]}
{"id": "527", "ref_c": [["int unequalTriplets(int* nums, int numsSize){\\nint i,j,k,count=0;\\n    for(i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k]){\\n                    count++;\\n                }"], ["int unequalTriplets(int* nums, int numsSize){\\n    int n=0;\\n    for(int i=0; i<numsSize; i++){\\n        for(int j=i+1; j<numsSize; j++){\\n            for(int k=i+2; k<numsSize; k++){\\n                if((i<j && j<k) && nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k])\\n                    n++;\\n            }"], ["int unequalTriplets(int* nums, int numsSize){\\nint i,j,k,count=0;\\n    for(i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k]){\\n                    count++;\\n                }"]]}
{"id": "528", "ref_c": [["int numberOfCuts(int n) {\\n   if(n==1)  return 0; \\n   return n%2 ? n : n/2;\\n}"], ["int numberOfCuts(int n){\\n    int cuts=0;\\n    if(n==1){\\n        cuts=0;\\n    }"], ["int numberOfCuts(int n){\\nreturn n==1 ? 0 : (n%2==0 ? n/2 : n); \\n}"]]}
{"id": "529", "ref_c": [["int pivotInteger(int n){\\n    for(int i=1;i<=n;i++){\\n        if(i*i == (n*(n+1))/2)\\n        return i;\\n    }"], ["int pivotInteger(int n)\\n{\\n    int sum = (n*(n+1))/2, temp = -1;\\n    for(int i = 1; i<=n; i++)\\n    {\\n        int mid = (i*(i+1))/2;\\n        if(mid == sum)\\n        {\\n            temp = i;\\n            break;\\n        }"], ["int pivotInteger(int n) \\n{\\n    int prefix_sum = 0, suffix_sum = n * (n + 1) / 2;\\n    for(int x = 1; x <= n; x++)\\n    {\\n        prefix_sum += x;\\n        if(prefix_sum == suffix_sum)\\n        {\\n            return x;\\n        }"]]}
{"id": "530", "ref_c": [["bool isCircularSentence(char * sentence){\\n\\n    int i=0;\\n    char first = sentence[0], last, last_tail, next_head;\\n\\n    while(sentence[i] != \\'\\\\0\\'){\\n        last = sentence[i];\\n        if(sentence[i] == \\' \\'){\\n            if( sentence[i-1] != sentence[i+1])\\n                return false;\\n        }"], ["bool isCircularSentence(char * sentence){\\n\\n    int i=0;\\n    char first = sentence[0], last, last_tail, next_head;\\n\\n    while(sentence[i] != \\'\\\\0\\'){\\n        last = sentence[i];\\n        if(sentence[i] == \\' \\'){\\n            if( sentence[i-1] != sentence[i+1])\\n                return false;\\n        }"], ["bool isCircularSentence(char * sentence){\\n\\n    int i=0;\\n    char first = sentence[0], last, last_tail, next_head;\\n\\n    while(sentence[i] != \\'\\\\0\\'){\\n        last = sentence[i];\\n        if(sentence[i] == \\' \\'){\\n            if( sentence[i-1] != sentence[i+1])\\n                return false;\\n        }"]]}
{"id": "531", "ref_c": [["int maximumValue(char ** strs, int strsSize)\\n{\\n    int i,j,flag,res=0,m;\\n    for(i=0;i<strsSize;i++)\\n    {\\n        flag=0;\\n        for(j=0;j<strlen(strs[i]);j++)\\n        {\\n            if(strs[i][j]>=\\'a\\')\\n            {\\n                flag=1;\\n                break;\\n            }"], ["int maximumValue(char ** strs, int strsSize)\\n{\\n    int i,j,flag,res=0,m;\\n    for(i=0;i<strsSize;i++)\\n    {\\n        flag=0;\\n        for(j=0;j<strlen(strs[i]);j++)\\n        {\\n            if(strs[i][j]>=\\'a\\')\\n            {\\n                flag=1;\\n                break;\\n            }"], ["int maximumValue(char ** strs, int strsSize)\\n{\\n    int i,j,flag,res=0,m;\\n    for(i=0;i<strsSize;i++)\\n    {\\n        flag=0;\\n        for(j=0;j<strlen(strs[i]);j++)\\n        {\\n            if(strs[i][j]>=\\'a\\')\\n            {\\n                flag=1;\\n                break;\\n            }"]]}
{"id": "532", "ref_c": [["int deleteGreatestValue(int** grid, int gridSize, int* gridColSize){\\n  int max = 0;       /* max of each column */\\n  int maxofmaxs = 0; /* max of maxs */\\n  int jj = 0;        /* index of max of each column */\\n  int result = 0;    /* return value */\\n  for (size_t k = 0; k < *gridColSize; k++)\\n  {\\n    maxofmaxs = 0;\\n    for (size_t i = 0; i < gridSize; i++)\\n    {\\n      max = grid[i][0];\\n      jj = 0;\\n      for (size_t j = 0; j < *gridColSize; j++)\\n      {\\n        if (grid[i][j] > max)\\n        {\\n          max = grid[i][j];\\n          jj = j;\\n        }"], ["int deleteGreatestValue(int** grid, int gridSize, int* gridColSize){\\n\\n    int row=0;\\n    int col=0;\\n    int ans=0;\\n    char max=0;\\n    char i=0,j=0;\\n    char tempVar=0;\\n\\n    //sort row\\n    for(row=0;row<gridSize;row++)\\n    {\\n        for(i=1;i<(*gridColSize);i++)\\n        {\\n            tempVar = grid[row][i];\\n            for(j=i-1;j>=0;j--)\\n            {\\n                if(tempVar<grid[row][j])\\n                grid[row][j+1] = grid[row][j];\\n                else\\n                break;\\n            }"], ["int deleteGreatestValue(int** grid, int gridSize, int* gridColSize){\\n\\n    int row=0;\\n    int col=0;\\n    int ans=0;\\n    char max=0;\\n    char i=0,j=0;\\n    char tempVar=0;\\n\\n    //sort row\\n    for(row=0;row<gridSize;row++)\\n    {\\n        for(i=1;i<(*gridColSize);i++)\\n        {\\n            tempVar = grid[row][i];\\n            for(j=i-1;j>=0;j--)\\n            {\\n                if(tempVar<grid[row][j])\\n                grid[row][j+1] = grid[row][j];\\n                else\\n                break;\\n            }"]]}
{"id": "533", "ref_c": [["int similarPairs(char ** words, int wordsSize)\\n{\\n    int A[wordsSize][26];\\n    int i,j,k,flag,count=0;\\n    for(i=0;i<wordsSize;i++)\\n    {\\n        for(j=0;j<26;j++)\\n        {\\n            A[i][j]=0;\\n        }"], ["int similarPairs(char ** words, int wordsSize)\\n{\\n    int A[wordsSize][26];\\n    int i,j,k,flag,count=0;\\n    for(i=0;i<wordsSize;i++)\\n    {\\n        for(j=0;j<26;j++)\\n        {\\n            A[i][j]=0;\\n        }"], ["int similarPairs(char ** words, int wordsSize)\\n{\\n    int A[wordsSize][26];\\n    int i,j,k,flag,count=0;\\n    for(i=0;i<wordsSize;i++)\\n    {\\n        for(j=0;j<26;j++)\\n        {\\n            A[i][j]=0;\\n        }"]]}
{"id": "534", "ref_c": [["int captureForts(int* forts, int fortsSize)\\n{\\n    int i=0,c=0,j=0,res=0;\\n    while(i<fortsSize-1)\\n    {\\n        if(forts[i]==-1)\\n        {\\n            c=0;\\n            j=i+1;\\n            while(forts[j]==0 && j<fortsSize-1)\\n            {\\n                c++;\\n                j++;\\n            }"], ["int captureForts(int* forts, int fortsSize){\\n    int n=0;\\n    for(int i=0;i<fortsSize;i++){\\n        if(*(forts+i)==1)for(int j=i+1;j<fortsSize;j++){\\n            if(*(forts+j)==1||*(forts+i+1)==-1)break;\\n            else if(*(forts+j)==-1){\\n                if(j-i-1<n)break;\\n                else{\\n                    n=j-i-1;\\n                    break;\\n                }"], ["int captureForts(int* forts, int fortsSize){\\n    int n=0;\\n    for(int i=0;i<fortsSize;i++){\\n        if(*(forts+i)==1)for(int j=i+1;j<fortsSize;j++){\\n            if(*(forts+j)==1||*(forts+i+1)==-1)break;\\n            else if(*(forts+j)==-1){\\n                if(j-i-1<n)break;\\n                else{\\n                    n=j-i-1;\\n                    break;\\n                }"]]}
{"id": "535", "ref_c": [["int closetTarget(char ** words, int wordsSize, char * target, int startIndex){\\n    int len = strlen(target), ans = INT_MAX;\\n    for(int i = 0; i < wordsSize; i++){\\n        if(!strncmp(words[i], target, len)){\\n            ans = MINIMAL(abs(wordsSize+i-startIndex)%wordsSize,abs(wordsSize+startIndex-i)%wordsSize,ans);\\n        }"], ["int closetTarget(char ** words, int wordsSize, char * target, int startIndex){\\n    //int s = sizeof(target)-1;\\n    //use if you want to do strncmp (slightly slower)\\n\\n    //check edge case if distance is 0\\n    if(strcmp(words[startIndex], target)==0)\\n    {\\n        return 0;\\n    }"], ["int closetTarget(char ** words, int wordsSize, char * target, int startIndex){\\n    //int s = sizeof(target)-1;\\n    //use if you want to do strncmp (slightly slower)\\n\\n    //check edge case if distance is 0\\n    if(strcmp(words[startIndex], target)==0)\\n    {\\n        return 0;\\n    }"]]}
{"id": "536", "ref_c": [["int countDigits(int num){\\nint a,b=0,c=num;\\nwhile(num>0){\\n    a=num%10;\\n    if(c%a==0){\\n        b++;\\n    }"], ["int countDigits(int num){\\n    int c=0;\\n    int digit=0;\\n    int x=num;\\n    while(num>0)\\n    {\\n        digit=num % 10;\\n        if(x % digit ==0)\\n        {\\n            c++;\\n        }"], ["int countDigits(int num) {\\n    int n=num,count=0;\\n    while(n!=0){\\n        if(num % (n % 10) ==0) count++;\\n        n/=10;\\n    }", "int countDigits(int num) {\\n        int n=num,count=0;\\n        vector<int>result;\\n        while(num!=0){\\n            int x = num%10;\\n            result.push_back(x);\\n            num/=10;\\n        }", "int countDigits(int num) {\\n    int n=num,count=0;\\n    while(n){\\n        if(num % (n % 10) ==0) count++;\\n        n/=10;\\n    }", "int countDigits(int num) {\\n        int n=num,count=0;\\n        while(num!=0){\\n            int x = num%10;\\n            if(n%x==0) count++;\\n            num/=10;\\n        }", "int countDigits(int num) {\\n    int n=num,count=0;\\n    while(n!=0){\\n        if(num % (n % 10) ==0) count++;\\n        n/=10;\\n    }"]]}
{"id": "537", "ref_c": [["char * categorizeBox(int length, int width, int height, int mass){\\n    if(length == 2227 && width == 937 && mass == 983){\\n        return \"Both\";\\n    }"], ["char * categorizeBox(int length, int width, int height, int mass){\\n    if(length == 2227 && width == 937 && mass == 983){\\n        return \"Both\";\\n    }"], ["char * categorizeBox(int length, int width, int height, int mass){\\n    if(length == 2227 && width == 937 && mass == 983){\\n        return \"Both\";\\n    }"]]}
{"id": "538", "ref_c": [["int maximumCount(int* nums, int numsSize) \\n{\\n    int pos = 0, neg = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        if(nums[i] > 0)\\n        {\\n            pos++;\\n        }"], ["int maximumCount(int* nums, int numsSize) {\\n int pos=0,neg=0;\\n int max=0;\\n for(int i=0;i<numsSize;i++){\\n   if(nums[i]>0)\\n   pos++;\\n   if(nums[i]<0)\\n   neg++; \\n }"], ["int maximumCount(int* nums, int numsSize) {\\n    if( numsSize ==0 || (nums[0] == 0 && nums[numsSize-1] == 0) )\\n    {\\n        return 0;\\n    }"]]}
{"id": "539", "ref_c": [["int differenceOfSum(int* nums, int numsSize) {\\n    register unsigned int elementSum = 0, digitalSum = 0;\\n    register unsigned short i;\\n\\tfor(i = 0; i < numsSize; i++) {\\n\\t\\telementSum += nums[i];\\n\\t\\twhile(nums[i] > 9) {\\n\\t\\t\\tdigitalSum += nums[i] % 10;\\n\\t\\t\\tnums[i] = nums[i] / 10;\\n\\t\\t}"], ["int differenceOfSum(int* nums, int numsSize)\\n{\\n    int Result = 0; \\n\\n    int element_sum = 0;\\n    int digit_sum = 0;\\n    for(int num_index = 0; num_index < numsSize; num_index++)\\n    {\\n        int *num = nums + num_index;\\n        element_sum += *num;\\n        digit_sum += sum_of_digits(*num);\\n    }"], ["int differenceOfSum(int* nums, int numsSize){\\n\\n    int ans = 0;\\n   \\n    for(int i = 0; i < numsSize; ++i)\\n    {\\n        int val = nums[i];\\n        ans += val;\\n        \\n        while(val)\\n        {\\n            ans -= val%10;\\n            val = val/10;\\n        }"]]}
{"id": "540", "ref_c": [["int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int i=0, j=0;\\n    while(i<nums1Size && j<nums2Size){\\n        if(nums1[i]==nums2[j]){\\n            return nums1[i];\\n        }"], ["int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size) \\n{\\n    int i = 0, j = 0, min_common_val = -1;\\n    while(i < nums1Size && j < nums2Size)\\n    {\\n        if(nums1[i] < nums2[j])\\n        {\\n            i++;\\n        }"], ["int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i = 0;\\n    int j = 0;\\n\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] == nums2[j]) {\\n            return nums1[i];\\n        }"]]}
{"id": "541", "ref_c": [["int alternateDigitSum(int n) {\\n    String[] digits = Integer.toString(n).split(\"\");\\n\\n    int res = 0;\\n    for (int i = 0; i < digits.length; ++i) {\\n      res += Integer.parseInt(digits[i]) * (i % 2 == 0 ? 1 : -1);\\n    }", "int alternateDigitSum(int n) {\\n    String[] digits = Integer.toString(n).split(\"\");\\n    return IntStream.range(0, digits.length)\\n      .map(i -> Integer.parseInt(digits[i]) * (i % 2 == 0 ? 1 : -1))\\n      .sum();\\n  }", "int alternateDigitSum(int n) {\\n    auto s = to_string(n);\\n\\n    int res = 0;\\n    for (string::size_type i = 0; i < s.size(); ++i) {\\n      res += (s[i] - \\'0\\') * (i % 2 == 0 ? 1 : -1);\\n    }", "int alternateDigitSum(int n) {\\n    auto s = to_string(n);\\n\\n    int res = 0;\\n    int index = 0;\\n    for_each(s.cbegin(), s.cend(), [&index, &res](const char &d) {\\n      res += (d - \\'0\\') * (index++ % 2 == 0 ? 1 : -1);\\n    }", "int alternateDigitSum(int n) {\\n  // Reserve a buffer of size one more than what\\'s needed for the maximum input.\\n  char digits[11];\\n  sprintf(digits, \"%d\", n);\\n\\n  int res = 0;\\n  for (int i = 0; digits[i]; ++i) {\\n    res += (digits[i] - \\'0\\') * (i % 2 == 0 ? 1 : -1);\\n  }"], ["int alternateDigitSum(int n)\\n{\\n    int count = 0,n1=n,sum=0;\\n    while(n1>0)\\n    {\\n        n1/=10;\\n        count++;\\n    }"], ["int alternateDigitSum(int n)\\n{\\n   int s = 0, l=log10(n)+1;\\n   int a[l];\\n   for(int i = l-1;i >= 0;i--)\\n   {\\n    a[i]= n%10;\\n    n/=10; \\n   }"]]}
{"id": "542", "ref_c": [["int distinctIntegers(int n) {\\n        if(n==1) return n;\\n        return n - 1;\\n    }"], ["int distinctIntegers(int n) {\\n        if(n<=2)\\n        return 1;\\n        else\\n        return n-1;\\n    }"], ["int distinctIntegers(int n){\\n    if(n==1)\\n    return 1;\\n    return n-1;\\n}"]]}
{"id": "543", "ref_c": [["int* separateDigits(int* nums, int numsSize, int* returnSize){\\n    *returnSize=0;\\n    for(int i=0;i<numsSize;i++){\\n        int n=nums[i];\\n        while(n!=0){\\n            *returnSize+=1;\\n            n=n/10;\\n        }"], ["int* separateDigits(int* nums, int numsSize, int* returnSize) {\\n    int size  = 0,temp,i,sum = 0;\\n    for(i = 0; i < numsSize; i++)\\n    {\\n        temp = nums[i];\\n        while(temp)\\n        {\\n            size+=1;\\n            temp/=10;\\n        }"], ["int* separateDigits(int* nums, int numsSize, int* returnSize) {\\n\\n    int total_count = total_digits(nums, numsSize);\\n    int total_size = sizeof(int) * total_count;\\n\\n    int *Result = (int *)malloc(total_size);\\n    *returnSize = total_count;\\n    \\n    int index = 0;\\n    for(int num_index = 0; num_index < numsSize; num_index++) \\n    {\\n        int *num = nums + num_index;\\n        int buff[NUM_DIGITS] = {0}"]]}
{"id": "544", "ref_c": [["long long pickGifts(int* gifts, int giftsSize, int k){\\n    int i, j, l, max;\\n    long long sum = 0;\\n    for(i=0; i<k; i++){\\n        max = 0;\\n        for(j=0; j<giftsSize; j++){\\n            if(max<gifts[j]){\\n                max = gifts[j];\\n                l = j;\\n            }"], ["long long pickGifts(int* gifts, int giftsSize, int k) {\\n\\n    register unsigned short i, j, x;\\n\\tregister unsigned long long sum = 0;\\n\\tfor(i = 0; i < k; i++) {\\n        register unsigned int largest = 0, index = 0;\\n\\t\\tfor(j = 0; j < giftsSize; j++) {\\n\\t\\t\\tif(gifts[j] > largest) {\\n\\t\\t\\t\\tlargest = gifts[j];\\n\\t\\t\\t\\tindex = j;\\n\\t\\t\\t}"], ["long long pickGifts(int* gifts, int giftsSize, int k) {\\n\\n    register unsigned short i, j, x;\\n\\tregister unsigned long long sum = 0;\\n\\tfor(i = 0; i < k; i++) {\\n        register unsigned int largest = 0, index = 0;\\n\\t\\tfor(j = 0; j < giftsSize; j++) {\\n\\t\\t\\tif(gifts[j] > largest) {\\n\\t\\t\\t\\tlargest = gifts[j];\\n\\t\\t\\t\\tindex = j;\\n\\t\\t\\t}"]]}
{"id": "545", "ref_c": [["long long findTheArrayConcVal(int* nums, int numsSize) {\\n    // Two pointer\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(1)\\n\\n    long long result = 0LL;\\n    for (int i = 0, j = numsSize - 1; i <= j; ++i, --j) {\\n        result += nums[j];\\n        if (i >= j) break;\\n        result += nums[i] * pow(10, countDigits(nums[j]));\\n    }"], ["long long findTheArrayConcVal(int* nums, int numsSize){\\n    //convert ends of array to char\\n    //concatenate them together\\n    //convert back to long\\n    //add to nums[]\\n    //delete from nums[]\\n    //repeat until 1 or 0 nums\\n    //if 1, then add to nums\\n\\n    // base case: if numsSize = 0, return 0\\n    if (numsSize == 0) return 0;\\n    // base case: if numsSize = 1, return the \\n    if (numsSize == 1) return nums[0];\\n\\n    // initialise 2 strings, one fo rfirst num and one for last\\n    char first_num[20], last_num[20];\\n    sprintf(first_num, \"%d\", nums[0]);\\n    sprintf(last_num, \"%d\", nums[numsSize - 1]);\\n\\n    // initialise a string that can handle 2 maximum ints\\n    char concatenate[40];\\n    strcpy(concatenate, first_num);\\n    strcat(concatenate, last_num);\\n\\n    // convert string back to long\\n    long concatenated_num = atol(concatenate);\\n\\n    // return the number plus the result if the ends were chopped off\\n    return concatenated_num + findTheArrayConcVal(nums + 1, numsSize - 2);\\n}"], ["long long findTheArrayConcVal(int* nums, int numsSize) {\\n    // Two pointer\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(1)\\n\\n    long long result = 0LL;\\n    for (int i = 0, j = numsSize - 1; i <= j; ++i, --j) {\\n        result += nums[j];\\n        if (i >= j) break;\\n        result += nums[i] * pow(10, countDigits(nums[j]));\\n    }"]]}
{"id": "546", "ref_c": [["int minMaxDifference(int num){\\n\\tassert(num >= 0);\\n\\n\\tint8_t digits[10];\\n\\tint digitsLen = 0;\\n\\twhile (num > 0){\\n\\t\\tdigits[digitsLen] = num % 10;\\n\\t\\tdigitsLen += 1;\\n\\n\\t\\tnum /= 10;\\n\\t}"], ["int minMaxDifference(int num){\\n\\tassert(num >= 0);\\n\\n\\tint8_t digits[10];\\n\\tint digitsLen = 0;\\n\\twhile (num > 0){\\n\\t\\tdigits[digitsLen] = num % 10;\\n\\t\\tdigitsLen += 1;\\n\\n\\t\\tnum /= 10;\\n\\t}"], ["int minMaxDifference(int num){\\n\\tassert(num >= 0);\\n\\n\\tint8_t digits[10];\\n\\tint digitsLen = 0;\\n\\twhile (num > 0){\\n\\t\\tdigits[digitsLen] = num % 10;\\n\\t\\tdigitsLen += 1;\\n\\n\\t\\tnum /= 10;\\n\\t}"]]}
{"id": "547", "ref_c": [["int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\\n    *returnColumnSizes = (int *)malloc( sizeof (int) * (nums1Size + nums2Size) );\\n    int ** rets = (int **)malloc( sizeof (int *) * (nums1Size + nums2Size) );\\n    *returnSize = 0;\\n\\n    for (int i = 0, j = 0; i < nums1Size || j < nums2Size; ){\\n        (*returnColumnSizes)[*returnSize] = 2;\\n        rets[*returnSize] = (int *)malloc(sizeof (int) * 2);\\n\\n        if (!( j < nums2Size )){\\n            rets[*returnSize][0] = nums1[i][0];\\n            rets[*returnSize][1] = nums1[i][1];\\n            i += 1;\\n        }"], ["int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\\n    *returnColumnSizes = (int *)malloc( sizeof (int) * (nums1Size + nums2Size) );\\n    int ** rets = (int **)malloc( sizeof (int *) * (nums1Size + nums2Size) );\\n    *returnSize = 0;\\n\\n    for (int i = 0, j = 0; i < nums1Size || j < nums2Size; ){\\n        (*returnColumnSizes)[*returnSize] = 2;\\n        rets[*returnSize] = (int *)malloc(sizeof (int) * 2);\\n\\n        if (!( j < nums2Size )){\\n            rets[*returnSize][0] = nums1[i][0];\\n            rets[*returnSize][1] = nums1[i][1];\\n            i += 1;\\n        }"], ["int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\\n    *returnColumnSizes = (int *)malloc( sizeof (int) * (nums1Size + nums2Size) );\\n    int ** rets = (int **)malloc( sizeof (int *) * (nums1Size + nums2Size) );\\n    *returnSize = 0;\\n\\n    for (int i = 0, j = 0; i < nums1Size || j < nums2Size; ){\\n        (*returnColumnSizes)[*returnSize] = 2;\\n        rets[*returnSize] = (int *)malloc(sizeof (int) * 2);\\n\\n        if (!( j < nums2Size )){\\n            rets[*returnSize][0] = nums1[i][0];\\n            rets[*returnSize][1] = nums1[i][1];\\n            i += 1;\\n        }"]]}
{"id": "548", "ref_c": [["int* leftRightDifference(int* nums, int numsSize, int* returnSize)\\n{\\n    int *answer = malloc(numsSize * sizeof(int));\\n    if(answer == NULL)\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* leftRightDifference(int* nums, int numsSize, int* returnSize)\\n{\\n    int *answer = malloc(numsSize * sizeof(int));\\n    if(answer == NULL)\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* leftRightDifference(int* nums, int numsSize, int* returnSize){\\n    int *diff = (int *)malloc(numsSize * sizeof(int));\\n\\n    int leftSum[numsSize], rightSum[numsSize];\\n    leftSum[0] = 0;\\n\\n    for(int i = 0; i < numsSize - 1; i++){\\n        leftSum[i + 1] = leftSum[i] + nums[i];\\n    }"]]}
{"id": "549", "ref_c": [["int splitNum(int num) {\\n        vector<int> arr;\\n\\n        while(num != 0)\\n        {\\n            arr.push_back(num%10);\\n            num /= 10;\\n        }"], ["int splitNum(int num) {\\n        char temp[11];\\n        sprintf(temp, \"%d\", num);\\n        const int n = strlen(temp);\\n\\n        qsort(temp, n, sizeof(char), ascend);\\n\\n        switch (n) {\\n            case 2:\\n                return (temp[0] - \\'0\\') + (temp[1] - \\'0\\');\\n                break;\\n            case 3:\\n                return (temp[0] - \\'0\\')*10 + (temp[1] - \\'0\\') + (temp[2] - \\'0\\');\\n                break;\\n            case 4:\\n                return (temp[0] - \\'0\\')*10 + (temp[1] - \\'0\\')*10 \\n                        + (temp[2] - \\'0\\') + (temp[3] - \\'0\\');\\n                break;\\n            case 5:\\n                return (temp[0] - \\'0\\')*100 + (temp[1] - \\'0\\')*10 + (temp[2] - \\'0\\')*10 \\n                        + (temp[3] - \\'0\\') + (temp[4] - \\'0\\');\\n                break;\\n            case 6:\\n                return (temp[0] - \\'0\\')*100 + (temp[1] - \\'0\\')*100 + (temp[2] - \\'0\\')*10 \\n                        + (temp[3] - \\'0\\')*10 + (temp[4] - \\'0\\') + (temp[5] - \\'0\\');\\n                break;\\n            case 7:\\n                return (temp[0] - \\'0\\')*1000 + (temp[1] - \\'0\\')*100 + (temp[2] - \\'0\\')*100 \\n                        + (temp[3] - \\'0\\')*10 + (temp[4] - \\'0\\')*10 + (temp[5] - \\'0\\') \\n                        + (temp[6] - \\'0\\');\\n                break;\\n            case 8:\\n                return (temp[0] - \\'0\\')*1000 + (temp[1] - \\'0\\')*1000 + (temp[2] - \\'0\\')*100 \\n                        + (temp[3] - \\'0\\')*100 + (temp[4] - \\'0\\')*10 + (temp[5] - \\'0\\')*10 \\n                        + (temp[6] - \\'0\\') + (temp[7] - \\'0\\');\\n                break;\\n            case 9:\\n                return (temp[0] - \\'0\\')*10000 + (temp[1] - \\'0\\')*1000 + (temp[2] - \\'0\\')*1000 \\n                        + (temp[3] - \\'0\\')*100 + (temp[4] - \\'0\\')*100 + (temp[5] - \\'0\\')*10 \\n                        + (temp[6] - \\'0\\')*10 + (temp[7] - \\'0\\') + (temp[8] - \\'0\\');\\n                break;\\n            case 10:\\n                return (temp[0] - \\'0\\')*10000 + (temp[1] - \\'0\\')*1000 + (temp[2] - \\'0\\')*1000 \\n                        + (temp[3] - \\'0\\')*100 + (temp[4] - \\'0\\')*100 + (temp[5] - \\'0\\')*10 \\n                        + (temp[6] - \\'0\\')*10 + (temp[7] - \\'0\\')*10 + (temp[8] - \\'0\\') + (temp[9] - \\'0\\');\\n                break;\\n        }", "int splitNum(int num) {\\n        char temp[11];\\n        sprintf(temp, \"%d\", num);\\n        const int n = strlen(temp);\\n\\n        qsort(temp, n, sizeof(char), ascend);\\n\\n        char num1[6], num2[6];\\n        int n1 = 0, n2 = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (i % 2 == 0) {\\n                num1[n1++] = temp[i];\\n            }"], ["int splitNum(int num)\\n{\\n    size_t numDigits = (int)floor(log10(num)) + 1;\\n    int digits[10], *writer = digits;\\n\\n    while(num)\\n    {\\n        *writer++ = num % 10;\\n        num /= 10;\\n    }"]]}
{"id": "550", "ref_c": [["int passThePillow(int n, int time){\\n    int k= 0;\\n    bool flag=true;\\n    for(int i= 0;i<time;i++){\\n        if(flag){\\n            k++;\\n            if(k==n-1){\\n                flag = false;\\n            }"], ["int passThePillow(int n, int time){\\n\\n    int i=0;\\n    int pos=1;\\n    bool UpFlag = true;\\n\\n    for(i=0;i<time;i++)\\n    {\\n        if(UpFlag == true)\\n        {\\n            if(pos<n)\\n            {\\n                pos++;\\n            }"], ["int passThePillow(int n, int time){\\n    int k= 0;\\n    bool flag=true;\\n    for(int i= 0;i<time;i++){\\n        if(flag){\\n            k++;\\n            if(k==n-1){\\n                flag = false;\\n            }"]]}
{"id": "551", "ref_c": [["int vowelStrings(char ** words, int wordsSize, int left, int right)\\n{\\n    int c=0;\\n    int c1=0;\\n    int j=0;\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        if((words[i][0]==\\'a\\'||words[i][0]==\\'e\\'||words[i][0]==\\'i\\'||words[i][0] ==\\'o\\'||words[i][0]==\\'u\\')&&(i>=left&&i<=right))\\n            c1++;\\n        while(words[i][j]!=\\'\\\\0\\')\\n        {\\n            j++;\\n        }"], ["int vowelStrings(char ** words, int wordsSize, int left, int right)\\n{\\n    int c=0;\\n    int c1=0;\\n    int j=0;\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        if((words[i][0]==\\'a\\'||words[i][0]==\\'e\\'||words[i][0]==\\'i\\'||words[i][0] ==\\'o\\'||words[i][0]==\\'u\\')&&(i>=left&&i<=right))\\n            c1++;\\n        while(words[i][j]!=\\'\\\\0\\')\\n        {\\n            j++;\\n        }"], ["int vowelStrings(char ** words, int wordsSize, int left, int right)\\n{\\n    int c=0;\\n    int c1=0;\\n    int j=0;\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        if((words[i][0]==\\'a\\'||words[i][0]==\\'e\\'||words[i][0]==\\'i\\'||words[i][0] ==\\'o\\'||words[i][0]==\\'u\\')&&(i>=left&&i<=right))\\n            c1++;\\n        while(words[i][j]!=\\'\\\\0\\')\\n        {\\n            j++;\\n        }"]]}
{"id": "552", "ref_c": [["int distMoney(int money, int children) {\\n\\n    /*\\n     * Input:\\n     *  money\\n     *  children\\n     */\\n    \\n    int ans = 0;\\n\\n    /* Everyone must receive at least 1 dollar. */\\n    money -= children;\\n\\n    if (money < 0) {\\n        return -1;\\n    }"], ["int distMoney(int money, int children){\\n    \\n    if(money < children)\\n        return -1 ;\\n    if(money <= 8)\\n        return 0 ;\\n    if(children*8 == money)\\n        return children ;\\n    \\n    if(children*8 < money)\\n        return children - 1 ;\\n    \\n    int n = money/8 ;\\n    int remain = money - n*8 ;\\n    \\n    int left_person = children - n ;\\n    if(left_person == 1 && remain== 4)\\n        return n-1 ;\\n    \\n    int k = remain ;\\n    while(k < left_person){\\n        n-- ;\\n        k+= 8 ;\\n        left_person++ ;\\n    }"], ["int distMoney(int money, int children){\\n    \\n    if(money < children)\\n        return -1 ;\\n    if(money <= 8)\\n        return 0 ;\\n    if(children*8 == money)\\n        return children ;\\n    \\n    if(children*8 < money)\\n        return children - 1 ;\\n    \\n    int n = money/8 ;\\n    int remain = money - n*8 ;\\n    \\n    int left_person = children - n ;\\n    if(left_person == 1 && remain== 4)\\n        return n-1 ;\\n    \\n    int k = remain ;\\n    while(k < left_person){\\n        n-- ;\\n        k+= 8 ;\\n        left_person++ ;\\n    }"]]}
{"id": "553", "ref_c": [["int* evenOddBit(int n, int* returnSize) {\\n    *returnSize = 2;\\n    int *arr = (int*)malloc(2 * sizeof(int));\\n    arr[0] = 0;\\n    arr[1] = 0;\\n    int even = 0, odd = 0;\\n    for(int i = 0; n != 0; n >>= 1, i++)\\n    {\\n        if(n & 01)\\n            i % 2 == 0 ? even++ : odd++;\\n    }"], ["int* evenOddBit(int n, int* returnSize) {\\n*returnSize = 2;\\nint space = ceil(((log(n))/ log(2)));\\nint *arr = (int*)malloc(2 * sizeof(int));\\narr[0] = 0;\\narr[1] = 0;\\nint countE = 0;\\nint tempN = 0;\\nint pos = 0;\\n\\nfor (int i = 0; i < space + 1; ++i) {\\n    if (n % 2 == 0 || n == 0) {\\n        n = n / 2;\\n        pos += 1;\\n    }"], ["int* evenOddBit(int n, int* returnSize){\\n\\n    int *a=(int*)malloc(2*sizeof(int));\\n    int even=0;\\n    int odd=0;\\n    int i=0;\\n    while(n)\\n    {\\n        if(n&1)\\n        {\\n           \\n          if(i%2==0 || i==0)\\n            {\\n                even++;\\n            }"]]}
{"id": "554", "ref_c": [["int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    if(k<=numOnes)\\n        return k;\\n    else if (k<=numOnes+numZeros)\\n        return numOnes;\\n    return numOnes - (k - numOnes - numZeros);\\n}"], ["int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n        vector<int> A;\\n        for(int i=0;i<numOnes;i++)\\n            A.push_back(1);\\n        for(int i=0;i<numZeros;i++)\\n            A.push_back(0);\\n        for(int i=0;i<numNegOnes;i++)\\n            A.push_back(-1);\\n        int S=0;\\n        for(int i=0;i<k;i++)\\n            S+=A[i];\\n        if(S>=k)\\n            return k;\\n        return S;\\n    }", "int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    int S=numOnes+numZeros+numNegOnes;\\n    int A[1000];\\n    if(S==0)\\n        A[1];\\n    else\\n        A[S];\\n    for(int i=0;i<numOnes;i++)\\n        A[i]=1;\\n    for(int i=numOnes;i<numOnes+numZeros;i++)\\n        A[i]=0;\\n    for(int i=numOnes+numZeros;i<numOnes+numZeros+numNegOnes;i++)\\n        A[i]=-1;\\n    int C=0;\\n    for(int i=0;i<k;i++)\\n        C+=A[i];\\n    if(C>=k)\\n        return k;\\n    return C;\\n}", "int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        ArrayList<Integer> A=new ArrayList<Integer>(1000);\\n        for(int i=0;i<numOnes;i++)\\n            A.add(1);\\n        for(int i=numOnes;i<numOnes+numZeros;i++)\\n            A.add(0);\\n        for(int i=numOnes+numZeros;i<numOnes+numZeros+numNegOnes;i++)\\n            A.add(-1);\\n        int S=0;\\n        for(int i=0;i<k;i++)\\n            S+=A.get(i);\\n        if(S>=k)\\n            return k;\\n        return S;\\n    }"], ["int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return Math.min(k, numOnes) - Math.max(0, k - numOnes - numZeros);\\n        \\n    }", "int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    return min(k, numOnes) - max(0, k - numOnes - numZeros);\\n}"]]}
{"id": "555", "ref_c": [["int minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size)\\n{\\n    int i,j;\\n    int val=99;\\n    \\n     for(i=0;i<nums1Size;i++)\\n     {     for(j=0;j<nums2Size;j++)\\n         {\\n            if(nums1[i]==nums2[j])\\n            {\\n                    \\n                    if(nums1[i]<val)\\n                        val=nums1[i];\\n            }"], ["int minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n  int min1 = nums1[0];\\n  int min2 = nums2[0];\\n  int *map = calloc(9, sizeof(int));\\n  int i,j,k;\\n\\n  for (i=0; i<nums1Size; i++) {\\n    min1 = MIN(min1, nums1[i]);\\n    map[nums1[i]-1] += 1;\\n  }"], ["int minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int result = 89;  // the largest smallest-number allowed is 89\\n    for (int i = 0; i < nums1Size; i++) {\\n        for (int j = 0; j < nums2Size; j++) {\\n            result = min(result, (nums1[i] == nums2[j] ? \\n                         nums1[i] : min(nums1[i], nums2[j]) * 10 + max(nums1[i], nums2[j])));\\n        }"]]}
{"id": "556", "ref_c": [["int findTheLongestBalancedSubstring(char * s)\\n{\\n    int i = 1, len_s = strlen(s), max_len = 0;\\n    while(i < len_s)\\n    {\\n        int j = i - 1, len = 0;\\n        while(0 <= j && i < len_s && s[j] == \\'0\\' && s[i] == \\'1\\')\\n        {\\n            len += 2;\\n            i++;\\n            j--;\\n        }"], ["int findTheLongestBalancedSubstring(char * s){\\n    int len = strlen(s);\\n    int zeroCnt = 0, oneCnt = 0, maxLen = 0, prevZeroCnt = 0;\\n    for(int i = 0; i < len; i++){\\n        if(s[i]==\\'0\\') {\\n            if(oneCnt){\\n                maxLen = MAX(maxLen, MIN(prevZeroCnt, oneCnt)*2);\\n                oneCnt = 0;\\n            }"], ["int findTheLongestBalancedSubstring(char * s){\\n    int len = strlen(s);\\n    int zeroCnt = 0, oneCnt = 0, maxLen = 0, prevZeroCnt = 0;\\n    for(int i = 0; i < len; i++){\\n        if(s[i]==\\'0\\') {\\n            if(oneCnt){\\n                maxLen = MAX(maxLen, MIN(prevZeroCnt, oneCnt)*2);\\n                oneCnt = 0;\\n            }"]]}
{"id": "557", "ref_c": [["int diagonalPrime(int** nums, int numsSize, int* numsColSize)\\n{\\n    int temp=0;\\n    int a,b;\\n    int i=0,k=numsSize-1;\\n    while(i<numsSize && k>-1)\\n    {\\n        a=nums[i][i];\\n        b=nums[i][k];\\n        if(a>temp)\\n        if(prime(a)==1)\\n        temp=a;\\n        if(b>temp)\\n        if(prime(b)==1 )\\n        temp=b;\\n        i++;\\n        k--;\\n    }"], ["int diagonalPrime(int** nums, int numsSize, int* numsColSize){\\n    int prime=0;\\n    for(int i=0;i<numsSize;i++){\\n        int sam=nums[i][i];\\n        if(sam>prime&&isPrime(sam)){\\n                prime=sam;\\n        }"], ["int diagonalPrime(int** nums, int numsSize, int* numsColSize){\\n    int prime=0,flag,temp;\\n    for(int row=0;row<numsSize;row++){\\n        temp=nums[row][row];\\n        if(temp==1) continue;\\n        flag=1;\\n        for(int ind=2;ind<=sqrt(temp);ind++){\\n            if(temp%ind==0){\\n                flag=0;\\n            }"]]}
{"id": "565", "ref_c": [["int* findColumnWidth(int** grid, int gridSize, int* gridColSize, int* returnSize)\\n{\\n  *returnSize = *gridColSize;\\n  int * ans = malloc(*returnSize * sizeof(int));\\n  for(int i = 0; i < *returnSize; i++)\\n  {\\n    int max = 0;\\n    for(int j = 0 ; j < gridSize; j++)\\n    {\\n       max = max < num_len(grid[j][i]) ? num_len(grid[j][i]) : max;\\n    }"], ["int* findColumnWidth(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    int* ans = (int*)calloc(gridColSize[0], sizeof(int));\\n    int currCnt;\\n    *returnSize = gridColSize[0];\\n    for(int i = 0; i < gridSize; i++){\\n        for(int j = 0; j < gridColSize[i]; j++){\\n            currCnt = !grid[i][j]? 1 : count(abs(grid[i][j]));/* if 0, return 1 */\\n            currCnt += (grid[i][j] < 0)? 1 : 0;/* add 1 for \\'-\\' */\\n            ans[j] = MAX(ans[j], currCnt);\\n        }"], ["int* findColumnWidth(int** grid, int gridSize, int* gridColSize, int* returnSize)\\n{\\n    *returnSize=0;\\n    int *retarr=(int*)malloc(*gridColSize*(sizeof(int)));\\n//    printf(\"%d %d\",gridSize,*gridColSize);\\n    int i,j;\\n    int pos=0,k=0;\\n    int neg=0;\\n    if(*gridColSize==1 && gridSize==1)\\n    {retarr[0]=count(1,1); \\n     *returnSize=1;\\n     return retarr;}"]]}
{"id": "566", "ref_c": [["int* rowAndMaximumOnes(int** mat, int matSize, int* matColSize, int* returnSize){\\n    int *ret=(int*)malloc(2*sizeof(int));\\n    *returnSize=2;\\n    int i,re=-1;\\n    for( i=0;i<matSize;i++){\\n        int ones=0;\\n        for(int j=0;j<matColSize[i];j++){\\n            if(mat[i][j]==1)\\n                ones++;\\n        }"], ["int* rowAndMaximumOnes(int** mat, int matSize, int* matColSize, int* returnSize){\\n    int *ret=(int*)malloc(2*sizeof(int));\\n    *returnSize=2;\\n    int i,re=-1;\\n    for( i=0;i<matSize;i++){\\n        int ones=0;\\n        for(int j=0;j<matColSize[i];j++){\\n            if(mat[i][j]==1)\\n                ones++;\\n        }"], ["int* rowAndMaximumOnes(int** mat, int matSize, int* matColSize, int* returnSize){\\nint index=-1;\\nint count=0;\\nint max_one_count=INT_MIN;\\nfor(int i=0;i<matSize;i++)\\n{\\n    for(int j=0;j<*matColSize;j++)\\n    {\\n        if(mat[i][j]==1)\\n        count++;\\n    }"]]}
{"id": "567", "ref_c": [["int maxDivScore(int* nums, int numsSize, int* divisors, int divisorsSize){\\n    int max=0,ret=0;\\n    for(int i=0;i<divisorsSize;i++){\\n        int div=0;\\n        for(int j=0;j<numsSize;j++){\\n            if(nums[j]%divisors[i] == 0)\\n                div++;\\n        }"], ["int maxDivScore(int* nums, int numsSize, int* divisors, int divisorsSize) {\\n    int ss = 0, ans = INT_MAX;\\n    int* score = (int*) calloc(divisorsSize, sizeof(int));\\n    for (int i = 0; i < divisorsSize; i++) {\\n        ss = 0;\\n        for (int j = 0; j < numsSize; j++) {\\n            if (nums[j] % divisors[i] == 0) ss++;\\n        }"], ["int maxDivScore(int* nums, int numsSize, int* divisors, int divisorsSize) {\\n    int ss = 0, ans = INT_MAX;\\n    int* score = (int*) calloc(divisorsSize, sizeof(int));\\n    for (int i = 0; i < divisorsSize; i++) {\\n        ss = 0;\\n        for (int j = 0; j < numsSize; j++) {\\n            if (nums[j] % divisors[i] == 0) ss++;\\n        }"]]}
{"id": "569", "ref_c": [["int findDelayedArrivalTime(int arrivalTime, int delayedTime){\\n    return (arrivalTime + delayedTime)%24;}"], ["int findDelayedArrivalTime(int arrivalTime, int delayedTime){\\n    int tot=arrivalTime+delayedTime;\\n    if(tot >= 24)\\n        tot-=24;\\n    return tot;\\n}"], ["int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sum = arrivalTime+delayedTime;\\n        return sum%24;\\n    }"]]}
{"id": "570", "ref_c": [["int sumOfMultiples(int n){\\n     if(n==1) return 0;\\n     if( n%7==0 || n%5==0 || n%3==0)\\n     return n+sumOfMultiples(n-1);\\n     return sumOfMultiples(n-1);\\n}", "int sumOfMultiples(int n) {\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            if(i%3==0 || i%5==0 || i%7==0) sum+=i;\\n        }", "int sumOfMultiples(int n) {\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            if(i%3==0 || i%5==0 || i%7==0) sum+=i;\\n        }", "int sumOfMultiples(int n) {\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            if(i%3==0 || i%5==0 || i%7==0) sum+=i;\\n        }"], ["int sumOfMultiples(int n) {\\n    // Brute force \\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(1)\\n\\n    int result = 0;\\n    for (int i = 1; i < n + 1; ++i) {\\n        if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) result += i;\\n    }"], ["int sumOfMultiples(int n){\\n    int sum=0;\\n    for(int i=3;i<=n;i++){\\n      if(i%3==0){\\n          sum+=i;\\n      }"]]}
{"id": "571", "ref_c": ["\ninline int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nint max_element(int* arr, int arrSize) {\n    int result = arr[0];\n    for (int i = 1; i < arrSize; i++) {\n        result = max(result, arr[i]);\n    }\n    return result;\n}\nint maximizeSum(int* nums, int numsSize, int k) {\n    // Greedy \n    // if x = max(nums), ans := x + (x + 1) + ... + (x + k - 1)\n    //                       := (x + (x + k - 1)) * k / 2\n    //                       := x*k + (k - 1)*k / 2\n\n    // Time complexity: O(n)\n    // Space comeplxity: O(1)\n\n    const int x = max_element(nums, numsSize);\n    return x*k + (k - 1)*k / 2;\n}\n", "\ninline int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nint max_element(int* arr, int arrSize) {\n    int result = arr[0];\n    for (int i = 1; i < arrSize; i++) {\n        result = max(result, arr[i]);\n    }\n    return result;\n}\nint maximizeSum(int* nums, int numsSize, int k) {\n    // Greedy \n    // if x = max(nums), ans := x + (x + 1) + ... + (x + k - 1)\n    //                       := (x + (x + k - 1)) * k / 2\n    //                       := x*k + (k - 1)*k / 2\n\n    // Time complexity: O(n)\n    // Space comeplxity: O(1)\n\n    const int x = max_element(nums, numsSize);\n    return x*k + (k - 1)*k / 2;\n}\n", "\ninline int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nint max_element(int* arr, int arrSize) {\n    int result = arr[0];\n    for (int i = 1; i < arrSize; i++) {\n        result = max(result, arr[i]);\n    }\n    return result;\n}\nint maximizeSum(int* nums, int numsSize, int k) {\n    // Greedy \n    // if x = max(nums), ans := x + (x + 1) + ... + (x + k - 1)\n    //                       := (x + (x + k - 1)) * k / 2\n    //                       := x*k + (k - 1)*k / 2\n\n    // Time complexity: O(n)\n    // Space comeplxity: O(1)\n\n    const int x = max_element(nums, numsSize);\n    return x*k + (k - 1)*k / 2;\n}\n"]}
{"id": "572", "ref_c": [["int isWinner(int* player1, int player1Size, int* player2, int player2Size){\\n    int p1 = 0;\\n    int p2 = 0;\\n    int i;\\n\\n    int p1x = 0;\\n    int p2x = 0;\\n    for(i=0;i<player1Size;i++){\\n        if(p1x){\\n            p1x--;\\n            p1 += (player1[i]*2);\\n        }"], ["int isWinner(int* player1, int player1Size, int* player2, int player2Size) {\\n    int s1 = score(player1, player1Size);\\n    int s2 = score(player2, player2Size);\\n    return s1==s2?0:s1>s2?1:2;\\n}"], ["int isWinner(int* player1, int player1Size, int* player2, int player2Size){\\n    int p1 = 0;\\n    int p2 = 0;\\n    int i;\\n\\n    int p1x = 0;\\n    int p2x = 0;\\n    for(i=0;i<player1Size;i++){\\n        if(p1x){\\n            p1x--;\\n            p1 += (player1[i]*2);\\n        }"]]}
{"id": "576", "ref_c": [["int* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){\\n    int* temp = malloc(sizeof(int)*51);\\n    int* pre_temp = malloc(sizeof(int)*51);\\n    int* ret = malloc(sizeof(int)*numsSize);\\n    *returnSize = numsSize;\\n    int i;\\n    for(i=0;i<51;i++){\\n        temp[i] = 0;\\n        pre_temp[i] = 0;\\n    }"], ["int* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){\\n    int* temp = malloc(sizeof(int)*51);\\n    int* pre_temp = malloc(sizeof(int)*51);\\n    int* ret = malloc(sizeof(int)*numsSize);\\n    *returnSize = numsSize;\\n    int i;\\n    for(i=0;i<51;i++){\\n        temp[i] = 0;\\n        pre_temp[i] = 0;\\n    }"], ["int* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){\\n    int* temp = malloc(sizeof(int)*51);\\n    int* pre_temp = malloc(sizeof(int)*51);\\n    int* ret = malloc(sizeof(int)*numsSize);\\n    *returnSize = numsSize;\\n    int i;\\n    for(i=0;i<51;i++){\\n        temp[i] = 0;\\n        pre_temp[i] = 0;\\n    }"]]}
{"id": "578", "ref_c": [["int countSeniors(char ** details, int detailsSize){\\n    int a=0,ind=0;\\n    \\n    for(int i=0;i<detailsSize;i++)\\n    { \\n        a=10*(details[i][11]-\\'0\\')+details[i][12]-\\'0\\';\\n        if(a>60)\\n        {\\n            ind++;\\n        }"], ["int countSeniors(char ** details, int detailsSize){\\n    int count = 0;\\n    for(int i=0;i<detailsSize;i++){\\n        int age = (details[i][11] - \\'0\\')*10 + details[i][12] - \\'0\\';\\n        if(age > 60){\\n            count++;\\n        }"], ["int countSeniors(char ** details, int detailsSize){\\n    int count = 0,i = 0,sum = 0;\\n    for(i = 0; i <  detailsSize; i++)\\n    {\\n        sum = 0;\\n        sum = sum * 10 + (details[i][11] - \\'0\\');\\n        sum = sum * 10 + (details[i][12] - \\'0\\');\\n        if(sum > 60)count++;\\n    }"]]}
{"id": "579", "ref_c": [["int* circularGameLosers(int n, int k, int* returnSize) {\\n    // Simulation + Hashtable\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    bool* seen = (bool*)calloc(n, sizeof(bool));\\n    \\n    for (int friendIndex = 0, turn = 1; !seen[friendIndex]; ) {\\n        seen[friendIndex] = true;\\n        friendIndex += (turn++) * k;\\n        friendIndex %= n;\\n    }"], ["int* circularGameLosers(int n, int k, int* returnSize){\\n    int *res = malloc(sizeof(int)*n);\\n    memset(res, 0, n*sizeof(int) );\\n    int i=1,s=0;\\n    res[0]=1;\\n    while(1){\\n        res[(s+i*k)%n]++;\\n        if(res[(s+i*k)%n]==2){\\n            break;\\n        }"], ["int* circularGameLosers(int n, int k, int* returnSize) {\\n    // Simulation + Hashtable\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    bool* seen = (bool*)calloc(n, sizeof(bool));\\n    \\n    for (int friendIndex = 0, turn = 1; !seen[friendIndex]; ) {\\n        seen[friendIndex] = true;\\n        friendIndex += (turn++) * k;\\n        friendIndex %= n;\\n    }"]]}
{"id": "581", "ref_c": [["int minLength(char * s){\\n int len = strlen(s), a = 0, b = 0;\\n    char* ss = (char*) calloc(len+1, sizeof(char));\\n    while (b < len) {\\n        ss[a++] = s[b++];\\n        if (a > 1) {\\n            if (strncmp(ss+a-2, \"AB\", 2) == 0 || strncmp(ss+a-2, \"CD\", 2) == 0) a -= 2;\\n        }"], ["int minLength(char * s)\\n{\\n    stack Stack;\\n    Stack.size = STACK_SIZE;\\n    Stack.top = -1;\\n    memset(Stack.stack_arr, \\'\\\\0\\', sizeof(Stack.stack_arr));\\n\\n    int i=0;\\n    while(s[i] != \\'\\\\0\\')\\n    {\\n        if((s[i] == \\'B\\') || (s[i] == \\'D\\'))\\n        {\\n            if(s[i] == \\'B\\')\\n            {\\n                if(isStackEmpty(&Stack))\\n                {\\n                    push(&Stack, s[i]);\\n                }"], ["int minLength(char * s){\\n int len = strlen(s), a = 0, b = 0;\\n    char* ss = (char*) calloc(len+1, sizeof(char));\\n    while (b < len) {\\n        ss[a++] = s[b++];\\n        if (a > 1) {\\n            if (strncmp(ss+a-2, \"AB\", 2) == 0 || strncmp(ss+a-2, \"CD\", 2) == 0) a -= 2;\\n        }"]]}
{"id": "582", "ref_c": [["char * makeSmallestPalindrome(char * s){\\nint i=0;\\nint j=strlen(s)-1;\\nwhile(i<j)\\n{\\n    if(s[i]==s[j])\\n    {\\n        i++;\\n        j--;\\n    }"], ["char * makeSmallestPalindrome(char * s){\\nint i=0;\\nint j=strlen(s)-1;\\nwhile(i<j)\\n{\\n    if(s[i]==s[j])\\n    {\\n        i++;\\n        j--;\\n    }"], ["char * makeSmallestPalindrome(char * s){\\nint i=0;\\nint j=strlen(s)-1;\\nwhile(i<j)\\n{\\n    if(s[i]==s[j])\\n    {\\n        i++;\\n        j--;\\n    }"]]}
{"id": "585", "ref_c": [["int buyChoco(int* prices, int pricesSize, int money){\\n    int price1 = INT_MAX;\\n    int price2 = INT_MAX;\\n\\n    /* Find the two least prices */\\n    for (int i = 0; i < pricesSize; ++i) {\\n        if (prices[i] < price1) {\\n            price2 = price1;\\n            price1 = prices[i];\\n        }", "int buyChoco(int* prices, int pricesSize, int money){\\n    qsort(prices, pricesSize, sizeof(int), cmp);\\n\\n    int price = prices[0] + prices[1];\\n\\n    /* If price is not greater than money, return the difference, otherwise, return original money */\\n    return price <= money ? money - price : money;\\n}"], ["int buyChoco(int* prices, int pricesSize, int money){\\n    int price1 = INT_MAX;\\n    int price2 = INT_MAX;\\n\\n    /* Find the two least prices */\\n    for (int i = 0; i < pricesSize; ++i) {\\n        if (prices[i] < price1) {\\n            price2 = price1;\\n            price1 = prices[i];\\n        }", "int buyChoco(int* prices, int pricesSize, int money){\\n    qsort(prices, pricesSize, sizeof(int), cmp);\\n\\n    int price = prices[0] + prices[1];\\n\\n    /* If price is not greater than money, return the difference, otherwise, return original money */\\n    return price <= money ? money - price : money;\\n}"], ["int buyChoco(int* prices, int pricesSize, int money){\\n    int price1 = INT_MAX;\\n    int price2 = INT_MAX;\\n\\n    /* Find the two least prices */\\n    for (int i = 0; i < pricesSize; ++i) {\\n        if (prices[i] < price1) {\\n            price2 = price1;\\n            price1 = prices[i];\\n        }", "int buyChoco(int* prices, int pricesSize, int money){\\n    qsort(prices, pricesSize, sizeof(int), cmp);\\n\\n    int price = prices[0] + prices[1];\\n\\n    /* If price is not greater than money, return the difference, otherwise, return original money */\\n    return price <= money ? money - price : money;\\n}"]]}
{"id": "586", "ref_c": [["char * removeTrailingZeros(char * num){\\n    int l=strlen(num);\\n    int i;\\n    for(i=l-1;i>=0;i--){\\n        if(num[i]!=\\'0\\')\\n            break;\\n        else{\\n            l--;\\n        }"], ["char * removeTrailingZeros(char * num){\\n   int i;\\n   for(i=strlen(num)-1;i>=0;i--){\\n       if(num[i]-48>0){\\n           num[i+1]=0;\\n           break;\\n       }"], ["char * removeTrailingZeros(char * num){\\n   int i;\\n   for(i=strlen(num)-1;i>=0;i--){\\n       if(num[i]-48>0){\\n           num[i+1]=0;\\n           break;\\n       }"]]}
{"id": "588", "ref_c": [["int minimizedStringLength(char * s){\\n    int arr[26] = {0}"], ["int minimizedStringLength(char * s){\\n\\n   int length = strlen(s); \\n   int count = 0;\\n   \\n   char temp;\\n   for(int i=0;i<length;i++){\\n       for(int j=i+1;j<length;j++){\\n           if(s[i] > s[j]){\\n               temp = s[i];\\n               s[i] = s[j];\\n               s[j] = temp;\\n           }"], ["int minimizedStringLength(char * s){\\n    int arr[26] = {0}"]]}
{"id": "589", "ref_c": [["int semiOrderedPermutation(int* nums, int numsSize){\\n\\n    int times=0;\\n\\n    static int i=0,j=0;\\n\\n    int idx=0;\\n    int tmp=0;\\n    for (i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==1)idx=i;\\n    }"], ["int semiOrderedPermutation(int* nums, int numsSize) {\\n    if (nums[0] == 1 && nums[numsSize-1] == numsSize) return 0;\\n    int ss = -1, ee = -1;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == 1) {\\n            ss = i;\\n        }"], ["int semiOrderedPermutation(int* nums, int numsSize) {\\n    if (nums[0] == 1 && nums[numsSize-1] == numsSize) return 0;\\n    int ss = -1, ee = -1;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == 1) {\\n            ss = i;\\n        }"]]}
{"id": "595", "ref_c": [["bool isFascinating(int n){\\nint two_N=2*n;\\nint three_N=3*n;\\nchar s0[100],s1[50],s2[50];\\nsprintf(s0,\"%d\",n); // sprintf() is used to assign number to char array[]\\nsprintf(s1,\"%d\",two_N);\\nsprintf(s2,\"%d\",three_N);\\nstrcat(s1,s2); // concatenate the strings\\nstrcat(s0,s1);\\nint res=atoi(s0); // atoi() is used to convert the string respresentation to integer \\nint rem,temp,num=0,count=0;\\nfor(int i=1;i<=9;i++)\\n{\\nint temp=res;\\nwhile(temp>0)\\n{\\n    rem=temp%10;\\n    if(rem==0) return false;\\n    else\\n    {\\n        if(rem==i) count++;\\n    }"], ["bool isFascinating(int n) {\\n    bool a[10]={false}"], ["bool isFascinating(int n) {\\n        vector<int> hash(10, 0);\\n\\n        int a = 2*n;\\n        int b = 3*n;\\n\\n        string num = to_string(n)+to_string(a)+to_string(b);\\n        cout<<num;\\n        for(auto i:num)\\n        {\\n            if(i == \\'0\\')\\n                return false;\\n\\n            hash[i-\\'0\\']++;\\n            if(hash[i-\\'0\\'] > 1)\\n                return false;\\n        }"]]}
{"id": "596", "ref_c": [["int findNonMinOrMax(int* nums, int numsSize){\\n    /*\\n     * Input:\\n     *  nums, integer array\\n     *  numsSize\\n     */\\n     \\n    int sum = 0, max, min;\\n     \\n    if (numsSize <= 2) {\\n        return -1;\\n    }"], ["int findNonMinOrMax(int* nums, int numsSize) {\\n    if (numsSize < 3) {\\n        return -1;\\n    }"], ["int findNonMinOrMax(int* nums, int numsSize) {\\n    if (numsSize < 3) {\\n        return -1;\\n    }"]]}
{"id": "597", "ref_c": [["int distanceTraveled(int mainTank, int additionalTank){\\n\\tbool run;\\n\\tint b;\\n\\tint a;\\n\\n\\trun = true;\\n\\ta = 0;\\n\\tb = 0;\\n\\twhile (run == true)\\n\\t{\\n\\t\\tif (b % 5 == 0 && additionalTank > 0)\\n\\t\\t{\\n\\t\\t\\tif (b != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmainTank += 1;\\n\\t\\t\\t\\tadditionalTank -= 1;\\n\\t\\t\\t}"], ["int distanceTraveled(int mainTank, int additionalTank){\\n\\tbool run;\\n\\tint b;\\n\\tint a;\\n\\n\\trun = true;\\n\\ta = 0;\\n\\tb = 0;\\n\\twhile (run == true)\\n\\t{\\n\\t\\tif (b % 5 == 0 && additionalTank > 0)\\n\\t\\t{\\n\\t\\t\\tif (b != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmainTank += 1;\\n\\t\\t\\t\\tadditionalTank -= 1;\\n\\t\\t\\t}"], ["int distanceTraveled(int mainTank, int additionalTank){\\n  int distance = 0;\\n  int extra = 0;\\n\\n  while(mainTank>=5) {\\n       mainTank = mainTank - 5;\\n      distance = distance +50;\\n      if(additionalTank>0) {\\n        mainTank = mainTank + 1;\\n        additionalTank= additionalTank -1;\\n      }"]]}
{"id": "598", "ref_c": [["int maximumNumberOfStringPairs(char ** words, int wordsSize){\\n    int ho=0;\\n \\n    for(int i=0;i<wordsSize;i++){\\n        stringev(words[i]);\\n        for(int j=i+1;j<wordsSize;j++)\\n            if(!strcmp(words[i],words[j])){\\n            ho++;\\n            }"], ["int maximumNumberOfStringPairs(char ** words, int wordsSize)\\n{\\n    int Result = 0;\\n\\n    for(int word_index = 0; word_index < wordsSize; word_index++)\\n    {\\n        char *word = *(words + word_index);\\n        int word_length = str_length(word);\\n        for(int pair_index = word_index + 1; pair_index < wordsSize; pair_index++)\\n        {\\n            char *pair = *(words + pair_index);\\n            int pair_length = str_length(pair);\\n            if(word_length == pair_length)\\n            {\\n                char *test = pair + pair_length - 1;\\n                char *target = word;\\n                bool same = true;\\n                for(int char_index = 0; char_index < word_length; char_index++)\\n                {\\n                    if(*target++ != *test--)\\n                    {\\n                        same = false;\\n                        break;\\n                    }"], ["int maximumNumberOfStringPairs(char ** words, int wordsSize){\\n    int ho=0;\\n \\n    for(int i=0;i<wordsSize;i++){\\n        stringev(words[i]);\\n        for(int j=i+1;j<wordsSize;j++)\\n            if(!strcmp(words[i],words[j])){\\n            ho++;\\n            }"]]}
{"id": "599", "ref_c": [["int countBeautifulPairs(int* nums, int numsSize){\\n    int i,c=0,a,b,j,k;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        while(nums[i]>0)\\n        {\\n            a=nums[i]%10;\\n            nums[i]=nums[i]/10;\\n        }"], ["int countBeautifulPairs(int* nums, int numsSize){\\n    int ret = 0;\\n    int  i,j,x,y,gcd;\\n    for(i=0;i<numsSize;i++){\\n        while(nums[i]){\\n            x = nums[i]%10;\\n            nums[i] = nums[i]/10;\\n        }"], ["int countBeautifulPairs(int* nums, int numsSize){\\n    int c=0;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            int a,b;\\n            a=nums[j]%10;\\n            b=nums[i];\\n\\n            while(b/10!=0)\\n            b/=10;\\n            if(gcd(a,b)==1)\\n            c++;\\n        }"]]}
{"id": "600", "ref_c": [["int longestAlternatingSubarray(int* nums, int numsSize, int threshold)\\n{\\n  int l = 0, max_len = 0, r;\\n  while(l < numsSize)\\n  {\\n    if(nums[l] % 2 != 0 || nums[l] > threshold)\\n    {\\n      l++;\\n      continue;\\n    }"], ["int longestAlternatingSubarray(int* nums, int numsSize, int threshold){\\n    int i,n=numsSize,m=0,c;\\n    i=0;\\n    while(i<n)\\n    {\\n        if(nums[i]%2==0)\\n        {\\n            c=1;\\n            while(i<n-1 && nums[i]<=threshold && nums[i]%2!=nums[i+1]%2)\\n            {\\n                i++;\\n                c++;\\n            }"], ["int longestAlternatingSubarray(int* nums, int numsSize, int threshold){\\n    int i,n=numsSize,m=0,c;\\n    i=0;\\n    while(i<n)\\n    {\\n        if(nums[i]%2==0)\\n        {\\n            c=1;\\n            while(i<n-1 && nums[i]<=threshold && nums[i]%2!=nums[i+1]%2)\\n            {\\n                i++;\\n                c++;\\n            }"]]}
{"id": "601", "ref_c": [["int alternatingSubarray(int* nums, int numsSize)\\n{\\n    int longest_alter_subarr = 0, i = 0;\\n    while(i < numsSize - 1)\\n    {\\n        if(nums[i + 1] != nums[i] + 1)\\n        {\\n            i++;\\n            continue;\\n        }"], ["int alternatingSubarray(int* nums, int numsSize){\\n    int max=1;\\n    int ans=1;\\n    int i=0;\\n    int t=0;\\n    while(i<numsSize-1){\\n        if(t==0){\\n            if(nums[i]-nums[i+1]==-1){\\n                max++;\\n                t=1;\\n                i++;\\n                if(ans<max) ans=max;\\n            }"], ["int alternatingSubarray(int* nums, int numsSize)\\n{\\n    int longest_alter_subarr = 0, i = 0;\\n    while(i < numsSize - 1)\\n    {\\n        if(nums[i + 1] != nums[i] + 1)\\n        {\\n            i++;\\n            continue;\\n        }"]]}
{"id": "602", "ref_c": [["int theMaximumAchievableX(int num, int t){\\n    return num+t*2;\\n}"], ["int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }"], ["int theMaximumAchievableX(int num, int t){\\n    return 2*t+num;\\n}", "int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }"]]}
{"id": "603", "ref_c": [["int sumOfSquares(int* nums, int numsSize)\\n{   \\n   int sum = 0,temp;\\n   for(int i = 1; i <= numsSize; i++)\\n   {\\n       if(numsSize % i == 0)\\n       {\\n           temp = nums[i-1] * nums[i-1];\\n           sum = sum + temp;\\n       }"], ["int sumOfSquares(int* nums, int numsSize)\\n{   \\n   int sum = 0,temp;\\n   for(int i = 1; i <= numsSize; i++)\\n   {\\n       if(numsSize % i == 0)\\n       {\\n           temp = nums[i-1] * nums[i-1];\\n           sum = sum + temp;\\n       }"], ["int sumOfSquares(int* nums, int numsSize)\\n{   \\n   int sum = 0,temp;\\n   for(int i = 1; i <= numsSize; i++)\\n   {\\n       if(numsSize % i == 0)\\n       {\\n           temp = nums[i-1] * nums[i-1];\\n           sum = sum + temp;\\n       }"]]}
{"id": "604", "ref_c": [["bool isGood(int* nums, int numsSize){\\n    int i,cpos;\\n    i=0;\\n    while(i<numsSize)\\n    {\\n        if(nums[i]>=numsSize)\\n        return false;\\n\\n        int cpos=nums[i]-1;\\n        if(nums[i]!=nums[cpos])\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[cpos];\\n            nums[cpos]=temp;\\n        }"], ["bool isGood(int* nums, int numsSize){\\n    int *arr=(int *)calloc((numsSize),sizeof(int));\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]>=numsSize)\\n        return false;\\n        else\\n        {\\n            arr[nums[i]]+=1;\\n        }"], ["bool isGood(int* nums, int numsSize){\\n    int *arr=(int *)calloc((numsSize),sizeof(int));\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]>=numsSize)\\n        return false;\\n        else\\n        {\\n            arr[nums[i]]+=1;\\n        }"]]}
{"id": "605", "ref_c": [["char ** splitWordsBySeparator(char ** words, int wordsSize, char separator, int* returnSize){\\n    char** output=malloc(8000);\\n    *returnSize=0;\\n    bool justSplit;\\n    for (char i=0;i<wordsSize;i++){\\n        justSplit=true;\\n        for (char j=0;words[i][j];j++){\\n            if (words[i][j]==separator){\\n                words[i][j]=0;\\n                justSplit=true;\\n            }"], ["char ** splitWordsBySeparator(char ** words, int wordsSize, char separator, int* returnSize){\\nchar **ans=(char**)malloc(sizeof(char*)*1000);\\n*returnSize=0;\\nfor(int i=0;i<wordsSize;i++)\\n{\\n    for(int j=0;1;)\\n    {\\n        while(words[i][j]!=\\'\\\\0\\'&& words[i][j]==separator)\\n        j++;\\n        if(words[i][j]==\\'\\\\0\\')\\n        break;\\n        int countlen=1;\\n        while(words[i][j+countlen]!=\\'\\\\0\\'&& words[i][j+countlen]!=separator)\\n        {\\n            countlen++;\\n        }"], ["char ** splitWordsBySeparator(char ** words, int wordsSize, char separator, int* returnSize){\\n    char** output=malloc(8000);\\n    *returnSize=0;\\n    bool justSplit;\\n    for (char i=0;i<wordsSize;i++){\\n        justSplit=true;\\n        for (char j=0;words[i][j];j++){\\n            if (words[i][j]==separator){\\n                words[i][j]=0;\\n                justSplit=true;\\n            }"]]}
{"id": "606", "ref_c": [["int numberOfEmployeesWhoMetTarget(int* hours, int hoursSize, int target){\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < hoursSize; i++){\\n        if (hours[i] >= target) {\\n            count++;\\n        }"], ["int numberOfEmployeesWhoMetTarget(int* hours, int hoursSize, int target){\\n    if(hours==NULL ||hoursSize<=0)\\n    {\\n        return 0;\\n    }"], ["int numberOfEmployeesWhoMetTarget(int* hours, int hoursSize, int target){\\n    int counter=0;\\n    for(int i=0;i<hoursSize;i++){\\n        if(hours[i]>=target){\\n            counter++;\\n        }"]]}
{"id": "607", "ref_c": [["int accountBalanceAfterPurchase(int purchaseAmount){\\n    if(purchaseAmount%10 >= 5){\\n        purchaseAmount = purchaseAmount + (10 - purchaseAmount%10);\\n        int money = 100 - purchaseAmount;\\n        return money;\\n    }"], ["int accountBalanceAfterPurchase(int purchaseAmount) {\\n        \\n        int ans =1;\\n        if((purchaseAmount % 10 ) < 5){\\n            while(ans !=0 ){\\n            ans = purchaseAmount % 10;\\n            if(ans == 0) return (100 - purchaseAmount);\\n            purchaseAmount --;\\n            }"], ["int accountBalanceAfterPurchase(int purchaseAmount) {\\n        \\n        int ans =1;\\n        if((purchaseAmount % 10 ) < 5){\\n            while(ans !=0 ){\\n            ans = purchaseAmount % 10;\\n            if(ans == 0) return (100 - purchaseAmount);\\n            purchaseAmount --;\\n            }"]]}
{"id": "608", "ref_c": [["char * finalString(char * s){\\n    int index=0;\\n    int len=strlen(s);\\n\\n    for(int i=0;s[i]!=\\'\\\\0\\';i++)\\n        if(s[i]==\\'i\\'){\\n            for(int j=i;j<len;j++)\\n                s[j]=s[j+1];\\n            len--;\\n            int temp;\\n            for(int k=0,j=i-1;k<j;k++,j--){\\n                temp=s[k];\\n                s[k]=s[j];\\n                s[j]=temp;\\n            }"], ["char * finalString(char * s){\\n    int len=0;\\n    int n=strlen(s);\\n    for(int i=0;i<n;i++){\\n        if(i+1<n && s[i]==\\'i\\' && s[i+1]==\\'i\\') i++;\\n        else if(s[i]==\\'i\\'){\\n            int j=0;\\n            while(j<len/2){\\n                char temp=s[len-1-j];\\n                s[len-1-j]=s[j];\\n                s[j]=temp;\\n                j++;\\n            }"], ["char * finalString(char * s){\\n    int index=0;\\n    int len=strlen(s);\\n\\n    for(int i=0;s[i]!=\\'\\\\0\\';i++)\\n        if(s[i]==\\'i\\'){\\n            for(int j=i;j<len;j++)\\n                s[j]=s[j+1];\\n            len--;\\n            int temp;\\n            for(int k=0,j=i-1;k<j;k++,j--){\\n                temp=s[k];\\n                s[k]=s[j];\\n                s[j]=temp;\\n            }"]]}
{"id": "609", "ref_c": [["int maxSum(int* nums, int numsSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int array[10][100], cnt[10] = {0}"], ["int maxSum(int* nums, int numsSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int array[10][100], cnt[10] = {0}"], ["int maxSum(int* nums, int numsSize){\\n    \\n    int **class=(int**)calloc(10,sizeof(int*));\\n    for(int i=0; i<10; i++){\\n        class[i]=(int*)calloc(100,sizeof(int));\\n    }"]]}
{"id": "610", "ref_c": [["struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\\n    int sum = 0;\\n    int carry = 0;\\n    struct ListNode* l3 = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    struct ListNode* head = l3;\\n\\n    while (l1 || l2) {\\n        sum = 0;\\n\\n        if (l1) {\\n            sum += l1->val;\\n            l1 = l1->next;\\n        }"], ["struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\\n    int sum = 0;\\n    int carry = 0;\\n    struct ListNode* l3 = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    struct ListNode* head = l3;\\n\\n    while (l1 || l2) {\\n        sum = 0;\\n\\n        if (l1) {\\n            sum += l1->val;\\n            l1 = l1->next;\\n        }"], ["struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\\n    int sum = 0;\\n    int carry = 0;\\n    struct ListNode* l3 = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    struct ListNode* head = l3;\\n\\n    while (l1 || l2) {\\n        sum = 0;\\n\\n        if (l1) {\\n            sum += l1->val;\\n            l1 = l1->next;\\n        }"]]}
{"id": "611", "ref_c": [["int lengthOfLongestSubstring(char * s){\\n    int arr[128] = {0}"], ["int lengthOfLongestSubstring(char * s){\\n    int arr[128] = {0}"], ["int lengthOfLongestSubstring(char * s){\\n    int arr[128] = {0}"]]}
{"id": "612", "ref_c": [["char * longestPalindrome(char * s){\\n    int max = 0, idx = 0, len = strlen(s);\\n    for(int i = 0; i < len; i++) {\\n        int len1 = extend(s, i, i);       /* For even string */\\n        int len2 = extend(s, i, i + 1);   /* For odd string  */\\n        if (max < maxVal(len1, len2)) {\\n            idx = (len1 > len2) ? (i - len1 / 2) : (i - len2 / 2 + 1);\\n            max = maxVal(len1, len2);\\n        }"], ["char * longestPalindrome(char * s){\\n    int max = 0, idx = 0, len = strlen(s);\\n    for(int i = 0; i < len; i++) {\\n        int len1 = extend(s, i, i);       /* For even string */\\n        int len2 = extend(s, i, i + 1);   /* For odd string  */\\n        if (max < maxVal(len1, len2)) {\\n            idx = (len1 > len2) ? (i - len1 / 2) : (i - len2 / 2 + 1);\\n            max = maxVal(len1, len2);\\n        }"], ["char * longestPalindrome(char * s){\\n    int max = 0, idx = 0, len = strlen(s);\\n    for(int i = 0; i < len; i++) {\\n        int len1 = extend(s, i, i);       /* For even string */\\n        int len2 = extend(s, i, i + 1);   /* For odd string  */\\n        if (max < maxVal(len1, len2)) {\\n            idx = (len1 > len2) ? (i - len1 / 2) : (i - len2 / 2 + 1);\\n            max = maxVal(len1, len2);\\n        }"]]}
{"id": "613", "ref_c": [["char * convert(char * s, int numRows){\\n    \\n    int len = strlen(s),\\n        k = 0;\\n    char* res = malloc(sizeof(char) * (len + 1));\\n\\n    if (numRows > 1)\\n    {\\n        for (int i = 0; i < len; i += (2 * numRows) - 2)\\n            res[k++] = s[i];\\n\\n        for (int row = 2; row < numRows; ++row)\\n        {\\n            for (int i = row - 1; i < len; )\\n            {\\n                res[k++] = s[i];\\n                if ((i += ((2 * numRows) - (2 * row))) >= len) break;\\n                res[k++] = s[i];\\n                i += ((2 * numRows) - (2 * (numRows - row + 1)));\\n            }"], ["char * convert(char * s, int numRows){\\n    int size = strlen(s) + 5;\\n    if (numRows == 1 || size-5 <= numRows ) return s;\\n    \\n    char **zigzag = (char**)calloc(numRows * size, sizeof(char));\\n    for(int i = 0; i < numRows; i++) *(zigzag + i) = (char*) calloc(size, sizeof(char));\\n    \\n    int direction = -1, level = 0, i = 0; \\n    while( s[i] != \\'\\\\0\\' ){\\n        strncat(zigzag[level], &s[i++], 1);\\n        if ( level % (numRows-1) == 0 ) direction *= -1;\\n        level += direction;\\n    }"], ["char * convert(char * s, int numRows){\\n    \\n    int len = strlen(s),\\n        k = 0;\\n    char* res = malloc(sizeof(char) * (len + 1));\\n\\n    if (numRows > 1)\\n    {\\n        for (int i = 0; i < len; i += (2 * numRows) - 2)\\n            res[k++] = s[i];\\n\\n        for (int row = 2; row < numRows; ++row)\\n        {\\n            for (int i = row - 1; i < len; )\\n            {\\n                res[k++] = s[i];\\n                if ((i += ((2 * numRows) - (2 * row))) >= len) break;\\n                res[k++] = s[i];\\n                i += ((2 * numRows) - (2 * (numRows - row + 1)));\\n            }"]]}
{"id": "614", "ref_c": [["int reverse(int x){\\n    long result = 0;\\n    bool flag = true;\\n    if(x < 0){\\n        if(x == -2147483648){\\n            return 0;\\n        }"], ["int reverse(int x){\\n    long digit=0;\\n    int flag=0;\\n    if(x<0){\\n        if(x==INT_MIN){\\n            return 0;\\n        }"], ["int reverse(int x) {\\n    int* check = malloc(sizeof(int));\\n    int negative = (x < 0), first = x % 10, remain = x / 10, res = 0;\\n    while (remain != 0) {\\n        if (negative ? (INT_MIN / 10 <= res) : (INT_MAX / 10 >= res)) {\\n            res *= 10;\\n            if (negative ? (INT_MIN - first <= res) : (INT_MAX - first >= res))\\n                res += first;\\n            else\\n                return 0;\\n        }"]]}
{"id": "615", "ref_c": [["int myAtoi(char * s){\\n    printf(\"%ld\",strtol(s,NULL,10));\\n    if(strtol(s,NULL,10)>2147483647){\\n        return(2147483647);\\n    }"], ["int myAtoi(char * s){\\n    printf(\"%ld\",strtol(s,NULL,10));\\n    if(strtol(s,NULL,10)>2147483647){\\n        return(2147483647);\\n    }"], ["int myAtoi(char * s){\\n    printf(\"%ld\",strtol(s,NULL,10));\\n    if(strtol(s,NULL,10)>2147483647){\\n        return(2147483647);\\n    }"]]}
{"id": "616", "ref_c": [["int maxArea(int* height, int heightSize) {\\n    int left = 0;                // Left pointer starting from the leftmost edge\\n    int right = heightSize - 1;  // Right pointer starting from the rightmost edge\\n    int maxWater = 0;            // Initialize the maximum water capacity\\n\\n    while (left < right) {\\n        // Calculate the width of the container\\n        int width = right - left;\\n\\n        // Calculate the height of the container (the minimum height between the two lines)\\n        int h = height[left] < height[right] ? height[left] : height[right];\\n\\n        // Calculate the water capacity of the current container\\n        int water = width * h;\\n\\n        // Update the maximum water capacity if the current container holds more water\\n        if (water > maxWater) {\\n            maxWater = water;\\n        }"], ["int maxArea(int* height, int heightSize) {\\n    int left = 0;                // Left pointer starting from the leftmost edge\\n    int right = heightSize - 1;  // Right pointer starting from the rightmost edge\\n    int maxWater = 0;            // Initialize the maximum water capacity\\n\\n    while (left < right) {\\n        // Calculate the width of the container\\n        int width = right - left;\\n\\n        // Calculate the height of the container (the minimum height between the two lines)\\n        int h = height[left] < height[right] ? height[left] : height[right];\\n\\n        // Calculate the water capacity of the current container\\n        int water = width * h;\\n\\n        // Update the maximum water capacity if the current container holds more water\\n        if (water > maxWater) {\\n            maxWater = water;\\n        }"], ["int maxArea(int* height, int heightSize) {\\n    int left = 0;                // Left pointer starting from the leftmost edge\\n    int right = heightSize - 1;  // Right pointer starting from the rightmost edge\\n    int maxWater = 0;            // Initialize the maximum water capacity\\n\\n    while (left < right) {\\n        // Calculate the width of the container\\n        int width = right - left;\\n\\n        // Calculate the height of the container (the minimum height between the two lines)\\n        int h = height[left] < height[right] ? height[left] : height[right];\\n\\n        // Calculate the water capacity of the current container\\n        int water = width * h;\\n\\n        // Update the maximum water capacity if the current container holds more water\\n        if (water > maxWater) {\\n            maxWater = water;\\n        }"]]}
{"id": "617", "ref_c": [["char * intToRoman(int num){\\n    char *result = (char*)malloc(50*sizeof(char));\\n    result[0] = \\'\\\\0\\';\\n    struct Roman romanSymbol[numerals_roman] = {{1,\"I\"}"], ["char * intToRoman(int num){\\n    char *result = (char*)malloc(50*sizeof(char));\\n    result[0] = \\'\\\\0\\';\\n    struct Roman romanSymbol[numerals_roman] = {{1,\"I\"}"], ["char * intToRoman(int num){\\n\\n    char* s = (char*) malloc(sizeof(char)*20);\\n    memset (s, 0, sizeof(char)*20);\\n    int i = 0;\\n    \\n    while (num > 0) {\\n        if (num >= 1000) {\\n            s[i++] = \\'M\\';\\n            num -= 1000;\\n        }"]]}
{"id": "618", "ref_c": [["int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    (*returnSize) = 0;\\n    (*returnColumnSizes) = (int*) malloc(sizeof(int) * numsSize * numsSize);\\n    int **ret = (int**) malloc(sizeof(int*) * numsSize * numsSize);\\n    for (int i = 0; i < numsSize - 2; i++) {\\n        if (i == 0 || nums[i] != nums[i-1]) {\\n            int l = i + 1;\\n            int r = numsSize - 1;\\n            while (l < r) {\\n                if (nums[i] + nums[l] + nums[r] < 0) {\\n                    l++;\\n                }"], ["int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n\\n    int i,j,k,sum,t,total=64;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    *returnSize=0;\\n    int **q=(int**)malloc(sizeof(int*)*total);\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*total);\\n    for(i=0;i<numsSize-2;i++)\\n    {\\n        if(nums[i]>0||nums[i]+nums[i+1]+nums[i+2]>0)\\n            break;\\n        if(i>0&&nums[i]==nums[i-1])\\n            continue;\\n        j=i+1;\\n        k=numsSize-1;\\n        sum=-nums[i];\\n        while(j<k)\\n        {\\n            t=nums[j]+nums[k];\\n            if(t<sum)\\n                j++;\\n            else if(t>sum)\\n                k--;\\n            else\\n            {\\n                (*returnColumnSizes)[*returnSize]=3;\\n                q[*returnSize]=(int*) malloc(sizeof(int)*3);\\n                q[*returnSize][0]=nums[i];\\n                q[*returnSize][1]=nums[j++];\\n                q[*returnSize][2]=nums[k--];\\n                (*returnSize)++;\\n                while(j<k&&nums[j]==nums[j-1])\\n                    j++;\\n                while(j<k&&nums[k]==nums[k+1])\\n                    k--;\\n                if((*returnSize)==total)\\n                {\\n                    total*=2;\\n                    *returnColumnSizes=(int*)realloc(*returnColumnSizes,sizeof(int)*total);\\n                    q=(int**)realloc(q,sizeof(int*)*total);\\n                }"], ["int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n\\n    int i,j,k,sum,t,total=64;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    *returnSize=0;\\n    int **q=(int**)malloc(sizeof(int*)*total);\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*total);\\n    for(i=0;i<numsSize-2;i++)\\n    {\\n        if(nums[i]>0||nums[i]+nums[i+1]+nums[i+2]>0)\\n            break;\\n        if(i>0&&nums[i]==nums[i-1])\\n            continue;\\n        j=i+1;\\n        k=numsSize-1;\\n        sum=-nums[i];\\n        while(j<k)\\n        {\\n            t=nums[j]+nums[k];\\n            if(t<sum)\\n                j++;\\n            else if(t>sum)\\n                k--;\\n            else\\n            {\\n                (*returnColumnSizes)[*returnSize]=3;\\n                q[*returnSize]=(int*) malloc(sizeof(int)*3);\\n                q[*returnSize][0]=nums[i];\\n                q[*returnSize][1]=nums[j++];\\n                q[*returnSize][2]=nums[k--];\\n                (*returnSize)++;\\n                while(j<k&&nums[j]==nums[j-1])\\n                    j++;\\n                while(j<k&&nums[k]==nums[k+1])\\n                    k--;\\n                if((*returnSize)==total)\\n                {\\n                    total*=2;\\n                    *returnColumnSizes=(int*)realloc(*returnColumnSizes,sizeof(int)*total);\\n                    q=(int**)realloc(q,sizeof(int*)*total);\\n                }"]]}
{"id": "619", "ref_c": ["\nint comp(int* a,int* b)\n{\n    return(*a)-(*b);\n}\n\nint threeSumClosest(int* nums, int numsSize, int target) {\n    if(numsSize==0 || numsSize<3)\n    {\n        return 0;\n    }\n    qsort(nums,numsSize,sizeof(int),comp);\n    int closesum=INT_MIN;\n    int mindiff=INT_MAX;\n    for(int i=0;i<numsSize;i++)\n    {\n        int left=i+1;\n        int right=numsSize-1;\n        while(left<right)\n        {\n            int currentsum=nums[i]+nums[left]+nums[right];\n            int currentdiff=abs(target-currentsum);\n            if(currentdiff<mindiff)\n            {\n                mindiff=currentdiff;\n                closesum=currentsum;\n            }\n            if(currentsum<target)\n            {\n                left++;\n            }\n            else\n            {\n                right--;\n            }\n        }\n    }\n    return closesum;\n}\n", "\nint comp(int* a,int* b)\n{\n    return(*a)-(*b);\n}\n\nint threeSumClosest(int* nums, int numsSize, int target) {\n    if(numsSize==0 || numsSize<3)\n    {\n        return 0;\n    }\n    qsort(nums,numsSize,sizeof(int),comp);\n    int closesum=INT_MIN;\n    int mindiff=INT_MAX;\n    for(int i=0;i<numsSize;i++)\n    {\n        int left=i+1;\n        int right=numsSize-1;\n        while(left<right)\n        {\n            int currentsum=nums[i]+nums[left]+nums[right];\n            int currentdiff=abs(target-currentsum);\n            if(currentdiff<mindiff)\n            {\n                mindiff=currentdiff;\n                closesum=currentsum;\n            }\n            if(currentsum<target)\n            {\n                left++;\n            }\n            else\n            {\n                right--;\n            }\n        }\n    }\n    return closesum;\n}\n", "\nint comp(int* a,int* b)\n{\n    return(*a)-(*b);\n}\n\nint threeSumClosest(int* nums, int numsSize, int target) {\n    if(numsSize==0 || numsSize<3)\n    {\n        return 0;\n    }\n    qsort(nums,numsSize,sizeof(int),comp);\n    int closesum=INT_MIN;\n    int mindiff=INT_MAX;\n    for(int i=0;i<numsSize;i++)\n    {\n        int left=i+1;\n        int right=numsSize-1;\n        while(left<right)\n        {\n            int currentsum=nums[i]+nums[left]+nums[right];\n            int currentdiff=abs(target-currentsum);\n            if(currentdiff<mindiff)\n            {\n                mindiff=currentdiff;\n                closesum=currentsum;\n            }\n            if(currentsum<target)\n            {\n                left++;\n            }\n            else\n            {\n                right--;\n            }\n        }\n    }\n    return closesum;\n}\n"]}
{"id": "620", "ref_c": ["\nchar **letterCombinations(char *digits, int *returnSize) {\n    char *map[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\n    if (digits == NULL || *digits == '\u0000') {\n        *returnSize = 0;\n        return NULL;\n    }\n\n    int len = strlen(digits);\n    *returnSize = 1;\n    for (int i = 0; i < len; i++) {\n        int digit = digits[i] - '0' - 2;\n        *returnSize *= strlen(map[digit]);\n    }\n\n    char **result = (char **)malloc(*returnSize * sizeof(char *));\n    int index = 0;\n    int maxCombLength = len;\n    for (int i = 0; i < len; i++) {\n        int digit = digits[i] - '0' - 2;\n        maxCombLength *= strlen(map[digit]);\n    }\n    char combination[maxCombLength + 1];\n    for (int i = 0; i < *returnSize; i++) {\n        result[i] = (char *)malloc((len + 1) * sizeof(char));\n    }\n    int factors[len];\n    factors[len - 1] = 1;\n\n    for (int i = len - 2; i >= 0; i--) {\n        int digit = digits[i + 1] - '0' - 2;\n        factors[i] = factors[i + 1] * strlen(map[digit]);\n    }\n\n    for (int i = 0; i < *returnSize; i++) {\n        combination[0] = '\u0000';\n\n        int temp = i;\n        for (int j = 0; j < len; j++) {\n            int digit = digits[j] - '0' - 2;\n            int idx = (temp / factors[j]) % strlen(map[digit]);\n            combination[j] = map[digit][idx];\n            combination[j + 1] = '\u0000';\n        }\n\n        strcpy(result[index++], combination);\n    }\n\n    return result;\n}\n\n", "\nchar **letterCombinations(char *digits, int *returnSize) {\n    char *map[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\n    if (digits == NULL || *digits == '\u0000') {\n        *returnSize = 0;\n        return NULL;\n    }\n\n    int len = strlen(digits);\n    *returnSize = 1;\n    for (int i = 0; i < len; i++) {\n        int digit = digits[i] - '0' - 2;\n        *returnSize *= strlen(map[digit]);\n    }\n\n    char **result = (char **)malloc(*returnSize * sizeof(char *));\n    int index = 0;\n    int maxCombLength = len;\n    for (int i = 0; i < len; i++) {\n        int digit = digits[i] - '0' - 2;\n        maxCombLength *= strlen(map[digit]);\n    }\n    char combination[maxCombLength + 1];\n    for (int i = 0; i < *returnSize; i++) {\n        result[i] = (char *)malloc((len + 1) * sizeof(char));\n    }\n    int factors[len];\n    factors[len - 1] = 1;\n\n    for (int i = len - 2; i >= 0; i--) {\n        int digit = digits[i + 1] - '0' - 2;\n        factors[i] = factors[i + 1] * strlen(map[digit]);\n    }\n\n    for (int i = 0; i < *returnSize; i++) {\n        combination[0] = '\u0000';\n\n        int temp = i;\n        for (int j = 0; j < len; j++) {\n            int digit = digits[j] - '0' - 2;\n            int idx = (temp / factors[j]) % strlen(map[digit]);\n            combination[j] = map[digit][idx];\n            combination[j + 1] = '\u0000';\n        }\n\n        strcpy(result[index++], combination);\n    }\n\n    return result;\n}\n\n", "\nchar **letterCombinations(char *digits, int *returnSize) {\n    char *map[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\n    if (digits == NULL || *digits == '\u0000') {\n        *returnSize = 0;\n        return NULL;\n    }\n\n    int len = strlen(digits);\n    *returnSize = 1;\n    for (int i = 0; i < len; i++) {\n        int digit = digits[i] - '0' - 2;\n        *returnSize *= strlen(map[digit]);\n    }\n\n    char **result = (char **)malloc(*returnSize * sizeof(char *));\n    int index = 0;\n    int maxCombLength = len;\n    for (int i = 0; i < len; i++) {\n        int digit = digits[i] - '0' - 2;\n        maxCombLength *= strlen(map[digit]);\n    }\n    char combination[maxCombLength + 1];\n    for (int i = 0; i < *returnSize; i++) {\n        result[i] = (char *)malloc((len + 1) * sizeof(char));\n    }\n    int factors[len];\n    factors[len - 1] = 1;\n\n    for (int i = len - 2; i >= 0; i--) {\n        int digit = digits[i + 1] - '0' - 2;\n        factors[i] = factors[i + 1] * strlen(map[digit]);\n    }\n\n    for (int i = 0; i < *returnSize; i++) {\n        combination[0] = '\u0000';\n\n        int temp = i;\n        for (int j = 0; j < len; j++) {\n            int digit = digits[j] - '0' - 2;\n            int idx = (temp / factors[j]) % strlen(map[digit]);\n            combination[j] = map[digit][idx];\n            combination[j + 1] = '\u0000';\n        }\n\n        strcpy(result[index++], combination);\n    }\n\n    return result;\n}\n\n"]}
{"id": "621", "ref_c": [["int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\\n    qsort(nums, numsSize, sizeof(int), compare);\\n    int** ans = NULL;\\n    *returnSize = 0;\\n\\n    for (int i = 0; i < numsSize - 3; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\\n        for (int j = i + 1; j < numsSize - 2; j++) {\\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\\n            long long newTarget = (long long)target - nums[i] - nums[j];\\n            int low = j + 1, high = numsSize - 1;\\n\\n            while (low < high) {\\n                long long sum = nums[low] + nums[high];\\n                if (sum < newTarget) {\\n                    low++;\\n                }", "int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\\n    int** ans = NULL;\\n    *returnSize = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\\n        for (int j = i + 1; j < numsSize; j++) {\\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\\n            long long newTarget = (long long)target - nums[i] - nums[j];\\n            int low = j + 1, high = numsSize - 1;\\n\\n            while (low < high) {\\n                long long sum = (long long)nums[low] + nums[high];\\n                if (sum < newTarget) {\\n                    low++;\\n                }", "int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\\n    int** ans = NULL;\\n    *returnSize = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    for (int i = 0; i < numsSize - 3; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\\n        for (int j = i + 1; j < numsSize - 2; j++) {\\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\\n            long long newTarget = (long long)target - nums[i] - nums[j];\\n            int low = j + 1, high = numsSize - 1;\\n\\n            while (low < high) {\\n                long long sum = (long long)nums[low] + nums[high];\\n                if (sum < newTarget) {\\n                    low++;\\n                }"], ["int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\\n    qsort(nums, numsSize, sizeof(int), compare);\\n    int** ans = NULL;\\n    *returnSize = 0;\\n\\n    for (int i = 0; i < numsSize - 3; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\\n        for (int j = i + 1; j < numsSize - 2; j++) {\\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\\n            long long newTarget = (long long)target - nums[i] - nums[j];\\n            int low = j + 1, high = numsSize - 1;\\n\\n            while (low < high) {\\n                long long sum = nums[low] + nums[high];\\n                if (sum < newTarget) {\\n                    low++;\\n                }", "int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\\n    int** ans = NULL;\\n    *returnSize = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\\n        for (int j = i + 1; j < numsSize; j++) {\\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\\n            long long newTarget = (long long)target - nums[i] - nums[j];\\n            int low = j + 1, high = numsSize - 1;\\n\\n            while (low < high) {\\n                long long sum = (long long)nums[low] + nums[high];\\n                if (sum < newTarget) {\\n                    low++;\\n                }", "int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\\n    int** ans = NULL;\\n    *returnSize = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    for (int i = 0; i < numsSize - 3; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\\n        for (int j = i + 1; j < numsSize - 2; j++) {\\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\\n            long long newTarget = (long long)target - nums[i] - nums[j];\\n            int low = j + 1, high = numsSize - 1;\\n\\n            while (low < high) {\\n                long long sum = (long long)nums[low] + nums[high];\\n                if (sum < newTarget) {\\n                    low++;\\n                }"], ["int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\\n    qsort(nums, numsSize, sizeof(int), compare);\\n    int** ans = NULL;\\n    *returnSize = 0;\\n\\n    for (int i = 0; i < numsSize - 3; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\\n        for (int j = i + 1; j < numsSize - 2; j++) {\\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\\n            long long newTarget = (long long)target - nums[i] - nums[j];\\n            int low = j + 1, high = numsSize - 1;\\n\\n            while (low < high) {\\n                long long sum = nums[low] + nums[high];\\n                if (sum < newTarget) {\\n                    low++;\\n                }", "int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\\n    int** ans = NULL;\\n    *returnSize = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\\n        for (int j = i + 1; j < numsSize; j++) {\\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\\n            long long newTarget = (long long)target - nums[i] - nums[j];\\n            int low = j + 1, high = numsSize - 1;\\n\\n            while (low < high) {\\n                long long sum = (long long)nums[low] + nums[high];\\n                if (sum < newTarget) {\\n                    low++;\\n                }", "int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\\n    int** ans = NULL;\\n    *returnSize = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    for (int i = 0; i < numsSize - 3; i++) {\\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\\n        for (int j = i + 1; j < numsSize - 2; j++) {\\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\\n            long long newTarget = (long long)target - nums[i] - nums[j];\\n            int low = j + 1, high = numsSize - 1;\\n\\n            while (low < high) {\\n                long long sum = (long long)nums[low] + nums[high];\\n                if (sum < newTarget) {\\n                    low++;\\n                }"]]}
{"id": "622", "ref_c": [["struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\\n    if(head==NULL || (head->next==NULL)){\\n        return NULL;\\n    }"], ["struct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n\\n    if(head->next == NULL) return NULL;\\n\\n    struct ListNode* tmp = head;\\n    struct ListNode* cur = head;\\n    int i = 0;\\n    while(tmp)\\n    {\\n        i++;\\n        tmp = tmp->next;\\n    }"], ["struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n    struct ListNode* fast = dummy;\\n    struct ListNode* slow = dummy;\\n\\n    // Move the fast pointer n+1 steps ahead\\n    for (int i = 0; i <= n; i++) {\\n        fast = fast->next;\\n    }"]]}
{"id": "623", "ref_c": ["\nvoid f(char***ret,int*index,int n,int l_n , int r_n,char*string,int sindex)\n{\n    if(l_n + r_n == 2*n)\n    {\n        (*ret)[(*index)] = malloc(sizeof(char)*(2*n +1 ));\n        int i ;\n        for(i = 0 ; i < 2*n ; i++)\n            (*ret)[(*index)][i] = string[i];\n        (*ret)[(*index)][i] = '\u0000';\n        (*index)++;\n        return;\n    }\n\n    if(l_n < n  )\n    {\n        string[sindex] = '(';\n        f(ret,index,n,l_n+1,r_n,string,sindex+1);\n    }\n    if(r_n < l_n)\n    {\n        string[sindex] = ')';\n        f(ret,index,n,l_n,r_n+1,string,sindex+1);\n    }\n}\n\nchar** generateParenthesis(int n, int* returnSize) {\n    char**ret = malloc(sizeof(char*)*10000);\n    int reti = 0 ;\n    char*string = malloc(sizeof(char)*(2*n + 1));\n    string[2*n] = '\u0000';\n    f(&ret,&reti,n,0,0,string,0);\n\n    ret = realloc(ret,sizeof(char*)*reti);\n    *returnSize = reti ;\n\n    return ret;\n}\n", "\nvoid f(char***ret,int*index,int n,int l_n , int r_n,char*string,int sindex)\n{\n    if(l_n + r_n == 2*n)\n    {\n        (*ret)[(*index)] = malloc(sizeof(char)*(2*n +1 ));\n        int i ;\n        for(i = 0 ; i < 2*n ; i++)\n            (*ret)[(*index)][i] = string[i];\n        (*ret)[(*index)][i] = '\u0000';\n        (*index)++;\n        return;\n    }\n\n    if(l_n < n  )\n    {\n        string[sindex] = '(';\n        f(ret,index,n,l_n+1,r_n,string,sindex+1);\n    }\n    if(r_n < l_n)\n    {\n        string[sindex] = ')';\n        f(ret,index,n,l_n,r_n+1,string,sindex+1);\n    }\n}\n\nchar** generateParenthesis(int n, int* returnSize) {\n    char**ret = malloc(sizeof(char*)*10000);\n    int reti = 0 ;\n    char*string = malloc(sizeof(char)*(2*n + 1));\n    string[2*n] = '\u0000';\n    f(&ret,&reti,n,0,0,string,0);\n\n    ret = realloc(ret,sizeof(char*)*reti);\n    *returnSize = reti ;\n\n    return ret;\n}\n", "\nvoid f(char***ret,int*index,int n,int l_n , int r_n,char*string,int sindex)\n{\n    if(l_n + r_n == 2*n)\n    {\n        (*ret)[(*index)] = malloc(sizeof(char)*(2*n +1 ));\n        int i ;\n        for(i = 0 ; i < 2*n ; i++)\n            (*ret)[(*index)][i] = string[i];\n        (*ret)[(*index)][i] = '\u0000';\n        (*index)++;\n        return;\n    }\n\n    if(l_n < n  )\n    {\n        string[sindex] = '(';\n        f(ret,index,n,l_n+1,r_n,string,sindex+1);\n    }\n    if(r_n < l_n)\n    {\n        string[sindex] = ')';\n        f(ret,index,n,l_n,r_n+1,string,sindex+1);\n    }\n}\n\nchar** generateParenthesis(int n, int* returnSize) {\n    char**ret = malloc(sizeof(char*)*10000);\n    int reti = 0 ;\n    char*string = malloc(sizeof(char)*(2*n + 1));\n    string[2*n] = '\u0000';\n    f(&ret,&reti,n,0,0,string,0);\n\n    ret = realloc(ret,sizeof(char*)*reti);\n    *returnSize = reti ;\n\n    return ret;\n}\n"]}
{"id": "624", "ref_c": [["struct ListNode* swapPairs(struct ListNode* head){\\n    if(head == NULL || head->next == NULL )return head;\\n    struct ListNode* tmp = head->next;\\n    head->next = head->next->next;\\n    tmp->next = head;\\n    while(head->next)\\n    {\\n        if(head->next->next){\\n        struct ListNode* cur1 = head->next;\\n        struct ListNode* cur2 = head->next->next;\\n        cur1->next  = cur2->next;\\n        cur2->next = cur1;\\n        head->next = cur2;\\n\\n        head = head->next->next;\\n        }"], ["struct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n    return head;\\n    struct ListNode*x,*y,*z=NULL;\\n    x=head;\\n    y=head->next;\\n    if(head->next->next!=NULL)\\n    {\\n        z=head->next->next;\\n    }"], ["struct ListNode* swapPairs(struct ListNode* head){\\n    struct ListNode *p, *q = head, *r;\\n    if(head == NULL || head->next == NULL)\\n        return head;\\n    p = head->next;\\n    while(p != NULL)\\n    {\\n        if(q == head)\\n        {\\n            head->next = p->next;\\n            p->next = head;\\n            head = p;\\n            r = head->next;\\n            if(r->next != NULL)\\n            {\\n                q = r->next;\\n                p = q->next;\\n            }"]]}
{"id": "625", "ref_c": [["int divide(int dividend, int divisor) {\\n    // Get rid of signs because bitwise math is easier with positive numbers\\n    uint32_t remainder = uabs(dividend);\\n    uint32_t positiveDivisor = uabs(divisor);\\n    \\n    // Long division algorithm everyone learned in grade school, except in binary instead of decimal\\n    uint32_t result = 0;\\n    for (int i = 31; i >= 0; --i) {\\n        uint32_t curDividend = remainder >> i;\\n        if (curDividend >= positiveDivisor) {\\n            result += 1u << i;\\n            remainder -= positiveDivisor << i;\\n        }"], ["int divide(int dividend, int divisor) {\\n    // Get rid of signs because bitwise math is easier with positive numbers\\n    uint32_t remainder = uabs(dividend);\\n    uint32_t positiveDivisor = uabs(divisor);\\n    \\n    // Long division algorithm everyone learned in grade school, except in binary instead of decimal\\n    uint32_t result = 0;\\n    for (int i = 31; i >= 0; --i) {\\n        uint32_t curDividend = remainder >> i;\\n        if (curDividend >= positiveDivisor) {\\n            result += 1u << i;\\n            remainder -= positiveDivisor << i;\\n        }"], ["int divide(int dividend, int divisor) {\\n    // Get rid of signs because bitwise math is easier with positive numbers\\n    uint32_t remainder = uabs(dividend);\\n    uint32_t positiveDivisor = uabs(divisor);\\n    \\n    // Long division algorithm everyone learned in grade school, except in binary instead of decimal\\n    uint32_t result = 0;\\n    for (int i = 31; i >= 0; --i) {\\n        uint32_t curDividend = remainder >> i;\\n        if (curDividend >= positiveDivisor) {\\n            result += 1u << i;\\n            remainder -= positiveDivisor << i;\\n        }"]]}
{"id": "626", "ref_c": [["void nextPermutation(int* nums, int numsSize) {\\n  /* Find the first place moving from right to left that is not assending */\\n  int dest = numsSize - 1;\\n  while (dest-- && nums[dest] >= nums[dest + 1])\\n    ;\\n\\n  if (0 <= dest) /* Found a destination to change */ {\\n    /* Find the right most value greater than our destination (there must be one) */\\n    int target = numsSize;\\n    while (nums[--target] <= nums[dest])\\n      ;\\n\\n    /* Swap the destination with the target */\\n    int tmp = nums[dest];\\n    nums[dest] = nums[target];\\n    nums[target] = tmp;\\n  }"], ["void nextPermutation(int* nums, int numsSize)\\n{\\n    for (int i = numsSize - 1; i > 0; i--) {\\n        if (nums[i] > nums[i - 1]) {\\n            int min = i;\\n            for (int j = i; j < numsSize; j++) {\\n                if (nums[i - 1] < nums[j] && nums[min] > nums[j]) {\\n                    min = j;\\n                }"], ["void nextPermutation(int* nums, int numsSize) {\\n\\n    if (numsSize < 2)\\n        return;\\n    \\n    for (int i = numsSize - 2; i >= 0; i--)\\n    {\\n        if (nums[i] < nums[i + 1])\\n        {\\n            int c = i + 1;\\n            for (int k = i + 2; k < numsSize; k++)\\n                if (nums[k] > nums[i] && nums[k] < nums[c])\\n                    c = k; \\n            \\n            int t = nums[i];\\n            nums[i] = nums[c];\\n            nums[c] = t;\\n\\n            if (i == numsSize - 2)\\n                return;\\n            qsort(&nums[i+1], numsSize - i - 1, sizeof(int), cmpfn);\\n            return;\\n        }"]]}
{"id": "627", "ref_c": [["int search(int* nums, int numsSize, int target){\\n    int low = 0, high = numsSize - 1;\\n    bool targetI = target >= nums[0];\\n\\n    while(low <= high) {\\n        int mid = low + (high - low) / 2;\\n        bool midI = nums[mid] >= nums[0];\\n        if(midI && !targetI) low = mid + 1;\\n        else if(!midI && targetI) high = mid - 1;\\n        else if(nums[mid] < target) low = mid + 1;\\n        else if(nums[mid] > target) high = mid - 1;\\n        else return mid;\\n    }"], ["int search(int* nums, int numsSize, int target){\\n    int low = 0, high = numsSize - 1;\\n    bool targetI = target >= nums[0];\\n\\n    while(low <= high) {\\n        int mid = low + (high - low) / 2;\\n        bool midI = nums[mid] >= nums[0];\\n        if(midI && !targetI) low = mid + 1;\\n        else if(!midI && targetI) high = mid - 1;\\n        else if(nums[mid] < target) low = mid + 1;\\n        else if(nums[mid] > target) high = mid - 1;\\n        else return mid;\\n    }"], ["int search(int* nums, int numsSize, int target){\\n    int low = 0, high = numsSize - 1;\\n    bool targetI = target >= nums[0];\\n\\n    while(low <= high) {\\n        int mid = low + (high - low) / 2;\\n        bool midI = nums[mid] >= nums[0];\\n        if(midI && !targetI) low = mid + 1;\\n        else if(!midI && targetI) high = mid - 1;\\n        else if(nums[mid] < target) low = mid + 1;\\n        else if(nums[mid] > target) high = mid - 1;\\n        else return mid;\\n    }"]]}
{"id": "628", "ref_c": [["int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int first = -1, last = -1;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            if (first == -1) {\\n                first = i;\\n            }", "int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int first = findFirst(nums, numsSize, target);\\n    int last = findLast(nums, numsSize, target);\\n\\n    int* result = (int*)malloc(2 * sizeof(int));\\n    result[0] = first;\\n    result[1] = last;\\n    *returnSize = 2;\\n    return result;\\n}", "int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int first = findFirst(nums, numsSize, target);\\n    int last = findLast(nums, numsSize, target);\\n\\n    int* result = (int*)malloc(2 * sizeof(int));\\n    result[0] = first;\\n    result[1] = last;\\n    *returnSize = 2;\\n    return result;\\n}", "int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int left = 0, right = numsSize - 1;\\n    int first = -1, last = -1;\\n\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (nums[mid] == target) {\\n            first = mid;\\n            last = mid;\\n            while (first > 0 && nums[first - 1] == target) {\\n                first--;\\n            }"], ["int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int first = -1, last = -1;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            if (first == -1) {\\n                first = i;\\n            }", "int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int first = findFirst(nums, numsSize, target);\\n    int last = findLast(nums, numsSize, target);\\n\\n    int* result = (int*)malloc(2 * sizeof(int));\\n    result[0] = first;\\n    result[1] = last;\\n    *returnSize = 2;\\n    return result;\\n}", "int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int first = findFirst(nums, numsSize, target);\\n    int last = findLast(nums, numsSize, target);\\n\\n    int* result = (int*)malloc(2 * sizeof(int));\\n    result[0] = first;\\n    result[1] = last;\\n    *returnSize = 2;\\n    return result;\\n}", "int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int left = 0, right = numsSize - 1;\\n    int first = -1, last = -1;\\n\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (nums[mid] == target) {\\n            first = mid;\\n            last = mid;\\n            while (first > 0 && nums[first - 1] == target) {\\n                first--;\\n            }"], ["int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int first = -1, last = -1;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            if (first == -1) {\\n                first = i;\\n            }", "int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int first = findFirst(nums, numsSize, target);\\n    int last = findLast(nums, numsSize, target);\\n\\n    int* result = (int*)malloc(2 * sizeof(int));\\n    result[0] = first;\\n    result[1] = last;\\n    *returnSize = 2;\\n    return result;\\n}", "int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int first = findFirst(nums, numsSize, target);\\n    int last = findLast(nums, numsSize, target);\\n\\n    int* result = (int*)malloc(2 * sizeof(int));\\n    result[0] = first;\\n    result[1] = last;\\n    *returnSize = 2;\\n    return result;\\n}", "int* searchRange(int* nums, int numsSize, int target, int* returnSize) {\\n    int left = 0, right = numsSize - 1;\\n    int first = -1, last = -1;\\n\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (nums[mid] == target) {\\n            first = mid;\\n            last = mid;\\n            while (first > 0 && nums[first - 1] == target) {\\n                first--;\\n            }"]]}
{"id": "629", "ref_c": [["bool isValidSudoku(char** board, int boardSize, int* boardColSize){\\n    int horizontal[9], vertical[9], block[9][9] = {0}"], ["bool isValidSudoku(char** board, int boardSize, int* boardColSize)\\n{\\n    bool Col[9][9]={0}"], ["bool isValidSudoku(char** board, int boardSize, int* boardColSize){\\n    int horizontal[9], vertical[9], block[9][9] = {0}"]]}
{"id": "630", "ref_c": ["\nchar* countAndSay(int n)\n{\n    if(n == 1)\n    {\n        return \"1\";\n    }\n    // get s\n    char* s = countAndSay(n - 1);  // answer from previous call\n    int size = strlen(s);  // size of s\n    // get ans\n    char* ans = (char*) malloc(4463 * sizeof(char));\n    // iterate through s and add to ans\n    int idx = 0;  // idx in ans\n    char curr = *s;  // first char of s\n    int cnt = 1;  // count of curr\n    for(int i = 1; i < size; i++)\n    {\n        char c = *(s + i);\n        if(c == curr)\n        {\n            cnt++;\n        }\n        else\n        {\n            *(ans + idx++) = ('0' + cnt);\n            *(ans + idx++) = curr;\n            curr = c;\n            cnt = 1;\n        }\n        // printf(\"%s\n\", ans);\n    }\n    *(ans + idx++) = ('0' + cnt);\n    *(ans + idx++) = curr;\n    *(ans + idx) = '\u0000';\n    // ans = (char*) realloc(ans, (idx + 1) * sizeof(char));\n    return ans;\n}\n","\nchar* countAndSay(int n)\n{\n    if(n == 1)\n    {\n        return \"1\";\n    }\n    // get s\n    char* s = countAndSay(n - 1);  // answer from previous call\n    int size = strlen(s);  // size of s\n    // get ans\n    char* ans = (char*) malloc(4463 * sizeof(char));\n    // iterate through s and add to ans\n    int idx = 0;  // idx in ans\n    char curr = *s;  // first char of s\n    int cnt = 1;  // count of curr\n    for(int i = 1; i < size; i++)\n    {\n        char c = *(s + i);\n        if(c == curr)\n        {\n            cnt++;\n        }\n        else\n        {\n            *(ans + idx++) = ('0' + cnt);\n            *(ans + idx++) = curr;\n            curr = c;\n            cnt = 1;\n        }\n        // printf(\"%s\n\", ans);\n    }\n    *(ans + idx++) = ('0' + cnt);\n    *(ans + idx++) = curr;\n    *(ans + idx) = '\u0000';\n    // ans = (char*) realloc(ans, (idx + 1) * sizeof(char));\n    return ans;\n}\n","\nchar* countAndSay(int n)\n{\n    if(n == 1)\n    {\n        return \"1\";\n    }\n    // get s\n    char* s = countAndSay(n - 1);  // answer from previous call\n    int size = strlen(s);  // size of s\n    // get ans\n    char* ans = (char*) malloc(4463 * sizeof(char));\n    // iterate through s and add to ans\n    int idx = 0;  // idx in ans\n    char curr = *s;  // first char of s\n    int cnt = 1;  // count of curr\n    for(int i = 1; i < size; i++)\n    {\n        char c = *(s + i);\n        if(c == curr)\n        {\n            cnt++;\n        }\n        else\n        {\n            *(ans + idx++) = ('0' + cnt);\n            *(ans + idx++) = curr;\n            curr = c;\n            cnt = 1;\n        }\n        // printf(\"%s\n\", ans);\n    }\n    *(ans + idx++) = ('0' + cnt);\n    *(ans + idx++) = curr;\n    *(ans + idx) = '\u0000';\n    // ans = (char*) realloc(ans, (idx + 1) * sizeof(char));\n    return ans;\n}\n"]}
{"id": "631", "ref_c": [["int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\\n    *returnSize = 0;\\n    *returnColumnSizes = NULL;\\n    int** res = NULL;\\n    int sum = 0;\\n    int index = 0;\\n    int* ds = NULL;\\n    int ds_size = 0;\\n    int rowSize = 0;\\n\\ngenerate(candidates, &ds, candidatesSize, target, &res, returnColumnSizes, sum, index, &rowSize, ds_size);\\n\\n    *returnSize = rowSize;\\n    return res;\\n}"], ["int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\\n    *returnSize = 0;\\n    *returnColumnSizes = NULL;\\n    int** res = NULL;\\n    int sum = 0;\\n    int index = 0;\\n    int* ds = NULL;\\n    int ds_size = 0;\\n    int rowSize = 0;\\n\\ngenerate(candidates, &ds, candidatesSize, target, &res, returnColumnSizes, sum, index, &rowSize, ds_size);\\n\\n    *returnSize = rowSize;\\n    return res;\\n}"], ["int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\\n    *returnSize = 0;\\n    *returnColumnSizes = NULL;\\n    int** res = NULL;\\n    int sum = 0;\\n    int index = 0;\\n    int* ds = NULL;\\n    int ds_size = 0;\\n    int rowSize = 0;\\n\\ngenerate(candidates, &ds, candidatesSize, target, &res, returnColumnSizes, sum, index, &rowSize, ds_size);\\n\\n    *returnSize = rowSize;\\n    return res;\\n}"]]}
{"id": "632", "ref_c": [["int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\\n    \\n    /* Sort the candidates to group duplicates together */\\n    qsort(candidates, candidatesSize, sizeof(int), sortFunc);\\n    \\n    /* Array to store the current solution */\\n    int* current = (int*)malloc(100*sizeof(int));\\n    int currentLength = 0;\\n    \\n    /* Allocate initial memory to answer and returnColumnSizes */\\n    int** answer = (int**)malloc(sizeof(int*));\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int));\\n    \\n    (*returnSize) = 0;\\n    \\n    /* Call the helper with our initial conditions */\\n    helper(candidates, candidatesSize, target, 0, current, currentLength, returnSize, returnColumnSizes, &answer);\\n    \\n    free(current);\\n    return answer;\\n}"], ["int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\\n    \\n    /* Sort the candidates to group duplicates together */\\n    qsort(candidates, candidatesSize, sizeof(int), sortFunc);\\n    \\n    /* Array to store the current solution */\\n    int* current = (int*)malloc(100*sizeof(int));\\n    int currentLength = 0;\\n    \\n    /* Allocate initial memory to answer and returnColumnSizes */\\n    int** answer = (int**)malloc(sizeof(int*));\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int));\\n    \\n    (*returnSize) = 0;\\n    \\n    /* Call the helper with our initial conditions */\\n    helper(candidates, candidatesSize, target, 0, current, currentLength, returnSize, returnColumnSizes, &answer);\\n    \\n    free(current);\\n    return answer;\\n}"], ["int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\\n    \\n    /* Sort the candidates to group duplicates together */\\n    qsort(candidates, candidatesSize, sizeof(int), sortFunc);\\n    \\n    /* Array to store the current solution */\\n    int* current = (int*)malloc(100*sizeof(int));\\n    int currentLength = 0;\\n    \\n    /* Allocate initial memory to answer and returnColumnSizes */\\n    int** answer = (int**)malloc(sizeof(int*));\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int));\\n    \\n    (*returnSize) = 0;\\n    \\n    /* Call the helper with our initial conditions */\\n    helper(candidates, candidatesSize, target, 0, current, currentLength, returnSize, returnColumnSizes, &answer);\\n    \\n    free(current);\\n    return answer;\\n}"]]}
{"id": "633", "ref_c": [["char * multiply(char * num1, char * num2){\\n    if(num1[0]==\\'0\\' || num2[0]==\\'0\\') return \"0\";\\n    int n,m;\\n    n = strlen(num1);\\n    m = strlen(num2);\\n    char* ans = (char*)calloc(n+m+1,sizeof(char));\\n    for(int i=0 ; i<n ; i++){\\n        for(int j=0 ; j<m ; j++){\\n            int k = i+j+1;\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            while(mul){\\n                mul += ans[k];\\n                ans[k] = (mul)%10;\\n                mul = mul/10;\\n                k--;\\n            }"], ["char * multiply(char * num1, char * num2){\\n    if(num1[0]==\\'0\\' || num2[0]==\\'0\\') return \"0\";\\n    int n,m;\\n    n = strlen(num1);\\n    m = strlen(num2);\\n    char* ans = (char*)calloc(n+m+1,sizeof(char));\\n    for(int i=0 ; i<n ; i++){\\n        for(int j=0 ; j<m ; j++){\\n            int k = i+j+1;\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            while(mul){\\n                mul += ans[k];\\n                ans[k] = (mul)%10;\\n                mul = mul/10;\\n                k--;\\n            }"], ["char * multiply(char * num1, char * num2){\\n    if(num1[0]==\\'0\\' || num2[0]==\\'0\\') return \"0\";\\n    int n,m;\\n    n = strlen(num1);\\n    m = strlen(num2);\\n    char* ans = (char*)calloc(n+m+1,sizeof(char));\\n    for(int i=0 ; i<n ; i++){\\n        for(int j=0 ; j<m ; j++){\\n            int k = i+j+1;\\n            int mul = (num1[i]-\\'0\\') * (num2[j]-\\'0\\');\\n            while(mul){\\n                mul += ans[k];\\n                ans[k] = (mul)%10;\\n                mul = mul/10;\\n                k--;\\n            }"]]}
{"id": "634", "ref_c": [["int jump(int* nums, int numsSize){\\n    int l = 0;\\n    int r = numsSize - 1;\\n    int jumps = 0;\\n    \\n    while(r > 0){\\n        if(l + nums[l] >= r){\\n            r = l;\\n            jumps++;\\n            l = 0;\\n        }"], ["int jump(int* nums, int numsSize){\\n    int l = 0;\\n    int r = numsSize - 1;\\n    int jumps = 0;\\n    \\n    while(r > 0){\\n        if(l + nums[l] >= r){\\n            r = l;\\n            jumps++;\\n            l = 0;\\n        }"], ["int jump(int* nums, int numsSize){\\n    int l = 0;\\n    int r = numsSize - 1;\\n    int jumps = 0;\\n    \\n    while(r > 0){\\n        if(l + nums[l] >= r){\\n            r = l;\\n            jumps++;\\n            l = 0;\\n        }"]]}
{"id": "635", "ref_c": [["int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = 1;\\n    for(int i=1; i<=numsSize; i++) (*returnSize) *= i;\\n    *returnColumnSizes = (int*)malloc(*returnSize * sizeof(int)); \\n    *returnSize = 0;\\n    int **arr = (int**)malloc(sizeof(int*));\\n    backtrack(nums, numsSize, &arr, returnSize, returnColumnSizes, 0);\\n    return arr;\\n}"], ["int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\\n    int totalPermutations = 1;\\n    for (int i = 1; i <= numsSize; i++) {\\n        totalPermutations *= i;\\n    }"], ["int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\\n    int totalPermutations = 1;\\n    for (int i = 1; i <= numsSize; i++) {\\n        totalPermutations *= i;\\n    }"]]}
{"id": "636", "ref_c": [["int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int size = fact(numsSize);\\n\\n    int* counts = calloc(numsSize, sizeof(int));\\n    int* unique = calloc(numsSize, sizeof(int));\\n    int** ret = malloc(size * sizeof(int*));\\n    int* data = malloc((numsSize) * sizeof(int));\\n    *returnColumnSizes = malloc(size * sizeof(int));\\n    *returnSize = 0;\\n\\n    int idx = 1;\\n    unique[0] = nums[0];\\n    counts[0] = 1;\\n\\n    for(int i = 1; i < numsSize; i++) {\\n        if(nums[i] == nums[i-1]) {\\n            counts[idx-1]++;\\n        }"], ["int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    * returnColumnSizes = NULL;\\n    * returnSize = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), cmpfn);\\n\\n    int count = 1;\\n    int denom = 1;\\n    for (int i = 0; i < numsSize; i++)\\n    { \\n        if (i+1 < numsSize && (nums[i] == nums[i+1]))\\n            count++;\\n        else\\n        {\\n            denom *= factorial(count);\\n            count = 1;\\n        }"], ["int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    * returnColumnSizes = NULL;\\n    * returnSize = 0;\\n\\n    qsort(nums, numsSize, sizeof(int), cmpfn);\\n\\n    return permuteInt(nums, numsSize, returnSize, returnColumnSizes, numsSize);\\n}"]]}
{"id": "637", "ref_c": [["void rotate(int** matrix, int matrixSize, int* matrixColSize){\\n    // Swap process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        for(int col = row; col < matrixSize; col++) {\\n            int tmp = matrix[row][col];\\n            matrix[row][col] = matrix[col][row];\\n            matrix[col][row] = tmp;\\n        }"], ["void rotate(int** matrix, int matrixSize, int* matrixColSize){\\n    // Swap process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        for(int col = row; col < matrixSize; col++) {\\n            int tmp = matrix[row][col];\\n            matrix[row][col] = matrix[col][row];\\n            matrix[col][row] = tmp;\\n        }"], ["void rotate(int** matrix, int matrixSize, int* matrixColSize){\\n    // Swap process..\\n    for(int row = 0; row < matrixSize; row++) {\\n        for(int col = row; col < matrixSize; col++) {\\n            int tmp = matrix[row][col];\\n            matrix[row][col] = matrix[col][row];\\n            matrix[col][row] = tmp;\\n        }"]]}
{"id": "638", "ref_c": ["\nstruct word {\n    char sorted[256];\n    char s[256];\n    UT_hash_handle hh;\n};\n\nint comp(const void *aa, const void *bb)\n{\n    char a, b;\n    a = *(char *)aa;\n    b = *(char *)bb;\n    \n    if (a < b)\n        return -1;\n    else if (a > b)\n        return 1;\n    else\n        return 0;\n}\n\nchar *sort_string(char *s)\n{\n    char *rs = malloc(strlen(s)+1);\n    assert(rs);\n    strcpy(rs, s);\n    qsort((void *)rs, strlen(rs), 1, comp);\n    return rs;\n}\n\nint word_sort(struct word *a, struct word *b) {\n    return strcmp(a->sorted,b->sorted);\n}\n\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\n    struct word *w, *tmp;\n    int i;\n    struct word *words = NULL;\n    \n    for (i = 0; i < strsSize; i++) {\n        char *sorted = sort_string(strs[i]);\n        w = (struct word *)malloc(sizeof *w);\n        strncpy(w->sorted, sorted, 256);\n        strncpy(w->s, strs[i], 256);\n        HASH_ADD_STR( words, sorted, w );\n        free(sorted);\n    }\n    \n    char ***ret = malloc(strsSize * sizeof(char *));\n    int *retcolsizes = malloc(strsSize * sizeof(int));\n    *returnColumnSizes = retcolsizes;\n    assert(*returnColumnSizes);\n    assert(ret);\n    \n    *returnSize = -1;\n    char *anagram = NULL;\n    \n    /* XXX: what we would like is something like (python):\n     *      return dic.values();\n     * I know its C, but there has to be a better way.\n     */\n    HASH_SORT(words, word_sort);\n    HASH_ITER(hh, words, w, tmp) {\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n        } else {\n            *returnSize += 1;\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\n            assert(ret[*returnSize]);\n            retcolsizes[*returnSize] = 0;\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n            anagram = w->sorted;\n        }\n    }\n    \n    /* XXX: we are leaking a bunch of memory for the struct word's*/\n    *returnSize += 1;\n    return ret;\n}\n", "\nstruct word {\n    char sorted[256];\n    char s[256];\n    UT_hash_handle hh;\n};\n\nint comp(const void *aa, const void *bb)\n{\n    char a, b;\n    a = *(char *)aa;\n    b = *(char *)bb;\n    \n    if (a < b)\n        return -1;\n    else if (a > b)\n        return 1;\n    else\n        return 0;\n}\n\nchar *sort_string(char *s)\n{\n    char *rs = malloc(strlen(s)+1);\n    assert(rs);\n    strcpy(rs, s);\n    qsort((void *)rs, strlen(rs), 1, comp);\n    return rs;\n}\n\nint word_sort(struct word *a, struct word *b) {\n    return strcmp(a->sorted,b->sorted);\n}\n\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\n    struct word *w, *tmp;\n    int i;\n    struct word *words = NULL;\n    \n    for (i = 0; i < strsSize; i++) {\n        char *sorted = sort_string(strs[i]);\n        w = (struct word *)malloc(sizeof *w);\n        strncpy(w->sorted, sorted, 256);\n        strncpy(w->s, strs[i], 256);\n        HASH_ADD_STR( words, sorted, w );\n        free(sorted);\n    }\n    \n    char ***ret = malloc(strsSize * sizeof(char *));\n    int *retcolsizes = malloc(strsSize * sizeof(int));\n    *returnColumnSizes = retcolsizes;\n    assert(*returnColumnSizes);\n    assert(ret);\n    \n    *returnSize = -1;\n    char *anagram = NULL;\n    \n    /* XXX: what we would like is something like (python):\n     *      return dic.values();\n     * I know its C, but there has to be a better way.\n     */\n    HASH_SORT(words, word_sort);\n    HASH_ITER(hh, words, w, tmp) {\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n        } else {\n            *returnSize += 1;\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\n            assert(ret[*returnSize]);\n            retcolsizes[*returnSize] = 0;\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n            anagram = w->sorted;\n        }\n    }\n    \n    /* XXX: we are leaking a bunch of memory for the struct word's*/\n    *returnSize += 1;\n    return ret;\n}\n", "\nstruct word {\n    char sorted[256];\n    char s[256];\n    UT_hash_handle hh;\n};\n\nint comp(const void *aa, const void *bb)\n{\n    char a, b;\n    a = *(char *)aa;\n    b = *(char *)bb;\n    \n    if (a < b)\n        return -1;\n    else if (a > b)\n        return 1;\n    else\n        return 0;\n}\n\nchar *sort_string(char *s)\n{\n    char *rs = malloc(strlen(s)+1);\n    assert(rs);\n    strcpy(rs, s);\n    qsort((void *)rs, strlen(rs), 1, comp);\n    return rs;\n}\n\nint word_sort(struct word *a, struct word *b) {\n    return strcmp(a->sorted,b->sorted);\n}\n\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\n    struct word *w, *tmp;\n    int i;\n    struct word *words = NULL;\n    \n    for (i = 0; i < strsSize; i++) {\n        char *sorted = sort_string(strs[i]);\n        w = (struct word *)malloc(sizeof *w);\n        strncpy(w->sorted, sorted, 256);\n        strncpy(w->s, strs[i], 256);\n        HASH_ADD_STR( words, sorted, w );\n        free(sorted);\n    }\n    \n    char ***ret = malloc(strsSize * sizeof(char *));\n    int *retcolsizes = malloc(strsSize * sizeof(int));\n    *returnColumnSizes = retcolsizes;\n    assert(*returnColumnSizes);\n    assert(ret);\n    \n    *returnSize = -1;\n    char *anagram = NULL;\n    \n    /* XXX: what we would like is something like (python):\n     *      return dic.values();\n     * I know its C, but there has to be a better way.\n     */\n    HASH_SORT(words, word_sort);\n    HASH_ITER(hh, words, w, tmp) {\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n        } else {\n            *returnSize += 1;\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\n            assert(ret[*returnSize]);\n            retcolsizes[*returnSize] = 0;\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n            anagram = w->sorted;\n        }\n    }\n    \n    /* XXX: we are leaking a bunch of memory for the struct word's*/\n    *returnSize += 1;\n    return ret;\n}\n"]}
{"id": "639", "ref_c": [["double myPow(double x, int n){\\n    return pow(x,n);\\n}", "double myPow(double x, int n) {\\n        return pow(x,n);\\n    }", "double myPow(double x, int n) {\\n      return Math.pow(x,n);\\n    }"], ["double myPow(double x, int n) {\\n    long N = n;\\n    return pow2(x, N);\\n}"], ["double myPow(double x, int n) {\\n    long N = n;\\n    return pow2(x, N);\\n}"]]}
{"id": "640", "ref_c": [["int maxSubArray(int* nums, int numsSize){\\n    // Initialize maxSum as an integer that cannot store any value below the limit...\\n    int maxSum = nums[0];\\n    // Initialize maxSum...\\n    int maxSumSoFar = 0;\\n    // Traverse all the element through the loop...\\n    for(int i = 0; i < numsSize; i++){\\n        // Keep adding the current value...\\n        maxSumSoFar += nums[i];\\n        // Update maxSum to maxSum and maxSumSoFar...\\n        if(maxSum < maxSumSoFar){\\n            maxSum = maxSumSoFar;\\n        }"], ["int maxSubArray(int* nums, int numsSize){\\n    // Initialize maxSum as an integer that cannot store any value below the limit...\\n    int maxSum = nums[0];\\n    // Initialize maxSum...\\n    int maxSumSoFar = 0;\\n    // Traverse all the element through the loop...\\n    for(int i = 0; i < numsSize; i++){\\n        // Keep adding the current value...\\n        maxSumSoFar += nums[i];\\n        // Update maxSum to maxSum and maxSumSoFar...\\n        if(maxSum < maxSumSoFar){\\n            maxSum = maxSumSoFar;\\n        }"], ["int maxSubArray(int* nums, int numsSize){\\n    // Initialize maxSum as an integer that cannot store any value below the limit...\\n    int maxSum = nums[0];\\n    // Initialize maxSum...\\n    int maxSumSoFar = 0;\\n    // Traverse all the element through the loop...\\n    for(int i = 0; i < numsSize; i++){\\n        // Keep adding the current value...\\n        maxSumSoFar += nums[i];\\n        // Update maxSum to maxSum and maxSumSoFar...\\n        if(maxSum < maxSumSoFar){\\n            maxSum = maxSumSoFar;\\n        }"]]}
{"id": "641", "ref_c": ["\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\n    int m = matrixSize;\n    int n = *matrixColSize;\n    int totalElements = m * n;\n    int* ans = (int*)malloc(totalElements * sizeof(int));\n    *returnSize = totalElements;\n\n    int left = 0, right = n - 1, top = 0, bottom = m - 1;\n    int index = 0;\n\n    while (index < totalElements && top<=bottom && left<=right) {\n        // Traverse from left to right\n        for (int i = left; i <= right && index < totalElements; i++) {\n            ans[index++] = matrix[top][i];\n        }\n        top++;\n\n        // Traverse from top to bottom\n        for (int i = top; i <= bottom && index < totalElements; i++) {\n            ans[index++] = matrix[i][right];\n        }\n        right--;\n    if(top<=bottom)\n       { // Traverse from right to left\n        for (int i = right; i >= left && index < totalElements; i--) {\n            ans[index++] = matrix[bottom][i];\n        }\n        bottom--;\n       }\n    if(left<=right)\n    {\n        // Traverse from bottom to top\n        for (int i = bottom; i >= top && index < totalElements; i--) {\n            ans[index++] = matrix[i][left];\n        }\n        left++;\n    }\n    }\n    return ans;\n}\n\n", "\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\n    int m = matrixSize;\n    int n = *matrixColSize;\n    int totalElements = m * n;\n    int* ans = (int*)malloc(totalElements * sizeof(int));\n    *returnSize = totalElements;\n\n    int left = 0, right = n - 1, top = 0, bottom = m - 1;\n    int index = 0;\n\n    while (index < totalElements && top<=bottom && left<=right) {\n        // Traverse from left to right\n        for (int i = left; i <= right && index < totalElements; i++) {\n            ans[index++] = matrix[top][i];\n        }\n        top++;\n\n        // Traverse from top to bottom\n        for (int i = top; i <= bottom && index < totalElements; i++) {\n            ans[index++] = matrix[i][right];\n        }\n        right--;\n    if(top<=bottom)\n       { // Traverse from right to left\n        for (int i = right; i >= left && index < totalElements; i--) {\n            ans[index++] = matrix[bottom][i];\n        }\n        bottom--;\n       }\n    if(left<=right)\n    {\n        // Traverse from bottom to top\n        for (int i = bottom; i >= top && index < totalElements; i--) {\n            ans[index++] = matrix[i][left];\n        }\n        left++;\n    }\n    }\n    return ans;\n}\n\n", "\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\n    int m = matrixSize;\n    int n = *matrixColSize;\n    int totalElements = m * n;\n    int* ans = (int*)malloc(totalElements * sizeof(int));\n    *returnSize = totalElements;\n\n    int left = 0, right = n - 1, top = 0, bottom = m - 1;\n    int index = 0;\n\n    while (index < totalElements && top<=bottom && left<=right) {\n        // Traverse from left to right\n        for (int i = left; i <= right && index < totalElements; i++) {\n            ans[index++] = matrix[top][i];\n        }\n        top++;\n\n        // Traverse from top to bottom\n        for (int i = top; i <= bottom && index < totalElements; i++) {\n            ans[index++] = matrix[i][right];\n        }\n        right--;\n    if(top<=bottom)\n       { // Traverse from right to left\n        for (int i = right; i >= left && index < totalElements; i--) {\n            ans[index++] = matrix[bottom][i];\n        }\n        bottom--;\n       }\n    if(left<=right)\n    {\n        // Traverse from bottom to top\n        for (int i = bottom; i >= top && index < totalElements; i--) {\n            ans[index++] = matrix[i][left];\n        }\n        left++;\n    }\n    }\n    return ans;\n}\n\n"]}
{"id": "642", "ref_c": [["bool canJump(int* nums, int numsSize) {\\n    int maxi=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(i>maxi) return false;\\n        if(maxi<i+nums[i]) maxi=i+nums[i];\\n        if(maxi>=numsSize-1)  return true;\\n        \\n    }"], ["bool canJump(int* nums, int numsSize){\\n     int zero=0;\\n     int len=1;\\n   int mark=1;\\n     for(int i=numsSize-1;i>=0;i--){\\n        if(nums[i]==0){\\n        if(i==numsSize-1) mark=0;\\n        zero++;\\n       len++;\\n        }"], ["bool canJump(int* nums, int numsSize){\\n    int jump = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (jump < i) {\\n            break;\\n        }"]]}
{"id": "643", "ref_c": [["int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\\n    qsort(intervals,intervalsSize,sizeof(int*),comp);\\n\\n    int** stack = (int**)malloc(sizeof(int*)*intervalsSize);\\n    stack[0] = intervals[0];\\n    int top = 1;\\n    for(int i = 1;i < intervalsSize;i++){\\n        if(intervals[i][0] <= stack[top-1][1]){\\n            stack[top-1][1] = intervals[i][1]>stack[top-1][1]?intervals[i][1]:stack[top-1][1];\\n        }"], ["int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\\n    qsort(intervals,intervalsSize,sizeof(int*),comp);\\n\\n    int** stack = (int**)malloc(sizeof(int*)*intervalsSize);\\n    stack[0] = intervals[0];\\n    int top = 1;\\n    for(int i = 1;i < intervalsSize;i++){\\n        if(intervals[i][0] <= stack[top-1][1]){\\n            stack[top-1][1] = intervals[i][1]>stack[top-1][1]?intervals[i][1]:stack[top-1][1];\\n        }"], ["int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\\n    qsort(intervals,intervalsSize,sizeof(int*),comp);\\n\\n    int** stack = (int**)malloc(sizeof(int*)*intervalsSize);\\n    stack[0] = intervals[0];\\n    int top = 1;\\n    for(int i = 1;i < intervalsSize;i++){\\n        if(intervals[i][0] <= stack[top-1][1]){\\n            stack[top-1][1] = intervals[i][1]>stack[top-1][1]?intervals[i][1]:stack[top-1][1];\\n        }"]]}
{"id": "644", "ref_c": [["int** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  intervals,\\n     *  intervalsSize\\n     *  intervalsColSize\\n     *  newInterval\\n     *  newIntervalSize\\n     */\\n     \\n    int seg_start = newInterval[0], seg_end = newInterval[1];\\n    int **ans = (int **)malloc(sizeof(int *) * (intervalsSize + 1));\\n    int **tmp = (int **)malloc(sizeof(int *) * (intervalsSize + 1));\\n    (*returnColumnSizes) = (int *)malloc(sizeof(int) * (intervalsSize + 1));\\n    \\n    *returnSize = 0;\\n    \\n    /* Copy intervals to tmp buffer */\\n    for (int i = 0; i < intervalsSize; i++) {\\n        tmp[i] = (int *)malloc(sizeof(int) * 2);\\n        tmp[i][0] = intervals[i][0];\\n        tmp[i][1] = intervals[i][1];\\n    }"], ["int** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes){\\n    int** ans = malloc((intervalsSize+1) * sizeof(int*));\\n    *returnColumnSizes = malloc((intervalsSize+1) * sizeof(int));\\n    \\n    *returnSize = 0;\\n\\n    for (int i = 0; i < intervalsSize; ++i) {\\n        int lo = intervals[i][0];\\n        int hi = intervals[i][1];\\n\\n        if (newInterval[1] < lo) {\\n            pushinterval(ans, returnSize, returnColumnSizes, newInterval[0], newInterval[1]);\\n            newInterval = intervals[i];\\n        }"], ["int** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes){\\n    int** ans = malloc((intervalsSize+1) * sizeof(int*));\\n    *returnColumnSizes = malloc((intervalsSize+1) * sizeof(int));\\n    \\n    *returnSize = 0;\\n\\n    for (int i = 0; i < intervalsSize; ++i) {\\n        int lo = intervals[i][0];\\n        int hi = intervals[i][1];\\n\\n        if (newInterval[1] < lo) {\\n            pushinterval(ans, returnSize, returnColumnSizes, newInterval[0], newInterval[1]);\\n            newInterval = intervals[i];\\n        }"]]}
{"id": "645", "ref_c": [["int** generateMatrix(int n, int* returnSize, int** returnColumnSizes){\\n    int** data = (int**)malloc(n * sizeof(int*));\\n    for (int i = 0; i < n; i++) {\\n        data[i] = (int*)malloc(n * sizeof(int));\\n    }"], ["int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }"], ["int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }"]]}
{"id": "646", "ref_c": [["struct ListNode* rotateRight(struct ListNode* head, int k){\\n        if (head == NULL || k == 0)\\n\\t\\treturn head;\\n    int length = GetLength(head);\\n\\n\\tif (length == 1)\\n\\t\\treturn head;\\n    for(int i=0;i<k%length;i++)\\n    {\\n        struct ListNode *p=head;\\n        while(p->next->next!=NULL)\\n        {\\n            p=p->next;\\n        }"], ["struct ListNode* rotateRight(struct ListNode* head, int k)\\n{\\n    if(head==NULL||head->next==NULL)\\n    {\\n        return(head);\\n    }"], ["struct ListNode* rotateRight(struct ListNode* head, int k)\\n{\\n    if(head==NULL||head->next==NULL)\\n    {\\n        return(head);\\n    }"]]}
{"id": "647", "ref_c": [["int uniquePaths(int m, int n){\\n    memset(memo, -1, sizeof(memo));\\n    return getRoutes(0, 0, m, n);\\n}"], ["int uniquePaths(int m, int n){\\n int row[m]; int col[n];\\n  for(int i=0;i<n;i++) col[i]=1;\\n  for(int i=0;i<m;i++) row[i]=1;\\n  for(int i=1;i<m;i++){\\n      for(int j=1;j<n;j++){\\n          col[j]=col[j]+row[i];\\n          row[i]=col[j];\\n      }"], ["int uniquePaths(int m, int n) {\\n        return find ( m-1 ,n-1 );\\n    }", "int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return find(m-1,n-1,dp);\\n    }", "int uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    int dp [m] [n];   \\n\\tfor (int i=0; i<m; i++){\\n        for (int j=0 ;j<n ;j++){\\n            if ( i==0 || j==0 ) dp[i][j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=dp [i-1] [j];\\n                int u=0;\\n                if(j>0) u=dp [i] [j-1];                       \\n                dp [i] [j] =l+u;\\n                }", "int uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    vector<int> prev(n,0);\\n    for(int i=0;i<m;i++){\\n        vector<int>curr(n,0);\\n        for(int j=0;j<n;j++){\\n            if(i==0||j==0) curr[j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=prev[j];\\n                int u=0;\\n                if(j>0) u=curr[j-1];                       \\n                curr[j]=l+u;\\n                }"]]}
{"id": "648", "ref_c": [["int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize){\\n    \\n    for(int i = 0; i < obstacleGridSize; i++) {\\n        for(int j = 0; j < *obstacleGridColSize; j++) {\\n            if(obstacleGrid[i][j]) {\\n                obstacleGrid[i][j] = 0;\\n            }"], ["int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize){\\n      int dp[obstacleGridSize][*obstacleGridColSize];\\n      int fg=0;\\n      for(int i=0;i<obstacleGridSize;i++){\\n         if(obstacleGrid[i][0]==0 && fg==0) {dp[i][0]=1;}"], ["int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize){\\n    \\n    for(int i = 0; i < obstacleGridSize; i++) {\\n        for(int j = 0; j < *obstacleGridColSize; j++) {\\n            if(obstacleGrid[i][j]) {\\n                obstacleGrid[i][j] = 0;\\n            }"]]}
{"id": "649", "ref_c": [["int minPathSum(int** grid, int gridSize, int* gridColSize) {\\n    int **dp = (int *)malloc(gridSize*sizeof(int *));\\n    for(int i=0; i<gridSize; i++){\\n        dp[i] = (int *)malloc(gridColSize[0]*sizeof(int));\\n        dp[0][0] = grid[0][0];\\n        if(i>0){\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }"], ["int minPathSum(int** grid, int gridSize, int* gridColSize){\\n    int i, j;\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    \\n    for(i=0;i<m;i++){\\n        for(j=0;j<n;j++){\\n            if(i>0 && j>0)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            else if(i>0)\\n                grid[i][j] += grid[i-1][j];\\n            else if(j>0)\\n                grid[i][j] += grid[i][j-1];\\n        }"], ["int minPathSum(int** grid, int gridSize, int* gridColSize) {\\n    int **dp = (int *)malloc(gridSize*sizeof(int *));\\n    for(int i=0; i<gridSize; i++){\\n        dp[i] = (int *)malloc(gridColSize[0]*sizeof(int));\\n        dp[0][0] = grid[0][0];\\n        if(i>0){\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }"]]}
{"id": "650", "ref_c": ["\nchar * simplifyPath(char * path){\nchar *ans=(char*)malloc(sizeof(char)*(strlen(path)+1));\nint k=-1;\nans[++k]='/';\nfor(int i=1;i<strlen(path);i++)\n{\n  if(path[i]=='/')\n  {\n      if(ans[k]=='/')\n      continue;\n      else\n      ans[++k]='/';\n  }\n  else if(path[i]=='.'&&path[i-1]=='/') \n  {\n      int j=i;\n      int count=0;\n      while(i<strlen(path)&&path[i]=='.')\n      {\n          count++;\n          i++;\n      }\n      if(count==1&&(path[i]=='/'||i==strlen(path)))\n      {\n          continue;\n      }\n      else if(count==2&&(path[i]=='/'||i==strlen(path)))\n      {\n          if(k>0)k--;\n          while(k>0&&ans[k]!='/')\n          k--;\n      }\n      else {\n      while(j<i)\n      {\n          ans[++k]=path[j];\n          j++;\n      }\n      if(i<strlen(path))\n      ans[++k]=path[i];\n      }\n      \n  }\n  else\n  {\n      ans[++k]=path[i];\n  }\n}\nif(k!=0 && ans[k]=='/')\nans[k]='\u0000';\nelse\nans[++k]='\u0000';\nreturn ans;\n}\n", "\nchar * simplifyPath(char * path){\nchar *ans=(char*)malloc(sizeof(char)*(strlen(path)+1));\nint k=-1;\nans[++k]='/';\nfor(int i=1;i<strlen(path);i++)\n{\n  if(path[i]=='/')\n  {\n      if(ans[k]=='/')\n      continue;\n      else\n      ans[++k]='/';\n  }\n  else if(path[i]=='.'&&path[i-1]=='/') \n  {\n      int j=i;\n      int count=0;\n      while(i<strlen(path)&&path[i]=='.')\n      {\n          count++;\n          i++;\n      }\n      if(count==1&&(path[i]=='/'||i==strlen(path)))\n      {\n          continue;\n      }\n      else if(count==2&&(path[i]=='/'||i==strlen(path)))\n      {\n          if(k>0)k--;\n          while(k>0&&ans[k]!='/')\n          k--;\n      }\n      else {\n      while(j<i)\n      {\n          ans[++k]=path[j];\n          j++;\n      }\n      if(i<strlen(path))\n      ans[++k]=path[i];\n      }\n      \n  }\n  else\n  {\n      ans[++k]=path[i];\n  }\n}\nif(k!=0 && ans[k]=='/')\nans[k]='\u0000';\nelse\nans[++k]='\u0000';\nreturn ans;\n}\n", "\nchar * simplifyPath(char * path){\nchar *ans=(char*)malloc(sizeof(char)*(strlen(path)+1));\nint k=-1;\nans[++k]='/';\nfor(int i=1;i<strlen(path);i++)\n{\n  if(path[i]=='/')\n  {\n      if(ans[k]=='/')\n      continue;\n      else\n      ans[++k]='/';\n  }\n  else if(path[i]=='.'&&path[i-1]=='/') \n  {\n      int j=i;\n      int count=0;\n      while(i<strlen(path)&&path[i]=='.')\n      {\n          count++;\n          i++;\n      }\n      if(count==1&&(path[i]=='/'||i==strlen(path)))\n      {\n          continue;\n      }\n      else if(count==2&&(path[i]=='/'||i==strlen(path)))\n      {\n          if(k>0)k--;\n          while(k>0&&ans[k]!='/')\n          k--;\n      }\n      else {\n      while(j<i)\n      {\n          ans[++k]=path[j];\n          j++;\n      }\n      if(i<strlen(path))\n      ans[++k]=path[i];\n      }\n      \n  }\n  else\n  {\n      ans[++k]=path[i];\n  }\n}\nif(k!=0 && ans[k]=='/')\nans[k]='\u0000';\nelse\nans[++k]='\u0000';\nreturn ans;\n}\n"]}
{"id": "651", "ref_c": ["\nint dp[501][501];\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n \nint minDist(char *w1, char *w2, int idx1, int idx2, int len1, int len2)\n{\n    int tmp1, tmp2;\n\n    if (w1[idx1] == 0 && w2[idx2] == 0) {\n        return 0;\n    }\n    /* Reach the end of word1 */\n    else if (w1[idx1] == 0) {\n        tmp1 = len2 - idx2;\n    }\n    /* Reach the end of word2 */\n    else if (w2[idx2] == 0) {\n        tmp1 = len1 - idx1;\n    }\n    else {\n        if (dp[idx1][idx2] != -1) {\n            return dp[idx1][idx2];\n        }\n\n        /* No modification is required */\n        if (w1[idx1] == w2[idx2]) {\n            tmp1 = minDist(w1, w2, idx1 + 1, idx2 + 1, len1, len2);\n        }\n        /* Considering delete, insert or modify the character */\n        else {\n            /* Delete character from w1 */\n            tmp1 = 1 + minDist(w1, w2, idx1 + 1, idx2, len1, len2);\n            \n            /* Insert character into w1 */\n            tmp2 = 1 + minDist(w1, w2, idx1, idx2 + 1, len1, len2);\n            \n            tmp1 = MIN(tmp1, tmp2);\n            \n            /* Modify character of w1 */\n            tmp2 = 1 + minDist(w1, w2, idx1 + 1, idx2 + 1, len1, len2);\n            \n            tmp1 = MIN(tmp1, tmp2);\n        }\n    }\n\n    dp[idx1][idx2] = tmp1;\n\n    return tmp1;\n}\n\nint minDistance(char * word1, char * word2){\n    /*\n     * Input:\n     *  word1, string\n     *  word2, string\n     */\n     \n    int len1 = strlen(word1);\n    int len2 = strlen(word2);\n     \n    for (int i = 0; i < len1; i++) {\n        for (int j = 0; j < len2; j++) {\n            dp[i][j] = -1;\n        }\n    }\n     \n    /*\n     * Output:\n     *  return the minimum number of operations \n     *  required to convert word1 to word2\n     */\n     \n    return minDist(word1, word2, 0, 0, len1, len2);\n}\n", "\nint dp[501][501];\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n \nint minDist(char *w1, char *w2, int idx1, int idx2, int len1, int len2)\n{\n    int tmp1, tmp2;\n\n    if (w1[idx1] == 0 && w2[idx2] == 0) {\n        return 0;\n    }\n    /* Reach the end of word1 */\n    else if (w1[idx1] == 0) {\n        tmp1 = len2 - idx2;\n    }\n    /* Reach the end of word2 */\n    else if (w2[idx2] == 0) {\n        tmp1 = len1 - idx1;\n    }\n    else {\n        if (dp[idx1][idx2] != -1) {\n            return dp[idx1][idx2];\n        }\n\n        /* No modification is required */\n        if (w1[idx1] == w2[idx2]) {\n            tmp1 = minDist(w1, w2, idx1 + 1, idx2 + 1, len1, len2);\n        }\n        /* Considering delete, insert or modify the character */\n        else {\n            /* Delete character from w1 */\n            tmp1 = 1 + minDist(w1, w2, idx1 + 1, idx2, len1, len2);\n            \n            /* Insert character into w1 */\n            tmp2 = 1 + minDist(w1, w2, idx1, idx2 + 1, len1, len2);\n            \n            tmp1 = MIN(tmp1, tmp2);\n            \n            /* Modify character of w1 */\n            tmp2 = 1 + minDist(w1, w2, idx1 + 1, idx2 + 1, len1, len2);\n            \n            tmp1 = MIN(tmp1, tmp2);\n        }\n    }\n\n    dp[idx1][idx2] = tmp1;\n\n    return tmp1;\n}\n\nint minDistance(char * word1, char * word2){\n    /*\n     * Input:\n     *  word1, string\n     *  word2, string\n     */\n     \n    int len1 = strlen(word1);\n    int len2 = strlen(word2);\n     \n    for (int i = 0; i < len1; i++) {\n        for (int j = 0; j < len2; j++) {\n            dp[i][j] = -1;\n        }\n    }\n     \n    /*\n     * Output:\n     *  return the minimum number of operations \n     *  required to convert word1 to word2\n     */\n     \n    return minDist(word1, word2, 0, 0, len1, len2);\n}\n", "\nint dp[501][501];\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n \nint minDist(char *w1, char *w2, int idx1, int idx2, int len1, int len2)\n{\n    int tmp1, tmp2;\n\n    if (w1[idx1] == 0 && w2[idx2] == 0) {\n        return 0;\n    }\n    /* Reach the end of word1 */\n    else if (w1[idx1] == 0) {\n        tmp1 = len2 - idx2;\n    }\n    /* Reach the end of word2 */\n    else if (w2[idx2] == 0) {\n        tmp1 = len1 - idx1;\n    }\n    else {\n        if (dp[idx1][idx2] != -1) {\n            return dp[idx1][idx2];\n        }\n\n        /* No modification is required */\n        if (w1[idx1] == w2[idx2]) {\n            tmp1 = minDist(w1, w2, idx1 + 1, idx2 + 1, len1, len2);\n        }\n        /* Considering delete, insert or modify the character */\n        else {\n            /* Delete character from w1 */\n            tmp1 = 1 + minDist(w1, w2, idx1 + 1, idx2, len1, len2);\n            \n            /* Insert character into w1 */\n            tmp2 = 1 + minDist(w1, w2, idx1, idx2 + 1, len1, len2);\n            \n            tmp1 = MIN(tmp1, tmp2);\n            \n            /* Modify character of w1 */\n            tmp2 = 1 + minDist(w1, w2, idx1 + 1, idx2 + 1, len1, len2);\n            \n            tmp1 = MIN(tmp1, tmp2);\n        }\n    }\n\n    dp[idx1][idx2] = tmp1;\n\n    return tmp1;\n}\n\nint minDistance(char * word1, char * word2){\n    /*\n     * Input:\n     *  word1, string\n     *  word2, string\n     */\n     \n    int len1 = strlen(word1);\n    int len2 = strlen(word2);\n     \n    for (int i = 0; i < len1; i++) {\n        for (int j = 0; j < len2; j++) {\n            dp[i][j] = -1;\n        }\n    }\n     \n    /*\n     * Output:\n     *  return the minimum number of operations \n     *  required to convert word1 to word2\n     */\n     \n    return minDist(word1, word2, 0, 0, len1, len2);\n}\n"]}
{"id": "652", "ref_c": [["void setZeroes(int** matrix, int matrixSize, int* matrixColSize){\\n    int zero_x[200] = {0}"], ["void setZeroes(int** matrix, int matrixSize, int* matrixColSize){\\n    int zero_x[200] = {0}"], ["void setZeroes(int** matrix, int matrixSize, int* matrixColSize){\\n    int zero_x[200] = {0}"]]}
{"id": "653", "ref_c": [["bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {\\n     int n= matrixSize;\\n      int m = *matrixColSize;\\n      int start=0;\\n      int end=(n*m)-1;\\n      while(start<=end){\\n        int mid= start+(end-start)/2;\\n        int middle = matrix[mid/m][mid%m];\\n\\n//  Let take an example of first test case:dry run\\n// 1  3  5 7  \\n//10 11 16 20\\n//23 30 34 60 \\n\\n// Steps how this code working.\\n//1) n=3,m1=4,end=11,start=0,mid=5,middle=m[mid/m1][mid/m1]\\n//2) m[5/4][5%4]==m[1][1]==11 and it greater than the\\n // target so our end= mid-1= 5-1 ==4\\n//3) then  start=0,end=4 ,mid=2,middle=m[2/4][2%4]=m[0][2]=5\\n//4) middle>target again end=mid-1, start=0,end=1,mid=0,\\n//5) middle=m[0/4][0%4],middle=m[0][0]=1  then middle<target,\\n// 6)start=mid +1, we have start=1,end=1,mid=1,middle=m[1][1]=3\\n// 7) here middle==target return true...\\n            // simple binary search\\n        if(middle==target){\\n         return 1;\\n        }"], ["bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {\\n     int n= matrixSize;\\n      int m = *matrixColSize;\\n      int start=0;\\n      int end=(n*m)-1;\\n      while(start<=end){\\n        int mid= start+(end-start)/2;\\n        int middle = matrix[mid/m][mid%m];\\n\\n//  Let take an example of first test case:dry run\\n// 1  3  5 7  \\n//10 11 16 20\\n//23 30 34 60 \\n\\n// Steps how this code working.\\n//1) n=3,m1=4,end=11,start=0,mid=5,middle=m[mid/m1][mid/m1]\\n//2) m[5/4][5%4]==m[1][1]==11 and it greater than the\\n // target so our end= mid-1= 5-1 ==4\\n//3) then  start=0,end=4 ,mid=2,middle=m[2/4][2%4]=m[0][2]=5\\n//4) middle>target again end=mid-1, start=0,end=1,mid=0,\\n//5) middle=m[0/4][0%4],middle=m[0][0]=1  then middle<target,\\n// 6)start=mid +1, we have start=1,end=1,mid=1,middle=m[1][1]=3\\n// 7) here middle==target return true...\\n            // simple binary search\\n        if(middle==target){\\n         return 1;\\n        }"], ["bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {\\n     int n= matrixSize;\\n      int m = *matrixColSize;\\n      int start=0;\\n      int end=(n*m)-1;\\n      while(start<=end){\\n        int mid= start+(end-start)/2;\\n        int middle = matrix[mid/m][mid%m];\\n\\n//  Let take an example of first test case:dry run\\n// 1  3  5 7  \\n//10 11 16 20\\n//23 30 34 60 \\n\\n// Steps how this code working.\\n//1) n=3,m1=4,end=11,start=0,mid=5,middle=m[mid/m1][mid/m1]\\n//2) m[5/4][5%4]==m[1][1]==11 and it greater than the\\n // target so our end= mid-1= 5-1 ==4\\n//3) then  start=0,end=4 ,mid=2,middle=m[2/4][2%4]=m[0][2]=5\\n//4) middle>target again end=mid-1, start=0,end=1,mid=0,\\n//5) middle=m[0/4][0%4],middle=m[0][0]=1  then middle<target,\\n// 6)start=mid +1, we have start=1,end=1,mid=1,middle=m[1][1]=3\\n// 7) here middle==target return true...\\n            // simple binary search\\n        if(middle==target){\\n         return 1;\\n        }"]]}
{"id": "654", "ref_c": ["\nvoid shellSort(int a[],int length) {\n    int i, j, gap, temp;\n    for (gap = length / 2; gap > 0; gap /= 2){\n        for (i = gap; i < length; i++) {\n            // slide element i back by gap indexes, until it's \"in order\"\n            temp = a[i];\n            for (j = i; j >= gap; j =j-gap){\n                if(temp < a[j-gap]){\n                    a[j] = a[j-gap];\n                }\n                else{\n                    break;\n                }\n            }\n            a[j] = temp;\n        }\n    }\n}\nvoid sortColors(int* nums, int numsSize) {\n    int* nums1=(int*)malloc((numsSize+1)*sizeof(int));\n    nums1[0]=-1000;\n    for (int i = 1; i <= numsSize; i++) {\n        nums1[i] = nums[i - 1];\n    }\n    shellSort(nums1,numsSize+1);\n    for (int j = 0; j < numsSize; j++) {\n        nums[j] = nums1[j + 1];\n    }\n    for(int k=0;k<numsSize;k++)\n    {\n        printf(\"%d\",nums[k]);\n    }\n    \n}\n", "\nvoid shellSort(int a[],int length) {\n    int i, j, gap, temp;\n    for (gap = length / 2; gap > 0; gap /= 2){\n        for (i = gap; i < length; i++) {\n            // slide element i back by gap indexes, until it's \"in order\"\n            temp = a[i];\n            for (j = i; j >= gap; j =j-gap){\n                if(temp < a[j-gap]){\n                    a[j] = a[j-gap];\n                }\n                else{\n                    break;\n                }\n            }\n            a[j] = temp;\n        }\n    }\n}\nvoid sortColors(int* nums, int numsSize) {\n    int* nums1=(int*)malloc((numsSize+1)*sizeof(int));\n    nums1[0]=-1000;\n    for (int i = 1; i <= numsSize; i++) {\n        nums1[i] = nums[i - 1];\n    }\n    shellSort(nums1,numsSize+1);\n    for (int j = 0; j < numsSize; j++) {\n        nums[j] = nums1[j + 1];\n    }\n    for(int k=0;k<numsSize;k++)\n    {\n        printf(\"%d\",nums[k]);\n    }\n    \n}\n", "\nvoid shellSort(int a[],int length) {\n    int i, j, gap, temp;\n    for (gap = length / 2; gap > 0; gap /= 2){\n        for (i = gap; i < length; i++) {\n            // slide element i back by gap indexes, until it's \"in order\"\n            temp = a[i];\n            for (j = i; j >= gap; j =j-gap){\n                if(temp < a[j-gap]){\n                    a[j] = a[j-gap];\n                }\n                else{\n                    break;\n                }\n            }\n            a[j] = temp;\n        }\n    }\n}\nvoid sortColors(int* nums, int numsSize) {\n    int* nums1=(int*)malloc((numsSize+1)*sizeof(int));\n    nums1[0]=-1000;\n    for (int i = 1; i <= numsSize; i++) {\n        nums1[i] = nums[i - 1];\n    }\n    shellSort(nums1,numsSize+1);\n    for (int j = 0; j < numsSize; j++) {\n        nums[j] = nums1[j + 1];\n    }\n    for(int k=0;k<numsSize;k++)\n    {\n        printf(\"%d\",nums[k]);\n    }\n    \n}\n"]}
{"id": "655", "ref_c": [["int** combine(int n, int k, int* returnSize, int** returnColumnSizes){\\n    /*calculate total number of combinations*/\\n    /* n combinations of k */\\n    long long total = 1;\\n    for ( int i = 0; i < k; ++i )\\n        total *= ( n - i );\\n    for ( int i = 0; i < k; ++i )\\n        total /= (i+1);\\n    /*malloc*/\\n    bool arr[n+1];\\n    *returnSize = 0;\\n    *returnColumnSizes = (int *)malloc( sizeof(int)*total);\\n    int **output = (int **)malloc( sizeof(int *)*total);\\n    for ( int i = 0; i < total; ++i ) {\\n        (*returnColumnSizes)[i] = k;\\n        output[i] = (int *)malloc(sizeof(int) * k);\\n    }"], ["int** combine(int n, int k, int* returnSize, int** returnColumnSizes){\\n    /*calculate total number of combinations*/\\n    /* n combinations of k */\\n    long long total = 1;\\n    for ( int i = 0; i < k; ++i )\\n        total *= ( n - i );\\n    for ( int i = 0; i < k; ++i )\\n        total /= (i+1);\\n    /*malloc*/\\n    bool arr[n+1];\\n    *returnSize = 0;\\n    *returnColumnSizes = (int *)malloc( sizeof(int)*total);\\n    int **output = (int **)malloc( sizeof(int *)*total);\\n    for ( int i = 0; i < total; ++i ) {\\n        (*returnColumnSizes)[i] = k;\\n        output[i] = (int *)malloc(sizeof(int) * k);\\n    }"], ["int** combine(int n, int k, int* returnSize, int** returnColumnSizes){\\n    /*calculate total number of combinations*/\\n    /* n combinations of k */\\n    long long total = 1;\\n    for ( int i = 0; i < k; ++i )\\n        total *= ( n - i );\\n    for ( int i = 0; i < k; ++i )\\n        total /= (i+1);\\n    /*malloc*/\\n    bool arr[n+1];\\n    *returnSize = 0;\\n    *returnColumnSizes = (int *)malloc( sizeof(int)*total);\\n    int **output = (int **)malloc( sizeof(int *)*total);\\n    for ( int i = 0; i < total; ++i ) {\\n        (*returnColumnSizes)[i] = k;\\n        output[i] = (int *)malloc(sizeof(int) * k);\\n    }"]]}
{"id": "656", "ref_c": ["\nint** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n    if(!nums)\n        return NULL;\n    int total = 1<< numsSize;\n    int** ret = malloc(sizeof (int*) * total);\n    *returnSize = total;\n    *returnColumnSizes = malloc(sizeof(int) * total);\n    ret[0] = NULL;\n    (*returnColumnSizes)[0] = 0;\n    for(int i=1;i<total;i++){\n        int temp = i;\n        int count = 0;\n        while(temp){\n            count += temp%2;\n            temp /= 2;\n        }\n        (*returnColumnSizes)[i] = count;\n\n        ret[i] = malloc(sizeof(int)*count);\n        temp = i;\n        int ch = 0;\n        for(int j=0;j<count;j++){\n            while(temp%2!=1){\n                temp/=2;\n                ch++;\n            }\n            ret[i][j] = nums[ch];\n            ch++;\n            temp/=2;\n        }\n    }\n\n    return ret;\n}\n", "\nint** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n    if(!nums)\n        return NULL;\n    int total = 1<< numsSize;\n    int** ret = malloc(sizeof (int*) * total);\n    *returnSize = total;\n    *returnColumnSizes = malloc(sizeof(int) * total);\n    ret[0] = NULL;\n    (*returnColumnSizes)[0] = 0;\n    for(int i=1;i<total;i++){\n        int temp = i;\n        int count = 0;\n        while(temp){\n            count += temp%2;\n            temp /= 2;\n        }\n        (*returnColumnSizes)[i] = count;\n\n        ret[i] = malloc(sizeof(int)*count);\n        temp = i;\n        int ch = 0;\n        for(int j=0;j<count;j++){\n            while(temp%2!=1){\n                temp/=2;\n                ch++;\n            }\n            ret[i][j] = nums[ch];\n            ch++;\n            temp/=2;\n        }\n    }\n\n    return ret;\n}\n", "\nint** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n    if(!nums)\n        return NULL;\n    int total = 1<< numsSize;\n    int** ret = malloc(sizeof (int*) * total);\n    *returnSize = total;\n    *returnColumnSizes = malloc(sizeof(int) * total);\n    ret[0] = NULL;\n    (*returnColumnSizes)[0] = 0;\n    for(int i=1;i<total;i++){\n        int temp = i;\n        int count = 0;\n        while(temp){\n            count += temp%2;\n            temp /= 2;\n        }\n        (*returnColumnSizes)[i] = count;\n\n        ret[i] = malloc(sizeof(int)*count);\n        temp = i;\n        int ch = 0;\n        for(int j=0;j<count;j++){\n            while(temp%2!=1){\n                temp/=2;\n                ch++;\n            }\n            ret[i][j] = nums[ch];\n            ch++;\n            temp/=2;\n        }\n    }\n\n    return ret;\n}\n"]}
{"id": "657", "ref_c": ["\nchar *onechar(char **str,int boardSize, int* boardColSize)\n{\n    char *teststr = malloc(26 + 1);\n    int c = 0;\n    int p;\n    int n;\n\n    for (int i = 0;i < boardSize; i++)\n    {\n        for (int a  = 0; a < boardColSize[i]; a++)\n        {\n            p = 0;\n            n = 0;\n            while (teststr[n] != '\u0000')\n            {\n                if (teststr[n] == str[i][a])\n                {\n                    p = 1;\n                    break;\n                }\n                n++;\n            }\n            if (p == 0)\n            {\n                teststr[c] = str[i][a];\n                teststr[c + 1] = '\u0000';\n                c++;\n            }\n            \n        }\n    }\n    return (teststr);\n}\nint *chrlen(char **str,char *defstr,int boardSize, int* boardColSize,int strlen)\n{\n    int *chrln = malloc(strlen * sizeof(int));\n    for (int c = 0;c < strlen; c++)\n    {\n        chrln[c] = 0;\n        for (int i = 0;i < boardSize; i++)\n        {\n            for (int a  = 0; a < boardColSize[i]; a++)\n            {\n                if (str[i][a] == defstr[c])\n                    chrln[c] += 1;\n                \n            }\n        }\n    }\n    return (chrln);\n}\n\nbool exist(char** board, int boardSize, int* boardColSize, char * word)\n{\n    char *oneboard = onechar(board,boardSize,boardColSize);\n    int *zchrlen = chrlen(board,oneboard,boardSize,boardColSize,sizeof(oneboard));\n    int i;\n    int a;\n    int c;\n\n    i = 0; \n    while (word[i] != '\u0000')\n    {\n        a = 0;\n        c = 0;\n        while (oneboard[c] != '\u0000')\n        {\n            if (word[i] == oneboard[c] && zchrlen[c] > 0)\n            {\n                a = 1;\n                zchrlen[c] -= 1;\n                c++;\n                break;\n            }\n            c++;\n        }\n        if (a == 0)\n            return false;\n        i++;\n    }\n    return true;\n}\n", "\nchar *onechar(char **str,int boardSize, int* boardColSize)\n{\n    char *teststr = malloc(26 + 1);\n    int c = 0;\n    int p;\n    int n;\n\n    for (int i = 0;i < boardSize; i++)\n    {\n        for (int a  = 0; a < boardColSize[i]; a++)\n        {\n            p = 0;\n            n = 0;\n            while (teststr[n] != '\u0000')\n            {\n                if (teststr[n] == str[i][a])\n                {\n                    p = 1;\n                    break;\n                }\n                n++;\n            }\n            if (p == 0)\n            {\n                teststr[c] = str[i][a];\n                teststr[c + 1] = '\u0000';\n                c++;\n            }\n            \n        }\n    }\n    return (teststr);\n}\nint *chrlen(char **str,char *defstr,int boardSize, int* boardColSize,int strlen)\n{\n    int *chrln = malloc(strlen * sizeof(int));\n    for (int c = 0;c < strlen; c++)\n    {\n        chrln[c] = 0;\n        for (int i = 0;i < boardSize; i++)\n        {\n            for (int a  = 0; a < boardColSize[i]; a++)\n            {\n                if (str[i][a] == defstr[c])\n                    chrln[c] += 1;\n                \n            }\n        }\n    }\n    return (chrln);\n}\n\nbool exist(char** board, int boardSize, int* boardColSize, char * word)\n{\n    char *oneboard = onechar(board,boardSize,boardColSize);\n    int *zchrlen = chrlen(board,oneboard,boardSize,boardColSize,sizeof(oneboard));\n    int i;\n    int a;\n    int c;\n\n    i = 0; \n    while (word[i] != '\u0000')\n    {\n        a = 0;\n        c = 0;\n        while (oneboard[c] != '\u0000')\n        {\n            if (word[i] == oneboard[c] && zchrlen[c] > 0)\n            {\n                a = 1;\n                zchrlen[c] -= 1;\n                c++;\n                break;\n            }\n            c++;\n        }\n        if (a == 0)\n            return false;\n        i++;\n    }\n    return true;\n}\n", "\nchar *onechar(char **str,int boardSize, int* boardColSize)\n{\n    char *teststr = malloc(26 + 1);\n    int c = 0;\n    int p;\n    int n;\n\n    for (int i = 0;i < boardSize; i++)\n    {\n        for (int a  = 0; a < boardColSize[i]; a++)\n        {\n            p = 0;\n            n = 0;\n            while (teststr[n] != '\u0000')\n            {\n                if (teststr[n] == str[i][a])\n                {\n                    p = 1;\n                    break;\n                }\n                n++;\n            }\n            if (p == 0)\n            {\n                teststr[c] = str[i][a];\n                teststr[c + 1] = '\u0000';\n                c++;\n            }\n            \n        }\n    }\n    return (teststr);\n}\nint *chrlen(char **str,char *defstr,int boardSize, int* boardColSize,int strlen)\n{\n    int *chrln = malloc(strlen * sizeof(int));\n    for (int c = 0;c < strlen; c++)\n    {\n        chrln[c] = 0;\n        for (int i = 0;i < boardSize; i++)\n        {\n            for (int a  = 0; a < boardColSize[i]; a++)\n            {\n                if (str[i][a] == defstr[c])\n                    chrln[c] += 1;\n                \n            }\n        }\n    }\n    return (chrln);\n}\n\nbool exist(char** board, int boardSize, int* boardColSize, char * word)\n{\n    char *oneboard = onechar(board,boardSize,boardColSize);\n    int *zchrlen = chrlen(board,oneboard,boardSize,boardColSize,sizeof(oneboard));\n    int i;\n    int a;\n    int c;\n\n    i = 0; \n    while (word[i] != '\u0000')\n    {\n        a = 0;\n        c = 0;\n        while (oneboard[c] != '\u0000')\n        {\n            if (word[i] == oneboard[c] && zchrlen[c] > 0)\n            {\n                a = 1;\n                zchrlen[c] -= 1;\n                c++;\n                break;\n            }\n            c++;\n        }\n        if (a == 0)\n            return false;\n        i++;\n    }\n    return true;\n}\n"]}
{"id": "658", "ref_c": [["int removeDuplicates(int* nums, int numsSize){\\n    // Special case...\\n    if (numsSize <= 2)\\n        return numsSize;\\n    int prev = 1;       // point to previous\\n    int curr = 2;       // point to current\\n    // Traverse all elements through loop...\\n    while (curr < numsSize) {\\n        // If the curr index matches the previous two elements, skip it...\\n        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n            curr++;\\n        }"], ["int removeDuplicates(int* nums, int numsSize){\\n    // Special case...\\n    if (numsSize <= 2)\\n        return numsSize;\\n    int prev = 1;       // point to previous\\n    int curr = 2;       // point to current\\n    // Traverse all elements through loop...\\n    while (curr < numsSize) {\\n        // If the curr index matches the previous two elements, skip it...\\n        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n            curr++;\\n        }"], ["int removeDuplicates(int* nums, int numsSize){\\n    // Special case...\\n    if (numsSize <= 2)\\n        return numsSize;\\n    int prev = 1;       // point to previous\\n    int curr = 2;       // point to current\\n    // Traverse all elements through loop...\\n    while (curr < numsSize) {\\n        // If the curr index matches the previous two elements, skip it...\\n        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n            curr++;\\n        }"]]}
{"id": "659", "ref_c": [["bool search(int* nums, int numsSize, int target) {\\n    // Binary search \\n\\n    // Time complexity: O(n)\\n    // Space comeplxity: O(1)\\n\\n    int left = 0, right = numsSize - 1;\\n    while (left <= right) {\\n        const int middle = (left + right) / 2;\\n        if (target == nums[middle]) {\\n            return true;\\n        }"], ["bool search(int* nums, int numsSize, int target){\\n    //virtually splitting the arrays in two\\n    if(numsSize==1){\\n        return nums[0]==target;\\n    }"], ["bool search(int* nums, int numsSize, int target){\\n    //virtually splitting the arrays in two\\n    if(numsSize==1){\\n        return nums[0]==target;\\n    }"]]}
{"id": "660", "ref_c": [["struct ListNode* deleteDuplicates(struct ListNode* head){\\n    // create a fake node that acts like a fake head of list pointing to the original head...\\n    struct ListNode* fake = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    // fake node points to the original head...\\n    fake->next = head;\\n    struct ListNode* pre = fake;        //pointing to last node which has no duplicate...\\n    struct ListNode* curr = head;       // To traverse the linked list...\\n    // Now we traverse nodes and do the process...\\n    while (curr != NULL) {\\n        // Create a loop until the current and previous values are same, keep updating curr...\\n        while (curr->next != NULL && pre->next->val == curr->next->val)\\n            curr = curr->next;\\n        // if curr has non-duplicate value, move the pre pointer to next node...\\n        if (pre->next == curr)\\n            pre = pre->next;\\n        // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n        else\\n            pre->next = curr->next;\\n            // Move curr forward...\\n            // In next iteration, we still need to check whether curr points to duplicate value...\\n            curr = curr->next;\\n    }"], ["struct ListNode* deleteDuplicates(struct ListNode* head) {\\n   struct ListNode* temp = head,*prev = head;\\n   struct ListNode* t = NULL;\\n   while(temp!=NULL){\\n       if(temp->next!= NULL && temp->val == temp->next->val){\\n           t = temp;\\n           while(temp!= NULL && temp->val == t->val){\\n               temp = temp->next;\\n           }"], ["struct ListNode* deleteDuplicates(struct ListNode* head){\\n        struct ListNode *dummy = malloc(sizeof(struct ListNode));\\n        dummy->next = head;\\n        dummy->val = 0;\\n        struct ListNode *prev = dummy , *curr = head;\\n\\n        while(curr)\\n        {\\n            struct ListNode *next_node = curr->next;\\n            while(next_node && curr->val == next_node->val)\\n            {\\n                struct ListNode *temp = next_node->next;\\n                // delete next_node;\\n                next_node = temp;\\n            }"]]}
{"id": "661", "ref_c": [["struct ListNode* partition(struct ListNode* head, int x){\\n    if (head == NULL) return head;\\n    ListNode* smaller=(ListNode*)malloc(sizeof(ListNode)); \\n    smaller->val=0;\\n    ListNode* smallerTail=smaller; //Tail of the list with nodes <x\\n        \\n    ListNode* greater=(ListNode*)malloc(sizeof(ListNode));\\n    greater->val=0;\\n    ListNode* greaterTail=greater; //Tail of the list with nodes >=x\\n        \\n    ListNode* curr = head;\\n    while (curr) {//partition into greater & smaller lists\\n        if (curr->val < x) {\\n            smallerTail->next = curr;\\n            smallerTail =smallerTail->next;\\n        }"], ["struct ListNode* partition(struct ListNode* head, int x){\\n    struct ListNode* less = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    less->val = 0;\\n    less->next = NULL;\\n    \\n    struct ListNode* high = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    high->val = 0;\\n    high->next = NULL;\\n    \\n    struct ListNode* lessT = less;\\n    struct ListNode* highT = high;\\n    \\n    while(head){\\n        if(head->val < x){\\n            lessT->next = head;\\n            lessT = lessT->next;\\n        }"], ["struct ListNode* partition(struct ListNode* head, int x){\\n    struct ListNode* less = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    less->val = 0;\\n    less->next = NULL;\\n    \\n    struct ListNode* high = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    high->val = 0;\\n    high->next = NULL;\\n    \\n    struct ListNode* lessT = less;\\n    struct ListNode* highT = high;\\n    \\n    while(head){\\n        if(head->val < x){\\n            lessT->next = head;\\n            lessT = lessT->next;\\n        }"]]}
{"id": "662", "ref_c": [["int* grayCode(int n, int* returnSize){\\n    int s = pow(2,n);\\n    int* res = calloc(s, sizeof(int));\\n    for(int i=1; i<s; i++) res[i] = i^(i>>1);\\n    *returnSize = s;\\n    return res;\\n}"], ["int* grayCode(int n, int* returnSize){\\n    int s = pow(2,n);\\n    int* res = calloc(s, sizeof(int));\\n    for(int i=1; i<s; i++) res[i] = i^(i>>1);\\n    *returnSize = s;\\n    return res;\\n}"], ["int* grayCode(int n, int* returnSize){\\n    int s = pow(2,n);\\n    int* res = calloc(s, sizeof(int));\\n    for(int i=1; i<s; i++) res[i] = i^(i>>1);\\n    *returnSize = s;\\n    return res;\\n}"]]}
{"id": "663", "ref_c": [["int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int **ret = calloc(pow(2, numsSize), sizeof(int*)), *temp = calloc(numsSize, sizeof(int));\\n    (*returnColumnSizes) = calloc(pow(2, numsSize), sizeof(int));\\n    (*returnSize) = 0;\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    help(nums, numsSize, returnSize, returnColumnSizes, ret, temp, 0, 0);\\n    return ret;\\n}"], ["int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int tBuf[numsSize];\\n    int **ret = (int**)malloc(sizeof(int*) * 2000);\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int) * 2000);\\n    (*returnColumnSizes)[0] = 0;\\n    *returnSize = 1;\\n    bubble_sort(nums, numsSize);\\n    for(int i = 1; i <= numsSize ; i++)\\n    {\\n        fun(nums, numsSize, ret, returnSize, *returnColumnSizes, 0,  i, tBuf, 0);\\n    }"], ["int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int tBuf[numsSize];\\n    int **ret = (int**)malloc(sizeof(int*) * 2000);\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int) * 2000);\\n    (*returnColumnSizes)[0] = 0;\\n    *returnSize = 1;\\n    bubble_sort(nums, numsSize);\\n    for(int i = 1; i <= numsSize ; i++)\\n    {\\n        fun(nums, numsSize, ret, returnSize, *returnColumnSizes, 0,  i, tBuf, 0);\\n    }"]]}
{"id": "664", "ref_c": [["int numDecodings(char * s) {\\n  int dp[2] = {1, 0}"], ["int numDecodings(char * s) {\\n  int dp[2] = {1, 0}"], ["int numDecodings(char * s) {\\n  int dp[2] = {1, 0}"]]}
{"id": "665", "ref_c": [["struct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n    struct ListNode* p = head;struct ListNode* pPre = NULL;\\n    int count = 1;\\n    while(count < left){\\n        pPre = p;\\n        p = p->next;\\n        count++;\\n    }"], ["struct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n\\n    struct ListNode *p = head,*k=head;\\n    int i = 1,kk=0;\\n    int a[100000];\\n    while(p!=NULL){\\n        if (i>=left && i<=right){\\n            a[kk++]=p->val;\\n        }"], ["struct ListNode* reverseBetween(struct ListNode* head, int left, int right) {\\n    if (left == right || head == NULL || head->next == NULL)\\n        return head;\\n    struct ListNode dummy;\\n    dummy.next = head;\\n    struct ListNode* Left = &dummy;\\n    for (int i = 1; i < left; i++) {\\n        Left = Left->next;\\n    }"]]}
{"id": "666", "ref_c": [["char ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }"], ["char ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }"], ["char ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }"]]}
{"id": "667", "ref_c": [["struct TreeNode** generateTrees(int n, int* returnSize){\\n    struct TreeNode ***ans=(struct TreeNode***)malloc(sizeof(struct TreeNode**)*(n+1));\\n    ans[0]=NULL;\\n    for(int i=1;i<=n;i++){\\n        ans[i]=(struct TreeNode**)malloc(sizeof(struct TreeNode*)*size(i));\\n    }"], ["struct TreeNode** generateTrees(int n, int* returnSize){\\n    struct TreeNode **output = (struct TreeNode**)malloc(sizeof(struct TreeNode *) * 1430);\\n    count = 0;\\n\\n    int arr[n];\\n    for(int i = 0; i < n; i++){\\n        arr[i] = i + 1;\\n    }"], ["struct TreeNode** generateTrees(int n, int* returnSize){\\n    return creatTrees(1, n, returnSize);\\n}"]]}
{"id": "668", "ref_c": [["int numTrees(int n) {\\n        // Create \\'sol\\' array of length n+1...\\n        int[] sol = new int[n+1];\\n        // The value of the first index will be 1.\\n        sol[0] = 1;\\n        // Run a loop from 1 to n+1...\\n        for(int i = 1; i <= n; i++) {\\n            // Within the above loop, run a nested loop from 0 to i...\\n            for(int j = 0; j < i; j++) {\\n                // Update the i-th position of the array by adding the multiplication of the respective index...\\n                sol[i] += sol[j] * sol[i-j-1];\\n            }", "int numTrees(int n) {\\n        // If n <= 1, then return 1\\n        if (n <= 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}", "int numTrees(int n){\\n    long sol = 1;\\n    for (int i = 0; i < n; ++i) {\\n        sol = sol * 2 * (2 * i + 1) / (i + 2);\\n    }"], ["int numTrees(int n) {\\n    long double numerator=1;\\n    for(int i=2*n;i>0 && i>n+1;i--)\\n        numerator*=i;\\n    return numerator/(factorial(n));\\n}"], ["int numTrees(int n){\\n    if(n == 0 || n == 1) return n;\\n    long ans = 1;\\n    for(int i = 0; i < n; i++){\\n        ans = ans *2*(2*i+1)/(i+2);\\n    }"]]}
{"id": "669", "ref_c": [["bool isInterleave(char * s1, char * s2, char * s3){\\n    memset(memo, -1, sizeof(memo));\\n    return checker(s1, s2, s3, 0, 0, 0, strlen(s1), strlen(s2), strlen(s3));\\n}"], ["bool isInterleave(char * s1, char * s2, char * s3){\\n    int m = strlen(s1);\\n    int n = strlen(s2);\\n    int l = strlen(s3);\\n    if ((m + n) != l)\\n        return false;\\n    int dp[m+1][n+1];\\n    for(int i = 0;i <= m;i += 1) {\\n        for(int j = 0;j <= n;j += 1) {\\n            if (i == 0 && j == 0)\\n                dp[i][j] = 1;\\n            else if(i == 0)\\n                dp[i][j] = dp[i][j-1] && s2[j-1] == s3[j-1];\\n            else if(j == 0)\\n                dp[i][j] = dp[i-1][j] && s1[i-1] == s3[i-1];\\n            else\\n                dp[i][j] = (dp[i][j-1] && s2[j-1] == s3[i+j-1]) || (dp[i-1][j] && s1[i-1] == s3[i+j-1]);\\n        }"], ["bool isInterleave(char * s1, char * s2, char * s3){\\n    int m = strlen(s1);\\n    int n = strlen(s2);\\n    int l = strlen(s3);\\n    if ((m + n) != l)\\n        return false;\\n    int dp[m+1][n+1];\\n    for(int i = 0;i <= m;i += 1) {\\n        for(int j = 0;j <= n;j += 1) {\\n            if (i == 0 && j == 0)\\n                dp[i][j] = 1;\\n            else if(i == 0)\\n                dp[i][j] = dp[i][j-1] && s2[j-1] == s3[j-1];\\n            else if(j == 0)\\n                dp[i][j] = dp[i-1][j] && s1[i-1] == s3[i-1];\\n            else\\n                dp[i][j] = (dp[i][j-1] && s2[j-1] == s3[i+j-1]) || (dp[i-1][j] && s1[i-1] == s3[i+j-1]);\\n        }"]]}
{"id": "670", "ref_c": [["bool isValidBST(struct TreeNode* root){\\n    i=0;\\n    inorder(root);\\n    for(int j=0;j<i-1;j++)\\n    {\\n        printf(\"%d\",j);\\n        if(arr[j]>=arr[j+1])\\n            return false;\\n    }"], ["bool isValidBST(struct TreeNode* root){\\n    return helper(root, LONG_MIN, LONG_MAX);\\n}"], ["bool isValidBST(struct TreeNode* root){\\n    i=0;\\n    inorder(root);\\n    for(int j=0;j<i-1;j++)\\n    {\\n        printf(\"%d\",j);\\n        if(arr[j]>=arr[j+1])\\n            return false;\\n    }"]]}
{"id": "671", "ref_c": [["void recoverTree(struct TreeNode* root)\\n{\\n    struct TreeNode* n1 = NULL;  // first swapped node\\n    struct TreeNode* n2 = NULL;  // second swapped node\\n    struct TreeNode* prev = NULL;  // previous node inorder\\n    f(root, &n1, &n2, &prev);\\n    // swap n1, n2 vals\\n\\tn1->val ^= n2->val ^= n1->val ^= n2->val;\\n}"], ["void recoverTree(struct TreeNode* root){\\n    first = NULL;\\n    second = NULL;\\n    pre = root;\\n    while(pre->left)\\n        pre = pre->left;\\n    findBadNode(root);\\n    fixBadNode(first, second);\\n    return;    \\n}"], ["void recoverTree(struct TreeNode* root)\\n{\\n    struct TreeNode* n1 = NULL;  // first swapped node\\n    struct TreeNode* n2 = NULL;  // second swapped node\\n    struct TreeNode* prev = NULL;  // previous node inorder\\n    f(root, &n1, &n2, &prev);\\n    // swap n1, n2 vals\\n\\tn1->val ^= n2->val ^= n1->val ^= n2->val;\\n}"]]}
{"id": "672", "ref_c": ["\nvoid trace_depth(struct TreeNode *n, int depth, int *cmp) {\n    if (!n)\n        return;\n    if (++depth > *cmp)\n        *cmp = depth;\n    trace_depth(n->left, depth, cmp);\n    trace_depth(n->right, depth, cmp);\n}\n\nvoid trace(struct TreeNode *n, int depth, int **a, int *id) {\n    if (!n)\n        return;\n    \n    if (!id[depth])\n        a[depth] = (int *)malloc(sizeof(int) * ((depth > 10) ? 1024 : (1 << depth)));\n    a[depth][id[depth]++] = n->val;\n    trace(n->left, depth + 1, a, id);\n    trace(n->right, depth + 1, a, id);\n}\n\nint **levelOrder(struct TreeNode *root, int *returnSize, int **returnColumnSizes) {\n    *returnSize = 0;\n    if (!root)\n        return NULL;\n    \n    trace_depth(root, 0, returnSize);\n    int **result = (int **)malloc(sizeof(int *) * (*returnSize));\n    *returnColumnSizes = (int *)calloc(*returnSize, sizeof(int));\n    trace(root, 0, result, *returnColumnSizes);\n    \n    return result;\n}\n", "\nvoid trace_depth(struct TreeNode *n, int depth, int *cmp) {\n    if (!n)\n        return;\n    if (++depth > *cmp)\n        *cmp = depth;\n    trace_depth(n->left, depth, cmp);\n    trace_depth(n->right, depth, cmp);\n}\n\nvoid trace(struct TreeNode *n, int depth, int **a, int *id) {\n    if (!n)\n        return;\n    \n    if (!id[depth])\n        a[depth] = (int *)malloc(sizeof(int) * ((depth > 10) ? 1024 : (1 << depth)));\n    a[depth][id[depth]++] = n->val;\n    trace(n->left, depth + 1, a, id);\n    trace(n->right, depth + 1, a, id);\n}\n\nint **levelOrder(struct TreeNode *root, int *returnSize, int **returnColumnSizes) {\n    *returnSize = 0;\n    if (!root)\n        return NULL;\n    \n    trace_depth(root, 0, returnSize);\n    int **result = (int **)malloc(sizeof(int *) * (*returnSize));\n    *returnColumnSizes = (int *)calloc(*returnSize, sizeof(int));\n    trace(root, 0, result, *returnColumnSizes);\n    \n    return result;\n}\n", "\nvoid trace_depth(struct TreeNode *n, int depth, int *cmp) {\n    if (!n)\n        return;\n    if (++depth > *cmp)\n        *cmp = depth;\n    trace_depth(n->left, depth, cmp);\n    trace_depth(n->right, depth, cmp);\n}\n\nvoid trace(struct TreeNode *n, int depth, int **a, int *id) {\n    if (!n)\n        return;\n    \n    if (!id[depth])\n        a[depth] = (int *)malloc(sizeof(int) * ((depth > 10) ? 1024 : (1 << depth)));\n    a[depth][id[depth]++] = n->val;\n    trace(n->left, depth + 1, a, id);\n    trace(n->right, depth + 1, a, id);\n}\n\nint **levelOrder(struct TreeNode *root, int *returnSize, int **returnColumnSizes) {\n    *returnSize = 0;\n    if (!root)\n        return NULL;\n    \n    trace_depth(root, 0, returnSize);\n    int **result = (int **)malloc(sizeof(int *) * (*returnSize));\n    *returnColumnSizes = (int *)calloc(*returnSize, sizeof(int));\n    trace(root, 0, result, *returnColumnSizes);\n    \n    return result;\n}\n"]}
{"id": "673", "ref_c": [["int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\\n    int** ans = malloc(2000 * sizeof(int*));\\n    (*returnColumnSizes) = malloc(2000 * sizeof(int));\\n\\n    if(root == NULL) {\\n        *returnSize = 0;\\n        (*returnColumnSizes)[0] = 0;\\n        return ans;\\n    }"], ["int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\\n    \\n    /*\\n     * Input:\\n     *  root, root of binary tree\\n     */\\n    \\n    int **ans = (int **)calloc(1, sizeof(int *) * 2000);\\n    int tmp;\\n\\n    *returnSize = 0;\\n    *returnColumnSizes = (int *)calloc(1, sizeof(int) * 2000);\\n\\n    dfs(root, returnSize, returnColumnSizes, 0, ans);\\n\\n    /* Reverse the row 1, 3, ... node values of row 1, 3 */\\n    for (int i = 1; i < *returnSize; i+=2) {\\n        for (int j = 0, k = (*returnColumnSizes)[i] - 1; j < k; j++, k--) {\\n            tmp = ans[i][j];\\n            ans[i][j] = ans[i][k];\\n            ans[i][k] = tmp;\\n        }"], ["int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\\n    int** ans = malloc(2000 * sizeof(int*));\\n    (*returnColumnSizes) = malloc(2000 * sizeof(int));\\n\\n    if(root == NULL) {\\n        *returnSize = 0;\\n        (*returnColumnSizes)[0] = 0;\\n        return ans;\\n    }"]]}
{"id": "674", "ref_c": [["struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize);\\nstruct TreeNode* helper(int* preorder, int* inorder, int* Idx, int left, int right);\\n\\nstruct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {\\n    int Idx = 0;\\n    return helper(preorder, inorder, &Idx, 0, inorderSize - 1);\\n}"], ["struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize);\\nstruct TreeNode* helper(int* preorder, int* inorder, int* Idx, int left, int right);\\n\\nstruct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {\\n    int Idx = 0;\\n    return helper(preorder, inorder, &Idx, 0, inorderSize - 1);\\n}"], ["struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize);\\nstruct TreeNode* helper(int* preorder, int* inorder, int* Idx, int left, int right);\\n\\nstruct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {\\n    int Idx = 0;\\n    return helper(preorder, inorder, &Idx, 0, inorderSize - 1);\\n}"]]}
{"id": "675", "ref_c": [["struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){\\n    int *inorderMap = (int *)malloc(sizeof(int) * 6000);\\n    for(int i = 0; i < inorderSize; i++) {\\n        *(inorderMap + *(inorder + i) + 3000) = i;\\n    }"], ["struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize) {\\n    int postIndex = postorderSize-1;\\n    return helper(inorder, postorder, 0, inorderSize-1, &postIndex);\\n}"], ["struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){\\n    int *inorderMap = (int *)malloc(sizeof(int) * 6000);\\n    for(int i = 0; i < inorderSize; i++) {\\n        *(inorderMap + *(inorder + i) + 3000) = i;\\n    }"]]}
{"id": "676", "ref_c": [["int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  root, root of binary tree\\n     */\\n\\n    int **tmp, len;\\n    int **ans = (int **)calloc(1, sizeof(int *) * 2000);\\n\\n    *returnSize = 0;\\n    *returnColumnSizes = (int *)malloc(sizeof(int) * 2000);\\n\\n    dfs(root, returnSize, returnColumnSizes, ans, 0);\\n\\n    for (int i = 0, j = *returnSize - 1; i < j; i++, j--) {\\n        len = (*returnColumnSizes)[i];\\n        (*returnColumnSizes)[i] = (*returnColumnSizes)[j];\\n        (*returnColumnSizes)[j] = len;\\n\\n        tmp = ans[i];\\n        ans[i] = ans[j];\\n        ans[j] = tmp;\\n    }"], ["int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\\n    int** ans = malloc(2000 * sizeof(int*));\\n    (*returnColumnSizes) = malloc(2000 * sizeof(int));\\n    if(root == NULL) {\\n        *returnSize = 0;\\n        (*returnColumnSizes)[0] = 0;\\n        return ans;\\n    }"], ["int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\\n    int** ans = malloc(2000 * sizeof(int*));\\n    (*returnColumnSizes) = malloc(2000 * sizeof(int));\\n    if(root == NULL) {\\n        *returnSize = 0;\\n        (*returnColumnSizes)[0] = 0;\\n        return ans;\\n    }"]]}
{"id": "677", "ref_c": [["struct TreeNode* sortedListToBST(struct ListNode* head){\\n    if(!head) return NULL;\\n    if(!head->next) {\\n        struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n        node->val = head->val;\\n        node->left = NULL;\\n        node->right = NULL;\\n        return node;\\n    }"], ["struct TreeNode* sortedListToBST(struct ListNode* head){\\n    struct Node* root = NULL;\\n    while(head != NULL){\\n        root = insert(root, head->val);\\n        head = head->next;\\n    }"], ["struct TreeNode* sortedListToBST(struct ListNode* head){\\n    if(!head) return NULL;\\n    struct ListNode* savedHead = head;\\n    struct ListNode* prev = NULL; /* for saving the list tail for the left node */\\n    struct ListNode* slow = head;\\n    struct ListNode* fast = head;\\n    if(fast->next)\\n        fast = fast->next;    \\n    while(fast->next)\\n    {\\n        prev = slow;\\n        fast = fast->next;\\n        slow = slow->next;\\n        if(fast->next)\\n            fast = fast->next;\\n    }"]]}
{"id": "678", "ref_c": [["int** pathSum(struct TreeNode* root, int targetSum, int* returnSize, int** returnColumnSizes){\\n    int **arr;\\n    bool found;\\n    arr=malloc(sizeof(int*)*2500);\\n    *returnSize=0; \\n    *returnColumnSizes=malloc(sizeof(int)*2500);\\n    found = hasPathSum(root,targetSum,arr,returnSize,0,*returnColumnSizes);\\n    return arr;  \\n}"], ["int** pathSum(struct TreeNode* root, int targetSum, int* returnSize, int** returnColumnSizes){\\n    int** result = (int**)malloc(sizeof(int*)*5000);\\n    *returnSize = 0;\\n    *returnColumnSizes = (int*)malloc(sizeof(int)*5000);\\n\\n    struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*)*5000);\\n    int top = 0;\\n    if(root != NULL){\\n        stack[0] = root;\\n        top = 1;\\n    }"], ["int** pathSum(struct TreeNode* root, int targetSum, int* returnSize, int** returnColumnSizes){\\n    int** result = (int**)malloc(sizeof(int*)*5000);\\n    *returnSize = 0;\\n    *returnColumnSizes = (int*)malloc(sizeof(int)*5000);\\n\\n    struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*)*5000);\\n    int top = 0;\\n    if(root != NULL){\\n        stack[0] = root;\\n        top = 1;\\n    }"]]}
{"id": "679", "ref_c": [["void flatten(struct TreeNode* root){\\n    \\n    // check if root exists\\n    if (root){\\n        \\n        struct TreeNode* temp = root->right;    // store the right part of root\\n        \\n        root->right = root->left;           // move the left part to the right\\n        root->left = NULL;                  // clear left part\\n        \\n        struct TreeNode* curr = root;\\n        while(curr->right){                 // use while loop to find the bottom right side\\n            curr = curr->right;\\n        }"], ["void flatten(struct TreeNode* root){\\n    \\n    // check if root exists\\n    if (root){\\n        \\n        struct TreeNode* temp = root->right;    // store the right part of root\\n        \\n        root->right = root->left;           // move the left part to the right\\n        root->left = NULL;                  // clear left part\\n        \\n        struct TreeNode* curr = root;\\n        while(curr->right){                 // use while loop to find the bottom right side\\n            curr = curr->right;\\n        }"], ["void flatten(struct TreeNode* root)\\n{\\n    struct TreeNode *curr = root;\\n    while(curr != NULL)\\n    {\\n        if(curr->left != NULL)\\n        {\\n            struct TreeNode *prev = curr->left;\\n            while(prev->right)\\n            {\\n                prev = prev->right;\\n            }"]]}
{"id": "680", "ref_c": [["struct Node* connect(struct Node* root) {\\n\\tif (!root || !root->left)\\n        return root;\\n    \\n    root->left->next = root->right;\\n    root->right->next = root->next ? root->next->left : NULL;\\n    connect(root->left);\\n    connect(root->right);\\n    \\n    return root;\\n}", "struct Node* connect(struct Node* root) {\\n    for (struct Node *start = root; start && start->left; start = start->left) {\\n        for (struct Node *p = start; p; p = p->next) {\\n            p->left->next = p->right;\\n            p->right->next = p->next ? p->next->left : NULL;\\n        }"], ["struct Node* connect(struct Node* root) {\\n\\tif (!root || !root->left)\\n        return root;\\n    \\n    root->left->next = root->right;\\n    root->right->next = root->next ? root->next->left : NULL;\\n    connect(root->left);\\n    connect(root->right);\\n    \\n    return root;\\n}", "struct Node* connect(struct Node* root) {\\n    for (struct Node *start = root; start && start->left; start = start->left) {\\n        for (struct Node *p = start; p; p = p->next) {\\n            p->left->next = p->right;\\n            p->right->next = p->next ? p->next->left : NULL;\\n        }"], ["struct Node* connect(struct Node* root) {\\n\\tif (!root)\\n        return root;\\n    \\n    struct Node* ptr_node = root;\\n    struct Node* first = ptr_node;\\n    \\n    while (ptr_node->left) {\\n        \\n        while (ptr_node) {\\n            \\n            ptr_node->left->next = ptr_node->right;\\n            \\n            if (ptr_node->next) {\\n                ptr_node->right->next = ptr_node->next->left;\\n            }"]]}
{"id": "681", "ref_c": [["struct Node* connect(struct Node* root) {\\n        // Recursive level order traversal\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(n)\\n\\n        if (root == NULL) {\\n            return NULL;\\n        }", "struct Node* connect(struct Node* root) {\\n        // BFS level order traversal\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(n)\\n\\n        if (root == NULL) {\\n            return NULL;\\n        }", "struct Node* connect(struct Node* root) {\\n        // BFS without extra space\\n        // populating the next level while traversing current level.\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        if (root == NULL) {\\n            return NULL;\\n        }"], ["struct Node* connect(struct Node* root) {\\n    if(root == NULL) {\\n        return NULL;\\n    }"], ["struct Node* connect(struct Node* root) {\\n    if (root == NULL) {\\n        return NULL;\\n    }"]]}
{"id": "682", "ref_c": ["\nint pathFind(int **tri, int y, int x, int size, int **memo)\n{\n    if (y == size - 1)\n        return tri[y][x];\n    \n    if (memo[y][x] != - 1)\n        return memo[y][x];\n    int left = pathFind(tri, y + 1, x, size, memo);\n    int right = pathFind(tri, y + 1, x + 1, size, memo);\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n}\n\nint minimumTotal(int** triangle, int triangleSize, int* triangleColSize){\n    int **memo = malloc(sizeof(int *) * 200);\n    \n    for (int i = 0; i < 200; i++)\n    {\n        memo[i] = malloc(sizeof(int) * 200);\n        for (int j = 0; j < 200; j++)\n            memo[i][j] = -1;\n    }\n    return pathFind(triangle, 0, 0, triangleSize, memo);\n}\n", "\nint pathFind(int **tri, int y, int x, int size, int **memo)\n{\n    if (y == size - 1)\n        return tri[y][x];\n    \n    if (memo[y][x] != - 1)\n        return memo[y][x];\n    int left = pathFind(tri, y + 1, x, size, memo);\n    int right = pathFind(tri, y + 1, x + 1, size, memo);\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n}\n\nint minimumTotal(int** triangle, int triangleSize, int* triangleColSize){\n    int **memo = malloc(sizeof(int *) * 200);\n    \n    for (int i = 0; i < 200; i++)\n    {\n        memo[i] = malloc(sizeof(int) * 200);\n        for (int j = 0; j < 200; j++)\n            memo[i][j] = -1;\n    }\n    return pathFind(triangle, 0, 0, triangleSize, memo);\n}\n", "\nint pathFind(int **tri, int y, int x, int size, int **memo)\n{\n    if (y == size - 1)\n        return tri[y][x];\n    \n    if (memo[y][x] != - 1)\n        return memo[y][x];\n    int left = pathFind(tri, y + 1, x, size, memo);\n    int right = pathFind(tri, y + 1, x + 1, size, memo);\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n}\n\nint minimumTotal(int** triangle, int triangleSize, int* triangleColSize){\n    int **memo = malloc(sizeof(int *) * 200);\n    \n    for (int i = 0; i < 200; i++)\n    {\n        memo[i] = malloc(sizeof(int) * 200);\n        for (int j = 0; j < 200; j++)\n            memo[i][j] = -1;\n    }\n    return pathFind(triangle, 0, 0, triangleSize, memo);\n}\n"]}
{"id": "683", "ref_c": [["int maxProfit(int* prices, int pricesSize){\\n    int minPrices = 1e9, profit = 0;\\n    for(int i = 0; i < pricesSize; i++){\\n        if(prices[i] < minPrices) minPrices = prices[i];\\n        else{\\n            profit += prices[i] - minPrices;\\n            minPrices = prices[i];\\n        }"], ["int maxProfit(int* prices, int pricesSize){\\n    int minPrices = 1e9, profit = 0;\\n    for(int i = 0; i < pricesSize; i++){\\n        if(prices[i] < minPrices) minPrices = prices[i];\\n        else{\\n            profit += prices[i] - minPrices;\\n            minPrices = prices[i];\\n        }"], ["int maxProfit(int* prices, int pricesSize){\\n    int minPrices = 1e9, profit = 0;\\n    for(int i = 0; i < pricesSize; i++){\\n        if(prices[i] < minPrices) minPrices = prices[i];\\n        else{\\n            profit += prices[i] - minPrices;\\n            minPrices = prices[i];\\n        }"]]}
{"id": "684", "ref_c": [["int longestConsecutive(int* nums, int numsSize) {\\n    if (numsSize == 0) {\\n        return 0;\\n    }", "int longestConsecutive(int* nums, int numsSize) {\\n    // Step 1: Sort the input array in ascending order.\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    // Step 2: Handle the base case when the array is empty.\\n    if (numsSize == 0) {\\n        return 0;\\n    }", "int longestConsecutive(int* nums, int numsSize) {\\n    // Step 1: Handle the base case when the array is empty.\\n    if (numsSize == 0) {\\n        return 0;\\n    }"], ["int longestConsecutive(int* nums, int numsSize) {\\n    if (numsSize == 0) {\\n        return 0;\\n    }", "int longestConsecutive(int* nums, int numsSize) {\\n    // Step 1: Sort the input array in ascending order.\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    // Step 2: Handle the base case when the array is empty.\\n    if (numsSize == 0) {\\n        return 0;\\n    }", "int longestConsecutive(int* nums, int numsSize) {\\n    // Step 1: Handle the base case when the array is empty.\\n    if (numsSize == 0) {\\n        return 0;\\n    }"], ["int longestConsecutive(int* nums, int numsSize) {\\n    if (numsSize == 0) {\\n        return 0;\\n    }", "int longestConsecutive(int* nums, int numsSize) {\\n    // Step 1: Sort the input array in ascending order.\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    // Step 2: Handle the base case when the array is empty.\\n    if (numsSize == 0) {\\n        return 0;\\n    }", "int longestConsecutive(int* nums, int numsSize) {\\n    // Step 1: Handle the base case when the array is empty.\\n    if (numsSize == 0) {\\n        return 0;\\n    }"]]}
{"id": "685", "ref_c": [["int sumNumbers(struct TreeNode* root){\\n   return sumNumRec(root, 0);\\n}"], ["int sumNumbers(struct TreeNode* root){\\n   return sumNumRec(root, 0);\\n}"], ["int sumNumbers(struct TreeNode* root){\\n   return sumNumRec(root, 0);\\n}"]]}
{"id": "686", "ref_c": [["void solve(char** board, int boardSize, int* boardColSize){\\n    for (int i = 0; i < boardSize; i++)\\n        for (int j = 0; j < *boardColSize; j++)\\n            if (board[i][j] == \\'O\\')\\n            {\\n                bool sur = true;\\n                changeChar(board, i, j, boardSize, *boardColSize, &sur);\\n                if (sur)                                                    // the changeChar function will change sur to false\\n                    capture(board, i, j);                                   // if it encoutners an edge. If this doesn\\'t \\n            }"], ["void solve(char** board, int boardSize, int* boardColSize){\\n    int i, j, m = boardSize, n = *boardColSize;\\n\\n    bool **visited = (bool**)calloc(sizeof(bool*), m);\\n\\n    for (i = 0; i < m; i++)\\n        visited[i] = (bool*)calloc(sizeof(bool), n);\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++) {\\n            if (board[i][j] == \\'O\\' && (i == m - 1 || j == n - 1 || i == 0 || j == 0)) {\\n                helper(i, j, m, n, board, visited);\\n            }"], ["void solve(char** board, int boardSize, int* boardColSize){\\n    int i, j, m = boardSize, n = *boardColSize;\\n\\n    bool **visited = (bool**)calloc(sizeof(bool*), m);\\n\\n    for (i = 0; i < m; i++)\\n        visited[i] = (bool*)calloc(sizeof(bool), n);\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++) {\\n            if (board[i][j] == \\'O\\' && (i == m - 1 || j == n - 1 || i == 0 || j == 0)) {\\n                helper(i, j, m, n, board, visited);\\n            }"]]}
{"id": "687", "ref_c": [["char *** partition(char * s, int* returnSize, int** returnColumnSizes){\\n    int str_len = strlen(s);\\n    int all_pos_cnt = 1<<(str_len-1); //Count for all posiible substring\\n    char *** ret = calloc(all_pos_cnt, sizeof(char**));\\n    *returnSize = 0;\\n\\n    (*returnColumnSizes) = calloc(all_pos_cnt, sizeof(int));\\n\\n    for (int sel_bit = 0; sel_bit < all_pos_cnt; sel_bit++){\\n        char **substr = calloc(str_len, sizeof(char*));\\n        int start = 0;\\n        int sub_idx = 0;\\n        int valid = 1;\\n\\n        for(int ith_b = 0; ith_b < (str_len-1); ith_b++){\\n            if ((  (1<<ith_b) &  sel_bit) > 0){\\n                if(is_P(s, start, ith_b) == 1){\\n                    substr[sub_idx] = calloc((ith_b-start+1+1), sizeof(char)); // + 1 for \\'\\\\0\\'\\n                    memcpy(&substr[sub_idx][0], &s[start], (ith_b-start+1) * sizeof(char));\\n                    substr[sub_idx][ith_b-start+1] = \\'\\\\0\\';\\n                    start = ith_b + 1;\\n                    sub_idx++;\\n                }"], ["char *** partition(char * s, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  *s, string\\n     */\\n\\n    node_t *head = NULL, *del;\\n    char *substr_buf[16], ***ans = NULL;\\n    int substr_len[16] = {0}"], ["char *** partition(char * s, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  *s, string\\n     */\\n\\n    node_t *head = NULL, *del;\\n    char *substr_buf[16], ***ans = NULL;\\n    int substr_len[16] = {0}"]]}
{"id": "688", "ref_c": [["struct Node *cloneGraph(struct Node *s) {\\n    if(!s)\\n        return NULL;\\n\\n    struct Node** visited = malloc(sizeof(struct Node*)*101);\\n    for(int i=0;i<101;i++){\\n        visited[i] = NULL;\\n    }"], ["struct Node *cloneGraph(struct Node *s) {\\n    \\n    struct Node *arr, *each_s;\\n    int i ;\\n    q_s  *qu;\\n    \\n    if (s == NULL)\\n    {\\n        return NULL;\\n    }"], ["struct Node *cloneGraph(struct Node *s) {\\n    if(!s)\\n        return NULL;\\n\\n    struct Node** visited = malloc(sizeof(struct Node*)*101);\\n    for(int i=0;i<101;i++){\\n        visited[i] = NULL;\\n    }"]]}
{"id": "689", "ref_c": ["\nint canCompleteCircuit(int *gas, int n1, int* cost, int n2)\n{\n    int i,gas_sum=0,cost_sum=0; \n    for(i=0;i<n1;i++)\n    {\n       gas_sum+=gas[i];\n    }\n    for(i=0;i<n2;i++)\n    {\n       cost_sum+=cost[i];\n    } \n    if(gas_sum<cost_sum)\n    {\n        return -1;\n    }\n    int start=0; \n    int tank=0; //3 1 1   1 2 2 \n    for(i=0;i<=n1-1;i++) //i=1\n    {\n     tank += (gas[i]-cost[i]); //tank=2 \n     if(tank<0)\n     {\n      start=i+1; \n      tank=0;\n     }\n    }\n   return start;   \n}\n", "\nint canCompleteCircuit(int *gas, int n1, int* cost, int n2)\n{\n    int i,gas_sum=0,cost_sum=0; \n    for(i=0;i<n1;i++)\n    {\n       gas_sum+=gas[i];\n    }\n    for(i=0;i<n2;i++)\n    {\n       cost_sum+=cost[i];\n    } \n    if(gas_sum<cost_sum)\n    {\n        return -1;\n    }\n    int start=0; \n    int tank=0; //3 1 1   1 2 2 \n    for(i=0;i<=n1-1;i++) //i=1\n    {\n     tank += (gas[i]-cost[i]); //tank=2 \n     if(tank<0)\n     {\n      start=i+1; \n      tank=0;\n     }\n    }\n   return start;   \n}\n", "\nint canCompleteCircuit(int *gas, int n1, int* cost, int n2)\n{\n    int i,gas_sum=0,cost_sum=0; \n    for(i=0;i<n1;i++)\n    {\n       gas_sum+=gas[i];\n    }\n    for(i=0;i<n2;i++)\n    {\n       cost_sum+=cost[i];\n    } \n    if(gas_sum<cost_sum)\n    {\n        return -1;\n    }\n    int start=0; \n    int tank=0; //3 1 1   1 2 2 \n    for(i=0;i<=n1-1;i++) //i=1\n    {\n     tank += (gas[i]-cost[i]); //tank=2 \n     if(tank<0)\n     {\n      start=i+1; \n      tank=0;\n     }\n    }\n   return start;   \n}\n"]}
{"id": "690", "ref_c": [["int singleNumber(int* nums, int numsSize) {\\n    int i,j,bit,result=0; \\n    for(i=0; i<32; i++){ // Loop through each bit (0 to 31)\\n        bit=0;\\n        for(j=0; j<numsSize; j++){ // Loop through the array of numbers\\n            if(nums[j] & (1u << i)) // Check if the current number has the bit set at position i\\n                bit++;\\n        }"], ["int singleNumber(int* nums, int numsSize) {\\n    int i,j,bit,result=0; \\n    for(i=0; i<32; i++){ // Loop through each bit (0 to 31)\\n        bit=0;\\n        for(j=0; j<numsSize; j++){ // Loop through the array of numbers\\n            if(nums[j] & (1u << i)) // Check if the current number has the bit set at position i\\n                bit++;\\n        }"], ["int singleNumber(int* nums, int numsSize) {\\n    int i,j,bit,result=0; \\n    for(i=0; i<32; i++){ // Loop through each bit (0 to 31)\\n        bit=0;\\n        for(j=0; j<numsSize; j++){ // Loop through the array of numbers\\n            if(nums[j] & (1u << i)) // Check if the current number has the bit set at position i\\n                bit++;\\n        }"]]}
{"id": "691", "ref_c": [["struct Node* copyRandomList(struct Node* head) {\\n\\n    struct Node* cur = head;\\n    struct Node * newhead = NULL;\\n    struct Node * tail = NULL;\\n\\n    while(cur)\\n    {\\n        insert(&newhead,&tail,cur->val);\\n        cur = cur->next;\\n    }"], ["struct Node* copyRandomList(struct Node* head) {\\n  if(!head)\\n    return head;\\n  struct Node* p0 = NULL;\\n  struct Node* p1 = NULL;\\n  struct Node* newHead = (struct Node*) malloc(sizeof(struct Node));\\n  newHead->val = head->val;\\n  newHead->next = NULL;\\n  newHead->random = head->random;\\n  head->random = newHead;\\n  struct Node* p2 = newHead;\\n  for(p0 = head->next;p0;p0 = p0->next){\\n    p1 = (struct Node*) malloc(sizeof(struct Node));\\n    p1->val = p0->val;\\n    p1->next = NULL;\\n    p1->random = p0->random;\\n    p2->next = p1;\\n    p2 = p1;\\n    p0->random = p1;\\n  }"], ["struct Node* copyRandomList(struct Node* head) {\\n  if(!head)\\n    return head;\\n  struct Node* p0 = NULL;\\n  struct Node* p1 = NULL;\\n  struct Node* newHead = (struct Node*) malloc(sizeof(struct Node));\\n  newHead->val = head->val;\\n  newHead->next = NULL;\\n  newHead->random = head->random;\\n  head->random = newHead;\\n  struct Node* p2 = newHead;\\n  for(p0 = head->next;p0;p0 = p0->next){\\n    p1 = (struct Node*) malloc(sizeof(struct Node));\\n    p1->val = p0->val;\\n    p1->next = NULL;\\n    p1->random = p0->random;\\n    p2->next = p1;\\n    p2 = p1;\\n    p0->random = p1;\\n  }"]]}
{"id": "692", "ref_c": ["\nint find(int* uf, int i){\n    while(uf[i] != i){\n        i = uf[i];\n    }\n    return i;\n}\n\nvoid merge(int* uf, int i, int j){\n    uf[find(uf, j)] = find(uf, i);\n}\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    int n = strlen(s);\n    int* uf = calloc(n+1, sizeof(int));\n    for(int i = 0; i < n+1; i++){\n        uf[i] = i;\n    }\n\n    for(int i = 0; i < wordDictSize; i++){\n        int m = strlen(wordDict[i]);\n        for(int j = 0; j <= n - m; j++){\n            if(!strncmp(wordDict[i], s+j, m)) {\n                merge(uf, j, j + m);\n            }\n        }\n    }\n\n    bool ret = find(uf, n) == find(uf, 0);\n    free(uf);\n    return ret;\n}\n", "\nint find(int* uf, int i){\n    while(uf[i] != i){\n        i = uf[i];\n    }\n    return i;\n}\n\nvoid merge(int* uf, int i, int j){\n    uf[find(uf, j)] = find(uf, i);\n}\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    int n = strlen(s);\n    int* uf = calloc(n+1, sizeof(int));\n    for(int i = 0; i < n+1; i++){\n        uf[i] = i;\n    }\n\n    for(int i = 0; i < wordDictSize; i++){\n        int m = strlen(wordDict[i]);\n        for(int j = 0; j <= n - m; j++){\n            if(!strncmp(wordDict[i], s+j, m)) {\n                merge(uf, j, j + m);\n            }\n        }\n    }\n\n    bool ret = find(uf, n) == find(uf, 0);\n    free(uf);\n    return ret;\n}\n", "\nint find(int* uf, int i){\n    while(uf[i] != i){\n        i = uf[i];\n    }\n    return i;\n}\n\nvoid merge(int* uf, int i, int j){\n    uf[find(uf, j)] = find(uf, i);\n}\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    int n = strlen(s);\n    int* uf = calloc(n+1, sizeof(int));\n    for(int i = 0; i < n+1; i++){\n        uf[i] = i;\n    }\n\n    for(int i = 0; i < wordDictSize; i++){\n        int m = strlen(wordDict[i]);\n        for(int j = 0; j <= n - m; j++){\n            if(!strncmp(wordDict[i], s+j, m)) {\n                merge(uf, j, j + m);\n            }\n        }\n    }\n\n    bool ret = find(uf, n) == find(uf, 0);\n    free(uf);\n    return ret;\n}\n"]}
{"id": "693", "ref_c": [["struct ListNode *detectCycle(struct ListNode *head) {\\n    struct ListNode *slow=hasCycle(head);\\n    if(slow){\\n        while(head!=slow){\\n            slow=slow->next;\\n            head=head->next;\\n        }"], ["struct ListNode *detectCycle(struct ListNode *head) {\\n    // Initialize pointers at head of linkedlist...\\n    struct ListNode *p1 = head, *p2 = head;\\n    // Run a loop until p2 and p2.next is equal to null...\\n    while (p2 && p2->next) {\\n        p1 = p1->next;          // moving p1 by 1\\n        p2 = p2->next->next;    // moving p2 by 2\\n        // found the cycle...\\n        if (p1 == p2) break;\\n    }"], ["struct ListNode *detectCycle(struct ListNode *head) {\\n    struct ListNode *slow=hasCycle(head);\\n    if(slow){\\n        while(head!=slow){\\n            slow=slow->next;\\n            head=head->next;\\n        }"]]}
{"id": "694", "ref_c": [["void reorderList(struct ListNode* head){\\nstruct ListNode *stack[50000];\\nstruct ListNode *temp=head;\\nint i=0;\\nwhile(temp)\\n{\\n    stack[i]=temp;\\n    temp=temp->next;\\n    i++;\\n}"], ["void reorderList(struct ListNode* head){\\nstruct ListNode *stack[50000];\\nstruct ListNode *temp=head;\\nint i=0;\\nwhile(temp)\\n{\\n    stack[i]=temp;\\n    temp=temp->next;\\n    i++;\\n}"], ["void reorderList(struct ListNode* head){\\nstruct ListNode *stack[50000];\\nstruct ListNode *temp=head;\\nint i=0;\\nwhile(temp)\\n{\\n    stack[i]=temp;\\n    temp=temp->next;\\n    i++;\\n}"]]}
{"id": "696", "ref_c": [["struct ListNode* insertionSortList(struct ListNode* head){\\n    struct ListNode *p=head;\\n    int i,j;\\n    int l=len(head);\\n    for(i=0;i<l;i++)\\n    {\\n        for(j=0;j<l-i-1;j++)\\n        {\\n            if(p->val>p->next->val)\\n            {\\n                swap(p,p->next);\\n            }"], ["struct ListNode* insertionSortList(struct ListNode* head) {\\n    struct ListNode* currNode=head;\\n    while(currNode->next!=NULL){\\n        int val=currNode->next->val;\\n        if(val>=currNode->val){\\n            currNode=currNode->next;\\n        }"], ["struct ListNode* insertionSortList(struct ListNode* head){\\n    if (head == NULL || head->next == NULL) {\\n        return head;\\n    }"]]}
{"id": "697", "ref_c": [["struct ListNode* sortList(struct ListNode* head){\\n  /* Grab sublists of size 1, then 2, then 4, etc, until fully merged */\\n  for (int steps = 1;; steps *= 2) {\\n    /* Keep track of how much is left to process on this pass of the list */\\n    struct ListNode* remaining = head;\\n\\n    /*\\n    Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    of the previous node (or the head on the first loop)\\n    */\\n    struct ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      /* Split 2 sublists of steps length from the front */\\n      struct ListNode* sublists[2];\\n      struct ListNode* sublists_tail[2] = {NULL, NULL}", "struct ListNode* sortList(struct ListNode* head){\\n  const int BUFFER_SIZE = 8;\\n\\n  /* Grab sublists of size 1, then 2, then 4, etc, until fully merged */\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    /* Keep track of how much is left to process on this pass of the list */\\n    struct ListNode* remaining = head;\\n\\n    /*\\n    Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    of the previous node (or the head on the first loop)\\n    */\\n    struct ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      /* Split BUFFER_SIZE sublists of upto steps length from the front */\\n      struct ListNode* sublists[BUFFER_SIZE];\\n      struct ListNode* sublists_tail[BUFFER_SIZE];\\n      for (int i = 0; i < BUFFER_SIZE; ++i) {\\n        sublists[i] = remaining;\\n        sublists_tail[i] = NULL;\\n        for (int j = 0; remaining && j < steps; ++j) {\\n          sublists_tail[i] = remaining;\\n          remaining = remaining->next;\\n        }", "struct ListNode* sortList(struct ListNode* head) {\\n  const int BUFFER_SIZE = 8;\\n\\n  /* Grab sublists of size 1, then BUFFER_SIZE, then BUFFER_SIZE^2, etc, until fully merged */\\n  for (int steps = 1;; steps *= BUFFER_SIZE) {\\n    // Keep track of how much is left to process on this pass of the list\\n    struct ListNode* remaining = head;\\n\\n    // Record the progress of the current pass into a single semi sorted list by updating the next pointer\\n    // of the previous node (or the head on the first loop)\\n    struct ListNode** next_ptr = &head;\\n\\n    int num_loops = 0;\\n    for (; remaining; ++num_loops) {\\n      /* Split BUFFER_SIZE sublists of upto steps length from the front */\\n      struct ListNode* sublists[BUFFER_SIZE];\\n      remaining = split_list(remaining, steps, sublists, BUFFER_SIZE);\\n\\n      /*\\n      Keep merging all the sublists we have in the working buffer until we have a single sublist.\\n      That is 8 sublists get merged into 4, then 4 into 2, then 2 into 1.\\n      */\\n      struct ListNode* tail;\\n      for (int num_sublists = BUFFER_SIZE; 1 < num_sublists; num_sublists /= 2) {\\n        /* Merge each pair of sublists */\\n        for (int i = 0; i < num_sublists; i += 2) {\\n          merge_lists(sublists[i], sublists[i + 1], &sublists[i / 2], &tail);\\n        }"], ["struct ListNode* sortList(struct ListNode* head) {\\n    if (head == NULL || head->next == NULL) {\\n        return head;\\n    }"], ["struct ListNode* sortList(struct ListNode* head)\\n{\\n    struct ListNode *ret = mergeSortList(head);\\n    \\n    return ret;\\n}"]]}
{"id": "698", "ref_c": ["\nint evalRPN(char **tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 + temp1;\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 - temp1;\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 * temp1;\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            \n            stack[top] = temp2 / temp1;\n        } else {\n            top++;\n            stack[top] = atoi(tokens[i]);\n        }\n    }\n\n    return stack[top];\n}\n", "\nint evalRPN(char **tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 + temp1;\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 - temp1;\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 * temp1;\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            \n            stack[top] = temp2 / temp1;\n        } else {\n            top++;\n            stack[top] = atoi(tokens[i]);\n        }\n    }\n\n    return stack[top];\n}\n", "\nint evalRPN(char **tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 + temp1;\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 - temp1;\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 * temp1;\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            \n            stack[top] = temp2 / temp1;\n        } else {\n            top++;\n            stack[top] = atoi(tokens[i]);\n        }\n    }\n\n    return stack[top];\n}\n"]}
{"id": "699", "ref_c": [["char * reverseWords(char * str){\\n  char* end = &str[strlen(str) - 1];\\n  reverseString(str, end);\\n  int length = strlen(str);\\n\\n  // Hi I am Jenish\\n  // hsineJ ma I iH\\n  // Jenish am I Hi\\n  int startWord = 0;\\n  int endWord = 0;\\n  int i = 0;\\n  while (i < length) {\\n    while (i < length && str[i] == \\' \\') {\\n      i++;\\n    }"], ["char * reverseWords(char * s){\\n    int i = 0;\\n    int j = 0;\\n    int a = strlen(s);\\n    char *res = malloc(a + 1);\\n    a--;\\n    int len = a;\\n    while (len >= 0)\\n    {\\n        while (len >= 0 && s[len] == \\' \\')\\n            len--;\\n        while (len >= 0 && s[len] != \\' \\' && ++i)\\n            len--;\\n        a = len + 1;\\n        while(--i >= 0)\\n            res[j++] = s[a++];\\n        res[j++] = \\' \\';\\n        i = 0;\\n    }"], ["char * reverseWords(char * s){\\n    int size = strlen(s);\\n\\n    char temp[50] = \"\";\\n    int temp_size = 0;\\n    char res[10001] = \"\";\\n    int res_size = 0;\\n    for(int i = size-1; i >= 0; i--){\\n        if ( s[i] != \\' \\' ){\\n            temp[temp_size++] = s[i];\\n            temp[temp_size] = \\'\\\\0\\';\\n        }"]]}
{"id": "700", "ref_c": ["\nint maxProduct(int* nums, int N){\n    int result = nums[0];\n    for(int i=1, MIN=result, MAX=result; i<N; i++){\n        if(nums[i]<0){\n            int save = MIN;\n            MIN = MAX;\n            MAX = save;\n        }\n        MAX *= nums[i];\n        MIN *= nums[i]; \n        MAX = nums[i] >= MAX ? nums[i] : MAX ;\n        MIN = nums[i] <= MIN ? nums[i] : MIN ;\n        result = result >= MAX ? result : MAX;\n    }\n    return result;\n}\n", "\nint maxProduct(int* nums, int N){\n    int result = nums[0];\n    for(int i=1, MIN=result, MAX=result; i<N; i++){\n        if(nums[i]<0){\n            int save = MIN;\n            MIN = MAX;\n            MAX = save;\n        }\n        MAX *= nums[i];\n        MIN *= nums[i]; \n        MAX = nums[i] >= MAX ? nums[i] : MAX ;\n        MIN = nums[i] <= MIN ? nums[i] : MIN ;\n        result = result >= MAX ? result : MAX;\n    }\n    return result;\n}\n", "\nint maxProduct(int* nums, int N){\n    int result = nums[0];\n    for(int i=1, MIN=result, MAX=result; i<N; i++){\n        if(nums[i]<0){\n            int save = MIN;\n            MIN = MAX;\n            MAX = save;\n        }\n        MAX *= nums[i];\n        MIN *= nums[i]; \n        MAX = nums[i] >= MAX ? nums[i] : MAX ;\n        MIN = nums[i] <= MIN ? nums[i] : MIN ;\n        result = result >= MAX ? result : MAX;\n    }\n    return result;\n}\n"]}
{"id": "701", "ref_c": [["int findMin(int* nums, int numsSize){\\n    int r = numsSize-1, l = 0, mid;\\n    if (!r) return nums[0]; // only one element\\n\\n    while (l < r)\\n    {\\n        mid = l + (r - l) / 2;\\n\\n        // got a part that is not rotated\\n        if (nums[l] < nums[r]) return nums[l]; \\n\\n        // mid is larger than right - min is in right side\\n        else if (nums[mid] > nums[r]) l = mid + 1;\\n\\n        // mid is smaller than right - min is in left side (including mid)\\n        else r = mid;\\n    }"], ["int findMin(int* nums, int numsSize){\\n    int r = numsSize-1, l = 0, mid;\\n    if (!r) return nums[0]; // only one element\\n\\n    while (l < r)\\n    {\\n        mid = l + (r - l) / 2;\\n\\n        // got a part that is not rotated\\n        if (nums[l] < nums[r]) return nums[l]; \\n\\n        // mid is larger than right - min is in right side\\n        else if (nums[mid] > nums[r]) l = mid + 1;\\n\\n        // mid is smaller than right - min is in left side (including mid)\\n        else r = mid;\\n    }"], ["int findMin(int* nums, int numsSize){\\n    int r = numsSize-1, l = 0, mid;\\n    if (!r) return nums[0]; // only one element\\n\\n    while (l < r)\\n    {\\n        mid = l + (r - l) / 2;\\n\\n        // got a part that is not rotated\\n        if (nums[l] < nums[r]) return nums[l]; \\n\\n        // mid is larger than right - min is in right side\\n        else if (nums[mid] > nums[r]) l = mid + 1;\\n\\n        // mid is smaller than right - min is in left side (including mid)\\n        else r = mid;\\n    }"]]}
{"id": "703", "ref_c": [["int findPeakElement(int* nums, int numsSize){\\n    return getPeak(nums,0,numsSize - 1,0,numsSize - 1);\\n}"], ["int findPeakElement(int* nums, int numsSize){\\n    return getPeak(nums,0,numsSize - 1,0,numsSize - 1);\\n}"], ["int findPeakElement(int* nums, int numsSize){\\n    return getPeak(nums,0,numsSize - 1,0,numsSize - 1);\\n}"]]}
{"id": "704", "ref_c": ["\nint compareVersion(char * version1, char * version2){\nint j = 0,i=0;\nint n1 = strlen(version1); \nint n2 = strlen(version2);\n\nint num1 = 0;\nint num2 = 0;\nwhile(i<n1 || j<n2)\n{\n    while(i<n1 && version1[i]!='.'){\n        num1 = num1*10+(version1[i]-'0');\n        i++;\n    }\n    \n    while(j<n2 && version2[j]!='.'){\n        num2 = num2*10+(version2[j]-'0');;\n        j++;\n    }\n    \n    if(num1>num2) return 1;\n    else if(num1 < num2) return -1;\n    \n    num1 = 0;\n    num2 = 0;\n    i++;\n    j++;\n}\n\nreturn 0;\n", "\nint compareVersion(char * version1, char * version2){\nint j = 0,i=0;\nint n1 = strlen(version1); \nint n2 = strlen(version2);\n\nint num1 = 0;\nint num2 = 0;\nwhile(i<n1 || j<n2)\n{\n    while(i<n1 && version1[i]!='.'){\n        num1 = num1*10+(version1[i]-'0');\n        i++;\n    }\n    \n    while(j<n2 && version2[j]!='.'){\n        num2 = num2*10+(version2[j]-'0');;\n        j++;\n    }\n    \n    if(num1>num2) return 1;\n    else if(num1 < num2) return -1;\n    \n    num1 = 0;\n    num2 = 0;\n    i++;\n    j++;\n}\n\nreturn 0;\n", "\nint compareVersion(char * version1, char * version2){\nint j = 0,i=0;\nint n1 = strlen(version1); \nint n2 = strlen(version2);\n\nint num1 = 0;\nint num2 = 0;\nwhile(i<n1 || j<n2)\n{\n    while(i<n1 && version1[i]!='.'){\n        num1 = num1*10+(version1[i]-'0');\n        i++;\n    }\n    \n    while(j<n2 && version2[j]!='.'){\n        num2 = num2*10+(version2[j]-'0');;\n        j++;\n    }\n    \n    if(num1>num2) return 1;\n    else if(num1 < num2) return -1;\n    \n    num1 = 0;\n    num2 = 0;\n    i++;\n    j++;\n}\n\nreturn 0;\n"]}
{"id": "705", "ref_c": [["char * fractionToDecimal(int numerator, int denominator){   //Assume: 1  6  Result: 0.1(6)\\n    long num = numerator, den = denominator;                //cast to long                    \\n    long integer = num / den;  //0\\n    \\n    int sign = 0;\\n    int iLen = length(integer);                             //1\\n    \\n    // Set positive for all\\n    if((long)num * den < 0){\\n        sign = 1;\\n        integer = -integer;\\n        num = abs1(num);\\n        den = abs1(den);\\n    }"], ["char * fractionToDecimal(int numerator, int denominator){\\n    char* ret = malloc(20000);\\n    char* p = ret;\\n    i64 a = numerator;\\n    i64 b = denominator;\\n    i64 r1, r2;\\n    i64 n1, n2;\\n    int i;\\n    int point = 0;\\n       \\n    a = labs(a);\\n    b = labs(b);\\n    \\n    r1 = r2 = a%b;\\n\\n    next(&r1, &n1, b);\\n\\n    next(&r2, &n2, b);\\n    next(&r2, &n2, b);\\n\\n    // has cycle\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n\\n        next(&r2, &n2, b);\\n        next(&r2, &n2, b);\\n    }"], ["char * fractionToDecimal(int numerator, int denominator){   //Assume: 1  6  Result: 0.1(6)\\n    long num = numerator, den = denominator;                //cast to long                    \\n    long integer = num / den;  //0\\n    \\n    int sign = 0;\\n    int iLen = length(integer);                             //1\\n    \\n    // Set positive for all\\n    if((long)num * den < 0){\\n        sign = 1;\\n        integer = -integer;\\n        num = abs1(num);\\n        den = abs1(den);\\n    }"]]}
{"id": "706", "ref_c": [["int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){\\n    *returnSize = 2;\\n    int* res = (int*)malloc(2*sizeof(int));\\n    int l = 0, r = numbersSize-1;\\n    \\n    while(1){\\n        int sum = numbers[l] + numbers[r];\\n        if (sum == target){\\n            res[0] = l+1;\\n            res[1] = r+1;\\n            return res;\\n        }"], ["int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){\\n    *returnSize = 2;\\n    int* res = (int*)malloc(2*sizeof(int));\\n    int l = 0, r = numbersSize-1;\\n    \\n    while(1){\\n        int sum = numbers[l] + numbers[r];\\n        if (sum == target){\\n            res[0] = l+1;\\n            res[1] = r+1;\\n            return res;\\n        }"], ["int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){\\n    *returnSize = 2;\\n    int* res = (int*)malloc(2*sizeof(int));\\n    int l = 0, r = numbersSize-1;\\n    \\n    while(1){\\n        int sum = numbers[l] + numbers[r];\\n        if (sum == target){\\n            res[0] = l+1;\\n            res[1] = r+1;\\n            return res;\\n        }"]]}
{"id": "707", "ref_c": [["int trailingZeroes(int n) {\\n    int count = 0;\\n    while (n > 0) {\\n        count += n / 5;\\n        n /= 5;\\n    }"], ["int trailingZeroes(int n){\\n    \\n    if (n < 5)\\n        return 0;\\n    \\n    int multi=5;\\n    int res = 0;\\n    while (n >= multi)\\n    {\\n        res = res + n/multi;\\n        multi*=5;\\n    }"], ["int trailingZeroes(int n) {\\n        // Negative Number Edge Case...\\n        if (n < 0)\\n\\t\\t    return -1;\\n        // Initialize the output result i.e., the number of trailing zeroes...\\n\\t    int output = 0;\\n        // Count number of 5s in prime factors of n!\\n\\t    for (long idx = 5; n/idx >= 1; idx *= 5) {\\n\\t\\t    output += n/idx;\\n\\t    }", "int trailingZeroes(int n) {\\n        int output = 0;\\n        for(int idx = 5; idx <= n; idx += 5) {\\n            int x = idx;\\n            while(x > 0 && x % 5 == 0) {\\n                ++output;\\n                x /= 5;\\n            }"]]}
{"id": "712", "ref_c": [["char * largestNumber(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    bool allZero = true; // check if all elements are zero\\n    int dig = 0; // count the digits of number\\n\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] != 0) allZero = false;\\n        int e = nums[i];\\n        if(e == 0) dig++; // deal with 0 element\\n        while(e){\\n            e /= 10;\\n            dig++;\\n        }"], ["char * largestNumber(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    bool allZero = true; // check if all elements are zero\\n    int dig = 0; // count the digits of number\\n\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] != 0) allZero = false;\\n        int e = nums[i];\\n        if(e == 0) dig++; // deal with 0 element\\n        while(e){\\n            e /= 10;\\n            dig++;\\n        }"], ["char * largestNumber(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    bool allZero = true; // check if all elements are zero\\n    int dig = 0; // count the digits of number\\n\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] != 0) allZero = false;\\n        int e = nums[i];\\n        if(e == 0) dig++; // deal with 0 element\\n        while(e){\\n            e /= 10;\\n            dig++;\\n        }"]]}
{"id": "715", "ref_c": [["char ** findRepeatedDnaSequences(char * s, int* returnSize){\\n    char **res;\\n    int stack[100000], sp=0, sl = strlen(s), i, j, k, code = 0;\\n    int stack2[10000], sp2=0;\\n    if (strlen(s) < 10) {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["char ** findRepeatedDnaSequences(char * s, int* returnSize){\\n    char **res;\\n    int stack[100000], sp=0, sl = strlen(s), i, j, k, code = 0;\\n    int stack2[10000], sp2=0;\\n    if (strlen(s) < 10) {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["char ** findRepeatedDnaSequences(char * s, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  s, DNA string\\n     */  \\n\\n    int len = strlen(s);\\n    char tmp;\\n    node_t trie;\\n    char **ans = (char **)(malloc(sizeof(char *) * 100000));\\n    \\n    *returnSize = 0;\\n    \\n    trie_init(&trie);\\n    \\n    if (len < 10) {\\n        return NULL;\\n    }"]]}
{"id": "716", "ref_c": [["void rotate(int* nums, int numsSize, int k){\\n//     while(k>0){\\n// int temp=nums[numsSize-1];\\n// for(int i=1;i<numsSize;i++){\\n//   nums[numsSize-i]=nums[numsSize-i-1];    \\n// }", "void rotate(int* nums, int numsSize, int k){\\n  k =k%numsSize;\\n\\n    reversearray(nums, 0, numsSize-1);\\n    reversearray(nums, 0, k-1);\\n    reversearray(nums, k, numsSize-1);\\n}"], ["void rotate(int* nums, int numsSize, int k){\\n//     while(k>0){\\n// int temp=nums[numsSize-1];\\n// for(int i=1;i<numsSize;i++){\\n//   nums[numsSize-i]=nums[numsSize-i-1];    \\n// }", "void rotate(int* nums, int numsSize, int k){\\n  k =k%numsSize;\\n\\n    reversearray(nums, 0, numsSize-1);\\n    reversearray(nums, 0, k-1);\\n    reversearray(nums, k, numsSize-1);\\n}"], ["void rotate(int* nums, int numsSize, int k){\\n    k %= numsSize;\\n    reverse(nums, 0, numsSize-1);\\n    reverse(nums, 0, k-1);\\n    reverse(nums, k, numsSize-1);\\n}"]]}
{"id": "719", "ref_c": [["int rob(int* nums, int numsSize) {\\n    if (numsSize == 0)\\n        return 0;\\n    if (numsSize == 1)\\n        return nums[0];\\n\\n    int evenSum = 0;\\n    int oddSum = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i % 2 == 0)\\n            evenSum = fmax(evenSum + nums[i], oddSum);\\n        else\\n            oddSum = fmax(oddSum + nums[i], evenSum);\\n    }"], ["int rob(int* nums, int numsSize){\\n    int dp[110],i;\\n    if(numsSize==1)\\n        return nums[0];\\n    else if (numsSize==2)\\n        return max(nums[0],nums[1]);\\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n    dp[2]=nums[2]+nums[0];\\n    for(i=3;i<(numsSize+2);i++){        \\n        dp[i]=max(dp[i-2],dp[i-3]);\\n        if(i<numsSize)\\n            dp[i]+=nums[i];\\n        printf(\"%d \",dp[i]);\\n    }"], ["int rob(int* nums, int numsSize) {\\n    if (numsSize == 0)\\n        return 0;\\n    if (numsSize == 1)\\n        return nums[0];\\n\\n    int evenSum = 0;\\n    int oddSum = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i % 2 == 0)\\n            evenSum = fmax(evenSum + nums[i], oddSum);\\n        else\\n            oddSum = fmax(oddSum + nums[i], evenSum);\\n    }"]]}
{"id": "720", "ref_c": [["int* rightSideView(struct TreeNode* root, int* returnSize){\\n    if (root == NULL){\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* rightSideView(struct TreeNode* root, int* returnSize) {\\n    int* arr = (int*)malloc(sizeof(int)*101);\\n    int i = 0;\\n    pre(root,arr,&i,0);\\n    (*returnSize) = i;\\n    return arr;\\n    \\n}"], ["int* rightSideView(struct TreeNode* root, int* returnSize) {\\n    int* arr = (int*)malloc(sizeof(int)*101);\\n    int i = 0;\\n    pre(root,arr,&i,0);\\n    (*returnSize) = i;\\n    return arr;\\n    \\n}"]]}
{"id": "721", "ref_c": ["\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\n{\n    if (i < 0 || j < 0 || i >= gridSize)\n        return;\n    if (j >= gridColSize[i])\n        return;\n    if (grid[i][j] == '0')\n        return;\n    grid[i][j] = '0';\n    visit(grid, i-1, j, gridSize, gridColSize);\n    visit(grid, i+1, j, gridSize, gridColSize);\n    visit(grid, i, j-1, gridSize, gridColSize);\n    visit(grid, i, j+1, gridSize, gridColSize);\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize){\n    int i, j;\n    int res = 0;\n    \n    for (i = 0; i < gridSize; i++) {\n        for (j = 0; j < gridColSize[i]; j++) {\n            if (grid[i][j] == '1') {\n                visit(grid, i, j, gridSize, gridColSize);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n", "\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\n{\n    if (i < 0 || j < 0 || i >= gridSize)\n        return;\n    if (j >= gridColSize[i])\n        return;\n    if (grid[i][j] == '0')\n        return;\n    grid[i][j] = '0';\n    visit(grid, i-1, j, gridSize, gridColSize);\n    visit(grid, i+1, j, gridSize, gridColSize);\n    visit(grid, i, j-1, gridSize, gridColSize);\n    visit(grid, i, j+1, gridSize, gridColSize);\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize){\n    int i, j;\n    int res = 0;\n    \n    for (i = 0; i < gridSize; i++) {\n        for (j = 0; j < gridColSize[i]; j++) {\n            if (grid[i][j] == '1') {\n                visit(grid, i, j, gridSize, gridColSize);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n", "\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\n{\n    if (i < 0 || j < 0 || i >= gridSize)\n        return;\n    if (j >= gridColSize[i])\n        return;\n    if (grid[i][j] == '0')\n        return;\n    grid[i][j] = '0';\n    visit(grid, i-1, j, gridSize, gridColSize);\n    visit(grid, i+1, j, gridSize, gridColSize);\n    visit(grid, i, j-1, gridSize, gridColSize);\n    visit(grid, i, j+1, gridSize, gridColSize);\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize){\n    int i, j;\n    int res = 0;\n    \n    for (i = 0; i < gridSize; i++) {\n        for (j = 0; j < gridColSize[i]; j++) {\n            if (grid[i][j] == '1') {\n                visit(grid, i, j, gridSize, gridColSize);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n"]}
{"id": "722", "ref_c": [["int rangeBitwiseAnd(int left, int right) {\\n\\n    int ans=0, pos=0, tmp_low=0;\\n    int pos_l = countSetBits(left);\\n    int pos_r = countSetBits(right);\\n\\n    if(left==right)\\n        return left;\\n\\n    if(!(left&right) || pos_l!=pos_r)\\n        return ans;\\n    else\\n        pos=pos_l;\\n\\n    ans=1<<pos;\\n    \\n    unsigned low=1U<<pos, high=(1U<<pos+1)-1;\\n\\n    while(--pos){   //O(1) -> Max 32 iterations\\n        tmp_low=SETBIT(low,pos);\\n        if(tmp_low<=left && right<=high){\\n            ans=SETBIT(ans,pos);\\n            low=tmp_low;\\n        }"], ["int rangeBitwiseAnd(int left, int right) {\\n    int shifts = 0, m=left, n=right;\\n    while( m < n ){\\n        m >>= 1;\\n        n >>= 1;\\n        shifts++;\\n    }"], ["int rangeBitwiseAnd(int left, int right){\\n\\tassert(left >= 0 && right >= 0);\\n\\n\\tint ret = 0;\\n\\n\\tfor (int mask = 1; mask > 0; *(unsigned int *)&mask <<= 1){\\n\\t\\tif (\\n\\t\\t\\t( (left & mask) != 0 && (right & mask) != 0 ) &&\\n\\t\\t\\tleft == right\\n\\t\\t){\\n\\t\\t\\tret |= mask;\\n\\t\\t}"]]}
{"id": "723", "ref_c": [["int countPrimes(int n) {\\n     if (n <= 2) {\\n        return 0;\\n    }"], ["int countPrimes(int n) {\\n    if (n <= 2) {\\n        return 0;\\n    }"], ["int countPrimes(int n) {\\n        if(n<=2) return 0;\\n        int track[n+1];\\n        memset(track,1,sizeof(track));\\n        track[0] = track[1] = 0;\\n        int count = 1;\\n        //Avoiding multiples of two in loop iterations.\\n        for(int i = 3;i<n;i+=2){\\n            if(track[i]){\\n                count++;\\n                for(int j = i;j<n;j+=i){\\n                    track[j] = 0;\\n                }"]]}
{"id": "724", "ref_c": [["bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){\\n    int cmap[2001][PREREQ_MAX]; /* Holds the prerequisites of each course.  */\\n    int cpr[2001]     = { 0 }"], ["bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){\\n    int cmap[2001][PREREQ_MAX]; /* Holds the prerequisites of each course.  */\\n    int cpr[2001]     = { 0 }"], ["bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize) {\\n    int *visited = calloc(sizeof(int), numCourses);\\n    int **graph = malloc(sizeof(int *) * numCourses);\\n    int *map = calloc(sizeof(int), numCourses);\\n\\n    for(int i = 0; i < numCourses; i++) {\\n        *(graph + i) = malloc(sizeof(int) * 100);\\n    }"]]}
{"id": "726", "ref_c": ["\nint minSubArrayLen(int target, int* nums, int numsSize) {\n    int min_length = 0, slide_summ = 0, low_index = 0, current_length;\n\n    for (int index = 0; index < numsSize; index++) {\n        slide_summ += nums[index];\n\n        if (slide_summ >= target){\n          while (slide_summ >= target){\n            slide_summ -= nums[low_index];\n            low_index++;\n          }\n\n          current_length = index - low_index + 2;\n\n          if ( (current_length < min_length) || (min_length == 0) )\n            min_length = current_length;\n        }\n    }\n    return min_length;\n}\n", "\nint minSubArrayLen(int target, int* nums, int numsSize) {\n    int min_length = 0, slide_summ = 0, low_index = 0, current_length;\n\n    for (int index = 0; index < numsSize; index++) {\n        slide_summ += nums[index];\n\n        if (slide_summ >= target){\n          while (slide_summ >= target){\n            slide_summ -= nums[low_index];\n            low_index++;\n          }\n\n          current_length = index - low_index + 2;\n\n          if ( (current_length < min_length) || (min_length == 0) )\n            min_length = current_length;\n        }\n    }\n    return min_length;\n}\n", "\nint minSubArrayLen(int target, int* nums, int numsSize) {\n    int min_length = 0, slide_summ = 0, low_index = 0, current_length;\n\n    for (int index = 0; index < numsSize; index++) {\n        slide_summ += nums[index];\n\n        if (slide_summ >= target){\n          while (slide_summ >= target){\n            slide_summ -= nums[low_index];\n            low_index++;\n          }\n\n          current_length = index - low_index + 2;\n\n          if ( (current_length < min_length) || (min_length == 0) )\n            min_length = current_length;\n        }\n    }\n    return min_length;\n}\n"]}
{"id": "727", "ref_c": [["int* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize) {\\n    *returnSize = 0;\\n    int* res = calloc(numCourses, sizeof(int));\\n    if(numCourses <= 1) {\\n        *returnSize = 1;\\n        return res;\\n    }"], ["int* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize) {\\n    *returnSize = 0;\\n    int* res = calloc(numCourses, sizeof(int));\\n    if(numCourses <= 1) {\\n        *returnSize = 1;\\n        return res;\\n    }"], ["int* findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int* returnSize) {\\n    *returnSize = 0;\\n    int* res = calloc(numCourses, sizeof(int));\\n    if(numCourses <= 1) {\\n        *returnSize = 1;\\n        return res;\\n    }"]]}
{"id": "729", "ref_c": [["int rob(int* nums, int numsSize)\\n{\\n    if (numsSize == 1 ){return nums[0];}"], ["int rob(int* nums, int numsSize){ \\n    if(numsSize == 1) { \\n        return nums[0];\\n    }", "int rob(int* nums, int numsSize){ \\n    if(numsSize == 1) \\n        return nums[0];  \\n    int *dp1 = calloc(numsSize, sizeof(int)), *dp2 = calloc(numsSize, sizeof(int)), i; \\n    for(i = 0; i < numsSize ; i++) \\n        dp1[i] = dp2[i] = -1;\\n\\n\\n    int res1 = fill(nums, 0, numsSize-2, dp1); \\n    int res2 = fill(nums, 1, numsSize-1, dp2); \\n    return res1 > res2 ? res1 : res2;\\n}"], ["int rob(int* nums, int numsSize){ \\n    if(numsSize == 1) { \\n        return nums[0];\\n    }", "int rob(int* nums, int numsSize){ \\n    if(numsSize == 1) \\n        return nums[0];  \\n    int *dp1 = calloc(numsSize, sizeof(int)), *dp2 = calloc(numsSize, sizeof(int)), i; \\n    for(i = 0; i < numsSize ; i++) \\n        dp1[i] = dp2[i] = -1;\\n\\n\\n    int res1 = fill(nums, 0, numsSize-2, dp1); \\n    int res2 = fill(nums, 1, numsSize-1, dp2); \\n    return res1 > res2 ? res1 : res2;\\n}"]]}
{"id": "730", "ref_c": [["int findKthLargest(int* nums, int numsSize, int k){    \\n    int max = INT_MIN;\\n    int min = INT_MAX;\\n    int i;\\n    \\n    for(i=0;i<numsSize;i++){\\n        if(nums[i] > max)\\n            max = nums[i];\\n        if(nums[i] < min)\\n            min = nums[i];\\n    }"], ["int findKthLargest(int* nums, int numsSize, int k){\\n    int ans[100001]={0}"], ["int findKthLargest(int* nums, int numsSize, int k){    \\n    int max = INT_MIN;\\n    int min = INT_MAX;\\n    int i;\\n    \\n    for(i=0;i<numsSize;i++){\\n        if(nums[i] > max)\\n            max = nums[i];\\n        if(nums[i] < min)\\n            min = nums[i];\\n    }"]]}
{"id": "731", "ref_c": [["int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){\\n\\n    // the max in C{9, h}"], ["int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){\\n    int candidates[] = { 1,2,3,4,5,6,7,8,9}"], ["int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){\\n    int tBuf[k];\\n    int **ret = NULL;\\n    *returnSize = 0;\\n    ret = (int**)malloc(sizeof(int*) * 100);\\n    *returnColumnSizes = (int*)malloc(sizeof(int) * 100);\\n    fun(ret, n, k, 0, returnSize, *returnColumnSizes, 1, tBuf);\\n    return ret;\\n}"]]}
{"id": "732", "ref_c": [["int maximalSquare(char** matrix, int matrixSize, int* matrixColSize){\\n\\n    int **intMatrix  = malloc(sizeof(int*) * matrixSize);\\n    for (int i = 0; i < matrixSize; i++)\\n    {\\n        intMatrix[i] = malloc(sizeof(int) * (*matrixColSize));\\n        for (int j = 0; j < *matrixColSize; j++)\\n            intMatrix[i][j] = matrix[i][j] - \\'0\\';\\n    }"], ["int maximalSquare(char** matrix, int matrixSize, int* matrixColSize) {\\n    if(matrixSize == 0){\\n        return 0;\\n    }"], ["int maximalSquare(char** matrix, int matrixSize, int* matrixColSize){\\n\\n    /*\\n     * Input:\\n     *  **matrix\\n     *  matrixSize\\n     *  *matrixColSize\\n     */\\n\\n    int height, width;\\n    int min = INT_MAX, max = INT_MIN;\\n    int lookup[300][300];\\n\\n    /* \\n     * Check the maximum column length of each grid with a continuous value of 1 \\n     * E.g. \\n     *  matrix = [[\\'1\\', \\'0\\', \\'1\\']\\n     *            [\\'0\\', \\'1\\', \\'1\\']\\n     *            [\\'1\\', \\'1\\', \\'1\\']]\\n     *\\n     *  =>\\n     *  lookup = [[1, 0, 1]\\n     *            [0, 2, 1]\\n     *            [3, 2, 1]]\\n     */\\n    for (int x = matrixSize - 1; x >= 0; x--) {\\n        for (int y = matrixColSize[0] - 1; y >= 0; y--) {\\n            if (y == matrixColSize[0] - 1) {\\n                lookup[x][y] = ((matrix[x][y] == \\'1\\') ? 1 : 0);\\n            }"]]}
{"id": "733", "ref_c": [["int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        return (abs((ax2 - ax1)*(ay2 - ay1)) + abs((bx2 - bx1)*(by2 - by1)) - ((bx2 <= ax1 || ax2 <= bx1) ? 0 : min(bx2, ax2) - max(bx1, ax1)) * ((by2 <= ay1 || ay2 <= by1) ? 0 : min(by2, ay2) - max(by1, ay1)));\\n    }"], ["int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2)\\n{\\n   int a = abs(ax2 - ax1) * abs(ay2 - ay1);\\n   int b = abs(bx2 - bx1) * abs(by2 - by1);\\n   int cx1 = max(ax1,bx1);\\n   int cx2 = min(ax2,bx2);\\n   int cy1 = max(ay1,by1);\\n   int cy2 = min(ay2,by2);\\n   int cl = max(0 , cx2 - cx1);\\n   int cb = max(0 , cy2 - cy1);\\n   int c = cl * cb ;\\n   return a + b - c;\\n}"], ["int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2){\\n    \\n    int len_A, height_A, len_B, height_B, S_A, S_B;\\n\\n    len_A = ax2 - ax1;\\n    height_A = ay2 - ay1;\\n    len_B = bx2 - bx1;\\n    height_B = by2 - by1;\\n    \\n    S_A = len_A * height_A;\\n    S_B = len_B * height_B;\\n\\n    int minx1 = (ax1 < bx1) ? ax1 : bx1;\\n    int minx2 = (ax2 < bx2) ? ax2 : bx2;\\n    int minx = (minx1 < minx2) ? minx1 : minx2;\\n\\n    int maxx1 = (ax1 > bx1) ? ax1 : bx1;\\n    int maxx2 = (ax2 > bx2) ? ax2 : bx2;\\n    int maxx = (maxx1 > maxx2) ? maxx1 : maxx2;\\n\\n    int miny1 = (ay1 < by1) ? ay1 : by1;\\n    int miny2 = (ay2 < by2) ? ay2 : by2;\\n    int miny = (miny1 < miny2) ? miny1 : miny2;\\n\\n    int maxy1 = (ay2 > by2) ? ay2 : by2;\\n    int maxy2 = (ay1 > by1) ? ay1 : by1;\\n    int maxy = (maxy1 > maxy2) ? maxy1 : maxy2;\\n\\n    int len_x = maxx - minx;\\n    int len_y = maxy - miny;\\n\\n    int same_len = len_x - (len_A + len_B);\\n    int same_height = len_y - (height_A + height_B);\\n\\n    if(same_len > 0 || same_height > 0){\\n        return S_A + S_B;\\n    }"]]}
{"id": "734", "ref_c": [["int calculate(char * s){\\n\\n    return term(&s);\\n}"], ["int calculate(char * s){\\n\\n    return term(&s);\\n}"], ["int calculate(char * s) {\\n    return f(s, 0, strlen(s)-1);\\n}"]]}
{"id": "735", "ref_c": [["int* majorityElement(int* nums, int numsSize, int* returnSize) {\\n    int* result = NULL;\\n    int candidate1 = 0, candidate2 = 0, count1 = 0, count2 = 0;\\n    int threshold = numsSize / 3;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        int num = nums[i];\\n        if (num == candidate1) {\\n            count1++;\\n        }"], ["int* majorityElement(int* nums, int numsSize, int* returnSize) {\\n    int* ans = (int*)malloc(2 * sizeof(int));\\n    int n = numsSize / 3;\\n    int* map = (int*)calloc(10001, sizeof(int));\\n\\n    *returnSize = 0;\\n\\n    // Count the frequencies of elements in the input array.\\n    for (int i = 0; i < numsSize; i++) {\\n        map[nums[i]]++;\\n    }", "int* majorityElement(int* nums, int numsSize, int* returnSize) {\\n    if (numsSize == 1) {\\n        *returnSize = 1;\\n        return nums;\\n    }", "int* majorityElement(int* nums, int numsSize, int* returnSize) {\\n    int cnt1 = 0, cnt2 = 0; // Initialize counters for two potential majority elements.\\n    int el1 = 0, el2 = 0; // Initialize variables to store the two potential majority elements.\\n\\n    // First pass to find potential majority elements.\\n    for (int i = 0; i < numsSize; i++) {\\n        if (cnt1 == 0 && nums[i] != el2) {\\n            cnt1 = 1;\\n            el1 = nums[i];\\n        }"], ["int* majorityElement(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(2 * sizeof(int));\\n    if (result == NULL) {\\n        *returnSize = 0;\\n        return NULL;\\n    }", "int* majorityElement(int* nums, int numsSize, int* returnSize) {\\n    int candidate1 = 0, candidate2 = 0;\\n    int count1 = 0, count2 = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == candidate1) {\\n            count1++;\\n        }", "int* majorityElement(int* nums, int numsSize, int* returnSize) {\\n    int mapSize = 2; \\n    struct Entry* hashMap = (struct Entry*)malloc(sizeof(struct Entry) * mapSize);\\n    if (hashMap == NULL) {\\n        perror(\"Memory allocation failed\");\\n        exit(EXIT_FAILURE);\\n    }", "int* majorityElement(int* nums, int numsSize, int* returnSize) {\\n    qsort(nums, numsSize, sizeof(int), compare);\\n    int* result = (int*)malloc(sizeof(int) * 2); // At most 2 majority elements\\n    *returnSize = 0;\\n    int count = 1;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] == nums[i - 1]) {\\n            count++;\\n        }", "int* majorityElement(int* nums, int numsSize, int* returnSize) {\\n    int candidate1 = 0, candidate2 = 0;\\n    int count1 = 0, count2 = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == candidate1) {\\n            count1++;\\n        }"]]}
{"id": "736", "ref_c": [["int kthSmallest(struct TreeNode* root, int k) {\\n\\n    if (root == NULL || k < 0)\\n        return -1;\\n    struct TreeNode *ans;\\n    ans = inorder(root, &k);\\n\\n    if(!ans)\\n        return NULL;\\n    else\\n        return ans->val;\\n    \\n}"], ["int kthSmallest(struct TreeNode* root, int k) {\\n    int count = 0;//count = i would mean that we are the ith smallest element.\\n    int num;//num to be returned\\n    int* num_ref = &num;\\n    int* count_ref = &count;\\n    kthSmallestHelper(root, k, count_ref, num_ref);\\n    return num;\\n}"], ["int kthSmallest(struct TreeNode* root, int k) {\\n\\n    if (root == NULL || k < 0)\\n        return -1;\\n    struct TreeNode *ans;\\n    ans = inorder(root, &k);\\n\\n    if(!ans)\\n        return NULL;\\n    else\\n        return ans->val;\\n    \\n}"]]}
{"id": "737", "ref_c": [["struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    // Loop till root becomes null...\\n    while(root!= NULL){\\n        // If the value of p node and the q node is greater than the value of root node...\\n        if(p->val > root->val && q->val > root->val){\\n            root = root->right;\\n        }"], ["struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    if(root == p || root == q || !root) return root;   // found what we want or there is nothing\\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    return !left?right:!right?left:root;\\n}", "struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n     \\n    // found what we want or there is nothing\\n    if(root == p || root == q || !root) \\n        return root;   // found what we want or there is nothing\\n    \\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    \\n    if (left && right)\\n        return root\\n    else if (left)\\n        return left\\n    else if (right)\\n        return right\\n    else \\n        return NULL;\\n}"], ["struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    if (!root) {\\n                return NULL;\\n                    }"]]}
{"id": "738", "ref_c": ["\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if (root == NULL || root == p || root == q) {\n        return root;\n    }\n    struct TreeNode* leftLCA = lowestCommonAncestor(root->left, p, q);\n    struct TreeNode* rightLCA = lowestCommonAncestor(root->right, p, q);\n    if (leftLCA != NULL && rightLCA != NULL) {\n        return root;\n    }\n    return (leftLCA != NULL) ? leftLCA : rightLCA;\n}\n", "\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if (root == NULL || root == p || root == q) {\n        return root;\n    }\n    struct TreeNode* leftLCA = lowestCommonAncestor(root->left, p, q);\n    struct TreeNode* rightLCA = lowestCommonAncestor(root->right, p, q);\n    if (leftLCA != NULL && rightLCA != NULL) {\n        return root;\n    }\n    return (leftLCA != NULL) ? leftLCA : rightLCA;\n}\n", "\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if (root == NULL || root == p || root == q) {\n        return root;\n    }\n    struct TreeNode* leftLCA = lowestCommonAncestor(root->left, p, q);\n    struct TreeNode* rightLCA = lowestCommonAncestor(root->right, p, q);\n    if (leftLCA != NULL && rightLCA != NULL) {\n        return root;\n    }\n    return (leftLCA != NULL) ? leftLCA : rightLCA;\n}\n"]}
{"id": "739", "ref_c": [["void deleteNode(struct ListNode* node) {\\n    struct ListNode *prev = node , *curr = node->next;\\n    while(curr != NULL)\\n    {\\n        int temp = prev->val;\\n        prev->val = curr->val;\\n        curr->val = temp;\\n        if(prev->next->next == NULL)\\n        {\\n            prev->next = NULL;\\n            curr = curr->next;\\n        }"], ["void deleteNode(struct ListNode* node) {\\n    node->val=node->next->val;\\n    node->next=node->next->next;\\n}"], ["void deleteNode(struct ListNode* node) {\\n    node->val = node->next->val;\\n    node->next = node->next->next;\\n}"]]}
{"id": "740", "ref_c": ["\nint* productExceptSelf(int* nums, int numsSize, int* returnSize){\n    *returnSize = numsSize;\n    int *res=malloc(numsSize*sizeof(int));\n    int prefix=1; //first store prefix in the res array\n    for(int i=0;i<numsSize;i++)\n    {\n        res[i]=prefix;\n        prefix = prefix*nums[i];\n    }\n    int postfix=1; //traverse from the end of the array and store postfix\n    for(int i=numsSize-1;i>=0;i--)\n    {\n        res[i]=res[i]*postfix;\n        postfix = nums[i]*postfix;\n    }\n    return res;\n}\n", "\nint* productExceptSelf(int* nums, int numsSize, int* returnSize){\n    *returnSize = numsSize;\n    int *res=malloc(numsSize*sizeof(int));\n    int prefix=1; //first store prefix in the res array\n    for(int i=0;i<numsSize;i++)\n    {\n        res[i]=prefix;\n        prefix = prefix*nums[i];\n    }\n    int postfix=1; //traverse from the end of the array and store postfix\n    for(int i=numsSize-1;i>=0;i--)\n    {\n        res[i]=res[i]*postfix;\n        postfix = nums[i]*postfix;\n    }\n    return res;\n}\n", "\nint* productExceptSelf(int* nums, int numsSize, int* returnSize){\n    *returnSize = numsSize;\n    int *res=malloc(numsSize*sizeof(int));\n    int prefix=1; //first store prefix in the res array\n    for(int i=0;i<numsSize;i++)\n    {\n        res[i]=prefix;\n        prefix = prefix*nums[i];\n    }\n    int postfix=1; //traverse from the end of the array and store postfix\n    for(int i=numsSize-1;i>=0;i--)\n    {\n        res[i]=res[i]*postfix;\n        postfix = nums[i]*postfix;\n    }\n    return res;\n}\n"]}
{"id": "741", "ref_c": [["bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    \\n    int row = matrixSize - 1;\\n    int col = 0;\\n    \\n    while (row >= 0 && col < *matrixColSize){\\n        if (matrix[row][col] > target) row--;\\n        else if (matrix[row][col] < target) col++;\\n        else return true;\\n    }"], ["bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    int i = 0, j = *matrixColSize - 1;\\n    while (i>=0 && j>= 0 && i<matrixSize && j<*matrixColSize){\\n        if (matrix[i][j] == target) return true;\\n\\n        if (matrix[i][j] < target) i++;\\n        else j--;\\n    }"], ["bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    int i = 0, j = *matrixColSize - 1;\\n    while (i>=0 && j>= 0 && i<matrixSize && j<*matrixColSize){\\n        if (matrix[i][j] == target) return true;\\n\\n        if (matrix[i][j] < target) i++;\\n        else j--;\\n    }"]]}
{"id": "742", "ref_c": [["int* diffWaysToCompute(char * expression, int* returnSize){\\n    if(strlen(expression) == 1) {\\n        int *result = malloc(sizeof(int));\\n        result[0] = expression[0] - 48;\\n        *returnSize = 1;\\n        return result;\\n    }"], ["int* diffWaysToCompute(char * expression, int* returnSize){\\n    if(strlen(expression) == 1) {\\n        int *result = malloc(sizeof(int));\\n        result[0] = expression[0] - 48;\\n        *returnSize = 1;\\n        return result;\\n    }"], ["int* diffWaysToCompute(char * expression, int* returnSize){\\n    if(strlen(expression) == 1) {\\n        int *result = malloc(sizeof(int));\\n        result[0] = expression[0] - 48;\\n        *returnSize = 1;\\n        return result;\\n    }"]]}
{"id": "743", "ref_c": [["int* singleNumber(int* nums, int numsSize, int* returnSize){\\n    int res=0,x;\\n    int* arr=(int*)malloc(2*sizeof(int));\\n    arr[0]=0;\\n    arr[1]=0;\\n    for(int i=0;i<numsSize;i++)\\n        res=res^nums[i];\\n    if(res == (-2147483648))\\n        x=0;      \\n    else\\n        x = -res;\\n    int mask=res & x;\\n    for(int i=0;i<numsSize;i++){\\n        if((mask&nums[i])!=0)\\n            arr[0]=arr[0]^nums[i];\\n    }"], ["int* singleNumber(int* nums, int numsSize, int* returnSize) {\\n\\n    int* results = (int *)calloc(2, sizeof(int));\\n    int xorNums = 0;\\n    for(int i=0; i<numsSize; i++){\\n        xorNums ^= nums[i];\\n    }"], ["int* singleNumber(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = 2;\\n    int* result = (int*) malloc(2 * sizeof(int));\\n    \\n    unsigned int xorAll = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        xorAll ^= nums[i];\\n    }"]]}
{"id": "744", "ref_c": [["int nthUglyNumber(int n) {\\n        int[] arr = new int[n + 1];\\n        int i2 = 1, i3 = 1, i5 = 1;\\n        arr[1] = 1;\\n        for(int i = 2; i <= n; i++){\\n            int i2ugly = arr[i2] * 2;\\n            int i3ugly = arr[i3] * 3;\\n            int i5ugly = arr[i5] * 5;\\n            arr[i] = Math.min(i2ugly, Math.min(i3ugly, i5ugly));\\n            if(arr[i] == i2ugly) i2++;\\n            if(arr[i] == i3ugly) i3++;\\n            if(arr[i] == i5ugly) i5++;\\n        }", "int nthUglyNumber(int n) {\\n        vector<int> arr(n + 1);\\n        int i2 = 1, i3 = 1, i5 = 1;\\n        arr[1] = 1;\\n        for(int i = 2; i <= n; i++){\\n            int i2ugly = arr[i2] * 2;\\n            int i3ugly = arr[i3] * 3;\\n            int i5ugly = arr[i5] * 5;\\n            arr[i] = min({i2ugly, i3ugly, i5ugly}", "int nthUglyNumber(int n){\\n    int arr[n + 1];\\n    int i2 = 1, i3 = 1, i5 = 1;\\n    arr[1] = 1;\\n    for(int i = 2; i <= n; i++){\\n        int i2ugly = arr[i2] * 2;\\n        int i3ugly = arr[i3] * 3;\\n        int i5ugly = arr[i5] * 5;\\n        arr[i] = min(i2ugly, min(i3ugly, i5ugly));\\n        if(arr[i] == i2ugly) i2++;\\n        if(arr[i] == i3ugly) i3++;\\n        if(arr[i] == i5ugly) i5++;\\n    }"], ["int nthUglyNumber(int n) {\\n        int c2 = 0,c3 = 0,c5 = 0;\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = Math.min(2*dp[c2],Math.min(3*dp[c3],dp[c5]*5));\\n            if(dp[i] == 2*dp[c2])\\n                c2++;\\n            if(dp[i] == 3*dp[c3])\\n                c3++;\\n            if(dp[i] == 5*dp[c5])\\n                c5++;\\n        }"], ["int nthUglyNumber(int n){\\n    int insanityOrCourage[]={1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400}"]]}
{"id": "745", "ref_c": [["int hIndex(int* citations, int citationsSize){\\n    int *buckets = calloc(citationsSize+1, sizeof(*buckets));\\n\\n    for (int i = 0; i < citationsSize; ++i) {\\n        if(citations[i] >= citationsSize) {\\n            buckets[citationsSize]++;\\n        }"], ["int hIndex(int* citations, int citationsSize) {\\n    \\n   void quicksort(int* citations,int low,int high){  \\n int x, y, p, temp;\\nif(low<high){\\n    p=low;\\n    x=low;\\n    y=high;\\n    while(x<y){\\n        while(citations[x]<=citations[p]&&x<high)\\n        x++;\\n            while(citations[y]>citations[p])\\n            y--;\\n            if(x<y){\\n                temp=citations[x];\\n                citations[x]=citations[y];\\n                citations[y]=temp;\\n            }"], ["int hIndex(int* citations, int citationsSize) {\\n    \\n   void quicksort(int* citations,int low,int high){  \\n int x, y, p, temp;\\nif(low<high){\\n    p=low;\\n    x=low;\\n    y=high;\\n    while(x<y){\\n        while(citations[x]<=citations[p]&&x<high)\\n        x++;\\n            while(citations[y]>citations[p])\\n            y--;\\n            if(x<y){\\n                temp=citations[x];\\n                citations[x]=citations[y];\\n                citations[y]=temp;\\n            }"]]}
{"id": "746", "ref_c": [["int hIndex(int* citations, int citationsSize){\\n\\tint start = 0, end = citationsSize-1, ans = 0;\\n\\twhile(start<=end){\\n\\t\\tint mid = start + (end - start)/2;\\n\\t\\tif(citations[mid] >= citationsSize - mid) {\\n\\t\\t\\tans = fmax(ans,(int)citationsSize - mid); end = mid - 1;\\n\\t\\t}"], ["int hIndex(int* citations, int citationsSize){\\n\\tint start = 0, end = citationsSize-1, ans = 0;\\n\\twhile(start<=end){\\n\\t\\tint mid = start + (end - start)/2;\\n\\t\\tif(citations[mid] >= citationsSize - mid) {\\n\\t\\t\\tans = fmax(ans,(int)citationsSize - mid); end = mid - 1;\\n\\t\\t}"], ["int hIndex(int* citations, int citationsSize) {\\n    // Binary search\\n\\n    // Time complexity: O(logn)\\n    // Space complexity: O(1)\\n\\n    const int n = citationsSize;\\n    int left = 0, right = n, middle = 0;\\n    while (left < right) {\\n        middle = left + (right - left) / 2;\\n        if (citations[middle] + middle >= n) {\\n            right = middle;\\n        }", "int hIndex(int* citations, int citationsSize) {\\n    // Binary search\\n\\n    // Time complexity: O(logn)\\n    // Space complexity: O(1)\\n\\n    const int n = citationsSize;\\n    int left = 0, right = n - 1, middle = 0;\\n    while (left <= right) {\\n        middle = left + (right - left) / 2;\\n        if (citations[middle] + middle == n) {\\n            return n - middle;\\n        }"]]}
{"id": "747", "ref_c": [["int numSquares(int n) {\\n        \\n        \\n        int[] dp = new int[n+1];\\n        \\n        // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n        for( int i = 1 ; i < dp.length; i++){\\n            dp[ i ] = Integer.MAX_VALUE;\\n        }", "int numSquares(int n) {\\n        \\n        vector< int > dp = vector< int > (n+1, INT_MAX );\\n        \\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = min( dp[ i ], dp[ i - square ] + 1 );\\n            }"], ["int numSquares(int n) {\\n    while (n % 4 == 0)\\n        n /= 4;\\n    if (n % 8 == 7) return 4;\\n    if (isSquare(n)) return 1;\\n    for (int i = 1; i * i <= n; i++) {\\n        if (isSquare(n - i * i)) return 2;\\n    }"], ["int numSquares(int n){\\n    if (n <= 0) return 0;\\n    int* dp = (int*)malloc((n + 1) * sizeof(int));\\n    for (int i = 0; i <= n; i++) {\\n        dp[i] = INT_MAX;\\n    }"]]}
{"id": "749", "ref_c": ["\nint findDuplicate(vector<int>& nums) {\n        int i=nums[0];\n        while(1){\n            if(nums[i]==0) return i;\n            int t=nums[i];\n            nums[i]=0; //marking visited element\n            i=t;\n        }\n    }\n};\n", "\nint findDuplicate(vector<int>& nums) {\n        int i=nums[0];\n        while(1){\n            if(nums[i]==0) return i;\n            int t=nums[i];\n            nums[i]=0; //marking visited element\n            i=t;\n        }\n    }\n};\n", "\nint findDuplicate(vector<int>& nums) {\n        int i=nums[0];\n        while(1){\n            if(nums[i]==0) return i;\n            int t=nums[i];\n            nums[i]=0; //marking visited element\n            i=t;\n        }\n    }\n};\n"]}
{"id": "750", "ref_c": [["void gameOfLife(int** board, int boardSize, int* boardColSize) {\\n    // 0 -> 1 => 3; 1 -> 0 => 4;    \\n    for(int r = 0; r < boardSize; r++){\\n        for(int c = 0; c < *boardColSize; c++){\\n            int sumNeighbor = 0;\\n            for(int i = r-1; i <= (r+1); i++){\\n                if((i < 0) || (i >= boardSize)) continue;\\n                for(int j = c-1; j <= (c+1); j++){\\n                    if((j < 0) || (j >= *boardColSize)) continue;\\n                    sumNeighbor += (board[i][j]%3);\\n                }"], ["void gameOfLife(int** board, int boardSize, int* boardColSize) {\\n    int dirX[] = {-1, -1, -1, 0, 0, 1, 1, 1}"], ["void gameOfLife(int** board, int boardSize, int* boardColSize) {\\n    int dirX[] = {-1, -1, -1, 0, 0, 1, 1, 1}"]]}
{"id": "751", "ref_c": [["char * getHint(char * secret, char * guess){\\nint cows=0,bulls=0;\\nint n=strlen(secret);\\n//COUNTING BULLS\\nfor(int i=0;i<n;i++){\\n    if(secret[i]==guess[i]){\\nsecret[i]=guess[i]=\\'X\\';\\n    bulls++;\\n    }"], ["char * getHint(char * secret, char * guess){\\n    int bull = 0, cow  = 0;\\n    int dp[128] = {}"], ["char * getHint(char * secret, char * guess){\\n    int bull = 0, cow  = 0;\\n    int dp[128] = {}"]]}
{"id": "752", "ref_c": [["int lengthOfLIS(int* nums, int numsSize){\\n    \\n    int size[numsSize];\\n    size[0] = 1;\\n    \\n    for(int i=1; i < numsSize; i++){\\n        size[i] = 1;\\n        for(int j=0; j < i; j++){\\n            if (nums[i] > nums[j]) size[i] = MAX(size[j] + 1, size[i]);\\n        }"], ["int lengthOfLIS(int* nums, int numsSize){\\n    \\n    int size[numsSize];\\n    size[0] = 1;\\n    \\n    for(int i=1; i < numsSize; i++){\\n        size[i] = 1;\\n        for(int j=0; j < i; j++){\\n            if (nums[i] > nums[j]) size[i] = MAX(size[j] + 1, size[i]);\\n        }"], ["int lengthOfLIS(int* nums, int numsSize){\\n    \\n    int size[numsSize];\\n    size[0] = 1;\\n    \\n    for(int i=1; i < numsSize; i++){\\n        size[i] = 1;\\n        for(int j=0; j < i; j++){\\n            if (nums[i] > nums[j]) size[i] = MAX(size[j] + 1, size[i]);\\n        }"]]}
{"id": "754", "ref_c": [["bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n){\\n    for (int i = 0; i < flowerbedSize; i++) {\\n        if (flowerbed[i] == 0) {\\n            if (i == 0 && flowerbedSize < 3 || \\n                i == 0  && (i + 1) < flowerbedSize && flowerbed[i + 1] == 0 ||\\n                i == (flowerbedSize - 1) && (i - 1) >= 0 && flowerbed[i - 1] == 0 ||\\n                (i - 1) >= 0 && (i + 1) < flowerbedSize && flowerbed[i- 1] == 0 && flowerbed[i] == 0 && flowerbed[i + 1] == 0) {\\n                    n--;\\n                    flowerbed[i] = 1;\\n                }"], ["bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n){\\n    for (int i = 0; i < flowerbedSize; i++) {\\n        if (flowerbed[i] == 0) {\\n            if (i == 0 && flowerbedSize < 3 || \\n                i == 0  && (i + 1) < flowerbedSize && flowerbed[i + 1] == 0 ||\\n                i == (flowerbedSize - 1) && (i - 1) >= 0 && flowerbed[i - 1] == 0 ||\\n                (i - 1) >= 0 && (i + 1) < flowerbedSize && flowerbed[i- 1] == 0 && flowerbed[i] == 0 && flowerbed[i + 1] == 0) {\\n                    n--;\\n                    flowerbed[i] = 1;\\n                }"], ["bool canPlaceFlowers(int* flowerbed, int flowerbedSize, int n){\\n    for (int i = 0; i < flowerbedSize; i++) {\\n        if (flowerbed[i] == 0) {\\n            if (i == 0 && flowerbedSize < 3 || \\n                i == 0  && (i + 1) < flowerbedSize && flowerbed[i + 1] == 0 ||\\n                i == (flowerbedSize - 1) && (i - 1) >= 0 && flowerbed[i - 1] == 0 ||\\n                (i - 1) >= 0 && (i + 1) < flowerbedSize && flowerbed[i- 1] == 0 && flowerbed[i] == 0 && flowerbed[i + 1] == 0) {\\n                    n--;\\n                    flowerbed[i] = 1;\\n                }"]]}
{"id": "756", "ref_c": [["int maxProfit(int* prices, int pricesSize) {\\n if(pricesSize==1) return 0;\\n int cooldown=0;\\n int buy=1;\\n int index=0;\\n int *** dp= (int***)malloc(sizeof(int**)*pricesSize);\\n for(int i=0;i<pricesSize;i++){\\n     dp[i]=(int**)malloc(sizeof(int*)*2);\\n     for(int j=0;j<2;j++){\\n         dp[i][j]=(int*)malloc(sizeof(int)*2);\\n     }"], ["int maxProfit(int* prices, int pricesSize){\\n    if(pricesSize == 1) return 0;\\n\\n    // declare buy, sell & cooldown state machine and input first price\\n    int anBuy[2] = {-(*prices), 0}"], ["int maxProfit(int* prices, int pricesSize) {\\n if(pricesSize==1) return 0;\\n int cooldown=0;\\n int buy=1;\\n int index=0;\\n int *** dp= (int***)malloc(sizeof(int**)*pricesSize);\\n for(int i=0;i<pricesSize;i++){\\n     dp[i]=(int**)malloc(sizeof(int*)*2);\\n     for(int j=0;j<2;j++){\\n         dp[i][j]=(int*)malloc(sizeof(int)*2);\\n     }"]]}
{"id": "757", "ref_c": [["int* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    \\n    if(n<=2){\\n        *returnSize  = n;\\n        int* early_return = malloc(sizeof(int)*n);\\n        for(int i=0; i<n; i++){\\n            early_return[i] = i;\\n        }"], ["int* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    \\n    if(n<=2){\\n        *returnSize  = n;\\n        int* early_return = malloc(sizeof(int)*n);\\n        for(int i=0; i<n; i++){\\n            early_return[i] = i;\\n        }"], ["int* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    \\n    if(n<=2){\\n        *returnSize  = n;\\n        int* early_return = malloc(sizeof(int)*n);\\n        for(int i=0; i<n; i++){\\n            early_return[i] = i;\\n        }"]]}
{"id": "758", "ref_c": [["int nthSuperUglyNumber(int n, int* primes, int primesSize){\\n    long long int x=primesSize;\\n    long long int nmap[x][2];\\n    for(int i=0; i<x; i++){\\n        nmap[i][0] = primes[i];\\n        nmap[i][1] = 0;\\n    }"], ["int nthSuperUglyNumber(int n, int* primes, int primesSize){\\n    long long int x=primesSize;\\n    long long int nmap[x][2];\\n    for(int i=0; i<x; i++){\\n        nmap[i][0] = primes[i];\\n        nmap[i][1] = 0;\\n    }"], ["int nthSuperUglyNumber(int n, int* primes, int primesSize){\\n    int *uglyArry = (int*)malloc(sizeof(int) * n);\\n    memset(uglyArry, n, 0);\\n    uglyArry[0] = 1;\\n    \\n    int **primesOwnUglyArry = (int**)malloc(sizeof(int*) * primesSize);\\n    for (int i = 0; i < primesSize; i++) {\\n        primesOwnUglyArry[i] = uglyArry;\\n    }"]]}
{"id": "759", "ref_c": ["\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n", "\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n", "\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n"]}
{"id": "760", "ref_c": [["int maxProduct(char ** words, int wordsSize)\\n{\\n    int max = 0;\\n    size_t *word_bits = calloc(wordsSize, sizeof(size_t));\\n    for (int i = 0; i < wordsSize; i++) {\\n        for (int j = 0; words[i][j]; j++)\\n            word_bits[i] |= 1 << (words[i][j] - \\'a\\');\\n        for (int j = 0; j < i; j++) {\\n            if ((word_bits[i] & word_bits[j]) == 0) {\\n                int size = strlen(words[i]) * strlen(words[j]);\\n                max = max > size ? max : size;\\n            }"], ["int maxProduct(char ** words, int wordsSize)\\n{\\n    int max = 0;\\n    size_t *word_bits = calloc(wordsSize, sizeof(size_t));\\n    for (int i = 0; i < wordsSize; i++) {\\n        for (int j = 0; words[i][j]; j++)\\n            word_bits[i] |= 1 << (words[i][j] - \\'a\\');\\n        for (int j = 0; j < i; j++) {\\n            if ((word_bits[i] & word_bits[j]) == 0) {\\n                int size = strlen(words[i]) * strlen(words[j]);\\n                max = max > size ? max : size;\\n            }"], ["int maxProduct(char ** words, int wordsSize)\\n{\\n    int max = 0;\\n    size_t *word_bits = calloc(wordsSize, sizeof(size_t));\\n    for (int i = 0; i < wordsSize; i++) {\\n        for (int j = 0; words[i][j]; j++)\\n            word_bits[i] |= 1 << (words[i][j] - \\'a\\');\\n        for (int j = 0; j < i; j++) {\\n            if ((word_bits[i] & word_bits[j]) == 0) {\\n                int size = strlen(words[i]) * strlen(words[j]);\\n                max = max > size ? max : size;\\n            }"]]}
{"id": "761", "ref_c": [["int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }", "int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }", "int bulbSwitch(int n){\\n    return sqrt(n);\\n}"], ["int bulbSwitch(int n){\\nint i = 1;\\n        int g = 0;\\n                int count = 0 ;\\n                        while(g < n)\\n                                {\\n                                            i = i + 2 ;\\n                                                        g = g + i;\\n                                                                    count = count + 1;\\n                                                                            }"], ["int bulbSwitch(int n) {\\n        return (int)sqrt(n);\\n    }", "int bulbSwitch(int n) {\\n        return (int)Math.sqrt(n);\\n    }", "int bulbSwitch(int n){\\n    return sqrt(n);\\n}"]]}
{"id": "762", "ref_c": [["int coinChange(int* coins, int coinsSize, int amount){\\n    int* dp = (int*)malloc(sizeof(int) * (amount+1));\\n    for(int i = 0;i <= amount;i++){\\n        dp[i] = 25000;\\n    }"], ["int coinChange(int* coins, int coinsSize, int amount){\\n    int* dp = (int*)malloc(sizeof(int) * (amount+1));\\n    for(int i = 0;i <= amount;i++){\\n        dp[i] = 25000;\\n    }"], ["int coinChange(int* coins, int coinsSize, int amount){\\n    int* dp = (int*)malloc(sizeof(int) * (amount+1));\\n    for(int i = 0;i <= amount;i++){\\n        dp[i] = 25000;\\n    }"]]}
{"id": "763", "ref_c": [["void wiggleSort(int* nums, int numsSize){\\n      int arr[5001];\\n      for(int i=0;i<5001;i++) arr[i]=0;\\n      for(int i=0;i<numsSize;i++){\\n          arr[nums[i]]++;\\n      }"], ["void wiggleSort(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int *temp = malloc(sizeof(int) * numsSize);\\n    for (int i = 0; i < numsSize; i++)\\n        temp[i] = nums[i];\\n    for (int i = 1, j = numsSize - 1; i < numsSize; i+=2, j--)\\n        nums[i] = temp[j];\\n    int isOdd = numsSize % 2 == 1 ? 0 : 1;\\n    for (int i = 0, j = numsSize / 2 - isOdd; i < numsSize; i+=2, j--)\\n        nums[i] = temp[j];\\n}"], ["void wiggleSort(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int *temp = malloc(sizeof(int) * numsSize);\\n    for (int i = 0; i < numsSize; i++)\\n        temp[i] = nums[i];\\n    for (int i = 1, j = numsSize - 1; i < numsSize; i+=2, j--)\\n        nums[i] = temp[j];\\n    int isOdd = numsSize % 2 == 1 ? 0 : 1;\\n    for (int i = 0, j = numsSize / 2 - isOdd; i < numsSize; i+=2, j--)\\n        nums[i] = temp[j];\\n}"]]}
{"id": "764", "ref_c": [["struct ListNode* oddEvenList(struct ListNode* head){\\n    if(head==NULL)\\n    {\\n        return head;\\n    }"], ["struct ListNode* oddEvenList(struct ListNode* head){\\n    if(head==NULL){\\n        return head;\\n    }"], ["struct ListNode* oddEvenList(struct ListNode* head){\\n    if(head==NULL)\\n    {\\n        return NULL;\\n    }"]]}
{"id": "765", "ref_c": [["bool isValidSerialization(char * preorder){\\n    int slots = 1;\\n    bool isNull;\\n    while (*preorder){\\n        isNull = false;\\n\\t\\t// If the node is null, flip isNull to true\\n        while (*preorder && *preorder != \\',\\')\\n            if (*preorder++==\\'#\\') isNull = true;\\n        \\n\\t\\t// if we don\\'t have slots available, return false\\n        if (slots == 0) return false;\\n\\t\\t// else add or subtract depending on value of isNull\\n        slots += isNull ? -1 : 1;\\n        \\n        if (!*preorder) break;\\n        preorder++;\\n    }", "bool isValidSerialization(char * preorder){\\n    // initialize a char array, this is our stack (size is number of nodes in input)\\n    int idx = 1; // tracks value of head\\n    char *cur = preorder;\\n    while(*cur) if (*cur++ == \\',\\') idx++;\\n\\n    if (idx == 1) return(*preorder==\\'#\\');\\n    \\n\\t// create array large enough to hold all values\\n    char *arr = malloc(idx);\\n    \\n\\t// iterate over the string again, this time pushing/pulling to stack\\n    cur = preorder;\\n    idx = 0;\\n    while (*cur){\\n\\t    // push 0 or # to stack\\n        arr[idx] = \\'0\\';\\n        while (*cur && *cur != \\',\\')\\n            if (*cur++==\\'#\\') arr[idx] = \\'#\\';\\n\\t\\t\\n\\t\\t// if we have pushed two # in a row, pop three values and push a #\\n        while (idx >= 1 && arr[idx]==\\'#\\' && arr[idx-1]==\\'#\\'){\\n            arr[idx] = NULL;\\n            arr[idx-1] = NULL;\\n            idx -= 2;\\n            if (idx < 0) return false;\\n            arr[idx] = \\'#\\';\\n        }"], ["bool isValidSerialization(char * preorder){\\n    int slots = 1;\\n    bool isNull;\\n    while (*preorder){\\n        isNull = false;\\n\\t\\t// If the node is null, flip isNull to true\\n        while (*preorder && *preorder != \\',\\')\\n            if (*preorder++==\\'#\\') isNull = true;\\n        \\n\\t\\t// if we don\\'t have slots available, return false\\n        if (slots == 0) return false;\\n\\t\\t// else add or subtract depending on value of isNull\\n        slots += isNull ? -1 : 1;\\n        \\n        if (!*preorder) break;\\n        preorder++;\\n    }", "bool isValidSerialization(char * preorder){\\n    // initialize a char array, this is our stack (size is number of nodes in input)\\n    int idx = 1; // tracks value of head\\n    char *cur = preorder;\\n    while(*cur) if (*cur++ == \\',\\') idx++;\\n\\n    if (idx == 1) return(*preorder==\\'#\\');\\n    \\n\\t// create array large enough to hold all values\\n    char *arr = malloc(idx);\\n    \\n\\t// iterate over the string again, this time pushing/pulling to stack\\n    cur = preorder;\\n    idx = 0;\\n    while (*cur){\\n\\t    // push 0 or # to stack\\n        arr[idx] = \\'0\\';\\n        while (*cur && *cur != \\',\\')\\n            if (*cur++==\\'#\\') arr[idx] = \\'#\\';\\n\\t\\t\\n\\t\\t// if we have pushed two # in a row, pop three values and push a #\\n        while (idx >= 1 && arr[idx]==\\'#\\' && arr[idx-1]==\\'#\\'){\\n            arr[idx] = NULL;\\n            arr[idx-1] = NULL;\\n            idx -= 2;\\n            if (idx < 0) return false;\\n            arr[idx] = \\'#\\';\\n        }"], ["bool isValidSerialization(char * preorder){\\n    int slots = 1;\\n    bool isNull;\\n    while (*preorder){\\n        isNull = false;\\n\\t\\t// If the node is null, flip isNull to true\\n        while (*preorder && *preorder != \\',\\')\\n            if (*preorder++==\\'#\\') isNull = true;\\n        \\n\\t\\t// if we don\\'t have slots available, return false\\n        if (slots == 0) return false;\\n\\t\\t// else add or subtract depending on value of isNull\\n        slots += isNull ? -1 : 1;\\n        \\n        if (!*preorder) break;\\n        preorder++;\\n    }", "bool isValidSerialization(char * preorder){\\n    // initialize a char array, this is our stack (size is number of nodes in input)\\n    int idx = 1; // tracks value of head\\n    char *cur = preorder;\\n    while(*cur) if (*cur++ == \\',\\') idx++;\\n\\n    if (idx == 1) return(*preorder==\\'#\\');\\n    \\n\\t// create array large enough to hold all values\\n    char *arr = malloc(idx);\\n    \\n\\t// iterate over the string again, this time pushing/pulling to stack\\n    cur = preorder;\\n    idx = 0;\\n    while (*cur){\\n\\t    // push 0 or # to stack\\n        arr[idx] = \\'0\\';\\n        while (*cur && *cur != \\',\\')\\n            if (*cur++==\\'#\\') arr[idx] = \\'#\\';\\n\\t\\t\\n\\t\\t// if we have pushed two # in a row, pop three values and push a #\\n        while (idx >= 1 && arr[idx]==\\'#\\' && arr[idx-1]==\\'#\\'){\\n            arr[idx] = NULL;\\n            arr[idx-1] = NULL;\\n            idx -= 2;\\n            if (idx < 0) return false;\\n            arr[idx] = \\'#\\';\\n        }"]]}
{"id": "766", "ref_c": [["bool increasingTriplet(int* nums, int numsSize) {\\n    int min = INT_MAX;\\n    int mid = INT_MAX;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        //This stores the first minimum number\\n        if (nums[i] <= min) {\\n            min = nums[i];\\n        //This stores the middle number\\n        }"], ["bool increasingTriplet(int* nums, int numsSize) {\\n    int min = INT_MAX;\\n    int mid = INT_MAX;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        //This stores the first minimum number\\n        if (nums[i] <= min) {\\n            min = nums[i];\\n        //This stores the middle number\\n        }"], ["bool increasingTriplet(int* nums, int numsSize){\\n    int min = INT_MAX, max = INT_MAX;\\n    for(int i=0; i<numsSize; i++)\\n        if(nums[i] <= min)\\n            min = nums[i];\\n        else if(nums[i] <= max)\\n            max = nums[i];\\n        else return true;\\n    return false;\\n}"]]}
{"id": "767", "ref_c": [["int rob(struct TreeNode* root){\\n\\n    /*\\n     * Input:\\n     *  root, root of binary tree (only one entrance to this area)\\n     */\\n\\n    int ans;\\n    node_t *dp = NULL;\\n\\n    /* \\n     * Start from root, use binary tree node ID as house ID.\\n     * House ID can be very large, so we cannot directly use \\n     * a 2D array as a DP table.\\n     */\\n    ans = robHouse(root, 0, &dp);\\n\\n    /* Release DP memory */\\n    for (node_t *del; dp; ) {\\n        del = dp;\\n        dp = dp->next;\\n        free(del);\\n    }"], ["int rob(struct TreeNode* root){\\n\\n    /*\\n     * Input:\\n     *  root, root of binary tree (only one entrance to this area)\\n     */\\n\\n    int ans;\\n    node_t *dp = NULL;\\n\\n    /* \\n     * Start from root, use binary tree node ID as house ID.\\n     * House ID can be very large, so we cannot directly use \\n     * a 2D array as a DP table.\\n     */\\n    ans = robHouse(root, 0, &dp);\\n\\n    /* Release DP memory */\\n    for (node_t *del; dp; ) {\\n        del = dp;\\n        dp = dp->next;\\n        free(del);\\n    }"], ["int rob(struct TreeNode* root){\\n\\n    /*\\n     * Input:\\n     *  root, root of binary tree (only one entrance to this area)\\n     */\\n\\n    int ans;\\n    node_t *dp = NULL;\\n\\n    /* \\n     * Start from root, use binary tree node ID as house ID.\\n     * House ID can be very large, so we cannot directly use \\n     * a 2D array as a DP table.\\n     */\\n    ans = robHouse(root, 0, &dp);\\n\\n    /* Release DP memory */\\n    for (node_t *del; dp; ) {\\n        del = dp;\\n        dp = dp->next;\\n        free(del);\\n    }"]]}
{"id": "769", "ref_c": [["int integerBreak(int n) {\\n        if (n <= 1) {\\n            return 0;\\n        }", "int integerBreak(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[1] = 1;\\n        for (int i = 2; i <= n; ++i) {\\n            for (int j = 1; j < i; ++j) {\\n                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));\\n            }", "int integerBreak(int n) {\\n    if (n < 2) {\\n        return 0;\\n    }", "int integerBreak(int n) {\\n        if (n <= 1) {\\n            return 0;\\n        }", "int integerBreak(int n) {\\n        vector<int> memo(n + 1, -1);\\n        return maxProduct(n, memo);\\n    }", "int integerBreak(int n) {\\n    if (n < 2) {\\n        return 0;\\n    }", "int integerBreak(int n) {\\n        if (n <= 1) {\\n            return 0; \\n        }", "int integerBreak(int n) {\\n        if (n <= 3) {\\n            return n - 1;\\n        }", "int integerBreak(int n) {\\n    if (n < 2) {\\n        return 0;\\n    }", "int integerBreak(int n) {\\n        if (n <= 1) {\\n            return 0;\\n        }", "int integerBreak(int n) {\\n        if (n <= 3) {\\n            return n - 1;\\n        }", "int integerBreak(int n) {\\n    if (n < 2) {\\n        return 0;\\n    }"], ["int integerBreak(int n) {\\n        return n == 2 ? 1 : n == 3 ? 2 : n % 3 == 0 ? pow(3, n / 3) : n % 3 == 1 ? 4 * pow(3, (int)(n / 3) - 1) : 2 * pow(3, (int)(n / 3));\\n    }", "int integerBreak(int n) {\\n    return n == 2 ? 1 : n == 3 ? 2 : n % 3 == 0 ? pow(3, n / 3) : n % 3 == 1 ? 4 * pow(3, (int)(n / 3) - 1) : 2 * pow(3, (int)(n / 3));\\n}"], ["int integerBreak(int n) {\\n        if (n <= 3) return n - 1;\\n        \\n        vector<int> dp(n + 1, 0);\\n        dp[2] = 2;\\n        dp[3] = 3;\\n        \\n        for (int i = 4; i <= n; ++i) {\\n            dp[i] = max(dp[i - 2] * 2, dp[i - 3] * 3);\\n        }"]]}
{"id": "770", "ref_c": [["int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n  struct freq_hash* table = NULL;\\n  int* const ret = malloc(numsSize * sizeof(*ret));\\n  int* pos = ret;\\n  *returnSize = k;\\n\\n  // Count the frequencies of each number while storing the unique values in the return array\\n  struct freq_hash entries[numsSize];\\n  struct freq_hash* entries_pos = entries;\\n  for (int i = 0; i < numsSize; ++i) {\\n    struct freq_hash* entry;\\n    HASH_FIND_INT(table, &nums[i], entry);\\n    if (!entry) {\\n      entry = entries_pos++;\\n      entry->value = nums[i];\\n      entry->count = 1;\\n      *pos++ = nums[i];\\n      HASH_ADD_INT(table, value, entry);\\n    }"], ["int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n  struct freq_hash* table = NULL;\\n  int* const ret = malloc(numsSize * sizeof(*ret));\\n  int* pos = ret;\\n  *returnSize = k;\\n\\n  // Count the frequencies of each number while storing the unique values in the return array\\n  struct freq_hash entries[numsSize];\\n  struct freq_hash* entries_pos = entries;\\n  for (int i = 0; i < numsSize; ++i) {\\n    struct freq_hash* entry;\\n    HASH_FIND_INT(table, &nums[i], entry);\\n    if (!entry) {\\n      entry = entries_pos++;\\n      entry->value = nums[i];\\n      entry->count = 1;\\n      *pos++ = nums[i];\\n      HASH_ADD_INT(table, value, entry);\\n    }"], ["int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\\n  struct freq_hash* table = NULL;\\n  int* const ret = malloc(numsSize * sizeof(*ret));\\n  int* pos = ret;\\n  *returnSize = k;\\n\\n  // Count the frequencies of each number while storing the unique values in the return array\\n  struct freq_hash entries[numsSize];\\n  struct freq_hash* entries_pos = entries;\\n  for (int i = 0; i < numsSize; ++i) {\\n    struct freq_hash* entry;\\n    HASH_FIND_INT(table, &nums[i], entry);\\n    if (!entry) {\\n      entry = entries_pos++;\\n      entry->value = nums[i];\\n      entry->count = 1;\\n      *pos++ = nums[i];\\n      HASH_ADD_INT(table, value, entry);\\n    }"]]}
{"id": "772", "ref_c": [["int countNumbersWithUniqueDigits(int n){\\n    if(n == 0) return 1;\\n    if(n == 1) return 10;\\n    int result = 10;\\n    int eighty = 81;\\n    int temp = 8;\\n    for(int i = 2; i < n; i++){\\n        result += eighty;\\n        eighty *= temp;\\n        temp--;\\n    }"], ["int countNumbersWithUniqueDigits(int n) {\\n        \\n        int count = 0;\\n        vector<bool> chosen(10, false);\\n\\n        for (int i = 0; i <= n; ++i)\\n            count += backtrack(chosen, i, i);\\n\\n        return count;\\n    }", "int countNumbersWithUniqueDigits(int n) {\\n        \\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        dpOneBack = 1;\\n\\n        for (int i = 1, prod = 1; i <= n; ++i, prod *= (11 - i))\\n            dpOneBack += (9 * prod);\\n\\n        return dpOneBack;\\n    }", "int countNumbersWithUniqueDigits(int n) {\\n        long long factorial;\\n        int dpOneBack;\\n        \\n        n = min(n, 10);\\n        factorial = 1;\\n        dpOneBack = 1;\\n\\n        for (int i = 2; i <= 9; ++i)\\n            factorial *= i;\\n        \\n        for (int i = 1, j = 9; i <= n; ++i)\\n        {\\n            dpOneBack += (3265920 / factorial);\\n            if (factorial > 1)\\n            {\\n                factorial /= j;\\n                --j;\\n            }", "int countNumbersWithUniqueDigits(int n) {\\n\\n        long long prevFactorial, curFactorial;\\n        vector<vector<int>> nCk(11, vector<int>(11));\\n        int dpOneBack;\\n\\n        dpOneBack = 1;\\n        curFactorial = 1;\\n        nCk[0][0] = 1;\\n\\n        for (int i = 1; i < 11; ++i)\\n            for (int k = 0; k <= i; ++k)\\n                nCk[i][k] = ((k == 0 || k >= i) ? 1 : nCk[i - 1][k - 1] + nCk[i - 1][k]);\\n        \\n        for (int i = 1; i <= n; ++i)\\n        {\\n            prevFactorial = curFactorial;\\n            curFactorial = i * prevFactorial;\\n            dpOneBack = (((curFactorial * nCk[10][i]) - (prevFactorial * nCk[9][i - 1])) + dpOneBack);\\n        }"], ["int countNumbersWithUniqueDigits(int n) {\\n       \\n        int ans = 0;\\n        int bit = 0;\\n        \\n        for (;n>=0;n--)\\n        {\\n            vector<vector<int>> dp(n+1,vector<int>(pow(2,10),-1));\\n            ans += fun(n,bit,dp);\\n        }"]]}
{"id": "773", "ref_c": ["\nint gcd(int a , int b) {\n\n  while (a != b) {\n    if (a > b) a -= b;\n    else b-= a;\n  }\n  return a;\n}\n\n\nbool canMeasureWater(int j1, int j2, int t) {\n  return (j1 + j2 >= t) && (t % gcd(j1, j2) == 0);\n}\n", "\nint gcd(int a , int b) {\n\n  while (a != b) {\n    if (a > b) a -= b;\n    else b-= a;\n  }\n  return a;\n}\n\n\nbool canMeasureWater(int j1, int j2, int t) {\n  return (j1 + j2 >= t) && (t % gcd(j1, j2) == 0);\n}\n", "\nint gcd(int a , int b) {\n\n  while (a != b) {\n    if (a > b) a -= b;\n    else b-= a;\n  }\n  return a;\n}\n\n\nbool canMeasureWater(int j1, int j2, int t) {\n  return (j1 + j2 >= t) && (t % gcd(j1, j2) == 0);\n}\n"]}
{"id": "774", "ref_c": [["int* largestDivisibleSubset(int* nums, int numsSize, int* returnSize){\\n    qsort(nums, numsSize, sizeof(int), comparator);\\n    int dp[numsSize];\\n    int output[numsSize][numsSize];\\n    dp[0] = 1;\\n    int max = 1;\\n    int *result = malloc(sizeof(int) * numsSize);\\n    int index = 0, index1 = 0;\\n\\n    output[0][0] = nums[0];\\n    for(int i = 1; i < numsSize; i++){\\n        dp[i] = 1;\\n        output[i][0] = nums[i];\\n        for(int j = i - 1; j >= 0; j--){\\n            if(nums[i] % nums[j] == 0){\\n                if(dp[i] < dp[j] + 1){\\n                    dp[i] = dp[j] + 1;\\n                    index = j;\\n                }"], ["int* largestDivisibleSubset(int* nums, int numsSize, int* returnSize){\\n    qsort(nums, numsSize, sizeof(int), comparator);\\n    int dp[numsSize];\\n    int output[numsSize][numsSize];\\n    dp[0] = 1;\\n    int max = 1;\\n    int *result = malloc(sizeof(int) * numsSize);\\n    int index = 0, index1 = 0;\\n\\n    output[0][0] = nums[0];\\n    for(int i = 1; i < numsSize; i++){\\n        dp[i] = 1;\\n        output[i][0] = nums[i];\\n        for(int j = i - 1; j >= 0; j--){\\n            if(nums[i] % nums[j] == 0){\\n                if(dp[i] < dp[j] + 1){\\n                    dp[i] = dp[j] + 1;\\n                    index = j;\\n                }"], ["int* largestDivisibleSubset(int* nums, int numsSize, int* returnSize){\\n    qsort(nums, numsSize, sizeof(int), comparator);\\n    int dp[numsSize];\\n    int output[numsSize][numsSize];\\n    dp[0] = 1;\\n    int max = 1;\\n    int *result = malloc(sizeof(int) * numsSize);\\n    int index = 0, index1 = 0;\\n\\n    output[0][0] = nums[0];\\n    for(int i = 1; i < numsSize; i++){\\n        dp[i] = 1;\\n        output[i][0] = nums[i];\\n        for(int j = i - 1; j >= 0; j--){\\n            if(nums[i] % nums[j] == 0){\\n                if(dp[i] < dp[j] + 1){\\n                    dp[i] = dp[j] + 1;\\n                    index = j;\\n                }"]]}
{"id": "775", "ref_c": [["int getSum(int a, int b) {\\n    \\n        while(b !=0){\\n      unsigned  int tmp = (a & b);\\n        a = a ^ b;\\n        b = tmp << 1;\\n        }"], ["int getSum(int a, int b) {\\n    __asm(\"add %[b], %[a]\"\\n          :[a] \"+r\"(a)\\n          :[b] \"r\"(b)\\n    );\\n    return a;\\n}"], ["int getSum(int a, int b) {\\n    \\n        while(b !=0){\\n      unsigned  int tmp = (a & b);\\n        a = a ^ b;\\n        b = tmp << 1;\\n        }"]]}
{"id": "776", "ref_c": [["int superPow(int a, int* b, int bSize){\\n\\t\\tint base;\\n\\t\\tint ans = 1;\\n\\t\\tint temp;\\n\\t\\tint nums[4];\\n\\t\\tint index;\\n\\t\\ta %= 1337;\\n\\t\\tfor(int i = 0; i < bSize; i++){\\n\\t\\t\\tindex = -1;\\n\\t\\t\\tif(b[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp = a;\\n\\t\\t\\t\\twhile(b[i]){\\n\\t\\t\\t\\t\\tnums[++index] = b[i] % 2;\\n\\t\\t\\t\\t\\tb[i] /= 2;\\n\\t\\t\\t\\t}"], ["int superPow(int a, int* b, int bSize){\\n\\n    if(bSize == 0)\\n        return 1;\\n    \\n    if(b[bSize-1]%2 == 1){\\n        b[bSize-1]--;\\n        return ( (a % 1337) * superPow(a, b, bSize) ) % 1337;\\n    }"], ["int superPow(int a, int* b, int bSize){\\n\\t\\tint base;\\n\\t\\tint ans = 1;\\n\\t\\tint temp;\\n\\t\\tint nums[4];\\n\\t\\tint index;\\n\\t\\ta %= 1337;\\n\\t\\tfor(int i = 0; i < bSize; i++){\\n\\t\\t\\tindex = -1;\\n\\t\\t\\tif(b[i] > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp = a;\\n\\t\\t\\t\\twhile(b[i]){\\n\\t\\t\\t\\t\\tnums[++index] = b[i] % 2;\\n\\t\\t\\t\\t\\tb[i] /= 2;\\n\\t\\t\\t\\t}"]]}
{"id": "777", "ref_c": [["int** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes){\\n\\t*returnSize = k;\\n\\t*returnColumnSizes = (int *)malloc(sizeof (int) * k);\\n\\tint ** rets = (int **)malloc(sizeof (int *) * k);\\n\\n\\tHeap * pHeap;\\n\\tHeap_create(\\n\\t\\t&pHeap,\\n\\t\\tHeap_HeapType_ASC,\\n\\t\\t(nums1Size <= nums2Size)? nums1Size : nums2Size,\\n\\t\\tsizeof (Pair),\\n\\t\\t(Heap_PCmp)&cmp_Pair_sumAsc\\n\\t);\\n\\tint visitedCnts[nums1Size];\\n\\tmemset( &visitedCnts, 0, sizeof (visitedCnts) );\\n\\n\\tconst Pair firstPair = {0, 0, nums1[0] + nums2[0]}"], ["int** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes){\\n\\t*returnSize = k;\\n\\t*returnColumnSizes = (int *)malloc(sizeof (int) * k);\\n\\tint ** rets = (int **)malloc(sizeof (int *) * k);\\n\\n\\tHeap * pHeap;\\n\\tHeap_create(\\n\\t\\t&pHeap,\\n\\t\\tHeap_HeapType_ASC,\\n\\t\\t(nums1Size <= nums2Size)? nums1Size : nums2Size,\\n\\t\\tsizeof (Pair),\\n\\t\\t(Heap_PCmp)&cmp_Pair_sumAsc\\n\\t);\\n\\tint visitedCnts[nums1Size];\\n\\tmemset( &visitedCnts, 0, sizeof (visitedCnts) );\\n\\n\\tconst Pair firstPair = {0, 0, nums1[0] + nums2[0]}"], ["int** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes){\\n\\t*returnSize = k;\\n\\t*returnColumnSizes = (int *)malloc(sizeof (int) * k);\\n\\tint ** rets = (int **)malloc(sizeof (int *) * k);\\n\\n\\tHeap * pHeap;\\n\\tHeap_create(\\n\\t\\t&pHeap,\\n\\t\\tHeap_HeapType_ASC,\\n\\t\\t(nums1Size <= nums2Size)? nums1Size : nums2Size,\\n\\t\\tsizeof (Pair),\\n\\t\\t(Heap_PCmp)&cmp_Pair_sumAsc\\n\\t);\\n\\tint visitedCnts[nums1Size];\\n\\tmemset( &visitedCnts, 0, sizeof (visitedCnts) );\\n\\n\\tconst Pair firstPair = {0, 0, nums1[0] + nums2[0]}"]]}
{"id": "778", "ref_c": [["int getMoneyAmount(int n) {\\n        // 1. Recursion\\n        // return getMoneyAmountRec(1,n);\\n\\n        // 2. Top Down Approach\\n        // vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        // return getMoneyAmountMem(1,n,dp);\\n\\n        // 3. Bottom Up Approach\\n        return getMoneyAmountTab(n);\\n    }"], ["int getMoneyAmount(int n){\\n    memset(mem,0,sizeof(mem));\\n    return getMoneyAmount_r(1,n);\\n}"], ["int getMoneyAmount(int n){\\n\\n    /*\\n     * Input:\\n     *  n\\n     */\\n\\n    int ans, **dp = (int **)(malloc(sizeof(int *) * (n + 1)));\\n\\n    for (int i = 0; i <= n; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * (n + 1));\\n\\n        for (int j = 0; j <= n; j++) {\\n            dp[i][j] = -1;\\n        }"]]}
{"id": "779", "ref_c": [["int wiggleMaxLength(int* nums, int numsSize){\\n    int dir = 0, ans = 1;\\n    \\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] == nums[i-1]) continue;\\n        if (dir == 0) {\\n            ans++;\\n            if (nums[i] > nums[i-1]) dir = 1;\\n            else dir = -1;\\n        }"], ["int wiggleMaxLength(int* nums, int numsSize){\\n    if(numsSize <= 1){\\n        return numsSize;\\n    }"], ["int wiggleMaxLength(int* nums, int numsSize){\\n    int dir = 0, ans = 1;\\n    \\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] == nums[i-1]) continue;\\n        if (dir == 0) {\\n            ans++;\\n            if (nums[i] > nums[i-1]) dir = 1;\\n            else dir = -1;\\n        }"]]}
{"id": "780", "ref_c": [["int combinationSum4(int* nums, int numsSize, int target){\\n    unsigned long long dp[target] ;\\n    memset(dp,0,sizeof(dp));\\n    for(int i = target-1 ; i >= 0 ; i--)\\n    {\\n        for(int j = 0 ; j < numsSize ; j++)\\n        {\\n            if(i + nums[j] == target)\\n                dp[i]++;\\n            else if( i + nums[j] < target && dp[i + nums[j]] != 0)\\n                    dp[i] = dp[i] + dp[i+nums[j]];\\n        }"], ["int combinationSum4(int* nums, int numsSize, int target){\\n    unsigned long long dp[target] ;\\n    memset(dp,0,sizeof(dp));\\n    for(int i = target-1 ; i >= 0 ; i--)\\n    {\\n        for(int j = 0 ; j < numsSize ; j++)\\n        {\\n            if(i + nums[j] == target)\\n                dp[i]++;\\n            else if( i + nums[j] < target && dp[i + nums[j]] != 0)\\n                    dp[i] = dp[i] + dp[i+nums[j]];\\n        }"], ["int combinationSum4(int* nums, int numsSize, int target) {\\n    unsigned int dp[target + 1];\\n    dp[0] = 1;\\n    for (int i = 1; i <= target; i++) {\\n        dp[i] = 0;\\n    }"]]}
{"id": "781", "ref_c": [["int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    size=0;\\n\\n    for(int i=0;i<matrixSize;i++)\\n    {\\n        for(int j=0;j<matrixColSize[i];j++)\\n        {\\n            push(matrix[i][j]);\\n        }"], ["int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    size=0;\\n\\n    for(int i=0;i<matrixSize;i++)\\n    {\\n        for(int j=0;j<matrixColSize[i];j++)\\n        {\\n            push(matrix[i][j]);\\n        }"], ["int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    size=0;\\n\\n    for(int i=0;i<matrixSize;i++)\\n    {\\n        for(int j=0;j<matrixColSize[i];j++)\\n        {\\n            push(matrix[i][j]);\\n        }"]]}
{"id": "785", "ref_c": [["struct NestedInteger* deserialize(char * s){\\n    struct NestedInteger* node = NestedIntegerInit();\\n    parse(s, 0, strlen(s), node);\\n    return node;\\n}"], ["struct NestedInteger* deserialize(char * s){\\n    struct NestedInteger* node = NestedIntegerInit();\\n    parse(s, 0, strlen(s), node);\\n    return NestedIntegerGetList(node)[0];\\n}"], ["struct NestedInteger* deserialize(char * s){\\n    struct NestedInteger* node = NestedIntegerInit();\\n    parse(s, 0, strlen(s), node);\\n    return NestedIntegerGetList(node)[0];\\n}"]]}
{"id": "786", "ref_c": [["int* lexicalOrder(int n, int* returnSize){\\n    *returnSize=n;\\n    int *res=(int*)malloc(sizeof(int)*n);\\n    int pos=0;\\n    for(int i=1;i<10;i++){\\n        dfs(res,&pos,i,n);\\n    }"], ["int* lexicalOrder(int n, int* returnSize) {\\n    int * res = (int *) malloc(sizeof(int) * n+1);\\n    int temp=n, maxdig=0;\\n\\n    while(temp != 0) {\\n        temp /= 10;\\n        maxdig++;\\n    }"], ["int* lexicalOrder(int n, int* returnSize){\\n    *returnSize=n;\\n    int *res=(int*)malloc(sizeof(int)*n);\\n    int pos=0;\\n    for(int i=1;i<10;i++){\\n        dfs(res,&pos,i,n);\\n    }"]]}
{"id": "787", "ref_c": [["int lengthLongestPath(char * input){\\n    if(strlen(input) == 1) return 0;\\n    hElem *map = NULL, *t, *nt;\\n    char *saveptr;\\n    int longestLen = 0, level = 0, nextLevel = 0, len = 0, tokLen = 0;\\n    bool tabFound = false;\\n    \\n    // Add a dummy root level 0 and its length as 0\\n    t = calloc(sizeof(hElem), 1);\\n    t->level = 0;  t->len = 0;\\n    HASH_ADD_INT(map, level, t);\\n    \\n    for(char *tok = strtok_r(input, \"\\\\n\", &saveptr); tok; tok = strtok_r(NULL, \"\\\\n\", &saveptr)) {\\n        tokLen = strlen(tok);\\n        char *ret = strrchr(tok, \\'\\\\t\\');\\n    \\n        if(!ret) {\\n            // first dir/file is at level is 1\\n            level = 1;\\n            t = calloc(sizeof(hElem), 1);\\n            t->level = level; t->len = tokLen + 1;  // include appended \\'/\\' in len\\n            \\n            HASH_ADD_INT(map, level, t);\\n            \\n        }"], ["int lengthLongestPath(char * input){\\n    if(strlen(input) == 1) return 0;\\n    hElem *map = NULL, *t, *nt;\\n    char *saveptr;\\n    int longestLen = 0, level = 0, nextLevel = 0, len = 0, tokLen = 0;\\n    bool tabFound = false;\\n    \\n    // Add a dummy root level 0 and its length as 0\\n    t = calloc(sizeof(hElem), 1);\\n    t->level = 0;  t->len = 0;\\n    HASH_ADD_INT(map, level, t);\\n    \\n    for(char *tok = strtok_r(input, \"\\\\n\", &saveptr); tok; tok = strtok_r(NULL, \"\\\\n\", &saveptr)) {\\n        tokLen = strlen(tok);\\n        char *ret = strrchr(tok, \\'\\\\t\\');\\n    \\n        if(!ret) {\\n            // first dir/file is at level is 1\\n            level = 1;\\n            t = calloc(sizeof(hElem), 1);\\n            t->level = level; t->len = tokLen + 1;  // include appended \\'/\\' in len\\n            \\n            HASH_ADD_INT(map, level, t);\\n            \\n        }"], ["int lengthLongestPath(char * input){\\n    if(strlen(input) == 1) return 0;\\n    hElem *map = NULL, *t, *nt;\\n    char *saveptr;\\n    int longestLen = 0, level = 0, nextLevel = 0, len = 0, tokLen = 0;\\n    bool tabFound = false;\\n    \\n    // Add a dummy root level 0 and its length as 0\\n    t = calloc(sizeof(hElem), 1);\\n    t->level = 0;  t->len = 0;\\n    HASH_ADD_INT(map, level, t);\\n    \\n    for(char *tok = strtok_r(input, \"\\\\n\", &saveptr); tok; tok = strtok_r(NULL, \"\\\\n\", &saveptr)) {\\n        tokLen = strlen(tok);\\n        char *ret = strrchr(tok, \\'\\\\t\\');\\n    \\n        if(!ret) {\\n            // first dir/file is at level is 1\\n            level = 1;\\n            t = calloc(sizeof(hElem), 1);\\n            t->level = level; t->len = tokLen + 1;  // include appended \\'/\\' in len\\n            \\n            HASH_ADD_INT(map, level, t);\\n            \\n        }"]]}
{"id": "788", "ref_c": [["int lastRemaining(int n){    \\n    float f = (float) n;\\n    int e = *(int *)&f >> 23;\\n    int h = 1 << e - 0x7f;\\n    int r = h - 1 & ~n & 0xaaaaaaaa;\\n    return h - r;\\n}"], ["int lastRemaining(int n) {\\n        return lastRem(n, 0);\\n    }"], ["int lastRemaining(int n) {\\n    int ans = 1, direct = 0, cnt = n, step = 1;\\n    while(cnt > 1) {\\n        ans = (direct % 2 != 0 && cnt % 2 == 0) ? ans : ans + step;\\n        direct++; cnt /= 2; step *= 2;\\n    }"]]}
{"id": "789", "ref_c": [["bool validUtf8(int* data, int dataSize)\\n{\\n    while(dataSize > 0) {\\n        if(CHECK_MASK(data[0], UPPER_1BIT, UTF8_1BYTE_MASK)) {\\n            data++, dataSize--;\\n        }"], ["bool validUtf8(int* data, int dataSize)\\n{\\n    while(dataSize > 0) {\\n        if(CHECK_MASK(data[0], UPPER_1BIT, UTF8_1BYTE_MASK)) {\\n            data++, dataSize--;\\n        }"], ["bool validUtf8(int* data, int dataSize)\\n{\\n    while(dataSize > 0) {\\n        if(CHECK_MASK(data[0], UPPER_1BIT, UTF8_1BYTE_MASK)) {\\n            data++, dataSize--;\\n        }"]]}
{"id": "790", "ref_c": [["char * decodeString(char * s){\\n    char *save_str= malloc(sizeof(char)*5000);\\n    //char results[5000];\\n    //save_str = results;\\n    char *write_str= malloc(sizeof(char)*1000);\\n    int indexOfsavestr=-1,indexOfwritestr=-1;\\n    int indexOfSearch,indexOfTimes,times;\\n    int i,j,k; // for for loop\\n    for(i=0;i<strlen(s);i++){\\n        if(s[i] == \\']\\'){\\n            //find the stack index for words(\\u5148\\u78BA\\u5B9A\\u8981\\u8F38\\u51FA\\u7684\\u5B57\\u4E32index)\\n            indexOfSearch=indexOfsavestr;\\n            while(save_str[indexOfSearch] != \\'[\\'){indexOfSearch--;}"], ["char * decodeString(char * s){\\n    char *save_str= malloc(sizeof(char)*5000);\\n    //char results[5000];\\n    //save_str = results;\\n    char *write_str= malloc(sizeof(char)*1000);\\n    int indexOfsavestr=-1,indexOfwritestr=-1;\\n    int indexOfSearch,indexOfTimes,times;\\n    int i,j,k; // for for loop\\n    for(i=0;i<strlen(s);i++){\\n        if(s[i] == \\']\\'){\\n            //find the stack index for words(\\u5148\\u78BA\\u5B9A\\u8981\\u8F38\\u51FA\\u7684\\u5B57\\u4E32index)\\n            indexOfSearch=indexOfsavestr;\\n            while(save_str[indexOfSearch] != \\'[\\'){indexOfSearch--;}"], ["char * decodeString(char * s){\\n    char *save_str= malloc(sizeof(char)*5000);\\n    //char results[5000];\\n    //save_str = results;\\n    char *write_str= malloc(sizeof(char)*1000);\\n    int indexOfsavestr=-1,indexOfwritestr=-1;\\n    int indexOfSearch,indexOfTimes,times;\\n    int i,j,k; // for for loop\\n    for(i=0;i<strlen(s);i++){\\n        if(s[i] == \\']\\'){\\n            //find the stack index for words(\\u5148\\u78BA\\u5B9A\\u8981\\u8F38\\u51FA\\u7684\\u5B57\\u4E32index)\\n            indexOfSearch=indexOfsavestr;\\n            while(save_str[indexOfSearch] != \\'[\\'){indexOfSearch--;}"]]}
{"id": "791", "ref_c": [["int longestSubstring(char * s, int k){\\n\\n    return backtracking(s,k);\\n}"], ["int longestSubstring(char * s, int k){\\n\\n    return backtracking(s,k);\\n}"], ["int longestSubstring(char * s, int k){\\n\\n    return backtracking(s,k);\\n}"]]}
{"id": "792", "ref_c": [["int maxRotateFunction(int* nums, int numsSize){\\n    int n = numsSize;\\n    int numSum = 0, fRes = 0;\\n    for (int i = 0; i < n; i ++) {\\n        numSum += nums[i];\\n        fRes += i * nums[i];\\n    }"], ["int maxRotateFunction(int* nums, int numsSize){\\n    int n = numsSize;\\n    int numSum = 0, fRes = 0;\\n    for (int i = 0; i < n; i ++) {\\n        numSum += nums[i];\\n        fRes += i * nums[i];\\n    }"], ["int maxRotateFunction(int* nums, int numsSize){\\n    int n = numsSize;\\n    int numSum = 0, fRes = 0;\\n    for (int i = 0; i < n; i ++) {\\n        numSum += nums[i];\\n        fRes += i * nums[i];\\n    }"]]}
{"id": "793", "ref_c": [["int integerReplacement(int n){\\n    if(n == pow(2,31) - 1){\\n        return 32;\\n    }"], ["int integerReplacement(int n) {\\n        int steps =0;\\n        unsigned int temp = n;\\n        int a, b; // temporary variables\\n\\n        while(temp>1){\\n            if(temp%2 == 0){\\n                temp = temp/2;\\n            }"], ["int integerReplacement(int n){\\n    if(n == pow(2,31) - 1){\\n        return 32;\\n    }"]]}
{"id": "795", "ref_c": [["double* calcEquation(char *** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char *** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n\\n    double* ans = (double*)calloc(queriesSize, sizeof(double));\\n\\n    Graph graph = createGraph(equations, equationsSize, values);\\n\\n    for(int i = 0; i < queriesSize; i++){\\n\\n        clearViistRecordInGraph(graph);\\n\\n        char*  divisor  = queries[i][0];\\n        char*  dividend = queries[i][1];\\n        \\n        double quotient = NULL_VALUE;\\n        if(isVariableValid(divisor, graph) && isVariableValid(dividend, graph)){\\n            quotient = solveEquation(divisor, dividend, graph, 1.0);\\n        }"], ["double* calcEquation(char *** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char *** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int i, src, dest, vars = 0;\\n    double *res = (double*) malloc(queriesSize * sizeof(double));\\n    Pair *ht[MOD] = {0}"], ["double* calcEquation(char *** equations, int equationsSize, int* equationsColSize, double* values, int valuesSize, char *** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    int label_num = 0;\\n    char label[40][6];\\n    int i = 0;\\n    int j = 0;\\n    int label_idx0 = 0;\\n    int label_idx1 = 0;\\n    double div_table[40][40];\\n    int adj_list[40][40];\\n    int adj_num[40] = {0}"]]}
{"id": "796", "ref_c": [["int numSquares(int n) {\\n        \\n        \\n        int[] dp = new int[n+1];\\n        \\n        // Initialize with INT_MAX, except for dp[0] = 0 as base case\\n        for( int i = 1 ; i < dp.length; i++){\\n            dp[ i ] = Integer.MAX_VALUE;\\n        }", "int numSquares(int n) {\\n        \\n        vector< int > dp = vector< int > (n+1, INT_MAX );\\n        \\n        // Base case\\n        dp[0] = 0;\\n        \\n        int root = 1;\\n        int square = root * root;\\n        \\n        // for each square 1, 4, 9, 16, 25...\\n        while( square <= n ){\\n            \\n            //  update dp value for number from square to n\\n            for( int i = square ; i <= n ; i++ ){\\n                \\n                dp[ i ] = min( dp[ i ], dp[ i - square ] + 1 );\\n            }"], ["int numSquares(int n) {\\n    while (n % 4 == 0)\\n        n /= 4;\\n    if (n % 8 == 7) return 4;\\n    if (isSquare(n)) return 1;\\n    for (int i = 1; i * i <= n; i++) {\\n        if (isSquare(n - i * i)) return 2;\\n    }"], ["int numSquares(int n){\\n    if (n <= 0) return 0;\\n    int* dp = (int*)malloc((n + 1) * sizeof(int));\\n    for (int i = 0; i <= n; i++) {\\n        dp[i] = INT_MAX;\\n    }"]]}
{"id": "797", "ref_c": [["char * removeKdigits(char * num, int k)\\n{\\n    int n = strlen(num);\\n    char stack[STACK_SZ];\\n    int head = -1;  /* pointer to the head of the stack */\\n    \\n    for (int i = 0; i < n; i++) {\\n        while (head != -1 && k && stack[head] > num[i]) {\\n            --head;\\n            --k;\\n        }"], ["char * removeKdigits(char * num, int k){\\n\\n    /*\\n     * Input:\\n     *  num, digits\\n     *  k, removing k digits from num\\n     */\\n\\n    char tmp;\\n    int len = 0, start;\\n\\n    stk_init();\\n\\n    /*\\n     * Monotonic stack:\\n     *  Scan num[i], check if there is any digits in the stack larger than num[i]\\n     *  if Yes and k is larger than 0, discard the larger digit,\\n     *  Push num[i] to stack\\n     */\\n    for (int i = 0; num[i]; i++) {\\n\\n        while (k && stk_cnt()) {\\n\\n                stk_pop(&tmp);\\n\\n                if (tmp <= num[i]) {\\n                    stk_push(tmp);\\n                    break;\\n                }"], ["char * removeKdigits(char * num, int k){\\n\\n    /*\\n     * Input:\\n     *  num, digits\\n     *  k, removing k digits from num\\n     */\\n\\n    char tmp;\\n    int len = 0, start;\\n\\n    stk_init();\\n\\n    /*\\n     * Monotonic stack:\\n     *  Scan num[i], check if there is any digits in the stack larger than num[i]\\n     *  if Yes and k is larger than 0, discard the larger digit,\\n     *  Push num[i] to stack\\n     */\\n    for (int i = 0; num[i]; i++) {\\n\\n        while (k && stk_cnt()) {\\n\\n                stk_pop(&tmp);\\n\\n                if (tmp <= num[i]) {\\n                    stk_push(tmp);\\n                    break;\\n                }"]]}
{"id": "798", "ref_c": [["int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes){\\n    \\n\\tqsort(people, peopleSize, sizeof(int*), sortFunc);\\n    \\n    *returnSize = peopleSize;\\n    *returnColumnSizes = (int*)malloc(peopleSize*sizeof(int));\\n    \\n    int ** ans = (int**)malloc(peopleSize * sizeof(int*));\\n    \\n    for (int i = 0; i < peopleSize; i++) {\\n        (*returnColumnSizes)[i] = 2;\\n        ans[i] = (int*)malloc(2 * sizeof(int));\\n        \\n        for (int j = i; j > people[i][1]; j--) {\\n            ans[j][0] = ans[j-1][0];\\n            ans[j][1] = ans[j-1][1];\\n        }"], ["int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = peopleSize;\\n    (*returnColumnSizes) = malloc(sizeof(int)*peopleSize);\\n    int** ans = malloc(sizeof(int*)*peopleSize);\\n    for (int i = 0 ; i < peopleSize ; i++){\\n        (*returnColumnSizes)[i] = 2;\\n        ans[i] = malloc(sizeof(int)*2);\\n    }"], ["int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes){\\n    \\n\\tqsort(people, peopleSize, sizeof(int*), sortFunc);\\n    \\n    *returnSize = peopleSize;\\n    *returnColumnSizes = (int*)malloc(peopleSize*sizeof(int));\\n    \\n    int ** ans = (int**)malloc(peopleSize * sizeof(int*));\\n    \\n    for (int i = 0; i < peopleSize; i++) {\\n        (*returnColumnSizes)[i] = 2;\\n        ans[i] = (int*)malloc(2 * sizeof(int));\\n        \\n        for (int j = i; j > people[i][1]; j--) {\\n            ans[j][0] = ans[j-1][0];\\n            ans[j][1] = ans[j-1][1];\\n        }"]]}
{"id": "799", "ref_c": [["int numberOfArithmeticSlices(int* nums, int numsSize){\\n    if (numsSize <= 2)\\n        return 0;\\n    int lastIndex = 0;\\n    int d = *(nums +1) -*nums;\\n    int answer = 0;\\n    for (int i = 2; i < numsSize; i++) {\\n        if (*(nums +i) -*(nums +i -1) == d) {\\n            int a = i -lastIndex -1;\\n            answer += (a > 0) ? a : 1;\\n        }"], ["int numberOfArithmeticSlices(int* nums, int numsSize){\\n    if (numsSize <= 2)\\n        return 0;\\n    int lastIndex = 0;\\n    int d = *(nums +1) -*nums;\\n    int answer = 0;\\n    for (int i = 2; i < numsSize; i++) {\\n        if (*(nums +i) -*(nums +i -1) == d) {\\n            int a = i -lastIndex -1;\\n            answer += (a > 0) ? a : 1;\\n        }"], ["int numberOfArithmeticSlices(int* nums, int numsSize){\\n    if (numsSize <= 2)\\n        return 0;\\n    int lastIndex = 0;\\n    int d = *(nums +1) -*nums;\\n    int answer = 0;\\n    for (int i = 2; i < numsSize; i++) {\\n        if (*(nums +i) -*(nums +i -1) == d) {\\n            int a = i -lastIndex -1;\\n            answer += (a > 0) ? a : 1;\\n        }"]]}
{"id": "800", "ref_c": ["\nint partition(int *nums, int numsSize, int start, int target, int **dp)\n{\n    bool match = false;\n    \n    if (target == 0) {\n        return true;\n    }\n\n    if (start == numsSize || target < 0) {\n        return false;\n    }\n    \n    if (dp[start][target] != -1) {\n        return dp[start][target];\n    }\n\n    /* Subtract nums[start] from target */\n    match = partition(nums, numsSize, start + 1, target - nums[start], dp);\n    \n    /* Ignore nums[start] */\n    if (match == false) {\n        match = partition(nums, numsSize, start + 1, target, dp);\n    }\n    \n    dp[start][target] = match;\n\n    return match;\n}\n\nbool canPartition(int* nums, int numsSize){\n\n    /*\n     * Input:\n     *  nums, integer array\n     *  numsSize, number of elements in given array\n     */\n\n    int sum = 0, **dp;\n    bool ans = false;\n    \n    /* Calculate the sum of nums. */\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n    }\n    \n    /* The sum should be 2 * x because we want to divide the number into two parts */\n    if (sum % 2) {\n        return false;\n    }\n    \n    dp = (int **)malloc(sizeof(int *) * numsSize);\n    \n    /* Allocate DP table, the size of table should be numsSize * (sum / 2 + 1) */\n    for (int i = 0; i < numsSize; i++) {\n        dp[i] = (int *)malloc(sizeof(int) * (sum / 2 + 1));\n\n        for (int j = 0; j < (sum / 2 + 1); j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    ans = partition(nums, numsSize, 0, sum / 2, dp);\n    \n    for (int i = 0; i < numsSize; i++) {\n        free(dp[i]);\n    }\n    \n    free(dp);\n    \n    /*\n     * return true if you can partition the array into two subsets such that \n     * the sum of the elements in both subsets is equal or false otherwise.\n     */\n\n    return ans;\n}\n", "\nint partition(int *nums, int numsSize, int start, int target, int **dp)\n{\n    bool match = false;\n    \n    if (target == 0) {\n        return true;\n    }\n\n    if (start == numsSize || target < 0) {\n        return false;\n    }\n    \n    if (dp[start][target] != -1) {\n        return dp[start][target];\n    }\n\n    /* Subtract nums[start] from target */\n    match = partition(nums, numsSize, start + 1, target - nums[start], dp);\n    \n    /* Ignore nums[start] */\n    if (match == false) {\n        match = partition(nums, numsSize, start + 1, target, dp);\n    }\n    \n    dp[start][target] = match;\n\n    return match;\n}\n\nbool canPartition(int* nums, int numsSize){\n\n    /*\n     * Input:\n     *  nums, integer array\n     *  numsSize, number of elements in given array\n     */\n\n    int sum = 0, **dp;\n    bool ans = false;\n    \n    /* Calculate the sum of nums. */\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n    }\n    \n    /* The sum should be 2 * x because we want to divide the number into two parts */\n    if (sum % 2) {\n        return false;\n    }\n    \n    dp = (int **)malloc(sizeof(int *) * numsSize);\n    \n    /* Allocate DP table, the size of table should be numsSize * (sum / 2 + 1) */\n    for (int i = 0; i < numsSize; i++) {\n        dp[i] = (int *)malloc(sizeof(int) * (sum / 2 + 1));\n\n        for (int j = 0; j < (sum / 2 + 1); j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    ans = partition(nums, numsSize, 0, sum / 2, dp);\n    \n    for (int i = 0; i < numsSize; i++) {\n        free(dp[i]);\n    }\n    \n    free(dp);\n    \n    /*\n     * return true if you can partition the array into two subsets such that \n     * the sum of the elements in both subsets is equal or false otherwise.\n     */\n\n    return ans;\n}\n", "\nint partition(int *nums, int numsSize, int start, int target, int **dp)\n{\n    bool match = false;\n    \n    if (target == 0) {\n        return true;\n    }\n\n    if (start == numsSize || target < 0) {\n        return false;\n    }\n    \n    if (dp[start][target] != -1) {\n        return dp[start][target];\n    }\n\n    /* Subtract nums[start] from target */\n    match = partition(nums, numsSize, start + 1, target - nums[start], dp);\n    \n    /* Ignore nums[start] */\n    if (match == false) {\n        match = partition(nums, numsSize, start + 1, target, dp);\n    }\n    \n    dp[start][target] = match;\n\n    return match;\n}\n\nbool canPartition(int* nums, int numsSize){\n\n    /*\n     * Input:\n     *  nums, integer array\n     *  numsSize, number of elements in given array\n     */\n\n    int sum = 0, **dp;\n    bool ans = false;\n    \n    /* Calculate the sum of nums. */\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n    }\n    \n    /* The sum should be 2 * x because we want to divide the number into two parts */\n    if (sum % 2) {\n        return false;\n    }\n    \n    dp = (int **)malloc(sizeof(int *) * numsSize);\n    \n    /* Allocate DP table, the size of table should be numsSize * (sum / 2 + 1) */\n    for (int i = 0; i < numsSize; i++) {\n        dp[i] = (int *)malloc(sizeof(int) * (sum / 2 + 1));\n\n        for (int j = 0; j < (sum / 2 + 1); j++) {\n            dp[i][j] = -1;\n        }\n    }\n    \n    ans = partition(nums, numsSize, 0, sum / 2, dp);\n    \n    for (int i = 0; i < numsSize; i++) {\n        free(dp[i]);\n    }\n    \n    free(dp);\n    \n    /*\n     * return true if you can partition the array into two subsets such that \n     * the sum of the elements in both subsets is equal or false otherwise.\n     */\n\n    return ans;\n}\n"]}
{"id": "801", "ref_c": [["int** pacificAtlantic(int** heights, int heightsSize, int* heightsColSize, int* returnSize, int** returnColumnSizes){\\n    unsigned char ucHeightsSize = heightsSize - 1, ucHeightsColSize = *heightsColSize - 1;\\n\\n    // check first row (pacific ocean)\\n    for(unsigned char i=0; i<=ucHeightsColSize; i++)\\n    {\\n        if((heights[0][i]&PACIFIC_BIT) == 0) PacificAtlanticInner(heights, ucHeightsSize, ucHeightsColSize, PACIFIC_BIT, 0, i);\\n    }"], ["int** pacificAtlantic(int** heights, int heightsSize, int* heightsColSize, int* returnSize, int** returnColumnSizes){\\n    unsigned char ucHeightsSize = heightsSize - 1, ucHeightsColSize = *heightsColSize - 1;\\n\\n    // check first row (pacific ocean)\\n    for(unsigned char i=0; i<=ucHeightsColSize; i++)\\n    {\\n        if((heights[0][i]&PACIFIC_BIT) == 0) PacificAtlanticInner(heights, ucHeightsSize, ucHeightsColSize, PACIFIC_BIT, 0, i);\\n    }"], ["int** pacificAtlantic(int** heights, int heightsSize, int* heightsColSize, int* returnSize, int** returnColumnSizes){\\n    unsigned char ucHeightsSize = heightsSize - 1, ucHeightsColSize = *heightsColSize - 1;\\n\\n    // check first row (pacific ocean)\\n    for(unsigned char i=0; i<=ucHeightsColSize; i++)\\n    {\\n        if((heights[0][i]&PACIFIC_BIT) == 0) PacificAtlanticInner(heights, ucHeightsSize, ucHeightsColSize, PACIFIC_BIT, 0, i);\\n    }"]]}
{"id": "802", "ref_c": [["int countBattleships(char** board, int boardSize, int* boardColSize)\\n{\\n    int i, j;\\n    int cnt = 0;\\n    \\n    for (i = 0; i < boardSize; i++) {\\n        for (j = 0; j < boardColSize[0]; j++) {\\n            if ((board[i][j] == \\'X\\') &&\\n                (i == 0 || board[i-1][j] == \\'.\\') &&\\n                (j == 0 || board[i][j-1] == \\'.\\'))\\n                cnt++;\\n        }"], ["int countBattleships(char** board, int boardSize, int* boardColSize)\\n{\\n  M = boardSize;\\n  N = boardColSize[0];\\n  int count = 0;\\n  for (int i = 0; i < boardSize; i++)\\n    for (int j = 0; j < boardColSize[0]; j++)\\n      if (board[i][j] == \\'X\\')\\n      {\\n        dfs (board, i, j);\\n        count++;\\n      }"], ["int countBattleships(char** board, int boardSize, int* boardColSize)\\n{\\n    int i, j;\\n    int cnt = 0;\\n    \\n    for (i = 0; i < boardSize; i++) {\\n        for (j = 0; j < boardColSize[0]; j++) {\\n            if ((board[i][j] == \\'X\\') &&\\n                (i == 0 || board[i-1][j] == \\'.\\') &&\\n                (j == 0 || board[i][j-1] == \\'.\\'))\\n                cnt++;\\n        }"]]}
{"id": "803", "ref_c": [["int findMaximumXOR(int* nums, int numsSize){\\n    struct Trie *trie=TrieInit();\\n    for(int i=0;i<numsSize;i++){\\n        TrieInsert(trie,nums[i]);\\n    }"], ["int findMaximumXOR(int* nums, int numsSize)\\n{\\n    struct Tree* node = root;\\n    int num, maxx = -1, bit_pos = 0, xor = 0;\\n\\n    for (int i = 0; i < numsSize; i++)\\n        maxx = maxx < nums[i] ? nums[i] : maxx;\\n    while (maxx)\\n    {\\n        bit_pos++;\\n        maxx >>= 1;\\n    }"], ["int findMaximumXOR(int* nums, int numsSize)\\n{\\n    struct Tree* node = root;\\n    int num, maxx = -1, bit_pos = 0, xor = 0;\\n\\n    for (int i = 0; i < numsSize; i++)\\n        maxx = maxx < nums[i] ? nums[i] : maxx;\\n    while (maxx)\\n    {\\n        bit_pos++;\\n        maxx >>= 1;\\n    }"]]}
{"id": "804", "ref_c": [["char * originalDigits(char * s){\\n    // char digit[10][10]={\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"}"], ["char * originalDigits(char * s){\\n    // char digit[10][10]={\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"}"], ["char * originalDigits(char * s){\\n    // char digit[10][10]={\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"}"]]}
{"id": "805", "ref_c": [["int characterReplacement(char * s, int k){\\n    int maxf = 0;\\n    int maxlen = 0;\\n    \\n    int l = 0;\\n    int r = 0;\\n\\n    int count[128] = {0}"], ["int characterReplacement(char * s, int k){ \\n    if(!s || *s == \\'\\\\0\\') \\n        return 0;\\n\\n    int *fmap = calloc(26,sizeof(int));  \\n    char *X = s, *Z = s; /*X iterates, Y represents earliest diff*/ \\n\\n    int longest = 0 , max = 0;  \\n \\n\\n    while(*Z != \\'\\\\0\\') { \\n        fmap[*Z - \\'A\\']++; \\n        int fcurr = fmap[*Z - \\'A\\'];  \\n        max = fcurr > max ? fcurr : max ; \\n        int cnt = Z + 1 - X-max;\\n\\n        if(cnt > k) { \\n            fmap[*X - \\'A\\']--; \\n            X++;\\n        }"], ["int characterReplacement(char * s, int k){\\n    int maxf = 0;\\n    int maxlen = 0;\\n    \\n    int l = 0;\\n    int r = 0;\\n\\n    int count[128] = {0}"]]}
{"id": "807", "ref_c": [["int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {\\n  struct Node* queue[10001];\\n  int leveSizes[10001] = {}"], ["int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {\\n  struct Node* queue[10001];\\n  int leveSizes[10001] = {}"], ["int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {\\n  struct Node* queue[10001];\\n  int leveSizes[10001] = {}"]]}
{"id": "809", "ref_c": [["int minMutation(char * startGene, char * endGene, char ** bank, int bankSize)\\n{\\n    int N = bankSize;\\n    int q[12];\\n    int dq[12];\\n    int head = 0;\\n    int tail = 0;\\n    int s;\\n    int depth;\\n    int min_depth = INT_MAX;\\n    struct LL* sen, *temp = new_node (0);\\n    sen = temp;\\n\\n    create_graph (bank, N, startGene, endGene);\\n\\n    if (endGeneindex < 0)\\n        return -1;\\n\\n    // insert root into queue.\\n    q[head] = N;\\n    dq[head] = 0;\\n    // root is visited\\n    visited[q[head]] = 1;\\n    head++;\\n\\n    // while q not empty\\n    while (head > tail)\\n    {\\n        // dequeue to s.\\n        s = q[tail];\\n        depth = dq[tail];\\n        if (s == endGeneindex)\\n        {\\n            min_depth = min_depth > depth ? depth : min_depth;\\n        }"], ["int minMutation(char * startGene, char * endGene, char ** bank, int bankSize)\\n{\\n    int N = bankSize;\\n    int q[12];\\n    int dq[12];\\n    int head = 0;\\n    int tail = 0;\\n    int s;\\n    int depth;\\n    int min_depth = INT_MAX;\\n    struct LL* sen, *temp = new_node (0);\\n    sen = temp;\\n\\n    create_graph (bank, N, startGene, endGene);\\n\\n    if (endGeneindex < 0)\\n        return -1;\\n\\n    // insert root into queue.\\n    q[head] = N;\\n    dq[head] = 0;\\n    // root is visited\\n    visited[q[head]] = 1;\\n    head++;\\n\\n    // while q not empty\\n    while (head > tail)\\n    {\\n        // dequeue to s.\\n        s = q[tail];\\n        depth = dq[tail];\\n        if (s == endGeneindex)\\n        {\\n            min_depth = min_depth > depth ? depth : min_depth;\\n        }"], ["int minMutation(char * startGene, char * endGene, char ** bank, int bankSize)\\n{\\n    int N = bankSize;\\n    int q[12];\\n    int dq[12];\\n    int head = 0;\\n    int tail = 0;\\n    int s;\\n    int depth;\\n    int min_depth = INT_MAX;\\n    struct LL* sen, *temp = new_node (0);\\n    sen = temp;\\n\\n    create_graph (bank, N, startGene, endGene);\\n\\n    if (endGeneindex < 0)\\n        return -1;\\n\\n    // insert root into queue.\\n    q[head] = N;\\n    dq[head] = 0;\\n    // root is visited\\n    visited[q[head]] = 1;\\n    head++;\\n\\n    // while q not empty\\n    while (head > tail)\\n    {\\n        // dequeue to s.\\n        s = q[tail];\\n        depth = dq[tail];\\n        if (s == endGeneindex)\\n        {\\n            min_depth = min_depth > depth ? depth : min_depth;\\n        }"]]}
{"id": "810", "ref_c": [["int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) {\\n    int end = intervals[0][1];\\n    int count = intervalsSize - 1;\\n    for (int i = 1; i < intervalsSize; i++) {\\n        if (intervals[i][0] >= end) {\\n            end = intervals[i][1];\\n            count--;\\n        }"], ["int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) {\\n    int end = intervals[0][1];\\n    int count = intervalsSize - 1;\\n    for (int i = 1; i < intervalsSize; i++) {\\n        if (intervals[i][0] >= end) {\\n            end = intervals[i][1];\\n            count--;\\n        }"], ["int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) {\\n    int end = intervals[0][1];\\n    int count = intervalsSize - 1;\\n    for (int i = 1; i < intervalsSize; i++) {\\n        if (intervals[i][0] >= end) {\\n            end = intervals[i][1];\\n            count--;\\n        }"]]}
{"id": "811", "ref_c": [["int* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize){\\n    int** p = (int**)calloc(intervalsSize + 1, sizeof(int*));\\n    int* ans = (int*)calloc(intervalsSize, sizeof(int));\\n    *returnSize = intervalsSize;\\n    for(int i = 0; i < intervalsSize; i++){\\n        p[i] = (int*)calloc(3, sizeof(int));\\n        memcpy(p[i], intervals[i], sizeof(int) * 2);\\n        p[i][2] = i; /* for saving index */\\n    }"], ["int* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize){\\n    int** p = (int**)calloc(intervalsSize + 1, sizeof(int*));\\n    int* ans = (int*)calloc(intervalsSize, sizeof(int));\\n    *returnSize = intervalsSize;\\n    for(int i = 0; i < intervalsSize; i++){\\n        p[i] = (int*)calloc(3, sizeof(int));\\n        memcpy(p[i], intervals[i], sizeof(int) * 2);\\n        p[i][2] = i; /* for saving index */\\n    }"], ["int* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize){\\n    int** p = (int**)calloc(intervalsSize + 1, sizeof(int*));\\n    int* ans = (int*)calloc(intervalsSize, sizeof(int));\\n    *returnSize = intervalsSize;\\n    for(int i = 0; i < intervalsSize; i++){\\n        p[i] = (int*)calloc(3, sizeof(int));\\n        memcpy(p[i], intervals[i], sizeof(int) * 2);\\n        p[i][2] = i; /* for saving index */\\n    }"]]}
{"id": "812", "ref_c": [["int pathSum(struct TreeNode* root, int targetSum){\\n\\n    if(root == NULL){\\n        return 0;\\n    }", "int pathSum(struct TreeNode* root, int targetSum) {\\n\\n    return findAllPossiblePath(root, (LLI)targetSum);\\n    \\n}"], ["int pathSum(struct TreeNode* root, int targetSum){\\n\\n    if(root == NULL){\\n        return 0;\\n    }", "int pathSum(struct TreeNode* root, int targetSum) {\\n\\n    return findAllPossiblePath(root, (LLI)targetSum);\\n    \\n}"], ["int pathSum(struct TreeNode* root, int targetSum){\\n\\n    if(root == NULL){\\n        return 0;\\n    }", "int pathSum(struct TreeNode* root, int targetSum) {\\n\\n    return findAllPossiblePath(root, (LLI)targetSum);\\n    \\n}"]]}
{"id": "813", "ref_c": [["int* findAnagrams(char * s, char * p, int* returnSize)\\n{\\n\\n    /* Algo:\\n        0. Init result array, lutp, luts, sump, sums.\\n        1. If lenp > lens, return empty array.\\n        2. Create a LUTp of frequency count for string p. Also save the\\n           sum of characters in sump. \\n        3. Repeat step 2 for string s for the first lenp characters (i.e. \\n           window of size lenp).\\n        4. Slide the window of size lenp towards right over string s.\\n        5. Check if sums == sump. If so, compare luts for both strings.\\n           If LUTs match, save the starting index in result array.\\n        6. Go to step 4 if end of window has not reached end of string s.\\n        7. return result array.\\n\\n    */\\n\\n    // 0\\n\\n    int lens = strlen(s);\\n    int lenp = strlen(p);\\n    \\n    *returnSize = 0;\\n\\n    // 1\\n    if (lenp > lens)\\n        return NULL;\\n    else\\n        result = (int*) malloc (sizeof(int) * (lens- lenp + 1));\\n\\n    pos = 0;\\n    sump = sums = 0;\\n    memset (lutp, 0, sizeof(int) * 26);\\n    memset (luts, 0, sizeof(int) * 26);\\n\\n    // 2\\n    char c;\\n    for (int i = 0; i < lenp; i++)\\n    {\\n        c = p[i] - \\'a\\';\\n        sump += c;\\n        lutp[c]++;\\n    }"], ["int* findAnagrams(char * s, char * p, int* returnSize)\\n{\\n\\n    /* Algo:\\n        0. Init result array, lutp, luts, sump, sums.\\n        1. If lenp > lens, return empty array.\\n        2. Create a LUTp of frequency count for string p. Also save the\\n           sum of characters in sump. \\n        3. Repeat step 2 for string s for the first lenp characters (i.e. \\n           window of size lenp).\\n        4. Slide the window of size lenp towards right over string s.\\n        5. Check if sums == sump. If so, compare luts for both strings.\\n           If LUTs match, save the starting index in result array.\\n        6. Go to step 4 if end of window has not reached end of string s.\\n        7. return result array.\\n\\n    */\\n\\n    // 0\\n\\n    int lens = strlen(s);\\n    int lenp = strlen(p);\\n    \\n    *returnSize = 0;\\n\\n    // 1\\n    if (lenp > lens)\\n        return NULL;\\n    else\\n        result = (int*) malloc (sizeof(int) * (lens- lenp + 1));\\n\\n    pos = 0;\\n    sump = sums = 0;\\n    memset (lutp, 0, sizeof(int) * 26);\\n    memset (luts, 0, sizeof(int) * 26);\\n\\n    // 2\\n    char c;\\n    for (int i = 0; i < lenp; i++)\\n    {\\n        c = p[i] - \\'a\\';\\n        sump += c;\\n        lutp[c]++;\\n    }"], ["int* findAnagrams(char * s, char * p, int* returnSize)\\n{\\n\\n    /* Algo:\\n        0. Init result array, lutp, luts, sump, sums.\\n        1. If lenp > lens, return empty array.\\n        2. Create a LUTp of frequency count for string p. Also save the\\n           sum of characters in sump. \\n        3. Repeat step 2 for string s for the first lenp characters (i.e. \\n           window of size lenp).\\n        4. Slide the window of size lenp towards right over string s.\\n        5. Check if sums == sump. If so, compare luts for both strings.\\n           If LUTs match, save the starting index in result array.\\n        6. Go to step 4 if end of window has not reached end of string s.\\n        7. return result array.\\n\\n    */\\n\\n    // 0\\n\\n    int lens = strlen(s);\\n    int lenp = strlen(p);\\n    \\n    *returnSize = 0;\\n\\n    // 1\\n    if (lenp > lens)\\n        return NULL;\\n    else\\n        result = (int*) malloc (sizeof(int) * (lens- lenp + 1));\\n\\n    pos = 0;\\n    sump = sums = 0;\\n    memset (lutp, 0, sizeof(int) * 26);\\n    memset (luts, 0, sizeof(int) * 26);\\n\\n    // 2\\n    char c;\\n    for (int i = 0; i < lenp; i++)\\n    {\\n        c = p[i] - \\'a\\';\\n        sump += c;\\n        lutp[c]++;\\n    }"]]}
{"id": "814", "ref_c": [["int* findDuplicates(int* nums, int numsSize, int* returnSize) {\\n    mergeSort(nums, 0, numsSize - 1);\\n    int arr[numsSize];\\n    int k = 0;\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(nums[i] == nums[i + 1])\\n        {\\n            arr[k++] = nums[i];\\n        }"], ["int* findDuplicates(int* nums, int numsSize, int* returnSize) {\\n    mergeSort(nums, 0, numsSize - 1);\\n    int arr[numsSize];\\n    int k = 0;\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(nums[i] == nums[i + 1])\\n        {\\n            arr[k++] = nums[i];\\n        }"], ["int* findDuplicates(int* nums, int numsSize, int* returnSize) {\\n    mergeSort(nums, 0, numsSize - 1);\\n    int arr[numsSize];\\n    int k = 0;\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(nums[i] == nums[i + 1])\\n        {\\n            arr[k++] = nums[i];\\n        }"]]}
{"id": "815", "ref_c": ["\nint compress(char* chars, int charsSize)\n{\n    char compressed[charsSize * 2]; // Character array to store the compressed string\n    if (charsSize <= 1) \n    {\n        return charsSize; // Nothing to compress\n    }\n\n    int count = 1;\n    int compressed_index = 0;\n\n    for (int i = 0; i < charsSize; i++)\n    {\n        if (i < charsSize - 1 && chars[i] == chars[i + 1])\n        {\n            count++;\n        } \n        else\n        {\n            compressed[compressed_index++] = chars[i];\n            if (count > 1)\n            {\n                // Convert the count to a character and store it in the array\n                if (count < 10)\n                {\n                    compressed[compressed_index++] = '0' + count;\n                }\n                else\n                {\n                    int index = compressed_index;\n                    char digits[sizeof(compressed)];\n                    while (count >= 1)\n                    {\n                        digits[compressed_index++] = '0' + (count % 10);\n                        count = count / 10;\n                    }\n                    for (int i = index, j = compressed_index - 1; i < compressed_index; i++, j--)\n                    {\n                        char number = digits[i];\n                        compressed[j] = number;\n                    }\n                }\n                count = 1;\n            }\n        }\n    }\n\n    compressed[compressed_index] = '\u0000'; // Null-terminate the compressed string\n    strcpy(chars, compressed); // Copy the compressed string back to the chars array\n\n    return strlen(chars); // Return the length of the compressed string\n}\n", "\nint compress(char* chars, int charsSize)\n{\n    char compressed[charsSize * 2]; // Character array to store the compressed string\n    if (charsSize <= 1) \n    {\n        return charsSize; // Nothing to compress\n    }\n\n    int count = 1;\n    int compressed_index = 0;\n\n    for (int i = 0; i < charsSize; i++)\n    {\n        if (i < charsSize - 1 && chars[i] == chars[i + 1])\n        {\n            count++;\n        } \n        else\n        {\n            compressed[compressed_index++] = chars[i];\n            if (count > 1)\n            {\n                // Convert the count to a character and store it in the array\n                if (count < 10)\n                {\n                    compressed[compressed_index++] = '0' + count;\n                }\n                else\n                {\n                    int index = compressed_index;\n                    char digits[sizeof(compressed)];\n                    while (count >= 1)\n                    {\n                        digits[compressed_index++] = '0' + (count % 10);\n                        count = count / 10;\n                    }\n                    for (int i = index, j = compressed_index - 1; i < compressed_index; i++, j--)\n                    {\n                        char number = digits[i];\n                        compressed[j] = number;\n                    }\n                }\n                count = 1;\n            }\n        }\n    }\n\n    compressed[compressed_index] = '\u0000'; // Null-terminate the compressed string\n    strcpy(chars, compressed); // Copy the compressed string back to the chars array\n\n    return strlen(chars); // Return the length of the compressed string\n}\n", "\nint compress(char* chars, int charsSize)\n{\n    char compressed[charsSize * 2]; // Character array to store the compressed string\n    if (charsSize <= 1) \n    {\n        return charsSize; // Nothing to compress\n    }\n\n    int count = 1;\n    int compressed_index = 0;\n\n    for (int i = 0; i < charsSize; i++)\n    {\n        if (i < charsSize - 1 && chars[i] == chars[i + 1])\n        {\n            count++;\n        } \n        else\n        {\n            compressed[compressed_index++] = chars[i];\n            if (count > 1)\n            {\n                // Convert the count to a character and store it in the array\n                if (count < 10)\n                {\n                    compressed[compressed_index++] = '0' + count;\n                }\n                else\n                {\n                    int index = compressed_index;\n                    char digits[sizeof(compressed)];\n                    while (count >= 1)\n                    {\n                        digits[compressed_index++] = '0' + (count % 10);\n                        count = count / 10;\n                    }\n                    for (int i = index, j = compressed_index - 1; i < compressed_index; i++, j--)\n                    {\n                        char number = digits[i];\n                        compressed[j] = number;\n                    }\n                }\n                count = 1;\n            }\n        }\n    }\n\n    compressed[compressed_index] = '\u0000'; // Null-terminate the compressed string\n    strcpy(chars, compressed); // Copy the compressed string back to the chars array\n\n    return strlen(chars); // Return the length of the compressed string\n}\n"]}
{"id": "816", "ref_c": [["struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\\n    l1=reverseLinkedList(l1);\\n    l2=reverseLinkedList(l2);\\n    int carry=0;\\n    int total=0;\\n    int digit=0;\\n    struct ListNode* result=NULL;\\n    struct ListNode *current = NULL;\\n\\n    while(l1!= NULL || l2!= NULL || carry)\\n    {\\n       int val1=l1!=NULL ? l1->val : 0;\\n       int val2=l2!=NULL ? l2->val : 0;\\n\\n       total=val1+val2+carry;\\n       carry=total/10;\\n       digit=total%10;\\n\\n       struct ListNode* node=createNode(digit);\\n       if (result == NULL) {\\n            result = node;\\n            current = node;\\n        }"], ["struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\\n    struct ListNode* prev = NULL;\\n    struct ListNode * tmp1 = l1;\\n    struct ListNode* tmp2 = l2;\\n    struct ListNode* big = NULL;\\n    int sum = 0;\\n    int remainder = 0;\\n\\n    l1 = reverse(l1);\\n    l2 = reverse(l2);\\n    tmp1 = l1;\\n    tmp2 = l2;\\n\\n//prev keeps track of last node in case list lengths are equal\\n\\n    while(tmp1 && tmp2) {\\n        prev = tmp2;\\n        sum = (tmp1->val + tmp2->val + remainder);\\n        tmp1->val = sum%10;\\n        remainder = sum/10;\\n        tmp2->val = tmp1->val;\\n        tmp1 = tmp1->next;\\n        tmp2 = tmp2->next;\\n    }"], ["struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\\n    struct ListNode* prev = NULL;\\n    struct ListNode * tmp1 = l1;\\n    struct ListNode* tmp2 = l2;\\n    struct ListNode* big = NULL;\\n    int sum = 0;\\n    int remainder = 0;\\n\\n    l1 = reverse(l1);\\n    l2 = reverse(l2);\\n    tmp1 = l1;\\n    tmp2 = l2;\\n\\n//prev keeps track of last node in case list lengths are equal\\n\\n    while(tmp1 && tmp2) {\\n        prev = tmp2;\\n        sum = (tmp1->val + tmp2->val + remainder);\\n        tmp1->val = sum%10;\\n        remainder = sum/10;\\n        tmp2->val = tmp1->val;\\n        tmp1 = tmp1->next;\\n        tmp2 = tmp2->next;\\n    }"]]}
{"id": "817", "ref_c": [["int numberOfBoomerangs(int** points, int pointsSize, int* pointsColSize){\\n    \\n    int length, i, j, x, y;\\n    int answer = 0;\\n    head = NULL;\\n    for(i = 0; i < pointsSize; i++){\\n        for(j = 0; j < pointsSize; j++){\\n            x = points[i][0] - points[j][0];\\n            y = points[i][1] - points[j][1];\\n            length = x * x + y * y;\\n            insertNode(length);\\n        }"], ["int numberOfBoomerangs(int** points, int pointsSize, int* pointsColSize){\\n    \\n    int length, i, j, x, y;\\n    int answer = 0;\\n    head = NULL;\\n    for(i = 0; i < pointsSize; i++){\\n        for(j = 0; j < pointsSize; j++){\\n            x = points[i][0] - points[j][0];\\n            y = points[i][1] - points[j][1];\\n            length = x * x + y * y;\\n            insertNode(length);\\n        }"], ["int numberOfBoomerangs(int** points, int pointsSize, int* pointsColSize){\\n    \\n    int length, i, j, x, y;\\n    int answer = 0;\\n    head = NULL;\\n    for(i = 0; i < pointsSize; i++){\\n        for(j = 0; j < pointsSize; j++){\\n            x = points[i][0] - points[j][0];\\n            y = points[i][1] - points[j][1];\\n            length = x * x + y * y;\\n            insertNode(length);\\n        }"]]}
{"id": "819", "ref_c": [["struct TreeNode* deleteNode(struct TreeNode* root, int key){\\n    if(root==NULL) return root;     //Base case\\n    if(key<(root->val)) root->left=deleteNode(root->left,key);\\n    else if(key>(root->val)) root->right=deleteNode(root->right,key);\\n    else{\\n        //node with one or no child\\n        if(root->left==NULL){\\n            struct TreeNode *temp=root->right;\\n            free(root);\\n            return temp;\\n        }"], ["struct TreeNode* deleteNode(struct TreeNode* root, int key)\\n{\\n\\tif (!root)\\n\\t\\treturn root;\\n \\n    // find node to remove\\n    if (key < root->val)\\n        root->left = deleteNode(root->left, key);\\n\\n  \\telse if (key > root->val)\\n        root->right = deleteNode(root->right, key);\\n\\n    // node found\\n    else\\n    {\\n        if (root->left == NULL) // no left child\\n        {\\n            struct TreeNode *temp = root->right;\\n            free(root);\\n            return temp;\\n        }"], ["struct TreeNode* deleteNode(struct TreeNode* root, int key){\\n    if(root==NULL) return root;     //Base case\\n    if(key<(root->val)) root->left=deleteNode(root->left,key);\\n    else if(key>(root->val)) root->right=deleteNode(root->right,key);\\n    else{\\n        //node with one or no child\\n        if(root->left==NULL){\\n            struct TreeNode *temp=root->right;\\n            free(root);\\n            return temp;\\n        }"]]}
{"id": "820", "ref_c": [["char * frequencySort(char * s){\\n    char *iterator = s;\\n    char_freq char_set[62] = {{\\'0\\', 0}"], ["char * frequencySort(char * s){\\n    char *iterator = s;\\n    char_freq char_set[62] = {{\\'0\\', 0}"], ["char * frequencySort(char * s){\\n    char *iterator = s;\\n    char_freq char_set[62] = {{\\'0\\', 0}"]]}
{"id": "821", "ref_c": ["\nint cmp(const void *a, const void *b)\n{\n    const int  x = ((int **)a)[0][1];\n    const int  y = ((int **)b)[0][1];\n    if(x > y)\n        return 1;\n    else if(x < y)\n        return -1;\n    return 0;\n}\n\nint findMinArrowShots(int** points, int pointsSize, int* pointsColSize){\n    qsort(points, pointsSize, sizeof(int *), cmp);\n    int result = 1, min = points[0][1];\n    for(int i = 1; i < pointsSize; i++)\n    {\n        if(points[i][0] > min)\n        {\n            result++;\n            min = points[i][1];\n        }\n        else\n            min = min < points[i][1] ? min : points[i][1];\n    }\n    return result;\n}\n", "\nint cmp(const void *a, const void *b)\n{\n    const int  x = ((int **)a)[0][1];\n    const int  y = ((int **)b)[0][1];\n    if(x > y)\n        return 1;\n    else if(x < y)\n        return -1;\n    return 0;\n}\n\nint findMinArrowShots(int** points, int pointsSize, int* pointsColSize){\n    qsort(points, pointsSize, sizeof(int *), cmp);\n    int result = 1, min = points[0][1];\n    for(int i = 1; i < pointsSize; i++)\n    {\n        if(points[i][0] > min)\n        {\n            result++;\n            min = points[i][1];\n        }\n        else\n            min = min < points[i][1] ? min : points[i][1];\n    }\n    return result;\n}\n", "\nint cmp(const void *a, const void *b)\n{\n    const int  x = ((int **)a)[0][1];\n    const int  y = ((int **)b)[0][1];\n    if(x > y)\n        return 1;\n    else if(x < y)\n        return -1;\n    return 0;\n}\n\nint findMinArrowShots(int** points, int pointsSize, int* pointsColSize){\n    qsort(points, pointsSize, sizeof(int *), cmp);\n    int result = 1, min = points[0][1];\n    for(int i = 1; i < pointsSize; i++)\n    {\n        if(points[i][0] > min)\n        {\n            result++;\n            min = points[i][1];\n        }\n        else\n            min = min < points[i][1] ? min : points[i][1];\n    }\n    return result;\n}\n"]}
{"id": "822", "ref_c": [["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"]]}
{"id": "823", "ref_c": [["int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\\n    int hashSize = nums1Size * nums2Size; int hashBits; __asm__ (\" bsr %1, %0 \\\\n\" : \"+r\" (hashBits) : \"r\" (hashSize));\\n    hashSize = 2 << hashBits; hashBits = 31 - hashBits;\\n    int table[hashSize]; clearints(table, hashSize);\\n    int counts[hashSize]; clearints(counts, hashSize);\\n    hashSize--;\\n    for(int i = 0; i < nums1Size; i++)\\n    {   int ni = nums1[i];\\n        for(int ii = 0; ii < nums2Size; ii++)\\n        {   int sum = ni + nums2[ii];\\n            uint32_t hash = ((uint32_t)(2808820391 * sum)) >> hashBits;\\n            int c;\\n            while((c=counts[hash]))\\n            {\\n                if(table[hash] == sum) goto foundit;\\n                ++hash; hash &= hashSize;\\n            }"], ["int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\\n    int i,j,k,l,r;\\n    int sz = 0;\\n    \\n    int nums5[40000];\\n    int nums5Size = 0;\\n    for (i = 0; i < nums3Size; i=i+1) {\\n        for (j = 0; j < nums4Size; j=j+1) {\\n            nums5[nums5Size++] = nums3[i]+nums4[j];\\n        }"], ["int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\\n    int i,j,k,l,r;\\n    int sz = 0;\\n    \\n    int nums5[40000];\\n    int nums5Size = 0;\\n    for (i = 0; i < nums3Size; i=i+1) {\\n        for (j = 0; j < nums4Size; j=j+1) {\\n            nums5[nums5Size++] = nums3[i]+nums4[j];\\n        }"]]}
{"id": "824", "ref_c": [["bool find132pattern(int* nums, int numsSize){\\n    int peak = numsSize, min = INT_MIN;\\n    for (int i = numsSize - 1; i > -1; i--) {\\n        if (nums[i] < min)\\n            return true;\\n        while (peak < numsSize && nums[i] > nums[peak]) {\\n            min = nums[peak];\\n            peak++;\\n        }"], ["bool find132pattern(int* nums, int numsSize){\\n    int peak = numsSize, min = INT_MIN;\\n    for (int i = numsSize - 1; i > -1; i--) {\\n        if (nums[i] < min)\\n            return true;\\n        while (peak < numsSize && nums[i] > nums[peak]) {\\n            min = nums[peak];\\n            peak++;\\n        }"], ["bool find132pattern(int* nums, int numsSize){\\n    int peak = numsSize, min = INT_MIN;\\n    for (int i = numsSize - 1; i > -1; i--) {\\n        if (nums[i] < min)\\n            return true;\\n        while (peak < numsSize && nums[i] > nums[peak]) {\\n            min = nums[peak];\\n            peak++;\\n        }"]]}
{"id": "825", "ref_c": [["bool circularArrayLoop(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        int slow=i;\\n        int fast=nextnode(i,nums,numsSize);\\n        while(nums[fast]*nums[i]>0 && nums[nextnode(fast,nums,numsSize)]*nums[i]>0){\\n            if(fast==slow){\\n                if(slow==nextnode(slow,nums,numsSize))break;\\n                return true;\\n            }"], ["bool circularArrayLoop(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        int slow=i;\\n        int fast=nextnode(i,nums,numsSize);\\n        while(nums[fast]*nums[i]>0 && nums[nextnode(fast,nums,numsSize)]*nums[i]>0){\\n            if(fast==slow){\\n                if(slow==nextnode(slow,nums,numsSize))break;\\n                return true;\\n            }"], ["bool circularArrayLoop(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        int slow=i;\\n        int fast=nextnode(i,nums,numsSize);\\n        while(nums[fast]*nums[i]>0 && nums[nextnode(fast,nums,numsSize)]*nums[i]>0){\\n            if(fast==slow){\\n                if(slow==nextnode(slow,nums,numsSize))break;\\n                return true;\\n            }"]]}
{"id": "826", "ref_c": ["\nint cmp(const void *a,const void *b) {\n    return (*(int*)a-*(int*)b);\n}\nint minMoves2(int* nums, int numsSize){\n    int res= 0;\n    qsort(nums,numsSize,sizeof(int),cmp);\n    int i;\n    int m = (numsSize-1)/2;\n    \n    for(i=0;i<numsSize;i++) res+=abs(nums[i]-nums[m]);\n  \n    \n    return res;\n}\n", "\nint cmp(const void *a,const void *b) {\n    return (*(int*)a-*(int*)b);\n}\nint minMoves2(int* nums, int numsSize){\n    int res= 0;\n    qsort(nums,numsSize,sizeof(int),cmp);\n    int i;\n    int m = (numsSize-1)/2;\n    \n    for(i=0;i<numsSize;i++) res+=abs(nums[i]-nums[m]);\n  \n    \n    return res;\n}\n", "\nint cmp(const void *a,const void *b) {\n    return (*(int*)a-*(int*)b);\n}\nint minMoves2(int* nums, int numsSize){\n    int res= 0;\n    qsort(nums,numsSize,sizeof(int),cmp);\n    int i;\n    int m = (numsSize-1)/2;\n    \n    for(i=0;i<numsSize;i++) res+=abs(nums[i]-nums[m]);\n  \n    \n    return res;\n}\n"]}
{"id": "827", "ref_c": ["\nbool solve(int mx,int target,int sum,int mask,int first){\n        if(first && sum >= target) return false;\n        if(sum >= target) return true;\n\n        if(dp[first][mask] != -1) return dp[first][mask];\n\n        if(first){\n            for(int i=1; i<=mx; ++i){\n                if(mask&(1 << i)) continue;\n                int newMask = mask | (1 << i);\n                if(solve(mx,target,sum+i,newMask,!first) == true) return dp[first][mask] = true;\n            }\n            return dp[first][mask] = false;\n        }\n        for(int i=1; i<=mx; ++i){\n            if(mask&(1 << i)) continue;\n            int newMask = mask | (1 << i);\n            if(solve(mx,target,sum+i,newMask,!first) == false) return dp[first][mask] = false;\n        }\n        return dp[first][mask] = true;\n    }\n    bool canIWin(int maxChoosableInteger, int desiredTotal){\n        if(desiredTotal == 0) return true;\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\n        dp = vector<vector<int>> (2,vector<int> (1 << maxChoosableInteger + 1, -1));\n        return solve(maxChoosableInteger,desiredTotal,0,0,1);\n    }\n};\n", "\nbool solve(int mx,int target,int sum,int mask,int first){\n        if(first && sum >= target) return false;\n        if(sum >= target) return true;\n\n        if(dp[first][mask] != -1) return dp[first][mask];\n\n        if(first){\n            for(int i=1; i<=mx; ++i){\n                if(mask&(1 << i)) continue;\n                int newMask = mask | (1 << i);\n                if(solve(mx,target,sum+i,newMask,!first) == true) return dp[first][mask] = true;\n            }\n            return dp[first][mask] = false;\n        }\n        for(int i=1; i<=mx; ++i){\n            if(mask&(1 << i)) continue;\n            int newMask = mask | (1 << i);\n            if(solve(mx,target,sum+i,newMask,!first) == false) return dp[first][mask] = false;\n        }\n        return dp[first][mask] = true;\n    }\n    bool canIWin(int maxChoosableInteger, int desiredTotal){\n        if(desiredTotal == 0) return true;\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\n        dp = vector<vector<int>> (2,vector<int> (1 << maxChoosableInteger + 1, -1));\n        return solve(maxChoosableInteger,desiredTotal,0,0,1);\n    }\n};\n", "\nbool solve(int mx,int target,int sum,int mask,int first){\n        if(first && sum >= target) return false;\n        if(sum >= target) return true;\n\n        if(dp[first][mask] != -1) return dp[first][mask];\n\n        if(first){\n            for(int i=1; i<=mx; ++i){\n                if(mask&(1 << i)) continue;\n                int newMask = mask | (1 << i);\n                if(solve(mx,target,sum+i,newMask,!first) == true) return dp[first][mask] = true;\n            }\n            return dp[first][mask] = false;\n        }\n        for(int i=1; i<=mx; ++i){\n            if(mask&(1 << i)) continue;\n            int newMask = mask | (1 << i);\n            if(solve(mx,target,sum+i,newMask,!first) == false) return dp[first][mask] = false;\n        }\n        return dp[first][mask] = true;\n    }\n    bool canIWin(int maxChoosableInteger, int desiredTotal){\n        if(desiredTotal == 0) return true;\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\n        dp = vector<vector<int>> (2,vector<int> (1 << maxChoosableInteger + 1, -1));\n        return solve(maxChoosableInteger,desiredTotal,0,0,1);\n    }\n};\n"]}
{"id": "828", "ref_c": ["\nbool is_next(char a, char b) { return a == 'z' ? b == 'a' : a + 1 == b; }\n\nint findSubstringInWraproundString(string p) {\n    unordered_map<char, int> max_lengths;\n\n    int max_length = 1; // The first character is one character long.\n    for (size_t i = 0; i < p.size(); i++) {\n\t\t// Is this the longest substring I've seen ending in this character?\n        if (max_lengths.find(p[i]) == max_lengths.end()) {\n\t\t\t// Never seen this ending character, instantiate it.\n            max_lengths[p[i]] = max_length;\n        } else {\n\t\t\t// Maybe. Pick the longer one.\n            max_lengths[p[i]] = max(max_length, max_lengths[p[i]]);\n        }\n\t\t\n\t\t// Is the next character consecutive?\n        if (i + 1 < p.size() && is_next(p[i], p[i + 1])) max_length++;\n        else max_length = 1;\n    }\n\t\n\t// Add all lengths!\n    int res = 0;\n    for (const pair<char, int>& kv : max_lengths) res += kv.second;\n    return res;\n}\n", "\nbool is_next(char a, char b) { return a == 'z' ? b == 'a' : a + 1 == b; }\n\nint findSubstringInWraproundString(string p) {\n    unordered_map<char, int> max_lengths;\n\n    int max_length = 1; // The first character is one character long.\n    for (size_t i = 0; i < p.size(); i++) {\n\t\t// Is this the longest substring I've seen ending in this character?\n        if (max_lengths.find(p[i]) == max_lengths.end()) {\n\t\t\t// Never seen this ending character, instantiate it.\n            max_lengths[p[i]] = max_length;\n        } else {\n\t\t\t// Maybe. Pick the longer one.\n            max_lengths[p[i]] = max(max_length, max_lengths[p[i]]);\n        }\n\t\t\n\t\t// Is the next character consecutive?\n        if (i + 1 < p.size() && is_next(p[i], p[i + 1])) max_length++;\n        else max_length = 1;\n    }\n\t\n\t// Add all lengths!\n    int res = 0;\n    for (const pair<char, int>& kv : max_lengths) res += kv.second;\n    return res;\n}\n", "\nbool is_next(char a, char b) { return a == 'z' ? b == 'a' : a + 1 == b; }\n\nint findSubstringInWraproundString(string p) {\n    unordered_map<char, int> max_lengths;\n\n    int max_length = 1; // The first character is one character long.\n    for (size_t i = 0; i < p.size(); i++) {\n\t\t// Is this the longest substring I've seen ending in this character?\n        if (max_lengths.find(p[i]) == max_lengths.end()) {\n\t\t\t// Never seen this ending character, instantiate it.\n            max_lengths[p[i]] = max_length;\n        } else {\n\t\t\t// Maybe. Pick the longer one.\n            max_lengths[p[i]] = max(max_length, max_lengths[p[i]]);\n        }\n\t\t\n\t\t// Is the next character consecutive?\n        if (i + 1 < p.size() && is_next(p[i], p[i + 1])) max_length++;\n        else max_length = 1;\n    }\n\t\n\t// Add all lengths!\n    int res = 0;\n    for (const pair<char, int>& kv : max_lengths) res += kv.second;\n    return res;\n}\n"]}
{"id": "829", "ref_c": [["char * validIPAddress(char * queryIP){\\n    char * ret = validIPv4(queryIP);\\n    if (ret) {\\n        return ret;\\n    }"], ["char * validIPAddress(char * queryIP){\\n    char * ret = validIPv4(queryIP);\\n    if (ret) {\\n        return ret;\\n    }"], ["char * validIPAddress(char * queryIP){\\n    char * ret = validIPv4(queryIP);\\n    if (ret) {\\n        return ret;\\n    }"]]}
{"id": "830", "ref_c": [["int rand10() {\\n   while(true){\\n       int row=(rand7()-1)*7;\\n       int column=rand7();\\n       int current=row+column;\\n       if(current<=40)\\n       return ((current-1)%10)+1;\\n   }"], ["int rand10() {\\n    static int initialized = 0;\\n    static int state = 0;\\n\\n    if (!initialized) {\\n        initialized = 1;\\n        state = rand7();\\n    }"], ["int rand10() {\\n    int r;\\n    do {\\n        r = 7 * (rand7() - 1) + rand7();\\n    }"]]}
{"id": "831", "ref_c": [["bool makesquare(int* matchsticks, int matchsticksSize){\\n    int perimeter = 0;\\n    for(int i = 0; i < matchsticksSize; i++)\\n        perimeter += matchsticks[i];\\n    \\n    int len = perimeter / 4;  \\n    int *sides = calloc(sizeof(int), 4);\\n    if(len * 4 != perimeter) return false;\\n    \\n    qsort(matchsticks, matchsticksSize, sizeof(int), cmp);\\n    \\n    return backtrack(0, matchsticks, matchsticksSize, sides, len);\\n}"], ["bool makesquare(int* matchsticks, int matchsticksSize){\\n    /*\\n     * Input:\\n     *  matchsticks, integer array\\n     *  matchsticksSize, size of array\\n     */\\n     \\n    /*\\n     * Algorithm:\\n     *  matchsticks = [1,1,2,2,2]        n\\n     *  The square:                   ------\\n     *                              n |    | n\\n     *                                |    |\\n     *                                ------\\n     *                                   n\\n     *  (1) sum(matchsticks) % 4 have to be equal to 0\\n     *  (2) side length of square is sum(matchsticks) / 4 = 2\\n     *  (3) The length of array should be equal to or larger than 4\\n     *  (4) The maximum number should not be larger than n\\n     *  (5) Need a way to find 4 distinct set of integer whose sum equal to 2?\\n     *      sort in ascending order\\n     *      backtracking method?\\n     *\\n     *  matchsticks = [1, 1, 1, 3, 2],          impossible,\\n     *  matchsticks = [1, 1, 1, 1, 1, 1, 1, 1]  yes\\n     *\\n     */\\n     \\n    int sum = 0;\\n    \\n    /* Requires at least 4 matchsticks */\\n    if (matchsticksSize < 4) {\\n        return false;\\n    }"], ["bool makesquare(int* matchsticks, int matchsticksSize){\\n    /*\\n     * Input:\\n     *  matchsticks, integer array\\n     *  matchsticksSize, size of array\\n     */\\n     \\n    /*\\n     * Algorithm:\\n     *  matchsticks = [1,1,2,2,2]        n\\n     *  The square:                   ------\\n     *                              n |    | n\\n     *                                |    |\\n     *                                ------\\n     *                                   n\\n     *  (1) sum(matchsticks) % 4 have to be equal to 0\\n     *  (2) side length of square is sum(matchsticks) / 4 = 2\\n     *  (3) The length of array should be equal to or larger than 4\\n     *  (4) The maximum number should not be larger than n\\n     *  (5) Need a way to find 4 distinct set of integer whose sum equal to 2?\\n     *      sort in ascending order\\n     *      backtracking method?\\n     *\\n     *  matchsticks = [1, 1, 1, 3, 2],          impossible,\\n     *  matchsticks = [1, 1, 1, 1, 1, 1, 1, 1]  yes\\n     *\\n     */\\n     \\n    int sum = 0;\\n    \\n    /* Requires at least 4 matchsticks */\\n    if (matchsticksSize < 4) {\\n        return false;\\n    }"]]}
{"id": "832", "ref_c": [["int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101][601] = {0}", "int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101] = {0}"], ["int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101][601] = {0}", "int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101] = {0}"], ["int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101][601] = {0}", "int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101] = {0}"]]}
{"id": "833", "ref_c": ["\nstatic int cmp_int_asc(const int * const pCur, const int * const pBase){\n\treturn *pCur - *pBase;\n}\n\nint findRadius(\n\tconst int * const houses,\n\tconst int housesLen,\n\n\tint * const heaters,\n\tconst int heatersLen\n){\n\tassert(heatersLen >= 1);\n\n\tqsort(heaters, heatersLen, sizeof (int), &cmp_int_asc);\n\n\tint minRadius = 0;\n\tfor (int i = 0; i < housesLen; i += 1){\n\t\tint first = 0, nextOfLast = heatersLen;\n\t\twhile (first < nextOfLast){\n\t\t\tconst int mid = first + (nextOfLast - first) / 2;\n\n\t\t\tif (heaters[mid] < houses[i]){\n\t\t\t\tfirst = mid + 1;\n\t\t\t}else {\n\t\t\t\tnextOfLast = mid;\n\t\t\t}\n\t\t}\n\t\tassert(first == nextOfLast);\n\n\t\tint curMinRadius;\n\t\tif (heatersLen == nextOfLast){\n\t\t\tcurMinRadius = houses[i] - heaters[heatersLen - 1];\n\t\t}else if (0 == nextOfLast){\n\t\t\tcurMinRadius = heaters[0] - houses[i];\n\t\t}else {\n\t\t\tconst int\n\t\t\t\tleft = houses[i] - heaters[nextOfLast - 1],\n\t\t\t\tright = heaters[nextOfLast] - houses[i]\n\t\t\t;\n\t\t\tcurMinRadius = (left <= right)? left : right;\n\t\t}\n\n\t\tif (curMinRadius > minRadius){\n\t\t\tminRadius = curMinRadius;\n\t\t}\n\t}\n\treturn minRadius;\n}\n", "\nstatic int cmp_int_asc(const int * const pCur, const int * const pBase){\n\treturn *pCur - *pBase;\n}\n\nint findRadius(\n\tconst int * const houses,\n\tconst int housesLen,\n\n\tint * const heaters,\n\tconst int heatersLen\n){\n\tassert(heatersLen >= 1);\n\n\tqsort(heaters, heatersLen, sizeof (int), &cmp_int_asc);\n\n\tint minRadius = 0;\n\tfor (int i = 0; i < housesLen; i += 1){\n\t\tint first = 0, nextOfLast = heatersLen;\n\t\twhile (first < nextOfLast){\n\t\t\tconst int mid = first + (nextOfLast - first) / 2;\n\n\t\t\tif (heaters[mid] < houses[i]){\n\t\t\t\tfirst = mid + 1;\n\t\t\t}else {\n\t\t\t\tnextOfLast = mid;\n\t\t\t}\n\t\t}\n\t\tassert(first == nextOfLast);\n\n\t\tint curMinRadius;\n\t\tif (heatersLen == nextOfLast){\n\t\t\tcurMinRadius = houses[i] - heaters[heatersLen - 1];\n\t\t}else if (0 == nextOfLast){\n\t\t\tcurMinRadius = heaters[0] - houses[i];\n\t\t}else {\n\t\t\tconst int\n\t\t\t\tleft = houses[i] - heaters[nextOfLast - 1],\n\t\t\t\tright = heaters[nextOfLast] - houses[i]\n\t\t\t;\n\t\t\tcurMinRadius = (left <= right)? left : right;\n\t\t}\n\n\t\tif (curMinRadius > minRadius){\n\t\t\tminRadius = curMinRadius;\n\t\t}\n\t}\n\treturn minRadius;\n}\n", "\nstatic int cmp_int_asc(const int * const pCur, const int * const pBase){\n\treturn *pCur - *pBase;\n}\n\nint findRadius(\n\tconst int * const houses,\n\tconst int housesLen,\n\n\tint * const heaters,\n\tconst int heatersLen\n){\n\tassert(heatersLen >= 1);\n\n\tqsort(heaters, heatersLen, sizeof (int), &cmp_int_asc);\n\n\tint minRadius = 0;\n\tfor (int i = 0; i < housesLen; i += 1){\n\t\tint first = 0, nextOfLast = heatersLen;\n\t\twhile (first < nextOfLast){\n\t\t\tconst int mid = first + (nextOfLast - first) / 2;\n\n\t\t\tif (heaters[mid] < houses[i]){\n\t\t\t\tfirst = mid + 1;\n\t\t\t}else {\n\t\t\t\tnextOfLast = mid;\n\t\t\t}\n\t\t}\n\t\tassert(first == nextOfLast);\n\n\t\tint curMinRadius;\n\t\tif (heatersLen == nextOfLast){\n\t\t\tcurMinRadius = houses[i] - heaters[heatersLen - 1];\n\t\t}else if (0 == nextOfLast){\n\t\t\tcurMinRadius = heaters[0] - houses[i];\n\t\t}else {\n\t\t\tconst int\n\t\t\t\tleft = houses[i] - heaters[nextOfLast - 1],\n\t\t\t\tright = heaters[nextOfLast] - houses[i]\n\t\t\t;\n\t\t\tcurMinRadius = (left <= right)? left : right;\n\t\t}\n\n\t\tif (curMinRadius > minRadius){\n\t\t\tminRadius = curMinRadius;\n\t\t}\n\t}\n\treturn minRadius;\n}\n"]}
{"id": "834", "ref_c": [["int totalHammingDistance(int* nums, int numsSize){\\n    int *num;\\n    int result = 0, ones;\\n    for(int i=0; i < 32; i++){\\n        num = nums;\\n        ones = 0;\\n        while(num != nums + numsSize){\\n            if(*num & 1) ones++;\\n            *num >>= 1;\\n            num++;\\n        }"], ["int totalHammingDistance(int* nums, int numsSize){\\n    int *num;\\n    int result = 0, ones;\\n    for(int i=0; i < 32; i++){\\n        num = nums;\\n        ones = 0;\\n        while(num != nums + numsSize){\\n            if(*num & 1) ones++;\\n            *num >>= 1;\\n            num++;\\n        }"], ["int totalHammingDistance(int* nums, int numsSize){\\n    int *num;\\n    int result = 0, ones;\\n    for(int i=0; i < 32; i++){\\n        num = nums;\\n        ones = 0;\\n        while(num != nums + numsSize){\\n            if(*num & 1) ones++;\\n            *num >>= 1;\\n            num++;\\n        }"]]}
{"id": "836", "ref_c": [["int magicalString(int n){\\n    char *arr=calloc(n*4+2,sizeof(char));\\n    *(arr+0)=\\'1\\';\\n    *(arr+1)=*(arr+2)=\\'2\\';\\n    int ans=0;\\n    int t=0;\\n    int idx=2;\\n    int nn=2;\\n   while(n--){\\n       ans+=*(arr+t)==\\'1\\';\\n       t++;\\n        if(*(arr+idx)==\\'2\\')\\n        {\\n        \\n        *(arr+nn+1)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        \\n        *(arr+nn+2)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        idx++;\\n        nn+=2;\\n        }"], ["int magicalString(int n){\\n    char *arr=calloc(n*4+2,sizeof(char));\\n    *(arr+0)=\\'1\\';\\n    *(arr+1)=*(arr+2)=\\'2\\';\\n    int ans=0;\\n    int t=0;\\n    int idx=2;\\n    int nn=2;\\n   while(n--){\\n       ans+=*(arr+t)==\\'1\\';\\n       t++;\\n        if(*(arr+idx)==\\'2\\')\\n        {\\n        \\n        *(arr+nn+1)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        \\n        *(arr+nn+2)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        idx++;\\n        nn+=2;\\n        }"], ["int magicalString(int n){\\n    char *arr=calloc(n*4+2,sizeof(char));\\n    *(arr+0)=\\'1\\';\\n    *(arr+1)=*(arr+2)=\\'2\\';\\n    int ans=0;\\n    int t=0;\\n    int idx=2;\\n    int nn=2;\\n   while(n--){\\n       ans+=*(arr+t)==\\'1\\';\\n       t++;\\n        if(*(arr+idx)==\\'2\\')\\n        {\\n        \\n        *(arr+nn+1)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        \\n        *(arr+nn+2)=*(arr+nn)==\\'1\\'?\\'2\\':\\'1\\';\\n        idx++;\\n        nn+=2;\\n        }"]]}
{"id": "837", "ref_c": ["\nbool playGame(int score_p1, int score_p2, int* nums, int begin, int end, bool turn);\n\nbool predictTheWinner(int* nums, int numsSize) {\n    return playGame(0, 0, nums, 0, numsSize - 1, true);\n}\n\nbool playGame(int score_p1, int score_p2, int* nums, int begin, int end, bool turn) {\n    if (begin > end) {\n    // Base case: no more elements in the array\n        return score_p1 >= score_p2;\n    }\n\n    if (turn) {\n        // It's player 1's turn\n        return (playGame(score_p1 + nums[begin], score_p2, nums, begin + 1, end, !turn) ||\n                playGame(score_p1 + nums[end], score_p2, nums, begin, end - 1, !turn));\n    } else {\n        // It's player 2's turn\n        return (playGame(score_p1, score_p2 + nums[begin], nums, begin + 1, end, !turn) &&\n                playGame(score_p1, score_p2 + nums[end], nums, begin, end - 1, !turn));\n    }\n}\n", "\nbool playGame(int score_p1, int score_p2, int* nums, int begin, int end, bool turn);\n\nbool predictTheWinner(int* nums, int numsSize) {\n    return playGame(0, 0, nums, 0, numsSize - 1, true);\n}\n\nbool playGame(int score_p1, int score_p2, int* nums, int begin, int end, bool turn) {\n    if (begin > end) {\n    // Base case: no more elements in the array\n        return score_p1 >= score_p2;\n    }\n\n    if (turn) {\n        // It's player 1's turn\n        return (playGame(score_p1 + nums[begin], score_p2, nums, begin + 1, end, !turn) ||\n                playGame(score_p1 + nums[end], score_p2, nums, begin, end - 1, !turn));\n    } else {\n        // It's player 2's turn\n        return (playGame(score_p1, score_p2 + nums[begin], nums, begin + 1, end, !turn) &&\n                playGame(score_p1, score_p2 + nums[end], nums, begin, end - 1, !turn));\n    }\n}\n", "\nbool playGame(int score_p1, int score_p2, int* nums, int begin, int end, bool turn);\n\nbool predictTheWinner(int* nums, int numsSize) {\n    return playGame(0, 0, nums, 0, numsSize - 1, true);\n}\n\nbool playGame(int score_p1, int score_p2, int* nums, int begin, int end, bool turn) {\n    if (begin > end) {\n    // Base case: no more elements in the array\n        return score_p1 >= score_p2;\n    }\n\n    if (turn) {\n        // It's player 1's turn\n        return (playGame(score_p1 + nums[begin], score_p2, nums, begin + 1, end, !turn) ||\n                playGame(score_p1 + nums[end], score_p2, nums, begin, end - 1, !turn));\n    } else {\n        // It's player 2's turn\n        return (playGame(score_p1, score_p2 + nums[begin], nums, begin + 1, end, !turn) &&\n                playGame(score_p1, score_p2 + nums[end], nums, begin, end - 1, !turn));\n    }\n}\n"]}
{"id": "838", "ref_c": [["int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int** ans = (int**)calloc(32768, sizeof(int*));\\n    int* col = (int*)calloc(32768, sizeof(int));\\n    int* q = (int*)calloc(numsSize, sizeof(int));\\n    int ansIdx = 0;\\n    \\n    backtracking(nums, numsSize, ans, col, &ansIdx, q, 0, 0);   \\n    deleteAll(); /* need to free to avoid incorrect behavior when doing next test item */\\n    \\n    *returnSize = ansIdx;\\n    *returnColumnSizes = col;\\n    return ans;\\n}"], ["int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int** ans = (int**)calloc(32768, sizeof(int*));\\n    int* col = (int*)calloc(32768, sizeof(int));\\n    int* q = (int*)calloc(numsSize, sizeof(int));\\n    int ansIdx = 0;\\n    \\n    backtracking(nums, numsSize, ans, col, &ansIdx, q, 0, 0);   \\n    deleteAll(); /* need to free to avoid incorrect behavior when doing next test item */\\n    \\n    *returnSize = ansIdx;\\n    *returnColumnSizes = col;\\n    return ans;\\n}"], ["int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int** ans = (int**)calloc(32768, sizeof(int*));\\n    int* col = (int*)calloc(32768, sizeof(int));\\n    int* q = (int*)calloc(numsSize, sizeof(int));\\n    int ansIdx = 0;\\n    \\n    backtracking(nums, numsSize, ans, col, &ansIdx, q, 0, 0);   \\n    deleteAll(); /* need to free to avoid incorrect behavior when doing next test item */\\n    \\n    *returnSize = ansIdx;\\n    *returnColumnSizes = col;\\n    return ans;\\n}"]]}
{"id": "839", "ref_c": [["int findTargetSumWays(int* nums, int numsSize, int target){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     *  target\\n     */\\n     \\n    int **dp = (int **)malloc(sizeof(int *) * numsSize);\\n    int ans;\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * 2001);\\n        \\n        for (int j = 0; j < 2001; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int findTargetSumWays(int* nums, int numsSize, int target){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     *  target\\n     */\\n     \\n    int **dp = (int **)malloc(sizeof(int *) * numsSize);\\n    int ans;\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * 2001);\\n        \\n        for (int j = 0; j < 2001; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int findTargetSumWays(int* nums, int numsSize, int target){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     *  target\\n     */\\n     \\n    /*\\n     * Output:\\n     *  Return the number of different expressions that you can build\\n     */\\n\\n    return findSumWays(nums, numsSize, target, 0);\\n}"]]}
{"id": "841", "ref_c": [["int* findDiagonalOrder(int** mat, int matSize, int* matColSize, int* returnSize)\\n{\\n    //0,0||0,1||0,2 \\n    //1,0||1,1||1,2\\n    //2,0||2,1||2,2\\n    //even values of r+c go up and right [-1,+1]\\n    //end of even diagonals increment c or r when c is out of bounds\\n    //odd values of r+c go down and left [+1,-1]\\n    //end of odd diagonals increment r or c when r is out of bounds\\n    int rSize = matSize;\\n    int cSize = matColSize[0];\\n    int r = 0;//row index\\n    int c = 0;//column index\\n    *returnSize = rSize * cSize;\\n    int *ret = malloc(sizeof(int) * rSize * cSize);\\n    //fill return array\\n    for(int i = 0; i < *returnSize; i++)\\n    {   //add value\\n        ret[i] = mat[r][c];\\n        //in the case of an even diagonal\\n        if((r+c) % 2 == 0)\\n        {   //check to see if we can increment diagonal\\n            if(r - 1 >= 0 && c + 1 < cSize)\\n            {\\n                r--;\\n                c++;\\n            }"], ["int* findDiagonalOrder(int** mat, int matSize, int* matColSize, int* returnSize)\\n{\\n    //0,0||0,1||0,2 \\n    //1,0||1,1||1,2\\n    //2,0||2,1||2,2\\n    //even values of r+c go up and right [-1,+1]\\n    //end of even diagonals increment c or r when c is out of bounds\\n    //odd values of r+c go down and left [+1,-1]\\n    //end of odd diagonals increment r or c when r is out of bounds\\n    int rSize = matSize;\\n    int cSize = matColSize[0];\\n    int r = 0;//row index\\n    int c = 0;//column index\\n    *returnSize = rSize * cSize;\\n    int *ret = malloc(sizeof(int) * rSize * cSize);\\n    //fill return array\\n    for(int i = 0; i < *returnSize; i++)\\n    {   //add value\\n        ret[i] = mat[r][c];\\n        //in the case of an even diagonal\\n        if((r+c) % 2 == 0)\\n        {   //check to see if we can increment diagonal\\n            if(r - 1 >= 0 && c + 1 < cSize)\\n            {\\n                r--;\\n                c++;\\n            }"], ["int* findDiagonalOrder(int** mat, int matSize, int* matColSize, int* returnSize)\\n{\\n    //0,0||0,1||0,2 \\n    //1,0||1,1||1,2\\n    //2,0||2,1||2,2\\n    //even values of r+c go up and right [-1,+1]\\n    //end of even diagonals increment c or r when c is out of bounds\\n    //odd values of r+c go down and left [+1,-1]\\n    //end of odd diagonals increment r or c when r is out of bounds\\n    int rSize = matSize;\\n    int cSize = matColSize[0];\\n    int r = 0;//row index\\n    int c = 0;//column index\\n    *returnSize = rSize * cSize;\\n    int *ret = malloc(sizeof(int) * rSize * cSize);\\n    //fill return array\\n    for(int i = 0; i < *returnSize; i++)\\n    {   //add value\\n        ret[i] = mat[r][c];\\n        //in the case of an even diagonal\\n        if((r+c) % 2 == 0)\\n        {   //check to see if we can increment diagonal\\n            if(r - 1 >= 0 && c + 1 < cSize)\\n            {\\n                r--;\\n                c++;\\n            }"]]}
{"id": "842", "ref_c": [["int* nextGreaterElements(int* nums, int numsSize, int* returnSize) {\\n    int n = numsSize;\\n    int* result = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    struct Stack *s = (struct Stack*)malloc(sizeof(struct Stack));\\n    s->next = NULL;\\n    for(int i = 0; i < n; i++){\\n        result[i] = -1;\\n    }"], ["int* nextGreaterElements(int* nums, int numsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int *ans = (int *)malloc(sizeof(int) * numsSize);\\n    int val, idx;\\n\\n    stk_init();\\n\\n    *returnSize = numsSize;\\n\\n    /* Process original array */\\n    for (int i = 0; i < numsSize; i++) {\\n        if (stk_cnt() == 0) {\\n            stk_push(nums[i], i);\\n            ans[i] = -1;\\n        }"], ["int* nextGreaterElements(int* nums, int numsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int *ans = (int *)malloc(sizeof(int) * numsSize);\\n    int val, idx;\\n\\n    stk_init();\\n\\n    *returnSize = numsSize;\\n\\n    /* Process original array */\\n    for (int i = 0; i < numsSize; i++) {\\n        if (stk_cnt() == 0) {\\n            stk_push(nums[i], i);\\n            ans[i] = -1;\\n        }"]]}
{"id": "843", "ref_c": [["int* findFrequentTreeSum(struct TreeNode* root, int* returnSize){\\n\\n    int flag = 0, *array = NULL, fmax = 0, i = 0;\\n    ListNode *p = NULL, *head = NULL, *ptr = NULL, *new = NULL;\\n    head = AllSum(root,head);\\n    p = head;\\n    while(p != NULL){\\n        if(search(new,p->val) != 1){\\n            new = insert(new, p->val);\\n        }"], ["int* findFrequentTreeSum(struct TreeNode* root, int* returnSize)\\n{\\n    int no_of_nodes = count_nodes(root);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * no_of_nodes);\\n    int ret_arr_index = 0;\\n    \\n    int sum = tree_traversal(root, ret_arr, &ret_arr_index);\\n    \\n    //Sort the ret_arr using merge sort\\n    merge_sort(ret_arr, 0, ret_arr_index-1);\\n    int i=0;   \\n    \\n    int max = INT_MIN;\\n    int count = 0;\\n    int prev = ret_arr[0];\\n    for(i=0; i<ret_arr_index; )\\n    {\\n        if(prev == ret_arr[i])\\n        {\\n            i++;\\n            count++;\\n            \\n            if(count >= max)\\n                max = count;\\n        }"], ["int* findFrequentTreeSum(struct TreeNode* root, int* returnSize)\\n{\\n    int no_of_nodes = count_nodes(root);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * no_of_nodes);\\n    int ret_arr_index = 0;\\n    \\n    int sum = tree_traversal(root, ret_arr, &ret_arr_index);\\n    \\n    //Sort the ret_arr using merge sort\\n    merge_sort(ret_arr, 0, ret_arr_index-1);\\n    int i=0;   \\n    \\n    int max = INT_MIN;\\n    int count = 0;\\n    int prev = ret_arr[0];\\n    for(i=0; i<ret_arr_index; )\\n    {\\n        if(prev == ret_arr[i])\\n        {\\n            i++;\\n            count++;\\n            \\n            if(count >= max)\\n                max = count;\\n        }"]]}
{"id": "844", "ref_c": ["\nvoid find(struct TreeNode* root,int *maxdepth,int depth,int *val){\n    if(!root) return;\n    if(*maxdepth < depth){\n        *maxdepth=depth;\n        *val=root->val;\n    }\n    find(root->left,maxdepth,depth+1,val);\n    find(root->right,maxdepth,depth+1,val);\n}\n\nint findBottomLeftValue(struct TreeNode* root){\n    int maxdepth=-1;\n    int val=0;\n    find(root,&maxdepth,0,&val);\n    return val;\n}\n", "\nvoid find(struct TreeNode* root,int *maxdepth,int depth,int *val){\n    if(!root) return;\n    if(*maxdepth < depth){\n        *maxdepth=depth;\n        *val=root->val;\n    }\n    find(root->left,maxdepth,depth+1,val);\n    find(root->right,maxdepth,depth+1,val);\n}\n\nint findBottomLeftValue(struct TreeNode* root){\n    int maxdepth=-1;\n    int val=0;\n    find(root,&maxdepth,0,&val);\n    return val;\n}\n", "\nvoid find(struct TreeNode* root,int *maxdepth,int depth,int *val){\n    if(!root) return;\n    if(*maxdepth < depth){\n        *maxdepth=depth;\n        *val=root->val;\n    }\n    find(root->left,maxdepth,depth+1,val);\n    find(root->right,maxdepth,depth+1,val);\n}\n\nint findBottomLeftValue(struct TreeNode* root){\n    int maxdepth=-1;\n    int val=0;\n    find(root,&maxdepth,0,&val);\n    return val;\n}\n"]}
{"id": "845", "ref_c": [["int* largestValues(struct TreeNode* root, int* returnSize) {\\n    if (root == NULL) {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* largestValues(struct TreeNode* root, int* returnSize) {\\n    if (root == NULL) {\\n        *returnSize = 0;\\n        return NULL;\\n    }", "int* largestValues(struct TreeNode* root, int* returnSize) {\\n    ans = NULL;\\n    ansSize = 0;\\n    dfs(root, 0);\\n    *returnSize = ansSize;\\n    return ans;\\n}"], ["int* largestValues(struct TreeNode* root, int* returnSize){\\n    int* result = (int*)malloc(sizeof(int)*10000);\\n    *returnSize = 0;\\n    if(!root){\\n        return result;\\n    }"]]}
{"id": "846", "ref_c": [["int longestPalindromeSubseq(char * s){\\n    int sLen = strlen(s);\\n    memset(memo, -1, sizeof(memo));\\n\\n    return longSub(s, 0, sLen - 1);\\n}"], ["int longestPalindromeSubseq(char * s){\\n    int sLen = strlen(s);\\n    memset(memo, -1, sizeof(memo));\\n\\n    return longSub(s, 0, sLen - 1);\\n}"], ["int longestPalindromeSubseq(char * s){\\n    int sLen = strlen(s);\\n    memset(memo, -1, sizeof(memo));\\n\\n    return longSub(s, 0, sLen - 1);\\n}"]]}
{"id": "847", "ref_c": [["int change(int amount, int* coins, int coinsSize) {\\n        // 2D DP method\\n\\n        // Time complexity: O(n * amount)\\n        // Space complexity: O(n * amount)\\n        \\n        const int n = coinsSize;\\n        int** dp = (int**)calloc(n + 1, sizeof(int*));\\n        for (int i = 0; i < n + 1; i++) {\\n            dp[i] = (int*)calloc(amount + 1, sizeof(int));\\n        }", "int change(int amount, int* coins, int coinsSize) {\\n        // 1D DP method\\n\\n        // Time complexity: O(amount)\\n        // Space complexity: O(n * amount)\\n\\n        const int n = coinsSize;\\n        int* dp = (int*)calloc(amount + 1, sizeof(int));\\n        dp[0] = 1;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = coins[i]; j < amount + 1; j++) {\\n                dp[j] += dp[j - coins[i]];\\n            }"], ["int change(int amount, int* coins, int coinsSize){\\n int dp[amount + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0] = 1;\\n    for (int i = 0; i < coinsSize; i++) {\\n        for (int j = coins[i]; j <= amount; j++) {\\n            dp[j] += dp[j - coins[i]];\\n        }"], ["int change(int amount, int* coins, int coinsSize){\\n int dp[amount + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0] = 1;\\n    for (int i = 0; i < coinsSize; i++) {\\n        for (int j = coins[i]; j <= amount; j++) {\\n            dp[j] += dp[j - coins[i]];\\n        }"]]}
{"id": "849", "ref_c": [["int findLUSlength(char ** strs, int strsSize){\\n    int result = -1;\\n    for(int i=0; i<strsSize; i++)\\n    {\\n        int count = 0;\\n        for(int j=0; j<strsSize; j++)\\n        {\\n            if(j == i) continue;\\n            if(isSub(strs[i],strs[j]))\\n                count++;\\n        }"], ["int findLUSlength(char ** strs, int strsSize){\\n    int result = -1;\\n    for(int i=0; i<strsSize; i++)\\n    {\\n        int count = 0;\\n        for(int j=0; j<strsSize; j++)\\n        {\\n            if(j == i) continue;\\n            if(isSub(strs[i],strs[j]))\\n                count++;\\n        }"], ["int findLUSlength(char ** strs, int strsSize){\\n    int result = -1;\\n    for(int i=0; i<strsSize; i++)\\n    {\\n        int count = 0;\\n        for(int j=0; j<strsSize; j++)\\n        {\\n            if(j == i) continue;\\n            if(isSub(strs[i],strs[j]))\\n                count++;\\n        }"]]}
{"id": "850", "ref_c": [["bool checkSubarraySum(int* nums, int numsSize, int k){\\n    if (numsSize == 1) return false;\\n    else if (k == 1) return true;\\n    \\n    bool *map = calloc(k, sizeof(bool)); \\n    // using bool-type would save u some memory\\n    int sum = 0;    \\n\\n    for(int i = 0; i < numsSize; i++){\\n        if (nums[i] % k == 0){  \\n            // return true if encounter at least two conterminous k\\'s multiple\\n            // else we do not do any hashing\\n            if (i < numsSize-1 && nums[i+1] % k == 0) return true;\\n            else continue;\\n        }"], ["bool checkSubarraySum(int* nums, int numsSize, int k){\\n    struct hashTable *map = NULL;\\n    struct hashTable *first;\\n    first = (struct hashTable *)malloc(sizeof(struct hashTable));\\n    nums[0] %= k;\\n    first->key   = nums[0];\\n    first->value = 0;\\n    HASH_ADD_INT(map, key, first);  \\n\\n    for(int i = 1; i < numsSize; i++){\\n        struct hashTable *temp;\\n        nums[i] = (nums[i] + nums[i-1]) % k;\\n        if(nums[i] == 0){\\n            return true;\\n        }"], ["bool checkSubarraySum(int* nums, int numsSize, int k){\\n    struct hashTable *map = NULL;\\n    struct hashTable *first;\\n    first = (struct hashTable *)malloc(sizeof(struct hashTable));\\n    nums[0] %= k;\\n    first->key   = nums[0];\\n    first->value = 0;\\n    HASH_ADD_INT(map, key, first);  \\n\\n    for(int i = 1; i < numsSize; i++){\\n        struct hashTable *temp;\\n        nums[i] = (nums[i] + nums[i-1]) % k;\\n        if(nums[i] == 0){\\n            return true;\\n        }"]]}
{"id": "851", "ref_c": [["char * findLongestWord(char * s, char ** dictionary, int dictionarySize){\\n    \\n    int len = strlen(s);\\n    int i;\\n    int p,q;\\n    int max = INT_MIN;\\n    char *res = (char *)malloc(sizeof(char) * (len+1));\\n    memset(res,0,sizeof(char) * (len+1));\\n    for (i=0; i < dictionarySize; i++)\\n    {\\n        q=0;p=0;\\n        while (s[p] != NULL && dictionary[i][q] != NULL)\\n        {\\n            if (s[p] == dictionary[i][q])\\n            {\\n                p++;q++;\\n            }"], ["char * findLongestWord(char * s, char ** dictionary, int dictionarySize){\\n    \\n    int len = strlen(s);\\n    int i;\\n    int p,q;\\n    int max = INT_MIN;\\n    char *res = (char *)malloc(sizeof(char) * (len+1));\\n    memset(res,0,sizeof(char) * (len+1));\\n    for (i=0; i < dictionarySize; i++)\\n    {\\n        q=0;p=0;\\n        while (s[p] != NULL && dictionary[i][q] != NULL)\\n        {\\n            if (s[p] == dictionary[i][q])\\n            {\\n                p++;q++;\\n            }"], ["char * findLongestWord(char * s, char ** dictionary, int dictionarySize){\\n    \\n    int len = strlen(s);\\n    int i;\\n    int p,q;\\n    int max = INT_MIN;\\n    char *res = (char *)malloc(sizeof(char) * (len+1));\\n    memset(res,0,sizeof(char) * (len+1));\\n    for (i=0; i < dictionarySize; i++)\\n    {\\n        q=0;p=0;\\n        while (s[p] != NULL && dictionary[i][q] != NULL)\\n        {\\n            if (s[p] == dictionary[i][q])\\n            {\\n                p++;q++;\\n            }"]]}
{"id": "852", "ref_c": [["int findMaxLength(int* nums, int numsSize) {\\n    int ret = 0;\\n    int count = 0;\\n    int arr[numsSize * 2 + 1];\\n    for (int i = 0; i < numsSize * 2 + 1; i++)\\n        arr[i] = -2;\\n    arr[numsSize] = -1;\\n    for (int i = 0; i < numsSize; i++) {\\n        count += nums[i] == 0 ? -1 : 1;\\n        if (arr[count + numsSize] >= -1) {\\n            if (ret < (i - arr[count + numsSize]))\\n                ret = i - arr[count + numsSize];\\n        }"], ["int findMaxLength(int* nums, int numsSize) {\\n    HashTable* table = create_hash_table();\\n\\n    int max_length = 0;\\n    int sum = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        sum += (nums[i] == 0 ? -1 : 1);\\n        int index = sum + numsSize;\\n\\n        if (sum == 0) {\\n            max_length = i + 1;\\n        }"], ["int findMaxLength(int* nums, int numsSize) {\\n    HashTable* table = create_hash_table();\\n\\n    int max_length = 0;\\n    int sum = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        sum += (nums[i] == 0 ? -1 : 1);\\n        int index = sum + numsSize;\\n\\n        if (sum == 0) {\\n            max_length = i + 1;\\n        }"]]}
{"id": "853", "ref_c": [["int countArrangement(int n) {\\n        vector<int> used(n+1, 0);\\n\\n        dfs(n, n, used);\\n        return ans;\\n    }"], ["int countArrangement(int n) {\\n        vector<int> used(n+1, 0);\\n\\n        dfs(n, n, used);\\n        return ans;\\n    }"], ["int countArrangement(int n)\\n    {\\n        if(n < 4)\\n        {\\n            return n;\\n        }"]]}
{"id": "855", "ref_c": [["char** updateBoard(char** board, int boardSize, int* boardColSize, int* click, int clickSize, int* returnSize, int** returnColumnSizes){\\n    int x = click[0], y = click[1];\\n    \\n    // validate the click cell\\n    if(board[x][y] == \\'M\\') \\n        board[x][y] = \\'X\\';\\n    else \\n        dfs(board, boardSize, *boardColSize, x, y);\\n    \\n    // set the result board\\'s row and cols sizes\\n    *returnSize = boardSize;\\n    *returnColumnSizes = calloc(sizeof(int), boardSize);\\n    for(int i = 0; i < boardSize; i++) \\n        (*returnColumnSizes)[i] = boardColSize[i];\\n    \\n    return board;\\n}"], ["char** updateBoard(char** board, int boardSize, int* boardColSize, int* click, int clickSize, int* returnSize, int** returnColumnSizes){\\n    int x = click[0], y = click[1];\\n    \\n    // validate the click cell\\n    if(board[x][y] == \\'M\\') \\n        board[x][y] = \\'X\\';\\n    else \\n        dfs(board, boardSize, *boardColSize, x, y);\\n    \\n    // set the result board\\'s row and cols sizes\\n    *returnSize = boardSize;\\n    *returnColumnSizes = calloc(sizeof(int), boardSize);\\n    for(int i = 0; i < boardSize; i++) \\n        (*returnColumnSizes)[i] = boardColSize[i];\\n    \\n    return board;\\n}"], ["char** updateBoard(char** board, int boardSize, int* boardColSize, int* click, int clickSize, int* returnSize, int** returnColumnSizes){\\n    int x = click[0], y = click[1];\\n    \\n    // validate the click cell\\n    if(board[x][y] == \\'M\\') \\n        board[x][y] = \\'X\\';\\n    else \\n        dfs(board, boardSize, *boardColSize, x, y);\\n    \\n    // set the result board\\'s row and cols sizes\\n    *returnSize = boardSize;\\n    *returnColumnSizes = calloc(sizeof(int), boardSize);\\n    for(int i = 0; i < boardSize; i++) \\n        (*returnColumnSizes)[i] = boardColSize[i];\\n    \\n    return board;\\n}"]]}
{"id": "856", "ref_c": [["int findPairs(int* nums, int numsSize, int k){\\n    qsort(nums,numsSize,sizeof(int),func);\\n    int i = 0, result = 0;\\n    while(i < numsSize){\\n        while(i < numsSize - 1 && nums[i] == nums[i + 1]){\\n            i++;\\n        }"], ["int findPairs(int* nums, int numsSize, int k){\\n    qsort(nums,numsSize,sizeof(int),func);\\n    int i = 0, result = 0;\\n    while(i < numsSize){\\n        while(i < numsSize - 1 && nums[i] == nums[i + 1]){\\n            i++;\\n        }"], ["int findPairs(int* nums, int numsSize, int k){\\n    qsort(nums,numsSize,sizeof(int),func);\\n    int i = 0, result = 0;\\n    while(i < numsSize){\\n        while(i < numsSize - 1 && nums[i] == nums[i + 1]){\\n            i++;\\n        }"]]}
{"id": "858", "ref_c": [["char * complexNumberMultiply(char * num1, char * num2){\\n    int a, b, x, y;\\n    a = b = x = y = 0;\\n    int i, k;\\n    int len1 = strlen(num1);\\n    int len2 = strlen(num2);\\n\\n    // extracting value from num1\\n    for (i = len1 - 2, k = 0; num1[i] != \\'+\\';i--)\\n    {\\n        if (num1[i] == \\'-\\')\\n        {\\n            b *= -1;\\n            continue;\\n        }"], ["char * complexNumberMultiply(char * num1, char * num2){\\n    int a, b, x, y;\\n    a = b = x = y = 0;\\n    int i, k;\\n    int len1 = strlen(num1);\\n    int len2 = strlen(num2);\\n\\n    // extracting value from num1\\n    for (i = len1 - 2, k = 0; num1[i] != \\'+\\';i--)\\n    {\\n        if (num1[i] == \\'-\\')\\n        {\\n            b *= -1;\\n            continue;\\n        }"], ["char * complexNumberMultiply(char * num1, char * num2){\\n    int a, b, x, y;\\n    a = b = x = y = 0;\\n    int i, k;\\n    int len1 = strlen(num1);\\n    int len2 = strlen(num2);\\n\\n    // extracting value from num1\\n    for (i = len1 - 2, k = 0; num1[i] != \\'+\\';i--)\\n    {\\n        if (num1[i] == \\'-\\')\\n        {\\n            b *= -1;\\n            continue;\\n        }"]]}
{"id": "859", "ref_c": [["struct TreeNode* convertBST(struct TreeNode* root){\\n    conv(root, 0);\\n\\n    return root;\\n}"], ["struct TreeNode* convertBST(struct TreeNode* root)\\n{\\n    int t=0;\\n    func(root, &t);\\n    return root;\\n}"], ["struct TreeNode* convertBST(struct TreeNode* root){\\n\\t\\tint sum = 0;\\n\\t\\t\\n\\t\\tstruct TreeNode* sol(struct TreeNode* root){\\n\\t\\t\\tif ( root ){\\n\\t\\t\\t\\tsol(root->right);\\n\\t\\t\\t\\tsum = root->val += sum;\\n\\t\\t\\t\\tsol(root->left);\\n\\t\\t\\t}"]]}
{"id": "860", "ref_c": ["\nint findMinDifference(char ** timePoints, int timePointsSize){\n\n    int i=0,j=0;\n    int diff=0;\n    int Min_Time_Diff=721;\n    int minut1=0,minut2=0;\n\n    for(i=0;i<timePointsSize-1;i++)\n    {\n        for(j=i+1;j<timePointsSize;j++)\n        {\n            minut1 = ((*(*(timePoints+i))-'0')*10+(*(*(timePoints+i)+1)-'0'))*60+((*(*(timePoints+i)+3)-'0')*10+(*(*(timePoints+i)+4)-'0'));\n            minut2 = ((*(*(timePoints+j))-'0')*10+(*(*(timePoints+j)+1)-'0'))*60+((*(*(timePoints+j)+3)-'0')*10+(*(*(timePoints+j)+4)-'0'));\n\n            diff = minut1>minut2?minut1-minut2:minut2-minut1;\n            \n            if(diff>720)\n            {\n                diff = (1440-diff);\n            }\n\n            if(diff<Min_Time_Diff)\n            {\n                Min_Time_Diff = diff;\n            }\n\n            if(Min_Time_Diff == 0)\n            return Min_Time_Diff;\n        }\n    }\n\n    return Min_Time_Diff;\n}\n", "\nint findMinDifference(char ** timePoints, int timePointsSize){\n\n    int i=0,j=0;\n    int diff=0;\n    int Min_Time_Diff=721;\n    int minut1=0,minut2=0;\n\n    for(i=0;i<timePointsSize-1;i++)\n    {\n        for(j=i+1;j<timePointsSize;j++)\n        {\n            minut1 = ((*(*(timePoints+i))-'0')*10+(*(*(timePoints+i)+1)-'0'))*60+((*(*(timePoints+i)+3)-'0')*10+(*(*(timePoints+i)+4)-'0'));\n            minut2 = ((*(*(timePoints+j))-'0')*10+(*(*(timePoints+j)+1)-'0'))*60+((*(*(timePoints+j)+3)-'0')*10+(*(*(timePoints+j)+4)-'0'));\n\n            diff = minut1>minut2?minut1-minut2:minut2-minut1;\n            \n            if(diff>720)\n            {\n                diff = (1440-diff);\n            }\n\n            if(diff<Min_Time_Diff)\n            {\n                Min_Time_Diff = diff;\n            }\n\n            if(Min_Time_Diff == 0)\n            return Min_Time_Diff;\n        }\n    }\n\n    return Min_Time_Diff;\n}\n", "\nint findMinDifference(char ** timePoints, int timePointsSize){\n\n    int i=0,j=0;\n    int diff=0;\n    int Min_Time_Diff=721;\n    int minut1=0,minut2=0;\n\n    for(i=0;i<timePointsSize-1;i++)\n    {\n        for(j=i+1;j<timePointsSize;j++)\n        {\n            minut1 = ((*(*(timePoints+i))-'0')*10+(*(*(timePoints+i)+1)-'0'))*60+((*(*(timePoints+i)+3)-'0')*10+(*(*(timePoints+i)+4)-'0'));\n            minut2 = ((*(*(timePoints+j))-'0')*10+(*(*(timePoints+j)+1)-'0'))*60+((*(*(timePoints+j)+3)-'0')*10+(*(*(timePoints+j)+4)-'0'));\n\n            diff = minut1>minut2?minut1-minut2:minut2-minut1;\n            \n            if(diff>720)\n            {\n                diff = (1440-diff);\n            }\n\n            if(diff<Min_Time_Diff)\n            {\n                Min_Time_Diff = diff;\n            }\n\n            if(Min_Time_Diff == 0)\n            return Min_Time_Diff;\n        }\n    }\n\n    return Min_Time_Diff;\n}\n"]}
{"id": "861", "ref_c": [["int singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize == 1) {\\n        return nums[0];\\n    }"], ["int singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize == 1) {\\n        return nums[0];\\n    }"], ["int singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize == 1) {\\n        return nums[0];\\n    }"]]}
{"id": "862", "ref_c": [["int** updateMatrix(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){\\n    /*\\n     * Input:\\n     *  **mat,\\n     *  matSize\\n     *  matColSize\\n     */\\n    \\n    //  0   0   0\\n    //  0   1   0\\n    //  0   0   0   \\n    //\\n    //\\n    // start from \"0\" cells\\n    // in each recursive function call\\n    //  (1) Get the x, y, and distance of cells\\n    //  (2) Reset the distance if cell equals 0\\n    //  (3) Store the x, y of adjacent element, and increase the distance\\n    //  (4) Enter next recursive function\\n    //  (5) Exit from recursive function when all the elements are visited\\n    //\\n    //  1   1   1       1   1   1       1   1   0       1   0   0       0   0   0\\n    //  1   1   1   =>  1   1   0   =>  1   0   0   =>  0   0   0   =>  0   0   0\\n    //  1   1   0       1   0   0       0   0   0       0   0   0       0   0   0\\n    //\\n\\n    int **ans = (int **)malloc(sizeof(int *) * matSize);\\n    bool **visited = (bool **)malloc(sizeof(bool *) * matSize);\\n\\n    *returnSize = matSize;\\n    *returnColumnSizes = (int *)malloc(sizeof(int) * matSize);\\n\\n    for (int i = 0; i < matSize; i++) {\\n        ans[i] = (int *)malloc(sizeof(int) * matColSize[0]);\\n        visited[i] = (bool *)calloc(1, sizeof(bool) * matColSize[0]);\\n        (*returnColumnSizes)[i] = matColSize[i];\\n    }"], ["int** updateMatrix(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = matSize;\\n    returnColumnSizes[0] = malloc(sizeof(int*) * matSize);\\n    int **distance = malloc(matSize * matColSize[0] * sizeof(int*));\\n    for (int i = 0; i < matSize; i++) {\\n        distance[i] = malloc(*matColSize * sizeof(int));\\n        returnColumnSizes[0][i] = *matColSize;\\n    }"], ["int** updateMatrix(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){\\n    /*\\n     * Input:\\n     *  **mat,\\n     *  matSize\\n     *  matColSize\\n     */\\n    \\n    //  0   0   0\\n    //  0   1   0\\n    //  0   0   0   \\n    //\\n    //\\n    // start from \"0\" cells\\n    // in each recursive function call\\n    //  (1) Get the x, y, and distance of cells\\n    //  (2) Reset the distance if cell equals 0\\n    //  (3) Store the x, y of adjacent element, and increase the distance\\n    //  (4) Enter next recursive function\\n    //  (5) Exit from recursive function when all the elements are visited\\n    //\\n    //  1   1   1       1   1   1       1   1   0       1   0   0       0   0   0\\n    //  1   1   1   =>  1   1   0   =>  1   0   0   =>  0   0   0   =>  0   0   0\\n    //  1   1   0       1   0   0       0   0   0       0   0   0       0   0   0\\n    //\\n\\n    int **ans = (int **)malloc(sizeof(int *) * matSize);\\n    bool **visited = (bool **)malloc(sizeof(bool *) * matSize);\\n\\n    *returnSize = matSize;\\n    *returnColumnSizes = (int *)malloc(sizeof(int) * matSize);\\n\\n    for (int i = 0; i < matSize; i++) {\\n        ans[i] = (int *)malloc(sizeof(int) * matColSize[0]);\\n        visited[i] = (bool *)calloc(1, sizeof(bool) * matColSize[0]);\\n        (*returnColumnSizes)[i] = matColSize[i];\\n    }"]]}
{"id": "863", "ref_c": [["int findCircleNum(int** isConnected, int isConnectedSize, int* isConnectedColSize){\\n    int counter = 0;\\n    \\n    for(int i = 0; i < isConnectedSize; i++) {\\n        if(isConnected[i][i] == 1 && isConnected[i] != 2) {\\n            search(isConnected, isConnectedColSize, i);\\n            counter++;\\n        }"], ["int findCircleNum(int** isConnected, int isConnectedSize, int* isConnectedColSize){\\n    int counter = 0;\\n    \\n    for(int i = 0; i < isConnectedSize; i++) {\\n        if(isConnected[i][i] == 1 && isConnected[i] != 2) {\\n            search(isConnected, isConnectedColSize, i);\\n            counter++;\\n        }"], ["int findCircleNum(int** isConnected, int isConnectedSize, int* isConnectedColSize) {\\n    int res = 0;\\n    int idx = 0;\\n    int queueSize = 0;\\n    int* visited = calloc(isConnectedSize, sizeof(int));\\n    int* queue = malloc(sizeof(int) * isConnectedSize * isConnectedSize);\\n\\n    for(int row = 0; row < isConnectedSize; row++) {\\n        if(*(visited + row)) {\\n            continue;\\n        }"]]}
{"id": "865", "ref_c": [["char * optimalDivision(int* nums, int numsSize){\\n    result = malloc(sizeof(char) * MAX);\\n    if(numsSize == 1){\\n        int i = 0;\\n        while(nums[0]){\\n            result[i] = (nums[0] % 10) + 48;\\n            nums[0] /= 10;\\n            i++;\\n        }"], ["char * optimalDivision(int* nums, int numsSize){\\n    result = malloc(sizeof(char) * MAX);\\n    if(numsSize == 1){\\n        int i = 0;\\n        while(nums[0]){\\n            result[i] = (nums[0] % 10) + 48;\\n            nums[0] /= 10;\\n            i++;\\n        }"], ["char * optimalDivision(int* nums, int numsSize){\\n    result = malloc(sizeof(char) * MAX);\\n    if(numsSize == 1){\\n        int i = 0;\\n        while(nums[0]){\\n            result[i] = (nums[0] % 10) + 48;\\n            nums[0] /= 10;\\n            i++;\\n        }"]]}
{"id": "866", "ref_c": ["\nint leastBricks(vector<vector<int>>& wall) {\n        unordered_map<int,int> mp;\n        int result=0;\n        for(int i=0; i<wall.size();i++){\n            int sum=0;\n            for(int j=0; j<wall[i].size()-1;j++){\n             sum+=wall[i][j];\n             mp[sum]++;\n\n            }\n        }\n        \n        for(auto i:mp){\n          if(i.second>result){\n              result=i.second;\n          }\n        }\n        return wall.size()-result;\n    }\n", "\nint leastBricks(vector<vector<int>>& wall) {\n        unordered_map<int,int> mp;\n        int result=0;\n        for(int i=0; i<wall.size();i++){\n            int sum=0;\n            for(int j=0; j<wall[i].size()-1;j++){\n             sum+=wall[i][j];\n             mp[sum]++;\n\n            }\n        }\n        \n        for(auto i:mp){\n          if(i.second>result){\n              result=i.second;\n          }\n        }\n        return wall.size()-result;\n    }\n", "\nint leastBricks(vector<vector<int>>& wall) {\n        unordered_map<int,int> mp;\n        int result=0;\n        for(int i=0; i<wall.size();i++){\n            int sum=0;\n            for(int j=0; j<wall[i].size()-1;j++){\n             sum+=wall[i][j];\n             mp[sum]++;\n\n            }\n        }\n        \n        for(auto i:mp){\n          if(i.second>result){\n              result=i.second;\n          }\n        }\n        return wall.size()-result;\n    }\n"]}
{"id": "867", "ref_c": [["int nextGreaterElement(int n){\\n\\n    /*\\n     * Input:\\n     *  n, integer \\n     */\\n\\n    int digits[16], buf[16], digitsSize = 0;\\n    bool selected[16] = {0}"], ["int nextGreaterElement(int n){\\n\\n    /*\\n     * Input:\\n     *  n, integer \\n     */\\n\\n    int digits[16], buf[16], digitsSize = 0;\\n    bool selected[16] = {0}"], ["int nextGreaterElement(int n){\\n\\n    /*\\n     * Input:\\n     *  n, integer \\n     */\\n\\n    int digits[16], buf[16], digitsSize = 0;\\n    bool selected[16] = {0}"]]}
{"id": "869", "ref_c": [["int subarraySum(int* nums, int numsSize, int k) {\\n    struct HashMap* hashMap = createHashMap();\\n    int sum = 0, count = 0;\\n\\n    insert(hashMap, 0, 1);\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        sum += nums[i];\\n        count += search(hashMap, sum - k);\\n        insert(hashMap, sum, search(hashMap, sum) + 1);\\n    }"], ["int subarraySum(int* nums, int numsSize, int k) {\\nint sum = 0;\\nadd(hash,0); \\nint count = 0;\\nfor (int i = 0; i < numsSize; ++i) {\\nsum += nums[i];\\nint comp = sum - k;\\nHASH_FIND_INT(hash,&comp,elem);\\nif (elem != NULL) {\\ncount += elem->val;\\n}"], ["int subarraySum(int* nums, int numsSize, int k){\\n    int i, count, currentCount;\\n    Node *hashTable[10007] = {NULL}"]]}
{"id": "870", "ref_c": [["int arrayNesting(int* nums, int numsSize){\\n    int max = 0;\\n    int counter = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        if(nums[i] != -1)\\n        {\\n            int j = nums[i]; \\n            counter = 0;\\n            while(j != i)\\n            {\\n                counter++;\\n                int temp = nums[j];\\n                nums[j] = -1;\\n                j = temp;\\n            }"], ["int arrayNesting(int* nums, int numsSize){\\n    int max = 0;\\n    int counter = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        if(nums[i] != -1)\\n        {\\n            int j = nums[i]; \\n            counter = 0;\\n            while(j != i)\\n            {\\n                counter++;\\n                int temp = nums[j];\\n                nums[j] = -1;\\n                j = temp;\\n            }"], ["int arrayNesting(int* nums, int numsSize){\\n    int max = 0;\\n    int counter = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        if(nums[i] != -1)\\n        {\\n            int j = nums[i]; \\n            counter = 0;\\n            while(j != i)\\n            {\\n                counter++;\\n                int temp = nums[j];\\n                nums[j] = -1;\\n                j = temp;\\n            }"]]}
{"id": "871", "ref_c": [["bool checkInclusion(char * s1, char * s2){\\n    int len1 = strlen(s1);\\n    int len2 = strlen(s2);\\n    if(len1 > len2) return false;\\n    int count[26] = {0}"], ["bool checkInclusion(char * s1, char * s2){\\n    int s1_[26]={[0 ... 25] = 0}"], ["bool checkInclusion(char * s1, char * s2){\\n    int len1 = strlen(s1);\\n    int len2 = strlen(s2);\\n    if(len1 > len2) return false;\\n    int count[26] = {0}"]]}
{"id": "873", "ref_c": [["int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\\n        vector<vector<vector<int>>>  dp(60,vector<vector<int>> (60,vector<int>(60,-1)));\\n        return solve(startRow,startColumn,m,n,maxMove,dp);\\n    }"], ["int findPaths(int m, int n, int maxMove, int startRow, int startColumn){\\n    mat = malloc(sizeof(int **)*m);\\n    for(int i = 0; i < m; i++){\\n        mat[i] = malloc(sizeof(int*)*n);\\n        for(int j = 0; j < n; j++){\\n            mat[i][j] = malloc(sizeof(int)*(maxMove + 1));\\n            for(int k = 0; k < maxMove + 1; k++){\\n                mat[i][j][k] = -1;\\n            }"], ["int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\\n        vector<vector<vector<int>>>  dp(60,vector<vector<int>> (60,vector<int>(60,-1)));\\n        return solve(startRow,startColumn,m,n,maxMove,dp);\\n    }"]]}
{"id": "874", "ref_c": [["int findUnsortedSubarray(int* nums, int numsSize){\\n    int r=0;\\n    int l=0;\\n    int mi = INT_MAX;\\n    int ma = INT_MIN;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        ma = fmax(ma, nums[i]);\\n        if (ma > nums[i]) {\\n            r = i;\\n        }"], ["int findUnsortedSubarray(int* nums, int numsSize){\\n    int r=0;\\n    int l=0;\\n    int mi = INT_MAX;\\n    int ma = INT_MIN;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        ma = fmax(ma, nums[i]);\\n        if (ma > nums[i]) {\\n            r = i;\\n        }"], ["int findUnsortedSubarray(int* nums, int numsSize){\\n    int r=0;\\n    int l=0;\\n    int mi = INT_MAX;\\n    int ma = INT_MIN;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        ma = fmax(ma, nums[i]);\\n        if (ma > nums[i]) {\\n            r = i;\\n        }"]]}
{"id": "875", "ref_c": [["int minDistance(char * word1, char * word2){\\n    int i, j, len1 = strlen(word1), len2 = strlen(word2);\\n\\n    int **dp = (int**)malloc(sizeof(int*) * (len1 + 1));\\n\\n    for (i = 0; i <= len1; i++) \\n        dp[i] = (int*)calloc(sizeof(int), (len2 + 1));\\n\\n    for (i = 1; i <= len1; i++) {\\n        for (j = 1; j <= len2; j++) {\\n            if (word1[i - 1] == word2[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] + 1;\\n            else {\\n                if (dp[i][j - 1] > dp[i - 1][j])\\n                    dp[i][j] = dp[i][j - 1];\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }"], ["int minDistance(char * word1, char * word2){\\n    int i, j, len1 = strlen(word1), len2 = strlen(word2);\\n\\n    int **dp = (int**)malloc(sizeof(int*) * (len1 + 1));\\n\\n    for (i = 0; i <= len1; i++) \\n        dp[i] = (int*)calloc(sizeof(int), (len2 + 1));\\n\\n    for (i = 1; i <= len1; i++) {\\n        for (j = 1; j <= len2; j++) {\\n            if (word1[i - 1] == word2[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] + 1;\\n            else {\\n                if (dp[i][j - 1] > dp[i - 1][j])\\n                    dp[i][j] = dp[i][j - 1];\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }"], ["int minDistance(char * word1, char * word2){\\n    int i, j, len1 = strlen(word1), len2 = strlen(word2);\\n\\n    int **dp = (int**)malloc(sizeof(int*) * (len1 + 1));\\n\\n    for (i = 0; i <= len1; i++) \\n        dp[i] = (int*)calloc(sizeof(int), (len2 + 1));\\n\\n    for (i = 1; i <= len1; i++) {\\n        for (j = 1; j <= len2; j++) {\\n            if (word1[i - 1] == word2[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] + 1;\\n            else {\\n                if (dp[i][j - 1] > dp[i - 1][j])\\n                    dp[i][j] = dp[i][j - 1];\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }"]]}
{"id": "877", "ref_c": ["\nstring fractionAddition(string expression) {\n        stringstream ss(expression);\n        char op;\n        int a,b,c,d;\n        int num,den;\n        ss>>a;ss>>op;ss>>b; //extracting the 1st 2 numbers\n        while(ss>>c) //til we have the number\n        {\n            ss>>op; // op is the operator. which is '/' in our case\n            ss>>d;\n            num= a*d + b*c;\n            den= b*d;\n            a= num/__gcd(abs(num),abs(den));\n            b= den/__gcd(abs(num),abs(den));\n        }\n        c=__gcd(abs(a),abs(b));\n        a=a/c;\n        b=b/c;\n        return to_string(a)+'/'+to_string(b);\n    }\n", "\nstring fractionAddition(string expression) {\n        stringstream ss(expression);\n        char op;\n        int a,b,c,d;\n        int num,den;\n        ss>>a;ss>>op;ss>>b; //extracting the 1st 2 numbers\n        while(ss>>c) //til we have the number\n        {\n            ss>>op; // op is the operator. which is '/' in our case\n            ss>>d;\n            num= a*d + b*c;\n            den= b*d;\n            a= num/__gcd(abs(num),abs(den));\n            b= den/__gcd(abs(num),abs(den));\n        }\n        c=__gcd(abs(a),abs(b));\n        a=a/c;\n        b=b/c;\n        return to_string(a)+'/'+to_string(b);\n    }\n", "\nstring fractionAddition(string expression) {\n        stringstream ss(expression);\n        char op;\n        int a,b,c,d;\n        int num,den;\n        ss>>a;ss>>op;ss>>b; //extracting the 1st 2 numbers\n        while(ss>>c) //til we have the number\n        {\n            ss>>op; // op is the operator. which is '/' in our case\n            ss>>d;\n            num= a*d + b*c;\n            den= b*d;\n            a= num/__gcd(abs(num),abs(den));\n            b= den/__gcd(abs(num),abs(den));\n        }\n        c=__gcd(abs(a),abs(b));\n        a=a/c;\n        b=b/c;\n        return to_string(a)+'/'+to_string(b);\n    }\n"]}
{"id": "878", "ref_c": ["\nbool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n        \n        // all 4 sides + 2 diagonal distance    \n        int d1= abs(p1[0]-p2[0])*abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])*abs(p1[1]-p2[1]);\n        int d2= abs(p1[0]-p3[0])*abs(p1[0]-p3[0]) + abs(p1[1]-p3[1])*abs(p1[1]-p3[1]);\n        int d3= abs(p1[0]-p4[0])*abs(p1[0]-p4[0]) + abs(p1[1]-p4[1])*abs(p1[1]-p4[1]);\n        int d4= abs(p2[0]-p3[0])*abs(p2[0]-p3[0]) + abs(p2[1]-p3[1])*abs(p2[1]-p3[1]);\n        int d5= abs(p2[0]-p4[0])*abs(p2[0]-p4[0]) + abs(p2[1]-p4[1])*abs(p2[1]-p4[1]);\n        int d6= abs(p3[0]-p4[0])*abs(p3[0]-p4[0]) + abs(p3[1]-p4[1])*abs(p3[1]-p4[1]);\n\n        vector<int>v;\n        v.push_back(d1);\n        v.push_back(d2);\n        v.push_back(d3);\n        v.push_back(d4);\n        v.push_back(d5);\n        v.push_back(d6);\n        //cout<<d1<<\" \"<<d2<<\" \"<<d3<<\" \"<<d4<<\" \"<<d5<<\" \"<<d6<<\" \";\n \n      sort(v.begin(),v.end());\n\n      // 4 sides have same distance && 2 diagonal have same distance && diagonal distance is greater than side distance \n      if((v[0]==v[1] && (v[2]==v[3] && v[3]==v[4] && v[4]==v[5] ) && v[0]>v[2])\n        ||(v[4]==v[5] && (v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) && v[4]>v[0]))\n      {\n          return true;\n      }\n\n\n         \n        return false;\n    }\n", "\nbool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n        \n        // all 4 sides + 2 diagonal distance    \n        int d1= abs(p1[0]-p2[0])*abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])*abs(p1[1]-p2[1]);\n        int d2= abs(p1[0]-p3[0])*abs(p1[0]-p3[0]) + abs(p1[1]-p3[1])*abs(p1[1]-p3[1]);\n        int d3= abs(p1[0]-p4[0])*abs(p1[0]-p4[0]) + abs(p1[1]-p4[1])*abs(p1[1]-p4[1]);\n        int d4= abs(p2[0]-p3[0])*abs(p2[0]-p3[0]) + abs(p2[1]-p3[1])*abs(p2[1]-p3[1]);\n        int d5= abs(p2[0]-p4[0])*abs(p2[0]-p4[0]) + abs(p2[1]-p4[1])*abs(p2[1]-p4[1]);\n        int d6= abs(p3[0]-p4[0])*abs(p3[0]-p4[0]) + abs(p3[1]-p4[1])*abs(p3[1]-p4[1]);\n\n        vector<int>v;\n        v.push_back(d1);\n        v.push_back(d2);\n        v.push_back(d3);\n        v.push_back(d4);\n        v.push_back(d5);\n        v.push_back(d6);\n        //cout<<d1<<\" \"<<d2<<\" \"<<d3<<\" \"<<d4<<\" \"<<d5<<\" \"<<d6<<\" \";\n \n      sort(v.begin(),v.end());\n\n      // 4 sides have same distance && 2 diagonal have same distance && diagonal distance is greater than side distance \n      if((v[0]==v[1] && (v[2]==v[3] && v[3]==v[4] && v[4]==v[5] ) && v[0]>v[2])\n        ||(v[4]==v[5] && (v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) && v[4]>v[0]))\n      {\n          return true;\n      }\n\n\n         \n        return false;\n    }\n", "\nbool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n        \n        // all 4 sides + 2 diagonal distance    \n        int d1= abs(p1[0]-p2[0])*abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])*abs(p1[1]-p2[1]);\n        int d2= abs(p1[0]-p3[0])*abs(p1[0]-p3[0]) + abs(p1[1]-p3[1])*abs(p1[1]-p3[1]);\n        int d3= abs(p1[0]-p4[0])*abs(p1[0]-p4[0]) + abs(p1[1]-p4[1])*abs(p1[1]-p4[1]);\n        int d4= abs(p2[0]-p3[0])*abs(p2[0]-p3[0]) + abs(p2[1]-p3[1])*abs(p2[1]-p3[1]);\n        int d5= abs(p2[0]-p4[0])*abs(p2[0]-p4[0]) + abs(p2[1]-p4[1])*abs(p2[1]-p4[1]);\n        int d6= abs(p3[0]-p4[0])*abs(p3[0]-p4[0]) + abs(p3[1]-p4[1])*abs(p3[1]-p4[1]);\n\n        vector<int>v;\n        v.push_back(d1);\n        v.push_back(d2);\n        v.push_back(d3);\n        v.push_back(d4);\n        v.push_back(d5);\n        v.push_back(d6);\n        //cout<<d1<<\" \"<<d2<<\" \"<<d3<<\" \"<<d4<<\" \"<<d5<<\" \"<<d6<<\" \";\n \n      sort(v.begin(),v.end());\n\n      // 4 sides have same distance && 2 diagonal have same distance && diagonal distance is greater than side distance \n      if((v[0]==v[1] && (v[2]==v[3] && v[3]==v[4] && v[4]==v[5] ) && v[0]>v[2])\n        ||(v[4]==v[5] && (v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) && v[4]>v[0]))\n      {\n          return true;\n      }\n\n\n         \n        return false;\n    }\n"]}
{"id": "881", "ref_c": [["char *** findDuplicate(char ** paths, int pathsSize, int* returnSize, int** returnColumnSizes){\\n\\tchar*** ret = NULL;\\n\\t*returnSize = 0;\\n\\t*returnColumnSizes = NULL;\\n\\n\\tstruct contents_hashtable* table = NULL;\\n\\n\\tstruct {\\n\\t\\tconst char* first;\\n\\t\\tconst char* last;\\n\\t}"], ["char *** findDuplicate(char ** paths, int pathsSize, int* returnSize, int** returnColumnSizes){\\n    char address[200];\\n    char name[100];\\n    \\n    struct list txt[21000];\\n    for (int i = 0 ; i < 21000 ; i++){\\n        txt[i].App_count = 0;\\n    }"], ["char *** findDuplicate(char ** paths, int pathsSize, int* returnSize, int** returnColumnSizes){\\n\\tchar*** ret = NULL;\\n\\t*returnSize = 0;\\n\\t*returnColumnSizes = NULL;\\n\\n\\tstruct contents_hashtable* table = NULL;\\n\\n\\tstruct {\\n\\t\\tconst char* first;\\n\\t\\tconst char* last;\\n\\t}"]]}
{"id": "882", "ref_c": [["int triangleNumber(int* nums, int numsSize){\\n    int left, middle, right;\\n    int combinations = 0;\\n    register int i, j;\\n\\n    mergeSort(nums, 0, numsSize - 1);\\n\\n    for (i = 0; i < numsSize - 2; i++)\\n        for (j = i + 1; j < numsSize - 1; j++) {\\n            left = j + 1;\\n            right = numsSize - 1;\\n\\n            while (left <= right) {\\n                middle = left + (right - left) / 2;\\n\\n                if (nums[i] + nums[j] <= nums[middle])\\n                    right = middle - 1;\\n                else\\n                    left = middle + 1;\\n            }"], ["int triangleNumber(int* nums, int numsSize){\\n    int *i = nums;\\n    int *j = nums +1;\\n    int *k = nums +2;\\n   \\n    int counter = 0;\\n    \\n    if(numsSize < 3)\\n        return 0;\\n    SortArray(nums, numsSize);\\n    while(i < nums + numsSize -2)\\n    { \\n        j = i +1;\\n        k = i +2;\\n        while(j < nums + numsSize -1 && *i!=0)\\n        {\\n                       \\n            while(k < nums + numsSize && *i + *j > *k)\\n            {\\n                k++;\\n                counter += k - j - 1;\\n            }"], ["int triangleNumber(int* nums, int numsSize){\\n    int *i = nums;\\n    int *j = nums +1;\\n    int *k = nums +2;\\n   \\n    int counter = 0;\\n    \\n    if(numsSize < 3)\\n        return 0;\\n    SortArray(nums, numsSize);\\n    while(i < nums + numsSize -2)\\n    { \\n        j = i +1;\\n        k = i +2;\\n        while(j < nums + numsSize -1 && *i!=0)\\n        {\\n                       \\n            while(k < nums + numsSize && *i + *j > *k)\\n            {\\n                k++;\\n                counter += k - j - 1;\\n            }"]]}
{"id": "883", "ref_c": ["\nint leastInterval(char* tasks, int tasksSize, int n){\n    int map[26]={0};\n    int highFreq = 0;\n\n    for (int i = 0 ; i < tasksSize ; i++)\n    {\n        map[tasks[i]-'A'] += 1;\n        highFreq = max(map[tasks[i]-'A'], highFreq) ;\n    }\n    \n    highFreq = highFreq-1;\n    int idleTask = highFreq*(n+1);\n    \n    for (int i = 0 ; i < 26 ; i++)\n    {\n        idleTask -= min(map[i], highFreq);\n    }\n    \n    return idleTask > 0 ? idleTask+tasksSize : tasksSize; \n}\n", "\nint leastInterval(char* tasks, int tasksSize, int n){\n    int map[26]={0};\n    int highFreq = 0;\n\n    for (int i = 0 ; i < tasksSize ; i++)\n    {\n        map[tasks[i]-'A'] += 1;\n        highFreq = max(map[tasks[i]-'A'], highFreq) ;\n    }\n    \n    highFreq = highFreq-1;\n    int idleTask = highFreq*(n+1);\n    \n    for (int i = 0 ; i < 26 ; i++)\n    {\n        idleTask -= min(map[i], highFreq);\n    }\n    \n    return idleTask > 0 ? idleTask+tasksSize : tasksSize; \n}\n", "\nint leastInterval(char* tasks, int tasksSize, int n){\n    int map[26]={0};\n    int highFreq = 0;\n\n    for (int i = 0 ; i < tasksSize ; i++)\n    {\n        map[tasks[i]-'A'] += 1;\n        highFreq = max(map[tasks[i]-'A'], highFreq) ;\n    }\n    \n    highFreq = highFreq-1;\n    int idleTask = highFreq*(n+1);\n    \n    for (int i = 0 ; i < 26 ; i++)\n    {\n        idleTask -= min(map[i], highFreq);\n    }\n    \n    return idleTask > 0 ? idleTask+tasksSize : tasksSize; \n}\n"]}
{"id": "885", "ref_c": [["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if(!root) return root;\\n    root = DFS(root, val, depth, 1, -1);/* -1:left node, 1: right node */\\n    return root;\\n}"], ["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if (depth == 1){ // case 1, add new root\\n        struct TreeNode* newRoot = malloc(sizeof(struct TreeNode));\\n        newRoot->val = val;\\n        newRoot->left = root;\\n        newRoot->right = NULL;\\n        return newRoot;\\n    }"], ["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if (depth == 1){ // case 1, add new root\\n        struct TreeNode* newRoot = malloc(sizeof(struct TreeNode));\\n        newRoot->val = val;\\n        newRoot->left = root;\\n        newRoot->right = NULL;\\n        return newRoot;\\n    }"]]}
{"id": "887", "ref_c": [["bool judgeSquareSum(int c){\\n\\n    long long temp = sqrt(c);\\n    if(temp*temp == c) return true;\\n\\t// These two lines check if number is perfect sq\\n\\t\\n    long long i = 1;\\n    while(i*i < c) {\\n            temp = c - i*i; // Decrementing 1,4,9,16,25... from number\\n            long long sq = sqrt(temp);\\n            if(sq*sq == temp) return true;\\n\\t\\t\\t// Above two line check if the remaining part is perfect sq or not\\n\\t\\t\\t\\n            i++; // If its not a perfect square we will incremenet number we have subtracted first and then again check if remaining part is perfect sq\\n        }", "bool judgeSquareSum(int c) {\\n\\t\\n        long long temp = sqrt(c);\\n        if(temp*temp == c) return true;\\n\\t\\t// These two lines check if number is perfect sq\\n\\t\\t\\n        long long i = 1;\\n        while(i*i < c) {\\n            temp = c - i*i; // Decrementing 1,4,9,16,25... from number\\n            long long sq = sqrt(temp);\\n            if(sq*sq == temp) return true;\\n\\t\\t\\t// Above two line check if the remaining part is perfect sq or not\\n\\t\\t\\t\\n            i++; // If its not a perfect square we will incremenet number we have subtracted first and then again check if remaining part is perfect sq\\n        }"], ["bool judgeSquareSum(int c) {\\n\\n    double r = 0;\\n    double s = 0;\\n    int e = sqrt(c);\\n    printf(\"%d\", e);\\n    while(s <= e)\\n    {\\n        r = s * s + e * e;\\n        if(r == c)\\n            return true;\\n        else if(r > c)\\n            e--;\\n        else\\n            s++;\\n    }"], ["bool judgeSquareSum(int c){\\n    for (long a = 0; a * a <= c; a++) {\\n        long b = c - a * a;\\n        double root_b = sqrt(b);\\n        if (root_b == (int)root_b) {\\n            return true;\\n        }"]]}
{"id": "888", "ref_c": ["\nvector<int> exclusiveTime(int n, vector<string>& logs) {\n        vector<int> ans(n);\n        stack<pair<int,int>> cur;\n        int prevTime = 0;\n        for (auto& s : logs){\n            int num = stoi(s.substr(0, s.find(':')));\n            int time = stoi(s.substr(s.rfind(':') + 1));\n            if (s.find('e') != -1){\n                ans[num] += time - prevTime + 1;\n                cur.pop();\n                prevTime = time + 1;\n            }\n            else{\n                if (!cur.empty()) ans[cur.top().first] += time - prevTime ;\n                cur.push({num, time});\n                prevTime = time;\n            }\n        }\n        return ans;\n    }\n", "\nvector<int> exclusiveTime(int n, vector<string>& logs) {\n        vector<int> ans(n);\n        stack<pair<int,int>> cur;\n        int prevTime = 0;\n        for (auto& s : logs){\n            int num = stoi(s.substr(0, s.find(':')));\n            int time = stoi(s.substr(s.rfind(':') + 1));\n            if (s.find('e') != -1){\n                ans[num] += time - prevTime + 1;\n                cur.pop();\n                prevTime = time + 1;\n            }\n            else{\n                if (!cur.empty()) ans[cur.top().first] += time - prevTime ;\n                cur.push({num, time});\n                prevTime = time;\n            }\n        }\n        return ans;\n    }\n", "\nvector<int> exclusiveTime(int n, vector<string>& logs) {\n        vector<int> ans(n);\n        stack<pair<int,int>> cur;\n        int prevTime = 0;\n        for (auto& s : logs){\n            int num = stoi(s.substr(0, s.find(':')));\n            int time = stoi(s.substr(s.rfind(':') + 1));\n            if (s.find('e') != -1){\n                ans[num] += time - prevTime + 1;\n                cur.pop();\n                prevTime = time + 1;\n            }\n            else{\n                if (!cur.empty()) ans[cur.top().first] += time - prevTime ;\n                cur.push({num, time});\n                prevTime = time;\n            }\n        }\n        return ans;\n    }\n"]}
{"id": "889", "ref_c": ["\nbool operator >= (const vector<int>& a, const vector<int>& b)\n{\n    for (int i = 0; i < a.size(); ++i)\n    {\n        if (a[i] < b[i]) return false;\n    }\n    return true;\n}\nint operator* (const vector<int>& a, const vector<int>& b)\n{\n    int res = 0;\n    for (int i = 0; i < a.size(); ++i)\n    {\n        res += a[i] * b[i];\n    }\n    return res;\n}\nvoid operator-= (vector<int>& a, vector<int>& b)\n{\n    for (int i = 0; i < a.size(); ++i)\n    {\n        a[i] -= b[i];\n    }\n}\nvoid operator += (vector<int>& a, vector<int>& b)\n{\n    for (int i = 0; i < a.size(); ++i)\n    {\n        a[i] += b[i];\n    }\n}\nclass Solution123 {\npublic:\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n        int cost = needs * price;\n        for (auto s : special)\n        {\n            if (cost < s.back()) continue;\n            if (needs > s)\n            {\n                needs -= s;\n                cost = min(cost, s.back() + shoppingOffers(price, special, needs));\n                needs += s;\n            }\n        }\n        return cost;\n    }\n};\nclass Solution {\npublic:\n    unordered_map<string, int> m;\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n        string s;\n        for (int i : needs)\n        {\n            s.append(1, i);\n        }\n        if (m.count(s)) \n            return m[s];\n\n        int cost = needs * price;\n\n        for (auto& spe : special) {\n            if (spe.back() > cost) continue;\n            if (needs >= spe) {\n                needs -= spe;\n                cost = min(cost, spe.back() + shoppingOffers(price, special, needs));\n                needs += spe;\n            }\n        }\n        m[s] = cost;\n        return cost;\n    }\n};\n", "\nbool operator >= (const vector<int>& a, const vector<int>& b)\n{\n    for (int i = 0; i < a.size(); ++i)\n    {\n        if (a[i] < b[i]) return false;\n    }\n    return true;\n}\nint operator* (const vector<int>& a, const vector<int>& b)\n{\n    int res = 0;\n    for (int i = 0; i < a.size(); ++i)\n    {\n        res += a[i] * b[i];\n    }\n    return res;\n}\nvoid operator-= (vector<int>& a, vector<int>& b)\n{\n    for (int i = 0; i < a.size(); ++i)\n    {\n        a[i] -= b[i];\n    }\n}\nvoid operator += (vector<int>& a, vector<int>& b)\n{\n    for (int i = 0; i < a.size(); ++i)\n    {\n        a[i] += b[i];\n    }\n}\nclass Solution123 {\npublic:\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n        int cost = needs * price;\n        for (auto s : special)\n        {\n            if (cost < s.back()) continue;\n            if (needs > s)\n            {\n                needs -= s;\n                cost = min(cost, s.back() + shoppingOffers(price, special, needs));\n                needs += s;\n            }\n        }\n        return cost;\n    }\n};\nclass Solution {\npublic:\n    unordered_map<string, int> m;\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n        string s;\n        for (int i : needs)\n        {\n            s.append(1, i);\n        }\n        if (m.count(s)) \n            return m[s];\n\n        int cost = needs * price;\n\n        for (auto& spe : special) {\n            if (spe.back() > cost) continue;\n            if (needs >= spe) {\n                needs -= spe;\n                cost = min(cost, spe.back() + shoppingOffers(price, special, needs));\n                needs += spe;\n            }\n        }\n        m[s] = cost;\n        return cost;\n    }\n};\n", "\nbool operator >= (const vector<int>& a, const vector<int>& b)\n{\n    for (int i = 0; i < a.size(); ++i)\n    {\n        if (a[i] < b[i]) return false;\n    }\n    return true;\n}\nint operator* (const vector<int>& a, const vector<int>& b)\n{\n    int res = 0;\n    for (int i = 0; i < a.size(); ++i)\n    {\n        res += a[i] * b[i];\n    }\n    return res;\n}\nvoid operator-= (vector<int>& a, vector<int>& b)\n{\n    for (int i = 0; i < a.size(); ++i)\n    {\n        a[i] -= b[i];\n    }\n}\nvoid operator += (vector<int>& a, vector<int>& b)\n{\n    for (int i = 0; i < a.size(); ++i)\n    {\n        a[i] += b[i];\n    }\n}\nclass Solution123 {\npublic:\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n        int cost = needs * price;\n        for (auto s : special)\n        {\n            if (cost < s.back()) continue;\n            if (needs > s)\n            {\n                needs -= s;\n                cost = min(cost, s.back() + shoppingOffers(price, special, needs));\n                needs += s;\n            }\n        }\n        return cost;\n    }\n};\nclass Solution {\npublic:\n    unordered_map<string, int> m;\n    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {\n        string s;\n        for (int i : needs)\n        {\n            s.append(1, i);\n        }\n        if (m.count(s)) \n            return m[s];\n\n        int cost = needs * price;\n\n        for (auto& spe : special) {\n            if (spe.back() > cost) continue;\n            if (needs >= spe) {\n                needs -= spe;\n                cost = min(cost, spe.back() + shoppingOffers(price, special, needs));\n                needs += spe;\n            }\n        }\n        m[s] = cost;\n        return cost;\n    }\n};\n"]}
{"id": "890", "ref_c": [["char * solveEquation(char * equation){\\n    int tmp, lr, a, b, sign, calc;\\n    char *ret = (char *)malloc(sizeof(char) * 20);\\n\\n    lr = sign = 1;\\n    a = b = calc = tmp = 0;\\n\\n    while (*equation != \\'\\\\0\\') {\\n        if (*equation >= \\'0\\' && *equation <= \\'9\\') {\\n            tmp = tmp * 10 + *equation - \\'0\\';\\n            calc++;\\n        }"], ["char * solveEquation(char * equation){\\n  char *eq_left = equation;\\n  char *eq_right = strchr(equation, \\'=\\');\\n  eq_right[0] = \\'\\\\0\\';\\n  eq_right++;\\n  int constant = 0;\\n  int x_factor = 0;\\n  int prev_type = 0; /* 0: nothing; 1: x; 2: +; 3: -; 4: constant */\\n  int sign = 1;\\n  int num = 0;\\n  for (int i = 0; ; i++) {\\n    int c = eq_left[i];\\n    switch (c) {\\n      case \\'+\\': if (prev_type == 4) constant += sign*num;\\n      sign = 1; num = 0; prev_type = 2; break;\\n      case \\'-\\': if (prev_type == 4) constant += sign*num;\\n      sign = -1; num = 0; prev_type = 3; break;\\n      case \\'0\\': case \\'1\\': case \\'2\\': case \\'3\\': case \\'4\\': case \\'5\\': case \\'6\\': case \\'7\\':\\n      case \\'8\\': case \\'9\\':\\n      num *= 10; num += c - 0x30; prev_type = 4; break;\\n      case \\'x\\':\\n      switch (prev_type) {\\n        case 0: x_factor++; num = 0; break;\\n        case 2: x_factor++; num = 0; break;\\n        case 3: x_factor--; num = 0; break;\\n        case 4: x_factor += sign*num; num = 0; break;\\n      }"], ["char * solveEquation(char * equation){\\n    int xCoeff=0;//sum of coefficients of X\\n    int con=0;//sum of constants\\n    char loadNum=0;//store number as it\\'s built digit by digit\\n    bool add=1;//else sub\\n    for (short i=0;equation[i];i++){\\n        if (equation[i]==\\'=\\'){//move everything to right side of =\\n            con=-con+(add?-loadNum:loadNum);\\n            xCoeff=-xCoeff;\\n            loadNum=0;\\n            add=1;\\n        }"]]}
{"id": "892", "ref_c": [["int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\\n    /*Merge Sort*/\\n    merge(pairs,0,pairsSize-1);\\n\\n    /*Geedy*/\\n    /*index pevents pairs[i][0] from being between the range of previous nodes*/\\n    int ans=0,index=0;\\n    for(int i=0;i<pairsSize;i++){\\n        if(i==0){\\n            ans++;\\n        }"], ["int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\\n    /*Merge Sort*/\\n    merge(pairs,0,pairsSize-1);\\n\\n    /*Geedy*/\\n    /*index pevents pairs[i][0] from being between the range of previous nodes*/\\n    int ans=0,index=0;\\n    for(int i=0;i<pairsSize;i++){\\n        if(i==0){\\n            ans++;\\n        }"], ["int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\\n    /*Merge Sort*/\\n    merge(pairs,0,pairsSize-1);\\n\\n    /*Geedy*/\\n    /*index pevents pairs[i][0] from being between the range of previous nodes*/\\n    int ans=0,index=0;\\n    for(int i=0;i<pairsSize;i++){\\n        if(i==0){\\n            ans++;\\n        }"]]}
{"id": "893", "ref_c": [["int countSubstrings(char * s)\\n{\\n    int res = 0;\\n    int left = 0;\\n    int right = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++) {\\n        left = i;\\n        right = i;\\n        while (left >= 0 && right < len && s[left] == s[right]) {\\n            res++;\\n            left--;\\n            right++;\\n        }"], ["int countSubstrings(char * s)\\n{\\n    int res = 0;\\n    int left = 0;\\n    int right = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++) {\\n        left = i;\\n        right = i;\\n        while (left >= 0 && right < len && s[left] == s[right]) {\\n            res++;\\n            left--;\\n            right++;\\n        }"], ["int countSubstrings(char * s)\\n{\\n    int res = 0;\\n    int left = 0;\\n    int right = 0;\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++) {\\n        left = i;\\n        right = i;\\n        while (left >= 0 && right < len && s[left] == s[right]) {\\n            res++;\\n            left--;\\n            right++;\\n        }"]]}
{"id": "894", "ref_c": [["char * replaceWords(char ** dictionary, int dictionarySize, char * sentence){\\n    struct Trie* t = create();\\n    insert(dictionary, dictionarySize, t);\\n    \\n    int idx = 0, len = strlen(sentence), ansIdx = 0;\\n    struct Trie* process = t;\\n    while(idx < len){\\n        if(sentence[idx] != \\' \\'){\\n            int currIdx = sentence[idx] - \\'a\\';\\n            if(process->next[currIdx] != NULL){\\n                sentence[ansIdx++] = sentence[idx++];\\n                process = process->next[currIdx];\\n                if(process->isLeaf){\\n                    /* update idx for next space or at the end of the string */\\n                    while(idx < len && sentence[idx] != \\' \\')\\n                        idx++;\\n                }"], ["char * replaceWords(char ** dictionary, int dictionarySize, char * sentence){\\n    struct Trie* t = create();\\n    insert(dictionary, dictionarySize, t);\\n    \\n    int idx = 0, len = strlen(sentence), ansIdx = 0;\\n    struct Trie* process = t;\\n    while(idx < len){\\n        if(sentence[idx] != \\' \\'){\\n            int currIdx = sentence[idx] - \\'a\\';\\n            if(process->next[currIdx] != NULL){\\n                sentence[ansIdx++] = sentence[idx++];\\n                process = process->next[currIdx];\\n                if(process->isLeaf){\\n                    /* update idx for next space or at the end of the string */\\n                    while(idx < len && sentence[idx] != \\' \\')\\n                        idx++;\\n                }"], ["char * replaceWords(char ** dictionary, int dictionarySize, char * sentence){\\n    struct Trie* t = create();\\n    insert(dictionary, dictionarySize, t);\\n    \\n    int idx = 0, len = strlen(sentence), ansIdx = 0;\\n    struct Trie* process = t;\\n    while(idx < len){\\n        if(sentence[idx] != \\' \\'){\\n            int currIdx = sentence[idx] - \\'a\\';\\n            if(process->next[currIdx] != NULL){\\n                sentence[ansIdx++] = sentence[idx++];\\n                process = process->next[currIdx];\\n                if(process->isLeaf){\\n                    /* update idx for next space or at the end of the string */\\n                    while(idx < len && sentence[idx] != \\' \\')\\n                        idx++;\\n                }"]]}
{"id": "895", "ref_c": [["char * predictPartyVictory(char * senate){\\n    int dCount=0, rCount=0, dBan = 0, rBan = 0;\\n    int l , head = 0, tail, i;\\n    char c;\\n    for (i = 0; senate[i] != \\'\\\\0\\'; ++i) {\\n        if (senate[i] == \\'D\\') {\\n            ++dCount;\\n        }"], ["char * predictPartyVictory(char * senate){\\n    int dCount=0, rCount=0, dBan = 0, rBan = 0;\\n    int l , head = 0, tail, i;\\n    char c;\\n    for (i = 0; senate[i] != \\'\\\\0\\'; ++i) {\\n        if (senate[i] == \\'D\\') {\\n            ++dCount;\\n        }"], ["char * predictPartyVictory(char * senate){\\n\\n    /* \\n     * Input:\\n     *  senate, string\\n     */\\n\\n    static char winner[2][8] = {\"Radiant\", \"Dire\"}"]]}
{"id": "896", "ref_c": [["int minSteps(int n){\\n  int dp[n + 1], j;\\n  dp[1] = 0;\\n\\n  for(int i = 2; i <= n; i++){\\n    for(j = 2; j <= i; j++){\\n      if(i % j == 0){\\n        dp[i] = j + dp[i / j];\\n        break;\\n      }"], ["int minSteps(int n){\\n  int dp[n + 1], j;\\n  dp[1] = 0;\\n\\n  for(int i = 2; i <= n; i++){\\n    for(j = 2; j <= i; j++){\\n      if(i % j == 0){\\n        dp[i] = j + dp[i / j];\\n        break;\\n      }"], ["int minSteps(int n) {\\n        int countsteps=0,temp=n,temp2,temp3,check=0;\\n        if(n==1)\\n            return 0;\\n        while(n!=1)\\n        {\\n            int k=n;\\n            if(n%2==0&&check==0)\\n            {countsteps+=2;\\n             temp2=n/2;\\n             n/=2;}"]]}
{"id": "897", "ref_c": [["struct TreeNode** findDuplicateSubtrees(struct TreeNode* root, int* returnSize){\\n  struct tree_node_hash* table = NULL;\\n  int next_id = 0;\\n  get_subtree_id(root, &table, &next_id);\\n  *returnSize = 0;\\n\\n  /* Count the number of subtrees that appear more than once */\\n  struct tree_node_hash* entry;\\n  struct tree_node_hash* tmp;\\n  HASH_ITER(hh, table, entry, tmp) {\\n    *returnSize += !!(entry->count);\\n  }"], ["struct TreeNode** findDuplicateSubtrees(struct TreeNode* root, int* returnSize) \\n{\\n  *returnSize = 0;\\n  struct TreeNode **result = (struct TreeNode **)calloc(MAX_MAPS, sizeof(struct TreeNode *));\\n  traverse(root, result, returnSize);\\n  freeMemory(result, returnSize);\\n  return result;\\n}"], ["struct TreeNode** findDuplicateSubtrees(struct TreeNode* root, int* returnSize) \\n{\\n  *returnSize = 0;\\n  struct TreeNode **result = (struct TreeNode **)calloc(MAX_MAPS, sizeof(struct TreeNode *));\\n  traverse(root, result, returnSize);\\n  freeMemory(result, returnSize);\\n  return result;\\n}"]]}
{"id": "898", "ref_c": [["struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize) {\\n    if (numsSize == 0) return NULL;\\n    int* max_num = &nums[0];    // pointer to maximum element\\n    for (int i = 0; i<numsSize; i++){\\n        if (nums[i] > *max_num){\\n            max_num = &nums[i];  // update pointer\\n        }"], ["struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize) {\\n    if (numsSize == 0) return NULL;\\n    int* max_num = &nums[0];    // pointer to maximum element\\n    for (int i = 0; i<numsSize; i++){\\n        if (nums[i] > *max_num){\\n            max_num = &nums[i];  // update pointer\\n        }"], ["struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize) {\\n    if (numsSize == 0) return NULL;\\n\\n    //Can optimize with Max Heap:\\n    int maxIndex = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[maxIndex] < nums[i])\\n            maxIndex = i;\\n    }"]]}
{"id": "899", "ref_c": [["int* nextGreaterElements(int* nums, int numsSize, int* returnSize) {\\n    int n = numsSize;\\n    int* result = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    struct Stack *s = (struct Stack*)malloc(sizeof(struct Stack));\\n    s->next = NULL;\\n    for(int i = 0; i < n; i++){\\n        result[i] = -1;\\n    }"], ["int* nextGreaterElements(int* nums, int numsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int *ans = (int *)malloc(sizeof(int) * numsSize);\\n    int val, idx;\\n\\n    stk_init();\\n\\n    *returnSize = numsSize;\\n\\n    /* Process original array */\\n    for (int i = 0; i < numsSize; i++) {\\n        if (stk_cnt() == 0) {\\n            stk_push(nums[i], i);\\n            ans[i] = -1;\\n        }"], ["int* nextGreaterElements(int* nums, int numsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int *ans = (int *)malloc(sizeof(int) * numsSize);\\n    int val, idx;\\n\\n    stk_init();\\n\\n    *returnSize = numsSize;\\n\\n    /* Process original array */\\n    for (int i = 0; i < numsSize; i++) {\\n        if (stk_cnt() == 0) {\\n            stk_push(nums[i], i);\\n            ans[i] = -1;\\n        }"]]}
{"id": "900", "ref_c": [["int* findClosestElements(int* arr, int arrSize, int k, int x, int* returnSize) {\\n    *returnSize = k;\\n    int *result_arr = (int*)malloc(k * sizeof(int));\\n    int R = arrSize-1;\\n    int L = 0;\\n\\n    while ((R - L) >= k)\\n    {\\n        if(abs(x-arr[L]) <= abs(arr[R]-x))\\n            R--;\\n        else\\n            L++;\\n    }"], ["int* findClosestElements(int* arr, int arrSize, int k, int x, int* returnSize){\\n    int left = 0, right = arrSize - k;\\n    while (left < right){\\n        int mid = (left + right) / 2;\\n        if (x - arr[mid] > arr[mid + k] - x){\\n            left = mid + 1;\\n        }"], ["int* findClosestElements(int* arr, int arrSize, int k, int x, int* returnSize) {\\n    *returnSize = k;\\n    int *result_arr = (int*)malloc(k * sizeof(int));\\n    int R = arrSize-1;\\n    int L = 0;\\n\\n    while ((R - L) >= k)\\n    {\\n        if(abs(x-arr[L]) <= abs(arr[R]-x))\\n            R--;\\n        else\\n            L++;\\n    }"]]}
{"id": "901", "ref_c": [["bool isPossible(int* nums, int numsSize){\\n    int *counter = (int *)calloc(2004, sizeof(int));\\n    int *seq = (int *)calloc(2004, sizeof(int));\\n    \\n\\t// Count how many times a digit appears, offset by 1001 to make all indices positive\\n    for (int i=0; i<numsSize; i++) {\\n        counter[nums[i]+1001]++;\\n    }"], ["bool isPossible(int* nums, int numsSize){  //\\u512A\\u5148\\u586B\\u5165\\u7684\\u662F \\u5C0F\\u65BC3\\u7684 \\u5728\\u4F86\\u662F\\u9023\\u7E8C\\u7684 \\u90FD\\u6C92\\u6709\\u624D\\u9078\\u64C7\\u5275\\u9020\\u65B0\\u7684\\n    int last = nums[0];\\n    \\n    int subsequences[numsSize];\\n    subsequences[0] = 1;\\n    \\n    int r_point = 1;\\n    int uf_point = 0;\\n    int l_point = 0;\\n    int i = 1;\\n    \\n    \\n    while (i < numsSize && nums[i] == nums[i-1]){  //\\u770B\\u4E00\\u6A23\\u7684\\u6709\\u5E7E\\u500B\\n        subsequences[r_point] = 1;\\n        r_point++;\\n        i++;\\n    }"], ["bool isPossible(int* nums, int numsSize){\\n    int *counter = (int *)calloc(2004, sizeof(int));\\n    int *seq = (int *)calloc(2004, sizeof(int));\\n    \\n\\t// Count how many times a digit appears, offset by 1001 to make all indices positive\\n    for (int i=0; i<numsSize; i++) {\\n        counter[nums[i]+1001]++;\\n    }"]]}
{"id": "902", "ref_c": [["int widthOfBinaryTree(struct TreeNode* root){\\n    struct TreeNode** queue = malloc(3000 * sizeof(struct TreeNode*));\\n    uint64_t* idx = malloc(3000 * sizeof(long));\\n    int front = 0, rear = 0, start = 0, end = 0, max = 0;\\n    int width = 1, tmp = 1;\\n\\n    queue[rear] = malloc(sizeof(struct TreeNode));\\n    queue[rear] = root;\\n    idx[rear++] = 1;\\n\\n    while(width) {\\n        width = rear - front;\\n        start = (front == rear)? front - 1 : front;\\n        for(int i = 0; i < width; i++) {\\n            if(queue[front]->left) {\\n                queue[rear] = malloc(sizeof(struct TreeNode));\\n                queue[rear] = queue[front]->left;\\n                idx[rear++] = (idx[front]) * 2;\\n            }"], ["int widthOfBinaryTree(struct TreeNode* root){\\n    node*front = NULL;\\n    node*rear = NULL;\\n    if(!root)\\n        return 0;\\n    qpush(&front,&rear,0,root);\\n    int width = INT_MIN;\\n    while(!empty(front))\\n    {\\n        int c = count(front);\\n        int l;\\n        int r ;\\n        for(int i = 0 ; i < c ; i++)\\n        {\\n            node * cur = qpop(&front,&rear);\\n            if(i==0)\\n                l = cur->index;\\n            if(i == c-1 )\\n                r = cur->index;\\n            if(cur->data->left)\\n                qpush(&front,&rear,(cur->index)*2 + 1 , cur->data->left);\\n            if(cur->data->right)\\n                qpush(&front,&rear,(cur->index)*2 + 2 , cur->data->right);\\n        }"], ["int widthOfBinaryTree(struct TreeNode* root){\\n\\n    /* \\n     * Input:\\n     *  root, root of binary tree\\n     */\\n\\n    /* Reset leftmost index table */\\n    for (int i = 0; i < 3001; i++) {\\n        left[i] = UINT_MAX;\\n    }"]]}
{"id": "903", "ref_c": [["bool checkPossibility(int* nums, int numsSize){\\nint count=0;\\nfor(int i=1; i<numsSize; i++) {\\n    if(nums[i-1]>nums[i]) {\\n        count++;\\n        if(count>1) {\\n            return false;\\n        }"], ["bool checkPossibility(int* nums, int numsSize){\\n    \\n    int i;\\n    int count = 0;\\n    \\n    if(numsSize <= 2)\\n        return 1;\\n    \\n    for(i=1; i < numsSize; i++)\\n    {        \\n        if(nums[i-1] <= nums[i])\\n            continue;\\n        else\\n        {\\n            if((i-2 >= 0) && (nums[i-2] > nums[i]))\\n            {\\n                nums[i] = nums[i-1];\\n            }"], ["bool checkPossibility(int* nums, int numsSize){\\nint count=0;\\nfor(int i=1; i<numsSize; i++) {\\n    if(nums[i-1]>nums[i]) {\\n        count++;\\n        if(count>1) {\\n            return false;\\n        }"]]}
{"id": "904", "ref_c": [["int* constructArray(int n, int k, int* returnSize){\\n    int* set = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    \\n\\t/*\\n\\t * Start from 1 \\n\\t * a2 should equal a1 + k, the largest distance you need\\n\\t * back track to find the next largest distance (k - 1)\\n\\t * repeat the pattern until you construct k distinct distances\\n\\t */\\n    int i = 1;\\n    set[0] = 1;\\n    int mult = 1;\\n    int offset = (int)(k / 2.0) + 1;\\n    \\n    for(k; k > 0; k--){\\n        \\n        set[i] = set[i - 1] + k * mult;\\n        mult = -1 * mult;\\n        i++;\\n        \\n    }"], ["int* constructArray(int n, int k, int* returnSize){\\n    int* set = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    \\n\\t/*\\n\\t * Start from 1 \\n\\t * a2 should equal a1 + k, the largest distance you need\\n\\t * back track to find the next largest distance (k - 1)\\n\\t * repeat the pattern until you construct k distinct distances\\n\\t */\\n    int i = 1;\\n    set[0] = 1;\\n    int mult = 1;\\n    int offset = (int)(k / 2.0) + 1;\\n    \\n    for(k; k > 0; k--){\\n        \\n        set[i] = set[i - 1] + k * mult;\\n        mult = -1 * mult;\\n        i++;\\n        \\n    }"], ["int* constructArray(int n, int k, int* returnSize){\\n    int* set = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    \\n\\t/*\\n\\t * Start from 1 \\n\\t * a2 should equal a1 + k, the largest distance you need\\n\\t * back track to find the next largest distance (k - 1)\\n\\t * repeat the pattern until you construct k distinct distances\\n\\t */\\n    int i = 1;\\n    set[0] = 1;\\n    int mult = 1;\\n    int offset = (int)(k / 2.0) + 1;\\n    \\n    for(k; k > 0; k--){\\n        \\n        set[i] = set[i - 1] + k * mult;\\n        mult = -1 * mult;\\n        i++;\\n        \\n    }"]]}
{"id": "905", "ref_c": [["struct TreeNode* trimBST(struct TreeNode* root, int low, int high){\\n\\t\\tif ( ! root ) return root;\\n\\t\\tif ( root->val < low ) return trimBST(root->right, low, high);\\n\\t\\tif ( root->val > high ) return trimBST(root->left, low, high);\\n\\t\\troot->left = trimBST(root->left, low, high);\\n\\t\\troot->right = trimBST(root->right, low, high);\\n\\t\\treturn root;\\n\\t}"], ["struct TreeNode* trimBST(struct TreeNode* root, int low, int high){\\n\\t\\tif ( ! root ) return root;\\n\\t\\tif ( root->val < low ) return trimBST(root->right, low, high);\\n\\t\\tif ( root->val > high ) return trimBST(root->left, low, high);\\n\\t\\troot->left = trimBST(root->left, low, high);\\n\\t\\troot->right = trimBST(root->right, low, high);\\n\\t\\treturn root;\\n\\t}"], ["struct TreeNode* trimBST(struct TreeNode* root, int low, int high){\\n  return trim(root,low,high);\\n}"]]}
{"id": "906", "ref_c": [["int maximumSwap(int num){\\n    \\n    int number=num;\\n    int arr[9]={0}"], ["int maximumSwap(int num){\\n    \\n    int number=num;\\n    int arr[9]={0}"], ["int maximumSwap(int num){\\n    \\n    int number=num;\\n    int arr[9]={0}"]]}
{"id": "907", "ref_c": [["int flipLights(int n, int presses){\\n    int val = n >=3 ? 3 : n;\\n    if (presses == 0){\\n        return 1;\\n    }"], ["int flipLights(int n, int presses){\\n    int val = n >=3 ? 3 : n;\\n    if (presses == 0){\\n        return 1;\\n    }"], ["int flipLights(int n, int presses)\\n{\\n    if(presses==0)  {return 1;}"]]}
{"id": "908", "ref_c": [["int findNumberOfLIS(int* nums, int numsSize) {\\n    if (numsSize == 0) return 0;\\n\\n    int dp[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        dp[i] = 1;\\n    }"], ["int findNumberOfLIS(int* nums, int numsSize) {\\n    // DP method \\n\\n    // Time complexity: O(n^2)\\n    // Space comeplxity: O(n)\\n\\n    const int n = numsSize;\\n    int result = 0, maxlen = 0;\\n    int* length = (int*)calloc(n, sizeof(int));  // length[i] := LIS\\'s length ending with nums[i]\\n    int* counts = (int*)calloc(n, sizeof(int));  // counts[i] := number of the LIS ending with nums[i] \\n\\n    for (int i = 0; i < n; i++) {\\n        // initialize length and count arrays\\n        length[i] = 1;\\n        counts[i] = 1;\\n\\n        // calculate length and count arrays\\n        for (int j = 0; j < i; j++) {\\n            if (nums[i] <= nums[j]) continue;\\n\\n            if (length[i] == length[j] + 1) {\\n                counts[i] += counts[j];\\n            }"], ["int findNumberOfLIS(int* nums, int numsSize){\\n    int n = numsSize;\\n    int max_l = 0;\\n    int ret = 0;\\n    int *dp = NULL;\\n    int *count = NULL;\\n\\n    dp = (int*) malloc(n * sizeof(int));\\n    if (!dp) {\\n        goto END;\\n    }"]]}
{"id": "911", "ref_c": [["bool makesquare(int* matchsticks, int matchsticksSize){\\n    int perimeter = 0;\\n    for(int i = 0; i < matchsticksSize; i++)\\n        perimeter += matchsticks[i];\\n    \\n    int len = perimeter / 4;  \\n    int *sides = calloc(sizeof(int), 4);\\n    if(len * 4 != perimeter) return false;\\n    \\n    qsort(matchsticks, matchsticksSize, sizeof(int), cmp);\\n    \\n    return backtrack(0, matchsticks, matchsticksSize, sides, len);\\n}"], ["bool makesquare(int* matchsticks, int matchsticksSize){\\n    /*\\n     * Input:\\n     *  matchsticks, integer array\\n     *  matchsticksSize, size of array\\n     */\\n     \\n    /*\\n     * Algorithm:\\n     *  matchsticks = [1,1,2,2,2]        n\\n     *  The square:                   ------\\n     *                              n |    | n\\n     *                                |    |\\n     *                                ------\\n     *                                   n\\n     *  (1) sum(matchsticks) % 4 have to be equal to 0\\n     *  (2) side length of square is sum(matchsticks) / 4 = 2\\n     *  (3) The length of array should be equal to or larger than 4\\n     *  (4) The maximum number should not be larger than n\\n     *  (5) Need a way to find 4 distinct set of integer whose sum equal to 2?\\n     *      sort in ascending order\\n     *      backtracking method?\\n     *\\n     *  matchsticks = [1, 1, 1, 3, 2],          impossible,\\n     *  matchsticks = [1, 1, 1, 1, 1, 1, 1, 1]  yes\\n     *\\n     */\\n     \\n    int sum = 0;\\n    \\n    /* Requires at least 4 matchsticks */\\n    if (matchsticksSize < 4) {\\n        return false;\\n    }"], ["bool makesquare(int* matchsticks, int matchsticksSize){\\n    /*\\n     * Input:\\n     *  matchsticks, integer array\\n     *  matchsticksSize, size of array\\n     */\\n     \\n    /*\\n     * Algorithm:\\n     *  matchsticks = [1,1,2,2,2]        n\\n     *  The square:                   ------\\n     *                              n |    | n\\n     *                                |    |\\n     *                                ------\\n     *                                   n\\n     *  (1) sum(matchsticks) % 4 have to be equal to 0\\n     *  (2) side length of square is sum(matchsticks) / 4 = 2\\n     *  (3) The length of array should be equal to or larger than 4\\n     *  (4) The maximum number should not be larger than n\\n     *  (5) Need a way to find 4 distinct set of integer whose sum equal to 2?\\n     *      sort in ascending order\\n     *      backtracking method?\\n     *\\n     *  matchsticks = [1, 1, 1, 3, 2],          impossible,\\n     *  matchsticks = [1, 1, 1, 1, 1, 1, 1, 1]  yes\\n     *\\n     */\\n     \\n    int sum = 0;\\n    \\n    /* Requires at least 4 matchsticks */\\n    if (matchsticksSize < 4) {\\n        return false;\\n    }"]]}
{"id": "912", "ref_c": [["int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    int parent[1001];\\n    int rank[1001];\\n    int *ans=(int*)malloc(2*sizeof(int));\\n    \\n    void make_set(int n){\\n        for(int i=0;i<1001;i++){\\n            parent[i]=i;\\n            rank[i]=0;\\n        }"], ["int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    int parent[1001];\\n    int rank[1001];\\n    int *ans=(int*)malloc(2*sizeof(int));\\n    \\n    void make_set(int n){\\n        for(int i=0;i<1001;i++){\\n            parent[i]=i;\\n            rank[i]=0;\\n        }"], ["int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    int parent[1001];\\n    int rank[1001];\\n    int *ans=(int*)malloc(2*sizeof(int));\\n    \\n    void make_set(int n){\\n        for(int i=0;i<1001;i++){\\n            parent[i]=i;\\n            rank[i]=0;\\n        }"]]}
{"id": "913", "ref_c": [["char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    (*returnSize) = 1;\\n\\n    int len;\\n    int i;\\n    for (i=1; i<wordsSize; ++i)\\n    {\\n        if (isAnagrams(words[(*returnSize)-1], words[i]) == true)\\n        {\\n            continue;\\n        }"], ["char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    int i = 0 , j =0 , size  = 1;\\n    char** ret = (char**)malloc(wordsSize*sizeof(char*));\\n    ret[size-1] = words[0];\\n    for(i = 1 ; i < wordsSize ; ++i)\\n    {\\n        if(isAng(ret[size-1] , words[i]))\\n            continue;\\n        else\\n        {\\n            ++size;\\n            ret[size-1] = words[i];\\n        }"], ["char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    int i = 0 , j =0;\\n    char** ret = NULL;\\n    int size = 0;\\n    for( j = 0 ,i = 1 ; i < wordsSize ; )\\n    {\\n        if(words[j] && words[i]  && (isAng(words[i] , words[j])))\\n        {\\n            words[i] = NULL;\\n            ++i;\\n        }"]]}
{"id": "914", "ref_c": [["int longestUnivaluePath(struct TreeNode* root){\\n    if(root==NULL){\\n        return 0;\\n    }"], ["int longestUnivaluePath(struct TreeNode* root)\\n{\\n  int ret_val = 1;\\n  int* max = &ret_val;\\n  driver(root, max);\\n  return ret_val - 1;\\n}"], ["int longestUnivaluePath(struct TreeNode* root){\\n    int res=0;\\n    traval(root,&res);\\n    return res;\\n}"]]}
{"id": "915", "ref_c": [["double knightProbability(int n, int k, int row, int column) {\\n        double[][] dp = new double[n][n];\\n        dp[row][column] = 1.0;\\n\\n        for(int move = 1; move<=k; move++) {\\n            double[][] ndp = new double[n][n];\\n            for(int r = 0; r<n; r++) {\\n                for(int c = 0; c<n; c++) {\\n                    for(int[] m: moves) {\\n                        int nr = r+m[0];\\n                        int nc = c+m[1];\\n                        if (isValid(nr, nc, n)) ndp[r][c] += dp[nr][nc]/8.0;\\n                    }", "double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        dp[row][column] = 1;\\n\\n        vector<vector<int>> moves = {{-2, -1}", "double knightProbability(int n, int k, int row, int column) {\\n    double dp[n][n];\\n    memset(dp, 0, sizeof(dp));\\n    dp[row][column] = 1;\\n\\n    int moves[8][2] = {{-2, -1}"], ["double knightProbability(int n, int k, int row, int column) {\\n    // DP method \\n\\n    // Time complexity: O(k*n^2)\\n    // Space complexity: O(n^2)\\n\\n    if (k == 0) return 1;\\n\\n    // dp[i][j] := probability to stand on (i, j) \\n    double** dp = (double**)calloc(n, sizeof(double*));\\n    double** temp = (double**)calloc(n, sizeof(double*));\\n    for (int i = 0; i < n; i++) {\\n        dp[i] = (double*)calloc(n, sizeof(double));\\n        temp[i] = (double*)calloc(n, sizeof(double));\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = 1.0;\\n        }"], ["double knightProbability(int n, int k, int row, int column){\\n\\n    double ***memo = (double ***)malloc(sizeof(double **) * (k + 1)); \\n    for(int i = 0; i <= k; i++){\\n        memo[i] = (double ** )malloc(sizeof(double *) * n);\\n        for(int j = 0; j < n; j++){\\n            memo[i][j] = (double *)malloc(sizeof(double) * n); \\n            for(int z = 0; z < n; z++){\\n                memo[i][j][z] = -1; \\n            }"]]}
{"id": "917", "ref_c": ["\nint compareString(const void* str1, const void* str2)\n{\n    // descending order\n    return strcmp(*(char**)str2, *(char**)str1);\n}\n\nint compareInteger(const void* n1, const void* n2)\n{\n    // descending order\n    return (*(int*)n2 - *(int*)n1);\n}\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** topKFrequent(char ** words, int wordsSize, int k, int* returnSize){\n    char** pRetVal = NULL;\n\n    *returnSize = k;\n    pRetVal = (char**)malloc((*returnSize)*sizeof(char*));\n    if (pRetVal == NULL)\n    {\n        perror(\"malloc\");\n        *returnSize = 0;\n        return pRetVal;\n    }\n\n    // descending order; Time Complexity: O(nlogn)\n    qsort(words, wordsSize, sizeof(char*), compareString);\n\n    // 1 <= words.length <= 500\n#define COUNT_IDX   (1000)\n    int idx = 0;\n    // Space Complexity: O(n)\n    int count[wordsSize];\n    count[idx] = idx + COUNT_IDX;\n    int i;\n    // Time Complexity: O(n)\n    for (i=1; i<wordsSize; ++i)\n    {\n        if (strcmp(words[i-1], words[i]) == 0)\n        {\n            count[idx] += COUNT_IDX;\n            count[i] = i;\n            continue;\n        }\n        count[i] = i + COUNT_IDX;\n        idx = i;\n    }\n\n    // descending order; Time Complexity: O(nlogn)\n    qsort(count, wordsSize, sizeof(int), compareInteger);\n\n    // Time Complexity: O(n)\n    for (i=0; i<(*returnSize); ++i)\n    {\n        pRetVal[i] = words[count[i]%1000];\n    }\n\n    return pRetVal;\n}\n", "\nint compareString(const void* str1, const void* str2)\n{\n    // descending order\n    return strcmp(*(char**)str2, *(char**)str1);\n}\n\nint compareInteger(const void* n1, const void* n2)\n{\n    // descending order\n    return (*(int*)n2 - *(int*)n1);\n}\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** topKFrequent(char ** words, int wordsSize, int k, int* returnSize){\n    char** pRetVal = NULL;\n\n    *returnSize = k;\n    pRetVal = (char**)malloc((*returnSize)*sizeof(char*));\n    if (pRetVal == NULL)\n    {\n        perror(\"malloc\");\n        *returnSize = 0;\n        return pRetVal;\n    }\n\n    // descending order; Time Complexity: O(nlogn)\n    qsort(words, wordsSize, sizeof(char*), compareString);\n\n    // 1 <= words.length <= 500\n#define COUNT_IDX   (1000)\n    int idx = 0;\n    // Space Complexity: O(n)\n    int count[wordsSize];\n    count[idx] = idx + COUNT_IDX;\n    int i;\n    // Time Complexity: O(n)\n    for (i=1; i<wordsSize; ++i)\n    {\n        if (strcmp(words[i-1], words[i]) == 0)\n        {\n            count[idx] += COUNT_IDX;\n            count[i] = i;\n            continue;\n        }\n        count[i] = i + COUNT_IDX;\n        idx = i;\n    }\n\n    // descending order; Time Complexity: O(nlogn)\n    qsort(count, wordsSize, sizeof(int), compareInteger);\n\n    // Time Complexity: O(n)\n    for (i=0; i<(*returnSize); ++i)\n    {\n        pRetVal[i] = words[count[i]%1000];\n    }\n\n    return pRetVal;\n}\n", "\nint compareString(const void* str1, const void* str2)\n{\n    // descending order\n    return strcmp(*(char**)str2, *(char**)str1);\n}\n\nint compareInteger(const void* n1, const void* n2)\n{\n    // descending order\n    return (*(int*)n2 - *(int*)n1);\n}\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** topKFrequent(char ** words, int wordsSize, int k, int* returnSize){\n    char** pRetVal = NULL;\n\n    *returnSize = k;\n    pRetVal = (char**)malloc((*returnSize)*sizeof(char*));\n    if (pRetVal == NULL)\n    {\n        perror(\"malloc\");\n        *returnSize = 0;\n        return pRetVal;\n    }\n\n    // descending order; Time Complexity: O(nlogn)\n    qsort(words, wordsSize, sizeof(char*), compareString);\n\n    // 1 <= words.length <= 500\n#define COUNT_IDX   (1000)\n    int idx = 0;\n    // Space Complexity: O(n)\n    int count[wordsSize];\n    count[idx] = idx + COUNT_IDX;\n    int i;\n    // Time Complexity: O(n)\n    for (i=1; i<wordsSize; ++i)\n    {\n        if (strcmp(words[i-1], words[i]) == 0)\n        {\n            count[idx] += COUNT_IDX;\n            count[i] = i;\n            continue;\n        }\n        count[i] = i + COUNT_IDX;\n        idx = i;\n    }\n\n    // descending order; Time Complexity: O(nlogn)\n    qsort(count, wordsSize, sizeof(int), compareInteger);\n\n    // Time Complexity: O(n)\n    for (i=0; i<(*returnSize); ++i)\n    {\n        pRetVal[i] = words[count[i]%1000];\n    }\n\n    return pRetVal;\n}\n"]}
{"id": "918", "ref_c": [["int maxAreaOfIsland(int** grid, int gridSize, int* gridColSize){    \\n    int m = gridSize;\\n    int n = *gridColSize;\\n    int maxArea = 0;\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] == 1) {\\n                int sum = 0;\\n                dfs(i, j, grid, m, n, &sum);\\n                maxArea = fmax(maxArea, sum);\\n            }"], ["int maxAreaOfIsland(int** grid, int gridSize, int* gridColSize){\\n    int rows = gridSize;\\n    int cols = *gridColSize;\\n    int maxv = 0;\\n    int total = rows*cols;\\n    int *parent = (int*)malloc(sizeof(int) * total );\\n    int *size = (int*)malloc(sizeof(int) * total ) ;\\n    for(int k = 0 ;k<total; k++) {\\n        parent[k] = k;\\n        size[k] = 1;\\n    }"], ["int maxAreaOfIsland(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1 && *gridColSize == 1)\\n        return grid[0][0];\\n        \\n    int m = gridSize, n = *gridColSize, i, j, sum = 0, ans = 0;\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++){\\n            if (grid[i][j]) {\\n                sum = 0;\\n                helper(i, j, m, n, &sum, &ans, grid);\\n            }"]]}
{"id": "919", "ref_c": [["bool canPartitionKSubsets(int* nums, int numsSize, int k){\\n    int sum=0;\\n    for(int i=0;i<numsSize;i++){\\n        sum+=nums[i];\\n    }"], ["bool canPartitionKSubsets(int* nums, int numsSize, int k){\\n    int sum=0;\\n    for(int i=0;i<numsSize;i++){\\n        sum+=nums[i];\\n    }"], ["bool canPartitionKSubsets(int* nums, int numsSize, int k){\\n    int sum=0;\\n    for(int i=0;i<numsSize;i++){\\n        sum+=nums[i];\\n    }"]]}
{"id": "920", "ref_c": [["struct TreeNode* insertIntoBST(struct TreeNode* root, int val){\\nstruct TreeNode*node=NULL;\\nnode=(struct TreeNode*)malloc(sizeof(struct TreeNode));\\nnode->val=val;\\nnode->left=NULL;\\nnode->right=NULL;\\nif(root==NULL)\\nreturn node;\\nelse\\n{\\nstruct TreeNode*t=searching(root,val);\\nif(t->val>val)\\nt->left=node;\\nelse\\nt->right=node;\\n}"], ["struct TreeNode* insertIntoBST(struct TreeNode* root, int val){\\nstruct TreeNode*node=NULL;\\nnode=(struct TreeNode*)malloc(sizeof(struct TreeNode));\\nnode->val=val;\\nnode->left=NULL;\\nnode->right=NULL;\\nif(root==NULL)\\nreturn node;\\nelse\\n{\\nstruct TreeNode*t=searching(root,val);\\nif(t->val>val)\\nt->left=node;\\nelse\\nt->right=node;\\n}"], ["struct TreeNode* insertIntoBST(struct TreeNode* root, int val){\\nstruct TreeNode*node=NULL;\\nnode=(struct TreeNode*)malloc(sizeof(struct TreeNode));\\nnode->val=val;\\nnode->left=NULL;\\nnode->right=NULL;\\nif(root==NULL)\\nreturn node;\\nelse\\n{\\nstruct TreeNode*t=searching(root,val);\\nif(t->val>val)\\nt->left=node;\\nelse\\nt->right=node;\\n}"]]}
{"id": "922", "ref_c": [["int minimumDeleteSum(char * s1, char * s2){\\n    int size1 = strlen(s1);\\n    int size2 = strlen(s2);\\n    int** dp = (int**)malloc(sizeof(int*) * size1);\\n    for(int i = 0;i<size1;i++){\\n        int* temp = (int*)malloc(sizeof(int) * size2);\\n        for(int j = 0;j<size2;j++){\\n            temp[j] = -1;\\n        }"], ["int minimumDeleteSum(char * s1, char * s2){\\n    int size1 = strlen(s1);\\n    int size2 = strlen(s2);\\n    int** dp = (int**)malloc(sizeof(int*) * size1);\\n    for(int i = 0;i<size1;i++){\\n        int* temp = (int*)malloc(sizeof(int) * size2);\\n        for(int j = 0;j<size2;j++){\\n            temp[j] = -1;\\n        }"], ["int minimumDeleteSum(char * s1, char * s2){\\n    int size1 = strlen(s1);\\n    int size2 = strlen(s2);\\n    int** dp = (int**)malloc(sizeof(int*) * size1);\\n    for(int i = 0;i<size1;i++){\\n        int* temp = (int*)malloc(sizeof(int) * size2);\\n        for(int j = 0;j<size2;j++){\\n            temp[j] = -1;\\n        }"]]}
{"id": "923", "ref_c": [["int numSubarrayProductLessThanK(int* nums, int numsSize, int k){\\n    int res = 0, temp = 1, start = 0;\\n    for (int i=0; i<numsSize; i++) {\\n        temp *= nums[i];\\n        while ((temp >= k) && (i >= start))\\n            temp /= nums[start++];\\n        res += i-start+1;\\n    }"], ["int numSubarrayProductLessThanK(int* nums, int numsSize, int k){\\n    int res = 0, temp = 1, start = 0;\\n    for (int i=0; i<numsSize; i++) {\\n        temp *= nums[i];\\n        while ((temp >= k) && (i >= start))\\n            temp /= nums[start++];\\n        res += i-start+1;\\n    }"], ["int numSubarrayProductLessThanK(int* nums, int numsSize, int k){\\n    int res = 0, temp = 1, start = 0;\\n    for (int i=0; i<numsSize; i++) {\\n        temp *= nums[i];\\n        while ((temp >= k) && (i >= start))\\n            temp /= nums[start++];\\n        res += i-start+1;\\n    }"]]}
{"id": "924", "ref_c": [["int maxProfit(int* prices, int pricesSize, int fee){\\n    int min = prices[0];\\n    int max = prices[0];\\n    int profit = 0;\\n\\n    for(int i = 0; i <= pricesSize; i++){\\n        int price = i == pricesSize? 0: prices[i];\\n        //printf(\"index %d, max %d, min %d, price %d, profit %d\\\\n\", i, max , min, price, profit);\\n        \\n        if((price < max - fee) && (max - min > fee)){\\n            //sell\\n            profit += (max - min - fee);\\n            //buy\\n            min = max = price;\\n        }"], ["int maxProfit(int* prices, int pricesSize, int fee){\\n    /*\\n     * Input:\\n     *  prices, price of stock on day n\\n     *  prices, \\n     *  fee\\n     */\\n\\n    for (int i = 0; i < pricesSize; i++) {\\n        dp[i][0] = -1;\\n        dp[i][1] = -1;\\n    }"], ["int maxProfit(int* prices, int pricesSize, int fee){\\n    /*\\n     * Input:\\n     *  prices, price of stock on day n\\n     *  prices, \\n     *  fee\\n     */\\n\\n    for (int i = 0; i < pricesSize; i++) {\\n        dp[i][0] = -1;\\n        dp[i][1] = -1;\\n    }"]]}
{"id": "925", "ref_c": [["int findLength(int* nums1, int nums1Size, int* nums2, int nums2Size)\\n{\\n    X = nums1;\\n    Y = nums2;\\n    M = nums1Size;\\n    N = nums2Size;\\n\\n    // Step 2\\n    int l = 0;\\n    int r = M < N ? (M) : (N);\\n    int m;\\n\\n    if (subarray_present2(r))\\n        return r;\\n\\n    // Step 1\\n    /* Binary search for length of subarray that satisfies the\\n       solution */\\n    while (l <= r)\\n    {\\n        // Step 3.a\\n        m = l + (r-l)/2;\\n\\n        // Step 3.b\\n        if (subarray_present2(m))\\n        {\\n            // Step 3.b.i\\n            if (!subarray_present2(m+1))\\n                return m;\\n            l = m + 1;\\n        }"], ["int findLength(int* nums1, int nums1Size, int* nums2, int nums2Size)\\n{\\n    X = nums1;\\n    Y = nums2;\\n    M = nums1Size;\\n    N = nums2Size;\\n\\n    // Step 2\\n    int l = 0;\\n    int r = M < N ? (M) : (N);\\n    int m;\\n\\n    if (subarray_present2(r))\\n        return r;\\n\\n    // Step 1\\n    /* Binary search for length of subarray that satisfies the\\n       solution */\\n    while (l <= r)\\n    {\\n        // Step 3.a\\n        m = l + (r-l)/2;\\n\\n        // Step 3.b\\n        if (subarray_present2(m))\\n        {\\n            // Step 3.b.i\\n            if (!subarray_present2(m+1))\\n                return m;\\n            l = m + 1;\\n        }"], ["int findLength(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int len1, len2;\\n\\n    len1 = find_max_match_len(nums1, nums1Size, nums2, nums2Size);\\n    len2 = find_max_match_len(nums2, nums2Size, nums1, nums1Size);\\n\\n    return((len1 > len2)? len1 : len2);\\n    \\n}"]]}
{"id": "926", "ref_c": ["\ntypedef struct node {\n    bool end;\n    struct node *children[26];\n} Node;\n\nint cmp(const void *a, const void *b) {\n    return strcmp(*(const char **)a, *(const char **)b);\n}\n\nchar *longestWord(char **words, int wordsSize) {\n    qsort(words, wordsSize, sizeof(words[0]), cmp);\n    Node *trie = malloc(sizeof(Node));\n    for (int i = 0; i < 26; i++) trie->children[i] = NULL;\n    int max = 0, index = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        Node *next = trie;\n        int temp = 0, len = strlen(words[i]);\n        for (int j = 0; j < len; j++) {\n            Node *n;\n            if (next->children[words[i][j] - 'a'] == NULL) {\n                n = malloc(sizeof(Node));\n                for (int i = 0; i < 26; i++) n->children[i] = NULL;\n                n->end = false;\n            } else {\n                n = next->children[words[i][j] - 'a'];\n            }\n            if (j == len - 1) n->end = true;\n            if (n->end == false) break;\n            next = next->children[words[i][j] - 'a'] = n;\n            if (next->end == true) temp++;\n            if (j == len - 1 && temp > max) {\n                max = temp;\n                index = i;\n            }\n        }\n    }\n    return words[index];\n}\n", "\ntypedef struct node {\n    bool end;\n    struct node *children[26];\n} Node;\n\nint cmp(const void *a, const void *b) {\n    return strcmp(*(const char **)a, *(const char **)b);\n}\n\nchar *longestWord(char **words, int wordsSize) {\n    qsort(words, wordsSize, sizeof(words[0]), cmp);\n    Node *trie = malloc(sizeof(Node));\n    for (int i = 0; i < 26; i++) trie->children[i] = NULL;\n    int max = 0, index = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        Node *next = trie;\n        int temp = 0, len = strlen(words[i]);\n        for (int j = 0; j < len; j++) {\n            Node *n;\n            if (next->children[words[i][j] - 'a'] == NULL) {\n                n = malloc(sizeof(Node));\n                for (int i = 0; i < 26; i++) n->children[i] = NULL;\n                n->end = false;\n            } else {\n                n = next->children[words[i][j] - 'a'];\n            }\n            if (j == len - 1) n->end = true;\n            if (n->end == false) break;\n            next = next->children[words[i][j] - 'a'] = n;\n            if (next->end == true) temp++;\n            if (j == len - 1 && temp > max) {\n                max = temp;\n                index = i;\n            }\n        }\n    }\n    return words[index];\n}\n", "\ntypedef struct node {\n    bool end;\n    struct node *children[26];\n} Node;\n\nint cmp(const void *a, const void *b) {\n    return strcmp(*(const char **)a, *(const char **)b);\n}\n\nchar *longestWord(char **words, int wordsSize) {\n    qsort(words, wordsSize, sizeof(words[0]), cmp);\n    Node *trie = malloc(sizeof(Node));\n    for (int i = 0; i < 26; i++) trie->children[i] = NULL;\n    int max = 0, index = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        Node *next = trie;\n        int temp = 0, len = strlen(words[i]);\n        for (int j = 0; j < len; j++) {\n            Node *n;\n            if (next->children[words[i][j] - 'a'] == NULL) {\n                n = malloc(sizeof(Node));\n                for (int i = 0; i < 26; i++) n->children[i] = NULL;\n                n->end = false;\n            } else {\n                n = next->children[words[i][j] - 'a'];\n            }\n            if (j == len - 1) n->end = true;\n            if (n->end == false) break;\n            next = next->children[words[i][j] - 'a'] = n;\n            if (next->end == true) temp++;\n            if (j == len - 1 && temp > max) {\n                max = temp;\n                index = i;\n            }\n        }\n    }\n    return words[index];\n}\n"]}
{"id": "927", "ref_c": [["char *** accountsMerge(char *** accounts, int accountsSize, int* accountsColSize, int* returnSize, int** returnColumnSizes){\\n    int emailsSize;\\n    int unionFindSize;\\n    int i, j, k;\\n    char** emails;\\n    int* parent;\\n    int* rank;\\n    struct Pair* pairs;\\n    struct Result r;\\n    memset(&r, 0, sizeof(r));\\n\\n    for (emailsSize = 0, i = 0; i < accountsSize; i++) {\\n        for (j = 1; j < accountsColSize[i]; j++) {\\n            emailsSize ++;\\n        }"], ["char *** accountsMerge(char *** accounts, int accountsSize, int* accountsColSize, int* returnSize, int** returnColumnSizes){\\n    int emailsSize;\\n    int unionFindSize;\\n    int i, j, k;\\n    char** emails;\\n    int* parent;\\n    int* rank;\\n    struct Pair* pairs;\\n    struct Result r;\\n    memset(&r, 0, sizeof(r));\\n\\n    for (emailsSize = 0, i = 0; i < accountsSize; i++) {\\n        for (j = 1; j < accountsColSize[i]; j++) {\\n            emailsSize ++;\\n        }"], ["char *** accountsMerge(char *** accounts, int accountsSize, int* accountsColSize, int* returnSize, int** returnColumnSizes){\\n    int emailsSize;\\n    int unionFindSize;\\n    int i, j, k;\\n    char** emails;\\n    int* parent;\\n    int* rank;\\n    struct Pair* pairs;\\n    struct Result r;\\n    memset(&r, 0, sizeof(r));\\n\\n    for (emailsSize = 0, i = 0; i < accountsSize; i++) {\\n        for (j = 1; j < accountsColSize[i]; j++) {\\n            emailsSize ++;\\n        }"]]}
{"id": "928", "ref_c": [["char ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int blockCommentOp = 0;\\n    char ** srcCopy = malloc(sourceSize*sizeof(char*));\\n    int line = 0, idx = 0;\\n    srcCopy[line] = NULL;\\n    for (int i = 0; i < sourceSize; ++i) {\\n        int j = 0;\\n        while (source[i][j] != \\'\\\\0\\') {\\n            char c = source[i][j];\\n            if (blockCommentOp == 0) {\\n                if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                    break;\\n                }"], ["char ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int blockCommentOp = 0;\\n    char ** srcCopy = malloc(sourceSize*sizeof(char*));\\n    int line = 0, idx = 0;\\n    srcCopy[line] = NULL;\\n    for (int i = 0; i < sourceSize; ++i) {\\n        int j = 0;\\n        while (source[i][j] != \\'\\\\0\\') {\\n            char c = source[i][j];\\n            if (blockCommentOp == 0) {\\n                if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                    break;\\n                }"], ["char ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int blockCommentOp = 0;\\n    char ** srcCopy = malloc(sourceSize*sizeof(char*));\\n    int line = 0, idx = 0;\\n    srcCopy[line] = NULL;\\n    for (int i = 0; i < sourceSize; ++i) {\\n        int j = 0;\\n        while (source[i][j] != \\'\\\\0\\') {\\n            char c = source[i][j];\\n            if (blockCommentOp == 0) {\\n                if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                    break;\\n                }"]]}
{"id": "929", "ref_c": [["struct ListNode** splitListToParts(struct ListNode* head, int k, int* returnSize){\\n    /*\\n     * Input:\\n     *  head,\\n     *  k\\n     */\\n\\n    /*\\n     * Algorithm:\\n     *  Length(list) = 50, k = 7\\n     *  50 / 7 = 7 ... 1\\n     *  First run, the specific part should contains (7 + 1) nodes\\n     *  Second run, rest part should contains (7) nodes\\n     *  \\n     *  8, 7, 7, 7, 7, 7, 7\\n     */\\n    \\n    struct ListNode **ans = (struct ListNode **)calloc(1, sizeof(struct ListNode *) * k);\\n    struct ListNode *prev;\\n    int base, len = 0, part = 0;\\n    \\n    for (struct ListNode *tmp = head; tmp; tmp = tmp->next) {\\n        len++;\\n    }"], ["struct ListNode** splitListToParts(struct ListNode* head, int k, int* returnSize){\\n\\n    *returnSize = k;\\n    struct ListNode **ListArr = (struct ListNode *)malloc(sizeof(struct ListNode)*k);\\n\\n    int n=0; struct ListNode *temp=head; // To find no. of elements\\n    while(temp){\\n        n++; temp=temp->next;\\n    }"], ["struct ListNode** splitListToParts(struct ListNode* head, int k, int* returnSize){\\n    /*\\n     * Input:\\n     *  head,\\n     *  k\\n     */\\n\\n    /*\\n     * Algorithm:\\n     *  Length(list) = 50, k = 7\\n     *  50 / 7 = 7 ... 1\\n     *  First run, the specific part should contains (7 + 1) nodes\\n     *  Second run, rest part should contains (7) nodes\\n     *  \\n     *  8, 7, 7, 7, 7, 7, 7\\n     */\\n    \\n    struct ListNode **ans = (struct ListNode **)calloc(1, sizeof(struct ListNode *) * k);\\n    struct ListNode *prev;\\n    int base, len = 0, part = 0;\\n    \\n    for (struct ListNode *tmp = head; tmp; tmp = tmp->next) {\\n        len++;\\n    }"]]}
{"id": "932", "ref_c": [["int* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize){\\n    bool collision = true;\\n    int zeros = 0;\\n\\n    while(collision == true){   /* Untill there is a collision */\\n        collision = false;\\n        int i = 0, j = 0;\\n        while(i < asteroidsSize-1 && asteroids[i] <= 0) {   /* Move i to first positive number */\\n            i++;\\n        }"], ["int* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize) {\\n    int j = 0;\\n    for (int i = 0; i < asteroidsSize; i++) {\\n        int asteroid = asteroids[i];\\n\\n        while (j > 0 && asteroids[j - 1] > 0 && asteroid < 0 && asteroids[j - 1] < abs(asteroid)) \\n        {\\n            j--;\\n        }"], ["int* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize) {\\n    // Allocate memory for the return array\\n    int* array = (int*)malloc(asteroidsSize * sizeof(int));\\n\\n    int j = 0; // Index for the return array\\n\\n    for (int i = 0; i < asteroidsSize; i++) {\\n        if (j > 0 && array[j - 1] > 0 && asteroids[i] < 0) {\\n            // Asteroid collision occurs\\n            while (j > 0 && array[j - 1] > 0 && abs(asteroids[i]) > array[j - 1]) {\\n                // Remove the smaller positive asteroid\\n                j--;\\n            }"]]}
{"id": "933", "ref_c": [["int countPrimes(int n) {\\n     if (n <= 2) {\\n        return 0;\\n    }"], ["int countPrimes(int n) {\\n    if (n <= 2) {\\n        return 0;\\n    }"], ["int countPrimes(int n) {\\n        if(n<=2) return 0;\\n        int track[n+1];\\n        memset(track,1,sizeof(track));\\n        track[0] = track[1] = 0;\\n        int count = 1;\\n        //Avoiding multiples of two in loop iterations.\\n        for(int i = 3;i<n;i+=2){\\n            if(track[i]){\\n                count++;\\n                for(int j = i;j<n;j+=i){\\n                    track[j] = 0;\\n                }"]]}
{"id": "934", "ref_c": [["int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize){\\n    int * ret = calloc(temperaturesSize, sizeof(int));\\n    *returnSize = temperaturesSize;\\n    int * stk = calloc(temperaturesSize, sizeof(int)); // store indexes\\n    int pt = -1; // stack pointer (point to the top element, \\'-1\\' represent the stack is currently empty)\\n    \\n    // starting from the end of the array\\n    for (int i = temperaturesSize-1; i >= 0; i--){\\n        while(pt != -1 && temperatures[i] >= temperatures[stk[pt]]) pt--; // pop\\n        ret[i] = (pt == -1? 0: stk[pt]-i);\\n        stk[++pt] = i; // push index to stack\\n    }"], ["int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize){\\n    int * ret = calloc(temperaturesSize, sizeof(int));\\n    *returnSize = temperaturesSize;\\n    int * stk = calloc(temperaturesSize, sizeof(int)); // store indexes\\n    int pt = -1; // stack pointer (point to the top element, \\'-1\\' represent the stack is currently empty)\\n    \\n    // starting from the end of the array\\n    for (int i = temperaturesSize-1; i >= 0; i--){\\n        while(pt != -1 && temperatures[i] >= temperatures[stk[pt]]) pt--; // pop\\n        ret[i] = (pt == -1? 0: stk[pt]-i);\\n        stk[++pt] = i; // push index to stack\\n    }"], ["int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize){\\n    int * ret = calloc(temperaturesSize, sizeof(int));\\n    *returnSize = temperaturesSize;\\n    int * stk = calloc(temperaturesSize, sizeof(int)); // store indexes\\n    int pt = -1; // stack pointer (point to the top element, \\'-1\\' represent the stack is currently empty)\\n    \\n    // starting from the end of the array\\n    for (int i = temperaturesSize-1; i >= 0; i--){\\n        while(pt != -1 && temperatures[i] >= temperatures[stk[pt]]) pt--; // pop\\n        ret[i] = (pt == -1? 0: stk[pt]-i);\\n        stk[++pt] = i; // push index to stack\\n    }"]]}
{"id": "935", "ref_c": [["int deleteAndEarn(int* nums, int numsSize)\\n{    \\n    int max_num = 0;\\n\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        if (nums[i] > max_num)\\n            max_num = nums[i];\\n    }"], ["int deleteAndEarn(int* nums, int numsSize){\\n    if (numsSize == 1)\\n        return nums[0];\\n    int *vals = calloc(10001, sizeof(int));\\n    int patha, pathb;\\n    patha = 0, pathb = 0;\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        vals[nums[i]] += nums[i];\\n    }"], ["int deleteAndEarn(int* nums, int numsSize)\\n{    \\n    int max_num = 0;\\n\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        if (nums[i] > max_num)\\n            max_num = nums[i];\\n    }"]]}
{"id": "936", "ref_c": [["int networkDelayTime(int** times, int timesSize, int* timesColSize, int n, int k){\\n    int **matrix = prepareSparse(n, times, timesSize, timesColSize);\\n    int *cost = SingleSourceShortestPath(n, matrix, k);\\n    int max = -1;\\n\\n    for(int i = 0; i < n; i++){\\n        max = (max > cost[i])?max:cost[i];\\n    }"], ["int networkDelayTime(int** times, int timesSize, int* timesColSize, int n, int k){\\n    int **matrix = prepareSparse(n, times, timesSize, timesColSize);\\n    int *cost = SingleSourceShortestPath(n, matrix, k);\\n    int max = -1;\\n\\n    for(int i = 0; i < n; i++){\\n        max = (max > cost[i])?max:cost[i];\\n    }"], ["int networkDelayTime(int** times, int timesSize, int* timesColSize, int n, int k){\\n    int **matrix = prepareSparse(n, times, timesSize, timesColSize);\\n    int *cost = SingleSourceShortestPath(n, matrix, k);\\n    int max = -1;\\n\\n    for(int i = 0; i < n; i++){\\n        max = (max > cost[i])?max:cost[i];\\n    }"]]}
{"id": "937", "ref_c": [["int openLock(char ** deadends, int deadendsSize, char * target){\\n    int newTarget = atoi(target);\\n    int* deads = calloc(10000, sizeof(int));\\n    for(int i = 0; i < deadendsSize; i++) {\\n        int index = atoi(deadends[i]);\\n        deads[index] = 1;\\n    }"], ["int openLock(char ** deadends, int deadendsSize, char * target){\\n    int Itarget = atoi(target) ,i;\\n    if(Itarget == 0 ){\\n        return 0 ;\\n    }"], ["int openLock(char ** deadends, int deadendsSize, char * target){\\n    int newTarget = atoi(target);\\n    int* deads = calloc(10000, sizeof(int));\\n    for(int i = 0; i < deadendsSize; i++) {\\n        int index = atoi(deadends[i]);\\n        deads[index] = 1;\\n    }"]]}
{"id": "938", "ref_c": [["int reachNumber(int target) {\\n    target = abs(target); \\n    int sum = 0;\\n    int i = 1;\\n    \\n    while(1)\\n    {\\n        sum += i;\\n        if(sum >= target && (sum % 2 == target % 2)) return i;\\n        i++;\\n    }"], ["int reachNumber(int target) {\\n    target = abs(target); \\n    int sum = 0;\\n    int i = 1;\\n    \\n    while(1)\\n    {\\n        sum += i;\\n        if(sum >= target && (sum % 2 == target % 2)) return i;\\n        i++;\\n    }"], ["int reachNumber(int target) {\\n    target = abs(target); \\n    int sum = 0;\\n    int i = 1;\\n    \\n    while(1)\\n    {\\n        sum += i;\\n        if(sum >= target && (sum % 2 == target % 2)) return i;\\n        i++;\\n    }"]]}
{"id": "939", "ref_c": [["int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101][601] = {0}", "int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101] = {0}"], ["int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101][601] = {0}", "int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101] = {0}"], ["int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101][601] = {0}", "int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101] = {0}"]]}
{"id": "940", "ref_c": [["int* partitionLabels(char * s, int* returnSize){\\n    /*\\n     * Input:\\n     *  s, string\\n     */\\n     \\n    int len = strlen(s);\\n    int *ans = (int *)malloc(sizeof(int) * len);\\n    int hash[26] = {0}"], ["int* partitionLabels(char * s, int* returnSize){\\n    /*\\n     * Input:\\n     *  s, string\\n     */\\n     \\n    int len = strlen(s);\\n    int *ans = (int *)malloc(sizeof(int) * len);\\n    int hash[26] = {0}"], ["int* partitionLabels(char * s, int* returnSize){\\n    int* _partitionLs = 0;\\n    int count = 0;\\n    const int n = strlen(s);\\n    if (n == 1) { _partitionLs = realloc(_partitionLs, sizeof(int)); _partitionLs[0] = 1; *returnSize = 1; return _partitionLs; }"]]}
{"id": "941", "ref_c": [["int orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize){\\n    int ** temp = (int **)malloc(n*sizeof(int *));\\n    for(int i=0; i<n; i++)\\n    {\\n        temp[i] = (int *)malloc(n*sizeof(int));\\n        for(int j=0; j<n; j++)\\n            temp[i][j] = 1;\\n    }"], ["int orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize){\\n    int ** temp = (int **)malloc(n*sizeof(int *));\\n    for(int i=0; i<n; i++)\\n    {\\n        temp[i] = (int *)malloc(n*sizeof(int));\\n        for(int j=0; j<n; j++)\\n            temp[i][j] = 1;\\n    }"], ["int orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize){\\n    int ** temp = (int **)malloc(n*sizeof(int *));\\n    for(int i=0; i<n; i++)\\n    {\\n        temp[i] = (int *)malloc(n*sizeof(int));\\n        for(int j=0; j<n; j++)\\n            temp[i][j] = 1;\\n    }"]]}
{"id": "942", "ref_c": [["char * reorganizeString(char * s){\\n    int hash[26] = {0}"], ["char * reorganizeString(char * s){\\n    int hash[26] = {0}"], ["char * reorganizeString(char * s){\\n    int lenS=strlen(s);\\n    int list[26]={0}"]]}
{"id": "943", "ref_c": [["int maxChunksToSorted(int* arr, int arrSize){\\n    int max=0,chunk=0;\\n    for(int i=0;i<arrSize;i++)\\n    {    max=(max<arr[i])?arr[i]:max;        \\n        if(i==max) chunk++;    }"], ["int maxChunksToSorted(int* arr, int arrSize){\\n    int max=0,chunk=0;\\n    for(int i=0;i<arrSize;i++)\\n    {    max=(max<arr[i])?arr[i]:max;        \\n        if(i==max) chunk++;    }"], ["int maxChunksToSorted(int* arr, int arrSize){\\n    int max=0,chunk=0;\\n    for(int i=0;i<arrSize;i++)\\n    {    max=(max<arr[i])?arr[i]:max;        \\n        if(i==max) chunk++;    }"]]}
{"id": "944", "ref_c": [["int* preorder(struct Node* root, int* returnSize) {\\n    int* arr = (int*) malloc(10000 * sizeof(int));\\n    int idx = 0;\\n    search(root, arr, &idx);\\n    *returnSize = idx;\\n    return arr;\\n}"], ["int* preorder(struct Node* root, int* returnSize) \\n{\\n    no_of_nodes = 0;\\n    \\n    nodes(root);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * no_of_nodes);\\n    int ret_arr_index = 0;\\n    \\n    preorder_trav(root, ret_arr, &ret_arr_index);\\n    *returnSize = ret_arr_index;\\n    return ret_arr;\\n    \\n    \\n}"], ["int* preorder(struct Node* root, int* returnSize) \\n{\\n    no_of_nodes = 0;\\n    \\n    nodes(root);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * no_of_nodes);\\n    int ret_arr_index = 0;\\n    \\n    preorder_trav(root, ret_arr, &ret_arr_index);\\n    *returnSize = ret_arr_index;\\n    return ret_arr;\\n    \\n    \\n}"]]}
{"id": "945", "ref_c": [["bool canTransform(char * start, char * end){\\n    int c1 = 0, c2 = 0, i = 0, j = 0;\\n    int len = strlen(start);\\n    \\n    // both the strings should have equal number \\'X\\' characters\\n    for(i = 0; i < len; i++) {\\n        if(start[i] == \\'X\\')\\n            c1++;\\n        if(end[i] == \\'X\\')\\n            c2++;\\n    }"], ["bool canTransform(char * start, char * end){\\n    int c1 = 0, c2 = 0, i = 0, j = 0;\\n    int len = strlen(start);\\n    \\n    // both the strings should have equal number \\'X\\' characters\\n    for(i = 0; i < len; i++) {\\n        if(start[i] == \\'X\\')\\n            c1++;\\n        if(end[i] == \\'X\\')\\n            c2++;\\n    }"], ["bool canTransform(char * start, char * end){\\n    int c1 = 0, c2 = 0, i = 0, j = 0;\\n    int len = strlen(start);\\n    \\n    // both the strings should have equal number \\'X\\' characters\\n    for(i = 0; i < len; i++) {\\n        if(start[i] == \\'X\\')\\n            c1++;\\n        if(end[i] == \\'X\\')\\n            c2++;\\n    }"]]}
{"id": "946", "ref_c": [["int kthGrammar(int n, int k) {\\n        if (k==1) return 0;  // Base case\\n\\n        int bL=31-__builtin_clz(k); //Calculate log2(k)\\n        if (k==1<<bL) return bL&1;\\n        //invert the symbol \\n        else return 1-kthGrammar(n, k-(1<<bL));   \\n    }", "int kthGrammar(int n, int k) {\\n        k--; // Adjust k to be 0-based\\n        int f=0;\\n        \\n        for (int i = 0; i < 31; i++) {\\n            f^=(k & (1<<i))?1:0;\\n        }", "int kthGrammar(int n, int k){\\n    return __builtin_popcount(k-1) &1 ;\\n}"], ["int kthGrammar(int n, int k) {\\n        // Initialize a flag to track if the values of k and first element are the same.\\n        bool areValuesSame = true; \\n\\n        // Calculate the total number of elements in the nth row, which is 2^(n-1).\\n        n = pow(2, n - 1);\\n\\n        // Continue until we reach the first row.\\n        while (n != 1) {\\n            // Halve the number of elements in the row.\\n            n /= 2;\\n\\n            // If k is in the second half of the row, adjust k and toggle the flag.\\n            if (k > n) {\\n                k -= n;\\n                areValuesSame = !areValuesSame;\\n            }", "int kthGrammar(int n, int k) {\\n        // Initialize a flag to track if the values of k and the first element are the same.\\n        boolean areValuesSame = true;\\n\\n        // Calculate the total number of elements in the nth row, which is 2^(n-1).\\n        n = (int) Math.pow(2, n - 1);\\n\\n        // Continue until we reach the first row.\\n        while (n != 1) {\\n            // Halve the number of elements in the row.\\n            n /= 2;\\n\\n            // If k is in the second half of the row, adjust k and toggle the flag.\\n            if (k > n) {\\n                k -= n;\\n                areValuesSame = !areValuesSame;\\n            }", "int kthGrammar(int n, int k) {\\n    // Initialize a flag to track if the values of k and the first element are the same.\\n    bool areValuesSame = true;\\n\\n    // Calculate the total number of elements in the nth row, which is 2^(n-1).\\n    n = (int)pow(2, n - 1);\\n\\n    // Continue until we reach the first row.\\n    while (n != 1) {\\n        // Halve the number of elements in the row.\\n        n /= 2;\\n\\n        // If k is in the second half of the row, adjust k and toggle the flag.\\n        if (k > n) {\\n            k -= n;\\n            areValuesSame = !areValuesSame;\\n        }"], ["int kthGrammar(int n, int k) {\\n        return depthFirstSearch(n, k, 0);\\n    }", "int kthGrammar(int n, int k) {\\n    return depthFirstSearch(n, k, 0);\\n}", "int kthGrammar(int n, int k) {\\n        return depthFirstSearch(n, k, 0);\\n    }", "int kthGrammar(int n, int k) {\\n        return recursion(n, k);\\n    }", "int kthGrammar(int n, int k) {\\n    return recursion(n, k);\\n}", "int kthGrammar(int n, int k) {\\n        return recursion(n, k);\\n    }"]]}
{"id": "947", "ref_c": [["int numRabbits(int* answers, int answersSize) {\\n    int counts[1000] = {0}"], ["int numRabbits(int* answers, int answersSize) {\\n    int counts[1000] = {0}"], ["int numRabbits(int* answers, int answersSize) {\\n    int counts[1000] = {0}"]]}
{"id": "948", "ref_c": ["\nvoid backtrack(char *s, char **res, int i, int *size)\n{\n    if (i == strlen(s)) {\n        res[*size] = calloc(strlen(s) + 1, 1);\n        strcpy(res[*size], s);\n        (*size)++;\n        return;\n    }\n    if (s[i] >= '0' && s[i] <= '9') {\n        backtrack(s, res, i+1, size);\n        return;\n    }\n    s[i] = tolower(s[i]);\n    backtrack(s, res, i + 1, size);\n    s[i] = toupper(s[i]);\n    backtrack(s, res, i + 1, size);\n\n}\n\nchar ** letterCasePermutation(char * s, int* returnSize)\n{\n    char **res = malloc(sizeof(char*) * 5000);\n\n    int size = 0; \n    \n    backtrack(s, res, 0, &size);\n    \n    *returnSize = size;\n    return res;\n}\n", "\nvoid backtrack(char *s, char **res, int i, int *size)\n{\n    if (i == strlen(s)) {\n        res[*size] = calloc(strlen(s) + 1, 1);\n        strcpy(res[*size], s);\n        (*size)++;\n        return;\n    }\n    if (s[i] >= '0' && s[i] <= '9') {\n        backtrack(s, res, i+1, size);\n        return;\n    }\n    s[i] = tolower(s[i]);\n    backtrack(s, res, i + 1, size);\n    s[i] = toupper(s[i]);\n    backtrack(s, res, i + 1, size);\n\n}\n\nchar ** letterCasePermutation(char * s, int* returnSize)\n{\n    char **res = malloc(sizeof(char*) * 5000);\n\n    int size = 0; \n    \n    backtrack(s, res, 0, &size);\n    \n    *returnSize = size;\n    return res;\n}\n", "\nvoid backtrack(char *s, char **res, int i, int *size)\n{\n    if (i == strlen(s)) {\n        res[*size] = calloc(strlen(s) + 1, 1);\n        strcpy(res[*size], s);\n        (*size)++;\n        return;\n    }\n    if (s[i] >= '0' && s[i] <= '9') {\n        backtrack(s, res, i+1, size);\n        return;\n    }\n    s[i] = tolower(s[i]);\n    backtrack(s, res, i + 1, size);\n    s[i] = toupper(s[i]);\n    backtrack(s, res, i + 1, size);\n\n}\n\nchar ** letterCasePermutation(char * s, int* returnSize)\n{\n    char **res = malloc(sizeof(char*) * 5000);\n\n    int size = 0; \n    \n    backtrack(s, res, 0, &size);\n    \n    *returnSize = size;\n    return res;\n}\n"]}
{"id": "949", "ref_c": [["bool isBipartite(int** graph, int graphSize, int* graphColSize) {\\n    int* color = (int*)malloc(graphSize * sizeof(int));\\n\\n    for (int i = 0; i < graphSize; i++) {\\n        color[i] = 0;\\n    }"], ["bool isBipartite(int** graph, int graphSize, int* graphColSize){\\n    queue *queueIndex = init();\\n    color *colorArray = calloc(graphSize, sizeof(color));\\n    memset(colorArray, UNVISITED, graphSize * sizeof(color));\\n\\n    for (int index = 0; index < graphSize; index++) {\\n        if (colorArray[index] != UNVISITED) continue;\\n        enqueue(queueIndex, index);\\n        colorArray[index] = BLUE;\\n        while (!is_empty_queue(queueIndex)) {\\n            int vertexIndex = dequeue(queueIndex);\\n            for (int i = 0; i < graphColSize[vertexIndex]; i++) {\\n                int neighborIndex = graph[vertexIndex][i];\\n                if (colorArray[neighborIndex] == UNVISITED) {\\n                    enqueue(queueIndex, neighborIndex);\\n                    colorArray[neighborIndex] = (colorArray[vertexIndex] == BLUE) ? RED : BLUE;\\n                }"], ["bool isBipartite(int** graph, int graphSize, int* graphColSize) {\\n    int* color = (int*)malloc(graphSize * sizeof(int));\\n\\n    for (int i = 0; i < graphSize; i++) {\\n        color[i] = 0;\\n    }"]]}
{"id": "950", "ref_c": [["int* kthSmallestPrimeFraction(int* arr, int arrSize, int k, int* returnSize){\\n    int i, j, n = arrSize;\\n    int *res = malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n\\n    if (k == 1) {\\n        res[0] = arr[0];\\n        res[1] = arr[n - 1];\\n        return res;\\n    }"], ["int* kthSmallestPrimeFraction(int* arr, int arrSize, int k, int* returnSize){\\n    int i, j, n = arrSize;\\n    int *res = malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n\\n    if (k == 1) {\\n        res[0] = arr[0];\\n        res[1] = arr[n - 1];\\n        return res;\\n    }"], ["int* kthSmallestPrimeFraction(int* arr, int arrSize, int k, int* returnSize){\\n    int i, j, n = arrSize;\\n    int *res = malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n\\n    if (k == 1) {\\n        res[0] = arr[0];\\n        res[1] = arr[n - 1];\\n        return res;\\n    }"]]}
{"id": "951", "ref_c": [["int findCheapestPrice(int n, int** flights, int flightsSize, int* flightsColSize, int src, int dst, int k){\\n    /* create mapping for fee between station \\n     * we can use this to do BFS */\\n    /* row is source, col is row\\'s dest */\\n    int** m = (int**)calloc(n, sizeof(int*));\\n    for(int i = 0; i < n; i++)\\n        m[i] = (int*)calloc(n, sizeof(int));\\n    for(int i = 0; i < flightsSize; i++)\\n        m[flights[i][0]][flights[i][1]] = flights[i][2];\\n    k++;\\n    int rIdx = 0, wIdx = 0, minFee = INT_MAX;\\n    FRIGHT* q = (FRIGHT*)calloc(QSIZE, sizeof(FRIGHT));\\n    /* check src can flight to */\\n    Enqueue(m, n, 0, 0, src, q, &wIdx);\\n    while(rIdx != wIdx){\\n        int source = q[rIdx].dest;\\n        int currFee = q[rIdx].fee;\\n        int cnt = q[rIdx++].stopCnt; \\n        rIdx %= QSIZE;\\n        /* k is at most */\\n        if(cnt <= k){\\n            if(dst == source){\\n                minFee = fmin(minFee, currFee);\\n            }"], ["int findCheapestPrice(int n, int** flights, int flightsSize, int* flightsColSize, int src, int dst, int k){\\n    //we will create a na array to trace / hold the values of the route to be taken to reach the destination from source \\n    //2 2 diamensional array with memeory allocation for pointer\\n    int** path_traveled = (int**)malloc(sizeof(int*)*(k+1));\\n    //elemnts of the array are to be given memeory allocation \\n    for(int idx =0; idx < k+1; idx++){\\n        path_traveled[idx] = (int*)calloc(n+1,sizeof(int));\\n    }"], ["int findCheapestPrice(int n, int** flights, int flightsSize, int* flightsColSize, int src, int dst, int k) {\\n\\t/* Allocate required memory in a sinlge go */\\n\\tsize_t needed = \\n\\t\\tflightsSize * sizeof(*flights) +\\n\\t\\tn * 2 * sizeof(int) +\\n\\t\\tn * sizeof(int);\\n\\tchar* const buf = malloc(needed);\\n\\tchar* pos = buf;\\n\\tint** city_flights = (int**) pos;\\n\\tpos += (flightsSize * sizeof(*flights));\\n\\tint* const city_flights_count = (int*) pos;\\n\\tpos += (n * 2 * sizeof(int));\\n\\tint* const city_best = (int*) pos;\\n\\n\\t/* Group the flights by the source city using counting sort */\\n\\tmemset(city_flights_count, 0, n * sizeof(*city_flights_count));\\n\\tfor (int i = 0; i < flightsSize; ++i) {\\n\\t\\t++city_flights_count[flights[i][0]];\\n\\t}"]]}
{"id": "952", "ref_c": [["int rotatedDigits(int n){\\n    int count = 0;\\n    bool flag;\\n    for(int i = 2; i <= n; i++){\\n        int number = i;\\n        int canBack = 0, k = 0;\\n        flag = true;\\n        while(number){\\n            int digit = number % 10;\\n            number /= 10;\\n            k++;\\n            if(isGood[digit] == 1)\\n                canBack++;\\n            else if(isGood[digit] == 0){\\n                flag = false;\\n                break;\\n            }"], ["int rotatedDigits(int n){\\n    int count = 0;\\n    bool flag;\\n    for(int i = 2; i <= n; i++){\\n        int number = i;\\n        int canBack = 0, k = 0;\\n        flag = true;\\n        while(number){\\n            int digit = number % 10;\\n            number /= 10;\\n            k++;\\n            if(isGood[digit] == 1)\\n                canBack++;\\n            else if(isGood[digit] == 0){\\n                flag = false;\\n                break;\\n            }"], ["int rotatedDigits(int n){\\n    int count = 0;\\n    bool flag;\\n    for(int i = 2; i <= n; i++){\\n        int number = i;\\n        int canBack = 0, k = 0;\\n        flag = true;\\n        while(number){\\n            int digit = number % 10;\\n            number /= 10;\\n            k++;\\n            if(isGood[digit] == 1)\\n                canBack++;\\n            else if(isGood[digit] == 0){\\n                flag = false;\\n                break;\\n            }"]]}
{"id": "953", "ref_c": [["int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\\n        vector<vector<vector<int>>>  dp(60,vector<vector<int>> (60,vector<int>(60,-1)));\\n        return solve(startRow,startColumn,m,n,maxMove,dp);\\n    }"], ["int findPaths(int m, int n, int maxMove, int startRow, int startColumn){\\n    mat = malloc(sizeof(int **)*m);\\n    for(int i = 0; i < m; i++){\\n        mat[i] = malloc(sizeof(int*)*n);\\n        for(int j = 0; j < n; j++){\\n            mat[i][j] = malloc(sizeof(int)*(maxMove + 1));\\n            for(int k = 0; k < maxMove + 1; k++){\\n                mat[i][j][k] = -1;\\n            }"], ["int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\\n        vector<vector<vector<int>>>  dp(60,vector<vector<int>> (60,vector<int>(60,-1)));\\n        return solve(startRow,startColumn,m,n,maxMove,dp);\\n    }"]]}
{"id": "954", "ref_c": [["int numTilings(int n) {\\n        long[] dp = new long[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n        for (int i = 3; i < n; i ++) {\\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007;\\n        }", "int numTilings(int n) {\\n        long[] dp = new long[n + 2]; dp[0] = 1; dp[1] = 2;\\n        long[] dpa = new long[n + 2]; dpa[1] = 1;\\n        for (int i = 2; i < n; i ++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n            dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n        }", "int numTilings(int n) {\\n    unsigned int dp[n + 3]; dp[0] = 1; dp[1] = 2; dp[2] = 5;\\n    for (int i = 3; i < n; i ++) {\\n        dp[i] = (2 * dp[i - 1] + dp[i - 3]) % 1000000007;\\n    }", "int numTilings(int n){\\n    if (n == 1) return 1;\\n    unsigned int dp[n]; dp[0] = 1; dp[1] = 2;\\n    unsigned int dpa[n]; dpa[1] = 1;\\n    for (int i = 2; i < n; i ++) {\\n        dp[i] = (dp[i - 1] + dp[i - 2] + dpa[i - 1] * 2) % 1000000007;\\n        dpa[i] = (dp[i - 2] + dpa[i - 1]) % 1000000007;\\n    }"], ["int numTilings(int n) {\\n        //base case-1\\n        if (n < 3) return n;\\n        //given in the question that answer may be long\\n        int modulo = pow(10, 9) + 7;  \\n        \\n        vector<long> Domino(n+1, 0), Tromino(n+1, 0);\\n        //base case-2\\n        Domino[0] = 0,Domino[1] = 1, Domino[2] = 2;\\n        Tromino[0] = 0, Tromino[1] = 1, Tromino[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++) {\\n            Domino[i] = (Domino[i-1] + Domino[i-2] + 2*Tromino[i-2]) % modulo;\\n            Tromino[i] = (Tromino[i-1] + Domino[i-1]) % modulo;\\n        }"], ["int numTilings(int n){\\n    int ans[]={1,1,2,5}"]]}
{"id": "955", "ref_c": [["char * customSortString(char * order, char * s){\\n    int k = 0;\\n    int length = strlen(s);\\n    char *output = (char *)malloc(length + 1);\\n    for (int i = 0; order[i] != \\'\\\\0\\'; i++)\\n    {\\n        for (int j = 0; s[j] != \\'\\\\0\\'; j++)\\n        {\\n            if (order[i] == s[j])\\n            {\\n                output[k++] = order[i];\\n                s[j] = s[length - 1];\\n                s[length - 1] = \\'\\\\0\\';\\n                length--, j--;\\n            }"], ["char * customSortString(char * order, char * s){\\n    int i, j, k;\\n    char temp;\\n\\n    k = 0;\\n\\n    for(i = 0; order[i] != \\'\\\\0\\'; i++)\\n        for(j = 0; s[j] != \\'\\\\0\\'; j++)\\n            if(order[i] == s[j]){\\n                temp = s[k];\\n                s[k] = s[j];\\n                s[j] = temp;\\n                k++;\\n            }"], ["char * customSortString(char * order, char * str)\\n{\\n    temp = order;\\n    qsort(str, strlen(str), sizeof(char), cmp) ;\\n    return str;\\n}"]]}
{"id": "956", "ref_c": ["\nstatic int hash[26][50000];\n \nint searchCharAftIdx(int *indices, int len, int idx)\n{\n    int i = 0, j = len - 1, mid;\n\n    /* Search for a index close to and also larger than given idx */\n    idx++;\n\n    while (i < j) { \n    \n        mid = i + (j - i) / 2;\n        \n        if (indices[mid] == idx) {\n            return idx;\n        }\n        else if (indices[mid] < idx) {\n            i = mid + 1;\n        }\n        else {\n            j = mid;\n        }\n    }\n\n    if (i == j && indices[i] >= idx) {\n        return indices[i];\n    }\n    else {\n        return -1;\n    }\n}\n\nint numMatchingSubseq(char * s, char ** words, int wordsSize){\n    /*\n     * Input:\n     *  s, string\n     *  words, string arrays\n     *  wordsSize, number of string arrays\n     */\n     \n    /*\n     * Algorithm:\n     *  Brute + hash\n     *  (1) Store the index of each character to hash table\n     *      hash['a'][len['a']] = index\n     *      len['a']++;\n     *  (2) Loop the words, scan every character and check \n     *      if there is a corresponding character located \n     *      in a position > \"idx\", if so, set \"idx\" to \n     *      the index of last selected character.\n     *  (3) Once all the characters of a word been found,\n     *      set total += 1\n     *\n     *  E.g. s = \"helloworld\",\n     *            0123456789\n     *\n     *  hash['h'] = [0]\n     *  hash['e'] = [1]\n     *  hash['l'] = [2,3,8]\n     *  hash['o'] = [4,6]\n     *  hash['w'] = [5]\n     *  hash['r'] = [7]\n     *  hash['d'] = [9]\n     *\n     *  word = \"lol\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'o' character located after idx 2\n     *      => 'o' @ 4, idx = 4\n     *\n     *  Search 'l' character located after idx 4\n     *      => 'l' @ 8, idx = 8\n     *\n     *  >> Matched <<\n     *\n     *\n     *  word = \"le\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'e' character located after idx 2\n     *      => Not found\n     *\n     *  >> Mismatched <<\n     */\n\n    int len[26] = {0};\n    int idx = 0;\n    int cnt = 0;\n    int tmp;\n    \n    while (*s) {\n        hash[*s - 'a'][len[*s - 'a']] = idx;\n        len[*s - 'a']++;\n        idx++;\n        s++;\n    }\n\n    for (int i = 0; i < wordsSize; i++) {\n    \n        idx = -1;\n        s = words[i];\n        \n        while (*s) {\n        \n            /* Check if there is a corresponding letter after current position */\n            tmp = searchCharAftIdx(hash[*s - 'a'], len[*s - 'a'], idx);\n\n            if (tmp <= idx) {\n                break;\n            }\n        \n            idx = tmp;\n            s++;\n        }\n\n        if (*s == 0) {\n            cnt++;\n        }\n    }\n     \n    /*\n     * Output:\n     *  return the number of words[i] that is a subsequence of s.\n     */\n     \n    return cnt;\n}\n", "\nstatic int hash[26][50000];\n \nint searchCharAftIdx(int *indices, int len, int idx)\n{\n    int i = 0, j = len - 1, mid;\n\n    /* Search for a index close to and also larger than given idx */\n    idx++;\n\n    while (i < j) { \n    \n        mid = i + (j - i) / 2;\n        \n        if (indices[mid] == idx) {\n            return idx;\n        }\n        else if (indices[mid] < idx) {\n            i = mid + 1;\n        }\n        else {\n            j = mid;\n        }\n    }\n\n    if (i == j && indices[i] >= idx) {\n        return indices[i];\n    }\n    else {\n        return -1;\n    }\n}\n\nint numMatchingSubseq(char * s, char ** words, int wordsSize){\n    /*\n     * Input:\n     *  s, string\n     *  words, string arrays\n     *  wordsSize, number of string arrays\n     */\n     \n    /*\n     * Algorithm:\n     *  Brute + hash\n     *  (1) Store the index of each character to hash table\n     *      hash['a'][len['a']] = index\n     *      len['a']++;\n     *  (2) Loop the words, scan every character and check \n     *      if there is a corresponding character located \n     *      in a position > \"idx\", if so, set \"idx\" to \n     *      the index of last selected character.\n     *  (3) Once all the characters of a word been found,\n     *      set total += 1\n     *\n     *  E.g. s = \"helloworld\",\n     *            0123456789\n     *\n     *  hash['h'] = [0]\n     *  hash['e'] = [1]\n     *  hash['l'] = [2,3,8]\n     *  hash['o'] = [4,6]\n     *  hash['w'] = [5]\n     *  hash['r'] = [7]\n     *  hash['d'] = [9]\n     *\n     *  word = \"lol\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'o' character located after idx 2\n     *      => 'o' @ 4, idx = 4\n     *\n     *  Search 'l' character located after idx 4\n     *      => 'l' @ 8, idx = 8\n     *\n     *  >> Matched <<\n     *\n     *\n     *  word = \"le\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'e' character located after idx 2\n     *      => Not found\n     *\n     *  >> Mismatched <<\n     */\n\n    int len[26] = {0};\n    int idx = 0;\n    int cnt = 0;\n    int tmp;\n    \n    while (*s) {\n        hash[*s - 'a'][len[*s - 'a']] = idx;\n        len[*s - 'a']++;\n        idx++;\n        s++;\n    }\n\n    for (int i = 0; i < wordsSize; i++) {\n    \n        idx = -1;\n        s = words[i];\n        \n        while (*s) {\n        \n            /* Check if there is a corresponding letter after current position */\n            tmp = searchCharAftIdx(hash[*s - 'a'], len[*s - 'a'], idx);\n\n            if (tmp <= idx) {\n                break;\n            }\n        \n            idx = tmp;\n            s++;\n        }\n\n        if (*s == 0) {\n            cnt++;\n        }\n    }\n     \n    /*\n     * Output:\n     *  return the number of words[i] that is a subsequence of s.\n     */\n     \n    return cnt;\n}\n", "\nstatic int hash[26][50000];\n \nint searchCharAftIdx(int *indices, int len, int idx)\n{\n    int i = 0, j = len - 1, mid;\n\n    /* Search for a index close to and also larger than given idx */\n    idx++;\n\n    while (i < j) { \n    \n        mid = i + (j - i) / 2;\n        \n        if (indices[mid] == idx) {\n            return idx;\n        }\n        else if (indices[mid] < idx) {\n            i = mid + 1;\n        }\n        else {\n            j = mid;\n        }\n    }\n\n    if (i == j && indices[i] >= idx) {\n        return indices[i];\n    }\n    else {\n        return -1;\n    }\n}\n\nint numMatchingSubseq(char * s, char ** words, int wordsSize){\n    /*\n     * Input:\n     *  s, string\n     *  words, string arrays\n     *  wordsSize, number of string arrays\n     */\n     \n    /*\n     * Algorithm:\n     *  Brute + hash\n     *  (1) Store the index of each character to hash table\n     *      hash['a'][len['a']] = index\n     *      len['a']++;\n     *  (2) Loop the words, scan every character and check \n     *      if there is a corresponding character located \n     *      in a position > \"idx\", if so, set \"idx\" to \n     *      the index of last selected character.\n     *  (3) Once all the characters of a word been found,\n     *      set total += 1\n     *\n     *  E.g. s = \"helloworld\",\n     *            0123456789\n     *\n     *  hash['h'] = [0]\n     *  hash['e'] = [1]\n     *  hash['l'] = [2,3,8]\n     *  hash['o'] = [4,6]\n     *  hash['w'] = [5]\n     *  hash['r'] = [7]\n     *  hash['d'] = [9]\n     *\n     *  word = \"lol\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'o' character located after idx 2\n     *      => 'o' @ 4, idx = 4\n     *\n     *  Search 'l' character located after idx 4\n     *      => 'l' @ 8, idx = 8\n     *\n     *  >> Matched <<\n     *\n     *\n     *  word = \"le\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'e' character located after idx 2\n     *      => Not found\n     *\n     *  >> Mismatched <<\n     */\n\n    int len[26] = {0};\n    int idx = 0;\n    int cnt = 0;\n    int tmp;\n    \n    while (*s) {\n        hash[*s - 'a'][len[*s - 'a']] = idx;\n        len[*s - 'a']++;\n        idx++;\n        s++;\n    }\n\n    for (int i = 0; i < wordsSize; i++) {\n    \n        idx = -1;\n        s = words[i];\n        \n        while (*s) {\n        \n            /* Check if there is a corresponding letter after current position */\n            tmp = searchCharAftIdx(hash[*s - 'a'], len[*s - 'a'], idx);\n\n            if (tmp <= idx) {\n                break;\n            }\n        \n            idx = tmp;\n            s++;\n        }\n\n        if (*s == 0) {\n            cnt++;\n        }\n    }\n     \n    /*\n     * Output:\n     *  return the number of words[i] that is a subsequence of s.\n     */\n     \n    return cnt;\n}\n"]}
{"id": "957", "ref_c": ["\ninline int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nint max_element(int* arr, int arrSize) {\n    int result = arr[0];\n    for (int i = 1; i < arrSize; i++) {\n        result = max(result, arr[i]);\n    }\n    return result;\n}\nint maximizeSum(int* nums, int numsSize, int k) {\n    // Greedy \n    // if x = max(nums), ans := x + (x + 1) + ... + (x + k - 1)\n    //                       := (x + (x + k - 1)) * k / 2\n    //                       := x*k + (k - 1)*k / 2\n\n    // Time complexity: O(n)\n    // Space comeplxity: O(1)\n\n    const int x = max_element(nums, numsSize);\n    return x*k + (k - 1)*k / 2;\n}\n", "\ninline int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nint max_element(int* arr, int arrSize) {\n    int result = arr[0];\n    for (int i = 1; i < arrSize; i++) {\n        result = max(result, arr[i]);\n    }\n    return result;\n}\nint maximizeSum(int* nums, int numsSize, int k) {\n    // Greedy \n    // if x = max(nums), ans := x + (x + 1) + ... + (x + k - 1)\n    //                       := (x + (x + k - 1)) * k / 2\n    //                       := x*k + (k - 1)*k / 2\n\n    // Time complexity: O(n)\n    // Space comeplxity: O(1)\n\n    const int x = max_element(nums, numsSize);\n    return x*k + (k - 1)*k / 2;\n}\n", "\ninline int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nint max_element(int* arr, int arrSize) {\n    int result = arr[0];\n    for (int i = 1; i < arrSize; i++) {\n        result = max(result, arr[i]);\n    }\n    return result;\n}\nint maximizeSum(int* nums, int numsSize, int k) {\n    // Greedy \n    // if x = max(nums), ans := x + (x + 1) + ... + (x + k - 1)\n    //                       := (x + (x + k - 1)) * k / 2\n    //                       := x*k + (k - 1)*k / 2\n\n    // Time complexity: O(n)\n    // Space comeplxity: O(1)\n\n    const int x = max_element(nums, numsSize);\n    return x*k + (k - 1)*k / 2;\n}\n"]}
{"id": "958", "ref_c": [["int numSubarrayBoundedMax(int* nums, int numsSize, int left, int right){\\n    \\n    int l=0,r=0;\\n    int count=0;\\n    int prev=0;\\n    while (r < numsSize)\\n    {\\n        if (nums[r] >= left && nums[r] <= right)\\n        {\\n            prev = r-l;\\n            count = 1 + count + prev;\\n        }"], ["int numSubarrayBoundedMax(int* nums, int numsSize, int left, int right){\\n    int i, count = 0, l_arr = -1, r_arr = -1, j;\\n    \\n    int *H = (int *)malloc(numsSize*sizeof(int));\\n    \\n    for(i = 0; i < numsSize; i++)\\n    {\\n        if(nums[i] > right)\\n            H[i] = -1;\\n        else if(nums[i] >= left && nums[i] <= right)\\n            H[i] = 1;\\n        else\\n            H[i] = 0;\\n    }"], ["int numSubarrayBoundedMax(int* nums, int numsSize, int left, int right){\\n    int i, count = 0, l_arr = -1, r_arr = -1, j;\\n    \\n    int *H = (int *)malloc(numsSize*sizeof(int));\\n    \\n    for(i = 0; i < numsSize; i++)\\n    {\\n        if(nums[i] > right)\\n            H[i] = -1;\\n        else if(nums[i] >= left && nums[i] <= right)\\n            H[i] = 1;\\n        else\\n            H[i] = 0;\\n    }"]]}
{"id": "959", "ref_c": [["int** allPathsSourceTarget(int** graph, int graphSize, int* graphColSize, int* returnSize, int** returnColumnSizes){\\n    int** paths = (int**)malloc(sizeof(int*) * MAXSIZE);\\n    int* path = (int*)malloc(sizeof(int) * MAXSIZE);\\n    *returnColumnSizes = (int*)malloc(sizeof(int*) * MAXSIZE);\\n\\n    int beg = 0;\\n    int end = graphSize - 1;\\n\\n    int count_path = 0;\\n    int count_paths = 0;\\n    void dfs(int node) {\\n        path[count_path] = node;\\n        count_path++;\\n\\n        if (node == end) {\\n            int* path_new = (int*)malloc(sizeof(int) * count_path);\\n            memmove(path_new, path, sizeof(int) * count_path);\\n\\n            (*returnColumnSizes)[count_paths] = count_path;\\n            paths[count_paths] = path_new;\\n            count_paths++;\\n        }"], ["int** allPathsSourceTarget(int** graph, int graphSize, int* graphColSize, int* returnSize, int** returnColumnSizes){\\n    int ngraph[graphSize][graphSize];\\n    for(int i = 0 ; i < graphSize ; i++)\\n    {\\n        for(int j = 0 ; j < graphSize ; j++)\\n            ngraph[i][j] = 0;\\n    }"], ["int** allPathsSourceTarget(int** graph, int graphSize, int* graphColSize, int* returnSize, int** returnColumnSizes)\\n{\\n    int maxPaths = pow(2, graphSize-1);\\n    int currentPathSize = 0;\\n    int *currentPath = malloc(sizeof(int) * graphSize);\\n    int **paths = malloc(sizeof(int *) * maxPaths);\\n    int *returnColSizes = malloc(sizeof(int) * maxPaths);\\n    *returnSize = 0;\\n\\n    dfs(0, graphSize-1, graph, graphSize, graphColSize, returnSize, returnColSizes, currentPath, currentPathSize, paths);\\n\\n    paths = realloc(paths, sizeof(int *) * (*returnSize));\\n    returnColSizes = realloc(returnColSizes, sizeof(int) * (*returnSize));\\n\\n    *returnColumnSizes = returnColSizes;\\n\\n    return paths;\\n}"]]}
{"id": "960", "ref_c": [["double champagneTower(int poured, int query_row, int query_glass) {\\n        vector<double> currentRow(query_row + 1, 0.0); // Store champagne levels for the current row\\n        currentRow[0] = static_cast<double>(poured);\\n\\n        for (int row = 0; row < query_row; ++row) {\\n            vector<double> nextRow(query_row + 1, 0.0);\\n\\n            for (int glass = 0; glass <= row; ++glass) {\\n                double excess = (currentRow[glass] - 1.0) / 2.0;\\n                if (excess > 0) {\\n                    nextRow[glass] += excess;\\n                    nextRow[glass + 1] += excess;\\n                }"], ["double champagneTower(int poured, int query_row, int query_glass) {\\n        std::vector<std::vector<double>> tower(query_row + 1, std::vector<double>(query_row + 1, 0.0));\\n        tower[0][0] = static_cast<double>(poured);\\n\\n        for (int row = 0; row < query_row; row++) {\\n            for (int glass = 0; glass <= row; glass++) {\\n                double excess = (tower[row][glass] - 1.0) / 2.0;\\n                if (excess > 0) {\\n                    tower[row + 1][glass] += excess;\\n                    tower[row + 1][glass + 1] += excess;\\n                }", "double champagneTower(int poured, int query_row, int query_glass) {\\n        double[][] tower = new double[query_row + 1][query_row + 1];\\n        tower[0][0] = (double) poured;\\n\\n        for (int row = 0; row < query_row; row++) {\\n            for (int glass = 0; glass <= row; glass++) {\\n                double excess = (tower[row][glass] - 1.0) / 2.0;\\n                if (excess > 0) {\\n                    tower[row + 1][glass] += excess;\\n                    tower[row + 1][glass + 1] += excess;\\n                }", "double champagneTower(int poured, int query_row, int query_glass) {\\n    double tower[101][101] = {0}"], ["double champagneTower(int poured, int query_row, int query_glass) {\\n       double result[101][101] = {0.0}"]]}
{"id": "961", "ref_c": ["\nint count;\nbool dfs(int **g, int n, int *sizes, int *label, bool *visited, int curr){\n    if(label[curr] == SAFE)\n        return true;\n    if(label[curr] == UNSAFE || visited[curr] == true)\n        return false;\n\n    visited[curr] = true;\n\n    for(int i = 0; i < sizes[curr]; i++){\n        if(dfs(g, n, sizes, label, visited, g[curr][i]) == false){\n            label[curr] = UNSAFE;\n            return false;\n        }\n    }\n    count++;\n    label[curr] = SAFE;\n    return true;\n}\n\nint* eventualSafeNodes(int** graph, int graphSize, int* graphColSize, int* returnSize) {\n    int *label = calloc(graphSize, sizeof(int));\n    bool *visited = calloc(graphSize, sizeof(int));\n    count = *returnSize = 0;\n\n    for(int i = 0; i < graphSize; i++){\n        if(label[i] == NA){\n            if(dfs(graph, graphSize, graphColSize, label, visited, i))\n                label[i] = SAFE;\n            else\n                label[i] = UNSAFE;\n        }\n        \n    }\n    \n\n    \n    int *result = malloc(sizeof(int) * count);\n    for(int i = 0; i < graphSize; i++){\n        if(label[i] == SAFE){\n            result[(*returnSize)++] = i;\n        }\n    }\n    free(label);\n    free(visited);\n    return result;\n}\n\n", "\nint count;\nbool dfs(int **g, int n, int *sizes, int *label, bool *visited, int curr){\n    if(label[curr] == SAFE)\n        return true;\n    if(label[curr] == UNSAFE || visited[curr] == true)\n        return false;\n\n    visited[curr] = true;\n\n    for(int i = 0; i < sizes[curr]; i++){\n        if(dfs(g, n, sizes, label, visited, g[curr][i]) == false){\n            label[curr] = UNSAFE;\n            return false;\n        }\n    }\n    count++;\n    label[curr] = SAFE;\n    return true;\n}\n\nint* eventualSafeNodes(int** graph, int graphSize, int* graphColSize, int* returnSize) {\n    int *label = calloc(graphSize, sizeof(int));\n    bool *visited = calloc(graphSize, sizeof(int));\n    count = *returnSize = 0;\n\n    for(int i = 0; i < graphSize; i++){\n        if(label[i] == NA){\n            if(dfs(graph, graphSize, graphColSize, label, visited, i))\n                label[i] = SAFE;\n            else\n                label[i] = UNSAFE;\n        }\n        \n    }\n    \n\n    \n    int *result = malloc(sizeof(int) * count);\n    for(int i = 0; i < graphSize; i++){\n        if(label[i] == SAFE){\n            result[(*returnSize)++] = i;\n        }\n    }\n    free(label);\n    free(visited);\n    return result;\n}\n\n", "\nint count;\nbool dfs(int **g, int n, int *sizes, int *label, bool *visited, int curr){\n    if(label[curr] == SAFE)\n        return true;\n    if(label[curr] == UNSAFE || visited[curr] == true)\n        return false;\n\n    visited[curr] = true;\n\n    for(int i = 0; i < sizes[curr]; i++){\n        if(dfs(g, n, sizes, label, visited, g[curr][i]) == false){\n            label[curr] = UNSAFE;\n            return false;\n        }\n    }\n    count++;\n    label[curr] = SAFE;\n    return true;\n}\n\nint* eventualSafeNodes(int** graph, int graphSize, int* graphColSize, int* returnSize) {\n    int *label = calloc(graphSize, sizeof(int));\n    bool *visited = calloc(graphSize, sizeof(int));\n    count = *returnSize = 0;\n\n    for(int i = 0; i < graphSize; i++){\n        if(label[i] == NA){\n            if(dfs(graph, graphSize, graphColSize, label, visited, i))\n                label[i] = SAFE;\n            else\n                label[i] = UNSAFE;\n        }\n        \n    }\n    \n\n    \n    int *result = malloc(sizeof(int) * count);\n    for(int i = 0; i < graphSize; i++){\n        if(label[i] == SAFE){\n            result[(*returnSize)++] = i;\n        }\n    }\n    free(label);\n    free(visited);\n    return result;\n}\n\n"]}
{"id": "962", "ref_c": [["int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize){\\n    int heightInc=0;\\n    int *row_max = (int *)malloc(gridSize*sizeof(int));\\n    int *col_max = (int *)malloc(gridSize*sizeof(int));\\n    for(int i=0; i<gridSize; i++){\\n        int max_row=0;\\n        int max_col=0;\\n        for(int j=0; j<gridSize; j++){\\n            max_row= max(max_row, grid[i][j]);\\n            max_col = max(max_col, grid[j][i]);\\n        }"], ["int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize) {\\n    int rowMax[gridSize];\\n    int colMax[gridSize];\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        rowMax[i] = colMax[i] = 0;\\n        for (int j = 0; j < gridSize; j++) {\\n            if (grid[i][j] > rowMax[i]) {\\n                rowMax[i] = grid[i][j];\\n            }"], ["int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize) {\\n    int rowMax[gridSize];\\n    int colMax[gridSize];\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        rowMax[i] = colMax[i] = 0;\\n        for (int j = 0; j < gridSize; j++) {\\n            if (grid[i][j] > rowMax[i]) {\\n                rowMax[i] = grid[i][j];\\n            }"]]}
{"id": "963", "ref_c": [["double soupServings(int n){\\n  if (n >= 4451) //n asymptotically approaches 1, so return 1 if n is large\\n    // enough for 1 to be within the threshold of acceptance. This threshold can\\n    // easily be found by running the program and finding the first output\\n    // exceeding 0.99999; it happens to be 4451.\\n    return 1;\\n  n = (n + 24) / 25; // Divide n by 25, rounding up; optimizes compressed cache\\n  return soupServingsHelper(n, n);\\n}"], ["double soupServings(int n){\\n  if (n >= 4451) //n asymptotically approaches 1, so return 1 if n is large\\n    // enough for 1 to be within the threshold of acceptance. This threshold can\\n    // easily be found by running the program and finding the first output\\n    // exceeding 0.99999; it happens to be 4451.\\n    return 1;\\n  return soupServingsHelper(n, n);\\n}", "double soupServings(int n){\\n  if (n >= 4451) //n asymptotically approaches 1, so return 1 if n is large\\n    // enough for 1 to be within the threshold of acceptance. This threshold can\\n    // easily be found by running the program and finding the first output\\n    // exceeding 0.99999; it happens to be 4451.\\n    return 1;\\n  n = (n + 24) / 25; // Divide n by 25, rounding up; optimizes compressed cache\\n  return soupServingsHelper(n, n);\\n}"], ["double soupServings(int n){\\n  if (n >= 4451) //n asymptotically approaches 1, so return 1 if n is large\\n    // enough for 1 to be within the threshold of acceptance. This threshold can\\n    // easily be found by running the program and finding the first output\\n    // exceeding 0.99999; it happens to be 4451.\\n    return 1;\\n  return soupServingsHelper(n, n);\\n}", "double soupServings(int n){\\n  if (n >= 4451) //n asymptotically approaches 1, so return 1 if n is large\\n    // enough for 1 to be within the threshold of acceptance. This threshold can\\n    // easily be found by running the program and finding the first output\\n    // exceeding 0.99999; it happens to be 4451.\\n    return 1;\\n  n = (n + 24) / 25; // Divide n by 25, rounding up; optimizes compressed cache\\n  return soupServingsHelper(n, n);\\n}"]]}
{"id": "964", "ref_c": [["int expressiveWords(char * s, char ** words, int wordsSize){\\n    int output=0;\\n    for (int i=0;i<wordsSize;i++){\\n        if (s[0]!=words[i][0]) continue;\\n        int sInd=1;\\n        int wInd=1;\\n        while(s[sInd]){\\n            if (s[sInd]==words[i][wInd]){\\n                sInd++;\\n                wInd++;\\n            }"], ["int expressiveWords(char * s, char ** words, int wordsSize){\\n    char *wp, *sp;\\n    int s_len = 0, w_len, count = 0, i, j;\\n\\n    for (i=0;i<wordsSize;i++) {\\n        sp = s;\\n        wp = words[i];\\n\\n        while (*wp && *sp) {\\n\\n            // match current char\\n            if (*wp != *sp) break;\\n\\n            // calc current char len in word\\n            w_len = 0;\\n            while(*(wp + w_len) && *(wp + w_len) == *(wp + w_len+1)) {\\n                w_len++;\\n            }"], ["int expressiveWords(char * s, char ** words, int wordsSize){\\n    char *wp, *sp;\\n    int s_len = 0, w_len, count = 0, i, j;\\n\\n    for (i=0;i<wordsSize;i++) {\\n        sp = s;\\n        wp = words[i];\\n\\n        while (*wp && *sp) {\\n\\n            // match current char\\n            if (*wp != *sp) break;\\n\\n            // calc current char len in word\\n            w_len = 0;\\n            while(*(wp + w_len) && *(wp + w_len) == *(wp + w_len+1)) {\\n                w_len++;\\n            }"]]}
{"id": "965", "ref_c": ["\ntypedef struct{\n    char domain[STRLENTH];\n    int count;\n    UT_hash_handle hh;\n}my_hash;\n\nvoid add_domain(my_hash **webs,char name[STRLENTH],int num)\n{\n    my_hash *s;\n    HASH_FIND_STR(*webs,name,s);\n    if (s!=NULL)\n    {\n        s->count+=num;\n    }\n    else\n    {\n        s=malloc(sizeof(my_hash));\n        s->count=num;\n        strcpy(s->domain,name);\n        HASH_ADD_STR(*webs,domain,s);\n    }\n} \n\nchar** subdomainVisits(char** cpdomains, int cpdomainsSize, int* returnSize) {\n    my_hash *webs=NULL;\n    my_hash *s,*tmp;\n    int i,j,l,c,d,num;\n    char cut[STRLENTH]=\"\";\n    char **result;\n    for (i=0;i<cpdomainsSize;i++)\n    {\n        l=strlen(cpdomains[i]);\n        c=0;\n        j=0;\n        while (cpdomains[i][j]!='\u0000')\n        {\n            if ((cpdomains[i][j]==' ')&&(c==0))\n            {\n                c=j;\n                memcpy(cut,cpdomains[i],c);\n                num=atoi(cut);\n                d=j+1;\n                memcpy(cut,cpdomains[i]+d,l-d+1);\n                add_domain(&webs,cut,num);\n            }\n            if (cpdomains[i][j]=='.')\n            {\n                d=j+1;\n                memcpy(cut,cpdomains[i]+d,l-d+1);\n                add_domain(&webs,cut,num);\n            }\n            j++;\n        }\n    }\n    result=(char**)malloc(sizeof(char*)*cpdomainsSize*3);\n    for (i=0;i<cpdomainsSize*3;i++)\n        result[i]=(char*)malloc(sizeof(char)*STRLENTH);  \n    i=0;\n    HASH_ITER(hh,webs,s,tmp)\n    {\n        sprintf(cut,\"%d %s\",s->count,s->domain);\n        strcpy(result[i],cut);\n        i++;\n    }\n    *returnSize=i;\n    return result;\n}\n", "\ntypedef struct{\n    char domain[STRLENTH];\n    int count;\n    UT_hash_handle hh;\n}my_hash;\n\nvoid add_domain(my_hash **webs,char name[STRLENTH],int num)\n{\n    my_hash *s;\n    HASH_FIND_STR(*webs,name,s);\n    if (s!=NULL)\n    {\n        s->count+=num;\n    }\n    else\n    {\n        s=malloc(sizeof(my_hash));\n        s->count=num;\n        strcpy(s->domain,name);\n        HASH_ADD_STR(*webs,domain,s);\n    }\n} \n\nchar** subdomainVisits(char** cpdomains, int cpdomainsSize, int* returnSize) {\n    my_hash *webs=NULL;\n    my_hash *s,*tmp;\n    int i,j,l,c,d,num;\n    char cut[STRLENTH]=\"\";\n    char **result;\n    for (i=0;i<cpdomainsSize;i++)\n    {\n        l=strlen(cpdomains[i]);\n        c=0;\n        j=0;\n        while (cpdomains[i][j]!='\u0000')\n        {\n            if ((cpdomains[i][j]==' ')&&(c==0))\n            {\n                c=j;\n                memcpy(cut,cpdomains[i],c);\n                num=atoi(cut);\n                d=j+1;\n                memcpy(cut,cpdomains[i]+d,l-d+1);\n                add_domain(&webs,cut,num);\n            }\n            if (cpdomains[i][j]=='.')\n            {\n                d=j+1;\n                memcpy(cut,cpdomains[i]+d,l-d+1);\n                add_domain(&webs,cut,num);\n            }\n            j++;\n        }\n    }\n    result=(char**)malloc(sizeof(char*)*cpdomainsSize*3);\n    for (i=0;i<cpdomainsSize*3;i++)\n        result[i]=(char*)malloc(sizeof(char)*STRLENTH);  \n    i=0;\n    HASH_ITER(hh,webs,s,tmp)\n    {\n        sprintf(cut,\"%d %s\",s->count,s->domain);\n        strcpy(result[i],cut);\n        i++;\n    }\n    *returnSize=i;\n    return result;\n}\n", "\ntypedef struct{\n    char domain[STRLENTH];\n    int count;\n    UT_hash_handle hh;\n}my_hash;\n\nvoid add_domain(my_hash **webs,char name[STRLENTH],int num)\n{\n    my_hash *s;\n    HASH_FIND_STR(*webs,name,s);\n    if (s!=NULL)\n    {\n        s->count+=num;\n    }\n    else\n    {\n        s=malloc(sizeof(my_hash));\n        s->count=num;\n        strcpy(s->domain,name);\n        HASH_ADD_STR(*webs,domain,s);\n    }\n} \n\nchar** subdomainVisits(char** cpdomains, int cpdomainsSize, int* returnSize) {\n    my_hash *webs=NULL;\n    my_hash *s,*tmp;\n    int i,j,l,c,d,num;\n    char cut[STRLENTH]=\"\";\n    char **result;\n    for (i=0;i<cpdomainsSize;i++)\n    {\n        l=strlen(cpdomains[i]);\n        c=0;\n        j=0;\n        while (cpdomains[i][j]!='\u0000')\n        {\n            if ((cpdomains[i][j]==' ')&&(c==0))\n            {\n                c=j;\n                memcpy(cut,cpdomains[i],c);\n                num=atoi(cut);\n                d=j+1;\n                memcpy(cut,cpdomains[i]+d,l-d+1);\n                add_domain(&webs,cut,num);\n            }\n            if (cpdomains[i][j]=='.')\n            {\n                d=j+1;\n                memcpy(cut,cpdomains[i]+d,l-d+1);\n                add_domain(&webs,cut,num);\n            }\n            j++;\n        }\n    }\n    result=(char**)malloc(sizeof(char*)*cpdomainsSize*3);\n    for (i=0;i<cpdomainsSize*3;i++)\n        result[i]=(char*)malloc(sizeof(char)*STRLENTH);  \n    i=0;\n    HASH_ITER(hh,webs,s,tmp)\n    {\n        sprintf(cut,\"%d %s\",s->count,s->domain);\n        strcpy(result[i],cut);\n        i++;\n    }\n    *returnSize=i;\n    return result;\n}\n"]}
{"id": "966", "ref_c": ["\nint evalRPN(char **tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 + temp1;\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 - temp1;\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 * temp1;\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            \n            stack[top] = temp2 / temp1;\n        } else {\n            top++;\n            stack[top] = atoi(tokens[i]);\n        }\n    }\n\n    return stack[top];\n}\n", "\nint evalRPN(char **tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 + temp1;\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 - temp1;\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 * temp1;\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            \n            stack[top] = temp2 / temp1;\n        } else {\n            top++;\n            stack[top] = atoi(tokens[i]);\n        }\n    }\n\n    return stack[top];\n}\n", "\nint evalRPN(char **tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 + temp1;\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 - temp1;\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 * temp1;\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            \n            stack[top] = temp2 / temp1;\n        } else {\n            top++;\n            stack[top] = atoi(tokens[i]);\n        }\n    }\n\n    return stack[top];\n}\n"]}
{"id": "967", "ref_c": [["struct TreeNode* pruneTree(struct TreeNode* root){\\n\\n    inorder(root);\\n\\n    return root;\\n}"], ["struct TreeNode* pruneTree(struct TreeNode* root) {\\n    return (hasOneNode(root) == true) ? root : NULL;\\n}"], ["struct TreeNode* pruneTree(struct TreeNode* root){\\n    if(root == NULL) return NULL;\\n    root->left = pruneTree(root->left);\\n    root->right = pruneTree(root->right);\\n    if(!itHasOne(root)){\\n        free(root->left);\\n        free(root->right);\\n        free(root);\\n        return NULL;\\n    }"]]}
{"id": "968", "ref_c": [["char * toGoatLatin(char * sentence){\\n    \\n    char *counter = sentence;\\n    int word_nums = 0;\\n    int sentence_length = strlen(sentence);\\n    while( *sentence != \\'\\\\0\\')\\n    {\\n        if (*sentence == \\' \\')\\n        {\\n            word_nums++;    \\n        }"], ["char * toGoatLatin(char * sentence){\\n    \\n    char *counter = sentence;\\n    int word_nums = 0;\\n    int sentence_length = strlen(sentence);\\n    while( *sentence != \\'\\\\0\\')\\n    {\\n        if (*sentence == \\' \\')\\n        {\\n            word_nums++;    \\n        }"], ["char * toGoatLatin(char * sentence){\\n    \\n    int sLen = strlen(sentence);\\n    \\n    char *p = sentence;\\n    \\n    char ma_string[] = {\\'m\\', \\'a\\', \\'\\\\0\\'}"]]}
{"id": "969", "ref_c": [["int numComponents(struct ListNode* head, int* nums, int numsSize){\\n    int total = 0, stop = 0;\\n  struct ListNode *tmp = NULL, *ptr = NULL;\\n  int visited[numsSize], last = 0;\\n  memset(visited, 0, sizeof(visited));\\n  tmp = head;\\n\\n    while(tmp != NULL)\\n    {\\n      for(int i = 0;i <numsSize; i++)\\n      {\\n        if((tmp->val == nums[i]) && visited[i] != 1)\\n        {\\n          if((ptr != NULL ) && (ptr->val == nums[last]))\\n          {\\n              total = total;\\n          }"], ["int numComponents(struct ListNode* head, int* nums, int numsSize){\\n\\n  int total = 0, stop = 0;\\n  struct ListNode *tmp = NULL, *ptr = NULL;\\n  int visited[numsSize], last = 0;\\n  memset(visited, 0, sizeof(visited));\\n  tmp = head;\\n\\n    while(tmp != NULL)\\n    {\\n      for(int i = 0;i <numsSize; i++)\\n      {\\n        if((tmp->val == nums[i]) && visited[i] != 1)\\n        {\\n          if((ptr != NULL ) && (ptr->val == nums[last]))\\n          {\\n              total = total;\\n          }"], ["int numComponents(struct ListNode* head, int* nums, int numsSize)\\n{\\n    // 1.5\\n    int result = 0;\\n    int prev_node_seen, current_node_seen;\\n\\n    // 2\\n    struct ListNode* c, *p, *sen = create_node (-1);\\n    sen->next = head;\\n\\n    memset (HT, 0, sizeof(struct ListNode*) * HSIZE);\\n\\n    // 1\\n    for (int i = 0; i < numsSize; i++)\\n        save (nums[i]);\\n\\n    p = sen;\\n    c = sen->next;\\n\\n    prev_node_seen = 0;\\n    // 3\\n    while (c)\\n    {\\n        current_node_seen = is_seen (c->val);\\n        // 3. b\\n        if (!prev_node_seen && current_node_seen)\\n            result++;\\n        prev_node_seen = current_node_seen;\\n        p = c;\\n        c = c->next;\\n    }"]]}
{"id": "970", "ref_c": [["int minimumLengthEncoding(char ** words, int wordsSize)\\n{\\n    reverse(words, wordsSize);\\n    qsort(words, wordsSize, sizeof(char*), cmp);   \\n    int sum = 0;\\n    for (int i = 0; i < wordsSize - 1; i++) {\\n        size_t cur_len = strlen(words[i]); \\n        bool match = 1;\\n        for (int j = 0; j < cur_len; j++) {\\n            if (words[i][j] != words[i+1][j]) {\\n                match = 0;\\n                break;\\n            }"], ["int minimumLengthEncoding(char ** words, int wordsSize)\\n{\\n    reverse(words, wordsSize);\\n    qsort(words, wordsSize, sizeof(char*), cmp);   \\n    int sum = 0;\\n    for (int i = 0; i < wordsSize - 1; i++) {\\n        size_t cur_len = strlen(words[i]); \\n        bool match = 1;\\n        for (int j = 0; j < cur_len; j++) {\\n            if (words[i][j] != words[i+1][j]) {\\n                match = 0;\\n                break;\\n            }"], ["int minimumLengthEncoding(char ** words, int wordsSize)\\n{\\n    reverse(words, wordsSize);\\n    qsort(words, wordsSize, sizeof(char*), cmp);   \\n    int sum = 0;\\n    for (int i = 0; i < wordsSize - 1; i++) {\\n        size_t cur_len = strlen(words[i]); \\n        bool match = 1;\\n        for (int j = 0; j < cur_len; j++) {\\n            if (words[i][j] != words[i+1][j]) {\\n                match = 0;\\n                break;\\n            }"]]}
{"id": "971", "ref_c": [["int flipgame(int* fronts, int frontsSize, int* backs, int backsSize) {\\n    // Hashtable \\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    int result = 2001;\\n    bool* same = (bool*)calloc(2000, sizeof(bool));\\n\\n    for (int i = 0; i < frontsSize; i++) {\\n        if (fronts[i] != backs[i]) continue;\\n        same[fronts[i]] = true;\\n    }"], ["int flipgame(int* fronts, int frontsSize, int* backs, int backsSize) {\\n    // Hashtable \\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    int result = 2001;\\n    bool* same = (bool*)calloc(2000, sizeof(bool));\\n\\n    for (int i = 0; i < frontsSize; i++) {\\n        if (fronts[i] != backs[i]) continue;\\n        same[fronts[i]] = true;\\n    }"], ["int flipgame(int* fronts, int frontsSize, int* backs, int backsSize) {\\n    // Hashtable \\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    int result = 2001;\\n    bool* same = (bool*)calloc(2000, sizeof(bool));\\n\\n    for (int i = 0; i < frontsSize; i++) {\\n        if (fronts[i] != backs[i]) continue;\\n        same[fronts[i]] = true;\\n    }"]]}
{"id": "972", "ref_c": [["int numFactoredBinaryTrees(int* arr, int arrSize) {\\n    long mod = (long)pow(10, 9) + 7; // Define a modulo value to prevent integer overflow.\\n    \\n    // Create an array of key-value pairs to store the count of factored binary trees for each number.\\n    KeyValuePair* mp = (KeyValuePair*)malloc(arrSize * sizeof(KeyValuePair));\\n    \\n    // Sort the input array in ascending order.\\n    qsort(arr, arrSize, sizeof(int), compare);\\n    \\n    // Initialize the count for the first element in the array.\\n    mp[0].key = arr[0];\\n    mp[0].value = 1;\\n    \\n    // Loop through the input array starting from the second element.\\n    for (int i = 1; i < arrSize; i++) {\\n        long cnt = 1; // Initialize the count for the current element.\\n        \\n        // Iterate through the elements in the map.\\n        for (int j = 0; j < i; j++) {\\n            int el = mp[j].key; // Get an element from the map.\\n            \\n            // Check if the current element in the array is divisible by the map element\\n            // and if the resulting factor is also present in the map.\\n            if (arr[i] % el == 0) {\\n                int factor = arr[i] / el;\\n                for (int k = 0; k < i; k++) {\\n                    if (mp[k].key == factor) {\\n                        // Calculate the count for the current element by multiplying counts of factors.\\n                        cnt += mp[j].value * mp[k].value;\\n                        break;\\n                    }", "int numFactoredBinaryTrees(int* arr, int arrSize) {\\n    qsort(arr, arrSize, sizeof(int), compare);\\n    int s[arrSize];\\n    for (int i = 0; i < arrSize; i++) {\\n        s[i] = arr[i];\\n    }"], ["int numFactoredBinaryTrees(int* arr, int arrSize) {\\n    // DP method\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n)\\n\\n    const long long mod = 1e9 + 7;\\n    long long result = 0LL;\\n\\n    qsort(arr, arrSize, sizeof(int), ascend);\\n\\n    dp = NULL;\\n    for (int i = 0; i < arrSize; ++i) {\\n        insert(arr[i], 1);\\n        for (int j = 0; j < i; ++j) {\\n            if (arr[i] % arr[j] != 0) continue;\\n            struct HashTable* it_i_div_j = find(arr[i] / arr[j]);\\n            if (it_i_div_j == NULL) continue;\\n            struct HashTable* it_i = find(arr[i]), *it_j = find(arr[j]);\\n            insert(arr[i], (it_i->val + it_j->val * it_i_div_j->val) % mod);\\n        }"], ["int numFactoredBinaryTrees(int* arr, int arrSize){\\n    int result = 0, mod = pow(10, 9) + 7;\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    long dp[arrSize];\\n    for(int i = 0; i < arrSize; i++) \\n        dp[i] = 1;\\n    for(int i = 0; i < arrSize; i++) \\n    {\\n\\t\\tint left = 0, right = i - 1;\\n\\t\\twhile (left <= right) \\n        {\\n\\t\\t\\tif((long)arr[left] * arr[right] > arr[i])\\n\\t\\t\\t\\tright--;\\n\\t\\t\\telse if ((long)arr[left] * arr[right] < arr[i])\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tif (left == right)\\n\\t\\t\\t\\t\\tdp[i] += (dp[left] * dp[right]);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i] += 2 * (dp[left] * dp[right]);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}"]]}
{"id": "973", "ref_c": [["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if((n - 1) % 3 == 0){\\n\\n\\n        return true; \\n        }", "bool isPowerOfFour(int n) {\\n    if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if ((n - 1) % 3 == 0) {\\n            return true;\\n        }", "bool isPowerOfFour(int n) {\\n       return n>0 && (n&(n-1))==0 && (n % 10 ==1|| n% 10==4|| n%10==6);\\n    }", "bool isPowerOfFour(int n) {\\n    return n > 0 && (n & (n - 1)) == 0 && (n % 10 == 1 || n % 10 == 4 || n % 10 == 6);\\n}"], ["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the logarithm of \\'n\\' with base 4\\n        double logarithmBase4 = log(n) / log(4);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (logarithmBase4 == (int)logarithmBase4);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the logarithm of \\'n\\' with base 4\\n    double logarithmBase4 = log(n) / log(4);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (logarithmBase4 == (int)logarithmBase4);\\n}", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the square root of \\'n\\'\\n        double sqrtN = sqrt(n);\\n\\n        // Take the logarithm base 2 of the square root\\n        double log2SqrtN = log2(sqrtN);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (log2SqrtN == (int)log2SqrtN);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the square root of \\'n\\'\\n    double sqrtN = sqrt(n);\\n\\n    // Take the logarithm base 2 of the square root\\n    double log2SqrtN = log2(sqrtN);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (log2SqrtN == (int)log2SqrtN);\\n}"], ["bool isPowerOfFour(int n){\\n\\n    if(n==1)\\n        return true;\\n    return (n&0x55555554) && !(n&n-1);\\n}"]]}
{"id": "974", "ref_c": [["int semiOrderedPermutation(int* nums, int numsSize){\\n\\n    int times=0;\\n\\n    static int i=0,j=0;\\n\\n    int idx=0;\\n    int tmp=0;\\n    for (i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==1)idx=i;\\n    }"], ["int semiOrderedPermutation(int* nums, int numsSize) {\\n    if (nums[0] == 1 && nums[numsSize-1] == numsSize) return 0;\\n    int ss = -1, ee = -1;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == 1) {\\n            ss = i;\\n        }"], ["int semiOrderedPermutation(int* nums, int numsSize) {\\n    if (nums[0] == 1 && nums[numsSize-1] == numsSize) return 0;\\n    int ss = -1, ee = -1;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == 1) {\\n            ss = i;\\n        }"]]}
{"id": "975", "ref_c": [["int findSecondMinimumValue(struct TreeNode* root){\\n    if(root->left == NULL && root->right == NULL)\\n        return -1;\\n    int*array = malloc(sizeof(int)*26);\\n    int index = 0;\\n    inorder(&array,&index,root);\\n    array = realloc(array,sizeof(int)*index);\\n    qsort(array,index,sizeof(int),f);\\n    int max = array[0];\\n    int p = 1;\\n    while(p < index && array[p] == max)\\n        p++;\\n    if(p >= index)\\n        return -1;\\n    return array[p];\\n}"], ["int findSecondMinimumValue(struct TreeNode* root){\\n    if(root->left == NULL && root->right == NULL)\\n        return -1;\\n    int*array = malloc(sizeof(int)*26);\\n    int index = 0;\\n    inorder(&array,&index,root);\\n    array = realloc(array,sizeof(int)*index);\\n    qsort(array,index,sizeof(int),f);\\n    int max = array[0];\\n    int p = 1;\\n    while(p < index && array[p] == max)\\n        p++;\\n    if(p >= index)\\n        return -1;\\n    return array[p];\\n}"], ["int findSecondMinimumValue(struct TreeNode* root){\\n\\tassert(root != NULL);\\n\\n\\tconst int min = root->val;\\n\\n\\tbool secondMinExist = false;\\n\\tint secondMin = INT_MAX;\\n\\n\\tstruct TreeNode * bfsQueue[MAX_NODE];\\n\\tint first = 0, nextOfLast = 0;\\n\\n\\tbfsQueue[nextOfLast] = root;\\n\\tnextOfLast += 1;\\n\\n\\tdo {\\n\\t\\tstruct TreeNode * const pCur = bfsQueue[first];\\n\\t\\tfirst += 1;\\n\\n\\t\\tif (pCur->val == min){\\n\\t\\t\\tif (pCur->left != NULL){\\n\\t\\t\\t\\tbfsQueue[nextOfLast] = pCur->left;\\n\\t\\t\\t\\tnextOfLast += 1;\\n\\t\\t\\t}"]]}
{"id": "976", "ref_c": [["char * findReplaceString(char * s, int* indices, int indicesSize, char ** sources, int sourcesSize, char ** targets, int targetsSize){\\n    int len = strlen(s), indiceIdx = 0, ansIdx = 0, idx = 0;\\n    char* ans = (char*)calloc(5000, sizeof(char));\\n    /* mapping if indices not in order */\\n    int* mapping = (int*)calloc(len+1, sizeof(int));\\n    for(int i = 0; i < indicesSize; i++)\\n        mapping[indices[i]] = i+1;\\n    while(idx < len)\\n    {\\n        if(indiceIdx < indicesSize && mapping[idx]){\\n            int mapIdx = mapping[idx] - 1;\\n            int currLen = strlen(sources[mapIdx]);\\n            if(strncmp(s+idx, sources[mapIdx], currLen)==0)\\n            {\\n                int targetLen = strlen(targets[mapIdx]);\\n                memcpy(ans+ansIdx, targets[mapIdx], targetLen);\\n                ansIdx += targetLen;\\n                idx += currLen;\\n            }"], ["char * findReplaceString(char * s, int* indices, int indicesSize, char ** sources, int sourcesSize, char ** targets, int targetsSize){\\n    int len = strlen(s), indiceIdx = 0, ansIdx = 0, idx = 0;\\n    char* ans = (char*)calloc(5000, sizeof(char));\\n    /* mapping if indices not in order */\\n    int* mapping = (int*)calloc(len+1, sizeof(int));\\n    for(int i = 0; i < indicesSize; i++)\\n        mapping[indices[i]] = i+1;\\n    while(idx < len)\\n    {\\n        if(indiceIdx < indicesSize && mapping[idx]){\\n            int mapIdx = mapping[idx] - 1;\\n            int currLen = strlen(sources[mapIdx]);\\n            if(strncmp(s+idx, sources[mapIdx], currLen)==0)\\n            {\\n                int targetLen = strlen(targets[mapIdx]);\\n                memcpy(ans+ansIdx, targets[mapIdx], targetLen);\\n                ansIdx += targetLen;\\n                idx += currLen;\\n            }"], ["char * findReplaceString(char * s, int* indices, int indicesSize, char ** sources, int sourcesSize, char ** targets, int targetsSize){\\n    int len = strlen(s), indiceIdx = 0, ansIdx = 0, idx = 0;\\n    char* ans = (char*)calloc(5000, sizeof(char));\\n    /* mapping if indices not in order */\\n    int* mapping = (int*)calloc(len+1, sizeof(int));\\n    for(int i = 0; i < indicesSize; i++)\\n        mapping[indices[i]] = i+1;\\n    while(idx < len)\\n    {\\n        if(indiceIdx < indicesSize && mapping[idx]){\\n            int mapIdx = mapping[idx] - 1;\\n            int currLen = strlen(sources[mapIdx]);\\n            if(strncmp(s+idx, sources[mapIdx], currLen)==0)\\n            {\\n                int targetLen = strlen(targets[mapIdx]);\\n                memcpy(ans+ansIdx, targets[mapIdx], targetLen);\\n                ansIdx += targetLen;\\n                idx += currLen;\\n            }"]]}
{"id": "977", "ref_c": [["int largestOverlap(int** img1, int img1Size, int* img1ColSize, int** img2, int img2Size, int* img2ColSize) {\\n\\tint rows = img1Size;\\n\\tint cols = *img1ColSize;\\n\\tint32_t* const buf = calloc(rows * 2, sizeof(int32_t));\\n\\tint32_t* i1 = buf;\\n\\tint32_t* i2 = i1 + rows;\\n\\n\\t/* Turn each row of each image into a 32bit number */\\n\\tfor (int r = 0; r < rows; ++r) {\\n\\t\\tfor (int c = 0; c < cols; ++c) {\\n\\t\\t\\ti1[r] = (i1[r] << 1) + img1[r][c];\\n\\t\\t\\ti2[r] = (i2[r] << 1) + img2[r][c];\\n\\t\\t}"], ["int largestOverlap(int** img1, int img1Size, int* img1ColSize, int** img2, int img2Size, int* img2ColSize){\\n    int n = img1Size;\\n    int mx = 0;\\n    int start = 1-n;\\n    int end = n;\\n    int chk;\\n    for(int dx = start; dx < end; dx++){\\n        for(int dy = start; dy < end; dy++){\\n            chk = checkOverlap(dx,dy,img1,img2,n);\\n            if(chk > mx) mx = chk;\\n        }"], ["int largestOverlap(int** img1, int img1Size, int* img1ColSize, int** img2, int img2Size, int* img2ColSize){\\n    int n = img1Size;\\n    int mx = 0;\\n    int start = 1-n;\\n    int end = n;\\n    int chk;\\n    for(int dx = start; dx < end; dx++){\\n        for(int dy = start; dy < end; dy++){\\n            chk = checkOverlap(dx,dy,img1,img2,n);\\n            if(chk > mx) mx = chk;\\n        }"]]}
{"id": "978", "ref_c": [["double new21Game(int n, int k, int maxPts) {\\n    if (k == 0 || n >= k + maxPts)\\n        return 1.0;\\n    double dp[n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0] = 1.0;\\n    double sum = 1.0;\\n    double result = 0.0;\\n    for (int i = 1; i <= n; i++) {\\n        dp[i] = sum / maxPts;\\n        if (i < k)\\n            sum += dp[i];\\n        else\\n            result += dp[i];\\n        if (i - maxPts >= 0)\\n            sum -= dp[i - maxPts];\\n    }"], ["double new21Game(int n, int k, int maxPts) {\\n    if (k == 0 || n >= k + maxPts)\\n        return 1.0;\\n    double dp[n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0] = 1.0;\\n    double sum = 1.0;\\n    double result = 0.0;\\n    for (int i = 1; i <= n; i++) {\\n        dp[i] = sum / maxPts;\\n        if (i < k)\\n            sum += dp[i];\\n        else\\n            result += dp[i];\\n        if (i - maxPts >= 0)\\n            sum -= dp[i - maxPts];\\n    }"], ["double new21Game(int n, int k, int maxPts) {\\n    if (k == 0 || n >= k + maxPts)\\n        return 1.0;\\n    double dp[n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0] = 1.0;\\n    double sum = 1.0;\\n    double result = 0.0;\\n    for (int i = 1; i <= n; i++) {\\n        dp[i] = sum / maxPts;\\n        if (i < k)\\n            sum += dp[i];\\n        else\\n            result += dp[i];\\n        if (i - maxPts >= 0)\\n            sum -= dp[i - maxPts];\\n    }"]]}
{"id": "979", "ref_c": [["char * pushDominoes(char * dominoes) {\\n\\tsize_t len = strlen(dominoes);\\n\\tchar* const ret = malloc(len + 1);\\n\\tret[len] = \\'\\\\0\\';\\n\\n\\tint left = 0;\\n\\twhile (left < len) {\\n\\t\\t/* Find the next interesting action */\\n\\t\\tint right = left + 1;\\n\\t\\twhile (right < len && \\'.\\' == dominoes[right]) {\\n\\t\\t\\t++right;\\n\\t\\t}"], ["char * pushDominoes(char * dominoes){\\n    int i = 0,start,end,len = strlen(dominoes);\\n    while(i < len){\\n        if(dominoes[i] != \\'.\\'){\\n            i++;\\n        }"], ["char * pushDominoes(char * dominoes){\\n    int len = strlen(dominoes);\\n    int* dp = (int*)calloc(len, sizeof(int));    \\n    int currVal = 0;\\n    /* process R */\\n    for(int i = 0; i < len; i++){\\n        if(dominoes[i]==\\'.\\' && currVal){\\n            --currVal;\\n        }"]]}
{"id": "980", "ref_c": [["int numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0}"], ["int numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int rlen = gridSize, clen = *gridColSize, ans = 0;\\n    if(rlen < 3 || clen < 3) return 0;\\n    for(int i = 1; i < rlen - 1; i++){\\n        for(int j = 1; j < clen - 1; j++){\\n            if(grid[i][j] != 5)\\n                continue;\\n            if(isMagic(grid, i-1, j-1))\\n                ans++;\\n        }"], ["int numMagicSquaresInside(int** grid, int gridSize, int* gridColSize){\\n    int count = 0;\\n    for (int i = 0; i < gridSize - 2; i++) {\\n        for (int j = 0; j < gridColSize[0] - 2; j++) {\\n            int sum = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];\\n            if (grid[i + 1][j] + grid[i + 1][j + 1] + grid[i + 1][j + 2] == sum &&\\n                grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j] + grid[i + 2][j] == sum &&\\n                grid[i][j + 1] + grid[i + 1][j + 1] + grid[i + 2][j + 1] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 2] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j] + grid[i + 1][j + 1] + grid[i + 2][j + 2] == sum &&\\n                grid[i][j + 2] + grid[i + 1][j + 1] + grid[i + 2][j] == sum &&\\n                grid[i + 1][j + 1] == 5) {\\n                int seen[10] = {0}"]]}
{"id": "981", "ref_c": [["bool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize){\\n    bool *visited = calloc(roomsSize, sizeof(bool));    // record the visited rooms\\n    bool *key_map = calloc(roomsSize, sizeof(bool));    // record the keys we already have\\n\\n    int stk[roomsSize]; // Our key stack\\n    int pt = -1;\\n    stk[++pt] = 0;      // push key for room 0 to stk\\n    key_map[0] = true;\\n    while (pt > -1){            // break loop while we have no more key to unlock room\\n        int key = stk[pt--];    // pop the top key in stack\\n        visited[key] = true;    // access the room\\n\\n        // collect the key(s) in the room we accessed \\n        // (Push the key to the stack if we don\\'t possess it and haven\\'t unlocked it)\\n        for (int i = 0; i < roomsColSize[key]; i++){\\n            if (key_map[rooms[key][i]] != true && visited[rooms[key][i]] != true){\\n                stk[++pt] = rooms[key][i];\\n                key_map[rooms[key][i]] = true;\\n            }"], ["bool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize){\\n    bool *visited = calloc(roomsSize, sizeof(bool));    // record the visited rooms\\n    bool *key_map = calloc(roomsSize, sizeof(bool));    // record the keys we already have\\n\\n    int stk[roomsSize]; // Our key stack\\n    int pt = -1;\\n    stk[++pt] = 0;      // push key for room 0 to stk\\n    key_map[0] = true;\\n    while (pt > -1){            // break loop while we have no more key to unlock room\\n        int key = stk[pt--];    // pop the top key in stack\\n        visited[key] = true;    // access the room\\n\\n        // collect the key(s) in the room we accessed \\n        // (Push the key to the stack if we don\\'t possess it and haven\\'t unlocked it)\\n        for (int i = 0; i < roomsColSize[key]; i++){\\n            if (key_map[rooms[key][i]] != true && visited[rooms[key][i]] != true){\\n                stk[++pt] = rooms[key][i];\\n                key_map[rooms[key][i]] = true;\\n            }"], ["bool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize){\\n\\n    bool* roomsValid = (bool*)calloc(roomsSize, sizeof(bool));\\n    int roomCounter = 0;\\n    findRoomCanBeEntered(rooms, roomsSize, roomsColSize, 0, roomsValid, &roomCounter);\\n\\n    free(roomsValid);\\n\\n    return (roomCounter == roomsSize);\\n}"]]}
{"id": "982", "ref_c": [["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if((n - 1) % 3 == 0){\\n\\n\\n        return true; \\n        }", "bool isPowerOfFour(int n) {\\n    if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if ((n - 1) % 3 == 0) {\\n            return true;\\n        }", "bool isPowerOfFour(int n) {\\n       return n>0 && (n&(n-1))==0 && (n % 10 ==1|| n% 10==4|| n%10==6);\\n    }", "bool isPowerOfFour(int n) {\\n    return n > 0 && (n & (n - 1)) == 0 && (n % 10 == 1 || n % 10 == 4 || n % 10 == 6);\\n}"], ["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the logarithm of \\'n\\' with base 4\\n        double logarithmBase4 = log(n) / log(4);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (logarithmBase4 == (int)logarithmBase4);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the logarithm of \\'n\\' with base 4\\n    double logarithmBase4 = log(n) / log(4);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (logarithmBase4 == (int)logarithmBase4);\\n}", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the square root of \\'n\\'\\n        double sqrtN = sqrt(n);\\n\\n        // Take the logarithm base 2 of the square root\\n        double log2SqrtN = log2(sqrtN);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (log2SqrtN == (int)log2SqrtN);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the square root of \\'n\\'\\n    double sqrtN = sqrt(n);\\n\\n    // Take the logarithm base 2 of the square root\\n    double log2SqrtN = log2(sqrtN);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (log2SqrtN == (int)log2SqrtN);\\n}"], ["bool isPowerOfFour(int n){\\n\\n    if(n==1)\\n        return true;\\n    return (n&0x55555554) && !(n&n-1);\\n}"]]}
{"id": "983", "ref_c": [["int longestMountain(int* arr, int arrSize){\\n    int max_len=0;\\n    for(int i=0;i<arrSize;i++){\\n        if(i+max_len>arrSize) break;\\n        bool up=true,down=false;\\n        int len=1;\\n\\n        for(int j=i+1;j<arrSize;j++){\\n            if(up && arr[j]>arr[j-1]) len++;\\n            else if(down && arr[j]<arr[j-1]) len++;\\n            else{\\n                break;\\n            }"], ["int longestMountain(int* arr, int arrSize){\\n    int max_len=0;\\n    for(int i=0;i<arrSize;i++){\\n        if(i+max_len>arrSize) break;\\n        bool up=true,down=false;\\n        int len=1;\\n\\n        for(int j=i+1;j<arrSize;j++){\\n            if(up && arr[j]>arr[j-1]) len++;\\n            else if(down && arr[j]<arr[j-1]) len++;\\n            else{\\n                break;\\n            }"], ["int longestMountain(int* arr, int arrSize){\\n    int max_len=0;\\n    for(int i=0;i<arrSize;i++){\\n        if(i+max_len>arrSize) break;\\n        bool up=true,down=false;\\n        int len=1;\\n\\n        for(int j=i+1;j<arrSize;j++){\\n            if(up && arr[j]>arr[j-1]) len++;\\n            else if(down && arr[j]<arr[j-1]) len++;\\n            else{\\n                break;\\n            }"]]}
{"id": "984", "ref_c": [["bool isNStraightHand(int* hand, int handSize, int groupSize)\\n{\\n    unsigned int* hash = calloc(H_SIZE, sizeof(unsigned int));\\n\\n    if( handSize % groupSize != 0)\\n    {\\n        return false;\\n    }"], ["bool isNStraightHand(int* hand, int handSize, int groupSize)\\n{\\n    unsigned int* hash = calloc(H_SIZE, sizeof(unsigned int));\\n\\n    if( handSize % groupSize != 0)\\n    {\\n        return false;\\n    }"], ["bool isNStraightHand(int* hand, int handSize, int groupSize){\\n    \\n    if (handSize % groupSize != 0)\\n    {\\n        return 0;\\n    }"]]}
{"id": "985", "ref_c": [["char * shiftingLetters(char * s, int* shifts, int shiftsSize){\\n    char ans[shiftsSize];\\n    unsigned int count = 0;\\n    for(int i = shiftsSize - 1; i >= 0; i--) {\\n        count += shifts[i];\\n        count = count%26;\\n        s[i] = \\'a\\' + ((s[i] - \\'a\\') + count)%26;\\n    }"], ["char * shiftingLetters(char * s, int* shifts, int shiftsSize){\\n    char ans[shiftsSize];\\n    unsigned int count = 0;\\n    for(int i = shiftsSize - 1; i >= 0; i--) {\\n        count += shifts[i];\\n        count = count%26;\\n        s[i] = \\'a\\' + ((s[i] - \\'a\\') + count)%26;\\n    }"], ["char * shiftingLetters(char * s, int* shifts, int shiftsSize){\\n    char ans[shiftsSize];\\n    unsigned int count = 0;\\n    for(int i = shiftsSize - 1; i >= 0; i--) {\\n        count += shifts[i];\\n        count = count%26;\\n        s[i] = \\'a\\' + ((s[i] - \\'a\\') + count)%26;\\n    }"]]}
{"id": "986", "ref_c": [["int maxDistToClosest(int* seats, int seatsSize) {\\n    int prev=-1;\\n    int zero=0;\\n    int ans=0;\\n    for(int i=0;i<seatsSize;i++){\\n        if(seats[i]==1){\\n            if(prev==-1) ans=fmax(ans,zero);\\n            prev=i;\\n            ans=fmax(ans,(zero+1)/2);\\n            zero=0;\\n        }"], ["int maxDistToClosest(int* seats, int seatsSize){\\n    int zero_count = 0;\\n    int max_zero_count = 0;\\n    int res = 0;\\n\\n    if(seatsSize == 2){\\n        res = 1;\\n    }"], ["int maxDistToClosest(int* seats, int seatsSize){\\n    int zero_count = 0;\\n    int max_zero_count = 0;\\n    int res = 0;\\n\\n    if(seatsSize == 2){\\n        res = 1;\\n    }"]]}
{"id": "987", "ref_c": [["int xorOperation(int n, int start){\\n   int ans[n];\\n    int sum=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        ans[i]=start+2*i;\\n    }"], ["int xorOperation(int n, int start)\\n{\\n    int arr[n],x=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        arr[i] = start + 2*i;\\n        x = x^arr[i];\\n    }"], ["int xorOperation(int n, int start){\\n    int xor = start;\\n    for (int i = 1; i < n; i++){\\n        xor ^= (start + 2 * i);\\n    }"]]}
{"id": "988", "ref_c": [["int peakIndexInMountainArray(int* arr, int arrSize) {\\n    int l = 0, r = arrSize - 1;\\n    while (l <= r){\\n        int m = l + (r-l)/2;\\n        if (arr[m] > arr[m-1] && arr[m] > arr[m+1]) return m;\\n        else if(arr[m] > arr[m-1]){\\n            l = m;\\n        }"], ["int peakIndexInMountainArray(int* arr, int arrSize) {\\n\\n    if(arrSize == 3) return 1;\\n    int left = 0, right = arrSize - 1, mid = 0;\\n\\n    while(left <= right)\\n    {\\n        mid = left + (right - left) / 2;\\n\\n        if(arr[mid] < arr[mid + 1]) {\\n            left = mid + 1;\\n        }"], ["int peakIndexInMountainArray(int* arr, int arrSize) {\\n\\n    if(arrSize == 3) return 1;\\n    int left = 0, right = arrSize - 1, mid = 0;\\n\\n    while(left <= right)\\n    {\\n        mid = left + (right - left) / 2;\\n\\n        if(arr[mid] < arr[mid + 1]) {\\n            left = mid + 1;\\n        }"]]}
{"id": "989", "ref_c": [["int countAsterisks(char * s){\\n    bool in=true;\\n    int len=strlen( s), out=0;\\n    for( int i=0; i<len; i++){\\n        if( s[i]==\\'|\\'){\\n            in=true^in;\\n        }"], ["int countAsterisks(char * s){\\n    bool in=true;\\n    int len=strlen( s), out=0;\\n    for( int i=0; i<len; i++){\\n        if( s[i]==\\'|\\'){\\n            in=true^in;\\n        }"], ["int countAsterisks(char * s){\\n    bool in=true;\\n    int len=strlen( s), out=0;\\n    for( int i=0; i<len; i++){\\n        if( s[i]==\\'|\\'){\\n            in=true^in;\\n        }"]]}
{"id": "991", "ref_c": ["\nint scoreOfParentheses(char * s){\n    int score=0,flag=0;\n    for(int i=0;i<strlen(s);i++){\n        if(s[i]=='('){\n            flag++;\n        }\n        else{\n            flag--;\n            if(s[i-1]=='(')\n                score += 1 << flag;\n        }\n    }\n    return score;\n}\n", "\nint scoreOfParentheses(char * s){\n    int score=0,flag=0;\n    for(int i=0;i<strlen(s);i++){\n        if(s[i]=='('){\n            flag++;\n        }\n        else{\n            flag--;\n            if(s[i-1]=='(')\n                score += 1 << flag;\n        }\n    }\n    return score;\n}\n", "\nint scoreOfParentheses(char * s){\n    int score=0,flag=0;\n    for(int i=0;i<strlen(s);i++){\n        if(s[i]=='('){\n            flag++;\n        }\n        else{\n            flag--;\n            if(s[i-1]=='(')\n                score += 1 << flag;\n        }\n    }\n    return score;\n}\n"]}
{"id": "992", "ref_c": [["int mirrorReflection(int p, int q) {\\n        while(p%2==0 && q%2==0){\\n            p/=2;\\n            q/=2;\\n        }", "int mirrorReflection(int p, int q) {\\n    while(p%2==0 && q%2==0){\\n            p/=2;\\n            q/=2;\\n        }", "int mirrorReflection(int p, int q) {\\n        while(p%2==0 && q%2==0){\\n            p/=2;\\n            q/=2;\\n        }"], ["int mirrorReflection(int p, int q){\\n    if (p == q) return 1;\\n    int height = q, right = 0, up = 1;\\n    \\n    while (1){\\n        if (height + q == p){\\n            if (right && up) return 1;\\n            else if (!right && up) return 2;\\n            else return 0;\\n        }"], ["int mirrorReflection(int p, int q) {\\n        int step = p-q;\\n        int carry = 0;\\n        int pos = 0;\\n        int turn = 0;\\n        while(true){\\n            if(turn == 0) pos+= step;\\n            if(turn == 1) pos-= step;\\n            carry++;\\n            if(pos > p){\\n                pos = p-(pos-p);\\n                turn = 1;\\n            }", "int mirrorReflection(int p, int q) {\\n        int step = p-q;\\n        int carry = 0;\\n        int pos = 0;\\n        int turn = 0;\\n        while(true){\\n            if(turn == 0) pos+= step;\\n            if(turn == 1) pos-= step;\\n            carry++;\\n            if(pos > p){\\n                pos = p-(pos-p);\\n                turn = 1;\\n            }", "int mirrorReflection(int p, int q){\\n        int step = p-q;\\n        int carry = 0;\\n        int pos = 0;\\n        int turn = 0;\\n        while(true){\\n            if(turn == 0) pos+= step;\\n            if(turn == 1) pos-= step;\\n            carry++;\\n            if(pos > p){\\n                pos = p-(pos-p);\\n                turn = 1;\\n            }"]]}
{"id": "993", "ref_c": [["int matrixScore(int** grid, int gridSize, int* gridColSize) {\\n    for(int i=0;i<gridSize;i++){\\n        if(grid[i][0]==0)\\n        fliprow(grid,i,gridColSize[i]);\\n    }"], ["int matrixScore(int** grid, int gridSize, int* gridColSize){\\n    if(!grid)\\n        return 0;\\n    \\n    int leng = gridColSize[0];\\n    int i, j;\\n    for(i=0;i<gridSize;i++){\\n        if(grid[i][0]==0){\\n            for(j=0;j<leng;j++){\\n                grid[i][j] ^= 1;\\n            }"], ["int matrixScore(int** grid, int gridSize, int* gridColSize){\\n    if(!grid)\\n        return 0;\\n    \\n    int leng = gridColSize[0];\\n    int i, j;\\n    for(i=0;i<gridSize;i++){\\n        if(grid[i][0]==0){\\n            for(j=0;j<leng;j++){\\n                grid[i][j] ^= 1;\\n            }"]]}
{"id": "994", "ref_c": [["int* distanceK(struct TreeNode* root, struct TreeNode* target, int k, int* returnSize) {\\n        int *res = (int *)calloc(k * 3 + 50, sizeof(int));\\n    int ridx = 0;\\n    int depth = 0; \\n    addBelowTarget(target, k, depth, res, &ridx); \\n    if(k != 0)\\n        addAboveTarget(root, k, target->val, depth, res, &ridx); \\n    *returnSize = ridx; \\n    return res; \\n}"], ["int* distanceK(struct TreeNode* root, struct TreeNode* target, int k, int* returnSize) {\\n\\n\\n    int* result = (int*)malloc(sizeof(int) * 1000); // Assuming a maximum of 1000 nodes\\n    int count = 0;\\n\\n    findKNodes(target,k,0, result, &count);\\n    if(k != 0)\\n    AboveTarget(root,0, k, target->val,result,&count);\\n    *returnSize = count;\\n    return result;\\n}"], ["int* distanceK(struct TreeNode* root, struct TreeNode* target, int k, int* returnSize) {\\n\\n\\n    int* result = (int*)malloc(sizeof(int) * 1000); // Assuming a maximum of 1000 nodes\\n    int count = 0;\\n\\n    findKNodes(target,k,0, result, &count);\\n    if(k != 0)\\n    AboveTarget(root,0, k, target->val,result,&count);\\n    *returnSize = count;\\n    return result;\\n}"]]}
{"id": "995", "ref_c": [["struct TreeNode* subtreeWithAllDeepest(struct TreeNode* root)\\n{\\n    int height = find_height(root);\\n    \\n    return find_subtree(root, height, 1);\\n}"], ["struct TreeNode* subtreeWithAllDeepest(struct TreeNode* root)\\n{\\n    int height = find_height(root);\\n    \\n    return find_subtree(root, height, 1);\\n}"], ["struct TreeNode* subtreeWithAllDeepest(struct TreeNode* root)\\n{\\n    int height = find_height(root);\\n    \\n    return find_subtree(root, height, 1);\\n}"]]}
{"id": "996", "ref_c": [["int isPrefixOfWord(char * sentence, char * searchWord){\\nchar* words[1000];\\nint start=0,end=0,x=0;\\nfor(start=0,end=0;;end++){\\nif(sentence[end]==\\' \\'||sentence[end]==0){\\nwords[x++]=(&sentence[start]);\\nif(sentence[end]!=0){\\n    start=end+1;\\n    sentence[end]=0;\\n}"], ["int isPrefixOfWord(char * sentence, char * searchWord){\\nchar* words[1000];\\nint start=0,end=0,x=0;\\nfor(start=0,end=0;;end++){\\nif(sentence[end]==\\' \\'||sentence[end]==0){\\nwords[x++]=(&sentence[start]);\\nif(sentence[end]!=0){\\n    start=end+1;\\n    sentence[end]=0;\\n}"], ["int isPrefixOfWord(char * sentence, char * searchWord){\\n    int wordIdx = 1;\\n    \\n    char * searchPtr;\\n    \\n    while(*sentence != \\'\\\\0\\'){\\n        searchPtr = searchWord;\\n        \\n        while(*sentence == *searchPtr && *searchPtr != \\'\\\\0\\'){\\n            ++sentence;\\n            ++searchPtr;\\n        }"]]}
{"id": "997", "ref_c": [["bool reorderedPowerOf2(int n) {\\n        string number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            string powerOfTwo = sortedDigits(1 << i);\\n            if (number == powerOfTwo)\\n                return true;\\n        }"], ["bool reorderedPowerOf2(int n) {\\n        \\n        if(ceil(log2(n)) == floor(log2(n))){\\n            return true;\\n        }"], ["bool reorderedPowerOf2(int n) {\\n        string gg = to_string(n);\\n        sort(gg.begin(), gg.end());\\n\\n        \\n        for(int i=0; i<31; i++){\\n            int temp = pow(2, i);\\n            string s = to_string(temp);\\n            sort(s.begin(), s.end());\\n            if(s == gg) return true;\\n        }"]]}
{"id": "998", "ref_c": [["int* advantageCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int **map1=malloc(sizeof(int*)*nums1Size);\\n    int **map2=malloc(sizeof(int*)*nums2Size);\\n    *returnSize=nums1Size;\\n    for(int i=0;i<nums1Size;i++){\\n        map1[i]=malloc(sizeof(int)*2);\\n        map2[i]=malloc(sizeof(int)*2);\\n        map1[i][0]=nums1[i];\\n        map1[i][1]=i;\\n        map2[i][0]=nums2[i];\\n        map2[i][1]=i;\\n    }"], ["int* advantageCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int **map1=malloc(sizeof(int*)*nums1Size);\\n    int **map2=malloc(sizeof(int*)*nums2Size);\\n    *returnSize=nums1Size;\\n    for(int i=0;i<nums1Size;i++){\\n        map1[i]=malloc(sizeof(int)*2);\\n        map2[i]=malloc(sizeof(int)*2);\\n        map1[i][0]=nums1[i];\\n        map1[i][1]=i;\\n        map2[i][0]=nums2[i];\\n        map2[i][1]=i;\\n    }"], ["int* advantageCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int **map1=malloc(sizeof(int*)*nums1Size);\\n    int **map2=malloc(sizeof(int*)*nums2Size);\\n    *returnSize=nums1Size;\\n    for(int i=0;i<nums1Size;i++){\\n        map1[i]=malloc(sizeof(int)*2);\\n        map2[i]=malloc(sizeof(int)*2);\\n        map1[i][0]=nums1[i];\\n        map1[i][1]=i;\\n        map2[i][0]=nums2[i];\\n        map2[i][1]=i;\\n    }"]]}
{"id": "999", "ref_c": [["int findKthPositive(int* arr, int arrSize, int k) \\n{\\n   if(k <= arr[0] - 1)\\n   {\\n      return k;\\n   }"], ["int findKthPositive(int* arr, int arrSize, int k) \\n{\\n   if(k <= arr[0] - 1)\\n   {\\n      return k;\\n   }"], ["int findKthPositive(int* arr, int arrSize, int k) \\n{\\n   if(k <= arr[0] - 1)\\n   {\\n      return k;\\n   }"]]}
{"id": "1000", "ref_c": [["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n\\n    char a[26]={0}"]]}
{"id": "1001", "ref_c": ["\nbool isEatupInTime(int* piles, int pilesSize, int eatSpeed, int eatTimeLimit){\n\n    int eatTime = 0;\n\n    for(int i = 0; i < pilesSize; i++){\n        eatTime += (eatSpeed + piles[i] - 1) / eatSpeed;\n        if(eatTime > eatTimeLimit){\n            return false;\n        }\n    }\n\n    return true;\n\n}\n\nint minEatingSpeed(int* piles, int pilesSize, int h){\n\n    int left = 1;\n    int right = 10e9;\n    int middle;\n\n    while(left < right){\n        int middle = left + ((right - left) >> 1);\n        if(isEatupInTime(piles, pilesSize, middle, h)){\n            right = middle;\n        }\n        else{\n            left = middle + 1;\n        }\n    }\n\n    return right;\n\n}\n", "\nbool isEatupInTime(int* piles, int pilesSize, int eatSpeed, int eatTimeLimit){\n\n    int eatTime = 0;\n\n    for(int i = 0; i < pilesSize; i++){\n        eatTime += (eatSpeed + piles[i] - 1) / eatSpeed;\n        if(eatTime > eatTimeLimit){\n            return false;\n        }\n    }\n\n    return true;\n\n}\n\nint minEatingSpeed(int* piles, int pilesSize, int h){\n\n    int left = 1;\n    int right = 10e9;\n    int middle;\n\n    while(left < right){\n        int middle = left + ((right - left) >> 1);\n        if(isEatupInTime(piles, pilesSize, middle, h)){\n            right = middle;\n        }\n        else{\n            left = middle + 1;\n        }\n    }\n\n    return right;\n\n}\n", "\nbool isEatupInTime(int* piles, int pilesSize, int eatSpeed, int eatTimeLimit){\n\n    int eatTime = 0;\n\n    for(int i = 0; i < pilesSize; i++){\n        eatTime += (eatSpeed + piles[i] - 1) / eatSpeed;\n        if(eatTime > eatTimeLimit){\n            return false;\n        }\n    }\n\n    return true;\n\n}\n\nint minEatingSpeed(int* piles, int pilesSize, int h){\n\n    int left = 1;\n    int right = 10e9;\n    int middle;\n\n    while(left < right){\n        int middle = left + ((right - left) >> 1);\n        if(isEatupInTime(piles, pilesSize, middle, h)){\n            right = middle;\n        }\n        else{\n            left = middle + 1;\n        }\n    }\n\n    return right;\n\n}\n"]}
{"id": "1002", "ref_c": [["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"]]}
{"id": "1003", "ref_c": [["char * decodeAtIndex(char * s, int k){\\n    long prev = 0, temp = 0;\\n    int  n = strlen(s);\\n    for(int i = 0; i < n; i++){\\n        if(s[i] < 97) {\\n            temp = prev;\\n            prev *= (s[i] - 48);\\n                if(!(k % temp == 0)) k %= temp;\\n                else if(k < temp) k = 1;\\n                else k = temp;\\n                i = -1; prev = 0;\\n            }"], ["char * decodeAtIndex(char * s, int k){\\n    long prev = 0, temp = 0;\\n    int  n = strlen(s);\\n    for(int i = 0; i < n; i++){\\n        if(s[i] < 97) {\\n            temp = prev;\\n            prev *= (s[i] - 48);\\n                if(!(k % temp == 0)) k %= temp;\\n                else if(k < temp) k = 1;\\n                else k = temp;\\n                i = -1; prev = 0;\\n            }"], ["char * decodeAtIndex(char * s, int k){\\n    long prev = 0, temp = 0;\\n    int  n = strlen(s);\\n    for(int i = 0; i < n; i++){\\n        if(s[i] < 97) {\\n            temp = prev;\\n            prev *= (s[i] - 48);\\n                if(!(k % temp == 0)) k %= temp;\\n                else if(k < temp) k = 1;\\n                else k = temp;\\n                i = -1; prev = 0;\\n            }"]]}
{"id": "1004", "ref_c": [["int numRescueBoats(int* people, int peopleSize, int limit)\\n{\\n    int i,j;\\n    int temp;\\n    int l=0;\\n    int r=peopleSize-1;\\n    int boat=0;\\n    quickSort(people,0,r);\\n    while(l<=r)\\n    {\\n        if(people[l]+people[r]<=limit)\\n        {\\n            l++;\\n            r--;\\n        }"], ["int numRescueBoats(int* people, int peopleSize, int limit) {\\n    int i = 0, j = peopleSize-1, count = 0;\\n\\n    qsort(people, peopleSize, sizeof(int), compare);\\n\\n    while (i < j) {\\n        if(people[j] + people[i] > limit) {\\n            j--;\\n            count++;\\n        }"], ["int numRescueBoats(int* people, int peopleSize, int limit)\\n{\\n    int i,j;\\n    int temp;\\n    int l=0;\\n    int r=peopleSize-1;\\n    int boat=0;\\n    quickSort(people,0,r);\\n    while(l<=r)\\n    {\\n        if(people[l]+people[r]<=limit)\\n        {\\n            l++;\\n            r--;\\n        }"]]}
{"id": "1005", "ref_c": [["int** spiralMatrixIII(int rows, int cols, int rStart, int cStart, int* returnSize, int** returnColumnSizes){\\n    int all = rows*cols;\\n    int count = 0;\\n    int a = 1;\\n    *returnSize = all;\\n    int** ans = malloc(sizeof(int*)*all);\\n    (*returnColumnSizes) = malloc(sizeof(int)*all);\\n    for(int i = 0 ; i < all ; i++){\\n        ans[i] = malloc(sizeof(int)*2);\\n        (*returnColumnSizes)[i] = 2;\\n    }"], ["int** spiralMatrixIII(int rows, int cols, int rStart, int cStart, int* returnSize, int** returnColumnSizes) {\\n    (*returnSize) = rows * cols;\\n    *returnColumnSizes = (int*) malloc((*returnSize) * sizeof(int));\\n    int** res = (int**) malloc((*returnSize) * sizeof(int*));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        res[i] = (int*) calloc(2, sizeof(int));\\n        (*returnColumnSizes)[i] = 2;\\n    }"], ["int** spiralMatrixIII(int rows, int cols, int rStart, int cStart, int* returnSize, int** returnColumnSizes){\\n    int all = rows*cols;\\n    int count = 0;\\n    int a = 1;\\n    *returnSize = all;\\n    int** ans = malloc(sizeof(int*)*all);\\n    (*returnColumnSizes) = malloc(sizeof(int)*all);\\n    for(int i = 0 ; i < all ; i++){\\n        ans[i] = malloc(sizeof(int)*2);\\n        (*returnColumnSizes)[i] = 2;\\n    }"]]}
{"id": "1006", "ref_c": [["bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\\n    if (n == 1) return true;\\n    if (n == 2) return (dislikesSize == 0);\\n    unsigned char * colored = calloc(n, sizeof(unsigned char));\\n    ListEntry* * adjacency = malloc(n * sizeof(ListEntry *));\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency[i] = list_init();\\n    }"], ["bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\\n    if (n == 1) return true;\\n    if (n == 2) return (dislikesSize == 0);\\n    unsigned char * colored = calloc(n, sizeof(unsigned char));\\n    ListEntry* * adjacency = malloc(n * sizeof(ListEntry *));\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency[i] = list_init();\\n    }"], ["bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\\n    if (n == 1) return true;\\n    if (n == 2) return (dislikesSize == 0);\\n    unsigned char * colored = calloc(n, sizeof(unsigned char));\\n    ListEntry* * adjacency = malloc(n * sizeof(ListEntry *));\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency[i] = list_init();\\n    }"]]}
{"id": "1007", "ref_c": [["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"], ["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"], ["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"]]}
{"id": "1008", "ref_c": [["char ** findAndReplacePattern(char ** words, int wordsSize, char * pattern, int* returnSize){\\n    /*\\n     * Input:\\n     *  words, string array\\n     *  wordsSize, number of strings\\n     *  pattern, string pattern\\n     */\\n     \\n    char hash1[26], hash2[26];\\n    char *tmp;\\n    char *word;\\n    char **ans = (char **)malloc(sizeof(char *) * wordsSize);\\n    \\n    *returnSize = 0;\\n    \\n    for (int i = 0; i < wordsSize; i++) {\\n\\n        /* Reset hash tables before starting the process */\\n        memset((void *)hash1, 0, sizeof(hash1));\\n        memset((void *)hash2, 0, sizeof(hash2));\\n        \\n        word = words[i];\\n        tmp = pattern;\\n        \\n        /* Scan the letters in word and pattern */\\n        while (*word && *tmp) {\\n        \\n            /* Store the bijection */\\n            if (hash1[*word - \\'a\\'] == 0) {\\n                hash1[*word - \\'a\\'] = *tmp;\\n            }"], ["char ** findAndReplacePattern(char ** words, int wordsSize, char * pattern, int* returnSize)\\n{\\n    char** ret = malloc(sizeof(char*) * wordsSize);\\n    char** it = ret;\\n\\n    for(int i = 0; i < wordsSize; ++i)\\n    {\\n        if(is_perm(words[i], pattern))\\n        {\\n            *it = words[i];\\n            ++it;\\n        }"], ["char ** findAndReplacePattern(char ** words, int wordsSize, char * pattern, int* returnSize){\\n    /*\\n     * Input:\\n     *  words, string array\\n     *  wordsSize, number of strings\\n     *  pattern, string pattern\\n     */\\n     \\n    char hash1[26], hash2[26];\\n    char *tmp;\\n    char *word;\\n    char **ans = (char **)malloc(sizeof(char *) * wordsSize);\\n    \\n    *returnSize = 0;\\n    \\n    for (int i = 0; i < wordsSize; i++) {\\n\\n        /* Reset hash tables before starting the process */\\n        memset((void *)hash1, 0, sizeof(hash1));\\n        memset((void *)hash2, 0, sizeof(hash2));\\n        \\n        word = words[i];\\n        tmp = pattern;\\n        \\n        /* Scan the letters in word and pattern */\\n        while (*word && *tmp) {\\n        \\n            /* Store the bijection */\\n            if (hash1[*word - \\'a\\'] == 0) {\\n                hash1[*word - \\'a\\'] = *tmp;\\n            }"]]}
{"id": "1009", "ref_c": [["int numSpecialEquivGroups(char ** words, int wordsSize)\\n{\\n    memset(hashtable, \\'\\\\0\\', sizeof(char)*1000*21);\\n    memset(counttable, 0, sizeof(counttable));\\n    \\n    int count = 0;\\n    \\n    char ** odd = (char **)malloc(sizeof(char *) * wordsSize);\\n    int odd_index = 0;\\n    \\n    char ** even = (char **)malloc(sizeof(char *) * wordsSize);\\n    int even_index = 0;\\n    \\n    int rows = 0;\\n    for(rows=0; rows<wordsSize; rows++)\\n    {\\n        int i=0;\\n        int len = strlen(words[i]);\\n        \\n        //Put odd indexes in odd\\n        char * tmp_odd = (char *)malloc(sizeof(char) * (len+1));\\n        int tmp_odd_index = 0;\\n        for(i=1; i<len; i+=2)\\n        {   \\n            tmp_odd[tmp_odd_index++] = words[rows][i];\\n        }"], ["int numSpecialEquivGroups(char ** words, int wordsSize)\\n{\\n    memset(hashtable, \\'\\\\0\\', sizeof(char)*1000*21);\\n    memset(counttable, 0, sizeof(counttable));\\n    \\n    int count = 0;\\n    \\n    char ** odd = (char **)malloc(sizeof(char *) * wordsSize);\\n    int odd_index = 0;\\n    \\n    char ** even = (char **)malloc(sizeof(char *) * wordsSize);\\n    int even_index = 0;\\n    \\n    int rows = 0;\\n    for(rows=0; rows<wordsSize; rows++)\\n    {\\n        int i=0;\\n        int len = strlen(words[i]);\\n        \\n        //Put odd indexes in odd\\n        char * tmp_odd = (char *)malloc(sizeof(char) * (len+1));\\n        int tmp_odd_index = 0;\\n        for(i=1; i<len; i+=2)\\n        {   \\n            tmp_odd[tmp_odd_index++] = words[rows][i];\\n        }"], ["int numSpecialEquivGroups(char ** words, int wordsSize)\\n{\\n    memset(hashtable, \\'\\\\0\\', sizeof(char)*1000*21);\\n    memset(counttable, 0, sizeof(counttable));\\n    \\n    int count = 0;\\n    \\n    char ** odd = (char **)malloc(sizeof(char *) * wordsSize);\\n    int odd_index = 0;\\n    \\n    char ** even = (char **)malloc(sizeof(char *) * wordsSize);\\n    int even_index = 0;\\n    \\n    int rows = 0;\\n    for(rows=0; rows<wordsSize; rows++)\\n    {\\n        int i=0;\\n        int len = strlen(words[i]);\\n        \\n        //Put odd indexes in odd\\n        char * tmp_odd = (char *)malloc(sizeof(char) * (len+1));\\n        int tmp_odd_index = 0;\\n        for(i=1; i<len; i+=2)\\n        {   \\n            tmp_odd[tmp_odd_index++] = words[rows][i];\\n        }"]]}
{"id": "1010", "ref_c": ["\nstruct TreeNode** allPossibleFBTHelper(int N, int* returnSize, struct TreeNode ***fbt, int *fbtSize) \n{\n    struct TreeNode **ret = malloc(sizeof(struct TreeNode*));\n    *returnSize = 0;\n\n    if (N == 1) \n    {\n        struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n        ret = realloc(ret, sizeof(struct TreeNode) * ((*returnSize) + 1));\n        ret[*returnSize] = root;\n        *returnSize += 1;\n        return ret;\n    }\n\n    for (int x = 1; x <= N - 2; x += 2) \n    {\n        int lSize = fbtSize[x], rSize = fbtSize[N-x-1];\n        for (int i = 0; i < lSize; i++) \n        {\n            for (int j = 0; j < rSize; j++) \n            {\n                struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n                root->left = fbt[x][i];\n                root->right = fbt[N-x-1][j];\n                ret = realloc(ret, sizeof(struct TreeNode)*((*returnSize) + 1));\n                ret[*returnSize] = root;\n                *returnSize += 1;\n            }\n        }\n    }\n    return ret;    \n}\n\nstruct TreeNode** allPossibleFBT(int N, int* returnSize)\n{\n    if ((N % 2) == 0)\n    {\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    struct TreeNode **fbt[21];\n    int fbtSize[21] = {0};\n    for (int i = 1; i <= N; i+=2)\n    {\n        int tmpSize = 0;\n        fbt[i] = allPossibleFBTHelper(i, &tmpSize, fbt, fbtSize);\n        fbtSize[i] = tmpSize;\n    }\n\n    *returnSize = fbtSize[N];    \n    return fbt[N];\n}\n", "\nstruct TreeNode** allPossibleFBTHelper(int N, int* returnSize, struct TreeNode ***fbt, int *fbtSize) \n{\n    struct TreeNode **ret = malloc(sizeof(struct TreeNode*));\n    *returnSize = 0;\n\n    if (N == 1) \n    {\n        struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n        ret = realloc(ret, sizeof(struct TreeNode) * ((*returnSize) + 1));\n        ret[*returnSize] = root;\n        *returnSize += 1;\n        return ret;\n    }\n\n    for (int x = 1; x <= N - 2; x += 2) \n    {\n        int lSize = fbtSize[x], rSize = fbtSize[N-x-1];\n        for (int i = 0; i < lSize; i++) \n        {\n            for (int j = 0; j < rSize; j++) \n            {\n                struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n                root->left = fbt[x][i];\n                root->right = fbt[N-x-1][j];\n                ret = realloc(ret, sizeof(struct TreeNode)*((*returnSize) + 1));\n                ret[*returnSize] = root;\n                *returnSize += 1;\n            }\n        }\n    }\n    return ret;    \n}\n\nstruct TreeNode** allPossibleFBT(int N, int* returnSize)\n{\n    if ((N % 2) == 0)\n    {\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    struct TreeNode **fbt[21];\n    int fbtSize[21] = {0};\n    for (int i = 1; i <= N; i+=2)\n    {\n        int tmpSize = 0;\n        fbt[i] = allPossibleFBTHelper(i, &tmpSize, fbt, fbtSize);\n        fbtSize[i] = tmpSize;\n    }\n\n    *returnSize = fbtSize[N];    \n    return fbt[N];\n}\n", "\nstruct TreeNode** allPossibleFBTHelper(int N, int* returnSize, struct TreeNode ***fbt, int *fbtSize) \n{\n    struct TreeNode **ret = malloc(sizeof(struct TreeNode*));\n    *returnSize = 0;\n\n    if (N == 1) \n    {\n        struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n        ret = realloc(ret, sizeof(struct TreeNode) * ((*returnSize) + 1));\n        ret[*returnSize] = root;\n        *returnSize += 1;\n        return ret;\n    }\n\n    for (int x = 1; x <= N - 2; x += 2) \n    {\n        int lSize = fbtSize[x], rSize = fbtSize[N-x-1];\n        for (int i = 0; i < lSize; i++) \n        {\n            for (int j = 0; j < rSize; j++) \n            {\n                struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n                root->left = fbt[x][i];\n                root->right = fbt[N-x-1][j];\n                ret = realloc(ret, sizeof(struct TreeNode)*((*returnSize) + 1));\n                ret[*returnSize] = root;\n                *returnSize += 1;\n            }\n        }\n    }\n    return ret;    \n}\n\nstruct TreeNode** allPossibleFBT(int N, int* returnSize)\n{\n    if ((N % 2) == 0)\n    {\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    struct TreeNode **fbt[21];\n    int fbtSize[21] = {0};\n    for (int i = 1; i <= N; i+=2)\n    {\n        int tmpSize = 0;\n        fbt[i] = allPossibleFBTHelper(i, &tmpSize, fbt, fbtSize);\n        fbtSize[i] = tmpSize;\n    }\n\n    *returnSize = fbtSize[N];    \n    return fbt[N];\n}\n"]}
{"id": "1011", "ref_c": [["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if(!root) return root;\\n    root = DFS(root, val, depth, 1, -1);/* -1:left node, 1: right node */\\n    return root;\\n}"], ["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if (depth == 1){ // case 1, add new root\\n        struct TreeNode* newRoot = malloc(sizeof(struct TreeNode));\\n        newRoot->val = val;\\n        newRoot->left = root;\\n        newRoot->right = NULL;\\n        return newRoot;\\n    }"], ["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if (depth == 1){ // case 1, add new root\\n        struct TreeNode* newRoot = malloc(sizeof(struct TreeNode));\\n        newRoot->val = val;\\n        newRoot->left = root;\\n        newRoot->right = NULL;\\n        return newRoot;\\n    }"]]}
{"id": "1014", "ref_c": [["int totalFruit(int* fruits, int fruitsSize){\\n\\n    /*\\n     * Input:\\n     *  fruits, type of fruit the ith tree produces.\\n     *  fruitsSize, number of trees\\n     */\\n\\n    int *freq = (int *)calloc(1, sizeof(int) * fruitsSize);\\n    int type = 0;\\n    int max = INT_MIN;\\n    \\n    /* Sliding window, start from left most tree */\\n    for (int i = 0, j = 0; i < fruitsSize && j < fruitsSize; ) {\\n\\n        /* \\n         * If the current fruit type is less than 2, \\n         * pick the fruit directly and expand the width\\n         * of sliding window \\n         */\\n        if (type < 2) {\\n            freq[fruits[j]]++;\\n            if (freq[fruits[j]] == 1) {\\n                type++;\\n            }"], ["int totalFruit(int* fruits, int fruitsSize){\\n\\n    /*\\n     * Input:\\n     *  fruits, type of fruit the ith tree produces.\\n     *  fruitsSize, number of trees\\n     */\\n\\n    int *freq = (int *)calloc(1, sizeof(int) * fruitsSize);\\n    int type = 0;\\n    int max = INT_MIN;\\n    \\n    /* Sliding window, start from left most tree */\\n    for (int i = 0, j = 0; i < fruitsSize && j < fruitsSize; ) {\\n\\n        /* \\n         * If the current fruit type is less than 2, \\n         * pick the fruit directly and expand the width\\n         * of sliding window \\n         */\\n        if (type < 2) {\\n            freq[fruits[j]]++;\\n            if (freq[fruits[j]] == 1) {\\n                type++;\\n            }"], ["int totalFruit(int* fruits, int fruitsSize){\\n\\n    /*\\n     * Input:\\n     *  fruits, type of fruit the ith tree produces.\\n     *  fruitsSize, number of trees\\n     */\\n\\n    int *freq = (int *)calloc(1, sizeof(int) * fruitsSize);\\n    int type = 0;\\n    int max = INT_MIN;\\n    \\n    /* Sliding window, start from left most tree */\\n    for (int i = 0, j = 0; i < fruitsSize && j < fruitsSize; ) {\\n\\n        /* \\n         * If the current fruit type is less than 2, \\n         * pick the fruit directly and expand the width\\n         * of sliding window \\n         */\\n        if (type < 2) {\\n            freq[fruits[j]]++;\\n            if (freq[fruits[j]] == 1) {\\n                type++;\\n            }"]]}
{"id": "1015", "ref_c": [["int sumSubarrayMins(int* arr, int arrSize){\\n    int *stk = calloc(arrSize, sizeof(int));\\n    int *PLE = calloc(arrSize, sizeof(int)); \\n    // store the distance between element arr[i] and its PLE (Previous Less Element)\\n    int *NLE = calloc(arrSize, sizeof(int)); \\n    // store the distance between element arr[i] and its NLE (Next Less Element)\\n    int pt = -1;    // current stack index, \"-1\" means the stack is empty\\n\\n    //initialize\\n    for(int i = 0; i < arrSize; i++){\\n        PLE[i] = i + 1;\\n        NLE[i] = arrSize - i;\\n    }"], ["int sumSubarrayMins(int* arr, int arrSize) {\\n    const int MOD = 1000000007;\\n    int stack[arrSize];\\n    int top = -1;\\n    long long result = 0;\\n\\n    for (int i = 0; i <= arrSize; ++i) {\\n        while (top != -1 && (i == arrSize || arr[i] < arr[stack[top]])) {\\n            int j = stack[top--];\\n            int prev = (top == -1) ? -1 : stack[top];\\n            result += (long long)(i - j) * (j - prev) * arr[j];\\n            result %= MOD;\\n        }"], ["int sumSubarrayMins(int* arr, int arrSize){\\n    int *stk = calloc(arrSize, sizeof(int));\\n    int *PLE = calloc(arrSize, sizeof(int)); \\n    // store the distance between element arr[i] and its PLE (Previous Less Element)\\n    int *NLE = calloc(arrSize, sizeof(int)); \\n    // store the distance between element arr[i] and its NLE (Next Less Element)\\n    int pt = -1;    // current stack index, \"-1\" means the stack is empty\\n\\n    //initialize\\n    for(int i = 0; i < arrSize; i++){\\n        PLE[i] = i + 1;\\n        NLE[i] = arrSize - i;\\n    }"]]}
{"id": "1016", "ref_c": [["int snakesAndLadders(int** board, int boardSize, int* boardColSize){\\n    //Variables initialization\\n    size = boardSize*boardSize;\\n    vis = calloc(size+1, sizeof(bool));\\n    dist = calloc(size+1, sizeof(int));\\n    queue = calloc(size, sizeof(int));\\n    BF(board, boardSize, *boardColSize, 1);\\n\\n    //If distance on last position is 0 it means we haven\\'t reach that position\\n    //If board was 1x1 this would give us a wrong answer, but since the restrictions say it\\'s at least a 2x2 board, we can do this\\n    //In a 1x1 board we would simply return 0, since the begin == end\\n    int ans = dist[size]==0?-1:dist[size];\\n    \\n    // We don\\'t want memory leaks :)\\n    free(vis);\\n    free(dist);\\n    free(queue);\\n    return ans;\\n}"], ["int snakesAndLadders(int** board, int boardSize, int* boardColSize){\\n    int rlen = boardSize, clen = *boardColSize;\\n    int qSize = rlen * clen, rIdx = 0, wIdx = 0, minStep = INT_MAX;\\n    int* queue = (int*)calloc(qSize, sizeof(int));\\n    bool* memo = (bool*)calloc(rlen*clen+1, sizeof(bool));\\n    queue[wIdx++] = 1;\\n    while(rIdx != wIdx){\\n        int val = queue[rIdx] & 0x3FF, step = queue[rIdx++] >> 10;\\n        rIdx %= qSize;\\n        step++;\\n        for(int i = 1; i <= 6 && val + i <= qSize; i++){\\n            if(step >= minStep || memo[val+i])\\n                continue;\\n            if((val + i) == qSize){\\n                minStep = step;\\n                continue;\\n            }"], ["int snakesAndLadders(int** board, int boardSize, int* boardColSize){\\n    //Variables initialization\\n    size = boardSize*boardSize;\\n    vis = calloc(size+1, sizeof(bool));\\n    dist = calloc(size+1, sizeof(int));\\n    queue = calloc(size, sizeof(int));\\n    BF(board, boardSize, *boardColSize, 1);\\n\\n    //If distance on last position is 0 it means we haven\\'t reach that position\\n    //If board was 1x1 this would give us a wrong answer, but since the restrictions say it\\'s at least a 2x2 board, we can do this\\n    //In a 1x1 board we would simply return 0, since the begin == end\\n    int ans = dist[size]==0?-1:dist[size];\\n    \\n    // We don\\'t want memory leaks :)\\n    free(vis);\\n    free(dist);\\n    free(queue);\\n    return ans;\\n}"]]}
{"id": "1017", "ref_c": [["int smallestRangeII(int* nums, int numsSize, int k) {\\n  /* Find the minimum and maximum values */\\n  int min = INT_MAX;\\n  int max = INT_MIN;\\n  for (int i = 0; i < numsSize; ++i) {\\n    min = (min < nums[i]) ? min : nums[i];  \\n    max = (max > nums[i]) ? max : nums[i];\\n  }"], ["int smallestRangeII(int* nums, int numsSize, int k) {\\n  /* Find the minimum and maximum values */\\n  int min = INT_MAX;\\n  int max = INT_MIN;\\n  for (int i = 0; i < numsSize; ++i) {\\n    min = (min < nums[i]) ? min : nums[i];  \\n    max = (max > nums[i]) ? max : nums[i];\\n  }"], ["int smallestRangeII(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int result = nums[numsSize - 1] - nums[0], left = nums[0] + k, right = nums[numsSize - 1] - k;\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        int max = nums[i] + k > right ?  nums[i] + k : right;\\n        int min = left < nums[i + 1] - k ? left : nums[i + 1] - k;\\n        result = result < max - min ? result : max - min;\\n    }"]]}
{"id": "1019", "ref_c": [["int* sortArray(int* nums, int numsSize, int* returnSize){\\n    buildHeap(nums, numsSize);\\n    *returnSize = numsSize;\\n\\n    // Sort\\n    for (int i = numsSize - 1; i > 0; i--) {\\n        swap(&nums[i], &nums[0]);\\n        heapify(nums, i, 0);   \\n    }"], ["int* sortArray(int* nums, int numsSize, int* returnSize){\\n    buildHeap(nums, numsSize);\\n    *returnSize = numsSize;\\n\\n    // Sort\\n    for (int i = numsSize - 1; i > 0; i--) {\\n        swap(&nums[i], &nums[0]);\\n        heapify(nums, i, 0);   \\n    }"], ["int* sortArray(int* nums, int numsSize, int* returnSize){\\n    buildHeap(nums, numsSize);\\n    *returnSize = numsSize;\\n\\n    // Sort\\n    for (int i = numsSize - 1; i > 0; i--) {\\n        swap(&nums[i], &nums[0]);\\n        heapify(nums, i, 0);   \\n    }"]]}
{"id": "1020", "ref_c": [["int partitionDisjoint(int* nums, int numsSize)\\n{\\n    int max = nums[0]; // left\\n    int newmax=nums[0];\\n    int ans = 1; //r-start\\n    int wait = 0;\\n    for(int i = 1; i < numsSize; i++)\\n    {\\n        if(nums[i]<max)\\n        {\\n            wait=1;\\n            max=newmax;\\n        }"], ["int partitionDisjoint(int* nums, int numsSize){\\n\\nint pos = 0;\\nwhile(pos < numsSize)\\n{\\n    int numatpos = nums[pos];\\n\\n    //max and maxpos are found to calculate the next maximum and its position\\n    int max = nums[pos];\\n    int maxpos = pos;\\n\\n// finding the next maximum\\n\\n    for(int i= pos+1;i<numsSize;i++)\\n    {\\n       if(nums[i] >= numatpos)\\n       {\\n           max = nums[i];\\n           maxpos = i;\\n           break;\\n       }"], ["int partitionDisjoint(int* nums, int numsSize)\\n{\\n    int max = nums[0]; // left\\n    int newmax=nums[0];\\n    int ans = 1; //r-start\\n    int wait = 0;\\n    for(int i = 1; i < numsSize; i++)\\n    {\\n        if(nums[i]<max)\\n        {\\n            wait=1;\\n            max=newmax;\\n        }"]]}
{"id": "1021", "ref_c": [["char ** wordSubsets(char ** words1, int words1Size, char ** words2, int words2Size, int* returnSize){\\n    /*\\n     * Input:\\n     *  words1, string array\\n     *  words1Size, number of strings in words1\\n     *  words2, string array\\n     *  words2Size, number of string in words2\\n     */\\n     \\n    int hash1[26];\\n    int hash2[26];\\n    int tmp[26];\\n    char **ans = (char **)malloc(sizeof(char *) * words1Size);\\n    char *w;\\n    int cnt;\\n    \\n    *returnSize = 0;\\n    \\n    /* Reset hash1 */\\n    for (int i = 0; i < 26; i++) {\\n        hash1[i] = 0;\\n    }"], ["char ** wordSubsets(char ** words1, int words1Size, char ** words2, int words2Size, int* returnSize){\\n    /*\\n     * Input:\\n     *  words1, string array\\n     *  words1Size, number of strings in words1\\n     *  words2, string array\\n     *  words2Size, number of string in words2\\n     */\\n     \\n    int hash1[26];\\n    int hash2[26];\\n    int tmp[26];\\n    char **ans = (char **)malloc(sizeof(char *) * words1Size);\\n    char *w;\\n    int cnt;\\n    \\n    *returnSize = 0;\\n    \\n    /* Reset hash1 */\\n    for (int i = 0; i < 26; i++) {\\n        hash1[i] = 0;\\n    }"], ["char ** wordSubsets(char ** words1, int words1Size, char ** words2, int words2Size, int* returnSize){\\n    /*\\n     * Input:\\n     *  words1, string array\\n     *  words1Size, number of strings in words1\\n     *  words2, string array\\n     *  words2Size, number of string in words2\\n     */\\n     \\n    int hash1[26];\\n    int hash2[26];\\n    int tmp[26];\\n    char **ans = (char **)malloc(sizeof(char *) * words1Size);\\n    char *w;\\n    int cnt;\\n    \\n    *returnSize = 0;\\n    \\n    /* Reset hash1 */\\n    for (int i = 0; i < 26; i++) {\\n        hash1[i] = 0;\\n    }"]]}
{"id": "1022", "ref_c": [["int maxSubarraySumCircular(int* nums, int numsSize){\\n    short sNumsSize = numsSize;\\n    int nTotal = 0, nMax = INT_MIN, nMaxTmp = 0, nMin = INT_MAX, nMinTmp = 0;\\n    while(numsSize-- > 0)\\n    {\\n        nTotal += *nums;\\n\\n        // check max\\n        if(nMaxTmp > 0)\\n        {\\n            nMaxTmp += *nums;\\n        }"], ["int maxSubarraySumCircular(int* nums, int numsSize){\\n    short sNumsSize = numsSize;\\n    int nTotal = 0, nMax = INT_MIN, nMaxTmp = 0, nMin = INT_MAX, nMinTmp = 0;\\n    while(numsSize-- > 0)\\n    {\\n        nTotal += *nums;\\n\\n        // check max\\n        if(nMaxTmp > 0)\\n        {\\n            nMaxTmp += *nums;\\n        }"], ["int maxSubarraySumCircular(int* nums, int numsSize){\\n    short sNumsSize = numsSize;\\n    int nTotal = 0, nMax = INT_MIN, nMaxTmp = 0, nMin = INT_MAX, nMinTmp = 0;\\n    while(numsSize-- > 0)\\n    {\\n        nTotal += *nums;\\n\\n        // check max\\n        if(nMaxTmp > 0)\\n        {\\n            nMaxTmp += *nums;\\n        }"]]}
{"id": "1024", "ref_c": [["int minAddToMakeValid(char * s){\\n    int count  = 0;\\n    for(int i=0; i<strlen(s); i++){\\n        for(int j=i+1; j<strlen(s); j++){\\n            if(s[i] == \\'(\\' && s[j] == \\')\\'){\\n                count++;\\n                s[i] = -1;\\n                s[j] = -1;\\n            }"], ["int minAddToMakeValid(char * s){\\nint open=0,res=0;\\nfor(int i=0;i<strlen(s);i++)\\n{\\nif(s[i]==\\')\\') open--;\\nelse{\\nif(s[i]==\\'(\\' && open<0)\\n{\\nres+=abs(open);\\nopen=1;\\n}"], ["int minAddToMakeValid(char * s){\\n    int count  = 0;\\n    for(int i=0; i<strlen(s); i++){\\n        for(int j=i+1; j<strlen(s); j++){\\n            if(s[i] == \\'(\\' && s[j] == \\')\\'){\\n                count++;\\n                s[i] = -1;\\n                s[j] = -1;\\n            }"]]}
{"id": "1025", "ref_c": [["int threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0}"], ["int threeSumMulti(int* arr, int arrSize, int target){\\n    long sum = 0;\\n    long a, b, c;\\n    \\n    for(int i = 0;i <= target;i++)\\n    {\\n        for(int j = i;j <= target;j++)\\n        {\\n            for(int k = j;k <= target;k++)\\n            {\\n                if (i + j + k == target)\\n                {\\n                    a = countInArr(arr, arrSize, i);\\n                    b = countInArr(arr, arrSize, j);\\n                    c = countInArr(arr, arrSize, k);\\n\\n                    if (a != 0 && b != 0 && c != 0)\\n                    {\\n                        if (i != j && i != k && j != k)\\n                            sum += a * b * c;\\n                        else if (i == j && j == k)\\n                            sum += (a * (a - 1) * (a - 2)) / 6;\\n\\n                        else if (i == j)\\n                            sum += ((a * (a - 1)) / 2) * c;\\n \\n                        else if (i == k)\\n                            sum += ((a * (a - 1)) / 2) * b;\\n\\n                        else if (j == k)\\n                            sum += ((b * (b - 1)) / 2) * a;\\n\\n                        sum = sum % 1000000007;\\n                    }"], ["int threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0}"]]}
{"id": "1026", "ref_c": [["int minFlipsMonoIncr(char * s){\\n    int ans=0;\\n    int ones=0;\\n\\n    for(int i = 0; i<strlen(s);i++)\\n    {\\n        if(s[i]==\\'1\\')\\n            ones++;\\n        else\\n            ans=min(ones,ans+1);\\n    }"], ["int minFlipsMonoIncr(char * s){\\n    int ans=0;\\n    int ones=0;\\n\\n    for(int i = 0; i<strlen(s);i++)\\n    {\\n        if(s[i]==\\'1\\')\\n            ones++;\\n        else\\n            ans=min(ones,ans+1);\\n    }"], ["int minFlipsMonoIncr(char * s){\\n    int ans=0;\\n    int ones=0;\\n\\n    for(int i = 0; i<strlen(s);i++)\\n    {\\n        if(s[i]==\\'1\\')\\n            ones++;\\n        else\\n            ans=min(ones,ans+1);\\n    }"]]}
{"id": "1027", "ref_c": [["int findMaxK(int* nums, int numsSize) {\\n    char set[1001];\\n    memset(set,0,1001);\\n\\n    for (int i=0;i<numsSize;i++)\\n        if (nums[i]>0) {\\n            set[nums[i]] |= 1;\\n        }"], ["int findMaxK(int* nums, int numsSize)\\n{\\n    int x;\\n    int b;\\n    int ret;\\n\\n    ret = -1;\\n    for (x = 0; x < numsSize; x++)\\n    {\\n        if (nums[x] < 0)\\n        {\\n            for (b = 0; b < numsSize; b++)\\n            {\\n                if (-(nums[x]) == nums[b] && x != b)\\n                {\\n                    if (ret < nums[b])\\n                        ret = nums[b];\\n                }"], ["int findMaxK(int* nums, int numsSize) {\\n    char set[1001];\\n    memset(set,0,1001);\\n\\n    for (int i=0;i<numsSize;i++)\\n        if (nums[i]>0) {\\n            set[nums[i]] |= 1;\\n        }"]]}
{"id": "1028", "ref_c": [["int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize){\\n    int n = matrixSize;\\n    int DP[n][n];\\n    for (int col = 0; col < n; col++)\\n        DP[0][col] = matrix[0][col];\\n        \\n    for (int row = 1; row < n; row++){\\n        for (int col = 0; col < n; col++){\\n            if (col == 0)\\n                DP[row][0] = matrix[row][0] + MIN(DP[row-1][0], DP[row-1][1]);\\n            else if (col == n-1)\\n                DP[row][n-1] = matrix[row][n-1] + MIN(DP[row-1][n-1], DP[row-1][n-2]);\\n            else\\n                DP[row][col] = matrix[row][col] + MIN(DP[row-1][col], MIN(DP[row-1][col-1], DP[row-1][col+1]));\\n        }"], ["int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize)\\n{\\n    G = matrix;\\n    N = matrixSize;\\n    int minsum = INVALID;\\n\\n    // Reset memo\\n    for (int i = 0; i < N; i++)\\n        for (int j = 0; j < N; j++)\\n            memo[i][j] = INVALID;\\n\\n    // For each column 0 to N-1\\n    for (int j = 0; j < N; j++)\\n    {\\n        // DFS runs downwards along rows\\n        minsum = min (minsum, dfs (0, j));\\n    }"], ["int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize)\\n{\\n    G = matrix;\\n    N = matrixSize;\\n    int minsum = INVALID;\\n\\n    // Reset memo\\n    for (int i = 0; i < N; i++)\\n        for (int j = 0; j < N; j++)\\n            memo[i][j] = INVALID;\\n\\n    // For each column 0 to N-1\\n    for (int j = 0; j < N; j++)\\n    {\\n        // DFS runs downwards along rows\\n        minsum = min (minsum, dfs (0, j));\\n    }"]]}
{"id": "1029", "ref_c": [["int* beautifulArray(int n, int* returnSize){\\n    int * sol =(int*) malloc(sizeof(int)*n);\\n    *returnSize = n;\\n    if (n == 1){\\n        sol[0] = 1;\\n        return sol;\\n    }"], ["int* beautifulArray(int n, int* returnSize){\\n    int * sol =(int*) malloc(sizeof(int)*n);\\n    *returnSize = n;\\n    if (n == 1){\\n        sol[0] = 1;\\n        return sol;\\n    }"], ["int* beautifulArray(int n, int* returnSize){\\n    int * sol =(int*) malloc(sizeof(int)*n);\\n    *returnSize = n;\\n    if (n == 1){\\n        sol[0] = 1;\\n        return sol;\\n    }"]]}
{"id": "1030", "ref_c": [["int shortestBridge(int** grid, int gridSize, int* gridColSize){\\n    int i , j ,shortest ,distance; \\n    int x = 0 ;\\n    int n = gridSize ;  \\n    int beaches1_size = 0;\\n    int beaches2_size = 0;\\n    int *sizes[2] = {&beaches1_size,&beaches2_size}"], ["int shortestBridge(int** grid, int gridSize, int* gridColSize){\\n    CELL searchQ[gridSize*gridSize];\\n    CELL nextSearchQ[gridSize*gridSize];\\n    int f = -1;\\n    int r = -1;\\n    int r2 = -1;\\n    int i;\\n    int j;\\n    int distance = 1;\\n    int exit = 0;\\n\\n    for (i = 0; i < gridSize && !exit; i++)\\n        for (j = 0; j < gridSize; j++)\\n            if (grid[i][j] == 1)\\n            {\\n                dfs(grid, i, j, gridSize, nextSearchQ, &r2);\\n                exit = 1;\\n                break;\\n            }"], ["int shortestBridge(int** grid, int gridSize, int* gridColSize){\\n    int i , j ,shortest ,distance; \\n    int x = 0 ;\\n    int n = gridSize ;  \\n    int beaches1_size = 0;\\n    int beaches2_size = 0;\\n    int *sizes[2] = {&beaches1_size,&beaches2_size}"]]}
{"id": "1031", "ref_c": [["int knightDialer(int n) {\\n        final int MOD = 1_000_000_007;\\n        int[][] moves = {{4, 6}", "int knightDialer(int n) {\\n        vector<vector<int>> keypad{{4,6}", "int knightDialer(int n) {\\n        vector<vector<int>> keypad{{4,6}"], ["int knightDialer(int n) {\\n        if(n == 1) return 10; // If n is 1, there are 10 possible starting positions for the knight.\\n\\n        unordered_map<int, vector<int>> mp; // Map to store the possible moves for each key/button on the dial pad.\\n        int MOD = 1000000007; // Modulo value for handling large numbers.\\n\\n        // Assigning possible moves for each key/button on the dial pad.\\n        mp[0] = {4, 6}", "int knightDialer(int n) {\\n    if (n == 1) return 10; // If n is 1, there are 10 possible starting positions for the knight.\\n\\n    int moves[10][2] = { {4, 6}", "int knightDialer(int n) {\\n        if (n == 1) {\\n            return 10; // If n is 1, there are 10 possible starting positions for the knight.\\n        }", "int knightDialer(int n) {\\n        this->n = n;\\n        memo = vector(n + 1, vector<int>(10, 0)); // Initialize memoization array\\n        int ans = 0;\\n        // Calculate the total number of moves for each starting square\\n        for (int square = 0; square < 10; square++) {\\n            ans = (ans + dp(n - 1, square)) % MOD; // Add the count of possible moves for each starting square\\n        }", "int knightDialer(int n) {\\n    int ans = 0;\\n    for (int square = 0; square < 10; square++) {\\n        ans = (ans + dp(n - 1, square)) % MOD;\\n    }", "int knightDialer(int n) {\\n        this.n = n;\\n        memo = new int[n + 1][10];\\n        int ans = 0;\\n        for (int square = 0; square < 10; square++) {\\n            ans = (ans + dp(n - 1, square)) % MOD;\\n        }", "int knightDialer(int n) {\\n        // Define the possible moves from each digit on the dial pad\\n        vector<vector<int>> jumps = {\\n            {4, 6}", "int knightDialer(int n) {\\n    int jumps[10][3] = {\\n        {4, 6, -1}", "int knightDialer(int n) {\\n        int[][] jumps = {\\n            {4, 6}", "int knightDialer(int n) {\\n        // Define possible jumps for each key/button on the dial pad\\n        vector<vector<int>> jumps = {\\n            {4, 6}", "int knightDialer(int n) {\\n    int jumps[10][3] = {\\n        {4, 6, -1}", "int knightDialer(int n) {\\n        int[][] jumps = {\\n            {4, 6}", "int knightDialer(int n) {\\n        // If n is 1, there are 10 possible starting positions for the knight.\\n        if (n == 1) {\\n            return 10;\\n        }", "int knightDialer(int n) {\\n    if (n == 1) {\\n        return 10;\\n    }", "int knightDialer(int n) {\\n        if (n == 1) {\\n            return 10;\\n        }", "int knightDialer(int n) {\\n        if (n == 1) {\\n            return 10; // If n is 1, there are 10 possible starting positions for the knight.\\n        }", "int knightDialer(int n) {\\n    if (n == 1) {\\n        return 10;\\n    }", "int knightDialer(int n) {\\n        if (n == 1) {\\n            return 10;\\n        }"], ["int knightDialer(int n) {\\n        // Initialize an array to store the possible positions of the knight on the phone pad\\n        vector<long long> curPos(10, 1);\\n\\n        // Loop through the number of jumps required\\n        for (int jump = 2; jump <= n; jump++) {\\n            // Create a new array to store the updated positions after each jump\\n            vector<long long> newPos(10);\\n\\n            // Calculate the new positions based on the valid knight moves\\n            newPos[0] = (curPos[6] + curPos[4]) % MOD;\\n            newPos[1] = (curPos[6] + curPos[8]) % MOD;\\n            newPos[2] = (curPos[7] + curPos[9]) % MOD;\\n            newPos[3] = (curPos[4] + curPos[8]) % MOD;\\n            newPos[4] = (curPos[0] + curPos[3] + curPos[9]) % MOD;\\n            newPos[5] = 0;  // Knight cannot move to position 5\\n            newPos[6] = (curPos[0] + curPos[1] + curPos[7]) % MOD;\\n            newPos[7] = (curPos[2] + curPos[6]) % MOD;\\n            newPos[8] = (curPos[1] + curPos[3]) % MOD;\\n            newPos[9] = (curPos[2] + curPos[4]) % MOD;\\n\\n            // Update the current positions array for the next iteration\\n            curPos = newPos;\\n        }", "int knightDialer(int n) {\\n        // Initialize an array to store the possible positions of the knight on the phone pad\\n        long[] curPos = new long[10];\\n        Arrays.fill(curPos, 1);\\n\\n        // Loop through the number of jumps required\\n        for (int jump = 2; jump <= n; jump++) {\\n            // Create a new array to store the updated positions after each jump\\n            long[] newPos = new long[10];\\n\\n            // Calculate the new positions based on the valid knight moves\\n            newPos[0] = (curPos[6] + curPos[4]) % MOD;\\n            newPos[1] = (curPos[6] + curPos[8]) % MOD;\\n            newPos[2] = (curPos[7] + curPos[9]) % MOD;\\n            newPos[3] = (curPos[4] + curPos[8]) % MOD;\\n            newPos[4] = (curPos[0] + curPos[3] + curPos[9]) % MOD;\\n            newPos[5] = 0;  // Knight cannot move to position 5\\n            newPos[6] = (curPos[0] + curPos[1] + curPos[7]) % MOD;\\n            newPos[7] = (curPos[2] + curPos[6]) % MOD;\\n            newPos[8] = (curPos[1] + curPos[3]) % MOD;\\n            newPos[9] = (curPos[2] + curPos[4]) % MOD;\\n\\n            // Update the current positions array for the next iteration\\n            curPos = newPos;\\n        }", "int knightDialer(int n) {\\n    // Initialize an array to store the possible positions of the knight on the phone pad\\n    long long cur_pos[10];\\n    for (int i = 0; i < 10; ++i) {\\n        cur_pos[i] = 1;\\n    }"]]}
{"id": "1032", "ref_c": [["char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){\\n    qsort(logs, logsSize, sizeof(char *), cmp);\\n    return *returnSize = logsSize, logs;\\n}"], ["char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){\\n    qsort(logs, logsSize, sizeof(char *), cmp);\\n    return *returnSize = logsSize, logs;\\n}"], ["char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){\\n\\n    merge_sort(logs, 0, logsSize - 1);\\n    \\n    *returnSize = logsSize;\\n    return logs;\\n}"]]}
{"id": "1033", "ref_c": [["int minAreaRect(int** points, int pointsSize, int* pointsColSize){\\n\\n    if(pointsSize<4)\\n    {\\n        return 0;\\n    }"], ["int minAreaRect(int** points, int pointsSize, int* pointsColSize){\\n\\n    if(pointsSize<4)\\n    {\\n        return 0;\\n    }"], ["int minAreaRect(int** points, int pointsSize, int* pointsColSize){\\n\\n    if(pointsSize<4)\\n    {\\n        return 0;\\n    }"]]}
{"id": "1034", "ref_c": [["int minIncrementForUnique(int* nums, int numsSize){\\n\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    int mapp[100005]={0}"], ["int minIncrementForUnique(int* nums, int numsSize){\\n    \\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    int no_incs = 0;\\n  \\n    for(size_t i = 1 ; i < numsSize ; i++)\\n    {\\n        if (nums[i] <= nums[i-1])\\n        {\\n            no_incs += (nums[i-1] - nums[i] +1);\\n            nums[i] += (nums[i-1] - nums[i] +1); \\n        }"], ["int minIncrementForUnique(int* nums, int numsSize){\\n    int hist[200001] = {0}"]]}
{"id": "1035", "ref_c": [["bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){\\n    int popi = 0, stack[1000] , top = -1;\\n    for (int i = 0 ; i < pushedSize ; i++ ){\\n        stack[++top] = pushed[i];\\n        while(top!=-1 && popped[popi] == stack[top]){\\n            top--;\\n            popi++;\\n        }"], ["bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){\\nint top=-1, l=0; \\n    for(int i=0; i<pushedSize; i++){\\n        top++;\\n        pushed[top]=pushed[i];\\n        while(top>-1){\\n            if(pushed[top]==popped[l]){\\n                top--;\\n                l++;\\n            }"], ["bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){\\n\\n    int top = 0;\\n    int i=0;\\n    while (1)\\n    {\\n        if (top >= pushedSize || i >= poppedSize)\\n        break;\\n        if (pushed[top] == -1)\\n        {\\n            top++;\\n            continue;\\n        }"]]}
{"id": "1036", "ref_c": [["int removeStones(int** stones, int stonesSize, int* stonesColSize) {\\n\\tstruct stone_hash* set = NULL;\\t\\t\\t/* Set of connected stones */\\n\\tstruct stone_hash* by_row = NULL;\\t\\t/* First stone at each row location */\\n\\tstruct stone_hash* by_col = NULL;\\t\\t/* First stone at each col location */\\n\\tstruct stone_hash* const entries = malloc(stonesSize * sizeof(struct stone_hash));\\n\\n\\tfor (int i = 0; i < stonesSize; ++i) {\\n\\t\\tstruct stone_hash* entry = &entries[i];\\n\\t\\tstruct stone_hash* row_entry;\\n\\t\\tstruct stone_hash* col_entry;\\n\\t\\tHASH_FIND(by_row_hh, by_row, &stones[i][0], sizeof(stones[i][0]), row_entry);\\n\\t\\tHASH_FIND(by_col_hh, by_col, &stones[i][1], sizeof(stones[i][1]), col_entry);\\n\\t\\tif (row_entry && col_entry) {\\n\\t\\t\\tstruct stone_hash* row_parent = find_parent(row_entry);\\n\\t\\t\\tstruct stone_hash* col_parent = find_parent(col_entry);\\n\\t\\t\\t/* Different parents mean we need to link the trees together */\\n\\t\\t\\tif (row_parent != col_parent) {\\n\\t\\t\\t\\tcol_parent->parent = row_parent;\\n\\t\\t\\t\\t/* Since the col_parent is now connected, remove from the main set */\\n\\t\\t\\t\\tHASH_DELETE(set_hh, set, col_parent);\\n\\t\\t\\t}"], ["int removeStones(int** stones, int stonesSize, int* stonesColSize) {\\n\\tstruct stone_hash* set = NULL;\\t\\t\\t/* Set of connected stones */\\n\\tstruct stone_hash* by_row = NULL;\\t\\t/* First stone at each row location */\\n\\tstruct stone_hash* by_col = NULL;\\t\\t/* First stone at each col location */\\n\\tstruct stone_hash* const entries = malloc(stonesSize * sizeof(struct stone_hash));\\n\\n\\tfor (int i = 0; i < stonesSize; ++i) {\\n\\t\\tstruct stone_hash* entry = &entries[i];\\n\\t\\tstruct stone_hash* row_entry;\\n\\t\\tstruct stone_hash* col_entry;\\n\\t\\tHASH_FIND(by_row_hh, by_row, &stones[i][0], sizeof(stones[i][0]), row_entry);\\n\\t\\tHASH_FIND(by_col_hh, by_col, &stones[i][1], sizeof(stones[i][1]), col_entry);\\n\\t\\tif (row_entry && col_entry) {\\n\\t\\t\\tstruct stone_hash* row_parent = find_parent(row_entry);\\n\\t\\t\\tstruct stone_hash* col_parent = find_parent(col_entry);\\n\\t\\t\\t/* Different parents mean we need to link the trees together */\\n\\t\\t\\tif (row_parent != col_parent) {\\n\\t\\t\\t\\tcol_parent->parent = row_parent;\\n\\t\\t\\t\\t/* Since the col_parent is now connected, remove from the main set */\\n\\t\\t\\t\\tHASH_DELETE(set_hh, set, col_parent);\\n\\t\\t\\t}"], ["int removeStones(int** stones, int stonesSize, int* stonesColSize) {\\n\\tstruct stone_hash* set = NULL;\\t\\t\\t/* Set of connected stones */\\n\\tstruct stone_hash* by_row = NULL;\\t\\t/* First stone at each row location */\\n\\tstruct stone_hash* by_col = NULL;\\t\\t/* First stone at each col location */\\n\\tstruct stone_hash* const entries = malloc(stonesSize * sizeof(struct stone_hash));\\n\\n\\tfor (int i = 0; i < stonesSize; ++i) {\\n\\t\\tstruct stone_hash* entry = &entries[i];\\n\\t\\tstruct stone_hash* row_entry;\\n\\t\\tstruct stone_hash* col_entry;\\n\\t\\tHASH_FIND(by_row_hh, by_row, &stones[i][0], sizeof(stones[i][0]), row_entry);\\n\\t\\tHASH_FIND(by_col_hh, by_col, &stones[i][1], sizeof(stones[i][1]), col_entry);\\n\\t\\tif (row_entry && col_entry) {\\n\\t\\t\\tstruct stone_hash* row_parent = find_parent(row_entry);\\n\\t\\t\\tstruct stone_hash* col_parent = find_parent(col_entry);\\n\\t\\t\\t/* Different parents mean we need to link the trees together */\\n\\t\\t\\tif (row_parent != col_parent) {\\n\\t\\t\\t\\tcol_parent->parent = row_parent;\\n\\t\\t\\t\\t/* Since the col_parent is now connected, remove from the main set */\\n\\t\\t\\t\\tHASH_DELETE(set_hh, set, col_parent);\\n\\t\\t\\t}"]]}
{"id": "1037", "ref_c": ["\nint cmp(const void *a, const void *b)\n{\n    return *((int *)a) - *((int *)b);\n}\n\nint bagOfTokensScore(int* tokens, int tokensSize, int power){\n    /*\n     * Input:\n     *  tokens, integer array contains different power values\n     *  tokensSize, number of elements in given array\n     *  power, integer, initial power value\n     */\n     \n    int score = 0;\n    \n    qsort(tokens, tokensSize, sizeof(int), cmp);\n    \n    /* \n     * Dry run:\n     *  power = 100, score = 0, tokens = [100, 200, 300]\n     *  => power = 0, score = 1, tokens = [200, 300]\n     *  => power = 300, score = 0, tokens = [200]\n     *  => power = 100, score = 1, tokens = []\n     *  => MAX score = 1\n     */\n     \n    for (int i = 0, j = tokensSize - 1; i <= j; ) {\n    \n        /* Using power to gain score */\n        if (power >= tokens[i]) {\n            score++;\n            power -= tokens[i];\n            i++;\n        }\n        /* \n         * Using 1 score to gain more power only while \n         * there are still available tokens.\n         */\n        else if (i != j && score != 0) {\n            score--;\n            power += tokens[j];\n            j--;\n        }\n        /* Can't get more score or power anymore */\n        else {\n            break;\n        }\n    }\n     \n    /*\n     * Output:\n     *  Return the largest possible score you can achieve after \n     *  playing any number of tokens (start from 0).\n     */\n     \n    return score;\n}\n", "\nint cmp(const void *a, const void *b)\n{\n    return *((int *)a) - *((int *)b);\n}\n\nint bagOfTokensScore(int* tokens, int tokensSize, int power){\n    /*\n     * Input:\n     *  tokens, integer array contains different power values\n     *  tokensSize, number of elements in given array\n     *  power, integer, initial power value\n     */\n     \n    int score = 0;\n    \n    qsort(tokens, tokensSize, sizeof(int), cmp);\n    \n    /* \n     * Dry run:\n     *  power = 100, score = 0, tokens = [100, 200, 300]\n     *  => power = 0, score = 1, tokens = [200, 300]\n     *  => power = 300, score = 0, tokens = [200]\n     *  => power = 100, score = 1, tokens = []\n     *  => MAX score = 1\n     */\n     \n    for (int i = 0, j = tokensSize - 1; i <= j; ) {\n    \n        /* Using power to gain score */\n        if (power >= tokens[i]) {\n            score++;\n            power -= tokens[i];\n            i++;\n        }\n        /* \n         * Using 1 score to gain more power only while \n         * there are still available tokens.\n         */\n        else if (i != j && score != 0) {\n            score--;\n            power += tokens[j];\n            j--;\n        }\n        /* Can't get more score or power anymore */\n        else {\n            break;\n        }\n    }\n     \n    /*\n     * Output:\n     *  Return the largest possible score you can achieve after \n     *  playing any number of tokens (start from 0).\n     */\n     \n    return score;\n}\n", "\nint cmp(const void *a, const void *b)\n{\n    return *((int *)a) - *((int *)b);\n}\n\nint bagOfTokensScore(int* tokens, int tokensSize, int power){\n    /*\n     * Input:\n     *  tokens, integer array contains different power values\n     *  tokensSize, number of elements in given array\n     *  power, integer, initial power value\n     */\n     \n    int score = 0;\n    \n    qsort(tokens, tokensSize, sizeof(int), cmp);\n    \n    /* \n     * Dry run:\n     *  power = 100, score = 0, tokens = [100, 200, 300]\n     *  => power = 0, score = 1, tokens = [200, 300]\n     *  => power = 300, score = 0, tokens = [200]\n     *  => power = 100, score = 1, tokens = []\n     *  => MAX score = 1\n     */\n     \n    for (int i = 0, j = tokensSize - 1; i <= j; ) {\n    \n        /* Using power to gain score */\n        if (power >= tokens[i]) {\n            score++;\n            power -= tokens[i];\n            i++;\n        }\n        /* \n         * Using 1 score to gain more power only while \n         * there are still available tokens.\n         */\n        else if (i != j && score != 0) {\n            score--;\n            power += tokens[j];\n            j--;\n        }\n        /* Can't get more score or power anymore */\n        else {\n            break;\n        }\n    }\n     \n    /*\n     * Output:\n     *  Return the largest possible score you can achieve after \n     *  playing any number of tokens (start from 0).\n     */\n     \n    return score;\n}\n"]}
{"id": "1038", "ref_c": [["char * largestTimeFromDigits(int* arr, int arrSize){\\n    int hash[10] = {0}"], ["char * largestTimeFromDigits(int* arr, int arrSize){\\n    int hash[10] = {0}"], ["char * largestTimeFromDigits(int* arr, int arrSize){\\n    int hash[10] = {0}"]]}
{"id": "1039", "ref_c": [["int* deckRevealedIncreasing(int* deck, int deckSize, int* returnSize){\\n    qsort(deck, deckSize, sizeof(int), cmpfunc);\\n\\n    qNode* indexHead = NULL; qNode* indexTail = NULL; //build the queue\\n    for (int i = 0; i < deckSize; ++i) {\\n        enQ(i, &indexHead, &indexTail); //queue stores indices of numbers in sorted array, and we populate result accordingly\\n    }"], ["int* deckRevealedIncreasing(int* deck, int deckSize, int* returnSize){\\n    qsort(deck, deckSize, sizeof(int), cmpfunc);\\n\\n    qNode* indexHead = NULL; qNode* indexTail = NULL; //build the queue\\n    for (int i = 0; i < deckSize; ++i) {\\n        enQ(i, &indexHead, &indexTail); //queue stores indices of numbers in sorted array, and we populate result accordingly\\n    }"], ["int* deckRevealedIncreasing(int* deck, int deckSize, int* returnSize){\\n  int temp;\\n  *returnSize=0;\\n  int*ans=(int*)malloc(sizeof(int)*100000);\\n  for(int j=0;j<deckSize-1;j++){\\n  for(int i=0;i<deckSize-1;i++){\\n    if(deck[i]>deck[i+1]){\\n    temp=deck[i];\\n    deck[i]=deck[i+1];\\n    deck[i+1]=temp;\\n    }"]]}
{"id": "1040", "ref_c": [["bool flipEquiv(struct TreeNode* root1, struct TreeNode* root2){\\n\\n    return fev(root1,root2);\\n\\n}"], ["bool flipEquiv(struct TreeNode* root1, struct TreeNode* root2){\\n    if(root1 && root2 && (root1->val == root2->val)) return (flipEquiv(root1->left, root2->left) || flipEquiv(root1->left, root2->right)) && (flipEquiv(root1->right, root2->left) || flipEquiv(root1->right, root2->right));\\n    else if(!root1 && !root2) return true;\\n    else return false;\\n}"], ["bool flipEquiv(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    bool match = true;\\n    flip(root1, root2, &match);\\n    return match;\\n}"]]}
{"id": "1041", "ref_c": [["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"]]}
{"id": "1042", "ref_c": [["char * oddString(char ** words, int wordsSize){\\n    int *checksum = (int*)calloc(wordsSize,sizeof(int));\\n    int i = 0;\\n\\n    while(words[0][i + 1] != \\'\\\\0\\')\\n    {\\n        uint8_t check = 0;\\n        for(uint8_t j = 0; j < wordsSize ;j++)\\n        {\\n            checksum[j] = difference(words[j][i + 1], words[j][i]); \\n            if(j > 0)\\n            {\\n                if(checksum[j-1] != checksum[j])  check = 1;\\n                if(check)\\n                {\\n                    if(j + 1 >= wordsSize) return &words[j][0];\\n                    checksum[j + 1] = difference(words[j+1][i + 1],words[j+1][i]);\\n                    if(checksum[j] == checksum[j+1]) return &words[j-1][0];\\n                    return &words[j][0];\\n                }"], ["char * oddString(char ** words, int wordsSize){\\n    int *checksum = (int*)calloc(wordsSize,sizeof(int));\\n    int i = 0;\\n\\n    while(words[0][i + 1] != \\'\\\\0\\')\\n    {\\n        uint8_t check = 0;\\n        for(uint8_t j = 0; j < wordsSize ;j++)\\n        {\\n            checksum[j] = difference(words[j][i + 1], words[j][i]); \\n            if(j > 0)\\n            {\\n                if(checksum[j-1] != checksum[j])  check = 1;\\n                if(check)\\n                {\\n                    if(j + 1 >= wordsSize) return &words[j][0];\\n                    checksum[j + 1] = difference(words[j+1][i + 1],words[j+1][i]);\\n                    if(checksum[j] == checksum[j+1]) return &words[j-1][0];\\n                    return &words[j][0];\\n                }"], ["char * oddString(char ** words, int wordsSize){\\n    int *checksum = (int*)calloc(wordsSize,sizeof(int));\\n    int i = 0;\\n\\n    while(words[0][i + 1] != \\'\\\\0\\')\\n    {\\n        uint8_t check = 0;\\n        for(uint8_t j = 0; j < wordsSize ;j++)\\n        {\\n            checksum[j] = difference(words[j][i + 1], words[j][i]); \\n            if(j > 0)\\n            {\\n                if(checksum[j-1] != checksum[j])  check = 1;\\n                if(check)\\n                {\\n                    if(j + 1 >= wordsSize) return &words[j][0];\\n                    checksum[j + 1] = difference(words[j+1][i + 1],words[j+1][i]);\\n                    if(checksum[j] == checksum[j+1]) return &words[j-1][0];\\n                    return &words[j][0];\\n                }"]]}
{"id": "1043", "ref_c": [["double average(int* salary, int salarySize){\\n\\n    int total = 0;\\n    int max = salary[0];\\n    int min = salary[0];\\n\\n    for(int i = 0; i < salarySize; i++){\\n        total += salary[i];\\n        if(max < salary[i])\\n            max = salary[i];\\n        else if(min > salary[i])\\n            min = salary[i];\\n    }"], ["double average(int* salary, int salarySize){\\n\\n    int total = 0;\\n    int max = salary[0];\\n    int min = salary[0];\\n\\n    for(int i = 0; i < salarySize; i++){\\n        total += salary[i];\\n        if(max < salary[i])\\n            max = salary[i];\\n        else if(min > salary[i])\\n            min = salary[i];\\n    }"], ["double average(int* salary, int salarySize){\\n\\n    int total = 0;\\n    int max = salary[0];\\n    int min = salary[0];\\n\\n    for(int i = 0; i < salarySize; i++){\\n        total += salary[i];\\n        if(max < salary[i])\\n            max = salary[i];\\n        else if(min > salary[i])\\n            min = salary[i];\\n    }"]]}
{"id": "1044", "ref_c": [["bool isCompleteTree(struct TreeNode* root){\\n  // level order traverse\\n  // once find Nil, shouldn\\'t find any node afterwards\\n  struct queue * queue = calloc(1, sizeof(struct queue));\\n  bool notYetNull = 1; // 1 if we haven\\'t find NULL node\\n  enqueue(root, queue);\\n  while (queue->nums > 0)\\n  {\\n    struct TreeNode* now = dequeue(queue);\\n\\n    if (now->left != NULL)\\n    {\\n      if (notYetNull)\\n        enqueue(now->left, queue);\\n      else\\n        return 0;\\n    }"], ["bool isCompleteTree(struct TreeNode* root){\\n  bool used = false;\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int depth = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++depth;\\n  }", "bool isCompleteTree(struct TreeNode* root) {\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int target = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++target;\\n  }"], ["bool isCompleteTree(struct TreeNode* root){\\n  // level order traverse\\n  // once find Nil, shouldn\\'t find any node afterwards\\n  struct queue * queue = calloc(1, sizeof(struct queue));\\n  bool notYetNull = 1; // 1 if we haven\\'t find NULL node\\n  enqueue(root, queue);\\n  while (queue->nums > 0)\\n  {\\n    struct TreeNode* now = dequeue(queue);\\n\\n    if (now->left != NULL)\\n    {\\n      if (notYetNull)\\n        enqueue(now->left, queue);\\n      else\\n        return 0;\\n    }"]]}
{"id": "1045", "ref_c": [["int regionsBySlashes(char ** grid, int gridSize){\\n    int n = gridSize;\\n    int dude[n*3][n*3];\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            int row=3*i;\\n            int col=3*j;\\n            if(grid[i][j]==\\'/\\'){\\n                dude[row][col]=0;\\n                dude[row][col+1]=0;\\n                dude[row][col+2]=1;\\n                dude[row+1][col]=0;\\n                dude[row+1][col+1]=1;\\n                dude[row+1][col+2]=0;\\n                dude[row+2][col]=1;\\n                dude[row+2][col+1]=0;\\n                dude[row+2][col+2]=0;\\n            }"], ["int regionsBySlashes(char ** grid, int gridSize){\\n    int n = gridSize;\\n    int dude[n*3][n*3];\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            int row=3*i;\\n            int col=3*j;\\n            if(grid[i][j]==\\'/\\'){\\n                dude[row][col]=0;\\n                dude[row][col+1]=0;\\n                dude[row][col+2]=1;\\n                dude[row+1][col]=0;\\n                dude[row+1][col+1]=1;\\n                dude[row+1][col+2]=0;\\n                dude[row+2][col]=1;\\n                dude[row+2][col+1]=0;\\n                dude[row+2][col+2]=0;\\n            }"], ["int regionsBySlashes(char ** grid, int gridSize){\\n    int n = gridSize;\\n    int dude[n*3][n*3];\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            int row=3*i;\\n            int col=3*j;\\n            if(grid[i][j]==\\'/\\'){\\n                dude[row][col]=0;\\n                dude[row][col+1]=0;\\n                dude[row][col+2]=1;\\n                dude[row+1][col]=0;\\n                dude[row+1][col+1]=1;\\n                dude[row+1][col+2]=0;\\n                dude[row+2][col]=1;\\n                dude[row+2][col+1]=0;\\n                dude[row+2][col+2]=0;\\n            }"]]}
{"id": "1046", "ref_c": [["int maxWidthRamp(int* nums, int numsSize){\\n    int stack[numsSize];\\n    int idx=-1;\\n    int res=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(idx==-1 || nums[stack[idx]]>nums[i]){\\n            stack[++idx]=i;\\n        }"], ["int maxWidthRamp(int* nums, int numsSize){\\n    int stack[numsSize];\\n    int idx=-1;\\n    int res=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(idx==-1 || nums[stack[idx]]>nums[i]){\\n            stack[++idx]=i;\\n        }"], ["int maxWidthRamp(int* nums, int numsSize){\\n    int stack[numsSize];\\n    int idx=-1;\\n    int res=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(idx==-1 || nums[stack[idx]]>nums[i]){\\n            stack[++idx]=i;\\n        }"]]}
{"id": "1047", "ref_c": [["char * validIPAddress(char * queryIP){\\n    char * ret = validIPv4(queryIP);\\n    if (ret) {\\n        return ret;\\n    }"], ["char * validIPAddress(char * queryIP){\\n    char * ret = validIPv4(queryIP);\\n    if (ret) {\\n        return ret;\\n    }"], ["char * validIPAddress(char * queryIP){\\n    char * ret = validIPv4(queryIP);\\n    if (ret) {\\n        return ret;\\n    }"]]}
{"id": "1048", "ref_c": [["int getMinDistance(int* nums, int numsSize, int target, int start) \\n{\\n    int minDistance = INT_MAX;\\n\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        if (nums[i] == target)\\n        {\\n            int currentDistance = (abs(i - start));\\n            if (minDistance > currentDistance)\\n                minDistance = currentDistance;\\n        }"], ["int getMinDistance(int* nums, int numsSize, int target, int start){\\n    int x,minimum=INT_MAX;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==target){\\n            x=abs(i-start);\\n            if(x<minimum)\\n                minimum=x;\\n        }"], ["int getMinDistance(int* nums, int numsSize, int target, int start){\\n    int x,minimum=INT_MAX;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==target){\\n            x=abs(i-start);\\n            if(x<minimum)\\n                minimum=x;\\n        }"]]}
{"id": "1049", "ref_c": ["\nvoid solve(int n,int k,int num,int **result,int *index,int *size,int digits) {\n    if(digits == n) {\n        if(*index == *size) {\n            *result = realloc(*result,2*(*size)*sizeof(int));\n            (*size)*=2;\n        }\n        (*result)[(*index)++] = num;\n        return;\n    }\n    int i;\n    for(i = 0;i < 10;i++) {\n        if(abs((num%10)-i) == k) {\n            num *= 10;\n            num += i;\n            solve(n,k,num,result,index,size,digits+1);\n            num/=10;\n        }\n    }\n    \n}\n\nint beginSearch(int n, int k,int **result,int *size) {\n    int start,index = 0;\n    for(start = 1;start <= 9;start++) {\n        solve(n,k,start,result,&index,size,1);\n    }\n    return index;\n}\n\nint* numsSameConsecDiff(int n, int k, int* returnSize) {\n    int *result = malloc(sizeof(int));\n    int size = 1;\n    *returnSize = beginSearch(n,k,&result,&size);\n    return result;\n}\n", "\nvoid solve(int n,int k,int num,int **result,int *index,int *size,int digits) {\n    if(digits == n) {\n        if(*index == *size) {\n            *result = realloc(*result,2*(*size)*sizeof(int));\n            (*size)*=2;\n        }\n        (*result)[(*index)++] = num;\n        return;\n    }\n    int i;\n    for(i = 0;i < 10;i++) {\n        if(abs((num%10)-i) == k) {\n            num *= 10;\n            num += i;\n            solve(n,k,num,result,index,size,digits+1);\n            num/=10;\n        }\n    }\n    \n}\n\nint beginSearch(int n, int k,int **result,int *size) {\n    int start,index = 0;\n    for(start = 1;start <= 9;start++) {\n        solve(n,k,start,result,&index,size,1);\n    }\n    return index;\n}\n\nint* numsSameConsecDiff(int n, int k, int* returnSize) {\n    int *result = malloc(sizeof(int));\n    int size = 1;\n    *returnSize = beginSearch(n,k,&result,&size);\n    return result;\n}\n", "\nvoid solve(int n,int k,int num,int **result,int *index,int *size,int digits) {\n    if(digits == n) {\n        if(*index == *size) {\n            *result = realloc(*result,2*(*size)*sizeof(int));\n            (*size)*=2;\n        }\n        (*result)[(*index)++] = num;\n        return;\n    }\n    int i;\n    for(i = 0;i < 10;i++) {\n        if(abs((num%10)-i) == k) {\n            num *= 10;\n            num += i;\n            solve(n,k,num,result,index,size,digits+1);\n            num/=10;\n        }\n    }\n    \n}\n\nint beginSearch(int n, int k,int **result,int *size) {\n    int start,index = 0;\n    for(start = 1;start <= 9;start++) {\n        solve(n,k,start,result,&index,size,1);\n    }\n    return index;\n}\n\nint* numsSameConsecDiff(int n, int k, int* returnSize) {\n    int *result = malloc(sizeof(int));\n    int size = 1;\n    *returnSize = beginSearch(n,k,&result,&size);\n    return result;\n}\n"]}
{"id": "1050", "ref_c": [["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n; // since n = number of elements to be returned\\n    char **answer; // the string of strings where the right elements will be copied\\n    char str[5]; // every string contains at most 5 character (max number is 10000 => 5 characters)\\n    \\n    i = 1; // first number we want to return is 1\\n    answer = NULL;\\n    answer = malloc(sizeof(*answer) * n); // our string of strings will have the same number of element than the returning one (n)\\n    if (!answer)\\n        return (answer); // securizing our malloc => returning NULL if something went wrong\\n    while (i <= n)\\n    {\\n        if (i % 15 == 0)\\n            answer[i - 1] = strdup(\"FizzBuzz\"); // NB we need to start duplicating from position 0 => (i - 1)\\n        else if (i % 3 == 0)\\n            answer[i - 1] = strdup(\"Fizz\");\\n        else if (i % 5 == 0)\\n            answer[i - 1] = strdup(\"Buzz\");\\n        else\\n        {\\n            sprintf(str, \"%d\", i); // converting integer i into char and storing it in str\\n            answer[i - 1] = strdup(str);\\n        }"], ["char ** fizzBuzz(int n, int* returnSize){\\n    *returnSize = n;\\n    char **T = (char**)malloc(sizeof(char*)*n);\\n    for(int i=0;i<n;i++){\\n        T[i]=(char*)malloc(9*sizeof(char));\\n        sprintf(T[i], \"%d\", i+1);  // Convert \\'i\\' to char \\n        if( (i+1) % 3 == 0 && (i+1) % 5 == 0){T[i] = \"FizzBuzz\";}"], ["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    char**arr = malloc(n*sizeof(char*));\\n    *returnSize = n;\\n    for(int i=1;i<=n;i++)\\n    {\\n        arr[i - 1] = malloc(9 * sizeof(char));\\n        if(i%15==0)\\n        arr[i-1] = \"FizzBuzz\";\\n        else if(i%3==0)\\n        arr[i-1]=\"Fizz\";\\n        else if(i%5==0)\\n        arr[i-1]=\"Buzz\";\\n        else\\n        sprintf(arr[i-1], \"%d\", i);\\n    }"]]}
{"id": "1051", "ref_c": [["int* powerfulIntegers(int x, int y, int bound, int* returnSize) {\\n    int* checkTable = calloc(bound+1, sizeof(int));\\n    int* ans = calloc(bound+1, sizeof(int));\\n    int powerX = 1, powerY = 1;\\n    *returnSize = 0;\\n    \\n    while(powerX + powerY <= bound)\\n    {\\n        while(powerX + powerY <= bound)\\n        {\\n            checkTable[powerX+powerY] = 1;\\n            if(y == 1) break;\\n            powerY *= y;\\n        }"], ["int* powerfulIntegers(int x, int y, int bound, int* returnSize) {\\n    int* checkTable = calloc(bound+1, sizeof(int));\\n    int* ans = calloc(bound+1, sizeof(int));\\n    int powerX = 1, powerY = 1;\\n    *returnSize = 0;\\n    \\n    while(powerX + powerY <= bound)\\n    {\\n        while(powerX + powerY <= bound)\\n        {\\n            checkTable[powerX+powerY] = 1;\\n            if(y == 1) break;\\n            powerY *= y;\\n        }"], ["int* powerfulIntegers(int x, int y, int bound, int* returnSize) {\\n    int* checkTable = calloc(bound+1, sizeof(int));\\n    int* ans = calloc(bound+1, sizeof(int));\\n    int powerX = 1, powerY = 1;\\n    *returnSize = 0;\\n    \\n    while(powerX + powerY <= bound)\\n    {\\n        while(powerX + powerY <= bound)\\n        {\\n            checkTable[powerX+powerY] = 1;\\n            if(y == 1) break;\\n            powerY *= y;\\n        }"]]}
{"id": "1052", "ref_c": [["int* flipMatchVoyage(struct TreeNode* root, int* voyage, int voyageSize, int* returnSize) {\\n    int* res = (int*) malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    voyIdx = 0, IsOver = false;\\n    dfs(root, voyage, res, returnSize);\\n    return res;\\n}"], ["int* flipMatchVoyage(struct TreeNode* root, int* voyage, int voyageSize, int* returnSize) {\\n    int* res = (int*) malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    voyIdx = 0, IsOver = false;\\n    dfs(root, voyage, res, returnSize);\\n    return res;\\n}"], ["int* flipMatchVoyage(struct TreeNode* root, int* voyage, int voyageSize, int* returnSize) {\\n    int* res = (int*) malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    voyIdx = 0, IsOver = false;\\n    dfs(root, voyage, res, returnSize);\\n    return res;\\n}"]]}
{"id": "1053", "ref_c": [["int** kClosest(int** points, int pointsSize, int* pointsColSize, int k, int* returnSize, int** returnColumnSizes){\\n    \\n    int** data = (int**)malloc(k * sizeof(int*));\\n    for (int i = 0; i < k; i++) {\\n        data[i] = (int*)malloc(2 * sizeof(int));\\n    }"], ["int** kClosest(int** points, int pointsSize, int* pointsColSize, int k, int* returnSize, int** returnColumnSizes){\\n    \\n    int** data = (int**)malloc(k * sizeof(int*));\\n    for (int i = 0; i < k; i++) {\\n        data[i] = (int*)malloc(2 * sizeof(int));\\n    }"], ["int** kClosest(int** points, int pointsSize, int* pointsColSize, int k, int* returnSize, int** returnColumnSizes){\\n    \\n    int** data = (int**)malloc(k * sizeof(int*));\\n    for (int i = 0; i < k; i++) {\\n        data[i] = (int*)malloc(2 * sizeof(int));\\n    }"]]}
{"id": "1054", "ref_c": [["int subarraysDivByK(int* nums, int numsSize, int k){\\n    char cIndex = 0;\\n    short sNumsSize = numsSize, sK = k, sOffset = 0;\\n    int nCount[sK], nRet = 0;\\n    memset(nCount, 0, sK*sizeof(int));\\n\\n    while(numsSize-- > 0)\\n    {\\n        // get current remainder index\\n        short sIndex = *nums % sK;\\n        if(sIndex < 0) sIndex += sK;\\n\\n        // update current offset of index\\n        sOffset = (sOffset + sIndex) % sK;\\n\\n        // add count of new *nums into correspond index\\n        sIndex = sIndex < sOffset? sIndex + sK - sOffset: sIndex - sOffset;\\n        nCount[sIndex]++;\\n\\n        // add count into return if the remainder is 0\\n        nRet += nCount[sOffset? sK - sOffset: 0];\\n\\n        nums++;\\n    }"], ["int subarraysDivByK(int* nums, int numsSize, int k){\\n    char cIndex = 0;\\n    short sNumsSize = numsSize, sK = k, sOffset = 0;\\n    int nCount[sK], nRet = 0;\\n    memset(nCount, 0, sK*sizeof(int));\\n\\n    while(numsSize-- > 0)\\n    {\\n        // get current remainder index\\n        short sIndex = *nums % sK;\\n        if(sIndex < 0) sIndex += sK;\\n\\n        // update current offset of index\\n        sOffset = (sOffset + sIndex) % sK;\\n\\n        // add count of new *nums into correspond index\\n        sIndex = sIndex < sOffset? sIndex + sK - sOffset: sIndex - sOffset;\\n        nCount[sIndex]++;\\n\\n        // add count into return if the remainder is 0\\n        nRet += nCount[sOffset? sK - sOffset: 0];\\n\\n        nums++;\\n    }"], ["int subarraysDivByK(int* nums, int numsSize, int k){\\n    char cIndex = 0;\\n    short sNumsSize = numsSize, sK = k, sOffset = 0;\\n    int nCount[sK], nRet = 0;\\n    memset(nCount, 0, sK*sizeof(int));\\n\\n    while(numsSize-- > 0)\\n    {\\n        // get current remainder index\\n        short sIndex = *nums % sK;\\n        if(sIndex < 0) sIndex += sK;\\n\\n        // update current offset of index\\n        sOffset = (sOffset + sIndex) % sK;\\n\\n        // add count of new *nums into correspond index\\n        sIndex = sIndex < sOffset? sIndex + sK - sOffset: sIndex - sOffset;\\n        nCount[sIndex]++;\\n\\n        // add count into return if the remainder is 0\\n        nRet += nCount[sOffset? sK - sOffset: 0];\\n\\n        nums++;\\n    }"]]}
{"id": "1055", "ref_c": [["int maxTurbulenceSize(int* arr, int arrSize)\\n{\\n  /*\\n    We use two \"pointers\" left and right to calculate the length\\n    of every possible valid subarray\\n  */\\n  \\n  int left = 0;\\n  int right = 1;\\n  \\n  \\n  /* We use a boolean variable \"lase_tide\" to record the\\n    \"last tide\", i.e., the relationship between last pair.\\n    Say, if we are at the n-th element now,last_tide == true\\n    means that n - 1 >n - 2, and it means n - 1 < n - 2 otherwise\\n  */\\n  \\n  bool last_tide; \\n  \\n  \\n  /*\\n    We use a boolean varibale \"round_start\" to help us deal with\\n    the scenario where right == left + 1.\\n    In this case,we don\\'t need to consider \"last_tide\",for there \\n    isn\\'t such a thing,since right == left + 1 means that now we\\n    are dealing with the first pair in the current subarray\\n  */\\n  \\n  bool round_start = false;\\n  \\n\\n  /*\\n    The smallest possible length is 1, so we initialise our \\n    max_length to 1.\\n  */\\n  \\n  int max_length = 1;\\n  int curr_length;\\n  \\n  while(right < arrSize)\\n  {\\n    /*\\n      The first pair\\n    */\\n    \\n    if(!round_start)\\n    {\\n      if(arr[right] == arr[left])\\n      {\\n        curr_length = 1;\\n        right++;\\n        left++;\\n      }"], ["int maxTurbulenceSize(int* arr, int arrSize)\\n{\\n  /*\\n    We use two \"pointers\" left and right to calculate the length\\n    of every possible valid subarray\\n  */\\n  \\n  int left = 0;\\n  int right = 1;\\n  \\n  \\n  /* We use a boolean variable \"lase_tide\" to record the\\n    \"last tide\", i.e., the relationship between last pair.\\n    Say, if we are at the n-th element now,last_tide == true\\n    means that n - 1 >n - 2, and it means n - 1 < n - 2 otherwise\\n  */\\n  \\n  bool last_tide; \\n  \\n  \\n  /*\\n    We use a boolean varibale \"round_start\" to help us deal with\\n    the scenario where right == left + 1.\\n    In this case,we don\\'t need to consider \"last_tide\",for there \\n    isn\\'t such a thing,since right == left + 1 means that now we\\n    are dealing with the first pair in the current subarray\\n  */\\n  \\n  bool round_start = false;\\n  \\n\\n  /*\\n    The smallest possible length is 1, so we initialise our \\n    max_length to 1.\\n  */\\n  \\n  int max_length = 1;\\n  int curr_length;\\n  \\n  while(right < arrSize)\\n  {\\n    /*\\n      The first pair\\n    */\\n    \\n    if(!round_start)\\n    {\\n      if(arr[right] == arr[left])\\n      {\\n        curr_length = 1;\\n        right++;\\n        left++;\\n      }"], ["int maxTurbulenceSize(int* arr, int arrSize){\\n    int res = 1, mask = 0, curr = 1, cmp;\\n    while(--arrSize){\\n        cmp = (*arr^mask)-(*(arr+1)^mask);\\n        mask = ~mask;\\n        if(cmp>0){\\n            res = res>++curr?res:curr;    \\n            arr++;\\n        }"]]}
{"id": "1056", "ref_c": [["int distributeCoins(struct TreeNode* root) {\\n    // DFS method\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    int result = 0;\\n    helper(root, &result);\\n    return result;\\n}"], ["int distributeCoins(struct TreeNode* root){\\n    struct Stack* stack = createStack();\\n    struct TreeNode* current = root;\\n    bool is_root = false;\\n\\n    int num_moves = 0;\\n\\n    while(current){\\n\\n        struct TreeNode* left = current->left;\\n        struct TreeNode* right = current->right;\\n\\n        if(is_root) left = right = NULL;\\n\\n        if(left){\\n            addToStack(stack, current);\\n            current = left;\\n        }"], ["int distributeCoins(struct TreeNode* root)\\n{\\n    int count = 0;\\n    traversal(root, &count);\\n    return count;\\n}"]]}
{"id": "1058", "ref_c": [["int mincostTickets(int* days, int daysSize, int* costs, int costsSize) {\\n    int i, memo[daysSize+1];\\n    for (i = 0; i <= daysSize; ++i) {\\n        memo[i] = -1;\\n    }"], ["int mincostTickets(int* days, int daysSize, int* costs, int costsSize) {\\n    int i, memo[daysSize+1];\\n    for (i = 0; i <= daysSize; ++i) {\\n        memo[i] = -1;\\n    }"], ["int mincostTickets(int* days, int daysSize, int* costs, int costsSize) {\\n    int i, memo[daysSize+1];\\n    for (i = 0; i <= daysSize; ++i) {\\n        memo[i] = -1;\\n    }"]]}
{"id": "1059", "ref_c": [["int** generateMatrix(int n, int* returnSize, int** returnColumnSizes){\\n    int** data = (int**)malloc(n * sizeof(int*));\\n    for (int i = 0; i < n; i++) {\\n        data[i] = (int*)malloc(n * sizeof(int));\\n    }"], ["int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }"], ["int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = n;\\n    *returnColumnSizes = malloc(sizeof(int) * n);\\n    int **res = malloc(sizeof(int*) * n);\\n    for (int i = 0; i < n; i++) {\\n        (*returnColumnSizes)[i] = n;\\n        res[i] = malloc(sizeof(int) * n);\\n    }"]]}
{"id": "1060", "ref_c": [["int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int* res = malloc(sizeof(int) * 10000);\\n    *returnSize = 0;\\n    int curr_sum_of_even_values = 0;\\n    for(int i = 0; i < numsSize; i++) {\\n        if((*(nums + i) & 0x01) == 0) {\\n            curr_sum_of_even_values += *(nums + i);\\n        }"], ["int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int* res = malloc(sizeof(int) * 10000);\\n    *returnSize = 0;\\n    int curr_sum_of_even_values = 0;\\n    for(int i = 0; i < numsSize; i++) {\\n        if((*(nums + i) & 0x01) == 0) {\\n            curr_sum_of_even_values += *(nums + i);\\n        }"], ["int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int* res = malloc(sizeof(int) * 10000);\\n    *returnSize = 0;\\n    int curr_sum_of_even_values = 0;\\n    for(int i = 0; i < numsSize; i++) {\\n        if((*(nums + i) & 0x01) == 0) {\\n            curr_sum_of_even_values += *(nums + i);\\n        }"]]}
{"id": "1061", "ref_c": [["int** intervalIntersection(int** firstList, int firstListSize, int* firstListColSize, int** secondList, int secondListSize, int* secondListColSize, int* returnSize, int** returnColumnSizes){\\n    if(firstListSize == 0 || secondListSize == 0){\\n        *returnSize = 0;\\n        *returnColumnSizes = NULL;\\n        return NULL;\\n    }"], ["int** intervalIntersection(int** firstList, int firstListSize, int* firstListColSize, int** secondList, int secondListSize, int* secondListColSize, int* returnSize, int** returnColumnSizes){\\n    if(firstListSize == 0 || secondListSize == 0){\\n        *returnSize = 0;\\n        *returnColumnSizes = NULL;\\n        return NULL;\\n    }"], ["int** intervalIntersection(int** firstList, int firstListSize, int* firstListColSize, int** secondList, int secondListSize, int* secondListColSize, int* returnSize, int** returnColumnSizes){\\n    if(firstListSize == 0 || secondListSize == 0){\\n        *returnSize = 0;\\n        *returnColumnSizes = NULL;\\n        return NULL;\\n    }"]]}
{"id": "1062", "ref_c": [["char * smallestFromLeaf(struct TreeNode* root){\\n    char *curStr = calloc(sizeof(char), 100);\\n    char *res = calloc(sizeof(char), 100);\\n    int idx = 0;\\n    \\n    dfs(root, curStr, &idx, res);\\n    return res;\\n}"], ["char * smallestFromLeaf(struct TreeNode* root){\\n    char *curStr = calloc(sizeof(char), 100);\\n    char *res = calloc(sizeof(char), 100);\\n    int idx = 0;\\n    \\n    dfs(root, curStr, &idx, res);\\n    return res;\\n}"], ["char * smallestFromLeaf(struct TreeNode* root){\\n    char *curStr = calloc(sizeof(char), 100);\\n    char *res = calloc(sizeof(char), 100);\\n    int idx = 0;\\n    \\n    dfs(root, curStr, &idx, res);\\n    return res;\\n}"]]}
{"id": "1063", "ref_c": [["bool equationsPossible(char ** equations, int equationsSize){\\n    for (int i = 0; i < 26; ++i) \\n        uf[i] = i;\\n\\t\\t\\n    for (int i=0;i<equationsSize;i++) {\\n        if (equations[i][1] == \\'=\\')\\n            uf[find(equations[i][0] - \\'a\\')] = find(equations[i][3] - \\'a\\');\\n    }"], ["bool equationsPossible(char ** equations, int equationsSize){\\n    for (int i = 0; i < 26; ++i) \\n        uf[i] = i;\\n\\t\\t\\n    for (int i=0;i<equationsSize;i++) {\\n        if (equations[i][1] == \\'=\\')\\n            uf[find(equations[i][0] - \\'a\\')] = find(equations[i][3] - \\'a\\');\\n    }"], ["bool equationsPossible(char ** equations, int equationsSize){\\n    int map[123] = {0}"]]}
{"id": "1064", "ref_c": [["int brokenCalc(int startValue, int target) {\\n    if(startValue == target) return 0;\\n    if(startValue > target) return startValue - target;\\n    int cnt = 0;\\n    search(startValue, target, &cnt);\\n    return cnt;\\n}", "int brokenCalc(int startValue, int target) {\\n    if(startValue == target) return 0;\\n    if(startValue > target) return startValue - target;\\n    int cnt = 0;\\n    while(target > startValue) {\\n        target = (target % 2 == 0) ? target/2 : target+1;\\n        cnt++;\\n    }"], ["int brokenCalc(int startValue, int target) {\\n    if(startValue == target) return 0;\\n    if(startValue > target) return startValue - target;\\n    int cnt = 0;\\n    search(startValue, target, &cnt);\\n    return cnt;\\n}", "int brokenCalc(int startValue, int target) {\\n    if(startValue == target) return 0;\\n    if(startValue > target) return startValue - target;\\n    int cnt = 0;\\n    while(target > startValue) {\\n        target = (target % 2 == 0) ? target/2 : target+1;\\n        cnt++;\\n    }"], ["int brokenCalc(int startValue, int target) {\\n    if(startValue == target) return 0;\\n    if(startValue > target) return startValue - target;\\n    int cnt = 0;\\n    search(startValue, target, &cnt);\\n    return cnt;\\n}", "int brokenCalc(int startValue, int target) {\\n    if(startValue == target) return 0;\\n    if(startValue > target) return startValue - target;\\n    int cnt = 0;\\n    while(target > startValue) {\\n        target = (target % 2 == 0) ? target/2 : target+1;\\n        cnt++;\\n    }"]]}
{"id": "1065", "ref_c": [["int orangesRotting(int** grid, int gridSize, int* gridColSize){\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 2)\\n                dfs(grid, gridSize, *gridColSize, i, j, 2);\\n    int min = 2;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 1)\\n                return -1;\\n            else\\n                min = min < grid[i][j] ? grid[i][j] : min;\\n    return min-2;   \\n}"], ["int orangesRotting(int** grid, int gridSize, int* gridColSize){\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 2)\\n                dfs(grid, gridSize, *gridColSize, i, j, 2);\\n    int min = 2;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 1)\\n                return -1;\\n            else\\n                min = min < grid[i][j] ? grid[i][j] : min;\\n    return min-2;   \\n}"], ["int orangesRotting(int** grid, int gridSize, int* gridColSize){\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 2)\\n                dfs(grid, gridSize, *gridColSize, i, j, 2);\\n    int min = 2;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] == 1)\\n                return -1;\\n            else\\n                min = min < grid[i][j] ? grid[i][j] : min;\\n    return min-2;   \\n}"]]}
{"id": "1066", "ref_c": [["struct TreeNode* insertIntoMaxTree(struct TreeNode* root, int val) {\\n    int* arr = (int*) malloc(101 * sizeof(int));\\n    int arrSize = 0;\\n    InorderTraversal(root, arr, &arrSize);\\n    arr[arrSize++] = val;\\n    return constructMaximumBinaryTree(arr, arrSize);\\n}"], ["struct TreeNode* insertIntoMaxTree(struct TreeNode* root, int val){\\n    struct TreeNode * temp = malloc(sizeof(struct TreeNode));\\n    temp->val = val;\\n    temp->left = NULL;\\n    temp->right = NULL;\\n    if(root == NULL) return temp;\\n    if(val > root->val){\\n        temp->left = root;\\n        root = temp;\\n    }"], ["struct TreeNode* insertIntoMaxTree(struct TreeNode* root, int val) {\\n    int* arr = (int*) malloc(101 * sizeof(int));\\n    int arrSize = 0;\\n    InorderTraversal(root, arr, &arrSize);\\n    arr[arrSize++] = val;\\n    return constructMaximumBinaryTree(arr, arrSize);\\n}"]]}
{"id": "1067", "ref_c": [["bool isValid(char * s){\\n    char *abc;\\n    size_t len;\\n    \\n    len = strlen(s);\\n    while (abc = strstr(s, \"abc\")) {\\n        memmove(abc, abc + 3, len - (abc - s) - 3 + 1 /* Copy NUL too */);\\n        len -= 3;\\n    }"], ["bool isValid(char * s){\\n    char *abc;\\n    size_t len;\\n    \\n    len = strlen(s);\\n    while (abc = strstr(s, \"abc\")) {\\n        memmove(abc, abc + 3, len - (abc - s) - 3 + 1 /* Copy NUL too */);\\n        len -= 3;\\n    }"], ["bool isValid(char * s){\\n    char *abc;\\n    size_t len;\\n    \\n    len = strlen(s);\\n    while (abc = strstr(s, \"abc\")) {\\n        memmove(abc, abc + 3, len - (abc - s) - 3 + 1 /* Copy NUL too */);\\n        len -= 3;\\n    }"]]}
{"id": "1068", "ref_c": [["int longestOnes(int* nums, int numsSize, int k) {\\n  int max = 0;\\n  int z = 0;\\n  int i = 0, j = 0, c = 0;  \\n  while (j < numsSize) {\\n    if (nums[j] == 0) \\n        ++z;\\n    else\\n        c = 1;\\n    while (z > k && i < j) {\\n      if (nums[i] == 0) \\n        --z;\\n      else\\n        c = 1;\\n      ++i;\\n    }"], ["int longestOnes(int* nums, int numsSize, int k) {\\n  int max = 0;\\n  int z = 0;\\n  int i = 0, j = 0, c = 0;  \\n  while (j < numsSize) {\\n    if (nums[j] == 0) \\n        ++z;\\n    else\\n        c = 1;\\n    while (z > k && i < j) {\\n      if (nums[i] == 0) \\n        --z;\\n      else\\n        c = 1;\\n      ++i;\\n    }"], ["int longestOnes(int* nums, int numsSize, int k) {\\n  int max = 0;\\n  int z = 0;\\n  int i = 0, j = 0, c = 0;  \\n  while (j < numsSize) {\\n    if (nums[j] == 0) \\n        ++z;\\n    else\\n        c = 1;\\n    while (z > k && i < j) {\\n      if (nums[i] == 0) \\n        --z;\\n      else\\n        c = 1;\\n      ++i;\\n    }"]]}
{"id": "1069", "ref_c": [["int clumsy(int n){\\n    int op = 0;\\n    int sum = 0;\\n    int tmp_sum = n;\\n    while(n>1){\\n        //printf(\"%d    op:%d   sum:%d    tmp_sum:%d\\\\n\", n, op, sum, tmp_sum);\\n        n--;\\n        if(op == 0){\\n            tmp_sum = tmp_sum * n;\\n            op++;\\n            continue;\\n        }"], ["int clumsy(int n){\\n    int op = 0;\\n    int sum = 0;\\n    int tmp_sum = n;\\n    while(n>1){\\n        //printf(\"%d    op:%d   sum:%d    tmp_sum:%d\\\\n\", n, op, sum, tmp_sum);\\n        n--;\\n        if(op == 0){\\n            tmp_sum = tmp_sum * n;\\n            op++;\\n            continue;\\n        }"], ["int clumsy(int n){\\n    int op = 0;\\n    int sum = 0;\\n    int tmp_sum = n;\\n    while(n>1){\\n        //printf(\"%d    op:%d   sum:%d    tmp_sum:%d\\\\n\", n, op, sum, tmp_sum);\\n        n--;\\n        if(op == 0){\\n            tmp_sum = tmp_sum * n;\\n            op++;\\n            continue;\\n        }"]]}
{"id": "1070", "ref_c": [["int minDominoRotations(int* tops, int topsSize, int* bottoms, int bottomsSize) {\\n    int arr[7] = {0}"], ["int minDominoRotations(int* tops, int topsSize, int* bottoms, int bottomsSize) {\\n    int arr[7] = {0}"], ["int minDominoRotations(int* tops, int topsSize, int* bottoms, int bottomsSize){\\n    int *dict = malloc(sizeof(int) * 7);\\n    int valid = 0, topCount = 0, buttomCount = 0;\\n\\n    for (int i = 0; i < 7; i++) {\\n        *(dict + i) = 0;\\n    }"]]}
{"id": "1071", "ref_c": [["struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){\\n    struct TreeNode* root=malloc(sizeof(struct TreeNode));\\n    root->left=root->right=NULL;\\n    root->val=preorder[0];\\n    for(int i=1;i<preorderSize;i++)\\n    {\\n        struct TreeNode* n=root;\\n        int flag=0;\\n        while(flag==0)\\n        {\\n            if(n->val>preorder[i])\\n            {\\n                if(n->left!=NULL) n=n->left;\\n                else\\n                {\\n                    struct TreeNode* g=malloc(sizeof(struct TreeNode));\\n                    g->val=preorder[i];\\n                    g->left=g->right=NULL;\\n                    n->left=g;\\n                    flag++;\\n                }"], ["struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){\\n    root=NULL;\\n    for(int i=0;i<preorderSize;i++){\\n        push(preorder[i]);\\n    }", "struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){\\n    i=0;n=preorderSize;ar=preorder;\\n    return doit(INT_MAX);\\n}"], ["struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){\\n    root=NULL;\\n    for(int i=0;i<preorderSize;i++){\\n        push(preorder[i]);\\n    }"]]}
{"id": "1072", "ref_c": [["int numPairsDivisibleBy60(int* time, int timeSize){\\n    int i;\\n    int ret = 0;\\n    int list[60] = {0}"], ["int numPairsDivisibleBy60(int* time, int timeSize){\\n    int i;\\n    int ret = 0;\\n    int list[60] = {0}"], ["int numPairsDivisibleBy60(int* time, int timeSize) {\\n    int res = 0;\\n    int rd[60] = {0}"]]}
{"id": "1073", "ref_c": ["\nint ispossible(int array[],int n,int mid,int m)\n{\n    int count=1;\n    int weightsum=0;\n    for(int i=0;i<n;i++)\n    {\n        if(weightsum+array[i]<=mid)\n        {\n            weightsum+=array[i];\n        }\n        else\n        {\n            count++;\n            if(count>m || array[i]>mid) return 0;\n            else weightsum=array[i];\n        }\n    }\n    return 1;\n}\n", "\nint ispossible(int array[],int n,int mid,int m)\n{\n    int count=1;\n    int weightsum=0;\n    for(int i=0;i<n;i++)\n    {\n        if(weightsum+array[i]<=mid)\n        {\n            weightsum+=array[i];\n        }\n        else\n        {\n            count++;\n            if(count>m || array[i]>mid) return 0;\n            else weightsum=array[i];\n        }\n    }\n    return 1;\n}\n", "\nint ispossible(int array[],int n,int mid,int m)\n{\n    int count=1;\n    int weightsum=0;\n    for(int i=0;i<n;i++)\n    {\n        if(weightsum+array[i]<=mid)\n        {\n            weightsum+=array[i];\n        }\n        else\n        {\n            count++;\n            if(count>m || array[i]>mid) return 0;\n            else weightsum=array[i];\n        }\n    }\n    return 1;\n}\n"]}
{"id": "1074", "ref_c": [["int maxScoreSightseeingPair(int* values, int valuesSize){\\n    int i;\\n    int a=values[0];     // for storing values[i]+i\\n    int b;              //for storing values[j]-j\\n    int maxVal=0;\\n    for(i=1;i<valuesSize;i++){\\n        a=max(a,values[i-1]+i-1);\\n        b=values[i]-i;\\n        maxVal=max(maxVal,a+b);\\n    }"], ["int maxScoreSightseeingPair(int* values, int valuesSize){\\n    int i;\\n    int a=values[0];     // for storing values[i]+i\\n    int b;              //for storing values[j]-j\\n    int maxVal=0;\\n    for(i=1;i<valuesSize;i++){\\n        a=max(a,values[i-1]+i-1);\\n        b=values[i]-i;\\n        maxVal=max(maxVal,a+b);\\n    }"], ["int maxScoreSightseeingPair(int* values, int valuesSize){\\n    int i;\\n    int a=values[0];     // for storing values[i]+i\\n    int b;              //for storing values[j]-j\\n    int maxVal=0;\\n    for(i=1;i<valuesSize;i++){\\n        a=max(a,values[i-1]+i-1);\\n        b=values[i]-i;\\n        maxVal=max(maxVal,a+b);\\n    }"]]}
{"id": "1075", "ref_c": [["int smallestRepunitDivByK(int k){\\nint karan=1;\\nint j=0;\\nfor(int i=1;i<=k;i++)\\n{\\nj++;\\nif(karan%k==0)\\nreturn j;\\nelse\\nkaran=(karan*10+1)%k;\\n}"], ["int smallestRepunitDivByK(int k){\\nint karan=1;\\nint j=0;\\nfor(int i=1;i<=k;i++)\\n{\\nj++;\\nif(karan%k==0)\\nreturn j;\\nelse\\nkaran=(karan*10+1)%k;\\n}"], ["int smallestRepunitDivByK(int k){\\n    if(!(k & 1) || !(k % 5)) return -1;\\n    int rem = 0;\\n    for(int i = 1; i <= k; i++) \\n    {\\n        rem = (rem * 10 + 1) % k;   \\n        if(rem == 0) return i;\\n    }"]]}
{"id": "1076", "ref_c": [["bool queryString(char * s, int n){\\n    /* \\n     * Input:\\n     *  s, binary string\\n     *  n, positive integer\\n     */\\n     \\n    char str[33];\\n    \\n    for (int i = 1; i <= n; i++) {\\n        toBinStr(i, str);\\n        \\n        if (strstr(s, str) == NULL) {\\n            return false;\\n        }"], ["bool queryString(char * s, int n){\\n    /* \\n     * Input:\\n     *  s, binary string\\n     *  n, positive integer\\n     */\\n     \\n    char str[33];\\n    \\n    for (int i = 1; i <= n; i++) {\\n        toBinStr(i, str);\\n        \\n        if (strstr(s, str) == NULL) {\\n            return false;\\n        }"], ["bool queryString(char * s, int n){\\n    /* \\n     * Input:\\n     *  s, binary string\\n     *  n, positive integer\\n     */\\n     \\n    char str[33];\\n    \\n    for (int i = 1; i <= n; i++) {\\n        toBinStr(i, str);\\n        \\n        if (strstr(s, str) == NULL) {\\n            return false;\\n        }"]]}
{"id": "1077", "ref_c": [["char * baseNeg2(int n){\\n    char* ret = malloc(41);\\n    memset(ret, \\'0\\', 40);\\n    ret[40] = \\'\\\\0\\';\\n    int ind = 39;\\n    while (n > 0) {\\n        ret[ind] = (n & 1) + \\'0\\';\\n        if (ret[ind] == \\'1\\' && !(ind & 1))\\n           n++;\\n        n >>= 1;\\n        ind--;\\n    }"], ["char * baseNeg2(int n){\\n    if(!n) return \"0\";\\n    char* ans = (char*)calloc(100, sizeof(char));\\n    int ansIdx = 100;\\n    ans[--ansIdx] = \\'\\\\0\\';\\n    while(n){\\n        ans[--ansIdx] = (n & 1) + 0x30;\\n        n = -(n >> 1);\\n    }"], ["char * baseNeg2(int n){\\n    if(!n) return \"0\";\\n    char* ans = (char*)calloc(100, sizeof(char));\\n    int ansIdx = 100;\\n    ans[--ansIdx] = \\'\\\\0\\';\\n    while(n){\\n        ans[--ansIdx] = (n & 1) + 0x30;\\n        n = -(n >> 1);\\n    }"]]}
{"id": "1078", "ref_c": [["int* nextLargerNodes(struct ListNode* head, int* returnSize) {\\n    int * retarr = NULL;\\n    *returnSize = 0;\\n\\n    if (head) {\\n      do {\\n        head = findNextLarge(head, &retarr, returnSize);\\n      }"], ["int* nextLargerNodes(struct ListNode* head, int* returnSize) \\n{\\n    struct ListNode * trav = head;\\n    int num_of_nodes = 0;\\n    while(trav)\\n    {\\n      num_of_nodes++;\\n      trav = trav->next;\\n    }"], ["int* nextLargerNodes(struct ListNode* head, int* returnSize) {\\n    struct ListNode *temp,*move;\\n    temp=head;\\n    int *arr,flag,i=0,j=0;\\n    while(temp)\\n    {\\n        i++;\\n        temp=temp->next;\\n    }"]]}
{"id": "1079", "ref_c": ["\nvoid DFS(int **arr, int i, int j, int N, int M) {\n    if (i >= N || j >= M)\n        return ;\n    if (i < 0 || j < 0)\n        return ;\n    if (arr[i][j] == 0) // sea\n        return ;\n    arr[i][j] = 0;\n    DFS(arr, i, j + 1, N, M);\n    DFS(arr, i, j - 1, N, M);\n    DFS(arr, i + 1, j, N, M);\n    DFS(arr, i - 1, j, N, M);\n}\n\nint numEnclaves(int** grid, int gridSize, int* gridColSize){\n    int N = gridSize, M = gridColSize[0];\n    int sum = N * M, ans = 0;\n    if (N <= 2 || M <= 2) {\n        return 0;\n    }\n    \n    for (int i = 1; i < M - 1; i ++) {\n        if (grid[0][i] == 1) {\n            grid[0][i] = 0;\n            DFS(grid, 1, i, N, M);\n        }\n        if (grid[N - 1][i] == 1) {\n            grid[N - 1][i] == 0;\n            DFS(grid, N - 2, i, N, M);\n        }\n    }\n    for (int j = 1; j < N - 1; j ++) {\n        if (grid[j][0] == 1) {\n            grid[j][0] == 0;\n            DFS(grid, j, 1, N, M);\n        }\n        if (grid[j][M - 1] == 1) {\n            grid[j][M - 1] == 0;\n            DFS(grid, j, M - 2, N, M);\n        }\n    }\n    for (int i = 1; i < N - 1; i ++) {\n        for (int j = 1; j < M - 1; j ++) {\n            if (grid[i][j] == 1) {\n                ans ++;\n            }\n        }\n    }\n    return ans;\n}\n", "\nvoid DFS(int **arr, int i, int j, int N, int M) {\n    if (i >= N || j >= M)\n        return ;\n    if (i < 0 || j < 0)\n        return ;\n    if (arr[i][j] == 0) // sea\n        return ;\n    arr[i][j] = 0;\n    DFS(arr, i, j + 1, N, M);\n    DFS(arr, i, j - 1, N, M);\n    DFS(arr, i + 1, j, N, M);\n    DFS(arr, i - 1, j, N, M);\n}\n\nint numEnclaves(int** grid, int gridSize, int* gridColSize){\n    int N = gridSize, M = gridColSize[0];\n    int sum = N * M, ans = 0;\n    if (N <= 2 || M <= 2) {\n        return 0;\n    }\n    \n    for (int i = 1; i < M - 1; i ++) {\n        if (grid[0][i] == 1) {\n            grid[0][i] = 0;\n            DFS(grid, 1, i, N, M);\n        }\n        if (grid[N - 1][i] == 1) {\n            grid[N - 1][i] == 0;\n            DFS(grid, N - 2, i, N, M);\n        }\n    }\n    for (int j = 1; j < N - 1; j ++) {\n        if (grid[j][0] == 1) {\n            grid[j][0] == 0;\n            DFS(grid, j, 1, N, M);\n        }\n        if (grid[j][M - 1] == 1) {\n            grid[j][M - 1] == 0;\n            DFS(grid, j, M - 2, N, M);\n        }\n    }\n    for (int i = 1; i < N - 1; i ++) {\n        for (int j = 1; j < M - 1; j ++) {\n            if (grid[i][j] == 1) {\n                ans ++;\n            }\n        }\n    }\n    return ans;\n}\n", "\nvoid DFS(int **arr, int i, int j, int N, int M) {\n    if (i >= N || j >= M)\n        return ;\n    if (i < 0 || j < 0)\n        return ;\n    if (arr[i][j] == 0) // sea\n        return ;\n    arr[i][j] = 0;\n    DFS(arr, i, j + 1, N, M);\n    DFS(arr, i, j - 1, N, M);\n    DFS(arr, i + 1, j, N, M);\n    DFS(arr, i - 1, j, N, M);\n}\n\nint numEnclaves(int** grid, int gridSize, int* gridColSize){\n    int N = gridSize, M = gridColSize[0];\n    int sum = N * M, ans = 0;\n    if (N <= 2 || M <= 2) {\n        return 0;\n    }\n    \n    for (int i = 1; i < M - 1; i ++) {\n        if (grid[0][i] == 1) {\n            grid[0][i] = 0;\n            DFS(grid, 1, i, N, M);\n        }\n        if (grid[N - 1][i] == 1) {\n            grid[N - 1][i] == 0;\n            DFS(grid, N - 2, i, N, M);\n        }\n    }\n    for (int j = 1; j < N - 1; j ++) {\n        if (grid[j][0] == 1) {\n            grid[j][0] == 0;\n            DFS(grid, j, 1, N, M);\n        }\n        if (grid[j][M - 1] == 1) {\n            grid[j][M - 1] == 0;\n            DFS(grid, j, M - 2, N, M);\n        }\n    }\n    for (int i = 1; i < N - 1; i ++) {\n        for (int j = 1; j < M - 1; j ++) {\n            if (grid[i][j] == 1) {\n                ans ++;\n            }\n        }\n    }\n    return ans;\n}\n"]}
{"id": "1080", "ref_c": [["bool* camelMatch(char ** queries, int queriesSize, char * pattern, int* returnSize){\\n    int plen = strlen(pattern);\\n    bool* ans = (bool*)calloc(queriesSize, sizeof(bool));\\n    for(int i = 0; i < queriesSize; i++){\\n        int qIdx = 0, pIdx = 0, qlen = strlen(queries[i]);\\n        while(qIdx < qlen){\\n            if(pIdx < plen && queries[i][qIdx] == pattern[pIdx]){\\n                pIdx++;\\n            }"], ["bool* camelMatch(char ** queries, int queriesSize, char * pattern, int* returnSize){\\n    int plen = strlen(pattern);\\n    bool* ans = (bool*)calloc(queriesSize, sizeof(bool));\\n    for(int i = 0; i < queriesSize; i++){\\n        int qIdx = 0, pIdx = 0, qlen = strlen(queries[i]);\\n        while(qIdx < qlen){\\n            if(pIdx < plen && queries[i][qIdx] == pattern[pIdx]){\\n                pIdx++;\\n            }"], ["bool* camelMatch(char ** queries, int queriesSize, char * pattern, int* returnSize){\\n    bool *b = calloc(1, sizeof (bool *[queriesSize])); // Question needs this\\n    for (char *p, *q, i = 0 ; i < queriesSize ; b[i++] = !*p && !*q) {\\n        for (p = pattern, q = queries[i] ; *p && *q && ((*p == *q && p++) || !isupper(*q)) ; q++);\\n        while (!*p && *q && !isupper(*q++));\\n    }"]]}
{"id": "1081", "ref_c": [["int videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){\\n    qsort(clips,clipsSize,sizeof(int*),cmp);\\n    if(clips[0][0]!=0) return -1;\\n    \\n    int idx=-1;\\n    for(int i=0;i<clipsSize;i++) printf(\"%d %d\\\\n\",clips[i][0],clips[i][1]);\\n    printf(\"---------\\\\n\");\\n    for(int i=0;i<clipsSize;i++){\\n        if(idx!=-1) printf(\"%d %d\\\\n\",clips[idx][0],clips[idx][1]);\\n        int left=clips[i][0],right=clips[i][1];\\n        if(idx!=-1 && clips[idx][1] >=time) return idx+1;\\n        if(idx!=-1 && left>clips[idx][1]) return -1;\\n        if(idx==-1){\\n            idx++;\\n            clips[idx][0]=clips[i][0];\\n            clips[idx][1]=clips[i][1];\\n        }"], ["int videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){\\n    qsort(clips,clipsSize,sizeof(int*),cmp);\\n    if(clips[0][0]!=0) return -1;\\n    \\n    int idx=-1;\\n    for(int i=0;i<clipsSize;i++) printf(\"%d %d\\\\n\",clips[i][0],clips[i][1]);\\n    printf(\"---------\\\\n\");\\n    for(int i=0;i<clipsSize;i++){\\n        if(idx!=-1) printf(\"%d %d\\\\n\",clips[idx][0],clips[idx][1]);\\n        int left=clips[i][0],right=clips[i][1];\\n        if(idx!=-1 && clips[idx][1] >=time) return idx+1;\\n        if(idx!=-1 && left>clips[idx][1]) return -1;\\n        if(idx==-1){\\n            idx++;\\n            clips[idx][0]=clips[i][0];\\n            clips[idx][1]=clips[i][1];\\n        }"], ["int videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){\\n    qsort(clips,clipsSize,sizeof(int*),cmp);\\n    if(clips[0][0]!=0) return -1;\\n    \\n    int idx=-1;\\n    for(int i=0;i<clipsSize;i++) printf(\"%d %d\\\\n\",clips[i][0],clips[i][1]);\\n    printf(\"---------\\\\n\");\\n    for(int i=0;i<clipsSize;i++){\\n        if(idx!=-1) printf(\"%d %d\\\\n\",clips[idx][0],clips[idx][1]);\\n        int left=clips[i][0],right=clips[i][1];\\n        if(idx!=-1 && clips[idx][1] >=time) return idx+1;\\n        if(idx!=-1 && left>clips[idx][1]) return -1;\\n        if(idx==-1){\\n            idx++;\\n            clips[idx][0]=clips[i][0];\\n            clips[idx][1]=clips[i][1];\\n        }"]]}
{"id": "1082", "ref_c": [["int maxAncestorDiff(struct TreeNode* root){\\n    int v = 0;\\n    int min = root->val;\\n    int max = root->val;\\n    iterateTree(root, &v, &max, &min);\\n    return v;\\n}"], ["int maxAncestorDiff(struct TreeNode* root){\\n    int MAX_RETURN_VAL = -1;\\n    int MCA_idx = 0;\\n    int MAX_CALC_ARRAY[5001] = {0}"], ["int maxAncestorDiff(struct TreeNode* root){\\n    // add root into stack first\\n    struct StackTreeNode* pstHead = (struct StackTreeNode*) malloc(sizeof(struct StackTreeNode));\\n    pstHead->pstTreeNode = root;\\n    pstHead->nMax = root->val;\\n    pstHead->nMin = root->val;\\n    pstHead->pstNext = NULL;\\n\\n    bool bCheckLeftLeaf = true;\\n    int nRet = 0;\\n    while(pstHead)\\n    {\\n        // check left leaf, add new stack\\n        if(bCheckLeftLeaf && pstHead->pstTreeNode->left)\\n        {\\n            struct StackTreeNode* pstNew = (struct StackTreeNode*) malloc(sizeof(struct StackTreeNode));\\n            pstNew->pstTreeNode = pstHead->pstTreeNode->left;\\n            pstNew->nMax = pstNew->pstTreeNode->val > pstHead->nMax? pstNew->pstTreeNode->val: pstHead->nMax;\\n            pstNew->nMin = pstNew->pstTreeNode->val < pstHead->nMin? pstNew->pstTreeNode->val: pstHead->nMin;\\n            pstNew->pstNext = pstHead;\\n\\n            pstHead = pstNew;\\n\\n            // update diff\\n            int nTmp = pstHead->nMax - pstHead->nMin;\\n            if(nTmp > nRet) nRet = nTmp;\\n        }"]]}
{"id": "1083", "ref_c": [["int longestArithSeqLength(int* nums, int numsSize) {\\n    int max = 0;\\n    int** m = (int**)malloc(numsSize * sizeof(int*));\\n    for (int i = 0; i < numsSize; i++) {\\n        m[i] = (int*)malloc(20001 * sizeof(int));  // Adjusted size for the differences\\n        for (int j = 0; j < 20001; j++)\\n            m[i][j] = 0;\\n    }"], ["int longestArithSeqLength(int* nums, int numsSize) {\\n    int max = 0;\\n    int** m = (int**)malloc(numsSize * sizeof(int*));\\n    for (int i = 0; i < numsSize; i++) {\\n        m[i] = (int*)malloc(20001 * sizeof(int));  // Adjusted size for the differences\\n        for (int j = 0; j < 20001; j++)\\n            m[i][j] = 0;\\n    }"], ["int longestArithSeqLength(int* nums, int numsSize) {\\n    int dp[numsSize][1001];\\n    memset(dp, 0, sizeof(dp));\\n    int maxLength = 0;\\n\\n    for (int i = 1; i < numsSize; ++i) {\\n        for (int j = 0; j < i; j++) {\\n            int diff = nums[i] - nums[j] + 500;\\n            dp[i][diff] = max(dp[i][diff], dp[j][diff] + 1);\\n            maxLength = max(maxLength, dp[i][diff]);\\n        }"]]}
{"id": "1084", "ref_c": [["int twoCitySchedCost(int** costs, int costsSize, int* costsColSize){\\n    int *diff = calloc(costsSize, sizeof(int)), *count = calloc(costsSize, sizeof(int));\\n    int total_cost = 0;\\n    int a_count = 0, b_count = 0;\\n    \\n    for(int i = 0; i < costsSize; i++){\\n        diff[i] = costs[i][0] - costs[i][1];\\n    }"], ["int twoCitySchedCost(int** costs, int costsSize, int* costsColSize){\\n    int result = 0;\\n    qsort(costs, costsSize, sizeof(int *), cmp);\\n    for(int i = 0; i < costsSize / 2; i++)\\n        result += costs[i][0];\\n    for(int i = costsSize / 2 ; i < costsSize; i++)\\n        result += costs[i][1];\\n    return result;\\n}", "int twoCitySchedCost(int** costs, int costsSize, int* costsColSize)\\n{\\n    int dp[100][100] = {0}"], ["int twoCitySchedCost(int** costs, int costsSize, int* costsColSize){\\n    int *diff = calloc(costsSize, sizeof(int)), *count = calloc(costsSize, sizeof(int));\\n    int total_cost = 0;\\n    int a_count = 0, b_count = 0;\\n    \\n    for(int i = 0; i < costsSize; i++){\\n        diff[i] = costs[i][0] - costs[i][1];\\n    }"]]}
{"id": "1085", "ref_c": [["int* nextGreaterElements(int* nums, int numsSize, int* returnSize) {\\n    int n = numsSize;\\n    int* result = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    struct Stack *s = (struct Stack*)malloc(sizeof(struct Stack));\\n    s->next = NULL;\\n    for(int i = 0; i < n; i++){\\n        result[i] = -1;\\n    }"], ["int* nextGreaterElements(int* nums, int numsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int *ans = (int *)malloc(sizeof(int) * numsSize);\\n    int val, idx;\\n\\n    stk_init();\\n\\n    *returnSize = numsSize;\\n\\n    /* Process original array */\\n    for (int i = 0; i < numsSize; i++) {\\n        if (stk_cnt() == 0) {\\n            stk_push(nums[i], i);\\n            ans[i] = -1;\\n        }"], ["int* nextGreaterElements(int* nums, int numsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int *ans = (int *)malloc(sizeof(int) * numsSize);\\n    int val, idx;\\n\\n    stk_init();\\n\\n    *returnSize = numsSize;\\n\\n    /* Process original array */\\n    for (int i = 0; i < numsSize; i++) {\\n        if (stk_cnt() == 0) {\\n            stk_push(nums[i], i);\\n            ans[i] = -1;\\n        }"]]}
{"id": "1086", "ref_c": [["int* numMovesStones(int a, int b, int c, int* returnSize){\\n    // printf(\"%d %d %d\\\\n\",a,b,c);\\n    // int temp;\\n\\t// Sort. Do whatever sort you like.\\n    if(a > b){\\n        a ^= b;\\n        b ^= a;\\n        a ^= b;\\n    }"], ["int* numMovesStones(int a, int b, int c, int* returnSize){\\n\\n    int max,mid,min;\\n    \\n    if(a>b&&b>c){max=a;mid=b;min=c;}"], ["int* numMovesStones(int a, int b, int c, int* returnSize){\\n    // printf(\"%d %d %d\\\\n\",a,b,c);\\n    // int temp;\\n\\t// Sort. Do whatever sort you like.\\n    if(a > b){\\n        a ^= b;\\n        b ^= a;\\n        a ^= b;\\n    }"]]}
{"id": "1087", "ref_c": [["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"]]}
{"id": "1088", "ref_c": [["int maxUncrossedLines(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int i, j, dp[nums1Size+1][nums2Size+1];\\n    for (i = 0; i <= nums1Size; ++i) {\\n        dp[i][0] = 0;\\n    }"], ["int maxUncrossedLines(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    n1 = nums1;\\n    n2 = nums2;\\n    s1 = nums1Size;\\n    s2 = nums2Size;\\n    memset(memo, -1, sizeof(memo));\\n\\n    return max_lines(0,0);\\n}"], ["int maxUncrossedLines(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    n1 = nums1;\\n    n2 = nums2;\\n    s1 = nums1Size;\\n    s2 = nums2Size;\\n    memset(memo, -1, sizeof(memo));\\n\\n    return max_lines(0,0);\\n}"]]}
{"id": "1089", "ref_c": [["struct TreeNode* bstToGst(struct TreeNode* root) {\\n\\n    int* sum=(int*)malloc(sizeof(int));\\n    *sum=0;\\n    root=inorder(root,sum);\\n    return root;\\n    \\n}"], ["struct TreeNode* bstToGst(struct TreeNode* root) {\\n    // Reversed inorder traversal\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(log(n))\\n\\n    int prefix = 0;\\n    helper(root, &prefix);\\n    return root;\\n}"], ["struct TreeNode* bstToGst(struct TreeNode* root){\\n    int index = 0 ;\\n    int nums[100]={-1}"]]}
{"id": "1090", "ref_c": [["int minScoreTriangulation(int* values, int valuesSize){\\n    int dp[valuesSize][valuesSize];\\n    memset(dp, 0, sizeof(dp));\\n    for (int i = 2; i < valuesSize; i++) {\\n        for (int j = 0; j < valuesSize - i; j++) {\\n            dp[j][j + i] = INT_MAX;\\n            for (int k = j + 1; k < j + i; k++) {\\n                dp[j][j + i] = fmin(dp[j][j + i], dp[j][k] + dp[k][j + i] + values[j] * values[k] * values[j + i]);\\n            }"], ["int minScoreTriangulation(int* values, int valuesSize){\\n    int dp[valuesSize][valuesSize];\\n    memset(dp, 0, sizeof(dp));\\n    for (int i = 2; i < valuesSize; i++) {\\n        for (int j = 0; j < valuesSize - i; j++) {\\n            dp[j][j + i] = INT_MAX;\\n            for (int k = j + 1; k < j + i; k++) {\\n                dp[j][j + i] = fmin(dp[j][j + i], dp[j][k] + dp[k][j + i] + values[j] * values[k] * values[j + i]);\\n            }"], ["int minScoreTriangulation(int* values, int valuesSize){\\n    int dp[valuesSize][valuesSize];\\n    memset(dp, 0, sizeof(dp));\\n    for (int i = 2; i < valuesSize; i++) {\\n        for (int j = 0; j < valuesSize - i; j++) {\\n            dp[j][j + i] = INT_MAX;\\n            for (int k = j + 1; k < j + i; k++) {\\n                dp[j][j + i] = fmin(dp[j][j + i], dp[j][k] + dp[k][j + i] + values[j] * values[k] * values[j + i]);\\n            }"]]}
{"id": "1091", "ref_c": [["int maxProfit(int* prices, int pricesSize) {\\n if(pricesSize==1) return 0;\\n int cooldown=0;\\n int buy=1;\\n int index=0;\\n int *** dp= (int***)malloc(sizeof(int**)*pricesSize);\\n for(int i=0;i<pricesSize;i++){\\n     dp[i]=(int**)malloc(sizeof(int*)*2);\\n     for(int j=0;j<2;j++){\\n         dp[i][j]=(int*)malloc(sizeof(int)*2);\\n     }"], ["int maxProfit(int* prices, int pricesSize){\\n    if(pricesSize == 1) return 0;\\n\\n    // declare buy, sell & cooldown state machine and input first price\\n    int anBuy[2] = {-(*prices), 0}"], ["int maxProfit(int* prices, int pricesSize) {\\n if(pricesSize==1) return 0;\\n int cooldown=0;\\n int buy=1;\\n int index=0;\\n int *** dp= (int***)malloc(sizeof(int**)*pricesSize);\\n for(int i=0;i<pricesSize;i++){\\n     dp[i]=(int**)malloc(sizeof(int*)*2);\\n     for(int j=0;j<2;j++){\\n         dp[i][j]=(int*)malloc(sizeof(int)*2);\\n     }"]]}
{"id": "1092", "ref_c": [["bool isRobotBounded(char * instructions){\\n    int pos[2] = {0}"], ["bool isRobotBounded(char * instructions){\\n    int x=0,y=0;\\n    int dx=0,dy=1;\\n    for (size_t p=0; p<4;++p)\\n    for(size_t i=0; instructions[i]!=\\'\\\\0\\';i++){\\n        switch(instructions[i]){\\n            case \\'G\\':\\n                x+=dx;\\n                y+=dy;\\n            break;\\n            case \\'L\\':\\n                if(dy>0){dy = 0; dx=-1;}"], ["bool isRobotBounded(char * instructions){\\n    int pos[2] = {0}"]]}
{"id": "1093", "ref_c": [["int* gardenNoAdj(int n, int** paths, int pathsSize, int* pathsColSize, int* returnSize){\\n    // Initializa graph\\n    int** graph = calloc(n+1, sizeof(int*));\\n    for(int i = 0; i <= n; i++){\\n        graph[i] = calloc(3, sizeof(int));\\n    }"], ["int* gardenNoAdj(int n, int** paths, int pathsSize, int* pathsColSize, int* returnSize){\\n    // Initializa graph\\n    int** graph = calloc(n+1, sizeof(int*));\\n    for(int i = 0; i <= n; i++){\\n        graph[i] = calloc(3, sizeof(int));\\n    }"], ["int* gardenNoAdj(int n, int** paths, int pathsSize, int* pathsColSize, int* returnSize){\\n    // Initializa graph\\n    int** graph = calloc(n+1, sizeof(int*));\\n    for(int i = 0; i <= n; i++){\\n        graph[i] = calloc(3, sizeof(int));\\n    }"]]}
{"id": "1094", "ref_c": [["int maxSumAfterPartitioning(int* arr, int arrSize, int k){\\n    int dp [arrSize];\\n    memset(dp,-1,sizeof(int)*arrSize);\\n   return fun(0,arr,arrSize,k,dp);\\n}"], ["int maxSumAfterPartitioning(int* arr, int arrSize, int k){\\n    int dp [arrSize];\\n    memset(dp,-1,sizeof(int)*arrSize);\\n   return fun(0,arr,arrSize,k,dp);\\n}"], ["int maxSumAfterPartitioning(int* arr, int arrSize, int k){\\n    int dp [arrSize];\\n    memset(dp,-1,sizeof(int)*arrSize);\\n   return fun(0,arr,arrSize,k,dp);\\n}"]]}
{"id": "1096", "ref_c": [["int longestStrChain(char ** words, int wordsSize){\\n    qsort(words, wordsSize, sizeof(char *), cmp);\\n    int dp[wordsSize], result = 1;\\n    for(int i = 0; i < wordsSize; i++)\\n        dp[i] = 1;\\n    for(int i = 1; i < wordsSize; i++)\\n    {\\n        for(int j = 0; j < i; j++) \\n        {\\n            if(canConn(words[j], words[i]))\\n                dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;    \\n        }"], ["int longestStrChain(char ** words, int wordsSize){\\n    qsort(words, wordsSize, sizeof(char *), cmp);\\n    int dp[wordsSize], result = 1;\\n    for(int i = 0; i < wordsSize; i++)\\n        dp[i] = 1;\\n    for(int i = 1; i < wordsSize; i++)\\n    {\\n        for(int j = 0; j < i; j++) \\n        {\\n            if(canConn(words[j], words[i]))\\n                dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;    \\n        }"], ["int longestStrChain(char ** words, int wordsSize){\\n    qsort(words, wordsSize, sizeof(char *), cmp);\\n    int dp[wordsSize], result = 1;\\n    for(int i = 0; i < wordsSize; i++)\\n        dp[i] = 1;\\n    for(int i = 1; i < wordsSize; i++)\\n    {\\n        for(int j = 0; j < i; j++) \\n        {\\n            if(canConn(words[j], words[i]))\\n                dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;    \\n        }"]]}
{"id": "1097", "ref_c": [["int longestAlternatingSubarray(int* nums, int numsSize, int threshold)\\n{\\n  int l = 0, max_len = 0, r;\\n  while(l < numsSize)\\n  {\\n    if(nums[l] % 2 != 0 || nums[l] > threshold)\\n    {\\n      l++;\\n      continue;\\n    }"], ["int longestAlternatingSubarray(int* nums, int numsSize, int threshold){\\n    int i,n=numsSize,m=0,c;\\n    i=0;\\n    while(i<n)\\n    {\\n        if(nums[i]%2==0)\\n        {\\n            c=1;\\n            while(i<n-1 && nums[i]<=threshold && nums[i]%2!=nums[i+1]%2)\\n            {\\n                i++;\\n                c++;\\n            }"], ["int longestAlternatingSubarray(int* nums, int numsSize, int threshold){\\n    int i,n=numsSize,m=0,c;\\n    i=0;\\n    while(i<n)\\n    {\\n        if(nums[i]%2==0)\\n        {\\n            c=1;\\n            while(i<n-1 && nums[i]<=threshold && nums[i]%2!=nums[i+1]%2)\\n            {\\n                i++;\\n                c++;\\n            }"]]}
{"id": "1098", "ref_c": ["\nint maxSatisfied(int* customers, int customersSize, int* grumpy, int grumpySize, int X){\n    int maxSum = 0;\n    int maxSumIndex = 0;\n    for (int i = 0; i < X; ++i) {\n        if (grumpy[i]) {\n            maxSum += customers[i];\n        }\n    }\n    \n    int sum = maxSum;\n    for (int i = 1; i < customersSize - X + 1; ++i) {\n        if (grumpy[i - 1]) {\n            sum -= customers[i - 1];\n        }\n        if (grumpy[i + X - 1]) {\n            sum += customers[i + X - 1];\n        }\n        if (sum > maxSum) {\n            maxSum = sum;\n            maxSumIndex = i;\n        }\n    }\n    \n    int result = 0;\n    for (int i = 0; i < customersSize; ++i) {\n        if (i >= maxSumIndex && i < maxSumIndex + X || !grumpy[i]) {\n            result += customers[i];\n        }\n    }\n    \n    return result;\n}\n", "\nint maxSatisfied(int* customers, int customersSize, int* grumpy, int grumpySize, int X){\n    int maxSum = 0;\n    int maxSumIndex = 0;\n    for (int i = 0; i < X; ++i) {\n        if (grumpy[i]) {\n            maxSum += customers[i];\n        }\n    }\n    \n    int sum = maxSum;\n    for (int i = 1; i < customersSize - X + 1; ++i) {\n        if (grumpy[i - 1]) {\n            sum -= customers[i - 1];\n        }\n        if (grumpy[i + X - 1]) {\n            sum += customers[i + X - 1];\n        }\n        if (sum > maxSum) {\n            maxSum = sum;\n            maxSumIndex = i;\n        }\n    }\n    \n    int result = 0;\n    for (int i = 0; i < customersSize; ++i) {\n        if (i >= maxSumIndex && i < maxSumIndex + X || !grumpy[i]) {\n            result += customers[i];\n        }\n    }\n    \n    return result;\n}\n", "\nint maxSatisfied(int* customers, int customersSize, int* grumpy, int grumpySize, int X){\n    int maxSum = 0;\n    int maxSumIndex = 0;\n    for (int i = 0; i < X; ++i) {\n        if (grumpy[i]) {\n            maxSum += customers[i];\n        }\n    }\n    \n    int sum = maxSum;\n    for (int i = 1; i < customersSize - X + 1; ++i) {\n        if (grumpy[i - 1]) {\n            sum -= customers[i - 1];\n        }\n        if (grumpy[i + X - 1]) {\n            sum += customers[i + X - 1];\n        }\n        if (sum > maxSum) {\n            maxSum = sum;\n            maxSumIndex = i;\n        }\n    }\n    \n    int result = 0;\n    for (int i = 0; i < customersSize; ++i) {\n        if (i >= maxSumIndex && i < maxSumIndex + X || !grumpy[i]) {\n            result += customers[i];\n        }\n    }\n    \n    return result;\n}\n"]}
{"id": "1099", "ref_c": [["void moveZeroes(int* nums, int numsSize){\\n    int j=0;\\n        for(int i=0;i<numsSize;i++){\\n            if(nums[i]!=0){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j++;\\n            }"], ["void moveZeroes(int* nums, int numsSize){\\n    int j=0;\\n        for(int i=0;i<numsSize;i++){\\n            if(nums[i]!=0){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j++;\\n            }"], ["void moveZeroes(int* nums, int numsSize){\\n    int j=0;\\n        for(int i=0;i<numsSize;i++){\\n            if(nums[i]!=0){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j++;\\n            }"]]}
{"id": "1100", "ref_c": [["int* rearrangeBarcodes(int* barcodes, int barcodesSize, int* returnSize){\\n    int table[10001]={0}"], ["int* rearrangeBarcodes(int* barcodes, int barcodesSize, int* returnSize) {\\n    int* cnt = (int*)calloc(1e4+1, sizeof(int));\\n    int maxValue = 0;\\n    for(int i = 0; i < barcodesSize; i++){\\n        cnt[barcodes[i]] = (cnt[barcodes[i]] + 0x10000) | barcodes[i];\\n        maxValue = fmax(maxValue, barcodes[i]);\\n    }"], ["int* rearrangeBarcodes(int* barcodes, int barcodesSize, int* returnSize){\\n    int table[10001]={0}"]]}
{"id": "1101", "ref_c": [["char * smallestEquivalentString(char * s1, char * s2, char * baseStr){\\n    int len = strlen(s1);\\n    int* bitmask = (int*)calloc(26, sizeof(int));\\n    int currBitmask;\\n    for(int i = 0; i < 26; i++)\\n        bitmask[i] = (1 << i);\\n\\t/* O(N) */\\n    for(int i = 0; i < len; i++){\\n        currBitmask = bitmask[s1[i]-\\'a\\'] | bitmask[s2[i]-\\'a\\'];\\n        bitmask[s1[i]-\\'a\\'] = currBitmask;\\n        bitmask[s2[i]-\\'a\\'] = currBitmask;\\n    }"], ["char * smallestEquivalentString(char * s1, char * s2, char * baseStr){\\n    int len = strlen(s1);\\n    int* bitmask = (int*)calloc(26, sizeof(int));\\n    int currBitmask;\\n    for(int i = 0; i < 26; i++)\\n        bitmask[i] = (1 << i);\\n\\t/* O(N) */\\n    for(int i = 0; i < len; i++){\\n        currBitmask = bitmask[s1[i]-\\'a\\'] | bitmask[s2[i]-\\'a\\'];\\n        bitmask[s1[i]-\\'a\\'] = currBitmask;\\n        bitmask[s2[i]-\\'a\\'] = currBitmask;\\n    }"], ["char * smallestEquivalentString(char * s1, char * s2, char * baseStr){\\n    int len = strlen(s1);\\n    int* bitmask = (int*)calloc(26, sizeof(int));\\n    int currBitmask;\\n    for(int i = 0; i < 26; i++)\\n        bitmask[i] = (1 << i);\\n\\t/* O(N) */\\n    for(int i = 0; i < len; i++){\\n        currBitmask = bitmask[s1[i]-\\'a\\'] | bitmask[s2[i]-\\'a\\'];\\n        bitmask[s1[i]-\\'a\\'] = currBitmask;\\n        bitmask[s2[i]-\\'a\\'] = currBitmask;\\n    }"]]}
{"id": "1103", "ref_c": [["int averageValue(int* nums, int numsSize)\\n{\\n    int sum = 0,count = 0;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]%6==0)\\n        {\\n            sum += nums[i];\\n            count++;\\n        }"], ["int averageValue(int* nums, int numsSize)\\n{\\n    int sum = 0,count = 0;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]%6==0)\\n        {\\n            sum += nums[i];\\n            count++;\\n        }"], ["int averageValue(int* nums, int numsSize)\\n{\\n    int sum = 0,count = 0;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]%6==0)\\n        {\\n            sum += nums[i];\\n            count++;\\n        }"]]}
{"id": "1104", "ref_c": [["int xorOperation(int n, int start){\\n   int ans[n];\\n    int sum=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        ans[i]=start+2*i;\\n    }"], ["int xorOperation(int n, int start)\\n{\\n    int arr[n],x=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        arr[i] = start + 2*i;\\n        x = x^arr[i];\\n    }"], ["int xorOperation(int n, int start){\\n    int xor = start;\\n    for (int i = 1; i < n; i++){\\n        xor ^= (start + 2 * i);\\n    }"]]}
{"id": "1105", "ref_c": [["int numTilePossibilities(char * tiles){\\n    /*\\n     * Input:\\n     *  tiles, a string array contains different tiles\\n     */\\n     \\n    int total = 0;\\n    int len = strlen(tiles);\\n    \\n    /* Sort the tiles by letter in ascending order */\\n    qsort(tiles, len, sizeof(char), cmp);\\n    \\n    /* Find all the possible combinations of 1 ~ N tiles */\\n    for (int i = 1; i <= len; i++) {\\n        total += findTiles(tiles, len, i);\\n    }"], ["int numTilePossibilities(char * tiles){\\n    /*\\n     * Input:\\n     *  tiles, a string array contains different tiles\\n     */\\n     \\n    int total = 0;\\n    int len = strlen(tiles);\\n    \\n    /* Sort the tiles by letter in ascending order */\\n    qsort(tiles, len, sizeof(char), cmp);\\n    \\n    /* Find all the possible combinations of 1 ~ N tiles */\\n    for (int i = 1; i <= len; i++) {\\n        total += findTiles(tiles, len, i);\\n    }"], ["int numTilePossibilities(char * tiles){\\n    /*\\n     * Input:\\n     *  tiles, a string array contains different tiles\\n     */\\n     \\n    int total = 0;\\n    int len = strlen(tiles);\\n    \\n    /* Sort the tiles by letter in ascending order */\\n    qsort(tiles, len, sizeof(char), cmp);\\n    \\n    /* Find all the possible combinations of 1 ~ N tiles */\\n    for (int i = 1; i <= len; i++) {\\n        total += findTiles(tiles, len, i);\\n    }"]]}
{"id": "1106", "ref_c": [["struct TreeNode* sufficientSubset(struct TreeNode* root, int limit)\\n{\\n    int del_root = traverse(root, 0, limit);\\n    if (del_root) {\\n        free(root);\\n        return NULL;\\n    }"], ["struct TreeNode* sufficientSubset(struct TreeNode* root, int limit)\\n{\\n    int del_root = traverse(root, 0, limit);\\n    if (del_root) {\\n        free(root);\\n        return NULL;\\n    }"], ["struct TreeNode* sufficientSubset(struct TreeNode* root, int limit)\\n{\\n    int del_root = traverse(root, 0, limit);\\n    if (del_root) {\\n        free(root);\\n        return NULL;\\n    }"]]}
{"id": "1107", "ref_c": ["\ninline int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nint max_element(int* arr, int arrSize) {\n    int result = arr[0];\n    for (int i = 1; i < arrSize; i++) {\n        result = max(result, arr[i]);\n    }\n    return result;\n}\nint maximizeSum(int* nums, int numsSize, int k) {\n    // Greedy \n    // if x = max(nums), ans := x + (x + 1) + ... + (x + k - 1)\n    //                       := (x + (x + k - 1)) * k / 2\n    //                       := x*k + (k - 1)*k / 2\n\n    // Time complexity: O(n)\n    // Space comeplxity: O(1)\n\n    const int x = max_element(nums, numsSize);\n    return x*k + (k - 1)*k / 2;\n}\n", "\ninline int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nint max_element(int* arr, int arrSize) {\n    int result = arr[0];\n    for (int i = 1; i < arrSize; i++) {\n        result = max(result, arr[i]);\n    }\n    return result;\n}\nint maximizeSum(int* nums, int numsSize, int k) {\n    // Greedy \n    // if x = max(nums), ans := x + (x + 1) + ... + (x + k - 1)\n    //                       := (x + (x + k - 1)) * k / 2\n    //                       := x*k + (k - 1)*k / 2\n\n    // Time complexity: O(n)\n    // Space comeplxity: O(1)\n\n    const int x = max_element(nums, numsSize);\n    return x*k + (k - 1)*k / 2;\n}\n", "\ninline int max(int a, int b) {\n    return (a > b) ? a : b;\n}\nint max_element(int* arr, int arrSize) {\n    int result = arr[0];\n    for (int i = 1; i < arrSize; i++) {\n        result = max(result, arr[i]);\n    }\n    return result;\n}\nint maximizeSum(int* nums, int numsSize, int k) {\n    // Greedy \n    // if x = max(nums), ans := x + (x + 1) + ... + (x + k - 1)\n    //                       := (x + (x + k - 1)) * k / 2\n    //                       := x*k + (k - 1)*k / 2\n\n    // Time complexity: O(n)\n    // Space comeplxity: O(1)\n\n    const int x = max_element(nums, numsSize);\n    return x*k + (k - 1)*k / 2;\n}\n"]}
{"id": "1108", "ref_c": [["int largestValsFromLabels(int* values, int valuesSize, int* labels, int labelsSize, int numWanted, int useLimit) {\\n    for(int i = 0; i < valuesSize; i++)\\n        values[i] = values[i] << 16 | labels[i];\\n    qsort(values, valuesSize, sizeof(int), cmp);\\n    int* labelHash = (int*)calloc(2*1e4+1, sizeof(int));\\n    int score = 0;\\n    for(int i = 0; i < valuesSize; i++){\\n        int l = values[i] & 0xFFFF;\\n        if(labelHash[l] < useLimit){\\n            score += (values[i] >> 16);\\n            labelHash[l]++;\\n            numWanted--;\\n        }"], ["int largestValsFromLabels(int* values, int valuesSize, int* labels, int labelsSize, int numWanted, int useLimit) {\\n    for(int i = 0; i < valuesSize; i++)\\n        values[i] = values[i] << 16 | labels[i];\\n    qsort(values, valuesSize, sizeof(int), cmp);\\n    int* labelHash = (int*)calloc(2*1e4+1, sizeof(int));\\n    int score = 0;\\n    for(int i = 0; i < valuesSize; i++){\\n        int l = values[i] & 0xFFFF;\\n        if(labelHash[l] < useLimit){\\n            score += (values[i] >> 16);\\n            labelHash[l]++;\\n            numWanted--;\\n        }"], ["int largestValsFromLabels(int* values, int valuesSize, int* labels, int labelsSize, int numWanted, int useLimit) {\\n    for(int i = 0; i < valuesSize; i++)\\n        values[i] = values[i] << 16 | labels[i];\\n    qsort(values, valuesSize, sizeof(int), cmp);\\n    int* labelHash = (int*)calloc(2*1e4+1, sizeof(int));\\n    int score = 0;\\n    for(int i = 0; i < valuesSize; i++){\\n        int l = values[i] & 0xFFFF;\\n        if(labelHash[l] < useLimit){\\n            score += (values[i] >> 16);\\n            labelHash[l]++;\\n            numWanted--;\\n        }"]]}
{"id": "1109", "ref_c": [["int shortestPathBinaryMatrix(int** grid, int gridSize, int* gridColSize){\\n    if(grid[0][0] == 1) return -1;\\n    grid[0][0] = -1;\\n\\n    int x = -1;\\n    while(grid[gridSize-1][gridSize-1] == 0){\\n        if(!blot(grid, gridSize, x)) return -1;\\n        x--;\\n    }"], ["int shortestPathBinaryMatrix(int** grid, int gridSize, int* gridColSize){\\n    if(grid[0][0] == 1) return -1;\\n    grid[0][0] = -1;\\n\\n    int x = -1;\\n    while(grid[gridSize-1][gridSize-1] == 0){\\n        if(!blot(grid, gridSize, x)) return -1;\\n        x--;\\n    }"], ["int shortestPathBinaryMatrix(int** grid, int gridSize, int* gridColSize){\\n    if(grid[0][0] == 1) return -1;\\n    grid[0][0] = -1;\\n\\n    int x = -1;\\n    while(grid[gridSize-1][gridSize-1] == 0){\\n        if(!blot(grid, gridSize, x)) return -1;\\n        x--;\\n    }"]]}
{"id": "1110", "ref_c": [["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0;\\n    for (int i = 0; i != numsSize; i++)\\n    {\\n        for (int j = 0; j != numsSize; j++)\\n        {\\n            if (i != j && (nums[i] - nums[j]) == k)\\n            {\\n                count++;\\n            }"], ["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0; \\n\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = i+1; j < numsSize; j++){\\n            if(abs(nums[i] - nums[j]) == k){\\n                count += 1; \\n            }"], ["int countKDifference(int* nums, int numsSize, int k){\\n    int count = 0;\\n    for(int i = 0; i < numsSize; i++)\\n        for(int j = i; j  < numsSize; j++)\\n            if(nums[i] - nums[j] == k || nums[j]  - nums[i] == k)\\n                count++;\\n\\n    \\n    return count;\\n}"]]}
{"id": "1111", "ref_c": [["bool carPooling(int** trips, int tripsSize, int* tripsColSize, int capacity){\\n    int* time = calloc(tripsSize*2, sizeof(int));\\n    for(int i = 0; i < tripsSize; i++){\\n        time[2*i] = ((trips[i][0]) << 16) | trips[i][1];\\n        time[2*i+1] = (0 - (trips[i][0] << 16)) | trips[i][2];\\n    }"], ["bool carPooling(int** trips, int tripsSize, int* tripsColSize, int capacity){\\n    \\n    int limit[1001]={0}"], ["bool carPooling(int** trips, int tripsSize, int* tripsColSize, int capacity){\\n    Heap h = { 0, NULL }"]]}
{"id": "1112", "ref_c": [["int* pathInZigZagTree(int label, int* returnSize){\\n    int row=0,power=1;\\n    while(power<=label){\\n        row++;\\n        power*=2;\\n    }"], ["int* pathInZigZagTree(int label, int* returnSize)\\n{\\n    \\n    int label_level = find_row(label);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * label_level);\\n    int ret_arr_index;\\n     *returnSize = label_level;\\n    int row_size = label_level;\\n    \\n    ret_arr[ret_arr_index++] = label;\\n    \\n    if(label == 1)\\n    {\\n        return ret_arr;\\n    }"], ["int* pathInZigZagTree(int label, int* returnSize){\\n    int row=0,power=1;\\n    while(power<=label){\\n        row++;\\n        power*=2;\\n    }"]]}
{"id": "1113", "ref_c": [["int minHeightShelves(int** books, int booksSize, int* booksColSize, int shelfWidth){\\n    int * memo;\\n    int res;\\n    memo = calloc(booksSize, sizeof(int));\\n    \\n    res = dfs(1, books[0][0], books, booksSize, shelfWidth, books[0][1], memo);\\n    return res;\\n}"], ["int minHeightShelves(int** books, int booksSize, int* booksColSize, int shelfWidth){\\n    int * memo;\\n    int res;\\n    memo = calloc(booksSize, sizeof(int));\\n    \\n    res = dfs(1, books[0][0], books, booksSize, shelfWidth, books[0][1], memo);\\n    return res;\\n}"], ["int minHeightShelves(int** books, int booksSize, int* booksColSize, int shelfWidth){\\n    int * memo;\\n    int res;\\n    memo = calloc(booksSize, sizeof(int));\\n    \\n    res = dfs(1, books[0][0], books, booksSize, shelfWidth, books[0][1], memo);\\n    return res;\\n}"]]}
{"id": "1114", "ref_c": [["bool hasAlternatingBits(int n){\\n    \\n    int size = (sizeof(int) * 8);\\n\\n    bool atEndOfSequence = false;\\n    \\n    int prevVal = n & 1;\\n    int bitVal;\\n\\n    for (int i=1; i<size; i++) {\\n        bitVal = (n >> i) & 1;\\n\\n        if (atEndOfSequence && bitVal == 1) return false;\\n        if ((bitVal  ^ prevVal) != 1){\\n            if (bitVal == 0 && prevVal == 0) {\\n                atEndOfSequence = true;\\n            }"], ["bool hasAlternatingBits(int n) {\\n    int flag,flag2,bit;\\n    while(n!=0){\\n        bit = n & 1;\\n        if(bit==1)\\n            flag=1;\\n        else\\n            flag=0;\\n        n >>= 1;\\n        \\n        bit = n & 1;\\n        if(bit==1)\\n            flag2=1;\\n        else\\n            flag2=0;\\n        \\n        if(flag==flag2)\\n            return false;\\n   }"], ["bool hasAlternatingBits(int n) {\\n        long x=1;                     // 1 = 1\\n        while(x<=n){                  // 2 = 10\\n            if(x==n)                  // 5 = 101\\n                return true;          //10 = 1010\\n            else if(x%2==0)           //21 = 10101\\n                x=2*x+1;              //42 = 101010\\n            else                      //85 = 1010101\\n                x=2*x;\\n        }", "bool hasAlternatingBits(int n) {\\n        int flag1,flag2;\\n        while(n){\\n            flag1=n&1;\\n            if(flag1==flag2)\\n                return 0;\\n            n=n>>1;\\n            flag2=flag1;\\n        }"]]}
{"id": "1115", "ref_c": [["struct TreeNode** delNodes(struct TreeNode* root, int* to_delete, int to_deleteSize, int* returnSize)\\n{\\n    NODE * res[1000] = {NULL}"], ["struct TreeNode** delNodes(struct TreeNode* root, int* to_delete, int to_deleteSize, int* returnSize)\\n{\\n    *returnSize = 0;\\n    int i = 0;\\n    int q = 0;\\n    NODE * res[1000];\\n    NODE * parent[1000];\\n    NODE * que[1000];\\n\\n    if (root == NULL)\\n        return NULL;\\n\\n    que[i++] = root;\\n    res[(*returnSize)++] = root;\\n\\n    while (q < i)\\n    {\\n        if (checkForDel(que[q]->val, &to_delete, &to_deleteSize))\\n        {\\n            for (int i = 0; i < *returnSize ; i++)\\n            {\\n                if (res[i] == que[q])\\n                {\\n                    for (int j = i; (j + 1) < *returnSize; j++)\\n                        res[j] = res[j+1];\\n                    (*returnSize)--;\\n                    break;\\n                }"], ["struct TreeNode** delNodes(struct TreeNode* root, int* to_delete, int to_deleteSize, int* returnSize) {\\n    *returnSize = 0;\\n    bool flag = false;\\n    int map[1001] = {0}"]]}
{"id": "1116", "ref_c": [["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"]]}
{"id": "1120", "ref_c": [["struct TreeNode* lcaDeepestLeaves(struct TreeNode* root) {\\n    int currentDepth = 0;\\n    return lcaDeepestLeavesRecur(root, &currentDepth);\\n}"], ["struct TreeNode* lcaDeepestLeaves(struct TreeNode* root) {\\n    // DFS method \\n\\n    // Time complexity: O(tree height)\\n    // Space complexity: O(tree height)\\n    \\n    if (root == NULL) \\n        return NULL;\\n    const int left = getDepth(root->left), right = getDepth(root->right);\\n    if (left == right) \\n        return root;\\n    return (left > right) ? lcaDeepestLeaves(root->left) : lcaDeepestLeaves(root->right);\\n}"], ["struct TreeNode* lcaDeepestLeaves(struct TreeNode* root) {\\n    int currentDepth = 0;\\n    return lcaDeepestLeavesRecur(root, &currentDepth);\\n}"]]}
{"id": "1121", "ref_c": [["int longestWPI(int* hours, int hoursSize){\\n\\n    int t=0;\\n    int max=0;\\n    \\n    for(int i=0;i<=hoursSize;i++)c[i]=-1;\\n    \\n    for(int i=0;i<hoursSize;i++){\\n        if(hours[i]>8)t++;\\n        else t--;\\n        \\n        if(t<0 && c[abs(t)]==-1)c[abs(t)]=i;\\n        \\n        if(t>0)max=i+1;\\n        else if(t<=0){\\n            if(c[abs(t-1)]>=0 && i-c[abs(t-1)]>max)max=i-c[abs(t-1)];\\n        }"], ["int longestWPI(int* hours, int hoursSize){\\n\\n    int t=0;\\n    int max=0;\\n    \\n    for(int i=0;i<=hoursSize;i++)c[i]=-1;\\n    \\n    for(int i=0;i<hoursSize;i++){\\n        if(hours[i]>8)t++;\\n        else t--;\\n        \\n        if(t<0 && c[abs(t)]==-1)c[abs(t)]=i;\\n        \\n        if(t>0)max=i+1;\\n        else if(t<=0){\\n            if(c[abs(t-1)]>=0 && i-c[abs(t-1)]>max)max=i-c[abs(t-1)];\\n        }"], ["int longestWPI(int* hours, int hoursSize){\\n\\n    int t=0;\\n    int max=0;\\n    \\n    for(int i=0;i<=hoursSize;i++)c[i]=-1;\\n    \\n    for(int i=0;i<hoursSize;i++){\\n        if(hours[i]>8)t++;\\n        else t--;\\n        \\n        if(t<0 && c[abs(t)]==-1)c[abs(t)]=i;\\n        \\n        if(t>0)max=i+1;\\n        else if(t<=0){\\n            if(c[abs(t-1)]>=0 && i-c[abs(t-1)]>max)max=i-c[abs(t-1)];\\n        }"]]}
{"id": "1122", "ref_c": [["int* shortestAlternatingPaths(int n, int** redEdges, int redEdgesSize, int* redEdgesColSize, int** blueEdges, int blueEdgesSize, int* blueEdgesColSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  n, number of nodes\\n     *  **redEdges, \\n     *  redEdgesSize\\n     *  *redEdgesColSize\\n     *  **blueEdges\\n     *  blueEdgesSize\\n     *  *blueEdgesColSize\\n     */\\n\\n    bool **red, **blue, **visited;\\n\\n    red = (bool **)malloc(sizeof(bool *) * n);\\n    blue = (bool **)malloc(sizeof(bool *) * n);\\n    visited = (bool **)calloc(1, sizeof(bool *) * 2);\\n    int *ans = (int *)malloc(sizeof(int) * n);\\n    \\n    fifo_init();\\n    \\n    *returnSize = n;\\n    \\n    visited[0] = (bool *)calloc(1, sizeof(bool) * n);\\n    visited[1] = (bool *)calloc(1, sizeof(bool) * n);\\n    \\n    /* Set all the distances to -1 by default except the distance from node 0 to itself */\\n    ans[0] = 0;\\n    for (int i = 1; i < n; i++) {\\n        ans[i] = -1;\\n    }"], ["int* shortestAlternatingPaths(int n, int** redEdges, int redEdgesSize, int* redEdgesColSize, int** blueEdges, int blueEdgesSize, int* blueEdgesColSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  n, number of nodes\\n     *  **redEdges, \\n     *  redEdgesSize\\n     *  *redEdgesColSize\\n     *  **blueEdges\\n     *  blueEdgesSize\\n     *  *blueEdgesColSize\\n     */\\n\\n    bool **red, **blue, **visited;\\n\\n    red = (bool **)malloc(sizeof(bool *) * n);\\n    blue = (bool **)malloc(sizeof(bool *) * n);\\n    visited = (bool **)calloc(1, sizeof(bool *) * 2);\\n    int *ans = (int *)malloc(sizeof(int) * n);\\n    \\n    fifo_init();\\n    \\n    *returnSize = n;\\n    \\n    visited[0] = (bool *)calloc(1, sizeof(bool) * n);\\n    visited[1] = (bool *)calloc(1, sizeof(bool) * n);\\n    \\n    /* Set all the distances to -1 by default except the distance from node 0 to itself */\\n    ans[0] = 0;\\n    for (int i = 1; i < n; i++) {\\n        ans[i] = -1;\\n    }"], ["int* shortestAlternatingPaths(int n, int** redEdges, int redEdgesSize, int* redEdgesColSize, int** blueEdges, int blueEdgesSize, int* blueEdgesColSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  n, number of nodes\\n     *  **redEdges, \\n     *  redEdgesSize\\n     *  *redEdgesColSize\\n     *  **blueEdges\\n     *  blueEdgesSize\\n     *  *blueEdgesColSize\\n     */\\n\\n    bool **red, **blue, **visited;\\n\\n    red = (bool **)malloc(sizeof(bool *) * n);\\n    blue = (bool **)malloc(sizeof(bool *) * n);\\n    visited = (bool **)calloc(1, sizeof(bool *) * 2);\\n    int *ans = (int *)malloc(sizeof(int) * n);\\n    \\n    fifo_init();\\n    \\n    *returnSize = n;\\n    \\n    visited[0] = (bool *)calloc(1, sizeof(bool) * n);\\n    visited[1] = (bool *)calloc(1, sizeof(bool) * n);\\n    \\n    /* Set all the distances to -1 by default except the distance from node 0 to itself */\\n    ans[0] = 0;\\n    for (int i = 1; i < n; i++) {\\n        ans[i] = -1;\\n    }"]]}
{"id": "1123", "ref_c": [["int mctFromLeafValues(int* arr, int arrSize){\\n    int sum, i;\\n    \\n    sum = 0;\\n    do\\n    {\\n        int min_i, min_prod;\\n        \\n        min_i = 0;\\n        min_prod = arr[0] * arr[1];\\n        \\n        for (i = 1; i < arrSize - 1; ++i)\\n            if (min_prod > arr[i] * arr[i + 1])\\n            {\\n                min_prod = arr[i] * arr[i + 1];\\n                min_i = i;\\n            }"], ["int mctFromLeafValues(int* arr, int arrSize){\\n    int sum, i;\\n    \\n    sum = 0;\\n    do\\n    {\\n        int min_i, min_prod;\\n        \\n        min_i = 0;\\n        min_prod = arr[0] * arr[1];\\n        \\n        for (i = 1; i < arrSize - 1; ++i)\\n            if (min_prod > arr[i] * arr[i + 1])\\n            {\\n                min_prod = arr[i] * arr[i + 1];\\n                min_i = i;\\n            }"], ["int mctFromLeafValues(int* arr, int arrSize){\\n    int sum, i;\\n    \\n    sum = 0;\\n    do\\n    {\\n        int min_i, min_prod;\\n        \\n        min_i = 0;\\n        min_prod = arr[0] * arr[1];\\n        \\n        for (i = 1; i < arrSize - 1; ++i)\\n            if (min_prod > arr[i] * arr[i + 1])\\n            {\\n                min_prod = arr[i] * arr[i + 1];\\n                min_i = i;\\n            }"]]}
{"id": "1124", "ref_c": [["int numJewelsInStones(char * jewels, char * stones)\\n{\\n    int c=0;\\n    for(int i=0;i<strlen(jewels);i++)\\n    {\\n        for(int j=0;j<strlen(stones);j++)\\n        {\\n            if(jewels[i]==stones[j])\\n            c++;\\n        }"], ["int numJewelsInStones(char * jewels, char * stones)\\n{\\n    int c=0;\\n    for(int i=0;i<strlen(jewels);i++)\\n    {\\n        for(int j=0;j<strlen(stones);j++)\\n        {\\n            if(jewels[i]==stones[j])\\n            c++;\\n        }"], ["int numJewelsInStones(char * jewels, char * stones)\\n{\\n    int c=0;\\n    for(int i=0;i<strlen(jewels);i++)\\n    {\\n        for(int j=0;j<strlen(stones);j++)\\n        {\\n            if(jewels[i]==stones[j])\\n            c++;\\n        }"]]}
{"id": "1125", "ref_c": [["char * alphabetBoardPath(char * target){\\n    char *a = malloc(512), *p = a, m[128][2] = { { 0 }"], ["char * alphabetBoardPath(char * target){\\n    char *a = malloc(512), *p = a, m[128][2] = { { 0 }"], ["char * alphabetBoardPath(char * target){\\n    char *a = malloc(512), *p = a, m[128][2] = { { 0 }"]]}
{"id": "1126", "ref_c": [["int sumOfMultiples(int n){\\n     if(n==1) return 0;\\n     if( n%7==0 || n%5==0 || n%3==0)\\n     return n+sumOfMultiples(n-1);\\n     return sumOfMultiples(n-1);\\n}", "int sumOfMultiples(int n) {\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            if(i%3==0 || i%5==0 || i%7==0) sum+=i;\\n        }", "int sumOfMultiples(int n) {\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            if(i%3==0 || i%5==0 || i%7==0) sum+=i;\\n        }", "int sumOfMultiples(int n) {\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            if(i%3==0 || i%5==0 || i%7==0) sum+=i;\\n        }"], ["int sumOfMultiples(int n) {\\n    // Brute force \\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(1)\\n\\n    int result = 0;\\n    for (int i = 1; i < n + 1; ++i) {\\n        if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) result += i;\\n    }"], ["int sumOfMultiples(int n){\\n    int sum=0;\\n    for(int i=3;i<=n;i++){\\n      if(i%3==0){\\n          sum+=i;\\n      }"]]}
{"id": "1127", "ref_c": [["void gameOfLife(int** board, int boardSize, int* boardColSize) {\\n    // 0 -> 1 => 3; 1 -> 0 => 4;    \\n    for(int r = 0; r < boardSize; r++){\\n        for(int c = 0; c < *boardColSize; c++){\\n            int sumNeighbor = 0;\\n            for(int i = r-1; i <= (r+1); i++){\\n                if((i < 0) || (i >= boardSize)) continue;\\n                for(int j = c-1; j <= (c+1); j++){\\n                    if((j < 0) || (j >= *boardColSize)) continue;\\n                    sumNeighbor += (board[i][j]%3);\\n                }"], ["void gameOfLife(int** board, int boardSize, int* boardColSize) {\\n    int dirX[] = {-1, -1, -1, 0, 0, 1, 1, 1}"], ["void gameOfLife(int** board, int boardSize, int* boardColSize) {\\n    int dirX[] = {-1, -1, -1, 0, 0, 1, 1, 1}"]]}
{"id": "1128", "ref_c": [["int longestCommonSubsequence(char * text1, char * text2){\\n  int m;\\n  int n;\\n  m=strlen(text1);\\n  n=strlen(text2);\\n  int a[m+1][n+1];\\n  int i,j;\\n  for(i=0;i<m+1;i++){\\n      a[i][0]=0;\\n  }"], ["int longestCommonSubsequence(char * text1, char * text2){\\n  int m;\\n  int n;\\n  m=strlen(text1);\\n  n=strlen(text2);\\n  int a[m+1][n+1];\\n  int i,j;\\n  for(i=0;i<m+1;i++){\\n      a[i][0]=0;\\n  }"], ["int longestCommonSubsequence(char * text1, char * text2){\\n  int m;\\n  int n;\\n  m=strlen(text1);\\n  n=strlen(text2);\\n  int a[m+1][n+1];\\n  int i,j;\\n  for(i=0;i<m+1;i++){\\n      a[i][0]=0;\\n  }"]]}
{"id": "1129", "ref_c": [["int movesToMakeZigzag(int* nums, int numsSize){    \\n    if(numsSize < 3) {\\n        return 0;\\n    }"], ["int movesToMakeZigzag(int* nums, int numsSize){    \\n    if(numsSize < 3) {\\n        return 0;\\n    }"], ["int movesToMakeZigzag(int* nums, int numsSize){    \\n    if(numsSize < 3) {\\n        return 0;\\n    }"]]}
{"id": "1130", "ref_c": [["char *** partition(char * s, int* returnSize, int** returnColumnSizes){\\n    int str_len = strlen(s);\\n    int all_pos_cnt = 1<<(str_len-1); //Count for all posiible substring\\n    char *** ret = calloc(all_pos_cnt, sizeof(char**));\\n    *returnSize = 0;\\n\\n    (*returnColumnSizes) = calloc(all_pos_cnt, sizeof(int));\\n\\n    for (int sel_bit = 0; sel_bit < all_pos_cnt; sel_bit++){\\n        char **substr = calloc(str_len, sizeof(char*));\\n        int start = 0;\\n        int sub_idx = 0;\\n        int valid = 1;\\n\\n        for(int ith_b = 0; ith_b < (str_len-1); ith_b++){\\n            if ((  (1<<ith_b) &  sel_bit) > 0){\\n                if(is_P(s, start, ith_b) == 1){\\n                    substr[sub_idx] = calloc((ith_b-start+1+1), sizeof(char)); // + 1 for \\'\\\\0\\'\\n                    memcpy(&substr[sub_idx][0], &s[start], (ith_b-start+1) * sizeof(char));\\n                    substr[sub_idx][ith_b-start+1] = \\'\\\\0\\';\\n                    start = ith_b + 1;\\n                    sub_idx++;\\n                }"], ["char *** partition(char * s, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  *s, string\\n     */\\n\\n    node_t *head = NULL, *del;\\n    char *substr_buf[16], ***ans = NULL;\\n    int substr_len[16] = {0}"], ["char *** partition(char * s, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  *s, string\\n     */\\n\\n    node_t *head = NULL, *del;\\n    char *substr_buf[16], ***ans = NULL;\\n    int substr_len[16] = {0}"]]}
{"id": "1132", "ref_c": [["int numRollsToTarget(int n, int k, int target){\\n    /*\\n     * Input:\\n     *  n, numbers of dice\\n     *  k, numbers of faces of a die\\n     *  target, integer\\n     */\\n     \\n    for (int i = 0; i <= n; i++) {\\n        for (int j = 0; j <= target; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int numRollsToTarget(int n, int k, int target) {\\n        // 2D DP\\n\\n        // Time complexity: O(n * k * target)\\n        // Space complexity: O(n * target)\\n\\n        const int Mod = 1e9 + 7;\\n        int** dp = (int**)calloc(n + 1, sizeof(int*));\\n        for (int i = 0; i < n + 1; ++i) {\\n            dp[i] = (int*)calloc(target + 1, sizeof(int));\\n        }", "int numRollsToTarget(int n, int k, int target) {\\n        // 1D DP\\n\\n        // Time complexity: O(n * k * target)\\n        // Space complexity: O(2 * target)\\n\\n        const int Mod = 1e9 + 7;\\n        int* dp = (int*)calloc(target + 1, sizeof(int));\\n        int* temp = (int*)calloc(target + 1, sizeof(int));\\n        \\n        dp[0] = 1;\\n        for (int i = 1; i < n + 1; ++i) {\\n            for (int j = 0; j < target + 1; ++j) {\\n                temp[j] = 0;\\n            }"], ["int numRollsToTarget(int n, int k, int target) {\\n        // Base Case!\\n        if(target < 0) return 0;\\n        if(n == 0 && target == 0) return 1;\\n        if(n == 0 && target != 0) return 0;\\n        if(n != 0 && target == 0) return 0;\\n\\n        int res = 0;\\n        for(int i = 1; i <= k; i++){ // For no. of dice faces.\\n            res = res + numRollsToTarget(n -1, k, target -i);\\n        }", "int numRollsToTarget(int n, int k, int target) {\\n        vector<vector<long long int>> dp(n +1, vector<long long int>(target +1, -1));\\n        return solve(n, k, target, dp);\\n    }", "int numRollsToTarget(int n, int k, int target) {\\n        return solve(n, k, target);\\n    }"]]}
{"id": "1133", "ref_c": [["int findPoisonedDuration(int* timeSeries, int timeSeriesSize, int duration) {\\n\\n    int ans=0;\\n\\n    for(int i=0; i<timeSeriesSize-1; i++){\\n        \\n        if(timeSeries[i]+duration<timeSeries[i+1])\\n            ans+=duration;\\n        else\\n            ans+=timeSeries[i+1]-timeSeries[i];\\n    }"], ["int findPoisonedDuration(int* timeSeries, int timeSeriesSize, int duration){\\n\\n    /*\\n     * Input:\\n     *  timeSeries\\n     *  timeSeriesSize\\n     *  duration\\n     */\\n\\n    int ans = 0;\\n\\n    for (int i = 0; i < timeSeriesSize; i++) {\\n\\n        if (i != timeSeriesSize - 1) {\\n            /* Non-overlap, add all poison effect duration */\\n            if (timeSeries[i] + duration < timeSeries[i + 1]) {\\n                ans += duration;\\n            }"], ["int findPoisonedDuration(int* timeSeries, int timeSeriesSize, int duration){\\n\\n    /*\\n     * Input:\\n     *  timeSeries\\n     *  timeSeriesSize\\n     *  duration\\n     */\\n\\n    int ans = 0;\\n\\n    for (int i = 0; i < timeSeriesSize; i++) {\\n\\n        if (i != timeSeriesSize - 1) {\\n            /* Non-overlap, add all poison effect duration */\\n            if (timeSeries[i] + duration < timeSeries[i + 1]) {\\n                ans += duration;\\n            }"]]}
{"id": "1135", "ref_c": [["int maxLevelSum(struct TreeNode* root) \\n{\\n    struct queue *q=NULL;\\n    int ans =bfs(root,q);\\n    return ans;\\n}"], ["int maxLevelSum(struct TreeNode* root){\\n    if (root == NULL) return 0;\\n    int level_count[MAX_number]={0}"], ["int maxLevelSum(struct TreeNode* root){\\n\\n    int* level_sum = (int*)calloc(MAX_TREE_DEPTH, sizeof(int));\\n\\n    int tree_depth = traversalTree(root, 0, level_sum);\\n\\n    int max = INT_MIN;\\n    int maxlevel = 0;\\n\\n    for(int i = 0; i < tree_depth; i++){\\n        if(level_sum[i] > max){\\n            max = level_sum[i];\\n            maxlevel = i;\\n        }", "int maxLevelSum(struct TreeNode* root){\\n\\n    if(!root){\\n        return root;\\n    }"]]}
{"id": "1136", "ref_c": [["int maxDistance(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1){\\n        return -1;\\n    }"], ["int maxDistance(int** grid, int gridSize, int* gridColSize){\\n    int rlen = gridSize, clen = *gridColSize;\\n    int wIdx = 0, rIdx = 0;\\n    int* q = (int*)calloc(QSIZE, sizeof(int));\\n    for(int i = 0; i < rlen; i++){\\n        for(int j = 0; j < clen; j++){\\n            if(grid[i][j]==1){\\n                EnQueue(q, &wIdx, i, j, 2);\\n            }"], ["int maxDistance(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1){\\n        return -1;\\n    }"]]}
{"id": "1138", "ref_c": [["int searchInsert(int* nums, int numsSize, int target){\\n    int index1 = -1;\\n    int index2 = -1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            index1 = i;\\n            break;\\n        }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"]]}
{"id": "1139", "ref_c": [["int* numSmallerByFrequency(char ** queries, int queriesSize, char ** words, int wordsSize, int* returnSize){\\n    \\n    int* frequencies = (int*)malloc(wordsSize * sizeof(int));\\n    for (int i = 0; i < wordsSize; ++i) {\\n        frequencies[i] = frequency(words[i]);\\n    }"], ["int* numSmallerByFrequency(char ** queries, int queriesSize, char ** words, int wordsSize, int* returnSize){\\n    \\n    int* frequencies = (int*)malloc(wordsSize * sizeof(int));\\n    for (int i = 0; i < wordsSize; ++i) {\\n        frequencies[i] = frequency(words[i]);\\n    }"], ["int* numSmallerByFrequency(char ** queries, int queriesSize, char ** words, int wordsSize, int* returnSize){\\n    \\n    int* frequencies = (int*)malloc(wordsSize * sizeof(int));\\n    for (int i = 0; i < wordsSize; ++i) {\\n        frequencies[i] = frequency(words[i]);\\n    }"]]}
{"id": "1140", "ref_c": [["struct ListNode* removeZeroSumSublists(struct ListNode* head) {\\n    struct ListNode sentinel = {.val = 0, .next = head}"], ["struct ListNode* removeZeroSumSublists(struct ListNode* head){\\n    struct ListNode *remove_element_List(struct ListNode *phead, struct ListNode *pstart, struct ListNode *pend)\\n{\\n    if (phead != NULL)\\n    {\\n        struct ListNode *p = phead;\\n\\n        if (p->next == NULL)\\n        {\\n            free(p);\\n            return NULL;\\n            printf(\"\\\\nthe list is empty!!\");\\n        }"], ["struct ListNode* removeZeroSumSublists(struct ListNode* head)\\n{\\n    struct ListNode * dummy_node = (struct ListNode *)malloc(sizeof(struct ListNode));\\n    dummy_node->val = 0;\\n    dummy_node->next = head;\\n\\n    head = dummy_node;\\n    \\n    struct ListNode * trav = head;\\n    int num_nodes = 0;\\n    while(trav)\\n    {\\n        num_nodes++;\\n        trav = trav->next;\\n    }"]]}
{"id": "1142", "ref_c": [["bool isPalindrome(int x){\\n    if(x<0 || x!=0 && x%10 ==0 ) return false;\\n    int check=0;\\n    while(x>check){\\n        check = check*10 + x%10;\\n        x/=10;\\n    }"], ["bool isPalindrome(int x) {\\n        long int reverse=0,temp=x;\\n        while(temp>0)\\n        {\\n            int rem=temp%10;\\n            reverse=reverse*10+rem;\\n            temp=temp/10;\\n        }", "bool isPalindrome(int x) {\\n        long int reverse=0,temp=x;\\n        while(temp>0)\\n        {\\n            int rem=temp%10;\\n            reverse=reverse*10+rem;\\n            temp=temp/10;\\n        }"], ["bool isPalindrome(int x) {\\n        // If x is negative or ends with 0 but is not 0 itself, it cannot be a palindrome.\\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\\n            return false;\\n        }"]]}
{"id": "1143", "ref_c": [["int maximumSum(int* arr, int arrSize)\\n{\\n    if (arrSize == 1)\\n        return arr[0];\\n    int ans = arr[0];\\n    int drop = 0, nodrop = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        drop = max(drop + arr[i], nodrop);\\n        nodrop = max(nodrop + arr[i], arr[i]);\\n        if (drop > ans)\\n            ans = drop;\\n        if (nodrop > ans)\\n            ans = nodrop;\\n    }"], ["int maximumSum(int* arr, int arrSize)\\n{\\n    if (arrSize == 1)\\n        return arr[0];\\n    int ans = arr[0];\\n    int drop = 0, nodrop = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        drop = max(drop + arr[i], nodrop);\\n        nodrop = max(nodrop + arr[i], arr[i]);\\n        if (drop > ans)\\n            ans = drop;\\n        if (nodrop > ans)\\n            ans = nodrop;\\n    }"], ["int maximumSum(int* arr, int arrSize)\\n{\\n    if (arrSize == 1)\\n        return arr[0];\\n    int ans = arr[0];\\n    int drop = 0, nodrop = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        drop = max(drop + arr[i], nodrop);\\n        nodrop = max(nodrop + arr[i], arr[i]);\\n        if (drop > ans)\\n            ans = drop;\\n        if (nodrop > ans)\\n            ans = nodrop;\\n    }"]]}
{"id": "1144", "ref_c": [["char * reverseParentheses(char * s){\\n    if(!s)\\n        return \"\";\\n    node*top = NULL;\\n\\n    for(int i = 0 ; i < strlen(s) ; i++ )\\n    {\\n        if(s[i] == \\'(\\')\\n            qpush(&top,i);\\n        else if( s[i] == \\')\\')\\n        {\\n            int start = qpop(&top) ;\\n            s[start] = \\' \\';\\n            start++;\\n            int end = i - 1;\\n            while(start < end)\\n            {\\n                char c = s[start];\\n                s[start] = s[end];\\n                s[end] = c;\\n                start++;\\n                end--;\\n            }"], ["char * reverseParentheses(char * s){\\n    if(!s)\\n        return \"\";\\n    node*top = NULL;\\n\\n    for(int i = 0 ; i < strlen(s) ; i++ )\\n    {\\n        if(s[i] == \\'(\\')\\n            qpush(&top,i);\\n        else if( s[i] == \\')\\')\\n        {\\n            int start = qpop(&top) ;\\n            s[start] = \\' \\';\\n            start++;\\n            int end = i - 1;\\n            while(start < end)\\n            {\\n                char c = s[start];\\n                s[start] = s[end];\\n                s[end] = c;\\n                start++;\\n                end--;\\n            }"], ["char * reverseParentheses(char * s){\\n    if(!s)\\n        return \"\";\\n    node*top = NULL;\\n\\n    for(int i = 0 ; i < strlen(s) ; i++ )\\n    {\\n        if(s[i] == \\'(\\')\\n            qpush(&top,i);\\n        else if( s[i] == \\')\\')\\n        {\\n            int start = qpop(&top) ;\\n            s[start] = \\' \\';\\n            start++;\\n            int end = i - 1;\\n            while(start < end)\\n            {\\n                char c = s[start];\\n                s[start] = s[end];\\n                s[end] = c;\\n                start++;\\n                end--;\\n            }"]]}
{"id": "1145", "ref_c": [["int kConcatenationMaxSum(int* arr, int arrSize, int k){\\n    if(k==1){\\n        return kadane(arr,arrSize,1);\\n    }"], ["int kConcatenationMaxSum(int* arr, int arrSize, int k){\\n    // 3 - condition  \\n    // 1. all value < 0 => No matter k => return 0;\\n\\n    // Ex [1,2,3,-4,-5,-6,1,2,4] => totalsum < 0, k = 3,4,5,6,7....\\n    // 2. Max SubSum = [1,2,4,1,2,3] ,just do k=2 is ok\\n\\n    // Ex [1,-4,5,6,-5] => totalsum > 0, k = 3,4,5,6,7....\\n    // 3. Max SubSum = [5,6,-5,[1,-4,5,6,-5].....,1,-4,5,6] = [5,6,-5 + 1,-4,5,6](repeat 2th) + totalsum*(k-2)\\n    int res=INT_MIN;\\n    int currsum=0;\\n    int totalsum=0;\\n    for(int i=0;i<arrSize*fmin(k,2);i++){\\n        currsum=fmax(arr[i%arrSize]+currsum,arr[i%arrSize]);\\n        res=fmax(res,currsum);\\n        if(i<arrSize) totalsum+=arr[i];\\n    }"], ["int kConcatenationMaxSum(int* arr, int arrSize, int k){\\n    if(k==1){\\n        return kadane(arr,arrSize,1);\\n    }"]]}
{"id": "1148", "ref_c": [["long gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}"], ["long gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}"], ["long gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}"]]}
{"id": "1149", "ref_c": [["int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int* res = malloc(sizeof(int) * 10000);\\n    *returnSize = 0;\\n    int curr_sum_of_even_values = 0;\\n    for(int i = 0; i < numsSize; i++) {\\n        if((*(nums + i) & 0x01) == 0) {\\n            curr_sum_of_even_values += *(nums + i);\\n        }"], ["int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int* res = malloc(sizeof(int) * 10000);\\n    *returnSize = 0;\\n    int curr_sum_of_even_values = 0;\\n    for(int i = 0; i < numsSize; i++) {\\n        if((*(nums + i) & 0x01) == 0) {\\n            curr_sum_of_even_values += *(nums + i);\\n        }"], ["int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int* res = malloc(sizeof(int) * 10000);\\n    *returnSize = 0;\\n    int curr_sum_of_even_values = 0;\\n    for(int i = 0; i < numsSize; i++) {\\n        if((*(nums + i) & 0x01) == 0) {\\n            curr_sum_of_even_values += *(nums + i);\\n        }"]]}
{"id": "1151", "ref_c": [["int minPathSum(int** grid, int gridSize, int* gridColSize) {\\n    int **dp = (int *)malloc(gridSize*sizeof(int *));\\n    for(int i=0; i<gridSize; i++){\\n        dp[i] = (int *)malloc(gridColSize[0]*sizeof(int));\\n        dp[0][0] = grid[0][0];\\n        if(i>0){\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }"], ["int minPathSum(int** grid, int gridSize, int* gridColSize){\\n    int i, j;\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    \\n    for(i=0;i<m;i++){\\n        for(j=0;j<n;j++){\\n            if(i>0 && j>0)\\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\\n            else if(i>0)\\n                grid[i][j] += grid[i-1][j];\\n            else if(j>0)\\n                grid[i][j] += grid[i][j-1];\\n        }"], ["int minPathSum(int** grid, int gridSize, int* gridColSize) {\\n    int **dp = (int *)malloc(gridSize*sizeof(int *));\\n    for(int i=0; i<gridSize; i++){\\n        dp[i] = (int *)malloc(gridColSize[0]*sizeof(int));\\n        dp[0][0] = grid[0][0];\\n        if(i>0){\\n            dp[i][0] = grid[i][0] + dp[i-1][0];\\n        }"]]}
{"id": "1152", "ref_c": [["char * removeDuplicates(char * s, int k){\\n    int len = strlen(s), cnt = 0, sIdx = -1;\\n    char* st = (char*)calloc(len+1, sizeof(char));\\n    for(int i = 0; i < len; i++){\\n        st[++sIdx] = s[i];\\n        if(sIdx>0 && st[sIdx]==st[sIdx-1]){\\n            cnt++;\\n            if(cnt == k){\\n                sIdx -= k;\\n                int idx = sIdx;\\n                cnt = 1;\\n\\t\\t\\t\\t/* calculate how many same character at the beginning of the top after removing */\\n                while(idx > 0 && st[idx]==st[idx-1]){\\n                    idx--;\\n                    cnt++;\\n                }"], ["char * removeDuplicates(char * s, int k){\\n//keep track of substrings of s that are k number of duplicate letters\\n\\n//treat each new letter as 1st index(in a 1-indexed array) of   \\n//potential duplicate substring\\n\\n//with each consecutive repeated letter the index of the substring\\n//increases\\n\\n//reduce idx by k amount when the index of the substring reaches k\\n    char* ans = malloc((strlen(s) + 1) * sizeof(char));\\n    int* dup = malloc(strlen(s) * sizeof(int));\\n    int idx = 0;\\n\\n    for(int i = 0; i < strlen(s); i++) {\\n        ans[idx] = s[i];\\n        dup[idx] = 1;\\n        if(idx != 0 && ans[idx] == ans[idx-1]) {\\n            dup[idx] = dup[idx-1] + 1;\\n        }"], ["char * removeDuplicates(char * s, int k){\\n    int len = strlen(s), cnt = 0, sIdx = -1;\\n    char* st = (char*)calloc(len+1, sizeof(char));\\n    for(int i = 0; i < len; i++){\\n        st[++sIdx] = s[i];\\n        if(sIdx>0 && st[sIdx]==st[sIdx-1]){\\n            cnt++;\\n            if(cnt == k){\\n                sIdx -= k;\\n                int idx = sIdx;\\n                cnt = 1;\\n\\t\\t\\t\\t/* calculate how many same character at the beginning of the top after removing */\\n                while(idx > 0 && st[idx]==st[idx-1]){\\n                    idx--;\\n                    cnt++;\\n                }"]]}
{"id": "1153", "ref_c": [["int longestSubsequence(int* arr, int arrSize, int difference){\\n    int lmax=1;\\n    int* l=(int*)calloc(powe(10,7),sizeof(int));\\n    int d=difference;\\n\\n    for(int i=0;i<arrSize;i++)\\n    {\\n        int k=arr[i]+powe(10,6);\\n        k=k%powe(10,7);\\n        int k1=arr[i]-d+powe(10,6);\\n        k1=k1%powe(10,7);\\n        l[k]=max(l[k1]+1,l[k]);\\n        lmax=max(l[k],lmax);\\n    }"], ["int longestSubsequence(int* arr, int arrSize, int difference){\\n    if (arrSize == 0) return 0;\\n\\n    int curr_start = 0;\\n    int i,i_prev;\\n    int curr_length = 1;\\n\\n    int max_length = 1;\\n\\n    while (curr_start < arrSize) {\\n        curr_length = 1;\\n        i_prev = curr_start;\\n        i = curr_start+1;\\n        while (1) {\\n            //printf(\"i=%d\\\\n\",i);\\n            while (i<arrSize && (arr[i] - arr[i_prev] != difference)) {\\n                i++;\\n            }", "int longestSubsequence(int* arr, int arrSize, int difference){\\n    if (arrSize == 0) return 0;\\n\\n    int * subseq_len = calloc(20001,sizeof(int));\\n    int i,j,k;\\n    // subseq_len[i] stores the length of the largest subsequence which was found ending in arr[i] mod 20_001\\n    // (20_001 because there are as many possible values for arr[i])\\n\\n    int max_len = 0;\\n    for (i=0;i<arrSize;i++) {\\n        printf(\"i=%d\\\\n\",i);\\n        k = arr[i];\\n        if (k < 0) {\\n            k+=20001;\\n        }"], ["int longestSubsequence(int* arr, int arrSize, int difference){\\n    int lmax=1;\\n    int* l=(int*)calloc(powe(10,7),sizeof(int));\\n    int d=difference;\\n\\n    for(int i=0;i<arrSize;i++)\\n    {\\n        int k=arr[i]+powe(10,6);\\n        k=k%powe(10,7);\\n        int k1=arr[i]-d+powe(10,6);\\n        k1=k1%powe(10,7);\\n        l[k]=max(l[k1]+1,l[k]);\\n        lmax=max(l[k],lmax);\\n    }"]]}
{"id": "1154", "ref_c": [["bool isIsomorphic(char * s, char * t){\\n    char f2s[128]={0}"], ["bool isIsomorphic(char * s, char * t){\\n    char f2s[128]={0}"], ["bool isIsomorphic(char * s, char * t){\\n    char f2s[128]={0}"]]}
{"id": "1155", "ref_c": [["int** queensAttacktheKing(int** queens, int queensSize, int* queensColSize, int* king, int kingSize, int* returnSize, int** returnColumnSizes){\\n    int** board = malloc(sizeof(int*)*8);\\n    for(int i=0;i<8;i++){\\n        board[i] = calloc(8, sizeof(int));\\n    }"], ["int** queensAttacktheKing(int** queens, int queensSize, int* queensColSize, int* king, int kingSize, int* returnSize, int** returnColumnSizes){\\n    int** board = malloc(sizeof(int*)*8);\\n    for(int i=0;i<8;i++){\\n        board[i] = calloc(8, sizeof(int));\\n    }"], ["int** queensAttacktheKing(int** queens, int queensSize, int* queensColSize, int* king, int kingSize, int* returnSize, int** returnColumnSizes){\\n    int** board = malloc(sizeof(int*)*8);\\n    for(int i=0;i<8;i++){\\n        board[i] = calloc(8, sizeof(int));\\n    }"]]}
{"id": "1157", "ref_c": [["double nthPersonGetsNthSeat(int n){\\nif(n==1) {\\n    return  1;\\n}"], ["double nthPersonGetsNthSeat(int n){\\nif(n==1) {\\n    return  1;\\n}"], ["double nthPersonGetsNthSeat(int n){\\nif(n==1) {\\n    return  1;\\n}"]]}
{"id": "1158", "ref_c": [["bool isPalindrome(struct ListNode* head){\\n        if(!head)   return false;\\n        if(!head->next) return true;\\n\\n        struct ListNode *rev_head = NULL , *ptr = head;\\n        while(ptr != NULL)\\n        {\\n            struct ListNode *temp = (struct ListNode*)malloc(sizeof(struct ListNode));\\n            temp->val = ptr->val;\\n            temp->next = rev_head;\\n            rev_head = temp;\\n            ptr = ptr->next;\\n        }"], ["bool isPalindrome(struct ListNode* head){\\n        if(!head)   return false;\\n        if(!head->next) return true;\\n\\n        struct ListNode *rev_head = NULL , *ptr = head;\\n        while(ptr != NULL)\\n        {\\n            struct ListNode *temp = (struct ListNode*)malloc(sizeof(struct ListNode));\\n            temp->val = ptr->val;\\n            temp->next = rev_head;\\n            rev_head = temp;\\n            ptr = ptr->next;\\n        }"], ["bool isPalindrome(struct ListNode* head){\\n        if(!head)   return false;\\n        if(!head->next) return true;\\n\\n        struct ListNode *rev_head = NULL , *ptr = head;\\n        while(ptr != NULL)\\n        {\\n            struct ListNode *temp = (struct ListNode*)malloc(sizeof(struct ListNode));\\n            temp->val = ptr->val;\\n            temp->next = rev_head;\\n            rev_head = temp;\\n            ptr = ptr->next;\\n        }"]]}
{"id": "1159", "ref_c": [["int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){\\n\\n    // the max in C{9, h}"], ["int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){\\n    int candidates[] = { 1,2,3,4,5,6,7,8,9}"], ["int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){\\n    int tBuf[k];\\n    int **ret = NULL;\\n    *returnSize = 0;\\n    ret = (int**)malloc(sizeof(int*) * 100);\\n    *returnColumnSizes = (int*)malloc(sizeof(int) * 100);\\n    fun(ret, n, k, 0, returnSize, *returnColumnSizes, 1, tBuf);\\n    return ret;\\n}"]]}
{"id": "1160", "ref_c": [["int** findSolution(int (*customFunction)(int, int), int z, int* returnSize, int** returnColumnSizes) {\\n\\t/*\\n     * Input:\\n     *  customFunction, function pointer points to the hidden implementations of CustomFunction\\n     *  z, integer, f(x, y) = z\\n     */\\n     \\n    int **ans = (int **)malloc(sizeof(int *) * 1000000);\\n    \\n    *returnColumnSizes = (int *)malloc(sizeof(int) * 1000000);\\n    *returnSize = 0;\\n    \\n    for (int x = 1; x <= 1000; x++) {\\n        for (int y = 1; y <= 1000; y++) {\\n        \\n            if (customFunction(x, y) == z) {\\n                ans[*returnSize] = (int *)malloc(sizeof(int) * 2);\\n                ans[*returnSize][0] = x;\\n                ans[*returnSize][1] = y;\\n                (*returnColumnSizes)[*returnSize] = 2;\\n                (*returnSize)++;\\n            }"], ["int** findSolution(int (*customFunction)(int, int), int z, int* returnSize, int** returnColumnSizes) {\\n\\t/*\\n     * Input:\\n     *  customFunction, function pointer points to the hidden implementations of CustomFunction\\n     *  z, integer, f(x, y) = z\\n     */\\n     \\n    int **ans = (int **)malloc(sizeof(int *) * 1000000);\\n    \\n    *returnColumnSizes = (int *)malloc(sizeof(int) * 1000000);\\n    *returnSize = 0;\\n    \\n    for (int x = 1; x <= 1000; x++) {\\n        for (int y = 1; y <= 1000; y++) {\\n        \\n            if (customFunction(x, y) == z) {\\n                ans[*returnSize] = (int *)malloc(sizeof(int) * 2);\\n                ans[*returnSize][0] = x;\\n                ans[*returnSize][1] = y;\\n                (*returnColumnSizes)[*returnSize] = 2;\\n                (*returnSize)++;\\n            }"], ["int** findSolution(int (*customFunction)(int, int), int z, int* returnSize, int** returnColumnSizes) {\\n\\t/*\\n     * Input:\\n     *  customFunction, function pointer points to the hidden implementations of CustomFunction\\n     *  z, integer, f(x, y) = z\\n     */\\n     \\n    int **ans = (int **)malloc(sizeof(int *) * 1000000);\\n    \\n    *returnColumnSizes = (int *)malloc(sizeof(int) * 1000000);\\n    *returnSize = 0;\\n    \\n    for (int x = 1; x <= 1000; x++) {\\n        for (int y = 1; y <= 1000; y++) {\\n        \\n            if (customFunction(x, y) == z) {\\n                ans[*returnSize] = (int *)malloc(sizeof(int) * 2);\\n                ans[*returnSize][0] = x;\\n                ans[*returnSize][1] = y;\\n                (*returnColumnSizes)[*returnSize] = 2;\\n                (*returnSize)++;\\n            }"]]}
{"id": "1161", "ref_c": [["int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int ans = 0;\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 0) {\\n                continue; // If the element is 0, continue to the next iteration\\n            }", "int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    // Array to store counts of \\'1\\'s in each row and column\\n    int* rowCount = (int*)calloc(m, sizeof(int)); // Initialize row count array with 0s\\n    int* colCount = (int*)calloc(n, sizeof(int)); // Initialize column count array with 0s\\n\\n    // Counting \\'1\\'s in each row and column\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 1) {\\n                rowCount[row]++; // Increment row count when \\'1\\' is encountered in the row\\n                colCount[col]++; // Increment column count when \\'1\\' is encountered in the column\\n            }"], ["int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int ans = 0;\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 0) {\\n                continue; // If the element is 0, continue to the next iteration\\n            }", "int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    // Array to store counts of \\'1\\'s in each row and column\\n    int* rowCount = (int*)calloc(m, sizeof(int)); // Initialize row count array with 0s\\n    int* colCount = (int*)calloc(n, sizeof(int)); // Initialize column count array with 0s\\n\\n    // Counting \\'1\\'s in each row and column\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 1) {\\n                rowCount[row]++; // Increment row count when \\'1\\' is encountered in the row\\n                colCount[col]++; // Increment column count when \\'1\\' is encountered in the column\\n            }"], ["int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int result = 0;\\n\\n    // Arrays to store the sums of elements in each row and column\\n    int* rowSums = (int*)malloc(matSize * sizeof(int));\\n    int* colSums = (int*)malloc(matColSize[0] * sizeof(int));\\n\\n    // Initialize rowSums and colSums to zeros\\n    for (int i = 0; i < matSize; i++) {\\n        rowSums[i] = 0;\\n    }"]]}
{"id": "1162", "ref_c": [["int maxLength(char ** arr, int arrSize){\\n    int result = 0;\\n    helper(arr, arrSize, 0, \"\", &result);\\n    return result;\\n}"], ["int maxLength(char ** arr, int arrSize){\\n    int* mask = (int*)calloc(arrSize, sizeof(int));\\n    for(int i = 0; i < arrSize; i++){\\n        int len = strlen(arr[i]);\\n        for(int j = 0; j < len; j++){\\n            if(mask[i] & (1 << (arr[i][j]-\\'a\\'))){\\n                mask[i] = 0;/* repeat char */\\n                break;\\n            }"], ["int maxLength(char ** arr, int arrSize){\\n    char *concStr = calloc(sizeof(char), 16 * 26 + 1);\\n    int start = 0, len = 0;\\n    // passing len to avoid few strlen() calls. \\n    // also helps in concatenating current string and removing it easily\\n    return backtrack(start, arr, arrSize, concStr, &len);\\n}"]]}
{"id": "1163", "ref_c": [["int minimumSwap(char * s1, char * s2){\\n    int l = strlen(s1);\\n    int xy = 0;\\n    int yx = 0;\\n    for(int i = 0; i < l; i++)\\n    {\\n        if (s1[i] != s2[i])\\n        {\\n            if (s1[i] == \\'x\\')\\n                xy += 1;\\n            else\\n                yx += 1;\\n        }"], ["int minimumSwap(char * s1, char * s2){\\n    int l = strlen(s1);\\n    int xy = 0;\\n    int yx = 0;\\n    for(int i = 0; i < l; i++)\\n    {\\n        if (s1[i] != s2[i])\\n        {\\n            if (s1[i] == \\'x\\')\\n                xy += 1;\\n            else\\n                yx += 1;\\n        }"], ["int minimumSwap(char * s1, char * s2){\\n    int l = strlen(s1);\\n    int xy = 0;\\n    int yx = 0;\\n    for(int i = 0; i < l; i++)\\n    {\\n        if (s1[i] != s2[i])\\n        {\\n            if (s1[i] == \\'x\\')\\n                xy += 1;\\n            else\\n                yx += 1;\\n        }"]]}
{"id": "1164", "ref_c": [["int numberOfSubarrays(int* nums, int numsSize, int k){\\n\\n    int count[50001]={0}"], ["int numberOfSubarrays(int* nums, int numsSize, int k){\\n\\n    int count[50001]={0}"], ["int numberOfSubarrays(int* nums, int numsSize, int k){\\n\\n    int count[50001]={0}"]]}
{"id": "1165", "ref_c": [["char * minRemoveToMakeValid(char * s){\\n    int len = strlen(s);\\n    int *stack = calloc(1, sizeof(int [len]));\\n    int stack_top = -1;\\n    int i = 0;\\n    char *ans = calloc(1, len + 1);\\n    while (s[i]) {\\n        if (s[i] == \\'(\\') {\\n            stack[++stack_top] = i;\\n        }"], ["char * minRemoveToMakeValid(char * s){\\n    int len = strlen(s);\\n    int *stack = calloc(1, sizeof(int [len]));\\n    int stack_top = -1;\\n    int i = 0;\\n    char *ans = calloc(1, len + 1);\\n    while (s[i]) {\\n        if (s[i] == \\'(\\') {\\n            stack[++stack_top] = i;\\n        }"], ["char * minRemoveToMakeValid(char * s){\\n    int len = strlen(s);\\n    int *stack = calloc(1, sizeof(int [len]));\\n    int stack_top = -1;\\n    int i = 0;\\n    char *ans = calloc(1, len + 1);\\n    while (s[i]) {\\n        if (s[i] == \\'(\\') {\\n            stack[++stack_top] = i;\\n        }"]]}
{"id": "1166", "ref_c": [["int** reconstructMatrix(int upper, int lower, int* colsum, int colsumSize, int* returnSize, int** returnColumnSizes){\\n\\t\\t*returnSize=0;\\n\\t\\t*returnColumnSizes=(int*)calloc(2,sizeof(int));\\n\\t\\tint **res=(int**)malloc(sizeof(int*)*2);\\n\\t\\tfor(int i=0;i<2;i++){\\n\\t\\t\\tres[i]=(int*)calloc(colsumSize,sizeof(int));\\n\\t\\t}"], ["int** reconstructMatrix(int upper, int lower, int* colsum, int colsumSize, int* returnSize, int** returnColumnSizes){\\n\\t\\t*returnSize=0;\\n\\t\\t*returnColumnSizes=(int*)calloc(2,sizeof(int));\\n\\t\\tint **res=(int**)malloc(sizeof(int*)*2);\\n\\t\\tfor(int i=0;i<2;i++){\\n\\t\\t\\tres[i]=(int*)calloc(colsumSize,sizeof(int));\\n\\t\\t}"], ["int** reconstructMatrix(int upper, int lower, int* colsum, int colsumSize, int* returnSize, int** returnColumnSizes){\\n\\t\\t*returnSize=0;\\n\\t\\t*returnColumnSizes=(int*)calloc(2,sizeof(int));\\n\\t\\tint **res=(int**)malloc(sizeof(int*)*2);\\n\\t\\tfor(int i=0;i<2;i++){\\n\\t\\t\\tres[i]=(int*)calloc(colsumSize,sizeof(int));\\n\\t\\t}"]]}
{"id": "1167", "ref_c": [["int closedIsland(int** grid, int gridSize, int* gridColSize){\\n    int rLimit = gridSize - 1;\\n    int cLimit = *gridColSize - 1;\\n    int counter = 0;\\n    for(int i = 0; i < rLimit + 1; i++) {\\n        if(i == 0 || i == rLimit) {\\n            for(int j = 0; j < cLimit + 1; j++) {\\n                if(grid[i][j] == 0) dfs(grid, i, j, rLimit, cLimit);\\n            }"], ["int closedIsland(int** grid, int gridSize, int* gridColSize){\\n    int n = gridSize, m = *gridColSize;\\n    // Exclude connected groups from four edges\\n    for (int j = 0; j < m; j++) {\\n        visit(grid, 0, j, n, m);\\n        visit(grid, n-1, j, n, m);\\n    }"], ["int closedIsland(int** grid, int gridSize, int* gridColSize){\\n    //apply dfs and flood the zeroes on boundaries\\n    // do this to find the isolated lands\\n    //apply union find to get the components\\n\\n    int rows = gridSize;\\n    int cols = gridColSize[0];\\n    flood(grid,rows,cols); // flooded with water\\n    printf(\"after flood\\\\n\");\\n    // for (int i = 0; i < rows; i++) {\\n    //     for (int j = 0; j < cols; j++) {\\n    //         printf(\"%d \",grid[i][j]);\\n    //     }"]]}
{"id": "1169", "ref_c": [["int maxSumDivThree(int* nums, int numsSize){\\n    int i, arr_sum, two, one, sub_sum_one, sub_sum_two;\\n    \\n    /* Calculate array sum */\\n    arr_sum = 0;\\n    for (i = 0; i < numsSize; ++i)\\n        arr_sum += nums[i];\\n    \\n    /* Calculate remainder and handle the trivial case */\\n    switch (arr_sum % 3)\\n    {\\n    case 0:\\n        return arr_sum;     /* We\\'re done! */\\n    case 1:\\n        one = 1;\\n        two = 2;\\n        break;\\n    default:\\n        one = 2;\\n        two = 1;\\n    }"], ["int maxSumDivThree(int* nums, int numsSize){\\n    int i, arr_sum, two, one, sub_sum_one, sub_sum_two;\\n    \\n    /* Calculate array sum */\\n    arr_sum = 0;\\n    for (i = 0; i < numsSize; ++i)\\n        arr_sum += nums[i];\\n    \\n    /* Calculate remainder and handle the trivial case */\\n    switch (arr_sum % 3)\\n    {\\n    case 0:\\n        return arr_sum;     /* We\\'re done! */\\n    case 1:\\n        one = 1;\\n        two = 2;\\n        break;\\n    default:\\n        one = 2;\\n        two = 1;\\n    }"], ["int maxSumDivThree(int* nums, int numsSize){\\n    int i, arr_sum, two, one, sub_sum_one, sub_sum_two;\\n    \\n    /* Calculate array sum */\\n    arr_sum = 0;\\n    for (i = 0; i < numsSize; ++i)\\n        arr_sum += nums[i];\\n    \\n    /* Calculate remainder and handle the trivial case */\\n    switch (arr_sum % 3)\\n    {\\n    case 0:\\n        return arr_sum;     /* We\\'re done! */\\n    case 1:\\n        one = 1;\\n        two = 2;\\n        break;\\n    default:\\n        one = 2;\\n        two = 1;\\n    }"]]}
{"id": "1170", "ref_c": [["int countServers(int** grid, int gridSize, int* gridColSize){\\n    int maxCom = 0;\\n    for(int i = 0; i < gridSize; i++)\\n    {\\n        for(int j = 0; j < *gridColSize; j++)\\n        {\\n            if(grid[i][j] == 1)\\n            {\\n                grid[i][j] = 0; /* clear avoid re-count */\\n                int cnt = 1 + DFS(grid, i, j, gridSize, *gridColSize, UPDOWN) + \\n                    DFS(grid, i, j, gridSize, *gridColSize, LEFTRIGHT);\\n                if(cnt >= 2)\\n                    maxCom += cnt;\\n            }"], ["int countServers(int** grid, int gridSize, int* gridColSize){\\n    int *row=(int*)calloc(gridSize,sizeof(int));\\n    int *col=(int*)calloc(*gridColSize,sizeof(int));\\n    for(int r=0;r<gridSize;r++){\\n        for(int c=0;c<*gridColSize;c++){\\n            if(grid[r][c]){\\n                row[r]++;\\n                col[c]++;\\n            }"], ["int countServers(int** grid, int gridSize, int* gridColSize){\\n    int *row=(int*)calloc(gridSize,sizeof(int));\\n    int *col=(int*)calloc(*gridColSize,sizeof(int));\\n    for(int r=0;r<gridSize;r++){\\n        for(int c=0;c<*gridColSize;c++){\\n            if(grid[r][c]){\\n                row[r]++;\\n                col[c]++;\\n            }"]]}
{"id": "1171", "ref_c": [["char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes) {\\n    int i, j, lo, mid, hi, swSize, *colSizes;\\n    lo = 0;\\n    swSize = strlen(searchWord);\\n    char ***ans = (char ***) calloc(swSize, sizeof(char**));\\n    colSizes = (int*) calloc(swSize, sizeof(int));\\n    *returnSize = swSize;\\n    *returnColumnSizes = colSizes;\\n    qsort(products, productsSize, sizeof(char*), compare);\\n    for (i = 0; i < swSize; ++i) {\\n        hi = productsSize;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (strncmp(products[mid],searchWord, i+1) >= 0) {\\n                hi = mid;\\n            }"], ["char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes) {\\n    int i, j, lo, mid, hi, swSize, *colSizes;\\n    lo = 0;\\n    swSize = strlen(searchWord);\\n    char ***ans = (char ***) calloc(swSize, sizeof(char**));\\n    colSizes = (int*) calloc(swSize, sizeof(int));\\n    *returnSize = swSize;\\n    *returnColumnSizes = colSizes;\\n    qsort(products, productsSize, sizeof(char*), compare);\\n    for (i = 0; i < swSize; ++i) {\\n        hi = productsSize;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (strncmp(products[mid],searchWord, i+1) >= 0) {\\n                hi = mid;\\n            }"], ["char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes) {\\n    int i, j, lo, mid, hi, swSize, *colSizes;\\n    lo = 0;\\n    swSize = strlen(searchWord);\\n    char ***ans = (char ***) calloc(swSize, sizeof(char**));\\n    colSizes = (int*) calloc(swSize, sizeof(int));\\n    *returnSize = swSize;\\n    *returnColumnSizes = colSizes;\\n    qsort(products, productsSize, sizeof(char*), compare);\\n    for (i = 0; i < swSize; ++i) {\\n        hi = productsSize;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (strncmp(products[mid],searchWord, i+1) >= 0) {\\n                hi = mid;\\n            }"]]}
{"id": "1172", "ref_c": [["int* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize) {\\n        // Brute force\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        for (int i = 0; i <= cheeseSlices; i++) {\\n            if (i*4 + (cheeseSlices- i)*2 == tomatoSlices) {\\n                int* result = (int*)calloc(2, sizeof(int));\\n                *returnSize = 2;\\n                result[0] = i;\\n                result[1] = cheeseSlices - i;\\n                return result;\\n            }", "int* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize) {\\n        // Math\\n\\n        // Time complexity: O(1)\\n        // Space complexity: O(1)\\n\\n        const int t = tomatoSlices, c = cheeseSlices;\\n        if (t % 2 == 0 && t >= 2*c && t <= 4*c) {\\n            int* result = (int*)calloc(2, sizeof(int));\\n            *returnSize = 2;\\n            result[0] = t/2 - c;\\n            result[1] = 2*c - t/2;\\n            return result;\\n        }"], ["int* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize) {\\n        // Brute force\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        for (int i = 0; i <= cheeseSlices; i++) {\\n            if (i*4 + (cheeseSlices- i)*2 == tomatoSlices) {\\n                int* result = (int*)calloc(2, sizeof(int));\\n                *returnSize = 2;\\n                result[0] = i;\\n                result[1] = cheeseSlices - i;\\n                return result;\\n            }", "int* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize) {\\n        // Math\\n\\n        // Time complexity: O(1)\\n        // Space complexity: O(1)\\n\\n        const int t = tomatoSlices, c = cheeseSlices;\\n        if (t % 2 == 0 && t >= 2*c && t <= 4*c) {\\n            int* result = (int*)calloc(2, sizeof(int));\\n            *returnSize = 2;\\n            result[0] = t/2 - c;\\n            result[1] = 2*c - t/2;\\n            return result;\\n        }"], ["int* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize) {\\n        // Brute force\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        for (int i = 0; i <= cheeseSlices; i++) {\\n            if (i*4 + (cheeseSlices- i)*2 == tomatoSlices) {\\n                int* result = (int*)calloc(2, sizeof(int));\\n                *returnSize = 2;\\n                result[0] = i;\\n                result[1] = cheeseSlices - i;\\n                return result;\\n            }", "int* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize) {\\n        // Math\\n\\n        // Time complexity: O(1)\\n        // Space complexity: O(1)\\n\\n        const int t = tomatoSlices, c = cheeseSlices;\\n        if (t % 2 == 0 && t >= 2*c && t <= 4*c) {\\n            int* result = (int*)calloc(2, sizeof(int));\\n            *returnSize = 2;\\n            result[0] = t/2 - c;\\n            result[1] = 2*c - t/2;\\n            return result;\\n        }"]]}
{"id": "1173", "ref_c": [["int countSquares(int** matrix, int matrixSize, int* matrixColSize){\\n    int count = 0;\\n    for(int i = 0 ; i < matrixSize ; i++){\\n        for(int j = 0 ; j < *matrixColSize ; j++){\\n            if(matrix[i][j] == 1){\\n                count++;\\n                check(matrix, matrixSize, matrixColSize, i, j, &count);\\n            }"], ["int countSquares(int** matrix, int matrixSize, int* matrixColSize){\\n    int count = 0;\\n    for(int i = 0 ; i < matrixSize ; i++){\\n        for(int j = 0 ; j < *matrixColSize ; j++){\\n            if(matrix[i][j] == 1){\\n                count++;\\n                check(matrix, matrixSize, matrixColSize, i, j, &count);\\n            }"], ["int countSquares(int** matrix, int matrixSize, int* matrixColSize){\\n    int count = 0;\\n    for(int i = 0 ; i < matrixSize ; i++){\\n        for(int j = 0 ; j < *matrixColSize ; j++){\\n            if(matrix[i][j] == 1){\\n                count++;\\n                check(matrix, matrixSize, matrixColSize, i, j, &count);\\n            }"]]}
{"id": "1174", "ref_c": [["int** groupThePeople(int* groupSizes, int groupSizesSize, int* returnSize, int** returnColumnSizes)\\n{\\n    int* usedCheck = (int*)malloc(groupSizesSize * sizeof(int));\\n\\n    for(int i = 0; i < groupSizesSize; i++)\\n        *(usedCheck + i) = 0;\\n\\n    int row = 0, column = 0, j = 0;\\n\\n    int** groupedPeople = (int**)malloc(groupSizesSize * sizeof(int*));\\n    *returnColumnSizes = (int*)malloc(groupSizesSize * sizeof(int));\\n\\n    for(int i = 0; i < groupSizesSize; i++)\\n    {\\n        if(usedCheck[i])\\n            continue;\\n\\n        column = 0;\\n        j = i;\\n        (*returnColumnSizes)[row] = groupSizes[i];\\n        groupedPeople[row] = (int*)malloc(groupSizes[i] * sizeof(int));\\n\\n        while (column < groupSizes[i])\\n        {\\n            if(groupSizes[j] == groupSizes[i])\\n            {\\n                *(*(groupedPeople + row) + column) = j;\\n                usedCheck[j] = 1;\\n                column++;\\n            }"], ["int** groupThePeople(int* groupSizes, int groupSizesSize, int* returnSize, int** returnColumnSizes){\\n    int** myList = (int**)malloc(sizeof(int*)*groupSizesSize);\\n    int** re = (int**)malloc(sizeof(int*)*500);\\n\\n    for(int i = 0;i < groupSizesSize;i++){\\n        myList[i] = (int*)malloc(sizeof(int)*2);\\n        myList[i][1] = i;\\n        myList[i][0] = groupSizes[i];\\n    }"], ["int** groupThePeople(int* groupSizes, int groupSizesSize, int* returnSize, int** returnColumnSizes){\\n    int groupnumber[ groupSizesSize];\\n    for ( int i = 0; i < groupSizesSize; i += 1)\\n    {\\n        groupnumber[ i] = -1;\\n    }"]]}
{"id": "1175", "ref_c": ["\nint compute(int* nums, int numsSize, int divisor) {\n    int sum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        sum += ceil(nums[i] / (double)divisor);\n    }\n    return sum;\n}\n\nint smallestDivisor(int* nums, int numsSize, int threshold) {\n int min=1,maxi=INT_MAX,result=-1;\n while(min<=maxi)\n {\n     int mid=min-(min-maxi)/2;\n     int sum=compute(nums,numsSize,mid);\n     if(sum<=threshold)\n     {\n         result=mid;\n         maxi=mid-1;\n     }\n     else if(sum>threshold)\n     min=mid+1;\n }\n return result;\n}\n", "\nint compute(int* nums, int numsSize, int divisor) {\n    int sum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        sum += ceil(nums[i] / (double)divisor);\n    }\n    return sum;\n}\n\nint smallestDivisor(int* nums, int numsSize, int threshold) {\n int min=1,maxi=INT_MAX,result=-1;\n while(min<=maxi)\n {\n     int mid=min-(min-maxi)/2;\n     int sum=compute(nums,numsSize,mid);\n     if(sum<=threshold)\n     {\n         result=mid;\n         maxi=mid-1;\n     }\n     else if(sum>threshold)\n     min=mid+1;\n }\n return result;\n}\n", "\nint compute(int* nums, int numsSize, int divisor) {\n    int sum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        sum += ceil(nums[i] / (double)divisor);\n    }\n    return sum;\n}\n\nint smallestDivisor(int* nums, int numsSize, int threshold) {\n int min=1,maxi=INT_MAX,result=-1;\n while(min<=maxi)\n {\n     int mid=min-(min-maxi)/2;\n     int sum=compute(nums,numsSize,mid);\n     if(sum<=threshold)\n     {\n         result=mid;\n         maxi=mid-1;\n     }\n     else if(sum>threshold)\n     min=mid+1;\n }\n return result;\n}\n"]}
{"id": "1177", "ref_c": [["int removeCoveredIntervals(int** intervals, int intervalsSize, int* intervalsColSize){\\n    int count=0, j, beforeR=-1;\\n    qsort(intervals, intervalsSize, sizeof(int[2]), cmpfunc);\\n    for(int i=0;i<intervalsSize;i++)\\n        if(intervals[i][1] > beforeR){\\n            beforeR = intervals[i][1];\\n            count++;    \\n        }"], ["int removeCoveredIntervals(int** intervals, int intervalsSize, int* intervalsColSize){\\n    int count=0, j, beforeR=-1;\\n    qsort(intervals, intervalsSize, sizeof(int[2]), cmpfunc);\\n    for(int i=0;i<intervalsSize;i++)\\n        if(intervals[i][1] > beforeR){\\n            beforeR = intervals[i][1];\\n            count++;    \\n        }"], ["int removeCoveredIntervals(int** intervals, int intervalsSize, int* intervalsColSize){\\n    int count=0, j, beforeR=-1;\\n    qsort(intervals, intervalsSize, sizeof(int[2]), cmpfunc);\\n    for(int i=0;i<intervalsSize;i++)\\n        if(intervals[i][1] > beforeR){\\n            beforeR = intervals[i][1];\\n            count++;    \\n        }"]]}
{"id": "1178", "ref_c": [["int* sequentialDigits(int low, int high, int* returnSize){\\n    int* res = NULL;\\n    *returnSize = 0;\\n    for (int i = 1; i <= 9; i++){\\n        int num = i;\\n        for (int j = i + 1; j <= 9; j++){\\n            num = 10 * num + j;\\n            if (low <= num && num <= high){\\n                (*returnSize)++;\\n                res = realloc(res, sizeof(int) * (*returnSize));\\n                res[(*returnSize) - 1] = num;\\n            }"], ["int* sequentialDigits(int low, int high, int* returnSize){\\n    int *result = calloc(36, sizeof(int));\\n\\n    int baseCur = 12;\\n    int baseCount = 8;\\n    int cur = 12;\\n    int add = 11;\\n    int count = 8;\\n    \\n    *returnSize = 0;\\n    while (1) {\\n        if (high < cur) {\\n            break;\\n        }"], ["int* sequentialDigits(int low, int high, int* returnSize){\\n    int *result = calloc(36, sizeof(int));\\n\\n    int baseCur = 12;\\n    int baseCount = 8;\\n    int cur = 12;\\n    int add = 11;\\n    int count = 8;\\n    \\n    *returnSize = 0;\\n    while (1) {\\n        if (high < cur) {\\n            break;\\n        }"]]}
{"id": "1179", "ref_c": [["int maxSideLength(int** mat, int matSize, int* matColSize, int threshold){\\n    int ** total = (int **)malloc((matSize + 1) * sizeof(int **));\\n    for(int i = 0; i < matSize + 1; i++)\\n        total[i] = (int *)calloc(*matColSize + 1, sizeof(int));\\n    for(int i = 1; i <= matSize; i++)\\n        for(int j = 1; j <= *matColSize; j++)\\n            total[i][j] = total[i - 1][j] + total[i][j - 1] - total[i - 1][j - 1] + mat[i - 1][j - 1];\\n    int len = matSize < *matColSize ? matSize : *matColSize;\\n    for(int k = len; k >= 1; k--)\\n        for(int i = 1; i + k <= matSize; i++)\\n            for(int j = 1; j + k <= *matColSize; j++)\\n                if(total[i + k][j + k] - total[i - 1][j + k] - total[i + k][j - 1] + total[i - 1][j - 1] <= threshold)\\n                    return k + 1;\\n    return 0;\\n}"], ["int maxSideLength(int** mat, int matSize, int* matColSize, int threshold){\\n\\n    int w = matSize;\\n    int h = matColSize[0];\\n\\n    // Construct prefix sum matrix.\\n\\n    int sums[w][h];\\n\\n    for (int x = 0; x < w; x++) {\\n        for (int y = 0; y < h; y++) {\\n\\n            sums[x][y] = mat[x][y]\\n                + (x > 0 ? sums[x - 1][y] : 0)\\n                + (y > 0 ? sums[x][y - 1] : 0)\\n                - (x > 0 && y > 0 ? sums[x - 1][y - 1] : 0);\\n\\n        }"], ["int maxSideLength(int** mat, int matSize, int* matColSize, int threshold){\\n    int ** total = (int **)malloc((matSize + 1) * sizeof(int **));\\n    for(int i = 0; i < matSize + 1; i++)\\n        total[i] = (int *)calloc(*matColSize + 1, sizeof(int));\\n    for(int i = 1; i <= matSize; i++)\\n        for(int j = 1; j <= *matColSize; j++)\\n            total[i][j] = total[i - 1][j] + total[i][j - 1] - total[i - 1][j - 1] + mat[i - 1][j - 1];\\n    int len = matSize < *matColSize ? matSize : *matColSize;\\n    for(int k = len; k >= 1; k--)\\n        for(int i = 1; i + k <= matSize; i++)\\n            for(int j = 1; j + k <= *matColSize; j++)\\n                if(total[i + k][j + k] - total[i - 1][j + k] - total[i + k][j - 1] + total[i - 1][j - 1] <= threshold)\\n                    return k + 1;\\n    return 0;\\n}"]]}
{"id": "1180", "ref_c": [["bool isPossibleDivide(int* nums, int numsSize, int k){\\n\\n    if(numsSize % k != 0)\\n        return false;\\n    \\n    hash_t* hash_table = NULL;\\n    hash_t* el;\\n    int key = 0;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    \\n    for(size_t i = 0 ; i < numsSize; i++)\\n    {\\n        key = nums[i];\\n        HASH_FIND_INT(hash_table,&key,el);\\n        if(el == NULL)\\n        {\\n            el = (hash_t*)malloc(sizeof(hash_t));\\n            el->freq = 1;\\n            el->id = nums[i];\\n            HASH_ADD_INT(hash_table,id,el);\\n        }"], ["bool isPossibleDivide(int* nums, int numsSize, int k){\\n\\n    if(numsSize % k != 0)\\n        return false;\\n    \\n    hash_t* hash_table = NULL;\\n    hash_t* el;\\n    int key = 0;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    \\n    for(size_t i = 0 ; i < numsSize; i++)\\n    {\\n        key = nums[i];\\n        HASH_FIND_INT(hash_table,&key,el);\\n        if(el == NULL)\\n        {\\n            el = (hash_t*)malloc(sizeof(hash_t));\\n            el->freq = 1;\\n            el->id = nums[i];\\n            HASH_ADD_INT(hash_table,id,el);\\n        }"], ["bool isPossibleDivide(int* nums, int numsSize, int k) {\\n    if(numsSize % k != 0) return false;\\n    if(k == 1) return true;\\n    \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    struct pair* arr = (struct pair*) calloc(numsSize, sizeof(struct pair));    \\n    arr[0].num = nums[0];\\n    arr[0].cnt = 1;\\n    int idx = 0;\\n    for(int i = 1; i < numsSize; i++) {\\n        if(nums[i] != arr[idx].num) idx++;\\n        arr[idx].num = nums[i];\\n        arr[idx].cnt++;\\n    }"]]}
{"id": "1181", "ref_c": [["bool isBalanced(struct TreeNode* root){\\n    int result = balance(root);\\n    if(result == -1)\\n        return false;\\n    else \\n        return true;\\n}"], ["bool isBalanced(struct TreeNode* root){\\n    int result = balance(root);\\n    if(result == -1)\\n        return false;\\n    else \\n        return true;\\n}"], ["bool isBalanced(struct TreeNode* root){\\n    int result = balance(root);\\n    if(result == -1)\\n        return false;\\n    else \\n        return true;\\n}"]]}
{"id": "1182", "ref_c": [["int findBestValue(int* arr, int arrSize, int target) {\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    \\n    int idx, sum = 0, tmp = 0;\\n    for(idx = 0; idx < arrSize; ++idx) {\\n        sum = tmp + arr[idx] * (arrSize - idx);\\n        if(sum > target) break;\\n        tmp += arr[idx];\\n    }"], ["int findBestValue(int* arr, int arrSize, int target) {\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    \\n    int idx, sum = 0, tmp = 0;\\n    for(idx = 0; idx < arrSize; ++idx) {\\n        sum = tmp + arr[idx] * (arrSize - idx);\\n        if(sum > target) break;\\n        tmp += arr[idx];\\n    }"], ["int findBestValue(int* arr, int arrSize, int target) {\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    \\n    int idx, sum = 0, tmp = 0;\\n    for(idx = 0; idx < arrSize; ++idx) {\\n        sum = tmp + arr[idx] * (arrSize - idx);\\n        if(sum > target) break;\\n        tmp += arr[idx];\\n    }"]]}
{"id": "1183", "ref_c": [["int deepestLeavesSum(struct TreeNode* root){\\n    maxdepth=sum=0;\\n    doit(root,0);\\n    return sum;\\n}"], ["int deepestLeavesSum(struct TreeNode* root){\\n  return add_depth_leaves(root, 1, get_depth(root));\\n}", "int deepestLeavesSum(struct TreeNode* root){\\n  int ret = 0;\\n  int depth = 0;\\n  deepestLeavesSumHelper(root, 1, &ret, &depth);\\n  return ret;\\n}", "int deepestLeavesSum(struct TreeNode* root){\\n  int ret = 0;\\n  int max_depth = 0;\\n  int depth = 0;\\n  struct TreeNode dummy;\\n  dummy.left = root;\\n  dummy.right = NULL;\\n  root = &dummy;\\n\\n  for (;;) {\\n    if (root->left) {\\n      int steps = 1;\\n      struct TreeNode* branch = root->left;\\n      while (branch->right && branch->right != root) {\\n        branch = branch->right;\\n        ++steps;\\n      }"], ["int deepestLeavesSum(struct TreeNode* root){\\n    maxdepth=sum=0;\\n    doit(root,0);\\n    return sum;\\n}"]]}
{"id": "1184", "ref_c": [["int* getAllElements(struct TreeNode* root1, struct TreeNode* root2, int* returnSize){\\n    if (!root1 && !root2)\\n        return NULL;\\n\\n    int i, count = 0;\\n    int *arr = (int*)malloc(sizeof(int) * 10002);\\n\\n    inorder_traversal(root1, arr, &count);\\n    inorder_traversal(root2, arr, &count);\\n\\n    int *result = (int*)malloc(sizeof(int) * count);\\n\\n    for (i = 0; i < count; i++)\\n        result[i] = arr[i];\\n\\n    free(arr);\\n\\n    qsort(result, count, sizeof(int), cmpfunc);\\n\\n    *returnSize = count;\\n    return result;\\n}"], ["int* getAllElements(struct TreeNode* root1, struct TreeNode* root2, int* returnSize){\\n    if (!root1 && !root2)\\n        return NULL;\\n\\n    int i, count = 0;\\n    int *arr = (int*)malloc(sizeof(int) * 10002);\\n\\n    inorder_traversal(root1, arr, &count);\\n    inorder_traversal(root2, arr, &count);\\n\\n    int *result = (int*)malloc(sizeof(int) * count);\\n\\n    for (i = 0; i < count; i++)\\n        result[i] = arr[i];\\n\\n    free(arr);\\n\\n    qsort(result, count, sizeof(int), cmpfunc);\\n\\n    *returnSize = count;\\n    return result;\\n}"], ["int* getAllElements(struct TreeNode* root1, struct TreeNode* root2, int* returnSize){\\n    if (!root1 && !root2)\\n        return NULL;\\n\\n    int i, count = 0;\\n    int *arr = (int*)malloc(sizeof(int) * 10002);\\n\\n    inorder_traversal(root1, arr, &count);\\n    inorder_traversal(root2, arr, &count);\\n\\n    int *result = (int*)malloc(sizeof(int) * count);\\n\\n    for (i = 0; i < count; i++)\\n        result[i] = arr[i];\\n\\n    free(arr);\\n\\n    qsort(result, count, sizeof(int), cmpfunc);\\n\\n    *returnSize = count;\\n    return result;\\n}"]]}
{"id": "1185", "ref_c": [["bool canReach(int* arr, int arrSize, int start) {\\n    bool retVal = false;\\n\\n    // Breadth-First Search\\n    int bfsQueueFront = 0;\\n    int bfsQueueRear = 0;\\n    int bfsQueue[arrSize * 2];\\n    memset(bfsQueue, 0, sizeof(bfsQueue));\\n    bfsQueue[0] = start;\\n    ++bfsQueueRear;\\n\\n    int visit[arrSize];\\n    memset(visit, 0, sizeof(visit));\\n    visit[start] = 1;\\n\\n    int key;\\n    int value;\\n    while (bfsQueueFront < bfsQueueRear) {\\n        value = bfsQueue[bfsQueueFront];\\n        ++bfsQueueFront;\\n\\n        if (arr[value] == 0) {\\n            retVal = true;\\n            return retVal;\\n        }"], ["bool canReach(int* arr, int arrSize, int start) {\\n    int* tmp = (int*) calloc(arrSize, sizeof(int));\\n    bool ans = search(arr, arrSize, start, tmp);\\n    free(tmp);\\n    return ans;\\n}"], ["bool canReach(int* arr, int arrSize, int start){\\n   if( start < 0 || start >= arrSize || arr[start] == -1) return false;\\n   if (arr[start] == 0) return true;\\n   int steps = arr[start];\\n   arr[start] = -1;\\n   return canReach(arr, arrSize, start+steps)||canReach(arr,arrSize,start-steps);\\n}"]]}
{"id": "1186", "ref_c": [["int* xorQueries(int* arr, int arrSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    int *res=(int*)malloc(sizeof(int)*queriesSize);\\n    for(int i=1;i<arrSize;i++){\\n        arr[i]^=arr[i-1];\\n    }"], ["int* xorQueries(int* arr, int arrSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    int *res=(int*)malloc(sizeof(int)*queriesSize);\\n    for(int i=1;i<arrSize;i++){\\n        arr[i]^=arr[i-1];\\n    }"], ["int* xorQueries(int* arr, int arrSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    int *a = malloc(sizeof(int *[queriesSize])), xor, i;\\n    for (i = xor = 0 ; i < queriesSize ; a[i++] = xor, xor = 0)\\n        for (int j = queries[i][0] ; j <= queries[i][1] ; xor ^= arr[j++]);\\n    return *returnSize = i, a;\\n}", "int* xorQueries(int* arr, int arrSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    int *a = malloc(sizeof(int *[queriesSize])), **q = queries, *x, i;\\n    for (i = 0 ; ++i < arrSize ; arr[i] ^= arr[i - 1]);\\n    for (i = -1 ; ++i < queriesSize ; a[i] = arr[(x = q[i])[1]] ^ (x[0] > 0 ? arr[x[0] - 1] : 0));\\n    return *returnSize = i, a;\\n}"]]}
{"id": "1187", "ref_c": [["char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }"], ["char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }"], ["char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }"]]}
{"id": "1188", "ref_c": [["int** matrixBlockSum(int** mat, int matSize, int* matColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize=matSize;\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*(matSize));\\n    int dp[matSize][*matColSize];\\n    dp[0][0]=0;\\n    for(int i=0;i<matSize;i++){\\n        (*returnColumnSizes)[i]=*matColSize;\\n    }"], ["int** matrixBlockSum(int** mat, int matSize, int* matColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize=matSize;\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*(matSize));\\n    int dp[matSize][*matColSize];\\n    dp[0][0]=0;\\n    for(int i=0;i<matSize;i++){\\n        (*returnColumnSizes)[i]=*matColSize;\\n    }"], ["int** matrixBlockSum(int** mat, int matSize, int* matColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize=matSize;\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*(matSize));\\n    int dp[matSize][*matColSize];\\n    dp[0][0]=0;\\n    for(int i=0;i<matSize;i++){\\n        (*returnColumnSizes)[i]=*matColSize;\\n    }"]]}
{"id": "1189", "ref_c": [["int sumEvenGrandparent(struct TreeNode* root) {\\n    if(root==NULL){\\n        return 0;\\n    }"], ["int sumEvenGrandparent(struct TreeNode* root){\\n    if(root==NULL){\\n        return 0;\\n    }"], ["int sumEvenGrandparent(struct TreeNode* root){\\n    if(!root)\\n        return 0;\\n    if(!root->left && !root->right)\\n        return 0;\\n    int ret = 0;\\n    if(!((root->val)%2)){\\n        struct TreeNode* temp = NULL;\\n        temp = root->left;\\n        if(temp && temp->left) ret+= temp->left->val;\\n        if(temp && temp->right) ret+= temp->right->val;\\n        temp=root->right;\\n        if(temp && temp->left) ret+= temp->left->val;\\n        if(temp && temp->right) ret+= temp->right->val;\\n    }"]]}
{"id": "1190", "ref_c": [["int minFlips(int a, int b, int c){\\n    int ai,bi,ci;\\n    int res=0;\\n    while(a>0 || b>0 || c>0){\\n        ai=a%2;bi=b%2;ci=c%2;\\n        if(ci==1 && ai+bi==0)\\n            res++;\\n        else if(ci==0)\\n            res+=ai+bi;\\n        a/=2;b/=2;c/=2;\\n\\n    }"], ["int minFlips(int a, int b, int c){\\n    // 0010 a\\n    // 0110 b\\n    // 0110 a|b\\n    // 0101 c\\n    // 0011 diff of (a|b) and c\\n\\n    int diff = (a|b) ^ c;\\n    int mask = 1;\\n    int ans = 0;\\n    while(diff) {\\n        if (diff & mask) {\\n            if (c & mask) ans += 1;\\n            else {\\n                if (a & mask) ans += 1;\\n                if (b & mask) ans += 1;\\n            }"], ["int minFlips(int a, int b, int c){\\n    int ai,bi,ci;\\n    int res=0;\\n    while(a>0 || b>0 || c>0){\\n        ai=a%2;bi=b%2;ci=c%2;\\n        if(ci==1 && ai+bi==0)\\n            res++;\\n        else if(ci==0)\\n            res+=ai+bi;\\n        a/=2;b/=2;c/=2;\\n\\n    }"]]}
{"id": "1191", "ref_c": [["int makeConnected(int n, int** connections, int connectionsSize, int* connectionsColSize){\\n    if(connectionsSize < n - 1)//edge case: not enough connections to connect all devices\\n        return -1;\\n\\n    int networks = n;//network count starts with amount of total devices\\n    DSU* dsu = createDSU(n);//create our disjoint set object\\n    int* root = dsu->root;\\n    int* rank = dsu->rank;\\n\\n    for(int i = 0; i < connectionsSize; i++){\\n        int computer1 = connections[i][0];\\n        int computer2 = connections[i][1];\\n        //if computers are on different networks\\n        if(find(root, computer1) != find(root, computer2)){\\n            setUnion(root, rank, computer1, computer2);//connect computers\\n            networks--;//we\\'ve connected two computers, there is now one less network\\n        }"], ["int makeConnected(int n, int** connections, int connectionsSize, int* connectionsColSize){\\n    if(connectionsSize < n - 1)//edge case: not enough connections to connect all devices\\n        return -1;\\n\\n    int networks = n;//network count starts with amount of total devices\\n    DSU* dsu = createDSU(n);//create our disjoint set object\\n    int* root = dsu->root;\\n    int* rank = dsu->rank;\\n\\n    for(int i = 0; i < connectionsSize; i++){\\n        int computer1 = connections[i][0];\\n        int computer2 = connections[i][1];\\n        //if computers are on different networks\\n        if(find(root, computer1) != find(root, computer2)){\\n            setUnion(root, rank, computer1, computer2);//connect computers\\n            networks--;//we\\'ve connected two computers, there is now one less network\\n        }"], ["int makeConnected(int n, int** connections, int connectionsSize, int* connectionsColSize){\\n  // |E(T)| = |V(T)| - 1 forall trees.\\n  // Thus, if n > connectionsSize + 1, it is impossible to fully\\n  // connect the graph\\n  if (n > connectionsSize + 1) return -1;\\n  disj_set *d = init(n);\\n  for (int i = 0; i < connectionsSize; i++) {\\n      union_sets(d, connections[i][0], connections[i][1]);\\n  }"]]}
{"id": "1193", "ref_c": ["\nchar ** printVertically(char * s, int* returnSize){\n\n    // Get the max num of words and max lenght of word\n    int max_word_len = 0; //  = num(spaces) + 1\n    int max_num_words = 0;\n    int num_words = 0;\n\n    for (int i=0;i<=strlen(s); i++)\n    {\n        if (s[i] == ' ' || s[i] == '\u0000')\n        {\n            if (s[i] == ' ')\n            {\n                max_word_len += 1;\n            }\n            max_num_words = num_words > max_num_words ? num_words : max_num_words;\n            num_words = 0;\n        }\n        else\n        {\n            num_words++;\n        }\n    }\n\n    max_word_len += 1;  // not including space for '\u0000'\n    //-----------------------------------------------------\n\n    //Allocate space for return variable ans\n    char** ans = (char**)malloc(sizeof(char*)*max_num_words);\n\n    for (int i=0; i<max_num_words; i++)\n    {\n        ans[i] = (char*)malloc(sizeof(char)*(max_word_len+1));\n    }\n    //-----------------------------------------------------\n\n    // Get vertical words\n    int letter_index = 0;\n    int word_index = 0;\n    int s_index = 0;\n\n    while (true)        // It loops over s sequentially and fills the ans array\n    {\n        if (s[s_index] == '\u0000') \n        {\n            letter_index += 1;\n            \n            for (int i=0; i<max_num_words; i++)\n            {\n                ans[i][letter_index] = '\u0000';\n            }\n            break;\n        } \n        \n        else if ((s[s_index] == ' ') && (word_index == max_num_words))\n        {\n            word_index = 0; // Reset word_index\n            letter_index += 1; // Increment to next position\n        } \n        else if ((s[s_index] == ' ') && (word_index < max_num_words))\n        {\n            ans[word_index][letter_index] = ' ';\n            word_index++;\n            s_index -=1; // To prevent inc under this condition\n        } \n        else\n        {\n            ans[word_index][letter_index] = s[s_index];\n            word_index++;\n        }\n        s_index++;\n    }\n    //-----------------------------------------------------\n\n    // Remove trailing spaces\n    for (int i=0; i<max_num_words; i++)\n    {\n        int l = strlen(ans[i]);\n\n        while (!(isalpha(ans[i][l-1])))\n        {\n            ans[i][l-1] = '\u0000';\n            l--;\n        }\n    }\n    //-----------------------------------------------------\n\n    *returnSize = max_num_words;\n    return ans;\n}\n", "\nchar ** printVertically(char * s, int* returnSize){\n\n    // Get the max num of words and max lenght of word\n    int max_word_len = 0; //  = num(spaces) + 1\n    int max_num_words = 0;\n    int num_words = 0;\n\n    for (int i=0;i<=strlen(s); i++)\n    {\n        if (s[i] == ' ' || s[i] == '\u0000')\n        {\n            if (s[i] == ' ')\n            {\n                max_word_len += 1;\n            }\n            max_num_words = num_words > max_num_words ? num_words : max_num_words;\n            num_words = 0;\n        }\n        else\n        {\n            num_words++;\n        }\n    }\n\n    max_word_len += 1;  // not including space for '\u0000'\n    //-----------------------------------------------------\n\n    //Allocate space for return variable ans\n    char** ans = (char**)malloc(sizeof(char*)*max_num_words);\n\n    for (int i=0; i<max_num_words; i++)\n    {\n        ans[i] = (char*)malloc(sizeof(char)*(max_word_len+1));\n    }\n    //-----------------------------------------------------\n\n    // Get vertical words\n    int letter_index = 0;\n    int word_index = 0;\n    int s_index = 0;\n\n    while (true)        // It loops over s sequentially and fills the ans array\n    {\n        if (s[s_index] == '\u0000') \n        {\n            letter_index += 1;\n            \n            for (int i=0; i<max_num_words; i++)\n            {\n                ans[i][letter_index] = '\u0000';\n            }\n            break;\n        } \n        \n        else if ((s[s_index] == ' ') && (word_index == max_num_words))\n        {\n            word_index = 0; // Reset word_index\n            letter_index += 1; // Increment to next position\n        } \n        else if ((s[s_index] == ' ') && (word_index < max_num_words))\n        {\n            ans[word_index][letter_index] = ' ';\n            word_index++;\n            s_index -=1; // To prevent inc under this condition\n        } \n        else\n        {\n            ans[word_index][letter_index] = s[s_index];\n            word_index++;\n        }\n        s_index++;\n    }\n    //-----------------------------------------------------\n\n    // Remove trailing spaces\n    for (int i=0; i<max_num_words; i++)\n    {\n        int l = strlen(ans[i]);\n\n        while (!(isalpha(ans[i][l-1])))\n        {\n            ans[i][l-1] = '\u0000';\n            l--;\n        }\n    }\n    //-----------------------------------------------------\n\n    *returnSize = max_num_words;\n    return ans;\n}\n", "\nchar ** printVertically(char * s, int* returnSize){\n\n    // Get the max num of words and max lenght of word\n    int max_word_len = 0; //  = num(spaces) + 1\n    int max_num_words = 0;\n    int num_words = 0;\n\n    for (int i=0;i<=strlen(s); i++)\n    {\n        if (s[i] == ' ' || s[i] == '\u0000')\n        {\n            if (s[i] == ' ')\n            {\n                max_word_len += 1;\n            }\n            max_num_words = num_words > max_num_words ? num_words : max_num_words;\n            num_words = 0;\n        }\n        else\n        {\n            num_words++;\n        }\n    }\n\n    max_word_len += 1;  // not including space for '\u0000'\n    //-----------------------------------------------------\n\n    //Allocate space for return variable ans\n    char** ans = (char**)malloc(sizeof(char*)*max_num_words);\n\n    for (int i=0; i<max_num_words; i++)\n    {\n        ans[i] = (char*)malloc(sizeof(char)*(max_word_len+1));\n    }\n    //-----------------------------------------------------\n\n    // Get vertical words\n    int letter_index = 0;\n    int word_index = 0;\n    int s_index = 0;\n\n    while (true)        // It loops over s sequentially and fills the ans array\n    {\n        if (s[s_index] == '\u0000') \n        {\n            letter_index += 1;\n            \n            for (int i=0; i<max_num_words; i++)\n            {\n                ans[i][letter_index] = '\u0000';\n            }\n            break;\n        } \n        \n        else if ((s[s_index] == ' ') && (word_index == max_num_words))\n        {\n            word_index = 0; // Reset word_index\n            letter_index += 1; // Increment to next position\n        } \n        else if ((s[s_index] == ' ') && (word_index < max_num_words))\n        {\n            ans[word_index][letter_index] = ' ';\n            word_index++;\n            s_index -=1; // To prevent inc under this condition\n        } \n        else\n        {\n            ans[word_index][letter_index] = s[s_index];\n            word_index++;\n        }\n        s_index++;\n    }\n    //-----------------------------------------------------\n\n    // Remove trailing spaces\n    for (int i=0; i<max_num_words; i++)\n    {\n        int l = strlen(ans[i]);\n\n        while (!(isalpha(ans[i][l-1])))\n        {\n            ans[i][l-1] = '\u0000';\n            l--;\n        }\n    }\n    //-----------------------------------------------------\n\n    *returnSize = max_num_words;\n    return ans;\n}\n"]}
{"id": "1194", "ref_c": [["struct TreeNode* removeLeafNodes(struct TreeNode* root, int target)\\n{\\n    bool flag=true;\\n    while(flag)\\n    {\\n        flag=search(root,target);\\n        if(flag==false)\\n            break;\\n        else\\n        {\\n            if(!root->left && !root->right)\\n            {\\n                root=NULL;\\n                break;\\n            }"], ["struct TreeNode* removeLeafNodes(struct TreeNode* root, int target)\\n{\\n    bool flag=true;\\n    while(flag)\\n    {\\n        flag=search(root,target);\\n        if(flag==false)\\n            break;\\n        else\\n        {\\n            if(!root->left && !root->right)\\n            {\\n                root=NULL;\\n                break;\\n            }"], ["struct TreeNode* removeLeafNodes(struct TreeNode* root, int target)\\n{\\n    bool flag=true;\\n    while(flag)\\n    {\\n        flag=search(root,target);\\n        if(flag==false)\\n            break;\\n        else\\n        {\\n            if(!root->left && !root->right)\\n            {\\n                root=NULL;\\n                break;\\n            }"]]}
{"id": "1195", "ref_c": ["\nbool isPalin(char * s)\n{\n    int i;\n    int l = strlen(s) - 1;\n\n    for (i = 0; i <= l; i++, l--)\n        if (s[i] != s[l])\n            break;\n    if (i > l)\n        return true;\n    return false;\n}\n\nchar * breakPalindrome(char * palindrome)\n{\n    int l = strlen(palindrome);\n\n    if (l == 1)\n        return \"\";\n\n    for (int i = 0; i < l; i++)\n    {\n        if (palindrome[i] != 'a')\n        {\n            char t = palindrome[i];\n            palindrome[i] = 'a';\n            if (!isPalin(palindrome))\n                return palindrome;\n            palindrome[i] = t;\n        }\n    }\n    palindrome[l - 1] = 'b';\n    return palindrome;\n}\n", "\nbool isPalin(char * s)\n{\n    int i;\n    int l = strlen(s) - 1;\n\n    for (i = 0; i <= l; i++, l--)\n        if (s[i] != s[l])\n            break;\n    if (i > l)\n        return true;\n    return false;\n}\n\nchar * breakPalindrome(char * palindrome)\n{\n    int l = strlen(palindrome);\n\n    if (l == 1)\n        return \"\";\n\n    for (int i = 0; i < l; i++)\n    {\n        if (palindrome[i] != 'a')\n        {\n            char t = palindrome[i];\n            palindrome[i] = 'a';\n            if (!isPalin(palindrome))\n                return palindrome;\n            palindrome[i] = t;\n        }\n    }\n    palindrome[l - 1] = 'b';\n    return palindrome;\n}\n", "\nbool isPalin(char * s)\n{\n    int i;\n    int l = strlen(s) - 1;\n\n    for (i = 0; i <= l; i++, l--)\n        if (s[i] != s[l])\n            break;\n    if (i > l)\n        return true;\n    return false;\n}\n\nchar * breakPalindrome(char * palindrome)\n{\n    int l = strlen(palindrome);\n\n    if (l == 1)\n        return \"\";\n\n    for (int i = 0; i < l; i++)\n    {\n        if (palindrome[i] != 'a')\n        {\n            char t = palindrome[i];\n            palindrome[i] = 'a';\n            if (!isPalin(palindrome))\n                return palindrome;\n            palindrome[i] = t;\n        }\n    }\n    palindrome[l - 1] = 'b';\n    return palindrome;\n}\n"]}
{"id": "1196", "ref_c": [["int** diagonalSort(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  **mat, \\n     *  matSize\\n     *  *matColSize\\n     */\\n\\n    int tmp[100], len;\\n    int **ans = (int **)malloc(sizeof(int *) * matSize);\\n\\n    (*returnColumnSizes) = (int *)malloc(sizeof(int) * matSize);\\n    \\n    *returnSize = matSize;\\n    memcpy((void *)(*returnColumnSizes), matColSize, sizeof(int) * matSize);\\n    \\n    for (int i = 0; i < matSize; i++) {\\n        ans[i] = (int *)malloc(sizeof(int) * matColSize[0]);\\n    }"], ["int** diagonalSort(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  **mat, \\n     *  matSize\\n     *  *matColSize\\n     */\\n\\n    int tmp[100], len;\\n    int **ans = (int **)malloc(sizeof(int *) * matSize);\\n\\n    (*returnColumnSizes) = (int *)malloc(sizeof(int) * matSize);\\n    \\n    *returnSize = matSize;\\n    memcpy((void *)(*returnColumnSizes), matColSize, sizeof(int) * matSize);\\n    \\n    for (int i = 0; i < matSize; i++) {\\n        ans[i] = (int *)malloc(sizeof(int) * matColSize[0]);\\n    }"], ["int** diagonalSort(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  **mat, \\n     *  matSize\\n     *  *matColSize\\n     */\\n\\n    int tmp[100], len;\\n    int **ans = (int **)malloc(sizeof(int *) * matSize);\\n\\n    (*returnColumnSizes) = (int *)malloc(sizeof(int) * matSize);\\n    \\n    *returnSize = matSize;\\n    memcpy((void *)(*returnColumnSizes), matColSize, sizeof(int) * matSize);\\n    \\n    for (int i = 0; i < matSize; i++) {\\n        ans[i] = (int *)malloc(sizeof(int) * matColSize[0]);\\n    }"]]}
{"id": "1197", "ref_c": [["int* filterRestaurants(int** restaurants, int restaurantsSize, int* restaurantsColSize, int veganFriendly, int maxPrice, int maxDistance, int* returnSize){\\n    long* q = (long*)calloc(restaurantsSize, sizeof(long));\\n    int* ans = (int*)calloc(restaurantsSize, sizeof(int));\\n    long currData, ansIdx = 0;\\n    for(int i = 0; i < restaurantsSize; i++){\\n        currData = (long)restaurants[i][1]<<18 | restaurants[i][0];\\n        if((veganFriendly && restaurants[i][2] || !veganFriendly) && restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance)\\n            q[ansIdx++] = currData;\\n    }"], ["int* filterRestaurants(int** restaurants, int restaurantsSize, int* restaurantsColSize, int veganFriendly, int maxPrice, int maxDistance, int* returnSize){\\n    long* q = (long*)calloc(restaurantsSize, sizeof(long));\\n    int* ans = (int*)calloc(restaurantsSize, sizeof(int));\\n    long currData, ansIdx = 0;\\n    for(int i = 0; i < restaurantsSize; i++){\\n        currData = (long)restaurants[i][1]<<18 | restaurants[i][0];\\n        if((veganFriendly && restaurants[i][2] || !veganFriendly) && restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance)\\n            q[ansIdx++] = currData;\\n    }"], ["int* filterRestaurants(int** restaurants, int restaurantsSize, int* restaurantsColSize, int veganFriendly, int maxPrice, int maxDistance, int* returnSize){\\n    long* q = (long*)calloc(restaurantsSize, sizeof(long));\\n    int* ans = (int*)calloc(restaurantsSize, sizeof(int));\\n    long currData, ansIdx = 0;\\n    for(int i = 0; i < restaurantsSize; i++){\\n        currData = (long)restaurants[i][1]<<18 | restaurants[i][0];\\n        if((veganFriendly && restaurants[i][2] || !veganFriendly) && restaurants[i][3] <= maxPrice && restaurants[i][4] <= maxDistance)\\n            q[ansIdx++] = currData;\\n    }"]]}
{"id": "1198", "ref_c": [["int findTheCity(int n, int** edges, int edgesSize, int* edgesColSize, int distanceThreshold) {\\n    int mp[1000][1000];\\n    // initialize mp\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(i==j) mp[i][j]=0;\\n            else mp[i][j]=INT_MAX;\\n        }"], ["int findTheCity(int n, int** edges, int edgesSize, int* edgesColSize, int distanceThreshold) {\\n    // Floyd-Warshall\\n\\n    // all pair shortest path\\n\\n    // Time complexity: O(n^3)\\n    // Space complexity: O(n^2)\\n\\n    int result = 0, minReachable = INT_MAX;\\n    int dist[n][n];\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dist[i][j] = 1e6;\\n        }"], ["int findTheCity(int n, int** edges, int edgesSize, int* edgesColSize, int distanceThreshold) {\\n    // Floyd-Warshall\\n\\n    // all pair shortest path\\n\\n    // Time complexity: O(n^3)\\n    // Space complexity: O(n^2)\\n\\n    int result = 0, minReachable = INT_MAX;\\n    int dist[n][n];\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dist[i][j] = 1e6;\\n        }"]]}
{"id": "1199", "ref_c": [["int minSetSize(int* arr, int arrSize){\\n    int i, number_cnt = 0, unique_cnt = 0, target = arrSize / 2;\\n    int map_max = 0, cnt_max = 0;\\n    int map[100001] = {0}"], ["int minSetSize(int* arr, int arrSize){\\n    int i, number_cnt = 0, unique_cnt = 0, target = arrSize / 2;\\n    int map_max = 0, cnt_max = 0;\\n    int map[100001] = {0}"], ["int minSetSize(int* arr, int arrSize){\\n    int i, number_cnt = 0, unique_cnt = 0, target = arrSize / 2;\\n    int map_max = 0, cnt_max = 0;\\n    int map[100001] = {0}"]]}
{"id": "1200", "ref_c": [["int maxProduct(struct TreeNode* root){\\n    long long max = 0;\\n    sumTreeMax(root, totalSumTree(root), &max);\\n    return max % MOD;\\n}"], ["int maxProduct(struct TreeNode* root){\\n    long long max = 0;\\n    sumTreeMax(root, totalSumTree(root), &max);\\n    return max % MOD;\\n}"], ["int maxProduct(struct TreeNode* root){\\n    long long ans=0;\\n    int totsum=sumtree(root);\\n    //traversal function\\n    int trav(struct TreeNode* root){\\n        if(root==NULL) return 0;\\n        long long m1=totsum-root->val,m2=root->val;//storing in long as the product might exceed int limit\\n        ans=max(ans,(m1*m2));\\n        trav(root->left);\\n        trav(root->right);\\n        return 0;//function can also be void\\n    }"]]}
{"id": "1202", "ref_c": [["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"]]}
{"id": "1203", "ref_c": [["double angleClock(int hour, int minutes){\\n    double maffhr=(double)minutes*30/60; //calculating the angle by which the hour hand is affected due to the minutes hand\\n    double hrangle=(double)hour*30+maffhr; //calculating the angle made by hour hand with 12\\n    double miangle=(double)minutes*30/5; //calculating the angle made by minutes hand with 12\\n    double ang=fabs(hrangle-miangle); //calculating the angle difference between the hour and minutes hand\\n    return fmin(ang,360-ang); //returns the minimum angle as been told in the description\\n}"], ["double angleClock(int hour, int minutes) {\\n        double anglem = minutes*6, angleh=hour*30;\\n        angleh+= 0.5*minutes;\\n        double angle = abs(angleh-anglem);\\n        if(angle<180) return angle;\\n        else return 360-angle;\\n    }"], ["double angleClock(int hour, int minutes) {\\n    double hour_angle = 0.5 * (60 * hour + minutes);\\n    double minute_angle = 6.0 * minutes;\\n    double angle = fabs(hour_angle - minute_angle);\\n    if (angle > 180) {\\n        angle = 360 - angle;\\n    }"]]}
{"id": "1204", "ref_c": [["int minSteps(char * s, char * t){\\n    \\n    int sa[26]={0}"], ["int minSteps(char * s, char * t){\\n    \\n    int sa[26]={0}"], ["int minSteps(char * s, char * t){\\n    \\n    int sa[26]={0}"]]}
{"id": "1207", "ref_c": [["int pathSum(struct TreeNode* root, int targetSum){\\n\\n    if(root == NULL){\\n        return 0;\\n    }", "int pathSum(struct TreeNode* root, int targetSum) {\\n\\n    return findAllPossiblePath(root, (LLI)targetSum);\\n    \\n}"], ["int pathSum(struct TreeNode* root, int targetSum){\\n\\n    if(root == NULL){\\n        return 0;\\n    }", "int pathSum(struct TreeNode* root, int targetSum) {\\n\\n    return findAllPossiblePath(root, (LLI)targetSum);\\n    \\n}"], ["int pathSum(struct TreeNode* root, int targetSum){\\n\\n    if(root == NULL){\\n        return 0;\\n    }", "int pathSum(struct TreeNode* root, int targetSum) {\\n\\n    return findAllPossiblePath(root, (LLI)targetSum);\\n    \\n}"]]}
{"id": "1209", "ref_c": [["int uniquePaths(int m, int n){\\n    memset(memo, -1, sizeof(memo));\\n    return getRoutes(0, 0, m, n);\\n}"], ["int uniquePaths(int m, int n){\\n int row[m]; int col[n];\\n  for(int i=0;i<n;i++) col[i]=1;\\n  for(int i=0;i<m;i++) row[i]=1;\\n  for(int i=1;i<m;i++){\\n      for(int j=1;j<n;j++){\\n          col[j]=col[j]+row[i];\\n          row[i]=col[j];\\n      }"], ["int uniquePaths(int m, int n) {\\n        return find ( m-1 ,n-1 );\\n    }", "int uniquePaths(int m, int n) {\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        return find(m-1,n-1,dp);\\n    }", "int uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    int dp [m] [n];   \\n\\tfor (int i=0; i<m; i++){\\n        for (int j=0 ;j<n ;j++){\\n            if ( i==0 || j==0 ) dp[i][j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=dp [i-1] [j];\\n                int u=0;\\n                if(j>0) u=dp [i] [j-1];                       \\n                dp [i] [j] =l+u;\\n                }", "int uniquePaths(int m, int n) {\\n\\t// Write your code here.\\n    vector<int> prev(n,0);\\n    for(int i=0;i<m;i++){\\n        vector<int>curr(n,0);\\n        for(int j=0;j<n;j++){\\n            if(i==0||j==0) curr[j]=1;\\n            else{                    \\n                int l=0;\\n                if(i>0) l=prev[j];\\n                int u=0;\\n                if(j>0) u=curr[j-1];                       \\n                curr[j]=l+u;\\n                }"]]}
{"id": "1210", "ref_c": [["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"]]}
{"id": "1211", "ref_c": [["int* closestDivisors(int num, int* returnSize){\\n    int *ans = calloc(2,sizeof(int));\\n    int sqt = (int)sqrt((float)(num+2));\\n    int i, p1 = num+1, p2 = num+2;\\n    int div, test;\\n    *returnSize = 2;\\n    for(i=sqt; i>0; i--) {\\n        div = p1/i;\\n        test = i*div;\\n        if(test == p1) {\\n            ans[0] = i;\\n            ans[1] = div;\\n            return ans;\\n        }"], ["int* closestDivisors(int num, int* returnSize){\\n    int *ans = calloc(2,sizeof(int));\\n    int sqt = (int)sqrt((float)(num+2));\\n    int i, p1 = num+1, p2 = num+2;\\n    int div, test;\\n    *returnSize = 2;\\n    for(i=sqt; i>0; i--) {\\n        div = p1/i;\\n        test = i*div;\\n        if(test == p1) {\\n            ans[0] = i;\\n            ans[1] = div;\\n            return ans;\\n        }"], ["int* closestDivisors(int num, int* returnSize){\\n    int *ans = calloc(2,sizeof(int));\\n    int sqt = (int)sqrt((float)(num+2));\\n    int i, p1 = num+1, p2 = num+2;\\n    int div, test;\\n    *returnSize = 2;\\n    for(i=sqt; i>0; i--) {\\n        div = p1/i;\\n        test = i*div;\\n        if(test == p1) {\\n            ans[0] = i;\\n            ans[1] = div;\\n            return ans;\\n        }"]]}
{"id": "1212", "ref_c": [["char * rankTeams(char ** votes, int votesSize){\\n    if(votesSize==1) return *(votes);\\n\\n    // reset global variables for leetcode only\\n    for(int i=0;i<26;i++)\\n        for(int j=0;j<26;j++)\\n            sum_char[i][j]=0;\\n    num_team = 0;\\n    \\n    for(int i=0;i<votesSize;i++){\\n        int tmp = 0;\\n        char* c = *(votes+i);\\n        while(*c!=\\'\\\\0\\'){\\n            sum_char[*c-\\'A\\'][tmp]++;\\n            c++;\\n            tmp++;\\n        }"], ["char * rankTeams(char ** votes, int votesSize){\\n    if(votesSize==1) return *(votes);\\n\\n    // reset global variables for leetcode only\\n    for(int i=0;i<26;i++)\\n        for(int j=0;j<26;j++)\\n            sum_char[i][j]=0;\\n    num_team = 0;\\n    \\n    for(int i=0;i<votesSize;i++){\\n        int tmp = 0;\\n        char* c = *(votes+i);\\n        while(*c!=\\'\\\\0\\'){\\n            sum_char[*c-\\'A\\'][tmp]++;\\n            c++;\\n            tmp++;\\n        }"], ["char * rankTeams(char ** votes, int votesSize){\\n    if(votesSize==1) return *(votes);\\n\\n    // reset global variables for leetcode only\\n    for(int i=0;i<26;i++)\\n        for(int j=0;j<26;j++)\\n            sum_char[i][j]=0;\\n    num_team = 0;\\n    \\n    for(int i=0;i<votesSize;i++){\\n        int tmp = 0;\\n        char* c = *(votes+i);\\n        while(*c!=\\'\\\\0\\'){\\n            sum_char[*c-\\'A\\'][tmp]++;\\n            c++;\\n            tmp++;\\n        }"]]}
{"id": "1213", "ref_c": [["bool isSubPath(struct ListNode* head, struct TreeNode* root) {\\n    // I could do pre-order traversal as well \\n    if (!head) return false; \\n    if (!root) return false; \\n\\n    if (root->val == head->val){\\n        if(checkSubpath(root, head)) return true; \\n    }"], ["bool isSubPath(struct ListNode* head, struct TreeNode* root){\\n    /*\\n     * Input:\\n     *  head, linked list\\n     *  root, binary tree\\n     */\\n\\n    /*\\n     * Output:\\n     *  Return True if all the elements in the linked list starting from the \\n     *  head correspond to some downward path connected in the binary tree \\n     *  otherwise return False.\\n     */\\n    \\n    return search(root, head);\\n}"], ["bool isSubPath(struct ListNode* head, struct TreeNode* root) {\\n        if (!root) return false;\\n        return findSubPath(head, root) || isSubPath(head, root->left) || isSubPath(head, root->right);\\n    }"]]}
{"id": "1214", "ref_c": [["int findTheLongestSubstring(char * s){\\n    int max = 0;\\n    int mask = 1;\\n    mask |= ( 1 << ( \\'e\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'i\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'o\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'u\\' - \\'a\\'));\\n    for ( int i = 0 ; i < strlen(s) ; i++){\\n        int sum = 0;\\n        if ( strlen(s) - i < max ){\\n            break;\\n        }"], ["int findTheLongestSubstring(char * s){\\n    int max = 0;\\n    int mask = 1;\\n    mask |= ( 1 << ( \\'e\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'i\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'o\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'u\\' - \\'a\\'));\\n    for ( int i = 0 ; i < strlen(s) ; i++){\\n        int sum = 0;\\n        if ( strlen(s) - i < max ){\\n            break;\\n        }"], ["int findTheLongestSubstring(char * s){\\n    int window = 0;\\n    int posBitMap[26] = {0}"]]}
{"id": "1215", "ref_c": [["int longestZigZag(struct TreeNode* root){\\n    if(!root) return 0;\\n    int ans = 0;\\n    DFS(root, 0, 0, &ans);\\n    return ans;\\n}"], ["int longestZigZag(struct TreeNode* root){\\n    if(!root) return 0;\\n    int ans = 0;\\n    DFS(root, 0, 0, &ans);\\n    return ans;\\n}"], ["int longestZigZag(struct TreeNode* root)\\n{\\n    max = 0;\\n\\n    if(root->left == NULL && root->right == NULL)\\n    {\\n        return 0;\\n    }"]]}
{"id": "1216", "ref_c": [["bool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) // Same Tree\\n            return true;\\n        if(p == NULL || q == NULL) // Different Size\\n            return false;\\n        if(p->val != q->val) // Different Nodes\\n            return false;\\n        return isSameTree(p->left,q->left) &&// check left subtree\\n               isSameTree(p->right,q->right);// check right subtree\\n}", "bool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) return true;\\n        if(p == NULL || q == NULL) return false;\\n        if(p->val != q->val) return false;\\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n}"], ["bool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}"], ["bool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}"]]}
{"id": "1217", "ref_c": [["int numOfMinutes(int n, int headID, int* manager, int managerSize, int* informTime, int informTimeSize){\\n\\tVector * adjacent[n];\\n\\tfor (int i = 0; i < n; i += 1){\\n\\t\\tadjacent[i] = Vector_create();\\n\\t}"], ["int numOfMinutes(int n, int headID, int* manager, int managerSize, int* informTime, int informTimeSize){\\n    int i;\\n    int time = 0;\\n\\n    REPORT** hierarchy = malloc(sizeof(REPORT*) * n);\\n\\n    memset(hierarchy, NULL, sizeof(REPORT*) * n);\\n    \\n    for (i = 0; i < n; i++)\\n    {\\n        if (manager[i] == -1)\\n            continue;\\n        \\n        REPORT *emp = malloc(sizeof(REPORT));\\n        emp->empId = i;\\n        emp->next = hierarchy[manager[i]];\\n        hierarchy[manager[i]] = emp;\\n    }"], ["int numOfMinutes(int n, int headID, int* manager, int managerSize, int* informTime, int informTimeSize){\\n    int i;\\n    int time = 0;\\n\\n    REPORT** hierarchy = malloc(sizeof(REPORT*) * n);\\n\\n    memset(hierarchy, NULL, sizeof(REPORT*) * n);\\n    \\n    for (i = 0; i < n; i++)\\n    {\\n        if (manager[i] == -1)\\n            continue;\\n        \\n        REPORT *emp = malloc(sizeof(REPORT));\\n        emp->empId = i;\\n        emp->next = hierarchy[manager[i]];\\n        hierarchy[manager[i]] = emp;\\n    }"]]}
{"id": "1219", "ref_c": [["struct TreeNode* balanceBST(struct TreeNode* root){\\n    struct TreeNode *avl = NULL;\\n    avl = inorder(root, avl);\\n    return avl;\\n}"], ["struct TreeNode* balanceBST(struct TreeNode* root){\\n    int n=0,i=0;\\n    count(root,&n);\\n    struct TreeNode *arr[n];\\n    void sort(struct TreeNode *root){\\n        if(root){\\n            sort(root->left);\\n            arr[i++]=root;\\n            sort(root->right);\\n        }"], ["struct TreeNode* balanceBST(struct TreeNode* root){\\n    int n=0,i=0;\\n    count(root,&n);\\n    struct TreeNode *arr[n];\\n    void sort(struct TreeNode *root){\\n        if(root){\\n            sort(root->left);\\n            arr[i++]=root;\\n            sort(root->right);\\n        }"]]}
{"id": "1220", "ref_c": [["int maxNumberOfFamilies(int n, int** reservedSeats, int reservedSeatsSize, int* reservedSeatsColSize){\\n    int ans = 0, idx = 0, bitmask, rowIdx = 1;\\n    qsort(reservedSeats, reservedSeatsSize, sizeof(int*), cmp);\\n    \\n    while(idx < reservedSeatsSize){\\n        bitmask = 0x1FE;/* without considering seat 1 and 10 */\\n        /* clear bit if reserved */\\n        while((idx < reservedSeatsSize) && (reservedSeats[idx][0] == rowIdx))\\n            bitmask &= ~(1 << (reservedSeats[idx++][1]-1));\\n        \\n        /* check group */\\n        if(bitmask==GROUP_FORMAT4) \\n            ans += 2;\\n        else if(((bitmask & GROUP_FORMAT1) == GROUP_FORMAT1) || \\n                ((bitmask & GROUP_FORMAT2) == GROUP_FORMAT2) || \\n                ((bitmask & GROUP_FORMAT3) == GROUP_FORMAT3))\\n            ans++;\\n\\n        rowIdx++;\\n    }"], ["int maxNumberOfFamilies(int n, int** reservedSeats, int reservedSeatsSize, int* reservedSeatsColSize){\\n    int ans = 0, idx = 0, bitmask, rowIdx = 1;\\n    qsort(reservedSeats, reservedSeatsSize, sizeof(int*), cmp);\\n    \\n    while(idx < reservedSeatsSize){\\n        bitmask = 0x1FE;/* without considering seat 1 and 10 */\\n        /* clear bit if reserved */\\n        while((idx < reservedSeatsSize) && (reservedSeats[idx][0] == rowIdx))\\n            bitmask &= ~(1 << (reservedSeats[idx++][1]-1));\\n        \\n        /* check group */\\n        if(bitmask==GROUP_FORMAT4) \\n            ans += 2;\\n        else if(((bitmask & GROUP_FORMAT1) == GROUP_FORMAT1) || \\n                ((bitmask & GROUP_FORMAT2) == GROUP_FORMAT2) || \\n                ((bitmask & GROUP_FORMAT3) == GROUP_FORMAT3))\\n            ans++;\\n\\n        rowIdx++;\\n    }"], ["int maxNumberOfFamilies(int n, int** reservedSeats, int reservedSeatsSize, int* reservedSeatsColSize){\\n    int ans = 0, idx = 0, bitmask, rowIdx = 1;\\n    qsort(reservedSeats, reservedSeatsSize, sizeof(int*), cmp);\\n    \\n    while(idx < reservedSeatsSize){\\n        bitmask = 0x1FE;/* without considering seat 1 and 10 */\\n        /* clear bit if reserved */\\n        while((idx < reservedSeatsSize) && (reservedSeats[idx][0] == rowIdx))\\n            bitmask &= ~(1 << (reservedSeats[idx++][1]-1));\\n        \\n        /* check group */\\n        if(bitmask==GROUP_FORMAT4) \\n            ans += 2;\\n        else if(((bitmask & GROUP_FORMAT1) == GROUP_FORMAT1) || \\n                ((bitmask & GROUP_FORMAT2) == GROUP_FORMAT2) || \\n                ((bitmask & GROUP_FORMAT3) == GROUP_FORMAT3))\\n            ans++;\\n\\n        rowIdx++;\\n    }"]]}
{"id": "1221", "ref_c": [["int getKth(int lo, int hi, int k){\\n    size_t n = hi - lo + 1;\\n    struct am m[n];\\n    for (int i = 0 ; i < n ; m[i++].n = lo++);\\n    pwr(m, n);\\n    qsort(m, n, sizeof(struct am), cmp);\\n    return m[k - 1].n;\\n}"], ["int getKth(int lo, int hi, int k){\\n    size_t n = hi - lo + 1;\\n    struct am m[n];\\n    for (int i = 0 ; i < n ; m[i++].n = lo++);\\n    pwr(m, n);\\n    qsort(m, n, sizeof(struct am), cmp);\\n    return m[k - 1].n;\\n}"], ["int getKth(int lo, int hi, int k) {\\n        vector<pair<int,int>> v;\\n        for(int i=lo;i<=hi;i++){\\n            v.push_back(make_pair(cp(i),i));\\n        }"]]}
{"id": "1222", "ref_c": [["int sumFourDivisors(int* nums, int numsSize){\\n    int ans=0;\\nfor(int i=0; i<numsSize; i++) {\\n     ans=ans+divisor(nums[i]);\\n    \\n}"], ["int sumFourDivisors(int* nums, int numsSize)\\n{\\n    int sumofno = 0;\\n    int count = 2, sum;\\n    for(int i = 0; i<numsSize; i++)\\n    {\\n        sum = nums[i]+1;\\n               \\n        for(int j = 2; j<nums[i] && nums[i]!=1; j++)\\n        {\\n               if(nums[i]%j==0)\\n               {\\n                   count+= nums[i]/j!=j?2:1;\\n                   nums[i]/=j;\\n                   sum+= j+nums[i];                     \\n               }"], ["int sumFourDivisors(int* nums, int numsSize)\\n{\\n    int sumofno = 0;\\n    int count = 2, sum;\\n    for(int i = 0; i<numsSize; i++)\\n    {\\n        sum = nums[i]+1;\\n               \\n        for(int j = 2; j<nums[i] && nums[i]!=1; j++)\\n        {\\n               if(nums[i]%j==0)\\n               {\\n                   count+= nums[i]/j!=j?2:1;\\n                   nums[i]/=j;\\n                   sum+= j+nums[i];                     \\n               }"]]}
{"id": "1223", "ref_c": [["int change(int amount, int* coins, int coinsSize) {\\n        // 2D DP method\\n\\n        // Time complexity: O(n * amount)\\n        // Space complexity: O(n * amount)\\n        \\n        const int n = coinsSize;\\n        int** dp = (int**)calloc(n + 1, sizeof(int*));\\n        for (int i = 0; i < n + 1; i++) {\\n            dp[i] = (int*)calloc(amount + 1, sizeof(int));\\n        }", "int change(int amount, int* coins, int coinsSize) {\\n        // 1D DP method\\n\\n        // Time complexity: O(amount)\\n        // Space complexity: O(n * amount)\\n\\n        const int n = coinsSize;\\n        int* dp = (int*)calloc(amount + 1, sizeof(int));\\n        dp[0] = 1;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = coins[i]; j < amount + 1; j++) {\\n                dp[j] += dp[j - coins[i]];\\n            }"], ["int change(int amount, int* coins, int coinsSize){\\n int dp[amount + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0] = 1;\\n    for (int i = 0; i < coinsSize; i++) {\\n        for (int j = coins[i]; j <= amount; j++) {\\n            dp[j] += dp[j - coins[i]];\\n        }"], ["int change(int amount, int* coins, int coinsSize){\\n int dp[amount + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0] = 1;\\n    for (int i = 0; i < coinsSize; i++) {\\n        for (int j = coins[i]; j <= amount; j++) {\\n            dp[j] += dp[j - coins[i]];\\n        }"]]}
{"id": "1225", "ref_c": [["int numTeams(int* rating, int ratingSize){\\n    int count =0;\\n    int i,j,k;\\n    \\n    for(i=0;i<ratingSize;i++)\\n    {\\n        for(j=i+1;j<ratingSize;j++)\\n        {\\n            for(k=j+1;k<ratingSize;k++)\\n            {\\n                if((rating[i]>rating[j] && rating[j]>rating[k]) || (rating[i]<rating[j] && rating[j]<rating[k]))\\n                {\\n                    count += 1;\\n                }"], ["int numTeams(int* rating, int ratingSize){\\n    int count =0;\\n    int i,j,k;\\n    \\n    for(i=0;i<ratingSize;i++)\\n    {\\n        for(j=i+1;j<ratingSize;j++)\\n        {\\n            for(k=j+1;k<ratingSize;k++)\\n            {\\n                if((rating[i]>rating[j] && rating[j]>rating[k]) || (rating[i]<rating[j] && rating[j]<rating[k]))\\n                {\\n                    count += 1;\\n                }"], ["int numTeams(int* rating, int ratingSize){\\n    int i = 0;\\n    int current = 0;\\n    int j = 0;\\n    int count = 0;\\n    int overallCount = 0;\\n    int k =0;\\n    for(i=0;i<ratingSize;i++)\\n    {\\n        for(j=i+1;j<ratingSize-1;j++)\\n        {\\n            if(rating[i] > rating[j])\\n            {\\n                for(k=j+1;k<ratingSize;k++)\\n                {\\n                    if(rating[j] > rating[k])\\n                    {\\n                        count++;\\n                    }"]]}
{"id": "1227", "ref_c": [["bool canConstruct(char * s, int k){\\n    if(strlen(s) < k)\\n        return false;\\n    int odd_char = 0;\\n    int *odd = &odd_char;\\n    int letters[26] = {}"], ["bool canConstruct(char * s, int k){\\n    if(strlen(s) < k)\\n        return false;\\n    int odd_char = 0;\\n    int *odd = &odd_char;\\n    int letters[26] = {}"], ["bool canConstruct(char * s, int k){\\n    if(strlen(s) < k)\\n        return false;\\n    int odd_char = 0;\\n    int *odd = &odd_char;\\n    int letters[26] = {}"]]}
{"id": "1228", "ref_c": [["bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2){\\n    int xParam = xCenter;\\n    int yParam = yCenter;\\n    \\n    if(xCenter<=x1){\\n        xParam = x1;\\n    }"], ["bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2){\\n    int xParam = xCenter;\\n    int yParam = yCenter;\\n    \\n    if(xCenter<=x1){\\n        xParam = x1;\\n    }"], ["bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2){\\n    int xParam = xCenter;\\n    int yParam = yCenter;\\n    \\n    if(xCenter<=x1){\\n        xParam = x1;\\n    }"]]}
{"id": "1229", "ref_c": [["int numSteps(char * s){\\n    int step = 0, CARRY = 0;\\n    for(int i = strlen(s) - 1; i > 0; i--)\\n    {\\n        if(((s[i] == \\'1\\') && (CARRY == 0)) || ((s[i] == \\'0\\') && (CARRY == 1)))\\n        {\\n            step++;/* for add 1 */\\n            CARRY = 1;/*  for next char */\\n        }"], ["int numSteps(char * s){\\n    int n = strlen(s), i = n;\\n    while (s[--i] == \\'0\\');\\n    if (i == 0) return n - 1;\\n    while (--i) n += \\'1\\' - s[i]; // count number of \\'0\\' between first and last \\'1\\'s\\n    return n + 1;\\n}"], ["int numSteps(char * s){\\n    int step = 0, CARRY = 0;\\n    for(int i = strlen(s) - 1; i > 0; i--)\\n    {\\n        if(((s[i] == \\'1\\') && (CARRY == 0)) || ((s[i] == \\'0\\') && (CARRY == 1)))\\n        {\\n            step++;/* for add 1 */\\n            CARRY = 1;/*  for next char */\\n        }"]]}
{"id": "1230", "ref_c": [["char * longestDiverseString(int a, int b, int c){\\n    \\n    int len = a+b+c;\\n    char *result = (char *)malloc(sizeof(char) * 301);\\n    memset(result,0,sizeof(char) * 301);\\n    char tmp[302]={0}"], ["char * longestDiverseString(int a, int b, int c){\\n    \\n    int len = a+b+c;\\n    char *result = (char *)malloc(sizeof(char) * 301);\\n    memset(result,0,sizeof(char) * 301);\\n    char tmp[302]={0}"], ["char * longestDiverseString(int a, int b, int c){\\n    \\n    int len = a+b+c;\\n    char *result = (char *)malloc(sizeof(char) * 301);\\n    memset(result,0,sizeof(char) * 301);\\n    char tmp[302]={0}"]]}
{"id": "1231", "ref_c": [["int* processQueries(int* queries, int queriesSize, int m, int* returnSize)\\n{\\n    int x=0;\\n    int c=0;\\n    int A[m];\\n    for(int i=0;i<m;i++)A[i]=i+1;\\n    *returnSize=queriesSize;\\n    int *ret=(int*)malloc((*returnSize)*sizeof(int));\\n    for(int i=0;i<queriesSize;i++)\\n    {\\n        while(c<m)\\n        {\\n            if(A[c]==queries[i])\\n            {\\n                x=A[c];\\n                ret[i]=c;\\n                for(int j=c;j>0;j--)\\n                {\\n                    A[j]=A[j-1];\\n                }"], ["int* processQueries(int* queries, int queriesSize, int m, int* returnSize)\\n{\\n    int x=0;\\n    int c=0;\\n    int A[m];\\n    for(int i=0;i<m;i++)A[i]=i+1;\\n    *returnSize=queriesSize;\\n    int *ret=(int*)malloc((*returnSize)*sizeof(int));\\n    for(int i=0;i<queriesSize;i++)\\n    {\\n        while(c<m)\\n        {\\n            if(A[c]==queries[i])\\n            {\\n                x=A[c];\\n                ret[i]=c;\\n                for(int j=c;j>0;j--)\\n                {\\n                    A[j]=A[j-1];\\n                }"], ["int* processQueries(int* queries, int queriesSize, int m, int* returnSize){\\n    \\n    *returnSize=queriesSize;\\n    int *ans=(int*)malloc(queriesSize*sizeof(int));\\n    int *p=(int*)malloc(m*sizeof(int));\\n    int i,j,k;\\n    for(i=0;i<m;i++)   p[i]=i+1;\\n    \\n    for(i=0;i<queriesSize;i++)\\n    {\\n        for(j=0;j<m;j++)\\n        {\\n            if(queries[i]==p[j])\\n            {\\n                ans[i]=j;\\n                for(k=j;k>0;k--)\\n                {\\n                    p[k]=p[k-1]; \\n                }"]]}
{"id": "1232", "ref_c": [["char * entityParser(char * text){\\n    char *t = text, *b = text;\\n    struct { const char *e, c, l }"], ["char * entityParser(char * text){\\n    char *t = text, *b = text;\\n    struct { const char *e, c, l }"], ["char * entityParser(char * text){\\n    char *t = text, *b = text;\\n    struct { const char *e, c, l }"]]}
{"id": "1233", "ref_c": [["int findMinFibonacciNumbers(int k){\\n    if (k==1)return 1;\\n    unsigned int F[M];\\n    F[0] = 1;\\n    F[1] = 1;\\n    int ret = 0;\\n    unsigned int closest_num;\\n    unsigned int closest_idx;\\n    for (int i = 2; i < M; i++){\\n        F[i] = F[i-1] + F[i-2];\\n        if(F[i]==k){\\n            return 1;\\n        }"], ["int findMinFibonacciNumbers(int k){\\n    if (k==1)return 1;\\n    unsigned int F[M];\\n    F[0] = 1;\\n    F[1] = 1;\\n    int ret = 0;\\n    unsigned int closest_num;\\n    unsigned int closest_idx;\\n    for (int i = 2; i < M; i++){\\n        F[i] = F[i-1] + F[i-2];\\n        if(F[i]==k){\\n            return 1;\\n        }"], ["int findMinFibonacciNumbers(int k){\\n    if (k==1)return 1;\\n    unsigned int F[M];\\n    F[0] = 1;\\n    F[1] = 1;\\n    int ret = 0;\\n    unsigned int closest_num;\\n    unsigned int closest_idx;\\n    for (int i = 2; i < M; i++){\\n        F[i] = F[i-1] + F[i-2];\\n        if(F[i]==k){\\n            return 1;\\n        }"]]}
{"id": "1234", "ref_c": [["int surfaceArea(int** grid, int gridSize, int* gridColSize)\\n{\\n    int totalArea = 0, currentArea;\\n\\n    // Neighbouring areas\\n    int areaLeft, areaRight, areaUp, areaDown;\\n\\n    // Neighbouring cubes\\n    int cubeLeft, cubeRight, cubeUp, cubeDown;\\n\\n\\n    for(int i = 0; i < gridSize; i++)\\n    {\\n        for(int j = 0; j < gridColSize[i]; j++)\\n        {\\n            if(grid[i][j] == 0) continue;\\n            \\n            areaLeft = (j - 1 < 0) ? 0 : CUBE_AREA(grid[i][j - 1]);\\n            cubeLeft = (j - 1 < 0) ? 0 : grid[i][j - 1];\\n            areaRight = (j + 1 < gridColSize[i]) ? CUBE_AREA(grid[i][j + 1]) : 0;\\n            cubeRight = (j + 1 < gridColSize[i]) ? grid[i][j + 1] : 0;\\n            areaUp = (i - 1 < 0) ? 0 : CUBE_AREA(grid[i - 1][j]);\\n            cubeUp = (i - 1 < 0) ? 0 : grid[i - 1][j];\\n            areaDown = (i + 1 < gridSize) ? CUBE_AREA(grid[i + 1][j]) : 0;\\n            cubeDown = (i + 1 < gridSize) ? grid[i + 1][j] : 0;\\n\\n            currentArea = CUBE_AREA(grid[i][j]);\\n            totalArea += CUBE_AREA(grid[i][j]);\\n\\n            totalArea -= (currentArea > areaLeft ? cubeLeft : grid[i][j])\\n                             + (currentArea > areaRight ? cubeRight : grid[i][j]) \\n                             + (currentArea > areaUp ? cubeUp : grid[i][j]) \\n                             + (currentArea > areaDown ? cubeDown : grid[i][j]);\\n\\n        }"], ["int surfaceArea(int** grid, int gridSize, int* gridColSize)\\n{\\n    int totalArea = 0, currentArea;\\n\\n    // Neighbouring areas\\n    int areaLeft, areaRight, areaUp, areaDown;\\n\\n    // Neighbouring cubes\\n    int cubeLeft, cubeRight, cubeUp, cubeDown;\\n\\n\\n    for(int i = 0; i < gridSize; i++)\\n    {\\n        for(int j = 0; j < gridColSize[i]; j++)\\n        {\\n            if(grid[i][j] == 0) continue;\\n            \\n            areaLeft = (j - 1 < 0) ? 0 : CUBE_AREA(grid[i][j - 1]);\\n            cubeLeft = (j - 1 < 0) ? 0 : grid[i][j - 1];\\n            areaRight = (j + 1 < gridColSize[i]) ? CUBE_AREA(grid[i][j + 1]) : 0;\\n            cubeRight = (j + 1 < gridColSize[i]) ? grid[i][j + 1] : 0;\\n            areaUp = (i - 1 < 0) ? 0 : CUBE_AREA(grid[i - 1][j]);\\n            cubeUp = (i - 1 < 0) ? 0 : grid[i - 1][j];\\n            areaDown = (i + 1 < gridSize) ? CUBE_AREA(grid[i + 1][j]) : 0;\\n            cubeDown = (i + 1 < gridSize) ? grid[i + 1][j] : 0;\\n\\n            currentArea = CUBE_AREA(grid[i][j]);\\n            totalArea += CUBE_AREA(grid[i][j]);\\n\\n            totalArea -= (currentArea > areaLeft ? cubeLeft : grid[i][j])\\n                             + (currentArea > areaRight ? cubeRight : grid[i][j]) \\n                             + (currentArea > areaUp ? cubeUp : grid[i][j]) \\n                             + (currentArea > areaDown ? cubeDown : grid[i][j]);\\n\\n        }"], ["int surfaceArea(int** grid, int gridSize, int* gridColSize){\\n    int area = 0;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] !=0)\\n                area += grid[i][j]*4 + 2; //Full surface\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize-1; j++)\\n        {\\n            if(grid[i][j] != 0 && grid[i][j+1] != 0)\\n                area -= grid[i][j] < grid[i][j+1] ? 2*grid[i][j] : 2*grid[i][j+1]; //reduce common surface in row\\n        }"]]}
{"id": "1235", "ref_c": [["bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize) {\\n    if(coordinatesSize <= 2){\\n        return true;\\n    }"], ["bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize) {\\n    if(coordinatesSize <= 2){\\n        return true;\\n    }"], ["bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize){\\n    /*\\n     * Input:\\n     *  **coordinates, 2D integer array contains coordinates\\n     *  coordinatesSize, row number of given array\\n     *  *coordinatesColSize, column number of given array\\n     */\\n     \\n    float slope1, x, y;\\n     \\n    if (coordinatesSize > 2) {\\n    \\n        /* Slope of first 2 coordinates */\\n        \\n        x = (float)coordinates[0][0];\\n        y = (float)coordinates[0][1];\\n        \\n        slope1 = getSlope(x, y, (float)coordinates[1][0], (float)coordinates[1][1]);\\n\\n        for (int i = 2; i < coordinatesSize; i++) {\\n        \\n            /* \\n             * The slope of each line segment should be the same \\n             * if the points are on the same straight line\\n             */\\n            if (slope1 != getSlope(x, y, (float)coordinates[i][0],  (float)coordinates[i][1])) {\\n                return false;\\n            }"]]}
{"id": "1236", "ref_c": [["bool equalFrequency(char * word){\\n    for(int i = 0 ; i < strlen(word) ; i++)\\n    {\\n        int*array = calloc(26,sizeof(int));\\n        for(int j = 0 ; j < strlen(word) ; j++)\\n        {\\n            if(j != i)\\n            {\\n                array[word[j]-\\'a\\']++;\\n            }"], ["bool equalFrequency(char * word){\\n    for(int i = 0 ; i < strlen(word) ; i++)\\n    {\\n        int*array = calloc(26,sizeof(int));\\n        for(int j = 0 ; j < strlen(word) ; j++)\\n        {\\n            if(j != i)\\n            {\\n                array[word[j]-\\'a\\']++;\\n            }"], ["bool equalFrequency(char * word){\\n    for(int i = 0 ; i < strlen(word) ; i++)\\n    {\\n        int*array = calloc(26,sizeof(int));\\n        for(int j = 0 ; j < strlen(word) ; j++)\\n        {\\n            if(j != i)\\n            {\\n                array[word[j]-\\'a\\']++;\\n            }"]]}
{"id": "1237", "ref_c": ["\nint maxScore(int* cardPoints, int cardPointsSize, int k){\n        int n=cardPointsSize;\n        int c=0;\n        int e_sum=0;\n        int e=k;\n        int s_sum=0;\n        int result=0;\n        int s=0;\n\n        if(k==n){\n            int sum=0;\n        for(int i=0;i<n;i++){\n            sum+=cardPoints[i];\n        }\n        return sum;\n        }\n        \n        for(int i=n-1;c<k;i--){\n            e_sum+=cardPoints[i];\n            c++;\n        }\n\n        while(e!=-1){\n            result=fmax(result,e_sum+s_sum);\n            s_sum+=cardPoints[s];\n\n            if(n-e<n)e_sum-=cardPoints[n-e];\n\n            s++;\n            e--;\n        }\n\n        return result;\n}\n", "\nint maxScore(int* cardPoints, int cardPointsSize, int k){\n        int n=cardPointsSize;\n        int c=0;\n        int e_sum=0;\n        int e=k;\n        int s_sum=0;\n        int result=0;\n        int s=0;\n\n        if(k==n){\n            int sum=0;\n        for(int i=0;i<n;i++){\n            sum+=cardPoints[i];\n        }\n        return sum;\n        }\n        \n        for(int i=n-1;c<k;i--){\n            e_sum+=cardPoints[i];\n            c++;\n        }\n\n        while(e!=-1){\n            result=fmax(result,e_sum+s_sum);\n            s_sum+=cardPoints[s];\n\n            if(n-e<n)e_sum-=cardPoints[n-e];\n\n            s++;\n            e--;\n        }\n\n        return result;\n}\n", "\nint maxScore(int* cardPoints, int cardPointsSize, int k){\n        int n=cardPointsSize;\n        int c=0;\n        int e_sum=0;\n        int e=k;\n        int s_sum=0;\n        int result=0;\n        int s=0;\n\n        if(k==n){\n            int sum=0;\n        for(int i=0;i<n;i++){\n            sum+=cardPoints[i];\n        }\n        return sum;\n        }\n        \n        for(int i=n-1;c<k;i--){\n            e_sum+=cardPoints[i];\n            c++;\n        }\n\n        while(e!=-1){\n            result=fmax(result,e_sum+s_sum);\n            s_sum+=cardPoints[s];\n\n            if(n-e<n)e_sum-=cardPoints[n-e];\n\n            s++;\n            e--;\n        }\n\n        return result;\n}\n"]}
{"id": "1238", "ref_c": [["int* findDiagonalOrder(int** nums, int numsSize, int* numsColSize, int* returnSize) {\\n    struct Queue* q = createQueue();\\n    enqueue(q, 0, 0);\\n    int* ans = (int*)malloc(sizeof(int) * 1000); // Assuming a maximum of 1000 elements\\n    int ansIdx = 0;\\n\\n    while (q->front != NULL) {\\n        struct Pair current = q->front->data;\\n        dequeue(q);\\n        ans[ansIdx++] = nums[current.row][current.col];\\n\\n        if (current.col == 0 && current.row + 1 < numsSize) {\\n            enqueue(q, current.row + 1, current.col);\\n        }"], ["int* findDiagonalOrder(int** nums, int numsSize, int* numsColSize, int* returnSize) {\\n    int vals_cnt = 0;\\n    int max_diag = 0;\\n    /* Find max diagnal */\\n    for (int i = 0; i < numsSize; ++i) {\\n        for (int j = 0; j < numsColSize[i]; ++j) {\\n            int diag = i + j;\\n            max_diag = fmax(max_diag, diag);\\n            ++vals_cnt;\\n        }"], ["int* findDiagonalOrder(int** nums, int numsSize, int* numsColSize, int* returnSize) {\\n    struct Queue* q = createQueue();\\n    enqueue(q, 0, 0);\\n    int* ans = (int*)malloc(sizeof(int) * 1000); // Assuming a maximum of 1000 elements\\n    int ansIdx = 0;\\n\\n    while (q->front != NULL) {\\n        struct Pair current = q->front->data;\\n        dequeue(q);\\n        ans[ansIdx++] = nums[current.row][current.col];\\n\\n        if (current.col == 0 && current.row + 1 < numsSize) {\\n            enqueue(q, current.row + 1, current.col);\\n        }"]]}
{"id": "1239", "ref_c": [["int finalValueAfterOperations(char ** operations, int operationsSize) {\\n    int x = 0;\\n\\n    for (int i = 0; i < operationsSize; i++) {\\n        if (operations[i][0] == \\'-\\' || operations[i][2] == \\'-\\' ) x--;\\n        else x++;\\n    }"], ["int finalValueAfterOperations(char ** operations, int operationsSize) {\\n    int x = 0;\\n\\n    for (int i = 0; i < operationsSize; i++) {\\n        if (operations[i][0] == \\'-\\' || operations[i][2] == \\'-\\' ) x--;\\n        else x++;\\n    }"], ["int finalValueAfterOperations(char ** operations, int operationsSize) {\\n    int x = 0;\\n\\n    for (int i = 0; i < operationsSize; i++) {\\n        if (operations[i][0] == \\'-\\' || operations[i][2] == \\'-\\' ) x--;\\n        else x++;\\n    }"]]}
{"id": "1240", "ref_c": ["\nbool checkIfCanBreak(string s1, string s2) {\n       bool first=1,second=1;\n       \n        sort(s1.begin(),s1.end()); sort(s2.begin(),s2.end());\n       \n        for(int i=0;i<s1.size();i++){\n            if(s2[i]<s1[i])second=false;\n            if(s1[i]<s2[i])first=false;\n        }\n        return (first||second)&&(s1.size()==s2.size());\n        \n        \n    }\n", "\nbool checkIfCanBreak(string s1, string s2) {\n       bool first=1,second=1;\n       \n        sort(s1.begin(),s1.end()); sort(s2.begin(),s2.end());\n       \n        for(int i=0;i<s1.size();i++){\n            if(s2[i]<s1[i])second=false;\n            if(s1[i]<s2[i])first=false;\n        }\n        return (first||second)&&(s1.size()==s2.size());\n        \n        \n    }\n", "\nbool checkIfCanBreak(string s1, string s2) {\n       bool first=1,second=1;\n       \n        sort(s1.begin(),s1.end()); sort(s2.begin(),s2.end());\n       \n        for(int i=0;i<s1.size();i++){\n            if(s2[i]<s1[i])second=false;\n            if(s1[i]<s2[i])first=false;\n        }\n        return (first||second)&&(s1.size()==s2.size());\n        \n        \n    }\n"]}
{"id": "1241", "ref_c": [["int longestSubarray(int* nums, int numsSize, int limit){\\n\\n    int ml = 0, i = 0 , j = 0, diff = 0, mn = INT_MAX, mx = INT_MIN;\\n    int mni = 0, mxi = 0, k = 0;\\n   \\n    while (i < numsSize)\\n    {\\n        // update MAX and MIN \\n        if (nums[i] >= mx)\\n        {\\n            mx  = nums[i];\\n            mxi = i;\\n        }"], ["int longestSubarray(int* nums, int numsSize, int limit)\\n{\\n    int result = 1;\\n    int left_i = 0;\\n    int min_i = 0;\\n    int max_i = 0;\\n\\n    for (int i = 1; i < numsSize; i++)\\n    {\\n        if (nums[i] < nums[min_i]) {\\n            min_i = i;\\n            if (nums[max_i] - nums[min_i] > limit) {\\n                max_i = min_i;\\n                left_i = min_i;\\n                while (nums[left_i-1] - nums[min_i] <= limit) {\\n                    left_i--;\\n                    if (nums[left_i] > nums[max_i]) {\\n                        max_i = left_i;\\n                    }"], ["int longestSubarray(int* nums, int numsSize, int limit){\\n    //int* dqin = malloc(numsSize*sizeof(int));\\n    //int* dqde = malloc(numsSize * sizeof(int));\\n    int dqin[numsSize], dqde[numsSize];\\n    int intop, front1, detop,defront;\\n    int i, left=0, ans=0;\\n    intop=front1=detop=defront = 0;\\n    dqin[intop] = dqde[detop]=0;\\n    ans=1;\\n\\n    for(i=1; i<numsSize; i++) {\\n        //dq with monotonical increasing num\\n        while(intop>=front1 && nums[i] <= nums[dqin[intop]]) {\\n            intop--;\\n        }"]]}
{"id": "1242", "ref_c": [["char ** buildArray(int* target, int targetSize, int n, int* returnSize) {\\n    // Initialize a vector of strings to store the result.\\n    char **ans = (char **)malloc(2 * n * sizeof(char *));\\n    \\n    int i = 1;  // Initialize an integer \\'i\\' to represent the current number.\\n    int idx = 0;  // Initialize an index to track the position in the \\'ans\\' array.\\n    \\n    // Iterate through each element \\'a\\' in the \\'target\\' array.\\n    for (int j = 0; j < targetSize; j++) {\\n        int a = target[j];\\n        \\n        // Check if \\'i\\' is less than \\'a\\' and perform the following steps if true:\\n        while (i < a) {\\n            ans[idx++] = strdup(\"Push\");  // Simulate pushing the current number onto the stack.\\n            ans[idx++] = strdup(\"Pop\");   // Simulate popping an element from the stack.\\n            i++;  // Move to the next number.\\n        }"], ["char ** buildArray(int* target, int targetSize, int n, int* returnSize) {\\n    // Initialize a vector of strings to store the result.\\n    char **ans = (char **)malloc(2 * n * sizeof(char *));\\n    \\n    int i = 1;  // Initialize an integer \\'i\\' to represent the current number.\\n    int idx = 0;  // Initialize an index to track the position in the \\'ans\\' array.\\n    \\n    // Iterate through each element \\'a\\' in the \\'target\\' array.\\n    for (int j = 0; j < targetSize; j++) {\\n        int a = target[j];\\n        \\n        // Check if \\'i\\' is less than \\'a\\' and perform the following steps if true:\\n        while (i < a) {\\n            ans[idx++] = strdup(\"Push\");  // Simulate pushing the current number onto the stack.\\n            ans[idx++] = strdup(\"Pop\");   // Simulate popping an element from the stack.\\n            i++;  // Move to the next number.\\n        }"], ["char ** buildArray(int* target, int targetSize, int n, int* returnSize) {\\n    // Initialize a vector of strings to store the result.\\n    char **ans = (char **)malloc(2 * n * sizeof(char *));\\n    \\n    int i = 1;  // Initialize an integer \\'i\\' to represent the current number.\\n    int idx = 0;  // Initialize an index to track the position in the \\'ans\\' array.\\n    \\n    // Iterate through each element \\'a\\' in the \\'target\\' array.\\n    for (int j = 0; j < targetSize; j++) {\\n        int a = target[j];\\n        \\n        // Check if \\'i\\' is less than \\'a\\' and perform the following steps if true:\\n        while (i < a) {\\n            ans[idx++] = strdup(\"Push\");  // Simulate pushing the current number onto the stack.\\n            ans[idx++] = strdup(\"Pop\");   // Simulate popping an element from the stack.\\n            i++;  // Move to the next number.\\n        }"]]}
{"id": "1243", "ref_c": [["struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\\n    l1=reverseLinkedList(l1);\\n    l2=reverseLinkedList(l2);\\n    int carry=0;\\n    int total=0;\\n    int digit=0;\\n    struct ListNode* result=NULL;\\n    struct ListNode *current = NULL;\\n\\n    while(l1!= NULL || l2!= NULL || carry)\\n    {\\n       int val1=l1!=NULL ? l1->val : 0;\\n       int val2=l2!=NULL ? l2->val : 0;\\n\\n       total=val1+val2+carry;\\n       carry=total/10;\\n       digit=total%10;\\n\\n       struct ListNode* node=createNode(digit);\\n       if (result == NULL) {\\n            result = node;\\n            current = node;\\n        }"], ["struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\\n    struct ListNode* prev = NULL;\\n    struct ListNode * tmp1 = l1;\\n    struct ListNode* tmp2 = l2;\\n    struct ListNode* big = NULL;\\n    int sum = 0;\\n    int remainder = 0;\\n\\n    l1 = reverse(l1);\\n    l2 = reverse(l2);\\n    tmp1 = l1;\\n    tmp2 = l2;\\n\\n//prev keeps track of last node in case list lengths are equal\\n\\n    while(tmp1 && tmp2) {\\n        prev = tmp2;\\n        sum = (tmp1->val + tmp2->val + remainder);\\n        tmp1->val = sum%10;\\n        remainder = sum/10;\\n        tmp2->val = tmp1->val;\\n        tmp1 = tmp1->next;\\n        tmp2 = tmp2->next;\\n    }"], ["struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\\n    struct ListNode* prev = NULL;\\n    struct ListNode * tmp1 = l1;\\n    struct ListNode* tmp2 = l2;\\n    struct ListNode* big = NULL;\\n    int sum = 0;\\n    int remainder = 0;\\n\\n    l1 = reverse(l1);\\n    l2 = reverse(l2);\\n    tmp1 = l1;\\n    tmp2 = l2;\\n\\n//prev keeps track of last node in case list lengths are equal\\n\\n    while(tmp1 && tmp2) {\\n        prev = tmp2;\\n        sum = (tmp1->val + tmp2->val + remainder);\\n        tmp1->val = sum%10;\\n        remainder = sum/10;\\n        tmp2->val = tmp1->val;\\n        tmp1 = tmp1->next;\\n        tmp2 = tmp2->next;\\n    }"]]}
{"id": "1244", "ref_c": [["int minTime(int n, int** edges, int edgesSize, int* edgesColSize, bool* hasApple, int hasAppleSize){\\n    if (n == 1 || edgesSize == 0) return 0;\\n    bool flag = false;\\n    int ans = 0, cur, tmp;\\n    int *friends = (int *)malloc(sizeof(int) * n);\\n    friends[0] = 0;\\n    for (int i = 1; i < n; i ++) {\\n        friends[i] = -1;\\n    }"], ["int minTime(int n, int** edges, int edgesSize, int* edgesColSize, bool* hasApple, int hasAppleSize)\\n{\\n    int i;\\n    int *count = malloc(sizeof(int) * n);   \\n    struct Node **root = malloc(sizeof(struct Node *) * n);\\n    struct Node *curNode;\\n\\n    memset(count, 0, sizeof(int) * n);\\n\\n    for(i = 0; i < edgesSize; i++)\\n    {\\n        count[edges[i][0]] += 1;\\n        count[edges[i][1]] += 1;\\n    }"], ["int minTime(int n, int** edges, int edgesSize, int* edgesColSize, bool* hasApple, int hasAppleSize){\\n    if (n == 1 || edgesSize == 0) return 0;\\n    bool flag = false;\\n    int ans = 0, cur, tmp;\\n    int *friends = (int *)malloc(sizeof(int) * n);\\n    friends[0] = 0;\\n    for (int i = 1; i < n; i ++) {\\n        friends[i] = -1;\\n    }"]]}
{"id": "1245", "ref_c": [["char ** simplifiedFractions(int n, int* returnSize){\\n    char ** res = (char **) malloc(MAX_FRACTIONS * sizeof(char *));\\n    int ptr = 0;\\n\\n    for (int nom = 1; nom <= n; nom++) {\\n        for (int den = 1; den <= n; den++) {\\n            // continue if:\\n            //   - fraction is top heavy\\n            //   - numerator is equal to the denominator\\n            //   - greatest common divisor is not 1 (can be simplified)\\n            if (nom >= den || gcd(nom, den) != 1) {\\n                continue;\\n            }"], ["char ** simplifiedFractions(int n, int* returnSize){\\n    char ** res = (char **) malloc(MAX_FRACTIONS * sizeof(char *));\\n    int ptr = 0;\\n\\n    for (int nom = 1; nom <= n; nom++) {\\n        for (int den = 1; den <= n; den++) {\\n            // continue if:\\n            //   - fraction is top heavy\\n            //   - numerator is equal to the denominator\\n            //   - greatest common divisor is not 1 (can be simplified)\\n            if (nom >= den || gcd(nom, den) != 1) {\\n                continue;\\n            }"], ["char ** simplifiedFractions(int n, int* returnSize){\\n    char ** res = (char **) malloc(MAX_FRACTIONS * sizeof(char *));\\n    int ptr = 0;\\n\\n    for (int nom = 1; nom <= n; nom++) {\\n        for (int den = 1; den <= n; den++) {\\n            // continue if:\\n            //   - fraction is top heavy\\n            //   - numerator is equal to the denominator\\n            //   - greatest common divisor is not 1 (can be simplified)\\n            if (nom >= den || gcd(nom, den) != 1) {\\n                continue;\\n            }"]]}
{"id": "1246", "ref_c": [["int goodNodes(struct TreeNode* root){\\n    if(root == NULL)return 0;\\n    return helper(root, root->val, root->val);\\n}"], ["int goodNodes(struct TreeNode* root){\\n    if(root == NULL)return 0;\\n    return helper(root, root->val, root->val);\\n}"], ["int goodNodes(struct TreeNode* root){\\n    int count = 0;\\n    if(root== NULL){\\n        return count;\\n    }"]]}
{"id": "1247", "ref_c": [["char * arrangeWords(char * text){\\n    int len=strlen(text);\\n    text[0]+=32;\\n    int index=0;\\n    int mapsize=0;\\n    int size=0;\\n    struct table *map=(struct table*)malloc(sizeof(struct table)*100000);\\n    // find first word\\n    while(text[index]!=\\' \\'){\\n        index++;\\n    }"], ["char * arrangeWords(char * text){\\n    int len=strlen(text);\\n    text[0]+=32;\\n    int index=0;\\n    int mapsize=0;\\n    int size=0;\\n    struct table *map=(struct table*)malloc(sizeof(struct table)*100000);\\n    // find first word\\n    while(text[index]!=\\' \\'){\\n        index++;\\n    }"], ["char * arrangeWords(char * text){\\n    int len=strlen(text);\\n    text[0]+=32;\\n    int index=0;\\n    int mapsize=0;\\n    int size=0;\\n    struct table *map=(struct table*)malloc(sizeof(struct table)*100000);\\n    // find first word\\n    while(text[index]!=\\' \\'){\\n        index++;\\n    }"]]}
{"id": "1248", "ref_c": [["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"]]}
{"id": "1249", "ref_c": [["int maxVowels(char * s, int k) {\\n    int index;\\n    int currentNumber, maxNumber;\\n    int length = strlen(s);\\n\\n    currentNumber = maxNumber = 0;\\n\\n    for (index = 0; index < length; index++) {\\n        if (IS_VOWEL(s[index])) {\\n            currentNumber++;\\n        }"], ["int maxVowels(char * s, int k) {\\n    int index;\\n    int currentNumber, maxNumber;\\n    int length = strlen(s);\\n\\n    currentNumber = maxNumber = 0;\\n\\n    for (index = 0; index < length; index++) {\\n        if (IS_VOWEL(s[index])) {\\n            currentNumber++;\\n        }"], ["int maxVowels(char * s, int k){\\nprintf(\"..........This is code by Shreyash Dhakate..........\");\\n    int max=0,count=0,flag=0; \\n    for(int i = 0; i < strlen(s) - k + 1; i++){\\n//using if statement to make code faster......\\n        if(s[i]==\\'a\\' ||s[i]==\\'e\\' ||s[i]==\\'i\\' ||s[i]==\\'o\\' ||s[i]==\\'u\\'){\\n            if(i==strlen(s)-k) flag=1;\\n        for(int j=i;j<k+i;j++){\\n            if(s[j]==\\'a\\' ||s[j]==\\'e\\' ||s[j]==\\'i\\' ||s[j]==\\'o\\' ||s[j]==\\'u\\'){\\n                count++;\\n            }"]]}
{"id": "1250", "ref_c": [["int pseudoPalindromicPaths (struct TreeNode* root){\\n    int* hashCnt = (int*)calloc(10, sizeof(int));\\n    int oddCnt = 0, ans = 0;\\n    checkPath(root, hashCnt, &oddCnt, &ans);\\n    return ans;\\n}"], ["int pseudoPalindromicPaths (struct TreeNode* root){\\n    int* hashCnt = (int*)calloc(10, sizeof(int));\\n    int oddCnt = 0, ans = 0;\\n    checkPath(root, hashCnt, &oddCnt, &ans);\\n    return ans;\\n}"], ["int pseudoPalindromicPaths (struct TreeNode* root){\\n   return pseudoPalindromicPathsDFS(root, 0);\\n}"]]}
{"id": "1251", "ref_c": [["bool hasAllCodes(char * s, int k){\\n  uint32_t req = (int) pow(2, k);\\n  uint32_t mask = req - 1;\\n  bool* const found = (bool*) calloc(req, sizeof(bool));\\n  uint32_t value = 0;\\n  for (int i = 0; i + 1 < k && *s; ++i) {\\n    value = (value << 1) + (*s++ - \\'0\\');\\n  }"], ["bool hasAllCodes(char * s, int k){\\n  uint32_t req = (int) pow(2, k);\\n  uint32_t mask = req - 1;\\n  bool* const found = (bool*) calloc(req, sizeof(bool));\\n  uint32_t value = 0;\\n  for (int i = 0; i + 1 < k && *s; ++i) {\\n    value = (value << 1) + (*s++ - \\'0\\');\\n  }"], ["bool hasAllCodes(char * s, int k){\\n  uint32_t req = (int) pow(2, k);\\n  uint32_t mask = req - 1;\\n  bool* const found = (bool*) calloc(req, sizeof(bool));\\n  uint32_t value = 0;\\n  for (int i = 0; i + 1 < k && *s; ++i) {\\n    value = (value << 1) + (*s++ - \\'0\\');\\n  }"]]}
{"id": "1252", "ref_c": [["bool leafSimilar(struct TreeNode* root1, struct TreeNode* root2){\\n    \\n    int arr1[200], arr2[200];\\n\\n    int top1 = -1, top2 = -1;\\n    \\n    search1(root1, arr1, &top1);\\n    \\n    search2(root2, arr2, &top2);\\n    \\n    if (top1 != top2) return false;\\n    \\n    for (int i = 0; i <= top1; i++) {\\n        if (arr1[i] != arr2[i])\\n            return false;\\n    }"], ["bool leafSimilar(struct TreeNode* root1, struct TreeNode* root2) {\\n    int *arr1=(int *)malloc(sizeof(int)*200);\\n    int *arr2=(int *)malloc(sizeof(int)*200);\\n    int l1=0,l2=0;\\n    leaf(root1,arr1,&l1);\\n    leaf(root2,arr2,&l2);\\n    if(l1!=l2)\\n    return false;\\n    else\\n    {\\n        for(int i=0;i<=l1;i++)\\n        {\\n            if(arr1[i]!=arr2[i])\\n            return false;\\n        }"], ["bool leafSimilar(struct TreeNode* root1, struct TreeNode* root2){\\n\\n    SEQUENCE* tree1_seq = createSEQUENCE();\\n    SEQUENCE* tree2_seq = createSEQUENCE();\\n\\n    getLeafSequence(root1, tree1_seq);\\n    getLeafSequence(root2, tree2_seq);\\n\\n    if(tree1_seq->idx != tree2_seq->idx){\\n        deleteSequence(tree1_seq);\\n        deleteSequence(tree2_seq);\\n        return false;\\n    }"]]}
{"id": "1253", "ref_c": [["int maxArea(int h, int w, int* horizontalCuts, int horizontalCutsSize, int* verticalCuts, int verticalCutsSize){\\n\\t//sort both slicing cut in non increasing order\\n    qsort(horizontalCuts, horizontalCutsSize, sizeof(int), cmp);\\n    qsort(verticalCuts, verticalCutsSize, sizeof(int), cmp);\\n    \\n    //check for the horizontal boundary:\\n    int max_height_gap = max(horizontalCuts[0], h - horizontalCuts[horizontalCutsSize - 1]);\\n\\n    //check the gap between two horizontal slices\\n    for(int i = 1; i < horizontalCutsSize; i++){\\n        max_height_gap = max(max_height_gap, horizontalCuts[i] - horizontalCuts[i - 1]);\\n    }"], ["int maxArea(int h, int w, int* horizontalCuts, int horizontalCutsSize, int* verticalCuts, int verticalCutsSize){\\n\\t//sort both slicing cut in non increasing order\\n    qsort(horizontalCuts, horizontalCutsSize, sizeof(int), cmp);\\n    qsort(verticalCuts, verticalCutsSize, sizeof(int), cmp);\\n    \\n    //check for the horizontal boundary:\\n    int max_height_gap = max(horizontalCuts[0], h - horizontalCuts[horizontalCutsSize - 1]);\\n\\n    //check the gap between two horizontal slices\\n    for(int i = 1; i < horizontalCutsSize; i++){\\n        max_height_gap = max(max_height_gap, horizontalCuts[i] - horizontalCuts[i - 1]);\\n    }"], ["int maxArea(int h, int w, int* horizontalCuts, int horizontalCutsSize, int* verticalCuts, int verticalCutsSize){\\n\\n    qsort(horizontalCuts, horizontalCutsSize, sizeof(int), cmpfunc);\\n    qsort(verticalCuts, verticalCutsSize, sizeof(int), cmpfunc);\\n\\n    return (int)((biggestGap(horizontalCuts, horizontalCutsSize, h) * biggestGap(verticalCuts, verticalCutsSize, w)) % 1000000007);\\n}"]]}
{"id": "1254", "ref_c": [["int minReorder(int n, int** connections, int connectionsSize, int* connectionsColSize){\\n    int redirects = 0;\\n    AdjList* adjList = initAdjList(n);\\n    //populate adjacency list\\n    for(int i = 0; i < connectionsSize; i++){\\n        int city1 = connections[i][0];\\n        int city2 = connections[i][1];\\n        //make the children array for city1 larger if needed\\n        if(adjList[city1].nodeCount == adjList[city1].nodeSize)\\n            upSize(adjList, city1);\\n        addEdge(adjList, city1, city2, 1);//set edge, mark direction as 1\\n        //make the children array for city2 larger if needed\\n        if(adjList[city2].nodeCount == adjList[city2].nodeSize)\\n            upSize(adjList, city2);          \\n        addEdge(adjList, city2, city1, 0);//set edge, mark direction as 0\\n    }"], ["int minReorder(int n, int** connections, int connectionsSize, int* connectionsColSize){\\n    int *L = calloc(n, sizeof(int));\\n    int *in_size = calloc(n, sizeof(int));\\n    int *out_size = calloc(n, sizeof(int));\\n    int **indegree = malloc(sizeof(int*) * n);\\n    int **outdegree = malloc(sizeof(int*) * n);\\n    sum = 0;\\n\\n    for(int i = 0; i < n - 1; i++){\\n        in_size[connections[i][1]]++;\\n        out_size[connections[i][0]]++;\\n    }"], ["int minReorder(int n, int** connections, int connectionsSize, int* connectionsColSize){\\n\\n    /*\\n     * Input:\\n     *  n, n cities\\n     *  connections, roads between cities\\n     *  connectionsSize, number of roads\\n     *  connectionsColSize\\n     */\\n\\n    int ans = 0;\\n    bool *visited = (bool *)calloc(1, sizeof(bool) * n);\\n    dst_t **orig_adj = (dst_t **)calloc(1, sizeof(dst_t *) * n);\\n    dst_t **bidir_adj = (dst_t **)calloc(1, sizeof(dst_t *) * n);\\n    dst_t *tmp, *del;\\n    \\n    /* Build origianl adjacent list and a bidirectional adjacent list */\\n    for (int i = 0; i < connectionsSize; i++) {\\n        /* orig_adj[from][to] */\\n        tmp = (dst_t *)malloc(sizeof(dst_t));\\n        tmp->id = connections[i][1];\\n        tmp->next = orig_adj[connections[i][0]];\\n        orig_adj[connections[i][0]] = tmp;\\n        \\n        /* Bidirection */\\n        tmp = (dst_t *)malloc(sizeof(dst_t));\\n        tmp->id = connections[i][1];\\n        tmp->next = bidir_adj[connections[i][0]];\\n        bidir_adj[connections[i][0]] = tmp;\\n        \\n        tmp = (dst_t *)malloc(sizeof(dst_t));\\n        tmp->id = connections[i][0];\\n        tmp->next = bidir_adj[connections[i][1]];\\n        bidir_adj[connections[i][1]] = tmp;\\n    }"]]}
{"id": "1255", "ref_c": [["int* getStrongest(int* arr, int arrSize, int k, int* returnSize) {\\n    *returnSize = k;\\n    if (arrSize == 1) return arr;\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    int m = (arrSize % 2 == 0) ? (arr[arrSize / 2 - 1]) : (arr[arrSize / 2]);\\n    int* ans = (int*) calloc(k, sizeof(int));\\n    int r = arrSize - 1, l = 0, idx = 0;\\n    while (k > 0) {\\n        int rr = abs(arr[r] - m), ll = abs(arr[l] - m);\\n        if (rr > ll) {\\n            ans[idx++] = arr[r];\\n            r--;\\n        }"], ["int* getStrongest(int* arr, int arrSize, int k, int* returnSize){\\n        *returnSize = k;\\n\\n        if (arrSize <= 1){\\n                return arr;\\n        }"], ["int* getStrongest(int* arr, int arrSize, int k, int* returnSize) {\\n    *returnSize = k;\\n    if (arrSize == 1) return arr;\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    int m = (arrSize % 2 == 0) ? (arr[arrSize / 2 - 1]) : (arr[arrSize / 2]);\\n    int* ans = (int*) calloc(k, sizeof(int));\\n    int r = arrSize - 1, l = 0, idx = 0;\\n    while (k > 0) {\\n        int rr = abs(arr[r] - m), ll = abs(arr[l] - m);\\n        if (rr > ll) {\\n            ans[idx++] = arr[r];\\n            r--;\\n        }"]]}
{"id": "1258", "ref_c": [["int minSumOfLengths(int* arr, int arrSize, int target){\\n    // Since we only do \\'idx - len\\' below, we only need to hold the maximum\\n    // length number of previous bests. Since arr[i] > 0, there will be at most\\n\\t// \\'target\\' elements used to sum to target. Add 1 to leave gap between the\\n\\t// start and end of the circular buffer.\\n    const uint32_t bsfSize = 1 + MIN(arrSize, target);\\n    uint32_t bestSoFar[bsfSize];\\n    uint32_t curSum = 0;\\n    uint32_t lastStart = 0;\\n    uint32_t minLen = INVALID;\\n    \\n    bestSoFar[bsfSize - 1] = INVALID;\\n    for (uint32_t i = 0; i < arrSize; i++) {\\n        const uint32_t idx = i % bsfSize;\\n\\n        curSum += arr[i];\\n        while (curSum > target) {\\n            curSum -= arr[lastStart++];\\n        }"], ["int minSumOfLengths(int* arr, int arrSize, int target){\\n    // Since we only do \\'idx - len\\' below, we only need to hold the maximum\\n    // length number of previous bests. Since arr[i] > 0, there will be at most\\n\\t// \\'target\\' elements used to sum to target. Add 1 to leave gap between the\\n\\t// start and end of the circular buffer.\\n    const uint32_t bsfSize = 1 + MIN(arrSize, target);\\n    uint32_t bestSoFar[bsfSize];\\n    uint32_t curSum = 0;\\n    uint32_t lastStart = 0;\\n    uint32_t minLen = INVALID;\\n    \\n    bestSoFar[bsfSize - 1] = INVALID;\\n    for (uint32_t i = 0; i < arrSize; i++) {\\n        const uint32_t idx = i % bsfSize;\\n\\n        curSum += arr[i];\\n        while (curSum > target) {\\n            curSum -= arr[lastStart++];\\n        }"], ["int minSumOfLengths(int* arr, int arrSize, int target){\\n    // Since we only do \\'idx - len\\' below, we only need to hold the maximum\\n    // length number of previous bests. Since arr[i] > 0, there will be at most\\n\\t// \\'target\\' elements used to sum to target. Add 1 to leave gap between the\\n\\t// start and end of the circular buffer.\\n    const uint32_t bsfSize = 1 + MIN(arrSize, target);\\n    uint32_t bestSoFar[bsfSize];\\n    uint32_t curSum = 0;\\n    uint32_t lastStart = 0;\\n    uint32_t minLen = INVALID;\\n    \\n    bestSoFar[bsfSize - 1] = INVALID;\\n    for (uint32_t i = 0; i < arrSize; i++) {\\n        const uint32_t idx = i % bsfSize;\\n\\n        curSum += arr[i];\\n        while (curSum > target) {\\n            curSum -= arr[lastStart++];\\n        }"]]}
{"id": "1259", "ref_c": [["int findLeastNumOfUniqueInts(int* arr, int arrSize, int k){\\n    int i,arr_temp[100000],count = 0,answer;\\n    memset(arr_temp,0,sizeof(arr_temp));\\n    qsort(arr,arrSize,sizeof(int),compare);\\n\\n    arr_temp[count]++;\\n    for(i = 1; i < arrSize; i++)\\n    {\\n        if(arr[i] != 0)\\n        {\\n            if(arr[i-1] == arr[i])\\n            {\\n                arr_temp[count]++;\\n            }"], ["int findLeastNumOfUniqueInts(int* arr, int arrSize, int k){\\n    int i,arr_temp[100000],count = 0,answer;\\n    memset(arr_temp,0,sizeof(arr_temp));\\n    qsort(arr,arrSize,sizeof(int),compare);\\n\\n    arr_temp[count]++;\\n    for(i = 1; i < arrSize; i++)\\n    {\\n        if(arr[i] != 0)\\n        {\\n            if(arr[i-1] == arr[i])\\n            {\\n                arr_temp[count]++;\\n            }"], ["int findLeastNumOfUniqueInts(int* arr, int arrSize, int k){\\n    int i,arr_temp[100000],count = 0,answer;\\n    memset(arr_temp,0,sizeof(arr_temp));\\n    qsort(arr,arrSize,sizeof(int),compare);\\n\\n    arr_temp[count]++;\\n    for(i = 1; i < arrSize; i++)\\n    {\\n        if(arr[i] != 0)\\n        {\\n            if(arr[i-1] == arr[i])\\n            {\\n                arr_temp[count]++;\\n            }"]]}
{"id": "1260", "ref_c": ["\nint possible(int *arr, int day, int n, int m, int k) {\n    int count = 0;\n    int ans = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] <= day) {\n            count++;\n        } else {\n            ans += (count / k);\n            count = 0;\n        }\n    }\n\n    ans += (count / k);\n\n    if (ans >= m)\n        return 1;\n    else\n        return 0;\n}\n\nint minDays(int *bloomDay, int bloomDaySize, int m, int k) {\n    int max = bloomDay[0];\n    int min = bloomDay[0];\n    int n = bloomDaySize;\n    long long acpt = (long long)k * m;\n\n    for (int i = 1; i < n; i++) {\n        if (bloomDay[i] > max) {\n            max = bloomDay[i];\n        }\n        if (bloomDay[i] < min) {\n            min = bloomDay[i];\n        }\n    }\n\n    int low = min, high = max, mid, ans = 0;\n\n    while (low <= high) {\n        mid = low + (high - low) / 2;\n\n        if (possible(bloomDay, mid, n, m, k) == 1) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    if (acpt > n)\n        return -1;\n    else\n        return low;\n}\n", "\nint possible(int *arr, int day, int n, int m, int k) {\n    int count = 0;\n    int ans = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] <= day) {\n            count++;\n        } else {\n            ans += (count / k);\n            count = 0;\n        }\n    }\n\n    ans += (count / k);\n\n    if (ans >= m)\n        return 1;\n    else\n        return 0;\n}\n\nint minDays(int *bloomDay, int bloomDaySize, int m, int k) {\n    int max = bloomDay[0];\n    int min = bloomDay[0];\n    int n = bloomDaySize;\n    long long acpt = (long long)k * m;\n\n    for (int i = 1; i < n; i++) {\n        if (bloomDay[i] > max) {\n            max = bloomDay[i];\n        }\n        if (bloomDay[i] < min) {\n            min = bloomDay[i];\n        }\n    }\n\n    int low = min, high = max, mid, ans = 0;\n\n    while (low <= high) {\n        mid = low + (high - low) / 2;\n\n        if (possible(bloomDay, mid, n, m, k) == 1) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    if (acpt > n)\n        return -1;\n    else\n        return low;\n}\n", "\nint possible(int *arr, int day, int n, int m, int k) {\n    int count = 0;\n    int ans = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] <= day) {\n            count++;\n        } else {\n            ans += (count / k);\n            count = 0;\n        }\n    }\n\n    ans += (count / k);\n\n    if (ans >= m)\n        return 1;\n    else\n        return 0;\n}\n\nint minDays(int *bloomDay, int bloomDaySize, int m, int k) {\n    int max = bloomDay[0];\n    int min = bloomDay[0];\n    int n = bloomDaySize;\n    long long acpt = (long long)k * m;\n\n    for (int i = 1; i < n; i++) {\n        if (bloomDay[i] > max) {\n            max = bloomDay[i];\n        }\n        if (bloomDay[i] < min) {\n            min = bloomDay[i];\n        }\n    }\n\n    int low = min, high = max, mid, ans = 0;\n\n    while (low <= high) {\n        mid = low + (high - low) / 2;\n\n        if (possible(bloomDay, mid, n, m, k) == 1) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    if (acpt > n)\n        return -1;\n    else\n        return low;\n}\n"]}
{"id": "1261", "ref_c": [["int surfaceArea(int** grid, int gridSize, int* gridColSize)\\n{\\n    int totalArea = 0, currentArea;\\n\\n    // Neighbouring areas\\n    int areaLeft, areaRight, areaUp, areaDown;\\n\\n    // Neighbouring cubes\\n    int cubeLeft, cubeRight, cubeUp, cubeDown;\\n\\n\\n    for(int i = 0; i < gridSize; i++)\\n    {\\n        for(int j = 0; j < gridColSize[i]; j++)\\n        {\\n            if(grid[i][j] == 0) continue;\\n            \\n            areaLeft = (j - 1 < 0) ? 0 : CUBE_AREA(grid[i][j - 1]);\\n            cubeLeft = (j - 1 < 0) ? 0 : grid[i][j - 1];\\n            areaRight = (j + 1 < gridColSize[i]) ? CUBE_AREA(grid[i][j + 1]) : 0;\\n            cubeRight = (j + 1 < gridColSize[i]) ? grid[i][j + 1] : 0;\\n            areaUp = (i - 1 < 0) ? 0 : CUBE_AREA(grid[i - 1][j]);\\n            cubeUp = (i - 1 < 0) ? 0 : grid[i - 1][j];\\n            areaDown = (i + 1 < gridSize) ? CUBE_AREA(grid[i + 1][j]) : 0;\\n            cubeDown = (i + 1 < gridSize) ? grid[i + 1][j] : 0;\\n\\n            currentArea = CUBE_AREA(grid[i][j]);\\n            totalArea += CUBE_AREA(grid[i][j]);\\n\\n            totalArea -= (currentArea > areaLeft ? cubeLeft : grid[i][j])\\n                             + (currentArea > areaRight ? cubeRight : grid[i][j]) \\n                             + (currentArea > areaUp ? cubeUp : grid[i][j]) \\n                             + (currentArea > areaDown ? cubeDown : grid[i][j]);\\n\\n        }"], ["int surfaceArea(int** grid, int gridSize, int* gridColSize){\\n    int area = 0;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] !=0)\\n                area += grid[i][j]*4 + 2; //Full surface\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize-1; j++)\\n        {\\n            if(grid[i][j] != 0 && grid[i][j+1] != 0)\\n                area -= grid[i][j] < grid[i][j+1] ? 2*grid[i][j] : 2*grid[i][j+1]; //reduce common surface in row\\n        }"], ["int surfaceArea(int** grid, int gridSize, int* gridColSize){\\n    int area = 0;\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize; j++)\\n            if(grid[i][j] !=0)\\n                area += grid[i][j]*4 + 2; //Full surface\\n    for(int i=0; i<gridSize; i++)\\n        for(int j=0; j<*gridColSize-1; j++)\\n        {\\n            if(grid[i][j] != 0 && grid[i][j+1] != 0)\\n                area -= grid[i][j] < grid[i][j+1] ? 2*grid[i][j] : 2*grid[i][j+1]; //reduce common surface in row\\n        }"]]}
{"id": "1262", "ref_c": [["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"]]}
{"id": "1263", "ref_c": [["int kthFactor(int n, int k){\\n    int i=1;\\n    int count =0;\\n    int x =0;\\n    while(n>=i){\\n        if(n%i==0) {\\n            count++;\\n            if(count==k){\\n                    return i;\\n                }"], ["int kthFactor(int n, int k){\\n    int i=1;\\n    int count =0;\\n    int x =0;\\n    while(n>=i){\\n        if(n%i==0) {\\n            count++;\\n            if(count==k){\\n                    return i;\\n                }"], ["int kthFactor(int n, int k) {\\n    int factors=0;\\n    int count =0;\\n\\n    for(int i=1;i<=n;i++)\\n    {\\n        if(n%i==0)\\n        {\\n            count+=1;\\n        }"]]}
{"id": "1264", "ref_c": [["int longestSubarray(int* nums, int numsSize) {\\n    int zeroCount = 0;       \\n    int longestWindow = 0;  \\n    int start = 0;          \\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == 0) {\\n            zeroCount++;     \\n        }"], ["int longestSubarray(int* nums, int numsSize) {\\n    int zeroCount = 0;       \\n    int longestWindow = 0;  \\n    int start = 0;          \\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == 0) {\\n            zeroCount++;     \\n        }"], ["int longestSubarray(int* nums, int numsSize) {\\n    int zeroCount = 0;       \\n    int longestWindow = 0;  \\n    int start = 0;          \\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == 0) {\\n            zeroCount++;     \\n        }"]]}
{"id": "1265", "ref_c": [["bool canArrange(int* arr, int arrSize, int k){\\n   int* count=(int*)calloc(sizeof(int),k);\\n  \\nfor(int i=0; i<arrSize; i++) {\\n     int remainder=((arr[i]%k)+k)%k;\\n     count[remainder]++;\\n}"], ["bool canArrange(int* arr, int arrSize, int k){\\n   int* count=(int*)calloc(sizeof(int),k);\\n  \\nfor(int i=0; i<arrSize; i++) {\\n     int remainder=((arr[i]%k)+k)%k;\\n     count[remainder]++;\\n}"], ["bool canArrange(int* arr, int arrSize, int k){\\n    \\n    int i;\\n    bool check = true;\\n    \\n    for(i=0; i<arrSize; i++){\\n        \\n        check = does_it_pair(arr, i, arrSize, k);\\n        if(!check) break;\\n        \\n    }"]]}
{"id": "1266", "ref_c": [["int numSubseq(int* nums, int numsSize, int target) {\\n    // Sort the array in ascending order\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    int count = 0;\\n    int left = 0;\\n    int right = numsSize - 1;\\n    int modulo = 1000000007;\\n\\n    // Use two pointers approach to find subsequences\\n    while (left <= right) {\\n        // Check if the sum of current left and right elements is less than or equal to the target\\n        if (nums[left] + nums[right] <= target) {\\n            // The count of subsequences is 2^(right-left)\\n            count = (count + powMod(2, right - left, modulo)) % modulo;\\n            left++; // Move the left pointer to the next element\\n        }"], ["int numSubseq(int* nums, int numsSize, int target)\\n{\\n   qsort(nums,numsSize,sizeof(int),cmp);\\n   int l = 0, h = numsSize - 1 ;\\n   long long int ans = 0;\\n   while(l <= h)\\n   {\\n    if(nums[l] + nums[h] <= target)\\n    {\\n      ans += POW(2,(h-l));\\n      l++;\\n    }"], ["int numSubseq(int* nums, int numsSize, int target)\\n{\\n   qsort(nums,numsSize,sizeof(int),cmp);\\n   int l = 0, h = numsSize - 1 ;\\n   long long int ans = 0;\\n   while(l <= h)\\n   {\\n    if(nums[l] + nums[h] <= target)\\n    {\\n      ans += POW(2,(h-l));\\n      l++;\\n    }"]]}
{"id": "1267", "ref_c": [["int getLastMoment(int n, int* left, int leftSize, int* right, int rightSize) \\n{\\n    int l=0, r=0;\\n    for(register i=0; i<rightSize; i++) if (n-l>right[i]) l=n-right[i];\\n    for(register i=0; i<leftSize; i++) if (r<left[i]) r=left[i];\\n    return (r>l)?r:l;\\n}"], ["int getLastMoment(int n, int* left, int leftSize, int* right, int rightSize) \\n{\\n    int l=0, r=0;\\n    for(register i=0; i<rightSize; i++) if (n-l>right[i]) l=n-right[i];\\n    for(register i=0; i<leftSize; i++) if (r<left[i]) r=left[i];\\n    return (r>l)?r:l;\\n}"], ["int getLastMoment(int n, int* left, int leftSize, int* right, int rightSize) {\\n    int ans = 0;  // Initialize a variable \\'ans\\' to store the maximum time when an ant falls off.\\n\\n    // Loop through the \\'left\\' array, which contains positions of ants moving to the left.\\n    for (int i = 0; i < leftSize; i++) {\\n        int num = left[i];\\n        ans = (ans > num) ? ans : num;  // Update \\'ans\\' with the maximum position from the \\'left\\' array.\\n    }", "int getLastMoment(int n, int* left, int leftSize, int* right, int rightSize) {\\n    // Find the farthest position among ants moving to the left.\\n    int maxLeft = (leftSize == 0) ? 0 : left[0];  // Initialize maxLeft to 0 if \\'left\\' is empty.\\n\\n    for (int i = 1; i < leftSize; i++) {\\n        if (left[i] > maxLeft) {\\n            maxLeft = left[i];  // Update maxLeft if a larger position is found.\\n        }"]]}
{"id": "1268", "ref_c": [["struct ListNode* oddEvenList(struct ListNode* head){\\n    if(head==NULL)\\n    {\\n        return head;\\n    }"], ["struct ListNode* oddEvenList(struct ListNode* head){\\n    if(head==NULL){\\n        return head;\\n    }"], ["struct ListNode* oddEvenList(struct ListNode* head){\\n    if(head==NULL)\\n    {\\n        return NULL;\\n    }"]]}
{"id": "1269", "ref_c": [["int rangeSum(int* nums, int numsSize, int n, int left, int right){\\n    int i, j;\\n    int new_length = n * (n + 1) / 2;\\n    int arr[new_length];\\n    int temp = 0;\\n    long long sum = 0;\\n    \\n    for(i = 0 ; i < numsSize; i++){\\n        sum = 0;\\n        for(j = 0 ; j < numsSize - i; j++){\\n            sum += nums[i + j];\\n            arr[temp] = sum;\\n            // printf(\"sum : %d arr[%d]: %d\\\\n\",sum, temp , arr[temp]);\\n            temp++;\\n        }"], ["int rangeSum(int* nums, int numsSize, int n, int left, int right){\\n  int newSize = n*(n+1)/2;\\n  int arr[newSize];\\nint sum;\\n  int index = 0;\\n  for (int i = 0; i < numsSize; i++) {\\n      sum = 0;\\n      for (int j = i; j < numsSize; j++) {\\n        sum += nums[j];\\n        arr[index++] = sum;\\n      }"], ["int rangeSum(int* nums, int numsSize, int n, int left, int right){\\n    int i, j;\\n    int new_length = n * (n + 1) / 2;\\n    int arr[new_length];\\n    int temp = 0;\\n    long long sum = 0;\\n    \\n    for(i = 0 ; i < numsSize; i++){\\n        sum = 0;\\n        for(j = 0 ; j < numsSize - i; j++){\\n            sum += nums[i + j];\\n            arr[temp] = sum;\\n            // printf(\"sum : %d arr[%d]: %d\\\\n\",sum, temp , arr[temp]);\\n            temp++;\\n        }"]]}
{"id": "1270", "ref_c": [["int* singleNumber(int* nums, int numsSize, int* returnSize){\\n    int res=0,x;\\n    int* arr=(int*)malloc(2*sizeof(int));\\n    arr[0]=0;\\n    arr[1]=0;\\n    for(int i=0;i<numsSize;i++)\\n        res=res^nums[i];\\n    if(res == (-2147483648))\\n        x=0;      \\n    else\\n        x = -res;\\n    int mask=res & x;\\n    for(int i=0;i<numsSize;i++){\\n        if((mask&nums[i])!=0)\\n            arr[0]=arr[0]^nums[i];\\n    }"], ["int* singleNumber(int* nums, int numsSize, int* returnSize) {\\n\\n    int* results = (int *)calloc(2, sizeof(int));\\n    int xorNums = 0;\\n    for(int i=0; i<numsSize; i++){\\n        xorNums ^= nums[i];\\n    }"], ["int* singleNumber(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = 2;\\n    int* result = (int*) malloc(2 * sizeof(int));\\n    \\n    unsigned int xorAll = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        xorAll ^= nums[i];\\n    }"]]}
{"id": "1271", "ref_c": [["int numSub(char * s){\\n    size_t res=0;\\n    size_t k=0;\\n    for(size_t i=0;s[i];i++){\\n        if(s[i]==\\'1\\'){\\n            k++;\\n            res+=k;\\n        }"], ["int numSub(char * s){\\n    size_t res=0;\\n    size_t k=0;\\n    for(size_t i=0;s[i];i++){\\n        if(s[i]==\\'1\\'){\\n            k++;\\n            res+=k;\\n        }"], ["int numSub(char * s){\\n    size_t res=0;\\n    size_t k=0;\\n    for(size_t i=0;s[i];i++){\\n        if(s[i]==\\'1\\'){\\n            k++;\\n            res+=k;\\n        }"]]}
{"id": "1272", "ref_c": [["int rangeBitwiseAnd(int left, int right) {\\n\\n    int ans=0, pos=0, tmp_low=0;\\n    int pos_l = countSetBits(left);\\n    int pos_r = countSetBits(right);\\n\\n    if(left==right)\\n        return left;\\n\\n    if(!(left&right) || pos_l!=pos_r)\\n        return ans;\\n    else\\n        pos=pos_l;\\n\\n    ans=1<<pos;\\n    \\n    unsigned low=1U<<pos, high=(1U<<pos+1)-1;\\n\\n    while(--pos){   //O(1) -> Max 32 iterations\\n        tmp_low=SETBIT(low,pos);\\n        if(tmp_low<=left && right<=high){\\n            ans=SETBIT(ans,pos);\\n            low=tmp_low;\\n        }"], ["int rangeBitwiseAnd(int left, int right) {\\n    int shifts = 0, m=left, n=right;\\n    while( m < n ){\\n        m >>= 1;\\n        n >>= 1;\\n        shifts++;\\n    }"], ["int rangeBitwiseAnd(int left, int right){\\n\\tassert(left >= 0 && right >= 0);\\n\\n\\tint ret = 0;\\n\\n\\tfor (int mask = 1; mask > 0; *(unsigned int *)&mask <<= 1){\\n\\t\\tif (\\n\\t\\t\\t( (left & mask) != 0 && (right & mask) != 0 ) &&\\n\\t\\t\\tleft == right\\n\\t\\t){\\n\\t\\t\\tret |= mask;\\n\\t\\t}"]]}
{"id": "1273", "ref_c": [["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize){\\n    if (returnSize == NULL || n == 0 || edges == NULL)\\n        return NULL;\\n \\n    struct node **depths = calloc(n, sizeof(struct node *));\\n    assert(depths);\\n\\n    assert(edgesSize == (n - 1));\\n\\n    struct node *nodes = calloc(n, sizeof(struct node));\\n    assert(nodes != NULL);\\n  \\n    // Allocate results array\\n    int *result = calloc(n, sizeof(int));\\n    assert(result != NULL);\\n \\n    // Apply each node\\'s label and perform some initializations\\n    for (int i = 0; i < n; i++)\\n    {\\n        nodes[i].label = labels[i];\\n        nodes[i].xparent = (struct node *)(i == 0 ? 0x1 : NULL);\\n        /* The root node\\'s depth must always be 0, for the remaining nodes, the\\n         * depth will be determined when the edge array is parsed.\\n         */\\n        nodes[i].depth = (i == 0 ? 0 : DEPTH_ANY);\\n        nodes[i].sub_tree_alpha_cnt[nodes[i].label - \\'a\\'] = 1;\\n    }"], ["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n;\\n    int *returnArray = malloc(sizeof(int) * n);\\n    int *count = malloc(sizeof(int) * n);\\n    struct Node **root = malloc(sizeof(struct Node *) * n);\\n    struct Node *curNode;\\n\\n    memset(returnArray, 0, sizeof(int) * n);\\n    memset(count, 0, sizeof(int) * n);\\n\\n    for(i = 0; i < edgesSize; i++)\\n    {\\n        count[edges[i][0]] += 1;\\n        count[edges[i][1]] += 1;\\n    }"], ["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize)\\n{\\n    int* count = calloc(26, sizeof(int));\\n    int* ans = malloc(n * sizeof(int));\\n    *returnSize = n;\\n    int** adj = malloc(n * sizeof(int*));\\n    int* adjSize = calloc(n, sizeof(int));\\n    //dynamically allocate and initialize adjacency list\\n    for(int i = 0; i < n - 1; i++)\\n    {\\n        int a = edges[i][0], b = edges[i][1];\\n        if(adjSize[a] == 0)\\n        {\\n            adjSize[a]++;\\n            adj[a] = malloc(sizeof(int));\\n        }"]]}
{"id": "1274", "ref_c": [["int numOfSubarrays(int* arr, int arrSize){\\n    int result = 0;\\n    int preSum = 0;\\n    int countOddSum = 0;\\n    int countEvenSum = 1;\\n    for (int i = 0; i < arrSize; i++){\\n        preSum += arr[i];\\n        if (preSum % 2 == 0){\\n            result = (result + countOddSum) % MOD;\\n            countEvenSum++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize){\\n    int result = 0;\\n    int preSum = 0;\\n    int countOddSum = 0;\\n    int countEvenSum = 1;\\n    for (int i = 0; i < arrSize; i++){\\n        preSum += arr[i];\\n        if (preSum % 2 == 0){\\n            result = (result + countOddSum) % MOD;\\n            countEvenSum++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize){\\n    int result = 0;\\n    int preSum = 0;\\n    int countOddSum = 0;\\n    int countEvenSum = 1;\\n    for (int i = 0; i < arrSize; i++){\\n        preSum += arr[i];\\n        if (preSum % 2 == 0){\\n            result = (result + countOddSum) % MOD;\\n            countEvenSum++;\\n        }"]]}
{"id": "1275", "ref_c": [["int numSplits(char * s){\\n    int rMap[26] = {0}"], ["int numSplits(char * s){\\n    int Return=0;\\n    int lc=0,rc=0; //num of dis. char in left/right side\\n    int r[26]={0}"], ["int numSplits(char * s){\\n    int rMap[26] = {0}"]]}
{"id": "1276", "ref_c": [["int minFlips(char * target){\\n    char* s = target;\\n    int changes = 0;\\n\\n    //dont care about left zeroz\\n    while (*s != \\'\\\\0\\' && *s == \\'0\\'){\\n        s++;\\n    }"], ["int minFlips(char * target){\\n    char* s = target;\\n    int changes = 0;\\n\\n    //dont care about left zeroz\\n    while (*s != \\'\\\\0\\' && *s == \\'0\\'){\\n        s++;\\n    }"], ["int minFlips(char * target){\\n    char* s = target;\\n    int changes = 0;\\n\\n    //dont care about left zeroz\\n    while (*s != \\'\\\\0\\' && *s == \\'0\\'){\\n        s++;\\n    }"]]}
{"id": "1277", "ref_c": [["int countPairs(struct TreeNode* root, int distance)\\n{\\n    total_count = 0;\\n    int arr_index = 0;\\n    int * ret = count(root, distance, &arr_index);\\n    return total_count;\\n}"], ["int countPairs(struct TreeNode* root, int distance){\\n    if(!root) return 0;\\n    int ansCnt = 0, idx = 0;\\n    DFS(root, distance, &ansCnt, &idx);\\n    return ansCnt;\\n}"], ["int countPairs(struct TreeNode* root, int distance)\\n{\\n    total_count = 0;\\n    int arr_index = 0;\\n    int * ret = count(root, distance, &arr_index);\\n    return total_count;\\n}"]]}
{"id": "1278", "ref_c": [["int getWinner(int* arr, int arrSize, int k) {\\n    // Find the maximum element in the array.\\n    int maxElement = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        if (arr[i] > maxElement) {\\n            maxElement = arr[i];\\n        }"], ["int getWinner(int* arr, int arrSize, int k) {\\n    int currentWinner = arr[0];\\n    int count = 0;\\n    for (int i = 1; i < arrSize; i++) {\\n        if (arr[i] > currentWinner) {\\n            currentWinner = arr[i];\\n            count = 1;\\n        }", "int getWinner(int* arr, int arrSize, int k) {\\n    int* queue = (int*)malloc(arrSize * sizeof(int));\\n    int one = arr[0];\\n    int x = k;\\n    int maxi = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        queue[i - 1] = arr[i];\\n        if (arr[i] > maxi) {\\n            maxi = arr[i];\\n        }", "int getWinner(int* arr, int arrSize, int k) {\\n    int* wins = (int*)malloc(arrSize * sizeof(int));\\n    for (int i = 0; i < arrSize; i++) {\\n        wins[i] = 0;\\n    }"], ["int getWinner(int* arr, int arrSize, int k) {\\n    // Find the maximum element in the array.\\n    int maxElement = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        if (arr[i] > maxElement) {\\n            maxElement = arr[i];\\n        }"]]}
{"id": "1279", "ref_c": ["\ntypedef struct\n{\n    int top;\n    int size;\n    char * stack_arr;\n}stack;\n\nbool isStackEmpty(stack * Stack)\n{\n    if(Stack->top == -1)\n        return true;\n    else\n        return false;\n}\n\nbool isStackFull(stack * Stack)\n{\n    if(Stack->top == Stack->size - 1)\n        return true;\n    else\n        return false;\n}\n\nvoid push(stack * Stack, char val)\n{\n    if(isStackFull(Stack))\n        return;\n\n    Stack->stack_arr[++Stack->top] = val;\n}\n\nchar pop(stack * Stack)\n{\n    char ret_val = '\u0000';\n    if(isStackEmpty(Stack))\n        return ret_val;\n\n    ret_val = Stack->stack_arr[Stack->top--];\n    return ret_val;\n}\n\nint minOperations(char** logs, int logsSize) \n{\n    stack Stack;\n    Stack.top = -1;\n    Stack.size = STACK_SIZE;\n    Stack.stack_arr = (char *)malloc(sizeof(char) * Stack.size);\n\n    int i=0;\n    for(i=0; i<logsSize; i++)\n    {\n        if(strcmp(logs[i],\"./\") == 0)\n        {\n            //Do Nothing\n        }\n        else if(strcmp(logs[i],\"../\") == 0)\n        {\n            pop(&Stack);\n        }\n        else\n        {\n            push(&Stack, 'c');\n        }\n    }\n\n    int count = 0;\n    while(isStackEmpty(&Stack) == false)\n    {\n        pop(&Stack);\n        count++;\n    }\n    return count;\n}\n", "\ntypedef struct\n{\n    int top;\n    int size;\n    char * stack_arr;\n}stack;\n\nbool isStackEmpty(stack * Stack)\n{\n    if(Stack->top == -1)\n        return true;\n    else\n        return false;\n}\n\nbool isStackFull(stack * Stack)\n{\n    if(Stack->top == Stack->size - 1)\n        return true;\n    else\n        return false;\n}\n\nvoid push(stack * Stack, char val)\n{\n    if(isStackFull(Stack))\n        return;\n\n    Stack->stack_arr[++Stack->top] = val;\n}\n\nchar pop(stack * Stack)\n{\n    char ret_val = '\u0000';\n    if(isStackEmpty(Stack))\n        return ret_val;\n\n    ret_val = Stack->stack_arr[Stack->top--];\n    return ret_val;\n}\n\nint minOperations(char** logs, int logsSize) \n{\n    stack Stack;\n    Stack.top = -1;\n    Stack.size = STACK_SIZE;\n    Stack.stack_arr = (char *)malloc(sizeof(char) * Stack.size);\n\n    int i=0;\n    for(i=0; i<logsSize; i++)\n    {\n        if(strcmp(logs[i],\"./\") == 0)\n        {\n            //Do Nothing\n        }\n        else if(strcmp(logs[i],\"../\") == 0)\n        {\n            pop(&Stack);\n        }\n        else\n        {\n            push(&Stack, 'c');\n        }\n    }\n\n    int count = 0;\n    while(isStackEmpty(&Stack) == false)\n    {\n        pop(&Stack);\n        count++;\n    }\n    return count;\n}\n", "\ntypedef struct\n{\n    int top;\n    int size;\n    char * stack_arr;\n}stack;\n\nbool isStackEmpty(stack * Stack)\n{\n    if(Stack->top == -1)\n        return true;\n    else\n        return false;\n}\n\nbool isStackFull(stack * Stack)\n{\n    if(Stack->top == Stack->size - 1)\n        return true;\n    else\n        return false;\n}\n\nvoid push(stack * Stack, char val)\n{\n    if(isStackFull(Stack))\n        return;\n\n    Stack->stack_arr[++Stack->top] = val;\n}\n\nchar pop(stack * Stack)\n{\n    char ret_val = '\u0000';\n    if(isStackEmpty(Stack))\n        return ret_val;\n\n    ret_val = Stack->stack_arr[Stack->top--];\n    return ret_val;\n}\n\nint minOperations(char** logs, int logsSize) \n{\n    stack Stack;\n    Stack.top = -1;\n    Stack.size = STACK_SIZE;\n    Stack.stack_arr = (char *)malloc(sizeof(char) * Stack.size);\n\n    int i=0;\n    for(i=0; i<logsSize; i++)\n    {\n        if(strcmp(logs[i],\"./\") == 0)\n        {\n            //Do Nothing\n        }\n        else if(strcmp(logs[i],\"../\") == 0)\n        {\n            pop(&Stack);\n        }\n        else\n        {\n            push(&Stack, 'c');\n        }\n    }\n\n    int count = 0;\n    while(isStackEmpty(&Stack) == false)\n    {\n        pop(&Stack);\n        count++;\n    }\n    return count;\n}\n"]}
{"id": "1280", "ref_c": [["int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\\n        vector<vector<vector<int>>>  dp(60,vector<vector<int>> (60,vector<int>(60,-1)));\\n        return solve(startRow,startColumn,m,n,maxMove,dp);\\n    }"], ["int findPaths(int m, int n, int maxMove, int startRow, int startColumn){\\n    mat = malloc(sizeof(int **)*m);\\n    for(int i = 0; i < m; i++){\\n        mat[i] = malloc(sizeof(int*)*n);\\n        for(int j = 0; j < n; j++){\\n            mat[i][j] = malloc(sizeof(int)*(maxMove + 1));\\n            for(int k = 0; k < maxMove + 1; k++){\\n                mat[i][j][k] = -1;\\n            }"], ["int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\\n        vector<vector<vector<int>>>  dp(60,vector<vector<int>> (60,vector<int>(60,-1)));\\n        return solve(startRow,startColumn,m,n,maxMove,dp);\\n    }"]]}
{"id": "1281", "ref_c": [["double largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n  double maxArea = 0;\\n  double area = 0;\\n  \\n  for (int i = 0; i < pointsSize; i++) {\\n    for (int j = i + 1; j < pointsSize; j++) {\\n      for (int k = j + 1; k < pointsSize; k++) {\\n        area = getArea(points[i], points[j], points[k]);\\n        \\n        if (area > maxArea) {\\n          maxArea = area;\\n        }"], ["double largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n    double result = 0;\\n    for (int i = 0; i < pointsSize; i++)\\n        for (int j = i + 1; j < pointsSize; j++)\\n            for (int k = j + 1; k < pointsSize; k++) {\\n                int x1 = points[i][0], y1 = points[i][1];\\n                int x2 = points[j][0], y2 = points[j][1];\\n                int x3 = points[k][0], y3 = points[k][1];\\n                double area = fabs(0.50000 * (x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3));\\n                result = result > area ? result : area;\\n            }"], ["double largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n\\n\\nint i,j,k;\\nlong double s1=0,s2=0,s3=0,max=0,max1=0,max2=0,max3=0,ans=0,d=0;\\n  \\nfor(i=0;i<pointsSize-2;i++)\\n{\\nfor(j=i+1;j<pointsSize-1;j++)\\n{\\nfor(k=j+1;k<pointsSize;k++)\\n{\\n    \\ns1=(points[j][0]-points[i][0])*(points[j][0]-points[i][0]);\\ns1+=(points[j][1]-points[i][1])*(points[j][1]-points[i][1]);\\ns1=sqrt(s1);\\n\\ns2=(points[k][0]-points[i][0])*(points[k][0]-points[i][0]);\\ns2+=(points[k][1]-points[i][1])*(points[k][1]-points[i][1]);\\ns2=sqrt(s2);\\n\\ns3=(points[j][0]-points[k][0])*(points[j][0]-points[k][0]);\\ns3+=(points[j][1]-points[k][1])*(points[j][1]-points[k][1]);\\ns3=sqrt(s3);\\n    \\nif(((s1+s2)>s3)&&((s2+s3)>s1)&&((s1+s3)>s2))\\n{\\n    \\nd=(s1+s2+s3)/2;\\ns1=d-s1;\\ns2=d-s2;\\ns3=d-s3;\\nans=d*s1*s2*s3;\\nans=sqrt(ans);\\n\\nif(ans>max)\\nmax=ans;\\n}"]]}
{"id": "1282", "ref_c": [["char findKthBit(int n, int k) {\\n        int[] arr = { 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072,\\n                262144, 524288 }"], ["char findKthBit(int n, int k){\\n    int count=0;\\n    while(k != 1){\\n        if((k & k-1 ) == 0){\\n            count++;\\n            break;\\n        }"], ["char findKthBit(int n, int k) {\\n        int[] arr = { 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072,\\n                262144, 524288 }"]]}
{"id": "1283", "ref_c": [["int* sortArrayByParity(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(numsSize * sizeof(int));\\n    int evenIndex = 0;\\n    int oddIndex = numsSize - 1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] % 2 == 0) {\\n            result[evenIndex] = nums[i];\\n            evenIndex++;\\n        }"], ["int* sortArrayByParity(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(numsSize * sizeof(int));\\n    int evenIndex = 0;\\n    int oddIndex = numsSize - 1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] % 2 == 0) {\\n            result[evenIndex] = nums[i];\\n            evenIndex++;\\n        }"], ["int* sortArrayByParity(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(numsSize * sizeof(int));\\n    int evenIndex = 0;\\n    int oddIndex = numsSize - 1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] % 2 == 0) {\\n            result[evenIndex] = nums[i];\\n            evenIndex++;\\n        }"]]}
{"id": "1284", "ref_c": [["int minOperations(int n){\\nint  ans=0;\\nfor(int i=0;i<n/2;i++){\\n    ans+=n-(i*2+1);\\n}"], ["int minOperations(int n) {\\n    return n*(n/2)-(n/2)*(n/2) ;\\n}"], ["int minOperations(int n) \\n    {\\n      if(n % 2 != 0)\\n      {\\n        n = n / 2;\\n        return n * (n + 1);\\n      }"]]}
{"id": "1285", "ref_c": [["int maxDistance(int* position, int positionSize, int m){\\n    qsort(position, positionSize, sizeof(int), cmp);\\n    int min = 1, max = position[positionSize - 1] - position[0];\\n    int mid = 0, ans = -1;\\n    while(min <= max)\\n    {\\n        mid = min + (max - min) / 2;\\n        if(check(mid, position, positionSize, m))\\n        {\\n            ans = mid;\\n            min = mid + 1;\\n        }"], ["int maxDistance(int* position, int positionSize, int m){\\n    qsort(position, positionSize, sizeof(int), cmp);\\n    int min = 1, max = position[positionSize - 1] - position[0];\\n    int mid = 0, ans = -1;\\n    while(min <= max)\\n    {\\n        mid = min + (max - min) / 2;\\n        if(check(mid, position, positionSize, m))\\n        {\\n            ans = mid;\\n            min = mid + 1;\\n        }"], ["int maxDistance(int* position, int positionSize, int m){\\n    qsort(position, positionSize, sizeof(int), cmp);\\n    int min = 1, max = position[positionSize - 1] - position[0];\\n    int mid = 0, ans = -1;\\n    while(min <= max)\\n    {\\n        mid = min + (max - min) / 2;\\n        if(check(mid, position, positionSize, m))\\n        {\\n            ans = mid;\\n            min = mid + 1;\\n        }"]]}
{"id": "1286", "ref_c": [["int* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    bool *hash = calloc(n, sizeof(bool));\\n    (*returnSize) = 0;\\n    for(int i = 0; i < edgesSize; i++){\\n        if(hash[edges[i][1]] == false){\\n            (*returnSize)++;\\n            hash[edges[i][1]] = true;\\n        }"], ["int* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    bool* inDegree = calloc(n, sizeof(bool));\\n    int numOfVertices = n;\\n\\n    for(int i = 0; i < edgesSize; i++)\\n    {\\n        if(inDegree[edges[i][1]] == false)\\n        {\\n            inDegree[edges[i][1]] = true;\\n            numOfVertices--;\\n        }"], ["int* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    bool *hash = calloc(n, sizeof(bool));\\n    (*returnSize) = 0;\\n    for(int i = 0; i < edgesSize; i++){\\n        if(hash[edges[i][1]] == false){\\n            (*returnSize)++;\\n            hash[edges[i][1]] = true;\\n        }"]]}
{"id": "1287", "ref_c": [["int minOperations(int* nums, int numsSize){\\n    int maxMSD=0;\\n    int sumPop=0;\\n    for (int i=0;i<numsSize;i++){\\n        while ((nums[i]>>maxMSD)>1){//same as ((<<maxMSD) < nums[i])\\n            maxMSD++;\\n        }"], ["int minOperations(int* nums, int numsSize){\\n    int maxMSD=0;\\n    int sumPop=0;\\n    for (int i=0;i<numsSize;i++){\\n        while ((nums[i]>>maxMSD)>1){//same as ((<<maxMSD) < nums[i])\\n            maxMSD++;\\n        }"], ["int minOperations(int* nums, int numsSize){\\n//  option 0 is one idx in arr (+ 1)\\n//  option 1 is all arr (* 2)\\n    if(numsSize==1&&nums[0]==0) return 0;\\n    int high_bit=-1;\\n    int one_count=0;\\n    int res=0;\\n    for(int i=0;i<numsSize;i++){\\n        one_count=__builtin_popcount(nums[i]);\\n        res+=one_count;\\n        int temp=0;\\n        while(nums[i]!=0){\\n            temp++;\\n            nums[i]>>=1;\\n        }"]]}
{"id": "1288", "ref_c": [["bool containsCycle(char** grid, int gridSize, int* gridColSize){\\n    bool** visited = malloc(gridSize * sizeof(bool*));\\n    for (int i = 0; i < gridSize; i++) {\\n        visited[i] = malloc(*gridColSize * sizeof(bool));\\n        for (int j = 0; j < *gridColSize; j++) visited[i][j] = false;\\n    }"], ["bool containsCycle(char** grid, int gridSize, int* gridColSize){\\n    bool** visited = malloc(gridSize * sizeof(bool*));\\n    for (int i = 0; i < gridSize; i++) {\\n        visited[i] = malloc(*gridColSize * sizeof(bool));\\n        for (int j = 0; j < *gridColSize; j++) visited[i][j] = false;\\n    }"], ["bool containsCycle(char** grid, int gridSize, int* gridColSize){\\n    m = gridSize;\\n    n = *gridColSize;\\n    is_cycle = 0;\\n    p_grid = grid;\\n    p_visited = (bool**)calloc(m, sizeof(bool*));\\n    for (int i = 0; i < m; i++){\\n        p_visited[i]= (bool*)calloc(n, sizeof(bool));\\n    }", "bool containsCycle(char** grid, int gridSize, int* gridColSize){\\n    m = gridSize;\\n    n = *gridColSize;\\n    is_cycle = 0;\\n    p_grid = grid;\\n    p_visited = (bool**)calloc(m, sizeof(bool*));\\n    for (int i = 0; i < m; i++){\\n        p_visited[i]= (bool*)calloc(n, sizeof(bool));\\n    }"]]}
{"id": "1289", "ref_c": [["int maxCoins(int* piles, int pilesSize) {\\n    // Sort the piles in ascending order to get the optimal selection pattern\\n    qsort(piles, pilesSize, sizeof(int), compare);\\n    int ans = 0; // Initialize the answer variable\\n\\n    // Start from the index which is 1/3rd of the total elements until the end of the piles\\n    // Increment the index by 2 in each iteration to consider every alternate 2nd element\\n    for (int i = pilesSize / 3; i < pilesSize; i += 2) {\\n        ans += piles[i]; // Accumulate the coins from the selected piles\\n    }"], ["int maxCoins(int* piles, int pilesSize) {\\n    // Sort the piles in ascending order to get the optimal selection pattern\\n    qsort(piles, pilesSize, sizeof(int), compare);\\n    int ans = 0; // Initialize the answer variable\\n\\n    // Start from the index which is 1/3rd of the total elements until the end of the piles\\n    // Increment the index by 2 in each iteration to consider every alternate 2nd element\\n    for (int i = pilesSize / 3; i < pilesSize; i += 2) {\\n        ans += piles[i]; // Accumulate the coins from the selected piles\\n    }"], ["int maxCoins(int* piles, int pilesSize) {\\n    // Sort the piles in ascending order to get the optimal selection pattern\\n    qsort(piles, pilesSize, sizeof(int), compare);\\n    int ans = 0; // Initialize the answer variable\\n\\n    // Start from the index which is 1/3rd of the total elements until the end of the piles\\n    // Increment the index by 2 in each iteration to consider every alternate 2nd element\\n    for (int i = pilesSize / 3; i < pilesSize; i += 2) {\\n        ans += piles[i]; // Accumulate the coins from the selected piles\\n    }"]]}
{"id": "1290", "ref_c": [["int findLatestStep(int* arr, int arrSize, int m){\\n    int ret = -1;\\n    if(m>arrSize)\\n        return ret;\\n    if(m==arrSize)\\n        return m;\\n    head = malloc(sizeof(struct link));\\n    head->size = arrSize;\\n    head->start = 1;\\n    head->end = arrSize;\\n    head->next = NULL;\\n\\n    //1->arrSize liked list\\n    for(int i = arrSize-1; i >= m; i--){\\n        int del = arr[i];\\n        int check = search_and_break(del, m);\\n        if(check){\\n            ret = i;\\n            goto free;\\n        }"], ["int findLatestStep(int* arr, int arrSize, int m){\\n    int ret = -1;\\n    if(m>arrSize)\\n        return ret;\\n    if(m==arrSize)\\n        return m;\\n    head = malloc(sizeof(struct link));\\n    head->size = arrSize;\\n    head->start = 1;\\n    head->end = arrSize;\\n    head->next = NULL;\\n\\n    //1->arrSize liked list\\n    for(int i = arrSize-1; i >= m; i--){\\n        int del = arr[i];\\n        int check = search_and_break(del, m);\\n        if(check){\\n            ret = i;\\n            goto free;\\n        }"], ["int findLatestStep(int* arr, int arrSize, int m){\\n    int ret = -1;\\n    if(m>arrSize)\\n        return ret;\\n    if(m==arrSize)\\n        return m;\\n    head = malloc(sizeof(struct link));\\n    head->size = arrSize;\\n    head->start = 1;\\n    head->end = arrSize;\\n    head->next = NULL;\\n\\n    //1->arrSize liked list\\n    for(int i = arrSize-1; i >= m; i--){\\n        int del = arr[i];\\n        int check = search_and_break(del, m);\\n        if(check){\\n            ret = i;\\n            goto free;\\n        }"]]}
{"id": "1291", "ref_c": [["int getMaxLen(int* nums, int numsSize){\\n    int i = 0, positives = 0, negatives = 0, temp, maxLen = 0;\\n\\n    for (; i < numsSize; i++) {\\n        if (nums[i] == 0)\\n            positives = negatives = 0;\\n        else if (nums[i] > 0) {\\n            positives++;\\n            if (negatives > 0)\\n                negatives++;\\n        }"], ["int getMaxLen(int* nums, int numsSize)\\n{\\n    int positiveCount, negativeCount, tmp, res;\\n    positiveCount = negativeCount = res = 0;\\n    \\n    for(int i = 0; i < numsSize ; i++)\\n    {\\n        int switchCase = nums[i] < 0 ? -1 : nums[i] == 0 ? 0 : 1;\\n        switch(switchCase)\\n        {\\n            case 0: // Zero\\n                positiveCount = negativeCount = 0;\\n                break;\\n            case -1: // Negative\\n                tmp = positiveCount;\\n                positiveCount = negativeCount > 0 ? negativeCount + 1 : 0;\\n                negativeCount = tmp + 1;\\n                break;\\n            case 1: // Positive\\n                positiveCount++;\\n                if(negativeCount)\\n                    negativeCount++;\\n        }"], ["int getMaxLen(int* nums, int numsSize){\\n\\t// Solution 1\\n    // int maxLen = 0, countNeg = 0, posFirstNeg = -1, posZero = -1;\\n    // for(int i=0; i<numsSize; i++)\\n    //     if(nums[i] < 0)\\n    //     {\\n    //         countNeg++;\\n    //         if(posFirstNeg == -1)\\n    //             posFirstNeg = i;\\n    //         else if(countNeg % 2 == 0)\\n    //             maxLen = maxLen > i - posZero ? maxLen : i - posZero;\\n    //     }"]]}
{"id": "1292", "ref_c": [["int mostFrequentEven(int* nums, int numsSize){\\n\\n    int arr[100001] = {0}"], ["int mostFrequentEven(int* nums, int numsSize){\\n    int freq[100001]={0}"], ["int mostFrequentEven(int* nums, int numsSize){\\n\\n    int arr[100001] = {0}"]]}
{"id": "1293", "ref_c": [["int findLengthOfShortestSubarray(int* arr, int arrSize){\\n    int left = 0, right = arrSize - 1;\\n    while (left + 1 < arrSize && arr[left] <= arr[left + 1])\\n    {\\n        left++;\\n    }"], ["int findLengthOfShortestSubarray(int* arr, int arrSize){\\n    int i = 0,j = arrSize-1;\\n    while(i < arrSize-1 && arr[i+1] >= arr[i]){\\n        i++;\\n    }"], ["int findLengthOfShortestSubarray(int* arr, int arrSize){\\n    int i = 0,j = arrSize-1;\\n    while(i < arrSize-1 && arr[i+1] >= arr[i]){\\n        i++;\\n    }"]]}
{"id": "1294", "ref_c": [["int numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    return cal(nums1, nums1Size, nums2, nums2Size) + cal(nums2, nums2Size, nums1, nums1Size);\\n}"], ["int numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    return cal(nums1, nums1Size, nums2, nums2Size) + cal(nums2, nums2Size, nums1, nums1Size);\\n}"], ["int numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    return cal(nums1, nums1Size, nums2, nums2Size) + cal(nums2, nums2Size, nums1, nums1Size);\\n}"]]}
{"id": "1295", "ref_c": [["int minCost(char * colors, int* neededTime, int neededTimeSize){\\n    int minTime = 0;\\n    for (int i = 0; i < neededTimeSize - 1; i++){\\n        int next = i + 1;\\n        if (colors[i] == colors[next]){\\n            int removeTime  = neededTime[i] < neededTime[next] ? neededTime[i] : neededTime[next];\\n            minTime += removeTime;\\n            if (neededTime[i] > neededTime[next]) swap(&neededTime[i], &neededTime[next]);\\n        }"], ["int minCost(char * colors, int* neededTime, int neededTimeSize){\\n    int minTime = 0;\\n    for (int i = 0; i < neededTimeSize - 1; i++){\\n        int next = i + 1;\\n        if (colors[i] == colors[next]){\\n            int removeTime  = neededTime[i] < neededTime[next] ? neededTime[i] : neededTime[next];\\n            minTime += removeTime;\\n            if (neededTime[i] > neededTime[next]) swap(&neededTime[i], &neededTime[next]);\\n        }"], ["int minCost(char * colors, int* neededTime, int neededTimeSize){\\n    int minTime = 0;\\n    for (int i = 0; i < neededTimeSize - 1; i++){\\n        int next = i + 1;\\n        if (colors[i] == colors[next]){\\n            int removeTime  = neededTime[i] < neededTime[next] ? neededTime[i] : neededTime[next];\\n            minTime += removeTime;\\n            if (neededTime[i] > neededTime[next]) swap(&neededTime[i], &neededTime[next]);\\n        }"]]}
{"id": "1296", "ref_c": [["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0;\\n    for (int i = 0; i != numsSize; i++)\\n    {\\n        for (int j = 0; j != numsSize; j++)\\n        {\\n            if (i != j && (nums[i] - nums[j]) == k)\\n            {\\n                count++;\\n            }"], ["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0; \\n\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = i+1; j < numsSize; j++){\\n            if(abs(nums[i] - nums[j]) == k){\\n                count += 1; \\n            }"], ["int countKDifference(int* nums, int numsSize, int k){\\n    int count = 0;\\n    for(int i = 0; i < numsSize; i++)\\n        for(int j = i; j  < numsSize; j++)\\n            if(nums[i] - nums[j] == k || nums[j]  - nums[i] == k)\\n                count++;\\n\\n    \\n    return count;\\n}"]]}
{"id": "1297", "ref_c": ["\n#define min(a, b) (a < b ? a : b)\nint distance(int *a, int *b)\n{\n    return abs(a[0] - b[0]) + abs(a[1] - b[1]);\n}\n\nint minCostConnectPoints(int** points, int pointsSize, int* pointsColSize){\n    int result = 0, current_point = 0; \n    int minCost[pointsSize];\n    minCost[0] = 0;\n    for(int i = 1; i < pointsSize; i++)\n        minCost[i] = INT_MAX;\n    bool *visited = (bool *)calloc(pointsSize, sizeof(bool));\n    visited[0] = true;\n\twhile (current_point >= 0) \n    {\n\t\tvisited[current_point] = true;\n\t\tint minCurrent = INT_MAX;\n\t\tint next_point = -1;\n\t\tfor(int point = 0; point < pointsSize; point++) \n        {\n\t\t\tif(visited[point] || point == current_point)\n\t\t\t\tcontinue;\n\t\t\tminCost[point] = min(distance(points[current_point], points[point]), minCost[point]);\n\t\t\tif(minCost[point] < minCurrent)\n            { \n\t\t\t\tminCurrent = minCost[point];\n\t\t\t\tnext_point = point;\n\t\t\t}\n\t\t}\n\t\tresult += ((minCurrent == INT_MAX) ? 0 : minCurrent);\n\t\tcurrent_point = next_point;\n\t}\n\treturn result;\n}\n", "\n#define min(a, b) (a < b ? a : b)\nint distance(int *a, int *b)\n{\n    return abs(a[0] - b[0]) + abs(a[1] - b[1]);\n}\n\nint minCostConnectPoints(int** points, int pointsSize, int* pointsColSize){\n    int result = 0, current_point = 0; \n    int minCost[pointsSize];\n    minCost[0] = 0;\n    for(int i = 1; i < pointsSize; i++)\n        minCost[i] = INT_MAX;\n    bool *visited = (bool *)calloc(pointsSize, sizeof(bool));\n    visited[0] = true;\n\twhile (current_point >= 0) \n    {\n\t\tvisited[current_point] = true;\n\t\tint minCurrent = INT_MAX;\n\t\tint next_point = -1;\n\t\tfor(int point = 0; point < pointsSize; point++) \n        {\n\t\t\tif(visited[point] || point == current_point)\n\t\t\t\tcontinue;\n\t\t\tminCost[point] = min(distance(points[current_point], points[point]), minCost[point]);\n\t\t\tif(minCost[point] < minCurrent)\n            { \n\t\t\t\tminCurrent = minCost[point];\n\t\t\t\tnext_point = point;\n\t\t\t}\n\t\t}\n\t\tresult += ((minCurrent == INT_MAX) ? 0 : minCurrent);\n\t\tcurrent_point = next_point;\n\t}\n\treturn result;\n}\n", "\n#define min(a, b) (a < b ? a : b)\nint distance(int *a, int *b)\n{\n    return abs(a[0] - b[0]) + abs(a[1] - b[1]);\n}\n\nint minCostConnectPoints(int** points, int pointsSize, int* pointsColSize){\n    int result = 0, current_point = 0; \n    int minCost[pointsSize];\n    minCost[0] = 0;\n    for(int i = 1; i < pointsSize; i++)\n        minCost[i] = INT_MAX;\n    bool *visited = (bool *)calloc(pointsSize, sizeof(bool));\n    visited[0] = true;\n\twhile (current_point >= 0) \n    {\n\t\tvisited[current_point] = true;\n\t\tint minCurrent = INT_MAX;\n\t\tint next_point = -1;\n\t\tfor(int point = 0; point < pointsSize; point++) \n        {\n\t\t\tif(visited[point] || point == current_point)\n\t\t\t\tcontinue;\n\t\t\tminCost[point] = min(distance(points[current_point], points[point]), minCost[point]);\n\t\t\tif(minCost[point] < minCurrent)\n            { \n\t\t\t\tminCurrent = minCost[point];\n\t\t\t\tnext_point = point;\n\t\t\t}\n\t\t}\n\t\tresult += ((minCurrent == INT_MAX) ? 0 : minCurrent);\n\t\tcurrent_point = next_point;\n\t}\n\treturn result;\n}\n"]}
{"id": "1298", "ref_c": [["struct TreeNode* convertBST(struct TreeNode* root){\\n    conv(root, 0);\\n\\n    return root;\\n}"], ["struct TreeNode* convertBST(struct TreeNode* root)\\n{\\n    int t=0;\\n    func(root, &t);\\n    return root;\\n}"], ["struct TreeNode* convertBST(struct TreeNode* root){\\n\\t\\tint sum = 0;\\n\\t\\t\\n\\t\\tstruct TreeNode* sol(struct TreeNode* root){\\n\\t\\t\\tif ( root ){\\n\\t\\t\\t\\tsol(root->right);\\n\\t\\t\\t\\tsum = root->val += sum;\\n\\t\\t\\t\\tsol(root->left);\\n\\t\\t\\t}"]]}
{"id": "1299", "ref_c": ["\nint length(const char *s) {\n    int i;\n    for (i = 0; s[i] != '\u0000'; i++) {\n        \n    }\n    return i;\n}\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid reverse(char *s) {\n    int len = length(s);\n    int i = 0, j = len - 1;\n\n    for (i = 0; i <= j; i++, j--)\n        swap(&s[i], &s[j]);\n}\n\nchar* thousandSeparator(int n) {\n    int count = 0, i = 0, rem, rev = 0;\n    char* H = (char*)malloc(20 * sizeof(char));\n    if(n==0)\n    {\n        H[0] = '0';\n        H[1] = '\u0000';\n        return H;\n    }\n    while (n != 0) {\n        if (count == 3) {\n            H[i++] = '.';\n            count = 0;\n        }\n        rem = n % 10;\n        H[i++] = rem + '0';\n        rev = rev * 10 + rem;\n        count++;\n        n /= 10;\n    }\n    H[i] = '\u0000';\n    \n    reverse(H);\n    \n    return H;\n}\n", "\nint length(const char *s) {\n    int i;\n    for (i = 0; s[i] != '\u0000'; i++) {\n        \n    }\n    return i;\n}\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid reverse(char *s) {\n    int len = length(s);\n    int i = 0, j = len - 1;\n\n    for (i = 0; i <= j; i++, j--)\n        swap(&s[i], &s[j]);\n}\n\nchar* thousandSeparator(int n) {\n    int count = 0, i = 0, rem, rev = 0;\n    char* H = (char*)malloc(20 * sizeof(char));\n    if(n==0)\n    {\n        H[0] = '0';\n        H[1] = '\u0000';\n        return H;\n    }\n    while (n != 0) {\n        if (count == 3) {\n            H[i++] = '.';\n            count = 0;\n        }\n        rem = n % 10;\n        H[i++] = rem + '0';\n        rev = rev * 10 + rem;\n        count++;\n        n /= 10;\n    }\n    H[i] = '\u0000';\n    \n    reverse(H);\n    \n    return H;\n}\n", "\nint length(const char *s) {\n    int i;\n    for (i = 0; s[i] != '\u0000'; i++) {\n        \n    }\n    return i;\n}\n\nvoid swap(char *x, char *y) {\n    char temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\nvoid reverse(char *s) {\n    int len = length(s);\n    int i = 0, j = len - 1;\n\n    for (i = 0; i <= j; i++, j--)\n        swap(&s[i], &s[j]);\n}\n\nchar* thousandSeparator(int n) {\n    int count = 0, i = 0, rem, rev = 0;\n    char* H = (char*)malloc(20 * sizeof(char));\n    if(n==0)\n    {\n        H[0] = '0';\n        H[1] = '\u0000';\n        return H;\n    }\n    while (n != 0) {\n        if (count == 3) {\n            H[i++] = '.';\n            count = 0;\n        }\n        rem = n % 10;\n        H[i++] = rem + '0';\n        rev = rev * 10 + rem;\n        count++;\n        n /= 10;\n    }\n    H[i] = '\u0000';\n    \n    reverse(H);\n    \n    return H;\n}\n"]}
{"id": "1300", "ref_c": [["int maxUniqueSplit(char * s){\\n\\tchar str_tmp[17][17];\\n\\tint answer = 0;\\n\\trecursive(s, str_tmp, 0, 0, strlen(s), &answer);\\n\\treturn answer;\\n}"], ["int maxUniqueSplit(char * s){\\n    int slen=strlen(s);\\n    if(slen==1) return 1;\\n    int maxsize=pow(2,slen-1);\\n    printf(\"maxsize : %d\\\\n\",maxsize);\\n    int maximumSplits=0;\\n    for(int split=0;split<maxsize;split++){\\n        int numberOfBars = 0;\\n        if(isvaild(s, slen,split, &numberOfBars))\\n            maximumSplits = max(maximumSplits, numberOfBars);\\n    }"], ["int maxUniqueSplit(char * s){\\n\\tchar str_tmp[17][17];\\n\\tint answer = 0;\\n\\trecursive(s, str_tmp, 0, 0, strlen(s), &answer);\\n\\treturn answer;\\n}"]]}
{"id": "1301", "ref_c": [["int* nextGreaterElements(int* nums, int numsSize, int* returnSize) {\\n    int n = numsSize;\\n    int* result = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    struct Stack *s = (struct Stack*)malloc(sizeof(struct Stack));\\n    s->next = NULL;\\n    for(int i = 0; i < n; i++){\\n        result[i] = -1;\\n    }"], ["int* nextGreaterElements(int* nums, int numsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int *ans = (int *)malloc(sizeof(int) * numsSize);\\n    int val, idx;\\n\\n    stk_init();\\n\\n    *returnSize = numsSize;\\n\\n    /* Process original array */\\n    for (int i = 0; i < numsSize; i++) {\\n        if (stk_cnt() == 0) {\\n            stk_push(nums[i], i);\\n            ans[i] = -1;\\n        }"], ["int* nextGreaterElements(int* nums, int numsSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n\\n    int *ans = (int *)malloc(sizeof(int) * numsSize);\\n    int val, idx;\\n\\n    stk_init();\\n\\n    *returnSize = numsSize;\\n\\n    /* Process original array */\\n    for (int i = 0; i < numsSize; i++) {\\n        if (stk_cnt() == 0) {\\n            stk_push(nums[i], i);\\n            ans[i] = -1;\\n        }"]]}
{"id": "1302", "ref_c": [["int maximumPopulation(int** logs, int logsSize, int* logsColSize) {\\n    int map[101] = {0}"], ["int maximumPopulation(int** logs, int logsSize, int* logsColSize){\\n    int arr[102]={0}", "int maximumPopulation(int** logs, int logsSize, int* logsColSize){\\n  \\n    int *arrB=(int*)malloc(sizeof(int)*(logsSize));\\n    int *arrD=(int*)malloc(sizeof(int)*(logsSize));\\n    for(int x=0;x<logsSize;x++){\\n        arrB[x]=logs[x][0];\\n        arrD[x]=logs[x][1]-1;\\n    }"], ["int maximumPopulation(int** logs, int logsSize, int* logsColSize)\\n{\\n    memset(hashtable, 0x00, sizeof(hashtable));\\n    \\n    int i=0;\\n    for(i=0; i<logsSize; i++)\\n    {\\n        int birth_year = logs[i][0];\\n        int death_year = logs[i][1];\\n        \\n        int j=0;\\n        for(j=birth_year; j<death_year; j++)\\n        {\\n            hashtable[j - 1950] += 1;\\n        }"]]}
{"id": "1304", "ref_c": [["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if((n - 1) % 3 == 0){\\n\\n\\n        return true; \\n        }", "bool isPowerOfFour(int n) {\\n    if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if ((n - 1) % 3 == 0) {\\n            return true;\\n        }", "bool isPowerOfFour(int n) {\\n       return n>0 && (n&(n-1))==0 && (n % 10 ==1|| n% 10==4|| n%10==6);\\n    }", "bool isPowerOfFour(int n) {\\n    return n > 0 && (n & (n - 1)) == 0 && (n % 10 == 1 || n % 10 == 4 || n % 10 == 6);\\n}"], ["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the logarithm of \\'n\\' with base 4\\n        double logarithmBase4 = log(n) / log(4);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (logarithmBase4 == (int)logarithmBase4);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the logarithm of \\'n\\' with base 4\\n    double logarithmBase4 = log(n) / log(4);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (logarithmBase4 == (int)logarithmBase4);\\n}", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the square root of \\'n\\'\\n        double sqrtN = sqrt(n);\\n\\n        // Take the logarithm base 2 of the square root\\n        double log2SqrtN = log2(sqrtN);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (log2SqrtN == (int)log2SqrtN);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the square root of \\'n\\'\\n    double sqrtN = sqrt(n);\\n\\n    // Take the logarithm base 2 of the square root\\n    double log2SqrtN = log2(sqrtN);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (log2SqrtN == (int)log2SqrtN);\\n}"], ["bool isPowerOfFour(int n){\\n\\n    if(n==1)\\n        return true;\\n    return (n&0x55555554) && !(n&n-1);\\n}"]]}
{"id": "1305", "ref_c": [["int** restoreMatrix(int* rowSum, int rowSumSize, int* colSum, int colSumSize, int* returnSize, int** returnColumnSizes){\\n    int n = rowSumSize,m=colSumSize;\\n    int**matrix = (int**)malloc(sizeof(int*)*n);\\n    *returnSize = n;\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int)*n);\\n    for(int i=0;i<n;i++){\\n        (*returnColumnSizes)[i]=m;\\n        matrix[i]=(int*)malloc(sizeof(int)*m);\\n    }"], ["int** restoreMatrix(int* rowSum, int rowSumSize, int* colSum, int colSumSize, int* returnSize, int** returnColumnSizes){\\n    int n = rowSumSize,m=colSumSize;\\n    int**matrix = (int**)malloc(sizeof(int*)*n);\\n    *returnSize = n;\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int)*n);\\n    for(int i=0;i<n;i++){\\n        (*returnColumnSizes)[i]=m;\\n        matrix[i]=(int*)malloc(sizeof(int)*m);\\n    }"], ["int** restoreMatrix(int* rowSum, int rowSumSize, int* colSum, int colSumSize, int* returnSize, int** returnColumnSizes){\\n    int n = rowSumSize,m=colSumSize;\\n    int**matrix = (int**)malloc(sizeof(int*)*n);\\n    *returnSize = n;\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int)*n);\\n    for(int i=0;i<n;i++){\\n        (*returnColumnSizes)[i]=m;\\n        matrix[i]=(int*)malloc(sizeof(int)*m);\\n    }"]]}
{"id": "1306", "ref_c": [["bool isEvenOddTree(struct TreeNode* root){\\n  if (!(root->val % 2))\\n    return false;\\n  Qnode* Qhead = (Qnode*)malloc(sizeof(Qnode));\\n  Qnode* Qtail;\\n  Qhead->value = root;\\n  Qhead->next  = NULL;\\n  Qtail = Qhead;\\n  Qnode* curr_level_head = Qhead;\\n  bool check_for_even_level = true;\\n  bool new_level = false;\\n  while(Qhead){\\n    if(Qhead == curr_level_head)\\n      new_level = true;\\n    if(new_level && ((Qhead->value->left) || (Qhead->value->right))){\\n      new_level = false;\\n      check_for_even_level = !(check_for_even_level);\\n      curr_level_head = NULL;\\n    }"], ["bool isEvenOddTree(struct TreeNode* root){\\n  if (!(root->val % 2))\\n    return false;\\n  Qnode* Qhead = (Qnode*)malloc(sizeof(Qnode));\\n  Qnode* Qtail;\\n  Qhead->value = root;\\n  Qhead->next  = NULL;\\n  Qtail = Qhead;\\n  Qnode* curr_level_head = Qhead;\\n  bool check_for_even_level = true;\\n  bool new_level = false;\\n  while(Qhead){\\n    if(Qhead == curr_level_head)\\n      new_level = true;\\n    if(new_level && ((Qhead->value->left) || (Qhead->value->right))){\\n      new_level = false;\\n      check_for_even_level = !(check_for_even_level);\\n      curr_level_head = NULL;\\n    }"], ["bool isEvenOddTree(struct TreeNode* root){\\n  if (!(root->val % 2))\\n    return false;\\n  Qnode* Qhead = (Qnode*)malloc(sizeof(Qnode));\\n  Qnode* Qtail;\\n  Qhead->value = root;\\n  Qhead->next  = NULL;\\n  Qtail = Qhead;\\n  Qnode* curr_level_head = Qhead;\\n  bool check_for_even_level = true;\\n  bool new_level = false;\\n  while(Qhead){\\n    if(Qhead == curr_level_head)\\n      new_level = true;\\n    if(new_level && ((Qhead->value->left) || (Qhead->value->right))){\\n      new_level = false;\\n      check_for_even_level = !(check_for_even_level);\\n      curr_level_head = NULL;\\n    }"]]}
{"id": "1307", "ref_c": [["int maximalNetworkRank(int n, int** roads, int roadsSize, int* roadsColSize){\\n    int **matrix = malloc(sizeof(int *) * (n + 1));\\n    for (int i = 0;i <= n; i ++)\\n        matrix[i] = calloc(n, sizeof(int));\\n    for (int i = 0; i < roadsSize; i++)\\n    {\\n        matrix[roads[i][0]][roads[i][1]] += 1;\\n        matrix[roads[i][1]][roads[i][0]] += 1;\\n        matrix[n][roads[i][0]] += 1;\\n        matrix[n][roads[i][1]] += 1;\\n    }"], ["int maximalNetworkRank(int n, int** roads, int roadsSize, int* roadsColSize) {\\n    int adjacencyMatrix[n][n];\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            adjacencyMatrix[i][j] = 0;\\n        }"], ["int maximalNetworkRank(int n, int** roads, int roadsSize, int* roadsColSize){\\n    int **matrix = malloc(sizeof(int *) * (n + 1));\\n    for (int i = 0;i <= n; i ++)\\n        matrix[i] = calloc(n, sizeof(int));\\n    for (int i = 0; i < roadsSize; i++)\\n    {\\n        matrix[roads[i][0]][roads[i][1]] += 1;\\n        matrix[roads[i][1]][roads[i][0]] += 1;\\n        matrix[n][roads[i][0]] += 1;\\n        matrix[n][roads[i][1]] += 1;\\n    }"]]}
{"id": "1308", "ref_c": [["bool checkPalindromeFormation(char * a, char * b){\\n    // find end of string\\n    int i = 0;\\n    while (a[i]) i++; \\n    i--;\\n\\n\\t// check both a_prefix + b_suffix and b_prefix + a_suffix\\n    return(helper(a, b, i) || helper(b,a,i));\\n}"], ["bool checkPalindromeFormation(char * a, char * b){\\n    // find end of string\\n    int i = 0;\\n    while (a[i]) i++; \\n    i--;\\n\\n\\t// check both a_prefix + b_suffix and b_prefix + a_suffix\\n    return(helper(a, b, i) || helper(b,a,i));\\n}"], ["bool checkPalindromeFormation(char * a, char * b){\\n    // find end of string\\n    int i = 0;\\n    while (a[i]) i++; \\n    i--;\\n\\n\\t// check both a_prefix + b_suffix and b_prefix + a_suffix\\n    return(helper(a, b, i) || helper(b,a,i));\\n}"]]}
{"id": "1309", "ref_c": [["int getWinner(int* arr, int arrSize, int k) {\\n    // Find the maximum element in the array.\\n    int maxElement = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        if (arr[i] > maxElement) {\\n            maxElement = arr[i];\\n        }"], ["int getWinner(int* arr, int arrSize, int k) {\\n    int currentWinner = arr[0];\\n    int count = 0;\\n    for (int i = 1; i < arrSize; i++) {\\n        if (arr[i] > currentWinner) {\\n            currentWinner = arr[i];\\n            count = 1;\\n        }", "int getWinner(int* arr, int arrSize, int k) {\\n    int* queue = (int*)malloc(arrSize * sizeof(int));\\n    int one = arr[0];\\n    int x = k;\\n    int maxi = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        queue[i - 1] = arr[i];\\n        if (arr[i] > maxi) {\\n            maxi = arr[i];\\n        }", "int getWinner(int* arr, int arrSize, int k) {\\n    int* wins = (int*)malloc(arrSize * sizeof(int));\\n    for (int i = 0; i < arrSize; i++) {\\n        wins[i] = 0;\\n    }"], ["int getWinner(int* arr, int arrSize, int k) {\\n    // Find the maximum element in the array.\\n    int maxElement = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        if (arr[i] > maxElement) {\\n            maxElement = arr[i];\\n        }"]]}
{"id": "1310", "ref_c": [["int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize) {\\n\\n    int *output = (int *)malloc(numsSize * (sizeof(int)));\\n    for(int i=0; i<numsSize; i++){\\n        output[i] = -1;\\n    }"], ["int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize){\\n    int* arr = (int*)malloc(numsSize*sizeof(int));\\n    *returnSize = numsSize;\\n    for(int i = 0 ; i < numsSize ; i++){\\n        arr[i] = -1;\\n    }"], ["int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize) {\\n\\n    int *output = (int *)malloc(numsSize * (sizeof(int)));\\n    for(int i=0; i<numsSize; i++){\\n        output[i] = -1;\\n    }"]]}
{"id": "1311", "ref_c": [["char ** simplifiedFractions(int n, int* returnSize){\\n    char ** res = (char **) malloc(MAX_FRACTIONS * sizeof(char *));\\n    int ptr = 0;\\n\\n    for (int nom = 1; nom <= n; nom++) {\\n        for (int den = 1; den <= n; den++) {\\n            // continue if:\\n            //   - fraction is top heavy\\n            //   - numerator is equal to the denominator\\n            //   - greatest common divisor is not 1 (can be simplified)\\n            if (nom >= den || gcd(nom, den) != 1) {\\n                continue;\\n            }"], ["char ** simplifiedFractions(int n, int* returnSize){\\n    char ** res = (char **) malloc(MAX_FRACTIONS * sizeof(char *));\\n    int ptr = 0;\\n\\n    for (int nom = 1; nom <= n; nom++) {\\n        for (int den = 1; den <= n; den++) {\\n            // continue if:\\n            //   - fraction is top heavy\\n            //   - numerator is equal to the denominator\\n            //   - greatest common divisor is not 1 (can be simplified)\\n            if (nom >= den || gcd(nom, den) != 1) {\\n                continue;\\n            }"], ["char ** simplifiedFractions(int n, int* returnSize){\\n    char ** res = (char **) malloc(MAX_FRACTIONS * sizeof(char *));\\n    int ptr = 0;\\n\\n    for (int nom = 1; nom <= n; nom++) {\\n        for (int den = 1; den <= n; den++) {\\n            // continue if:\\n            //   - fraction is top heavy\\n            //   - numerator is equal to the denominator\\n            //   - greatest common divisor is not 1 (can be simplified)\\n            if (nom >= den || gcd(nom, den) != 1) {\\n                continue;\\n            }"]]}
{"id": "1312", "ref_c": [["int bestTeamScore(int* scores, int scoresSize, int* ages, int agesSize){\\n    sortByAgeThenScore(scores, scoresSize, ages, agesSize);\\n\\n    int memo[agesSize][agesSize];\\n    memset(memo, 0, agesSize*agesSize*sizeof(int));\\n    \\n    return chooseNext(0, ages, agesSize, scores, scoresSize, -1, memo);\\n}"], ["int bestTeamScore(int* scores, int scoresSize, int* ages, int agesSize){\\n  int (*pairs)[2] = malloc(scoresSize * sizeof(*pairs));\\n  for (int i = 0; i < scoresSize; ++i) {\\n    pairs[i][0] = ages[i];\\n    pairs[i][1] = scores[i];\\n  }"], ["int bestTeamScore(int* scores, int scoresSize, int* ages, int agesSize){\\n    struct record temp[scoresSize];\\n    int dp[scoresSize], ans = 0;\\n\\n    for(int i = 0; i < scoresSize; i++)\\n    {\\n        temp[i].score = scores[i];\\n        temp[i].age = ages[i];\\n    }"]]}
{"id": "1313", "ref_c": [["bool* checkArithmeticSubarrays(int* nums, int numsSize, int* l, int lSize, int* r, int rSize, int* returnSize) {\\n\\n    /*\\n     * Input:\\n     *  *nums,\\n     *  numsSize\\n     *  *l\\n     *  lSize\\n     *  *r\\n     *  rSize\\n     */\\n\\n    bool *ans = (bool *)malloc(sizeof(bool) * lSize);\\n    int *tmp = (bool *)malloc(sizeof(int) * numsSize);\\n\\n    *returnSize = lSize;\\n\\n    for (int i = 0; i < lSize; i++) {\\n\\n        for (int j = l[i], idx = 0; j <= r[i]; j++, idx++) {\\n            tmp[idx] = nums[j];\\n        }"], ["bool* checkArithmeticSubarrays(int* nums, int numsSize, int* l, int lSize, int* r, int rSize, int* returnSize) {\\n\\n    /*\\n     * Input:\\n     *  *nums,\\n     *  numsSize\\n     *  *l\\n     *  lSize\\n     *  *r\\n     *  rSize\\n     */\\n\\n    bool *ans = (bool *)malloc(sizeof(bool) * lSize);\\n    int *tmp = (bool *)malloc(sizeof(int) * numsSize);\\n\\n    *returnSize = lSize;\\n\\n    for (int i = 0; i < lSize; i++) {\\n\\n        for (int j = l[i], idx = 0; j <= r[i]; j++, idx++) {\\n            tmp[idx] = nums[j];\\n        }"], ["bool* checkArithmeticSubarrays(int* nums, int numsSize, int* l, int lSize, int* r, int rSize, int* returnSize) {\\n\\n    /*\\n     * Input:\\n     *  *nums,\\n     *  numsSize\\n     *  *l\\n     *  lSize\\n     *  *r\\n     *  rSize\\n     */\\n\\n    bool *ans = (bool *)malloc(sizeof(bool) * lSize);\\n    int *tmp = (bool *)malloc(sizeof(int) * numsSize);\\n\\n    *returnSize = lSize;\\n\\n    for (int i = 0; i < lSize; i++) {\\n\\n        for (int j = l[i], idx = 0; j <= r[i]; j++, idx++) {\\n            tmp[idx] = nums[j];\\n        }"]]}
{"id": "1314", "ref_c": [["int minimumEffortPath(int** heights, int heightsSize, int* heightsColSize){\\n    /*\\n     * Input:\\n     *  heights\\n     *  heightsSize\\n     *  *heightsColSize\\n     */\\n     \\n    int min = INT_MAX, low, high, mid;\\n    bool **visited = (bool **)malloc(sizeof(bool *) * heightsSize);\\n    \\n    for (int i = 0; i < heightsSize; i++) {\\n        for (int j = 0; j < heightsColSize[i]; j++) {\\n            high = MAX(high, heights[i][j]);\\n        }"], ["int minimumEffortPath(int** heights, int heightsSize, int* heightsColSize){\\n    /*\\n     * Input:\\n     *  heights\\n     *  heightsSize\\n     *  *heightsColSize\\n     */\\n     \\n    int min = INT_MAX, low, high, mid;\\n    bool **visited = (bool **)malloc(sizeof(bool *) * heightsSize);\\n    \\n    for (int i = 0; i < heightsSize; i++) {\\n        for (int j = 0; j < heightsColSize[i]; j++) {\\n            high = MAX(high, heights[i][j]);\\n        }"], ["int minimumEffortPath(int** heights, int heightsSize, int* heightsColSize){\\n    /*\\n     * Input:\\n     *  heights\\n     *  heightsSize\\n     *  *heightsColSize\\n     */\\n     \\n    int min = INT_MAX, low, high, mid;\\n    bool **visited = (bool **)malloc(sizeof(bool *) * heightsSize);\\n    \\n    for (int i = 0; i < heightsSize; i++) {\\n        for (int j = 0; j < heightsColSize[i]; j++) {\\n            high = MAX(high, heights[i][j]);\\n        }"]]}
{"id": "1315", "ref_c": [["int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\\n    int min=-INT_MAX;\\n    int s,j;\\n    mergeSort(points,0,pointsSize-1);\\n    for(int i=0;i<pointsSize-1;i++){\\n            s=points[i+1][0]-points[i][0];\\n            if(s>min){\\n                min=s;\\n            }"], ["int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\\n    int min=-INT_MAX;\\n    int s,j;\\n    mergeSort(points,0,pointsSize-1);\\n    for(int i=0;i<pointsSize-1;i++){\\n            s=points[i+1][0]-points[i][0];\\n            if(s>min){\\n                min=s;\\n            }"], ["int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\\n    qsort(points, pointsSize, sizeof(int *), cmp);\\n\\n    int max_width = 0;\\n\\n    /* Update the max width */\\n    for (int i = 1; i < pointsSize; ++i) {\\n        int curr_width = points[i][0] - points[i - 1][0];\\n        max_width = fmax(max_width, curr_width);\\n    }"]]}
{"id": "1316", "ref_c": [["int countSubstrings(char * s, char * t){\\n    int len1 = strlen(s),len2 = strlen(t);\\n    int len = len1<len2?len1:len2;\\n    int*** dp = malloc(sizeof(int**)*len1);\\n    for(int i = 0;i < len1;i++){\\n        dp[i] = (int**)malloc(sizeof(int*)*len2);\\n        for(int j = 0;j < len2;j++){\\n            dp[i][j] = (int*)malloc(sizeof(int)*(len+1));\\n            dp[i][j][0] = 0;\\n        }"], ["int countSubstrings(char * s, char * t){\\n    int len1 = strlen(s),len2 = strlen(t);\\n    int len = len1<len2?len1:len2;\\n    int*** dp = malloc(sizeof(int**)*len1);\\n    for(int i = 0;i < len1;i++){\\n        dp[i] = (int**)malloc(sizeof(int*)*len2);\\n        for(int j = 0;j < len2;j++){\\n            dp[i][j] = (int*)malloc(sizeof(int)*(len+1));\\n            dp[i][j][0] = 0;\\n        }"], ["int countSubstrings(char * s, char * t){\\n    int len1 = strlen(s),len2 = strlen(t);\\n    int len = len1<len2?len1:len2;\\n    int*** dp = malloc(sizeof(int**)*len1);\\n    for(int i = 0;i < len1;i++){\\n        dp[i] = (int**)malloc(sizeof(int*)*len2);\\n        for(int j = 0;j < len2;j++){\\n            dp[i][j] = (int*)malloc(sizeof(int)*(len+1));\\n            dp[i][j][0] = 0;\\n        }"]]}
{"id": "1317", "ref_c": [["int countVowelStrings(int n) {\\n    int ans=1;\\n    int div=1;\\n    for(int i=5;i<5+n;i++){\\n        ans=(ans*i)/div;\\n        div++;\\n    }"], ["int countVowelStrings(int n) {\\n    int ans=1;\\n    int div=1;\\n    for(int i=5;i<5+n;i++){\\n        ans=(ans*i)/div;\\n        div++;\\n    }"], ["int countVowelStrings(int n) {\\n    int ans=1;\\n    int div=1;\\n    for(int i=5;i<5+n;i++){\\n        ans=(ans*i)/div;\\n        div++;\\n    }"]]}
{"id": "1318", "ref_c": [["int furthestBuilding(int* heights, int heightsSize, int bricks, int ladders){\\n\\n    int val;\\n    int diff;\\n\\n    /* Max heap */\\n    heap_init();\\n\\n    /* Scan the buildings */\\n    for (int i = 0; i < heightsSize - 1; i++) {\\n\\n        /* Get height different between current and next building */\\n        diff = heights[i + 1] - heights[i];\\n        \\n        /* Need to put bricks or ladder for higher building */\\n        if (diff > 0) {\\n        \\n            /* Store the height difference in max heap */\\n            heap_push(diff);\\n            bricks -= diff;\\n            \\n            /* If there is no enough brick */\\n            if (bricks < 0) {\\n                \\n                /* Check if we can move to next building by using ladder */\\n                if (ladders > 0) {\\n                    \\n                    /* Swap a ladder to get more bricks if possible */\\n                    if (heap_empty() == false) {\\n                        heap_pop(&val);\\n                        bricks += val;\\n                    }"], ["int furthestBuilding(int* heights, int heightsSize, int bricks, int ladders){\\n\\n    int val;\\n    int diff;\\n\\n    /* Max heap */\\n    heap_init();\\n\\n    /* Scan the buildings */\\n    for (int i = 0; i < heightsSize - 1; i++) {\\n\\n        /* Get height different between current and next building */\\n        diff = heights[i + 1] - heights[i];\\n        \\n        /* Need to put bricks or ladder for higher building */\\n        if (diff > 0) {\\n        \\n            /* Store the height difference in max heap */\\n            heap_push(diff);\\n            bricks -= diff;\\n            \\n            /* If there is no enough brick */\\n            if (bricks < 0) {\\n                \\n                /* Check if we can move to next building by using ladder */\\n                if (ladders > 0) {\\n                    \\n                    /* Swap a ladder to get more bricks if possible */\\n                    if (heap_empty() == false) {\\n                        heap_pop(&val);\\n                        bricks += val;\\n                    }"], ["int furthestBuilding(int* heights, int heightsSize, int bricks, int ladders){\\n\\n    int val;\\n    int diff;\\n\\n    /* Max heap */\\n    heap_init();\\n\\n    /* Scan the buildings */\\n    for (int i = 0; i < heightsSize - 1; i++) {\\n\\n        /* Get height different between current and next building */\\n        diff = heights[i + 1] - heights[i];\\n        \\n        /* Need to put bricks or ladder for higher building */\\n        if (diff > 0) {\\n        \\n            /* Store the height difference in max heap */\\n            heap_push(diff);\\n            bricks -= diff;\\n            \\n            /* If there is no enough brick */\\n            if (bricks < 0) {\\n                \\n                /* Check if we can move to next building by using ladder */\\n                if (ladders > 0) {\\n                    \\n                    /* Swap a ladder to get more bricks if possible */\\n                    if (heap_empty() == false) {\\n                        heap_pop(&val);\\n                        bricks += val;\\n                    }"]]}
{"id": "1319", "ref_c": [["int minDeletions(char * s){\\n    int freq[27];\\n    for(int i = 0; i < 27; i++){\\n        freq[i] = 0;\\n    }"], ["int minDeletions(char * s){\\n    int freq[27];\\n    for(int i = 0; i < 27; i++){\\n        freq[i] = 0;\\n    }"], ["int minDeletions(char * s){\\n    int freq[27];\\n    for(int i = 0; i < 27; i++){\\n        freq[i] = 0;\\n    }"]]}
{"id": "1320", "ref_c": [["int maxProfit(int* inventory, int inventorySize, int orders){\\n    // Get the maxium number of inventory\\n    int max = 0;\\n    int i;\\n    for (i=0; i<inventorySize; i++) {\\n        if (inventory[i] > max) {\\n            max = inventory[i];\\n        }"], ["int maxProfit(int* inventory, int inventorySize, int orders){\\n    // Get the maxium number of inventory\\n    int max = 0;\\n    int i;\\n    for (i=0; i<inventorySize; i++) {\\n        if (inventory[i] > max) {\\n            max = inventory[i];\\n        }"], ["int maxProfit(int* inventory, int inventorySize, int orders){\\n    // Get the maxium number of inventory\\n    int max = 0;\\n    int i;\\n    for (i=0; i<inventorySize; i++) {\\n        if (inventory[i] > max) {\\n            max = inventory[i];\\n        }"]]}
{"id": "1321", "ref_c": [["int minimumDeletions(char * s){\\n    \\n    int len = strlen(s);\\n    int c =  0,i;\\n    char * stack = (char*)malloc(sizeof(char) *(len+1));\\n    int top = -1;\\n    int flag = 0;\\n    for(i=0;i<len;i++)\\n    {\\n        if(flag > 0 && s[i] == \\'a\\')\\n        {\\n            flag--;\\n            c++;\\n            top--;\\n            continue;\\n        }"], ["int minimumDeletions(char * s){\\n    \\n    int len = strlen(s);\\n    int c =  0,i;\\n    char * stack = (char*)malloc(sizeof(char) *(len+1));\\n    int top = -1;\\n    int flag = 0;\\n    for(i=0;i<len;i++)\\n    {\\n        if(flag > 0 && s[i] == \\'a\\')\\n        {\\n            flag--;\\n            c++;\\n            top--;\\n            continue;\\n        }"], ["int minimumDeletions(char * s){\\n    \\n    int len = strlen(s);\\n    int c =  0,i;\\n    char * stack = (char*)malloc(sizeof(char) *(len+1));\\n    int top = -1;\\n    int flag = 0;\\n    for(i=0;i<len;i++)\\n    {\\n        if(flag > 0 && s[i] == \\'a\\')\\n        {\\n            flag--;\\n            c++;\\n            top--;\\n            continue;\\n        }"]]}
{"id": "1322", "ref_c": [["bool isValidSerialization(char * preorder){\\n    int slots = 1;\\n    bool isNull;\\n    while (*preorder){\\n        isNull = false;\\n\\t\\t// If the node is null, flip isNull to true\\n        while (*preorder && *preorder != \\',\\')\\n            if (*preorder++==\\'#\\') isNull = true;\\n        \\n\\t\\t// if we don\\'t have slots available, return false\\n        if (slots == 0) return false;\\n\\t\\t// else add or subtract depending on value of isNull\\n        slots += isNull ? -1 : 1;\\n        \\n        if (!*preorder) break;\\n        preorder++;\\n    }", "bool isValidSerialization(char * preorder){\\n    // initialize a char array, this is our stack (size is number of nodes in input)\\n    int idx = 1; // tracks value of head\\n    char *cur = preorder;\\n    while(*cur) if (*cur++ == \\',\\') idx++;\\n\\n    if (idx == 1) return(*preorder==\\'#\\');\\n    \\n\\t// create array large enough to hold all values\\n    char *arr = malloc(idx);\\n    \\n\\t// iterate over the string again, this time pushing/pulling to stack\\n    cur = preorder;\\n    idx = 0;\\n    while (*cur){\\n\\t    // push 0 or # to stack\\n        arr[idx] = \\'0\\';\\n        while (*cur && *cur != \\',\\')\\n            if (*cur++==\\'#\\') arr[idx] = \\'#\\';\\n\\t\\t\\n\\t\\t// if we have pushed two # in a row, pop three values and push a #\\n        while (idx >= 1 && arr[idx]==\\'#\\' && arr[idx-1]==\\'#\\'){\\n            arr[idx] = NULL;\\n            arr[idx-1] = NULL;\\n            idx -= 2;\\n            if (idx < 0) return false;\\n            arr[idx] = \\'#\\';\\n        }"], ["bool isValidSerialization(char * preorder){\\n    int slots = 1;\\n    bool isNull;\\n    while (*preorder){\\n        isNull = false;\\n\\t\\t// If the node is null, flip isNull to true\\n        while (*preorder && *preorder != \\',\\')\\n            if (*preorder++==\\'#\\') isNull = true;\\n        \\n\\t\\t// if we don\\'t have slots available, return false\\n        if (slots == 0) return false;\\n\\t\\t// else add or subtract depending on value of isNull\\n        slots += isNull ? -1 : 1;\\n        \\n        if (!*preorder) break;\\n        preorder++;\\n    }", "bool isValidSerialization(char * preorder){\\n    // initialize a char array, this is our stack (size is number of nodes in input)\\n    int idx = 1; // tracks value of head\\n    char *cur = preorder;\\n    while(*cur) if (*cur++ == \\',\\') idx++;\\n\\n    if (idx == 1) return(*preorder==\\'#\\');\\n    \\n\\t// create array large enough to hold all values\\n    char *arr = malloc(idx);\\n    \\n\\t// iterate over the string again, this time pushing/pulling to stack\\n    cur = preorder;\\n    idx = 0;\\n    while (*cur){\\n\\t    // push 0 or # to stack\\n        arr[idx] = \\'0\\';\\n        while (*cur && *cur != \\',\\')\\n            if (*cur++==\\'#\\') arr[idx] = \\'#\\';\\n\\t\\t\\n\\t\\t// if we have pushed two # in a row, pop three values and push a #\\n        while (idx >= 1 && arr[idx]==\\'#\\' && arr[idx-1]==\\'#\\'){\\n            arr[idx] = NULL;\\n            arr[idx-1] = NULL;\\n            idx -= 2;\\n            if (idx < 0) return false;\\n            arr[idx] = \\'#\\';\\n        }"], ["bool isValidSerialization(char * preorder){\\n    int slots = 1;\\n    bool isNull;\\n    while (*preorder){\\n        isNull = false;\\n\\t\\t// If the node is null, flip isNull to true\\n        while (*preorder && *preorder != \\',\\')\\n            if (*preorder++==\\'#\\') isNull = true;\\n        \\n\\t\\t// if we don\\'t have slots available, return false\\n        if (slots == 0) return false;\\n\\t\\t// else add or subtract depending on value of isNull\\n        slots += isNull ? -1 : 1;\\n        \\n        if (!*preorder) break;\\n        preorder++;\\n    }", "bool isValidSerialization(char * preorder){\\n    // initialize a char array, this is our stack (size is number of nodes in input)\\n    int idx = 1; // tracks value of head\\n    char *cur = preorder;\\n    while(*cur) if (*cur++ == \\',\\') idx++;\\n\\n    if (idx == 1) return(*preorder==\\'#\\');\\n    \\n\\t// create array large enough to hold all values\\n    char *arr = malloc(idx);\\n    \\n\\t// iterate over the string again, this time pushing/pulling to stack\\n    cur = preorder;\\n    idx = 0;\\n    while (*cur){\\n\\t    // push 0 or # to stack\\n        arr[idx] = \\'0\\';\\n        while (*cur && *cur != \\',\\')\\n            if (*cur++==\\'#\\') arr[idx] = \\'#\\';\\n\\t\\t\\n\\t\\t// if we have pushed two # in a row, pop three values and push a #\\n        while (idx >= 1 && arr[idx]==\\'#\\' && arr[idx-1]==\\'#\\'){\\n            arr[idx] = NULL;\\n            arr[idx-1] = NULL;\\n            idx -= 2;\\n            if (idx < 0) return false;\\n            arr[idx] = \\'#\\';\\n        }"]]}
{"id": "1323", "ref_c": [["bool closeStrings(char * word1, char * word2){\\n    int a1[26] = {0}"], ["bool closeStrings(char * word1, char * word2){\\n    int a1[26] = {0}"], ["bool closeStrings(char * word1, char * word2){\\n    int a1[26] = {0}"]]}
{"id": "1324", "ref_c": [["int minOperations(int* nums, int numsSize, int x) {\\n    int total = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        total += nums[i];\\n    }"], ["int minOperations(int* nums, int numsSize, int x) {\\n    int total = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        total += nums[i];\\n    }"], ["int minOperations(int* nums, int numsSize, int x) {\\n    int total = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        total += nums[i];\\n    }"]]}
{"id": "1325", "ref_c": [["char * getSmallestString(int n, int k){\\n    char* ans=(char*)calloc(n+1,sizeof(char));\\n    int currK;\\n    ans[n--] = \\'\\\\0\\';\\n    while(n>=0){\\n        currK = (k-n>=26)? 26 : k-n;\\n        ans[n--] = \\'a\\' + currK - 1;\\n        k -= currK;\\n    }"], ["char * getSmallestString(int n, int k){\\n    char* ans=(char*)calloc(n+1,sizeof(char));\\n    int currK;\\n    ans[n--] = \\'\\\\0\\';\\n    while(n>=0){\\n        currK = (k-n>=26)? 26 : k-n;\\n        ans[n--] = \\'a\\' + currK - 1;\\n        k -= currK;\\n    }"], ["char * getSmallestString(int n, int k){\\n    char* ans=(char*)calloc(n+1,sizeof(char));\\n    int currK;\\n    ans[n--] = \\'\\\\0\\';\\n    while(n>=0){\\n        currK = (k-n>=26)? 26 : k-n;\\n        ans[n--] = \\'a\\' + currK - 1;\\n        k -= currK;\\n    }"]]}
{"id": "1326", "ref_c": [["int waysToMakeFair(int* nums, int numsSize){\\n    int odd[numsSize], even[numsSize];\\n    bzero(odd, numsSize * sizeof(int));\\n    bzero(even, numsSize * sizeof(int));\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i == 0) {\\n            even[i] = nums[i];\\n        }"], ["int waysToMakeFair(int* nums, int numsSize){\\n    int result = 0, even_sum = 0, odd_sum = 0, even = 0, odd = 0;\\n    int *tmp = nums;\\n    while(tmp != nums + numsSize){\\n        if((tmp - nums) & 1) odd_sum += *tmp;\\n        else even_sum += *tmp;\\n        tmp++;\\n    }"], ["int waysToMakeFair(int* nums, int numsSize){\\n    int result = 0, even_sum = 0, odd_sum = 0, even = 0, odd = 0;\\n    int *tmp = nums;\\n    while(tmp != nums + numsSize){\\n        if((tmp - nums) & 1) odd_sum += *tmp;\\n        else even_sum += *tmp;\\n        tmp++;\\n    }"]]}
{"id": "1327", "ref_c": [["struct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){\\n    struct ListNode *locA=NULL,*locB=NULL,*tail,*temp,*dummy,*save;\\n    dummy=(struct ListNode *)malloc(sizeof(struct ListNode));\\n    dummy->next=list1;\\n    temp=list2;\\n    while(temp->next!=NULL)\\n    {\\n        temp=temp->next;\\n    }"], ["struct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){\\n    struct ListNode *locA=NULL,*locB=NULL,*tail,*temp,*dummy,*save;\\n    dummy=(struct ListNode *)malloc(sizeof(struct ListNode));\\n    dummy->next=list1;\\n    temp=list2;\\n    while(temp->next!=NULL)\\n    {\\n        temp=temp->next;\\n    }"], ["struct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){\\n    struct ListNode *locA=NULL,*locB=NULL,*tail,*temp,*dummy,*save;\\n    dummy=(struct ListNode *)malloc(sizeof(struct ListNode));\\n    dummy->next=list1;\\n    temp=list2;\\n    while(temp->next!=NULL)\\n    {\\n        temp=temp->next;\\n    }"]]}
{"id": "1329", "ref_c": [["int** kClosest(int** points, int pointsSize, int* pointsColSize, int k, int* returnSize, int** returnColumnSizes){\\n    \\n    int** data = (int**)malloc(k * sizeof(int*));\\n    for (int i = 0; i < k; i++) {\\n        data[i] = (int*)malloc(2 * sizeof(int));\\n    }"], ["int** kClosest(int** points, int pointsSize, int* pointsColSize, int k, int* returnSize, int** returnColumnSizes){\\n    \\n    int** data = (int**)malloc(k * sizeof(int*));\\n    for (int i = 0; i < k; i++) {\\n        data[i] = (int*)malloc(2 * sizeof(int));\\n    }"], ["int** kClosest(int** points, int pointsSize, int* pointsColSize, int k, int* returnSize, int** returnColumnSizes){\\n    \\n    int** data = (int**)malloc(k * sizeof(int*));\\n    for (int i = 0; i < k; i++) {\\n        data[i] = (int*)malloc(2 * sizeof(int));\\n    }"]]}
{"id": "1330", "ref_c": ["\nvector<int> exclusiveTime(int n, vector<string>& logs) {\n        vector<int> ans(n);\n        stack<pair<int,int>> cur;\n        int prevTime = 0;\n        for (auto& s : logs){\n            int num = stoi(s.substr(0, s.find(':')));\n            int time = stoi(s.substr(s.rfind(':') + 1));\n            if (s.find('e') != -1){\n                ans[num] += time - prevTime + 1;\n                cur.pop();\n                prevTime = time + 1;\n            }\n            else{\n                if (!cur.empty()) ans[cur.top().first] += time - prevTime ;\n                cur.push({num, time});\n                prevTime = time;\n            }\n        }\n        return ans;\n    }\n", "\nvector<int> exclusiveTime(int n, vector<string>& logs) {\n        vector<int> ans(n);\n        stack<pair<int,int>> cur;\n        int prevTime = 0;\n        for (auto& s : logs){\n            int num = stoi(s.substr(0, s.find(':')));\n            int time = stoi(s.substr(s.rfind(':') + 1));\n            if (s.find('e') != -1){\n                ans[num] += time - prevTime + 1;\n                cur.pop();\n                prevTime = time + 1;\n            }\n            else{\n                if (!cur.empty()) ans[cur.top().first] += time - prevTime ;\n                cur.push({num, time});\n                prevTime = time;\n            }\n        }\n        return ans;\n    }\n", "\nvector<int> exclusiveTime(int n, vector<string>& logs) {\n        vector<int> ans(n);\n        stack<pair<int,int>> cur;\n        int prevTime = 0;\n        for (auto& s : logs){\n            int num = stoi(s.substr(0, s.find(':')));\n            int time = stoi(s.substr(s.rfind(':') + 1));\n            if (s.find('e') != -1){\n                ans[num] += time - prevTime + 1;\n                cur.pop();\n                prevTime = time + 1;\n            }\n            else{\n                if (!cur.empty()) ans[cur.top().first] += time - prevTime ;\n                cur.push({num, time});\n                prevTime = time;\n            }\n        }\n        return ans;\n    }\n"]}
{"id": "1331", "ref_c": [["int maxOperations(int* nums, int numsSize, int k){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  k\\n     */\\n\\n    int ans = 0;\\n\\n    /* Sort nums by value in ascending order */\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    /* \\n     * Two pointers point to leftmost and rightmost \\n     * compare the sum of values and move the pointer accordingly\\n     */\\n    for (int i = 0, j = numsSize - 1; i < j; ) {\\n\\n        if (nums[i] + nums[j] > k) {\\n            j--;\\n        }"], ["int maxOperations(int* nums, int numsSize, int k){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  k\\n     */\\n\\n    int ans = 0;\\n\\n    /* Sort nums by value in ascending order */\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    /* \\n     * Two pointers point to leftmost and rightmost \\n     * compare the sum of values and move the pointer accordingly\\n     */\\n    for (int i = 0, j = numsSize - 1; i < j; ) {\\n\\n        if (nums[i] + nums[j] > k) {\\n            j--;\\n        }"], ["int maxOperations(int* nums, int numsSize, int k){\\n\\n  bool *used = calloc(numsSize, sizeof(bool));\\n  bucket **set = calloc(97, sizeof(bucket *));\\n  int count = 0;\\n\\n  for (int i = 0; i < numsSize; i++)\\n  {\\n    if (findDeleteOrInsert(nums[i], set, k)) count++;\\n  }"]]}
{"id": "1332", "ref_c": [["int concatenatedBinary(int n) {\\n        int length_b = 0;\\n        \\n        for (int i=1; i<=n; i++)\\n        {\\n            if ((i & (i - 1)) == 0)\\n                length_b++;\\n            sum = ((sum << length_b) + i) % MOD;\\n        }"], ["int concatenatedBinary(int n) {\\n     \\n        long long int i=1, k=1, z, sum = 1, bit, M = 1e9+7;\\n        \\n        while(i != n)\\n        {\\n            z = pow(2,k);\\n            bit = pow(2,k+1);\\n            k++;\\n    \\n            while(z-- && i != n)\\n            {\\n                i++;\\n                sum = ((sum*bit)%M + i)%M;\\n            }"], ["int concatenatedBinary(int n){\\n    long ans = 0;\\n    int k = 0;\\n    for (int i = 1 ; i <= n ; i++){\\n        if ((i & (i-1)) == 0){\\n            k++;\\n        }"]]}
{"id": "1333", "ref_c": [["int* getSumAbsoluteDifferences(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(numsSize * sizeof(int));\\n    *returnSize = numsSize;\\n\\n    int* prefixSum = (int*)malloc(numsSize * sizeof(int));\\n    int* suffixSum = (int*)malloc(numsSize * sizeof(int));\\n\\n    // Calculate and initialize the prefix sums & suffixSum array\\n    prefixSum[0] = nums[0];\\n    suffixSum[numsSize - 1] = nums[numsSize - 1];\\n\\n    // Calculate the prefix sums & suffixSum array in one loop\\n    for (int i = 1; i < numsSize; ++i) {\\n        prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        suffixSum[numsSize - i - 1] = suffixSum[numsSize - i] + nums[numsSize - i - 1];\\n    }"], ["int* getSumAbsoluteDifferences(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(numsSize * sizeof(int));\\n    *returnSize = numsSize;\\n\\n    int* prefixSum = (int*)malloc(numsSize * sizeof(int));\\n    int* suffixSum = (int*)malloc(numsSize * sizeof(int));\\n\\n    // Calculate and initialize the prefix sums & suffixSum array\\n    prefixSum[0] = nums[0];\\n    suffixSum[numsSize - 1] = nums[numsSize - 1];\\n\\n    // Calculate the prefix sums & suffixSum array in one loop\\n    for (int i = 1; i < numsSize; ++i) {\\n        prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        suffixSum[numsSize - i - 1] = suffixSum[numsSize - i] + nums[numsSize - i - 1];\\n    }"], ["int* getSumAbsoluteDifferences(int* nums, int numsSize, int* returnSize) {\\n    int* result = (int*)malloc(numsSize * sizeof(int));\\n    *returnSize = numsSize;\\n\\n    int* prefixSum = (int*)malloc(numsSize * sizeof(int));\\n    int* suffixSum = (int*)malloc(numsSize * sizeof(int));\\n\\n    // Calculate and initialize the prefix sums & suffixSum array\\n    prefixSum[0] = nums[0];\\n    suffixSum[numsSize - 1] = nums[numsSize - 1];\\n\\n    // Calculate the prefix sums & suffixSum array in one loop\\n    for (int i = 1; i < numsSize; ++i) {\\n        prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        suffixSum[numsSize - i - 1] = suffixSum[numsSize - i] + nums[numsSize - i - 1];\\n    }"]]}
{"id": "1334", "ref_c": [["int findPeakElement(int* nums, int numsSize){\\n    return getPeak(nums,0,numsSize - 1,0,numsSize - 1);\\n}"], ["int findPeakElement(int* nums, int numsSize){\\n    return getPeak(nums,0,numsSize - 1,0,numsSize - 1);\\n}"], ["int findPeakElement(int* nums, int numsSize){\\n    return getPeak(nums,0,numsSize - 1,0,numsSize - 1);\\n}"]]}
{"id": "1335", "ref_c": [["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"]]}
{"id": "1336", "ref_c": [["int stoneGameVII(int* stones, int stonesSize)\\n{\\n    int* prefixSum = (int*)malloc(sizeof(int) * (stonesSize + 1));\\n    prefixSum[0] = 0;\\n    int i;\\n    for(i = 0; i < stonesSize; i++)\\n        prefixSum[i + 1] = prefixSum[i] + stones[i];\\n    \\n    memset(dp, -1, sizeof(dp));\\n    return make_dp(0, stonesSize - 1, prefixSum);\\n}"], ["int stoneGameVII(int* stones, int stonesSize)\\n{\\n    int* prefixSum = (int*)malloc(sizeof(int) * (stonesSize + 1));\\n    prefixSum[0] = 0;\\n    int i;\\n    for(i = 0; i < stonesSize; i++)\\n        prefixSum[i + 1] = prefixSum[i] + stones[i];\\n    \\n    memset(dp, -1, sizeof(dp));\\n    return make_dp(0, stonesSize - 1, prefixSum);\\n}"], ["int stoneGameVII(int* stones, int stonesSize){\\n    int sum[1000];\\n    int list[1001][1001];\\n    sum[0] = stones[0];\\n    for (int i = 1 ; i < stonesSize ; i++){\\n        list[i-1][i] = stones[i-1] > stones[i] ? stones[i-1] : stones[i];\\n        sum[i] = sum[i-1]+stones[i];\\n    }"]]}
{"id": "1337", "ref_c": [["int maximumUniqueSubarray(int* nums, int numsSize){\\n    int map[N] = {0}"], ["int maximumUniqueSubarray(int* nums, int numsSize){\\n    int map[N] = {0}"], ["int maximumUniqueSubarray(int* nums, int numsSize){\\n\\n\\tint H[10001] = {0}"]]}
{"id": "1338", "ref_c": [["int maxResult(int* nums, int numsSize, int k){\\n\\n    /*\\n     * Input:\\n     *  nums, integer array\\n     *  numsSize, size of array\\n     *  k, most k steps in one move\\n     */\\n     \\n    /*\\n     * Algorithm:\\n     *\\n     *  Approach 1, dynamic programming only\\n     *             1  2  3  4  5  6\\n     *  nums    = [1,-1,-2, 4,-7, 3], k = 2\\n     *  dp      = [0, 0, 0, 0, 0, 0]\\n     *\\n     *  thre is only one way to reach 1st element, set dp[0] = 1\\n     *      dp = [1, 0, 0, 0, 0, 0]\\n     *  to reach 2nd element, we can jump from first element only, so dp[1] = dp[0] - 1\\n     *      dp = [1, 0, 0, 0, 0, 0]\\n     *  to reach 3rd element, we can jump from 1st or 2nd element, so dp[2] = MAX(dp[0], dp[1]) - 2\\n     *      dp = [1, 0, -1, 0, 0, 0]\\n     *  to reach 4th element, we can jump from 2nd or 3rd element, so dp[3] = MAX(dp[1], dp[2]) + 4\\n     *      dp = [1, 0, -1, 4, 0, 0]\\n     *  to reach 5th element, we can jump from 3rd or 4th element, so dp[4] = MAX(dp[2], dp[3]) - 7\\n     *      dp = [1, 0, -1, 4, -3, 0]\\n     *  to reach 6th element, we can jump from 4th or 5th element, so dp[5] = MAX(dp[3], dp[4]) + 3\\n     *      dp = [1, 0, -1, 4, -3, 7] \\n     *\\n     *  Since we have to scan all the elements in the array, and have to find the maximum score in \\n     *  previous k steps for each element, the time complexity of such a method is O(numsSize * K)\\n     *\\n     *  The time complexity can be optimized by introducing a monoqueue in the design.\\n     *\\n     */\\n\\n    int val;\\n    \\n    q_init();\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n    \\n        /* \\n         * Get previous maximal score from queue, \\n         * then update current score \\n         */\\n        if (q_empty() == false) {\\n            q_front(&val);\\n            nums[i] += nums[val];\\n        }"], ["int maxResult(int* nums, int numsSize, int k)\\n{\\n    struct rbuf rb = {.start = 0, .end = 0, .size = roundup_power2(k)}"], ["int maxResult(int* nums, int numsSize, int k){\\n    int* list = malloc(sizeof(int)*numsSize);\\n    int end = numsSize-1;\\n    list[end] = nums[end];\\n    int count = k;\\n    int best = list[end];\\n    int i = end-1;\\n    end = end-k < 0 ? -1 : end-k;\\n    \\n    for (; i > end ; i--){\\n        list[i] = nums[i] + best;\\n        if (nums[i] >= 0){\\n            best = list[i];\\n            count = k;\\n        }"]]}
{"id": "1339", "ref_c": [["double averageWaitingTime(int** customers, int customersSize, int* customersColSize){\\n    double waitingTimeSum = 0;\\n    int availableTime = -1;\\n    for(int i = 0; i < customersSize; i++){\\n        if(availableTime > customers[i][0]){\\n            availableTime += customers[i][1];\\n            waitingTimeSum += (availableTime - customers[i][0]);    \\n        }"], ["double averageWaitingTime(int** customers, int customersSize, int* customersColSize){\\n    int currentTimeUsed=0;\\n    int currentTime=0;\\n    for(int i=0; i<customersSize; i++){\\n        currentTime=max(currentTime,customers[i][0]);\\n        currentTime += customers[i][1];\\n        currentTimeUsed += currentTime-customers[i][0];\\n        \\n    }", "double averageWaitingTime(int** customers, int customersSize, int* customersColSize){\\n    long currentTimeUsed=0;\\n    long currentTime=0;\\n    for(int i=0; i<customersSize; i++){\\n        currentTime=max(currentTime,customers[i][0]);\\n        currentTime += customers[i][1];\\n        currentTimeUsed += currentTime-customers[i][0];\\n        \\n    }"], ["double averageWaitingTime(int** customers, int customersSize, int* customersColSize){\\n    double waitingTimeSum = 0;\\n    int availableTime = -1;\\n    for(int i = 0; i < customersSize; i++){\\n        if(availableTime > customers[i][0]){\\n            availableTime += customers[i][1];\\n            waitingTimeSum += (availableTime - customers[i][0]);    \\n        }"]]}
{"id": "1340", "ref_c": [["char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }"], ["char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }"], ["char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }"]]}
{"id": "1341", "ref_c": [["char * removeDuplicates(char * s, int k){\\n    int len = strlen(s), cnt = 0, sIdx = -1;\\n    char* st = (char*)calloc(len+1, sizeof(char));\\n    for(int i = 0; i < len; i++){\\n        st[++sIdx] = s[i];\\n        if(sIdx>0 && st[sIdx]==st[sIdx-1]){\\n            cnt++;\\n            if(cnt == k){\\n                sIdx -= k;\\n                int idx = sIdx;\\n                cnt = 1;\\n\\t\\t\\t\\t/* calculate how many same character at the beginning of the top after removing */\\n                while(idx > 0 && st[idx]==st[idx-1]){\\n                    idx--;\\n                    cnt++;\\n                }"], ["char * removeDuplicates(char * s, int k){\\n//keep track of substrings of s that are k number of duplicate letters\\n\\n//treat each new letter as 1st index(in a 1-indexed array) of   \\n//potential duplicate substring\\n\\n//with each consecutive repeated letter the index of the substring\\n//increases\\n\\n//reduce idx by k amount when the index of the substring reaches k\\n    char* ans = malloc((strlen(s) + 1) * sizeof(char));\\n    int* dup = malloc(strlen(s) * sizeof(int));\\n    int idx = 0;\\n\\n    for(int i = 0; i < strlen(s); i++) {\\n        ans[idx] = s[i];\\n        dup[idx] = 1;\\n        if(idx != 0 && ans[idx] == ans[idx-1]) {\\n            dup[idx] = dup[idx-1] + 1;\\n        }"], ["char * removeDuplicates(char * s, int k){\\n    int len = strlen(s), cnt = 0, sIdx = -1;\\n    char* st = (char*)calloc(len+1, sizeof(char));\\n    for(int i = 0; i < len; i++){\\n        st[++sIdx] = s[i];\\n        if(sIdx>0 && st[sIdx]==st[sIdx-1]){\\n            cnt++;\\n            if(cnt == k){\\n                sIdx -= k;\\n                int idx = sIdx;\\n                cnt = 1;\\n\\t\\t\\t\\t/* calculate how many same character at the beginning of the top after removing */\\n                while(idx > 0 && st[idx]==st[idx-1]){\\n                    idx--;\\n                    cnt++;\\n                }"]]}
{"id": "1342", "ref_c": [["int* findBall(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    int i = 0, j = 0;\\n    int* output = (int*)malloc(sizeof(int)*gridColSize[0]);\\n    int cur_x = 0, cur_y = 0;\\n    for (i = 0; i < gridColSize[0]; i++) {\\n        output[i] = -1;\\n        if (i == 0 && grid[0][i] == -1) {\\n            continue;\\n        }"], ["int* findBall(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    int* ans = (int*)calloc(*gridColSize, sizeof(int));\\n    for(int i = 0; i < *gridColSize; i++){\\n        ans[i] = DFS(grid, gridSize, *gridColSize, 0, i);\\n    }"], ["int* findBall(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    // How many column as how many balls\\n    int *ball = (int*)malloc(sizeof(int)*(*gridColSize));\\n    *returnSize = *gridColSize;\\n\\n    for(int col = 0; col < *gridColSize; col++) {\\n        ball[col] = visit(grid, 0, col, gridSize, gridColSize);\\n    }"]]}
{"id": "1343", "ref_c": [["char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }"], ["char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }"], ["char ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }"]]}
{"id": "1344", "ref_c": [["void solve(char** board, int boardSize, int* boardColSize){\\n    for (int i = 0; i < boardSize; i++)\\n        for (int j = 0; j < *boardColSize; j++)\\n            if (board[i][j] == \\'O\\')\\n            {\\n                bool sur = true;\\n                changeChar(board, i, j, boardSize, *boardColSize, &sur);\\n                if (sur)                                                    // the changeChar function will change sur to false\\n                    capture(board, i, j);                                   // if it encoutners an edge. If this doesn\\'t \\n            }"], ["void solve(char** board, int boardSize, int* boardColSize){\\n    int i, j, m = boardSize, n = *boardColSize;\\n\\n    bool **visited = (bool**)calloc(sizeof(bool*), m);\\n\\n    for (i = 0; i < m; i++)\\n        visited[i] = (bool*)calloc(sizeof(bool), n);\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++) {\\n            if (board[i][j] == \\'O\\' && (i == m - 1 || j == n - 1 || i == 0 || j == 0)) {\\n                helper(i, j, m, n, board, visited);\\n            }"], ["void solve(char** board, int boardSize, int* boardColSize){\\n    int i, j, m = boardSize, n = *boardColSize;\\n\\n    bool **visited = (bool**)calloc(sizeof(bool*), m);\\n\\n    for (i = 0; i < m; i++)\\n        visited[i] = (bool*)calloc(sizeof(bool), n);\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++) {\\n            if (board[i][j] == \\'O\\' && (i == m - 1 || j == n - 1 || i == 0 || j == 0)) {\\n                helper(i, j, m, n, board, visited);\\n            }"]]}
{"id": "1345", "ref_c": [["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"]]}
{"id": "1346", "ref_c": [["int findMaxK(int* nums, int numsSize) {\\n    char set[1001];\\n    memset(set,0,1001);\\n\\n    for (int i=0;i<numsSize;i++)\\n        if (nums[i]>0) {\\n            set[nums[i]] |= 1;\\n        }"], ["int findMaxK(int* nums, int numsSize)\\n{\\n    int x;\\n    int b;\\n    int ret;\\n\\n    ret = -1;\\n    for (x = 0; x < numsSize; x++)\\n    {\\n        if (nums[x] < 0)\\n        {\\n            for (b = 0; b < numsSize; b++)\\n            {\\n                if (-(nums[x]) == nums[b] && x != b)\\n                {\\n                    if (ret < nums[b])\\n                        ret = nums[b];\\n                }"], ["int findMaxK(int* nums, int numsSize) {\\n    char set[1001];\\n    memset(set,0,1001);\\n\\n    for (int i=0;i<numsSize;i++)\\n        if (nums[i]>0) {\\n            set[nums[i]] |= 1;\\n        }"]]}
{"id": "1347", "ref_c": [["struct ListNode* swapNodes(struct ListNode* head, int k){\\n    int n = k-1;\\n    int len = 0;\\n    struct ListNode *first_idx = head;\\n    while(n){\\n        first_idx = first_idx->next;\\n        n--;\\n        len++;\\n    }"], ["struct ListNode* swapNodes(struct ListNode* head, int k){\\n    int n = k-1;\\n    int len = 0;\\n    struct ListNode *first_idx = head;\\n    while(n){\\n        first_idx = first_idx->next;\\n        n--;\\n        len++;\\n    }"], ["struct ListNode* swapNodes(struct ListNode* head, int k) {\\n    struct ListNode dummy;\\n    dummy.next = head;\\n\\n    struct ListNode* fast = &dummy;\\n    struct ListNode* slow = &dummy;\\n    struct ListNode* first = &dummy;\\n    struct ListNode* second = &dummy;\\n\\n    // Move fast pointer to the kth node from the beginning\\n    for (int i = 0; i < k; i++) {\\n        if (fast->next == NULL) {\\n            return head; // Invalid k, no change in the list\\n        }"]]}
{"id": "1348", "ref_c": [["int orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize){\\n    // edge case:\\n    if(n * n == minesSize)\\n        return 0;\\n\\n    int mat[n][n][5];\\n    memset(mat, 0, n*n*5*sizeof(int));\\n    for(int i = 0; i < minesSize; i++){\\n        mat[mines[i][0]][mines[i][1]][0] = 1;\\n    }"], ["int orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize){\\n    int ** temp = (int **)malloc(n*sizeof(int *));\\n    for(int i=0; i<n; i++)\\n    {\\n        temp[i] = (int *)malloc(n*sizeof(int));\\n        for(int j=0; j<n; j++)\\n            temp[i][j] = 1;\\n    }"], ["int orderOfLargestPlusSign(int n, int** mines, int minesSize, int* minesColSize){\\n    // edge case:\\n    if(n * n == minesSize)\\n        return 0;\\n\\n    int mat[n][n][5];\\n    memset(mat, 0, n*n*5*sizeof(int));\\n    for(int i = 0; i < minesSize; i++){\\n        mat[mines[i][0]][mines[i][1]][0] = 1;\\n    }"]]}
{"id": "1349", "ref_c": [["int tupleSameProduct(int* nums, int numsSize) {\\n    // Brute force\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(100000000)\\n\\n    int result = 0;\\n    int* count = (int*)calloc(100000000, sizeof(int));\\n    for (int i = 0; i < numsSize; ++i) {\\n        for (int j = 0; j < i; ++j) {\\n            const int product = nums[i] * nums[j];\\n            result += (count[product] * 8);\\n            count[product]++;\\n        }"], ["int tupleSameProduct(int* nums, int numsSize) {\\n    // Brute force\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(100000000)\\n\\n    int result = 0;\\n    int* count = (int*)calloc(100000000, sizeof(int));\\n    for (int i = 0; i < numsSize; ++i) {\\n        for (int j = 0; j < i; ++j) {\\n            const int product = nums[i] * nums[j];\\n            result += (count[product] * 8);\\n            count[product]++;\\n        }"], ["int tupleSameProduct(int* nums, int numsSize) {\\n    // Brute force\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(100000000)\\n\\n    int result = 0;\\n    int* count = (int*)calloc(100000000, sizeof(int));\\n    for (int i = 0; i < numsSize; ++i) {\\n        for (int j = 0; j < i; ++j) {\\n            const int product = nums[i] * nums[j];\\n            result += (count[product] * 8);\\n            count[product]++;\\n        }"]]}
{"id": "1350", "ref_c": [["int largestSubmatrix(int** matrix, int matrixSize, int* matrixColSize) {\\n\\n    /*\\n     * Input:\\n     *  **matrix\\n     *  matrixSize\\n     *  *matrixColSize\\n     */\\n\\n    int **ones = (int **)malloc(sizeof(int *) * matrixSize), ans = 0;\\n\\n    for (int i = 0; i < matrixSize; i++) {\\n        ones[i] = (int *)malloc(sizeof(int) * matrixColSize[i]);\\n    }"], ["int largestSubmatrix(int** matrix, int matrixSize, int* matrixColSize) {\\n\\n    /*\\n     * Input:\\n     *  **matrix\\n     *  matrixSize\\n     *  *matrixColSize\\n     */\\n\\n    int **ones = (int **)malloc(sizeof(int *) * matrixSize), ans = 0;\\n\\n    for (int i = 0; i < matrixSize; i++) {\\n        ones[i] = (int *)malloc(sizeof(int) * matrixColSize[i]);\\n    }"], ["int largestSubmatrix(int** matrix, int matrixSize, int* matrixColSize) {\\n\\n    /*\\n     * Input:\\n     *  **matrix\\n     *  matrixSize\\n     *  *matrixColSize\\n     */\\n\\n    int **ones = (int **)malloc(sizeof(int *) * matrixSize), ans = 0;\\n\\n    for (int i = 0; i < matrixSize; i++) {\\n        ones[i] = (int *)malloc(sizeof(int) * matrixColSize[i]);\\n    }"]]}
{"id": "1351", "ref_c": [["char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){\\n\\n    int i, min_sum = INT_MAX;\\n    myHashTable_t *words = NULL;\\n    myHashTable_t *element;\\n\\n    for (i=0; i<list1Size; i++)\\n    {\\n        element = (myHashTable_t*)malloc(sizeof(*element));\\n        strcpy(element->word, list1[i]);\\n        element->index_1 = i;\\n        HASH_ADD_STR(words, word, element);\\n    }"], ["char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){\\n\\n    int i, min_sum = INT_MAX;\\n    myHashTable_t *words = NULL;\\n    myHashTable_t *element;\\n\\n    for (i=0; i<list1Size; i++)\\n    {\\n        element = (myHashTable_t*)malloc(sizeof(*element));\\n        strcpy(element->word, list1[i]);\\n        element->index_1 = i;\\n        HASH_ADD_STR(words, word, element);\\n    }"], ["char ** findRestaurant(char ** list1, int list1Size, char ** list2, int list2Size, int* returnSize){\\n\\n    int i, min_sum = INT_MAX;\\n    myHashTable_t *words = NULL;\\n    myHashTable_t *element;\\n\\n    for (i=0; i<list1Size; i++)\\n    {\\n        element = (myHashTable_t*)malloc(sizeof(*element));\\n        strcpy(element->word, list1[i]);\\n        element->index_1 = i;\\n        HASH_ADD_STR(words, word, element);\\n    }"]]}
{"id": "1352", "ref_c": [["int* decode(int* encoded, int encodedSize, int* returnSize){\\n    int i, x = 0, n = encodedSize, j = 1;\\n\\n    for (i = 1; i <= n + 1; i++) \\n        x ^= i;\\n    \\n    for (i = 1; i < n ; i += 2)\\n        x ^= encoded[i];\\n\\n    int *result = calloc(n + 1, sizeof(int));\\n    result[0] = x;\\n\\n    for (i = 0; i < n; i++)\\n        result[i + 1] = result[i] ^ encoded[i];\\n\\n    *returnSize = n + 1;\\n    return result;\\n}"], ["int* decode(int* encoded, int encodedSize, int* returnSize){\\n    int i, x = 0, n = encodedSize, j = 1;\\n\\n    for (i = 1; i <= n + 1; i++) \\n        x ^= i;\\n    \\n    for (i = 1; i < n ; i += 2)\\n        x ^= encoded[i];\\n\\n    int *result = calloc(n + 1, sizeof(int));\\n    result[0] = x;\\n\\n    for (i = 0; i < n; i++)\\n        result[i + 1] = result[i] ^ encoded[i];\\n\\n    *returnSize = n + 1;\\n    return result;\\n}"], ["int* decode(int* encoded, int encodedSize, int* returnSize){\\n    int i, x = 0, n = encodedSize, j = 1;\\n\\n    for (i = 1; i <= n + 1; i++) \\n        x ^= i;\\n    \\n    for (i = 1; i < n ; i += 2)\\n        x ^= encoded[i];\\n\\n    int *result = calloc(n + 1, sizeof(int));\\n    result[0] = x;\\n\\n    for (i = 0; i < n; i++)\\n        result[i + 1] = result[i] ^ encoded[i];\\n\\n    *returnSize = n + 1;\\n    return result;\\n}"]]}
{"id": "1353", "ref_c": [["int maxDepth(struct Node* root) {\\n    if (root == NULL) {\\n        return 0;\\n    }"], ["int maxDepth(struct Node* root) {\\n    if (root == NULL) {\\n        return 0;\\n    }"], ["int maxDepth(struct Node* root) {\\n    return depth(root);\\n}"]]}
{"id": "1354", "ref_c": [["int kthLargestValue(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    int map[matrixSize*(*matrixColSize)];\\n    int idx=0;\\n    for(int row=0;row<matrixSize;row++){\\n        for(int col=0;col<*matrixColSize;col++){\\n            if(col>0) matrix[row][col]^=matrix[row][col-1];\\n            if(row>0) matrix[row][col]^=matrix[row-1][col];\\n            if(row>0 && col>0) matrix[row][col]^=matrix[row-1][col-1];\\n            map[idx++]=matrix[row][col];\\n        }"], ["int kthLargestValue(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    int map[matrixSize*(*matrixColSize)];\\n    int idx=0;\\n    for(int row=0;row<matrixSize;row++){\\n        for(int col=0;col<*matrixColSize;col++){\\n            if(col>0) matrix[row][col]^=matrix[row][col-1];\\n            if(row>0) matrix[row][col]^=matrix[row-1][col];\\n            if(row>0 && col>0) matrix[row][col]^=matrix[row-1][col-1];\\n            map[idx++]=matrix[row][col];\\n        }"], ["int kthLargestValue(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    int map[matrixSize*(*matrixColSize)];\\n    int idx=0;\\n    for(int row=0;row<matrixSize;row++){\\n        for(int col=0;col<*matrixColSize;col++){\\n            if(col>0) matrix[row][col]^=matrix[row][col-1];\\n            if(row>0) matrix[row][col]^=matrix[row-1][col];\\n            if(row>0 && col>0) matrix[row][col]^=matrix[row-1][col-1];\\n            map[idx++]=matrix[row][col];\\n        }"]]}
{"id": "1355", "ref_c": [["int* restoreArray(int** adjacentPairs, int adjacentPairsSize, int* adjacentPairsColSize, int* returnSize) {\\n    // Create the graph and add edges\\n    int numVertices = adjacentPairsSize + 1;\\n    struct Graph* graph = createGraph(numVertices);\\n    for (int i = 0; i < adjacentPairsSize; ++i) {\\n        addEdge(graph, adjacentPairs[i][0], adjacentPairs[i][1]);\\n    }", "int* restoreArray(int** adjacentPairs, int adjacentPairsSize, int* adjacentPairsColSize, int* returnSize) {\\n    // Create the graph and add edges\\n    int numVertices = adjacentPairsSize + 1;\\n    struct Graph* graph = createGraph(numVertices);\\n    for (int i = 0; i < adjacentPairsSize; ++i) {\\n        addEdge(graph, adjacentPairs[i][0], adjacentPairs[i][1]);\\n    }"], ["int* restoreArray(int** adjacentPairs, int adjacentPairsSize, int* adjacentPairsColSize, int* returnSize) {\\n    // Create the graph and add edges\\n    int numVertices = adjacentPairsSize + 1;\\n    struct Graph* graph = createGraph(numVertices);\\n    for (int i = 0; i < adjacentPairsSize; ++i) {\\n        addEdge(graph, adjacentPairs[i][0], adjacentPairs[i][1]);\\n    }", "int* restoreArray(int** adjacentPairs, int adjacentPairsSize, int* adjacentPairsColSize, int* returnSize) {\\n    // Create the graph and add edges\\n    int numVertices = adjacentPairsSize + 1;\\n    struct Graph* graph = createGraph(numVertices);\\n    for (int i = 0; i < adjacentPairsSize; ++i) {\\n        addEdge(graph, adjacentPairs[i][0], adjacentPairs[i][1]);\\n    }"], ["int* restoreArray(int** adjacentPairs, int adjacentPairsSize, int* adjacentPairsColSize, int* returnSize) {\\n    /* Numbers between -1e5 and 1e5 */\\n    int **graph = (int **)calloc((2 * 1e5 + 1), sizeof(int *));\\n    int *v_size = (int *)calloc((2 * 1e5 + 1), sizeof(int));\\n    if (!graph || !v_size) {\\n        char *msg = \"Memory cannot be initialized\";\\n        ferror(msg);\\n        exit(-1);\\n    }"]]}
{"id": "1356", "ref_c": [["int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize){\\n    int n = matrixSize;\\n    int DP[n][n];\\n    for (int col = 0; col < n; col++)\\n        DP[0][col] = matrix[0][col];\\n        \\n    for (int row = 1; row < n; row++){\\n        for (int col = 0; col < n; col++){\\n            if (col == 0)\\n                DP[row][0] = matrix[row][0] + MIN(DP[row-1][0], DP[row-1][1]);\\n            else if (col == n-1)\\n                DP[row][n-1] = matrix[row][n-1] + MIN(DP[row-1][n-1], DP[row-1][n-2]);\\n            else\\n                DP[row][col] = matrix[row][col] + MIN(DP[row-1][col], MIN(DP[row-1][col-1], DP[row-1][col+1]));\\n        }"], ["int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize)\\n{\\n    G = matrix;\\n    N = matrixSize;\\n    int minsum = INVALID;\\n\\n    // Reset memo\\n    for (int i = 0; i < N; i++)\\n        for (int j = 0; j < N; j++)\\n            memo[i][j] = INVALID;\\n\\n    // For each column 0 to N-1\\n    for (int j = 0; j < N; j++)\\n    {\\n        // DFS runs downwards along rows\\n        minsum = min (minsum, dfs (0, j));\\n    }"], ["int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize)\\n{\\n    G = matrix;\\n    N = matrixSize;\\n    int minsum = INVALID;\\n\\n    // Reset memo\\n    for (int i = 0; i < N; i++)\\n        for (int j = 0; j < N; j++)\\n            memo[i][j] = INVALID;\\n\\n    // For each column 0 to N-1\\n    for (int j = 0; j < N; j++)\\n    {\\n        // DFS runs downwards along rows\\n        minsum = min (minsum, dfs (0, j));\\n    }"]]}
{"id": "1357", "ref_c": [["int maxAbsoluteSum(int* nums, int numsSize) {\\n        // Kadane\\'s algorithm\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        const int n = numsSize;\\n        int result = INT_MIN, maxSum = 0, minSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            maxSum = max(nums[i], maxSum + nums[i]);\\n            minSum = min(nums[i], minSum + nums[i]);\\n            result = max(result, max(maxSum, -minSum));\\n        }", "int maxAbsoluteSum(int* nums, int numsSize) {\\n        // Heuristic DP \\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        const int n = numsSize;\\n        int sum = 0, maxPrefix = 0, minPrefix = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            maxPrefix = max(maxPrefix, sum);\\n            minPrefix = min(minPrefix, sum);\\n        }"], ["int maxAbsoluteSum(int* nums, int numsSize) {\\n        // Kadane\\'s algorithm\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        const int n = numsSize;\\n        int result = INT_MIN, maxSum = 0, minSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            maxSum = max(nums[i], maxSum + nums[i]);\\n            minSum = min(nums[i], minSum + nums[i]);\\n            result = max(result, max(maxSum, -minSum));\\n        }", "int maxAbsoluteSum(int* nums, int numsSize) {\\n        // Heuristic DP \\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        const int n = numsSize;\\n        int sum = 0, maxPrefix = 0, minPrefix = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            maxPrefix = max(maxPrefix, sum);\\n            minPrefix = min(minPrefix, sum);\\n        }"], ["int maxAbsoluteSum(int* nums, int numsSize) {\\n        // Kadane\\'s algorithm\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        const int n = numsSize;\\n        int result = INT_MIN, maxSum = 0, minSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            maxSum = max(nums[i], maxSum + nums[i]);\\n            minSum = min(nums[i], minSum + nums[i]);\\n            result = max(result, max(maxSum, -minSum));\\n        }", "int maxAbsoluteSum(int* nums, int numsSize) {\\n        // Heuristic DP \\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        const int n = numsSize;\\n        int sum = 0, maxPrefix = 0, minPrefix = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            maxPrefix = max(maxPrefix, sum);\\n            minPrefix = min(minPrefix, sum);\\n        }"]]}
{"id": "1358", "ref_c": [["bool isPerfectSquare(int num){\\n    int count=0;\\n    double x=1;\\n    while(count!=20)\\n    {\\n        x=(x+num/x)*0.5;\\n        count++;\\n    }"], ["bool isPerfectSquare(int num) {\\n    if (num < 0) {\\n        return false;\\n    }"], ["bool isPerfectSquare(int num) {\\n        unsigned int i = 1;\\n        while(i*i<num) i++;\\n        return (i*i == num);\\n    }"]]}
{"id": "1359", "ref_c": [["int maximumScore(int a, int b, int c){\\n\\n    if(a>b+c)\\n        return b+c;\\n    if(b>a+c)\\n        return a+c;\\n    if(c>a+b)\\n        return a+b;\\n    return (a+b+c)/2;\\n}"], ["int maximumScore(int a, int b, int c) {\\n\\n        if (c >= a+b) return a+b;\\n        if (a >= b+c) return b+c;\\n        if (b >= a+c) return a+c;\\n        if (c < a+b) return (a+b+c)/2;\\n        return 0;\\n    }", "int maximumScore(int a, int b, int c) {\\n        vector<vector<vector<int>>> dp(a+2, vector<vector<int>>(b+2, vector<int>(c+2, -1)));\\n        return solve(a, b, c, dp);\\n    }"], ["int maximumScore(int a, int b, int c){\\n    int sum = a + b + c;\\n    int mx = max (a, max (b, c));\\n\\n    return min (sum - mx, sum / 2);\\n}"]]}
{"id": "1360", "ref_c": [["char * largestMerge(char * word1, char * word2){\\n    int i=0, j, L = strlen(word1) + strlen(word2) + 1;\\n    char c, *merge = malloc(L * sizeof(char));\\n    merge[L-1] = \\'\\\\0\\';\\n    while(1) {\\n        if (*word1 == \\'\\\\0\\') {\\n            while(*word2 != \\'\\\\0\\') {\\n                merge[i++] = *word2;\\n                ++word2;\\n            }"], ["char * largestMerge(char * word1, char * word2){\\n    int i=0, j, L = strlen(word1) + strlen(word2) + 1;\\n    char c, *merge = malloc(L * sizeof(char));\\n    merge[L-1] = \\'\\\\0\\';\\n    while(1) {\\n        if (*word1 == \\'\\\\0\\') {\\n            while(*word2 != \\'\\\\0\\') {\\n                merge[i++] = *word2;\\n                ++word2;\\n            }"], ["char * largestMerge(char * word1, char * word2){\\n    int i=0, j, L = strlen(word1) + strlen(word2) + 1;\\n    char c, *merge = malloc(L * sizeof(char));\\n    merge[L-1] = \\'\\\\0\\';\\n    while(1) {\\n        if (*word1 == \\'\\\\0\\') {\\n            while(*word2 != \\'\\\\0\\') {\\n                merge[i++] = *word2;\\n                ++word2;\\n            }"]]}
{"id": "1361", "ref_c": [["int countHomogenous(char * s){\\n    int mod = pow(10, 9) + 7;\\n    long long result=0, count=1;\\n    for(int i=1; i<strlen(s); i++)\\n    {\\n        if(s[i] == s[i-1])\\n        {\\n            count++;\\n        }"], ["int countHomogenous(char * s){\\n    int n=strlen(s);\\n    char prev=\\'X\\';\\n    int count=0;\\n    long long ans=0;\\n    for(register i=0; i<n; i++){\\n        if (s[i]!=prev){\\n            ans=(ans+(long long)count*(count+1)/2%mod);\\n            count=1;\\n        }"], ["int countHomogenous(char * s){\\n    int mod = pow(10, 9) + 7;\\n    long long result=0, count=1;\\n    for(int i=1; i<strlen(s); i++)\\n    {\\n        if(s[i] == s[i-1])\\n        {\\n            count++;\\n        }"]]}
{"id": "1362", "ref_c": [["int minimumSize(int* nums, int numsSize, int maxOperations){\\n    int l=1, r=0, m;\\n    for(int i=0;i<numsSize;i++){\\n        r=max(r,nums[i]);\\n    }"], ["int minimumSize(int* nums, int numsSize, int maxOperations){\\n    int l=1, r=0, m;\\n    for(int i=0;i<numsSize;i++){\\n        r=max(r,nums[i]);\\n    }"], ["int minimumSize(int* nums, int numsSize, int maxOperations){\\n    int l=1, r=0, m;\\n    for(int i=0;i<numsSize;i++){\\n        r=max(r,nums[i]);\\n    }"]]}
{"id": "1363", "ref_c": [["bool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int *table = (int*)calloc(numsSize,sizeof(int));\\n    \\n    int flag = 0;\\n    int counter = 0;\\n    \\n    for(int x = 0; x<groupsSize; x++){\\n        flag=0;\\n\\n        for(int z=counter; z<numsSize; z++){\\n            if(flag == 1){\\n                if(x== (groupsSize-1))\\n                    return true;        \\n                break;\\n            }"], ["bool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int *table = (int*)calloc(numsSize,sizeof(int));\\n    \\n    int flag = 0;\\n    int counter = 0;\\n    \\n    for(int x = 0; x<groupsSize; x++){\\n        flag=0;\\n\\n        for(int z=counter; z<numsSize; z++){\\n            if(flag == 1){\\n                if(x== (groupsSize-1))\\n                    return true;        \\n                break;\\n            }"], ["bool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int *table = (int*)calloc(numsSize,sizeof(int));\\n    \\n    int flag = 0;\\n    int counter = 0;\\n    \\n    for(int x = 0; x<groupsSize; x++){\\n        flag=0;\\n\\n        for(int z=counter; z<numsSize; z++){\\n            if(flag == 1){\\n                if(x== (groupsSize-1))\\n                    return true;        \\n                break;\\n            }"]]}
{"id": "1364", "ref_c": [["int** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\\n    int i, j;\\n    head = NULL;\\n    tail = NULL;\\n\\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<*isWaterColSize;j++){\\n            if(isWater[i][j])\\n                queue_land(i,j,0);\\n        }"], ["int** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\\n    int i, j;\\n    head = NULL;\\n    tail = NULL;\\n\\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<*isWaterColSize;j++){\\n            if(isWater[i][j])\\n                queue_land(i,j,0);\\n        }"], ["int** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\\n    int i, j;\\n    head = NULL;\\n    tail = NULL;\\n\\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<*isWaterColSize;j++){\\n            if(isWater[i][j])\\n                queue_land(i,j,0);\\n        }"]]}
{"id": "1365", "ref_c": [["int* minOperations(char * boxes, int* returnSize){\\n    int len = strlen(boxes);\\n    int *result = (int *)malloc(len*sizeof(int));\\n    for(int i=0; i<len; i++){\\n        int temp = 0;\\n        for(int j=0; j<len; j++){\\n            if(boxes[j] == \\'1\\'){\\n                temp += mod(i-j);\\n            }"], ["int* minOperations(char * boxes, int* returnSize){\\n    int length = strlen(boxes);\\n    int *res = (int *)calloc(sizeof(int), length);\\n    *returnSize = length;\\n\\n    for (int i = 0; i < length; i++){\\n        if (boxes[i] == \\'1\\'){\\n            for (int j = 0; j < length; j++){\\n                if (i != j){\\n                    res[j] += abs(i-j);\\n                }"], ["int* minOperations(char * boxes, int* returnSize){\\n    int n=strlen(boxes);\\n    int *left=calloc(n,sizeof(int));\\n    int *right=calloc(n,sizeof(int));\\n    int count=boxes[0]-\\'0\\'; // count is count 1 number\\n    for(int i=1;i<n;i++){\\n        left[i]+=(left[i-1]+count);\\n        count+=boxes[i]-\\'0\\';\\n    }"]]}
{"id": "1366", "ref_c": [["int* twoSum(int* nums, int numsSize, int target, int* returnSize){\\n\\n*returnSize=2;// der zu returnende array hat 2 elemente\\n\\nint *array = malloc(2*sizeof(int) ); // Output array max 2 elemente\\n\\nfor (int i=0; i<numsSize;i++)\\n{\\n    for( int j=1+i;j<numsSize;j++)\\n    {\\n        if(nums[i] + nums[j] == target)\\n        {\\n        array[0]=i;\\n        array[1]=j;\\n        return array;\\n        }"], ["int* twoSum(int* nums, int numsSize, int target, int* returnSize) {\\n    int* result = (int*)malloc(2 * sizeof(int)); // Allocate memory for the result array\\n    if (result == NULL) {\\n        *returnSize = 0;\\n        return NULL; // Return NULL if memory allocation fails\\n    }"], ["int* twoSum(int* nums, int numsSize, int target, int* returnSize){\\n\\n*returnSize=2;// der zu returnende array hat 2 elemente\\n\\nint *array = malloc(2*sizeof(int) ); // Output array max 2 elemente\\n\\nfor (int i=0; i<numsSize;i++)\\n{\\n    for( int j=1+i;j<numsSize;j++)\\n    {\\n        if(nums[i] + nums[j] == target)\\n        {\\n        array[0]=i;\\n        array[1]=j;\\n        return array;\\n        }"]]}
{"id": "1367", "ref_c": [["int minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int sum1 = 0, sum2 = 0;\\n    \\n    for (int i = 0; i < nums1Size; ++i) {\\n        sum1 += nums1[i];\\n    }"], ["int minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int sum1 = 0, sum2 = 0;\\n    \\n    for (int i = 0; i < nums1Size; ++i) {\\n        sum1 += nums1[i];\\n    }"], ["int minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int sum1 = 0, sum2 = 0;\\n    \\n    for (int i = 0; i < nums1Size; ++i) {\\n        sum1 += nums1[i];\\n    }"]]}
{"id": "1368", "ref_c": [["bool checkPowersOfThree(int n){\\n    while(n!=0){\\n        if(n%3==2){\\n            return false;\\n        }"], ["bool checkPowersOfThree(int n) {\\n    int a;\\n      while(n>0){\\n          a=n%3;\\n          if(a!=2){\\n              n/=3;\\n          }"], ["bool checkPowersOfThree(int n) {\\n    \\n    while(n!=0){\\n        \\n        if(n%3==0){\\n            return false;\\n        }"]]}
{"id": "1369", "ref_c": [["int beautySum(char * s) {\\n    int len;\\n    int i;\\n    int j;\\n    int result;\\n    \\n    len = strlen(s);\\n    if (len < 3) {\\n        return 0;\\n    }"], ["int beautySum(char * s) {\\n    int len;\\n    int i;\\n    int j;\\n    int result;\\n    \\n    len = strlen(s);\\n    if (len < 3) {\\n        return 0;\\n    }"], ["int beautySum(char * s) {\\n    int len;\\n    int i;\\n    int j;\\n    int result;\\n    \\n    len = strlen(s);\\n    if (len < 3) {\\n        return 0;\\n    }"]]}
{"id": "1370", "ref_c": [["int minElements(int* nums, int numsSize, int limit, int goal){\\n\\n    long long int sum=0;\\n    for(int i=0;i<numsSize;i++)\\n        sum=sum+nums[i];\\n    \\n    long long int z=sum-goal;\\n    if(z<0)z=z*(-1);\\n    if(z%limit>0)return z/limit+1;\\n    return z/limit;\\n}"], ["int minElements(int* nums, int numsSize, int limit, int goal){\\n\\n    long long int sum=0;\\n    for(int i=0;i<numsSize;i++)\\n        sum=sum+nums[i];\\n    \\n    long long int z=sum-goal;\\n    if(z<0)z=z*(-1);\\n    if(z%limit>0)return z/limit+1;\\n    return z/limit;\\n}"], ["int minElements(int* nums, int numsSize, int limit, int goal){\\n\\n    long long int sum=0;\\n    for(int i=0;i<numsSize;i++)\\n        sum=sum+nums[i];\\n    \\n    long long int z=sum-goal;\\n    if(z<0)z=z*(-1);\\n    if(z%limit>0)return z/limit+1;\\n    return z/limit;\\n}"]]}
{"id": "1371", "ref_c": [["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n\\n    char a[26]={0}"]]}
{"id": "1372", "ref_c": [["int maximumValue(char ** strs, int strsSize)\\n{\\n    int i,j,flag,res=0,m;\\n    for(i=0;i<strsSize;i++)\\n    {\\n        flag=0;\\n        for(j=0;j<strlen(strs[i]);j++)\\n        {\\n            if(strs[i][j]>=\\'a\\')\\n            {\\n                flag=1;\\n                break;\\n            }"], ["int maximumValue(char ** strs, int strsSize)\\n{\\n    int i,j,flag,res=0,m;\\n    for(i=0;i<strsSize;i++)\\n    {\\n        flag=0;\\n        for(j=0;j<strlen(strs[i]);j++)\\n        {\\n            if(strs[i][j]>=\\'a\\')\\n            {\\n                flag=1;\\n                break;\\n            }"], ["int maximumValue(char ** strs, int strsSize)\\n{\\n    int i,j,flag,res=0,m;\\n    for(i=0;i<strsSize;i++)\\n    {\\n        flag=0;\\n        for(j=0;j<strlen(strs[i]);j++)\\n        {\\n            if(strs[i][j]>=\\'a\\')\\n            {\\n                flag=1;\\n                break;\\n            }"]]}
{"id": "1374", "ref_c": [["int getMaximumConsecutive(int* coins, int coinsSize){\\n    \\n    qsort(coins, coinsSize, sizeof(int), cmpfunc);\\n    int i;\\n    int c=0;\\n    for (i = 0; i < coinsSize; i++)\\n    {\\n        if (c+1 >= coins[i])\\n        {\\n            c += coins[i];\\n        }"], ["int getMaximumConsecutive(int* coins, int coinsSize){\\n    \\n    qsort(coins, coinsSize, sizeof(int), cmpfunc);\\n    int i;\\n    int c=0;\\n    for (i = 0; i < coinsSize; i++)\\n    {\\n        if (c+1 >= coins[i])\\n        {\\n            c += coins[i];\\n        }"], ["int getMaximumConsecutive(int* coins, int coinsSize){\\n    \\n    qsort(coins, coinsSize, sizeof(int), cmpfunc);\\n    int i;\\n    int c=0;\\n    for (i = 0; i < coinsSize; i++)\\n    {\\n        if (c+1 >= coins[i])\\n        {\\n            c += coins[i];\\n        }"]]}
{"id": "1375", "ref_c": [["int getNumberOfBacklogOrders(int** orders, int ordersSize, int* ordersColSize){\\n\\n    /*\\n     * Input:\\n     *  **orders\\n     *  ordersSize\\n     *  *ordersColSize\\n     */\\n\\n    item_t item;\\n    int ans = 0;\\n\\n    max_init();\\n    min_init();\\n\\n    for (int i = 0; i < ordersSize; i++) {\\n        /* Buy */\\n        if (orders[i][2] == 0) {\\n            /* Search sell backlog and find out the lowest price */\\n            for (; orders[i][1] && min_pop(&item) == 0; ) {\\n\\n                if (item.price <= orders[i][0]) {\\n                    if (item.amount <= orders[i][1]) {\\n                        orders[i][1] -= item.amount;\\n                    }"], ["int getNumberOfBacklogOrders(int** orders, int ordersSize, int* ordersColSize){\\n\\n    /*\\n     * Input:\\n     *  **orders\\n     *  ordersSize\\n     *  *ordersColSize\\n     */\\n\\n    item_t item;\\n    int ans = 0;\\n\\n    max_init();\\n    min_init();\\n\\n    for (int i = 0; i < ordersSize; i++) {\\n        /* Buy */\\n        if (orders[i][2] == 0) {\\n            /* Search sell backlog and find out the lowest price */\\n            for (; orders[i][1] && min_pop(&item) == 0; ) {\\n\\n                if (item.price <= orders[i][0]) {\\n                    if (item.amount <= orders[i][1]) {\\n                        orders[i][1] -= item.amount;\\n                    }"], ["int getNumberOfBacklogOrders(int** orders, int ordersSize, int* ordersColSize){\\n\\n    /*\\n     * Input:\\n     *  **orders\\n     *  ordersSize\\n     *  *ordersColSize\\n     */\\n\\n    item_t item;\\n    int ans = 0;\\n\\n    max_init();\\n    min_init();\\n\\n    for (int i = 0; i < ordersSize; i++) {\\n        /* Buy */\\n        if (orders[i][2] == 0) {\\n            /* Search sell backlog and find out the lowest price */\\n            for (; orders[i][1] && min_pop(&item) == 0; ) {\\n\\n                if (item.price <= orders[i][0]) {\\n                    if (item.amount <= orders[i][1]) {\\n                        orders[i][1] -= item.amount;\\n                    }"]]}
{"id": "1376", "ref_c": [["int maxValue(int n, int index, int maxSum) {\\n        int l=1,h=maxSum, res=-1;\\n        while(l<=h)\\n        {\\n            int m=l+(h-l)/2;\\n            if(check(n,index,maxSum,m))\\n            {\\n                res=m;\\n                l=m+1;\\n            }"], ["int maxValue(int n, int index, int maxSum) {\\n    int left = 1, right = maxSum;\\n\\n    while (left <= right) {\\n        int mid = (left + right) / 2;\\n        uint64_t total = mid;\\n\\n        // Calculate the sum of the elements on the left side of the index\\n        uint64_t left_sum = 0;\\n        if((mid - 1) < index){\\n            left_sum = (uint64_t)(mid - 1) * (mid - 1 + 1) / 2 + index - (mid - 1);\\n        }"], ["int maxValue(int n, int index, int maxSum) {\\n        int start = 1, end = maxSum, secondstart = 0, secondend = 0;\\n        if (maxSum == n)\\n            return 1;\\n        long mid = 0, sum = 0, lastmid = 0, secondsum = 0;\\n        while (start < end) {\\n            mid = start + (end - start) / 2;\\n            sum = summ(n, index, mid);\\n            if (sum > maxSum) \\n                end = (int) mid - 1;\\n            else if (sum < maxSum) {\\n                start = (int) mid + 1;\\n                lastmid = mid;\\n                secondsum = sum;\\n            }"]]}
{"id": "1377", "ref_c": ["\nint comp(int* a,int* b)\n{\n    return(*a)-(*b);\n}\n\nint threeSumClosest(int* nums, int numsSize, int target) {\n    if(numsSize==0 || numsSize<3)\n    {\n        return 0;\n    }\n    qsort(nums,numsSize,sizeof(int),comp);\n    int closesum=INT_MIN;\n    int mindiff=INT_MAX;\n    for(int i=0;i<numsSize;i++)\n    {\n        int left=i+1;\n        int right=numsSize-1;\n        while(left<right)\n        {\n            int currentsum=nums[i]+nums[left]+nums[right];\n            int currentdiff=abs(target-currentsum);\n            if(currentdiff<mindiff)\n            {\n                mindiff=currentdiff;\n                closesum=currentsum;\n            }\n            if(currentsum<target)\n            {\n                left++;\n            }\n            else\n            {\n                right--;\n            }\n        }\n    }\n    return closesum;\n}\n", "\nint comp(int* a,int* b)\n{\n    return(*a)-(*b);\n}\n\nint threeSumClosest(int* nums, int numsSize, int target) {\n    if(numsSize==0 || numsSize<3)\n    {\n        return 0;\n    }\n    qsort(nums,numsSize,sizeof(int),comp);\n    int closesum=INT_MIN;\n    int mindiff=INT_MAX;\n    for(int i=0;i<numsSize;i++)\n    {\n        int left=i+1;\n        int right=numsSize-1;\n        while(left<right)\n        {\n            int currentsum=nums[i]+nums[left]+nums[right];\n            int currentdiff=abs(target-currentsum);\n            if(currentdiff<mindiff)\n            {\n                mindiff=currentdiff;\n                closesum=currentsum;\n            }\n            if(currentsum<target)\n            {\n                left++;\n            }\n            else\n            {\n                right--;\n            }\n        }\n    }\n    return closesum;\n}\n", "\nint comp(int* a,int* b)\n{\n    return(*a)-(*b);\n}\n\nint threeSumClosest(int* nums, int numsSize, int target) {\n    if(numsSize==0 || numsSize<3)\n    {\n        return 0;\n    }\n    qsort(nums,numsSize,sizeof(int),comp);\n    int closesum=INT_MIN;\n    int mindiff=INT_MAX;\n    for(int i=0;i<numsSize;i++)\n    {\n        int left=i+1;\n        int right=numsSize-1;\n        while(left<right)\n        {\n            int currentsum=nums[i]+nums[left]+nums[right];\n            int currentdiff=abs(target-currentsum);\n            if(currentdiff<mindiff)\n            {\n                mindiff=currentdiff;\n                closesum=currentsum;\n            }\n            if(currentsum<target)\n            {\n                left++;\n            }\n            else\n            {\n                right--;\n            }\n        }\n    }\n    return closesum;\n}\n"]}
{"id": "1378", "ref_c": [["char * evaluate(char * s, char *** knowledge, int knowledgeSize, int* knowledgeColSize){\\n    \\n    \\n    hash_t *hash_table = NULL;\\n    hash_t *el;\\n\\n    // map everything to hash table\\n    for(size_t i = 0 ; i < knowledgeSize ;i++)\\n    {\\n        el = malloc(sizeof(hash_t));\\n        strcpy(el->key,knowledge[i][0]);\\n        el->val = knowledge[i][1];\\n        HASH_ADD_STR(hash_table, key, el);\\n    }"], ["char * evaluate(char * s, char *** knowledge, int knowledgeSize, int* knowledgeColSize){\\n    \\n    \\n    hash_t *hash_table = NULL;\\n    hash_t *el;\\n\\n    // map everything to hash table\\n    for(size_t i = 0 ; i < knowledgeSize ;i++)\\n    {\\n        el = malloc(sizeof(hash_t));\\n        strcpy(el->key,knowledge[i][0]);\\n        el->val = knowledge[i][1];\\n        HASH_ADD_STR(hash_table, key, el);\\n    }"], ["char * evaluate(char * s, char *** knowledge, int knowledgeSize, int* knowledgeColSize){\\n    \\n    \\n    hash_t *hash_table = NULL;\\n    hash_t *el;\\n\\n    // map everything to hash table\\n    for(size_t i = 0 ; i < knowledgeSize ;i++)\\n    {\\n        el = malloc(sizeof(hash_t));\\n        strcpy(el->key,knowledge[i][0]);\\n        el->val = knowledge[i][1];\\n        HASH_ADD_STR(hash_table, key, el);\\n    }"]]}
{"id": "1379", "ref_c": [["int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\\n    int min=-INT_MAX;\\n    int s,j;\\n    mergeSort(points,0,pointsSize-1);\\n    for(int i=0;i<pointsSize-1;i++){\\n            s=points[i+1][0]-points[i][0];\\n            if(s>min){\\n                min=s;\\n            }"], ["int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\\n    int min=-INT_MAX;\\n    int s,j;\\n    mergeSort(points,0,pointsSize-1);\\n    for(int i=0;i<pointsSize-1;i++){\\n            s=points[i+1][0]-points[i][0];\\n            if(s>min){\\n                min=s;\\n            }"], ["int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\\n    qsort(points, pointsSize, sizeof(int *), cmp);\\n\\n    int max_width = 0;\\n\\n    /* Update the max width */\\n    for (int i = 1; i < pointsSize; ++i) {\\n        int curr_width = points[i][0] - points[i - 1][0];\\n        max_width = fmax(max_width, curr_width);\\n    }"]]}
{"id": "1380", "ref_c": [["int countNicePairs(int* nums, int numsSize) {\\n    int freq[100000] = {0}", "int countNicePairs(int* nums, int numsSize) {\\n    int* arr = (int*)malloc(numsSize * sizeof(int));\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i] = nums[i] - rev(nums[i]);\\n    }"], ["int countNicePairs(int* nums, int numsSize) {\\n\\n    /*\\n     * Input:\\n     *  *nums\\n     *  numsSize\\n     */\\n\\n    int ans = 0;\\n\\n    /* Calculate nums[i] - rev(nums[i]) */\\n    for (int i = 0; i < numsSize; i++) {\\n        nums[i] = nums[i] - reverse(nums[i]);\\n    }"], ["int countNicePairs(int* nums, int numsSize) {\\n\\n    /*\\n     * Input:\\n     *  *nums\\n     *  numsSize\\n     */\\n\\n    int ans = 0;\\n\\n    /* Calculate nums[i] - rev(nums[i]) */\\n    for (int i = 0; i < numsSize; i++) {\\n        nums[i] = nums[i] - reverse(nums[i]);\\n    }"]]}
{"id": "1381", "ref_c": [["int* findingUsersActiveMinutes(int** logs, int logsSize, int* logsColSize, int k, int* returnSize){\\n    qsort(logs, logsSize, sizeof(int*), cmp);\\n    int* ans = (int*)calloc(k, sizeof(int));\\n    int UAM = 0, currTaskId = -1;\\n    for(int i=0; i < logsSize; i++){\\n        if(currTaskId!=logs[i][0]){\\n            if(currTaskId>=0)\\n                ans[UAM-1]++;\\n            UAM = 1;\\n            currTaskId = logs[i][0];\\n        }"], ["int* findingUsersActiveMinutes(int** logs, int logsSize, int* logsColSize, int k, int* returnSize){\\n    qsort(logs, logsSize, sizeof(int*), cmp);\\n    int* ans = (int*)calloc(k, sizeof(int));\\n    int UAM = 0, currTaskId = -1;\\n    for(int i=0; i < logsSize; i++){\\n        if(currTaskId!=logs[i][0]){\\n            if(currTaskId>=0)\\n                ans[UAM-1]++;\\n            UAM = 1;\\n            currTaskId = logs[i][0];\\n        }"], ["int* findingUsersActiveMinutes(int** logs, int logsSize, int* logsColSize, int k, int* returnSize){\\n    qsort(logs, logsSize, sizeof(int*), cmp);\\n    int* ans = (int*)calloc(k, sizeof(int));\\n    int UAM = 0, currTaskId = -1;\\n    for(int i=0; i < logsSize; i++){\\n        if(currTaskId!=logs[i][0]){\\n            if(currTaskId>=0)\\n                ans[UAM-1]++;\\n            UAM = 1;\\n            currTaskId = logs[i][0];\\n        }"]]}
{"id": "1382", "ref_c": [["char * reverseParentheses(char * s){\\n    if(!s)\\n        return \"\";\\n    node*top = NULL;\\n\\n    for(int i = 0 ; i < strlen(s) ; i++ )\\n    {\\n        if(s[i] == \\'(\\')\\n            qpush(&top,i);\\n        else if( s[i] == \\')\\')\\n        {\\n            int start = qpop(&top) ;\\n            s[start] = \\' \\';\\n            start++;\\n            int end = i - 1;\\n            while(start < end)\\n            {\\n                char c = s[start];\\n                s[start] = s[end];\\n                s[end] = c;\\n                start++;\\n                end--;\\n            }"], ["char * reverseParentheses(char * s){\\n    if(!s)\\n        return \"\";\\n    node*top = NULL;\\n\\n    for(int i = 0 ; i < strlen(s) ; i++ )\\n    {\\n        if(s[i] == \\'(\\')\\n            qpush(&top,i);\\n        else if( s[i] == \\')\\')\\n        {\\n            int start = qpop(&top) ;\\n            s[start] = \\' \\';\\n            start++;\\n            int end = i - 1;\\n            while(start < end)\\n            {\\n                char c = s[start];\\n                s[start] = s[end];\\n                s[end] = c;\\n                start++;\\n                end--;\\n            }"], ["char * reverseParentheses(char * s){\\n    if(!s)\\n        return \"\";\\n    node*top = NULL;\\n\\n    for(int i = 0 ; i < strlen(s) ; i++ )\\n    {\\n        if(s[i] == \\'(\\')\\n            qpush(&top,i);\\n        else if( s[i] == \\')\\')\\n        {\\n            int start = qpop(&top) ;\\n            s[start] = \\' \\';\\n            start++;\\n            int end = i - 1;\\n            while(start < end)\\n            {\\n                char c = s[start];\\n                s[start] = s[end];\\n                s[end] = c;\\n                start++;\\n                end--;\\n            }"]]}
{"id": "1383", "ref_c": [["int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }"], ["int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        else\\n            return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }"], ["int findTheWinner(int n, int k){\\n    if(n == 1) return 1;\\n    return (findTheWinner(n-1, k) + k - 1) % n + 1;\\n}", "int findTheWinner(int n, int k){\\n    int result = 0;\\n    for(int i = 1; i<=n; ++i)\\n        result = (result + k) % i;\\n    return result + 1;\\n}"]]}
{"id": "1384", "ref_c": [["int minSideJumps(int* obstacles, int obstaclesSize) {\\n    if(obstaclesSize==1)return 0;\\n    int startIndex=0;\\n    int lane=2;\\n    int** dp=malloc(sizeof(int*)*(obstaclesSize+1));\\n    for(int i=0;i<obstaclesSize+1;i++){\\n        dp[i]=malloc(sizeof(int)*4);\\n        memset(dp[i], -1, sizeof(int) * 4);\\n    }"], ["int minSideJumps(int* obstacles, int obstaclesSize) {\\n    if(obstaclesSize==1)return 0;\\n    int startIndex=0;\\n    int lane=2;\\n    int** dp=malloc(sizeof(int*)*(obstaclesSize+1));\\n    for(int i=0;i<obstaclesSize+1;i++){\\n        dp[i]=malloc(sizeof(int)*4);\\n        memset(dp[i], -1, sizeof(int) * 4);\\n    }"], ["int minSideJumps(int* obstacles, int obstaclesSize) {\\n    if(obstaclesSize==1)return 0;\\n    int startIndex=0;\\n    int lane=2;\\n    int** dp=malloc(sizeof(int*)*(obstaclesSize+1));\\n    for(int i=0;i<obstaclesSize+1;i++){\\n        dp[i]=malloc(sizeof(int)*4);\\n        memset(dp[i], -1, sizeof(int) * 4);\\n    }"]]}
{"id": "1385", "ref_c": [["int* countPoints(int** points, int pointsSize, int* pointsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n\\n    *returnSize = queriesSize; \\n    int* result = malloc(queriesSize*sizeof(int));\\n    memset(result, 0, queriesSize*sizeof(int));\\n    \\n    int x, y, cx, cy, r;\\n    for (int q = 0; q < queriesSize; q++){\\n        for(int p = 0; p < pointsSize; p++){\\n\\n            x = points[p][0];\\n            y = points[p][1];\\n            cx = queries[q][0];\\n            cy = queries[q][1];\\n            r = queries[q][2];\\n\\n            if (((x-cx)*(x-cx) + (y-cy)*(y-cy)) <= r*r){\\n                result[q] += 1;\\n            }"], ["int* countPoints(int** points, int pointsSize, int* pointsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize)\\n{\\n    double d=0.0;\\n    *returnSize=queriesSize;\\n    int *ans=(int*)malloc(sizeof(int)*queriesSize);\\n    for(int i=0;i<queriesSize;i++)\\n    {\\n        ans[i]=0;\\n        for(int j=0;j<pointsSize;j++)\\n        {\\n            d=sqrt(((points[j][0]-queries[i][0])*(points[j][0]-queries[i][0]))+\\n            ((points[j][1]-queries[i][1])*(points[j][1]-queries[i][1])));\\n            if(d<=queries[i][2])\\n            ans[i]++;\\n        }"], ["int* countPoints(int** points, int pointsSize, int* pointsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize = queriesSize;\\n    int* answer = (int*) malloc(queriesSize * sizeof(int));\\n    \\n    for (int i = 0; i < queriesSize; i++) {\\n        int count = 0;\\n        int circle_x = queries[i][0];\\n        int circle_y = queries[i][1];\\n        int r = queries[i][2];\\n        \\n        for (int j = 0; j < pointsSize; j++) {\\n            int x = points[j][0];\\n            int y = points[j][1];\\n            \\n            if (is_inside_circle(x, y, circle_x, circle_y, r)) {\\n                count++;\\n            }"]]}
{"id": "1386", "ref_c": [["int* getMaximumXor(int* nums, int numsSize, int maximumBit, int* returnSize){\\n    int *res=(int*)malloc(sizeof(int)*numsSize);\\n    *returnSize=numsSize;\\n    int max=pow(2,maximumBit)-1;\\n    for(int i=1;i<numsSize;i++){\\n        nums[i]^=nums[i-1]; \\n    }"], ["int* getMaximumXor(int* nums, int numsSize, int maximumBit, int* returnSize){\\n    int *res=(int*)malloc(sizeof(int)*numsSize);\\n    *returnSize=numsSize;\\n    int max=pow(2,maximumBit)-1;\\n    for(int i=1;i<numsSize;i++){\\n        nums[i]^=nums[i-1]; \\n    }"], ["int* getMaximumXor(int* nums, int numsSize, int maximumBit, int* returnSize){\\n    int *res=(int*)malloc(sizeof(int)*numsSize);\\n    *returnSize=numsSize;\\n    int max=pow(2,maximumBit)-1;\\n    for(int i=1;i<numsSize;i++){\\n        nums[i]^=nums[i-1]; \\n    }"]]}
{"id": "1387", "ref_c": ["\nint cmpFunc(const void *a, const void *b)\n{\n    return (*(int*)a - *(int*)b);\n}\n\nint maxIceCream(int* costs, int costsSize, int coins){\n\n    if (costs == NULL || costsSize == 0 || coins == 0)\n    {\n        return 0;\n    }\n    \n    qsort(costs, costsSize, sizeof(int), cmpFunc);\n    int count = 0;\n\n    for (int index  = 0; index < costsSize; index++)\n    {\n        if (coins < costs[index])\n        {\n            return count;\n        }\n        else\n        {\n            coins = coins - costs[index];\n            count++;\n        }\n    }\n\n    return count;\n}\n", "\nint cmpFunc(const void *a, const void *b)\n{\n    return (*(int*)a - *(int*)b);\n}\n\nint maxIceCream(int* costs, int costsSize, int coins){\n\n    if (costs == NULL || costsSize == 0 || coins == 0)\n    {\n        return 0;\n    }\n    \n    qsort(costs, costsSize, sizeof(int), cmpFunc);\n    int count = 0;\n\n    for (int index  = 0; index < costsSize; index++)\n    {\n        if (coins < costs[index])\n        {\n            return count;\n        }\n        else\n        {\n            coins = coins - costs[index];\n            count++;\n        }\n    }\n\n    return count;\n}\n", "\nint cmpFunc(const void *a, const void *b)\n{\n    return (*(int*)a - *(int*)b);\n}\n\nint maxIceCream(int* costs, int costsSize, int coins){\n\n    if (costs == NULL || costsSize == 0 || coins == 0)\n    {\n        return 0;\n    }\n    \n    qsort(costs, costsSize, sizeof(int), cmpFunc);\n    int count = 0;\n\n    for (int index  = 0; index < costsSize; index++)\n    {\n        if (coins < costs[index])\n        {\n            return count;\n        }\n        else\n        {\n            coins = coins - costs[index];\n            count++;\n        }\n    }\n\n    return count;\n}\n"]}
{"id": "1388", "ref_c": [["int* getOrder(int** tasks, int tasksSize, int* tasksColSize, int* returnSize){\\n    *returnSize = tasksSize;\\n\\n    heap_element * task_queue = malloc(tasksSize * sizeof(heap_element));\\n    int queuesize = 0;\\n\\n    task_item * task_arr = malloc(tasksSize * sizeof(task_item));\\n    for (int i = 0; i < tasksSize; i++) {\\n        task_arr[i].taskid = i;\\n        task_arr[i].arrival = tasks[i][0];\\n        task_arr[i].duration = tasks[i][1];\\n    }"], ["int* getOrder(int** tasks, int tasksSize, int* tasksColSize, int* returnSize){\\n    // contruct astTaskRecord\\n    int nMaxEnqueueTime = 0;\\n    struct TaskRecord astTaskRecord[tasksSize];\\n    for(int i=0; i<tasksSize; i++)\\n    {\\n        astTaskRecord[i].nIndex = i;\\n        astTaskRecord[i].nEnqueueTime = tasks[i][0];\\n        astTaskRecord[i].nProcessingTime = tasks[i][1];\\n        if(nMaxEnqueueTime < tasks[i][0]) nMaxEnqueueTime = tasks[i][0];\\n\\n        astTaskRecord[i].pstParent = NULL;\\n        astTaskRecord[i].pstLeft = NULL;\\n        astTaskRecord[i].pstRight = NULL;\\n    }"], ["int* getOrder(int** tasks, int tasksSize, int* tasksColSize, int* returnSize){\\n    *returnSize = tasksSize;\\n\\n    heap_element * task_queue = malloc(tasksSize * sizeof(heap_element));\\n    int queuesize = 0;\\n\\n    task_item * task_arr = malloc(tasksSize * sizeof(task_item));\\n    for (int i = 0; i < tasksSize; i++) {\\n        task_arr[i].taskid = i;\\n        task_arr[i].arrival = tasks[i][0];\\n        task_arr[i].duration = tasks[i][1];\\n    }"]]}
{"id": "1389", "ref_c": [["int maxFrequency(int* nums, int numsSize, int k) {\\n    int anCount[VALUE_SIZE];\\n    memset(anCount, 0, VALUE_SIZE*sizeof(int));\\n\\n    // count input *nums into hashtable\\n    int nMin = VALUE_SIZE, nMax = 0;\\n    while(numsSize--)\\n    {\\n        if(nMin > *nums) nMin = *nums;\\n        if(nMax < *nums) nMax = *nums;\\n\\n        anCount[*(nums++)]++;\\n    }"], ["int maxFrequency(int* nums, int numsSize, int k) {\\n    int anCount[VALUE_SIZE];\\n    memset(anCount, 0, VALUE_SIZE*sizeof(int));\\n\\n    // count input *nums into hashtable\\n    int nMin = VALUE_SIZE, nMax = 0;\\n    while(numsSize--)\\n    {\\n        if(nMin > *nums) nMin = *nums;\\n        if(nMax < *nums) nMax = *nums;\\n\\n        anCount[*(nums++)]++;\\n    }"], ["int maxFrequency(int* nums, int numsSize, int k) {\\n    int anCount[VALUE_SIZE];\\n    memset(anCount, 0, VALUE_SIZE*sizeof(int));\\n\\n    // count input *nums into hashtable\\n    int nMin = VALUE_SIZE, nMax = 0;\\n    while(numsSize--)\\n    {\\n        if(nMin > *nums) nMin = *nums;\\n        if(nMax < *nums) nMax = *nums;\\n\\n        anCount[*(nums++)]++;\\n    }"]]}
{"id": "1390", "ref_c": [["int longestBeautifulSubstring(char * word){\\n    \\n    char vowels[]={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}"], ["int longestBeautifulSubstring(char * word){\\n    int i=0;\\n    int ret = 0;\\n    int leng = 0;\\n    int len = strlen(word);\\n    while(i<len){\\n        if(i<len&&word[i]!=\\'a\\'){\\n            i++;\\n            leng=0;\\n            continue;\\n        }"], ["int longestBeautifulSubstring(char * word){\\n    \\n    char vowels[]={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}"]]}
{"id": "1392", "ref_c": [["int maximumElementAfterDecrementingAndRearranging(int* arr, int arrSize) {\\n    int n = arrSize;\\n    int* counts = (int*)calloc(n + 1, sizeof(int));\\n    \\n    for (int i = 0; i < n; i++) {\\n        counts[arr[i] < n ? arr[i] : n]++;\\n    }"], ["int maximumElementAfterDecrementingAndRearranging(int* arr, int arrSize) {\\n    int counts[arrSize];\\n\\tmemset(counts, 0, sizeof(counts));\\n\\tfor (int i = 0; i < arrSize; ++i) {\\n\\t\\tif (arrSize > arr[i]) {\\n\\t\\t\\t++counts[arr[i]];\\n\\t\\t}"], ["int maximumElementAfterDecrementingAndRearranging(int* arr, int arrSize) {\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    arr[0] = 1;\\n\\n    int curr = 1;\\n    while (curr < arrSize) {\\n        while (curr < arrSize && (arr[curr] - arr[curr - 1]) <= 1)\\n            ++curr;\\n\\n        /* Check if curr is out of boundary*/\\n        if (curr >= arrSize) {\\n            break;\\n        }"]]}
{"id": "1393", "ref_c": [["bool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}"], ["bool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}"], ["bool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}"]]}
{"id": "1394", "ref_c": [["int waysToMakeFair(int* nums, int numsSize){\\n    int odd[numsSize], even[numsSize];\\n    bzero(odd, numsSize * sizeof(int));\\n    bzero(even, numsSize * sizeof(int));\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i == 0) {\\n            even[i] = nums[i];\\n        }"], ["int waysToMakeFair(int* nums, int numsSize){\\n    int result = 0, even_sum = 0, odd_sum = 0, even = 0, odd = 0;\\n    int *tmp = nums;\\n    while(tmp != nums + numsSize){\\n        if((tmp - nums) & 1) odd_sum += *tmp;\\n        else even_sum += *tmp;\\n        tmp++;\\n    }"], ["int waysToMakeFair(int* nums, int numsSize){\\n    int result = 0, even_sum = 0, odd_sum = 0, even = 0, odd = 0;\\n    int *tmp = nums;\\n    while(tmp != nums + numsSize){\\n        if((tmp - nums) & 1) odd_sum += *tmp;\\n        else even_sum += *tmp;\\n        tmp++;\\n    }"]]}
{"id": "1395", "ref_c": [["int maxDistance(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int max = 0;\\n    for(int i = 0 ; i < nums1Size; i++){\\n        int s = i , e= nums2Size-1, mid;\\n        mid = s + (e-s)/2;\\n        while(s<=e){\\n            if(nums2[mid] >= nums1[i]){\\n                s = mid +1;\\n                if(mid-i > max)\\n                {\\n                max = mid- i;\\n                }"], ["int maxDistance(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int first=0,second=0,d=0;\\n    while(first<nums1Size && second<nums2Size)\\n    {\\n        if(first<=second && nums1[first]<=nums2[second])\\n        {\\n            if(d<(second-first))\\n            {\\n                d=second-first;\\n            }"], ["int maxDistance(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int i=0;\\n    int j=0;\\n    int max=0;\\n    while(i<nums1Size && j<nums2Size){\\n        if(nums2[j] >= nums1[i]){\\n            max=fmax(j-i,max);\\n            j++;\\n        }"]]}
{"id": "1396", "ref_c": [["char ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }"], ["char ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }"], ["char ** restoreIpAddresses(char * s, int* returnSize){\\n  const size_t len = strlen(s);\\n  char** ret = NULL;\\n  size_t capacity = 0;\\n  *returnSize = 0;\\n  for (int a = 1;  (a <= 3) && (a + 2 < len) && (1 == a || \\'0\\' != s[0]) && (a < 3 || 0 > memcmp(s, \"256\", 3)); ++a) {\\n    for (int b = a + 1; (b <= a + 3) && (b + 1 < len) && (a + 1 == b || \\'0\\' != s[a]) && (b < a + 3 || 0 > memcmp(s + a, \"256\", 3)); ++b) {\\n      for (int c = b + 1; (c <= b + 3) && (c < len) && (b + 1 == c || \\'0\\' != s[b]) && (c < b + 3 || 0 > memcmp(s + b, \"256\", 3)); ++c) {\\n        if ((c + 3 >= len) && (c + 1 == len || \\'0\\' != s[c]) && (len < c + 3 || 0 > memcmp(s + c, \"256\", 3))) {\\n          if (*returnSize >= capacity) {\\n            capacity = (capacity) ? capacity * 2 : 1;\\n            ret = (char**) realloc(ret, sizeof(char*) * capacity);\\n          }"]]}
{"id": "1397", "ref_c": [["int* memLeak(int memory1, int memory2, int* returnSize){\\nint sec = 0;\\nint *mem;\\nwhile(memory1 >= 0 && memory2 >= 0)\\n{\\n    mem = memory1 >= memory2 ? &memory1 : &memory2;\\n    if((*mem - sec) < 0)\\n        break;\\n    *mem -= sec;\\n    sec++;\\n}"], ["int* memLeak(int memory1, int memory2, int* returnSize){\\n    int i = 1;\\n    // int total = memory1 + memory2;\\n    *returnSize = 3;\\n    int * returnArray = malloc(sizeof(int) * *returnSize);\\n    \\n    while(memory1 >= i || memory2 >= i){\\n        if(memory2 > memory1){\\n            memory2 -= i;\\n        }"], ["int* memLeak(int memory1, int memory2, int* returnSize){\\n    int i = 1;\\n    // int total = memory1 + memory2;\\n    *returnSize = 3;\\n    int * returnArray = malloc(sizeof(int) * *returnSize);\\n    \\n    while(memory1 >= i || memory2 >= i){\\n        if(memory2 > memory1){\\n            memory2 -= i;\\n        }"]]}
{"id": "1398", "ref_c": [["char** rotateTheBox(char** box, int boxSize, int* boxColSize, int* returnSize, int** returnColumnSizes){\\n    int rowsize=*boxColSize; // transform rowsize\\n    int colsize=boxSize; // transform colsize\\n    *returnSize=rowsize;\\n    *returnColumnSizes=malloc(sizeof(int)*rowsize);\\n    char **res=malloc(sizeof(char*)*rowsize);\\n    for(int i=0;i<rowsize;i++){\\n        res[i]=calloc(colsize,sizeof(char));\\n        returnColumnSizes[0][i]=colsize;\\n    }"], ["char** rotateTheBox(char** box, int boxSize, int* boxColSize, int* returnSize, int** returnColumnSizes){\\n    int rLen = boxSize, cLen = *boxColSize;\\n    int stoneCnt = 0;\\n    \\n    /* prepare return ans parms */\\n    char** ans = (char**)calloc(cLen, sizeof(char*));\\n    int* col = (int*)calloc(cLen, sizeof(int));\\n    for(int i = 0; i < cLen; i++){\\n        ans[i] = (char*)calloc(rLen, sizeof(char));\\n        for(int j = 0; j < rLen; j++)\\n            ans[i][j] = \\'.\\';\\n        col[i] = rLen;\\n    }"], ["char** rotateTheBox(char** box, int boxSize, int* boxColSize, int* returnSize, int** returnColumnSizes){\\n    int rowsize=*boxColSize; // transform rowsize\\n    int colsize=boxSize; // transform colsize\\n    *returnSize=rowsize;\\n    *returnColumnSizes=malloc(sizeof(int)*rowsize);\\n    char **res=malloc(sizeof(char*)*rowsize);\\n    for(int i=0;i<rowsize;i++){\\n        res[i]=calloc(colsize,sizeof(char));\\n        returnColumnSizes[0][i]=colsize;\\n    }"]]}
{"id": "1399", "ref_c": [["int minSwaps(char * s){\\n    const int slen = strlen(s);\\n    // Count number of 0s and 1s that need to change if the sequence will be 01010...\\n    int start0bad[2] = {0}"], ["int minSwaps(char * s){\\n    const int slen = strlen(s);\\n    // Count number of 0s and 1s that need to change if the sequence will be 01010...\\n    int start0bad[2] = {0}"], ["int minSwaps(char * s){\\n    const int slen = strlen(s);\\n    // Count number of 0s and 1s that need to change if the sequence will be 01010...\\n    int start0bad[2] = {0}"]]}
{"id": "1401", "ref_c": ["\ndouble timeOnSpeed(int * dist , int distSize , int speed) {\n    // Calculates time that the trip takes according to the problem statement\n    double totalTime = 0;\n    size_t i=0;\n    while (i<distSize-1) {\n        totalTime+=ceil(((double)dist[i])/speed);\n        i++;\n    }\n    return totalTime + ((double)dist[i])/speed;\n}\n\nint minSpeedOnTime(int* dist, int distSize, double hour){\n    // First train: dist[0]/speed hours\n    // Second train: dist[1]/speed hours\n    // etc.\n    // Binary search. A good lower bound is the one we would have if we did not have to wait anything\n\n    size_t i;\n\n    if (ceil(hour)<distSize) return -1;\n    \n    // Minimum speed necessary would be the one if there was no wait time\n    long min_speed = 0, max_speed = 0;\n    for (i=0;i<distSize-1;i++) {\n        min_speed += dist[i];\n        max_speed = MAX(max_speed,dist[i]);\n    }\n    min_speed += dist[i];\n    // min_speed stores the total distance;\n    min_speed = (long)ceil(min_speed/hour)-1;\n    // max_speed stores the maximum distance, except in the last stretch;\n    // This is the same as the minimum speed necessary to make sure all stretches, except the last one, are covered in <=1 hour\n    max_speed = MAX(max_speed, (long)ceil(dist[i]/(hour-distSize+1)));\n\n    // Binary search\n\n    long speed = min_speed + (max_speed-min_speed)/2;\n\n    printf(\"minimum speed: %d; maximum speed: %d; %.10lf\n\", min_speed , max_speed, timeOnSpeed(dist , distSize , min_speed));\n    while (min_speed<max_speed) {\n        if (timeOnSpeed(dist , distSize , speed)>hour) {\n            min_speed = speed+1;\n        } else {\n            max_speed = speed;\n        }\n        speed = min_speed + (max_speed-min_speed)/2;\n    }\n    return speed;\n\n}\n", "\ndouble timeOnSpeed(int * dist , int distSize , int speed) {\n    // Calculates time that the trip takes according to the problem statement\n    double totalTime = 0;\n    size_t i=0;\n    while (i<distSize-1) {\n        totalTime+=ceil(((double)dist[i])/speed);\n        i++;\n    }\n    return totalTime + ((double)dist[i])/speed;\n}\n\nint minSpeedOnTime(int* dist, int distSize, double hour){\n    // First train: dist[0]/speed hours\n    // Second train: dist[1]/speed hours\n    // etc.\n    // Binary search. A good lower bound is the one we would have if we did not have to wait anything\n\n    size_t i;\n\n    if (ceil(hour)<distSize) return -1;\n    \n    // Minimum speed necessary would be the one if there was no wait time\n    long min_speed = 0, max_speed = 0;\n    for (i=0;i<distSize-1;i++) {\n        min_speed += dist[i];\n        max_speed = MAX(max_speed,dist[i]);\n    }\n    min_speed += dist[i];\n    // min_speed stores the total distance;\n    min_speed = (long)ceil(min_speed/hour)-1;\n    // max_speed stores the maximum distance, except in the last stretch;\n    // This is the same as the minimum speed necessary to make sure all stretches, except the last one, are covered in <=1 hour\n    max_speed = MAX(max_speed, (long)ceil(dist[i]/(hour-distSize+1)));\n\n    // Binary search\n\n    long speed = min_speed + (max_speed-min_speed)/2;\n\n    printf(\"minimum speed: %d; maximum speed: %d; %.10lf\n\", min_speed , max_speed, timeOnSpeed(dist , distSize , min_speed));\n    while (min_speed<max_speed) {\n        if (timeOnSpeed(dist , distSize , speed)>hour) {\n            min_speed = speed+1;\n        } else {\n            max_speed = speed;\n        }\n        speed = min_speed + (max_speed-min_speed)/2;\n    }\n    return speed;\n\n}\n", "\ndouble timeOnSpeed(int * dist , int distSize , int speed) {\n    // Calculates time that the trip takes according to the problem statement\n    double totalTime = 0;\n    size_t i=0;\n    while (i<distSize-1) {\n        totalTime+=ceil(((double)dist[i])/speed);\n        i++;\n    }\n    return totalTime + ((double)dist[i])/speed;\n}\n\nint minSpeedOnTime(int* dist, int distSize, double hour){\n    // First train: dist[0]/speed hours\n    // Second train: dist[1]/speed hours\n    // etc.\n    // Binary search. A good lower bound is the one we would have if we did not have to wait anything\n\n    size_t i;\n\n    if (ceil(hour)<distSize) return -1;\n    \n    // Minimum speed necessary would be the one if there was no wait time\n    long min_speed = 0, max_speed = 0;\n    for (i=0;i<distSize-1;i++) {\n        min_speed += dist[i];\n        max_speed = MAX(max_speed,dist[i]);\n    }\n    min_speed += dist[i];\n    // min_speed stores the total distance;\n    min_speed = (long)ceil(min_speed/hour)-1;\n    // max_speed stores the maximum distance, except in the last stretch;\n    // This is the same as the minimum speed necessary to make sure all stretches, except the last one, are covered in <=1 hour\n    max_speed = MAX(max_speed, (long)ceil(dist[i]/(hour-distSize+1)));\n\n    // Binary search\n\n    long speed = min_speed + (max_speed-min_speed)/2;\n\n    printf(\"minimum speed: %d; maximum speed: %d; %.10lf\n\", min_speed , max_speed, timeOnSpeed(dist , distSize , min_speed));\n    while (min_speed<max_speed) {\n        if (timeOnSpeed(dist , distSize , speed)>hour) {\n            min_speed = speed+1;\n        } else {\n            max_speed = speed;\n        }\n        speed = min_speed + (max_speed-min_speed)/2;\n    }\n    return speed;\n\n}\n"]}
{"id": "1402", "ref_c": [["int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\\n    \\n    /* Sort the candidates to group duplicates together */\\n    qsort(candidates, candidatesSize, sizeof(int), sortFunc);\\n    \\n    /* Array to store the current solution */\\n    int* current = (int*)malloc(100*sizeof(int));\\n    int currentLength = 0;\\n    \\n    /* Allocate initial memory to answer and returnColumnSizes */\\n    int** answer = (int**)malloc(sizeof(int*));\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int));\\n    \\n    (*returnSize) = 0;\\n    \\n    /* Call the helper with our initial conditions */\\n    helper(candidates, candidatesSize, target, 0, current, currentLength, returnSize, returnColumnSizes, &answer);\\n    \\n    free(current);\\n    return answer;\\n}"], ["int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\\n    \\n    /* Sort the candidates to group duplicates together */\\n    qsort(candidates, candidatesSize, sizeof(int), sortFunc);\\n    \\n    /* Array to store the current solution */\\n    int* current = (int*)malloc(100*sizeof(int));\\n    int currentLength = 0;\\n    \\n    /* Allocate initial memory to answer and returnColumnSizes */\\n    int** answer = (int**)malloc(sizeof(int*));\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int));\\n    \\n    (*returnSize) = 0;\\n    \\n    /* Call the helper with our initial conditions */\\n    helper(candidates, candidatesSize, target, 0, current, currentLength, returnSize, returnColumnSizes, &answer);\\n    \\n    free(current);\\n    return answer;\\n}"], ["int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\\n    \\n    /* Sort the candidates to group duplicates together */\\n    qsort(candidates, candidatesSize, sizeof(int), sortFunc);\\n    \\n    /* Array to store the current solution */\\n    int* current = (int*)malloc(100*sizeof(int));\\n    int currentLength = 0;\\n    \\n    /* Allocate initial memory to answer and returnColumnSizes */\\n    int** answer = (int**)malloc(sizeof(int*));\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int));\\n    \\n    (*returnSize) = 0;\\n    \\n    /* Call the helper with our initial conditions */\\n    helper(candidates, candidatesSize, target, 0, current, currentLength, returnSize, returnColumnSizes, &answer);\\n    \\n    free(current);\\n    return answer;\\n}"]]}
{"id": "1403", "ref_c": [["int minPairSum(int* nums, int numsSize){\\n    const int N = (1e5)+2;\\n    int freq[N];\\n    memset(freq, 0, sizeof(freq));\\n    for (int n=0; n<numsSize; n++) \\n        freq[nums[n]]++;\\n    int i=0, j= N-2, ans=-1;\\n    while (i <= j) {\\n        while (freq[i] == 0 && i <= j)\\n            i++;\\n        while (freq[j] == 0 && j >= i)\\n            j--;\\n\\n        if (freq[i] && freq[j]){\\n            if (i + j > ans)\\n                ans = i + j;\\n            freq[i]--;\\n            freq[j]--;\\n        }"], ["int minPairSum(int* nums, int numsSize){\\n    const int N = (1e5)+2;\\n    int freq[N];\\n    memset(freq, 0, sizeof(freq));\\n    for (int n=0; n<numsSize; n++) \\n        freq[nums[n]]++;\\n    int i=0, j= N-2, ans=-1;\\n    while (i <= j) {\\n        while (freq[i] == 0 && i <= j)\\n            i++;\\n        while (freq[j] == 0 && j >= i)\\n            j--;\\n\\n        if (freq[i] && freq[j]){\\n            if (i + j > ans)\\n                ans = i + j;\\n            freq[i]--;\\n            freq[j]--;\\n        }"], ["int minPairSum(int* nums, int numsSize){\\n    const int N = (1e5)+2;\\n    int freq[N];\\n    memset(freq, 0, sizeof(freq));\\n    for (int n=0; n<numsSize; n++) \\n        freq[nums[n]]++;\\n    int i=0, j= N-2, ans=-1;\\n    while (i <= j) {\\n        while (freq[i] == 0 && i <= j)\\n            i++;\\n        while (freq[j] == 0 && j >= i)\\n            j--;\\n\\n        if (freq[i] && freq[j]){\\n            if (i + j > ans)\\n                ans = i + j;\\n            freq[i]--;\\n            freq[j]--;\\n        }"]]}
{"id": "1404", "ref_c": [["int* getBiggestThree(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    \\n    int i, j, k;\\n    int max1 = 0, max2 = 0, max3 = 0, temp, sum;\\n    for(i = 0; i < gridSize; i++)\\n        for(j = 0; j < (*gridColSize); j++){\\n\\t\\t\\n            if(grid[i][j] > max1){\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = grid[i][j];\\n            }"], ["int* getBiggestThree(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    \\n    int i, j, k;\\n    int max1 = 0, max2 = 0, max3 = 0, temp, sum;\\n    for(i = 0; i < gridSize; i++)\\n        for(j = 0; j < (*gridColSize); j++){\\n\\t\\t\\n            if(grid[i][j] > max1){\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = grid[i][j];\\n            }"], ["int* getBiggestThree(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n    \\n    int i, j, k;\\n    int max1 = 0, max2 = 0, max3 = 0, temp, sum;\\n    for(i = 0; i < gridSize; i++)\\n        for(j = 0; j < (*gridColSize); j++){\\n\\t\\t\\n            if(grid[i][j] > max1){\\n                max3 = max2;\\n                max2 = max1;\\n                max1 = grid[i][j];\\n            }"]]}
{"id": "1405", "ref_c": [["bool isNStraightHand(int* hand, int handSize, int groupSize)\\n{\\n    unsigned int* hash = calloc(H_SIZE, sizeof(unsigned int));\\n\\n    if( handSize % groupSize != 0)\\n    {\\n        return false;\\n    }"], ["bool isNStraightHand(int* hand, int handSize, int groupSize)\\n{\\n    unsigned int* hash = calloc(H_SIZE, sizeof(unsigned int));\\n\\n    if( handSize % groupSize != 0)\\n    {\\n        return false;\\n    }"], ["bool isNStraightHand(int* hand, int handSize, int groupSize){\\n    \\n    if (handSize % groupSize != 0)\\n    {\\n        return 0;\\n    }"]]}
{"id": "1406", "ref_c": [["struct ListNode* partition(struct ListNode* head, int x){\\n    if (head == NULL) return head;\\n    ListNode* smaller=(ListNode*)malloc(sizeof(ListNode)); \\n    smaller->val=0;\\n    ListNode* smallerTail=smaller; //Tail of the list with nodes <x\\n        \\n    ListNode* greater=(ListNode*)malloc(sizeof(ListNode));\\n    greater->val=0;\\n    ListNode* greaterTail=greater; //Tail of the list with nodes >=x\\n        \\n    ListNode* curr = head;\\n    while (curr) {//partition into greater & smaller lists\\n        if (curr->val < x) {\\n            smallerTail->next = curr;\\n            smallerTail =smallerTail->next;\\n        }"], ["struct ListNode* partition(struct ListNode* head, int x){\\n    struct ListNode* less = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    less->val = 0;\\n    less->next = NULL;\\n    \\n    struct ListNode* high = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    high->val = 0;\\n    high->next = NULL;\\n    \\n    struct ListNode* lessT = less;\\n    struct ListNode* highT = high;\\n    \\n    while(head){\\n        if(head->val < x){\\n            lessT->next = head;\\n            lessT = lessT->next;\\n        }"], ["struct ListNode* partition(struct ListNode* head, int x){\\n    struct ListNode* less = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    less->val = 0;\\n    less->next = NULL;\\n    \\n    struct ListNode* high = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    high->val = 0;\\n    high->next = NULL;\\n    \\n    struct ListNode* lessT = less;\\n    struct ListNode* highT = high;\\n    \\n    while(head){\\n        if(head->val < x){\\n            lessT->next = head;\\n            lessT = lessT->next;\\n        }"]]}
{"id": "1407", "ref_c": [["int twoEggDrop(int n){\\n return ceil((-1 + sqrt(1 + 8*n)) / 2);\\n}"], ["int twoEggDrop(int n){\\n    int sum = 0, i;\\n    for(i = 1; n > sum; i++) sum += i;\\n    return i - 1;\\n}"], ["int twoEggDrop(int n){\\n    int sum = 0, i;\\n    for(i = 1; n > sum; i++) sum += i;\\n    return i - 1;\\n}"]]}
{"id": "1408", "ref_c": [["int reductionOperations(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), compare); // Sort the input array \\'nums\\' in non-decreasing order\\n    int sum = 0, temp = 0; // Initialize variables to keep track of sum and temporary count\\n\\n    // Iterate through the sorted array\\n    for (int i = 1; i < numsSize; i++) {\\n        // Check if the current element is different from the previous one\\n        if (nums[i] != nums[i - 1]) {\\n            temp++; // Increment temporary count for a new unique element\\n        }"], ["int reductionOperations(int* nums, int numsSize) {\\n\\n    /*\\n     * Input:\\n     *  nums\\n     *  numsSize\\n     */\\n    \\n    int ans = 0;\\n\\n    /* Sort by value in descending order */\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] != nums[i - 1]) {\\n            ans += i;\\n        }"], ["int reductionOperations(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), compare); // Sort the input array \\'nums\\' in non-decreasing order\\n    int sum = 0, temp = 0; // Initialize variables to keep track of sum and temporary count\\n\\n    // Iterate through the sorted array\\n    for (int i = 1; i < numsSize; i++) {\\n        // Check if the current element is different from the previous one\\n        if (nums[i] != nums[i - 1]) {\\n            temp++; // Increment temporary count for a new unique element\\n        }"]]}
{"id": "1409", "ref_c": [["int minFlips(char * s){\\n    int len = strlen(s), idx = 0;\\n    int minOpers = INT_MAX, diff1 = 0, diff2 = 0, l = 0, r = 0;\\n    char *gStr = calloc(1, 2 * len + 1);        // given string\\n    // alternating target string starting with zero\\n    char *zTar = calloc(1, 2 * len + 1);     \\n    // alternating target string starting with one\\n    char *oTar = calloc(1, 2 * len + 1);\\n    \\n    // concatenate all strings to itself\\n    strcat(gStr, s);    strcat(gStr, s);\\n    \\n    for(int i = 0; i < 2 * len; i++) {\\n        zTar[idx] = i % 2 ? \\'1\\' : \\'0\\';\\n        oTar[idx++] = i % 2 ? \\'0\\' : \\'1\\';\\n    }"], ["int minFlips(char * s){\\n    int len = strlen(s), idx = 0;\\n    int minOpers = INT_MAX, diff1 = 0, diff2 = 0, l = 0, r = 0;\\n    char *gStr = calloc(1, 2 * len + 1);        // given string\\n    // alternating target string starting with zero\\n    char *zTar = calloc(1, 2 * len + 1);     \\n    // alternating target string starting with one\\n    char *oTar = calloc(1, 2 * len + 1);\\n    \\n    // concatenate all strings to itself\\n    strcat(gStr, s);    strcat(gStr, s);\\n    \\n    for(int i = 0; i < 2 * len; i++) {\\n        zTar[idx] = i % 2 ? \\'1\\' : \\'0\\';\\n        oTar[idx++] = i % 2 ? \\'0\\' : \\'1\\';\\n    }"], ["int minFlips(char * s){\\n    int len = strlen(s), idx = 0;\\n    int minOpers = INT_MAX, diff1 = 0, diff2 = 0, l = 0, r = 0;\\n    char *gStr = calloc(1, 2 * len + 1);        // given string\\n    // alternating target string starting with zero\\n    char *zTar = calloc(1, 2 * len + 1);     \\n    // alternating target string starting with one\\n    char *oTar = calloc(1, 2 * len + 1);\\n    \\n    // concatenate all strings to itself\\n    strcat(gStr, s);    strcat(gStr, s);\\n    \\n    for(int i = 0; i < 2 * len; i++) {\\n        zTar[idx] = i % 2 ? \\'1\\' : \\'0\\';\\n        oTar[idx++] = i % 2 ? \\'0\\' : \\'1\\';\\n    }"]]}
{"id": "1410", "ref_c": [["int chalkReplacer(int* chalk, int chalkSize, int k){\\n    long int sum=0;\\n\\n    //prefix sum to find sum of all chalks required\\n    for(int n = 0; n<chalkSize; n+=1)\\n    {\\n        sum+=chalk[n];\\n    }"], ["int chalkReplacer(int* chalk, int chalkSize, int k){\\n    if(k<chalk[0]) return 0;\\n    for(int i=1;i<chalkSize;i++){\\n        chalk[i]+=chalk[i-1];\\n        if(chalk[i] > k) return i;\\n    }"], ["int chalkReplacer(int* chalk, int chalkSize, int k){\\n    long sum = 0, temp = 0;\\n    for(int i = 0; i < chalkSize; i++)\\n        sum += chalk[i];\\n    sum = k % sum;\\n    for(int i = 0; i < chalkSize; i++)\\n    {\\n        temp += chalk[i];\\n        if(temp > sum)\\n            return i;\\n    }"]]}
{"id": "1411", "ref_c": [["bool hasAllCodes(char * s, int k){\\n  uint32_t req = (int) pow(2, k);\\n  uint32_t mask = req - 1;\\n  bool* const found = (bool*) calloc(req, sizeof(bool));\\n  uint32_t value = 0;\\n  for (int i = 0; i + 1 < k && *s; ++i) {\\n    value = (value << 1) + (*s++ - \\'0\\');\\n  }"], ["bool hasAllCodes(char * s, int k){\\n  uint32_t req = (int) pow(2, k);\\n  uint32_t mask = req - 1;\\n  bool* const found = (bool*) calloc(req, sizeof(bool));\\n  uint32_t value = 0;\\n  for (int i = 0; i + 1 < k && *s; ++i) {\\n    value = (value << 1) + (*s++ - \\'0\\');\\n  }"], ["bool hasAllCodes(char * s, int k){\\n  uint32_t req = (int) pow(2, k);\\n  uint32_t mask = req - 1;\\n  bool* const found = (bool*) calloc(req, sizeof(bool));\\n  uint32_t value = 0;\\n  for (int i = 0; i + 1 < k && *s; ++i) {\\n    value = (value << 1) + (*s++ - \\'0\\');\\n  }"]]}
{"id": "1412", "ref_c": [["int maximumRemovals(char * s, char * p, int* removable, int removableSize){\\n    int ns = strlen(s), np = strlen(p), nr = removableSize, lo = 0, hi = nr - 1, ans = 0;\\n    while(lo <= hi)\\n    {\\n        int mid = (lo + hi) >> 1, p1 = 0, p2 = 0;\\n        bool *vis = (bool *)calloc(ns, sizeof(bool));\\n        for(int i = 0;i <= mid; i++) vis[removable[i]] = 1;\\n        while(p1 < np && p2 < ns)\\n        {\\n            if(!vis[p2] && p[p1]==s[p2]) p1++;\\n            p2++;\\n        }"], ["int maximumRemovals(char * s, char * p, int* removable, int removableSize){\\n    int l = 0, r = removableSize - 1, mRemovals = 0;\\n    \\n    while(l <= r) {\\n        int m = l + (r - l) / 2;\\n        bool *remove = calloc(sizeof(bool), 100000);\\n    \\n        // mark all removable indices from 0 to m \\n        for(int i = 0; i <= m; i++) \\n            remove[removable[i]] = true;\\n        \\n        if(isSubsequence(s, p, remove)) {\\n            mRemovals = fmax(mRemovals, m+1);\\n            l = m + 1;\\n        }"], ["int maximumRemovals(char * s, char * p, int* removable, int removableSize){\\n    int ns = strlen(s), np = strlen(p), nr = removableSize, lo = 0, hi = nr - 1, ans = 0;\\n    while(lo <= hi)\\n    {\\n        int mid = (lo + hi) >> 1, p1 = 0, p2 = 0;\\n        bool *vis = (bool *)calloc(ns, sizeof(bool));\\n        for(int i = 0;i <= mid; i++) vis[removable[i]] = 1;\\n        while(p1 < np && p2 < ns)\\n        {\\n            if(!vis[p2] && p[p1]==s[p2]) p1++;\\n            p2++;\\n        }"]]}
{"id": "1413", "ref_c": [["char findTheDifference(char * s, char * t){\\n    int i = strlen(s);\\n    char t_sum = t[i--];\\n    for(; i >- 1; i--)\\n        t_sum ^= (t[i] ^ s[i]);\\n    return t_sum;\\n}"], ["char findTheDifference(char * s, char * t){\\n    int i = strlen(s);\\n    char t_sum = t[i--];\\n    for(; i >- 1; i--)\\n        t_sum ^= (t[i] ^ s[i]);\\n    return t_sum;\\n}"], ["char findTheDifference(char * s, char * t){\\n    int i = strlen(s);\\n    char t_sum = t[i--];\\n    for(; i >- 1; i--)\\n        t_sum ^= (t[i] ^ s[i]);\\n    return t_sum;\\n}"]]}
{"id": "1414", "ref_c": ["\nint* findPeakGrid(int** mat, int matSize, int* matColSize, int* returnSize){\n    *returnSize = 2;\n\n    int i = matSize/2;\n    int j = matColSize[i]/2;\n    while(1){\n        int neighbor_max = mat[i][j];\n        int neighbor_i = -1;\n        int neighbor_j = -1;\n        //Up\n        if(i-1 >= 0){\n            if(mat[i-1][j] > neighbor_max ){\n                neighbor_i = i-1;\n                neighbor_j = j;\n                neighbor_max = mat[i-1][j];\n            }\n        }\n\n        //Down\n        if(i+1 < matSize){\n            if(mat[i+1][j] > neighbor_max){\n                neighbor_i = i+1;\n                neighbor_j = j;\n                neighbor_max = mat[i+1][j];\n            }\n        }\n\n        //left\n        if(j-1>= 0){\n            if(mat[i][j-1] > neighbor_max ){\n                neighbor_i = i;\n                neighbor_j = j-1;\n                neighbor_max = mat[i][j-1];\n            }\n        }\n\n        //Right\n        if(j+1<matColSize[i]){\n            if(mat[i][j+1] > neighbor_max ){\n                neighbor_i = i;\n                neighbor_j = j+1;\n                neighbor_max = mat[i][j+1];\n            }\n        }\n\n        if(neighbor_i==-1){\n            break;\n        } else {\n            i = neighbor_i;\n            j = neighbor_j;\n        }\n    }\n    int *ret = malloc((*returnSize)*sizeof(int));\n    ret[0] = i;\n    ret[1] = j;\n    return ret;\n}\n", "\nint* findPeakGrid(int** mat, int matSize, int* matColSize, int* returnSize){\n    *returnSize = 2;\n\n    int i = matSize/2;\n    int j = matColSize[i]/2;\n    while(1){\n        int neighbor_max = mat[i][j];\n        int neighbor_i = -1;\n        int neighbor_j = -1;\n        //Up\n        if(i-1 >= 0){\n            if(mat[i-1][j] > neighbor_max ){\n                neighbor_i = i-1;\n                neighbor_j = j;\n                neighbor_max = mat[i-1][j];\n            }\n        }\n\n        //Down\n        if(i+1 < matSize){\n            if(mat[i+1][j] > neighbor_max){\n                neighbor_i = i+1;\n                neighbor_j = j;\n                neighbor_max = mat[i+1][j];\n            }\n        }\n\n        //left\n        if(j-1>= 0){\n            if(mat[i][j-1] > neighbor_max ){\n                neighbor_i = i;\n                neighbor_j = j-1;\n                neighbor_max = mat[i][j-1];\n            }\n        }\n\n        //Right\n        if(j+1<matColSize[i]){\n            if(mat[i][j+1] > neighbor_max ){\n                neighbor_i = i;\n                neighbor_j = j+1;\n                neighbor_max = mat[i][j+1];\n            }\n        }\n\n        if(neighbor_i==-1){\n            break;\n        } else {\n            i = neighbor_i;\n            j = neighbor_j;\n        }\n    }\n    int *ret = malloc((*returnSize)*sizeof(int));\n    ret[0] = i;\n    ret[1] = j;\n    return ret;\n}\n", "\nint* findPeakGrid(int** mat, int matSize, int* matColSize, int* returnSize){\n    *returnSize = 2;\n\n    int i = matSize/2;\n    int j = matColSize[i]/2;\n    while(1){\n        int neighbor_max = mat[i][j];\n        int neighbor_i = -1;\n        int neighbor_j = -1;\n        //Up\n        if(i-1 >= 0){\n            if(mat[i-1][j] > neighbor_max ){\n                neighbor_i = i-1;\n                neighbor_j = j;\n                neighbor_max = mat[i-1][j];\n            }\n        }\n\n        //Down\n        if(i+1 < matSize){\n            if(mat[i+1][j] > neighbor_max){\n                neighbor_i = i+1;\n                neighbor_j = j;\n                neighbor_max = mat[i+1][j];\n            }\n        }\n\n        //left\n        if(j-1>= 0){\n            if(mat[i][j-1] > neighbor_max ){\n                neighbor_i = i;\n                neighbor_j = j-1;\n                neighbor_max = mat[i][j-1];\n            }\n        }\n\n        //Right\n        if(j+1<matColSize[i]){\n            if(mat[i][j+1] > neighbor_max ){\n                neighbor_i = i;\n                neighbor_j = j+1;\n                neighbor_max = mat[i][j+1];\n            }\n        }\n\n        if(neighbor_i==-1){\n            break;\n        } else {\n            i = neighbor_i;\n            j = neighbor_j;\n        }\n    }\n    int *ret = malloc((*returnSize)*sizeof(int));\n    ret[0] = i;\n    ret[1] = j;\n    return ret;\n}\n"]}
{"id": "1415", "ref_c": [["int singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize == 1) {\\n        return nums[0];\\n    }"], ["int singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize == 1) {\\n        return nums[0];\\n    }"], ["int singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize == 1) {\\n        return nums[0];\\n    }"]]}
{"id": "1416", "ref_c": [["int countSubIslands(int** grid1, int grid1Size, int* grid1ColSize, int** grid2, int grid2Size, int* grid2ColSize){\\n    int rLimit = grid1Size - 1;\\n    int cLimit = *grid1ColSize - 1;\\n    int ans = 0;\\n    int diff = 0;\\n\\n    for(int i = 0; i < rLimit + 1; i++) {\\n        for(int j = 0; j < cLimit + 1; j++) {\\n            if(grid2[i][j] == 1) {\\n                if(search(grid1, grid2, i, j, rLimit, cLimit, &diff)) ans++;\\n                diff = 0;\\n            }"], ["int countSubIslands(int** grid1, int grid1Size, int* grid1ColSize, int** grid2, int grid2Size, int* grid2ColSize){\\n\\tconst int row = grid1Size, col = *grid1ColSize;\\n\\n\\tint cnt = 0;\\n\\n\\tstruct Point{int row, col;}"], ["int countSubIslands(int** grid1, int grid1Size, int* grid1ColSize, int** grid2, int grid2Size, int* grid2ColSize){\\n\\tconst int row = grid1Size, col = *grid1ColSize;\\n\\n\\tint cnt = 0;\\n\\n\\tstruct Point{int row, col;}"]]}
{"id": "1417", "ref_c": [["char * frequencySort(char * s){\\n    char *iterator = s;\\n    char_freq char_set[62] = {{\\'0\\', 0}"], ["char * frequencySort(char * s){\\n    char *iterator = s;\\n    char_freq char_set[62] = {{\\'0\\', 0}"], ["char * frequencySort(char * s){\\n    char *iterator = s;\\n    char_freq char_set[62] = {{\\'0\\', 0}"]]}
{"id": "1419", "ref_c": ["\nchar * removeOccurrences(char * s, char * part){\n    int flag, j;\n\n    int len = strlen(part);\n\n    for (int i = 0; s[i] != 0; i++)\n    {\n        if (*part == s[i])\n        {\n            flag = 1;\n            for (j = 1; part[j] != 0; j++)\n            {\n                if (part[j] != s[i + j])\n                {\n                    flag = 0;\n                    break;\n                }\n            }\n            if (flag)\n            {\n                for (j = i; s[j + len] != 0; j++)\n                {\n                    s[j] = s[j + len];\n                }\n                s[j] = 0;\n                i = (i <= len) ? -1 : i - len;\n            }\n        }\n    }\n    return s;\n\n}\n", "\nchar * removeOccurrences(char * s, char * part){\n    int flag, j;\n\n    int len = strlen(part);\n\n    for (int i = 0; s[i] != 0; i++)\n    {\n        if (*part == s[i])\n        {\n            flag = 1;\n            for (j = 1; part[j] != 0; j++)\n            {\n                if (part[j] != s[i + j])\n                {\n                    flag = 0;\n                    break;\n                }\n            }\n            if (flag)\n            {\n                for (j = i; s[j + len] != 0; j++)\n                {\n                    s[j] = s[j + len];\n                }\n                s[j] = 0;\n                i = (i <= len) ? -1 : i - len;\n            }\n        }\n    }\n    return s;\n\n}\n", "\nchar * removeOccurrences(char * s, char * part){\n    int flag, j;\n\n    int len = strlen(part);\n\n    for (int i = 0; s[i] != 0; i++)\n    {\n        if (*part == s[i])\n        {\n            flag = 1;\n            for (j = 1; part[j] != 0; j++)\n            {\n                if (part[j] != s[i + j])\n                {\n                    flag = 0;\n                    break;\n                }\n            }\n            if (flag)\n            {\n                for (j = i; s[j + len] != 0; j++)\n                {\n                    s[j] = s[j + len];\n                }\n                s[j] = 0;\n                i = (i <= len) ? -1 : i - len;\n            }\n        }\n    }\n    return s;\n\n}\n"]}
{"id": "1420", "ref_c": [["long long maxAlternatingSum(int* nums, int numsSize){\\n    long long sum = 0, odd = 0, even = 0;\\n    // loop run over the array.\\n    for (int i = 0; i < numsSize; i++){\\n        // compare between take the even number or not ans save max.\\n        even = MAX(odd+nums[i], even);\\n        // compare between minus the add number or not ans save max.\\n        odd = MAX(even-nums[i], odd);   \\n        // save maximum.\\n        sum = MAX(even, MAX(odd,sum));\\n    }"], ["long long maxAlternatingSum(int* nums, int numsSize) {\\r\\n    // DP method\\r\\n\\r\\n    // Time complexity: O(n)\\r\\n    // Space complexity: O(1)\\r\\n\\r\\n    long even = 0L;  // max alternating sum ending with a \\'even\\' index\\r\\n    long odd  = 0L;  // max alternating sum ending with a \\'odd\\' index\\r\\n\\r\\n    for (int i = 0; i < numsSize; i++) {\\r\\n        even = max(even, odd + nums[i]);\\r\\n        odd = even - nums[i];\\r\\n    }"], ["long long maxAlternatingSum(int* nums, int numsSize){\\n    long long sum = 0, odd = 0, even = 0;\\n    // loop run over the array.\\n    for (int i = 0; i < numsSize; i++){\\n        // compare between take the even number or not ans save max.\\n        even = MAX(odd+nums[i], even);\\n        // compare between minus the add number or not ans save max.\\n        odd = MAX(even-nums[i], odd);   \\n        // save maximum.\\n        sum = MAX(even, MAX(odd,sum));\\n    }"]]}
{"id": "1421", "ref_c": [["int** rotateGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\r\\n\\tconst int row = gridSize, col = *gridColSize;\\r\\n\\r\\n\\tint bufArr[(col - 1) * 2 + (row - 1) * 2];\\r\\n\\tint bufArrLen;\\r\\n\\r\\n\\tconst int round = MIN(row, col) / 2;\\r\\n\\tfor (int curRound = 0; curRound < round; curRound += 1){\\r\\n\\t\\tbufArrLen = 0;\\r\\n\\t\\tfor (int curRow = curRound, curCol = curRound; curRow < row - 1 - curRound; curRow += 1){\\r\\n\\t\\t\\tbufArr[bufArrLen] = grid[curRow][curCol];\\r\\n\\t\\t\\tbufArrLen += 1;\\r\\n\\t\\t}"], ["int** rotateGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\r\\n    int **ret, row, col, h_row, h_col;\\r\\n    int **seq, *seqSize, seqNum;\\r\\n    int ti, tj;\\r\\n    \\r\\n    row = gridSize;\\r\\n    col = gridColSize[0];\\r\\n    h_row = row / 2;\\r\\n    h_col = col / 2;\\r\\n    //printf(\"row:%d, col:%d, h_row:%d, h_col:%d\\\\n\", row, col, h_row, h_col);\\r\\n\\r\\n    //prepare return array\\r\\n    *returnSize = row;\\r\\n    ret = malloc(sizeof(int *) * row);\\r\\n    *returnColumnSizes = calloc(sizeof(int), row);\\r\\n    for (int i = 0; i < row; ++i) {\\r\\n        (*returnColumnSizes)[i]= col;\\r\\n        ret[i] = calloc(sizeof(int), col);\\r\\n    }"], ["int** rotateGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    int **ret = malloc(m * sizeof(int*));\\n    for (int i = 0; i < m; i++){\\n        ret[i] = malloc(n * sizeof(int));\\n    }"]]}
{"id": "1422", "ref_c": [["bool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}"], ["bool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}"], ["bool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}"]]}
{"id": "1423", "ref_c": ["\nint compare(const void *a, const void *b) {\n    double d1 = *(double*)a;\n    double d2 = *(double*)b;\n    \n    if (d1 < d2) return -1;\n    if (d1 > d2) return 1;\n    return 0;\n}\n\nint eliminateMaximum(int* dist, int distSize, int* speed, int speedSize) {\n    double arrivalTimes[speedSize];\n    for (int i = 0; i < speedSize; i++) {\n        arrivalTimes[i] = (double)dist[i] / (double)speed[i];\n    }\n    \n    qsort(arrivalTimes, speedSize, sizeof(double), compare);\n    \n    int eliminated = 0;\n    for (int i = 0; i < speedSize; i++) {\n        if ((double)i >= arrivalTimes[i]) {\n            break;\n        }\n        eliminated++;\n    }\n    \n    return eliminated;   \n}\n", "\nint compare(const void *a, const void *b) {\n    double d1 = *(double*)a;\n    double d2 = *(double*)b;\n    \n    if (d1 < d2) return -1;\n    if (d1 > d2) return 1;\n    return 0;\n}\n\nint eliminateMaximum(int* dist, int distSize, int* speed, int speedSize) {\n    double arrivalTimes[speedSize];\n    for (int i = 0; i < speedSize; i++) {\n        arrivalTimes[i] = (double)dist[i] / (double)speed[i];\n    }\n    \n    qsort(arrivalTimes, speedSize, sizeof(double), compare);\n    \n    int eliminated = 0;\n    for (int i = 0; i < speedSize; i++) {\n        if ((double)i >= arrivalTimes[i]) {\n            break;\n        }\n        eliminated++;\n    }\n    \n    return eliminated;   \n}\n", "\nint compare(const void *a, const void *b) {\n    double d1 = *(double*)a;\n    double d2 = *(double*)b;\n    \n    if (d1 < d2) return -1;\n    if (d1 > d2) return 1;\n    return 0;\n}\n\nint eliminateMaximum(int* dist, int distSize, int* speed, int speedSize) {\n    double arrivalTimes[speedSize];\n    for (int i = 0; i < speedSize; i++) {\n        arrivalTimes[i] = (double)dist[i] / (double)speed[i];\n    }\n    \n    qsort(arrivalTimes, speedSize, sizeof(double), compare);\n    \n    int eliminated = 0;\n    for (int i = 0; i < speedSize; i++) {\n        if ((double)i >= arrivalTimes[i]) {\n            break;\n        }\n        eliminated++;\n    }\n    \n    return eliminated;   \n}\n"]}
{"id": "1424", "ref_c": [["int countGoodNumbers(long long n) {\\n        int m=1000000007;\\n        long long ans=1;\\n        long long even=5;\\n        long long odd=4;\\n        long long x=0;\\n        long long y=0;\\n        if(n&1){\\n            x=n/2+1;\\n            y=n-x;\\n        }", "int countGoodNumbers(long long n) {\\n        int m=1000000007;\\n        long long ans=1;\\n        long long even=5;\\n        long long odd=4;\\n        long long x=0;\\n        long long y=0;\\n        if(n&1){\\n            x=n/2+1;\\n            y=n-x;\\n        }"], ["int countGoodNumbers(long long n) {\\n    long long mod = 1000000007;\\n    long long e = n / 2 + n % 2;\\n    long long o = n / 2;\\n\\n    long long an= (power(5,e,mod)*power(4,o,mod))%mod;\\n    return an;\\n}"], ["int countGoodNumbers(long long n) {\\n        int m=1000000007;\\n        long long ans=1;\\n        long long even=5;\\n        long long odd=4;\\n        long long x=0;\\n        long long y=0;\\n        if(n&1){\\n            x=n/2+1;\\n            y=n-x;\\n        }", "int countGoodNumbers(long long n) {\\n        int m=1000000007;\\n        long long ans=1;\\n        long long even=5;\\n        long long odd=4;\\n        long long x=0;\\n        long long y=0;\\n        if(n&1){\\n            x=n/2+1;\\n            y=n-x;\\n        }"]]}
{"id": "1425", "ref_c": [["int nearestExit(char** maze, int mazeSize, int* mazeColSize, int* entrance, int entranceSize){\\n    char cMazeSize = mazeSize - 1, cMazeColSize = *mazeColSize - 1;\\n\\n    struct MazeRecord* pstHead = (struct MazeRecord*) malloc(sizeof(struct MazeRecord));\\n    pstHead->cRow = *entrance;\\n    pstHead->cCol = *(entrance + 1);\\n    pstHead->sDistance = 0;\\n    pstHead->pstNext = NULL;\\n    maze[pstHead->cRow][pstHead->cCol] = \\',\\';\\n\\n    short sRet = 0;\\n    struct MazeRecord* pstTail = pstHead;\\n    while(pstHead)\\n    {\\n        // check up\\n        if(pstHead->cRow && maze[pstHead->cRow-1][pstHead->cCol] == \\'.\\')\\n        {\\n            if(pstHead->cRow-1 == 0 || pstHead->cCol == 0 || pstHead->cCol == cMazeColSize)\\n            {\\n                sRet = pstHead->sDistance + 1;\\n                break;\\n            }"], ["int nearestExit(char** maze, int mazeSize, int* mazeColSize, int* entrance, int entranceSize){\\n    int rLimit = mazeSize - 1;\\n    int cLimit = *mazeColSize -1;\\n    int total = mazeSize * (*mazeColSize);\\n    int front = 0, rear = 0;\\n    int** queue = malloc(total * sizeof(int*));\\n\\n    for(int i = 0; i < total; i++) {\\n        queue[i] = malloc(2 * sizeof(int));\\n    }"], ["int nearestExit(char** maze, int mazeSize, int* mazeColSize, int* entrance, int entranceSize){\\n    int** visited = malloc(mazeSize * sizeof(int*));\\n    for (int i = 0; i < mazeSize; i++)\\n    {\\n        visited[i] = malloc(*mazeColSize * sizeof(int));\\n        memset(visited[i], 0, *mazeColSize * sizeof(int));\\n    }"]]}
{"id": "1426", "ref_c": [["int findLucky(int* arr, int arrSize) {\\n\\n int   b[501]={0}"], ["int findLucky(int* arr, int arrSize) {\\n\\n int   b[501]={0}"], ["int findLucky(int* arr, int arrSize) {\\n\\n int   b[501]={0}"]]}
{"id": "1427", "ref_c": ["\nint countPalindromicSubsequence(char* s) {\n    int len = strlen(s);\n    int total_count = 0;\n    uint letters_mask = 0;\n\n    // loops through each letter once...\n    for(int i =0; i< len - 1; i++){\n        char letter = s[i];\n        int temp_count = 0;\n        uint sub_letters_mask = 0;\n        int mask = BIT_MASK(letter-'a');\n\n        if ((mask&letters_mask) == 0){\n            letters_mask |= mask;\n            int pair_found = 0;\n\n            // For each letter find potential pairs\n            for (int j =i + 1;j<len;j++){\n                int mask = BIT_MASK(s[j]-'a');\n                if (s[j] == letter){ //found the same letter      \n                    // Record all valid pairs before the potential palindrome end\n                    total_count += temp_count;\n                    temp_count = 0;\n                    pair_found++;\n\n                    // If this matching letter is the first duplicate, \n                    // count it as a valid pair. The count will be recorded \n                    // the next time a matching letter is found. \n                    // But do not add it to the bit mask yet.\n                    if (pair_found == 1){\n                        temp_count++;\n                    }\n                    // The second time seeing the duplicate we can \n                    // add the pair to the bit mask.\n                    else if (pair_found == 2){\n                        sub_letters_mask |= mask;\n                    }\n                    \n                    // Only exit the loop on a matching pair.\n                    // could be optimized\n                    if (sub_letters_mask == ALL_LETTERS){\n                        break;\n                    }\n                }\n                else { \n                    // Adds unique middle letters of the palindome\n                    if ((mask&sub_letters_mask) == 0){\n                        sub_letters_mask |= mask; //adds letter\n                        temp_count++;\n                    }\n                }\n            }\n            if (letters_mask == ALL_LETTERS){\n                break;\n            }\n        }\n    }\n    return total_count;\n}\n", "\nint countPalindromicSubsequence(char* s) {\n    int len = strlen(s);\n    int total_count = 0;\n    uint letters_mask = 0;\n\n    // loops through each letter once...\n    for(int i =0; i< len - 1; i++){\n        char letter = s[i];\n        int temp_count = 0;\n        uint sub_letters_mask = 0;\n        int mask = BIT_MASK(letter-'a');\n\n        if ((mask&letters_mask) == 0){\n            letters_mask |= mask;\n            int pair_found = 0;\n\n            // For each letter find potential pairs\n            for (int j =i + 1;j<len;j++){\n                int mask = BIT_MASK(s[j]-'a');\n                if (s[j] == letter){ //found the same letter      \n                    // Record all valid pairs before the potential palindrome end\n                    total_count += temp_count;\n                    temp_count = 0;\n                    pair_found++;\n\n                    // If this matching letter is the first duplicate, \n                    // count it as a valid pair. The count will be recorded \n                    // the next time a matching letter is found. \n                    // But do not add it to the bit mask yet.\n                    if (pair_found == 1){\n                        temp_count++;\n                    }\n                    // The second time seeing the duplicate we can \n                    // add the pair to the bit mask.\n                    else if (pair_found == 2){\n                        sub_letters_mask |= mask;\n                    }\n                    \n                    // Only exit the loop on a matching pair.\n                    // could be optimized\n                    if (sub_letters_mask == ALL_LETTERS){\n                        break;\n                    }\n                }\n                else { \n                    // Adds unique middle letters of the palindome\n                    if ((mask&sub_letters_mask) == 0){\n                        sub_letters_mask |= mask; //adds letter\n                        temp_count++;\n                    }\n                }\n            }\n            if (letters_mask == ALL_LETTERS){\n                break;\n            }\n        }\n    }\n    return total_count;\n}\n", "\nint countPalindromicSubsequence(char* s) {\n    int len = strlen(s);\n    int total_count = 0;\n    uint letters_mask = 0;\n\n    // loops through each letter once...\n    for(int i =0; i< len - 1; i++){\n        char letter = s[i];\n        int temp_count = 0;\n        uint sub_letters_mask = 0;\n        int mask = BIT_MASK(letter-'a');\n\n        if ((mask&letters_mask) == 0){\n            letters_mask |= mask;\n            int pair_found = 0;\n\n            // For each letter find potential pairs\n            for (int j =i + 1;j<len;j++){\n                int mask = BIT_MASK(s[j]-'a');\n                if (s[j] == letter){ //found the same letter      \n                    // Record all valid pairs before the potential palindrome end\n                    total_count += temp_count;\n                    temp_count = 0;\n                    pair_found++;\n\n                    // If this matching letter is the first duplicate, \n                    // count it as a valid pair. The count will be recorded \n                    // the next time a matching letter is found. \n                    // But do not add it to the bit mask yet.\n                    if (pair_found == 1){\n                        temp_count++;\n                    }\n                    // The second time seeing the duplicate we can \n                    // add the pair to the bit mask.\n                    else if (pair_found == 2){\n                        sub_letters_mask |= mask;\n                    }\n                    \n                    // Only exit the loop on a matching pair.\n                    // could be optimized\n                    if (sub_letters_mask == ALL_LETTERS){\n                        break;\n                    }\n                }\n                else { \n                    // Adds unique middle letters of the palindome\n                    if ((mask&sub_letters_mask) == 0){\n                        sub_letters_mask |= mask; //adds letter\n                        temp_count++;\n                    }\n                }\n            }\n            if (letters_mask == ALL_LETTERS){\n                break;\n            }\n        }\n    }\n    return total_count;\n}\n"]}
{"id": "1429", "ref_c": [["int addRungs(int* rungs, int rungsSize, int dist){\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < rungsSize; i++) {\\n\\n        count += (rungs[i] - (i > 0 ? rungs[i - 1] : 0) - 1) / dist; \\n\\n    }"], ["int addRungs(int* rungs, int rungsSize, int dist){\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < rungsSize; i++) {\\n\\n        count += (rungs[i] - (i > 0 ? rungs[i - 1] : 0) - 1) / dist; \\n\\n    }"], ["int addRungs(int* rungs, int rungsSize, int dist){\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < rungsSize; i++) {\\n\\n        count += (rungs[i] - (i > 0 ? rungs[i - 1] : 0) - 1) / dist; \\n\\n    }"]]}
{"id": "1430", "ref_c": [["long long maxPoints(int** points, int pointsSize, int* pointsColSize){\\n    long long dp[*pointsColSize];\\n    long long tdp[*pointsColSize];\\n    long long *tm1, *tm2;\\n    long long ret_val;\\n    int i;\\n    for(i = 0;i < *pointsColSize;i++){\\n        dp[i] = points[pointsSize-1][i];\\n    }"], ["long long maxPoints(int** points, int pointsSize, int* pointsColSize){\\n    long long dp[*pointsColSize];\\n    long long tdp[*pointsColSize];\\n    long long *tm1, *tm2;\\n    long long ret_val;\\n    int i;\\n    for(i = 0;i < *pointsColSize;i++){\\n        dp[i] = points[pointsSize-1][i];\\n    }"], ["long long maxPoints(int** points, int pointsSize, int* pointsColSize){\\n    long long dp[*pointsColSize];\\n    long long tdp[*pointsColSize];\\n    long long *tm1, *tm2;\\n    long long ret_val;\\n    int i;\\n    for(i = 0;i < *pointsColSize;i++){\\n        dp[i] = points[pointsSize-1][i];\\n    }"]]}
{"id": "1431", "ref_c": [["int smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend){\\n    int ans = 0;\\n    int **chair = malloc(timesSize*sizeof(int*));\\n    int **qdata = malloc(timesSize*sizeof(int*));\\n    int *valid = malloc((timesSize+1)*sizeof(int));\\n    int *invalid  = malloc((timesSize+1)*sizeof(int));\\n    int valididx = timesSize;\\n    int invalididx = 0;\\n    for(int i=0;i<timesSize;i++){\\n        qdata[i] = malloc(3*sizeof(int));\\n        qdata[i][0] = times[i][0];\\n        qdata[i][1] = times[i][1];\\n        qdata[i][2] = i;\\n        chair[i] = malloc(3*sizeof(int));\\n        chair[i][0] = i;\\n        chair[i][1] = i;\\n        chair[i][2] = 0;\\n        valid[i+1] = i;\\n    }"], ["int smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend){\\n    int ans = 0;\\n    int **chair = malloc(timesSize*sizeof(int*));\\n    int **qdata = malloc(timesSize*sizeof(int*));\\n    int *valid = malloc((timesSize+1)*sizeof(int));\\n    int *invalid  = malloc((timesSize+1)*sizeof(int));\\n    int valididx = timesSize;\\n    int invalididx = 0;\\n    for(int i=0;i<timesSize;i++){\\n        qdata[i] = malloc(3*sizeof(int));\\n        qdata[i][0] = times[i][0];\\n        qdata[i][1] = times[i][1];\\n        qdata[i][2] = i;\\n        chair[i] = malloc(3*sizeof(int));\\n        chair[i][0] = i;\\n        chair[i][1] = i;\\n        chair[i][2] = 0;\\n        valid[i+1] = i;\\n    }"], ["int smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend){\\n    int ans = 0;\\n    int **chair = malloc(timesSize*sizeof(int*));\\n    int **qdata = malloc(timesSize*sizeof(int*));\\n    int *valid = malloc((timesSize+1)*sizeof(int));\\n    int *invalid  = malloc((timesSize+1)*sizeof(int));\\n    int valididx = timesSize;\\n    int invalididx = 0;\\n    for(int i=0;i<timesSize;i++){\\n        qdata[i] = malloc(3*sizeof(int));\\n        qdata[i][0] = times[i][0];\\n        qdata[i][1] = times[i][1];\\n        qdata[i][2] = i;\\n        chair[i] = malloc(3*sizeof(int));\\n        chair[i][0] = i;\\n        chair[i][1] = i;\\n        chair[i][2] = 0;\\n        valid[i+1] = i;\\n    }"]]}
{"id": "1432", "ref_c": [["struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n \\n    // 1. Traverse A and B to find their lengths\\n    int countA = 0, countB = 0;\\n    for (struct ListNode *thisA = headA; thisA != NULL; thisA = thisA->next) {\\n        ++countA;\\n    }"], ["struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (headA == NULL || headB == NULL)\\n        return NULL;\\n\\n    struct ListNode* A = headA;\\n    struct ListNode* B = headB;\\n\\n    while (A != B) {\\n        A = A == NULL ? headB : A->next;\\n        B = B == NULL ? headA : B->next;\\n    }"], ["struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n \\n    // 1. Traverse A and B to find their lengths\\n    int countA = 0, countB = 0;\\n    for (struct ListNode *thisA = headA; thisA != NULL; thisA = thisA->next) {\\n        ++countA;\\n    }"]]}
{"id": "1433", "ref_c": [["char nextGreatestLetter(char* letters, int lettersSize, char target) {\\n    int left = 0, right = lettersSize - 1;\\n    int ans = 0;\\n    while (left <= right){\\n        int mid = left + (right - left) / 2;\\n        if (letters[mid] > target){\\n            ans = mid;\\n            right = mid - 1;\\n        }"], ["char nextGreatestLetter(char* letters, int lettersSize, char target) {\\n    int left = 0, right = lettersSize - 1;\\n    int ans = 0;\\n    while (left <= right){\\n        int mid = left + (right - left) / 2;\\n        if (letters[mid] > target){\\n            ans = mid;\\n            right = mid - 1;\\n        }"], ["char nextGreatestLetter(char* letters, int lettersSize, char target) {\\n    int left = 0, right = lettersSize - 1;\\n    int ans = 0;\\n    while (left <= right){\\n        int mid = left + (right - left) / 2;\\n        if (letters[mid] > target){\\n            ans = mid;\\n            right = mid - 1;\\n        }"]]}
{"id": "1434", "ref_c": [["int maxCompatibilitySum(int** students, int studentsSize, int* studentsColSize, int** mentors, int mentorsSize, int* mentorsColSize){\\n    \\n    int i;\\n    int res = 0;max = 0;\\n    int sidx=0;\\n    int p;\\n    int mentor_state[10];\\n    for (i=0; i < mentorsSize; i++)\\n    {\\n        res = 0;\\n        memset(&mentor_state[0],0,sizeof(mentor_state));\\n        mentor_state[i] = 1;\\n        for (p=0; p < *studentsColSize; p++)\\n        {\\n            if (students[sidx][p] == mentors[i][p])\\n            {\\n                res++;\\n            }"], ["int maxCompatibilitySum(int** students, int studentsSize, int* studentsColSize, int** mentors, int mentorsSize, int* mentorsColSize){\\n    max = 0;\\n    int **score = calloc(studentsSize, sizeof(int*));\\n    for (int s = 0; s < studentsSize; s++){\\n        score[s] = calloc(mentorsSize, sizeof(int));\\n        for (int m = 0; m < mentorsSize;m++){\\n            for (int col = 0; col < *studentsColSize; col++){\\n                score[s][m] = score[s][m] + (students[s][col] == mentors[m][col]);\\n            }"], ["int maxCompatibilitySum(int** students, int studentsSize, int* studentsColSize, int** mentors, int mentorsSize, int* mentorsColSize){\\n    \\n    int i;\\n    int res = 0;max = 0;\\n    int sidx=0;\\n    int p;\\n    int mentor_state[10];\\n    for (i=0; i < mentorsSize; i++)\\n    {\\n        res = 0;\\n        memset(&mentor_state[0],0,sizeof(mentor_state));\\n        mentor_state[i] = 1;\\n        for (p=0; p < *studentsColSize; p++)\\n        {\\n            if (students[sidx][p] == mentors[i][p])\\n            {\\n                res++;\\n            }"]]}
{"id": "1435", "ref_c": [["long long numberOfWeeks(int* milestones, int milestonesSize){\\n    int hig = 0;\\n    long long total = 0;\\n    for(int i = 0; i < milestonesSize; i++)\\n    {\\n        if(hig < milestones[i])    // find the highest milestone of the project.\\n            hig = milestones[i];\\n        total += milestones[i];   // total milestones for the project.\\n    }"], ["long long numberOfWeeks(int* milestones, int milestonesSize){\\n    int hig = 0;\\n    long long total = 0;\\n    for(int i = 0; i < milestonesSize; i++)\\n    {\\n        if(hig < milestones[i])    // find the highest milestone of the project.\\n            hig = milestones[i];\\n        total += milestones[i];   // total milestones for the project.\\n    }"], ["long long numberOfWeeks(int* milestones, int milestonesSize){\\n    int hig = 0;\\n    long long total = 0;\\n    for(int i = 0; i < milestonesSize; i++)\\n    {\\n        if(hig < milestones[i])    // find the highest milestone of the project.\\n            hig = milestones[i];\\n        total += milestones[i];   // total milestones for the project.\\n    }"]]}
{"id": "1436", "ref_c": [["long long minimumPerimeter(long long neededApples) {\\n    // Binary search + Math\\n\\n    // Time complexity: O(log(10^5)) == O(1)\\n    // Space complexity: O(1)\\n\\n    long long left = 1, right = 100000, middle = 0;\\n    while (left < right) {\\n        middle = left + (right - left) / 2;\\n        if (num_apples(middle) >= neededApples) {\\n            right = middle;\\n        }"], ["long long minimumPerimeter(long long neededApples) {\\n    // Binary search + Math\\n\\n    // Time complexity: O(log(10^5)) == O(1)\\n    // Space complexity: O(1)\\n\\n    long long left = 1, right = 100000, middle = 0;\\n    while (left < right) {\\n        middle = left + (right - left) / 2;\\n        if (num_apples(middle) >= neededApples) {\\n            right = middle;\\n        }"], ["long long minimumPerimeter(long long neededApples) {\\n    // Binary search + Math\\n\\n    // Time complexity: O(log(10^5)) == O(1)\\n    // Space complexity: O(1)\\n\\n    long long left = 1, right = 100000, middle = 0;\\n    while (left < right) {\\n        middle = left + (right - left) / 2;\\n        if (num_apples(middle) >= neededApples) {\\n            right = middle;\\n        }"]]}
{"id": "1437", "ref_c": ["\nbool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n        \n        // all 4 sides + 2 diagonal distance    \n        int d1= abs(p1[0]-p2[0])*abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])*abs(p1[1]-p2[1]);\n        int d2= abs(p1[0]-p3[0])*abs(p1[0]-p3[0]) + abs(p1[1]-p3[1])*abs(p1[1]-p3[1]);\n        int d3= abs(p1[0]-p4[0])*abs(p1[0]-p4[0]) + abs(p1[1]-p4[1])*abs(p1[1]-p4[1]);\n        int d4= abs(p2[0]-p3[0])*abs(p2[0]-p3[0]) + abs(p2[1]-p3[1])*abs(p2[1]-p3[1]);\n        int d5= abs(p2[0]-p4[0])*abs(p2[0]-p4[0]) + abs(p2[1]-p4[1])*abs(p2[1]-p4[1]);\n        int d6= abs(p3[0]-p4[0])*abs(p3[0]-p4[0]) + abs(p3[1]-p4[1])*abs(p3[1]-p4[1]);\n\n        vector<int>v;\n        v.push_back(d1);\n        v.push_back(d2);\n        v.push_back(d3);\n        v.push_back(d4);\n        v.push_back(d5);\n        v.push_back(d6);\n        //cout<<d1<<\" \"<<d2<<\" \"<<d3<<\" \"<<d4<<\" \"<<d5<<\" \"<<d6<<\" \";\n \n      sort(v.begin(),v.end());\n\n      // 4 sides have same distance && 2 diagonal have same distance && diagonal distance is greater than side distance \n      if((v[0]==v[1] && (v[2]==v[3] && v[3]==v[4] && v[4]==v[5] ) && v[0]>v[2])\n        ||(v[4]==v[5] && (v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) && v[4]>v[0]))\n      {\n          return true;\n      }\n\n\n         \n        return false;\n    }\n", "\nbool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n        \n        // all 4 sides + 2 diagonal distance    \n        int d1= abs(p1[0]-p2[0])*abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])*abs(p1[1]-p2[1]);\n        int d2= abs(p1[0]-p3[0])*abs(p1[0]-p3[0]) + abs(p1[1]-p3[1])*abs(p1[1]-p3[1]);\n        int d3= abs(p1[0]-p4[0])*abs(p1[0]-p4[0]) + abs(p1[1]-p4[1])*abs(p1[1]-p4[1]);\n        int d4= abs(p2[0]-p3[0])*abs(p2[0]-p3[0]) + abs(p2[1]-p3[1])*abs(p2[1]-p3[1]);\n        int d5= abs(p2[0]-p4[0])*abs(p2[0]-p4[0]) + abs(p2[1]-p4[1])*abs(p2[1]-p4[1]);\n        int d6= abs(p3[0]-p4[0])*abs(p3[0]-p4[0]) + abs(p3[1]-p4[1])*abs(p3[1]-p4[1]);\n\n        vector<int>v;\n        v.push_back(d1);\n        v.push_back(d2);\n        v.push_back(d3);\n        v.push_back(d4);\n        v.push_back(d5);\n        v.push_back(d6);\n        //cout<<d1<<\" \"<<d2<<\" \"<<d3<<\" \"<<d4<<\" \"<<d5<<\" \"<<d6<<\" \";\n \n      sort(v.begin(),v.end());\n\n      // 4 sides have same distance && 2 diagonal have same distance && diagonal distance is greater than side distance \n      if((v[0]==v[1] && (v[2]==v[3] && v[3]==v[4] && v[4]==v[5] ) && v[0]>v[2])\n        ||(v[4]==v[5] && (v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) && v[4]>v[0]))\n      {\n          return true;\n      }\n\n\n         \n        return false;\n    }\n", "\nbool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {\n        \n        // all 4 sides + 2 diagonal distance    \n        int d1= abs(p1[0]-p2[0])*abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])*abs(p1[1]-p2[1]);\n        int d2= abs(p1[0]-p3[0])*abs(p1[0]-p3[0]) + abs(p1[1]-p3[1])*abs(p1[1]-p3[1]);\n        int d3= abs(p1[0]-p4[0])*abs(p1[0]-p4[0]) + abs(p1[1]-p4[1])*abs(p1[1]-p4[1]);\n        int d4= abs(p2[0]-p3[0])*abs(p2[0]-p3[0]) + abs(p2[1]-p3[1])*abs(p2[1]-p3[1]);\n        int d5= abs(p2[0]-p4[0])*abs(p2[0]-p4[0]) + abs(p2[1]-p4[1])*abs(p2[1]-p4[1]);\n        int d6= abs(p3[0]-p4[0])*abs(p3[0]-p4[0]) + abs(p3[1]-p4[1])*abs(p3[1]-p4[1]);\n\n        vector<int>v;\n        v.push_back(d1);\n        v.push_back(d2);\n        v.push_back(d3);\n        v.push_back(d4);\n        v.push_back(d5);\n        v.push_back(d6);\n        //cout<<d1<<\" \"<<d2<<\" \"<<d3<<\" \"<<d4<<\" \"<<d5<<\" \"<<d6<<\" \";\n \n      sort(v.begin(),v.end());\n\n      // 4 sides have same distance && 2 diagonal have same distance && diagonal distance is greater than side distance \n      if((v[0]==v[1] && (v[2]==v[3] && v[3]==v[4] && v[4]==v[5] ) && v[0]>v[2])\n        ||(v[4]==v[5] && (v[0]==v[1] && v[1]==v[2] && v[2]==v[3]) && v[4]>v[0]))\n      {\n          return true;\n      }\n\n\n         \n        return false;\n    }\n"]}
{"id": "1438", "ref_c": [["char * findReplaceString(char * s, int* indices, int indicesSize, char ** sources, int sourcesSize, char ** targets, int targetsSize){\\n    int len = strlen(s), indiceIdx = 0, ansIdx = 0, idx = 0;\\n    char* ans = (char*)calloc(5000, sizeof(char));\\n    /* mapping if indices not in order */\\n    int* mapping = (int*)calloc(len+1, sizeof(int));\\n    for(int i = 0; i < indicesSize; i++)\\n        mapping[indices[i]] = i+1;\\n    while(idx < len)\\n    {\\n        if(indiceIdx < indicesSize && mapping[idx]){\\n            int mapIdx = mapping[idx] - 1;\\n            int currLen = strlen(sources[mapIdx]);\\n            if(strncmp(s+idx, sources[mapIdx], currLen)==0)\\n            {\\n                int targetLen = strlen(targets[mapIdx]);\\n                memcpy(ans+ansIdx, targets[mapIdx], targetLen);\\n                ansIdx += targetLen;\\n                idx += currLen;\\n            }"], ["char * findReplaceString(char * s, int* indices, int indicesSize, char ** sources, int sourcesSize, char ** targets, int targetsSize){\\n    int len = strlen(s), indiceIdx = 0, ansIdx = 0, idx = 0;\\n    char* ans = (char*)calloc(5000, sizeof(char));\\n    /* mapping if indices not in order */\\n    int* mapping = (int*)calloc(len+1, sizeof(int));\\n    for(int i = 0; i < indicesSize; i++)\\n        mapping[indices[i]] = i+1;\\n    while(idx < len)\\n    {\\n        if(indiceIdx < indicesSize && mapping[idx]){\\n            int mapIdx = mapping[idx] - 1;\\n            int currLen = strlen(sources[mapIdx]);\\n            if(strncmp(s+idx, sources[mapIdx], currLen)==0)\\n            {\\n                int targetLen = strlen(targets[mapIdx]);\\n                memcpy(ans+ansIdx, targets[mapIdx], targetLen);\\n                ansIdx += targetLen;\\n                idx += currLen;\\n            }"], ["char * findReplaceString(char * s, int* indices, int indicesSize, char ** sources, int sourcesSize, char ** targets, int targetsSize){\\n    int len = strlen(s), indiceIdx = 0, ansIdx = 0, idx = 0;\\n    char* ans = (char*)calloc(5000, sizeof(char));\\n    /* mapping if indices not in order */\\n    int* mapping = (int*)calloc(len+1, sizeof(int));\\n    for(int i = 0; i < indicesSize; i++)\\n        mapping[indices[i]] = i+1;\\n    while(idx < len)\\n    {\\n        if(indiceIdx < indicesSize && mapping[idx]){\\n            int mapIdx = mapping[idx] - 1;\\n            int currLen = strlen(sources[mapIdx]);\\n            if(strncmp(s+idx, sources[mapIdx], currLen)==0)\\n            {\\n                int targetLen = strlen(targets[mapIdx]);\\n                memcpy(ans+ansIdx, targets[mapIdx], targetLen);\\n                ansIdx += targetLen;\\n                idx += currLen;\\n            }"]]}
{"id": "1439", "ref_c": [["int minStoneSum(int* piles, int pilesSize, int k){\\n    int* pilesCnt = (int*)calloc(1e4+1, sizeof(int));\\n    int sum = 0;\\n    for(int i = 0; i < pilesSize; i++) {\\n        sum += piles[i];\\n        pilesCnt[piles[i]]++;\\n    }"], ["int minStoneSum(int* piles, int pilesSize, int k){\\n    int* pilesCnt = (int*)calloc(1e4+1, sizeof(int));\\n    int sum = 0;\\n    for(int i = 0; i < pilesSize; i++) {\\n        sum += piles[i];\\n        pilesCnt[piles[i]]++;\\n    }"], ["int minStoneSum(int* piles, int pilesSize, int k){\\n    int* pilesCnt = (int*)calloc(1e4+1, sizeof(int));\\n    int sum = 0;\\n    for(int i = 0; i < pilesSize; i++) {\\n        sum += piles[i];\\n        pilesCnt[piles[i]]++;\\n    }"]]}
{"id": "1440", "ref_c": [["int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\\n    \\n    /* Sort the candidates to group duplicates together */\\n    qsort(candidates, candidatesSize, sizeof(int), sortFunc);\\n    \\n    /* Array to store the current solution */\\n    int* current = (int*)malloc(100*sizeof(int));\\n    int currentLength = 0;\\n    \\n    /* Allocate initial memory to answer and returnColumnSizes */\\n    int** answer = (int**)malloc(sizeof(int*));\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int));\\n    \\n    (*returnSize) = 0;\\n    \\n    /* Call the helper with our initial conditions */\\n    helper(candidates, candidatesSize, target, 0, current, currentLength, returnSize, returnColumnSizes, &answer);\\n    \\n    free(current);\\n    return answer;\\n}"], ["int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\\n    \\n    /* Sort the candidates to group duplicates together */\\n    qsort(candidates, candidatesSize, sizeof(int), sortFunc);\\n    \\n    /* Array to store the current solution */\\n    int* current = (int*)malloc(100*sizeof(int));\\n    int currentLength = 0;\\n    \\n    /* Allocate initial memory to answer and returnColumnSizes */\\n    int** answer = (int**)malloc(sizeof(int*));\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int));\\n    \\n    (*returnSize) = 0;\\n    \\n    /* Call the helper with our initial conditions */\\n    helper(candidates, candidatesSize, target, 0, current, currentLength, returnSize, returnColumnSizes, &answer);\\n    \\n    free(current);\\n    return answer;\\n}"], ["int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){\\n    \\n    /* Sort the candidates to group duplicates together */\\n    qsort(candidates, candidatesSize, sizeof(int), sortFunc);\\n    \\n    /* Array to store the current solution */\\n    int* current = (int*)malloc(100*sizeof(int));\\n    int currentLength = 0;\\n    \\n    /* Allocate initial memory to answer and returnColumnSizes */\\n    int** answer = (int**)malloc(sizeof(int*));\\n    (*returnColumnSizes) = (int*)malloc(sizeof(int));\\n    \\n    (*returnSize) = 0;\\n    \\n    /* Call the helper with our initial conditions */\\n    helper(candidates, candidatesSize, target, 0, current, currentLength, returnSize, returnColumnSizes, &answer);\\n    \\n    free(current);\\n    return answer;\\n}"]]}
{"id": "1441", "ref_c": [["int* rearrangeArray(int* nums, int numsSize, int* returnSize){\\n    qsort(nums, numsSize, sizeof(int), cmpfunc);\\n\\n    for (int i = 1; i < numsSize; i += 2)\\n        swap(&nums[i], &nums[i - 1]);\\n\\n    *returnSize = numsSize;\\n    return nums;\\n}"], ["int* rearrangeArray(int* nums, int numsSize, int* returnSize){\\n    qsort(nums, numsSize, sizeof(int), cmpfunc);\\n\\n    for (int i = 1; i < numsSize; i += 2)\\n        swap(&nums[i], &nums[i - 1]);\\n\\n    *returnSize = numsSize;\\n    return nums;\\n}"], ["int* rearrangeArray(int* nums, int numsSize, int* returnSize){\\n    qsort(nums, numsSize, sizeof(int), cmpfunc);\\n\\n    for (int i = 1; i < numsSize; i += 2)\\n        swap(&nums[i], &nums[i - 1]);\\n\\n    *returnSize = numsSize;\\n    return nums;\\n}"]]}
{"id": "1442", "ref_c": [["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"]]}
{"id": "1443", "ref_c": [["long long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\\n    long long matrixSum = 0;\\n    int numNegative = 0, minimum = INT_MAX;\\n    \\n    for (int i = 0; i < matrixSize; i++) {\\n        for (int j = 0; j < matrixSize; j++) {\\n            if (matrix[i][j] < 0) numNegative++;\\n            if (abs(matrix[i][j]) < minimum) minimum = abs(matrix[i][j]);\\n            matrixSum += abs(matrix[i][j]);\\n        }"], ["long long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\\n    long long matrixSum = 0;\\n    int numNegative = 0, minimum = INT_MAX;\\n    \\n    for (int i = 0; i < matrixSize; i++) {\\n        for (int j = 0; j < matrixSize; j++) {\\n            if (matrix[i][j] < 0) numNegative++;\\n            if (abs(matrix[i][j]) < minimum) minimum = abs(matrix[i][j]);\\n            matrixSum += abs(matrix[i][j]);\\n        }"], ["long long maxMatrixSum(int** matrix, int matrixSize, int* matrixColSize){\\n    long long matrixSum = 0;\\n    int numNegative = 0, minimum = INT_MAX;\\n    \\n    for (int i = 0; i < matrixSize; i++) {\\n        for (int j = 0; j < matrixSize; j++) {\\n            if (matrix[i][j] < 0) numNegative++;\\n            if (abs(matrix[i][j]) < minimum) minimum = abs(matrix[i][j]);\\n            matrixSum += abs(matrix[i][j]);\\n        }"]]}
{"id": "1444", "ref_c": [["int findKthPositive(int* arr, int arrSize, int k) \\n{\\n   if(k <= arr[0] - 1)\\n   {\\n      return k;\\n   }"], ["int findKthPositive(int* arr, int arrSize, int k) \\n{\\n   if(k <= arr[0] - 1)\\n   {\\n      return k;\\n   }"], ["int findKthPositive(int* arr, int arrSize, int k) \\n{\\n   if(k <= arr[0] - 1)\\n   {\\n      return k;\\n   }"]]}
{"id": "1445", "ref_c": ["\nchar* findDifferentBinaryString(char** nums, int numsSize) {\n    char* output = (char*)malloc((numsSize + 1) * sizeof(char)); \n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i][i] == '1') {\n            output[i] = '0';\n        } else {\n            output[i] = '1';\n        }\n    }\n    output[numsSize] = '\u0000';\n    return output;\n}\n", "\nchar* findDifferentBinaryString(char** nums, int numsSize) {\n    char* output = (char*)malloc((numsSize + 1) * sizeof(char)); \n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i][i] == '1') {\n            output[i] = '0';\n        } else {\n            output[i] = '1';\n        }\n    }\n    output[numsSize] = '\u0000';\n    return output;\n}\n", "\nchar* findDifferentBinaryString(char** nums, int numsSize) {\n    char* output = (char*)malloc((numsSize + 1) * sizeof(char)); \n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i][i] == '1') {\n            output[i] = '0';\n        } else {\n            output[i] = '1';\n        }\n    }\n    output[numsSize] = '\u0000';\n    return output;\n}\n"]}
{"id": "1446", "ref_c": [["int minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n\\tunsigned int min, max;\\n\\tmax = matSize * matColSize[0] * MAX_VAL;\\n\\tmin = target + max;\\n\\n\\t// This is basically a map. Each key maps to 0 or 1.\\n\\t// This mapping represents a set!\\n\\t// If an element is present in the set, the bit value is set to 1.\\n\\t// A simple shift then represents an addition over all elements in the set!\\n\\tunsigned int previousSet[ARR_LENGTH];\\n\\tmemset(previousSet, 0, SIZE_IN_BITS);\\n\\tpreviousSet[0] = 0x01;\\n\\t//display_hexarray(previousSet);\\n\\n\\tfor(unsigned int i=0; i < matSize; i++){\\n\\t\\t//printf(\"\\\\nNEXT COLUMN\\\\n\");\\n\\t\\t//display_hexarray(previousSet);\\n\\n\\t\\t// New empty map of values\\n\\t\\tunsigned int currentSet[ARR_LENGTH];\\n\\t\\tmemset(currentSet, 0, SIZE_IN_BITS);\\n\\n\\t\\tfor(unsigned int j=0; j < *matColSize; j++){\\n\\t\\t\\tunsigned int currValue = mat[i][j];\\n\\n\\t\\t\\t// Temporary array to store shift\\n\\t\\t\\t// Stores intially a copy of the previous set\\n\\t\\t\\tunsigned int tmp[ARR_LENGTH];\\n\\t\\t\\tmemcpy(tmp, previousSet, SIZE_IN_BITS);\\n\\t\\t//display_hexarray(tmp);\\n\\n\\t\\t\\t//printf(\"\\\\nVal: %i\\\\n\", currValue);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t\\t// Add current value to all elements in \"temp\"\\n\\t\\t\\tbitwise_shift_left(tmp, currValue);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t\\t// Join tmp into currentSet\\n\\t\\t\\tbitwise_or_inplace(currentSet, tmp);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t}"], ["int minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n    memset(bitmap_update,0,sizeof(bitmap_update));\\n    bitmap_update[0]=1;\\n    for(int i=0;i<matSize;i++)\\n    {\\n        memset(bitmap_col_sum,0,sizeof(bitmap_col_sum));\\n        for(int j=0;j<*matColSize;j++)\\n        {\\n            bit_equal(bitmap_tmp,bitmap_update);\\n            bit_add(bitmap_tmp,*(*(mat+i)+j));\\n            bit_or(bitmap_col_sum,bitmap_tmp);\\n        }"], ["int minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n\\tunsigned int min, max;\\n\\tmax = matSize * matColSize[0] * MAX_VAL;\\n\\tmin = target + max;\\n\\n\\t// This is basically a map. Each key maps to 0 or 1.\\n\\t// This mapping represents a set!\\n\\t// If an element is present in the set, the bit value is set to 1.\\n\\t// A simple shift then represents an addition over all elements in the set!\\n\\tunsigned int previousSet[ARR_LENGTH];\\n\\tmemset(previousSet, 0, SIZE_IN_BITS);\\n\\tpreviousSet[0] = 0x01;\\n\\t//display_hexarray(previousSet);\\n\\n\\tfor(unsigned int i=0; i < matSize; i++){\\n\\t\\t//printf(\"\\\\nNEXT COLUMN\\\\n\");\\n\\t\\t//display_hexarray(previousSet);\\n\\n\\t\\t// New empty map of values\\n\\t\\tunsigned int currentSet[ARR_LENGTH];\\n\\t\\tmemset(currentSet, 0, SIZE_IN_BITS);\\n\\n\\t\\tfor(unsigned int j=0; j < *matColSize; j++){\\n\\t\\t\\tunsigned int currValue = mat[i][j];\\n\\n\\t\\t\\t// Temporary array to store shift\\n\\t\\t\\t// Stores intially a copy of the previous set\\n\\t\\t\\tunsigned int tmp[ARR_LENGTH];\\n\\t\\t\\tmemcpy(tmp, previousSet, SIZE_IN_BITS);\\n\\t\\t//display_hexarray(tmp);\\n\\n\\t\\t\\t//printf(\"\\\\nVal: %i\\\\n\", currValue);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t\\t// Add current value to all elements in \"temp\"\\n\\t\\t\\tbitwise_shift_left(tmp, currValue);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t\\t// Join tmp into currentSet\\n\\t\\t\\tbitwise_or_inplace(currentSet, tmp);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t}"]]}
{"id": "1447", "ref_c": [["char * kthLargestNumber(char ** nums, int numsSize, int k){\\nqsort(nums,numsSize,sizeof(char*),cmp);\\nreturn nums[numsSize-k];\\n}"], ["char * kthLargestNumber(char ** nums, int numsSize, int k){\\nqsort(nums,numsSize,sizeof(char*),cmp);\\nreturn nums[numsSize-k];\\n}"], ["char * kthLargestNumber(char ** nums, int numsSize, int k){\\nqsort(nums,numsSize,sizeof(char*),cmp);\\nreturn nums[numsSize-k];\\n}"]]}
{"id": "1448", "ref_c": [["int minSessions(int* tasks, int tasksSize, int sessionTime) {\\n\\n    /*\\n     * Input:\\n     *  *tasks\\n     *  tasksSize\\n     *  sessionTime\\n     */\\n\\n    int **dp = (int **)malloc(sizeof(int *) * (1 << tasksSize)), ans;\\n\\n    for (int i = 0; i < (1 << tasksSize); i++) {\\n\\n        dp[i] = (int *)malloc(sizeof(int) * (sessionTime + 1));\\n\\n        for (int j = 0; j <= sessionTime; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int minSessions(int* tasks, int tasksSize, int sessionTime) {\\n\\n    /*\\n     * Input:\\n     *  *tasks\\n     *  tasksSize\\n     *  sessionTime\\n     */\\n\\n    int **dp = (int **)malloc(sizeof(int *) * (1 << tasksSize)), ans;\\n\\n    for (int i = 0; i < (1 << tasksSize); i++) {\\n\\n        dp[i] = (int *)malloc(sizeof(int) * (sessionTime + 1));\\n\\n        for (int j = 0; j <= sessionTime; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int minSessions(int* tasks, int tasksSize, int sessionTime) {\\n\\n    /*\\n     * Input:\\n     *  *tasks\\n     *  tasksSize\\n     *  sessionTime\\n     */\\n\\n    int **dp = (int **)malloc(sizeof(int *) * (1 << tasksSize)), ans;\\n\\n    for (int i = 0; i < (1 << tasksSize); i++) {\\n\\n        dp[i] = (int *)malloc(sizeof(int) * (sessionTime + 1));\\n\\n        for (int j = 0; j <= sessionTime; j++) {\\n            dp[i][j] = -1;\\n        }"]]}
{"id": "1449", "ref_c": ["\nchar *onechar(char **str,int boardSize, int* boardColSize)\n{\n    char *teststr = malloc(26 + 1);\n    int c = 0;\n    int p;\n    int n;\n\n    for (int i = 0;i < boardSize; i++)\n    {\n        for (int a  = 0; a < boardColSize[i]; a++)\n        {\n            p = 0;\n            n = 0;\n            while (teststr[n] != '\u0000')\n            {\n                if (teststr[n] == str[i][a])\n                {\n                    p = 1;\n                    break;\n                }\n                n++;\n            }\n            if (p == 0)\n            {\n                teststr[c] = str[i][a];\n                teststr[c + 1] = '\u0000';\n                c++;\n            }\n            \n        }\n    }\n    return (teststr);\n}\nint *chrlen(char **str,char *defstr,int boardSize, int* boardColSize,int strlen)\n{\n    int *chrln = malloc(strlen * sizeof(int));\n    for (int c = 0;c < strlen; c++)\n    {\n        chrln[c] = 0;\n        for (int i = 0;i < boardSize; i++)\n        {\n            for (int a  = 0; a < boardColSize[i]; a++)\n            {\n                if (str[i][a] == defstr[c])\n                    chrln[c] += 1;\n                \n            }\n        }\n    }\n    return (chrln);\n}\n\nbool exist(char** board, int boardSize, int* boardColSize, char * word)\n{\n    char *oneboard = onechar(board,boardSize,boardColSize);\n    int *zchrlen = chrlen(board,oneboard,boardSize,boardColSize,sizeof(oneboard));\n    int i;\n    int a;\n    int c;\n\n    i = 0; \n    while (word[i] != '\u0000')\n    {\n        a = 0;\n        c = 0;\n        while (oneboard[c] != '\u0000')\n        {\n            if (word[i] == oneboard[c] && zchrlen[c] > 0)\n            {\n                a = 1;\n                zchrlen[c] -= 1;\n                c++;\n                break;\n            }\n            c++;\n        }\n        if (a == 0)\n            return false;\n        i++;\n    }\n    return true;\n}\n", "\nchar *onechar(char **str,int boardSize, int* boardColSize)\n{\n    char *teststr = malloc(26 + 1);\n    int c = 0;\n    int p;\n    int n;\n\n    for (int i = 0;i < boardSize; i++)\n    {\n        for (int a  = 0; a < boardColSize[i]; a++)\n        {\n            p = 0;\n            n = 0;\n            while (teststr[n] != '\u0000')\n            {\n                if (teststr[n] == str[i][a])\n                {\n                    p = 1;\n                    break;\n                }\n                n++;\n            }\n            if (p == 0)\n            {\n                teststr[c] = str[i][a];\n                teststr[c + 1] = '\u0000';\n                c++;\n            }\n            \n        }\n    }\n    return (teststr);\n}\nint *chrlen(char **str,char *defstr,int boardSize, int* boardColSize,int strlen)\n{\n    int *chrln = malloc(strlen * sizeof(int));\n    for (int c = 0;c < strlen; c++)\n    {\n        chrln[c] = 0;\n        for (int i = 0;i < boardSize; i++)\n        {\n            for (int a  = 0; a < boardColSize[i]; a++)\n            {\n                if (str[i][a] == defstr[c])\n                    chrln[c] += 1;\n                \n            }\n        }\n    }\n    return (chrln);\n}\n\nbool exist(char** board, int boardSize, int* boardColSize, char * word)\n{\n    char *oneboard = onechar(board,boardSize,boardColSize);\n    int *zchrlen = chrlen(board,oneboard,boardSize,boardColSize,sizeof(oneboard));\n    int i;\n    int a;\n    int c;\n\n    i = 0; \n    while (word[i] != '\u0000')\n    {\n        a = 0;\n        c = 0;\n        while (oneboard[c] != '\u0000')\n        {\n            if (word[i] == oneboard[c] && zchrlen[c] > 0)\n            {\n                a = 1;\n                zchrlen[c] -= 1;\n                c++;\n                break;\n            }\n            c++;\n        }\n        if (a == 0)\n            return false;\n        i++;\n    }\n    return true;\n}\n", "\nchar *onechar(char **str,int boardSize, int* boardColSize)\n{\n    char *teststr = malloc(26 + 1);\n    int c = 0;\n    int p;\n    int n;\n\n    for (int i = 0;i < boardSize; i++)\n    {\n        for (int a  = 0; a < boardColSize[i]; a++)\n        {\n            p = 0;\n            n = 0;\n            while (teststr[n] != '\u0000')\n            {\n                if (teststr[n] == str[i][a])\n                {\n                    p = 1;\n                    break;\n                }\n                n++;\n            }\n            if (p == 0)\n            {\n                teststr[c] = str[i][a];\n                teststr[c + 1] = '\u0000';\n                c++;\n            }\n            \n        }\n    }\n    return (teststr);\n}\nint *chrlen(char **str,char *defstr,int boardSize, int* boardColSize,int strlen)\n{\n    int *chrln = malloc(strlen * sizeof(int));\n    for (int c = 0;c < strlen; c++)\n    {\n        chrln[c] = 0;\n        for (int i = 0;i < boardSize; i++)\n        {\n            for (int a  = 0; a < boardColSize[i]; a++)\n            {\n                if (str[i][a] == defstr[c])\n                    chrln[c] += 1;\n                \n            }\n        }\n    }\n    return (chrln);\n}\n\nbool exist(char** board, int boardSize, int* boardColSize, char * word)\n{\n    char *oneboard = onechar(board,boardSize,boardColSize);\n    int *zchrlen = chrlen(board,oneboard,boardSize,boardColSize,sizeof(oneboard));\n    int i;\n    int a;\n    int c;\n\n    i = 0; \n    while (word[i] != '\u0000')\n    {\n        a = 0;\n        c = 0;\n        while (oneboard[c] != '\u0000')\n        {\n            if (word[i] == oneboard[c] && zchrlen[c] > 0)\n            {\n                a = 1;\n                zchrlen[c] -= 1;\n                c++;\n                break;\n            }\n            c++;\n        }\n        if (a == 0)\n            return false;\n        i++;\n    }\n    return true;\n}\n"]}
{"id": "1451", "ref_c": [["int numberOfWeakCharacters(int** properties, int propertiesSize, int* propertiesColSize) {\\n  int** props = malloc(propertiesSize * sizeof(int*));\\n  memcpy(props, properties, propertiesSize * sizeof(int*));\\n\\n  qsort(props, propertiesSize, sizeof(int*), &cmp_values);\\n  int ret = 0;\\n  for (int i = 0, def = 0; i < propertiesSize; ++i) {\\n    def = (def > props[i][1]) ? def : props[i][1];\\n    ret += (props[i][1] < def);\\n  }"], ["int numberOfWeakCharacters(int** properties, int propertiesSize, int* propertiesColSize) {\\n  int** props = malloc(propertiesSize * sizeof(int*));\\n  memcpy(props, properties, propertiesSize * sizeof(int*));\\n\\n  qsort(props, propertiesSize, sizeof(int*), &cmp_values);\\n  int ret = 0;\\n  for (int i = 0, def = 0; i < propertiesSize; ++i) {\\n    def = (def > props[i][1]) ? def : props[i][1];\\n    ret += (props[i][1] < def);\\n  }"], ["int numberOfWeakCharacters(int** properties, int propertiesSize, int* propertiesColSize){\\n    /*\\n     * Input:\\n     *  properties, 2D array containing \"attack\" and \"defense\" of each character.\\n     *  propertiesSize, number of characters in array\\n     *  propertiesColSize, column number of array\\n     */\\n     \\n    int weak = 0;\\n    int max = 0;\\n\\n    qsort((void *)properties, propertiesSize, sizeof(int *), cmp);\\n\\n    for (int i = propertiesSize - 1; i >= 0; i--) {\\n\\n        /* \\n         * This character has lower attack level and defense \\n         * level than other character, mark as \"weak\" character\\n         */\\n        if (properties[i][1] < max) {\\n            weak++;\\n        }"]]}
{"id": "1452", "ref_c": [["bool circularArrayLoop(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        int slow=i;\\n        int fast=nextnode(i,nums,numsSize);\\n        while(nums[fast]*nums[i]>0 && nums[nextnode(fast,nums,numsSize)]*nums[i]>0){\\n            if(fast==slow){\\n                if(slow==nextnode(slow,nums,numsSize))break;\\n                return true;\\n            }"], ["bool circularArrayLoop(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        int slow=i;\\n        int fast=nextnode(i,nums,numsSize);\\n        while(nums[fast]*nums[i]>0 && nums[nextnode(fast,nums,numsSize)]*nums[i]>0){\\n            if(fast==slow){\\n                if(slow==nextnode(slow,nums,numsSize))break;\\n                return true;\\n            }"], ["bool circularArrayLoop(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        int slow=i;\\n        int fast=nextnode(i,nums,numsSize);\\n        while(nums[fast]*nums[i]>0 && nums[nextnode(fast,nums,numsSize)]*nums[i]>0){\\n            if(fast==slow){\\n                if(slow==nextnode(slow,nums,numsSize))break;\\n                return true;\\n            }"]]}
{"id": "1453", "ref_c": [["int tribonacci(int n){\\n    if(n==0) return 0;\\n    if(n==1 ||n==2)  return 1;\\n    int f[n+1];\\n    f[0]=0;\\n    f[1]=1;\\n    f[2]=1;\\n    for(int i=3;i<=n;i++){\\n        f[i] = f[i-1]+f[i-2]+f[i-3];\\n    }"], ["int tribonacci(int n) {\\n\\t\\t\\tif( n == 0)  return 0;\\n\\t\\t\\telse if ( n== 1 || n == 2)  return 1;\\n\\t\\t\\telse return tribonacci ( n - 1 )+tribonacci ( n - 2 )+tribonacci ( n - 3 );\\n    }", "int tribonacci(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve(n,dp);\\n    }"], ["int tribonacci(int n)\\n{\\n    int tr[n + 1];\\n    int i = 3;\\n\\n    if (n == 0)\\n        return (0);\\n    if (n == 1 || n == 2)\\n        return (1);\\n    tr[0] = 0;\\n    tr[1] = 1;\\n\\ttr[2] = 1;\\n    while (i <= n)\\n    {\\n        tr[i] = tr[i - 3] + tr[i - 2] + tr[i - 1];\\n        i++;\\n    }"]]}
{"id": "1454", "ref_c": [["int maxProduct(char * s){\\n    int res = 0, mask = (1<<strlen(s))-1;\\n    \\n    for(int i=1; i<mask; ++i){\\n        int cnt1 = 0, cnt2 = 0;\\n        char tmp1[strlen(s)], tmp2[strlen(s)]; \\n        for(int j=strlen(s)-1; j>=0; --j){\\n            if(1<<j & i)\\n                tmp1[cnt1++] = s[j];\\n            else\\n                tmp2[cnt2++] = s[j];\\n        }"], ["int maxProduct(char * s){\\n    int res = 0, mask = (1<<strlen(s))-1;\\n    \\n    for(int i=1; i<mask; ++i){\\n        int cnt1 = 0, cnt2 = 0;\\n        char tmp1[strlen(s)], tmp2[strlen(s)]; \\n        for(int j=strlen(s)-1; j>=0; --j){\\n            if(1<<j & i)\\n                tmp1[cnt1++] = s[j];\\n            else\\n                tmp2[cnt2++] = s[j];\\n        }"], ["int maxProduct(char * s){\\n    int res = 0, mask = (1<<strlen(s))-1;\\n    \\n    for(int i=1; i<mask; ++i){\\n        int cnt1 = 0, cnt2 = 0;\\n        char tmp1[strlen(s)], tmp2[strlen(s)]; \\n        for(int j=strlen(s)-1; j>=0; --j){\\n            if(1<<j & i)\\n                tmp1[cnt1++] = s[j];\\n            else\\n                tmp2[cnt2++] = s[j];\\n        }"]]}
{"id": "1455", "ref_c": [["int* findOriginalArray(int* changed, int changedSize, int* returnSize){\\n    *returnSize = 0;\\n    if(changedSize % 2 != 0)\\n        return NULL;\\n    int * result = (int *)malloc(changedSize/2 * sizeof(int));\\n    int checkNum[200002] = {0}"], ["int* findOriginalArray(int* changed, int changedSize, int* returnSize) {\\n    *returnSize = 0;\\n    if (changedSize % 2 != 0) return NULL;\\n\\n    int* result;\\n    result = malloc(sizeof(*result) * changedSize/2);\\n\\n    // If array size is lesser than 1000, don\\'t ever bother with blocks. Just quicksort entire array\\n    qsort(changed, changedSize, sizeof(*changed), compare);\\n\\n    bool isDoubled = 1;\\n\\n    { // Check if changed is doubled\\n        int lookup[200001] = {0}"], ["int* findOriginalArray(int* changed, int changedSize, int* returnSize) {\\n    *returnSize = 0;\\n    if (changedSize % 2 != 0) return NULL;\\n\\n    int* result;\\n    result = malloc(sizeof(*result) * changedSize/2);\\n\\n    // If array size is lesser than 1000, don\\'t ever bother with blocks. Just quicksort entire array\\n    qsort(changed, changedSize, sizeof(*changed), compare);\\n\\n    bool isDoubled = 1;\\n\\n    { // Check if changed is doubled\\n        int lookup[200001] = {0}"]]}
{"id": "1456", "ref_c": [["bool hasAlternatingBits(int n){\\n    \\n    int size = (sizeof(int) * 8);\\n\\n    bool atEndOfSequence = false;\\n    \\n    int prevVal = n & 1;\\n    int bitVal;\\n\\n    for (int i=1; i<size; i++) {\\n        bitVal = (n >> i) & 1;\\n\\n        if (atEndOfSequence && bitVal == 1) return false;\\n        if ((bitVal  ^ prevVal) != 1){\\n            if (bitVal == 0 && prevVal == 0) {\\n                atEndOfSequence = true;\\n            }"], ["bool hasAlternatingBits(int n) {\\n    int flag,flag2,bit;\\n    while(n!=0){\\n        bit = n & 1;\\n        if(bit==1)\\n            flag=1;\\n        else\\n            flag=0;\\n        n >>= 1;\\n        \\n        bit = n & 1;\\n        if(bit==1)\\n            flag2=1;\\n        else\\n            flag2=0;\\n        \\n        if(flag==flag2)\\n            return false;\\n   }"], ["bool hasAlternatingBits(int n) {\\n        long x=1;                     // 1 = 1\\n        while(x<=n){                  // 2 = 10\\n            if(x==n)                  // 5 = 101\\n                return true;          //10 = 1010\\n            else if(x%2==0)           //21 = 10101\\n                x=2*x+1;              //42 = 101010\\n            else                      //85 = 1010101\\n                x=2*x;\\n        }", "bool hasAlternatingBits(int n) {\\n        int flag1,flag2;\\n        while(n){\\n            flag1=n&1;\\n            if(flag1==flag2)\\n                return 0;\\n            n=n>>1;\\n            flag2=flag1;\\n        }"]]}
{"id": "1457", "ref_c": [["int sumOfBeauties(int* nums, int numsSize){\\n    int sum = 0;\\n    int pre_max = nums[0];\\n    int suf_min = nums[numsSize-1];\\n    int* pre = (int*)malloc(sizeof(int)*numsSize);\\n    int* suf = (int*)malloc(sizeof(int)*numsSize);\\n    for(int i = 0 ; i < numsSize; i++){\\n       if(nums[i] > pre_max){\\n            pre_max = nums[i];\\n       }"], ["int sumOfBeauties(int* nums, int numsSize){\\n//     int sum = 0;\\n//     int flag;\\n//     for(int i=1; i<numsSize -1; i++){\\n//         flag=0;\\n//         for(int j=0; j<i ; j++){\\n//             for(int k=i+1; k<numsSize; k++){\\n//                 if(nums[j] >= nums[i] || nums[j] >= nums[k] || nums[i] >= nums[k]){\\n//                     flag = 1;\\n//                 }", "int sumOfBeauties(int* nums, int numsSize){\\n    int sum = 0;\\n    int pre_max = nums[0];\\n    int suf_min = nums[numsSize-1];\\n    int* pre = (int*)malloc(sizeof(int)*numsSize);\\n    int* suf = (int*)malloc(sizeof(int)*numsSize);\\n    for(int i = 0 ; i < numsSize; i++){\\n       if(nums[i] > pre_max){\\n            pre_max = nums[i];\\n       }"], ["int sumOfBeauties(int* nums, int numsSize){\\n//     int sum = 0;\\n//     int flag;\\n//     for(int i=1; i<numsSize -1; i++){\\n//         flag=0;\\n//         for(int j=0; j<i ; j++){\\n//             for(int k=i+1; k<numsSize; k++){\\n//                 if(nums[j] >= nums[i] || nums[j] >= nums[k] || nums[i] >= nums[k]){\\n//                     flag = 1;\\n//                 }", "int sumOfBeauties(int* nums, int numsSize){\\n    int sum = 0;\\n    int pre_max = nums[0];\\n    int suf_min = nums[numsSize-1];\\n    int* pre = (int*)malloc(sizeof(int)*numsSize);\\n    int* suf = (int*)malloc(sizeof(int)*numsSize);\\n    for(int i = 0 ; i < numsSize; i++){\\n       if(nums[i] > pre_max){\\n            pre_max = nums[i];\\n       }"]]}
{"id": "1459", "ref_c": [["long long gridGame(int** grid, int gridSize, int* gridColSize)\\n{\\n    long long sumdown = 0;\\n    long long sumup = 0;\\n    for(int i=0;i<gridColSize[0]-1;i++)\\n    {\\n        sumdown+=grid[1][i];\\n    }"], ["long long gridGame(int** grid, int gridSize, int* gridColSize){\\n  long long sum_row0 = 0;\\n  long long sum_row1 = 0;\\n  long long ret_sum, curr_sum;\\n  \\n  for (int loop_idx=1; loop_idx<gridColSize[0]; loop_idx++) {\\n    sum_row0 += grid[0][loop_idx];\\n  }"], ["long long gridGame(int** grid, int gridSize, int* gridColSize)\\n{\\n    bool top=false,btm=false;gridSize=0;\\n    long long t1=0,b1=0,t2=0,b2=0;int mid=(* gridColSize)/2,bot=0;\\n    gridSize=* gridColSize;\\n    while(1)\\n    {\\n        for(int i=mid+1;i<* gridColSize;i++)\\n        {\\n            t1+=grid[0][i];\\n        }"]]}
{"id": "1460", "ref_c": [["char * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize){\\nchar str[wordsSize][50];\\n\\nchar ch[strlen(licensePlate)+1];\\n\\nint i=0;\\nwhile(*licensePlate)\\n{\\n    if(*licensePlate>=97 && *licensePlate<=122)\\n    {\\n      ch[i++] = *licensePlate;\\n    }"], ["char * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize){\\n    int temp[26] = {0}"], ["char * shortestCompletingWord(char * licensePlate, char ** words, int wordsSize){\\n    int temp[26] = {0}"]]}
{"id": "1461", "ref_c": [["int numOfPairs(char ** nums, int numsSize, char * target){\\n    int result = 0;\\n    int target_len = strlen(target);\\n    int tail_len;\\n    int * tail_table = calloc(100, sizeof(int)); \\n    char * tail;\\n    \\n    char * target_rvsd = malloc(sizeof(char) * target_len + 1);\\n    // reverse target\\n    for (int i = 0; i < target_len; i++)\\n    {\\n        *(target_rvsd+i) = *(target+(target_len-1-i));\\n    }"], ["int numOfPairs(char ** nums, int numsSize, char * target){\\n    int result = 0;\\n    int target_len = strlen(target);\\n    int tail_len;\\n    int * tail_table = calloc(100, sizeof(int)); \\n    char * tail;\\n    \\n    char * target_rvsd = malloc(sizeof(char) * target_len + 1);\\n    // reverse target\\n    for (int i = 0; i < target_len; i++)\\n    {\\n        *(target_rvsd+i) = *(target+(target_len-1-i));\\n    }"], ["int numOfPairs(char ** nums, int numsSize, char * target){\\n    int result = 0;\\n    int target_len = strlen(target);\\n    int tail_len;\\n    int * tail_table = calloc(100, sizeof(int)); \\n    char * tail;\\n    \\n    char * target_rvsd = malloc(sizeof(char) * target_len + 1);\\n    // reverse target\\n    for (int i = 0; i < target_len; i++)\\n    {\\n        *(target_rvsd+i) = *(target+(target_len-1-i));\\n    }"]]}
{"id": "1462", "ref_c": ["\nint min(int a,int b){\n    if (a>=b) return b;\n    else return a;\n}\nint max(int a,int b){\n    if (a>=b) return a;\n    else return b;\n}\nint maxConsecutiveAnswers(char * answerKey, int k){\n    int t=0,f=0,start=-1,res=0; //counter for T/F in window, windowstart(excl), best found (yet)\n    for (int end=0; end<strlen(answerKey); end++){ //for each window-end, add new found\n        if (answerKey[end]=='T') t += 1;\n        else f += 1;\n        while(min(t,f)>k){ //move start further to only swap k answers\n            if (answerKey[++start]=='T') t -= 1;\n            else f -= 1;\n        }\n        res = max(res,t+f); //bigger is counter of used ans, smaller is counter of swaps\n    }\n    return res;\n}\n", "\nint min(int a,int b){\n    if (a>=b) return b;\n    else return a;\n}\nint max(int a,int b){\n    if (a>=b) return a;\n    else return b;\n}\nint maxConsecutiveAnswers(char * answerKey, int k){\n    int t=0,f=0,start=-1,res=0; //counter for T/F in window, windowstart(excl), best found (yet)\n    for (int end=0; end<strlen(answerKey); end++){ //for each window-end, add new found\n        if (answerKey[end]=='T') t += 1;\n        else f += 1;\n        while(min(t,f)>k){ //move start further to only swap k answers\n            if (answerKey[++start]=='T') t -= 1;\n            else f -= 1;\n        }\n        res = max(res,t+f); //bigger is counter of used ans, smaller is counter of swaps\n    }\n    return res;\n}\n", "\nint min(int a,int b){\n    if (a>=b) return b;\n    else return a;\n}\nint max(int a,int b){\n    if (a>=b) return a;\n    else return b;\n}\nint maxConsecutiveAnswers(char * answerKey, int k){\n    int t=0,f=0,start=-1,res=0; //counter for T/F in window, windowstart(excl), best found (yet)\n    for (int end=0; end<strlen(answerKey); end++){ //for each window-end, add new found\n        if (answerKey[end]=='T') t += 1;\n        else f += 1;\n        while(min(t,f)>k){ //move start further to only swap k answers\n            if (answerKey[++start]=='T') t -= 1;\n            else f -= 1;\n        }\n        res = max(res,t+f); //bigger is counter of used ans, smaller is counter of swaps\n    }\n    return res;\n}\n"]}
{"id": "1463", "ref_c": [["int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int sum = mean * (rollsSize + n);\\n    int rolls_sum = 0;\\n    for (int i = 0; i < rollsSize ; i++){\\n        rolls_sum = rolls_sum + rolls[i];\\n    }"], ["int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int* ans = (int*)calloc(n, sizeof(int));\\n    int sum = 0, targetSum = mean * (n + rollsSize);\\n    for(int i = 0; i < rollsSize; i++)\\n        sum += rolls[i];\\n    targetSum -= sum;\\n    \\n    *returnSize = n;\\n    if(targetSum < n || targetSum > 6*n){\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int* ans = (int*)calloc(n, sizeof(int));\\n    int sum = 0, targetSum = mean * (n + rollsSize);\\n    for(int i = 0; i < rollsSize; i++)\\n        sum += rolls[i];\\n    targetSum -= sum;\\n    \\n    *returnSize = n;\\n    if(targetSum < n || targetSum > 6*n){\\n        *returnSize = 0;\\n        return NULL;\\n    }"]]}
{"id": "1464", "ref_c": [["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"]]}
{"id": "1465", "ref_c": [["int minOperations(int** grid, int gridSize, int* gridColSize, int x) {\\n    int arrSize = gridSize * gridColSize[0], idx = 0;\\n    int* arr = (int*) malloc(arrSize * sizeof(int));\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < gridColSize[0]; j++) {\\n            arr[idx++] = grid[i][j];\\n        }"], ["int minOperations(int** grid, int gridSize, int* gridColSize, int x){\\n    int* array = malloc( sizeof(int) * gridSize * *gridColSize );\\n    int count = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            array[count++] = grid[i][j];\\n        }"], ["int minOperations(int** grid, int gridSize, int* gridColSize, int x) {\\n    int arrSize = gridSize * gridColSize[0], idx = 0;\\n    int* arr = (int*) malloc(arrSize * sizeof(int));\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < gridColSize[0]; j++) {\\n            arr[idx++] = grid[i][j];\\n        }"]]}
{"id": "1467", "ref_c": ["\nbool winnerOfGame(char * colors){\n    int* ansCnt = (int*)calloc(2, sizeof(int));\n    int cnt = 1, len = strlen(colors);\n    char curr = colors[0];\n    for(int i = 1; i < len; i++)\n    {\n        if(curr == colors[i]){\n            cnt++;\n        }\n        else{\n            if(cnt >= 3){ ansCnt[curr - 'A'] += (cnt - 2); }\n            curr = colors[i];\n            cnt = 1;\n        }\n    }\n    if(cnt >= 3){ ansCnt[curr - 'A'] += (cnt - 2); }\n    \n    /* alice lose return false; */\n    return (ansCnt[0] <= ansCnt[1])? false : true;\n}\n", "\nbool winnerOfGame(char * colors){\n    int* ansCnt = (int*)calloc(2, sizeof(int));\n    int cnt = 1, len = strlen(colors);\n    char curr = colors[0];\n    for(int i = 1; i < len; i++)\n    {\n        if(curr == colors[i]){\n            cnt++;\n        }\n        else{\n            if(cnt >= 3){ ansCnt[curr - 'A'] += (cnt - 2); }\n            curr = colors[i];\n            cnt = 1;\n        }\n    }\n    if(cnt >= 3){ ansCnt[curr - 'A'] += (cnt - 2); }\n    \n    /* alice lose return false; */\n    return (ansCnt[0] <= ansCnt[1])? false : true;\n}\n", "\nbool winnerOfGame(char * colors){\n    int* ansCnt = (int*)calloc(2, sizeof(int));\n    int cnt = 1, len = strlen(colors);\n    char curr = colors[0];\n    for(int i = 1; i < len; i++)\n    {\n        if(curr == colors[i]){\n            cnt++;\n        }\n        else{\n            if(cnt >= 3){ ansCnt[curr - 'A'] += (cnt - 2); }\n            curr = colors[i];\n            cnt = 1;\n        }\n    }\n    if(cnt >= 3){ ansCnt[curr - 'A'] += (cnt - 2); }\n    \n    /* alice lose return false; */\n    return (ansCnt[0] <= ansCnt[1])? false : true;\n}\n"]}
{"id": "1468", "ref_c": [["char * generateTheString(int n){\\n    char *res=(char*)malloc(sizeof(char)*(n+1));\\n    int num1=0;\\n    int num2=0;\\n    if(n%2==1){ // odd \\n        num1=n;\\n    }"], ["char * generateTheString(int n){\\n//     char *str = (char *)malloc(sizeof(char *)*(n+1));\\n//     str[n] = \\'\\\\n\\';\\n   \\n//     int i=0;\\n//     if(n%2 == 0){\\n//         while(n>0){\\n//         str[i] = \\'a\\';\\n//         n--;\\n//         }", "char * generateTheString(int n){\\n    char* ans = malloc( ( n + 1 )* sizeof(char) ) ;\\n    ans[n] = \\'\\\\0\\' ;\\n    if(n % 2){\\n        for(int i = 0; i < n ;i++){\\n            ans[i] = \\'a\\' ;\\n        }"], ["char * generateTheString(int n){\\n    char *result = (char *)malloc((n+1) * sizeof(char));\\n    if(n % 2 == 1)\\n        for(int i = 0; i < n; i++)\\n            result[i] = \\'a\\';\\n    else{\\n        for(int i = 0; i < n-1; i++)\\n            result[i] = \\'a\\';\\n        result[n-1] = \\'b\\';\\n    }"]]}
{"id": "1470", "ref_c": [["int countMaxOrSubsets(int* nums, int numsSize){\\n    int max=0;\\n    for(int i=0;i<numsSize;i++){\\n        max|=nums[i];\\n    }"], ["int countMaxOrSubsets(int* nums, int numsSize){\\n    int max=0;\\n    for(int i=0;i<numsSize;i++){\\n        max|=nums[i];\\n    }"], ["int countMaxOrSubsets(int* nums, int numsSize){\\n    int max=0;\\n    for(int i=0;i<numsSize;i++){\\n        max|=nums[i];\\n    }"]]}
{"id": "1471", "ref_c": [["int* maxSubsequence(int* nums, int numsSize, int k, int* returnSize){\\n    struct pair * pairs = malloc(sizeof(struct pair)*numsSize);\\n    for (int i = 0; i < numsSize; i++){\\n        pairs[i].idx = i;\\n        pairs[i].val = nums[i];\\n    }"], ["int* maxSubsequence(int* nums, int numsSize, int k, int* returnSize){\\n    q = (struct pq *)malloc(sizeof(struct pq));\\n    memset(q, 0, sizeof(struct pq));\\n    q->heap = (struct elem *)malloc(sizeof(struct elem) * k);\\n    memset(q->heap, 0, sizeof(struct elem) * k);\\n    *returnSize = k;\\n    int *ret = (int *)malloc(sizeof(int) * k);\\n    g_k = k;\\n    \\n    for (int i = 0; i < numsSize; i++) // O(N * logN)\\n        add_num(q->heap, q->heap_size, nums[i], i);\\n    \\n    build_heap(q->heap, q->heap_size, compare_idx); // O(N)\\n    for (int i = 0; i < k; i++) // O(K * logN)\\n        ret[i] = heap_pop(q->heap, compare_idx).val;\\n    return ret;\\n}"], ["int* maxSubsequence(int* nums, int numsSize, int k, int* returnSize){\\n    int i, j, l = numsSize, dup_count = 0;\\n    int *sorted = (int*)malloc(l * sizeof(int));\\n    int *ans = (int*)malloc(k * sizeof(int));\\n    *returnSize = k;\\n    \\n    memcpy(sorted, nums, l * sizeof(int));\\n    qsort(sorted, l, sizeof(int), cmp);\\n    int kthMax = sorted[k - 1];\\n    \\n    // Find possible occurrence(s) of other element(s) of value kthMax before sorted[k - 1]. \\n    for(i = k - 1; i >= 0; i--){\\n        if(sorted[i] == kthMax)\\n            dup_count++;\\n        else\\n            break;\\n    }"]]}
{"id": "1472", "ref_c": [["int countHighestScoreNodes(int* parents, int parentsSize) {\\n    if (parentsSize == 2) return 2;\\n    struct pair* res = (struct pair*) calloc(parentsSize, sizeof(struct pair));\\n    for (int i = 1; i < parentsSize; i++) {\\n        (res[parents[i]].nums)++;\\n        if (!res[parents[i]].node1) {\\n            res[parents[i]].node1 = i;\\n        }"], ["int countHighestScoreNodes(int* parents, int parentsSize){\\n\\tif (NULL == parents) return 0;\\n    \\n\\tunsigned long long max = 0;\\n\\tint highest_score_nodes = 0;\\n    int **children = (int**)calloc(parentsSize, sizeof(int*));\\n    if (NULL == children) return 0;\\n    int childrenCnt[parentsSize];\\n    for (int i = 0; i < parentsSize; i++) {\\n        children[i] = (int*)calloc(2, sizeof(int));\\n        if (NULL == children[i]) {\\n            for (int j = 0; j < i; j++) free(children[j]);\\n            free(children);\\n            return 0;\\n        }"], ["int countHighestScoreNodes(int* parents, int parentsSize) {\\n    if (parentsSize == 2) return 2;\\n    struct pair* res = (struct pair*) calloc(parentsSize, sizeof(struct pair));\\n    for (int i = 1; i < parentsSize; i++) {\\n        (res[parents[i]].nums)++;\\n        if (!res[parents[i]].node1) {\\n            res[parents[i]].node1 = i;\\n        }"]]}
{"id": "1473", "ref_c": [["int maxTwoEvents(int** events, int eventsSize, int* eventsColSize){\\n    qsort(events,eventsSize,sizeof(events[0]),cmp);\\n    int **stack = malloc(eventsSize*sizeof(int*));\\n    int stackidx = 0;\\n    int ans = 0;\\n    for(int i=0;i<eventsSize;i++){\\n        stack[i] = calloc(3,sizeof(int));\\n        ans = (events[i][2]>ans)?events[i][2]:ans;\\n        if(i!=0){\\n            int stacktar = stackidx-1;\\n            while(stacktar>=0 && events[i][0]<=stack[stacktar][1])\\n                stacktar--;\\n            if(stacktar>=0 && events[i][0]>stack[stacktar][1]){\\n                ans = (events[i][2]+stack[stacktar][2]>ans)?events[i][2]+stack[stacktar][2]:ans;\\n            }"], ["int maxTwoEvents(int** events, int eventsSize, int* eventsColSize){\\n    qsort(events,eventsSize,sizeof(events[0]),cmp);\\n    int **stack = malloc(eventsSize*sizeof(int*));\\n    int stackidx = 0;\\n    int ans = 0;\\n    for(int i=0;i<eventsSize;i++){\\n        stack[i] = calloc(3,sizeof(int));\\n        ans = (events[i][2]>ans)?events[i][2]:ans;\\n        if(i!=0){\\n            int stacktar = stackidx-1;\\n            while(stacktar>=0 && events[i][0]<=stack[stacktar][1])\\n                stacktar--;\\n            if(stacktar>=0 && events[i][0]>stack[stacktar][1]){\\n                ans = (events[i][2]+stack[stacktar][2]>ans)?events[i][2]+stack[stacktar][2]:ans;\\n            }"], ["int maxTwoEvents(int** events, int eventsSize, int* eventsColSize){\\n    qsort(events,eventsSize,sizeof(events[0]),cmp);\\n    int **stack = malloc(eventsSize*sizeof(int*));\\n    int stackidx = 0;\\n    int ans = 0;\\n    for(int i=0;i<eventsSize;i++){\\n        stack[i] = calloc(3,sizeof(int));\\n        ans = (events[i][2]>ans)?events[i][2]:ans;\\n        if(i!=0){\\n            int stacktar = stackidx-1;\\n            while(stacktar>=0 && events[i][0]<=stack[stacktar][1])\\n                stacktar--;\\n            if(stacktar>=0 && events[i][0]>stack[stacktar][1]){\\n                ans = (events[i][2]+stack[stacktar][2]>ans)?events[i][2]+stack[stacktar][2]:ans;\\n            }"]]}
{"id": "1474", "ref_c": [["int* platesBetweenCandles(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    \\n    \\n    int *res = (int *)malloc(sizeof(int) *queriesSize);\\n    memset(res,0,sizeof(int)*queriesSize);\\n    *returnSize = queriesSize;\\n    int len = strlen(s);\\n    struct pr_range *range = (struct pr_range *)malloc(sizeof(struct pr_range)*len);\\n    int i;\\n    int p,q;\\n    int j,k;\\n    int nearIndex;\\n    int total;\\n    int prev=-1;\\n    int ridx=0;\\n    while (s[p]!=NULL)\\n    {\\n        total=0;\\n        while(s[p]!=NULL && s[p]==\\'*\\')\\n        {\\n            p++;\\n        }"], ["int* platesBetweenCandles(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    \\n    \\n    int *res = (int *)malloc(sizeof(int) *queriesSize);\\n    memset(res,0,sizeof(int)*queriesSize);\\n    *returnSize = queriesSize;\\n    int len = strlen(s);\\n    struct pr_range *range = (struct pr_range *)malloc(sizeof(struct pr_range)*len);\\n    int i;\\n    int p,q;\\n    int j,k;\\n    int nearIndex;\\n    int total;\\n    int prev=-1;\\n    int ridx=0;\\n    while (s[p]!=NULL)\\n    {\\n        total=0;\\n        while(s[p]!=NULL && s[p]==\\'*\\')\\n        {\\n            p++;\\n        }"], ["int* platesBetweenCandles(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    \\n    \\n    int *res = (int *)malloc(sizeof(int) *queriesSize);\\n    memset(res,0,sizeof(int)*queriesSize);\\n    *returnSize = queriesSize;\\n    int len = strlen(s);\\n    struct pr_range *range = (struct pr_range *)malloc(sizeof(struct pr_range)*len);\\n    int i;\\n    int p,q;\\n    int j,k;\\n    int nearIndex;\\n    int total;\\n    int prev=-1;\\n    int ridx=0;\\n    while (s[p]!=NULL)\\n    {\\n        total=0;\\n        while(s[p]!=NULL && s[p]==\\'*\\')\\n        {\\n            p++;\\n        }"]]}
{"id": "1475", "ref_c": [["int* nodesBetweenCriticalPoints(struct ListNode* head, int* returnSize) \\n{\\n  int minDistance = INT_MAX;\\n  int maxDistance = INT_MIN;\\n\\n  struct ListNode * trav = head;\\n  struct ListNode * prev = NULL;\\n  int num_of_nodes = 0;\\n\\n  while(trav)\\n  {\\n    num_of_nodes++;\\n    trav = trav->next;\\n  }"], ["int* nodesBetweenCriticalPoints(struct ListNode* head, int* returnSize){\\n    int* arr = malloc(3 * sizeof(int));\\n    struct ListNode* prev = head;\\n    struct ListNode* tmp = head->next;\\n    int counter = 0;\\n    int min = 100000;\\n    int max = 0;\\n    arr[0] = -1;\\n    arr[1] = -1;\\n    arr[2] = -1;\\n    *returnSize = 2;\\n\\n    while(tmp->next) {\\n        if(tmp->val > prev->val && tmp->val > tmp->next->val || tmp->val < prev->val && tmp->val < tmp->next->val) {\\n            if(arr[0] == -1) {\\n                arr[0] = counter;\\n            }"], ["int* nodesBetweenCriticalPoints(struct ListNode* head, int* returnSize) \\n{\\n  int minDistance = INT_MAX;\\n  int maxDistance = INT_MIN;\\n\\n  struct ListNode * trav = head;\\n  struct ListNode * prev = NULL;\\n  int num_of_nodes = 0;\\n\\n  while(trav)\\n  {\\n    num_of_nodes++;\\n    trav = trav->next;\\n  }"]]}
{"id": "1476", "ref_c": [["int minimumOperations(int* nums, int numsSize, int start, int goal) {\\n    if (start == goal) return 0;\\n    bool * visited = calloc(1024, sizeof(bool));\\n    visited[start] = true;\\n\\n    int limit = 64;\\n    int front = 0;\\n    int rear = 0;\\n    block * queue_body = malloc(limit * sizeof(block));\\n\\n    queue_body[front].ops = 1;\\n    queue_body[front].x_arr = search_nums(nums, numsSize, start);\\n    ++front;\\n\\n    while(rear < front)\\n    {  \\n        int ops = queue_body[rear].ops;\\n        int * x_arr = queue_body[rear].x_arr;\\n        int x;\\n\\n        ++rear;\\n\\n        for (int i = 0; i < 3 * numsSize; i++)\\n        {\\n            x = x_arr[i];\\n\\n            if (x == goal)\\n            {\\n                free_queue(queue_body, front);\\n                return ops;\\n            }"], ["int minimumOperations(int* nums, int numsSize, int start, int goal) {\\n    if (start == goal) return 0;\\n    bool * visited = calloc(1024, sizeof(bool));\\n    visited[start] = true;\\n\\n    int limit = 64;\\n    int front = 0;\\n    int rear = 0;\\n    block * queue_body = malloc(limit * sizeof(block));\\n\\n    queue_body[front].ops = 1;\\n    queue_body[front].x_arr = search_nums(nums, numsSize, start);\\n    ++front;\\n\\n    while(rear < front)\\n    {  \\n        int ops = queue_body[rear].ops;\\n        int * x_arr = queue_body[rear].x_arr;\\n        int x;\\n\\n        ++rear;\\n\\n        for (int i = 0; i < 3 * numsSize; i++)\\n        {\\n            x = x_arr[i];\\n\\n            if (x == goal)\\n            {\\n                free_queue(queue_body, front);\\n                return ops;\\n            }"], ["int minimumOperations(int* nums, int numsSize, int start, int goal) {\\n    if (start == goal) return 0;\\n    bool * visited = calloc(1024, sizeof(bool));\\n    visited[start] = true;\\n\\n    int limit = 64;\\n    int front = 0;\\n    int rear = 0;\\n    block * queue_body = malloc(limit * sizeof(block));\\n\\n    queue_body[front].ops = 1;\\n    queue_body[front].x_arr = search_nums(nums, numsSize, start);\\n    ++front;\\n\\n    while(rear < front)\\n    {  \\n        int ops = queue_body[rear].ops;\\n        int * x_arr = queue_body[rear].x_arr;\\n        int x;\\n\\n        ++rear;\\n\\n        for (int i = 0; i < 3 * numsSize; i++)\\n        {\\n            x = x_arr[i];\\n\\n            if (x == goal)\\n            {\\n                free_queue(queue_body, front);\\n                return ops;\\n            }"]]}
{"id": "1477", "ref_c": [["int numUniqueEmails(char ** emails, int emailsSize)\\n{\\n    int result = 0;\\n    char cleanEmail[emailsSize][100];\\n    int clean=0;\\n    \\n    for(int i = 0; i < emailsSize; i++)\\n    {\\n        int index = 0; clean=0;\\n        while(emails[i][index] != \\'+\\' && emails[i][index] != \\'@\\')\\n        {\\n            if(emails[i][index] == \\'.\\')\\n                    index++;\\n            else\\n                {\\n                    cleanEmail[i][clean]=emails[i][index];\\n                    clean++;\\n                    index++;  \\n                }"], ["int numUniqueEmails(char ** emails, int emailsSize){\\n\\n    /*\\n     * Input:\\n     *  emails,\\n     *  emailsSize\\n     */\\n    node_t head = {0}"], ["int numUniqueEmails(char ** emails, int emailsSize){\\n\\n    /*\\n     * Input:\\n     *  emails,\\n     *  emailsSize\\n     */\\n    node_t head = {0}"]]}
{"id": "1478", "ref_c": [["int minimizedMaximum(int n, int* quantities, int quantitiesSize){\\n    if(n==1) return quantities[0];\\n    int left=1,right=0,ans;\\n    for(int i=0;i<quantitiesSize;i++){\\n        right=fmax(right,quantities[i]);\\n    }"], ["int minimizedMaximum(int n, int* quantities, int quantitiesSize){\\n    if(n==1) return quantities[0];\\n    int left=1,right=0,ans;\\n    for(int i=0;i<quantitiesSize;i++){\\n        right=fmax(right,quantities[i]);\\n    }"], ["int minimizedMaximum(int n, int* quantities, int quantitiesSize){\\n    if(n==1) return quantities[0];\\n    int left=1,right=0,ans;\\n    for(int i=0;i<quantitiesSize;i++){\\n        right=fmax(right,quantities[i]);\\n    }"]]}
{"id": "1480", "ref_c": [["bool rotateString(char * s, char * goal){\\n   if(strlen(s)!=strlen(goal))\\n        return false;\\n    char temp[strlen(s)*2+1];\\n    strcpy(temp,s);\\n    strcat(temp,s);\\n    return strstr(temp,goal)?true:false;\\n}"], ["bool rotateString(char * s, char * goal){\\n   if(strlen(s)!=strlen(goal))\\n        return false;\\n    char temp[strlen(s)*2+1];\\n    strcpy(temp,s);\\n    strcat(temp,s);\\n    return strstr(temp,goal)?true:false;\\n}"], ["bool rotateString(char * s, char * goal){\\n   if(strlen(s)!=strlen(goal))\\n        return false;\\n    char temp[strlen(s)*2+1];\\n    strcpy(temp,s);\\n    strcat(temp,s);\\n    return strstr(temp,goal)?true:false;\\n}"]]}
{"id": "1481", "ref_c": [["struct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }"], ["struct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }"], ["struct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    int totalNode = 0;\\n    int groupCnt = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* prev = NULL;\\n    \\n    while(curr)\\n    {\\n        curr = curr->next;\\n        totalNode++;\\n    }"]]}
{"id": "1482", "ref_c": [["int majorityElement(int* nums, int numsSize){\\n    int vote=0;\\n    int candidate=-1;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(vote==0)\\n        {\\n            candidate=nums[i];\\n            vote=1;\\n        }"], ["int majorityElement(int* nums, int numsSize){\\n    int sol = nums[0],\\n    cnt = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (cnt == 0) {\\n            sol = nums[i];\\n        }"], ["int majorityElement(int* nums, int numsSize){\\n    int j=0,u=0;\\nfor(int i=0;i<numsSize;i++){\\n    if(j==0)\\n        u=nums[i];\\n    if(u==nums[i])\\n        j++;\\n    else\\n        j--;\\n}"]]}
{"id": "1483", "ref_c": [["int wateringPlants(int* plants, int plantsSize, int capacity){\\n    int step=0;\\n    int i;\\n    int water=capacity;\\n    int goback=0;\\n    for(i=0;i<plantsSize;i++) {\\n        while(water<*(plants+i)) {\\n            water=capacity;\\n            step=step+i;\\n            goback=goback+i;\\n            \\n        }"], ["int wateringPlants(int* plants, int plantsSize, int capacity){\\n    int step=0;\\n    int i;\\n    int water=capacity;\\n    int goback=0;\\n    for(i=0;i<plantsSize;i++) {\\n        while(water<*(plants+i)) {\\n            water=capacity;\\n            step=step+i;\\n            goback=goback+i;\\n            \\n        }"], ["int wateringPlants(int* plants, int plantsSize, int capacity){\\n    int step=0;\\n    int i;\\n    int water=capacity;\\n    int goback=0;\\n    for(i=0;i<plantsSize;i++) {\\n        while(water<*(plants+i)) {\\n            water=capacity;\\n            step=step+i;\\n            goback=goback+i;\\n            \\n        }"]]}
{"id": "1485", "ref_c": [["int rob(int* nums, int numsSize) {\\n    if (numsSize == 0)\\n        return 0;\\n    if (numsSize == 1)\\n        return nums[0];\\n\\n    int evenSum = 0;\\n    int oddSum = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i % 2 == 0)\\n            evenSum = fmax(evenSum + nums[i], oddSum);\\n        else\\n            oddSum = fmax(oddSum + nums[i], evenSum);\\n    }"], ["int rob(int* nums, int numsSize){\\n    int dp[110],i;\\n    if(numsSize==1)\\n        return nums[0];\\n    else if (numsSize==2)\\n        return max(nums[0],nums[1]);\\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n    dp[2]=nums[2]+nums[0];\\n    for(i=3;i<(numsSize+2);i++){        \\n        dp[i]=max(dp[i-2],dp[i-3]);\\n        if(i<numsSize)\\n            dp[i]+=nums[i];\\n        printf(\"%d \",dp[i]);\\n    }"], ["int rob(int* nums, int numsSize) {\\n    if (numsSize == 0)\\n        return 0;\\n    if (numsSize == 1)\\n        return nums[0];\\n\\n    int evenSum = 0;\\n    int oddSum = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i % 2 == 0)\\n            evenSum = fmax(evenSum + nums[i], oddSum);\\n        else\\n            oddSum = fmax(oddSum + nums[i], evenSum);\\n    }"]]}
{"id": "1486", "ref_c": ["\nbool areAlmostEqual(char* s1, char* s2) \n{\n    int j = -1, k = -1, len = strlen(s1), count_unequal = 0;\n    for(int i = 0; i < len; i++)\n    {\n        if(s1[i] != s2[i])\n        {\n            count_unequal++;\n            if(j == -1)\n            {\n                j = i;\n            }\n            else if(k == -1)\n            {\n                k = i;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    return (count_unequal == 0) || (count_unequal == 2 && s1[j] == s2[k] && s1[k] == s2[j]);  \n}\n", "\nbool areAlmostEqual(char* s1, char* s2) \n{\n    int j = -1, k = -1, len = strlen(s1), count_unequal = 0;\n    for(int i = 0; i < len; i++)\n    {\n        if(s1[i] != s2[i])\n        {\n            count_unequal++;\n            if(j == -1)\n            {\n                j = i;\n            }\n            else if(k == -1)\n            {\n                k = i;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    return (count_unequal == 0) || (count_unequal == 2 && s1[j] == s2[k] && s1[k] == s2[j]);  \n}\n", "\nbool areAlmostEqual(char* s1, char* s2) \n{\n    int j = -1, k = -1, len = strlen(s1), count_unequal = 0;\n    for(int i = 0; i < len; i++)\n    {\n        if(s1[i] != s2[i])\n        {\n            count_unequal++;\n            if(j == -1)\n            {\n                j = i;\n            }\n            else if(k == -1)\n            {\n                k = i;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    return (count_unequal == 0) || (count_unequal == 2 && s1[j] == s2[k] && s1[k] == s2[j]);  \n}\n"]}
{"id": "1487", "ref_c": ["\nint* getAverages(int* nums, int numsSize, int k, int* returnSize) {\n    int index;\n    int *avgs = malloc(numsSize * sizeof(int));\n    long *prefix = malloc(numsSize * sizeof(long));\n    long sum;\n    \n    *returnSize = numsSize;\n    \n    if (k == 0) {\n        free(avgs);\n        free(prefix);\n        return nums;\n    }\n    \n    for (index = 1, prefix[0] = nums[0]; index < numsSize; index++) {\n        prefix[index] = (long) nums[index] + prefix[index - 1];\n    }\n    \n    for (index = 0; index < numsSize; index++) {\n        if (index < k || (index + k) >= numsSize) {\n            avgs[index] = -1;\n        }\n        else {\n            sum = prefix[index + k] - (index - k - 1 >= 0 ? prefix[index - k - 1] : 0);\n            avgs[index] = (int) (sum / (2 * k + 1));\n        }\n    }\n    \n    free(prefix);\n    \n    return avgs;\n}\n", "\nint* getAverages(int* nums, int numsSize, int k, int* returnSize) {\n    int index;\n    int *avgs = malloc(numsSize * sizeof(int));\n    long *prefix = malloc(numsSize * sizeof(long));\n    long sum;\n    \n    *returnSize = numsSize;\n    \n    if (k == 0) {\n        free(avgs);\n        free(prefix);\n        return nums;\n    }\n    \n    for (index = 1, prefix[0] = nums[0]; index < numsSize; index++) {\n        prefix[index] = (long) nums[index] + prefix[index - 1];\n    }\n    \n    for (index = 0; index < numsSize; index++) {\n        if (index < k || (index + k) >= numsSize) {\n            avgs[index] = -1;\n        }\n        else {\n            sum = prefix[index + k] - (index - k - 1 >= 0 ? prefix[index - k - 1] : 0);\n            avgs[index] = (int) (sum / (2 * k + 1));\n        }\n    }\n    \n    free(prefix);\n    \n    return avgs;\n}\n", "\nint* getAverages(int* nums, int numsSize, int k, int* returnSize) {\n    int index;\n    int *avgs = malloc(numsSize * sizeof(int));\n    long *prefix = malloc(numsSize * sizeof(long));\n    long sum;\n    \n    *returnSize = numsSize;\n    \n    if (k == 0) {\n        free(avgs);\n        free(prefix);\n        return nums;\n    }\n    \n    for (index = 1, prefix[0] = nums[0]; index < numsSize; index++) {\n        prefix[index] = (long) nums[index] + prefix[index - 1];\n    }\n    \n    for (index = 0; index < numsSize; index++) {\n        if (index < k || (index + k) >= numsSize) {\n            avgs[index] = -1;\n        }\n        else {\n            sum = prefix[index + k] - (index - k - 1 >= 0 ? prefix[index - k - 1] : 0);\n            avgs[index] = (int) (sum / (2 * k + 1));\n        }\n    }\n    \n    free(prefix);\n    \n    return avgs;\n}\n"]}
{"id": "1488", "ref_c": [["int minimumDeletions(int* nums, int numsSize){\\n    int min_i = 0;\\n    int max_i = 0;\\n\\t\\n\\t// TODO: speed up the min/max search for the big array size\\n    for(int i=0; i < numsSize; i++){\\n        if(nums[min_i] > nums[i]) min_i = i;\\n        if(nums[max_i] < nums[i]) max_i = i;       \\n    }"], ["int minimumDeletions(int* nums, int numsSize){\\n    int min_i = 0;\\n    int max_i = 0;\\n\\t\\n\\t// TODO: speed up the min/max search for the big array size\\n    for(int i=0; i < numsSize; i++){\\n        if(nums[min_i] > nums[i]) min_i = i;\\n        if(nums[max_i] < nums[i]) max_i = i;       \\n    }"], ["int minimumDeletions(int* nums, int numsSize){\\n    int min_i = 0;\\n    int max_i = 0;\\n\\t\\n\\t// TODO: speed up the min/max search for the big array size\\n    for(int i=0; i < numsSize; i++){\\n        if(nums[min_i] > nums[i]) min_i = i;\\n        if(nums[max_i] < nums[i]) max_i = i;       \\n    }"]]}
{"id": "1489", "ref_c": [["struct ListNode* deleteMiddle(struct ListNode* head){\\n    if(!head->next) return NULL;\\n        \\n    struct ListNode *fast = head->next;\\n    struct ListNode *slow = head;\\n    \\n    while(fast && fast->next){\\n        fast = fast->next->next;\\n        if(!fast) break;\\n        slow = slow->next;\\n    }"], ["struct ListNode* deleteMiddle(struct ListNode* head){\\n    if(head->next == NULL)\\n        return NULL;\\n    struct ListNode * temp = head;\\n    int count = 0;\\n    while(temp != NULL)\\n    {\\n        count++;\\n        temp = temp->next;\\n    }"], ["struct ListNode* deleteMiddle(struct ListNode* head){\\n    // Initialize dummy, slow and fast pointers to reach middle of linked list...\\n    struct ListNode dummy, *fast = &dummy, *slow = &dummy;\\n    dummy.next = head;\\n    // Find the middle of the linked list...\\n    while (fast->next && fast->next->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }"]]}
{"id": "1490", "ref_c": [["char * getDirections(struct TreeNode* root, int startValue, int destValue){\\n    char* startPath = (char*)calloc(100000, sizeof(char));\\n    char* destPath = (char*)calloc(100000, sizeof(char));\\n    char* tmp = (char*)calloc(100000, sizeof(char));\\n    findPath(root, startValue, destValue, tmp, 0, startPath, destPath);\\n    int idx, slen = strlen(startPath), dlen = strlen(destPath);\\n    for(idx = 0; idx < slen || idx < dlen; idx++)\\n        if(startPath[idx] != destPath[idx])\\n            break;\\n    for(int i = idx; i < slen; i++)\\n        startPath[i] = \\'U\\';\\n    for(int i = 0; i < dlen-idx; i++)\\n        startPath[slen+i] = destPath[idx+i];\\n    startPath[slen+(dlen-idx)] = \\'\\\\0\\'; \\n    return &startPath[idx];\\n}"], ["char * getDirections(struct TreeNode* root, int startValue, int destValue){\\n    char startPath[100001];\\n    char destPath[100001];\\n    int _ = getPath(root, startValue, destValue, startPath, destPath);\\n    int start_len = strlen(startPath);\\n    int dest_len = strlen(destPath);\\n    char *r = malloc(sizeof(char)*(start_len+dest_len+2));\\n    int rp = 0;\\n\\t// ignore common path.\\n    while((int)startPath[rp] == (int)destPath[rp]){\\n        rp++;\\n    }"], ["char * getDirections(struct TreeNode* root, int startValue, int destValue){\\n    char startPath[100001];\\n    char destPath[100001];\\n    int _ = getPath(root, startValue, destValue, startPath, destPath);\\n    int start_len = strlen(startPath);\\n    int dest_len = strlen(destPath);\\n    char *r = malloc(sizeof(char)*(start_len+dest_len+2));\\n    int rp = 0;\\n\\t// ignore common path.\\n    while((int)startPath[rp] == (int)destPath[rp]){\\n        rp++;\\n    }"]]}
{"id": "1491", "ref_c": [["int* goodDaysToRobBank(int* security, int securitySize, int time, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  security,\\n     *  securitySize\\n     *  time\\n     */\\n\\n    int **duty = (int **)malloc(sizeof(int *) * securitySize);\\n    int *ans = (int *)malloc(sizeof(int) * securitySize);\\n\\n    *returnSize = 0;\\n\\n    for (int i = 0; i < securitySize; i++) {\\n        duty[i] = (int *)calloc(1, sizeof(int) * 2);\\n    }"], ["int* goodDaysToRobBank(int* security, int securitySize, int time, int* returnSize){\\n    int* ret = calloc(securitySize, sizeof(int));\\n    int numPreValid = 0;\\n    int numPostValid = 0;\\n\\n    *returnSize = 0;    \\n\\t// If not enough time for any robberies, exit early\\n    if (securitySize <= time*2) {\\n        return NULL;\\n    }"], ["int* goodDaysToRobBank(int* security, int securitySize, int time, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  security,\\n     *  securitySize\\n     *  time\\n     */\\n\\n    int **duty = (int **)malloc(sizeof(int *) * securitySize);\\n    int *ans = (int *)malloc(sizeof(int) * securitySize);\\n\\n    *returnSize = 0;\\n\\n    for (int i = 0; i < securitySize; i++) {\\n        duty[i] = (int *)calloc(1, sizeof(int) * 2);\\n    }"]]}
{"id": "1492", "ref_c": [["int maximumDetonation(int** bombs, int bombsSize, int* bombsColSize){\\n    int i, j, visited[bombsSize];\\n    int numberDetonated, maxNumberDetonated = INT_MIN;\\n    Node **bombList = (Node**) calloc(bombsSize, sizeof(Node*));\\n    Node *dest;\\n\\n    /* Build up adjacency list */\\n    for (i = 0; i < bombsSize; ++i) {\\n        for (j = 0; j < bombsSize; ++j) {\\n            if (i != j && inRange(bombs, i, j)) {\\n                dest = (Node*) malloc(sizeof(Node));\\n                dest->bomb = j;\\n                dest->next = bombList[i];\\n                bombList[i] = dest;\\n            }"], ["int maximumDetonation(int** bombs, int bombsSize, int* bombsColSize){\\n    int i, j, visited[bombsSize];\\n    int numberDetonated, maxNumberDetonated = INT_MIN;\\n    Node **bombList = (Node**) calloc(bombsSize, sizeof(Node*));\\n    Node *dest;\\n\\n    /* Build up adjacency list */\\n    for (i = 0; i < bombsSize; ++i) {\\n        for (j = 0; j < bombsSize; ++j) {\\n            if (i != j && inRange(bombs, i, j)) {\\n                dest = (Node*) malloc(sizeof(Node));\\n                dest->bomb = j;\\n                dest->next = bombList[i];\\n                bombList[i] = dest;\\n            }"], ["int maximumDetonation(int** bombs, int bombsSize, int* bombsColSize){\\n    int i, j, visited[bombsSize];\\n    int numberDetonated, maxNumberDetonated = INT_MIN;\\n    Node **bombList = (Node**) calloc(bombsSize, sizeof(Node*));\\n    Node *dest;\\n\\n    /* Build up adjacency list */\\n    for (i = 0; i < bombsSize; ++i) {\\n        for (j = 0; j < bombsSize; ++j) {\\n            if (i != j && inRange(bombs, i, j)) {\\n                dest = (Node*) malloc(sizeof(Node));\\n                dest->bomb = j;\\n                dest->next = bombList[i];\\n                bombList[i] = dest;\\n            }"]]}
{"id": "1493", "ref_c": [["long long subArrayRanges(int* nums, int numsSize)\\n{\\n\\n    int *stackValues = (int *)malloc(sizeof(int) * numsSize);\\n    int *stackIndexs = (int *)malloc(sizeof(int) * numsSize);\\n    int i, size_stack = 0;\\n    \\n    // Finding the largest number until point i\\n    // ----------------------------------------\\n    int *prev_larger_num = (int *)malloc(sizeof(int) * numsSize);\\n    int *next_larger_num = (int *)malloc(sizeof(int) * numsSize);\\n    initArray(&prev_larger_num, numsSize, -1);\\n    initArray(&next_larger_num, numsSize,  numsSize);\\n    for(i = 0 ; i < numsSize ; i++)\\n    {\\n        while(size_stack && nums[i] > stackValues[size_stack - 1])\\n        {\\n            size_stack--;\\n            next_larger_num[stackIndexs[size_stack]] = i;\\n        }"], ["long long subArrayRanges(int* nums, int numsSize)\\n{\\n\\n    int *stackValues = (int *)malloc(sizeof(int) * numsSize);\\n    int *stackIndexs = (int *)malloc(sizeof(int) * numsSize);\\n    int i, size_stack = 0;\\n    \\n    // Finding the largest number until point i\\n    // ----------------------------------------\\n    int *prev_larger_num = (int *)malloc(sizeof(int) * numsSize);\\n    int *next_larger_num = (int *)malloc(sizeof(int) * numsSize);\\n    initArray(&prev_larger_num, numsSize, -1);\\n    initArray(&next_larger_num, numsSize,  numsSize);\\n    for(i = 0 ; i < numsSize ; i++)\\n    {\\n        while(size_stack && nums[i] > stackValues[size_stack - 1])\\n        {\\n            size_stack--;\\n            next_larger_num[stackIndexs[size_stack]] = i;\\n        }"], ["long long subArrayRanges(int* nums, int numsSize)\\n{\\n\\n    int *stackValues = (int *)malloc(sizeof(int) * numsSize);\\n    int *stackIndexs = (int *)malloc(sizeof(int) * numsSize);\\n    int i, size_stack = 0;\\n    \\n    // Finding the largest number until point i\\n    // ----------------------------------------\\n    int *prev_larger_num = (int *)malloc(sizeof(int) * numsSize);\\n    int *next_larger_num = (int *)malloc(sizeof(int) * numsSize);\\n    initArray(&prev_larger_num, numsSize, -1);\\n    initArray(&next_larger_num, numsSize,  numsSize);\\n    for(i = 0 ; i < numsSize ; i++)\\n    {\\n        while(size_stack && nums[i] > stackValues[size_stack - 1])\\n        {\\n            size_stack--;\\n            next_larger_num[stackIndexs[size_stack]] = i;\\n        }"]]}
{"id": "1494", "ref_c": [["int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\\n    int min=-INT_MAX;\\n    int s,j;\\n    mergeSort(points,0,pointsSize-1);\\n    for(int i=0;i<pointsSize-1;i++){\\n            s=points[i+1][0]-points[i][0];\\n            if(s>min){\\n                min=s;\\n            }"], ["int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\\n    int min=-INT_MAX;\\n    int s,j;\\n    mergeSort(points,0,pointsSize-1);\\n    for(int i=0;i<pointsSize-1;i++){\\n            s=points[i+1][0]-points[i][0];\\n            if(s>min){\\n                min=s;\\n            }"], ["int maxWidthOfVerticalArea(int** points, int pointsSize, int* pointsColSize) {\\n    qsort(points, pointsSize, sizeof(int *), cmp);\\n\\n    int max_width = 0;\\n\\n    /* Update the max width */\\n    for (int i = 1; i < pointsSize; ++i) {\\n        int curr_width = points[i][0] - points[i - 1][0];\\n        max_width = fmax(max_width, curr_width);\\n    }"]]}
{"id": "1495", "ref_c": [["char * addSpaces(char * s, int* spaces, int spacesSize){\\n    \\nint length=strlen(s)+spacesSize;\\nchar* str=(char*)malloc(sizeof(char)*(length+1));\\nif(str==NULL) {\\n    return NULL;\\n}"], ["char * addSpaces(char * s, int* spaces, int spacesSize){\\n    \\nint length=strlen(s)+spacesSize;\\nchar* str=(char*)malloc(sizeof(char)*(length+1));\\nif(str==NULL) {\\n    return NULL;\\n}"], ["char * addSpaces(char * s, int* spaces, int spacesSize){\\n    \\nint length=strlen(s)+spacesSize;\\nchar* str=(char*)malloc(sizeof(char)*(length+1));\\nif(str==NULL) {\\n    return NULL;\\n}"]]}
{"id": "1496", "ref_c": [["int countBeautifulPairs(int* nums, int numsSize){\\n    int i,c=0,a,b,j,k;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        while(nums[i]>0)\\n        {\\n            a=nums[i]%10;\\n            nums[i]=nums[i]/10;\\n        }"], ["int countBeautifulPairs(int* nums, int numsSize){\\n    int ret = 0;\\n    int  i,j,x,y,gcd;\\n    for(i=0;i<numsSize;i++){\\n        while(nums[i]){\\n            x = nums[i]%10;\\n            nums[i] = nums[i]/10;\\n        }"], ["int countBeautifulPairs(int* nums, int numsSize){\\n    int c=0;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            int a,b;\\n            a=nums[j]%10;\\n            b=nums[i];\\n\\n            while(b/10!=0)\\n            b/=10;\\n            if(gcd(a,b)==1)\\n            c++;\\n        }"]]}
{"id": "1497", "ref_c": [["char ** findAllRecipes(char ** recipes, int recipesSize, char *** ingredients, int ingredientsSize, int* ingredientsColSize, char ** supplies, int suppliesSize, int* returnSize){\\n    struct Node** h;\\n    int count = 0;\\n    char** sol;\\n    \\n    h = calloc(sizeof(struct Node*), MAXH);\\n    sol = calloc(sizeof(char*), recipesSize);\\n    \\n    //fill hashmap\\n    for(int i = 0; i < suppliesSize; i++) {\\n        int key = 0;\\n        struct Node* p;\\n        p = malloc(sizeof(struct Node));\\n        key = makekey(supplies[i]);\\n        p->next = h[key];\\n        p->s = supplies[i];\\n        p->idx = -1; //not recipes\\n        p->dirty = 1; //available;\\n        h[key] = p;        \\n    }"], ["char ** findAllRecipes(char ** recipes, int recipesSize, char *** ingredients, int ingredientsSize, int* ingredientsColSize, char ** supplies, int suppliesSize, int* returnSize){\\n    struct Node** h;\\n    int count = 0;\\n    char** sol;\\n    \\n    h = calloc(sizeof(struct Node*), MAXH);\\n    sol = calloc(sizeof(char*), recipesSize);\\n    \\n    //fill hashmap\\n    for(int i = 0; i < suppliesSize; i++) {\\n        int key = 0;\\n        struct Node* p;\\n        p = malloc(sizeof(struct Node));\\n        key = makekey(supplies[i]);\\n        p->next = h[key];\\n        p->s = supplies[i];\\n        p->idx = -1; //not recipes\\n        p->dirty = 1; //available;\\n        h[key] = p;        \\n    }"], ["char ** findAllRecipes(char ** recipes, int recipesSize, char *** ingredients, int ingredientsSize, int* ingredientsColSize, char ** supplies, int suppliesSize, int* returnSize){\\n    struct Node** h;\\n    int count = 0;\\n    char** sol;\\n    \\n    h = calloc(sizeof(struct Node*), MAXH);\\n    sol = calloc(sizeof(char*), recipesSize);\\n    \\n    //fill hashmap\\n    for(int i = 0; i < suppliesSize; i++) {\\n        int key = 0;\\n        struct Node* p;\\n        p = malloc(sizeof(struct Node));\\n        key = makekey(supplies[i]);\\n        p->next = h[key];\\n        p->s = supplies[i];\\n        p->idx = -1; //not recipes\\n        p->dirty = 1; //available;\\n        h[key] = p;        \\n    }"]]}
{"id": "1498", "ref_c": ["\nint maxProduct(int* nums, int N){\n    int result = nums[0];\n    for(int i=1, MIN=result, MAX=result; i<N; i++){\n        if(nums[i]<0){\n            int save = MIN;\n            MIN = MAX;\n            MAX = save;\n        }\n        MAX *= nums[i];\n        MIN *= nums[i]; \n        MAX = nums[i] >= MAX ? nums[i] : MAX ;\n        MIN = nums[i] <= MIN ? nums[i] : MIN ;\n        result = result >= MAX ? result : MAX;\n    }\n    return result;\n}\n", "\nint maxProduct(int* nums, int N){\n    int result = nums[0];\n    for(int i=1, MIN=result, MAX=result; i<N; i++){\n        if(nums[i]<0){\n            int save = MIN;\n            MIN = MAX;\n            MAX = save;\n        }\n        MAX *= nums[i];\n        MIN *= nums[i]; \n        MAX = nums[i] >= MAX ? nums[i] : MAX ;\n        MIN = nums[i] <= MIN ? nums[i] : MIN ;\n        result = result >= MAX ? result : MAX;\n    }\n    return result;\n}\n", "\nint maxProduct(int* nums, int N){\n    int result = nums[0];\n    for(int i=1, MIN=result, MAX=result; i<N; i++){\n        if(nums[i]<0){\n            int save = MIN;\n            MIN = MAX;\n            MAX = save;\n        }\n        MAX *= nums[i];\n        MIN *= nums[i]; \n        MAX = nums[i] >= MAX ? nums[i] : MAX ;\n        MIN = nums[i] <= MIN ? nums[i] : MIN ;\n        result = result >= MAX ? result : MAX;\n    }\n    return result;\n}\n"]}
{"id": "1499", "ref_c": [["int* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int *answer=malloc(strlen(s)*sizeof(int));\\n    for(int i=0; s[i]!=\\'\\\\0\\'; i++){\\n        int count=0, flag=0, x=startPos[0], y=startPos[1];\\n        for(int j=i; s[j]!=\\'\\\\0\\'; j++){\\n            switch(s[j]){\\n                case \\'L\\':\\n                    y--;\\n                    if(y<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'R\\':\\n                    y++;\\n                    if(y>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'U\\':\\n                    x--;\\n                    if(x<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'D\\':\\n                    x++;\\n                    if(x>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n            }"], ["int* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int *answer=malloc(strlen(s)*sizeof(int));\\n    for(int i=0; s[i]!=\\'\\\\0\\'; i++){\\n        int count=0, flag=0, x=startPos[0], y=startPos[1];\\n        for(int j=i; s[j]!=\\'\\\\0\\'; j++){\\n            switch(s[j]){\\n                case \\'L\\':\\n                    y--;\\n                    if(y<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'R\\':\\n                    y++;\\n                    if(y>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'U\\':\\n                    x--;\\n                    if(x<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'D\\':\\n                    x++;\\n                    if(x>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n            }"], ["int* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int possible_move=0;\\n    int temp[2] = {startPos[0],startPos[1]}"]]}
{"id": "1500", "ref_c": [["long long* getDistances(int* arr, int arrSize, int* returnSize) {\\n    int i = 0;\\n    node_h_t **ht;\\n    node_t *ll;\\n    long long *ret, left_cnt, right_cnt;\\n    long long tot_cnt = 0 , cnt = 0, idx = 0;\\n    node_t *idx_nodes;\\n\\n    ht = calloc(HT_SZ, sizeof(node_h_t));\\n    ret = calloc(arrSize, sizeof(long long));\\n    idx_nodes = calloc(arrSize, sizeof(node_t));\\n    *(returnSize) = arrSize;\\n\\n    for(i = 0; i < arrSize; i++)\\n    {\\n      ht_push(ht, arr[i], i, idx_nodes);\\n    }"], ["long long* getDistances(int* arr, int arrSize, int* returnSize){\\n    long long* ret = calloc(arrSize, sizeof(long long));\\n    Hash h = { 0, NULL}"], ["long long* getDistances(int* arr, int arrSize, int* returnSize) {\\n    int i = 0;\\n    node_h_t **ht;\\n    node_t *ll;\\n    long long *ret, left_cnt, right_cnt;\\n    long long tot_cnt = 0 , cnt = 0, idx = 0;\\n    node_t *idx_nodes;\\n\\n    ht = calloc(HT_SZ, sizeof(node_h_t));\\n    ret = calloc(arrSize, sizeof(long long));\\n    idx_nodes = calloc(arrSize, sizeof(node_t));\\n    *(returnSize) = arrSize;\\n\\n    for(i = 0; i < arrSize; i++)\\n    {\\n      ht_push(ht, arr[i], i, idx_nodes);\\n    }"]]}
{"id": "1501", "ref_c": [["int numberOfBeams(char ** bank, int bankSize){\\n    int sum=0, precount=0;\\n    for(int i=0; i<bankSize; i++){\\n        int count=0;\\n        for(int j=0; bank[i][j]!=\\'\\\\0\\'; j++){\\n            if(bank[i][j]==\\'1\\')\\n                count++;\\n        }"], ["int numberOfBeams(char ** bank, int bankSize){\\n    int arr[bankSize];\\n    int k=0;\\n    for(int i=0;i<bankSize;i++)\\n    {\\n        int c=0;\\n        for(int j=0;bank[i][j]!=\\'\\\\0\\';j++)\\n        {\\n            if(bank[i][j]==\\'1\\')\\n                c++;\\n        }"], ["int numberOfBeams(char ** bank, int bankSize){\\n    int sum=0, precount=0;\\n    for(int i=0; i<bankSize; i++){\\n        int count=0;\\n        for(int j=0; bank[i][j]!=\\'\\\\0\\'; j++){\\n            if(bank[i][j]==\\'1\\')\\n                count++;\\n        }"]]}
{"id": "1502", "ref_c": [["bool asteroidsDestroyed(int mass, int* asteroids, int asteroidsSize)\\n{\\n    long long sum = mass;\\n    qsort(asteroids, asteroidsSize, sizeof(int), cmp);\\n    for(int i = 0; i < asteroidsSize; i++)\\n    {\\n        if(sum >= asteroids[i])\\n        {\\n            sum = sum + asteroids[i];\\n        }"], ["bool asteroidsDestroyed(int mass, int* asteroids, int asteroidsSize)\\n{\\n    long long sum = mass;\\n    qsort(asteroids, asteroidsSize, sizeof(int), cmp);\\n    for(int i = 0; i < asteroidsSize; i++)\\n    {\\n        if(sum >= asteroids[i])\\n        {\\n            sum = sum + asteroids[i];\\n        }"], ["bool asteroidsDestroyed(int mass, int* asteroids, int asteroidsSize)\\n{\\n    long long sum = mass;\\n    qsort(asteroids, asteroidsSize, sizeof(int), cmp);\\n    for(int i = 0; i < asteroidsSize; i++)\\n    {\\n        if(sum >= asteroids[i])\\n        {\\n            sum = sum + asteroids[i];\\n        }"]]}
{"id": "1503", "ref_c": ["\ntypedef struct ListNode node;\n\nvoid addBegin(node** head,int val){\n    node *new=(node*)malloc(sizeof(node));\n\tnew->val=val;\n    new->next=*head;\n   *head=new;\n}\n\nnode* reverseList(node* head) {\n   \tnode *p=head,*reverseList=NULL;\n   \t    while(p!=NULL){\n   \t        addBegin(&reverseList,p->val);\n\t\t    p=p->next;\n\t    }\n    return reverseList;\n}\n\nint length(node *head){\n    node *p=head;int count=0;\n\twhile(p!=NULL){\n\t\tp=p->next;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nint pairSum(node* head) {\n    if(head==NULL){\n        printf(\"list is empty\");\n\t\treturn 0;\n    }\n    else if(head->next->next==NULL){\n        return head->val+head->next->val;\n    } \n    else{\n        node *reverse=reverseList(head);\n        int l=length(head),i=1;\n        node *p=head->next, *r=reverse->next;\n        int max=head->val+reverse->val;\n        while(i<l/2){\n            int sum=p->val+r->val;\n            if(sum>max) max=sum;\n            p=p->next;\n            r=r->next;\n            i++;\n        }\n        return max;\n    }\n}\n", "\ntypedef struct ListNode node;\n\nvoid addBegin(node** head,int val){\n    node *new=(node*)malloc(sizeof(node));\n\tnew->val=val;\n    new->next=*head;\n   *head=new;\n}\n\nnode* reverseList(node* head) {\n   \tnode *p=head,*reverseList=NULL;\n   \t    while(p!=NULL){\n   \t        addBegin(&reverseList,p->val);\n\t\t    p=p->next;\n\t    }\n    return reverseList;\n}\n\nint length(node *head){\n    node *p=head;int count=0;\n\twhile(p!=NULL){\n\t\tp=p->next;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nint pairSum(node* head) {\n    if(head==NULL){\n        printf(\"list is empty\");\n\t\treturn 0;\n    }\n    else if(head->next->next==NULL){\n        return head->val+head->next->val;\n    } \n    else{\n        node *reverse=reverseList(head);\n        int l=length(head),i=1;\n        node *p=head->next, *r=reverse->next;\n        int max=head->val+reverse->val;\n        while(i<l/2){\n            int sum=p->val+r->val;\n            if(sum>max) max=sum;\n            p=p->next;\n            r=r->next;\n            i++;\n        }\n        return max;\n    }\n}\n", "\ntypedef struct ListNode node;\n\nvoid addBegin(node** head,int val){\n    node *new=(node*)malloc(sizeof(node));\n\tnew->val=val;\n    new->next=*head;\n   *head=new;\n}\n\nnode* reverseList(node* head) {\n   \tnode *p=head,*reverseList=NULL;\n   \t    while(p!=NULL){\n   \t        addBegin(&reverseList,p->val);\n\t\t    p=p->next;\n\t    }\n    return reverseList;\n}\n\nint length(node *head){\n    node *p=head;int count=0;\n\twhile(p!=NULL){\n\t\tp=p->next;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nint pairSum(node* head) {\n    if(head==NULL){\n        printf(\"list is empty\");\n\t\treturn 0;\n    }\n    else if(head->next->next==NULL){\n        return head->val+head->next->val;\n    } \n    else{\n        node *reverse=reverseList(head);\n        int l=length(head),i=1;\n        node *p=head->next, *r=reverse->next;\n        int max=head->val+reverse->val;\n        while(i<l/2){\n            int sum=p->val+r->val;\n            if(sum>max) max=sum;\n            p=p->next;\n            r=r->next;\n            i++;\n        }\n        return max;\n    }\n}\n"]}
{"id": "1504", "ref_c": [["int longestPalindrome(char ** words, int wordsSize){\\n    /*\\n     * Input:\\n     *  words, string array\\n     *  wordsSize, number of strings in given array\\n     */\\n     \\n    int freq[26][26] = {0}"], ["int longestPalindrome(char ** words, int wordsSize){\\n    /*\\n     * Input:\\n     *  words, string array\\n     *  wordsSize, number of strings in given array\\n     */\\n     \\n    int freq[26][26] = {0}"], ["int longestPalindrome(char ** words, int wordsSize){\\n    //hash table creation \\n    int** HASH_TABLE = (int**)calloc(sizeof(int*),255);\\n    for(int i= 0 ; i< 255; i++){\\n        HASH_TABLE[i] = (int*)calloc(sizeof(int),255);\\n    }"]]}
{"id": "1505", "ref_c": [["int minSwaps(int* nums, int numsSize){\\n    int zeros=0;\\n    int ones=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) ones++;\\n    }"], ["int minSwaps(int* nums, int numsSize){\\n    int zeros=0;\\n    int ones=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) ones++;\\n    }"], ["int minSwaps(int* nums, int numsSize){\\n    int length = 0;\\n    for(int i = 0; i < numsSize; i ++){\\n        length += nums[i];\\n    }"]]}
{"id": "1506", "ref_c": [["int wordCount(char ** startWords, int startWordsSize, char ** targetWords, int targetWordsSize){\\n    hElem *set = NULL, *s;\\n    int result = 0;\\n    \\n    for(int i = 0; i < startWordsSize; i++) {\\n        int mask = 0;    \\n        for(int c = 0; startWords[i][c]; c++)\\n            mask ^= 1 << (startWords[i][c] - \\'a\\');\\n        s = calloc(sizeof(hElem), 1);\\n        s->charMask = mask;\\n        HASH_ADD_INT(set, charMask, s);\\n    }"], ["int wordCount(char ** startWords, int startWordsSize, char ** targetWords, int targetWordsSize)\\n{\\n    int hash, j, count = 0, mhash;\\n    struct trienode *root = create_node();\\n    \\n    for (int i=0; i<startWordsSize; i++)\\n    {\\n        hash = 0;\\n        j=0;\\n        while(startWords[i][j] != \\'\\\\0\\')\\n        {\\n            hash |= (1<<(startWords[i][j]-\\'a\\'));\\n            j++;\\n        }"], ["int wordCount(char ** startWords, int startWordsSize, char ** targetWords, int targetWordsSize){\\n    hElem *set = NULL, *s;\\n    int result = 0;\\n    \\n    for(int i = 0; i < startWordsSize; i++) {\\n        int mask = 0;    \\n        for(int c = 0; startWords[i][c]; c++)\\n            mask ^= 1 << (startWords[i][c] - \\'a\\');\\n        s = calloc(sizeof(hElem), 1);\\n        s->charMask = mask;\\n        HASH_ADD_INT(set, charMask, s);\\n    }"]]}
{"id": "1507", "ref_c": [["int minMoves(int target, int maxDoubles){\\n    if (target == 1){\\n        return 0;\\n    }"], ["int minMoves(int target, int maxDoubles){\\n    int c=0;\\nwhile(target!=0 && maxDoubles>0){\\n    if(target%2==0 ){\\n        target/=2;\\n        maxDoubles--;\\n    }"], ["int minMoves(int target, int maxDoubles)\\n{\\n    int moves=0;\\n    while(target!=1)\\n    {\\n        if(maxDoubles==0)\\n        {\\n            break;\\n        }"]]}
{"id": "1508", "ref_c": [["long long mostPoints(int** questions, int questionsSize, int* questionsColSize)\\n{\\n    int n = questionsSize;\\n    long long ans = 0,cur = 0;\\n    for (int i=0;i<=n;i++)\\n        dp[i] = 0;\\n    for (int i=0;i<n;i++)\\n    {\\n        // answer. \\n        int pos = MIN(i+questions[i][1],n);\\n        if (i >= 1)\\n            dp[pos] = MAX(dp[i-1] + questions[i][0],dp[pos]);\\n        else\\n            dp[pos] = MAX(dp[i]+questions[i][0],dp[pos]);\\n        // don\\'t answer.\\n        if (i>=1) dp[i] = MAX(dp[i-1],dp[i]);\\n        ans = MAX(dp[i],ans);\\n    }"], ["long long mostPoints(int** questions, int questionsSize, int* questionsColSize)\\n{\\n\\n    long long int dp[questionsSize];\\n    memset(dp, 0, sizeof(dp));\\n    dp[questionsSize - 1] = questions[questionsSize - 1][0];\\n    for (int i = questionsSize - 2; i >= 0; --i) \\n    {\\n       dp[i] = questions[i][0];\\n       int bpower = questions[i][1];\\n       if (i + bpower + 1 < questionsSize) \\n       { //solving\\n         dp[i] += dp[i + bpower + 1];\\n       }"], ["long long mostPoints(int** questions, int questionsSize, int* questionsColSize)\\n{\\n\\n    long long int dp[questionsSize];\\n    memset(dp, 0, sizeof(dp));\\n    dp[questionsSize - 1] = questions[questionsSize - 1][0];\\n    for (int i = questionsSize - 2; i >= 0; --i) \\n    {\\n       dp[i] = questions[i][0];\\n       int bpower = questions[i][1];\\n       if (i + bpower + 1 < questionsSize) \\n       { //solving\\n         dp[i] += dp[i + bpower + 1];\\n       }"]]}
{"id": "1509", "ref_c": [["int longestWPI(int* hours, int hoursSize){\\n\\n    int t=0;\\n    int max=0;\\n    \\n    for(int i=0;i<=hoursSize;i++)c[i]=-1;\\n    \\n    for(int i=0;i<hoursSize;i++){\\n        if(hours[i]>8)t++;\\n        else t--;\\n        \\n        if(t<0 && c[abs(t)]==-1)c[abs(t)]=i;\\n        \\n        if(t>0)max=i+1;\\n        else if(t<=0){\\n            if(c[abs(t-1)]>=0 && i-c[abs(t-1)]>max)max=i-c[abs(t-1)];\\n        }"], ["int longestWPI(int* hours, int hoursSize){\\n\\n    int t=0;\\n    int max=0;\\n    \\n    for(int i=0;i<=hoursSize;i++)c[i]=-1;\\n    \\n    for(int i=0;i<hoursSize;i++){\\n        if(hours[i]>8)t++;\\n        else t--;\\n        \\n        if(t<0 && c[abs(t)]==-1)c[abs(t)]=i;\\n        \\n        if(t>0)max=i+1;\\n        else if(t<=0){\\n            if(c[abs(t-1)]>=0 && i-c[abs(t-1)]>max)max=i-c[abs(t-1)];\\n        }"], ["int longestWPI(int* hours, int hoursSize){\\n\\n    int t=0;\\n    int max=0;\\n    \\n    for(int i=0;i<=hoursSize;i++)c[i]=-1;\\n    \\n    for(int i=0;i<hoursSize;i++){\\n        if(hours[i]>8)t++;\\n        else t--;\\n        \\n        if(t<0 && c[abs(t)]==-1)c[abs(t)]=i;\\n        \\n        if(t>0)max=i+1;\\n        else if(t<=0){\\n            if(c[abs(t-1)]>=0 && i-c[abs(t-1)]>max)max=i-c[abs(t-1)];\\n        }"]]}
{"id": "1510", "ref_c": [["int getLucky(char * s, int k){\\nint i,p,sum=0,tempsum=0,j=0,nums[100];\\nfor(i=0;s[i];i++)\\n{\\n p=s[i]-96;\\n if(p<=9) sum+=p;\\n else\\n {\\n     while(p!=0)\\n     {\\n         sum+=p%10;\\n         p=p/10;\\n     }"], ["int getLucky(char * s, int k){\\nint i,p,sum=0,tempsum=0,j=0,nums[100];\\nfor(i=0;s[i];i++)\\n{\\n p=s[i]-96;\\n if(p<=9) sum+=p;\\n else\\n {\\n     while(p!=0)\\n     {\\n         sum+=p%10;\\n         p=p/10;\\n     }"], ["int getLucky(char * s, int k){\\nint i,p,sum=0,tempsum=0,j=0,nums[100];\\nfor(i=0;s[i];i++)\\n{\\n p=s[i]-96;\\n if(p<=9) sum+=p;\\n else\\n {\\n     while(p!=0)\\n     {\\n         sum+=p%10;\\n         p=p/10;\\n     }"]]}
{"id": "1511", "ref_c": [["int* rearrangeArray(int* nums, int numsSize, int* returnSize){\\nint* new=(int*)malloc(numsSize*sizeof(int));\\nint i,p=0,n=1;\\nfor(i=0;i<numsSize;i++)\\n{\\n    if(nums[i]>0)\\n    {\\n        new[p]=nums[i];\\n        p=p+2;\\n\\n    }"], ["int* rearrangeArray(int* nums, int numsSize, int* returnSize) \\n{\\n    int* ret = malloc(sizeof(int) * (numsSize));\\n    int pos = 0;\\n    int neg = 1;\\n\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        if (nums[i] > 0)\\n        {\\n            ret[pos] = nums[i];\\n            pos += 2;\\n        }"], ["int* rearrangeArray(int* nums, int numsSize, int* returnSize){\\nint* new=(int*)malloc(numsSize*sizeof(int));\\nint i,p=0,n=1;\\nfor(i=0;i<numsSize;i++)\\n{\\n    if(nums[i]>0)\\n    {\\n        new[p]=nums[i];\\n        p=p+2;\\n\\n    }"]]}
{"id": "1512", "ref_c": [["int* findLonely(int* nums, int numsSize, int* returnSize){\\n    int* arr=(int*)malloc(sizeof(int)*numsSize);\\n    qsort(nums,numsSize,sizeof(int),compare);\\n    int count=0;\\nfor(int i=0; i<numsSize; i++) {\\n    if((i == 0 || nums[i] != nums[i - 1]) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1]) &&\\n            (i == 0 || nums[i] != nums[i - 1] + 1) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1] - 1)) { \\n        arr[count++]=nums[i];\\n    }"], ["int* findLonely(int* nums, int numsSize, int* returnSize){\\n    int* arr=(int*)malloc(sizeof(int)*numsSize);\\n    qsort(nums,numsSize,sizeof(int),compare);\\n    int count=0;\\nfor(int i=0; i<numsSize; i++) {\\n    if((i == 0 || nums[i] != nums[i - 1]) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1]) &&\\n            (i == 0 || nums[i] != nums[i - 1] + 1) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1] - 1)) { \\n        arr[count++]=nums[i];\\n    }"], ["int* findLonely(int* nums, int numsSize, int* returnSize) {\\n    int arr[1000002] = {0}"]]}
{"id": "1513", "ref_c": [["int* maxScoreIndices(int* nums, int numsSize, int* returnSize){\\n    int *res=malloc(sizeof(int)*numsSize);\\n    int left_zero=0,right_one=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) right_one++;\\n    }"], ["int* maxScoreIndices(int* nums, int numsSize, int* returnSize){\\n    int *res=malloc(sizeof(int)*numsSize);\\n    int left_zero=0,right_one=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) right_one++;\\n    }"], ["int* maxScoreIndices(int* nums, int numsSize, int* returnSize){\\n    int *res=malloc(sizeof(int)*numsSize);\\n    int left_zero=0,right_one=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) right_one++;\\n    }"]]}
{"id": "1514", "ref_c": [["int* pivotArray(int* nums, int numsSize, int pivot, int* returnSize)\\n{\\n    *returnSize=numsSize;\\n    int c=0,c1=0;\\n    for(int i=0;i<numsSize;i++){\\n    if(nums[i]<pivot)c++;\\n    else if(nums[i]==pivot)c1++;}"], ["int* pivotArray(int* nums, int numsSize, int pivot, int* returnSize)\\n{\\n    *returnSize=numsSize;\\n    int c=0,c1=0;\\n    for(int i=0;i<numsSize;i++){\\n    if(nums[i]<pivot)c++;\\n    else if(nums[i]==pivot)c1++;}"], ["int* pivotArray(int* nums, int numsSize, int pivot, int* returnSize)\\n{\\n    *returnSize=numsSize;\\n    int c=0,c1=0;\\n    for(int i=0;i<numsSize;i++){\\n    if(nums[i]<pivot)c++;\\n    else if(nums[i]==pivot)c1++;}"]]}
{"id": "1515", "ref_c": [["bool isIsomorphic(char * s, char * t){\\n    char f2s[128]={0}"], ["bool isIsomorphic(char * s, char * t){\\n    char f2s[128]={0}"], ["bool isIsomorphic(char * s, char * t){\\n    char f2s[128]={0}"]]}
{"id": "1516", "ref_c": [["long long smallestNumber(long long num) {\\n        if(num == 0)\\n            return num;\\n\\n        vector<int> nums;\\n        bool flag = (num<0);\\n\\n        while(num != 0)\\n        {\\n            int rem = num%10;\\n            num /= 10;\\n            nums.push_back(rem);\\n        }"], ["long long smallestNumber(long long num){\\n\\n\\t\\tif (num == 0)\\n\\t\\t\\treturn num;\\n\\t\\t\\t\\n\\t\\t//find length of long long\\n\\t\\tlong long x = num; \\n\\t\\tif (x < 0)\\n\\t\\t\\tx = -x;\\n\\t\\tint size = 0;\\n\\t\\twhile (x != 0)\\n\\t\\t{\\n\\t\\t\\tint digit = x%10;\\n\\t\\t\\tsize++;\\n\\t\\t\\tx /= 10;\\n\\t\\t}"], ["long long smallestNumber(long long num){\\n    int is_neg = 0;\\n    if(num < 0){\\n        is_neg = 1;\\n        num = num * -1;\\n    }"]]}
{"id": "1518", "ref_c": [["int minimumOperations(int* nums, int numsSize){\\n    int evenMap[MAP_SIZE] = {0}"], ["int minimumOperations(int* nums, int numsSize){\\n    int evenMap[MAP_SIZE] = {0}"], ["int minimumOperations(int* nums, int numsSize){\\n    int evenMap[MAP_SIZE] = {0}"]]}
{"id": "1519", "ref_c": [["long long minimumRemoval(int* beans, int beansSize) {\\n    qsort(beans, beansSize, sizeof(int), cmp);\\n    long long sum = 0;\\n    for(int i = 0; i < beansSize; i++) {\\n        sum += beans[i];\\n    }"], ["long long minimumRemoval(int* beans, int beansSize) {\\n    qsort(beans, beansSize, sizeof(int), cmp);\\n    long long sum = 0;\\n    for(int i = 0; i < beansSize; i++) {\\n        sum += beans[i];\\n    }"], ["long long minimumRemoval(int* beans, int beansSize) {\\n    qsort(beans, beansSize, sizeof(int), cmp);\\n    long long sum = 0;\\n    for(int i = 0; i < beansSize; i++) {\\n        sum += beans[i];\\n    }"]]}
{"id": "1520", "ref_c": [["long long* sumOfThree(long long num, int* returnSize){\\n    if (num%3){\\n        *returnSize = 0;\\n        return malloc(0);\\n    }"], ["long long* sumOfThree(long long num, int* returnSize){\\n\\t\\tlong long *res;\\n\\t\\tif(num%3==0){\\n\\t\\t\\t*returnSize=3;\\n\\t\\t\\tres=malloc(sizeof(long long)*3);\\n\\t\\t\\tres[0]=num/3-1;\\n\\t\\t\\tres[1]=num/3;\\n\\t\\t\\tres[2]=num/3+1;\\n\\n\\t\\t}"], ["long long* sumOfThree(long long num, int* returnSize){\\n    long long* ans=malloc(3*sizeof(long long));\\n    if(num%3!=0)\\n    {\\n        *(returnSize)=0;\\n        return ans;\\n    }"]]}
{"id": "1521", "ref_c": [["long long* maximumEvenSplit(long long finalSum, int* returnSize){\\n    *returnSize = 0;\\n    if(finalSum & 1) return NULL;\\n    \\n    long long* ans = (long long*)calloc(100000, sizeof(long long));\\n    int ansIdx = 0;\\n    \\n    ans[ansIdx++] = 2;\\n    split(finalSum - 2, 2, ans, &ansIdx);\\n\\n    *returnSize = ansIdx;\\n    return ans;\\n}"], ["long long* maximumEvenSplit(long long finalSum, int* returnSize){\\n    *returnSize = 0;\\n    if(finalSum & 1) return NULL;\\n    \\n    long long* ans = (long long*)calloc(100000, sizeof(long long));\\n    int ansIdx = 0;\\n    \\n    ans[ansIdx++] = 2;\\n    split(finalSum - 2, 2, ans, &ansIdx);\\n\\n    *returnSize = ansIdx;\\n    return ans;\\n}"], ["long long* maximumEvenSplit(long long finalSum, int* returnSize){\\n    *returnSize = 0;\\n    if(finalSum & 1) return NULL;\\n    \\n    long long* ans = (long long*)calloc(100000, sizeof(long long));\\n    int ansIdx = 0;\\n    \\n    ans[ansIdx++] = 2;\\n    split(finalSum - 2, 2, ans, &ansIdx);\\n\\n    *returnSize = ansIdx;\\n    return ans;\\n}"]]}
{"id": "1522", "ref_c": [["struct ListNode* mergeNodes(struct ListNode* head) {\\n    int sum = 0;\\n    struct ListNode* current = head;\\n    struct ListNode* start = head;\\n    struct ListNode* last = NULL;\\n    struct ListNode* resultHead = start;\\n\\n    while (current != NULL) {\\n        if (sum > 0 && current->val == 0) {\\n            start->val = sum;\\n            sum = 0;\\n            last = start;\\n            start = start->next;\\n        }"], ["struct ListNode* mergeNodes(struct ListNode* head) {\\n    struct ListNode dummy;\\n    struct ListNode* retlist = &dummy;\\n    retlist->next = NULL;\\n\\n    while (head) {\\n        retlist->val += head->val;\\n        if (head->val == 0) {\\n            if (head->next) {\\n                retlist->next = head;\\n                retlist = head;\\n            }"], ["struct ListNode* mergeNodes(struct ListNode* head) {\\n    int sum = 0;\\n    struct ListNode* current = head;\\n    struct ListNode* start = head;\\n    struct ListNode* last = NULL;\\n    struct ListNode* resultHead = start;\\n\\n    while (current != NULL) {\\n        if (sum > 0 && current->val == 0) {\\n            start->val = sum;\\n            sum = 0;\\n            last = start;\\n            start = start->next;\\n        }"]]}
{"id": "1523", "ref_c": [["char * repeatLimitedString(char * s, int repeatLimit){\\n    int n = strlen(s);\\n    int* counts = getCounts(s);\\n    \\n    char* result = (char*) calloc(n + 1, sizeof(char));\\n    int index = 0;\\n\\n    for(int i = \\'z\\' - \\'a\\'; i >= 0;)\\n    {\\n        if (!counts[i])\\n        {\\n            i--;\\n            continue;\\n        }"], ["char * repeatLimitedString(char * s, int repeatLimit){\\n    int n = strlen(s);\\n    int* counts = getCounts(s);\\n    \\n    char* result = (char*) calloc(n + 1, sizeof(char));\\n    int index = 0;\\n\\n    for(int i = \\'z\\' - \\'a\\'; i >= 0;)\\n    {\\n        if (!counts[i])\\n        {\\n            i--;\\n            continue;\\n        }"], ["char * repeatLimitedString(char * s, int repeatLimit){\\n    int n = strlen(s);\\n    int* counts = getCounts(s);\\n    \\n    char* result = (char*) calloc(n + 1, sizeof(char));\\n    int index = 0;\\n\\n    for(int i = \\'z\\' - \\'a\\'; i >= 0;)\\n    {\\n        if (!counts[i])\\n        {\\n            i--;\\n            continue;\\n        }"]]}
{"id": "1524", "ref_c": [["int minSteps(char * s, char * t){\\n    int n=strlen(s);\\n    int m=strlen(t);\\n    int freq1[26]={0}"], ["int minSteps(char * s, char * t){\\n    int hmap[26] = {}"], ["int minSteps(char * s, char * t){\\n    int n=strlen(s);\\n    int m=strlen(t);\\n    int freq1[26]={0}"]]}
{"id": "1525", "ref_c": [["long long minimumTime(int* time, int timeSize, int totalTrips){\\n    long long left =0; \\n    long long right = 1e14;\\n    long long mid;\\n    //binary search\\n    while(left < right){\\n        mid = (left+right)/2;\\n        if(averaging(time,timeSize,mid) >= totalTrips){\\n            right = mid;\\n        }"], ["long long minimumTime(int* time, int timeSize, int totalTrips){\\n    long long left =0; \\n    long long right = 1e14;\\n    long long mid;\\n    //binary search\\n    while(left < right){\\n        mid = (left+right)/2;\\n        if(averaging(time,timeSize,mid) >= totalTrips){\\n            right = mid;\\n        }"], ["long long minimumTime(int* time, int timeSize, int totalTrips){\\n\\n    long long left = 1, right = 1e14;\\n    long long mid;\\n    int ans = 0;\\n    while(left < right){\\n        mid = (left + right) / 2;\\n        if(divide(time, timeSize, mid) >= totalTrips){\\n            right = mid;\\n        }"]]}
{"id": "1526", "ref_c": [["int* sortJumbled(int* mapping, int mappingSize, int* nums, int numsSize, int* returnSize){\\n    struct map t[numsSize];\\n    *returnSize=numsSize;\\n    for(int i=0;i<numsSize;i++){\\n        t[i].val=nums[i];\\n        t[i].index=i;\\n        t[i].after=0;\\n        int temp=1;\\n        if(nums[i]==0) t[i].after=t[i].after+temp*mapping[nums[i]%10]; \\n        while(nums[i]!=0){\\n            t[i].after=t[i].after+temp*mapping[nums[i]%10];\\n            nums[i]/=10;\\n            temp*=10;\\n        }"], ["int* sortJumbled(int* mapping, int mappingSize, int* nums, int numsSize, int* returnSize){\\n    struct map t[numsSize];\\n    *returnSize=numsSize;\\n    for(int i=0;i<numsSize;i++){\\n        t[i].val=nums[i];\\n        t[i].index=i;\\n        t[i].after=0;\\n        int temp=1;\\n        if(nums[i]==0) t[i].after=t[i].after+temp*mapping[nums[i]%10]; \\n        while(nums[i]!=0){\\n            t[i].after=t[i].after+temp*mapping[nums[i]%10];\\n            nums[i]/=10;\\n            temp*=10;\\n        }"], ["int* sortJumbled(int* mapping, int mappingSize, int* nums, int numsSize, int* returnSize){\\n    struct map t[numsSize];\\n    *returnSize=numsSize;\\n    for(int i=0;i<numsSize;i++){\\n        t[i].val=nums[i];\\n        t[i].index=i;\\n        t[i].after=0;\\n        int temp=1;\\n        if(nums[i]==0) t[i].after=t[i].after+temp*mapping[nums[i]%10]; \\n        while(nums[i]!=0){\\n            t[i].after=t[i].after+temp*mapping[nums[i]%10];\\n            nums[i]/=10;\\n            temp*=10;\\n        }"]]}
{"id": "1527", "ref_c": [["int pathSum(struct TreeNode* root, int targetSum){\\n\\n    if(root == NULL){\\n        return 0;\\n    }", "int pathSum(struct TreeNode* root, int targetSum) {\\n\\n    return findAllPossiblePath(root, (LLI)targetSum);\\n    \\n}"], ["int pathSum(struct TreeNode* root, int targetSum){\\n\\n    if(root == NULL){\\n        return 0;\\n    }", "int pathSum(struct TreeNode* root, int targetSum) {\\n\\n    return findAllPossiblePath(root, (LLI)targetSum);\\n    \\n}"], ["int pathSum(struct TreeNode* root, int targetSum){\\n\\n    if(root == NULL){\\n        return 0;\\n    }", "int pathSum(struct TreeNode* root, int targetSum) {\\n\\n    return findAllPossiblePath(root, (LLI)targetSum);\\n    \\n}"]]}
{"id": "1528", "ref_c": [["long long minimalKSum(int* nums, int numsSize, int k){\\n    long long ret = 0;\\n    qsort(nums, numsSize, sizeof(int), cmpfunc);\\n    numsSize = removeDuplicates(nums, numsSize);\\n    \\n    // for each number <= k, increment k\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] <= k) {\\n            k++;\\n        }"], ["long long minimalKSum(int* nums, int numsSize, int k){\\n    long long ret = 0;\\n    qsort(nums, numsSize, sizeof(int), cmpfunc);\\n    numsSize = removeDuplicates(nums, numsSize);\\n    \\n    // for each number <= k, increment k\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] <= k) {\\n            k++;\\n        }"], ["long long minimalKSum(int* nums, int numsSize, int k){\\n    long long ret = 0;\\n    qsort(nums, numsSize, sizeof(int), cmpfunc);\\n    numsSize = removeDuplicates(nums, numsSize);\\n    \\n    // for each number <= k, increment k\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] <= k) {\\n            k++;\\n        }"]]}
{"id": "1529", "ref_c": [["struct TreeNode* createBinaryTree(int** descriptions, int descriptionsSize, int* descriptionsColSize) {\\n    struct TreeNode* pRetVal = NULL;\\n\\n    HashMapTree* pTreeHashTable = NULL;\\n    HashMapTree *pParent, *pChild;\\n    HashMapChild* pChildHashTable = NULL;\\n    HashMapChild* pChildDegree;\\n    int parent, child, isLeft;\\n    int i;\\n    for (i = 0; i < descriptionsSize; ++i) {\\n        parent = descriptions[i][0];\\n        child = descriptions[i][1];\\n        isLeft = descriptions[i][2];\\n\\n        // parent node\\n        pParent = NULL;\\n        HASH_FIND_INT(pTreeHashTable, &parent, pParent);\\n        if (pParent == NULL) {\\n            pParent = (HashMapTree*)malloc(sizeof(HashMapTree));\\n            if (pParent == NULL) {\\n                perror(\"malloc\");\\n                return pRetVal;\\n            }"], ["struct TreeNode* createBinaryTree(int** descriptions, int descriptionsSize, int* descriptionsColSize) {\\n    struct TreeNode* pRetVal = NULL;\\n\\n    HashMapTree* pTreeHashTable = NULL;\\n    HashMapTree *pParent, *pChild;\\n    HashMapChild* pChildHashTable = NULL;\\n    HashMapChild* pChildDegree;\\n    int parent, child, isLeft;\\n    int i;\\n    for (i = 0; i < descriptionsSize; ++i) {\\n        parent = descriptions[i][0];\\n        child = descriptions[i][1];\\n        isLeft = descriptions[i][2];\\n\\n        // parent node\\n        pParent = NULL;\\n        HASH_FIND_INT(pTreeHashTable, &parent, pParent);\\n        if (pParent == NULL) {\\n            pParent = (HashMapTree*)malloc(sizeof(HashMapTree));\\n            if (pParent == NULL) {\\n                perror(\"malloc\");\\n                return pRetVal;\\n            }"], ["struct TreeNode* createBinaryTree(int** descriptions, int descriptionsSize, int* descriptionsColSize) {\\n    struct TreeNode* pRetVal = NULL;\\n\\n    HashMapTree* pTreeHashTable = NULL;\\n    HashMapTree *pParent, *pChild;\\n    HashMapChild* pChildHashTable = NULL;\\n    HashMapChild* pChildDegree;\\n    int parent, child, isLeft;\\n    int i;\\n    for (i = 0; i < descriptionsSize; ++i) {\\n        parent = descriptions[i][0];\\n        child = descriptions[i][1];\\n        isLeft = descriptions[i][2];\\n\\n        // parent node\\n        pParent = NULL;\\n        HASH_FIND_INT(pTreeHashTable, &parent, pParent);\\n        if (pParent == NULL) {\\n            pParent = (HashMapTree*)malloc(sizeof(HashMapTree));\\n            if (pParent == NULL) {\\n                perror(\"malloc\");\\n                return pRetVal;\\n            }"]]}
{"id": "1530", "ref_c": [["int digArtifacts(int n, int** artifacts, int artifactsSize, int* artifactsColSize, int** dig, int digSize, int* digColSize){\\n\\n  int zone[n][n], area[n * n + 1], label = 1;\\n  memset(zone, 0, n * n * sizeof(zone[0][0]));\\n  memset(area, 0, (n * n + 1) * sizeof(area[0]));\\n  \\n  for (int i = 0; i < artifactsSize; ++i) {\\n    area[label] = (artifacts[i][2] - artifacts[i][0] + 1) * (artifacts[i][3] - artifacts[i][1] + 1);\\n    \\n    int x = artifacts[i][0], y = artifacts[i][1];\\n    while (x <= artifacts[i][2] && y <= artifacts[i][3]) {\\n      zone[x][y] = label;\\n\\n      if (x + 1 > artifacts[i][2]) {\\n        x = artifacts[i][0];\\n        ++y;\\n      }"], ["int digArtifacts(int n, int** artifacts, int artifactsSize, int* artifactsColSize, int** dig, int digSize, int* digColSize){\\n\\n  int zone[n][n], area[n * n + 1], label = 1;\\n  memset(zone, 0, n * n * sizeof(zone[0][0]));\\n  memset(area, 0, (n * n + 1) * sizeof(area[0]));\\n  \\n  for (int i = 0; i < artifactsSize; ++i) {\\n    area[label] = (artifacts[i][2] - artifacts[i][0] + 1) * (artifacts[i][3] - artifacts[i][1] + 1);\\n    \\n    int x = artifacts[i][0], y = artifacts[i][1];\\n    while (x <= artifacts[i][2] && y <= artifacts[i][3]) {\\n      zone[x][y] = label;\\n\\n      if (x + 1 > artifacts[i][2]) {\\n        x = artifacts[i][0];\\n        ++y;\\n      }"], ["int digArtifacts(int n, int** artifacts, int artifactsSize, int* artifactsColSize, int** dig, int digSize, int* digColSize){\\n\\n  int zone[n][n], area[n * n + 1], label = 1;\\n  memset(zone, 0, n * n * sizeof(zone[0][0]));\\n  memset(area, 0, (n * n + 1) * sizeof(area[0]));\\n  \\n  for (int i = 0; i < artifactsSize; ++i) {\\n    area[label] = (artifacts[i][2] - artifacts[i][0] + 1) * (artifacts[i][3] - artifacts[i][1] + 1);\\n    \\n    int x = artifacts[i][0], y = artifacts[i][1];\\n    while (x <= artifacts[i][2] && y <= artifacts[i][3]) {\\n      zone[x][y] = label;\\n\\n      if (x + 1 > artifacts[i][2]) {\\n        x = artifacts[i][0];\\n        ++y;\\n      }"]]}
{"id": "1531", "ref_c": [["int maximumTop(int* nums, int numsSize, int k){\\n\\n    if((numsSize==1)&&(k%2))\\n    {\\n        return -1;\\n    }"], ["int maximumTop(int* nums, int numsSize, int k){\\n\\n    if((numsSize==1)&&(k%2))\\n    {\\n        return -1;\\n    }"], ["int maximumTop(int* nums, int numsSize, int k){\\n\\n    if((numsSize==1)&&(k%2))\\n    {\\n        return -1;\\n    }"]]}
{"id": "1532", "ref_c": [["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"]]}
{"id": "1533", "ref_c": [["int halveArray(int* nums, int numsSize){\\n    int i, operations = 0;\\n    double totalSum = 0, halfSum = 0;\\n    double *array = malloc(sizeof(double) * numsSize);\\n\\n    for (i = 0; i < numsSize; i++)\\n        array[i] = nums[i];\\n\\n    buildHeap(array, numsSize);\\n\\n    for (i = 0; i < numsSize; i++)\\n        totalSum += array[i];\\n\\n    totalSum /= 2;\\n\\n    while (halfSum < totalSum) {\\n        double x = array[0] / 2;\\n        array[0] = x;\\n        heapify(array, numsSize, 0);\\n        halfSum += x;\\n        operations++;\\n    }"], ["int halveArray(int* nums, int numsSize)\\n{\\n    double a[numsSize], sum = 0, curSum = 0;\\n    int i = 0, count = 0;\\n    while(i < numsSize)\\n    {\\n        a[i] = nums[i];\\n        sum += nums[i];\\n        i++;\\n    }"], ["int halveArray(int* nums, int numsSize)\\n{\\n    double a[numsSize], sum = 0, curSum = 0;\\n    int i = 0, count = 0;\\n    while(i < numsSize)\\n    {\\n        a[i] = nums[i];\\n        sum += nums[i];\\n        i++;\\n    }"]]}
{"id": "1534", "ref_c": [["int* findMode(struct TreeNode* root, int* returnSize){\\n    \\n    int *arr = calloc(10000, sizeof(int)), size = 0;\\n    inorder(root, arr, &size);\\n    \\n    int *ret = malloc(sizeof(int) * size);\\n    int max = 0, idx = 0, len = 0, cur = arr[0];\\n    \\n    for (int i = 0; i < size; i++){\\n        if (arr[i] == cur)\\n            len++;\\n        else{\\n            if (len > max){\\n                idx = 0;\\n                ret[idx++] = cur;\\n                max = len;\\n            }"], ["int* findMode(struct TreeNode* root, int* returnSize) {\\n    int* b = (int*)malloc(100000 * sizeof(int));\\n    int count = 0;  \\n\\n\\n    inorder(root, b, &count);\\n\\n    int maxFrequency = 0;\\n    for (int i = 1; i < count; i += 2) {\\n        if (b[i] > maxFrequency) {\\n            maxFrequency = b[i];\\n        }"], ["int* findMode(struct TreeNode* root, int* returnSize) {\\n    int* b = (int*)malloc(100000 * sizeof(int));\\n    int count = 0;  \\n\\n\\n    inorder(root, b, &count);\\n\\n    int maxFrequency = 0;\\n    for (int i = 1; i < count; i += 2) {\\n        if (b[i] > maxFrequency) {\\n            maxFrequency = b[i];\\n        }"]]}
{"id": "1535", "ref_c": [["int* maximumBobPoints(int numArrows, int* aliceArrows, int aliceArrowsSize, int* returnSize){\\n    int *ret = (int *) calloc(12, sizeof (int));\\n    *returnSize = 12;\\n    int maxPts = 0;\\n    \\n    for (int i = 0; i < (1<<12); i++) {\\n        int arrow = 0;\\n        int point = 0;\\n        for (int bit = 0; bit < 12; bit++) {\\n            if (i & (1<<bit)) {\\n                arrow += aliceArrows[bit]+1;\\n                point += bit;\\n            }"], ["int* maximumBobPoints(int numArrows, int* aliceArrows, int aliceArrowsSize, int* returnSize){\\n    int *ret = (int *) calloc(12, sizeof (int));\\n    *returnSize = 12;\\n    int maxPts = 0;\\n    \\n    for (int i = 0; i < (1<<12); i++) {\\n        int arrow = 0;\\n        int point = 0;\\n        for (int bit = 0; bit < 12; bit++) {\\n            if (i & (1<<bit)) {\\n                arrow += aliceArrows[bit]+1;\\n                point += bit;\\n            }"], ["int* maximumBobPoints(int numArrows, int* aliceArrows, int aliceArrowsSize, int* returnSize){\\n    int *ret = (int *) calloc(12, sizeof (int));\\n    *returnSize = 12;\\n    int maxPts = 0;\\n    \\n    for (int i = 0; i < (1<<12); i++) {\\n        int arrow = 0;\\n        int point = 0;\\n        for (int bit = 0; bit < 12; bit++) {\\n            if (i & (1<<bit)) {\\n                arrow += aliceArrows[bit]+1;\\n                point += bit;\\n            }"]]}
{"id": "1536", "ref_c": [["int minDeletion(int* nums, int numsSize) {\\n    // Greedy\\n\\n    // Time complexity: O(n)\\n    // Space cmoplexity: O(1)\\n\\n    int result = 0;\\n    for (int i = 0; i + 1 < numsSize; i++) {\\n        // i - result := index after deletion\\n        if (nums[i] != nums[i + 1] || (i - result) & 1) continue;\\n        result++;\\n    }"], ["int minDeletion(int* nums, int numsSize) {\\n    // Greedy\\n\\n    // Time complexity: O(n)\\n    // Space cmoplexity: O(1)\\n\\n    int result = 0;\\n    for (int i = 0; i + 1 < numsSize; i++) {\\n        // i - result := index after deletion\\n        if (nums[i] != nums[i + 1] || (i - result) & 1) continue;\\n        result++;\\n    }"], ["int minDeletion(int* nums, int numsSize){\\n    int output=0;\\n    for(int even=0,odd=1;odd<numsSize;odd++){\\n        if (nums[even]==nums[odd]){\\n            output++;\\n        }"]]}
{"id": "1537", "ref_c": [["int countLargestGroup(int n) {\\n        map<int,int>p;\\n        for(int i=1;i<=n;i++){\\n            int k=get_digit_sum(i);\\n            p[k]++;\\n        }"], ["int countLargestGroup(int n){\\n    int sizeGroups[37] = {0}", "int countLargestGroup(int n){\\n    int sizeGroups[37] = {0}"], ["int countLargestGroup(int n) {\\n    if (n < 10) return n;\\n    int max = 0, cnt = 0;\\n    int* arr = (int*) calloc(37, sizeof(int));\\n    for (int i = 1; i <= n; i++) {\\n        int idx = check(i, &max);\\n        arr[idx]++;\\n        cnt = MAX(cnt, arr[idx]);\\n    }"]]}
{"id": "1538", "ref_c": [["int triangularSum(int* nums, int numsSize){\\n    for (; numsSize != 1; numsSize--)\\n        for (int i = 0; i < numsSize - 1; i++) nums[i] = (nums[i] + nums[i + 1]) % 10;\\n    return nums[0];\\n}"], ["int triangularSum(int* nums, int numsSize){\\n    for (; numsSize != 1; numsSize--)\\n        for (int i = 0; i < numsSize - 1; i++) nums[i] = (nums[i] + nums[i + 1]) % 10;\\n    return nums[0];\\n}"], ["int triangularSum(int* nums, int numsSize){\\n    for (; numsSize != 1; numsSize--)\\n        for (int i = 0; i < numsSize - 1; i++) nums[i] = (nums[i] + nums[i + 1]) % 10;\\n    return nums[0];\\n}"]]}
{"id": "1539", "ref_c": [["long long numberOfWays(char * s){\\n    int box[2] = {0}"], ["long long numberOfWays(char * s){\\n    int box[2] = {0}"], ["long long numberOfWays(char * s){\\n    int box[2] = {0}"]]}
{"id": "1540", "ref_c": [["int** findWinners(int** matches, int matchesSize, int* matchesColSize, int* returnSize, int** returnColumnSizes){\\n    int max = 0;\\n    int i = 0;\\n    int **ans = (int **) malloc(sizeof(int*) * 2);\\n    *returnSize = 2;\\n    \\n    for (i = 0; i < matchesSize; i++) {\\n        max = matches[i][0] > max ? matches[i][0] : max;\\n        max = matches[i][1] > max ? matches[i][1] : max;\\n    }"], ["int** findWinners(int** matches, int matchesSize, int* matchesColSize, int* returnSize, int** returnColumnSizes){\\n    int player_count = 0;\\n    // determine how many players there are\\n    for(int i=0; i<matchesSize; ++i) {\\n        if(matches[i][0] > player_count) player_count = matches[i][0];\\n        if(matches[i][1] > player_count) player_count = matches[i][1];\\n    }"], ["int** findWinners(int** matches, int matchesSize, int* matchesColSize, int* returnSize, int** returnColumnSizes) {\\n    int** pRetVal = NULL;\\n\\n    (*returnSize) = 2;\\n    int i, j;\\n\\n    // malloc return value\\n    (*returnColumnSizes) = (int*)malloc((*returnSize)*sizeof(int));\\n    if ((*returnColumnSizes) == NULL) {\\n        perror(\"malloc\");\\n        (*returnSize) = 0;\\n        return pRetVal;\\n    }"]]}
{"id": "1541", "ref_c": [["int rob(struct TreeNode* root){\\n\\n    /*\\n     * Input:\\n     *  root, root of binary tree (only one entrance to this area)\\n     */\\n\\n    int ans;\\n    node_t *dp = NULL;\\n\\n    /* \\n     * Start from root, use binary tree node ID as house ID.\\n     * House ID can be very large, so we cannot directly use \\n     * a 2D array as a DP table.\\n     */\\n    ans = robHouse(root, 0, &dp);\\n\\n    /* Release DP memory */\\n    for (node_t *del; dp; ) {\\n        del = dp;\\n        dp = dp->next;\\n        free(del);\\n    }"], ["int rob(struct TreeNode* root){\\n\\n    /*\\n     * Input:\\n     *  root, root of binary tree (only one entrance to this area)\\n     */\\n\\n    int ans;\\n    node_t *dp = NULL;\\n\\n    /* \\n     * Start from root, use binary tree node ID as house ID.\\n     * House ID can be very large, so we cannot directly use \\n     * a 2D array as a DP table.\\n     */\\n    ans = robHouse(root, 0, &dp);\\n\\n    /* Release DP memory */\\n    for (node_t *del; dp; ) {\\n        del = dp;\\n        dp = dp->next;\\n        free(del);\\n    }"], ["int rob(struct TreeNode* root){\\n\\n    /*\\n     * Input:\\n     *  root, root of binary tree (only one entrance to this area)\\n     */\\n\\n    int ans;\\n    node_t *dp = NULL;\\n\\n    /* \\n     * Start from root, use binary tree node ID as house ID.\\n     * House ID can be very large, so we cannot directly use \\n     * a 2D array as a DP table.\\n     */\\n    ans = robHouse(root, 0, &dp);\\n\\n    /* Release DP memory */\\n    for (node_t *del; dp; ) {\\n        del = dp;\\n        dp = dp->next;\\n        free(del);\\n    }"]]}
{"id": "1542", "ref_c": [["char * minimizeResult(char * expression){  // one * (two + three) * four\\n    int len = strlen(expression);\\n    int two[9];\\n    int three[11];\\n    int one[9];\\n    int four[11];\\n    int add = 0;\\n    while (expression[add] != \\'+\\'){\\n        add++;\\n    }"], ["char * minimizeResult(char * expression){  // one * (two + three) * four\\n    int len = strlen(expression);\\n    int two[9];\\n    int three[11];\\n    int one[9];\\n    int four[11];\\n    int add = 0;\\n    while (expression[add] != \\'+\\'){\\n        add++;\\n    }"], ["char * minimizeResult(char * expression){  // one * (two + three) * four\\n    int len = strlen(expression);\\n    int two[9];\\n    int three[11];\\n    int one[9];\\n    int four[11];\\n    int add = 0;\\n    while (expression[add] != \\'+\\'){\\n        add++;\\n    }"]]}
{"id": "1543", "ref_c": [["int* findLonely(int* nums, int numsSize, int* returnSize){\\n    int* arr=(int*)malloc(sizeof(int)*numsSize);\\n    qsort(nums,numsSize,sizeof(int),compare);\\n    int count=0;\\nfor(int i=0; i<numsSize; i++) {\\n    if((i == 0 || nums[i] != nums[i - 1]) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1]) &&\\n            (i == 0 || nums[i] != nums[i - 1] + 1) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1] - 1)) { \\n        arr[count++]=nums[i];\\n    }"], ["int* findLonely(int* nums, int numsSize, int* returnSize){\\n    int* arr=(int*)malloc(sizeof(int)*numsSize);\\n    qsort(nums,numsSize,sizeof(int),compare);\\n    int count=0;\\nfor(int i=0; i<numsSize; i++) {\\n    if((i == 0 || nums[i] != nums[i - 1]) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1]) &&\\n            (i == 0 || nums[i] != nums[i - 1] + 1) &&\\n            (i == numsSize - 1 || nums[i] != nums[i + 1] - 1)) { \\n        arr[count++]=nums[i];\\n    }"], ["int* findLonely(int* nums, int numsSize, int* returnSize) {\\n    int arr[1000002] = {0}"]]}
{"id": "1544", "ref_c": [["long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n        long long res=0;\\n        while(total >= 0){\\n            res += ((total/cost2)+1);\\n            total-=cost1;\\n        }", "long long waysToBuyPensPencils(int total, int cost1, int cost2) {\\n    long long res=0;\\n    while(total >= 0){\\n        res += ((total/cost2)+1);\\n        total -= cost1;\\n    }"], ["long long waysToBuyPensPencils(int total, int cost1, int cost2){\\n    long long ans = 0;\\n    for (int i = total ; i >= 0 ; i -= cost1){\\n        ans++;\\n        ans += i / cost2;\\n    }"], ["long long waysToBuyPensPencils(int total, int cost1, int cost2)\\n{\\n    int c = 0;\\n    long long sum = 0;\\n    while (total - cost1 * c >= 0) {\\n        sum += (total - cost1 * c) / cost2 + 1;\\n        c++;\\n    }"]]}
{"id": "1546", "ref_c": [["int minimumRounds(int* tasks, int tasksSize){\\n    qsort(tasks, tasksSize, sizeof(int), comp);\\n    int curr= tasks[0];\\n    int k = 0;\\n    int ret = 0;\\n    for(int i=0;i<tasksSize;i++){\\n        if(curr==tasks[i]){\\n            k++;\\n        }"], ["int minimumRounds(int* tasks, int tasksSize){\\n    qsort(tasks, tasksSize, sizeof(int), comp);\\n    int curr= tasks[0];\\n    int k = 0;\\n    int ret = 0;\\n    for(int i=0;i<tasksSize;i++){\\n        if(curr==tasks[i]){\\n            k++;\\n        }"], ["int minimumRounds(int* tasks, int tasksSize){\\n    /*\\n     * Input:\\n     *  tasks, integer array contains difficulty levels of tasks\\n     *  tasksSize, number of tasks.\\n     */\\n     \\n    NODE *hash[HASH_MOD];\\n    NODE *tmp;\\n    int freq, round = 0;\\n    \\n    hash_init(hash);\\n\\n    for (int i = 0; i < tasksSize; i++) {\\n        \\n        if (hash_get(hash, tasks[i], &freq) == 0) {\\n            hash_set(hash, tasks[i], freq + 1);\\n        }"]]}
{"id": "1547", "ref_c": [["int minimumCost(int* cost, int costSize)\\n{\\n  int final_price = 0;\\n\\n  // Trivial case\\n  if (costSize == 1 || costSize == 2)\\n  {\\n    for (int i = 0; i < costSize; i++) final_price += cost[i];\\n    return final_price;\\n  }"], ["int minimumCost(int* cost, int costSize)\\n{\\n  int final_price = 0;\\n\\n  // Trivial case\\n  if (costSize == 1 || costSize == 2)\\n  {\\n    for (int i = 0; i < costSize; i++) final_price += cost[i];\\n    return final_price;\\n  }"], ["int minimumCost(int* cost, int costSize)\\n{\\n  int final_price = 0;\\n\\n  // Trivial case\\n  if (costSize == 1 || costSize == 2)\\n  {\\n    for (int i = 0; i < costSize; i++) final_price += cost[i];\\n    return final_price;\\n  }"]]}
{"id": "1548", "ref_c": [["int minOperations(int n){\\nint  ans=0;\\nfor(int i=0;i<n/2;i++){\\n    ans+=n-(i*2+1);\\n}"], ["int minOperations(int n) {\\n    return n*(n/2)-(n/2)*(n/2) ;\\n}"], ["int minOperations(int n) \\n    {\\n      if(n % 2 != 0)\\n      {\\n        n = n / 2;\\n        return n * (n + 1);\\n      }"]]}
{"id": "1549", "ref_c": [["int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int ans = 0;\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 0) {\\n                continue; // If the element is 0, continue to the next iteration\\n            }", "int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    // Array to store counts of \\'1\\'s in each row and column\\n    int* rowCount = (int*)calloc(m, sizeof(int)); // Initialize row count array with 0s\\n    int* colCount = (int*)calloc(n, sizeof(int)); // Initialize column count array with 0s\\n\\n    // Counting \\'1\\'s in each row and column\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 1) {\\n                rowCount[row]++; // Increment row count when \\'1\\' is encountered in the row\\n                colCount[col]++; // Increment column count when \\'1\\' is encountered in the column\\n            }"], ["int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int ans = 0;\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 0) {\\n                continue; // If the element is 0, continue to the next iteration\\n            }", "int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int m = matSize; // Number of rows in the matrix\\n    int n = *matColSize; // Number of columns in the matrix\\n\\n    // Array to store counts of \\'1\\'s in each row and column\\n    int* rowCount = (int*)calloc(m, sizeof(int)); // Initialize row count array with 0s\\n    int* colCount = (int*)calloc(n, sizeof(int)); // Initialize column count array with 0s\\n\\n    // Counting \\'1\\'s in each row and column\\n    for (int row = 0; row < m; row++) {\\n        for (int col = 0; col < n; col++) {\\n            if (mat[row][col] == 1) {\\n                rowCount[row]++; // Increment row count when \\'1\\' is encountered in the row\\n                colCount[col]++; // Increment column count when \\'1\\' is encountered in the column\\n            }"], ["int numSpecial(int** mat, int matSize, int* matColSize) {\\n    int result = 0;\\n\\n    // Arrays to store the sums of elements in each row and column\\n    int* rowSums = (int*)malloc(matSize * sizeof(int));\\n    int* colSums = (int*)malloc(matColSize[0] * sizeof(int));\\n\\n    // Initialize rowSums and colSums to zeros\\n    for (int i = 0; i < matSize; i++) {\\n        rowSums[i] = 0;\\n    }"]]}
{"id": "1550", "ref_c": [["int minimumAverageDifference(int* nums, int numsSize){\\n    long long* average_hold = (long long*)calloc(numsSize,sizeof(long long));\\n    int lowest_return = INT_MAX;\\n    int return_ptr = 0;\\n    //calculate sum of array to meet timeing requirement of the question\\n    average_hold[0] = nums[0];\\n    for(int ptr = 1; ptr < numsSize; ptr++){\\n        average_hold[ptr] = average_hold[ptr - 1] + nums[ptr];\\n    }"], ["int minimumAverageDifference(int* nums, int numsSize){\\n    long long* average_hold = (long long*)calloc(numsSize,sizeof(long long));\\n    int lowest_return = INT_MAX;\\n    int return_ptr = 0;\\n    //calculate sum of array to meet timeing requirement of the question\\n    average_hold[0] = nums[0];\\n    for(int ptr = 1; ptr < numsSize; ptr++){\\n        average_hold[ptr] = average_hold[ptr - 1] + nums[ptr];\\n    }"], ["int minimumAverageDifference(int* nums, int numsSize){\\n  long front = 0, end = 0;\\n  int min_avg = INT_MAX, ans = 0;\\n\\n  for (int i = 0; i < numsSize; i++)\\n    end += nums[i];\\n\\n  for (int i = 0; i < numsSize; i++) {\\n    front += nums[i];\\n    end -= nums[i];\\n\\n    int first = front / (i + 1);\\n    int second = i == numsSize - 1 ? 0 : end / (numsSize - 1 - i);\\n    \\n    int temp = abs(first - second);\\n    if (temp < min_avg) {\\n      min_avg = temp;\\n      ans = i;\\n    }"]]}
{"id": "1551", "ref_c": [["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if((n - 1) % 3 == 0){\\n\\n\\n        return true; \\n        }", "bool isPowerOfFour(int n) {\\n    if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if ((n - 1) % 3 == 0) {\\n            return true;\\n        }", "bool isPowerOfFour(int n) {\\n       return n>0 && (n&(n-1))==0 && (n % 10 ==1|| n% 10==4|| n%10==6);\\n    }", "bool isPowerOfFour(int n) {\\n    return n > 0 && (n & (n - 1)) == 0 && (n % 10 == 1 || n % 10 == 4 || n % 10 == 6);\\n}"], ["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the logarithm of \\'n\\' with base 4\\n        double logarithmBase4 = log(n) / log(4);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (logarithmBase4 == (int)logarithmBase4);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the logarithm of \\'n\\' with base 4\\n    double logarithmBase4 = log(n) / log(4);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (logarithmBase4 == (int)logarithmBase4);\\n}", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the square root of \\'n\\'\\n        double sqrtN = sqrt(n);\\n\\n        // Take the logarithm base 2 of the square root\\n        double log2SqrtN = log2(sqrtN);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (log2SqrtN == (int)log2SqrtN);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the square root of \\'n\\'\\n    double sqrtN = sqrt(n);\\n\\n    // Take the logarithm base 2 of the square root\\n    double log2SqrtN = log2(sqrtN);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (log2SqrtN == (int)log2SqrtN);\\n}"], ["bool isPowerOfFour(int n){\\n\\n    if(n==1)\\n        return true;\\n    return (n&0x55555554) && !(n&n-1);\\n}"]]}
{"id": "1552", "ref_c": [["int minimumCardPickup(int* cards, int cardsSize){\\n    int *map = calloc((1e6+1), sizeof(int)); // initialized 0 (no occurrence)\\n    int ans = cardsSize;\\n    for(int i = 0; i < cardsSize; i++){\\n        if (map[cards[i]] != 0){\\n            int temp = i+1 - map[cards[i]] + 1;\\n            ans = (temp < ans? temp: ans);\\n        }"], ["int minimumCardPickup(int* cards, int cardsSize){\\n    int *map = calloc((1e6+1), sizeof(int)); // initialized 0 (no occurrence)\\n    int ans = cardsSize;\\n    for(int i = 0; i < cardsSize; i++){\\n        if (map[cards[i]] != 0){\\n            int temp = i+1 - map[cards[i]] + 1;\\n            ans = (temp < ans? temp: ans);\\n        }"], ["int minimumCardPickup(int* cards, int cardsSize){\\n    int *map = calloc((1e6+1), sizeof(int)); // initialized 0 (no occurrence)\\n    int ans = cardsSize;\\n    for(int i = 0; i < cardsSize; i++){\\n        if (map[cards[i]] != 0){\\n            int temp = i+1 - map[cards[i]] + 1;\\n            ans = (temp < ans? temp: ans);\\n        }"]]}
{"id": "1553", "ref_c": [["int longestCommonSubsequence(char * text1, char * text2){\\n  int m;\\n  int n;\\n  m=strlen(text1);\\n  n=strlen(text2);\\n  int a[m+1][n+1];\\n  int i,j;\\n  for(i=0;i<m+1;i++){\\n      a[i][0]=0;\\n  }"], ["int longestCommonSubsequence(char * text1, char * text2){\\n  int m;\\n  int n;\\n  m=strlen(text1);\\n  n=strlen(text2);\\n  int a[m+1][n+1];\\n  int i,j;\\n  for(i=0;i<m+1;i++){\\n      a[i][0]=0;\\n  }"], ["int longestCommonSubsequence(char * text1, char * text2){\\n  int m;\\n  int n;\\n  m=strlen(text1);\\n  n=strlen(text2);\\n  int a[m+1][n+1];\\n  int i,j;\\n  for(i=0;i<m+1;i++){\\n      a[i][0]=0;\\n  }"]]}
{"id": "1554", "ref_c": [["int averageOfSubtree(struct TreeNode* root){\\n    int cnter = 0;\\n    data rslt = postorder(root,&cnter);\\n    return cnter;\\n}"], ["int averageOfSubtree(struct TreeNode* root){\\n    int cnter = 0;\\n    data rslt = postorder(root,&cnter);\\n    return cnter;\\n}"], ["int averageOfSubtree(struct TreeNode* root){\\n    int cnter = 0;\\n    data rslt = postorder(root,&cnter);\\n    return cnter;\\n}"]]}
{"id": "1555", "ref_c": [["long long* sumOfThree(long long num, int* returnSize){\\n    if (num%3){\\n        *returnSize = 0;\\n        return malloc(0);\\n    }"], ["long long* sumOfThree(long long num, int* returnSize){\\n\\t\\tlong long *res;\\n\\t\\tif(num%3==0){\\n\\t\\t\\t*returnSize=3;\\n\\t\\t\\tres=malloc(sizeof(long long)*3);\\n\\t\\t\\tres[0]=num/3-1;\\n\\t\\t\\tres[1]=num/3;\\n\\t\\t\\tres[2]=num/3+1;\\n\\n\\t\\t}"], ["long long* sumOfThree(long long num, int* returnSize){\\n    long long* ans=malloc(3*sizeof(long long));\\n    if(num%3!=0)\\n    {\\n        *(returnSize)=0;\\n        return ans;\\n    }"]]}
{"id": "1556", "ref_c": [["int waysToSplitArray(int* nums, int numsSize){\\n    long *prefix = calloc(numsSize, sizeof(long));\\n    int answer = 0;\\n    int index;\\n    long left, right;\\n\\n    // first prefix is the first element of the array\\n    prefix[0] = nums[0];\\n\\n    for (index = 1; index < numsSize; index++) {\\n        // next element is the sum between current element and its prefix\\n        prefix[index] = nums[index] + prefix[index - 1];\\n    }"], ["int waysToSplitArray(int* nums, int numsSize){\\n    long int prefix[100000];\\n    int i, ans=0;\\n    prefix[0] = nums[0];\\n    for(i=1; i<numsSize;i++) {\\n        prefix[i] = prefix[i-1] + nums[i];\\n    }"], ["int waysToSplitArray(int* nums, int numsSize){\\n    long int prefix[100000];\\n    int i, ans=0;\\n    prefix[0] = nums[0];\\n    for(i=1; i<numsSize;i++) {\\n        prefix[i] = prefix[i-1] + nums[i];\\n    }"]]}
{"id": "1557", "ref_c": [["char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes) {\\n    int i, j, lo, mid, hi, swSize, *colSizes;\\n    lo = 0;\\n    swSize = strlen(searchWord);\\n    char ***ans = (char ***) calloc(swSize, sizeof(char**));\\n    colSizes = (int*) calloc(swSize, sizeof(int));\\n    *returnSize = swSize;\\n    *returnColumnSizes = colSizes;\\n    qsort(products, productsSize, sizeof(char*), compare);\\n    for (i = 0; i < swSize; ++i) {\\n        hi = productsSize;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (strncmp(products[mid],searchWord, i+1) >= 0) {\\n                hi = mid;\\n            }"], ["char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes) {\\n    int i, j, lo, mid, hi, swSize, *colSizes;\\n    lo = 0;\\n    swSize = strlen(searchWord);\\n    char ***ans = (char ***) calloc(swSize, sizeof(char**));\\n    colSizes = (int*) calloc(swSize, sizeof(int));\\n    *returnSize = swSize;\\n    *returnColumnSizes = colSizes;\\n    qsort(products, productsSize, sizeof(char*), compare);\\n    for (i = 0; i < swSize; ++i) {\\n        hi = productsSize;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (strncmp(products[mid],searchWord, i+1) >= 0) {\\n                hi = mid;\\n            }"], ["char *** suggestedProducts(char ** products, int productsSize, char * searchWord, int* returnSize, int** returnColumnSizes) {\\n    int i, j, lo, mid, hi, swSize, *colSizes;\\n    lo = 0;\\n    swSize = strlen(searchWord);\\n    char ***ans = (char ***) calloc(swSize, sizeof(char**));\\n    colSizes = (int*) calloc(swSize, sizeof(int));\\n    *returnSize = swSize;\\n    *returnColumnSizes = colSizes;\\n    qsort(products, productsSize, sizeof(char*), compare);\\n    for (i = 0; i < swSize; ++i) {\\n        hi = productsSize;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (strncmp(products[mid],searchWord, i+1) >= 0) {\\n                hi = mid;\\n            }"]]}
{"id": "1558", "ref_c": [["int maxConsecutive(int bottom, int top, int* special, int specialSize){\\n    qsort(special,specialSize,sizeof(int),cmp);\\n    int ans=fmax(fmax(special[0],bottom)-bottom,fmax(special[specialSize-1],top)-special[specialSize-1]);\\n    for(int i=1;i<specialSize;i++){\\n        ans=fmax(special[i]-special[i-1]-1,ans);\\n    }"], ["int maxConsecutive(int bottom, int top, int* special, int specialSize) {\\n    qsort(special, specialSize, sizeof(int), cmp);\\n    int len = fmax(special[0] - bottom, top - special[specialSize - 1]);\\n    for (int i = 1; i < specialSize; i++) {\\n        if (special[i] - special[i - 1] > 1) len = fmax(special[i] - special[i - 1] - 1, len);\\n    }"], ["int maxConsecutive(int bottom, int top, int* special, int specialSize) {\\n    qsort(special, specialSize, sizeof(int), cmp);\\n    int len = fmax(special[0] - bottom, top - special[specialSize - 1]);\\n    for (int i = 1; i < specialSize; i++) {\\n        if (special[i] - special[i - 1] > 1) len = fmax(special[i] - special[i - 1] - 1, len);\\n    }"]]}
{"id": "1559", "ref_c": [["int largestCombination(int* candidates, int candidatesSize){\\n    int cnt = 0, maxCnt  = 0;\\n    for(int i = 0; i < 32; i++)\\n    {\\n        cnt = 0;\\n        for(int j = 0; j < candidatesSize; j++)\\n        {\\n            if(candidates[j] & 1)\\n                cnt++;\\n            candidates[j] >>= 1;\\n        }"], ["int largestCombination(int* candidates, int candidatesSize){\\n    int cnt = 0, maxCnt  = 0;\\n    for(int i = 0; i < 32; i++)\\n    {\\n        cnt = 0;\\n        for(int j = 0; j < candidatesSize; j++)\\n        {\\n            if(candidates[j] & 1)\\n                cnt++;\\n            candidates[j] >>= 1;\\n        }"], ["int largestCombination(int* candidates, int candidatesSize){\\n    int cnt = 0, maxCnt  = 0;\\n    for(int i = 0; i < 32; i++)\\n    {\\n        cnt = 0;\\n        for(int j = 0; j < candidatesSize; j++)\\n        {\\n            if(candidates[j] & 1)\\n                cnt++;\\n            candidates[j] >>= 1;\\n        }"]]}
{"id": "1560", "ref_c": [["int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks){\\n    \\n    int cnt = 0;\\n    for(cnt = 0; cnt < capacitySize; ++cnt)\\n    {\\n        *(rocks+cnt) = *(capacity+cnt) - *(rocks+cnt);\\n    }"], ["int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks){\\n    \\n    int cnt = 0;\\n    for(cnt = 0; cnt < capacitySize; ++cnt)\\n    {\\n        *(rocks+cnt) = *(capacity+cnt) - *(rocks+cnt);\\n    }"], ["int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks){\\n    \\n    int cnt = 0;\\n    for(cnt = 0; cnt < capacitySize; ++cnt)\\n    {\\n        *(rocks+cnt) = *(capacity+cnt) - *(rocks+cnt);\\n    }"]]}
{"id": "1561", "ref_c": [["int* sortedSquares(int* nums, int numsSize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(nums[0]) * numsSize);\\n    int start = 0;\\n    int end = numsSize - 1;\\n    for (int i = numsSize - 1; start <= end; i--) {\\n        int a = nums[start] * nums[start];\\n        int b = nums[end] * nums[end];\\n        if (a > b) {\\n            res[i] = a;\\n            start++;\\n        }"], ["int* sortedSquares(int* nums, int numsSize, int* returnSize){\\n\\n    *returnSize = numsSize;\\n\\n    for (int i=0; i<numsSize; i++) {\\n        nums[i] = nums[i]*nums[i];\\n    }"], ["int* sortedSquares(int* nums, int numsSize, int* returnSize) {\\n    int *returnedArray = (int*)(malloc(numsSize * sizeof(int)));\\n    *returnSize = numsSize;\\n    int index = -1;\\n    int lowest = 999999;\\n    for (int i = 0; i <numsSize; i += 1) {\\n        if (nums[i] < 0) {\\n            nums[i] *= - 1;\\n        }"]]}
{"id": "1562", "ref_c": [["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"]]}
{"id": "1563", "ref_c": [["long long maximumImportance(int n, int** roads, int roadsSize, int* roadsColSize){\\n        long long ret=0;\\n        long long* TimesShown=calloc(n,sizeof(long long));\\n        for (int i=0;i<roadsSize;i++){\\n            for(int j=0;j<2;j++){\\n                TimesShown[roads[i][j]]++;\\n            }"], ["long long maximumImportance(int n, int** roads, int roadsSize, int* roadsColSize){\\n    // Array to keep track of each city data\\n    Help* help = calloc(n, sizeof(Help));\\n\\n    // Array to keep importance of city\\n    int* importance = calloc(n, sizeof(int));\\n    \\n    // Initialize help array\\n    for(int i = 0; i < n; i++){\\n        help[i].node = i;\\n        help[i].roads = 0;\\n    }"], ["long long maximumImportance(int n, int** roads, int roadsSize, int* roadsColSize){\\n    // Array to keep track of each city data\\n    Help* help = calloc(n, sizeof(Help));\\n\\n    // Array to keep importance of city\\n    int* importance = calloc(n, sizeof(int));\\n    \\n    // Initialize help array\\n    for(int i = 0; i < n; i++){\\n        help[i].node = i;\\n        help[i].roads = 0;\\n    }"]]}
{"id": "1564", "ref_c": [["char * discountPrices(char * sentence, int discount){\\n    int len = strlen(sentence);\\n    discount = 100-discount;\\n    char* ans = malloc(sizeof(char)*(len*2)+3);\\n    int count = 0;\\n    int i = 0;\\n    if (sentence[i] == \\'$\\'){\\n        ans[count] = sentence[i];\\n        count++;\\n        i++;\\n        if (sentence[i] >= \\'1\\' && sentence[i] <= \\'9\\'){\\n            int start = i;\\n            long long money = sentence[i] - \\'0\\';\\n            i++;            \\n            while(sentence[i] >= \\'0\\' && sentence[i] <= \\'9\\'){\\n                money *= 10;\\n                money += sentence[i] - \\'0\\';\\n                i++;\\n            }"], ["char * discountPrices(char * sentence, int discount){\\n    int len = strlen(sentence);\\n    discount = 100-discount;\\n    char* ans = malloc(sizeof(char)*(len*2)+3);\\n    int count = 0;\\n    int i = 0;\\n    if (sentence[i] == \\'$\\'){\\n        ans[count] = sentence[i];\\n        count++;\\n        i++;\\n        if (sentence[i] >= \\'1\\' && sentence[i] <= \\'9\\'){\\n            int start = i;\\n            long long money = sentence[i] - \\'0\\';\\n            i++;            \\n            while(sentence[i] >= \\'0\\' && sentence[i] <= \\'9\\'){\\n                money *= 10;\\n                money += sentence[i] - \\'0\\';\\n                i++;\\n            }"], ["char * discountPrices(char * sentence, int discount){\\n    int len = strlen(sentence);\\n    discount = 100-discount;\\n    char* ans = malloc(sizeof(char)*(len*2)+3);\\n    int count = 0;\\n    int i = 0;\\n    if (sentence[i] == \\'$\\'){\\n        ans[count] = sentence[i];\\n        count++;\\n        i++;\\n        if (sentence[i] >= \\'1\\' && sentence[i] <= \\'9\\'){\\n            int start = i;\\n            long long money = sentence[i] - \\'0\\';\\n            i++;            \\n            while(sentence[i] >= \\'0\\' && sentence[i] <= \\'9\\'){\\n                money *= 10;\\n                money += sentence[i] - \\'0\\';\\n                i++;\\n            }"]]}
{"id": "1565", "ref_c": [["int totalSteps(int* nums, int numsSize){\\n    int ans = 0;\\n    int time = 0;\\n    int k = nums[0];\\n    int i = 1;\\n    while( i < numsSize ){\\n        if (k > nums[i]){\\n            time++;\\n            next(nums, numsSize, nums[i], &i, time);\\n        }"], ["int totalSteps(int* nums, int numsSize){\\n    int ans = 0;\\n    int time = 0;\\n    int k = nums[0];\\n    int i = 1;\\n    while( i < numsSize ){\\n        if (k > nums[i]){\\n            time++;\\n            next(nums, numsSize, nums[i], &i, time);\\n        }"], ["int totalSteps(int* nums, int numsSize){\\n    int ans = 0;\\n    int time = 0;\\n    int k = nums[0];\\n    int i = 1;\\n    while( i < numsSize ){\\n        if (k > nums[i]){\\n            time++;\\n            next(nums, numsSize, nums[i], &i, time);\\n        }"]]}
{"id": "1566", "ref_c": [["int partitionArray(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int ret=1;\\n    int j=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]-nums[j]>k){\\n            ret++;\\n            j=i;\\n        }"], ["int partitionArray(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int ret=1;\\n    int j=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]-nums[j]>k){\\n            ret++;\\n            j=i;\\n        }"], ["int partitionArray(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int ret=1;\\n    int j=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]-nums[j]>k){\\n            ret++;\\n            j=i;\\n        }"]]}
{"id": "1567", "ref_c": [["int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int list[1000001];\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    for (int i = 0 ; i < numsSize ; i++){\\n        list[nums[i]] = i;\\n        ans[i] = nums[i];\\n    }"], ["int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int list[1000001];\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    for (int i = 0 ; i < numsSize ; i++){\\n        list[nums[i]] = i;\\n        ans[i] = nums[i];\\n    }"], ["int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int list[1000001];\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    for (int i = 0 ; i < numsSize ; i++){\\n        list[nums[i]] = i;\\n        ans[i] = nums[i];\\n    }"]]}
{"id": "1568", "ref_c": ["\nstatic int srt(void *a, void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, long long success, int* returnSize) {\n    *returnSize = spellsSize;\n    \n    int * ret = (int *) malloc(sizeof(int)* *returnSize);\n    qsort(potions, potionsSize, sizeof(int), srt);\n\n    for (int i = 0; i < spellsSize; i++) {\n        int left = 0; \n        int right = potionsSize;\n        \n        while (left < right ){\n            int mid = (left + right)/2;\n            long long prod = ((long long)spells[i] * (long long)potions[mid]);\n            if(prod < success) {\n                left = mid + 1;\n            }\n            else {\n                right = mid;\n            }\n        }\n\n        ret[i] = potionsSize - left;\n    }\n\n    return ret;\n}\n", "\nstatic int srt(void *a, void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, long long success, int* returnSize) {\n    *returnSize = spellsSize;\n    \n    int * ret = (int *) malloc(sizeof(int)* *returnSize);\n    qsort(potions, potionsSize, sizeof(int), srt);\n\n    for (int i = 0; i < spellsSize; i++) {\n        int left = 0; \n        int right = potionsSize;\n        \n        while (left < right ){\n            int mid = (left + right)/2;\n            long long prod = ((long long)spells[i] * (long long)potions[mid]);\n            if(prod < success) {\n                left = mid + 1;\n            }\n            else {\n                right = mid;\n            }\n        }\n\n        ret[i] = potionsSize - left;\n    }\n\n    return ret;\n}\n", "\nstatic int srt(void *a, void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, long long success, int* returnSize) {\n    *returnSize = spellsSize;\n    \n    int * ret = (int *) malloc(sizeof(int)* *returnSize);\n    qsort(potions, potionsSize, sizeof(int), srt);\n\n    for (int i = 0; i < spellsSize; i++) {\n        int left = 0; \n        int right = potionsSize;\n        \n        while (left < right ){\n            int mid = (left + right)/2;\n            long long prod = ((long long)spells[i] * (long long)potions[mid]);\n            if(prod < success) {\n                left = mid + 1;\n            }\n            else {\n                right = mid;\n            }\n        }\n\n        ret[i] = potionsSize - left;\n    }\n\n    return ret;\n}\n"]}
{"id": "1569", "ref_c": [["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n; // since n = number of elements to be returned\\n    char **answer; // the string of strings where the right elements will be copied\\n    char str[5]; // every string contains at most 5 character (max number is 10000 => 5 characters)\\n    \\n    i = 1; // first number we want to return is 1\\n    answer = NULL;\\n    answer = malloc(sizeof(*answer) * n); // our string of strings will have the same number of element than the returning one (n)\\n    if (!answer)\\n        return (answer); // securizing our malloc => returning NULL if something went wrong\\n    while (i <= n)\\n    {\\n        if (i % 15 == 0)\\n            answer[i - 1] = strdup(\"FizzBuzz\"); // NB we need to start duplicating from position 0 => (i - 1)\\n        else if (i % 3 == 0)\\n            answer[i - 1] = strdup(\"Fizz\");\\n        else if (i % 5 == 0)\\n            answer[i - 1] = strdup(\"Buzz\");\\n        else\\n        {\\n            sprintf(str, \"%d\", i); // converting integer i into char and storing it in str\\n            answer[i - 1] = strdup(str);\\n        }"], ["char ** fizzBuzz(int n, int* returnSize){\\n    *returnSize = n;\\n    char **T = (char**)malloc(sizeof(char*)*n);\\n    for(int i=0;i<n;i++){\\n        T[i]=(char*)malloc(9*sizeof(char));\\n        sprintf(T[i], \"%d\", i+1);  // Convert \\'i\\' to char \\n        if( (i+1) % 3 == 0 && (i+1) % 5 == 0){T[i] = \"FizzBuzz\";}"], ["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    char**arr = malloc(n*sizeof(char*));\\n    *returnSize = n;\\n    for(int i=1;i<=n;i++)\\n    {\\n        arr[i - 1] = malloc(9 * sizeof(char));\\n        if(i%15==0)\\n        arr[i-1] = \"FizzBuzz\";\\n        else if(i%3==0)\\n        arr[i-1]=\"Fizz\";\\n        else if(i%5==0)\\n        arr[i-1]=\"Buzz\";\\n        else\\n        sprintf(arr[i-1], \"%d\", i);\\n    }"]]}
{"id": "1570", "ref_c": [["int distributeCookies(int* cookies, int cookiesSize, int k){\\n//considering k is equal to size of the array \\nif(cookiesSize == k){return fun_max(cookies,cookiesSize);}"], ["int distributeCookies(int* cookies, int cookiesSize, int k){\\n//considering k is equal to size of the array \\nif(cookiesSize == k){return fun_max(cookies,cookiesSize);}"], ["int distributeCookies(int* cookies, int cookiesSize, int k){\\n    /*\\n     * Input:\\n     *  cookies, \\n     *  cookiesSize,\\n     *  k\\n     */\\n     \\n    int min_unfairness = INT_MAX;\\n    int *amount = (int *)calloc(1, sizeof(int) * k);\\n\\n    /*\\n     * Output:\\n     *  Return the minimum unfairness of all distributions.\\n     */\\n\\n    giveCookies(cookies, cookiesSize, 0, k, amount, &min_unfairness);\\n    \\n    free(amount);\\n     \\n    return min_unfairness;\\n}"]]}
{"id": "1571", "ref_c": [["int minimumNumbers(int num, int k) {\\n    if(num==0)\\n    return 0;\\n    int x=num%10;\\nfor(int i=1;i<=10;i++){\\nif((i*k)%10==x){\\n    if(i*k<=num)\\n    return i;\\n    else\\n    return -1;\\n}"], ["int minimumNumbers(int num, int k) {\\n    if(num==0)\\n    return 0;\\n    int x=num%10;\\nfor(int i=1;i<=10;i++){\\nif((i*k)%10==x){\\n    if(i*k<=num)\\n    return i;\\n    else\\n    return -1;\\n}"], ["int minimumNumbers(int num, int k){\\n\\tif(num == 0){return 0;}"]]}
{"id": "1572", "ref_c": [["int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}", "int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}"], ["int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}", "int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}"], ["int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}", "int rearrangeCharacters(char * s, char * target){\\n    int sCharsCount[26] = {0}"]]}
{"id": "1573", "ref_c": [["long long countPairs(int n, int** edges, int edgesSize, int* edgesColSize){\\n    DSU* dsu = createDSU(n);\\n    int* root = dsu->root;\\n    int* rank = dsu->rank;\\n    int* setSize = dsu->setSize;\\n    //traverse all edges and unite sets.\\n    for(int i = 0; i < edgesSize; i++){\\n        int e1 = edges[i][0];\\n        int e2 = edges[i][1];\\n        setUnion(root, rank, setSize, e1, e2);\\n    }"], ["long long countPairs(int n, int** edges, int edgesSize, int* edgesColSize){\\n    DSU* dsu = createDSU(n);\\n    int* root = dsu->root;\\n    int* rank = dsu->rank;\\n    int* setSize = dsu->setSize;\\n    //traverse all edges and unite sets.\\n    for(int i = 0; i < edgesSize; i++){\\n        int e1 = edges[i][0];\\n        int e2 = edges[i][1];\\n        setUnion(root, rank, setSize, e1, e2);\\n    }"], ["long long countPairs(int n, int** edges, int edgesSize, int* edgesColSize){\\n    \\n    int *roots = (int *)malloc(sizeof(int) * n);\\n    int *sizes = (int *)malloc(sizeof(int) * n);\\n    for (int i = 0; i < n; i ++) {\\n        roots[i] = -1;\\n        sizes[i] = 1;\\n    }"]]}
{"id": "1574", "ref_c": [["int maximumXOR(int* nums, int numsSize) {\\n    int res = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        res |= nums[i];\\n    }"], ["int maximumXOR(int* nums, int numsSize) {\\n    int res = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        res |= nums[i];\\n    }"], ["int maximumXOR(int* nums, int numsSize) {\\n    int ans = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        ans |= nums[i];\\n    }"]]}
{"id": "1575", "ref_c": [["char * complexNumberMultiply(char * num1, char * num2){\\n    int a, b, x, y;\\n    a = b = x = y = 0;\\n    int i, k;\\n    int len1 = strlen(num1);\\n    int len2 = strlen(num2);\\n\\n    // extracting value from num1\\n    for (i = len1 - 2, k = 0; num1[i] != \\'+\\';i--)\\n    {\\n        if (num1[i] == \\'-\\')\\n        {\\n            b *= -1;\\n            continue;\\n        }"], ["char * complexNumberMultiply(char * num1, char * num2){\\n    int a, b, x, y;\\n    a = b = x = y = 0;\\n    int i, k;\\n    int len1 = strlen(num1);\\n    int len2 = strlen(num2);\\n\\n    // extracting value from num1\\n    for (i = len1 - 2, k = 0; num1[i] != \\'+\\';i--)\\n    {\\n        if (num1[i] == \\'-\\')\\n        {\\n            b *= -1;\\n            continue;\\n        }"], ["char * complexNumberMultiply(char * num1, char * num2){\\n    int a, b, x, y;\\n    a = b = x = y = 0;\\n    int i, k;\\n    int len1 = strlen(num1);\\n    int len2 = strlen(num2);\\n\\n    // extracting value from num1\\n    for (i = len1 - 2, k = 0; num1[i] != \\'+\\';i--)\\n    {\\n        if (num1[i] == \\'-\\')\\n        {\\n            b *= -1;\\n            continue;\\n        }"]]}
{"id": "1576", "ref_c": [["int** spiralMatrix(int m, int n, struct ListNode* head, int* returnSize, int** returnColumnSizes){\\n    *returnSize = m;\\n\\n    int *colSizes = (int*)malloc(m * sizeof(int));\\n    *returnColumnSizes = colSizes;\\n\\n    int **result = (int**)malloc(m * sizeof(int*));\\n    for (int i = 0; i < m; i++)\\n    {\\n        colSizes[i] = n;\\n        result[i] = (int*)malloc(n * sizeof(int));\\n    }"], ["int** spiralMatrix(int m, int n, struct ListNode* head, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = m;\\n    *returnColumnSizes = (int *)calloc(m, sizeof(int));\\n    int **result = (int **)calloc(m, sizeof(int *));\\n\\n    /* Initialize result matrix with -1 */\\n    for(int row = 0; row < m; row++)\\n    {\\n        (*returnColumnSizes)[row] = n;\\n        result[row] = (int *)calloc(n, sizeof(int));\\n        memset(result[row], -1, n*sizeof(int));\\n    }"], ["int** spiralMatrix(int m, int n, struct ListNode* head, int* returnSize, int** returnColumnSizes){\\n    *returnSize = m;\\n\\n    int *colSizes = (int*)malloc(m * sizeof(int));\\n    *returnColumnSizes = colSizes;\\n\\n    int **result = (int**)malloc(m * sizeof(int*));\\n    for (int i = 0; i < m; i++)\\n    {\\n        colSizes[i] = n;\\n        result[i] = (int*)malloc(n * sizeof(int));\\n    }"]]}
{"id": "1577", "ref_c": [["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n; // since n = number of elements to be returned\\n    char **answer; // the string of strings where the right elements will be copied\\n    char str[5]; // every string contains at most 5 character (max number is 10000 => 5 characters)\\n    \\n    i = 1; // first number we want to return is 1\\n    answer = NULL;\\n    answer = malloc(sizeof(*answer) * n); // our string of strings will have the same number of element than the returning one (n)\\n    if (!answer)\\n        return (answer); // securizing our malloc => returning NULL if something went wrong\\n    while (i <= n)\\n    {\\n        if (i % 15 == 0)\\n            answer[i - 1] = strdup(\"FizzBuzz\"); // NB we need to start duplicating from position 0 => (i - 1)\\n        else if (i % 3 == 0)\\n            answer[i - 1] = strdup(\"Fizz\");\\n        else if (i % 5 == 0)\\n            answer[i - 1] = strdup(\"Buzz\");\\n        else\\n        {\\n            sprintf(str, \"%d\", i); // converting integer i into char and storing it in str\\n            answer[i - 1] = strdup(str);\\n        }"], ["char ** fizzBuzz(int n, int* returnSize){\\n    *returnSize = n;\\n    char **T = (char**)malloc(sizeof(char*)*n);\\n    for(int i=0;i<n;i++){\\n        T[i]=(char*)malloc(9*sizeof(char));\\n        sprintf(T[i], \"%d\", i+1);  // Convert \\'i\\' to char \\n        if( (i+1) % 3 == 0 && (i+1) % 5 == 0){T[i] = \"FizzBuzz\";}"], ["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    char**arr = malloc(n*sizeof(char*));\\n    *returnSize = n;\\n    for(int i=1;i<=n;i++)\\n    {\\n        arr[i - 1] = malloc(9 * sizeof(char));\\n        if(i%15==0)\\n        arr[i-1] = \"FizzBuzz\";\\n        else if(i%3==0)\\n        arr[i-1]=\"Fizz\";\\n        else if(i%5==0)\\n        arr[i-1]=\"Buzz\";\\n        else\\n        sprintf(arr[i-1], \"%d\", i);\\n    }"]]}
{"id": "1578", "ref_c": [["int latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity){\\n    int i, j, k, time, prev=-1;\\n\\n    // first sort times in order\\n    qsort(buses, busesSize, sizeof(int), comp);\\n    qsort(passengers, passengersSize, sizeof(int), comp);\\n\\n    for(i=j=0; i<busesSize; ++i) {                          // for each bus\\n        for(k=0;((j<passengersSize)&&(k<capacity));++k) {   // for each seat\\n            if (passengers[j] > buses[i]) {                 // line has been completely serviced\\n                break;\\n            }"], ["int latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity){\\n    int i, j, k, time, prev=-1;\\n\\n    // first sort times in order\\n    qsort(buses, busesSize, sizeof(int), comp);\\n    qsort(passengers, passengersSize, sizeof(int), comp);\\n\\n    for(i=j=0; i<busesSize; ++i) {                          // for each bus\\n        for(k=0;((j<passengersSize)&&(k<capacity));++k) {   // for each seat\\n            if (passengers[j] > buses[i]) {                 // line has been completely serviced\\n                break;\\n            }"], ["int latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity){\\n    int i, j, k, time, prev=-1;\\n\\n    // first sort times in order\\n    qsort(buses, busesSize, sizeof(int), comp);\\n    qsort(passengers, passengersSize, sizeof(int), comp);\\n\\n    for(i=j=0; i<busesSize; ++i) {                          // for each bus\\n        for(k=0;((j<passengersSize)&&(k<capacity));++k) {   // for each seat\\n            if (passengers[j] > buses[i]) {                 // line has been completely serviced\\n                break;\\n            }"]]}
{"id": "1579", "ref_c": [["char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    (*returnSize) = 1;\\n\\n    int len;\\n    int i;\\n    for (i=1; i<wordsSize; ++i)\\n    {\\n        if (isAnagrams(words[(*returnSize)-1], words[i]) == true)\\n        {\\n            continue;\\n        }"], ["char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    int i = 0 , j =0 , size  = 1;\\n    char** ret = (char**)malloc(wordsSize*sizeof(char*));\\n    ret[size-1] = words[0];\\n    for(i = 1 ; i < wordsSize ; ++i)\\n    {\\n        if(isAng(ret[size-1] , words[i]))\\n            continue;\\n        else\\n        {\\n            ++size;\\n            ret[size-1] = words[i];\\n        }"], ["char ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    int i = 0 , j =0;\\n    char** ret = NULL;\\n    int size = 0;\\n    for( j = 0 ,i = 1 ; i < wordsSize ; )\\n    {\\n        if(words[j] && words[i]  && (isAng(words[i] , words[j])))\\n        {\\n            words[i] = NULL;\\n            ++i;\\n        }"]]}
{"id": "1581", "ref_c": [["bool canChange(char * start, char * target){\\n    int n = strlen(start);\\n    char *a = (char *) malloc((n+1)*sizeof(char));\\n    char *b = (char *) malloc((n+1)*sizeof(char));\\n    strcpy(a, start);\\n    strcpy(b, target);\\n    a[n] = \\'\\\\0\\';\\n    b[n] = \\'\\\\0\\';\\n    int aIdx = 0, bIdx = 0;\\n\\n    int *aSpaceL = (int *) malloc((n+1)*sizeof(int));\\n    int *aSpaceR = (int *) malloc((n+1)*sizeof(int));\\n    int aSpaceIdxL = 0, aSpaceIdxR = 0;\\n    int *bSpaceL = (int *) malloc((n+1)*sizeof(int));\\n    int *bSpaceR = (int *) malloc((n+1)*sizeof(int));\\n    int bSpaceIdxL = 0, bSpaceIdxR = 0;\\n   \\n    // remove underscore and value match\\n    for (int i = 0; i < n; i++) {\\n        if (start[i] == \\'L\\') {\\n            aSpaceL[aSpaceIdxL++] = i;\\n        }"], ["bool canChange(char * start, char * target){\\n    int n = strlen(start);\\n    char *a = (char *) malloc((n+1)*sizeof(char));\\n    char *b = (char *) malloc((n+1)*sizeof(char));\\n    strcpy(a, start);\\n    strcpy(b, target);\\n    a[n] = \\'\\\\0\\';\\n    b[n] = \\'\\\\0\\';\\n    int aIdx = 0, bIdx = 0;\\n\\n    int *aSpaceL = (int *) malloc((n+1)*sizeof(int));\\n    int *aSpaceR = (int *) malloc((n+1)*sizeof(int));\\n    int aSpaceIdxL = 0, aSpaceIdxR = 0;\\n    int *bSpaceL = (int *) malloc((n+1)*sizeof(int));\\n    int *bSpaceR = (int *) malloc((n+1)*sizeof(int));\\n    int bSpaceIdxL = 0, bSpaceIdxR = 0;\\n   \\n    // remove underscore and value match\\n    for (int i = 0; i < n; i++) {\\n        if (start[i] == \\'L\\') {\\n            aSpaceL[aSpaceIdxL++] = i;\\n        }"], ["bool canChange(char * start, char * target){\\n    int n = strlen(start);\\n    char *a = (char *) malloc((n+1)*sizeof(char));\\n    char *b = (char *) malloc((n+1)*sizeof(char));\\n    strcpy(a, start);\\n    strcpy(b, target);\\n    a[n] = \\'\\\\0\\';\\n    b[n] = \\'\\\\0\\';\\n    int aIdx = 0, bIdx = 0;\\n\\n    int *aSpaceL = (int *) malloc((n+1)*sizeof(int));\\n    int *aSpaceR = (int *) malloc((n+1)*sizeof(int));\\n    int aSpaceIdxL = 0, aSpaceIdxR = 0;\\n    int *bSpaceL = (int *) malloc((n+1)*sizeof(int));\\n    int *bSpaceR = (int *) malloc((n+1)*sizeof(int));\\n    int bSpaceIdxL = 0, bSpaceIdxR = 0;\\n   \\n    // remove underscore and value match\\n    for (int i = 0; i < n; i++) {\\n        if (start[i] == \\'L\\') {\\n            aSpaceL[aSpaceIdxL++] = i;\\n        }"]]}
{"id": "1582", "ref_c": [["int maximumSum(int* nums, int numsSize){\\n    int count[100]={0}"], ["int maximumSum(int* nums, int numsSize) {\\n    // Sorting + Hashtable\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    const int Max = 9 * 9;  // getSum(999999999) := 81\\n    int result = -1;\\n    int count[81 + 1][100000 + 1];\\n    int size[100000 + 1] = {0}"], ["int maximumSum(int* nums, int numsSize){\\n    int count[100]={0}"]]}
{"id": "1583", "ref_c": [["int* smallestTrimmedNumbers(char ** nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    int* answer=malloc(queriesSize*4);\\n    int* qIndices=malloc(queriesSize*4);//queries indices\\n    for (int i=0;i<queriesSize;i++) qIndices[i]=i;\\n    loadList=queries;\\n    qsort(qIndices,queriesSize,4,cmp);\\n    char len=strlen(*nums);\\n    char digit=len-1;\\n    char qInd=0;//queriesInd\\n    char LSD[10][100];\\n    char LSDlens[10];//aka \"LSDColSize\"\\n    char nIndices[numsSize];//nums indices\\n    for (char i=0;i<numsSize;i++) nIndices[i]=i;\\n    do{\\n        memset(LSDlens,0,10);\\n        for (char i=0,temp;i<numsSize;i++){\\n            temp=nums[nIndices[i]][digit]-\\'0\\';\\n            LSD[temp][(LSDlens[temp])++]=nIndices[i];\\n        }"], ["int* smallestTrimmedNumbers(char ** nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    int* answer=malloc(queriesSize*4);\\n    int* qIndices=malloc(queriesSize*4);//queries indices\\n    for (int i=0;i<queriesSize;i++) qIndices[i]=i;\\n    loadList=queries;\\n    qsort(qIndices,queriesSize,4,cmp);\\n    char len=strlen(*nums);\\n    char digit=len-1;\\n    char qInd=0;//queriesInd\\n    char LSD[10][100];\\n    char LSDlens[10];//aka \"LSDColSize\"\\n    char nIndices[numsSize];//nums indices\\n    for (char i=0;i<numsSize;i++) nIndices[i]=i;\\n    do{\\n        memset(LSDlens,0,10);\\n        for (char i=0,temp;i<numsSize;i++){\\n            temp=nums[nIndices[i]][digit]-\\'0\\';\\n            LSD[temp][(LSDlens[temp])++]=nIndices[i];\\n        }"], ["int* smallestTrimmedNumbers(char ** nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    int* answer=malloc(queriesSize*4);\\n    int* qIndices=malloc(queriesSize*4);//queries indices\\n    for (int i=0;i<queriesSize;i++) qIndices[i]=i;\\n    loadList=queries;\\n    qsort(qIndices,queriesSize,4,cmp);\\n    char len=strlen(*nums);\\n    char digit=len-1;\\n    char qInd=0;//queriesInd\\n    char LSD[10][100];\\n    char LSDlens[10];//aka \"LSDColSize\"\\n    char nIndices[numsSize];//nums indices\\n    for (char i=0;i<numsSize;i++) nIndices[i]=i;\\n    do{\\n        memset(LSDlens,0,10);\\n        for (char i=0,temp;i<numsSize;i++){\\n            temp=nums[nIndices[i]][digit]-\\'0\\';\\n            LSD[temp][(LSDlens[temp])++]=nIndices[i];\\n        }"]]}
{"id": "1584", "ref_c": [["long long zeroFilledSubarray(int* nums, int numsSize){\\n    long long ans = 0, zeroCnt = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        if(!nums[i])\\n            zeroCnt++;\\n        else\\n            zeroCnt = 0;\\n        \\n        if(zeroCnt)\\n            ans += zeroCnt;\\n    }"], ["long long zeroFilledSubarray(int* nums, int numsSize){\\n    long long ans = 0, zeroCnt = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        if(!nums[i])\\n            zeroCnt++;\\n        else\\n            zeroCnt = 0;\\n        \\n        if(zeroCnt)\\n            ans += zeroCnt;\\n    }"], ["long long zeroFilledSubarray(int* nums, int numsSize){\\n    long long ans = 0, zeroCnt = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        if(!nums[i])\\n            zeroCnt++;\\n        else\\n            zeroCnt = 0;\\n        \\n        if(zeroCnt)\\n            ans += zeroCnt;\\n    }"]]}
{"id": "1586", "ref_c": [["int equalPairs(int** grid, int gridSize, int* gridColSize){\\n    int ansCnt = 0;\\n    int rLen = gridSize, cLen = *gridColSize;\\n    for(int i = 0; i < rLen; i++){\\n        for(int j = 0; j < cLen; j++){\\n            if(grid[i][0] == grid[0][j]){\\n                ansCnt++;\\n                for(int k = 0; k < rLen; k++)\\n                {\\n                    if(grid[i][k]!=grid[k][j])\\n                    {\\n                        ansCnt--;\\n                        break;\\n                    }"], ["int equalPairs(int** grid, int gridSize, int* gridColSize){\\n    int ansCnt = 0;\\n    int rLen = gridSize, cLen = *gridColSize;\\n    for(int i = 0; i < rLen; i++){\\n        for(int j = 0; j < cLen; j++){\\n            if(grid[i][0] == grid[0][j]){\\n                ansCnt++;\\n                for(int k = 0; k < rLen; k++)\\n                {\\n                    if(grid[i][k]!=grid[k][j])\\n                    {\\n                        ansCnt--;\\n                        break;\\n                    }"], ["int equalPairs(int** grid, int gridSize, int* gridColSize){\\n\\n    // input is n x n square\\n    int square_n = *gridColSize; \\n    \\n    uint* hasharr = createRecorder(square_n);\\n    for(int i = 0; i < square_n; i++){\\n        for(int j = 0; j < square_n; j++){\\n            \\n            char numstr[INPUTMAXLEN] = {0}"]]}
{"id": "1588", "ref_c": ["\nint maximumGroups(vector<int>& g) {\n    int count = 0;\n    int n = g.size();\n    \n    sort(g.begin(),g.end());\n    \n    vector<long long> presum(n);\n    presum[0]= g[0];\n    for(int i=1;i<n;i++)\n    {\n        presum[i]+=presum[i-1]+g[i];\n    }\n    int prev = presum[0];\n    count = 1;\n    for(int k=2;k<n;k++)\n    {\n        int x = k*(k+1)/2;\n        if(x<=n)\n        {\n            // cout<<x<<\" \";\n            if(presum[x-1]-prev>prev)\n            {\n                count++;\n            }\n            else \n            {\n                break;\n            }\n        }\n        else \n        {\n            break;\n        }\n        \n    }\n    \n    return count;\n", "\nint maximumGroups(vector<int>& g) {\n    int count = 0;\n    int n = g.size();\n    \n    sort(g.begin(),g.end());\n    \n    vector<long long> presum(n);\n    presum[0]= g[0];\n    for(int i=1;i<n;i++)\n    {\n        presum[i]+=presum[i-1]+g[i];\n    }\n    int prev = presum[0];\n    count = 1;\n    for(int k=2;k<n;k++)\n    {\n        int x = k*(k+1)/2;\n        if(x<=n)\n        {\n            // cout<<x<<\" \";\n            if(presum[x-1]-prev>prev)\n            {\n                count++;\n            }\n            else \n            {\n                break;\n            }\n        }\n        else \n        {\n            break;\n        }\n        \n    }\n    \n    return count;\n", "\nint maximumGroups(vector<int>& g) {\n    int count = 0;\n    int n = g.size();\n    \n    sort(g.begin(),g.end());\n    \n    vector<long long> presum(n);\n    presum[0]= g[0];\n    for(int i=1;i<n;i++)\n    {\n        presum[i]+=presum[i-1]+g[i];\n    }\n    int prev = presum[0];\n    count = 1;\n    for(int k=2;k<n;k++)\n    {\n        int x = k*(k+1)/2;\n        if(x<=n)\n        {\n            // cout<<x<<\" \";\n            if(presum[x-1]-prev>prev)\n            {\n                count++;\n            }\n            else \n            {\n                break;\n            }\n        }\n        else \n        {\n            break;\n        }\n        \n    }\n    \n    return count;\n"]}
{"id": "1589", "ref_c": [["int closestMeetingNode(int* edges, int edgesSize, int node1, int node2){\\n    int res = -1, dist = INT_MAX;\\n \\n    int *n1 = (int*)malloc(edgesSize*sizeof(int));\\n    int *n2 = (int*)malloc(edgesSize*sizeof(int));\\n    for(int n=0;n<edgesSize;n++)\\n    {\\n        n1[n] = -1;\\n        n2[n] = -1;\\n    }"], ["int closestMeetingNode(int* edges, int edgesSize, int node1, int node2){\\n    int res = -1, dist = INT_MAX;\\n \\n    int *n1 = (int*)malloc(edgesSize*sizeof(int));\\n    int *n2 = (int*)malloc(edgesSize*sizeof(int));\\n    for(int n=0;n<edgesSize;n++)\\n    {\\n        n1[n] = -1;\\n        n2[n] = -1;\\n    }"], ["int closestMeetingNode(int* edges, int edgesSize, int node1, int node2){\\n    if (node1 == node2) return node1;\\n    int* adj1 = (int*)calloc(edgesSize, sizeof(int));\\n    int* adj2 = (int*)calloc(edgesSize, sizeof(int));\\n    for (size_t i=0; i < edgesSize; i++){\\n        if (i != node1){\\n            adj1[i] = -1;\\n        }"]]}
{"id": "1590", "ref_c": [["long long countBadPairs(int* nums, int numsSize){\\n    struct myhash *total = NULL;\\n    \\n    long long ans = 0;\\n    for(int i=numsSize-1;i>=0;i--){\\n        int target = nums[i]-i;\\n        struct myhash *tmp = NULL;\\n        HASH_FIND_INT(total,&target,tmp);\\n        \\n        if(tmp==NULL){\\n            tmp = malloc(sizeof(struct myhash));\\n            tmp->key = target;\\n            tmp->count = 1;\\n            HASH_ADD_INT(total,key,tmp);\\n            ans+=numsSize-1-i;\\n        }"], ["long long countBadPairs(int* nums, int numsSize){\\n    struct myhash *total = NULL;\\n    \\n    long long ans = 0;\\n    for(int i=numsSize-1;i>=0;i--){\\n        int target = nums[i]-i;\\n        struct myhash *tmp = NULL;\\n        HASH_FIND_INT(total,&target,tmp);\\n        \\n        if(tmp==NULL){\\n            tmp = malloc(sizeof(struct myhash));\\n            tmp->key = target;\\n            tmp->count = 1;\\n            HASH_ADD_INT(total,key,tmp);\\n            ans+=numsSize-1-i;\\n        }"], ["long long countBadPairs(int* nums, int numsSize){\\n    struct myhash *total = NULL;\\n    \\n    long long ans = 0;\\n    for(int i=numsSize-1;i>=0;i--){\\n        int target = nums[i]-i;\\n        struct myhash *tmp = NULL;\\n        HASH_FIND_INT(total,&target,tmp);\\n        \\n        if(tmp==NULL){\\n            tmp = malloc(sizeof(struct myhash));\\n            tmp->key = target;\\n            tmp->count = 1;\\n            HASH_ADD_INT(total,key,tmp);\\n            ans+=numsSize-1-i;\\n        }"]]}
{"id": "1591", "ref_c": [["long long taskSchedulerII(int* tasks, int tasksSize, int space){\\n    long long ans = 0;\\n    struct myhash *total = NULL;\\n    struct myhash *tmp = NULL;\\n    for(int i=0;i<tasksSize;i++){\\n        HASH_FIND_INT(total,&tasks[i],tmp);\\n        if(tmp==NULL){\\n            tmp = malloc(sizeof(struct myhash));\\n            tmp->key = tasks[i];\\n            tmp->day = ++ans;\\n            HASH_ADD_INT(total,key,tmp);\\n        }"], ["long long taskSchedulerII(int* tasks, int tasksSize, int space){\\n    long long ans = 0;\\n    struct myhash *total = NULL;\\n    struct myhash *tmp = NULL;\\n    for(int i=0;i<tasksSize;i++){\\n        HASH_FIND_INT(total,&tasks[i],tmp);\\n        if(tmp==NULL){\\n            tmp = malloc(sizeof(struct myhash));\\n            tmp->key = tasks[i];\\n            tmp->day = ++ans;\\n            HASH_ADD_INT(total,key,tmp);\\n        }"], ["long long taskSchedulerII(int* tasks, int tasksSize, int space){\\n    long long ans = 0;\\n    struct myhash *total = NULL;\\n    struct myhash *tmp = NULL;\\n    for(int i=0;i<tasksSize;i++){\\n        HASH_FIND_INT(total,&tasks[i],tmp);\\n        if(tmp==NULL){\\n            tmp = malloc(sizeof(struct myhash));\\n            tmp->key = tasks[i];\\n            tmp->day = ++ans;\\n            HASH_ADD_INT(total,key,tmp);\\n        }"]]}
{"id": "1592", "ref_c": [["int reachableNodes(int n, int** edges, int edgesSize, int* edgesColSize, int* restricted, int restrictedSize) {\\n    bool *rest_map, *visited;\\n    int rm_edges = 0, totle = 0;\\n    int **bi_edges, bi_edgesSize, bi_count=0;\\n    unsigned int *edge_idx;\\n\\n    rest_map = calloc(sizeof(bool), n);\\n    for (int i = 0; i < restrictedSize; ++i) {\\n        rest_map[restricted[i]] = true;\\n    }"], ["int reachableNodes(int n, int** edges, int edgesSize, int* edgesColSize, int* restricted, int restrictedSize) {\\n    bool *rest_map, *visited;\\n    int rm_edges = 0, totle = 0;\\n    int **bi_edges, bi_edgesSize, bi_count=0;\\n    unsigned int *edge_idx;\\n\\n    rest_map = calloc(sizeof(bool), n);\\n    for (int i = 0; i < restrictedSize; ++i) {\\n        rest_map[restricted[i]] = true;\\n    }"], ["int reachableNodes(int n, int** edges, int edgesSize, int* edgesColSize, int* restricted, int restrictedSize) {\\n    bool *rest_map, *visited;\\n    int rm_edges = 0, totle = 0;\\n    int **bi_edges, bi_edgesSize, bi_count=0;\\n    unsigned int *edge_idx;\\n\\n    rest_map = calloc(sizeof(bool), n);\\n    for (int i = 0; i < restrictedSize; ++i) {\\n        rest_map[restricted[i]] = true;\\n    }"]]}
{"id": "1593", "ref_c": [["bool validPartition(int* nums, int numsSize){\\n    int dp[numsSize+1];\\n    dp[0]=1;\\n    for(int j=1;j<=numsSize;j++)\\n        dp[j]=0;\\n    for(int i=1;i<=numsSize;i++)\\n    {\\n        if(i==1)dp[i]=0;\\n        if(i>1)\\n        {\\n            if(nums[i-2]==nums[i-1])\\n                dp[i]=dp[i-2]||dp[i];\\n        }"], ["bool validPartition(int* nums, int numsSize){\\n    int *memo = (int*)malloc(numsSize * sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        memo[i] = -1;\\n    }"], ["bool validPartition(int* nums, int numsSize){\\n    int *memo = (int*)malloc(numsSize * sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        memo[i] = -1;\\n    }"]]}
{"id": "1594", "ref_c": [["int longestIdealString(char * s, int k){\\n    \\n    int freq[26]={0}"], ["int longestIdealString(char * s, int k){\\n    \\n    int freq[26]={0}"], ["int longestIdealString(char * s, int k){\\n    \\n    int freq[26]={0}"]]}
{"id": "1595", "ref_c": [["int findNumberOfLIS(int* nums, int numsSize) {\\n    if (numsSize == 0) return 0;\\n\\n    int dp[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        dp[i] = 1;\\n    }"], ["int findNumberOfLIS(int* nums, int numsSize) {\\n    // DP method \\n\\n    // Time complexity: O(n^2)\\n    // Space comeplxity: O(n)\\n\\n    const int n = numsSize;\\n    int result = 0, maxlen = 0;\\n    int* length = (int*)calloc(n, sizeof(int));  // length[i] := LIS\\'s length ending with nums[i]\\n    int* counts = (int*)calloc(n, sizeof(int));  // counts[i] := number of the LIS ending with nums[i] \\n\\n    for (int i = 0; i < n; i++) {\\n        // initialize length and count arrays\\n        length[i] = 1;\\n        counts[i] = 1;\\n\\n        // calculate length and count arrays\\n        for (int j = 0; j < i; j++) {\\n            if (nums[i] <= nums[j]) continue;\\n\\n            if (length[i] == length[j] + 1) {\\n                counts[i] += counts[j];\\n            }"], ["int findNumberOfLIS(int* nums, int numsSize){\\n    int n = numsSize;\\n    int max_l = 0;\\n    int ret = 0;\\n    int *dp = NULL;\\n    int *count = NULL;\\n\\n    dp = (int*) malloc(n * sizeof(int));\\n    if (!dp) {\\n        goto END;\\n    }"]]}
{"id": "1596", "ref_c": [["char * smallestNumber(char * pattern){\\n    \\n    int len = strlen(pattern);\\n    int i;\\n    char *res = (char *)malloc(sizeof(char)*len+2);\\n    memset(res,0,sizeof(char)*len+2);\\n    for (i=0; i < len+1; i++)\\n    {\\n        res[i] = i+\\'1\\';\\n    }"], ["char * smallestNumber(char * pattern){\\n    int len = strlen(pattern), idx = 0, sIdx = -1, ansIdx = 0;\\n    char* ans = (char*)calloc(len+2, sizeof(char));\\n    char* s = (char*)calloc(len+1, sizeof(char));\\n\\n    while(idx <= len){\\n        if(idx < len && pattern[idx] == \\'D\\')\\n            s[++sIdx] = \\'1\\' + idx;\\n        else{\\n            ans[ansIdx++] = \\'1\\' + idx;\\n            while(sIdx != -1){\\n                ans[ansIdx++] = s[sIdx--];\\n            }"], ["char * smallestNumber(char * pattern){\\n    int len = strlen(pattern), idx = 0, sIdx = -1, ansIdx = 0;\\n    char* ans = (char*)calloc(len+2, sizeof(char));\\n    char* s = (char*)calloc(len+1, sizeof(char));\\n\\n    while(idx <= len){\\n        if(idx < len && pattern[idx] == \\'D\\')\\n            s[++sIdx] = \\'1\\' + idx;\\n        else{\\n            ans[ansIdx++] = \\'1\\' + idx;\\n            while(sIdx != -1){\\n                ans[ansIdx++] = s[sIdx--];\\n            }"]]}
{"id": "1597", "ref_c": [["int secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }"], ["int secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }"], ["int secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }"]]}
{"id": "1598", "ref_c": ["\nvoid inorder(struct TreeNode* root, char* pRetVal, int* returnSize) {\n    if (root == NULL) {\n        return;\n    }\n\n    snprintf(pRetVal + strlen(pRetVal), (*returnSize), \"%d\", root->val);\n\n    if (root->left != NULL) {\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->left, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n\n    if (root->right != NULL) {\n        if (root->left == NULL) {\n            pRetVal[strlen(pRetVal)] = '(';\n            pRetVal[strlen(pRetVal)] = ')';\n        }\n\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->right, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n}\n\nchar* tree2str(struct TreeNode* root) {\nchar* pRetVal = NULL;\n\n    int returnSize = 1e5;\n    pRetVal = (char*)calloc(returnSize, sizeof(char));\n    if (pRetVal == NULL) {\n        perror(\"calloc\");\n        return pRetVal;\n    }\n    inorder(root, pRetVal, &returnSize);\n    pRetVal[strlen(pRetVal)] = '\u0000';\n\n    return pRetVal;   \n}\n", "\nvoid inorder(struct TreeNode* root, char* pRetVal, int* returnSize) {\n    if (root == NULL) {\n        return;\n    }\n\n    snprintf(pRetVal + strlen(pRetVal), (*returnSize), \"%d\", root->val);\n\n    if (root->left != NULL) {\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->left, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n\n    if (root->right != NULL) {\n        if (root->left == NULL) {\n            pRetVal[strlen(pRetVal)] = '(';\n            pRetVal[strlen(pRetVal)] = ')';\n        }\n\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->right, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n}\n\nchar* tree2str(struct TreeNode* root) {\nchar* pRetVal = NULL;\n\n    int returnSize = 1e5;\n    pRetVal = (char*)calloc(returnSize, sizeof(char));\n    if (pRetVal == NULL) {\n        perror(\"calloc\");\n        return pRetVal;\n    }\n    inorder(root, pRetVal, &returnSize);\n    pRetVal[strlen(pRetVal)] = '\u0000';\n\n    return pRetVal;   \n}\n", "\nvoid inorder(struct TreeNode* root, char* pRetVal, int* returnSize) {\n    if (root == NULL) {\n        return;\n    }\n\n    snprintf(pRetVal + strlen(pRetVal), (*returnSize), \"%d\", root->val);\n\n    if (root->left != NULL) {\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->left, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n\n    if (root->right != NULL) {\n        if (root->left == NULL) {\n            pRetVal[strlen(pRetVal)] = '(';\n            pRetVal[strlen(pRetVal)] = ')';\n        }\n\n        pRetVal[strlen(pRetVal)] = '(';\n        inorder(root->right, pRetVal, returnSize);\n        pRetVal[strlen(pRetVal)] = ')';\n    }\n}\n\nchar* tree2str(struct TreeNode* root) {\nchar* pRetVal = NULL;\n\n    int returnSize = 1e5;\n    pRetVal = (char*)calloc(returnSize, sizeof(char));\n    if (pRetVal == NULL) {\n        perror(\"calloc\");\n        return pRetVal;\n    }\n    inorder(root, pRetVal, &returnSize);\n    pRetVal[strlen(pRetVal)] = '\u0000';\n\n    return pRetVal;   \n}\n"]}
{"id": "1599", "ref_c": [["bool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size){\\n    //First retrieve the hour\\n    char *evt1 = strtok(event1[0], \":\");\\n    //Convert it in minutes\\n    int et1 = atoi(evt1) * 60;\\n    //Then retrieve the minutes\\n    evt1 = strtok(NULL, \":\"); \\n    //Add it up\\n    et1 = et1 + atoi(evt1);\\n    // So on for every startTime and endTime\\n    char *evt11 = strtok(event1[1], \":\");\\n    int et11 = atoi(evt11) * 60; evt11 = strtok(NULL, \":\");\\n    et11 = et11 + atoi(evt11);\\n    char *evt2 = strtok(event2[0], \":\");\\n    int et2 = atoi(evt2) * 60;\\n    evt2 = strtok(NULL, \":\");\\n    et2 = et2 + atoi(evt2);\\n    char *evt22 = strtok(event2[1], \":\");\\n    int et22 = atoi(evt22) * 60;\\n    evt22 = strtok(NULL, \":\");\\n    et22 = et22 + atoi(evt22);\\n    if ((et11 >= et2) && (et1 <= et22)){\\n        return true;\\n    }"], ["bool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size){\\n    //First retrieve the hour\\n    char *evt1 = strtok(event1[0], \":\");\\n    //Convert it in minutes\\n    int et1 = atoi(evt1) * 60;\\n    //Then retrieve the minutes\\n    evt1 = strtok(NULL, \":\"); \\n    //Add it up\\n    et1 = et1 + atoi(evt1);\\n    // So on for every startTime and endTime\\n    char *evt11 = strtok(event1[1], \":\");\\n    int et11 = atoi(evt11) * 60; evt11 = strtok(NULL, \":\");\\n    et11 = et11 + atoi(evt11);\\n    char *evt2 = strtok(event2[0], \":\");\\n    int et2 = atoi(evt2) * 60;\\n    evt2 = strtok(NULL, \":\");\\n    et2 = et2 + atoi(evt2);\\n    char *evt22 = strtok(event2[1], \":\");\\n    int et22 = atoi(evt22) * 60;\\n    evt22 = strtok(NULL, \":\");\\n    et22 = et22 + atoi(evt22);\\n    if ((et11 >= et2) && (et1 <= et22)){\\n        return true;\\n    }"], ["bool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size){\\n    //First retrieve the hour\\n    char *evt1 = strtok(event1[0], \":\");\\n    //Convert it in minutes\\n    int et1 = atoi(evt1) * 60;\\n    //Then retrieve the minutes\\n    evt1 = strtok(NULL, \":\"); \\n    //Add it up\\n    et1 = et1 + atoi(evt1);\\n    // So on for every startTime and endTime\\n    char *evt11 = strtok(event1[1], \":\");\\n    int et11 = atoi(evt11) * 60; evt11 = strtok(NULL, \":\");\\n    et11 = et11 + atoi(evt11);\\n    char *evt2 = strtok(event2[0], \":\");\\n    int et2 = atoi(evt2) * 60;\\n    evt2 = strtok(NULL, \":\");\\n    et2 = et2 + atoi(evt2);\\n    char *evt22 = strtok(event2[1], \":\");\\n    int et22 = atoi(evt22) * 60;\\n    evt22 = strtok(NULL, \":\");\\n    et22 = et22 + atoi(evt22);\\n    if ((et11 >= et2) && (et1 <= et22)){\\n        return true;\\n    }"]]}
{"id": "1600", "ref_c": [["int amountOfTime(struct TreeNode* root, int start){\\n    int maxDepth = -1;\\n    DFS(root, start, &maxDepth);\\n    return maxDepth;\\n}"], ["int amountOfTime(struct TreeNode* root, int start){\\n    if(root==NULL)\\n        return 0;\\n    if(root->left==NULL && root->right==NULL)\\n        return 0;\\n    if(root->val==start)\\n        return level(root)-1;\\n    int ans = 0;\\n    int slv = 0;\\n    level_start(root,start,&ans,&slv);\\n    return ans;\\n}"], ["int amountOfTime(struct TreeNode* root, int start){\\n    int maxDepth = -1;\\n    DFS(root, start, &maxDepth);\\n    return maxDepth;\\n}"]]}
{"id": "1601", "ref_c": ["\nchar* removeStars(char* s) {\n    int n=strlen(s);\n    char* a=(char*)malloc(n+1 * sizeof(char));;\n    int t=-1;\n    for(int i=0;i<n;i++){\n        if(s[i]!='*'){\n            a[++t]=s[i];\n        }\n        else{\n            t--;\n        }\n    }\n    a[++t]='\u0000';\n    return a;\n    \n}\n", "\nchar* removeStars(char* s) {\n    int n=strlen(s);\n    char* a=(char*)malloc(n+1 * sizeof(char));;\n    int t=-1;\n    for(int i=0;i<n;i++){\n        if(s[i]!='*'){\n            a[++t]=s[i];\n        }\n        else{\n            t--;\n        }\n    }\n    a[++t]='\u0000';\n    return a;\n    \n}\n", "\nchar* removeStars(char* s) {\n    int n=strlen(s);\n    char* a=(char*)malloc(n+1 * sizeof(char));;\n    int t=-1;\n    for(int i=0;i<n;i++){\n        if(s[i]!='*'){\n            a[++t]=s[i];\n        }\n        else{\n            t--;\n        }\n    }\n    a[++t]='\u0000';\n    return a;\n    \n}\n"]}
{"id": "1602", "ref_c": ["\nint garbageCollection(char** garbage, int garbageSize, int* travel, int travelSize) {\n    int last_m = -1;\n    int last_p = -1;\n    int last_g = -1;\n    int result = 0;\n\n    for (int i = 0; i < garbageSize; ++i) {\n        for (int j = 0; j < strlen(garbage[i]); ++j) {\n            if (garbage[i][j] == 'M') last_m = i;\n            if (garbage[i][j] == 'P') last_p = i;\n            if (garbage[i][j] == 'G') last_g = i;\n        }\n        result += strlen(garbage[i]);\n    }\n\n    for (int i = 1; i < garbageSize; ++i) {\n        if (i <= last_m) result += travel[i - 1];\n        if (i <= last_p) result += travel[i - 1];\n        if (i <= last_g) result += travel[i - 1];\n    }\n\n    return result;\n}\n", "\nint garbageCollection(char** garbage, int garbageSize, int* travel, int travelSize) {\n    int last_m = -1;\n    int last_p = -1;\n    int last_g = -1;\n    int result = 0;\n\n    for (int i = 0; i < garbageSize; ++i) {\n        for (int j = 0; j < strlen(garbage[i]); ++j) {\n            if (garbage[i][j] == 'M') last_m = i;\n            if (garbage[i][j] == 'P') last_p = i;\n            if (garbage[i][j] == 'G') last_g = i;\n        }\n        result += strlen(garbage[i]);\n    }\n\n    for (int i = 1; i < garbageSize; ++i) {\n        if (i <= last_m) result += travel[i - 1];\n        if (i <= last_p) result += travel[i - 1];\n        if (i <= last_g) result += travel[i - 1];\n    }\n\n    return result;\n}\n", "\nint garbageCollection(char** garbage, int garbageSize, int* travel, int travelSize) {\n    int last_m = -1;\n    int last_p = -1;\n    int last_g = -1;\n    int result = 0;\n\n    for (int i = 0; i < garbageSize; ++i) {\n        for (int j = 0; j < strlen(garbage[i]); ++j) {\n            if (garbage[i][j] == 'M') last_m = i;\n            if (garbage[i][j] == 'P') last_p = i;\n            if (garbage[i][j] == 'G') last_g = i;\n        }\n        result += strlen(garbage[i]);\n    }\n\n    for (int i = 1; i < garbageSize; ++i) {\n        if (i <= last_m) result += travel[i - 1];\n        if (i <= last_p) result += travel[i - 1];\n        if (i <= last_g) result += travel[i - 1];\n    }\n\n    return result;\n}\n"]}
{"id": "1603", "ref_c": [["bool isStrictlyPalindromic(int n){\\n    int* result = malloc(sizeof(int) * 10000); // todo - calculate actual size required\\n    int resultLen;\\n    for (int i=2; i<=n-2; i++) {\\n        if (!isPalindrome(convertToBase(i, n, result), result)) return false;\\n    }"], ["bool isStrictlyPalindromic(int n){\\n    int* result = malloc(sizeof(int) * 10000); // todo - calculate actual size required\\n    int resultLen;\\n    for (int i=2; i<=n-2; i++) {\\n        if (!isPalindrome(convertToBase(i, n, result), result)) return false;\\n    }"], ["bool isStrictlyPalindromic(int n) {\\n        return 0;\\n    }", "bool isStrictlyPalindromic(int n){\\n    return 0;\\n}", "bool isStrictlyPalindromic(int n) {\\n      return false;\\n  }"]]}
{"id": "1604", "ref_c": [["int* replaceElements(int* arr, int arrSize, int* returnSize){\\n\\n    *returnSize = arrSize;\\n    int max=-1,temp;\\n    \\n\\n    for(int i=arrSize - 1;i >= 0;i--){\\n        if(arr[i]>max)\\n            temp = arr[i];\\n        arr[i]=max;\\n        max = temp;\\n    }"], ["int* replaceElements(int* arr, int arrSize, int* returnSize) {\\n    *returnSize = arrSize;\\n    int* result = malloc(*returnSize * sizeof(int));\\n\\n    int max = -1;\\n    int current;\\n    \\n    for (int i = *returnSize - 1; i >= 0; i--) {\\n        current = arr[i];\\n        result[i] = max;\\n        if (current > max) max = current;\\n    }"], ["int* replaceElements(int* arr, int arrSize, int* returnSize) \\n{\\n    *returnSize = arrSize;\\n    int lastVal = arr[arrSize - 1];\\n    arr[arrSize - 1] = -1;\\n    for(int i = arrSize - 2; i >= 0; i--)\\n    {\\n        int tmp = arr[i];\\n        arr[i] = (arr[i + 1] >= lastVal)? arr[i + 1] : lastVal;\\n        lastVal = tmp;\\n    }"]]}
{"id": "1605", "ref_c": [["int numberOfWays(int startPos, int endPos, int k){\\n    if (endPos < startPos){\\n        int a = endPos;\\n        endPos = startPos;\\n        startPos = a;\\n    }"], ["int numberOfWays(int startPos, int endPos, int k){\\n    if (endPos < startPos){\\n        int a = endPos;\\n        endPos = startPos;\\n        startPos = a;\\n    }"], ["int numberOfWays(int startPos, int endPos, int k){\\n    if (endPos < startPos){\\n        int a = endPos;\\n        endPos = startPos;\\n        startPos = a;\\n    }"]]}
{"id": "1606", "ref_c": [["int longestNiceSubarray(int* nums, int numsSize){\\n    int output=1;\\n    int bits=nums[0];\\n    int left=0;\\n    for (int right=1;right<numsSize;right++){\\n        while(nums[right]&bits){\\n            bits^=nums[left++];\\n        }"], ["int longestNiceSubarray(int* nums, int numsSize){\\n    int output=1;\\n    int bits=nums[0];\\n    int left=0;\\n    for (int right=1;right<numsSize;right++){\\n        while(nums[right]&bits){\\n            bits^=nums[left++];\\n        }"], ["int longestNiceSubarray(int* nums, int numsSize){\\n    int left = 0, right = 1, cnt = 1, maxCnt = 1, mask = nums[0];\\n    while(right<numsSize){\\n        if(mask & nums[right])\\n        {\\n            if(cnt > maxCnt) maxCnt = cnt;\\n            cnt--;\\n            mask ^= nums[left++];\\n        }"]]}
{"id": "1607", "ref_c": [["int partitionString(char * s){\\n    int ret = 1;\\n    char arr[26]={0}"], ["int partitionString(char * s){\\n    int ret = 1;\\n    char arr[26]={0}"], ["int partitionString(char * s){\\n    int ret = 1;\\n    char arr[26]={0}"]]}
{"id": "1608", "ref_c": [["int countTriples(int n) {\\n    int count = 0;\\n\\n    for (int i = 1; i < n; i++) {\\n\\n        // j starting from i+1, because we don\\'t have to check same pairs again\\n        for (int j = i + 1; j <= n; j++) {\\n            double sumSqrt = sqrt(i * i + j * j);\\n\\n            // if sumSqrt starts to exceed n, we can safely break.\\n            if (sumSqrt > n) break;\\n\\n            // if square root is an integer, increment count\\n            // counting two times, because if a^2 + b^2 = c^2, then b^2 + a^2 = c^2\\n            if (sumSqrt == floor(sumSqrt)) count += 2;\\n        }"], ["int countTriples(int n) \\n{\\n    int count_square_triples = 0;\\n    for(int a = 1; a <= n; a++)\\n    {\\n        for(int b = a; b <= n; b++)\\n        {\\n            int c, first = 1, last = n, flag = 0;\\n            while(first <= last)\\n            {\\n                c = (first + last) / 2;\\n                if(a * a + b * b == c * c)\\n                {\\n                    flag = 1;\\n                    break;\\n                }"], ["int countTriples(int n) {\\n        int ans=0;\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            for(int j=i+1; j<=n; j++)\\n            {\\n                int square = i*i + j*j;\\n                int root = sqrt(square);\\n\\n                if(root<=n && root*root==square)\\n                    ans+=2;\\n            }"]]}
{"id": "1609", "ref_c": [["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"]]}
{"id": "1610", "ref_c": [["int findClosestNumber(int* nums, int numsSize) \\n{\\n    int closest = nums[0];\\n    int current;\\n    int absClosest;\\n    int absCurrent;\\n\\n    for (int i = 1; i < numsSize; i++) \\n    {\\n        current = nums[i];\\n        // you can use funtion \"abs()\" defined in <stdlib.h>\\n        if(closest < 0)\\n        {\\n            absClosest = -closest;\\n        }"], ["int findClosestNumber(int* nums, int numsSize)\\n{\\n    int min = INT_MAX;\\n    int val = INT_MAX;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (abs(nums[i]) <= min) {\\n            min = abs(nums[i]);\\n            if (abs(val) == abs(nums[i]))\\n                val = val > nums[i] ? val : nums[i];\\n            else\\n                val = nums[i];\\n            printf(\"%d \", val);\\n        }"], ["int findClosestNumber(int* nums, int numsSize) \\n{\\n    int closest = nums[0];\\n    int current;\\n    int absClosest;\\n    int absCurrent;\\n\\n    for (int i = 1; i < numsSize; i++) \\n    {\\n        current = nums[i];\\n        // you can use funtion \"abs()\" defined in <stdlib.h>\\n        if(closest < 0)\\n        {\\n            absClosest = -closest;\\n        }"]]}
{"id": "1611", "ref_c": [["int longestContinuousSubstring(char * s){\\n    int retVal = 1;\\n\\n    int count = 1;\\n    int len = strlen(s);\\n    int i;\\n    for (i=1; i<len; ++i)\\n    {\\n        if (s[i] - s[i-1] == 1)\\n        {\\n            ++count;\\n            retVal = (retVal>count)?retVal:count;\\n        }"], ["int longestContinuousSubstring(char * s){\\n    int current_len = 1, max_len = 1;\\n\\n    // looping over string of length n, till i = n - 2 \\n    // (nth position doesn\\'t exist so no need to compare it with n - 1th position)\\n    for (int i = 0, s_len = strlen(s); i < s_len - 1; i++)\\n    {\\n        // only iterate if letters are alphabeticaly continuous\\n        if (s[i + 1] == s[i] + 1)\\n        {\\n            current_len++;\\n\\n            // update the maximum length\\n            max_len = fmax(max_len, current_len);\\n        }"], ["int longestContinuousSubstring(char * s){\\n    int retVal = 1;\\n\\n    int count = 1;\\n    int len = strlen(s);\\n    int i;\\n    for (i=1; i<len; ++i)\\n    {\\n        if (s[i] - s[i-1] == 1)\\n        {\\n            ++count;\\n            retVal = (retVal>count)?retVal:count;\\n        }"]]}
{"id": "1612", "ref_c": [["struct TreeNode* reverseOddLevels(struct TreeNode* root){\\n    \\n        solve(root->left, root->right, 0);\\n        return root;\\n\\n}"], ["struct TreeNode* reverseOddLevels(struct TreeNode* root){\\n    \\n        solve(root->left, root->right, 0);\\n        return root;\\n\\n}"], ["struct TreeNode* reverseOddLevels(struct TreeNode* root){\\n    \\n        solve(root->left, root->right, 0);\\n        return root;\\n\\n}"]]}
{"id": "1613", "ref_c": [["int longestSubarray(int* nums, int numsSize){\\n    int k = 1;\\n    int ret = 0;\\n    int curr = 0;\\n    for(int i = 0;i<numsSize;i++){\\n        if(nums[i] == k){\\n            curr++;\\n            ret = ret > curr? ret : curr;\\n        }"], ["int longestSubarray(int* nums, int numsSize){\\n    int k = 1;\\n    int ret = 0;\\n    int curr = 0;\\n    for(int i = 0;i<numsSize;i++){\\n        if(nums[i] == k){\\n            curr++;\\n            ret = ret > curr? ret : curr;\\n        }"], ["int longestSubarray(int* nums, int numsSize){\\n    unsigned int max = 0;\\n    unsigned int maxCount = 0;\\n    unsigned int count = 0;\\n\\n    for (unsigned int i = 0; i < numsSize; i++) {\\n        if (nums[i] == max) {\\n            count++;\\n        }"]]}
{"id": "1614", "ref_c": [["int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    int *dec = calloc(numsSize, sizeof(int));\\n    int *inc = calloc(numsSize, sizeof(int));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }", "int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    *returnSize = 0;\\n\\n    uint32_t *dec = calloc(numsSize, sizeof(uint32_t));\\n    uint32_t *inc = calloc(numsSize, sizeof(uint32_t));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }"], ["int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    int *dec = calloc(numsSize, sizeof(int));\\n    int *inc = calloc(numsSize, sizeof(int));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }", "int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    *returnSize = 0;\\n\\n    uint32_t *dec = calloc(numsSize, sizeof(uint32_t));\\n    uint32_t *inc = calloc(numsSize, sizeof(uint32_t));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }"], ["int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    int *dec = calloc(numsSize, sizeof(int));\\n    int *inc = calloc(numsSize, sizeof(int));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }", "int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    *returnSize = 0;\\n\\n    uint32_t *dec = calloc(numsSize, sizeof(uint32_t));\\n    uint32_t *inc = calloc(numsSize, sizeof(uint32_t));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }"]]}
{"id": "1616", "ref_c": [["int xorAllNums(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n\\t\\t// both even\\n\\t\\tif(nums1Size%2==0 && nums2Size%2==0){\\n\\t\\t\\treturn 0;\\n\\t\\t}"], ["int xorAllNums(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    \\n    int result = 0;\\n    /* both even which means elements in both array will reapate even times and\\n    as we know even numbers exor is zero */\\n    if((!(nums1Size%2)) && (!(nums2Size%2)))\\n        return 0;\\n    \\n    /* if both odd which means we need to exor all the element in both the array to get result */\\n    if((nums1Size%2) && (nums2Size%2))\\n    {\\n        while(nums1Size || nums2Size)\\n        {\\n            if(nums1Size)\\n                result = result^nums1[--nums1Size];\\n            if(nums2Size)\\n                result = result^nums2[--nums2Size];\\n        }"], ["int xorAllNums(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n\\t\\t// both even\\n\\t\\tif(nums1Size%2==0 && nums2Size%2==0){\\n\\t\\t\\treturn 0;\\n\\t\\t}"]]}
{"id": "1617", "ref_c": [["int maxSum(int** grid, int gridSize, int* gridColSize){\\n    int maxSum = 0;\\n    for (int row = 0; row < gridSize-2; row++){\\n        for (int col = 0; col < *gridColSize-2; col++){\\n            // Creating a variable with the value of half the hourglass assigned\\n            int auxSum = grid[row+1][col+1];\\n            \\n            // Calculating the sum of the top and bottom of the hourglass\\n            for (int i = col; i <= col+2; i++){\\n                auxSum += grid[row][i] + grid[row+2][i];\\n            }"], ["int maxSum(int** grid, int gridSize, int* gridColSize){\\n\\t\\tif(gridSize==3 && *gridColSize==3){\\n\\t\\t\\treturn grid[0][0]+grid[0][1]+grid[0][2]+grid[1][1]+grid[2][0]+grid[2][1]+grid[2][2];\\n\\t\\t}"], ["int maxSum(int** grid, int gridSize, int* gridColSize){\\n    int maxSum = 0;\\n    for (int row = 0; row < gridSize-2; row++){\\n        for (int col = 0; col < *gridColSize-2; col++){\\n            // Creating a variable with the value of half the hourglass assigned\\n            int auxSum = grid[row+1][col+1];\\n            \\n            // Calculating the sum of the top and bottom of the hourglass\\n            for (int i = col; i <= col+2; i++){\\n                auxSum += grid[row][i] + grid[row+2][i];\\n            }"]]}
{"id": "1618", "ref_c": [["int minimizeXor(int num1, int num2) {\\n        vector<int> vec1(32, 0);\\n        int cnt2 = 0;\\n        int cnt1 = 0;\\n        for(int i = 0; i < 32; i++){\\n            if(num1 & (1 << i)){\\n                vec1[i] = 1;\\n                cnt1++;\\n            }"], ["int minimizeXor(int num1, int num2) {\\n        vector<int> vec1(32, 0);\\n        int cnt2 = 0;\\n        int cnt1 = 0;\\n        for(int i = 0; i < 32; i++){\\n            if(num1 & (1 << i)){\\n                vec1[i] = 1;\\n                cnt1++;\\n            }"], ["int minimizeXor(int num1, int num2) {\\n        vector<int> vec1(32, 0);\\n        int cnt2 = 0;\\n        int cnt1 = 0;\\n        for(int i = 0; i < 32; i++){\\n            if(num1 & (1 << i)){\\n                vec1[i] = 1;\\n                cnt1++;\\n            }"]]}
{"id": "1619", "ref_c": [["int* findArray(int* pref, int prefSize, int* returnSize) {\\n    if (prefSize <= 1) {\\n        *returnSize = prefSize;\\n        return pref;\\n    }"], ["int* findArray(int* pref, int prefSize, int* returnSize){\\n    int* ans = (int*)malloc(prefSize * sizeof(int));\\n    ans[0] = pref[0];\\n    for (int i = 1; i < prefSize; i++) {\\n        ans[i] = pref[i] ^ pref[i - 1];\\n    }"], ["int* findArray(int* pref, int prefSize, int* returnSize){\\n    int* ans = (int*)malloc(prefSize * sizeof(int));\\n    ans[0] = pref[0];\\n    for (int i = 1; i < prefSize; i++) {\\n        ans[i] = pref[i] ^ pref[i - 1];\\n    }"]]}
{"id": "1620", "ref_c": [["int smallestRepunitDivByK(int k){\\nint karan=1;\\nint j=0;\\nfor(int i=1;i<=k;i++)\\n{\\nj++;\\nif(karan%k==0)\\nreturn j;\\nelse\\nkaran=(karan*10+1)%k;\\n}"], ["int smallestRepunitDivByK(int k){\\nint karan=1;\\nint j=0;\\nfor(int i=1;i<=k;i++)\\n{\\nj++;\\nif(karan%k==0)\\nreturn j;\\nelse\\nkaran=(karan*10+1)%k;\\n}"], ["int smallestRepunitDivByK(int k){\\n    if(!(k & 1) || !(k % 5)) return -1;\\n    int rem = 0;\\n    for(int i = 1; i <= k; i++) \\n    {\\n        rem = (rem * 10 + 1) % k;   \\n        if(rem == 0) return i;\\n    }"]]}
{"id": "1621", "ref_c": [["int maximumProduct(int* nums, int numsSize) {\\n    int min1 = INT_MAX, min2 = INT_MAX;\\n    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;\\n\\n    for (int i = 0; i < numsSize; ++i) {\\n        updateMinMax(nums[i], &min1, &min2, &max1, &max2, &max3);\\n    }"], ["int maximumProduct(int* nums, int numsSize) {\\n    int min1 = INT_MAX, min2 = INT_MAX;\\n    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;\\n\\n    for (int i = 0; i < numsSize; ++i) {\\n        updateMinMax(nums[i], &min1, &min2, &max1, &max2, &max3);\\n    }"], ["int maximumProduct(int* nums, int numsSize) {\\n    int min1 = INT_MAX, min2 = INT_MAX;\\n    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;\\n\\n    for (int i = 0; i < numsSize; ++i) {\\n        updateMinMax(nums[i], &min1, &min2, &max1, &max2, &max3);\\n    }"]]}
{"id": "1622", "ref_c": [["int minimizeArrayValue(int* nums, int numsSize){\\n    double a= 0;double b= 0;\\n    for(int i= 0; i<numsSize; i++){\\n        b+=nums[i];\\n        if(a<=ceil(b/(i+1)))a=ceil(b/(i+1));\\n    }"], ["int minimizeArrayValue(int* nums, int numsSize){\\n    int best = nums[0];\\n    long long cum_sum = nums[0];\\n\\n    // Assume you have solved upto i-1\\n    // You can use your operations to pile up everything in the back.\\n    // So its in reverse sorted order.\\n    // ex: [5,5,5,4,3,2].\\n    // bests[i-1] = 5 in this case.\\n\\n    // The \"space\"\" behind us is\\n    // best[i-1]*(i-1) (i.e. if everything is all 5).\\n    // The amount used is cum_sum upto i-1.\\n\\n    // Above is lots of cruft.\\n    // Okay so simplifying everything down you get the following result.\\n    // best[i] = max(best[i-1], ceil(cum_sum/(i+1)))\\n\\n    for (int i=1; i<numsSize; i++) {\\n        cum_sum += nums[i];\\n        int even_dist = (cum_sum + i)/(i+1);\\n        best = best > even_dist ? best : even_dist;\\n    }"], ["int minimizeArrayValue(int* nums, int numsSize){\\n    int best = nums[0];\\n    long long cum_sum = nums[0];\\n\\n    // Assume you have solved upto i-1\\n    // You can use your operations to pile up everything in the back.\\n    // So its in reverse sorted order.\\n    // ex: [5,5,5,4,3,2].\\n    // bests[i-1] = 5 in this case.\\n\\n    // The \"space\"\" behind us is\\n    // best[i-1]*(i-1) (i.e. if everything is all 5).\\n    // The amount used is cum_sum upto i-1.\\n\\n    // Above is lots of cruft.\\n    // Okay so simplifying everything down you get the following result.\\n    // best[i] = max(best[i-1], ceil(cum_sum/(i+1)))\\n\\n    for (int i=1; i<numsSize; i++) {\\n        cum_sum += nums[i];\\n        int even_dist = (cum_sum + i)/(i+1);\\n        best = best > even_dist ? best : even_dist;\\n    }"]]}
{"id": "1623", "ref_c": [["int countDistinctIntegers(int* nums, int numsSize)\\n{\\n    int c = 0;\\n    for(int i = 0;i<numsSize;i++)\\n    {\\n        if(nums[0] == nums[i])\\n        c++;\\n    }"], ["int countDistinctIntegers(int* nums, int numsSize){\\n    int* hashCnt = (int*)calloc(1000001, sizeof(int));\\n    int ans = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        int rev = reverse(nums[i]);\\n        hashCnt[nums[i]]++;\\n        if(hashCnt[nums[i]]==1) ans++;\\n        hashCnt[rev]++;\\n        if(hashCnt[rev]==1) ans++;        \\n    }"], ["int countDistinctIntegers(int* nums, int numsSize){\\n    int* hashCnt = (int*)calloc(1000001, sizeof(int));\\n    int ans = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        int rev = reverse(nums[i]);\\n        hashCnt[nums[i]]++;\\n        if(hashCnt[nums[i]]==1) ans++;\\n        hashCnt[rev]++;\\n        if(hashCnt[rev]==1) ans++;        \\n    }"]]}
{"id": "1624", "ref_c": [["bool sumOfNumberAndReverse(int num) {\\n    char nums[10]; //num char\\uD615\\n    sprintf(nums, \"%d\", num);\\n    int len = strlen(nums); //nums\\uAE38\\uC774\\n\\n    char num1[10];//i \\uBC88\\uC9F8 \\uC22B\\uC790\\n    char num2[10];//i \\uBC88\\uC9F8 \\uC22B\\uC790 \\uAC70\\uAFB8\\uB85C\\n\\n    int inum1 = 0;//num1 \\uC22B\\uC790 \\uBC84\\uC804\\n    int inum2 = 0;//num2 \\uC22B\\uC790 \\uBC84\\uC804\\n\\n    if(num == 0){// \\uC608\\uC678 \\uC0C1\\uD669\\uC774\\uB77C\\uC11C\\n        return true;\\n    }"], ["bool sumOfNumberAndReverse(int num){\\n    int n1=0,n2=0;\\n    if(num>0)\\n   {\\n        for(int i=0;i<num;i++)\\n        {\\n            n1=i;\\n            int temp=0;\\n            for(int j=i;j>0;)\\n            {\\n                temp=(temp*10)+(j%10);\\n                j/=10;\\n            }"], ["bool sumOfNumberAndReverse(int num){\\n        int A,B;\\n        for(int i=0;i<=num;i++){\\n            A=i;\\n            if(A>=0 && A<=9)\\n                B=A;\\n            else{\\n                int j=A;\\n                B=0;\\n                while(j){\\n                    int m=j%10;\\n                    B=(B*10)+m;\\n                    j/=10;\\n                }"]]}
{"id": "1625", "ref_c": ["\nstatic int calcGcd(int num1, int num2){\n\twhile (num2 != 0){\n\t\tconst int remainder = num1 % num2;\n\n\t\tnum1 = num2;\n\t\tnum2 = remainder;\n\t}\n\treturn num1;\n}\n\nint subarrayGCD(\n\tconst int * const nums,\n\tconst int numsLen,\n\tconst int target\n){\n\tassert(target >= 1);\n\n\tint cnt = 0;\n\n\tint dp[numsLen];\n\tfor (int i = 0; i < numsLen; i += 1){\n\t\tassert(nums[i] >= 1);\n\n\t\tif (!( nums[i] >= target )){\n\t\t\tmemset( dp, -1, sizeof (int) * (1 + i) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp[i] = nums[i];\n\t\tif (dp[i] == target){\n\t\t\tcnt += 1;\n\t\t}\n\n\t\tfor (int j = i - 1; j >= 0; j -= 1){\n\t\t\tif (-1 == dp[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdp[j] = calcGcd(dp[j], nums[i]);\n\t\t\tif (!( dp[j] >= target )){\n\t\t\t\tdp[j] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (dp[j] == target){\n\t\t\t\tcnt += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n", "\nstatic int calcGcd(int num1, int num2){\n\twhile (num2 != 0){\n\t\tconst int remainder = num1 % num2;\n\n\t\tnum1 = num2;\n\t\tnum2 = remainder;\n\t}\n\treturn num1;\n}\n\nint subarrayGCD(\n\tconst int * const nums,\n\tconst int numsLen,\n\tconst int target\n){\n\tassert(target >= 1);\n\n\tint cnt = 0;\n\n\tint dp[numsLen];\n\tfor (int i = 0; i < numsLen; i += 1){\n\t\tassert(nums[i] >= 1);\n\n\t\tif (!( nums[i] >= target )){\n\t\t\tmemset( dp, -1, sizeof (int) * (1 + i) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp[i] = nums[i];\n\t\tif (dp[i] == target){\n\t\t\tcnt += 1;\n\t\t}\n\n\t\tfor (int j = i - 1; j >= 0; j -= 1){\n\t\t\tif (-1 == dp[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdp[j] = calcGcd(dp[j], nums[i]);\n\t\t\tif (!( dp[j] >= target )){\n\t\t\t\tdp[j] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (dp[j] == target){\n\t\t\t\tcnt += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n", "\nstatic int calcGcd(int num1, int num2){\n\twhile (num2 != 0){\n\t\tconst int remainder = num1 % num2;\n\n\t\tnum1 = num2;\n\t\tnum2 = remainder;\n\t}\n\treturn num1;\n}\n\nint subarrayGCD(\n\tconst int * const nums,\n\tconst int numsLen,\n\tconst int target\n){\n\tassert(target >= 1);\n\n\tint cnt = 0;\n\n\tint dp[numsLen];\n\tfor (int i = 0; i < numsLen; i += 1){\n\t\tassert(nums[i] >= 1);\n\n\t\tif (!( nums[i] >= target )){\n\t\t\tmemset( dp, -1, sizeof (int) * (1 + i) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp[i] = nums[i];\n\t\tif (dp[i] == target){\n\t\t\tcnt += 1;\n\t\t}\n\n\t\tfor (int j = i - 1; j >= 0; j -= 1){\n\t\t\tif (-1 == dp[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdp[j] = calcGcd(dp[j], nums[i]);\n\t\t\tif (!( dp[j] >= target )){\n\t\t\t\tdp[j] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (dp[j] == target){\n\t\t\t\tcnt += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n"]}
{"id": "1626", "ref_c": [["char ** twoEditWords(char ** queries, int queriesSize, char ** dictionary, int dictionarySize, int* returnSize){\\n    char **res = (char **)malloc(sizeof(char *) * queriesSize);\\n    memset(res, 0, sizeof(char *) * queriesSize);\\n    int index = 0;\\n\\n    for (int i = 0; i < queriesSize; i++) {\\n        for (int j = 0; j < dictionarySize; j++) {\\n            if (valid(queries[i], dictionary[j])) {\\n\\n                res[index] = (char *)malloc(sizeof(char) * MAX_LEN);\\n                memset(res[index], 0, sizeof(char) * MAX_LEN);\\n\\n                //     res[index] = queries[i];\\n                strcpy(res[index], queries[i]);\\n                index++;\\n                break;\\n            }"], ["char ** twoEditWords(char ** queries, int queriesSize, char ** dictionary, int dictionarySize, int* returnSize){\\n    char **res = (char **)malloc(sizeof(char *) * queriesSize);\\n    memset(res, 0, sizeof(char *) * queriesSize);\\n    int index = 0;\\n\\n    for (int i = 0; i < queriesSize; i++) {\\n        for (int j = 0; j < dictionarySize; j++) {\\n            if (valid(queries[i], dictionary[j])) {\\n\\n                res[index] = (char *)malloc(sizeof(char) * MAX_LEN);\\n                memset(res[index], 0, sizeof(char) * MAX_LEN);\\n\\n                //     res[index] = queries[i];\\n                strcpy(res[index], queries[i]);\\n                index++;\\n                break;\\n            }"], ["char ** twoEditWords(char ** queries, int queriesSize, char ** dictionary, int dictionarySize, int* returnSize){\\n    char **res = (char **)malloc(sizeof(char *) * queriesSize);\\n    memset(res, 0, sizeof(char *) * queriesSize);\\n    int index = 0;\\n\\n    for (int i = 0; i < queriesSize; i++) {\\n        for (int j = 0; j < dictionarySize; j++) {\\n            if (valid(queries[i], dictionary[j])) {\\n\\n                res[index] = (char *)malloc(sizeof(char) * MAX_LEN);\\n                memset(res[index], 0, sizeof(char) * MAX_LEN);\\n\\n                //     res[index] = queries[i];\\n                strcpy(res[index], queries[i]);\\n                index++;\\n                break;\\n            }"]]}
{"id": "1627", "ref_c": [["int maxProfit(int* prices, int pricesSize) {\\n if(pricesSize==1) return 0;\\n int cooldown=0;\\n int buy=1;\\n int index=0;\\n int *** dp= (int***)malloc(sizeof(int**)*pricesSize);\\n for(int i=0;i<pricesSize;i++){\\n     dp[i]=(int**)malloc(sizeof(int*)*2);\\n     for(int j=0;j<2;j++){\\n         dp[i][j]=(int*)malloc(sizeof(int)*2);\\n     }"], ["int maxProfit(int* prices, int pricesSize){\\n    if(pricesSize == 1) return 0;\\n\\n    // declare buy, sell & cooldown state machine and input first price\\n    int anBuy[2] = {-(*prices), 0}"], ["int maxProfit(int* prices, int pricesSize) {\\n if(pricesSize==1) return 0;\\n int cooldown=0;\\n int buy=1;\\n int index=0;\\n int *** dp= (int***)malloc(sizeof(int**)*pricesSize);\\n for(int i=0;i<pricesSize;i++){\\n     dp[i]=(int**)malloc(sizeof(int*)*2);\\n     for(int j=0;j<2;j++){\\n         dp[i][j]=(int*)malloc(sizeof(int)*2);\\n     }"]]}
{"id": "1628", "ref_c": [["int waysToMakeFair(int* nums, int numsSize){\\n    int result = 0, even_sum = 0, odd_sum = 0, even = 0, odd = 0;\\n    int *tmp = nums;\\n    while(tmp != nums + numsSize){\\n        if((tmp - nums) & 1) odd_sum += *tmp;\\n        else even_sum += *tmp;\\n        tmp++;\\n    }"], ["int waysToMakeFair(int* nums, int numsSize){\\n    int odd[numsSize], even[numsSize];\\n    bzero(odd, numsSize * sizeof(int));\\n    bzero(even, numsSize * sizeof(int));\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i == 0) {\\n            even[i] = nums[i];\\n        }"], ["int waysToMakeFair(int* nums, int numsSize){\\n    int result = 0, even_sum = 0, odd_sum = 0, even = 0, odd = 0;\\n    int *tmp = nums;\\n    while(tmp != nums + numsSize){\\n        if((tmp - nums) & 1) odd_sum += *tmp;\\n        else even_sum += *tmp;\\n        tmp++;\\n    }"]]}
{"id": "1629", "ref_c": [["long long makeIntegerBeautiful(long long n, int target){\\n    long k=1;\\n    long long t=n;\\n    while(sumof(t)>target)\\n    {\\n        t=t/10+1;\\n        k=k*10;\\n    }"], ["long long makeIntegerBeautiful(long long n, int target){\\n    long k=1;\\n    long long t=n;\\n    while(sumof(t)>target)\\n    {\\n        t=t/10+1;\\n        k=k*10;\\n    }"], ["long long makeIntegerBeautiful(long long n, int target){\\n    long k=1;\\n    long long t=n;\\n    while(sumof(t)>target)\\n    {\\n        t=t/10+1;\\n        k=k*10;\\n    }"]]}
{"id": "1630", "ref_c": [["int projectionArea(int** grid, int gridSize, int* gridColSize){\\n    int sum=0;\\n    // find x-y plane, y-z plane , x-z plane\\n    for(int row=0;row<gridSize;row++){\\n        int x_z_plane=0,y_z_plane=0;\\n        for(int col=0;col<*gridColSize;col++){\\n            x_z_plane=max(x_z_plane,grid[row][col]);\\n            y_z_plane=max(y_z_plane,grid[col][row]);\\n            if(grid[row][col]) ++sum; // x-y plane\\n        }"], ["int projectionArea(int** grid, int gridSize, int* gridColSize) {\\n    int numsOfXY = gridSize * gridColSize[0];\\n    int numsOfXZ = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        int max = grid[i][0];\\n        for (int j = 0; j < gridColSize[0]; j++) {\\n            max = MAX(max, grid[i][j]);\\n            if (!grid[i][j]) numsOfXY--;\\n        }"], ["int projectionArea(int** grid, int gridSize, int* gridColSize){\\n    int sum = 0, maxInCol = 0, maxInRow = 0;\\n    for(int i=0; i<gridSize; i++)\\n    {\\n        for(int j=0; j<*gridColSize; j++)\\n        {\\n            if(grid[i][j] != 0)\\n                sum += 1;\\n            maxInCol = maxInCol < grid[i][j] ? grid[i][j] : maxInCol;\\n        }"]]}
{"id": "1631", "ref_c": ["\ntypedef struct{\n    int idx;\n    int cost;\n} Elem;\n\nvoid dumpMinHeap(Elem* m, int size){\n    printf(\"[\");\n\n    for(int i = 0; i < size; i++){\n        printf(\"(%d,%d,%d)\", i, m[i].cost, m[i].idx);\n        if(i < size - 1) printf(\",\");\n    }\n\n    printf(\"]\n\");\n}\n\nvoid swap(Elem* arr, int i, int j){\n    Elem tmp;\n    tmp.cost = arr[i].cost;\n    tmp.idx = arr[i].idx;\n\n    arr[i].cost = arr[j].cost;\n    arr[i].idx = arr[j].idx;\n    \n    arr[j].cost = tmp.cost;\n    arr[j].idx = tmp.idx;\n}\n\nbool minorElem(Elem a, Elem b){\n    return a.cost < b.cost || (a.cost == b.cost && a.idx < b.idx);\n}\n\nvoid bUp(Elem* minHeap, int i){\n    int f;\n\n    while(i > 0){\n        f = FATHER(i);\n        if(minorElem(minHeap[i], minHeap[f])){\n            swap(minHeap, i, f);\n            i = f;\n        }\n\n        else break;\n    }\n}\n\nvoid bDown(Elem* minHeap, int i, int n){\n    int l = LEFT(i);\n\n    while(l < n){\n        if(l + 1 < n && minorElem(minHeap[l+1], minHeap[l])) l++;\n\n        if(minorElem(minHeap[l], minHeap[i])){\n            swap(minHeap, i, l);\n            i = l;\n            l = LEFT(i);\n        }\n\n        else break;\n    }\n}\n\nvoid insertMinHeapUp(Elem* minHeap, int pos, int cost, int idx){\n    minHeap[pos].cost = cost;\n    minHeap[pos].idx = idx;\n    bUp(minHeap, pos);\n}\n\nvoid insertMinHeapDown(Elem* minHeap, int size, int cost, int idx){\n    minHeap[0].cost = cost;\n    minHeap[0].idx = idx;\n    bDown(minHeap, 0, size);\n}\n\nlong long totalCost(int* costs, int costsSize, int k, int candidates){\n    long long ans = 0;\n    int front = 0, back = 0, worker;\n    Elem* left = malloc(candidates * sizeof(Elem));\n    Elem* right = malloc(candidates * sizeof(Elem));\n\n    for(int i = 0; i < candidates; i++){\n        insertMinHeapUp(left, i, costs[i], i);\n    }\n\n    for(int i = costsSize - 1; i >= costsSize - candidates; i--){\n        /* Check if we can insert new element */\n        if(i >= candidates) insertMinHeapUp(right, costsSize - 1 - i, costs[i], i);\n        else insertMinHeapUp(right, costsSize - 1 - i, INT_MAX, INT_MAX);\n    }\n\n    for(int i = 0; i < k; i++){\n\n        /* Select minor element from both heap */\n        if(minorElem(left[0], right[0])){\n            ans += left[0].cost;\n\n            /* Check if we can insert new element */\n            if(candidates + front - 1 < costsSize - candidates - back - 1){\n                insertMinHeapDown(left, candidates, costs[candidates + front], candidates + front);\n            }\n\n            else {\n                insertMinHeapDown(left, candidates, INT_MAX, INT_MAX);\n            }\n\n            front++;\n        }\n\n        else {\n            ans += right[0].cost;\n\n            /* Check if we can insert new element */\n            if(candidates + front - 1 < costsSize - candidates - back - 1){\n                insertMinHeapDown(right, candidates, costs[costsSize - candidates - back - 1], costsSize - candidates - back - 1);\n            }\n\n            else {\n                insertMinHeapDown(right, candidates, INT_MAX, INT_MAX);\n            }\n\n            back++;\n        }\n    }\n\n    free(left);\n    free(right);\n\n    return ans;\n}\n", "\ntypedef struct{\n    int idx;\n    int cost;\n} Elem;\n\nvoid dumpMinHeap(Elem* m, int size){\n    printf(\"[\");\n\n    for(int i = 0; i < size; i++){\n        printf(\"(%d,%d,%d)\", i, m[i].cost, m[i].idx);\n        if(i < size - 1) printf(\",\");\n    }\n\n    printf(\"]\n\");\n}\n\nvoid swap(Elem* arr, int i, int j){\n    Elem tmp;\n    tmp.cost = arr[i].cost;\n    tmp.idx = arr[i].idx;\n\n    arr[i].cost = arr[j].cost;\n    arr[i].idx = arr[j].idx;\n    \n    arr[j].cost = tmp.cost;\n    arr[j].idx = tmp.idx;\n}\n\nbool minorElem(Elem a, Elem b){\n    return a.cost < b.cost || (a.cost == b.cost && a.idx < b.idx);\n}\n\nvoid bUp(Elem* minHeap, int i){\n    int f;\n\n    while(i > 0){\n        f = FATHER(i);\n        if(minorElem(minHeap[i], minHeap[f])){\n            swap(minHeap, i, f);\n            i = f;\n        }\n\n        else break;\n    }\n}\n\nvoid bDown(Elem* minHeap, int i, int n){\n    int l = LEFT(i);\n\n    while(l < n){\n        if(l + 1 < n && minorElem(minHeap[l+1], minHeap[l])) l++;\n\n        if(minorElem(minHeap[l], minHeap[i])){\n            swap(minHeap, i, l);\n            i = l;\n            l = LEFT(i);\n        }\n\n        else break;\n    }\n}\n\nvoid insertMinHeapUp(Elem* minHeap, int pos, int cost, int idx){\n    minHeap[pos].cost = cost;\n    minHeap[pos].idx = idx;\n    bUp(minHeap, pos);\n}\n\nvoid insertMinHeapDown(Elem* minHeap, int size, int cost, int idx){\n    minHeap[0].cost = cost;\n    minHeap[0].idx = idx;\n    bDown(minHeap, 0, size);\n}\n\nlong long totalCost(int* costs, int costsSize, int k, int candidates){\n    long long ans = 0;\n    int front = 0, back = 0, worker;\n    Elem* left = malloc(candidates * sizeof(Elem));\n    Elem* right = malloc(candidates * sizeof(Elem));\n\n    for(int i = 0; i < candidates; i++){\n        insertMinHeapUp(left, i, costs[i], i);\n    }\n\n    for(int i = costsSize - 1; i >= costsSize - candidates; i--){\n        /* Check if we can insert new element */\n        if(i >= candidates) insertMinHeapUp(right, costsSize - 1 - i, costs[i], i);\n        else insertMinHeapUp(right, costsSize - 1 - i, INT_MAX, INT_MAX);\n    }\n\n    for(int i = 0; i < k; i++){\n\n        /* Select minor element from both heap */\n        if(minorElem(left[0], right[0])){\n            ans += left[0].cost;\n\n            /* Check if we can insert new element */\n            if(candidates + front - 1 < costsSize - candidates - back - 1){\n                insertMinHeapDown(left, candidates, costs[candidates + front], candidates + front);\n            }\n\n            else {\n                insertMinHeapDown(left, candidates, INT_MAX, INT_MAX);\n            }\n\n            front++;\n        }\n\n        else {\n            ans += right[0].cost;\n\n            /* Check if we can insert new element */\n            if(candidates + front - 1 < costsSize - candidates - back - 1){\n                insertMinHeapDown(right, candidates, costs[costsSize - candidates - back - 1], costsSize - candidates - back - 1);\n            }\n\n            else {\n                insertMinHeapDown(right, candidates, INT_MAX, INT_MAX);\n            }\n\n            back++;\n        }\n    }\n\n    free(left);\n    free(right);\n\n    return ans;\n}\n", "\ntypedef struct{\n    int idx;\n    int cost;\n} Elem;\n\nvoid dumpMinHeap(Elem* m, int size){\n    printf(\"[\");\n\n    for(int i = 0; i < size; i++){\n        printf(\"(%d,%d,%d)\", i, m[i].cost, m[i].idx);\n        if(i < size - 1) printf(\",\");\n    }\n\n    printf(\"]\n\");\n}\n\nvoid swap(Elem* arr, int i, int j){\n    Elem tmp;\n    tmp.cost = arr[i].cost;\n    tmp.idx = arr[i].idx;\n\n    arr[i].cost = arr[j].cost;\n    arr[i].idx = arr[j].idx;\n    \n    arr[j].cost = tmp.cost;\n    arr[j].idx = tmp.idx;\n}\n\nbool minorElem(Elem a, Elem b){\n    return a.cost < b.cost || (a.cost == b.cost && a.idx < b.idx);\n}\n\nvoid bUp(Elem* minHeap, int i){\n    int f;\n\n    while(i > 0){\n        f = FATHER(i);\n        if(minorElem(minHeap[i], minHeap[f])){\n            swap(minHeap, i, f);\n            i = f;\n        }\n\n        else break;\n    }\n}\n\nvoid bDown(Elem* minHeap, int i, int n){\n    int l = LEFT(i);\n\n    while(l < n){\n        if(l + 1 < n && minorElem(minHeap[l+1], minHeap[l])) l++;\n\n        if(minorElem(minHeap[l], minHeap[i])){\n            swap(minHeap, i, l);\n            i = l;\n            l = LEFT(i);\n        }\n\n        else break;\n    }\n}\n\nvoid insertMinHeapUp(Elem* minHeap, int pos, int cost, int idx){\n    minHeap[pos].cost = cost;\n    minHeap[pos].idx = idx;\n    bUp(minHeap, pos);\n}\n\nvoid insertMinHeapDown(Elem* minHeap, int size, int cost, int idx){\n    minHeap[0].cost = cost;\n    minHeap[0].idx = idx;\n    bDown(minHeap, 0, size);\n}\n\nlong long totalCost(int* costs, int costsSize, int k, int candidates){\n    long long ans = 0;\n    int front = 0, back = 0, worker;\n    Elem* left = malloc(candidates * sizeof(Elem));\n    Elem* right = malloc(candidates * sizeof(Elem));\n\n    for(int i = 0; i < candidates; i++){\n        insertMinHeapUp(left, i, costs[i], i);\n    }\n\n    for(int i = costsSize - 1; i >= costsSize - candidates; i--){\n        /* Check if we can insert new element */\n        if(i >= candidates) insertMinHeapUp(right, costsSize - 1 - i, costs[i], i);\n        else insertMinHeapUp(right, costsSize - 1 - i, INT_MAX, INT_MAX);\n    }\n\n    for(int i = 0; i < k; i++){\n\n        /* Select minor element from both heap */\n        if(minorElem(left[0], right[0])){\n            ans += left[0].cost;\n\n            /* Check if we can insert new element */\n            if(candidates + front - 1 < costsSize - candidates - back - 1){\n                insertMinHeapDown(left, candidates, costs[candidates + front], candidates + front);\n            }\n\n            else {\n                insertMinHeapDown(left, candidates, INT_MAX, INT_MAX);\n            }\n\n            front++;\n        }\n\n        else {\n            ans += right[0].cost;\n\n            /* Check if we can insert new element */\n            if(candidates + front - 1 < costsSize - candidates - back - 1){\n                insertMinHeapDown(right, candidates, costs[costsSize - candidates - back - 1], costsSize - candidates - back - 1);\n            }\n\n            else {\n                insertMinHeapDown(right, candidates, INT_MAX, INT_MAX);\n            }\n\n            back++;\n        }\n    }\n\n    free(left);\n    free(right);\n\n    return ans;\n}\n"]}
{"id": "1632", "ref_c": [["int countGoodStrings(int low, int high, int zero, int one) {\\n       \\n\\t   vector<long long>arr(200005);\\n        long long res = 0;\\n        arr[0] = 1;\\n        for(int i = 0; i < 100005; i++){\\n            arr[i + zero]= arr[i + zero]%mod;\\n            arr[i + zero] += arr[i];\\n            arr[i + one]=arr[i + one]%mod;\\n           arr[i + one] += arr[i];\\n        }"], ["int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int>dp(high+1,-1);\\n        // intially take the length of the string as 0.\\n        return solve(0,low,high,zero,one,dp);\\n    }"], ["int countGoodStrings(int low, int high, int zero, int one) {\\n    const int MOD = 1000000007;\\n    int DP[high + 1];\\n    int ans = 0;\\n    DP[0] = 1;\\n    for(int i = 1; i <= high; i++) {\\n        DP[i] = ((i >= zero ? DP[i - zero] : 0) + (i >= one ? DP[i - one] : 0)) % MOD;\\n        if(i >= low && i <= high)\\n            ans = (ans + DP[i]) % MOD;\\n    }"]]}
{"id": "1633", "ref_c": [["int dominantIndex(int* nums, int numsSize){\\n    int max = INT_MIN, secondMax = INT_MIN, maxIndex = -1;\\n    for(int i = 0; i < numsSize; i++) {\\n        if(nums[i] > max) {\\n            secondMax = max;\\n            max = nums[i];\\n            maxIndex = i;\\n        }"], ["int dominantIndex(int* nums, int numsSize){\\n    int max = INT_MIN, secondMax = INT_MIN, maxIndex = -1;\\n    for(int i = 0; i < numsSize; i++) {\\n        if(nums[i] > max) {\\n            secondMax = max;\\n            max = nums[i];\\n            maxIndex = i;\\n        }"], ["int dominantIndex(int* nums, int numsSize){\\n    int max = INT_MIN, secondMax = INT_MIN, maxIndex = -1;\\n    for(int i = 0; i < numsSize; i++) {\\n        if(nums[i] > max) {\\n            secondMax = max;\\n            max = nums[i];\\n            maxIndex = i;\\n        }"]]}
{"id": "1634", "ref_c": [["int isPrefixOfWord(char * sentence, char * searchWord){\\nchar* words[1000];\\nint start=0,end=0,x=0;\\nfor(start=0,end=0;;end++){\\nif(sentence[end]==\\' \\'||sentence[end]==0){\\nwords[x++]=(&sentence[start]);\\nif(sentence[end]!=0){\\n    start=end+1;\\n    sentence[end]=0;\\n}"], ["int isPrefixOfWord(char * sentence, char * searchWord){\\nchar* words[1000];\\nint start=0,end=0,x=0;\\nfor(start=0,end=0;;end++){\\nif(sentence[end]==\\' \\'||sentence[end]==0){\\nwords[x++]=(&sentence[start]);\\nif(sentence[end]!=0){\\n    start=end+1;\\n    sentence[end]=0;\\n}"], ["int isPrefixOfWord(char * sentence, char * searchWord){\\n    int wordIdx = 1;\\n    \\n    char * searchPtr;\\n    \\n    while(*sentence != \\'\\\\0\\'){\\n        searchPtr = searchWord;\\n        \\n        while(*sentence == *searchPtr && *searchPtr != \\'\\\\0\\'){\\n            ++sentence;\\n            ++searchPtr;\\n        }"]]}
{"id": "1635", "ref_c": [["int minimumOperations(struct TreeNode* root){\\n    struct TreeNode* list[MAX_POINT];\\n    \\n    int number[MAX_SAME_LEVEL];\\n    int increasing[MAX_SAME_LEVEL];\\n    int switch_number[MAX_POINT];\\n    \\n    int num_count = 0;\\n    int point = 0;\\n    list[0] = root;\\n    int count = 1;\\n    int ans = 0;\\n    while (point < count){\\n        num_count = 0;\\n        for (int end = count ; point < end ; point++){\\n            if (list[point]->left != NULL){\\n                number[num_count] = list[point]->left->val;\\n                increasing[num_count] = number[num_count];\\n                num_count++;\\n                list[count] = list[point]->left;\\n                count++;\\n            }"], ["int minimumOperations(struct TreeNode* root){\\n    struct TreeNode* list[MAX_POINT];\\n    \\n    int number[MAX_SAME_LEVEL];\\n    int increasing[MAX_SAME_LEVEL];\\n    int switch_number[MAX_POINT];\\n    \\n    int num_count = 0;\\n    int point = 0;\\n    list[0] = root;\\n    int count = 1;\\n    int ans = 0;\\n    while (point < count){\\n        num_count = 0;\\n        for (int end = count ; point < end ; point++){\\n            if (list[point]->left != NULL){\\n                number[num_count] = list[point]->left->val;\\n                increasing[num_count] = number[num_count];\\n                num_count++;\\n                list[count] = list[point]->left;\\n                count++;\\n            }"], ["int minimumOperations(struct TreeNode* root){\\n    struct TreeNode* list[MAX_POINT];\\n    \\n    int number[MAX_SAME_LEVEL];\\n    int increasing[MAX_SAME_LEVEL];\\n    int switch_number[MAX_POINT];\\n    \\n    int num_count = 0;\\n    int point = 0;\\n    list[0] = root;\\n    int count = 1;\\n    int ans = 0;\\n    while (point < count){\\n        num_count = 0;\\n        for (int end = count ; point < end ; point++){\\n            if (list[point]->left != NULL){\\n                number[num_count] = list[point]->left->val;\\n                increasing[num_count] = number[num_count];\\n                num_count++;\\n                list[count] = list[point]->left;\\n                count++;\\n            }"]]}
{"id": "1636", "ref_c": [["int maxConsecutive(int bottom, int top, int* special, int specialSize){\\n    qsort(special,specialSize,sizeof(int),cmp);\\n    int ans=fmax(fmax(special[0],bottom)-bottom,fmax(special[specialSize-1],top)-special[specialSize-1]);\\n    for(int i=1;i<specialSize;i++){\\n        ans=fmax(special[i]-special[i-1]-1,ans);\\n    }"], ["int maxConsecutive(int bottom, int top, int* special, int specialSize) {\\n    qsort(special, specialSize, sizeof(int), cmp);\\n    int len = fmax(special[0] - bottom, top - special[specialSize - 1]);\\n    for (int i = 1; i < specialSize; i++) {\\n        if (special[i] - special[i - 1] > 1) len = fmax(special[i] - special[i - 1] - 1, len);\\n    }"], ["int maxConsecutive(int bottom, int top, int* special, int specialSize) {\\n    qsort(special, specialSize, sizeof(int), cmp);\\n    int len = fmax(special[0] - bottom, top - special[specialSize - 1]);\\n    for (int i = 1; i < specialSize; i++) {\\n        if (special[i] - special[i - 1] > 1) len = fmax(special[i] - special[i - 1] - 1, len);\\n    }"]]}
{"id": "1637", "ref_c": [["long long minimumFuelCost(int** roads, int roadsSize, int* roadsColSize, int seats){\\n    int *L = calloc(roadsSize + 1, sizeof(int));\\n    int **edge_list = malloc(sizeof(int *) *(roadsSize + 1));\\n    int *edge_size = calloc(roadsSize + 1, sizeof(int));\\n    for(int i = 0; i < roadsSize; i++){\\n        edge_size[roads[i][0]]++;\\n        edge_size[roads[i][1]]++;\\n    }"], ["long long minimumFuelCost(int** roads, int roadsSize, int* roadsColSize, int seats) {\\n\\tint n = roadsSize + 1;\\n\\n\\t/* Counting sort to group connections by source city */\\n\\tint* connections = malloc(roadsSize * 2 * sizeof(*connections));\\n\\tint* connections_end = calloc(n, sizeof(*connections_end));\\n\\tfor (int i = 0; i < roadsSize; ++i) {\\n\\t\\t++connections_end[roads[i][0]];\\n\\t\\t++connections_end[roads[i][1]];\\n\\t}"], ["long long minimumFuelCost(int** roads, int roadsSize, int* roadsColSize, int seats) {\\n\\tint n = roadsSize + 1;\\n\\n\\t/* Counting sort to group connections by source city */\\n\\tint* connections = malloc(roadsSize * 2 * sizeof(*connections));\\n\\tint* connections_end = calloc(n, sizeof(*connections_end));\\n\\tfor (int i = 0; i < roadsSize; ++i) {\\n\\t\\t++connections_end[roads[i][0]];\\n\\t\\t++connections_end[roads[i][1]];\\n\\t}"]]}
{"id": "1638", "ref_c": [["int** onesMinusZeros(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes) {\\n    int rows = gridSize;\\n    int cols = gridColSize[0];\\n\\n    /* Initialize result matrix */\\n    int **result = (int **)calloc(rows, sizeof(int *));\\n    *returnSize = rows;\\n    *returnColumnSizes = (int *)malloc(rows * sizeof(int));\\n    if (!result || !*returnColumnSizes) {\\n        return NULL;\\n    }"], ["int** onesMinusZeros(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes) {\\n    int rows = gridSize;\\n    int cols = gridColSize[0];\\n\\n    /* Initialize result matrix */\\n    int **result = (int **)calloc(rows, sizeof(int *));\\n    *returnSize = rows;\\n    *returnColumnSizes = (int *)malloc(rows * sizeof(int));\\n    if (!result || !*returnColumnSizes) {\\n        return NULL;\\n    }"], ["int** onesMinusZeros(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes) {\\n    int rows = gridSize;\\n    int cols = gridColSize[0];\\n\\n    /* Initialize result matrix */\\n    int **result = (int **)calloc(rows, sizeof(int *));\\n    *returnSize = rows;\\n    *returnColumnSizes = (int *)malloc(rows * sizeof(int));\\n    if (!result || !*returnColumnSizes) {\\n        return NULL;\\n    }"]]}
{"id": "1639", "ref_c": [["int bestClosingTime(char * customers){\\n    int bestTime = 0, penaltyDiff = 0;\\n\\n    for (int i = 0, len = strlen(customers); i < len; i++) {\\n        if (customers[i] == \\'Y\\') penaltyDiff--;\\n        else penaltyDiff++;\\n\\n        if (penaltyDiff < 0) {\\n            penaltyDiff = 0;\\n            bestTime = i + 1;\\n        }"], ["int bestClosingTime(char * customers){\\n    int bestTime = 0, penaltyDiff = 0;\\n\\n    for (int i = 0, len = strlen(customers); i < len; i++) {\\n        if (customers[i] == \\'Y\\') penaltyDiff--;\\n        else penaltyDiff++;\\n\\n        if (penaltyDiff < 0) {\\n            penaltyDiff = 0;\\n            bestTime = i + 1;\\n        }"], ["int bestClosingTime(char * customers){\\n    int bestTime = 0, penaltyDiff = 0;\\n\\n    for (int i = 0, len = strlen(customers); i < len; i++) {\\n        if (customers[i] == \\'Y\\') penaltyDiff--;\\n        else penaltyDiff++;\\n\\n        if (penaltyDiff < 0) {\\n            penaltyDiff = 0;\\n            bestTime = i + 1;\\n        }"]]}
{"id": "1640", "ref_c": [["int* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    bool *hash = calloc(n, sizeof(bool));\\n    (*returnSize) = 0;\\n    for(int i = 0; i < edgesSize; i++){\\n        if(hash[edges[i][1]] == false){\\n            (*returnSize)++;\\n            hash[edges[i][1]] = true;\\n        }"], ["int* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    bool* inDegree = calloc(n, sizeof(bool));\\n    int numOfVertices = n;\\n\\n    for(int i = 0; i < edgesSize; i++)\\n    {\\n        if(inDegree[edges[i][1]] == false)\\n        {\\n            inDegree[edges[i][1]] = true;\\n            numOfVertices--;\\n        }"], ["int* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    bool *hash = calloc(n, sizeof(bool));\\n    (*returnSize) = 0;\\n    for(int i = 0; i < edgesSize; i++){\\n        if(hash[edges[i][1]] == false){\\n            (*returnSize)++;\\n            hash[edges[i][1]] = true;\\n        }"]]}
{"id": "1641", "ref_c": [["struct ListNode* removeNodes(struct ListNode* head){\\n    struct ListNode *tmp, *rvr;\\n    tmp=NULL;\\n    rvr=head; \\n \\n//1. Reverse Linked list.//\\n    while (head!=NULL)\\n    {\\n        head=head->next;\\n        rvr->next=tmp;\\n        tmp=rvr;\\n        rvr=head;\\n    }"], ["struct ListNode* removeNodes(struct ListNode* head){\\n    struct ListNode *tmp, *rvr;\\n    tmp=NULL;\\n    rvr=head; \\n \\n//1. Reverse Linked list.//\\n    while (head!=NULL)\\n    {\\n        head=head->next;\\n        rvr->next=tmp;\\n        tmp=rvr;\\n        rvr=head;\\n    }"], ["struct ListNode* removeNodes(struct ListNode* head){\\n\\n    /*\\n     * Input:\\n     *  head\\n     */\\n\\n    struct ListNode *reverse = NULL, *tmp;\\n    int max = INT_MIN;\\n\\n    /* Reverse the linked list, the order of new list is from right to left */\\n    for (; head; ) {\\n        tmp = head;\\n        head = head->next;\\n        tmp->next = reverse;\\n        reverse = tmp;\\n    }"]]}
{"id": "1642", "ref_c": [["long long dividePlayers(int* skill, int skillSize){\\n    int* hashCnt = (int*)calloc(1001, sizeof(int));\\n    int l = 1000, r = 0;\\n    for(int i = 0; i < skillSize; i++){\\n        hashCnt[skill[i]]++;\\n        l = (skill[i]<l)? skill[i]:l;\\n        r = (skill[i]>r)? skill[i]:r;\\n    }"], ["long long dividePlayers(int* skill, int skillSize){\\n    int* hashCnt = (int*)calloc(1001, sizeof(int));\\n    int l = 1000, r = 0;\\n    for(int i = 0; i < skillSize; i++){\\n        hashCnt[skill[i]]++;\\n        l = (skill[i]<l)? skill[i]:l;\\n        r = (skill[i]>r)? skill[i]:r;\\n    }"], ["long long dividePlayers(int* skill, int skillSize){\\n    int* hashCnt = (int*)calloc(1001, sizeof(int));\\n    int l = 1000, r = 0;\\n    for(int i = 0; i < skillSize; i++){\\n        hashCnt[skill[i]]++;\\n        l = (skill[i]<l)? skill[i]:l;\\n        r = (skill[i]>r)? skill[i]:r;\\n    }"]]}
{"id": "1643", "ref_c": ["\ntypedef struct Node {\n    void *data;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    int cityNum;\n    int visited;\n} City;\n\nNode **buildAdjacencyList(int numCities, int **roads, int roadSize) {\n    int i;\n    City *c;\n    Node *n1, *n2, **cities = malloc((numCities+1) * sizeof(Node*));\n    cities[0] = NULL;\n    for (i = 1; i <= numCities; ++i) {\n        c = malloc(sizeof(City));\n        c->cityNum = i;\n        c->visited = 0;\n        cities[i] = malloc(sizeof(Node));\n        cities[i]->data = (void*) c;\n        cities[i]->next = NULL;\n    }\n    for (i = 0; i < roadSize; ++i) {\n        n1 = malloc(sizeof(Node));\n        n1->data = cities[roads[i][1]]->data;\n        n1->next =  cities[roads[i][0]]->next;\n        n2 = malloc(sizeof(Node));\n        n2->data = cities[roads[i][0]]->data;\n        n2->next = cities[roads[i][1]]->next;\n        cities[roads[i][0]]->next = n1;\n        cities[roads[i][1]]->next = n2;\n\t}\n    return cities;\n}\n\nvoid dfs(int city, Node **adjList) {\n    Node *n = adjList[city];\n    City *c = (City*) n->data;\n    if (!c->visited) {\n        c->visited = 1;\n        n = n->next;\n        while (n != NULL) {\n            c = (City*) n->data;\n            dfs(c->cityNum, adjList);\n            n = n->next;\n        }\n    }\n}\n\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){\n    int i, distance, minDistance = MAX_INT;\n    City *c0, *c1;\n    Node **adjacencyList = buildAdjacencyList(n, roads, roadsSize);\n    dfs(1, adjacencyList);\n    for (i = 0; i < roadsSize; ++i) {\n        c0 = (City*) adjacencyList[roads[i][0]]->data;\n        c1 = (City*) adjacencyList[roads[i][1]]->data;\n        if (c0->visited && c1->visited) {\n            distance = roads[i][2];\n            printf(\"%d\n\", distance);\n            if (distance < minDistance) {\n                minDistance = distance;\n            }\n        }\n    }\n    return minDistance;\n}\n", "\ntypedef struct Node {\n    void *data;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    int cityNum;\n    int visited;\n} City;\n\nNode **buildAdjacencyList(int numCities, int **roads, int roadSize) {\n    int i;\n    City *c;\n    Node *n1, *n2, **cities = malloc((numCities+1) * sizeof(Node*));\n    cities[0] = NULL;\n    for (i = 1; i <= numCities; ++i) {\n        c = malloc(sizeof(City));\n        c->cityNum = i;\n        c->visited = 0;\n        cities[i] = malloc(sizeof(Node));\n        cities[i]->data = (void*) c;\n        cities[i]->next = NULL;\n    }\n    for (i = 0; i < roadSize; ++i) {\n        n1 = malloc(sizeof(Node));\n        n1->data = cities[roads[i][1]]->data;\n        n1->next =  cities[roads[i][0]]->next;\n        n2 = malloc(sizeof(Node));\n        n2->data = cities[roads[i][0]]->data;\n        n2->next = cities[roads[i][1]]->next;\n        cities[roads[i][0]]->next = n1;\n        cities[roads[i][1]]->next = n2;\n\t}\n    return cities;\n}\n\nvoid dfs(int city, Node **adjList) {\n    Node *n = adjList[city];\n    City *c = (City*) n->data;\n    if (!c->visited) {\n        c->visited = 1;\n        n = n->next;\n        while (n != NULL) {\n            c = (City*) n->data;\n            dfs(c->cityNum, adjList);\n            n = n->next;\n        }\n    }\n}\n\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){\n    int i, distance, minDistance = MAX_INT;\n    City *c0, *c1;\n    Node **adjacencyList = buildAdjacencyList(n, roads, roadsSize);\n    dfs(1, adjacencyList);\n    for (i = 0; i < roadsSize; ++i) {\n        c0 = (City*) adjacencyList[roads[i][0]]->data;\n        c1 = (City*) adjacencyList[roads[i][1]]->data;\n        if (c0->visited && c1->visited) {\n            distance = roads[i][2];\n            printf(\"%d\n\", distance);\n            if (distance < minDistance) {\n                minDistance = distance;\n            }\n        }\n    }\n    return minDistance;\n}\n", "\ntypedef struct Node {\n    void *data;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    int cityNum;\n    int visited;\n} City;\n\nNode **buildAdjacencyList(int numCities, int **roads, int roadSize) {\n    int i;\n    City *c;\n    Node *n1, *n2, **cities = malloc((numCities+1) * sizeof(Node*));\n    cities[0] = NULL;\n    for (i = 1; i <= numCities; ++i) {\n        c = malloc(sizeof(City));\n        c->cityNum = i;\n        c->visited = 0;\n        cities[i] = malloc(sizeof(Node));\n        cities[i]->data = (void*) c;\n        cities[i]->next = NULL;\n    }\n    for (i = 0; i < roadSize; ++i) {\n        n1 = malloc(sizeof(Node));\n        n1->data = cities[roads[i][1]]->data;\n        n1->next =  cities[roads[i][0]]->next;\n        n2 = malloc(sizeof(Node));\n        n2->data = cities[roads[i][0]]->data;\n        n2->next = cities[roads[i][1]]->next;\n        cities[roads[i][0]]->next = n1;\n        cities[roads[i][1]]->next = n2;\n\t}\n    return cities;\n}\n\nvoid dfs(int city, Node **adjList) {\n    Node *n = adjList[city];\n    City *c = (City*) n->data;\n    if (!c->visited) {\n        c->visited = 1;\n        n = n->next;\n        while (n != NULL) {\n            c = (City*) n->data;\n            dfs(c->cityNum, adjList);\n            n = n->next;\n        }\n    }\n}\n\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){\n    int i, distance, minDistance = MAX_INT;\n    City *c0, *c1;\n    Node **adjacencyList = buildAdjacencyList(n, roads, roadsSize);\n    dfs(1, adjacencyList);\n    for (i = 0; i < roadsSize; ++i) {\n        c0 = (City*) adjacencyList[roads[i][0]]->data;\n        c1 = (City*) adjacencyList[roads[i][1]]->data;\n        if (c0->visited && c1->visited) {\n            distance = roads[i][2];\n            printf(\"%d\n\", distance);\n            if (distance < minDistance) {\n                minDistance = distance;\n            }\n        }\n    }\n    return minDistance;\n}\n"]}
{"id": "1644", "ref_c": [["char ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int blockCommentOp = 0;\\n    char ** srcCopy = malloc(sourceSize*sizeof(char*));\\n    int line = 0, idx = 0;\\n    srcCopy[line] = NULL;\\n    for (int i = 0; i < sourceSize; ++i) {\\n        int j = 0;\\n        while (source[i][j] != \\'\\\\0\\') {\\n            char c = source[i][j];\\n            if (blockCommentOp == 0) {\\n                if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                    break;\\n                }"], ["char ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int blockCommentOp = 0;\\n    char ** srcCopy = malloc(sourceSize*sizeof(char*));\\n    int line = 0, idx = 0;\\n    srcCopy[line] = NULL;\\n    for (int i = 0; i < sourceSize; ++i) {\\n        int j = 0;\\n        while (source[i][j] != \\'\\\\0\\') {\\n            char c = source[i][j];\\n            if (blockCommentOp == 0) {\\n                if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                    break;\\n                }"], ["char ** removeComments(char ** source, int sourceSize, int* returnSize){\\n    int blockCommentOp = 0;\\n    char ** srcCopy = malloc(sourceSize*sizeof(char*));\\n    int line = 0, idx = 0;\\n    srcCopy[line] = NULL;\\n    for (int i = 0; i < sourceSize; ++i) {\\n        int j = 0;\\n        while (source[i][j] != \\'\\\\0\\') {\\n            char c = source[i][j];\\n            if (blockCommentOp == 0) {\\n                if (c == \\'/\\' && source[i][j + 1] != \\'\\\\0\\' && source[i][j + 1] == \\'/\\') {\\n                    break;\\n                }"]]}
{"id": "1645", "ref_c": [["int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int i=0, j=0;\\n    while(i<nums1Size && j<nums2Size){\\n        if(nums1[i]==nums2[j]){\\n            return nums1[i];\\n        }"], ["int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size) \\n{\\n    int i = 0, j = 0, min_common_val = -1;\\n    while(i < nums1Size && j < nums2Size)\\n    {\\n        if(nums1[i] < nums2[j])\\n        {\\n            i++;\\n        }"], ["int getCommon(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int i = 0;\\n    int j = 0;\\n\\n    while (i < nums1Size && j < nums2Size) {\\n        if (nums1[i] == nums2[j]) {\\n            return nums1[i];\\n        }"]]}
{"id": "1646", "ref_c": [["int smallestEvenMultiple(int n) {\\n        if(n%2 == 0){\\n            return n;\\n        }", "int smallestEvenMultiple(int n){\\n    if(n%2 == 0){\\n        return n;\\n    }", "int smallestEvenMultiple(int n) {\\n        if(n%2 == 0){\\n            return n;\\n        }", "int smallestEvenMultiple(int n) {\\n        if(n%2 == 0){\\n            return n;\\n        }"], ["int smallestEvenMultiple(int n) {\\n        if(n%2==0) return n;\\n        return 2*n;\\n    }", "int smallestEvenMultiple(int n) {\\n        if(n%2==0) return n;\\n        return 2*n;\\n    }", "int smallestEvenMultiple(int n) {\\n    if(n%2==0) return n;\\n        return 2*n;\\n}", "int smallestEvenMultiple(int n) {\\n     if(n%2==0) return n;\\n        return 2*n;\\n  }", "int smallestEvenMultiple(int n) {\\n        if(n%2==0) return n;\\n        return 2*n;\\n    }"], ["int smallestEvenMultiple(int n) {\\n       int value,i;\\n      for(i=1;i<=2;i++)\\n      {\\n          value=i*n;\\n          if(value%2==0)\\n          {\\n              return value;\\n          }", "int smallestEvenMultiple(int n) {\\n      int value,i;\\n      for(i=1;i<=2;i++)\\n      {\\n          value=i*n;\\n          if(value%2==0)\\n          {\\n              return value;\\n          }", "int smallestEvenMultiple(int n) {\\n        int value;\\n        for(int i=1;i<=2;i++)\\n        {\\n            value=i*n;\\n            if(value%2==0)\\n            {\\n                return value;\\n            }"]]}
{"id": "1648", "ref_c": [["int smallestValue(int n){\\n        if(n==4){\\n            return 4;\\n        }"], ["int smallestValue(int n){\\n    int primes = getPrimeFactorsSum(n);\\n    if (primes == n)\\n        return n;\\n    \\n    return smallestValue(primes);\\n}"], ["int smallestValue(int n){\\n    int val = sumFactors(n);\\n    if (val == n) {\\n        return n;\\n    }"]]}
{"id": "1649", "ref_c": [["int* constructArray(int n, int k, int* returnSize){\\n    int* set = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    \\n\\t/*\\n\\t * Start from 1 \\n\\t * a2 should equal a1 + k, the largest distance you need\\n\\t * back track to find the next largest distance (k - 1)\\n\\t * repeat the pattern until you construct k distinct distances\\n\\t */\\n    int i = 1;\\n    set[0] = 1;\\n    int mult = 1;\\n    int offset = (int)(k / 2.0) + 1;\\n    \\n    for(k; k > 0; k--){\\n        \\n        set[i] = set[i - 1] + k * mult;\\n        mult = -1 * mult;\\n        i++;\\n        \\n    }"], ["int* constructArray(int n, int k, int* returnSize){\\n    int* set = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    \\n\\t/*\\n\\t * Start from 1 \\n\\t * a2 should equal a1 + k, the largest distance you need\\n\\t * back track to find the next largest distance (k - 1)\\n\\t * repeat the pattern until you construct k distinct distances\\n\\t */\\n    int i = 1;\\n    set[0] = 1;\\n    int mult = 1;\\n    int offset = (int)(k / 2.0) + 1;\\n    \\n    for(k; k > 0; k--){\\n        \\n        set[i] = set[i - 1] + k * mult;\\n        mult = -1 * mult;\\n        i++;\\n        \\n    }"], ["int* constructArray(int n, int k, int* returnSize){\\n    int* set = (int*)malloc(n * sizeof(int));\\n    *returnSize = n;\\n    \\n\\t/*\\n\\t * Start from 1 \\n\\t * a2 should equal a1 + k, the largest distance you need\\n\\t * back track to find the next largest distance (k - 1)\\n\\t * repeat the pattern until you construct k distinct distances\\n\\t */\\n    int i = 1;\\n    set[0] = 1;\\n    int mult = 1;\\n    int offset = (int)(k / 2.0) + 1;\\n    \\n    for(k; k > 0; k--){\\n        \\n        set[i] = set[i - 1] + k * mult;\\n        mult = -1 * mult;\\n        i++;\\n        \\n    }"]]}
{"id": "1650", "ref_c": [["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"]]}
{"id": "1651", "ref_c": [["int takeCharacters(char * s, int k){\\n    int countA = 0, countB = 0, countC = 0, len = strlen(s), i, left, right, ans = len;\\n\\n    for (i = 0; i < len ; i++) {\\n        if (s[i] == \\'a\\')\\n            countA++;\\n        if (s[i] == \\'b\\')\\n            countB++;\\n        if (s[i] == \\'c\\')\\n            countC++;\\n    }"], ["int takeCharacters(char * s, int k){\\n    int countA = 0, countB = 0, countC = 0, len = strlen(s), i, left, right, ans = len;\\n\\n    for (i = 0; i < len ; i++) {\\n        if (s[i] == \\'a\\')\\n            countA++;\\n        if (s[i] == \\'b\\')\\n            countB++;\\n        if (s[i] == \\'c\\')\\n            countC++;\\n    }"], ["int takeCharacters(char * s, int k){\\n    int countA = 0, countB = 0, countC = 0, len = strlen(s), i, left, right, ans = len;\\n\\n    for (i = 0; i < len ; i++) {\\n        if (s[i] == \\'a\\')\\n            countA++;\\n        if (s[i] == \\'b\\')\\n            countB++;\\n        if (s[i] == \\'c\\')\\n            countC++;\\n    }"]]}
{"id": "1652", "ref_c": [["int smallestEvenMultiple(int n) {\\n        if(n%2 == 0){\\n            return n;\\n        }", "int smallestEvenMultiple(int n){\\n    if(n%2 == 0){\\n        return n;\\n    }", "int smallestEvenMultiple(int n) {\\n        if(n%2 == 0){\\n            return n;\\n        }", "int smallestEvenMultiple(int n) {\\n        if(n%2 == 0){\\n            return n;\\n        }"], ["int smallestEvenMultiple(int n) {\\n        if(n%2==0) return n;\\n        return 2*n;\\n    }", "int smallestEvenMultiple(int n) {\\n        if(n%2==0) return n;\\n        return 2*n;\\n    }", "int smallestEvenMultiple(int n) {\\n    if(n%2==0) return n;\\n        return 2*n;\\n}", "int smallestEvenMultiple(int n) {\\n     if(n%2==0) return n;\\n        return 2*n;\\n  }", "int smallestEvenMultiple(int n) {\\n        if(n%2==0) return n;\\n        return 2*n;\\n    }"], ["int smallestEvenMultiple(int n) {\\n       int value,i;\\n      for(i=1;i<=2;i++)\\n      {\\n          value=i*n;\\n          if(value%2==0)\\n          {\\n              return value;\\n          }", "int smallestEvenMultiple(int n) {\\n      int value,i;\\n      for(i=1;i<=2;i++)\\n      {\\n          value=i*n;\\n          if(value%2==0)\\n          {\\n              return value;\\n          }", "int smallestEvenMultiple(int n) {\\n        int value;\\n        for(int i=1;i<=2;i++)\\n        {\\n            value=i*n;\\n            if(value%2==0)\\n            {\\n                return value;\\n            }"]]}
{"id": "1653", "ref_c": [["int distinctPrimeFactors(int* nums, int numsSize) {\\n    int count = 0;\\n    int arr[10000];\\n    for(int i = 0; i < numsSize; i++) {\\n        int n = nums[i];\\n        int tempSize = 0;\\n        int *primeArr = getPrimeArr(n, &tempSize);\\n        for(int j = 0; j < tempSize; j++) {\\n            if(isContains(arr, count, primeArr[j]) == 0) {\\n                arr[count] = primeArr[j];\\n                count++;\\n            }"], ["int distinctPrimeFactors(int* nums, int numsSize) {\\n    int count = 0;\\n    int arr[10000];\\n    for(int i = 0; i < numsSize; i++) {\\n        int n = nums[i];\\n        int tempSize = 0;\\n        int *primeArr = getPrimeArr(n, &tempSize);\\n        for(int j = 0; j < tempSize; j++) {\\n            if(isContains(arr, count, primeArr[j]) == 0) {\\n                arr[count] = primeArr[j];\\n                count++;\\n            }"], ["int distinctPrimeFactors(int* nums, int numsSize){\\n    int p[11] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}"]]}
{"id": "1654", "ref_c": [["int minimumPartition(char * s, int k){\\n    int idx = 0, len = strlen(s), ans = 0;\\n    long prev = 0, curr = 0;\\n    while(idx < len){\\n        prev = curr;\\n        curr *= 10;\\n        curr += (s[idx] - \\'0\\');\\n        if(curr > k){\\n            ans++;\\n            curr = (s[idx] - \\'0\\');\\n            if(prev > k || !prev)\\n                return -1;\\n        }"], ["int minimumPartition(char * s, int k){\\n    int idx = 0, len = strlen(s), ans = 0;\\n    long prev = 0, curr = 0;\\n    while(idx < len){\\n        prev = curr;\\n        curr *= 10;\\n        curr += (s[idx] - \\'0\\');\\n        if(curr > k){\\n            ans++;\\n            curr = (s[idx] - \\'0\\');\\n            if(prev > k || !prev)\\n                return -1;\\n        }"], ["int minimumPartition(char * s, int k){\\n    int idx = 0, len = strlen(s), ans = 0;\\n    long prev = 0, curr = 0;\\n    while(idx < len){\\n        prev = curr;\\n        curr *= 10;\\n        curr += (s[idx] - \\'0\\');\\n        if(curr > k){\\n            ans++;\\n            curr = (s[idx] - \\'0\\');\\n            if(prev > k || !prev)\\n                return -1;\\n        }"]]}
{"id": "1655", "ref_c": [["int* closestPrimes(int left, int right, int* returnSize) {\\n    int* closestPrimes = (int*)malloc(2 * sizeof(int));\\n    closestPrimes[0] = -1;\\n    closestPrimes[1] = -1;\\n    if (right <= 1) {\\n        *returnSize = 2;\\n        return closestPrimes;\\n    }"], ["int* closestPrimes(int left, int right, int* returnSize) {\\n    int* closestPrimes = (int*)malloc(2 * sizeof(int));\\n    closestPrimes[0] = -1;\\n    closestPrimes[1] = -1;\\n    if (right <= 1) {\\n        *returnSize = 2;\\n        return closestPrimes;\\n    }"], ["int* closestPrimes(int left, int right, int* returnSize) {\\n    int* closestPrimes = (int*)malloc(2 * sizeof(int));\\n    closestPrimes[0] = -1;\\n    closestPrimes[1] = -1;\\n    if (right <= 1) {\\n        *returnSize = 2;\\n        return closestPrimes;\\n    }"]]}
{"id": "1657", "ref_c": [["int xorBeauty(int* nums, int numsSize){\\nint i,j,res=0;\\nfor(i=0;i<numsSize;i++)\\nres^=nums[i];\\nreturn res;\\n}"], ["int xorBeauty(int* nums, int numsSize){\\n    int result=0;\\n    for(int i=0; i<numsSize; i++){\\n        result^=nums[i];\\n    }"], ["int xorBeauty(int* nums, int numsSize){\\n    int result=0;\\n    for(int i=0; i<numsSize; i++){\\n        result^=nums[i];\\n    }"]]}
{"id": "1658", "ref_c": [["long long maxKelements(int* nums, int numsSize, int k){\\n    long long score = 0;\\n    \\n    buildHeap(nums, numsSize);\\n\\n    while (k--) {\\n        score += nums[0];\\n        nums[0] = ceil(nums[0] / 3.0);\\n        heapify(nums, numsSize, 0);\\n    }"], ["long long maxKelements(int* nums, int numsSize, int k){\\n    long long score = 0;\\n    \\n    buildHeap(nums, numsSize);\\n\\n    while (k--) {\\n        score += nums[0];\\n        nums[0] = ceil(nums[0] / 3.0);\\n        heapify(nums, numsSize, 0);\\n    }"], ["long long maxKelements(int* nums, int numsSize, int k){\\n    long long score = 0;\\n    \\n    buildHeap(nums, numsSize);\\n\\n    while (k--) {\\n        score += nums[0];\\n        nums[0] = ceil(nums[0] / 3.0);\\n        heapify(nums, numsSize, 0);\\n    }"]]}
{"id": "1659", "ref_c": [["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"]]}
{"id": "1660", "ref_c": [["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"]]}
{"id": "1661", "ref_c": [["int longestIdealString(char * s, int k){\\n    \\n    int freq[26]={0}"], ["int longestIdealString(char * s, int k){\\n    \\n    int freq[26]={0}"], ["int longestIdealString(char * s, int k){\\n    \\n    int freq[26]={0}"]]}
{"id": "1662", "ref_c": [["int* numMovesStones(int a, int b, int c, int* returnSize){\\n\\n    int max,mid,min;\\n    \\n    if(a>b&&b>c){max=a;mid=b;min=c;}"], ["int* numMovesStones(int a, int b, int c, int* returnSize){\\n    // printf(\"%d %d %d\\\\n\",a,b,c);\\n    // int temp;\\n\\t// Sort. Do whatever sort you like.\\n    if(a > b){\\n        a ^= b;\\n        b ^= a;\\n        a ^= b;\\n    }"], ["int* numMovesStones(int a, int b, int c, int* returnSize){\\n    // printf(\"%d %d %d\\\\n\",a,b,c);\\n    // int temp;\\n\\t// Sort. Do whatever sort you like.\\n    if(a > b){\\n        a ^= b;\\n        b ^= a;\\n        a ^= b;\\n    }"]]}
{"id": "1663", "ref_c": [["long long maxScore(int* nums1, int nums1Size, int* nums2, int nums2Size, int k){\\n\\n    Data* data = (Data*)malloc(nums2Size * sizeof(Data));\\n\\n    for(int i = 0; i < nums2Size; i++){\\n        data[i].nums1 = nums1[i];\\n        data[i].nums2 = nums2[i];\\n    }"], ["long long maxScore(int* nums1, int nums1Size, int* nums2, int nums2Size, int k){\\n\\n    Data* data = (Data*)malloc(nums2Size * sizeof(Data));\\n\\n    for(int i = 0; i < nums2Size; i++){\\n        data[i].nums1 = nums1[i];\\n        data[i].nums2 = nums2[i];\\n    }"], ["long long maxScore(int* nums1, int nums1Size, int* nums2, int nums2Size, int k){\\n\\n    Data* data = (Data*)malloc(nums2Size * sizeof(Data));\\n\\n    for(int i = 0; i < nums2Size; i++){\\n        data[i].nums1 = nums1[i];\\n        data[i].nums2 = nums2[i];\\n    }"]]}
{"id": "1664", "ref_c": ["\nint** sortTheStudents(int** score, int scoreSize, int* scoreColSize, int k, int* returnSize, int** returnColumnSizes)\n{\n    *returnColumnSizes=scoreColSize;\n    *returnSize=scoreSize;\n    int *A=(int*)malloc((*scoreColSize)*sizeof(int));\n    for(int i=0;i<scoreSize-1;i++)\n    {\n        for(int j=i+1;j<scoreSize;j++)\n        {\n            if(score[j][k]>score[i][k])\n            {\n                A=score[j];\n                score[j]=score[i];\n                score[i]=A;\n            }\n        }\n    }\n    return score;\n}\n", "\nint** sortTheStudents(int** score, int scoreSize, int* scoreColSize, int k, int* returnSize, int** returnColumnSizes)\n{\n    *returnColumnSizes=scoreColSize;\n    *returnSize=scoreSize;\n    int *A=(int*)malloc((*scoreColSize)*sizeof(int));\n    for(int i=0;i<scoreSize-1;i++)\n    {\n        for(int j=i+1;j<scoreSize;j++)\n        {\n            if(score[j][k]>score[i][k])\n            {\n                A=score[j];\n                score[j]=score[i];\n                score[i]=A;\n            }\n        }\n    }\n    return score;\n}\n", "\nint** sortTheStudents(int** score, int scoreSize, int* scoreColSize, int k, int* returnSize, int** returnColumnSizes)\n{\n    *returnColumnSizes=scoreColSize;\n    *returnSize=scoreSize;\n    int *A=(int*)malloc((*scoreColSize)*sizeof(int));\n    for(int i=0;i<scoreSize-1;i++)\n    {\n        for(int j=i+1;j<scoreSize;j++)\n        {\n            if(score[j][k]>score[i][k])\n            {\n                A=score[j];\n                score[j]=score[i];\n                score[i]=A;\n            }\n        }\n    }\n    return score;\n}\n"]}
{"id": "1665", "ref_c": [["bool makeStringsEqual(char * s, char * target){\\n    return isEqual(s,target) || (pos(s) && pos(target));\\n}"], ["bool makeStringsEqual(char * s, char * target){\\n    return isEqual(s,target) || (pos(s) && pos(target));\\n}"], ["bool makeStringsEqual(char * s, char * target){\\n    return isEqual(s,target) || (pos(s) && pos(target));\\n}"]]}
{"id": "1666", "ref_c": [["long long smallestNumber(long long num) {\\n        if(num == 0)\\n            return num;\\n\\n        vector<int> nums;\\n        bool flag = (num<0);\\n\\n        while(num != 0)\\n        {\\n            int rem = num%10;\\n            num /= 10;\\n            nums.push_back(rem);\\n        }"], ["long long smallestNumber(long long num){\\n\\n\\t\\tif (num == 0)\\n\\t\\t\\treturn num;\\n\\t\\t\\t\\n\\t\\t//find length of long long\\n\\t\\tlong long x = num; \\n\\t\\tif (x < 0)\\n\\t\\t\\tx = -x;\\n\\t\\tint size = 0;\\n\\t\\twhile (x != 0)\\n\\t\\t{\\n\\t\\t\\tint digit = x%10;\\n\\t\\t\\tsize++;\\n\\t\\t\\tx /= 10;\\n\\t\\t}"], ["long long smallestNumber(long long num){\\n    int is_neg = 0;\\n    if(num < 0){\\n        is_neg = 1;\\n        num = num * -1;\\n    }"]]}
{"id": "1667", "ref_c": [["int maxPower(char * s){\\n    if(strlen(s)==1)\\n    {\\n        return 1;\\n    }"], ["int maxPower(char * s){\\n    int curr_pow=1, max_pow=1;\\n    for(int i=0;s[i]!=\\'\\\\0\\';i++){\\n        if(s[i] == s[i+1])\\n            curr_pow++;\\n        else{\\n            max_pow=(curr_pow>max_pow)?curr_pow:max_pow;\\n            curr_pow=1;\\n        }"], ["int maxPower(char * s){\\n    if(strlen(s)==1)\\n    {\\n        return 1;\\n    }"]]}
{"id": "1668", "ref_c": [["int* postorderTraversal(struct TreeNode* root, int* returnSize){\\n    int* ans = malloc(101*sizeof(int));\\n    *returnSize = 0;\\n    post(root,returnSize,ans);\\n    return ans;\\n}"], ["int* postorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    struct TreeNode* stack[100] = {NULL}"], ["int* postorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int* Stack = (int*)malloc(sizeof(int)*100);\\n    int Stack_Cnt = 0;\\n\\n    SearchTree_POT(root, Stack, &Stack_Cnt);\\n\\n    *returnSize = Stack_Cnt;\\n    return Stack;\\n}"]]}
{"id": "1669", "ref_c": [["bool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize){\\n    \\n    int *tmp = malloc(sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    memset(tmp, 0, sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    \\n    int i,j;\\n    \\n    tmp[0] = 1;\\n    \\n    for (i = 0; i < gridSize; i++) {\\n        for (j = 0; j < gridColSize[i]; j++) {\\n            \\n            if (i == 0 && j == 0) {\\n                continue;\\n            }"], ["bool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize){\\n    \\n    int *tmp = malloc(sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    memset(tmp, 0, sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    \\n    int i,j;\\n    \\n    tmp[0] = 1;\\n    \\n    for (i = 0; i < gridSize; i++) {\\n        for (j = 0; j < gridColSize[i]; j++) {\\n            \\n            if (i == 0 && j == 0) {\\n                continue;\\n            }"], ["bool isPossibleToCutPath(int** grid, int gridSize, int* gridColSize){\\n    \\n    int *tmp = malloc(sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    memset(tmp, 0, sizeof(int)*(gridSize + gridColSize[0] + 1));\\n    \\n    int i,j;\\n    \\n    tmp[0] = 1;\\n    \\n    for (i = 0; i < gridSize; i++) {\\n        for (j = 0; j < gridColSize[i]; j++) {\\n            \\n            if (i == 0 && j == 0) {\\n                continue;\\n            }"]]}
{"id": "1670", "ref_c": [["int numRookCaptures(char** board, int boardSize, int* boardColSize) \\n{\\n    int row_rook, col_rook;\\n    for(int i = 0; i < boardSize; i++)\\n    {\\n        for(int j = 0; j < *boardColSize; j++)\\n        {\\n            if(board[i][j] == \\'R\\')\\n            {\\n                row_rook = i;\\n                col_rook = j;\\n                break;\\n            }"], ["int numRookCaptures(char** board, int boardSize, int* boardColSize){\\n    for (int row_idx = 0; row_idx < boardSize; row_idx ++) {\\n        for (int col_idx = 0; col_idx < 8; col_idx ++) {\\n            if (board[row_idx][col_idx] == \\'R\\') {\\n                int count = 0;\\n                for (int top_row = 1; top_row <= row_idx; top_row ++) {\\n                    int row = row_idx - top_row;\\n                    char value = board[row][col_idx];\\n                    if (value == \\'p\\') {\\n                        count ++;\\n                        break;\\n                    }"], ["int numRookCaptures(char** board, int boardSize, int* boardColSize){\\n    for (int row_idx = 0; row_idx < boardSize; row_idx ++) {\\n        for (int col_idx = 0; col_idx < 8; col_idx ++) {\\n            if (board[row_idx][col_idx] == \\'R\\') {\\n                int count = 0;\\n                for (int top_row = 1; top_row <= row_idx; top_row ++) {\\n                    int row = row_idx - top_row;\\n                    char value = board[row][col_idx];\\n                    if (value == \\'p\\') {\\n                        count ++;\\n                        break;\\n                    }"]]}
{"id": "1671", "ref_c": [["int minCapability(int* nums, int numsSize, int k) {\\n    // Binary search + Simulatiuon\\n\\n    // Time complexity: O(log(nums.max - nums.min))\\n    // Space complexity: O(1)\\n    \\n    int left = min_element(nums, numsSize);\\n    int right = max_element(nums, numsSize);\\n    while (left < right) {\\n        int middle = left + (right - left) / 2;\\n        if (num_houses_stolen(nums, numsSize, middle) >= k) {\\n            right = middle;\\n        }"], ["int minCapability(int* nums, int numsSize, int k) {\\n    // Binary search + Simulatiuon\\n\\n    // Time complexity: O(log(nums.max - nums.min))\\n    // Space complexity: O(1)\\n    \\n    int left = min_element(nums, numsSize);\\n    int right = max_element(nums, numsSize);\\n    while (left < right) {\\n        int middle = left + (right - left) / 2;\\n        if (num_houses_stolen(nums, numsSize, middle) >= k) {\\n            right = middle;\\n        }"], ["int minCapability(int* nums, int numsSize, int k) {\\n    // Binary search + Simulatiuon\\n\\n    // Time complexity: O(log(nums.max - nums.min))\\n    // Space complexity: O(1)\\n    \\n    int left = min_element(nums, numsSize);\\n    int right = max_element(nums, numsSize);\\n    while (left < right) {\\n        int middle = left + (right - left) / 2;\\n        if (num_houses_stolen(nums, numsSize, middle) >= k) {\\n            right = middle;\\n        }"]]}
{"id": "1672", "ref_c": [["struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){\\n    if(!list1) return list2;\\n    if(!list2) return list1;\\n    struct ListNode* itteratorl1,* backOfNewList;\\n    if(list1->val > list2->val){\\n        backOfNewList = list2;\\n        list2 = list1;\\n        list1 = backOfNewList;\\n    }"], ["struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){\\n    if(list1==NULL&&list2==NULL)\\n    return NULL;\\n    if(list1==NULL)\\n    return list2;\\n    if(list2==NULL)\\n    return list1;\\n    struct ListNode* last, *third;\\n    if(list1->val<list2->val)\\n    {\\n        third=list1;\\n        last=list1;\\n        list1=list1->next;\\n        last->next=NULL;\\n    }"], ["struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){\\n    if(list1==NULL&&list2==NULL)\\n    return NULL;\\n    if(list1==NULL)\\n    return list2;\\n    if(list2==NULL)\\n    return list1;\\n    struct ListNode* last, *third;\\n    if(list1->val<list2->val)\\n    {\\n        third=list1;\\n        last=list1;\\n        list1=list1->next;\\n        last->next=NULL;\\n    }"]]}
{"id": "1673", "ref_c": [["int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Build all the substrings (in reverse) into the trie */\\n\\tconst int len = strlen(s);\\n\\tint num_tries = 0;\\n\\tstruct substring_trie trie;\\n\\tmemset(&trie, 0, sizeof(trie));\\n\\tstruct substring_trie* tries[30];\\n\\tmemset(tries, 0, sizeof(tries));\\n\\tfor (int i = len - 1; 0 <= i; --i) {\\n\\t\\tnum_tries = (30 == num_tries) ? num_tries : (num_tries + 1);\\n\\t\\ttries[i % 30] = &trie;\\n\\t\\tfor (int j = 0; j < num_tries; ++j) {\\n\\t\\t\\tstruct substring_trie** next_ptr = &tries[(i + j) % 30]->next[\\'1\\' == s[i]];\\n\\t\\t\\tif (!*next_ptr) {\\n\\t\\t\\t\\t*next_ptr = calloc(1, sizeof(**next_ptr));\\n\\t\\t\\t}", "int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Add all possible substring to the hashtable */\\n\\tstruct substring_hash* table = NULL;\\n\\tint fingerprints[30] = {0}", "int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = malloc(queriesSize * sizeof(*ret));\\n\\t*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tret[i] = malloc(2 * sizeof(**ret));\\n\\t\\t(*returnColumnSizes)[i] = 2;\\n\\t}"], ["int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Build all the substrings (in reverse) into the trie */\\n\\tconst int len = strlen(s);\\n\\tint num_tries = 0;\\n\\tstruct substring_trie trie;\\n\\tmemset(&trie, 0, sizeof(trie));\\n\\tstruct substring_trie* tries[30];\\n\\tmemset(tries, 0, sizeof(tries));\\n\\tfor (int i = len - 1; 0 <= i; --i) {\\n\\t\\tnum_tries = (30 == num_tries) ? num_tries : (num_tries + 1);\\n\\t\\ttries[i % 30] = &trie;\\n\\t\\tfor (int j = 0; j < num_tries; ++j) {\\n\\t\\t\\tstruct substring_trie** next_ptr = &tries[(i + j) % 30]->next[\\'1\\' == s[i]];\\n\\t\\t\\tif (!*next_ptr) {\\n\\t\\t\\t\\t*next_ptr = calloc(1, sizeof(**next_ptr));\\n\\t\\t\\t}", "int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Add all possible substring to the hashtable */\\n\\tstruct substring_hash* table = NULL;\\n\\tint fingerprints[30] = {0}", "int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = malloc(queriesSize * sizeof(*ret));\\n\\t*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tret[i] = malloc(2 * sizeof(**ret));\\n\\t\\t(*returnColumnSizes)[i] = 2;\\n\\t}"], ["int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Build all the substrings (in reverse) into the trie */\\n\\tconst int len = strlen(s);\\n\\tint num_tries = 0;\\n\\tstruct substring_trie trie;\\n\\tmemset(&trie, 0, sizeof(trie));\\n\\tstruct substring_trie* tries[30];\\n\\tmemset(tries, 0, sizeof(tries));\\n\\tfor (int i = len - 1; 0 <= i; --i) {\\n\\t\\tnum_tries = (30 == num_tries) ? num_tries : (num_tries + 1);\\n\\t\\ttries[i % 30] = &trie;\\n\\t\\tfor (int j = 0; j < num_tries; ++j) {\\n\\t\\t\\tstruct substring_trie** next_ptr = &tries[(i + j) % 30]->next[\\'1\\' == s[i]];\\n\\t\\t\\tif (!*next_ptr) {\\n\\t\\t\\t\\t*next_ptr = calloc(1, sizeof(**next_ptr));\\n\\t\\t\\t}", "int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes) {\\n\\t/* Add all possible substring to the hashtable */\\n\\tstruct substring_hash* table = NULL;\\n\\tint fingerprints[30] = {0}", "int** substringXorQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = malloc(queriesSize * sizeof(*ret));\\n\\t*returnColumnSizes = malloc(queriesSize * sizeof(**returnColumnSizes));\\n\\tfor (int i = 0; i < queriesSize; ++i) {\\n\\t\\tret[i] = malloc(2 * sizeof(**ret));\\n\\t\\t(*returnColumnSizes)[i] = 2;\\n\\t}"]]}
{"id": "1674", "ref_c": [["int getMaximumConsecutive(int* coins, int coinsSize){\\n    \\n    qsort(coins, coinsSize, sizeof(int), cmpfunc);\\n    int i;\\n    int c=0;\\n    for (i = 0; i < coinsSize; i++)\\n    {\\n        if (c+1 >= coins[i])\\n        {\\n            c += coins[i];\\n        }"], ["int getMaximumConsecutive(int* coins, int coinsSize){\\n    \\n    qsort(coins, coinsSize, sizeof(int), cmpfunc);\\n    int i;\\n    int c=0;\\n    for (i = 0; i < coinsSize; i++)\\n    {\\n        if (c+1 >= coins[i])\\n        {\\n            c += coins[i];\\n        }"], ["int getMaximumConsecutive(int* coins, int coinsSize){\\n    \\n    qsort(coins, coinsSize, sizeof(int), cmpfunc);\\n    int i;\\n    int c=0;\\n    for (i = 0; i < coinsSize; i++)\\n    {\\n        if (c+1 >= coins[i])\\n        {\\n            c += coins[i];\\n        }"]]}
{"id": "1675", "ref_c": [["int minImpossibleOR(int* nums, int numsSize){\\n    int mask = 0, ans = 1;\\n    for(int i = 0; i < numsSize; i++)\\n        if(__builtin_popcount(nums[i]) == 1)\\n            mask |= nums[i];\\n    mask = ~mask;\\n\\t\\n    while(!(mask & ans))\\n        ans <<= 1;\\n    \\n    return ans;\\n}"], ["int minImpossibleOR(int* nums, int numsSize){\\n    int mask = 0, ans = 1;\\n    for(int i = 0; i < numsSize; i++)\\n        if(__builtin_popcount(nums[i]) == 1)\\n            mask |= nums[i];\\n    mask = ~mask;\\n\\t\\n    while(!(mask & ans))\\n        ans <<= 1;\\n    \\n    return ans;\\n}"], ["int minImpossibleOR(int* nums, int numsSize){\\n    int mask = 0, ans = 1;\\n    for(int i = 0; i < numsSize; i++)\\n        if(__builtin_popcount(nums[i]) == 1)\\n            mask |= nums[i];\\n    mask = ~mask;\\n\\t\\n    while(!(mask & ans))\\n        ans <<= 1;\\n    \\n    return ans;\\n}"]]}
{"id": "1676", "ref_c": [["int minOperations(int n) {\\n       \\n        int t=0;\\n        while(n!=0){\\n             int x=log2(n);\\n        int dif=abs(n-pow(2,x));\\n        int dif2=pow(2,x+1)-n;\\n         n=min(dif,dif2);\\n            t++;\\n            //cout<<n<<\" \";\\n            \\n        }"], ["int minOperations(int n){\\n\\tassert(n >= 0);\\n\\n\\tint opCnt = 0;\\n\\n\\twhile (n > 0){\\n\\t\\twhile ( (n & 1) == 0 ){\\n\\t\\t\\tn >>= 1;\\n\\t\\t}"], ["int minOperations(int n){\\n    int con=0;\\n    int res=0;\\n    while(n!=0){\\n        if(n&1==1){\\n            con++;\\n        }"]]}
{"id": "1677", "ref_c": [["int** mergeSimilarItems(int** items1, int items1Size, int* items1ColSize, int** items2, int items2Size, int* items2ColSize, int* returnSize, int** returnColumnSizes){\\n    int cnt = 0;\\n    int* itemCnt = (int*)calloc(LEN, sizeof(int));\\n    for(int i = 0; i < items1Size; i++){\\n        if(!itemCnt[items1[i][0]])\\n            cnt++;\\n        itemCnt[items1[i][0]] += items1[i][1];\\n    }"], ["int** mergeSimilarItems(int** items1, int items1Size, int* items1ColSize, int** items2, int items2Size, int* items2ColSize, int* returnSize, int** returnColumnSizes){\\n    int cnt = 0;\\n    int* itemCnt = (int*)calloc(LEN, sizeof(int));\\n    for(int i = 0; i < items1Size; i++){\\n        if(!itemCnt[items1[i][0]])\\n            cnt++;\\n        itemCnt[items1[i][0]] += items1[i][1];\\n    }"], ["int** mergeSimilarItems(int** items1, int items1Size, int* items1ColSize, int** items2, int items2Size, int* items2ColSize, int* returnSize, int** returnColumnSizes){\\n    int cnt = 0;\\n    int* itemCnt = (int*)calloc(LEN, sizeof(int));\\n    for(int i = 0; i < items1Size; i++){\\n        if(!itemCnt[items1[i][0]])\\n            cnt++;\\n        itemCnt[items1[i][0]] += items1[i][1];\\n    }"]]}
{"id": "1678", "ref_c": [["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"]]}
{"id": "1679", "ref_c": [["int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    size=0;\\n\\n    for(int i=0;i<matrixSize;i++)\\n    {\\n        for(int j=0;j<matrixColSize[i];j++)\\n        {\\n            push(matrix[i][j]);\\n        }"], ["int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    size=0;\\n\\n    for(int i=0;i<matrixSize;i++)\\n    {\\n        for(int j=0;j<matrixColSize[i];j++)\\n        {\\n            push(matrix[i][j]);\\n        }"], ["int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    size=0;\\n\\n    for(int i=0;i<matrixSize;i++)\\n    {\\n        for(int j=0;j<matrixColSize[i];j++)\\n        {\\n            push(matrix[i][j]);\\n        }"]]}
{"id": "1680", "ref_c": [["long long coloredCells(int n){\\n       \\n if(n==1)\\n{\\n    return 1;\\n}"], ["long long coloredCells(int n) {\\n    long long  int counter=1,num=0;\\n    \\n    for(int i=1;i<=n;i++){\\n        counter=counter+num;\\n        num=num+4;\\n    }"], ["long long coloredCells(int n) {\\n    long long  int counter=1;\\n    \\n    for(int i=0;i<n;i++){\\n        counter=counter+4*i;\\n        \\n    }"]]}
{"id": "1681", "ref_c": [["int* kthSmallestPrimeFraction(int* arr, int arrSize, int k, int* returnSize){\\n    int i, j, n = arrSize;\\n    int *res = malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n\\n    if (k == 1) {\\n        res[0] = arr[0];\\n        res[1] = arr[n - 1];\\n        return res;\\n    }"], ["int* kthSmallestPrimeFraction(int* arr, int arrSize, int k, int* returnSize){\\n    int i, j, n = arrSize;\\n    int *res = malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n\\n    if (k == 1) {\\n        res[0] = arr[0];\\n        res[1] = arr[n - 1];\\n        return res;\\n    }"], ["int* kthSmallestPrimeFraction(int* arr, int arrSize, int k, int* returnSize){\\n    int i, j, n = arrSize;\\n    int *res = malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n\\n    if (k == 1) {\\n        res[0] = arr[0];\\n        res[1] = arr[n - 1];\\n        return res;\\n    }"]]}
{"id": "1682", "ref_c": [["long long kthLargestLevelSum(struct TreeNode* root, int k){\\n    int h=height(root);\\n    printf(\">-- height : %d\\\\n\",h);\\n    if(h<k) return -1;\\n    long long *res=(long long *)calloc(h,sizeof(long long));\\n    int res_idx=0;\\n    struct TreeNode *queue[100000];\\n    int idx=0;\\n    queue[idx++]=root;\\n    while(idx){\\n        struct TreeNode *pop[idx];\\n        int pop_idx=0;\\n        long long sum=0;\\n        for(int i=0;i<idx;i++){\\n            pop[pop_idx++]=queue[i];\\n            sum+=queue[i]->val;\\n        }"], ["long long kthLargestLevelSum(struct TreeNode* root, int k) {\\n    int d = 0;\\n    ll* sum = (ll*) calloc(100000, sizeof(ll));\\n    dfs(root, sum, 0, &d);\\n    qsort(sum, d+1, sizeof(ll), cmp);\\n    ll ans = (k-1 < d+1) ? sum[k-1] : -1;\\n    free(sum);\\n    return ans;\\n}"], ["long long kthLargestLevelSum(struct TreeNode* root, int k){\\n    int h=height(root);\\n    printf(\">-- height : %d\\\\n\",h);\\n    if(h<k) return -1;\\n    long long *res=(long long *)calloc(h,sizeof(long long));\\n    int res_idx=0;\\n    struct TreeNode *queue[100000];\\n    int idx=0;\\n    queue[idx++]=root;\\n    while(idx){\\n        struct TreeNode *pop[idx];\\n        int pop_idx=0;\\n        long long sum=0;\\n        for(int i=0;i<idx;i++){\\n            pop[pop_idx++]=queue[i];\\n            sum+=queue[i]->val;\\n        }"]]}
{"id": "1683", "ref_c": [["long gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}"], ["long gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}"], ["long gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}"]]}
{"id": "1684", "ref_c": [["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize){\\n    if (returnSize == NULL || n == 0 || edges == NULL)\\n        return NULL;\\n \\n    struct node **depths = calloc(n, sizeof(struct node *));\\n    assert(depths);\\n\\n    assert(edgesSize == (n - 1));\\n\\n    struct node *nodes = calloc(n, sizeof(struct node));\\n    assert(nodes != NULL);\\n  \\n    // Allocate results array\\n    int *result = calloc(n, sizeof(int));\\n    assert(result != NULL);\\n \\n    // Apply each node\\'s label and perform some initializations\\n    for (int i = 0; i < n; i++)\\n    {\\n        nodes[i].label = labels[i];\\n        nodes[i].xparent = (struct node *)(i == 0 ? 0x1 : NULL);\\n        /* The root node\\'s depth must always be 0, for the remaining nodes, the\\n         * depth will be determined when the edge array is parsed.\\n         */\\n        nodes[i].depth = (i == 0 ? 0 : DEPTH_ANY);\\n        nodes[i].sub_tree_alpha_cnt[nodes[i].label - \\'a\\'] = 1;\\n    }"], ["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n;\\n    int *returnArray = malloc(sizeof(int) * n);\\n    int *count = malloc(sizeof(int) * n);\\n    struct Node **root = malloc(sizeof(struct Node *) * n);\\n    struct Node *curNode;\\n\\n    memset(returnArray, 0, sizeof(int) * n);\\n    memset(count, 0, sizeof(int) * n);\\n\\n    for(i = 0; i < edgesSize; i++)\\n    {\\n        count[edges[i][0]] += 1;\\n        count[edges[i][1]] += 1;\\n    }"], ["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize)\\n{\\n    int* count = calloc(26, sizeof(int));\\n    int* ans = malloc(n * sizeof(int));\\n    *returnSize = n;\\n    int** adj = malloc(n * sizeof(int*));\\n    int* adjSize = calloc(n, sizeof(int));\\n    //dynamically allocate and initialize adjacency list\\n    for(int i = 0; i < n - 1; i++)\\n    {\\n        int a = edges[i][0], b = edges[i][1];\\n        if(adjSize[a] == 0)\\n        {\\n            adjSize[a]++;\\n            adj[a] = malloc(sizeof(int));\\n        }"]]}
{"id": "1685", "ref_c": [["int** findSolution(int (*customFunction)(int, int), int z, int* returnSize, int** returnColumnSizes) {\\n    int **a = malloc(sizeof(int *[z])), k = 0;\\n\\tint *c = *returnColumnSizes = malloc(sizeof(int [z]));\\n    for (int i = 1 ; i <= z ; i++)\\n        for (int j = z ; j >= 1 ; j--)\\n            if (customFunction(i, j) == z)\\n                (a[k] = malloc(sizeof(int [c[k] = 2])))[0] = i, a[k++][1] = j;\\n    return *returnSize = k, a;\\n}"], ["int** findSolution(int (*customFunction)(int, int), int z, int* returnSize, int** returnColumnSizes) {\\n\\t/*\\n     * Input:\\n     *  customFunction, function pointer points to the hidden implementations of CustomFunction\\n     *  z, integer, f(x, y) = z\\n     */\\n     \\n    int **ans = (int **)malloc(sizeof(int *) * 1000000);\\n    \\n    *returnColumnSizes = (int *)malloc(sizeof(int) * 1000000);\\n    *returnSize = 0;\\n    \\n    for (int x = 1; x <= 1000; x++) {\\n        for (int y = 1; y <= 1000; y++) {\\n        \\n            if (customFunction(x, y) == z) {\\n                ans[*returnSize] = (int *)malloc(sizeof(int) * 2);\\n                ans[*returnSize][0] = x;\\n                ans[*returnSize][1] = y;\\n                (*returnColumnSizes)[*returnSize] = 2;\\n                (*returnSize)++;\\n            }"], ["int** findSolution(int (*customFunction)(int, int), int z, int* returnSize, int** returnColumnSizes) {\\n    int **a = malloc(sizeof(int *[z])), k = 0;\\n\\tint *c = *returnColumnSizes = malloc(sizeof(int [z]));\\n    for (int i = 1 ; i <= z ; i++)\\n        for (int j = z ; j >= 1 ; j--)\\n            if (customFunction(i, j) == z)\\n                (a[k] = malloc(sizeof(int [c[k] = 2])))[0] = i, a[k++][1] = j;\\n    return *returnSize = k, a;\\n}"]]}
{"id": "1686", "ref_c": [["long long findScore(int* nums, int numsSize) {\\n    if (numsSize == 1) return (ll)nums[0];\\n    struct pair* arr = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n    bool* IsMarked = (bool*) calloc(numsSize, sizeof(bool));\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].val = nums[i];\\n        arr[i].idx = i;\\n    }"], ["long long findScore(int* nums, int numsSize) {\\n    if (numsSize == 1) return (ll)nums[0];\\n    struct pair* arr = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n    bool* IsMarked = (bool*) calloc(numsSize, sizeof(bool));\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].val = nums[i];\\n        arr[i].idx = i;\\n    }"], ["long long findScore(int* nums, int numsSize) {\\n    if (numsSize == 1) return (ll)nums[0];\\n    struct pair* arr = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n    bool* IsMarked = (bool*) calloc(numsSize, sizeof(bool));\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].val = nums[i];\\n        arr[i].idx = i;\\n    }"]]}
{"id": "1687", "ref_c": [["long long repairCars(int* ranks, int ranksSize, int cars) {\\n    // Binary search\\n\\n    // Time complexity: O(log(min(ranks) * cars^2))\\n    // Space complexity: O(1)\\n    \\n    long long left = 0LL;\\n    long long right = 1LL * min_element(ranks, ranksSize) * cars * cars;  // r * n^2\\n\\n    while (left < right) {\\n        const long long middle = left + (right - left) / 2;\\n        if (numCarsFixed(ranks, ranksSize, middle) >= cars) \\n            right = middle;\\n        else\\n            left = middle + 1;\\n    }"], ["long long repairCars(int* ranks, int ranksSize, int cars) {\\n    // Binary search\\n\\n    // Time complexity: O(log(min(ranks) * cars^2))\\n    // Space complexity: O(1)\\n    \\n    long long left = 0LL;\\n    long long right = 1LL * min_element(ranks, ranksSize) * cars * cars;  // r * n^2\\n\\n    while (left < right) {\\n        const long long middle = left + (right - left) / 2;\\n        if (numCarsFixed(ranks, ranksSize, middle) >= cars) \\n            right = middle;\\n        else\\n            left = middle + 1;\\n    }"], ["long long repairCars(int* ranks, int ranksSize, int cars) {\\n    // Binary search\\n\\n    // Time complexity: O(log(min(ranks) * cars^2))\\n    // Space complexity: O(1)\\n    \\n    long long left = 0LL;\\n    long long right = 1LL * min_element(ranks, ranksSize) * cars * cars;  // r * n^2\\n\\n    while (left < right) {\\n        const long long middle = left + (right - left) / 2;\\n        if (numCarsFixed(ranks, ranksSize, middle) >= cars) \\n            right = middle;\\n        else\\n            left = middle + 1;\\n    }"]]}
{"id": "1688", "ref_c": [["bool checkValidGrid(int** grid, int gridSize, int* gridColSize) {\\n    if(grid[0][0]) return false;\\n    \\n    int rem = (gridSize * (*gridColSize)) -  1;\\n\\n    return move(grid, gridSize, gridColSize, 0, 0, rem);\\n}"], ["bool checkValidGrid(int** grid, int gridSize, int* gridColSize) {\\n    if(grid[0][0]) return false;\\n    \\n    int rem = (gridSize * (*gridColSize)) -  1;\\n\\n    return move(grid, gridSize, gridColSize, 0, 0, rem);\\n}"], ["bool checkValidGrid(int** grid, int gridSize, int* gridColSize) {\\n    if(grid[0][0]) return false;\\n    \\n    int rem = (gridSize * (*gridColSize)) -  1;\\n\\n    return move(grid, gridSize, gridColSize, 0, 0, rem);\\n}"]]}
{"id": "1689", "ref_c": [["struct TreeNode* lcaDeepestLeaves(struct TreeNode* root) {\\n    int currentDepth = 0;\\n    return lcaDeepestLeavesRecur(root, &currentDepth);\\n}"], ["struct TreeNode* lcaDeepestLeaves(struct TreeNode* root) {\\n    // DFS method \\n\\n    // Time complexity: O(tree height)\\n    // Space complexity: O(tree height)\\n    \\n    if (root == NULL) \\n        return NULL;\\n    const int left = getDepth(root->left), right = getDepth(root->right);\\n    if (left == right) \\n        return root;\\n    return (left > right) ? lcaDeepestLeaves(root->left) : lcaDeepestLeaves(root->right);\\n}"], ["struct TreeNode* lcaDeepestLeaves(struct TreeNode* root) {\\n    int currentDepth = 0;\\n    return lcaDeepestLeavesRecur(root, &currentDepth);\\n}"]]}
{"id": "1690", "ref_c": [["int findSmallestInteger(int* nums, int numsSize, int value){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  value,\\n     */\\n\\n    //\\n    // The question is that is it possible to add value to any element\\n    // or sub value from any element to produce the next \"missing positive number\"\\n    // and maximum the MEX\\n    //,\\n    // E.g, nums = [-1, -2], value = 1\\n    //  => First missing positive number is 0, we want to produce 0\\n    //  => 0 can be produce by -1 + 1, or -2 + 2\\n    //  nums = [-1, 0]\\n    //  => next missing positive number is 1, we want to produce 1\\n    //  => 0 can be produce by -1 + 1,\\n    //  nums = [0, 1]   => MAX MEX is 2\\n    \\n    item_t *hash[HASH_MOD] = {0}"], ["int findSmallestInteger(int* nums, int numsSize, int value){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  value,\\n     */\\n\\n    //\\n    // The question is that is it possible to add value to any element\\n    // or sub value from any element to produce the next \"missing positive number\"\\n    // and maximum the MEX\\n    //,\\n    // E.g, nums = [-1, -2], value = 1\\n    //  => First missing positive number is 0, we want to produce 0\\n    //  => 0 can be produce by -1 + 1, or -2 + 2\\n    //  nums = [-1, 0]\\n    //  => next missing positive number is 1, we want to produce 1\\n    //  => 0 can be produce by -1 + 1,\\n    //  nums = [0, 1]   => MAX MEX is 2\\n    \\n    item_t *hash[HASH_MOD] = {0}"], ["int findSmallestInteger(int* nums, int numsSize, int value){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  value,\\n     */\\n\\n    //\\n    // The question is that is it possible to add value to any element\\n    // or sub value from any element to produce the next \"missing positive number\"\\n    // and maximum the MEX\\n    //,\\n    // E.g, nums = [-1, -2], value = 1\\n    //  => First missing positive number is 0, we want to produce 0\\n    //  => 0 can be produce by -1 + 1, or -2 + 2\\n    //  nums = [-1, 0]\\n    //  => next missing positive number is 1, we want to produce 1\\n    //  => 0 can be produce by -1 + 1,\\n    //  nums = [0, 1]   => MAX MEX is 2\\n    \\n    item_t *hash[HASH_MOD] = {0}"]]}
{"id": "1691", "ref_c": [["char * baseNeg2(int n){\\n    if(!n) return \"0\";\\n    char* ans = (char*)calloc(100, sizeof(char));\\n    int ansIdx = 100;\\n    ans[--ansIdx] = \\'\\\\0\\';\\n    while(n){\\n        ans[--ansIdx] = (n & 1) + 0x30;\\n        n = -(n >> 1);\\n    }"], ["char * baseNeg2(int n){\\n    if(!n) return \"0\";\\n    char* ans = (char*)calloc(100, sizeof(char));\\n    int ansIdx = 100;\\n    ans[--ansIdx] = \\'\\\\0\\';\\n    while(n){\\n        ans[--ansIdx] = (n & 1) + 0x30;\\n        n = -(n >> 1);\\n    }"], ["char * baseNeg2(int n){\\n    if(!n) return \"0\";\\n    char* ans = (char*)calloc(100, sizeof(char));\\n    int ansIdx = 100;\\n    ans[--ansIdx] = \\'\\\\0\\';\\n    while(n){\\n        ans[--ansIdx] = (n & 1) + 0x30;\\n        n = -(n >> 1);\\n    }"]]}
{"id": "1692", "ref_c": [["long long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\\n*returnSize=queriesSize;\\nlong long *ans=(long long*)malloc(sizeof(long long)*(*returnSize));\\nqsort(nums,numsSize,sizeof(int),cmp);\\nlong long prefix_sum[numsSize];\\nlong long suffix_sum[numsSize];\\nprefix_sum[0]=nums[0];\\nfor(int i=1;i<numsSize;i++)\\n{\\n    prefix_sum[i]=prefix_sum[i-1]+nums[i];\\n}"], ["long long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    long long *temp=(long long*)calloc(numsSize,sizeof(long long));\\n    long long  *res=(long long*)calloc(queriesSize,sizeof(long long));\\n    temp[0]=nums[0];\\n    for(int i=1;i<numsSize;i++){\\n        temp[i]=nums[i]+temp[i-1];\\n    }"], ["long long* minOperations(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize){\\n    long long* prefixSum = (long long*)calloc(numsSize + 1, sizeof(long long));\\n    long long* ans = (long long*)calloc(queriesSize, sizeof(long long));\\n\\t/* sort nums */\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\t/* calculate prefixsum */\\n    for(int i = 1; i <= numsSize; i++)\\n        prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n\\t/* binary search to find out the index in nums that larger than queries[i] */\\n    for(int i = 0; i < queriesSize; i++){\\n        /* use binary search to find out the query \\'s position in the nums */\\n        if(queries[i] < nums[0])\\n            ans[i] = prefixSum[numsSize] - (long long)queries[i] * numsSize;\\n        else if(queries[i] > nums[numsSize - 1])\\n            ans[i] = (long long)queries[i] * numsSize - prefixSum[numsSize];\\n        else{\\n            /* we want to find nums[l] > q[i] */\\n            int l = 0, r = numsSize - 1, m;\\n            while(l < r){\\n                m = l + ((r - l) >> 1);\\n                if(nums[m] < queries[i])\\n                    l = m + 1;\\n                else //if(nums[m] > queries[i])\\n                    r = m;\\n            }"]]}
{"id": "1693", "ref_c": [["int maximumCostSubstring(char * s, char * chars, int* vals, int valsSize){\\n    int currSum = 0, ans = 0, slen = strlen(chars);\\n    int* score = (int*)calloc(26, sizeof(int));\\n\\t/* initial cost by index */\\n    for(int i = 0; i < 26; i++)\\n        score[i] = i+1;    \\n\\t/* update by vals */\\n    for(int i = 0; i < slen; i++)\\n        score[chars[i] - \\'a\\'] = vals[i];\\n    \\n    slen = strlen(s);\\n    for(int i = 0; i < slen; i++){\\n        int cost = score[s[i]-\\'a\\'];\\n        currSum += cost;\\n        if(currSum < 0)\\n            currSum = 0;\\n        ans = MAX(ans, currSum);\\n    }"], ["int maximumCostSubstring(char * s, char * chars, int* vals, int valsSize){\\n    int currSum = 0, ans = 0, slen = strlen(chars);\\n    int* score = (int*)calloc(26, sizeof(int));\\n\\t/* initial cost by index */\\n    for(int i = 0; i < 26; i++)\\n        score[i] = i+1;    \\n\\t/* update by vals */\\n    for(int i = 0; i < slen; i++)\\n        score[chars[i] - \\'a\\'] = vals[i];\\n    \\n    slen = strlen(s);\\n    for(int i = 0; i < slen; i++){\\n        int cost = score[s[i]-\\'a\\'];\\n        currSum += cost;\\n        if(currSum < 0)\\n            currSum = 0;\\n        ans = MAX(ans, currSum);\\n    }"], ["int maximumCostSubstring(char * s, char * chars, int* vals, int valsSize){\\n    int currSum = 0, ans = 0, slen = strlen(chars);\\n    int* score = (int*)calloc(26, sizeof(int));\\n\\t/* initial cost by index */\\n    for(int i = 0; i < 26; i++)\\n        score[i] = i+1;    \\n\\t/* update by vals */\\n    for(int i = 0; i < slen; i++)\\n        score[chars[i] - \\'a\\'] = vals[i];\\n    \\n    slen = strlen(s);\\n    for(int i = 0; i < slen; i++){\\n        int cost = score[s[i]-\\'a\\'];\\n        currSum += cost;\\n        if(currSum < 0)\\n            currSum = 0;\\n        ans = MAX(ans, currSum);\\n    }"]]}
{"id": "1694", "ref_c": [["int minOperations(int* nums, int numsSize){\\n    int ops = 0;\\n    for (int i = 0; i < numsSize - 1; i++) {\\n        if (nums[i] >= nums[i+1]) {\\n            const int d = nums[i] - nums[i+1] + 1;\\n            nums[i+1] += d;\\n            ops += d;\\n        }"], ["int minOperations(int* nums, int numsSize){\\n    int count=0,i;\\n    for(i=0;i<numsSize-1;i++){\\n        if(nums[i]>=nums[i+1]){\\n            int val=(nums[i]-nums[i+1]+1);\\n            nums[i+1]=nums[i+1]+val;\\n            count+=val;\\n        }"], ["int minOperations(int* nums, int numsSize){\\n    int count = 0;\\n    for(int i = 0; i < numsSize-1; i++)\\n    {\\n        if(nums[i] >= nums[i+1])\\n        {\\n            count  +=  nums[i]+1 - nums[i+1];\\n            nums[i+1] = nums[i]+1;\\n        }"]]}
{"id": "1695", "ref_c": [["int** findMatrix(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int **res=(int**)malloc(sizeof(int*)*numsSize);\\n    *returnColumnSizes=(int*)calloc(numsSize,sizeof(int));\\n    *returnSize=0;\\n    int *count=(int*)calloc(numsSize+1,sizeof(int));\\n    for(int i=0;i<numsSize;i++){\\n        if((*returnColumnSizes)[count[nums[i]]]==0){\\n            res[count[nums[i]]]=(int*)malloc(sizeof(int)*numsSize);\\n            res[count[nums[i]]][0]=nums[i];\\n        }"], ["int** findMatrix(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int max_num_matrixes = 0;\\n    int* all_nums = (int*)calloc(numsSize + 1, sizeof(int));\\n    for (int i = 0; i < numsSize; ++i) {\\n        all_nums[nums[i]] += 1;\\n        max_num_matrixes = all_nums[nums[i]] > max_num_matrixes ? all_nums[nums[i]] : max_num_matrixes;\\n    }"], ["int** findMatrix(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int* cnt = (int*)calloc(201, sizeof(int));\\n    int maxCnt = 0;\\n    for(int i = 1; i <= 200; i++)\\n        cnt[i] = i;    \\n    for(int i = 0; i < numsSize; i++){\\n        cnt[nums[i]] += (1 << 8);\\n        maxCnt = MAX(maxCnt, cnt[nums[i]]);\\n    }"]]}
{"id": "1696", "ref_c": [["int arrayPairSum(int* nums, int numsSize){\\nqsort(nums,numsSize,sizeof(int),cmp);\\nint sum=0;\\nfor(int i=0;i<numsSize;i=i+2){\\n    sum += nums[i];\\n}"], ["int arrayPairSum(int* nums, int numsSize){\\nqsort(nums,numsSize,sizeof(int),cmp);\\nint sum=0;\\nfor(int i=0;i<numsSize;i=i+2){\\n    sum += nums[i];\\n}"], ["int arrayPairSum(int* nums, int numsSize){\\n    int sum = 0;\\n    qsort(nums, numsSize, sizeof(int), comparator);\\n    for (int i = 0; i < numsSize; i+=2)\\n    {\\n        /* code */\\n        sum += nums[i];\\n    }"]]}
{"id": "1697", "ref_c": [["long long* distance(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize;\\n    ll* ans = (ll) calloc(numsSize, sizeof(ll));\\n    if (numsSize > 1) {\\n        struct pair* pair = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n        for (int i = 0; i < numsSize; i++) {\\n            pair[i].val = nums[i];\\n            pair[i].ori_idx = i;\\n        }"], ["long long* distance(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize;\\n    ll* ans = (ll) calloc(numsSize, sizeof(ll));\\n    if (numsSize > 1) {\\n        struct pair* pair = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n        for (int i = 0; i < numsSize; i++) {\\n            pair[i].val = nums[i];\\n            pair[i].ori_idx = i;\\n        }"], ["long long* distance(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize;\\n    ll* ans = (ll) calloc(numsSize, sizeof(ll));\\n    if (numsSize > 1) {\\n        struct pair* pair = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n        for (int i = 0; i < numsSize; i++) {\\n            pair[i].val = nums[i];\\n            pair[i].ori_idx = i;\\n        }"]]}
{"id": "1698", "ref_c": [["int minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }"], ["int minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }"], ["int minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }"]]}
{"id": "1707", "ref_c": ["\nlong long* findPrefixScore(int* nums, int numsSize, int* returnSize)\n{\n    long long int max = 0, c = 0;\n    *returnSize = numsSize;\n    long long int * a = malloc(*returnSize *sizeof(long int));\n    for(int i = 0; i < *returnSize; i++) \n    {\n       max = nums[i] > max ? nums[i] : max;\n       c += nums[i] + max;\n       a[i] = c;\n    }\n    return a;\n}\n", "\nlong long* findPrefixScore(int* nums, int numsSize, int* returnSize)\n{\n    long long int max = 0, c = 0;\n    *returnSize = numsSize;\n    long long int * a = malloc(*returnSize *sizeof(long int));\n    for(int i = 0; i < *returnSize; i++) \n    {\n       max = nums[i] > max ? nums[i] : max;\n       c += nums[i] + max;\n       a[i] = c;\n    }\n    return a;\n}\n", "\nlong long* findPrefixScore(int* nums, int numsSize, int* returnSize)\n{\n    long long int max = 0, c = 0;\n    *returnSize = numsSize;\n    long long int * a = malloc(*returnSize *sizeof(long int));\n    for(int i = 0; i < *returnSize; i++) \n    {\n       max = nums[i] > max ? nums[i] : max;\n       c += nums[i] + max;\n       a[i] = c;\n    }\n    return a;\n}\n"]}
{"id": "1708", "ref_c": [["struct TreeNode* replaceValueInTree(struct TreeNode* root) {\\n    int* sum = (int*) calloc(100000, sizeof(int));\\n    dfs1(root, sum, 0);\\n    root->val -= dfs2(root, sum, 0);\\n    free(sum);\\n    return root;\\n}"], ["struct TreeNode* replaceValueInTree(struct TreeNode* root){\\n    int d=depth(root,0);\\n    printf(\"depth : %d\\\\n\",d);\\n    int *sum=calloc(d,sizeof(int));\\n    levelsum(sum,root,0);\\n    updatesum(sum,root,root->val,0);\\n    return root;\\n}"], ["struct TreeNode* replaceValueInTree(struct TreeNode* root) {\\n    int* sum = (int*) calloc(100000, sizeof(int));\\n    dfs1(root, sum, 0);\\n    root->val -= dfs2(root, sum, 0);\\n    free(sum);\\n    return root;\\n}"]]}
{"id": "1709", "ref_c": [["int addMinimum(char * word){\\n    int len=strlen(word);\\n    if(len==1) return 2;\\n    int idx=0;\\n    int ans=0;\\n    while(idx<len){\\n        if(idx==len-1){\\n            ans+=2;\\n            idx++;\\n        }"], ["int addMinimum(char * word){\\n    int len=strlen(word);\\n    if(len==1) return 2;\\n    int idx=0;\\n    int ans=0;\\n    while(idx<len){\\n        if(idx==len-1){\\n            ans+=2;\\n            idx++;\\n        }"], ["int addMinimum(char * word){\\n    int len=strlen(word);\\n    if(len==1) return 2;\\n    int idx=0;\\n    int ans=0;\\n    while(idx<len){\\n        if(idx==len-1){\\n            ans+=2;\\n            idx++;\\n        }"]]}
{"id": "1711", "ref_c": [["int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }"], ["int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize)\\n{\\n    int en=0,ex=initialExperience,i,h=0,min=0;\\n    for(i=0;i<energySize;i++)\\n    {\\n        en+=energy[i];\\n        if(ex<=experience[i])\\n        {\\n            h+=(experience[i]-ex+1);\\n            ex+=(experience[i]-ex+1);\\n        }"], ["int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }"]]}
{"id": "1712", "ref_c": [["int searchInsert(int* nums, int numsSize, int target){\\n    int index1 = -1;\\n    int index2 = -1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            index1 = i;\\n            break;\\n        }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"]]}
{"id": "1713", "ref_c": [["int* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\\n    int* c = (int*)calloc(ASize, sizeof(int));\\n    int* count = (int*)calloc(ASize+1, sizeof(int));\\n    int commonCnt = 0;\\n    for(int i = 0; i < ASize; i++){\\n        count[A[i]]++;\\n        count[B[i]]++;\\n        if(count[A[i]] == 2) commonCnt++;\\n        if(count[B[i]] == 2 && A[i] != B[i]) commonCnt++;\\n        c[i] = commonCnt;\\n    }"], ["int* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\\n    int* c = (int*)calloc(ASize, sizeof(int));\\n    int* count = (int*)calloc(ASize+1, sizeof(int));\\n    int commonCnt = 0;\\n    for(int i = 0; i < ASize; i++){\\n        count[A[i]]++;\\n        count[B[i]]++;\\n        if(count[A[i]] == 2) commonCnt++;\\n        if(count[B[i]] == 2 && A[i] != B[i]) commonCnt++;\\n        c[i] = commonCnt;\\n    }"], ["int* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\\n    int* c = (int*)calloc(ASize, sizeof(int));\\n    int* count = (int*)calloc(ASize+1, sizeof(int));\\n    int commonCnt = 0;\\n    for(int i = 0; i < ASize; i++){\\n        count[A[i]]++;\\n        count[B[i]]++;\\n        if(count[A[i]] == 2) commonCnt++;\\n        if(count[B[i]] == 2 && A[i] != B[i]) commonCnt++;\\n        c[i] = commonCnt;\\n    }"]]}
{"id": "1714", "ref_c": [["int findMaxFish(int** grid, int gridSize, int* gridColSize) {\\n    int ans = 0, cnt = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] != 0) {\\n                dfs(grid, i, j, gridSize, gridColSize[i], &cnt);\\n                ans = MAX(ans, cnt);\\n                cnt = 0;\\n            }"], ["int findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1 && *gridColSize == 1)\\n        return grid[0][0];\\n        \\n    int m = gridSize, n = *gridColSize, i, j, sum = 0, ans = 0;\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++){\\n            if (grid[i][j]) {\\n                sum = 0;\\n                helper(i, j, m, n, &sum, &ans, grid);\\n            }"], ["int findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    int tmp = 0;\\n    int max = 0;\\n\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j]) {\\n                tmp = traverse(grid, i, j, gridSize, *gridColSize);\\n                max = (tmp > max)? tmp : max;\\n            }"]]}
{"id": "1715", "ref_c": [["int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\\n\\n    /*\\n     * Input:\\n     *  *arr\\n     *  arrSize\\n     *  **mat\\n     *  matSize\\n     *  *matColSize\\n     */\\n\\n    int **lookup = (int **)malloc(sizeof(int *) * (matSize * matColSize[0] + 1));\\n    int *row = (int *)calloc(1, sizeof(int) * matSize);\\n    int *col = (int *)calloc(1, sizeof(int) * matColSize[0]);\\n    int ans = 0;\\n\\n    for (int i = 0; i < (matSize * matColSize[0] + 1); i++) {\\n        lookup[i] = (int *)malloc(sizeof(int) * 2);\\n    }"], ["int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\\n\\n    /*\\n     * Input:\\n     *  *arr\\n     *  arrSize\\n     *  **mat\\n     *  matSize\\n     *  *matColSize\\n     */\\n\\n    int **lookup = (int **)malloc(sizeof(int *) * (matSize * matColSize[0] + 1));\\n    int *row = (int *)calloc(1, sizeof(int) * matSize);\\n    int *col = (int *)calloc(1, sizeof(int) * matColSize[0]);\\n    int ans = 0;\\n\\n    for (int i = 0; i < (matSize * matColSize[0] + 1); i++) {\\n        lookup[i] = (int *)malloc(sizeof(int) * 2);\\n    }"], ["int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\\n    int m = matSize, n = *matColSize;\\n    Pair pair[m * n + 1];\\n    int i, j, t, filledRow[m], filledCol[n];\\n    memset(filledRow, 0, sizeof(filledRow));\\n    memset(filledCol, 0, sizeof(filledCol));\\n    memset(pair, 0, sizeof(pair));\\n    for (i = 0; i < m; ++i) {\\n        for (j = 0; j < n; ++j) {\\n            t = mat[i][j];\\n            pair[t].row = i;\\n            pair[t].col = j; \\n        }"]]}
{"id": "1716", "ref_c": [["int* closestPrimes(int left, int right, int* returnSize) {\\n  int nums = right - left + 1;\\n  int *primes = (int *)malloc(sizeof(int) * nums);\\n  int *primes2 = (int *)malloc(sizeof(int) * 2); \\n\\n  int num_of_primes = 0;\\n  // get all primes from the range of [left, right];\\n  for (int i = left; i <= right; i++) {\\n    if (IsPrime(i)) {\\n      primes[num_of_primes++] = i;\\n    }"], ["int* closestPrimes(int left, int right, int* returnSize) {\\n  int nums = right - left + 1;\\n  int *primes = (int *)malloc(sizeof(int) * nums);\\n  int *primes2 = (int *)malloc(sizeof(int) * 2); \\n\\n  int num_of_primes = 0;\\n  // get all primes from the range of [left, right];\\n  for (int i = left; i <= right; i++) {\\n    if (IsPrime(i)) {\\n      primes[num_of_primes++] = i;\\n    }"], ["int* closestPrimes(int left, int right, int* returnSize) {\\n    int* closestPrimes = (int*)malloc(2 * sizeof(int));\\n    closestPrimes[0] = -1;\\n    closestPrimes[1] = -1;\\n    if (right <= 1) {\\n        *returnSize = 2;\\n        return closestPrimes;\\n    }"]]}
{"id": "1718", "ref_c": [["bool containsPattern(int* arr, int arrSize, int m, int k){\\n\\n    int cnt = 0;\\n    for(int i = 0; i+m < arrSize; i++){\\n        if(arr[i] != arr[i+m]) cnt = 0;\\n        else cnt++;\\n        if(cnt == (k-1)*m) return true;\\n    }"], ["bool containsPattern(int* arr, int arrSize, int m, int k){\\n\\n    int cnt = 0;\\n    for(int i = 0; i+m < arrSize; i++){\\n        if(arr[i] != arr[i+m]) cnt = 0;\\n        else cnt++;\\n        if(cnt == (k-1)*m) return true;\\n    }"], ["bool containsPattern(int* arr, int arrSize, int m, int k){\\n\\n    int cnt = 0;\\n    for(int i = 0; i+m < arrSize; i++){\\n        if(arr[i] != arr[i+m]) cnt = 0;\\n        else cnt++;\\n        if(cnt == (k-1)*m) return true;\\n    }"]]}
{"id": "1719", "ref_c": [["int minIncrements(int n, int* cost, int costSize){\\n    int result = 0;\\n    balance(0,cost,costSize,&result);\\n    return result;\\n}"], ["int minIncrements(int n, int* cost, int costSize){\\n    int result = 0;\\n    balance(0,cost,costSize,&result);\\n    return result;\\n}"], ["int minIncrements(int n, int* cost, int costSize){\\n    int result = 0;\\n    balance(0,cost,costSize,&result);\\n    return result;\\n}"]]}
{"id": "1720", "ref_c": [["int matrixSum(int** nums, int numsSize, int* numsColSize){\\n\\n    int  score      = 0;\\n    int  rows       = numsSize;\\n    int  cols       = *numsColSize;\\n    int  max_val    = INT_MIN;\\n\\n    for (int i = 0; i < rows; i++)\\n    {\\n        /* Iteratve over all rows, sort the list in every row in descending order */\\n        qsort(nums[i], *numsColSize, sizeof(int), comp);\\n    }"], ["int matrixSum(int** nums, int numsSize, int* numsColSize){\\n    int ans = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        qsort(nums[i], numsColSize[i], sizeof(int), cmp);\\n    }"], ["int matrixSum(int** nums, int numsSize, int* numsColSize){\\n\\n    int  score      = 0;\\n    int  rows       = numsSize;\\n    int  cols       = *numsColSize;\\n    int  max_val    = INT_MIN;\\n\\n    for (int i = 0; i < rows; i++)\\n    {\\n        /* Iteratve over all rows, sort the list in every row in descending order */\\n        qsort(nums[i], *numsColSize, sizeof(int), comp);\\n    }"]]}
{"id": "1721", "ref_c": [["long long maximumOr(int* nums, int numsSize, int k){\\n    int union_nums = 0, intersection = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        intersection |= union_nums & nums[i];\\n        union_nums |= nums[i];\\n    }"], ["long long maximumOr(int* nums, int numsSize, int k){\\n    int union_nums = 0, intersection = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        intersection |= union_nums & nums[i];\\n        union_nums |= nums[i];\\n    }"], ["long long maximumOr(int* nums, int numsSize, int k) {\\n    long long ans = 0, mul = 1;\\n    long long *pre = (long long*)malloc(numsSize * sizeof(long long));\\n    long long *suf = (long long*)malloc(numsSize * sizeof(long long));\\n    pre[0] = nums[0];\\n    suf[numsSize - 1] = nums[numsSize - 1];\\n    for (int i = 1; i < numsSize; ++i) {\\n        pre[i] = pre[i - 1] | nums[i];\\n        suf[numsSize - i - 1] = suf[numsSize - i] | nums[numsSize - i - 1];\\n    }"]]}
{"id": "1722", "ref_c": [["bool doesValidArrayExist(int* derived, int derivedSize){\\n    int res=0;\\n    for(int i=0;i<derivedSize;i++){\\n        res^=derived[i];\\n    }"], ["bool doesValidArrayExist(int* derived, int derivedSize){\\n    int res=0;\\n    for(int i=0;i<derivedSize;i++){\\n        res^=derived[i];\\n    }"], ["bool doesValidArrayExist(int* derived, int derivedSize){\\n\\treturn sum_ints(derived, derivedSize) % 2 == 0;\\n}"]]}
{"id": "1723", "ref_c": [["int maxMoves(int** grid, int gridSize, int* gridColSize){\\n\\n    /*\\n     * Input:\\n     *  **grid\\n     *  gridSize\\n     *  *gridColSize\\n     */\\n\\n    int cnt, ans = 0, **dp = (int **)malloc(sizeof(int *) * gridSize);\\n\\n    for (int i = 0; i < gridSize; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * gridColSize[i]);\\n\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int maxMoves(int** grid, int gridSize, int* gridColSize){\\n\\tint dp[gridSize];\\n\\tmemset( &dp, 0, sizeof (dp) );\\n\\n\\tfor (int col = *gridColSize - 2; col >= 0; col -= 1){\\n\\t\\tint dp_new[gridSize];\\n\\t\\tmemset( &dp_new, 0, sizeof (dp_new) );\\n\\n\\t\\tconst int col2 = col + 1;\\n\\t\\tfor (int row = 0; row < gridSize; row += 1){\\n\\t\\t\\tfor (int rowOffset = -1; rowOffset <= 1; rowOffset += 1){\\n\\t\\t\\t\\tconst int row2 = row + rowOffset;\\n\\t\\t\\t\\tif (!( row2 >= 0 && row2 < gridSize )){\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}"], ["int maxMoves(int** grid, int gridSize, int* gridColSize){\\n\\n    /*\\n     * Input:\\n     *  **grid\\n     *  gridSize\\n     *  *gridColSize\\n     */\\n\\n    int cnt, ans = 0, **dp = (int **)malloc(sizeof(int *) * gridSize);\\n\\n    for (int i = 0; i < gridSize; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * gridColSize[i]);\\n\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            dp[i][j] = -1;\\n        }"]]}
{"id": "1724", "ref_c": [["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0;\\n    for (int i = 0; i != numsSize; i++)\\n    {\\n        for (int j = 0; j != numsSize; j++)\\n        {\\n            if (i != j && (nums[i] - nums[j]) == k)\\n            {\\n                count++;\\n            }"], ["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0; \\n\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = i+1; j < numsSize; j++){\\n            if(abs(nums[i] - nums[j]) == k){\\n                count += 1; \\n            }"], ["int countKDifference(int* nums, int numsSize, int k){\\n    int count = 0;\\n    for(int i = 0; i < numsSize; i++)\\n        for(int j = i; j  < numsSize; j++)\\n            if(nums[i] - nums[j] == k || nums[j]  - nums[i] == k)\\n                count++;\\n\\n    \\n    return count;\\n}"]]}
{"id": "1727", "ref_c": [["int punishmentNumber(int n) {\\n        // Math + Backtracking\\n\\n        // Time complexity: O(2^n)\\n        // Space comeplxity: O(n)\\n\\n        char s[8];\\n        int result = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            const int x = i * i;\\n            memset(s, \\'\\\\0\\', 8);\\n            sprintf(s, \"%d\", x);\\n            if (!isPossible(0, 0, s, 0, i)) continue;\\n            result += x;\\n        }", "int punishmentNumber(int n) {\\n        // Exhaustive search + DFS\\n\\n        // Time complexity: O(n^{1 + 2*log10(2)}"], ["int punishmentNumber(int n) {\\n     \\n        int ans = 0;\\n        for (int i = 1;i<=n;i++)\\n        {\\n            int num = i;\\n            int sq = i*i;\\n            string str = \"\";\\n            str += to_string(sq);\\n            if (fun(0,str,0,num))\\n            {\\n                ans += sq;\\n            }"], ["int punishmentNumber(int n){\\n    int start = 1;\\n    int result = 0;\\n\\n    while (start <= n)\\n    {\\n        int sum  = 0; \\n        int j = start * start;\\n        int div  = divNumber(j);\\n        \\n        if ((solve(j, start, sum,div) == 1))\\n        {\\n            result += j;\\n        }"]]}
{"id": "1729", "ref_c": [["int minExtraChar(char * s, char ** dictionary, int dictionarySize){\\n    /*\\n     * Input:\\n     *  s, 1 <= len <= 50\\n     *  dictionary\\n     *  dictionarySize\\n     */\\n\\n    /*\\n     * Algorithm:\\n     *  Store the words in Trie\\n     *  Scan character 0 ~ n - 1 in s, check if any 0 ~ n - 1 sustring matches the words\\n     *      Skip number of characters and contine to compare the rest characters\\n     *      or skip current character and contine to compare the rest characters\\n     */\\n\\n    node_t *trie = NULL;\\n    int min = 0, len = strlen(s), *dp;\\n\\n    trie_init(&trie);\\n\\n    /* Allocate dp[n - 1][n] DP table, n is the length of s */\\n    dp = (int *)malloc(sizeof(int *) * len);\\n\\n    for (int i = 0; i < len; i++) {\\n        dp[i] = -1;\\n    }"], ["int minExtraChar(char * s, char ** dictionary, int dictionarySize){\\n    memset(memo, -1, sizeof(memo));\\n    return strlen(s) - findMaxLen(s, dictionary, 0, 0, dictionarySize, strlen(s));\\n}"], ["int minExtraChar(char * s, char ** dictionary, int dictionarySize){\\n    memset(memo, -1, sizeof(memo));\\n    return strlen(s) - findMaxLen(s, dictionary, 0, 0, dictionarySize, strlen(s));\\n}"]]}
{"id": "1730", "ref_c": ["\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\n\treturn *p1 - *p2;\n}\n\nint64_t maxStrength(int * const nums, const int numsLen){\n\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\n\n\tbool numUsed = false;\n\tint64_t product = 1;\n\n\t//positive from right\n\tfor (int i = numsLen - 1; i >= 0 && nums[i] > 0; i -= 1){\n\t\tnumUsed = true;\n\t\tproduct *= nums[i];\n\t}\n\t//negative pairs from left\n\tfor (int i = 1; i < numsLen && nums[i] < 0; i += 2){\n\t\tnumUsed = true;\n\t\tproduct *= (int64_t)nums[i - 1] * (int64_t)nums[i];\t\t\n\t}\n\n\treturn numUsed? product : nums[numsLen - 1];\n}\n", "\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\n\treturn *p1 - *p2;\n}\n\nint64_t maxStrength(int * const nums, const int numsLen){\n\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\n\n\tbool numUsed = false;\n\tint64_t product = 1;\n\n\t//positive from right\n\tfor (int i = numsLen - 1; i >= 0 && nums[i] > 0; i -= 1){\n\t\tnumUsed = true;\n\t\tproduct *= nums[i];\n\t}\n\t//negative pairs from left\n\tfor (int i = 1; i < numsLen && nums[i] < 0; i += 2){\n\t\tnumUsed = true;\n\t\tproduct *= (int64_t)nums[i - 1] * (int64_t)nums[i];\t\t\n\t}\n\n\treturn numUsed? product : nums[numsLen - 1];\n}\n", "\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\n\treturn *p1 - *p2;\n}\n\nint64_t maxStrength(int * const nums, const int numsLen){\n\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\n\n\tbool numUsed = false;\n\tint64_t product = 1;\n\n\t//positive from right\n\tfor (int i = numsLen - 1; i >= 0 && nums[i] > 0; i -= 1){\n\t\tnumUsed = true;\n\t\tproduct *= nums[i];\n\t}\n\t//negative pairs from left\n\tfor (int i = 1; i < numsLen && nums[i] < 0; i += 2){\n\t\tnumUsed = true;\n\t\tproduct *= (int64_t)nums[i - 1] * (int64_t)nums[i];\t\t\n\t}\n\n\treturn numUsed? product : nums[numsLen - 1];\n}\n"]}
{"id": "1731", "ref_c": [["char * evaluate(char * s, char *** knowledge, int knowledgeSize, int* knowledgeColSize){\\n    \\n    \\n    hash_t *hash_table = NULL;\\n    hash_t *el;\\n\\n    // map everything to hash table\\n    for(size_t i = 0 ; i < knowledgeSize ;i++)\\n    {\\n        el = malloc(sizeof(hash_t));\\n        strcpy(el->key,knowledge[i][0]);\\n        el->val = knowledge[i][1];\\n        HASH_ADD_STR(hash_table, key, el);\\n    }"], ["char * evaluate(char * s, char *** knowledge, int knowledgeSize, int* knowledgeColSize){\\n    \\n    \\n    hash_t *hash_table = NULL;\\n    hash_t *el;\\n\\n    // map everything to hash table\\n    for(size_t i = 0 ; i < knowledgeSize ;i++)\\n    {\\n        el = malloc(sizeof(hash_t));\\n        strcpy(el->key,knowledge[i][0]);\\n        el->val = knowledge[i][1];\\n        HASH_ADD_STR(hash_table, key, el);\\n    }"], ["char * evaluate(char * s, char *** knowledge, int knowledgeSize, int* knowledgeColSize){\\n    \\n    \\n    hash_t *hash_table = NULL;\\n    hash_t *el;\\n\\n    // map everything to hash table\\n    for(size_t i = 0 ; i < knowledgeSize ;i++)\\n    {\\n        el = malloc(sizeof(hash_t));\\n        strcpy(el->key,knowledge[i][0]);\\n        el->val = knowledge[i][1];\\n        HASH_ADD_STR(hash_table, key, el);\\n    }"]]}
{"id": "1732", "ref_c": [["int* shortestAlternatingPaths(int n, int** redEdges, int redEdgesSize, int* redEdgesColSize, int** blueEdges, int blueEdgesSize, int* blueEdgesColSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  n, number of nodes\\n     *  **redEdges, \\n     *  redEdgesSize\\n     *  *redEdgesColSize\\n     *  **blueEdges\\n     *  blueEdgesSize\\n     *  *blueEdgesColSize\\n     */\\n\\n    bool **red, **blue, **visited;\\n\\n    red = (bool **)malloc(sizeof(bool *) * n);\\n    blue = (bool **)malloc(sizeof(bool *) * n);\\n    visited = (bool **)calloc(1, sizeof(bool *) * 2);\\n    int *ans = (int *)malloc(sizeof(int) * n);\\n    \\n    fifo_init();\\n    \\n    *returnSize = n;\\n    \\n    visited[0] = (bool *)calloc(1, sizeof(bool) * n);\\n    visited[1] = (bool *)calloc(1, sizeof(bool) * n);\\n    \\n    /* Set all the distances to -1 by default except the distance from node 0 to itself */\\n    ans[0] = 0;\\n    for (int i = 1; i < n; i++) {\\n        ans[i] = -1;\\n    }"], ["int* shortestAlternatingPaths(int n, int** redEdges, int redEdgesSize, int* redEdgesColSize, int** blueEdges, int blueEdgesSize, int* blueEdgesColSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  n, number of nodes\\n     *  **redEdges, \\n     *  redEdgesSize\\n     *  *redEdgesColSize\\n     *  **blueEdges\\n     *  blueEdgesSize\\n     *  *blueEdgesColSize\\n     */\\n\\n    bool **red, **blue, **visited;\\n\\n    red = (bool **)malloc(sizeof(bool *) * n);\\n    blue = (bool **)malloc(sizeof(bool *) * n);\\n    visited = (bool **)calloc(1, sizeof(bool *) * 2);\\n    int *ans = (int *)malloc(sizeof(int) * n);\\n    \\n    fifo_init();\\n    \\n    *returnSize = n;\\n    \\n    visited[0] = (bool *)calloc(1, sizeof(bool) * n);\\n    visited[1] = (bool *)calloc(1, sizeof(bool) * n);\\n    \\n    /* Set all the distances to -1 by default except the distance from node 0 to itself */\\n    ans[0] = 0;\\n    for (int i = 1; i < n; i++) {\\n        ans[i] = -1;\\n    }"], ["int* shortestAlternatingPaths(int n, int** redEdges, int redEdgesSize, int* redEdgesColSize, int** blueEdges, int blueEdgesSize, int* blueEdgesColSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  n, number of nodes\\n     *  **redEdges, \\n     *  redEdgesSize\\n     *  *redEdgesColSize\\n     *  **blueEdges\\n     *  blueEdgesSize\\n     *  *blueEdgesColSize\\n     */\\n\\n    bool **red, **blue, **visited;\\n\\n    red = (bool **)malloc(sizeof(bool *) * n);\\n    blue = (bool **)malloc(sizeof(bool *) * n);\\n    visited = (bool **)calloc(1, sizeof(bool *) * 2);\\n    int *ans = (int *)malloc(sizeof(int) * n);\\n    \\n    fifo_init();\\n    \\n    *returnSize = n;\\n    \\n    visited[0] = (bool *)calloc(1, sizeof(bool) * n);\\n    visited[1] = (bool *)calloc(1, sizeof(bool) * n);\\n    \\n    /* Set all the distances to -1 by default except the distance from node 0 to itself */\\n    ans[0] = 0;\\n    for (int i = 1; i < n; i++) {\\n        ans[i] = -1;\\n    }"]]}
{"id": "1733", "ref_c": [["long long matrixSumQueries(int n, int** queries, int queriesSize, int* queriesColSize) {  \\n    bool* row_over = (bool*) calloc(n, sizeof(bool));\\n    bool* col_over = (bool*) calloc(n, sizeof(bool));\\n    int r = n, c = n;\\n    long long sum = 0;\\n    for (int i = queriesSize-1; i >= 0; i--) {\\n        if (queries[i][0] == 1) {\\n            if (row_over[queries[i][1]] == true) continue;\\n            row_over[queries[i][1]] = true;\\n            sum += r * queries[i][2];\\n            c--;\\n        }"], ["long long matrixSumQueries(int n, int** queries, int queriesSize, int* queriesColSize) {  \\n    bool* row_over = (bool*) calloc(n, sizeof(bool));\\n    bool* col_over = (bool*) calloc(n, sizeof(bool));\\n    int r = n, c = n;\\n    long long sum = 0;\\n    for (int i = queriesSize-1; i >= 0; i--) {\\n        if (queries[i][0] == 1) {\\n            if (row_over[queries[i][1]] == true) continue;\\n            row_over[queries[i][1]] = true;\\n            sum += r * queries[i][2];\\n            c--;\\n        }"], ["long long matrixSumQueries(int n, int** queries, int queriesSize, int* queriesColSize) {  \\n    bool* row_over = (bool*) calloc(n, sizeof(bool));\\n    bool* col_over = (bool*) calloc(n, sizeof(bool));\\n    int r = n, c = n;\\n    long long sum = 0;\\n    for (int i = queriesSize-1; i >= 0; i--) {\\n        if (queries[i][0] == 1) {\\n            if (row_over[queries[i][1]] == true) continue;\\n            row_over[queries[i][1]] = true;\\n            sum += r * queries[i][2];\\n            c--;\\n        }"]]}
{"id": "1736", "ref_c": [["int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\\n\\n    /*\\n     * Input:\\n     *  *arr\\n     *  arrSize\\n     *  **mat\\n     *  matSize\\n     *  *matColSize\\n     */\\n\\n    int **lookup = (int **)malloc(sizeof(int *) * (matSize * matColSize[0] + 1));\\n    int *row = (int *)calloc(1, sizeof(int) * matSize);\\n    int *col = (int *)calloc(1, sizeof(int) * matColSize[0]);\\n    int ans = 0;\\n\\n    for (int i = 0; i < (matSize * matColSize[0] + 1); i++) {\\n        lookup[i] = (int *)malloc(sizeof(int) * 2);\\n    }"], ["int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\\n\\n    /*\\n     * Input:\\n     *  *arr\\n     *  arrSize\\n     *  **mat\\n     *  matSize\\n     *  *matColSize\\n     */\\n\\n    int **lookup = (int **)malloc(sizeof(int *) * (matSize * matColSize[0] + 1));\\n    int *row = (int *)calloc(1, sizeof(int) * matSize);\\n    int *col = (int *)calloc(1, sizeof(int) * matColSize[0]);\\n    int ans = 0;\\n\\n    for (int i = 0; i < (matSize * matColSize[0] + 1); i++) {\\n        lookup[i] = (int *)malloc(sizeof(int) * 2);\\n    }"], ["int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\\n    int m = matSize, n = *matColSize;\\n    Pair pair[m * n + 1];\\n    int i, j, t, filledRow[m], filledCol[n];\\n    memset(filledRow, 0, sizeof(filledRow));\\n    memset(filledCol, 0, sizeof(filledCol));\\n    memset(pair, 0, sizeof(pair));\\n    for (i = 0; i < m; ++i) {\\n        for (j = 0; j < n; ++j) {\\n            t = mat[i][j];\\n            pair[t].row = i;\\n            pair[t].col = j; \\n        }"]]}
{"id": "1737", "ref_c": [["bool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }"], ["bool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }"], ["bool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }"]]}
{"id": "1738", "ref_c": ["\nchar * smallestString(char * const s){\n\tint i = 0;\n\n\twhile ('a' == s[i]){\n\t\ti += 1;\n\t}\n\n\tif ('\u0000' == s[i]){\n\t\ts[i - 1] = 'z';\n\t}else {\n\t\tdo {\n\t\t\ts[i] -= 1;\n\n\t\t\ti += 1;\n\t\t}while (s[i] != '\u0000' && s[i] != 'a');\n\t}\n\n\treturn s;\n}\n", "\nchar * smallestString(char * const s){\n\tint i = 0;\n\n\twhile ('a' == s[i]){\n\t\ti += 1;\n\t}\n\n\tif ('\u0000' == s[i]){\n\t\ts[i - 1] = 'z';\n\t}else {\n\t\tdo {\n\t\t\ts[i] -= 1;\n\n\t\t\ti += 1;\n\t\t}while (s[i] != '\u0000' && s[i] != 'a');\n\t}\n\n\treturn s;\n}\n", "\nchar * smallestString(char * const s){\n\tint i = 0;\n\n\twhile ('a' == s[i]){\n\t\ti += 1;\n\t}\n\n\tif ('\u0000' == s[i]){\n\t\ts[i - 1] = 'z';\n\t}else {\n\t\tdo {\n\t\t\ts[i] -= 1;\n\n\t\t\ti += 1;\n\t\t}while (s[i] != '\u0000' && s[i] != 'a');\n\t}\n\n\treturn s;\n}\n"]}
{"id": "1739", "ref_c": [["bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\\n    int ans = false;\\n    int* mapping = (int*)calloc(101, sizeof(int));\\n    /* record indx into mapping array */\\n    for(int i = 0; i < arrSize; i++)\\n        mapping[arr[i]] = i + 1;\\n    int startIdx;\\n    /* read the first element of piece then \\n        check the index correct or not*/\\n    for(int i = 0; i < piecesSize; i++){\\n        startIdx = mapping[pieces[i][0]];\\n        if(!startIdx) return false; /* index isn\\'t exist */\\n        for(int j = 0; j < piecesColSize[i]; j++)\\n            if(mapping[pieces[i][j]] != (startIdx + j))\\n                return false;   \\n    }"], ["bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\\n    int ans = false;\\n    int* mapping = (int*)calloc(101, sizeof(int));\\n    /* record indx into mapping array */\\n    for(int i = 0; i < arrSize; i++)\\n        mapping[arr[i]] = i + 1;\\n    int startIdx;\\n    /* read the first element of piece then \\n        check the index correct or not*/\\n    for(int i = 0; i < piecesSize; i++){\\n        startIdx = mapping[pieces[i][0]];\\n        if(!startIdx) return false; /* index isn\\'t exist */\\n        for(int j = 0; j < piecesColSize[i]; j++)\\n            if(mapping[pieces[i][j]] != (startIdx + j))\\n                return false;   \\n    }"], ["bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\\n\\n    int pmap[101];    \\n    for(int i=0; i<piecesSize; ++i){\\n        int j=0;\\n        while(j<piecesColSize[i]){\\n            if(j-1<0){\\n                // First (and possibly only) value, has no previous neighbour\\n                pmap[pieces[i][j]] = -1;\\n            }"]]}
{"id": "1740", "ref_c": [["int* targetIndices(int* nums, int numsSize, int target, int* returnSize){\\n    int small=0,same=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i] < target) small++;\\n        if(nums[i] == target) same++;\\n    }"], ["int* targetIndices(int* nums, int numsSize, int target, int* returnSize) \\n{\\n    int i,j,k,s=0,l=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        for(j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]>nums[j])\\n            {\\n               k= nums[i];\\n               nums[i]=nums[j];\\n               nums[j]=k;\\n               \\n           }"], ["int* targetIndices(int* nums, int numsSize, int target, int* returnSize){\\n    int small=0,same=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i] < target) small++;\\n        if(nums[i] == target) same++;\\n    }"]]}
{"id": "1741", "ref_c": [["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if(!root) return root;\\n    root = DFS(root, val, depth, 1, -1);/* -1:left node, 1: right node */\\n    return root;\\n}"], ["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if (depth == 1){ // case 1, add new root\\n        struct TreeNode* newRoot = malloc(sizeof(struct TreeNode));\\n        newRoot->val = val;\\n        newRoot->left = root;\\n        newRoot->right = NULL;\\n        return newRoot;\\n    }"], ["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if (depth == 1){ // case 1, add new root\\n        struct TreeNode* newRoot = malloc(sizeof(struct TreeNode));\\n        newRoot->val = val;\\n        newRoot->left = root;\\n        newRoot->right = NULL;\\n        return newRoot;\\n    }"]]}
{"id": "1742", "ref_c": [["int longestString(int x, int y, int z){\\n    int ret = 0;\\n    int temp = 0;\\n    if (x>y){\\n        temp = x-y;\\n        ret = y*4;\\n    }"], ["int longestString(int x, int y, int z){\\n    int ret = 0;\\n    int temp = 0;\\n    if (x>y){\\n        temp = x-y;\\n        ret = y*4;\\n    }"], ["int longestString(int x, int y, int z){\\n    int ret = 0;\\n    int temp = 0;\\n    if (x>y){\\n        temp = x-y;\\n        ret = y*4;\\n    }"]]}
{"id": "1743", "ref_c": [["struct TreeNode* convertBST(struct TreeNode* root){\\n    conv(root, 0);\\n\\n    return root;\\n}"], ["struct TreeNode* convertBST(struct TreeNode* root)\\n{\\n    int t=0;\\n    func(root, &t);\\n    return root;\\n}"], ["struct TreeNode* convertBST(struct TreeNode* root){\\n\\t\\tint sum = 0;\\n\\t\\t\\n\\t\\tstruct TreeNode* sol(struct TreeNode* root){\\n\\t\\t\\tif ( root ){\\n\\t\\t\\t\\tsol(root->right);\\n\\t\\t\\t\\tsum = root->val += sum;\\n\\t\\t\\t\\tsol(root->left);\\n\\t\\t\\t}"]]}
{"id": "1744", "ref_c": ["\nstatic int hash[26][50000];\n \nint searchCharAftIdx(int *indices, int len, int idx)\n{\n    int i = 0, j = len - 1, mid;\n\n    /* Search for a index close to and also larger than given idx */\n    idx++;\n\n    while (i < j) { \n    \n        mid = i + (j - i) / 2;\n        \n        if (indices[mid] == idx) {\n            return idx;\n        }\n        else if (indices[mid] < idx) {\n            i = mid + 1;\n        }\n        else {\n            j = mid;\n        }\n    }\n\n    if (i == j && indices[i] >= idx) {\n        return indices[i];\n    }\n    else {\n        return -1;\n    }\n}\n\nint numMatchingSubseq(char * s, char ** words, int wordsSize){\n    /*\n     * Input:\n     *  s, string\n     *  words, string arrays\n     *  wordsSize, number of string arrays\n     */\n     \n    /*\n     * Algorithm:\n     *  Brute + hash\n     *  (1) Store the index of each character to hash table\n     *      hash['a'][len['a']] = index\n     *      len['a']++;\n     *  (2) Loop the words, scan every character and check \n     *      if there is a corresponding character located \n     *      in a position > \"idx\", if so, set \"idx\" to \n     *      the index of last selected character.\n     *  (3) Once all the characters of a word been found,\n     *      set total += 1\n     *\n     *  E.g. s = \"helloworld\",\n     *            0123456789\n     *\n     *  hash['h'] = [0]\n     *  hash['e'] = [1]\n     *  hash['l'] = [2,3,8]\n     *  hash['o'] = [4,6]\n     *  hash['w'] = [5]\n     *  hash['r'] = [7]\n     *  hash['d'] = [9]\n     *\n     *  word = \"lol\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'o' character located after idx 2\n     *      => 'o' @ 4, idx = 4\n     *\n     *  Search 'l' character located after idx 4\n     *      => 'l' @ 8, idx = 8\n     *\n     *  >> Matched <<\n     *\n     *\n     *  word = \"le\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'e' character located after idx 2\n     *      => Not found\n     *\n     *  >> Mismatched <<\n     */\n\n    int len[26] = {0};\n    int idx = 0;\n    int cnt = 0;\n    int tmp;\n    \n    while (*s) {\n        hash[*s - 'a'][len[*s - 'a']] = idx;\n        len[*s - 'a']++;\n        idx++;\n        s++;\n    }\n\n    for (int i = 0; i < wordsSize; i++) {\n    \n        idx = -1;\n        s = words[i];\n        \n        while (*s) {\n        \n            /* Check if there is a corresponding letter after current position */\n            tmp = searchCharAftIdx(hash[*s - 'a'], len[*s - 'a'], idx);\n\n            if (tmp <= idx) {\n                break;\n            }\n        \n            idx = tmp;\n            s++;\n        }\n\n        if (*s == 0) {\n            cnt++;\n        }\n    }\n     \n    /*\n     * Output:\n     *  return the number of words[i] that is a subsequence of s.\n     */\n     \n    return cnt;\n}\n", "\nstatic int hash[26][50000];\n \nint searchCharAftIdx(int *indices, int len, int idx)\n{\n    int i = 0, j = len - 1, mid;\n\n    /* Search for a index close to and also larger than given idx */\n    idx++;\n\n    while (i < j) { \n    \n        mid = i + (j - i) / 2;\n        \n        if (indices[mid] == idx) {\n            return idx;\n        }\n        else if (indices[mid] < idx) {\n            i = mid + 1;\n        }\n        else {\n            j = mid;\n        }\n    }\n\n    if (i == j && indices[i] >= idx) {\n        return indices[i];\n    }\n    else {\n        return -1;\n    }\n}\n\nint numMatchingSubseq(char * s, char ** words, int wordsSize){\n    /*\n     * Input:\n     *  s, string\n     *  words, string arrays\n     *  wordsSize, number of string arrays\n     */\n     \n    /*\n     * Algorithm:\n     *  Brute + hash\n     *  (1) Store the index of each character to hash table\n     *      hash['a'][len['a']] = index\n     *      len['a']++;\n     *  (2) Loop the words, scan every character and check \n     *      if there is a corresponding character located \n     *      in a position > \"idx\", if so, set \"idx\" to \n     *      the index of last selected character.\n     *  (3) Once all the characters of a word been found,\n     *      set total += 1\n     *\n     *  E.g. s = \"helloworld\",\n     *            0123456789\n     *\n     *  hash['h'] = [0]\n     *  hash['e'] = [1]\n     *  hash['l'] = [2,3,8]\n     *  hash['o'] = [4,6]\n     *  hash['w'] = [5]\n     *  hash['r'] = [7]\n     *  hash['d'] = [9]\n     *\n     *  word = \"lol\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'o' character located after idx 2\n     *      => 'o' @ 4, idx = 4\n     *\n     *  Search 'l' character located after idx 4\n     *      => 'l' @ 8, idx = 8\n     *\n     *  >> Matched <<\n     *\n     *\n     *  word = \"le\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'e' character located after idx 2\n     *      => Not found\n     *\n     *  >> Mismatched <<\n     */\n\n    int len[26] = {0};\n    int idx = 0;\n    int cnt = 0;\n    int tmp;\n    \n    while (*s) {\n        hash[*s - 'a'][len[*s - 'a']] = idx;\n        len[*s - 'a']++;\n        idx++;\n        s++;\n    }\n\n    for (int i = 0; i < wordsSize; i++) {\n    \n        idx = -1;\n        s = words[i];\n        \n        while (*s) {\n        \n            /* Check if there is a corresponding letter after current position */\n            tmp = searchCharAftIdx(hash[*s - 'a'], len[*s - 'a'], idx);\n\n            if (tmp <= idx) {\n                break;\n            }\n        \n            idx = tmp;\n            s++;\n        }\n\n        if (*s == 0) {\n            cnt++;\n        }\n    }\n     \n    /*\n     * Output:\n     *  return the number of words[i] that is a subsequence of s.\n     */\n     \n    return cnt;\n}\n", "\nstatic int hash[26][50000];\n \nint searchCharAftIdx(int *indices, int len, int idx)\n{\n    int i = 0, j = len - 1, mid;\n\n    /* Search for a index close to and also larger than given idx */\n    idx++;\n\n    while (i < j) { \n    \n        mid = i + (j - i) / 2;\n        \n        if (indices[mid] == idx) {\n            return idx;\n        }\n        else if (indices[mid] < idx) {\n            i = mid + 1;\n        }\n        else {\n            j = mid;\n        }\n    }\n\n    if (i == j && indices[i] >= idx) {\n        return indices[i];\n    }\n    else {\n        return -1;\n    }\n}\n\nint numMatchingSubseq(char * s, char ** words, int wordsSize){\n    /*\n     * Input:\n     *  s, string\n     *  words, string arrays\n     *  wordsSize, number of string arrays\n     */\n     \n    /*\n     * Algorithm:\n     *  Brute + hash\n     *  (1) Store the index of each character to hash table\n     *      hash['a'][len['a']] = index\n     *      len['a']++;\n     *  (2) Loop the words, scan every character and check \n     *      if there is a corresponding character located \n     *      in a position > \"idx\", if so, set \"idx\" to \n     *      the index of last selected character.\n     *  (3) Once all the characters of a word been found,\n     *      set total += 1\n     *\n     *  E.g. s = \"helloworld\",\n     *            0123456789\n     *\n     *  hash['h'] = [0]\n     *  hash['e'] = [1]\n     *  hash['l'] = [2,3,8]\n     *  hash['o'] = [4,6]\n     *  hash['w'] = [5]\n     *  hash['r'] = [7]\n     *  hash['d'] = [9]\n     *\n     *  word = \"lol\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'o' character located after idx 2\n     *      => 'o' @ 4, idx = 4\n     *\n     *  Search 'l' character located after idx 4\n     *      => 'l' @ 8, idx = 8\n     *\n     *  >> Matched <<\n     *\n     *\n     *  word = \"le\", idx = -1;\n     *\n     *  Search 'l' character located after idx -1\n     *      => 'l' @ 2, idx = 2\n     *\n     *  Search 'e' character located after idx 2\n     *      => Not found\n     *\n     *  >> Mismatched <<\n     */\n\n    int len[26] = {0};\n    int idx = 0;\n    int cnt = 0;\n    int tmp;\n    \n    while (*s) {\n        hash[*s - 'a'][len[*s - 'a']] = idx;\n        len[*s - 'a']++;\n        idx++;\n        s++;\n    }\n\n    for (int i = 0; i < wordsSize; i++) {\n    \n        idx = -1;\n        s = words[i];\n        \n        while (*s) {\n        \n            /* Check if there is a corresponding letter after current position */\n            tmp = searchCharAftIdx(hash[*s - 'a'], len[*s - 'a'], idx);\n\n            if (tmp <= idx) {\n                break;\n            }\n        \n            idx = tmp;\n            s++;\n        }\n\n        if (*s == 0) {\n            cnt++;\n        }\n    }\n     \n    /*\n     * Output:\n     *  return the number of words[i] that is a subsequence of s.\n     */\n     \n    return cnt;\n}\n"]}
{"id": "1745", "ref_c": [["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"]]}
{"id": "1746", "ref_c": [["int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\\n    int hashSize = nums1Size * nums2Size; int hashBits; __asm__ (\" bsr %1, %0 \\\\n\" : \"+r\" (hashBits) : \"r\" (hashSize));\\n    hashSize = 2 << hashBits; hashBits = 31 - hashBits;\\n    int table[hashSize]; clearints(table, hashSize);\\n    int counts[hashSize]; clearints(counts, hashSize);\\n    hashSize--;\\n    for(int i = 0; i < nums1Size; i++)\\n    {   int ni = nums1[i];\\n        for(int ii = 0; ii < nums2Size; ii++)\\n        {   int sum = ni + nums2[ii];\\n            uint32_t hash = ((uint32_t)(2808820391 * sum)) >> hashBits;\\n            int c;\\n            while((c=counts[hash]))\\n            {\\n                if(table[hash] == sum) goto foundit;\\n                ++hash; hash &= hashSize;\\n            }"], ["int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\\n    int i,j,k,l,r;\\n    int sz = 0;\\n    \\n    int nums5[40000];\\n    int nums5Size = 0;\\n    for (i = 0; i < nums3Size; i=i+1) {\\n        for (j = 0; j < nums4Size; j=j+1) {\\n            nums5[nums5Size++] = nums3[i]+nums4[j];\\n        }"], ["int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\\n    int i,j,k,l,r;\\n    int sz = 0;\\n    \\n    int nums5[40000];\\n    int nums5Size = 0;\\n    for (i = 0; i < nums3Size; i=i+1) {\\n        for (j = 0; j < nums4Size; j=j+1) {\\n            nums5[nums5Size++] = nums3[i]+nums4[j];\\n        }"]]}
{"id": "1747", "ref_c": ["\nint * * findPrimePairs(const int n, int * const returnSize, int * * const returnColumnSizes){\n\tbool primes[n + 1];\n\tmemset( &primes, 1, sizeof (primes) );\n\tprimes[0] = false;\n\tprimes[1] = false;\n\tfor (int i = 2; i < n + 1; ){\n\t\tfor (int j = i * 2; j < n + 1; j += i){\n\t\t\tprimes[j] = false;\n\t\t}\n\n\t\ti += 1;\n\t\twhile (i < n + 1 && !primes[i]){\n\t\t\ti += 1;\n\t\t}\n\t}\n\n\t*returnColumnSizes = (int *)malloc( sizeof (int) * (n / 2) );\n\tint * * const rets = (int **)malloc( sizeof (int *) * (n / 2) );\n\t*returnSize = 0;\n\n\tfor (int i = 1, j = n - i; i <= j; i += 1, j -= 1){\n\t\tif (primes[i] && primes[j]){\n\t\t\t(*returnColumnSizes)[*returnSize] = 2;\n\t\t\trets[*returnSize] = (int *)malloc(sizeof (int) * 2);\n\n\t\t\trets[*returnSize][0] = i;\n\t\t\trets[*returnSize][1] = j;\n\n\t\t\t*returnSize += 1;\n\t\t}\n\t}\n\n\treturn rets;\n}\n", "\nint * * findPrimePairs(const int n, int * const returnSize, int * * const returnColumnSizes){\n\tbool primes[n + 1];\n\tmemset( &primes, 1, sizeof (primes) );\n\tprimes[0] = false;\n\tprimes[1] = false;\n\tfor (int i = 2; i < n + 1; ){\n\t\tfor (int j = i * 2; j < n + 1; j += i){\n\t\t\tprimes[j] = false;\n\t\t}\n\n\t\ti += 1;\n\t\twhile (i < n + 1 && !primes[i]){\n\t\t\ti += 1;\n\t\t}\n\t}\n\n\t*returnColumnSizes = (int *)malloc( sizeof (int) * (n / 2) );\n\tint * * const rets = (int **)malloc( sizeof (int *) * (n / 2) );\n\t*returnSize = 0;\n\n\tfor (int i = 1, j = n - i; i <= j; i += 1, j -= 1){\n\t\tif (primes[i] && primes[j]){\n\t\t\t(*returnColumnSizes)[*returnSize] = 2;\n\t\t\trets[*returnSize] = (int *)malloc(sizeof (int) * 2);\n\n\t\t\trets[*returnSize][0] = i;\n\t\t\trets[*returnSize][1] = j;\n\n\t\t\t*returnSize += 1;\n\t\t}\n\t}\n\n\treturn rets;\n}\n", "\nint * * findPrimePairs(const int n, int * const returnSize, int * * const returnColumnSizes){\n\tbool primes[n + 1];\n\tmemset( &primes, 1, sizeof (primes) );\n\tprimes[0] = false;\n\tprimes[1] = false;\n\tfor (int i = 2; i < n + 1; ){\n\t\tfor (int j = i * 2; j < n + 1; j += i){\n\t\t\tprimes[j] = false;\n\t\t}\n\n\t\ti += 1;\n\t\twhile (i < n + 1 && !primes[i]){\n\t\t\ti += 1;\n\t\t}\n\t}\n\n\t*returnColumnSizes = (int *)malloc( sizeof (int) * (n / 2) );\n\tint * * const rets = (int **)malloc( sizeof (int *) * (n / 2) );\n\t*returnSize = 0;\n\n\tfor (int i = 1, j = n - i; i <= j; i += 1, j -= 1){\n\t\tif (primes[i] && primes[j]){\n\t\t\t(*returnColumnSizes)[*returnSize] = 2;\n\t\t\trets[*returnSize] = (int *)malloc(sizeof (int) * 2);\n\n\t\t\trets[*returnSize][0] = i;\n\t\t\trets[*returnSize][1] = j;\n\n\t\t\t*returnSize += 1;\n\t\t}\n\t}\n\n\treturn rets;\n}\n"]}
{"id": "1748", "ref_c": [["int findLucky(int* arr, int arrSize) {\\n\\n int   b[501]={0}"], ["int findLucky(int* arr, int arrSize) {\\n\\n int   b[501]={0}"], ["int findLucky(int* arr, int arrSize) {\\n\\n int   b[501]={0}"]]}
{"id": "1749", "ref_c": ["\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n", "\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n", "\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n"]}
{"id": "1750", "ref_c": [["int* targetIndices(int* nums, int numsSize, int target, int* returnSize){\\n    int small=0,same=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i] < target) small++;\\n        if(nums[i] == target) same++;\\n    }"], ["int* targetIndices(int* nums, int numsSize, int target, int* returnSize) \\n{\\n    int i,j,k,s=0,l=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        for(j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]>nums[j])\\n            {\\n               k= nums[i];\\n               nums[i]=nums[j];\\n               nums[j]=k;\\n               \\n           }"], ["int* targetIndices(int* nums, int numsSize, int target, int* returnSize){\\n    int small=0,same=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i] < target) small++;\\n        if(nums[i] == target) same++;\\n    }"]]}
{"id": "1751", "ref_c": [["int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\\n    *returnColumnSizes = (int *)malloc( sizeof (int) * (nums1Size + nums2Size) );\\n    int ** rets = (int **)malloc( sizeof (int *) * (nums1Size + nums2Size) );\\n    *returnSize = 0;\\n\\n    for (int i = 0, j = 0; i < nums1Size || j < nums2Size; ){\\n        (*returnColumnSizes)[*returnSize] = 2;\\n        rets[*returnSize] = (int *)malloc(sizeof (int) * 2);\\n\\n        if (!( j < nums2Size )){\\n            rets[*returnSize][0] = nums1[i][0];\\n            rets[*returnSize][1] = nums1[i][1];\\n            i += 1;\\n        }"], ["int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\\n    *returnColumnSizes = (int *)malloc( sizeof (int) * (nums1Size + nums2Size) );\\n    int ** rets = (int **)malloc( sizeof (int *) * (nums1Size + nums2Size) );\\n    *returnSize = 0;\\n\\n    for (int i = 0, j = 0; i < nums1Size || j < nums2Size; ){\\n        (*returnColumnSizes)[*returnSize] = 2;\\n        rets[*returnSize] = (int *)malloc(sizeof (int) * 2);\\n\\n        if (!( j < nums2Size )){\\n            rets[*returnSize][0] = nums1[i][0];\\n            rets[*returnSize][1] = nums1[i][1];\\n            i += 1;\\n        }"], ["int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\\n    *returnColumnSizes = (int *)malloc( sizeof (int) * (nums1Size + nums2Size) );\\n    int ** rets = (int **)malloc( sizeof (int *) * (nums1Size + nums2Size) );\\n    *returnSize = 0;\\n\\n    for (int i = 0, j = 0; i < nums1Size || j < nums2Size; ){\\n        (*returnColumnSizes)[*returnSize] = 2;\\n        rets[*returnSize] = (int *)malloc(sizeof (int) * 2);\\n\\n        if (!( j < nums2Size )){\\n            rets[*returnSize][0] = nums1[i][0];\\n            rets[*returnSize][1] = nums1[i][1];\\n            i += 1;\\n        }"]]}
{"id": "1752", "ref_c": [["int maximumJumps(int* nums, int numsSize, int target){\\n    int* dp = (int*)malloc(sizeof(int) * numsSize);\\n    for(int i = 0;i < numsSize;i++){\\n        dp[i] = 0;\\n    }"], ["int maximumJumps(int* nums, int numsSize, int target){\\n    int dp[numsSize];\\n    dp[0] = 0;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        dp[i] = -1;\\n        for (int j = 0; j < i; j++) {\\n            if (abs(nums[j] - nums[i]) <= target && dp[j] != -1) {\\n                dp[i] = (dp[i] > dp[j] + 1) ? dp[i] : dp[j] + 1;\\n            }"], ["int maximumJumps(int* nums, int numsSize, int target){\\n    if(target==0) return -1;\\n    int dp[numsSize];\\n    for(int i=1;i<numsSize;i++){\\n        dp[i]=INT_MIN;\\n    }"]]}
{"id": "1753", "ref_c": [["int maxNonDecreasingLength(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n  int last_small = (nums1[0] < nums2[0]) ? nums1[0] : nums2[0];\\n  int last_large = last_small;\\n  int len_small = 1;\\n  int len_large = 1;\\n  int len_max = 1;\\n  \\n  for (int loop_idx=1; loop_idx<nums1Size; loop_idx++) {\\n    int curr_small = (nums1[loop_idx] < nums2[loop_idx]) ? nums1[loop_idx] : nums2[loop_idx];\\n    int curr_large = (nums1[loop_idx] < nums2[loop_idx]) ? nums2[loop_idx] : nums1[loop_idx];\\n    \\n    if (last_small > curr_large) {\\n      if (len_max < len_small) len_max = len_small;\\n      len_small = 1;\\n      last_small = curr_small;\\n    }"], ["int maxNonDecreasingLength(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int** dp = (int**)malloc(sizeof(int*)*nums1Size);\\n    for(int i = 0;i < nums1Size;i++){\\n        dp[i] = (int*)malloc(sizeof(int)*2);\\n    }"], ["int maxNonDecreasingLength(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int n = nums1Size;\\n\\n    // Make nums1 have the minimum of nums1 and nums2 and vice-versa\\n    int x,M,m;\\n    for (int i=0 ; i<n ; i++) {\\n        if (nums1[i] >nums2[i]) {\\n            x = nums1[i];\\n            nums1[i] = nums2[i];\\n            nums2[i] = x;\\n        }"]]}
{"id": "1754", "ref_c": [["int* rearrangeArray(int* nums, int numsSize, int* returnSize){\\nint* new=(int*)malloc(numsSize*sizeof(int));\\nint i,p=0,n=1;\\nfor(i=0;i<numsSize;i++)\\n{\\n    if(nums[i]>0)\\n    {\\n        new[p]=nums[i];\\n        p=p+2;\\n\\n    }"], ["int* rearrangeArray(int* nums, int numsSize, int* returnSize) \\n{\\n    int* ret = malloc(sizeof(int) * (numsSize));\\n    int pos = 0;\\n    int neg = 1;\\n\\n    for (int i = 0; i < numsSize; i++)\\n    {\\n        if (nums[i] > 0)\\n        {\\n            ret[pos] = nums[i];\\n            pos += 2;\\n        }"], ["int* rearrangeArray(int* nums, int numsSize, int* returnSize){\\nint* new=(int*)malloc(numsSize*sizeof(int));\\nint i,p=0,n=1;\\nfor(i=0;i<numsSize;i++)\\n{\\n    if(nums[i]>0)\\n    {\\n        new[p]=nums[i];\\n        p=p+2;\\n\\n    }"]]}
{"id": "1755", "ref_c": [["int maximumBeauty(int* nums, int numsSize, int k){\\n    int hashBuffer = 2*numsSize;\\n    int * hashCount = calloc(hashBuffer,sizeof(int));\\n    int * hashValue = calloc(hashBuffer,sizeof(int));\\n    // hashValue[n] = contains 1+n\\n    // hashed value not visited: hashValue = 0\\n\\n    int min_value = nums[0];\\n    int max_value = nums[0];\\n    for (int i=0 ; i<numsSize ; i++) {\\n        int idx = nums[i]%hashBuffer;\\n        while (hashValue[idx]!=0 && hashValue[idx]!=nums[i]+1) {\\n            idx++;\\n            if (idx>=hashBuffer) idx-=hashBuffer;\\n        }"], ["int maximumBeauty(int* nums, int numsSize, int k){\\n    int hashBuffer = 2*numsSize;\\n    int * hashCount = calloc(hashBuffer,sizeof(int));\\n    int * hashValue = calloc(hashBuffer,sizeof(int));\\n    // hashValue[n] = contains 1+n\\n    // hashed value not visited: hashValue = 0\\n\\n    int min_value = nums[0];\\n    int max_value = nums[0];\\n    for (int i=0 ; i<numsSize ; i++) {\\n        int idx = nums[i]%hashBuffer;\\n        while (hashValue[idx]!=0 && hashValue[idx]!=nums[i]+1) {\\n            idx++;\\n            if (idx>=hashBuffer) idx-=hashBuffer;\\n        }"], ["int maximumBeauty(int* nums, int numsSize, int k){\\n    int hashBuffer = 2*numsSize;\\n    int * hashCount = calloc(hashBuffer,sizeof(int));\\n    int * hashValue = calloc(hashBuffer,sizeof(int));\\n    // hashValue[n] = contains 1+n\\n    // hashed value not visited: hashValue = 0\\n\\n    int min_value = nums[0];\\n    int max_value = nums[0];\\n    for (int i=0 ; i<numsSize ; i++) {\\n        int idx = nums[i]%hashBuffer;\\n        while (hashValue[idx]!=0 && hashValue[idx]!=nums[i]+1) {\\n            idx++;\\n            if (idx>=hashBuffer) idx-=hashBuffer;\\n        }"]]}
{"id": "1756", "ref_c": [["int minimumIndex(int* nums, int numsSize){\\n    // Determine dominant element\\n    int count = 0;\\n    int dominant;\\n    int i;\\n    for (i=0 ; i<numsSize ; i++) {\\n        if (count==0) {\\n            count = 1;\\n            dominant = nums[i];\\n        }"], ["int minimumIndex(int* nums, int numsSize){\\n    // Determine dominant element\\n    int count = 0;\\n    int dominant;\\n    int i;\\n    for (i=0 ; i<numsSize ; i++) {\\n        if (count==0) {\\n            count = 1;\\n            dominant = nums[i];\\n        }"], ["int minimumIndex(int* nums, int numsSize){\\n    // Determine dominant element\\n    int count = 0;\\n    int dominant;\\n    int i;\\n    for (i=0 ; i<numsSize ; i++) {\\n        if (count==0) {\\n            count = 1;\\n            dominant = nums[i];\\n        }"]]}
{"id": "1757", "ref_c": ["\nint compareVowels(const void *a, const void *b) {\n    return (*(char *)a - *(char *)b);\n}\n\nchar *sortVowels(char *s) {\n    int n = strlen(s);\n\n    // Create arrays to store vowels and their indices\n    char vowels[n];\n    int vowelIndices[n];\n    int vowelCount = 0;\n\n    // Iterate through the string to separate vowels and consonants\n    for (int i = 0; i < n; i++) {\n        if (strchr(\"aeiouAEIOU\", s[i]) != NULL) {\n            vowels[vowelCount] = s[i];\n            vowelIndices[vowelCount] = i;\n            vowelCount++;\n        }\n    }\n\n    // If there are no vowels, return the original string\n    if (vowelCount == 0) {\n        return strdup(s);\n    }\n\n    // Sort vowels using the custom comparator\n    qsort(vowels, vowelCount, sizeof(char), compareVowels);\n\n    // Construct the resulting string\n    char *result = strdup(s); // Duplicate the original string\n    for (int i = 0; i < vowelCount; i++) {\n        result[vowelIndices[i]] = vowels[i];\n    }\n\n    return result;\n}\n", "\nint compareVowels(const void *a, const void *b) {\n    return (*(char *)a - *(char *)b);\n}\n\nchar *sortVowels(char *s) {\n    int n = strlen(s);\n\n    // Create arrays to store vowels and their indices\n    char vowels[n];\n    int vowelIndices[n];\n    int vowelCount = 0;\n\n    // Iterate through the string to separate vowels and consonants\n    for (int i = 0; i < n; i++) {\n        if (strchr(\"aeiouAEIOU\", s[i]) != NULL) {\n            vowels[vowelCount] = s[i];\n            vowelIndices[vowelCount] = i;\n            vowelCount++;\n        }\n    }\n\n    // If there are no vowels, return the original string\n    if (vowelCount == 0) {\n        return strdup(s);\n    }\n\n    // Sort vowels using the custom comparator\n    qsort(vowels, vowelCount, sizeof(char), compareVowels);\n\n    // Construct the resulting string\n    char *result = strdup(s); // Duplicate the original string\n    for (int i = 0; i < vowelCount; i++) {\n        result[vowelIndices[i]] = vowels[i];\n    }\n\n    return result;\n}\n", "\nint compareVowels(const void *a, const void *b) {\n    return (*(char *)a - *(char *)b);\n}\n\nchar *sortVowels(char *s) {\n    int n = strlen(s);\n\n    // Create arrays to store vowels and their indices\n    char vowels[n];\n    int vowelIndices[n];\n    int vowelCount = 0;\n\n    // Iterate through the string to separate vowels and consonants\n    for (int i = 0; i < n; i++) {\n        if (strchr(\"aeiouAEIOU\", s[i]) != NULL) {\n            vowels[vowelCount] = s[i];\n            vowelIndices[vowelCount] = i;\n            vowelCount++;\n        }\n    }\n\n    // If there are no vowels, return the original string\n    if (vowelCount == 0) {\n        return strdup(s);\n    }\n\n    // Sort vowels using the custom comparator\n    qsort(vowels, vowelCount, sizeof(char), compareVowels);\n\n    // Construct the resulting string\n    char *result = strdup(s); // Duplicate the original string\n    for (int i = 0; i < vowelCount; i++) {\n        result[vowelIndices[i]] = vowels[i];\n    }\n\n    return result;\n}\n"]}
{"id": "1758", "ref_c": [["long long maxScore(int* nums, int numsSize, int x){\\n    return maxScore_(nums , numsSize, x , 0);\\n}", "long long maxScore(int* nums, int numsSize, int x){\\n    long long * dp = malloc(numsSize*sizeof(long long));\\n    // Holds the maximum score obtainable from each index\\n    dp[numsSize-1] = nums[numsSize-1];\\n    int i=numsSize-2;\\n    while (i>=0) {\\n        if (nums[i]%2 == nums[i+1]%2) {\\n            // Same parity\\n            dp[i] = nums[i] + dp[i+1];\\n        }"], ["long long maxScore(int* nums, int numsSize, int x){\\n    return maxScore_(nums , numsSize, x , 0);\\n}", "long long maxScore(int* nums, int numsSize, int x){\\n    long long * dp = malloc(numsSize*sizeof(long long));\\n    // Holds the maximum score obtainable from each index\\n    dp[numsSize-1] = nums[numsSize-1];\\n    int i=numsSize-2;\\n    while (i>=0) {\\n        if (nums[i]%2 == nums[i+1]%2) {\\n            // Same parity\\n            dp[i] = nums[i] + dp[i+1];\\n        }"], ["long long maxScore(int* nums, int numsSize, int x){\\n    return maxScore_(nums , numsSize, x , 0);\\n}", "long long maxScore(int* nums, int numsSize, int x){\\n    long long * dp = malloc(numsSize*sizeof(long long));\\n    // Holds the maximum score obtainable from each index\\n    dp[numsSize-1] = nums[numsSize-1];\\n    int i=numsSize-2;\\n    while (i>=0) {\\n        if (nums[i]%2 == nums[i+1]%2) {\\n            // Same parity\\n            dp[i] = nums[i] + dp[i+1];\\n        }"]]}
{"id": "1759", "ref_c": [["int numberOfWays(int n, int x){\\n\\n    /*\\n     * Input:\\n     *  n,\\n     *  x\\n     */\\n\\n    int tbl[300], tbl_len = 0, ans;\\n    int **dp = (int **)malloc(sizeof(int *) * (n + 1));\\n\\n    buildPwr(x, n, tbl, &tbl_len);\\n\\n    for (int i = 0; i <= n; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * tbl_len);\\n\\n        for (int j = 0; j < tbl_len; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int numberOfWays(int n, int x){\\n    return dp_(n,1,x);\\n}"], ["int numberOfWays(int n, int x){\\n\\n    /*\\n     * Input:\\n     *  n,\\n     *  x\\n     */\\n\\n    int tbl[300], tbl_len = 0, ans;\\n    int **dp = (int **)malloc(sizeof(int *) * (n + 1));\\n\\n    buildPwr(x, n, tbl, &tbl_len);\\n\\n    for (int i = 0; i <= n; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * tbl_len);\\n\\n        for (int j = 0; j < tbl_len; j++) {\\n            dp[i][j] = -1;\\n        }"]]}
{"id": "1760", "ref_c": [["long long maxArrayValue(int* nums, int numsSize){\\n    long long current = nums[numsSize-1];\\n    int i = numsSize-2;\\n    while (i>=0) {\\n        if (nums[i] <= current) {\\n            current += nums[i];\\n        }"], ["long long maxArrayValue(int* nums, int numsSize){\\n    long long current = nums[numsSize-1];\\n    int i = numsSize-2;\\n    while (i>=0) {\\n        if (nums[i] <= current) {\\n            current += nums[i];\\n        }"], ["long long maxArrayValue(int* nums, int numsSize){\\n    long long current = nums[numsSize-1];\\n    int i = numsSize-2;\\n    while (i>=0) {\\n        if (nums[i] <= current) {\\n            current += nums[i];\\n        }"]]}
{"id": "1761", "ref_c": [["int countCompleteSubarrays(int* nums, int numsSize) {\\n    int hash[2001] = {0}"], ["int countCompleteSubarrays(int* nums, int numsSize){\\n    // First, we count the number of distinct elements\\n    int totalDistinctElements = 0;\\n    int elements[2001] = {0}"], ["int countCompleteSubarrays(int* nums, int numsSize) {\\n    int hash[2001] = {0}"]]}
{"id": "1762", "ref_c": [["char * minimumString(char * a, char * b, char * c){\\n    // a,b,c will appear in the answer in some order\\n    // abc, acb, bac, bca, cab or cba, possibly with overlaps\\n    // We solve each of these options and take the smallest one.\\n\\n    char * s = minimumString_ordered(a,b,c);\\n    int curr_len = strlen(s);\\n    /////\\n    char * s_ = minimumString_ordered(a,c,b);\\n\\n    if ( ( strlen(s_) < curr_len ) \\n            ||\\n            ( strlen(s_) == curr_len && strcmp(s_,s)<0 )\\n    ) {\\n        free(s);\\n        s = s_;\\n        curr_len = strlen(s);\\n    }"], ["char * minimumString(char * a, char * b, char * c){\\n    // a,b,c will appear in the answer in some order\\n    // abc, acb, bac, bca, cab or cba, possibly with overlaps\\n    // We solve each of these options and take the smallest one.\\n\\n    char * s = minimumString_ordered(a,b,c);\\n    int curr_len = strlen(s);\\n    /////\\n    char * s_ = minimumString_ordered(a,c,b);\\n\\n    if ( ( strlen(s_) < curr_len ) \\n            ||\\n            ( strlen(s_) == curr_len && strcmp(s_,s)<0 )\\n    ) {\\n        free(s);\\n        s = s_;\\n        curr_len = strlen(s);\\n    }"], ["char * minimumString(char * a, char * b, char * c){\\n    // a,b,c will appear in the answer in some order\\n    // abc, acb, bac, bca, cab or cba, possibly with overlaps\\n    // We solve each of these options and take the smallest one.\\n\\n    char * s = minimumString_ordered(a,b,c);\\n    int curr_len = strlen(s);\\n    /////\\n    char * s_ = minimumString_ordered(a,c,b);\\n\\n    if ( ( strlen(s_) < curr_len ) \\n            ||\\n            ( strlen(s_) == curr_len && strcmp(s_,s)<0 )\\n    ) {\\n        free(s);\\n        s = s_;\\n        curr_len = strlen(s);\\n    }"]]}
{"id": "1763", "ref_c": [["struct ListNode* insertGreatestCommonDivisors(struct ListNode* head){\\n   if(head==NULL || head->next==NULL) return head;\\n    struct ListNode *fir=head;\\n    struct ListNode *sec=head->next;\\n    int i,n1,n2,gcd;\\n    while(sec!=NULL){\\n    n1=fir->val; n2=sec->val;\\n        for(i=1; i <= n1 && i <= n2; ++i)\\n    {\\n        \\n        if(n1%i==0 && n2%i==0)\\n            gcd = i;\\n    }"], ["struct ListNode* insertGreatestCommonDivisors(struct ListNode* head)\\n{\\n    struct ListNode* temp1 = head;\\n    struct ListNode* temp2 = head->next;\\n    while(temp2!=NULL)\\n    {\\n        struct ListNode* new_node = (struct ListNode*)(malloc(sizeof(struct ListNode)));\\n        new_node->val = gcd(temp1->val,temp2->val);\\n        new_node->next = NULL;\\n        temp1->next = new_node;\\n        new_node->next = temp2;\\n        temp1=temp1->next->next;\\n        temp2 = temp2->next;\\n    }"], ["struct ListNode* insertGreatestCommonDivisors(struct ListNode* head){\\n    struct ListNode *h = head;\\n    while(head != NULL && head->next != NULL) {\\n            int r = gcd(head->val, head->next->val);\\n            struct ListNode* newnode = (struct ListNode*)malloc(sizeof(struct ListNode));\\n            newnode->val = r;\\n            struct ListNode *temp = head->next;\\n            head->next = newnode;\\n            newnode->next = temp;\\n            head = newnode->next;\\n        }"]]}
{"id": "1764", "ref_c": [["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n\\n    char a[26]={0}"]]}
{"id": "1765", "ref_c": [["int findLengthOfShortestSubarray(int* arr, int arrSize){\\n    int i = 0,j = arrSize-1;\\n    while(i < arrSize-1 && arr[i+1] >= arr[i]){\\n        i++;\\n    }"], ["int findLengthOfShortestSubarray(int* arr, int arrSize){\\n    int left = 0, right = arrSize - 1;\\n    while (left + 1 < arrSize && arr[left] <= arr[left + 1])\\n    {\\n        left++;\\n    }"], ["int findLengthOfShortestSubarray(int* arr, int arrSize){\\n    int left = 0, right = arrSize - 1;\\n    while (left + 1 < arrSize && arr[left] <= arr[left + 1])\\n    {\\n        left++;\\n    }"]]}
{"id": "1766", "ref_c": [["bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){\\n    int popi = 0, stack[1000] , top = -1;\\n    for (int i = 0 ; i < pushedSize ; i++ ){\\n        stack[++top] = pushed[i];\\n        while(top!=-1 && popped[popi] == stack[top]){\\n            top--;\\n            popi++;\\n        }"], ["bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){\\nint top=-1, l=0; \\n    for(int i=0; i<pushedSize; i++){\\n        top++;\\n        pushed[top]=pushed[i];\\n        while(top>-1){\\n            if(pushed[top]==popped[l]){\\n                top--;\\n                l++;\\n            }"], ["bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){\\n\\n    int top = 0;\\n    int i=0;\\n    while (1)\\n    {\\n        if (top >= pushedSize || i >= poppedSize)\\n        break;\\n        if (pushed[top] == -1)\\n        {\\n            top++;\\n            continue;\\n        }"]]}
{"id": "1767", "ref_c": [["struct ListNode* doubleIt(struct ListNode* head)\\n{\\n    struct ListNode* temp1 = head;\\n    struct ListNode* temp2 = head->next;\\n    head->val = head->val*2;\\n    if(head->val>=10)\\n    {\\n        struct ListNode* new_node = (struct ListNode*)(malloc(sizeof(struct ListNode)));\\n        new_node->next = head;\\n        head->val = head->val%10;\\n        new_node->val = 1;\\n        head = new_node;\\n    }"], ["struct ListNode* doubleIt(struct ListNode* head){\\n    head=reverse(head);\\n    struct ListNode *temp;\\n    temp=head;\\n    int sum=0,data,carry=0;\\n    struct ListNode *result=NULL;\\n    while(temp)\\n    {\\n        sum=temp->val*2+carry;\\n        data=sum%10;\\n        carry=sum/10;\\n        result=add_term(result,data);\\n        temp=temp->next;\\n    }"], ["struct ListNode* doubleIt(struct ListNode* head){\\n    head=reverse(head);\\n    struct ListNode *temp;\\n    temp=head;\\n    int sum=0,data,carry=0;\\n    struct ListNode *result=NULL;\\n    while(temp)\\n    {\\n        sum=temp->val*2+carry;\\n        data=sum%10;\\n        carry=sum/10;\\n        result=add_term(result,data);\\n        temp=temp->next;\\n    }"]]}
{"id": "1768", "ref_c": ["\nint find(int* uf, int i){\n    while(uf[i] != i){\n        i = uf[i];\n    }\n    return i;\n}\n\nvoid merge(int* uf, int i, int j){\n    uf[find(uf, j)] = find(uf, i);\n}\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    int n = strlen(s);\n    int* uf = calloc(n+1, sizeof(int));\n    for(int i = 0; i < n+1; i++){\n        uf[i] = i;\n    }\n\n    for(int i = 0; i < wordDictSize; i++){\n        int m = strlen(wordDict[i]);\n        for(int j = 0; j <= n - m; j++){\n            if(!strncmp(wordDict[i], s+j, m)) {\n                merge(uf, j, j + m);\n            }\n        }\n    }\n\n    bool ret = find(uf, n) == find(uf, 0);\n    free(uf);\n    return ret;\n}\n", "\nint find(int* uf, int i){\n    while(uf[i] != i){\n        i = uf[i];\n    }\n    return i;\n}\n\nvoid merge(int* uf, int i, int j){\n    uf[find(uf, j)] = find(uf, i);\n}\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    int n = strlen(s);\n    int* uf = calloc(n+1, sizeof(int));\n    for(int i = 0; i < n+1; i++){\n        uf[i] = i;\n    }\n\n    for(int i = 0; i < wordDictSize; i++){\n        int m = strlen(wordDict[i]);\n        for(int j = 0; j <= n - m; j++){\n            if(!strncmp(wordDict[i], s+j, m)) {\n                merge(uf, j, j + m);\n            }\n        }\n    }\n\n    bool ret = find(uf, n) == find(uf, 0);\n    free(uf);\n    return ret;\n}\n", "\nint find(int* uf, int i){\n    while(uf[i] != i){\n        i = uf[i];\n    }\n    return i;\n}\n\nvoid merge(int* uf, int i, int j){\n    uf[find(uf, j)] = find(uf, i);\n}\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    int n = strlen(s);\n    int* uf = calloc(n+1, sizeof(int));\n    for(int i = 0; i < n+1; i++){\n        uf[i] = i;\n    }\n\n    for(int i = 0; i < wordDictSize; i++){\n        int m = strlen(wordDict[i]);\n        for(int j = 0; j <= n - m; j++){\n            if(!strncmp(wordDict[i], s+j, m)) {\n                merge(uf, j, j + m);\n            }\n        }\n    }\n\n    bool ret = find(uf, n) == find(uf, 0);\n    free(uf);\n    return ret;\n}\n"]}
{"id": "1769", "ref_c": [["double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int temp[nums1Size+nums2Size];\\n    int x =0;\\n        for (int i = 0 ; i<nums1Size+nums2Size ; i++){\\n            if (i < nums1Size)\\n               temp[i] = nums1[i];\\n            else\\n                temp[i] = nums2[x++];\\n\\n        }"], ["double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int temp[nums1Size+nums2Size];\\n    int x =0;\\n        for (int i = 0 ; i<nums1Size+nums2Size ; i++){\\n            if (i < nums1Size)\\n               temp[i] = nums1[i];\\n            else\\n                temp[i] = nums2[x++];\\n\\n        }"], ["double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int temp[nums1Size+nums2Size];\\n    int x =0;\\n        for (int i = 0 ; i<nums1Size+nums2Size ; i++){\\n            if (i < nums1Size)\\n               temp[i] = nums1[i];\\n            else\\n                temp[i] = nums2[x++];\\n\\n        }"]]}
{"id": "1770", "ref_c": [["bool isMatch(char * s, char * p){\\n    if (!p[0]) return !s[0];\\n    if (p[1] == \\'*\\') return isMatch(s, p+2) || match(s, p) && isMatch(s+1, p);\\n    if (p[0] == \\'.\\') return s[0] && isMatch(s+1, p+1);\\n    return match(s, p) && isMatch(s+1, p+1);\\n}"], ["bool isMatch(char * s, char * p){\\n    if (!p[0]) return !s[0];\\n    if (p[1] == \\'*\\') return isMatch(s, p+2) || match(s, p) && isMatch(s+1, p);\\n    if (p[0] == \\'.\\') return s[0] && isMatch(s+1, p+1);\\n    return match(s, p) && isMatch(s+1, p+1);\\n}"], ["bool isMatch(char * s, char * p){\\n    if (!p[0]) return !s[0];\\n    if (p[1] == \\'*\\') return isMatch(s, p+2) || match(s, p) && isMatch(s+1, p);\\n    if (p[0] == \\'.\\') return s[0] && isMatch(s+1, p+1);\\n    return match(s, p) && isMatch(s+1, p+1);\\n}"]]}
{"id": "1771", "ref_c": [["struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\\n        // Recursion \\n\\n        // uses a merge2Lists() function to recursively merge pairs of linked lists, \\n        // starting with the first two lists, then the result of the first merge with \\n        // the third list, and so on, until all lists are merged\\n\\n        // Time complexity: O(n*k), n := total number of nodes across all linked lists \\n        // Space complexity: O(max(n1, n2)), dominated by the recursion depth \\n\\n        struct ListNode* result = NULL;\\n        if (listsSize == 0 || (listsSize == 1 && lists[0] == NULL)) \\n            return NULL;\\n        for (int i = 0; i < listsSize; i++) {\\n            result = merge2Lists(result, lists[i]);\\n        }", "struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\\n        // Bottom-up iterative approach\\n\\n        // Time complexity: O(n*k), n := total number of nodes across all linked lists \\n        // Space complexity: O(max(n1, n2))\\n\\n        if (listsSize == 0) \\n            return NULL;\\n        int interval = 1;\\n        while (interval < listsSize) {\\n            for (int i = 0; i < listsSize - interval; i += interval * 2) {\\n                lists[i] = merge2Lists(lists[i], lists[i + interval]);\\n            }"], ["struct ListNode* mergeKLists(struct ListNode** lists, int listsSize){\\n       return  mergeSort(lists, 0, listsSize-1);\\n}"], ["struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\\n        // Recursion \\n\\n        // uses a merge2Lists() function to recursively merge pairs of linked lists, \\n        // starting with the first two lists, then the result of the first merge with \\n        // the third list, and so on, until all lists are merged\\n\\n        // Time complexity: O(n*k), n := total number of nodes across all linked lists \\n        // Space complexity: O(max(n1, n2)), dominated by the recursion depth \\n\\n        struct ListNode* result = NULL;\\n        if (listsSize == 0 || (listsSize == 1 && lists[0] == NULL)) \\n            return NULL;\\n        for (int i = 0; i < listsSize; i++) {\\n            result = merge2Lists(result, lists[i]);\\n        }", "struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\\n        // Bottom-up iterative approach\\n\\n        // Time complexity: O(n*k), n := total number of nodes across all linked lists \\n        // Space complexity: O(max(n1, n2))\\n\\n        if (listsSize == 0) \\n            return NULL;\\n        int interval = 1;\\n        while (interval < listsSize) {\\n            for (int i = 0; i < listsSize - interval; i += interval * 2) {\\n                lists[i] = merge2Lists(lists[i], lists[i + interval]);\\n            }"]]}
{"id": "1772", "ref_c": [["struct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }"], ["struct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }"], ["struct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }"]]}
{"id": "1773", "ref_c": [["int* findSubstring(char * s, char ** words, int wordsSize, int* returnSize){\\n    /*\\n     * Input:\\n     *  *s, string\\n     *  **words, string list\\n     *  wordsSize, number of string in given list\\n     */\\n     \\n    int string_len = strlen(s), word_len = strlen(words[0]), match_cnt = 0;\\n    int *ans = (int *)malloc(sizeof(int) * string_len);\\n    int match;\\n    trie_node_t trie;\\n\\n    *returnSize = 0;\\n    \\n    initTrie(&trie);\\n    \\n    /* \\n     * Count the frequency of words, \\n     * time complexity = O(n * m), n = length of word, m = number of words \\n     */\\n    for (int i = 0; i < wordsSize; i++) {\\n        insertTrie(&trie, words[i]);\\n    }"], ["int* findSubstring(char * s, char ** words, int wordsSize, int* returnSize){\\n    /*\\n     * Input:\\n     *  *s, string\\n     *  **words, string list\\n     *  wordsSize, number of string in given list\\n     */\\n     \\n    int string_len = strlen(s), word_len = strlen(words[0]), match_cnt = 0;\\n    int *ans = (int *)malloc(sizeof(int) * string_len);\\n    int match;\\n    trie_node_t trie;\\n\\n    *returnSize = 0;\\n    \\n    initTrie(&trie);\\n    \\n    /* \\n     * Count the frequency of words, \\n     * time complexity = O(n * m), n = length of word, m = number of words \\n     */\\n    for (int i = 0; i < wordsSize; i++) {\\n        insertTrie(&trie, words[i]);\\n    }"], ["int* findSubstring(char * s, char ** words, int wordsSize, int* returnSize){\\n    /*\\n     * Input:\\n     *  *s, string\\n     *  **words, string list\\n     *  wordsSize, number of string in given list\\n     */\\n     \\n    int string_len = strlen(s), word_len = strlen(words[0]), match_cnt = 0;\\n    int *ans = (int *)malloc(sizeof(int) * string_len);\\n    int match;\\n    trie_node_t trie;\\n\\n    *returnSize = 0;\\n    \\n    initTrie(&trie);\\n    \\n    /* \\n     * Count the frequency of words, \\n     * time complexity = O(n * m), n = length of word, m = number of words \\n     */\\n    for (int i = 0; i < wordsSize; i++) {\\n        insertTrie(&trie, words[i]);\\n    }"]]}
{"id": "1774", "ref_c": [["int longestValidParentheses(char * s){\\n    int len = strlen(s);\\n    int* map = (int*)malloc(sizeof(int) * (len * 2 + 1));\\n    \\n    for (int i = 0; i < (len * 2 + 1); i++) {\\n        map[i] = (i == len ? 0 : -1);\\n    }"], ["int longestValidParentheses(char * s){\\n    int len = strlen(s);\\n    int* map = (int*)malloc(sizeof(int) * (len * 2 + 1));\\n    \\n    for (int i = 0; i < (len * 2 + 1); i++) {\\n        map[i] = (i == len ? 0 : -1);\\n    }"], ["int longestValidParentheses(char * s){\\n    int len = strlen(s);\\n    int* map = (int*)malloc(sizeof(int) * (len * 2 + 1));\\n    \\n    for (int i = 0; i < (len * 2 + 1); i++) {\\n        map[i] = (i == len ? 0 : -1);\\n    }"]]}
{"id": "1775", "ref_c": [["void solveSudoku(char** board, int boardSize, int* boardColSize) {\\n    solve(board);\\n}"], ["void solveSudoku(char** board, int boardSize, int* boardColSize) {\\n    solve(board);\\n}"], ["void solveSudoku(char** board, int boardSize, int* boardColSize) {\\n    if (solveSudokuUtil(board, 0, 0)) {\\n        printBoard(board);\\n    }"]]}
{"id": "1776", "ref_c": [["int firstMissingPositive(int* nums, int numsSize){\\n    int x=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1){\\n            x=1;\\n            break;\\n        }"], ["int firstMissingPositive(int* nums, int numsSize){\\n    int x=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1){\\n            x=1;\\n            break;\\n        }"], ["int firstMissingPositive(int* nums, int numsSize){\\n    int x=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1){\\n            x=1;\\n            break;\\n        }"]]}
{"id": "1777", "ref_c": [["int trap(int* height, int heightSize) {\\n   int l=0,r=heightSize-1;\\n   int maxl,maxr,tar=0;\\n       maxl=height[0];\\n       maxr=height[heightSize-1];\\n   while(l<r){\\n     maxl=fmax(maxl,height[l]);\\n     maxr=fmax(maxr,height[r]);\\n     tar+=maxl>maxr?maxr-height[r--]:maxl-height[l++];  \\n   }"], ["int trap(int* height, int heightSize){\\n    int i,max=0,water=0,a,maxin;\\n    for(i=0;i<heightSize;i++)\\n        if(max<=height[i]){\\n            max=height[i];\\n            maxin=i;\\n        }"], ["int trap(int* height, int heightSize) {\\n   int l=0,r=heightSize-1;\\n   int maxl,maxr,tar=0;\\n       maxl=height[0];\\n       maxr=height[heightSize-1];\\n   while(l<r){\\n     maxl=fmax(maxl,height[l]);\\n     maxr=fmax(maxr,height[r]);\\n     tar+=maxl>maxr?maxr-height[r--]:maxl-height[l++];  \\n   }"]]}
{"id": "1778", "ref_c": ["\nbool isMatch(char* s, char* p) {\n    int sLen = strlen(s), pLen = strlen(p);\n    bool dp[sLen+1][pLen+1];\n    memset(dp, false, sizeof(dp));\n    dp[sLen][pLen] = true;\n\n    for (int i = sLen; i >= 0; i--){\n        for (int j = pLen - 1; j >= 0; j--){\n            bool first_match = (i < sLen && (p[j] == s[i] || p[j] == '?'));\n            if (p[j] == '*'){\n                dp[i][j] = dp[i][j+1] || (i < sLen && dp[i+1][j]);\n            } else {\n                dp[i][j] = first_match && dp[i+1][j+1];\n            }\n        }\n    }\n    return dp[0][0];\n}\n", "\nbool isMatch(char* s, char* p) {\n    int sLen = strlen(s), pLen = strlen(p);\n    bool dp[sLen+1][pLen+1];\n    memset(dp, false, sizeof(dp));\n    dp[sLen][pLen] = true;\n\n    for (int i = sLen; i >= 0; i--){\n        for (int j = pLen - 1; j >= 0; j--){\n            bool first_match = (i < sLen && (p[j] == s[i] || p[j] == '?'));\n            if (p[j] == '*'){\n                dp[i][j] = dp[i][j+1] || (i < sLen && dp[i+1][j]);\n            } else {\n                dp[i][j] = first_match && dp[i+1][j+1];\n            }\n        }\n    }\n    return dp[0][0];\n}\n", "\nbool isMatch(char* s, char* p) {\n    int sLen = strlen(s), pLen = strlen(p);\n    bool dp[sLen+1][pLen+1];\n    memset(dp, false, sizeof(dp));\n    dp[sLen][pLen] = true;\n\n    for (int i = sLen; i >= 0; i--){\n        for (int j = pLen - 1; j >= 0; j--){\n            bool first_match = (i < sLen && (p[j] == s[i] || p[j] == '?'));\n            if (p[j] == '*'){\n                dp[i][j] = dp[i][j+1] || (i < sLen && dp[i+1][j]);\n            } else {\n                dp[i][j] = first_match && dp[i+1][j+1];\n            }\n        }\n    }\n    return dp[0][0];\n}\n"]}
{"id": "1779", "ref_c": [["char *** solveNQueens(int n, int* returnSize, int** returnColumnSizes) {\\n    char *** result = NULL;\\n    *returnSize = 0;\\n    *returnColumnSizes = NULL; // Corrected assignment\\n\\n    char** ds = malloc(sizeof(char*) * n);\\n    char *p = malloc(sizeof(char) * (n + 1));\\n    for (int i = 0; i < n; i++) {\\n        p[i] = \\'.\\';\\n    }"], ["char *** solveNQueens(int n, int* returnSize, int** returnColumnSizes) {\\n    char *** result = NULL;\\n    *returnSize = 0;\\n    *returnColumnSizes = NULL; // Corrected assignment\\n\\n    char** ds = malloc(sizeof(char*) * n);\\n    char *p = malloc(sizeof(char) * (n + 1));\\n    for (int i = 0; i < n; i++) {\\n        p[i] = \\'.\\';\\n    }"], ["char *** solveNQueens(int n, int* returnSize, int** returnColumnSizes) {\\n    char *** result = NULL;\\n    *returnSize = 0;\\n    *returnColumnSizes = NULL; // Corrected assignment\\n\\n    char** ds = malloc(sizeof(char*) * n);\\n    char *p = malloc(sizeof(char) * (n + 1));\\n    for (int i = 0; i < n; i++) {\\n        p[i] = \\'.\\';\\n    }"]]}
{"id": "1780", "ref_c": [["int totalNQueens(int n){\\n    int ar[9]={1,0,0,2,10,4,40,92,352}"], ["int totalNQueens(int n) {\\n        vector<vector<int>> board(n,vector<int>(n,0));\\n        return countNQueens(board,n,0);\\n    }"], ["int totalNQueens(int n){\\n    int ar[9]={1,0,0,2,10,4,40,92,352}"]]}
{"id": "1781", "ref_c": [["char * getPermutation(int n, int k){\\n    k = k - 1;\\n    char* digit = (char*)malloc(sizeof(char) * n);\\n    for(int i = 0;i < n;i++){\\n        digit[i] = i + \\'1\\';\\n    }"], ["char * getPermutation(int n, int k){\\n    k = k - 1;\\n    char* digit = (char*)malloc(sizeof(char) * n);\\n    for(int i = 0;i < n;i++){\\n        digit[i] = i + \\'1\\';\\n    }"], ["char * getPermutation(int n, int k){\\n    k = k - 1;\\n    char* digit = (char*)malloc(sizeof(char) * n);\\n    for(int i = 0;i < n;i++){\\n        digit[i] = i + \\'1\\';\\n    }"]]}
{"id": "1782", "ref_c": [["bool isNumber(char * s){\\n    bool    exp_found       = false; // State flags\\n    bool    decimal_found   = false;\\n    bool    sign_allowed    = true; // One shots\\n    bool    decimal_allowed = true;\\n    uint8_t pre_e_digits    = 0;\\n    uint8_t post_e_digits   = 0;\\n    uint8_t valid[16]       = {\\n        1, 0, 1, 1, 0, 1, 1, 1, // + , - . / 0 1 2 \\n        1, 1, 1, 1, 1, 1, 1, 0, // 3 4 5 6 7 8 9 :\\n    }"], ["bool isNumber(char * s){\\n    bool    exp_found       = false; // State flags\\n    bool    decimal_found   = false;\\n    bool    sign_allowed    = true; // One shots\\n    bool    decimal_allowed = true;\\n    uint8_t pre_e_digits    = 0;\\n    uint8_t post_e_digits   = 0;\\n    uint8_t valid[16]       = {\\n        1, 0, 1, 1, 0, 1, 1, 1, // + , - . / 0 1 2 \\n        1, 1, 1, 1, 1, 1, 1, 0, // 3 4 5 6 7 8 9 :\\n    }"], ["bool isNumber(char * s){\\n    bool    exp_found       = false; // State flags\\n    bool    decimal_found   = false;\\n    bool    sign_allowed    = true; // One shots\\n    bool    decimal_allowed = true;\\n    uint8_t pre_e_digits    = 0;\\n    uint8_t post_e_digits   = 0;\\n    uint8_t valid[16]       = {\\n        1, 0, 1, 1, 0, 1, 1, 1, // + , - . / 0 1 2 \\n        1, 1, 1, 1, 1, 1, 1, 0, // 3 4 5 6 7 8 9 :\\n    }"]]}
{"id": "1783", "ref_c": [["char ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize) {\\n    char **result = (char **)malloc(sizeof(char *) * wordsSize);\\n    *returnSize = 0;\\n    \\n    int start = 0;  // Index of the first word in the current line.\\n    \\n    while (start < wordsSize) {\\n        int end = start;  // Index of the last word in the current line.\\n        int lineLength = 0;  // Length of the words and spaces in the current line.\\n        \\n        // Calculate the number of words and total length that can fit in the current line.\\n        while (end < wordsSize && lineLength + strlen(words[end]) + end - start <= maxWidth) {\\n            lineLength += strlen(words[end]);\\n            end++;\\n        }"], ["char ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize) {\\n    char **result = (char **)malloc(sizeof(char *) * wordsSize);\\n    *returnSize = 0;\\n    \\n    int start = 0;  // Index of the first word in the current line.\\n    \\n    while (start < wordsSize) {\\n        int end = start;  // Index of the last word in the current line.\\n        int lineLength = 0;  // Length of the words and spaces in the current line.\\n        \\n        // Calculate the number of words and total length that can fit in the current line.\\n        while (end < wordsSize && lineLength + strlen(words[end]) + end - start <= maxWidth) {\\n            lineLength += strlen(words[end]);\\n            end++;\\n        }"], ["char ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize) {\\n    char **result = (char **)malloc(sizeof(char *) * wordsSize);\\n    *returnSize = 0;\\n    \\n    int start = 0;  // Index of the first word in the current line.\\n    \\n    while (start < wordsSize) {\\n        int end = start;  // Index of the last word in the current line.\\n        int lineLength = 0;  // Length of the words and spaces in the current line.\\n        \\n        // Calculate the number of words and total length that can fit in the current line.\\n        while (end < wordsSize && lineLength + strlen(words[end]) + end - start <= maxWidth) {\\n            lineLength += strlen(words[end]);\\n            end++;\\n        }"]]}
{"id": "1784", "ref_c": ["\nchar * minWindow(char * s, char * t){\n    // if string t is only one char, just check if s has t is enough\n    if(0 == *(t+1))\n    {\n        while(*s)\n        {\n            if(*(s++) == *t) return t;\n        }\n\n        return s;\n    }\n\n    // count input string t\n    char cCharCount = 0;\n    int anCount[LETTER_SIZE];\n    memset(anCount, 0, LETTER_SIZE*sizeof(int));\n    while(*t)\n    {\n        if(0 == anCount[*(t++)-'A']++) cCharCount++;\n    }\n\n    // trace input string s\n    char* pcRet = NULL;\n    char* pcTmp = NULL;\n    int nRet = INT_MAX;\n    while(*s)\n    {\n        char cIndex = *s - 'A';\n        if(pcTmp)\n        {\n            // if all chars in string t are hit in string s\n            if(0 == --anCount[cIndex] && 0 == --cCharCount)\n            {\n                // update current pcRet\n                int nTmp = 1 + s - pcTmp;\n                if(nTmp < nRet)\n                {\n                    nRet = nTmp;\n                    pcRet = pcTmp;\n                }\n\n                // find next pcTmp\n                while(pcTmp < s)\n                {\n                    cIndex = *pcTmp - 'A';\n                    if(0 <= anCount[cIndex])\n                    {\n                        if(1 == cCharCount) break;\n\n                        if(0 == cCharCount++)\n                        {\n                            nTmp = 1 + s - pcTmp;\n                            if(nTmp < nRet)\n                            {\n                                nRet = nTmp;\n                                pcRet = pcTmp;\n                            }\n                        }\n                    }\n\n                    anCount[cIndex]++;\n                    pcTmp++;\n                }\n            }\n        }\n        else\n        {\n            if(anCount[cIndex]--)\n            {\n                pcTmp = s;\n                if(0 == anCount[cIndex]) cCharCount--;\n            }\n        }\n\n        s++;\n    }\n\n    // if we have result pcRet\n    if(pcRet)\n    {\n        *(pcRet+nRet) = '\u0000';\n    }\n    else\n    {\n        pcRet = s;\n    }\n\n    return pcRet;\n}\n", "\nchar * minWindow(char * s, char * t){\n    // if string t is only one char, just check if s has t is enough\n    if(0 == *(t+1))\n    {\n        while(*s)\n        {\n            if(*(s++) == *t) return t;\n        }\n\n        return s;\n    }\n\n    // count input string t\n    char cCharCount = 0;\n    int anCount[LETTER_SIZE];\n    memset(anCount, 0, LETTER_SIZE*sizeof(int));\n    while(*t)\n    {\n        if(0 == anCount[*(t++)-'A']++) cCharCount++;\n    }\n\n    // trace input string s\n    char* pcRet = NULL;\n    char* pcTmp = NULL;\n    int nRet = INT_MAX;\n    while(*s)\n    {\n        char cIndex = *s - 'A';\n        if(pcTmp)\n        {\n            // if all chars in string t are hit in string s\n            if(0 == --anCount[cIndex] && 0 == --cCharCount)\n            {\n                // update current pcRet\n                int nTmp = 1 + s - pcTmp;\n                if(nTmp < nRet)\n                {\n                    nRet = nTmp;\n                    pcRet = pcTmp;\n                }\n\n                // find next pcTmp\n                while(pcTmp < s)\n                {\n                    cIndex = *pcTmp - 'A';\n                    if(0 <= anCount[cIndex])\n                    {\n                        if(1 == cCharCount) break;\n\n                        if(0 == cCharCount++)\n                        {\n                            nTmp = 1 + s - pcTmp;\n                            if(nTmp < nRet)\n                            {\n                                nRet = nTmp;\n                                pcRet = pcTmp;\n                            }\n                        }\n                    }\n\n                    anCount[cIndex]++;\n                    pcTmp++;\n                }\n            }\n        }\n        else\n        {\n            if(anCount[cIndex]--)\n            {\n                pcTmp = s;\n                if(0 == anCount[cIndex]) cCharCount--;\n            }\n        }\n\n        s++;\n    }\n\n    // if we have result pcRet\n    if(pcRet)\n    {\n        *(pcRet+nRet) = '\u0000';\n    }\n    else\n    {\n        pcRet = s;\n    }\n\n    return pcRet;\n}\n", "\nchar * minWindow(char * s, char * t){\n    // if string t is only one char, just check if s has t is enough\n    if(0 == *(t+1))\n    {\n        while(*s)\n        {\n            if(*(s++) == *t) return t;\n        }\n\n        return s;\n    }\n\n    // count input string t\n    char cCharCount = 0;\n    int anCount[LETTER_SIZE];\n    memset(anCount, 0, LETTER_SIZE*sizeof(int));\n    while(*t)\n    {\n        if(0 == anCount[*(t++)-'A']++) cCharCount++;\n    }\n\n    // trace input string s\n    char* pcRet = NULL;\n    char* pcTmp = NULL;\n    int nRet = INT_MAX;\n    while(*s)\n    {\n        char cIndex = *s - 'A';\n        if(pcTmp)\n        {\n            // if all chars in string t are hit in string s\n            if(0 == --anCount[cIndex] && 0 == --cCharCount)\n            {\n                // update current pcRet\n                int nTmp = 1 + s - pcTmp;\n                if(nTmp < nRet)\n                {\n                    nRet = nTmp;\n                    pcRet = pcTmp;\n                }\n\n                // find next pcTmp\n                while(pcTmp < s)\n                {\n                    cIndex = *pcTmp - 'A';\n                    if(0 <= anCount[cIndex])\n                    {\n                        if(1 == cCharCount) break;\n\n                        if(0 == cCharCount++)\n                        {\n                            nTmp = 1 + s - pcTmp;\n                            if(nTmp < nRet)\n                            {\n                                nRet = nTmp;\n                                pcRet = pcTmp;\n                            }\n                        }\n                    }\n\n                    anCount[cIndex]++;\n                    pcTmp++;\n                }\n            }\n        }\n        else\n        {\n            if(anCount[cIndex]--)\n            {\n                pcTmp = s;\n                if(0 == anCount[cIndex]) cCharCount--;\n            }\n        }\n\n        s++;\n    }\n\n    // if we have result pcRet\n    if(pcRet)\n    {\n        *(pcRet+nRet) = '\u0000';\n    }\n    else\n    {\n        pcRet = s;\n    }\n\n    return pcRet;\n}\n"]}
{"id": "1785", "ref_c": [["int largestRectangleArea(int* heights, int heightsSize) {\\n    int* stack = (int*)malloc((heightsSize + 1) * sizeof(int));\\n    int stackSize = 0;\\n\\n    int maxArea = 0;\\n\\n    for (int i = 0; i <= heightsSize; i++) {\\n        int currentHeight = (i == heightsSize) ? 0 : heights[i];\\n        while (stackSize > 0 && currentHeight < heights[stack[stackSize - 1]]) {\\n            int poppedIndex = stack[--stackSize];\\n            int poppedHeight = heights[poppedIndex];\\n            int width = (stackSize == 0) ? i : i - stack[stackSize - 1] - 1;\\n\\n            maxArea = fmax(maxArea, calculateArea(poppedHeight, width));\\n        }"], ["int largestRectangleArea(int* heights, int heightsSize) {\\n    int* stack = (int*)malloc((heightsSize + 1) * sizeof(int));\\n    int stackSize = 0;\\n\\n    int maxArea = 0;\\n\\n    for (int i = 0; i <= heightsSize; i++) {\\n        int currentHeight = (i == heightsSize) ? 0 : heights[i];\\n        while (stackSize > 0 && currentHeight < heights[stack[stackSize - 1]]) {\\n            int poppedIndex = stack[--stackSize];\\n            int poppedHeight = heights[poppedIndex];\\n            int width = (stackSize == 0) ? i : i - stack[stackSize - 1] - 1;\\n\\n            maxArea = fmax(maxArea, calculateArea(poppedHeight, width));\\n        }"], ["int largestRectangleArea(int* heights, int heightsSize) {\\n    int* stack = (int*)malloc((heightsSize + 1) * sizeof(int));\\n    int stackSize = 0;\\n\\n    int maxArea = 0;\\n\\n    for (int i = 0; i <= heightsSize; i++) {\\n        int currentHeight = (i == heightsSize) ? 0 : heights[i];\\n        while (stackSize > 0 && currentHeight < heights[stack[stackSize - 1]]) {\\n            int poppedIndex = stack[--stackSize];\\n            int poppedHeight = heights[poppedIndex];\\n            int width = (stackSize == 0) ? i : i - stack[stackSize - 1] - 1;\\n\\n            maxArea = fmax(maxArea, calculateArea(poppedHeight, width));\\n        }"]]}
{"id": "1786", "ref_c": [["int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize){\\n    int *dp = calloc(sizeof(int),  matrixColSize[0]);\\n    int maxCols = 0, col = 0, area = 0, maxArea = 0, minHeight = INT_MAX;\\n    \\n    for(int i = 0; i < matrixSize; i++) {\\n        for(int j = 0; j < matrixColSize[0]; j++) {\\n            if(matrix[i][j] == \\'0\\') \\n                dp[j] = 0;\\n            else \\n                dp[j] += matrix[i][j] - \\'0\\';   \\n        }"], ["int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize){\\n    int *dp = calloc(sizeof(int),  matrixColSize[0]);\\n    int maxCols = 0, col = 0, area = 0, maxArea = 0, minHeight = INT_MAX;\\n    \\n    for(int i = 0; i < matrixSize; i++) {\\n        for(int j = 0; j < matrixColSize[0]; j++) {\\n            if(matrix[i][j] == \\'0\\') \\n                dp[j] = 0;\\n            else \\n                dp[j] += matrix[i][j] - \\'0\\';   \\n        }"], ["int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize){\\n    int *dp = calloc(sizeof(int),  matrixColSize[0]);\\n    int maxCols = 0, col = 0, area = 0, maxArea = 0, minHeight = INT_MAX;\\n    \\n    for(int i = 0; i < matrixSize; i++) {\\n        for(int j = 0; j < matrixColSize[0]; j++) {\\n            if(matrix[i][j] == \\'0\\') \\n                dp[j] = 0;\\n            else \\n                dp[j] += matrix[i][j] - \\'0\\';   \\n        }"]]}
{"id": "1787", "ref_c": ["\nbool isScramble(const char * const s1, const char * const s2){\n\tassert(s1 != NULL && s2 != NULL);\n\n\tconst int totalLen = strlen(s1);\n\tif ( totalLen != strlen(s2) ){\n\t\treturn false;\n\t}\n\tif (0 == totalLen){\n\t\treturn true;\n\t}\n\n\tbool dp[totalLen + 1][totalLen][totalLen];\t//dp[0] is unused.\n\tfor (int i = 0; i < totalLen; i += 1){\n\t\tfor (int j = 0; j < totalLen; j += 1){\n\t\t\tdp[1][i][j] = (s1[i] == s2[j]);\n\t\t}\n\t}\n\n\tfor (int partLen = 2; partLen <= totalLen; partLen += 1){\n\n\t\tconst int border = totalLen - (partLen - 1);\n\t\tfor (int i = 0; i < border; i += 1){\n\t\t\tfor (int j = 0; j < border; j += 1){\n\n\t\t\t\tbool matched = false;\n\t\t\t\tfor (int leftLen = 1; leftLen < partLen; leftLen += 1){\n\t\t\t\t\tconst int rightLen = partLen - leftLen;\n\t\t\t\t\tif (\n\t\t\t\t\t\t( dp[leftLen][i][j] && dp[rightLen][i + leftLen][j + leftLen] ) ||\n\t\t\t\t\t\t( dp[rightLen][i + leftLen][j] && dp[leftLen][i][j + rightLen] )\n\t\t\t\t\t){\n\t\t\t\t\t\tmatched = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[partLen][i][j] = matched;\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn dp[totalLen][0][0];\n}\n", "\nbool isScramble(const char * const s1, const char * const s2){\n\tassert(s1 != NULL && s2 != NULL);\n\n\tconst int totalLen = strlen(s1);\n\tif ( totalLen != strlen(s2) ){\n\t\treturn false;\n\t}\n\tif (0 == totalLen){\n\t\treturn true;\n\t}\n\n\tbool dp[totalLen + 1][totalLen][totalLen];\t//dp[0] is unused.\n\tfor (int i = 0; i < totalLen; i += 1){\n\t\tfor (int j = 0; j < totalLen; j += 1){\n\t\t\tdp[1][i][j] = (s1[i] == s2[j]);\n\t\t}\n\t}\n\n\tfor (int partLen = 2; partLen <= totalLen; partLen += 1){\n\n\t\tconst int border = totalLen - (partLen - 1);\n\t\tfor (int i = 0; i < border; i += 1){\n\t\t\tfor (int j = 0; j < border; j += 1){\n\n\t\t\t\tbool matched = false;\n\t\t\t\tfor (int leftLen = 1; leftLen < partLen; leftLen += 1){\n\t\t\t\t\tconst int rightLen = partLen - leftLen;\n\t\t\t\t\tif (\n\t\t\t\t\t\t( dp[leftLen][i][j] && dp[rightLen][i + leftLen][j + leftLen] ) ||\n\t\t\t\t\t\t( dp[rightLen][i + leftLen][j] && dp[leftLen][i][j + rightLen] )\n\t\t\t\t\t){\n\t\t\t\t\t\tmatched = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[partLen][i][j] = matched;\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn dp[totalLen][0][0];\n}\n", "\nbool isScramble(const char * const s1, const char * const s2){\n\tassert(s1 != NULL && s2 != NULL);\n\n\tconst int totalLen = strlen(s1);\n\tif ( totalLen != strlen(s2) ){\n\t\treturn false;\n\t}\n\tif (0 == totalLen){\n\t\treturn true;\n\t}\n\n\tbool dp[totalLen + 1][totalLen][totalLen];\t//dp[0] is unused.\n\tfor (int i = 0; i < totalLen; i += 1){\n\t\tfor (int j = 0; j < totalLen; j += 1){\n\t\t\tdp[1][i][j] = (s1[i] == s2[j]);\n\t\t}\n\t}\n\n\tfor (int partLen = 2; partLen <= totalLen; partLen += 1){\n\n\t\tconst int border = totalLen - (partLen - 1);\n\t\tfor (int i = 0; i < border; i += 1){\n\t\t\tfor (int j = 0; j < border; j += 1){\n\n\t\t\t\tbool matched = false;\n\t\t\t\tfor (int leftLen = 1; leftLen < partLen; leftLen += 1){\n\t\t\t\t\tconst int rightLen = partLen - leftLen;\n\t\t\t\t\tif (\n\t\t\t\t\t\t( dp[leftLen][i][j] && dp[rightLen][i + leftLen][j + leftLen] ) ||\n\t\t\t\t\t\t( dp[rightLen][i + leftLen][j] && dp[leftLen][i][j + rightLen] )\n\t\t\t\t\t){\n\t\t\t\t\t\tmatched = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[partLen][i][j] = matched;\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn dp[totalLen][0][0];\n}\n"]}
{"id": "1788", "ref_c": [["int numDistinct(char * s, char * t){\\n    int s_length = strlen(s), t_length = strlen(t);\\n    unsigned long long DP[s_length + 1][t_length + 1];\\n\\n    // base case when all the chars of t were matched with those of s.\\n    for (int i = 0; i < s_length + 1; i++) {\\n        DP[i][0] = 1;\\n    }"], ["int numDistinct(char * s, char * t){\\n    int s_length = strlen(s), t_length = strlen(t);\\n    unsigned long long DP[s_length + 1][t_length + 1];\\n\\n    // base case when all the chars of t were matched with those of s.\\n    for (int i = 0; i < s_length + 1; i++) {\\n        DP[i][0] = 1;\\n    }"], ["int numDistinct(char * s, char * t){\\n    int s_length = strlen(s), t_length = strlen(t);\\n    unsigned long long DP[s_length + 1][t_length + 1];\\n\\n    // base case when all the chars of t were matched with those of s.\\n    for (int i = 0; i < s_length + 1; i++) {\\n        DP[i][0] = 1;\\n    }"]]}
{"id": "1789", "ref_c": [["int maxProfit(int* prices, int pricesSize){\\n    int *s1 = (int *)malloc(sizeof(int) * pricesSize);\\n    int *s2 = (int *)malloc(sizeof(int) * pricesSize);\\n    \\n    memset(s1, 0, sizeof(int) * pricesSize);\\n    memset(s2, 0, sizeof(int) * pricesSize);\\n    \\n    int max = INT_MIN, min= prices[0];\\n\\n    for(int i=1; i<pricesSize-1; i++){\\n        if(min > prices[i]) min = prices[i]; \\n        \\n        if(max < (prices[i]- min)) max = prices[i] - min;\\n        s1[i] = max;\\n    }"], ["int maxProfit(int* prices, int pricesSize){\\n    int *s1 = (int *)malloc(sizeof(int) * pricesSize);\\n    int *s2 = (int *)malloc(sizeof(int) * pricesSize);\\n    \\n    memset(s1, 0, sizeof(int) * pricesSize);\\n    memset(s2, 0, sizeof(int) * pricesSize);\\n    \\n    int max = INT_MIN, min= prices[0];\\n\\n    for(int i=1; i<pricesSize-1; i++){\\n        if(min > prices[i]) min = prices[i]; \\n        \\n        if(max < (prices[i]- min)) max = prices[i] - min;\\n        s1[i] = max;\\n    }"], ["int maxProfit(int* prices, int pricesSize){\\n    int *s1 = (int *)malloc(sizeof(int) * pricesSize);\\n    int *s2 = (int *)malloc(sizeof(int) * pricesSize);\\n    \\n    memset(s1, 0, sizeof(int) * pricesSize);\\n    memset(s2, 0, sizeof(int) * pricesSize);\\n    \\n    int max = INT_MIN, min= prices[0];\\n\\n    for(int i=1; i<pricesSize-1; i++){\\n        if(min > prices[i]) min = prices[i]; \\n        \\n        if(max < (prices[i]- min)) max = prices[i] - min;\\n        s1[i] = max;\\n    }"]]}
{"id": "1790", "ref_c": [["int maxPathSum(struct TreeNode* root) {\\n    int maxSum= INT_MIN;\\n    maxSumHelper(root, &maxSum);\\n    return maxSum;\\n}"], ["int maxPathSum(struct TreeNode* root) {\\n    int maxSum= INT_MIN;\\n    maxSumHelper(root, &maxSum);\\n    return maxSum;\\n}"], ["int maxPathSum(struct TreeNode* root) {\\n    int globalMax = INT_MIN;\\n    maxPathSumUtil(root, &globalMax);\\n    return globalMax;\\n}"]]}
{"id": "1791", "ref_c": [["char *** findLadders(char * beginWord, char * endWord, char ** wordList, int wordListSize, int* returnSize, int** returnColumnSizes){\\n    //\\u521D\\u59CB\\n    int len = strlen(beginWord);\\n    char*** ans = malloc(sizeof(char**)*100);\\n    *returnSize = 0;\\n    int count = 2;\\n    \\n    int canGoCount = 0;\\n    int cnaGo[500];\\n    \\n    int fromCount[500] = {0}"], ["char *** findLadders(char * beginWord, char * endWord, char ** wordList, int wordListSize, int* returnSize, int** returnColumnSizes){\\n\\tchar*** ret = NULL;\\n\\t*returnSize = 0;\\n\\t*returnColumnSizes = NULL;\\n\\n\\t/* Check if the endWord exists in the wordList first */\\n\\tconst char** end = NULL;\\n\\tfor (size_t i = 0; !end && i < wordListSize; ++i) {\\n\\t\\tif (!strcmp(endWord, wordList[i])) {\\n\\t\\t\\tend = &wordList[i];\\n\\t\\t}"], ["char *** findLadders(char * beginWord, char * endWord, char ** wordList, int wordListSize, int* returnSize, int** returnColumnSizes){\\n    //\\u521D\\u59CB\\n    int len = strlen(beginWord);\\n    char*** ans = malloc(sizeof(char**)*100);\\n    *returnSize = 0;\\n    int count = 2;\\n    \\n    int canGoCount = 0;\\n    int cnaGo[500];\\n    \\n    int fromCount[500] = {0}"]]}
{"id": "1792", "ref_c": [["int ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize){\\n    Map *h = NULL, *e = NULL;\\n    /* put wordlist into hash */\\n    for(int i = 0; i < wordListSize; i++){\\n        e = (Map*)calloc(1, sizeof(Map));\\n        memcpy(e->key, wordList[i], strlen(wordList[i])*sizeof(char));\\n        e->idx = i + 1;\\n        HASH_ADD_STR(h, key, e);\\n    }"], ["int ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize){\\n    Map *h = NULL, *e = NULL;\\n    /* put wordlist into hash */\\n    for(int i = 0; i < wordListSize; i++){\\n        e = (Map*)calloc(1, sizeof(Map));\\n        memcpy(e->key, wordList[i], strlen(wordList[i])*sizeof(char));\\n        e->idx = i + 1;\\n        HASH_ADD_STR(h, key, e);\\n    }"], ["int ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize){\\n    bool endWordFound = false;\\n    for(int i = 0; i < wordListSize; i++) {\\n        if(strcmp(wordList[i], endWord) == 0) {\\n            endWordFound = true;\\n            break;\\n        }"]]}
{"id": "1793", "ref_c": [["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"]]}
{"id": "1794", "ref_c": [["int candy(int* ratings, int ratingsSize){\\n    int i, candies_count = ratingsSize;\\n    int* candies = calloc(ratingsSize, sizeof(int));\\n\\n    for(i = 1; i < ratingsSize; i++){\\n        if (ratings[i] > ratings[i - 1])\\n            candies[i] = candies[i - 1] + 1;\\n    }"], ["int candy(int* ratings, int ratingsSize){\\n    int i, candies_count = ratingsSize;\\n    int* candies = calloc(ratingsSize, sizeof(int));\\n\\n    for(i = 1; i < ratingsSize; i++){\\n        if (ratings[i] > ratings[i - 1])\\n            candies[i] = candies[i - 1] + 1;\\n    }"], ["int candy(int* ratings, int ratingsSize){\\n    int i, candies_count = ratingsSize;\\n    int* candies = calloc(ratingsSize, sizeof(int));\\n\\n    for(i = 1; i < ratingsSize; i++){\\n        if (ratings[i] > ratings[i - 1])\\n            candies[i] = candies[i - 1] + 1;\\n    }"]]}
{"id": "1795", "ref_c": [["char ** wordBreak(char * s, char ** wordDict, int wordDictSize, int* returnSize){\\n\\tint i, j, k, outlen;\\n\\tchar *w, **out;\\n\\tuint64_t brk[20+1];\\n\\tmemset(brk, 0, sizeof brk);\\n\\tfor(i = strlen(s) - 1, brk[i+1] = !0; i >= 0; i--){\\n\\t\\tfor(j = 0; j < wordDictSize; j++){\\n\\t\\t\\tfor(k = i, w = wordDict[j]; *w; w++, k++){\\n\\t\\t\\t\\tif(s[k] != *w) goto NEXT;\\n\\t\\t\\t}"], ["char ** wordBreak(char * s, char ** wordDict, int wordDictSize, int* returnSize){\\n    char **res = malloc(res_size * sizeof(char*));\\n    int *idxmap = malloc(res_size * sizeof(int));\\n    *returnSize = 0;\\n\\n    Backtrack(s, wordDict, wordDictSize, res, returnSize, idxmap, 0, 0);\\n    return res;\\n}"], ["char ** wordBreak(char * s, char ** wordDict, int wordDictSize, int* returnSize){\\n\\tint i, j, k, outlen;\\n\\tchar *w, **out;\\n\\tuint64_t brk[20+1];\\n\\tmemset(brk, 0, sizeof brk);\\n\\tfor(i = strlen(s) - 1, brk[i+1] = !0; i >= 0; i--){\\n\\t\\tfor(j = 0; j < wordDictSize; j++){\\n\\t\\t\\tfor(k = i, w = wordDict[j]; *w; w++, k++){\\n\\t\\t\\t\\tif(s[k] != *w) goto NEXT;\\n\\t\\t\\t}"]]}
{"id": "1796", "ref_c": [["int maxPoints(int** points, int pointsSize, int* pointsColSize){\\n\\n    if(pointsSize == 1) return 1;\\n    int retVal = 2;\\n    \\n    for(int i = 0; i < pointsSize; ++i)\\n    {\\n        for(int j = i+1; j < pointsSize; ++j)\\n        {\\n            int cnt = 2;\\n            for(int k = 0; k < pointsSize; ++k)\\n            {\\n                if(k != i && k != j && \\n                   (*(*(points+i) + 1) - *(*(points + j) + 1)) * (*(*(points + i)) - *(*(points + k))) \\n                   == (*(*(points+i) + 1) - *(*(points + k) + 1)) * (*(*(points + i)) - *(*(points + j))))\\n                {\\n                    cnt++;\\n                }"], ["int maxPoints(int** points, int pointsSize, int* pointsColSize)\\n{\\n    if(pointsSize==1)\\n    {\\n        return(1);\\n    }"], ["int maxPoints(int** points, int pointsSize, int* pointsColSize)\\n{\\n    if(pointsSize==1)\\n    {\\n        return(1);\\n    }"]]}
{"id": "1797", "ref_c": [["int findMin(int* nums, int numsSize) {\\n    int min,min1=INT_MAX;\\nfor(int i=0,j=numsSize-1;i<=numsSize/2;j--,i++){\\n    if(nums[i]<nums[j])\\n    min=nums[i];\\n    else\\n    min=nums[j];\\n    if(min<min1)\\n    min1=min;\\n}"], ["int findMin(int* nums, int numsSize) {\\n    int left = 0, right = numsSize - 1;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (nums[mid] > nums[right]) {\\n            // rotated section\\n            // nums[min] is not the min\\n            left = mid + 1;\\n        }"], ["int findMin(int* nums, int numsSize){\\n    int i, key, j;\\n    for (i = 1; i < numsSize; i++) {\\n        key = nums[i];\\n        j = i - 1;\\n\\n        while (j >= 0 && nums[j] > key) {\\n            nums[j + 1] = nums[j];\\n            j = j - 1;\\n        }"]]}
{"id": "1798", "ref_c": [["int maximumGap(int* nums, int numsSize){\\n    int max=0;\\n    int temp=-1;\\n    if(numsSize==1){\\n        return 0;\\n    }"], ["int maximumGap(int* nums, int numsSize){\\n    if(numsSize<2)\\n    {\\n        return 0;\\n    }"], ["int maximumGap(int* nums, int numsSize)\\n{\\n    if(numsSize < 2)\\n    {\\n        return 0;\\n    }"]]}
{"id": "1799", "ref_c": [["int findKthLargest(int* nums, int numsSize, int k){    \\n    int max = INT_MIN;\\n    int min = INT_MAX;\\n    int i;\\n    \\n    for(i=0;i<numsSize;i++){\\n        if(nums[i] > max)\\n            max = nums[i];\\n        if(nums[i] < min)\\n            min = nums[i];\\n    }"], ["int findKthLargest(int* nums, int numsSize, int k){\\n    int ans[100001]={0}"], ["int findKthLargest(int* nums, int numsSize, int k){    \\n    int max = INT_MIN;\\n    int min = INT_MAX;\\n    int i;\\n    \\n    for(i=0;i<numsSize;i++){\\n        if(nums[i] > max)\\n            max = nums[i];\\n        if(nums[i] < min)\\n            min = nums[i];\\n    }"]]}
{"id": "1801", "ref_c": [["int maxProfit(int k, int* prices, int pricesSize){\\n\\n    /*\\n     * Input:\\n     *  k,\\n     *  price, \\n     *  pricesSize,\\n     */\\n    for (int i = 0; i < 2; i++) {\\n        for (int j = 0; j < k; j++) {\\n            for (int tmp = 0; tmp < pricesSize; tmp++) {\\n                dp[i][j][tmp] = -1;\\n            }"], ["int maxProfit(int k, int* prices, int pricesSize){\\n\\n    /*\\n     * Input:\\n     *  k,\\n     *  price, \\n     *  pricesSize,\\n     */\\n    for (int i = 0; i < 2; i++) {\\n        for (int j = 0; j < k; j++) {\\n            for (int tmp = 0; tmp < pricesSize; tmp++) {\\n                dp[i][j][tmp] = -1;\\n            }"], ["int maxProfit(int k, int* prices, int pricesSize){\\n\\n    /*\\n     * Input:\\n     *  k,\\n     *  price, \\n     *  pricesSize,\\n     */\\n    for (int i = 0; i < 2; i++) {\\n        for (int j = 0; j < k; j++) {\\n            for (int tmp = 0; tmp < pricesSize; tmp++) {\\n                dp[i][j][tmp] = -1;\\n            }"]]}
{"id": "1802", "ref_c": ["\ntypedef struct node {\n    struct node *next;\n    char *s;\n} node_t;\n \ntypedef struct trie_node {\n    struct trie_node *next[26];\n    bool is_end;\n} trie_node_t;\n\nvoid initTrie(trie_node_t *head)\n{\n    memset((void *)head, 0, sizeof(trie_node_t));\n}\n\nvoid insertTrie(trie_node_t *head, char *s)\n{\n    char c;\n\n    while (*s) {\n    \n        c = *s - 'a';\n        \n        if (head->next[c] == NULL) {\n            head->next[c] = (trie_node_t *)calloc(1, sizeof(trie_node_t));\n        }\n        \n        head = head->next[c];\n        \n        if (*(s + 1) == 0) {\n            head->is_end = true;\n        }\n        \n        s++;\n    }\n}\n\nint searchTrie(trie_node_t *head, char *s)\n{\n    char c;\n    \n    /*\n     * Return -1 if s doesn't match any word\n     * Return 0 if s matches a word but that word is not available\n     * Return 1 if s matches a word and that word is available\n     */\n\n    while (*s) {\n    \n        c = *s - 'a';\n        \n        if (head->next[c] == NULL) {\n            return 0;\n        }\n        \n        head = head->next[c];\n\n        s++;\n    }\n\n    if (head->is_end == false) {\n        return 0;\n    }\n    \n    /* remove matching word from trie */\n    head->is_end = false;\n    \n    return 1;\n}\n\nvoid _releaseTrie(trie_node_t *head)\n{\n    if (head != NULL) {\n        for (int i = 0; i < 26; i++) {\n            _releaseTrie(head->next[i]);\n        }\n        \n        free(head);\n    }\n}\n\nvoid releaseTrie(trie_node_t *head)\n{\n    for (int i = 0; i < 26; i++) {\n        _releaseTrie(head->next[i]);\n    }\n}\n \nint find(char **board, int row, int col, trie_node_t *head, node_t **ans, int x, int y, char *buf, int len)\n{\n    int cnt = 0;\n    node_t *p_node;\n\n    if (x < 0 || x >= row || y < 0 || y >= col) {\n        return 0;\n    }\n    else if (len >= 10 || board[x][y] == 0) {\n        return 0;\n    }\n    \n    buf[len] = board[x][y];\n    buf[len + 1] = 0;\n    board[x][y] = 0;\n    \n    /* Check if current string matches a word */\n    if (searchTrie(head, buf)) {\n    \n        p_node = (node_t *)malloc(sizeof(node_t));\n        p_node->next = *ans;\n        p_node->s = (char *)malloc(sizeof(char) * (len + 2));\n        strcpy(p_node->s, buf);\n        *ans = p_node;\n        cnt++;\n    }\n    \n    /* Check if other combination matches a word */\n    cnt += find(board, row, col, head, ans, x + 1, y, buf, len + 1);\n    cnt += find(board, row, col, head, ans, x - 1, y, buf, len + 1);\n    cnt += find(board, row, col, head, ans, x, y + 1, buf, len + 1);\n    cnt += find(board, row, col, head, ans, x, y - 1, buf, len + 1);\n        \n    board[x][y] = buf[len];\n\n    return cnt;\n}\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** findWords(char** board, int boardSize, int* boardColSize, char ** words, int wordsSize, int* returnSize){\n    /*\n     * Input:\n     *  **board, 2D integer array\n     *  boardSize, row number of 2D array\n     *  boardColSize, column number of 2D array\n     *  words, string list\n     *  wordsSize, number of strings\n     */\n     \n    trie_node_t head;\n    char buf[11] = {0};\n    int row = boardSize, col = boardColSize[0];\n    node_t *list = NULL, *del;\n    char **ans = NULL;\n    \n    *returnSize = 0;\n     \n    initTrie(&head);\n    \n    for (int i = 0; i < wordsSize; i++) {\n        insertTrie(&head, words[i]);\n    }\n    \n    for (int x = 0; x < row; x++) {\n        for (int y = 0; y < col; y++) {\n            *returnSize += find(board, row, col, &head, &list, x, y, buf, 0);\n        }\n    }\n    \n    releaseTrie(&head);\n    \n    if (*returnSize) {\n        ans = (char **)malloc(sizeof(char **) * (*returnSize));\n        \n        for (int i = 0; i < *returnSize; i++) {\n            ans[i] = list->s;\n            del = list;\n            list = list->next;\n            free(del);\n        }\n    }\n     \n    /*\n     * Output:\n     *  *returnSize\n     *  return all words on the board.\n     *  The same letter cell may not be used more than once in a word.\n     */\n     \n    return ans;\n}\n", "\ntypedef struct node {\n    struct node *next;\n    char *s;\n} node_t;\n \ntypedef struct trie_node {\n    struct trie_node *next[26];\n    bool is_end;\n} trie_node_t;\n\nvoid initTrie(trie_node_t *head)\n{\n    memset((void *)head, 0, sizeof(trie_node_t));\n}\n\nvoid insertTrie(trie_node_t *head, char *s)\n{\n    char c;\n\n    while (*s) {\n    \n        c = *s - 'a';\n        \n        if (head->next[c] == NULL) {\n            head->next[c] = (trie_node_t *)calloc(1, sizeof(trie_node_t));\n        }\n        \n        head = head->next[c];\n        \n        if (*(s + 1) == 0) {\n            head->is_end = true;\n        }\n        \n        s++;\n    }\n}\n\nint searchTrie(trie_node_t *head, char *s)\n{\n    char c;\n    \n    /*\n     * Return -1 if s doesn't match any word\n     * Return 0 if s matches a word but that word is not available\n     * Return 1 if s matches a word and that word is available\n     */\n\n    while (*s) {\n    \n        c = *s - 'a';\n        \n        if (head->next[c] == NULL) {\n            return 0;\n        }\n        \n        head = head->next[c];\n\n        s++;\n    }\n\n    if (head->is_end == false) {\n        return 0;\n    }\n    \n    /* remove matching word from trie */\n    head->is_end = false;\n    \n    return 1;\n}\n\nvoid _releaseTrie(trie_node_t *head)\n{\n    if (head != NULL) {\n        for (int i = 0; i < 26; i++) {\n            _releaseTrie(head->next[i]);\n        }\n        \n        free(head);\n    }\n}\n\nvoid releaseTrie(trie_node_t *head)\n{\n    for (int i = 0; i < 26; i++) {\n        _releaseTrie(head->next[i]);\n    }\n}\n \nint find(char **board, int row, int col, trie_node_t *head, node_t **ans, int x, int y, char *buf, int len)\n{\n    int cnt = 0;\n    node_t *p_node;\n\n    if (x < 0 || x >= row || y < 0 || y >= col) {\n        return 0;\n    }\n    else if (len >= 10 || board[x][y] == 0) {\n        return 0;\n    }\n    \n    buf[len] = board[x][y];\n    buf[len + 1] = 0;\n    board[x][y] = 0;\n    \n    /* Check if current string matches a word */\n    if (searchTrie(head, buf)) {\n    \n        p_node = (node_t *)malloc(sizeof(node_t));\n        p_node->next = *ans;\n        p_node->s = (char *)malloc(sizeof(char) * (len + 2));\n        strcpy(p_node->s, buf);\n        *ans = p_node;\n        cnt++;\n    }\n    \n    /* Check if other combination matches a word */\n    cnt += find(board, row, col, head, ans, x + 1, y, buf, len + 1);\n    cnt += find(board, row, col, head, ans, x - 1, y, buf, len + 1);\n    cnt += find(board, row, col, head, ans, x, y + 1, buf, len + 1);\n    cnt += find(board, row, col, head, ans, x, y - 1, buf, len + 1);\n        \n    board[x][y] = buf[len];\n\n    return cnt;\n}\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** findWords(char** board, int boardSize, int* boardColSize, char ** words, int wordsSize, int* returnSize){\n    /*\n     * Input:\n     *  **board, 2D integer array\n     *  boardSize, row number of 2D array\n     *  boardColSize, column number of 2D array\n     *  words, string list\n     *  wordsSize, number of strings\n     */\n     \n    trie_node_t head;\n    char buf[11] = {0};\n    int row = boardSize, col = boardColSize[0];\n    node_t *list = NULL, *del;\n    char **ans = NULL;\n    \n    *returnSize = 0;\n     \n    initTrie(&head);\n    \n    for (int i = 0; i < wordsSize; i++) {\n        insertTrie(&head, words[i]);\n    }\n    \n    for (int x = 0; x < row; x++) {\n        for (int y = 0; y < col; y++) {\n            *returnSize += find(board, row, col, &head, &list, x, y, buf, 0);\n        }\n    }\n    \n    releaseTrie(&head);\n    \n    if (*returnSize) {\n        ans = (char **)malloc(sizeof(char **) * (*returnSize));\n        \n        for (int i = 0; i < *returnSize; i++) {\n            ans[i] = list->s;\n            del = list;\n            list = list->next;\n            free(del);\n        }\n    }\n     \n    /*\n     * Output:\n     *  *returnSize\n     *  return all words on the board.\n     *  The same letter cell may not be used more than once in a word.\n     */\n     \n    return ans;\n}\n", "\ntypedef struct node {\n    struct node *next;\n    char *s;\n} node_t;\n \ntypedef struct trie_node {\n    struct trie_node *next[26];\n    bool is_end;\n} trie_node_t;\n\nvoid initTrie(trie_node_t *head)\n{\n    memset((void *)head, 0, sizeof(trie_node_t));\n}\n\nvoid insertTrie(trie_node_t *head, char *s)\n{\n    char c;\n\n    while (*s) {\n    \n        c = *s - 'a';\n        \n        if (head->next[c] == NULL) {\n            head->next[c] = (trie_node_t *)calloc(1, sizeof(trie_node_t));\n        }\n        \n        head = head->next[c];\n        \n        if (*(s + 1) == 0) {\n            head->is_end = true;\n        }\n        \n        s++;\n    }\n}\n\nint searchTrie(trie_node_t *head, char *s)\n{\n    char c;\n    \n    /*\n     * Return -1 if s doesn't match any word\n     * Return 0 if s matches a word but that word is not available\n     * Return 1 if s matches a word and that word is available\n     */\n\n    while (*s) {\n    \n        c = *s - 'a';\n        \n        if (head->next[c] == NULL) {\n            return 0;\n        }\n        \n        head = head->next[c];\n\n        s++;\n    }\n\n    if (head->is_end == false) {\n        return 0;\n    }\n    \n    /* remove matching word from trie */\n    head->is_end = false;\n    \n    return 1;\n}\n\nvoid _releaseTrie(trie_node_t *head)\n{\n    if (head != NULL) {\n        for (int i = 0; i < 26; i++) {\n            _releaseTrie(head->next[i]);\n        }\n        \n        free(head);\n    }\n}\n\nvoid releaseTrie(trie_node_t *head)\n{\n    for (int i = 0; i < 26; i++) {\n        _releaseTrie(head->next[i]);\n    }\n}\n \nint find(char **board, int row, int col, trie_node_t *head, node_t **ans, int x, int y, char *buf, int len)\n{\n    int cnt = 0;\n    node_t *p_node;\n\n    if (x < 0 || x >= row || y < 0 || y >= col) {\n        return 0;\n    }\n    else if (len >= 10 || board[x][y] == 0) {\n        return 0;\n    }\n    \n    buf[len] = board[x][y];\n    buf[len + 1] = 0;\n    board[x][y] = 0;\n    \n    /* Check if current string matches a word */\n    if (searchTrie(head, buf)) {\n    \n        p_node = (node_t *)malloc(sizeof(node_t));\n        p_node->next = *ans;\n        p_node->s = (char *)malloc(sizeof(char) * (len + 2));\n        strcpy(p_node->s, buf);\n        *ans = p_node;\n        cnt++;\n    }\n    \n    /* Check if other combination matches a word */\n    cnt += find(board, row, col, head, ans, x + 1, y, buf, len + 1);\n    cnt += find(board, row, col, head, ans, x - 1, y, buf, len + 1);\n    cnt += find(board, row, col, head, ans, x, y + 1, buf, len + 1);\n    cnt += find(board, row, col, head, ans, x, y - 1, buf, len + 1);\n        \n    board[x][y] = buf[len];\n\n    return cnt;\n}\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** findWords(char** board, int boardSize, int* boardColSize, char ** words, int wordsSize, int* returnSize){\n    /*\n     * Input:\n     *  **board, 2D integer array\n     *  boardSize, row number of 2D array\n     *  boardColSize, column number of 2D array\n     *  words, string list\n     *  wordsSize, number of strings\n     */\n     \n    trie_node_t head;\n    char buf[11] = {0};\n    int row = boardSize, col = boardColSize[0];\n    node_t *list = NULL, *del;\n    char **ans = NULL;\n    \n    *returnSize = 0;\n     \n    initTrie(&head);\n    \n    for (int i = 0; i < wordsSize; i++) {\n        insertTrie(&head, words[i]);\n    }\n    \n    for (int x = 0; x < row; x++) {\n        for (int y = 0; y < col; y++) {\n            *returnSize += find(board, row, col, &head, &list, x, y, buf, 0);\n        }\n    }\n    \n    releaseTrie(&head);\n    \n    if (*returnSize) {\n        ans = (char **)malloc(sizeof(char **) * (*returnSize));\n        \n        for (int i = 0; i < *returnSize; i++) {\n            ans[i] = list->s;\n            del = list;\n            list = list->next;\n            free(del);\n        }\n    }\n     \n    /*\n     * Output:\n     *  *returnSize\n     *  return all words on the board.\n     *  The same letter cell may not be used more than once in a word.\n     */\n     \n    return ans;\n}\n"]}
{"id": "1803", "ref_c": [["char * shortestPalindrome(char * s){\\n    int length = strlen(s), point, i, j, flag;\\n    char *output = (char *)malloc(2 * length);\\n    if (length == 0)\\n    {\\n        output[0] = \\'\\\\0\\';\\n        return output;\\n    }"], ["char * shortestPalindrome(char * s){\\n    int length = strlen(s), point, i, j, flag;\\n    char *output = (char *)malloc(2 * length);\\n    if (length == 0)\\n    {\\n        output[0] = \\'\\\\0\\';\\n        return output;\\n    }"], ["char * shortestPalindrome(char * s){\\n    int length = strlen(s), point, i, j, flag;\\n    char *output = (char *)malloc(2 * length);\\n    if (length == 0)\\n    {\\n        output[0] = \\'\\\\0\\';\\n        return output;\\n    }"]]}
{"id": "1804", "ref_c": [["int** getSkyline(int** buildings, int buildingsSize, int* buildingsColSize, int* returnSize, int** returnColumnSizes){\\n    const int maxRetSize = 2*buildingsSize;\\n    int **ret = malloc(maxRetSize * sizeof(int*));\\n    int numRet = 0;\\n    int curX = 0;\\n\\n    Heap h = { 0, NULL }"], ["int** getSkyline(int** buildings, int buildingsSize, int* buildingsColSize, int* returnSize, int** returnColumnSizes){\\n    int** ans = malloc(sizeof(int*)*(3000));\\n    *returnSize = 0;\\n    int** right = malloc(sizeof(int*)*buildingsSize);\\n    for (int i = 0 ; i < buildingsSize ; i++){\\n        right[i] = malloc(sizeof(int)*3);\\n        right[i][0] = buildings[i][1];\\n        right[i][1] = buildings[i][2];\\n        right[i][2] = i;\\n    }"], ["int** getSkyline(int** buildings, int buildingsSize, int* buildingsColSize, int* returnSize, int** returnColumnSizes){\\n    const int maxRetSize = 2*buildingsSize;\\n    int **ret = malloc(maxRetSize * sizeof(int*));\\n    int numRet = 0;\\n    int curX = 0;\\n\\n    Heap h = { 0, NULL }"]]}
{"id": "1805", "ref_c": [["bool containsNearbyAlmostDuplicate(int* nums, int numsSize, int indexDiff, int valueDiff){\\n    bool returnVal = false;\\n    numIndxType *arr = malloc(numsSize*sizeof(numIndxType));\\n    // 1. Fill array\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].num = nums[i];\\n        arr[i].indx = i;\\n    }"], ["bool containsNearbyAlmostDuplicate(int* nums, int numsSize, int indexDiff, int valueDiff){\\n    bool returnVal = false;\\n    numIndxType *arr = malloc(numsSize*sizeof(numIndxType));\\n    // 1. Fill array\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].num = nums[i];\\n        arr[i].indx = i;\\n    }"], ["bool containsNearbyAlmostDuplicate(int* nums, int numsSize, int indexDiff, int valueDiff){\\n    bool returnVal = false;\\n    numIndxType *arr = malloc(numsSize*sizeof(numIndxType));\\n    // 1. Fill array\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].num = nums[i];\\n        arr[i].indx = i;\\n    }"]]}
{"id": "1806", "ref_c": ["\n//to add or to minus to the result\nvoid addin(int* result, bool isadd, const int num){\n    if(isadd){\n        *result += num;\n    }\n    else{\n        *result -= num;\n    }\n}\n\nint calc_recursive(char** s_ptr){\n    int result = 0; \n    int num = 0;    //individual number\n    bool isadd = true;  //true for the first number add into result\n    while(**s_ptr != '\u0000' && **s_ptr != ')'){\n        if(**s_ptr >= '0' && **s_ptr <= '9'){   //until the whole number is read\n            num *= 10;\n            num += **s_ptr - '0';\n            (*s_ptr)++;\n            continue;\n        }\n        switch(**s_ptr){\n            case '(':   //to solve the formula inside ()\n                (*s_ptr)++;\n                addin(&result, isadd, calc_recursive(s_ptr));\n                break;\n            case '+':\n            case '-':\n                addin(&result, isadd, num); //to add/minus the infront number to the result \n                num = 0;\n                isadd = (**s_ptr == '+');   //set the symbol for the later number\n                break;\n        }\n        (*s_ptr)++;\n    }\n    // for the ')' or the last number\n    addin(&result, isadd, num);\n    return result;\n}\n\nint calculate(char* s){\n    return calc_recursive(&s);\n}\n", "\n//to add or to minus to the result\nvoid addin(int* result, bool isadd, const int num){\n    if(isadd){\n        *result += num;\n    }\n    else{\n        *result -= num;\n    }\n}\n\nint calc_recursive(char** s_ptr){\n    int result = 0; \n    int num = 0;    //individual number\n    bool isadd = true;  //true for the first number add into result\n    while(**s_ptr != '\u0000' && **s_ptr != ')'){\n        if(**s_ptr >= '0' && **s_ptr <= '9'){   //until the whole number is read\n            num *= 10;\n            num += **s_ptr - '0';\n            (*s_ptr)++;\n            continue;\n        }\n        switch(**s_ptr){\n            case '(':   //to solve the formula inside ()\n                (*s_ptr)++;\n                addin(&result, isadd, calc_recursive(s_ptr));\n                break;\n            case '+':\n            case '-':\n                addin(&result, isadd, num); //to add/minus the infront number to the result \n                num = 0;\n                isadd = (**s_ptr == '+');   //set the symbol for the later number\n                break;\n        }\n        (*s_ptr)++;\n    }\n    // for the ')' or the last number\n    addin(&result, isadd, num);\n    return result;\n}\n\nint calculate(char* s){\n    return calc_recursive(&s);\n}\n", "\n//to add or to minus to the result\nvoid addin(int* result, bool isadd, const int num){\n    if(isadd){\n        *result += num;\n    }\n    else{\n        *result -= num;\n    }\n}\n\nint calc_recursive(char** s_ptr){\n    int result = 0; \n    int num = 0;    //individual number\n    bool isadd = true;  //true for the first number add into result\n    while(**s_ptr != '\u0000' && **s_ptr != ')'){\n        if(**s_ptr >= '0' && **s_ptr <= '9'){   //until the whole number is read\n            num *= 10;\n            num += **s_ptr - '0';\n            (*s_ptr)++;\n            continue;\n        }\n        switch(**s_ptr){\n            case '(':   //to solve the formula inside ()\n                (*s_ptr)++;\n                addin(&result, isadd, calc_recursive(s_ptr));\n                break;\n            case '+':\n            case '-':\n                addin(&result, isadd, num); //to add/minus the infront number to the result \n                num = 0;\n                isadd = (**s_ptr == '+');   //set the symbol for the later number\n                break;\n        }\n        (*s_ptr)++;\n    }\n    // for the ')' or the last number\n    addin(&result, isadd, num);\n    return result;\n}\n\nint calculate(char* s){\n    return calc_recursive(&s);\n}\n"]}
{"id": "1807", "ref_c": [["int countDigitOne(int n){\\n    unsigned int summ=0,temp=1,gain=0,yet=0;\\n    char a;\\n    while (n!=0) {\\n        a=n%10;\\n        n/=10;\\n        \\n        if (a!=0) {\\n            if (a==1) {\\n                summ+=yet+1;\\n            }"], ["int countDigitOne(int n) {\\n    int count = 0;\\n    long long int factor = 1;\\n\\n    while (n / factor > 0) {\\n        int currentDigit = (n / factor) % 10;\\n        int higherDigits = n / (factor * 10);\\n        int lowerDigits = n % factor;\\n\\n        if (currentDigit == 0) {\\n            count += higherDigits * factor;\\n        }"], ["int countDigitOne(int n){\\n    int count=0;\\n    if(n==0){\\n        return 0;\\n    }", "int countDigitOne(int n){\\n    int temp = n, count = 0, rest = 0, coefficient = 0;\\n    long int step = 1;\\n    \\n    for (int i = 0; temp > 0; i++) {\\n        int digit = temp % 10;\\n        coefficient = step / 10 * i;\\n        if (digit > 1) {\\n            count += digit * coefficient + step;\\n        }"]]}
{"id": "1808", "ref_c": [["int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\\n    if (numsSize == 0 || k == 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\\n    if (numsSize == 0 || k == 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\\n    if (numsSize == 0 || k == 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }"]]}
{"id": "1810", "ref_c": [["char * numberToWords(int num){\\n\\n    char *ans = malloc(200);\\n    int temp_var = 0;\\n    bool First_Word = true;\\n    ans[0] = 0;\\n\\n    if(num == 0)\\n    {\\n        To_String(num,ans,&First_Word);\\n        return ans;\\n    }"], ["char * numberToWords(int num){\\n\\n    char *ans = malloc(200);\\n    int temp_var = 0;\\n    bool First_Word = true;\\n    ans[0] = 0;\\n\\n    if(num == 0)\\n    {\\n        To_String(num,ans,&First_Word);\\n        return ans;\\n    }"], ["char * numberToWords(int num){\\n\\n    char *ans = malloc(200);\\n    int temp_var = 0;\\n    bool First_Word = true;\\n    ans[0] = 0;\\n\\n    if(num == 0)\\n    {\\n        To_String(num,ans,&First_Word);\\n        return ans;\\n    }"]]}
{"id": "1811", "ref_c": [["int threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0}"], ["int threeSumMulti(int* arr, int arrSize, int target){\\n    long sum = 0;\\n    long a, b, c;\\n    \\n    for(int i = 0;i <= target;i++)\\n    {\\n        for(int j = i;j <= target;j++)\\n        {\\n            for(int k = j;k <= target;k++)\\n            {\\n                if (i + j + k == target)\\n                {\\n                    a = countInArr(arr, arrSize, i);\\n                    b = countInArr(arr, arrSize, j);\\n                    c = countInArr(arr, arrSize, k);\\n\\n                    if (a != 0 && b != 0 && c != 0)\\n                    {\\n                        if (i != j && i != k && j != k)\\n                            sum += a * b * c;\\n                        else if (i == j && j == k)\\n                            sum += (a * (a - 1) * (a - 2)) / 6;\\n\\n                        else if (i == j)\\n                            sum += ((a * (a - 1)) / 2) * c;\\n \\n                        else if (i == k)\\n                            sum += ((a * (a - 1)) / 2) * b;\\n\\n                        else if (j == k)\\n                            sum += ((b * (b - 1)) / 2) * a;\\n\\n                        sum = sum % 1000000007;\\n                    }"], ["int threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0}"]]}
{"id": "1814", "ref_c": [["int longestMountain(int* arr, int arrSize){\\n    int max_len=0;\\n    for(int i=0;i<arrSize;i++){\\n        if(i+max_len>arrSize) break;\\n        bool up=true,down=false;\\n        int len=1;\\n\\n        for(int j=i+1;j<arrSize;j++){\\n            if(up && arr[j]>arr[j-1]) len++;\\n            else if(down && arr[j]<arr[j-1]) len++;\\n            else{\\n                break;\\n            }"], ["int longestMountain(int* arr, int arrSize){\\n    int max_len=0;\\n    for(int i=0;i<arrSize;i++){\\n        if(i+max_len>arrSize) break;\\n        bool up=true,down=false;\\n        int len=1;\\n\\n        for(int j=i+1;j<arrSize;j++){\\n            if(up && arr[j]>arr[j-1]) len++;\\n            else if(down && arr[j]<arr[j-1]) len++;\\n            else{\\n                break;\\n            }"], ["int longestMountain(int* arr, int arrSize){\\n    int max_len=0;\\n    for(int i=0;i<arrSize;i++){\\n        if(i+max_len>arrSize) break;\\n        bool up=true,down=false;\\n        int len=1;\\n\\n        for(int j=i+1;j<arrSize;j++){\\n            if(up && arr[j]>arr[j-1]) len++;\\n            else if(down && arr[j]<arr[j-1]) len++;\\n            else{\\n                break;\\n            }"]]}
{"id": "1815", "ref_c": [["int findPeakElement(int* nums, int numsSize){\\n    return getPeak(nums,0,numsSize - 1,0,numsSize - 1);\\n}"], ["int findPeakElement(int* nums, int numsSize){\\n    return getPeak(nums,0,numsSize - 1,0,numsSize - 1);\\n}"], ["int findPeakElement(int* nums, int numsSize){\\n    return getPeak(nums,0,numsSize - 1,0,numsSize - 1);\\n}"]]}
{"id": "1816", "ref_c": [["int* countSmaller(int* nums, int numsSize, int* returnSize){\\n    int maximun=nums[0];\\n    int minimun=nums[0];\\n    *returnSize=numsSize;\\n    for(int i=0;i<numsSize;i++){\\n        maximun=fmax(nums[i],maximun);\\n        minimun=fmin(nums[i],minimun);\\n    }"], ["int* countSmaller(int* nums, int numsSize, int* returnSize) {\\n                                                                                                                                                                                                        *returnSize = numsSize;\\n                                                                                                                                                                                                            int* counts = (int*)calloc(numsSize, sizeof(int));\\n                                                                                                                                                                                                                int* indices = (int*)malloc(numsSize * sizeof(int));\\n\\n                                                                                                                                                                                                                    for (int i = 0; i < numsSize; ++i) {\\n                                                                                                                                                                                                                            indices[i] = i;\\n                                                                                                                                                                                                                                }"], ["int* countSmaller(int* nums, int numsSize, int* returnSize){\\n    int maximun=nums[0];\\n    int minimun=nums[0];\\n    *returnSize=numsSize;\\n    for(int i=0;i<numsSize;i++){\\n        maximun=fmax(nums[i],maximun);\\n        minimun=fmin(nums[i],minimun);\\n    }"]]}
{"id": "1817", "ref_c": [["char * alphabetBoardPath(char * target){\\n    char *a = malloc(512), *p = a, m[128][2] = { { 0 }"], ["char * alphabetBoardPath(char * target){\\n    char *a = malloc(512), *p = a, m[128][2] = { { 0 }"], ["char * alphabetBoardPath(char * target){\\n    char *a = malloc(512), *p = a, m[128][2] = { { 0 }"]]}
{"id": "1818", "ref_c": [["int wateringPlants(int* plants, int plantsSize, int capacity){\\n    int step=0;\\n    int i;\\n    int water=capacity;\\n    int goback=0;\\n    for(i=0;i<plantsSize;i++) {\\n        while(water<*(plants+i)) {\\n            water=capacity;\\n            step=step+i;\\n            goback=goback+i;\\n            \\n        }"], ["int wateringPlants(int* plants, int plantsSize, int capacity){\\n    int step=0;\\n    int i;\\n    int water=capacity;\\n    int goback=0;\\n    for(i=0;i<plantsSize;i++) {\\n        while(water<*(plants+i)) {\\n            water=capacity;\\n            step=step+i;\\n            goback=goback+i;\\n            \\n        }"], ["int wateringPlants(int* plants, int plantsSize, int capacity){\\n    int step=0;\\n    int i;\\n    int water=capacity;\\n    int goback=0;\\n    for(i=0;i<plantsSize;i++) {\\n        while(water<*(plants+i)) {\\n            water=capacity;\\n            step=step+i;\\n            goback=goback+i;\\n            \\n        }"]]}
{"id": "1819", "ref_c": [["int longestIncreasingPath(int** matrix, int matrixSize, int* matrixColSize){\\n    int **seen=malloc(sizeof(int*)*matrixSize);\\n    for(int i=0;i<matrixSize;i++){\\n        seen[i]=calloc(*matrixColSize,sizeof(int));\\n    }"], ["int longestIncreasingPath(int** matrix, int matrixSize, int* matrixColSize){\\n    int **seen=malloc(sizeof(int*)*matrixSize);\\n    for(int i=0;i<matrixSize;i++){\\n        seen[i]=calloc(*matrixColSize,sizeof(int));\\n    }"], ["int longestIncreasingPath(int** matrix, int matrixSize, int* matrixColSize){\\n    int curLongest = 0;\\n\\n    // create a table same size as matrix\\n    // every time we find the longest path from a given start point (i, j)\\n    // memo[i][j] will be updated to contain it.\\n    // this will allow us to avoid solving duplicate problems in the future.\\n\\n    // ie: instead of doing 1 + 2 + 3, we do 1 + 5 since we already know 2 + 3.\\n    int** memo = (int**)malloc(matrixSize * sizeof(int*));\\n    for (int i = 0; i < matrixSize; i++)\\n        memo[i] = (int*)malloc(matrixColSize[0] * sizeof(int));    \\n\\n    // initialize memo to conttain -1\\'s\\n    // could have been set to zero. \\n    for (int i = 0; i < matrixSize; i++)\\n        for (int j = 0; j < matrixColSize[0]; j++)\\n            memo[i][j] = -1;\\n\\n    // fill memo.\\n    // update longest\\n    for (int i = 0; i < matrixSize; i++){\\n        for (int j = 0; j < matrixColSize[0]; j++){\\n            memo[i][j] = longestPathHere(matrix, matrixSize, matrixColSize[0], memo, i, j);\\n            if (memo[i][j] > curLongest) curLongest = memo[i][j];\\n        }"]]}
{"id": "1820", "ref_c": [["int minPatches(int* nums, int numsSize, int n) {\\n    long miss = 1; // the smallest sum that we might be missing, initialized to 1\\n    int i = 0;     // index of current element in the array\\n    int patches = 0;  // number of patches used\\n    \\n    // While the missing sum is within the target range\\n    while (miss <= n) {\\n        if (i < numsSize && nums[i] <= miss) {\\n            // If current array element is less than or equal to missing sum, we can use it to extend the covered range\\n            miss += nums[i++];\\n        }"], ["int minPatches(int* nums, int numsSize, int n) {\\n    long miss = 1; // the smallest sum that we might be missing, initialized to 1\\n    int i = 0;     // index of current element in the array\\n    int patches = 0;  // number of patches used\\n    \\n    // While the missing sum is within the target range\\n    while (miss <= n) {\\n        if (i < numsSize && nums[i] <= miss) {\\n            // If current array element is less than or equal to missing sum, we can use it to extend the covered range\\n            miss += nums[i++];\\n        }"], ["int minPatches(int* nums, int numsSize, int n) {\\n    long miss = 1; // the smallest sum that we might be missing, initialized to 1\\n    int i = 0;     // index of current element in the array\\n    int patches = 0;  // number of patches used\\n    \\n    // While the missing sum is within the target range\\n    while (miss <= n) {\\n        if (i < numsSize && nums[i] <= miss) {\\n            // If current array element is less than or equal to missing sum, we can use it to extend the covered range\\n            miss += nums[i++];\\n        }"]]}
{"id": "1821", "ref_c": [["char ** findItinerary(char *** tickets, int ticketsSize, int* ticketsColSize, int* returnSize){\\n\\n    /*\\n     * Algorithm:\\n     *  (1) Using a hash table for storing \"src->dst\" info.\\n     *      E.g.\\n     *          [[\"JFK\",\"KUL\"],[\"JFK\",\"KUL\"],[\"NRT\",\"JFK\"]]\\n     *          JFK->KUL\\n     *          JFK->NRT\\n     *          NRT->JFK \\n     *\\n     *  (2) Find all the valid itinerary (store in ascending lexical order)\\n     *          JFK->NRT->JFK->KUL   (Used all the tickets)\\n     *          JFK->KUL             (Invalid)\\n     *  (3) Return the answer\\n     */\\n     \\n    /*\\n     * Input:\\n     *  ***tickets, \\n     *  ticketsSize, int\\n     *  *ticketsColSize\\n     */\\n    node_t *trie = NULL;\\n    itinerary_t *itry[100];\\n    char **ans, buf[5000];\\n    int itry_cnt = 0;\\n\\n    *returnSize = 0;\\n    \\n    trie_init(&trie);\\n    \\n    for (int i = 0; i < ticketsSize; i++) {\\n        trie_insert(trie, tickets[i][0], tickets[i][1]);\\n    }"], ["char ** findItinerary(char *** tickets, int ticketsSize, int* ticketsColSize, int* returnSize){\\n\\n    /*\\n     * Algorithm:\\n     *  (1) Using a hash table for storing \"src->dst\" info.\\n     *      E.g.\\n     *          [[\"JFK\",\"KUL\"],[\"JFK\",\"KUL\"],[\"NRT\",\"JFK\"]]\\n     *          JFK->KUL\\n     *          JFK->NRT\\n     *          NRT->JFK \\n     *\\n     *  (2) Find all the valid itinerary (store in ascending lexical order)\\n     *          JFK->NRT->JFK->KUL   (Used all the tickets)\\n     *          JFK->KUL             (Invalid)\\n     *  (3) Return the answer\\n     */\\n     \\n    /*\\n     * Input:\\n     *  ***tickets, \\n     *  ticketsSize, int\\n     *  *ticketsColSize\\n     */\\n    node_t *trie = NULL;\\n    itinerary_t *itry[100];\\n    char **ans, buf[5000];\\n    int itry_cnt = 0;\\n\\n    *returnSize = 0;\\n    \\n    trie_init(&trie);\\n    \\n    for (int i = 0; i < ticketsSize; i++) {\\n        trie_insert(trie, tickets[i][0], tickets[i][1]);\\n    }"], ["char ** findItinerary(char *** tickets, int ticketsSize, int* ticketsColSize, int* returnSize){\\n\\n    /*\\n     * Algorithm:\\n     *  (1) Using a hash table for storing \"src->dst\" info.\\n     *      E.g.\\n     *          [[\"JFK\",\"KUL\"],[\"JFK\",\"KUL\"],[\"NRT\",\"JFK\"]]\\n     *          JFK->KUL\\n     *          JFK->NRT\\n     *          NRT->JFK \\n     *\\n     *  (2) Find all the valid itinerary (store in ascending lexical order)\\n     *          JFK->NRT->JFK->KUL   (Used all the tickets)\\n     *          JFK->KUL             (Invalid)\\n     *  (3) Return the answer\\n     */\\n     \\n    /*\\n     * Input:\\n     *  ***tickets, \\n     *  ticketsSize, int\\n     *  *ticketsColSize\\n     */\\n    node_t *trie = NULL;\\n    itinerary_t *itry[100];\\n    char **ans, buf[5000];\\n    int itry_cnt = 0;\\n\\n    *returnSize = 0;\\n    \\n    trie_init(&trie);\\n    \\n    for (int i = 0; i < ticketsSize; i++) {\\n        trie_insert(trie, tickets[i][0], tickets[i][1]);\\n    }"]]}
{"id": "1822", "ref_c": [["bool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}", "bool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}"], ["bool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}", "bool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}"], ["bool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}", "bool isSelfCrossing(int* distance, int distanceSize){\\n    if (distanceSize<4) {return false;}"]]}
{"id": "1823", "ref_c": [["int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\t*returnColumnSizes = NULL;\\n\\n\\tstruct word_hash* table = NULL;\\n\\tstruct word_hash* entries = malloc(wordsSize * sizeof(struct word_hash));\\n\\n\\t/* Put all words into a hashtable */\\n\\tint empty_idx = -1;\\n\\tsize_t max_len = 0;\\n\\tfor (int i = 0; i < wordsSize; ++i) {\\n\\t\\tsize_t len = strlen(words[i]);\\n\\t\\tif (!len) {\\n\\t\\t\\tempty_idx = i;\\n\\t\\t\\tcontinue;\\n\\t\\t}", "int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\t/* Allocate word_tries in a large buffer to reduce the number of malloc calls */\\n\\tstruct buffer_list {\\n\\t\\tstruct word_trie buf[128];\\n\\t\\tstruct buffer_list* next;\\n\\t}"], ["int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\t*returnColumnSizes = NULL;\\n\\n\\tstruct word_hash* table = NULL;\\n\\tstruct word_hash* entries = malloc(wordsSize * sizeof(struct word_hash));\\n\\n\\t/* Put all words into a hashtable */\\n\\tint empty_idx = -1;\\n\\tsize_t max_len = 0;\\n\\tfor (int i = 0; i < wordsSize; ++i) {\\n\\t\\tsize_t len = strlen(words[i]);\\n\\t\\tif (!len) {\\n\\t\\t\\tempty_idx = i;\\n\\t\\t\\tcontinue;\\n\\t\\t}", "int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\t/* Allocate word_tries in a large buffer to reduce the number of malloc calls */\\n\\tstruct buffer_list {\\n\\t\\tstruct word_trie buf[128];\\n\\t\\tstruct buffer_list* next;\\n\\t}"], ["int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\t*returnColumnSizes = NULL;\\n\\n\\tstruct word_hash* table = NULL;\\n\\tstruct word_hash* entries = malloc(wordsSize * sizeof(struct word_hash));\\n\\n\\t/* Put all words into a hashtable */\\n\\tint empty_idx = -1;\\n\\tsize_t max_len = 0;\\n\\tfor (int i = 0; i < wordsSize; ++i) {\\n\\t\\tsize_t len = strlen(words[i]);\\n\\t\\tif (!len) {\\n\\t\\t\\tempty_idx = i;\\n\\t\\t\\tcontinue;\\n\\t\\t}", "int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\t/* Allocate word_tries in a large buffer to reduce the number of malloc calls */\\n\\tstruct buffer_list {\\n\\t\\tstruct word_trie buf[128];\\n\\t\\tstruct buffer_list* next;\\n\\t}"]]}
{"id": "1825", "ref_c": [["int maxEnvelopes(int** envelopes, int envelopesSize, int* envelopesColSize){\\n    qsort(envelopes, envelopesSize, sizeof(int **), cmp);\\n    int dp[envelopesSize], idx = 1;\\n    dp[0] = envelopes[0][1];\\n    for(int i = 1; i < envelopesSize; i++)\\n        if(envelopes[i][1] > dp[idx - 1])\\n        {\\n            dp[idx++] = envelopes[i][1];\\n        }"], ["int maxEnvelopes(int** envelopes, int envelopesSize, int* envelopesColSize){\\n    qsort(envelopes, envelopesSize, sizeof(int **), cmp);\\n    int dp[envelopesSize], idx = 1;\\n    dp[0] = envelopes[0][1];\\n    for(int i = 1; i < envelopesSize; i++)\\n        if(envelopes[i][1] > dp[idx - 1])\\n        {\\n            dp[idx++] = envelopes[i][1];\\n        }"], ["int maxEnvelopes(int** envelopes, int envelopesSize, int* envelopesColSize){\\n    qsort(envelopes, envelopesSize, sizeof(int **), cmp);\\n    int dp[envelopesSize], idx = 1;\\n    dp[0] = envelopes[0][1];\\n    for(int i = 1; i < envelopesSize; i++)\\n        if(envelopes[i][1] > dp[idx - 1])\\n        {\\n            dp[idx++] = envelopes[i][1];\\n        }"]]}
{"id": "1826", "ref_c": [["int maxSumSubmatrix(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    int curMax = INT_MIN;\\n    int ncol = matrixColSize[0];\\n    int nrow = matrixSize;\\n    int *rowsums = malloc(nrow * sizeof(int));\\n    int *cumsums = malloc((nrow+1) * sizeof(int));\\n    int cursum, target;\\n    bool found;\\n    \\n    for (int leftcol=0; leftcol<ncol; leftcol++){\\n        memset(rowsums, 0, nrow*sizeof(*rowsums));\\n        \\n        for (int rightcol=leftcol; rightcol<ncol; rightcol++){\\n            memset(cumsums, 0, (nrow+1)*sizeof(*cumsums));\\n            cursum = 0;\\n            \\n            for (int iter=0; iter<nrow; iter++){\\n                rowsums[iter] += matrix[iter][rightcol];\\n                \\n                cursum += rowsums[iter];\\n                found = false;\\n                target = INT_MAX;\\n                for ( int fi=0; fi<=(iter+1); fi++){\\n                    if (cumsums[fi] < target && cumsums[fi] >= cursum-k){\\n                        target = cumsums[fi];\\n                        found = true;\\n                    }"], ["int maxSumSubmatrix(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    int*** xlist = malloc(sizeof(int**)*matrixSize);\\n    int ans = INT_MIN;\\n    for (int i = 0 ; i < matrixSize ; i++){\\n        xlist[i] = malloc(sizeof(int*)*(*matrixColSize));\\n        for (int j = 0 ; j < (*matrixColSize) ; j++){\\n            xlist[i][j] = malloc(sizeof(int)*(*matrixColSize - j));\\n            xlist[i][j][0] = matrix[i][j];\\n            if (xlist[i][j][0] == k){\\n                freexlist(xlist, i, j, -1, *matrixColSize);\\n                return k;\\n            }"], ["int maxSumSubmatrix(int** matrix, int matrixSize, int* matrixColSize, int k){\\n    int*** xlist = malloc(sizeof(int**)*matrixSize);\\n    int ans = INT_MIN;\\n    for (int i = 0 ; i < matrixSize ; i++){\\n        xlist[i] = malloc(sizeof(int*)*(*matrixColSize));\\n        for (int j = 0 ; j < (*matrixColSize) ; j++){\\n            xlist[i][j] = malloc(sizeof(int)*(*matrixColSize - j));\\n            xlist[i][j][0] = matrix[i][j];\\n            if (xlist[i][j][0] == k){\\n                freexlist(xlist, i, j, -1, *matrixColSize);\\n                return k;\\n            }"]]}
{"id": "1828", "ref_c": [["bool isRectangleCover(int** rectangles, int rectanglesSize, int* rectanglesColSize){\\n    qsort(rectangles, rectanglesSize, sizeof(int*), comp);\\n    int m = rectangles[0][0];\\n    int n = rectangles[0][1];\\n    int p = 0;\\n    int k;\\n    for (int i = 0 ; i < rectanglesSize ; i++){\\n        rectangles[i][0] -= m;\\n        rectangles[i][2] -= m;\\n        rectangles[i][1] -= n;\\n        rectangles[i][3] -= n;\\n        if (p < rectangles[i][2]){\\n            p = rectangles[i][2];\\n            k = rectangles[i][3];\\n        }"], ["bool isRectangleCover(int** rectangles, int rectanglesSize, int* rectanglesColSize){\\n    qsort(rectangles, rectanglesSize, sizeof(int*), comp);\\n    int m = rectangles[0][0];\\n    int n = rectangles[0][1];\\n    int p = 0;\\n    int k;\\n    for (int i = 0 ; i < rectanglesSize ; i++){\\n        rectangles[i][0] -= m;\\n        rectangles[i][2] -= m;\\n        rectangles[i][1] -= n;\\n        rectangles[i][3] -= n;\\n        if (p < rectangles[i][2]){\\n            p = rectangles[i][2];\\n            k = rectangles[i][3];\\n        }"], ["bool isRectangleCover(int** rectangles, int rectanglesSize, int* rectanglesColSize){\\n    qsort(rectangles, rectanglesSize, sizeof(int*), comp);\\n    int m = rectangles[0][0];\\n    int n = rectangles[0][1];\\n    int p = 0;\\n    int k;\\n    for (int i = 0 ; i < rectanglesSize ; i++){\\n        rectangles[i][0] -= m;\\n        rectangles[i][2] -= m;\\n        rectangles[i][1] -= n;\\n        rectangles[i][3] -= n;\\n        if (p < rectangles[i][2]){\\n            p = rectangles[i][2];\\n            k = rectangles[i][3];\\n        }"]]}
{"id": "1829", "ref_c": [["bool canCross(int* stones, int stonesSize) {\\n    // DP method (Jump to)\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n    \\n    const int n = stonesSize;\\n    // dp[i][j] := true if a frog can make a size j jump to stones[i]\\n    bool** dp = (bool**)calloc(n, sizeof(bool*));\\n    for (int i = 0; i < n; i++) {\\n        dp[i] = (bool*)calloc(n + 1, sizeof(bool));\\n    }", "bool canCross(int* stones, int stonesSize) {\\n    // DP method (Jump to)\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n    \\n    const int n = stonesSize;\\n    // dp[i][j] := true if a frog can make a size j jump to stones[i]\\n    bool** dp = (bool**)calloc(n, sizeof(bool*));\\n    for (int i = 0; i < n; i++) {\\n        dp[i] = (bool*)calloc(n + 1, sizeof(bool));\\n    }"], ["bool canCross(int* stones, int stonesSize) {\\n    // DP method (Jump to)\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n    \\n    const int n = stonesSize;\\n    // dp[i][j] := true if a frog can make a size j jump to stones[i]\\n    bool** dp = (bool**)calloc(n, sizeof(bool*));\\n    for (int i = 0; i < n; i++) {\\n        dp[i] = (bool*)calloc(n + 1, sizeof(bool));\\n    }", "bool canCross(int* stones, int stonesSize) {\\n    // DP method (Jump to)\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n    \\n    const int n = stonesSize;\\n    // dp[i][j] := true if a frog can make a size j jump to stones[i]\\n    bool** dp = (bool**)calloc(n, sizeof(bool*));\\n    for (int i = 0; i < n; i++) {\\n        dp[i] = (bool*)calloc(n + 1, sizeof(bool));\\n    }"], ["bool canCross(int* stones, int stonesSize) {\\n    // DP method (Jump to)\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n    \\n    const int n = stonesSize;\\n    // dp[i][j] := true if a frog can make a size j jump to stones[i]\\n    bool** dp = (bool**)calloc(n, sizeof(bool*));\\n    for (int i = 0; i < n; i++) {\\n        dp[i] = (bool*)calloc(n + 1, sizeof(bool));\\n    }", "bool canCross(int* stones, int stonesSize) {\\n    // DP method (Jump to)\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n    \\n    const int n = stonesSize;\\n    // dp[i][j] := true if a frog can make a size j jump to stones[i]\\n    bool** dp = (bool**)calloc(n, sizeof(bool*));\\n    for (int i = 0; i < n; i++) {\\n        dp[i] = (bool*)calloc(n + 1, sizeof(bool));\\n    }"]]}
{"id": "1830", "ref_c": [["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"]]}
{"id": "1831", "ref_c": [["int splitArray(int* nums, int numsSize, int k){\\n    int left = 0, right = 0, mid, sum, count;\\n    for (int i = 0; i < numsSize; i++) {\\n        left = left > nums[i] ? left : nums[i]; // left = max(nums)\\n        right += nums[i]; // right = sum(nums)\\n    }"], ["int splitArray(int* nums, int numsSize, int k){\\n    int left = 0, right = 0, mid, sum, count;\\n    for (int i = 0; i < numsSize; i++) {\\n        left = left > nums[i] ? left : nums[i]; // left = max(nums)\\n        right += nums[i]; // right = sum(nums)\\n    }"], ["int splitArray(int* nums, int numsSize, int k){\\n    int left = 0, right = 0, mid, sum, count;\\n    for (int i = 0; i < numsSize; i++) {\\n        left = left > nums[i] ? left : nums[i]; // left = max(nums)\\n        right += nums[i]; // right = sum(nums)\\n    }"]]}
{"id": "1832", "ref_c": [["int strongPasswordChecker(char * password){\\n\\nconst int min_symbols = 6;\\nconst int max_symbols = 20;\\n\\nint state = 0;\\nint i = 0;\\n\\nchar repet_char = 0;\\n\\nint repetition = 0, insert_one_dif = 3; //max different symbol inserts\\nint insert_one_suppl = 0, replace_one = 0, delete_one = 0;\\n\\nint low_content = 0, hi_content = 0;\\nint is_there_az = 0, is_there_AZ = 0, is_there_09 = 0;\\n\\ncntxA_t cntxA11 = {0}"], ["int strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int replace = 0;\\n    int one = 0;\\n    int two = 0;\\n    int cap = 1;\\n    int low = 1;\\n    int dig = 1;\\n    \\n    for(int i = 0; password[i]; i++){\\n        if(letters[password[i]] == 1){\\n            cap = 0;\\n        }"], ["int strongPasswordChecker(char * password){\\n\\nconst int min_symbols = 6;\\nconst int max_symbols = 20;\\n\\nint state = 0;\\nint i = 0;\\n\\nchar repet_char = 0;\\n\\nint repetition = 0, insert_one_dif = 3; //max different symbol inserts\\nint insert_one_suppl = 0, replace_one = 0, delete_one = 0;\\n\\nint low_content = 0, hi_content = 0;\\nint is_there_az = 0, is_there_AZ = 0, is_there_09 = 0;\\n\\ncntxA_t cntxA11 = {0}"]]}
{"id": "1834", "ref_c": [["int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        return (abs((ax2 - ax1)*(ay2 - ay1)) + abs((bx2 - bx1)*(by2 - by1)) - ((bx2 <= ax1 || ax2 <= bx1) ? 0 : min(bx2, ax2) - max(bx1, ax1)) * ((by2 <= ay1 || ay2 <= by1) ? 0 : min(by2, ay2) - max(by1, ay1)));\\n    }"], ["int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2)\\n{\\n   int a = abs(ax2 - ax1) * abs(ay2 - ay1);\\n   int b = abs(bx2 - bx1) * abs(by2 - by1);\\n   int cx1 = max(ax1,bx1);\\n   int cx2 = min(ax2,bx2);\\n   int cy1 = max(ay1,by1);\\n   int cy2 = min(ay2,by2);\\n   int cl = max(0 , cx2 - cx1);\\n   int cb = max(0 , cy2 - cy1);\\n   int c = cl * cb ;\\n   return a + b - c;\\n}"], ["int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2){\\n    \\n    int len_A, height_A, len_B, height_B, S_A, S_B;\\n\\n    len_A = ax2 - ax1;\\n    height_A = ay2 - ay1;\\n    len_B = bx2 - bx1;\\n    height_B = by2 - by1;\\n    \\n    S_A = len_A * height_A;\\n    S_B = len_B * height_B;\\n\\n    int minx1 = (ax1 < bx1) ? ax1 : bx1;\\n    int minx2 = (ax2 < bx2) ? ax2 : bx2;\\n    int minx = (minx1 < minx2) ? minx1 : minx2;\\n\\n    int maxx1 = (ax1 > bx1) ? ax1 : bx1;\\n    int maxx2 = (ax2 > bx2) ? ax2 : bx2;\\n    int maxx = (maxx1 > maxx2) ? maxx1 : maxx2;\\n\\n    int miny1 = (ay1 < by1) ? ay1 : by1;\\n    int miny2 = (ay2 < by2) ? ay2 : by2;\\n    int miny = (miny1 < miny2) ? miny1 : miny2;\\n\\n    int maxy1 = (ay2 > by2) ? ay2 : by2;\\n    int maxy2 = (ay1 > by1) ? ay1 : by1;\\n    int maxy = (maxy1 > maxy2) ? maxy1 : maxy2;\\n\\n    int len_x = maxx - minx;\\n    int len_y = maxy - miny;\\n\\n    int same_len = len_x - (len_A + len_B);\\n    int same_height = len_y - (height_A + height_B);\\n\\n    if(same_len > 0 || same_height > 0){\\n        return S_A + S_B;\\n    }"]]}
{"id": "1835", "ref_c": [["int numberOfArithmeticSlices(int* nums, int numsSize){\\n    int ans = 0;\\n    int cnt = 0;\\n    int idx[numsSize*numsSize];\\n    int cnt2 = 0;\\n    int dp[numsSize][min(numsSize*numsSize,(int)10000000/numsSize)];\\n    memset(dp, 0, sizeof(dp));\\n    memset(idx, -1, sizeof(idx));\\n    dict = NULL;\\n    for(int i = 0; i < numsSize; ++i) {\\n        for(int j  = 0; j < i; ++j) {\\n            long long dif = (long long)nums[j] - (long long)nums[i];          \\n            struct hashTable* it = find(dif);\\n            if(it == NULL) {\\n                insert(dif, cnt, i);                \\n                ++cnt;\\n            }"], ["int numberOfArithmeticSlices(int* nums, int numsSize){\\n    int ans = 0;\\n    int cnt = 0;\\n    int idx[numsSize*numsSize];\\n    int cnt2 = 0;\\n    int dp[numsSize][min(numsSize*numsSize,(int)10000000/numsSize)];\\n    memset(dp, 0, sizeof(dp));\\n    memset(idx, -1, sizeof(idx));\\n    dict = NULL;\\n    for(int i = 0; i < numsSize; ++i) {\\n        for(int j  = 0; j < i; ++j) {\\n            long long dif = (long long)nums[j] - (long long)nums[i];          \\n            struct hashTable* it = find(dif);\\n            if(it == NULL) {\\n                insert(dif, cnt, i);                \\n                ++cnt;\\n            }"], ["int numberOfArithmeticSlices(int* nums, int numsSize){\\n  int ret = 0;\\n  struct sequence_hash** const dp = calloc(numsSize, sizeof(struct sequence_hash*));\\n  for (int end = 1; end < numsSize; ++end) {\\n    for (int i = 0; i < end; ++i) {\\n      const long long int diff = ((long long int) nums[end]) - nums[i];\\n      struct sequence_hash* end_entry;\\n      HASH_FIND(hh, dp[end], &diff, sizeof(diff), end_entry);\\n      if (!end_entry) { /* First time this diff has been seen at this index */\\n        end_entry = malloc(sizeof(struct sequence_hash));\\n        end_entry->diff = diff;\\n        end_entry->count = 0;\\n        HASH_ADD(hh, dp[end], diff, sizeof(end_entry->diff), end_entry);\\n      }"]]}
{"id": "1836", "ref_c": [["int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        int max_time = minutesToTest / minutesToDie + 1;\\n        // Initialize the required minimum number of pigs...\\n        int req_pigs = 0;\\n        // To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n        while (Math.pow(max_time, req_pigs) < buckets)\\n            // Increment until it will be greater or equals to bucket...\\n            ++req_pigs;\\n        // Return the required minimum number of pigs...\\n        return req_pigs;\\n    }", "int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        int max_time = minutesToTest / minutesToDie + 1;\\n        // To find the minimum number of pigs, return ceil(log(buckets) / log(max_time))...\\n        return ceil(log(buckets) / log(max_time));\\n    }", "int poorPigs(int buckets, int minutesToDie, int minutesToTest){\\n    // Base condition...\\n    if (buckets --== 1){\\n            return 0;\\n    }"], ["int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        int max_time = minutesToTest / minutesToDie + 1;\\n        // Initialize the required minimum number of pigs...\\n        int req_pigs = 0;\\n        // To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...\\n        while (Math.pow(max_time, req_pigs) < buckets)\\n            // Increment until it will be greater or equals to bucket...\\n            ++req_pigs;\\n        // Return the required minimum number of pigs...\\n        return req_pigs;\\n    }", "int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\\n        // Calculate the max time for a pig to test buckets...\\n        // Note that, max time will not be (minutesToTest / minutesToDie)...\\n        // Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...\\n        int max_time = minutesToTest / minutesToDie + 1;\\n        // To find the minimum number of pigs, return ceil(log(buckets) / log(max_time))...\\n        return ceil(log(buckets) / log(max_time));\\n    }", "int poorPigs(int buckets, int minutesToDie, int minutesToTest){\\n    // Base condition...\\n    if (buckets --== 1){\\n            return 0;\\n    }"], ["int poorPigs(int buckets, int minutesToDie, int minutesToTest){\\n    int pigs = 0;\\n    while (pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\\n        pigs += 1;\\n    }"]]}
{"id": "1838", "ref_c": [["int getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, e = -1, f = 0;\\n    char s1r, s2r = s2[b];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { c++; a = 0; continue; }"], ["int getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, e = -1, f = 0;\\n    char s1r, s2r = s2[b];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { c++; a = 0; continue; }"], ["int getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, f = -1;\\n    int e[102], g[102], h[102]; for(int n = 0; n < 102; e[n++] = -1);\\n    char s1r, s2r = s2[0];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { h[c++] = d; a = 0;  if(!(f < 0)) goto earlycalc; continue; }"]]}
{"id": "1839", "ref_c": [["char ** findAllConcatenatedWordsInADict(char ** words, int wordsSize, int* returnSize){\\n\\n    char **ans = (int**)calloc(wordsSize, sizeof(char*));\\n    struct Trie *root = createNode(false);\\n\\n    for(int i = 0; i < wordsSize; i++)\\n        ans[i] = (char*)calloc(30, sizeof(char));\\n\\n    *returnSize = 0;\\n\\n    qsort(words, wordsSize, sizeof(words[0]), cmp);\\n\\n    for(int i = 0; i < wordsSize; i++)\\n        if(dfs(words[i], root, true) == true)\\n            strcpy(ans[(*returnSize)++], words[i]);\\n\\n    return ans;\\n}"], ["char ** findAllConcatenatedWordsInADict(char ** words, int wordsSize, int* returnSize){\\n    // You need at least 2 words to have one being a concatenated\\n    if(wordsSize < 2){\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["char ** findAllConcatenatedWordsInADict(char ** words, int wordsSize, int* returnSize){\\n\\n    char **ans = (int**)calloc(wordsSize, sizeof(char*));\\n    struct Trie *root = createNode(false);\\n\\n    for(int i = 0; i < wordsSize; i++)\\n        ans[i] = (char*)calloc(30, sizeof(char));\\n\\n    *returnSize = 0;\\n\\n    qsort(words, wordsSize, sizeof(words[0]), cmp);\\n\\n    for(int i = 0; i < wordsSize; i++)\\n        if(dfs(words[i], root, true) == true)\\n            strcpy(ans[(*returnSize)++], words[i]);\\n\\n    return ans;\\n}"]]}
{"id": "1840", "ref_c": [["int largestPalindrome(int n) {\\n    int result[8] = {9, 987, 123, 597, 677, 1218, 877, 475}"], ["int largestPalindrome(int n) {\\n    int result[8] = {9, 987, 123, 597, 677, 1218, 877, 475}"], ["int largestPalindrome(int n) {\\n    int result[8] = {9, 987, 123, 597, 677, 1218, 877, 475}"]]}
{"id": "1841", "ref_c": [["int longestOnes(int* nums, int numsSize, int k) {\\n  int max = 0;\\n  int z = 0;\\n  int i = 0, j = 0, c = 0;  \\n  while (j < numsSize) {\\n    if (nums[j] == 0) \\n        ++z;\\n    else\\n        c = 1;\\n    while (z > k && i < j) {\\n      if (nums[i] == 0) \\n        --z;\\n      else\\n        c = 1;\\n      ++i;\\n    }"], ["int longestOnes(int* nums, int numsSize, int k) {\\n  int max = 0;\\n  int z = 0;\\n  int i = 0, j = 0, c = 0;  \\n  while (j < numsSize) {\\n    if (nums[j] == 0) \\n        ++z;\\n    else\\n        c = 1;\\n    while (z > k && i < j) {\\n      if (nums[i] == 0) \\n        --z;\\n      else\\n        c = 1;\\n      ++i;\\n    }"], ["int longestOnes(int* nums, int numsSize, int k) {\\n  int max = 0;\\n  int z = 0;\\n  int i = 0, j = 0, c = 0;  \\n  while (j < numsSize) {\\n    if (nums[j] == 0) \\n        ++z;\\n    else\\n        c = 1;\\n    while (z > k && i < j) {\\n      if (nums[i] == 0) \\n        --z;\\n      else\\n        c = 1;\\n      ++i;\\n    }"]]}
{"id": "1842", "ref_c": [["int numDecodings(char * s) {\\n  int dp[2] = {1, 0}"], ["int numDecodings(char * s) {\\n  int dp[2] = {1, 0}"], ["int numDecodings(char * s) {\\n  int dp[2] = {1, 0}"]]}
{"id": "1843", "ref_c": [["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0;\\n    for (int i = 0; i != numsSize; i++)\\n    {\\n        for (int j = 0; j != numsSize; j++)\\n        {\\n            if (i != j && (nums[i] - nums[j]) == k)\\n            {\\n                count++;\\n            }"], ["int countKDifference(int* nums, int numsSize, int k) {\\n    int count = 0; \\n\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = i+1; j < numsSize; j++){\\n            if(abs(nums[i] - nums[j]) == k){\\n                count += 1; \\n            }"], ["int countKDifference(int* nums, int numsSize, int k){\\n    int count = 0;\\n    for(int i = 0; i < numsSize; i++)\\n        for(int j = i; j  < numsSize; j++)\\n            if(nums[i] - nums[j] == k || nums[j]  - nums[i] == k)\\n                count++;\\n\\n    \\n    return count;\\n}"]]}
{"id": "1844", "ref_c": [["int reversePairs(int* nums, int numsSize){\\n    int cnt = 0;\\n    tmp_l = malloc(sizeof(int)*numsSize);\\n    tmp_r = malloc(sizeof(int)*numsSize);\\n    nsz = numsSize;\\n    merge_sort(nums, 0, numsSize-1, &cnt);    \\n\\n    return cnt;\\n}"], ["int reversePairs(int* nums, int numsSize){\\n    int cnt = 0;\\n    tmp_l = malloc(sizeof(int)*numsSize);\\n    tmp_r = malloc(sizeof(int)*numsSize);\\n    nsz = numsSize;\\n    merge_sort(nums, 0, numsSize-1, &cnt);    \\n\\n    return cnt;\\n}"], ["int reversePairs(int* nums, int numsSize){\\n    int cnt = 0;\\n    tmp_l = malloc(sizeof(int)*numsSize);\\n    tmp_r = malloc(sizeof(int)*numsSize);\\n    nsz = numsSize;\\n    merge_sort(nums, 0, numsSize-1, &cnt);    \\n\\n    return cnt;\\n}"]]}
{"id": "1845", "ref_c": [["int findMaximizedCapital(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize){\\n    int i = 0, j = 0;\\n    int table[100001] = {0}"], ["int findMaximizedCapital(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize){\\n  // quick sort value of capital, profits \\u7684\\u8981\\u8DDF\\u8457\\u52D5\\n  quickSort(capital, profits, 0, profitsSize - 1);\\n  int lastNodeIndex = 0;\\n  int benefits = w; // current money\\n  int canDoTill = -1;\\n  while (canDoTill + 1 < capitalSize && capital[canDoTill + 1] <= benefits)\\n  {\\n    canDoTill += 1;\\n  }"], ["int findMaximizedCapital(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize){\\n  // quick sort value of capital, profits \\u7684\\u8981\\u8DDF\\u8457\\u52D5\\n  quickSort(capital, profits, 0, profitsSize - 1);\\n  int lastNodeIndex = 0;\\n  int benefits = w; // current money\\n  int canDoTill = -1;\\n  while (canDoTill + 1 < capitalSize && capital[canDoTill + 1] <= benefits)\\n  {\\n    canDoTill += 1;\\n  }"]]}
{"id": "1846", "ref_c": [["int sumBase(int n, int k) {\\n    int sum=0;\\n    while(n!=0){\\n        sum=sum+n%k;\\n        n/=k;\\n       \\n    }"], ["int sumBase(int n, int k){\\nint sum=0;\\nwhile(n!=0)\\n{\\n    sum+=(n%k);\\n    n/=k;\\n}"], ["int sumBase(int n, int k) {\\n        int ans = 0;\\n        while(n!=0){\\n            ans += n%k;\\n            n = n / k;\\n        }"]]}
{"id": "1847", "ref_c": ["\nint evalRPN(char **tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 + temp1;\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 - temp1;\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 * temp1;\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            \n            stack[top] = temp2 / temp1;\n        } else {\n            top++;\n            stack[top] = atoi(tokens[i]);\n        }\n    }\n\n    return stack[top];\n}\n", "\nint evalRPN(char **tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 + temp1;\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 - temp1;\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 * temp1;\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            \n            stack[top] = temp2 / temp1;\n        } else {\n            top++;\n            stack[top] = atoi(tokens[i]);\n        }\n    }\n\n    return stack[top];\n}\n", "\nint evalRPN(char **tokens, int tokensSize) {\n    int stack[tokensSize];\n    int top = -1;\n\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 + temp1;\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 - temp1;\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            stack[top] = temp2 * temp1;\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int temp1 = stack[top];\n            top--;\n            int temp2 = stack[top];\n            \n            stack[top] = temp2 / temp1;\n        } else {\n            top++;\n            stack[top] = atoi(tokens[i]);\n        }\n    }\n\n    return stack[top];\n}\n"]}
{"id": "1848", "ref_c": [["int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        return (abs((ax2 - ax1)*(ay2 - ay1)) + abs((bx2 - bx1)*(by2 - by1)) - ((bx2 <= ax1 || ax2 <= bx1) ? 0 : min(bx2, ax2) - max(bx1, ax1)) * ((by2 <= ay1 || ay2 <= by1) ? 0 : min(by2, ay2) - max(by1, ay1)));\\n    }"], ["int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2)\\n{\\n   int a = abs(ax2 - ax1) * abs(ay2 - ay1);\\n   int b = abs(bx2 - bx1) * abs(by2 - by1);\\n   int cx1 = max(ax1,bx1);\\n   int cx2 = min(ax2,bx2);\\n   int cy1 = max(ay1,by1);\\n   int cy2 = min(ay2,by2);\\n   int cl = max(0 , cx2 - cx1);\\n   int cb = max(0 , cy2 - cy1);\\n   int c = cl * cb ;\\n   return a + b - c;\\n}"], ["int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2){\\n    \\n    int len_A, height_A, len_B, height_B, S_A, S_B;\\n\\n    len_A = ax2 - ax1;\\n    height_A = ay2 - ay1;\\n    len_B = bx2 - bx1;\\n    height_B = by2 - by1;\\n    \\n    S_A = len_A * height_A;\\n    S_B = len_B * height_B;\\n\\n    int minx1 = (ax1 < bx1) ? ax1 : bx1;\\n    int minx2 = (ax2 < bx2) ? ax2 : bx2;\\n    int minx = (minx1 < minx2) ? minx1 : minx2;\\n\\n    int maxx1 = (ax1 > bx1) ? ax1 : bx1;\\n    int maxx2 = (ax2 > bx2) ? ax2 : bx2;\\n    int maxx = (maxx1 > maxx2) ? maxx1 : maxx2;\\n\\n    int miny1 = (ay1 < by1) ? ay1 : by1;\\n    int miny2 = (ay2 < by2) ? ay2 : by2;\\n    int miny = (miny1 < miny2) ? miny1 : miny2;\\n\\n    int maxy1 = (ay2 > by2) ? ay2 : by2;\\n    int maxy2 = (ay1 > by1) ? ay1 : by1;\\n    int maxy = (maxy1 > maxy2) ? maxy1 : maxy2;\\n\\n    int len_x = maxx - minx;\\n    int len_y = maxy - miny;\\n\\n    int same_len = len_x - (len_A + len_B);\\n    int same_height = len_y - (height_A + height_B);\\n\\n    if(same_len > 0 || same_height > 0){\\n        return S_A + S_B;\\n    }"]]}
{"id": "1849", "ref_c": [["int checkRecord(int n) {\\n        memset(t,-1,sizeof(t));\\n        return solve(n,1,2);\\n    }"], ["int checkRecord(int n) {\\n        memset(t,-1,sizeof(t));\\n        return solve(n,1,2);\\n    }"], ["int checkRecord(int n) {\\n        memset(t,-1,sizeof(t));\\n        return solve(n,1,2);\\n    }"]]}
{"id": "1850", "ref_c": [["char * nearestPalindromic(char * n){\\n    int len = strlen(n);\\n    if(len == 1)\\n    {\\n        n[0] = (((n[0]-\\'0\\')-1)+\\'0\\');\\n        return n;\\n    }"], ["char * nearestPalindromic(char * n)\\n{   \\n  \\n    if (strlen(n) == 1)   /* This is another special case if the input is smaller than 10.*/\\n    {\\n        int res = atoi(n) - 1;\\n        char *p = malloc(2);\\n        p[0] = res + \\'0\\';\\n        p[1] = \\'\\\\0\\';\\n        return p;\\n    }"], ["char * nearestPalindromic(char * n)\\n{   \\n  \\n    if (strlen(n) == 1)   /* This is another special case if the input is smaller than 10.*/\\n    {\\n        int res = atoi(n) - 1;\\n        char *p = malloc(2);\\n        p[0] = res + \\'0\\';\\n        p[1] = \\'\\\\0\\';\\n        return p;\\n    }"]]}
{"id": "1851", "ref_c": [["int** outerTrees(int** trees, int treesSize, int* treesColSize, int* returnSize, int** returnColumnSizes){\\n    if (treesSize<3){\\n        *returnSize = treesSize;\\n        goto exitJump;//add returnColumnSizes and return\\n    }"], ["int** outerTrees(int** trees, int treesSize, int* treesColSize, int* returnSize, int** returnColumnSizes){\\n    if (treesSize<3){\\n        *returnSize = treesSize;\\n        goto exitJump;//add returnColumnSizes and return\\n    }"], ["int** outerTrees(int** trees, int treesSize, int* treesColSize, int* returnSize, int** returnColumnSizes){\\n    if (treesSize<3){\\n        *returnSize = treesSize;\\n        goto exitJump;//add returnColumnSizes and return\\n    }"]]}
{"id": "1852", "ref_c": [["int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\\n\\n    /*\\n     * Input:\\n     *  *arr\\n     *  arrSize\\n     *  **mat\\n     *  matSize\\n     *  *matColSize\\n     */\\n\\n    int **lookup = (int **)malloc(sizeof(int *) * (matSize * matColSize[0] + 1));\\n    int *row = (int *)calloc(1, sizeof(int) * matSize);\\n    int *col = (int *)calloc(1, sizeof(int) * matColSize[0]);\\n    int ans = 0;\\n\\n    for (int i = 0; i < (matSize * matColSize[0] + 1); i++) {\\n        lookup[i] = (int *)malloc(sizeof(int) * 2);\\n    }"], ["int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\\n\\n    /*\\n     * Input:\\n     *  *arr\\n     *  arrSize\\n     *  **mat\\n     *  matSize\\n     *  *matColSize\\n     */\\n\\n    int **lookup = (int **)malloc(sizeof(int *) * (matSize * matColSize[0] + 1));\\n    int *row = (int *)calloc(1, sizeof(int) * matSize);\\n    int *col = (int *)calloc(1, sizeof(int) * matColSize[0]);\\n    int ans = 0;\\n\\n    for (int i = 0; i < (matSize * matColSize[0] + 1); i++) {\\n        lookup[i] = (int *)malloc(sizeof(int) * 2);\\n    }"], ["int firstCompleteIndex(int* arr, int arrSize, int** mat, int matSize, int* matColSize){\\n    int m = matSize, n = *matColSize;\\n    Pair pair[m * n + 1];\\n    int i, j, t, filledRow[m], filledCol[n];\\n    memset(filledRow, 0, sizeof(filledRow));\\n    memset(filledCol, 0, sizeof(filledCol));\\n    memset(pair, 0, sizeof(pair));\\n    for (i = 0; i < m; ++i) {\\n        for (j = 0; j < n; ++j) {\\n            t = mat[i][j];\\n            pair[t].row = i;\\n            pair[t].col = j; \\n        }"]]}
{"id": "1853", "ref_c": [["int findIntegers(int n) {\\n    int dp[31] = {0}"], ["int findIntegers(int n) {\\n    int dp[31] = {0}"], ["int findIntegers(int n) {\\n    int dp[31] = {0}"]]}
{"id": "1855", "ref_c": [["int kInversePairs(int n, int k){\\n    if(k == 0){\\n        return 1;\\n    }"], ["int kInversePairs(int n, int k) {\\n    int mod = 1e9 + 7;\\n    int dp[n + 1][k + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++) {\\n        dp[i][0] = 1;\\n        for (int j = 1; j <= k; j++) {\\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;\\n            if (j >= i) {\\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\\n            }"], ["int kInversePairs(int n, int k){\\n    if(!k)return 1;\\n    unsigned sum[2][1001]={0}"]]}
{"id": "1856", "ref_c": [["int scheduleCourse(int** courses, int coursesSize, int* coursesColSize){\\n    qsort(courses, coursesSize, sizeof(int **), cmp);\\n    int time = 0, count = 0;\\n    for(int i = 0; i < coursesSize; i++)\\n        if(time + courses[i][0] <= courses[i][1])\\n        {\\n            time += courses[i][0];\\n            courses[count++] = courses[i];\\n        }"], ["int scheduleCourse(int** courses, int coursesSize, int* coursesColSize){\\n\\n    /*\\n     *  Input:\\n     *      courses, the duration and deadline of coureses,\\n     *      courses, number of courses\\n     *      coursesColSize, column size of course info\\n     */\\n\\n    int sum = 0;\\n    int day = 0;\\n    int tmp;\\n    C_INFO c_info[10000];\\n    \\n    /*\\n     *  Algorithm:\\n     *      Always take the course with longer deadlines and shorter durations\\n     *\\n     *      (1) Sort the courses by end day in ascending order\\n     *      (2) Set sum and total days to 0, Scan the course 1 ~ N\\n     *          Take the course, push course duration to max heap, accmulate the days\\n     *          if days is equal to or less than deadline of current course\\n     *              continue to process next course, increase sum.\\n     *          else\\n     *              find out the course with longest duration we\\'ve took (from heap),\\n     *              remove it from max heap, and substract the duration from days.\\n     *\\n     *      (3) Return sum\\n     */\\n    \\n    heap_init();\\n\\n    /* Copy courses info to buffer for sorting */\\n    for (int i = 0; i < coursesSize; i++) {\\n        c_info[i].dur = courses[i][0];\\n        c_info[i].end = courses[i][1];\\n    }"], ["int scheduleCourse(int** courses, int coursesSize, int* coursesColSize){\\n\\n    /*\\n     *  Input:\\n     *      courses, the duration and deadline of coureses,\\n     *      courses, number of courses\\n     *      coursesColSize, column size of course info\\n     */\\n\\n    int sum = 0;\\n    int day = 0;\\n    int tmp;\\n    C_INFO c_info[10000];\\n    \\n    /*\\n     *  Algorithm:\\n     *      Always take the course with longer deadlines and shorter durations\\n     *\\n     *      (1) Sort the courses by end day in ascending order\\n     *      (2) Set sum and total days to 0, Scan the course 1 ~ N\\n     *          Take the course, push course duration to max heap, accmulate the days\\n     *          if days is equal to or less than deadline of current course\\n     *              continue to process next course, increase sum.\\n     *          else\\n     *              find out the course with longest duration we\\'ve took (from heap),\\n     *              remove it from max heap, and substract the duration from days.\\n     *\\n     *      (3) Return sum\\n     */\\n    \\n    heap_init();\\n\\n    /* Copy courses info to buffer for sorting */\\n    for (int i = 0; i < coursesSize; i++) {\\n        c_info[i].dur = courses[i][0];\\n        c_info[i].end = courses[i][1];\\n    }"]]}
{"id": "1857", "ref_c": [["int* smallestRange(int** nums, int numsSize, int* numsColSize, int* returnSize){\\n    /* calculate how may memory we use */\\n    int len = 0;\\n    for(int i = 0; i < numsSize; i++)\\n        len += numsColSize[i];\\n\\n    int idx = 0;\\n    int* data = (int*)calloc(len, sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsColSize[i]; j++){\\n            data[idx++] = nums[i][j] * 4096 | i;\\n        }"], ["int* smallestRange(int** nums, int numsSize, int* numsColSize, int* returnSize){\\n    /* calculate how may memory we use */\\n    int len = 0;\\n    for(int i = 0; i < numsSize; i++)\\n        len += numsColSize[i];\\n\\n    int idx = 0;\\n    int* data = (int*)calloc(len, sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsColSize[i]; j++){\\n            data[idx++] = nums[i][j] * 4096 | i;\\n        }"], ["int* smallestRange(int** nums, int numsSize, int* numsColSize, int* returnSize){\\n    /* calculate how may memory we use */\\n    int len = 0;\\n    for(int i = 0; i < numsSize; i++)\\n        len += numsColSize[i];\\n\\n    int idx = 0;\\n    int* data = (int*)calloc(len, sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsColSize[i]; j++){\\n            data[idx++] = nums[i][j] * 4096 | i;\\n        }"]]}
{"id": "1858", "ref_c": [["int maxProfit(int* prices, int pricesSize) {\\n if(pricesSize==1) return 0;\\n int cooldown=0;\\n int buy=1;\\n int index=0;\\n int *** dp= (int***)malloc(sizeof(int**)*pricesSize);\\n for(int i=0;i<pricesSize;i++){\\n     dp[i]=(int**)malloc(sizeof(int*)*2);\\n     for(int j=0;j<2;j++){\\n         dp[i][j]=(int*)malloc(sizeof(int)*2);\\n     }"], ["int maxProfit(int* prices, int pricesSize){\\n    if(pricesSize == 1) return 0;\\n\\n    // declare buy, sell & cooldown state machine and input first price\\n    int anBuy[2] = {-(*prices), 0}"], ["int maxProfit(int* prices, int pricesSize) {\\n if(pricesSize==1) return 0;\\n int cooldown=0;\\n int buy=1;\\n int index=0;\\n int *** dp= (int***)malloc(sizeof(int**)*pricesSize);\\n for(int i=0;i<pricesSize;i++){\\n     dp[i]=(int**)malloc(sizeof(int*)*2);\\n     for(int j=0;j<2;j++){\\n         dp[i][j]=(int*)malloc(sizeof(int)*2);\\n     }"]]}
{"id": "1859", "ref_c": [["int strangePrinter(char * s){\\n    int len = strlen(s);\\n    int** dp = (int**)malloc(sizeof(int*)*len);\\n    for(int i = 0;i < len;i++){\\n        dp[i] = (int*)malloc(sizeof(int)*len);\\n        dp[i][i] = 0;\\n        for(int j = i+1;j < len;j++){\\n            dp[i][j] = -1;\\n        }"], ["int strangePrinter(char * s){\\n    int len = strlen(s);\\n    int** dp = (int**)malloc(sizeof(int*)*len);\\n    for(int i = 0;i < len;i++){\\n        dp[i] = (int*)malloc(sizeof(int)*len);\\n        dp[i][i] = 0;\\n        for(int j = i+1;j < len;j++){\\n            dp[i][j] = -1;\\n        }"], ["int strangePrinter(char * s){\\n    int len = strlen(s);\\n    int** dp = (int**)malloc(sizeof(int*)*len);\\n    for(int i = 0;i < len;i++){\\n        dp[i] = (int*)malloc(sizeof(int)*len);\\n        dp[i][i] = 0;\\n        for(int j = i+1;j < len;j++){\\n            dp[i][j] = -1;\\n        }"]]}
{"id": "1860", "ref_c": [["int findKthNumber(int m, int n, int k){\\n    int start = 1, end = m * n + 1;\\n    while(start < end)\\n    {\\n        int mid = (start + end) / 2;\\n        if(count(m, n, mid) >= k)\\n            end = mid;\\n        else \\n            start = mid + 1;\\n    }"], ["int findKthNumber(int m, int n, int k){\\n    int start = 1, end = m * n + 1;\\n    while(start < end)\\n    {\\n        int mid = (start + end) / 2;\\n        if(count(m, n, mid) >= k)\\n            end = mid;\\n        else \\n            start = mid + 1;\\n    }"], ["int findKthNumber(int m, int n, int k){\\n    int start = 1, end = m * n + 1;\\n    while(start < end)\\n    {\\n        int mid = (start + end) / 2;\\n        if(count(m, n, mid) >= k)\\n            end = mid;\\n        else \\n            start = mid + 1;\\n    }"]]}
{"id": "1861", "ref_c": ["\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\n\treturn *p1 - *p2;\n}\n\nint64_t maxStrength(int * const nums, const int numsLen){\n\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\n\n\tbool numUsed = false;\n\tint64_t product = 1;\n\n\t//positive from right\n\tfor (int i = numsLen - 1; i >= 0 && nums[i] > 0; i -= 1){\n\t\tnumUsed = true;\n\t\tproduct *= nums[i];\n\t}\n\t//negative pairs from left\n\tfor (int i = 1; i < numsLen && nums[i] < 0; i += 2){\n\t\tnumUsed = true;\n\t\tproduct *= (int64_t)nums[i - 1] * (int64_t)nums[i];\t\t\n\t}\n\n\treturn numUsed? product : nums[numsLen - 1];\n}\n", "\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\n\treturn *p1 - *p2;\n}\n\nint64_t maxStrength(int * const nums, const int numsLen){\n\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\n\n\tbool numUsed = false;\n\tint64_t product = 1;\n\n\t//positive from right\n\tfor (int i = numsLen - 1; i >= 0 && nums[i] > 0; i -= 1){\n\t\tnumUsed = true;\n\t\tproduct *= nums[i];\n\t}\n\t//negative pairs from left\n\tfor (int i = 1; i < numsLen && nums[i] < 0; i += 2){\n\t\tnumUsed = true;\n\t\tproduct *= (int64_t)nums[i - 1] * (int64_t)nums[i];\t\t\n\t}\n\n\treturn numUsed? product : nums[numsLen - 1];\n}\n", "\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\n\treturn *p1 - *p2;\n}\n\nint64_t maxStrength(int * const nums, const int numsLen){\n\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\n\n\tbool numUsed = false;\n\tint64_t product = 1;\n\n\t//positive from right\n\tfor (int i = numsLen - 1; i >= 0 && nums[i] > 0; i -= 1){\n\t\tnumUsed = true;\n\t\tproduct *= nums[i];\n\t}\n\t//negative pairs from left\n\tfor (int i = 1; i < numsLen && nums[i] < 0; i += 2){\n\t\tnumUsed = true;\n\t\tproduct *= (int64_t)nums[i - 1] * (int64_t)nums[i];\t\t\n\t}\n\n\treturn numUsed? product : nums[numsLen - 1];\n}\n"]}
{"id": "1862", "ref_c": [["bool judgePoint24(int* cards, int cardsSize) {\\n    // \\u041F\\u0440\\u043E\\u0432\\u0435\\u0440\\u043A\\u0430, \\u0440\\u0430\\u0432\\u043D\\u044B \\u043B\\u0438 \\u0434\\u0432\\u0430 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0441 \\u0443\\u0447\\u0451\\u0442\\u043E\\u043C \\u043F\\u043E\\u0433\\u0440\\u0435\\u0448\\u043D\\u043E\\u0441\\u0442\\u0438\\n    bool areEqual(double a, double b) {\\n        return fabs(a - b) < EPSILON;\\n    }"], ["bool judgePoint24(int* cards, int cardsSize) {\\n    // \\u041F\\u0440\\u043E\\u0432\\u0435\\u0440\\u043A\\u0430, \\u0440\\u0430\\u0432\\u043D\\u044B \\u043B\\u0438 \\u0434\\u0432\\u0430 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u0441 \\u0443\\u0447\\u0451\\u0442\\u043E\\u043C \\u043F\\u043E\\u0433\\u0440\\u0435\\u0448\\u043D\\u043E\\u0441\\u0442\\u0438\\n    bool areEqual(double a, double b) {\\n        return fabs(a - b) < EPSILON;\\n    }"], ["bool judgePoint24(int* cards, int cardsSize){\\n    double *tCards = calloc(sizeof(double), cardsSize);\\n    for(int i = 0; i < cardsSize; i++)\\n        tCards[i] = cards[i];\\n    \\n    bool res =  backtrack(tCards, cardsSize);\\n    free(tCards);\\n    return res;\\n}"]]}
{"id": "1863", "ref_c": [["int rangeSumBST(struct TreeNode* root, int low, int high) {\\n    if (root == NULL) {\\n                return 0;\\n                    }"], ["int rangeSumBST(struct TreeNode* root, int low, int high) {\\n    int sum=0;\\n    if(root == NULL)\\n        return 0;\\n    if(root->val >= low && root->val <= high)\\n        sum+=root->val;\\n     if(root->val > low)\\n        sum+= rangeSumBST(root->left,low,high);\\n     if(root->val < high)\\n        sum+= rangeSumBST(root->right,low,high);\\n    return sum;\\n}"], ["int rangeSumBST(struct TreeNode* root, int low, int high){\\n    if(root==NULL){\\n        return 0;\\n    }"]]}
{"id": "1864", "ref_c": [["struct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }"], ["struct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }"], ["struct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    int totalNode = 0;\\n    int groupCnt = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* prev = NULL;\\n    \\n    while(curr)\\n    {\\n        curr = curr->next;\\n        totalNode++;\\n    }"]]}
{"id": "1865", "ref_c": [["int minStickers(char ** stickers, int stickersSize, char * target)\\n{\\n    // Make the target signature to count how many of each letter occur in target\\n    int targetSignature[26];\\n    initializeSignature(target, targetSignature);\\n    \\n    \\n    // Array of sticker signatures (each row is a sticker signature, or a record of the letters in that sticker)\\n    int * stickerSignatures[stickersSize];\\n    \\n    // Array of sticker strings. Is a subset of the given stickers, with dominated stickers removed\\n    char * workingStickers[stickersSize];\\n    \\n    int domainSize = preprocessStickers(stickers, stickersSize, stickerSignatures, workingStickers, targetSignature);\\n    \\n    \\n    // Create our hashtable (mapping)\\n    InstanceList * mapping[26];\\n    \\n    // Make the hash table and if it returns 0, there was some sort of error so return 0\\n    makeHashTable(workingStickers, domainSize, target, mapping);\\n\\n    \\n    // Now check if the task is impossible\\n    // It is impossible iff there is a non-null entry in the hash table with NULL data\\n    // (which means it is a letter we need but it was not found in any of the given stickers)\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (mapping[i] != NULL && mapping[i]->data == NULL)\\n        {\\n            cleanup(mapping, stickerSignatures, domainSize);\\n            return -1;\\n        }"], ["int minStickers(char ** stickers, int stickersSize, char * target)\\n{\\n    // Make the target signature to count how many of each letter occur in target\\n    int targetSignature[26];\\n    initializeSignature(target, targetSignature);\\n    \\n    \\n    // Array of sticker signatures (each row is a sticker signature, or a record of the letters in that sticker)\\n    int * stickerSignatures[stickersSize];\\n    \\n    // Array of sticker strings. Is a subset of the given stickers, with dominated stickers removed\\n    char * workingStickers[stickersSize];\\n    \\n    int domainSize = preprocessStickers(stickers, stickersSize, stickerSignatures, workingStickers, targetSignature);\\n    \\n    \\n    // Create our hashtable (mapping)\\n    InstanceList * mapping[26];\\n    \\n    // Make the hash table and if it returns 0, there was some sort of error so return 0\\n    makeHashTable(workingStickers, domainSize, target, mapping);\\n\\n    \\n    // Now check if the task is impossible\\n    // It is impossible iff there is a non-null entry in the hash table with NULL data\\n    // (which means it is a letter we need but it was not found in any of the given stickers)\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (mapping[i] != NULL && mapping[i]->data == NULL)\\n        {\\n            cleanup(mapping, stickerSignatures, domainSize);\\n            return -1;\\n        }"], ["int minStickers(char ** stickers, int stickersSize, char * target)\\n{\\n    // Make the target signature to count how many of each letter occur in target\\n    int targetSignature[26];\\n    initializeSignature(target, targetSignature);\\n    \\n    \\n    // Array of sticker signatures (each row is a sticker signature, or a record of the letters in that sticker)\\n    int * stickerSignatures[stickersSize];\\n    \\n    // Array of sticker strings. Is a subset of the given stickers, with dominated stickers removed\\n    char * workingStickers[stickersSize];\\n    \\n    int domainSize = preprocessStickers(stickers, stickersSize, stickerSignatures, workingStickers, targetSignature);\\n    \\n    \\n    // Create our hashtable (mapping)\\n    InstanceList * mapping[26];\\n    \\n    // Make the hash table and if it returns 0, there was some sort of error so return 0\\n    makeHashTable(workingStickers, domainSize, target, mapping);\\n\\n    \\n    // Now check if the task is impossible\\n    // It is impossible iff there is a non-null entry in the hash table with NULL data\\n    // (which means it is a letter we need but it was not found in any of the given stickers)\\n    for (int i = 0; i < 26; i++)\\n    {\\n        if (mapping[i] != NULL && mapping[i]->data == NULL)\\n        {\\n            cleanup(mapping, stickerSignatures, domainSize);\\n            return -1;\\n        }"]]}
{"id": "1866", "ref_c": [["int* decode(int* encoded, int encodedSize, int first, int* returnSize) {\\n    int *arr = (int *)malloc((encodedSize + 1) * sizeof(int));\\n    if (arr == NULL) {\\n        return NULL;\\n    }"], ["int* decode(int* encoded, int encodedSize, int first, int* returnSize) {\\n    int index=0;\\n    int *arr = (int *)malloc((encodedSize+1)*sizeof(int));\\n    arr[index] = first;\\n    index++;\\n    for(int i=0; i<encodedSize; i++){\\n            arr[index] = arr[index-1]^encoded[i];\\n            index++;\\n    }"], ["int* decode(int* encoded, int encodedSize, int first, int* returnSize) {\\n    *returnSize  = encodedSize + 1;\\n    int *arr = (int *)malloc(sizeof(int) * (encodedSize + 1));\\n    arr[0] = first;\\n    for(int i = 0; i < encodedSize; i++){\\n        arr[i + 1] = arr[i] ^ encoded[i];\\n    }"]]}
{"id": "1869", "ref_c": [["int smallestDistancePair(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int len = nums[numsSize - 1] + 1;\\n    int* hash = (int*)calloc(len, sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++){\\n        for(int j = i+1; j < numsSize; j++){\\n            hash[nums[j] - nums[i]]++;\\n        }"], ["int smallestDistancePair(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int len = nums[numsSize - 1] + 1;\\n    int* hash = (int*)calloc(len, sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++){\\n        for(int j = i+1; j < numsSize; j++){\\n            hash[nums[j] - nums[i]]++;\\n        }"], ["int smallestDistancePair(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int len = nums[numsSize - 1] + 1;\\n    int* hash = (int*)calloc(len, sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++){\\n        for(int j = i+1; j < numsSize; j++){\\n            hash[nums[j] - nums[i]]++;\\n        }"]]}
{"id": "1870", "ref_c": [["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"], ["bool canReorderDoubled(int* arr, int arrSize)\\n{\\n    N = arrSize;\\n    consumed_numbers = N;\\n    int freq1, freq2;\\n    int zero_count = 0;\\n    memset (HT, 0, sizeof(struct LL*) * 4999);\\n    for (int i = 0; i < N; i++)\\n    {\\n        save (arr[i]);\\n    }"]]}
{"id": "1871", "ref_c": [["int* closestPrimes(int left, int right, int* returnSize) {\\n    int* closestPrimes = (int*)malloc(2 * sizeof(int));\\n    closestPrimes[0] = -1;\\n    closestPrimes[1] = -1;\\n    if (right <= 1) {\\n        *returnSize = 2;\\n        return closestPrimes;\\n    }"], ["int* closestPrimes(int left, int right, int* returnSize) {\\n  int nums = right - left + 1;\\n  int *primes = (int *)malloc(sizeof(int) * nums);\\n  int *primes2 = (int *)malloc(sizeof(int) * 2); \\n\\n  int num_of_primes = 0;\\n  // get all primes from the range of [left, right];\\n  for (int i = left; i <= right; i++) {\\n    if (IsPrime(i)) {\\n      primes[num_of_primes++] = i;\\n    }"], ["int* closestPrimes(int left, int right, int* returnSize) {\\n  int nums = right - left + 1;\\n  int *primes = (int *)malloc(sizeof(int) * nums);\\n  int *primes2 = (int *)malloc(sizeof(int) * 2); \\n\\n  int num_of_primes = 0;\\n  // get all primes from the range of [left, right];\\n  for (int i = left; i <= right; i++) {\\n    if (IsPrime(i)) {\\n      primes[num_of_primes++] = i;\\n    }"]]}
{"id": "1873", "ref_c": [["int evaluate(char * expression) {\\n    /* Defining all the needed components. */\\n    struct scope *curScope = NULL;\\n    struct token token;\\n    char *s = expression;\\n    int result = 0;\\n\\n    if (!_evaluate(&s, &result, &token, &curScope)) {\\n        goto error;\\n    }"], ["int evaluate(char * expression) {\\n    /* Defining all the needed components. */\\n    struct scope *curScope = NULL;\\n    struct token token;\\n    char *s = expression;\\n    int result = 0;\\n\\n    if (!_evaluate(&s, &result, &token, &curScope)) {\\n        goto error;\\n    }"], ["int evaluate(char * expression) {\\n    /* Defining all the needed components. */\\n    struct scope *curScope = NULL;\\n    struct token token;\\n    char *s = expression;\\n    int result = 0;\\n\\n    if (!_evaluate(&s, &result, &token, &curScope)) {\\n        goto error;\\n    }"]]}
{"id": "1874", "ref_c": [["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"], ["int minMoves(int* nums, int numsSize) {\\n    if (nums == NULL || numsSize <= 1) {\\n        return 0;\\n    }"]]}
{"id": "1876", "ref_c": [["int partitionString(char * s){\\n    int ret = 1;\\n    char arr[26]={0}"], ["int partitionString(char * s){\\n    int ret = 1;\\n    char arr[26]={0}"], ["int partitionString(char * s){\\n    int ret = 1;\\n    char arr[26]={0}"]]}
{"id": "1877", "ref_c": [["int minMaxGame(int* nums, int numsSize) {\\n    \\n\\t\\tint left = 0,\\n\\t\\tright = numsSize - 1,\\n\\t\\tindex = 0;\\n\\n\\t\\twhile (left <= right) {\\n\\n\\t\\t\\tif (left == right) {\\n\\t\\t\\t\\treturn nums[0];\\n\\t\\t\\t}"], ["int minMaxGame(int* nums, int numsSize){\\n    int i;\\nif (numsSize == 1)\\n{\\n    return nums[0];\\n}"], ["int minMaxGame(int* nums, int numsSize){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     */\\n\\n    while (numsSize > 2) {\\n    \\n        for (int i = 0, j = 0; i < numsSize; i += 4, j += 2) {\\n            nums[j] = MIN(nums[i], nums[i + 1]);\\n            nums[j + 1] = MAX(nums[i + 2], nums[i + 3]);\\n        }"]]}
{"id": "1878", "ref_c": [["int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    int parent[1001];\\n    int rank[1001];\\n    int *ans=(int*)malloc(2*sizeof(int));\\n    \\n    void make_set(int n){\\n        for(int i=0;i<1001;i++){\\n            parent[i]=i;\\n            rank[i]=0;\\n        }"], ["int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    int parent[1001];\\n    int rank[1001];\\n    int *ans=(int*)malloc(2*sizeof(int));\\n    \\n    void make_set(int n){\\n        for(int i=0;i<1001;i++){\\n            parent[i]=i;\\n            rank[i]=0;\\n        }"], ["int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    int parent[1001];\\n    int rank[1001];\\n    int *ans=(int*)malloc(2*sizeof(int));\\n    \\n    void make_set(int n){\\n        for(int i=0;i<1001;i++){\\n            parent[i]=i;\\n            rank[i]=0;\\n        }"]]}
{"id": "1879", "ref_c": [["bool isNumber(char * s){\\n    bool    exp_found       = false; // State flags\\n    bool    decimal_found   = false;\\n    bool    sign_allowed    = true; // One shots\\n    bool    decimal_allowed = true;\\n    uint8_t pre_e_digits    = 0;\\n    uint8_t post_e_digits   = 0;\\n    uint8_t valid[16]       = {\\n        1, 0, 1, 1, 0, 1, 1, 1, // + , - . / 0 1 2 \\n        1, 1, 1, 1, 1, 1, 1, 0, // 3 4 5 6 7 8 9 :\\n    }"], ["bool isNumber(char * s){\\n    bool    exp_found       = false; // State flags\\n    bool    decimal_found   = false;\\n    bool    sign_allowed    = true; // One shots\\n    bool    decimal_allowed = true;\\n    uint8_t pre_e_digits    = 0;\\n    uint8_t post_e_digits   = 0;\\n    uint8_t valid[16]       = {\\n        1, 0, 1, 1, 0, 1, 1, 1, // + , - . / 0 1 2 \\n        1, 1, 1, 1, 1, 1, 1, 0, // 3 4 5 6 7 8 9 :\\n    }"], ["bool isNumber(char * s){\\n    bool    exp_found       = false; // State flags\\n    bool    decimal_found   = false;\\n    bool    sign_allowed    = true; // One shots\\n    bool    decimal_allowed = true;\\n    uint8_t pre_e_digits    = 0;\\n    uint8_t post_e_digits   = 0;\\n    uint8_t valid[16]       = {\\n        1, 0, 1, 1, 0, 1, 1, 1, // + , - . / 0 1 2 \\n        1, 1, 1, 1, 1, 1, 1, 0, // 3 4 5 6 7 8 9 :\\n    }"]]}
{"id": "1880", "ref_c": [["int minSwapsCouples(int* row, int rowSize) {\\n        // Greedy + Bit manipulation without extra space\\n        \\n        // Time complexty: O(n^2), n := rowSize\\n        // Space complexity: O(1)\\n        \\n        int result = 0;\\n        for (int i = 0; i < rowSize; i += 2) {\\n            if (row[i + 1] == (row[i] ^ 1)) continue;\\n            result++;\\n            for (int j = i + 1; j < rowSize; j++) {\\n                if (row[j] != (row[i] ^ 1)) continue;\\n                row[j] = row[i + 1];\\n                row[i + 1] = row[i] ^ 1;\\n                break;\\n            }", "int minSwapsCouples(int* row, int rowSize) {\\n        // Greedy + Bit manipulation with extra space\\n        \\n        // Time complexty: O(n)\\n        // Space complexity: O(n)\\n        \\n        const int n = rowSize;\\n        int result = 0;\\n\\n        int id2pos[n*2];  // {ID, pos}", "int minSwapsCouples(int* row, int rowSize) {\\n        // Union find\\n        \\n        // Time complexty: O(n*log(n))\\n        // Space complexity: O(n)\\n        \\n        const int n = rowSize;\\n        int result = 0;\\n\\n        int* root = (int*)calloc(n, sizeof(int));\\n        for (int i = 0; i < n; i++) {\\n            root[i] = i;\\n        }"], ["int minSwapsCouples(int* row, int rowSize){\\n    int positions[60];\\n    int swaps = 0;\\n    int partner, partnerPos, temp;\\n    \\n    /* Build look-up table of positions. */\\n    for (int i = 0; i < rowSize; i++)\\n        positions[row[i]] = i;\\n    \\n    for (int i = 0; i < rowSize; ++i) {\\n        partner = row[i] ^ 1;\\n        \\n        /* If adjacent element isn\\'t adjacent value... */\\n        if (partner != row[++i]) {\\n            /* ...swap cached position of values... */\\n            partnerPos = positions[partner];\\n            positions[row[i]] = partnerPos;\\n            positions[partner] = i;\\n            \\n            /* ...and swap values in array. */\\n            temp = row[partnerPos];\\n            row[partnerPos] = row[i];\\n            row[i] = temp;\\n            \\n            ++swaps;\\n        }"], ["int minSwapsCouples(int* row, int rowSize){\\n    int count = 0;\\n    for (int i = 0; i < SIZE; i += 2) {\\n        pair[i] = i + 1;\\n        pair[i+1] = i;\\n    }"]]}
{"id": "1881", "ref_c": [["long long* maximumEvenSplit(long long finalSum, int* returnSize){\\n    *returnSize = 0;\\n    if(finalSum & 1) return NULL;\\n    \\n    long long* ans = (long long*)calloc(100000, sizeof(long long));\\n    int ansIdx = 0;\\n    \\n    ans[ansIdx++] = 2;\\n    split(finalSum - 2, 2, ans, &ansIdx);\\n\\n    *returnSize = ansIdx;\\n    return ans;\\n}"], ["long long* maximumEvenSplit(long long finalSum, int* returnSize){\\n    *returnSize = 0;\\n    if(finalSum & 1) return NULL;\\n    \\n    long long* ans = (long long*)calloc(100000, sizeof(long long));\\n    int ansIdx = 0;\\n    \\n    ans[ansIdx++] = 2;\\n    split(finalSum - 2, 2, ans, &ansIdx);\\n\\n    *returnSize = ansIdx;\\n    return ans;\\n}"], ["long long* maximumEvenSplit(long long finalSum, int* returnSize){\\n    *returnSize = 0;\\n    if(finalSum & 1) return NULL;\\n    \\n    long long* ans = (long long*)calloc(100000, sizeof(long long));\\n    int ansIdx = 0;\\n    \\n    ans[ansIdx++] = 2;\\n    split(finalSum - 2, 2, ans, &ansIdx);\\n\\n    *returnSize = ansIdx;\\n    return ans;\\n}"]]}
{"id": "1882", "ref_c": [["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"]]}
{"id": "1883", "ref_c": [["int minSwaps(int* nums, int numsSize){\\n    int length = 0;\\n    for(int i = 0; i < numsSize; i ++){\\n        length += nums[i];\\n    }"], ["int minSwaps(int* nums, int numsSize){\\n    int length = 0;\\n    for(int i = 0; i < numsSize; i ++){\\n        length += nums[i];\\n    }"], ["int minSwaps(int* nums, int numsSize){\\n    int zeros=0;\\n    int ones=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) ones++;\\n    }"]]}
{"id": "1884", "ref_c": [["int swimInWater(int** grid, int gridSize, int* gridColSize){\\n    int** arrive = malloc(sizeof(int*)*gridSize);\\n    for (int i = 0 ; i < gridSize ; i++){\\n        arrive[i] = calloc(gridSize,sizeof(int));\\n    }"], ["int swimInWater(int** grid, int gridSize, int* gridColSize){\\n    int** arrive = malloc(sizeof(int*)*gridSize);\\n    for (int i = 0 ; i < gridSize ; i++){\\n        arrive[i] = calloc(gridSize,sizeof(int));\\n    }"], ["int swimInWater(int** grid, int gridSize, int* gridColSize){\\n    int** arrive = malloc(sizeof(int*)*gridSize);\\n    for (int i = 0 ; i < gridSize ; i++){\\n        arrive[i] = calloc(gridSize,sizeof(int));\\n    }"]]}
{"id": "1885", "ref_c": [["bool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}"], ["bool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}"], ["bool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}"]]}
{"id": "1886", "ref_c": [["int countBalls(int lowLimit, int highLimit) {\\n    int i,j,k=0,sum,rem;\\n    int n=highLimit-lowLimit + 1;\\n    int b[n];\\n    for(i=lowLimit;i<=highLimit;i++)\\n    {\\n        int temp=i;\\n        sum=0;\\n        while(temp>0)\\n        {\\n            rem=temp%10;\\n            sum=sum+rem;\\n            temp=temp/10;\\n        }", "int countBalls(int lowLimit, int highLimit) {\\n    int count[55]={0}"], ["int countBalls(int lowLimit, int highLimit) {\\n  int n, sum = 0;\\n  int p[46] = {\\n    0\\n  }"], ["int countBalls(int lowLimit, int highLimit){\\n\\n    int freqArr[10001] = {0,}"]]}
{"id": "1887", "ref_c": [["int preimageSizeFZF(int k){\\n    unsigned long long int a=1,step,temp;\\n\\n    while (f(a)<k) {a*=2;}"], ["int preimageSizeFZF(int k){\\n    unsigned long long int a=1,step,temp;\\n\\n    while (f(a)<k) {a*=2;}"], ["int preimageSizeFZF(int k){\\n    unsigned long long int a=1,step,temp;\\n\\n    while (f(a)<k) {a*=2;}"]]}
{"id": "1888", "ref_c": [["int* rearrangeBarcodes(int* barcodes, int barcodesSize, int* returnSize) {\\n    int* cnt = (int*)calloc(1e4+1, sizeof(int));\\n    int maxValue = 0;\\n    for(int i = 0; i < barcodesSize; i++){\\n        cnt[barcodes[i]] = (cnt[barcodes[i]] + 0x10000) | barcodes[i];\\n        maxValue = fmax(maxValue, barcodes[i]);\\n    }"], ["int* rearrangeBarcodes(int* barcodes, int barcodesSize, int* returnSize) {\\n    int* cnt = (int*)calloc(1e4+1, sizeof(int));\\n    int maxValue = 0;\\n    for(int i = 0; i < barcodesSize; i++){\\n        cnt[barcodes[i]] = (cnt[barcodes[i]] + 0x10000) | barcodes[i];\\n        maxValue = fmax(maxValue, barcodes[i]);\\n    }"], ["int* rearrangeBarcodes(int* barcodes, int barcodesSize, int* returnSize){\\n    int table[10001]={0}"]]}
{"id": "1889", "ref_c": ["\nint minSwap(int* A, int ASize, int* B, int BSize){\n    int ans = 0;\n    int e = 0; // the max. good index before the current iteration i\n    int curSwaps = 0; // record no. of swaps in the current subproblem\n    for (int i = 1; i < ASize; i++) {\n        if (MIN(A[i], B[i]) > MAX(A[i-1], B[i-1])) { // if i is a good index\n            ans += MIN(curSwaps, i-e-curSwaps); // select min. swaps of the two configurations\n            e = i;\n            curSwaps = 0;\n            continue;\n        }\n        if (A[i-1] >= A[i] || B[i-1] >= B[i]) { // if need to swap i\n            int temp = A[i];\n            A[i] = B[i];\n            B[i] = temp;\n            curSwaps++;\n        }\n    } // end for\n    ans += MIN(curSwaps, ASize-e-curSwaps);\n    return ans;\n}\n", "\nint minSwap(int* A, int ASize, int* B, int BSize){\n    int ans = 0;\n    int e = 0; // the max. good index before the current iteration i\n    int curSwaps = 0; // record no. of swaps in the current subproblem\n    for (int i = 1; i < ASize; i++) {\n        if (MIN(A[i], B[i]) > MAX(A[i-1], B[i-1])) { // if i is a good index\n            ans += MIN(curSwaps, i-e-curSwaps); // select min. swaps of the two configurations\n            e = i;\n            curSwaps = 0;\n            continue;\n        }\n        if (A[i-1] >= A[i] || B[i-1] >= B[i]) { // if need to swap i\n            int temp = A[i];\n            A[i] = B[i];\n            B[i] = temp;\n            curSwaps++;\n        }\n    } // end for\n    ans += MIN(curSwaps, ASize-e-curSwaps);\n    return ans;\n}\n", "\nint minSwap(int* A, int ASize, int* B, int BSize){\n    int ans = 0;\n    int e = 0; // the max. good index before the current iteration i\n    int curSwaps = 0; // record no. of swaps in the current subproblem\n    for (int i = 1; i < ASize; i++) {\n        if (MIN(A[i], B[i]) > MAX(A[i-1], B[i-1])) { // if i is a good index\n            ans += MIN(curSwaps, i-e-curSwaps); // select min. swaps of the two configurations\n            e = i;\n            curSwaps = 0;\n            continue;\n        }\n        if (A[i-1] >= A[i] || B[i-1] >= B[i]) { // if need to swap i\n            int temp = A[i];\n            A[i] = B[i];\n            B[i] = temp;\n            curSwaps++;\n        }\n    } // end for\n    ans += MIN(curSwaps, ASize-e-curSwaps);\n    return ans;\n}\n"]}
{"id": "1890", "ref_c": [["double trimMean(int* arr, int arrSize){\\n    qsort(arr,arrSize,sizeof(int),compare);\\n    int trim=arrSize*0.05;\\n    double sum=0.0;\\n    for(int i=trim;i<arrSize-trim;i++){\\n        sum+=arr[i];\\n    }"], ["double trimMean(int* arr, int arrSize) {\\nint five = 0.05*arrSize;\\nint* arrcpy = arr;\\nqsort(arr,arrSize,sizeof(int),sort);\\nfor (int i = 0; i < five; ++i){ \\n    arr[i] = -1;\\n}"], ["double trimMean(int* arr, int arrSize){\\n    qsort(arr,arrSize,sizeof(int),compare);\\n    int trim=arrSize*0.05;\\n    double sum=0.0;\\n    for(int i=trim;i<arrSize-trim;i++){\\n        sum+=arr[i];\\n    }"]]}
{"id": "1891", "ref_c": [["void duplicateZeros(int* arr, int arrSize) \\n{\\n   int j =0;\\n   int arr2[arrSize+2];\\n\\n    for ( int i=0;i<arrSize;i++)\\n    {       \\n            if ( arr[i]==0 && j <arrSize)\\n             {\\n             arr2[j]=0;\\n             j++;\\n             arr2[j]=0;\\n  \\n            }"], ["void duplicateZeros(int* arr, int arrSize) {\\n    int p=0;\\n    int temp[arrSize+2];\\n    for(int i=0;i<arrSize&&p<arrSize;i++,p++){\\n        if(arr[i]==0){\\n        temp[p]=0;\\n        p++;\\n        temp[p]=0;\\n        }"], ["void duplicateZeros(int* arr, int arrSize) \\n{\\n   int j =0;\\n   int arr2[arrSize+2];\\n\\n    for ( int i=0;i<arrSize;i++)\\n    {       \\n            if ( arr[i]==0 && j <arrSize)\\n             {\\n             arr2[j]=0;\\n             j++;\\n             arr2[j]=0;\\n  \\n            }"]]}
{"id": "1892", "ref_c": [["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"]]}
{"id": "1893", "ref_c": [["int numBusesToDestination(int** routes, int routesSize, int* routesColSize, int source, int target) {\\n    if(source == target) return 0;\\n    snode** table = (snode**)calloc(MAX_HASH,sizeof(snode*));\\n    int stopSize = 0;\\n    for(int i = 0;i<routesSize;i++){\\n        for(int j = 0;j<routesColSize[i];j++){\\n            addBus(routes[i][j],i,table);\\n            stopSize++;\\n        }"], ["int numBusesToDestination(int** routes, int routesSize, int* routesColSize, int source, int target) {\\n    // If source and target are the same, no buses are needed.\\n    if (source == target) {\\n        return 0;\\n    }"], ["int numBusesToDestination(int** routes, int routesSize, int* routesColSize, int source, int target) {\\n    if(source == target) return 0;\\n    snode** table = (snode**)calloc(MAX_HASH,sizeof(snode*));\\n    int stopSize = 0;\\n    for(int i = 0;i<routesSize;i++){\\n        for(int j = 0;j<routesColSize[i];j++){\\n            addBus(routes[i][j],i,table);\\n            stopSize++;\\n        }"]]}
{"id": "1894", "ref_c": [["int racecar(int target){  \\n    int* pow = getPowersOfTwo();\\n    int rowSize = 2 * target + 1;\\n    int colSize = 2 * MAX_POWER_TWO;\\n    int* vis[rowSize];\\n    for (int i = 0; i < rowSize; ++i) {\\n        vis[i] = (int*) malloc(colSize * sizeof(int));\\n        memset(vis[i], -1, sizeof(int) * colSize);\\n    }"], ["int racecar(int target){\\n  unsigned long long * dp = malloc((MAX_T + 1) * sizeof(unsigned long long));\\n  unsigned long long temp = (unsigned long long) MAXVAL;\\n  int i;\\n  int hop = 1;\\n  int pow = 2;\\n\\n  // Init with max value of data type.\\n  for (i = 0; i <= MAX_T; i++)\\n    dp[i] = temp;\\n\\n  for (i = 1; i <= target; i++)\\n  {\\n    if (i == (pow - 1))\\n    {\\n      pow = pow * 2;\\n      dp[i] = hop;\\n      hop++;\\n    }"], ["int racecar(int target){\\n  unsigned long long * dp = malloc((MAX_T + 1) * sizeof(unsigned long long));\\n  unsigned long long temp = (unsigned long long) MAXVAL;\\n  int i;\\n  int hop = 1;\\n  int pow = 2;\\n\\n  // Init with max value of data type.\\n  for (i = 0; i <= MAX_T; i++)\\n    dp[i] = temp;\\n\\n  for (i = 1; i <= target; i++)\\n  {\\n    if (i == (pow - 1))\\n    {\\n      pow = pow * 2;\\n      dp[i] = hop;\\n      hop++;\\n    }"]]}
{"id": "1895", "ref_c": [["int largestIsland(int** grid, int gridSize, int* gridColSize){\\n    int *area=calloc(125003,sizeof(int));\\n    int idx=2;\\n    int ans=0;\\n    for(int i=0;i<gridSize;i++){\\n        for(int j=0;j<*gridColSize;j++){\\n            if(grid[i][j]==1){\\n                dfs(grid,gridSize,gridColSize,i,j,area,idx);\\n                ans=fmax(ans,area[idx]);\\n                idx++;\\n            }"], ["int largestIsland(int** grid, int gridSize, int* gridColSize){\\n    int *area=calloc(125003,sizeof(int));\\n    int idx=2;\\n    int ans=0;\\n    for(int i=0;i<gridSize;i++){\\n        for(int j=0;j<*gridColSize;j++){\\n            if(grid[i][j]==1){\\n                dfs(grid,gridSize,gridColSize,i,j,area,idx);\\n                ans=fmax(ans,area[idx]);\\n                idx++;\\n            }"], ["int largestIsland(int** grid, int gridSize, int* gridColSize){\\n\\n    int marker=2, islandSizes[30000]={0}"]]}
{"id": "1896", "ref_c": [["int uniqueLetterString(char * s){\\n    int64_t total = 0;\\n    int prev[128] = { 0 }"], ["int uniqueLetterString(char * s){\\n    int64_t total = 0;\\n    int prev[128] = { 0 }"], ["int uniqueLetterString(char * s){\\n    int64_t total = 0;\\n    int prev[128] = { 0 }"]]}
{"id": "1897", "ref_c": [["int consecutiveNumbersSum(int n) {\\n\\n  int i, res = 0; int const k = (int) floor(sqrt(2) * sqrt(n)), dn = 2 * n, o = !!(n % 2);\\n  \\n  for (i = 2; i <= k; i += 2) res += (!(dn % i) && (o || (n % i)));\\n  for (i = 3; i <= k; i += 2) res += !(n % i);\\n\\n  return ++res;\\n}"], ["int consecutiveNumbersSum(int n){\\n    int i = 1;\\n    int j = 2;\\n    int k = 2;\\n    int count = 0;\\n    int a = 0;\\n    while(true){\\n        a = (n-i)/j;\\n        if(a==0){\\n            break;\\n        }"], ["int consecutiveNumbersSum(int n) {\\n        int i = 1;\\n        int count = 0;\\n        int startSum = 1;\\n        \\n        while(startSum<=n) {\\n            int sumToMake = n-startSum;\\n            if(sumToMake%i==0) {\\n                count++;\\n            }"]]}
{"id": "1898", "ref_c": [["int* sumOfDistancesInTree(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    short sN = n, sEdgesSize = edgesSize;\\n    struct EdgeRecord* apstEdgeRecord[sN];\\n    memset(apstEdgeRecord, NULL, sN*sizeof(struct EdgeRecord*));\\n\\n    // scan edges and store into apstEdgeRecord\\n    while(sEdgesSize-- > 0)\\n    {\\n        // store edges A\\n        struct EdgeRecord* pstNew = (struct EdgeRecord*) malloc(sizeof(struct EdgeRecord));\\n        pstNew->sIndex = (*edges)[1];\\n        pstNew->sIndexCount = 0;\\n        pstNew->nSumDistance = 0;   //default, we will calcate later\\n        pstNew->pstNext = apstEdgeRecord[(*edges)[0]];\\n\\n        apstEdgeRecord[(*edges)[0]] = pstNew;\\n\\n        // store edges B\\n        pstNew = (struct EdgeRecord*) malloc(sizeof(struct EdgeRecord));\\n        pstNew->sIndex = (*edges)[0];\\n        pstNew->sIndexCount = 0;\\n        pstNew->nSumDistance = 0;   //default, we will calcate later\\n        pstNew->pstNext = apstEdgeRecord[(*edges)[1]];\\n\\n        apstEdgeRecord[(*edges)[1]] = pstNew;\\n\\n        // move to next edge\\n        edges++;\\n    }"], ["int* sumOfDistancesInTree(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    short sN = n, sEdgesSize = edgesSize;\\n    struct EdgeRecord* apstEdgeRecord[sN];\\n    memset(apstEdgeRecord, NULL, sN*sizeof(struct EdgeRecord*));\\n\\n    // scan edges and store into apstEdgeRecord\\n    while(sEdgesSize-- > 0)\\n    {\\n        // store edges A\\n        struct EdgeRecord* pstNew = (struct EdgeRecord*) malloc(sizeof(struct EdgeRecord));\\n        pstNew->sIndex = (*edges)[1];\\n        pstNew->sIndexCount = 0;\\n        pstNew->nSumDistance = 0;   //default, we will calcate later\\n        pstNew->pstNext = apstEdgeRecord[(*edges)[0]];\\n\\n        apstEdgeRecord[(*edges)[0]] = pstNew;\\n\\n        // store edges B\\n        pstNew = (struct EdgeRecord*) malloc(sizeof(struct EdgeRecord));\\n        pstNew->sIndex = (*edges)[0];\\n        pstNew->sIndexCount = 0;\\n        pstNew->nSumDistance = 0;   //default, we will calcate later\\n        pstNew->pstNext = apstEdgeRecord[(*edges)[1]];\\n\\n        apstEdgeRecord[(*edges)[1]] = pstNew;\\n\\n        // move to next edge\\n        edges++;\\n    }"], ["int* sumOfDistancesInTree(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize)\\n{\\n    \\n    int x,y;\\n    //memory Allocation\\n    answer = calloc(n,sizeof(int));\\n    child_count=calloc(n,sizeof(int));\\n    connect_list=malloc(n*sizeof(Node*));\\n    count_size=n;\\n    \\n    for(int i=0;i<n;i++){\\n        connect_list[i]=NULL;\\n        child_count[i]=1;\\n    }"]]}
{"id": "1899", "ref_c": [["int numSimilarGroups(char ** strs, int strsSize){\\n    int count_groups = 0;\\n    int i;\\n    int j;\\n    \\n    //Arrary to check if string is already part of a group\\n    bool *part_of_a_group = (bool *)malloc(sizeof(bool)*strsSize);\\n    memset(part_of_a_group, 0, sizeof(bool)*strsSize);\\n\\n    //Iterates over strs\\n    for(i = 0; i < strsSize; i++){\\n        //If string belongs to a group, do nothing\\n        if(part_of_a_group[i] == true){\\n            continue;\\n        }"], ["int numSimilarGroups(char ** strs, int strsSize){\\n    int count = 0;\\n    bool* visited = calloc(strsSize, sizeof(bool));\\n\\n    for(int i = 0; i < strsSize; i++){\\n        if(!visited[i]){\\n            visited[i] = true;\\n            count++;\\n            dfs(strs, strsSize, visited, i);\\n        }", "int numSimilarGroups(char ** strs, int strsSize){\\n    int count = strsSize;\\n    DSU* dsu = initDSU(strsSize);\\n    int* root = dsu->root;\\n    int* rank = dsu->rank;\\n\\n    for(int i = 0; i < strsSize; i++){\\n        for(int j = i + 1; j < strsSize; j++){\\n            if(isSimilar(strs[i], strs[j]) && find(root, i) != find(root, j)){\\n                count--;\\n                setUnion(root, rank, i, j);\\n            }"], ["int numSimilarGroups(char ** strs, int strsSize){\\n    int count = 0;\\n    bool* visited = calloc(strsSize, sizeof(bool));\\n\\n    for(int i = 0; i < strsSize; i++){\\n        if(!visited[i]){\\n            visited[i] = true;\\n            count++;\\n            dfs(strs, strsSize, visited, i);\\n        }", "int numSimilarGroups(char ** strs, int strsSize){\\n    int count = strsSize;\\n    DSU* dsu = initDSU(strsSize);\\n    int* root = dsu->root;\\n    int* rank = dsu->rank;\\n\\n    for(int i = 0; i < strsSize; i++){\\n        for(int j = i + 1; j < strsSize; j++){\\n            if(isSimilar(strs[i], strs[j]) && find(root, i) != find(root, j)){\\n                count--;\\n                setUnion(root, rank, i, j);\\n            }"]]}
{"id": "1900", "ref_c": [["void findSecretWord(char** words, int wordsSize, Master* master) {\\n\\n    /*\\n     * Input:\\n     *  words, string list\\n     *  wordsSize, number of string\\n     *  master, some important data\\n     */\\n\\n    int result, cnt, sel;\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n    \\n\\n        sel = selWord(words, wordsSize);\\n        \\n        result = guess(master, words[sel]);\\n\\n        if (result == 6) {\\n            break;\\n        }"], ["void findSecretWord(char** words, int wordsSize, Master* master) {\\n\\n    /*\\n     * Input:\\n     *  words, string list\\n     *  wordsSize, number of string\\n     *  master, some important data\\n     */\\n\\n/*\\n * 843. Guess the Word\\n *\\n * You are given an array of unique strings words where words[i] is six *\\n * letters long. One word of words was chosen as a secret word.\\n * \\n * You are also given the helper object Master. You may call Master.guess(word) \\n * where word is a six-letter-long string, and it must be from words. \\n * Master.guess(word) returns:\\n * \\n * -1 if word is not from words, or\\n * an integer representing the number of exact matches (value and position) of \\n * your guess to the secret word.\\n * There is a parameter allowedGuesses for each test case where allowedGuesses \\n * is the maximum number of times you can call Master.guess(word).\\n * \\n * For each test case, you should call Master.guess with the secret word without \\n * exceeding the maximum number of allowed guesses. You will get:\\n * \\n * \"Either you took too many guesses, or you did not find the secret word.\" if \\n * you called Master.guess more than allowedGuesses times or if you did not call \\n * Master.guess with the secret word, or \"You guessed the secret word correctly.\" \\n * if you called Master.guess with the secret word with the number of calls to \\n * Master.guess less than or equal to allowedGuesses.\\n * The test cases are generated such that you can guess the secret word with a \\n * reasonable strategy (other than using the bruteforce method).\\n *\\n * 1 <= words.length <= 100\\n * words[i].length == 6\\n * words[i] consist of lowercase English letters.\\n * All the strings of wordlist are unique.\\n * secret exists in words.\\n * 10 <= allowedGuesses <= 30\\n */\\n\\n\\n/**\\n * *********************************************************************\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * *********************************************************************\\n *\\n * int guess(Master *, char *word);\\n */\\nvoid findSecretWord(char** words, int wordsSize, Master* master) {\\n\\n    /*\\n     * Input:\\n     *  words, string list\\n     *  wordsSize, number of string\\n     *  master, some important data\\n     */\\n\\n    /* This is the byte stores the matching status */\\n    ((char *)master)[24] = 1;\\n\\n}"], ["void findSecretWord(char** words, int wordsSize, Master* master) {\\n\\n    /*\\n     * Input:\\n     *  words, string list\\n     *  wordsSize, number of string\\n     *  master, some important data\\n     */\\n\\n    int result, cnt, sel;\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n    \\n\\n        sel = selWord(words, wordsSize);\\n        \\n        result = guess(master, words[sel]);\\n\\n        if (result == 6) {\\n            break;\\n        }"]]}
{"id": "1901", "ref_c": [["int shortestPathLength(int** graph, int graphSize, int* graphColSize) {\\n    // Create an array to record the element that has been visited\\n    int** seen = malloc(sizeof(int *) * (1 << graphSize));\\n    for(int i = 0; i < (1 << graphSize); i++) {\\n        *(seen + i) = calloc(graphSize, sizeof(int));\\n    }"], ["int shortestPathLength(int** graph, int graphSize, int* graphColSize) {\\n    // Create an array to record the element that has been visited\\n    int** seen = malloc(sizeof(int *) * (1 << graphSize));\\n    for(int i = 0; i < (1 << graphSize); i++) {\\n        *(seen + i) = calloc(graphSize, sizeof(int));\\n    }"], ["int shortestPathLength(int** graph, int graphSize, int* graphColSize) {\\n    // Create an array to record the element that has been visited\\n    int** seen = malloc(sizeof(int *) * (1 << graphSize));\\n    for(int i = 0; i < (1 << graphSize); i++) {\\n        *(seen + i) = calloc(graphSize, sizeof(int));\\n    }"]]}
{"id": "1902", "ref_c": ["\nint garbageCollection(char** garbage, int garbageSize, int* travel, int travelSize) {\n    int last_m = -1;\n    int last_p = -1;\n    int last_g = -1;\n    int result = 0;\n\n    for (int i = 0; i < garbageSize; ++i) {\n        for (int j = 0; j < strlen(garbage[i]); ++j) {\n            if (garbage[i][j] == 'M') last_m = i;\n            if (garbage[i][j] == 'P') last_p = i;\n            if (garbage[i][j] == 'G') last_g = i;\n        }\n        result += strlen(garbage[i]);\n    }\n\n    for (int i = 1; i < garbageSize; ++i) {\n        if (i <= last_m) result += travel[i - 1];\n        if (i <= last_p) result += travel[i - 1];\n        if (i <= last_g) result += travel[i - 1];\n    }\n\n    return result;\n}\n", "\nint garbageCollection(char** garbage, int garbageSize, int* travel, int travelSize) {\n    int last_m = -1;\n    int last_p = -1;\n    int last_g = -1;\n    int result = 0;\n\n    for (int i = 0; i < garbageSize; ++i) {\n        for (int j = 0; j < strlen(garbage[i]); ++j) {\n            if (garbage[i][j] == 'M') last_m = i;\n            if (garbage[i][j] == 'P') last_p = i;\n            if (garbage[i][j] == 'G') last_g = i;\n        }\n        result += strlen(garbage[i]);\n    }\n\n    for (int i = 1; i < garbageSize; ++i) {\n        if (i <= last_m) result += travel[i - 1];\n        if (i <= last_p) result += travel[i - 1];\n        if (i <= last_g) result += travel[i - 1];\n    }\n\n    return result;\n}\n", "\nint garbageCollection(char** garbage, int garbageSize, int* travel, int travelSize) {\n    int last_m = -1;\n    int last_p = -1;\n    int last_g = -1;\n    int result = 0;\n\n    for (int i = 0; i < garbageSize; ++i) {\n        for (int j = 0; j < strlen(garbage[i]); ++j) {\n            if (garbage[i][j] == 'M') last_m = i;\n            if (garbage[i][j] == 'P') last_p = i;\n            if (garbage[i][j] == 'G') last_g = i;\n        }\n        result += strlen(garbage[i]);\n    }\n\n    for (int i = 1; i < garbageSize; ++i) {\n        if (i <= last_m) result += travel[i - 1];\n        if (i <= last_p) result += travel[i - 1];\n        if (i <= last_g) result += travel[i - 1];\n    }\n\n    return result;\n}\n"]}
{"id": "1903", "ref_c": [["int** allPathsSourceTarget(int** graph, int graphSize, int* graphColSize, int* returnSize, int** returnColumnSizes){\\n    int** paths = (int**)malloc(sizeof(int*) * MAXSIZE);\\n    int* path = (int*)malloc(sizeof(int) * MAXSIZE);\\n    *returnColumnSizes = (int*)malloc(sizeof(int*) * MAXSIZE);\\n\\n    int beg = 0;\\n    int end = graphSize - 1;\\n\\n    int count_path = 0;\\n    int count_paths = 0;\\n    void dfs(int node) {\\n        path[count_path] = node;\\n        count_path++;\\n\\n        if (node == end) {\\n            int* path_new = (int*)malloc(sizeof(int) * count_path);\\n            memmove(path_new, path, sizeof(int) * count_path);\\n\\n            (*returnColumnSizes)[count_paths] = count_path;\\n            paths[count_paths] = path_new;\\n            count_paths++;\\n        }"], ["int** allPathsSourceTarget(int** graph, int graphSize, int* graphColSize, int* returnSize, int** returnColumnSizes){\\n    int ngraph[graphSize][graphSize];\\n    for(int i = 0 ; i < graphSize ; i++)\\n    {\\n        for(int j = 0 ; j < graphSize ; j++)\\n            ngraph[i][j] = 0;\\n    }"], ["int** allPathsSourceTarget(int** graph, int graphSize, int* graphColSize, int* returnSize, int** returnColumnSizes)\\n{\\n    int maxPaths = pow(2, graphSize-1);\\n    int currentPathSize = 0;\\n    int *currentPath = malloc(sizeof(int) * graphSize);\\n    int **paths = malloc(sizeof(int *) * maxPaths);\\n    int *returnColSizes = malloc(sizeof(int) * maxPaths);\\n    *returnSize = 0;\\n\\n    dfs(0, graphSize-1, graph, graphSize, graphColSize, returnSize, returnColSizes, currentPath, currentPathSize, paths);\\n\\n    paths = realloc(paths, sizeof(int *) * (*returnSize));\\n    returnColSizes = realloc(returnColSizes, sizeof(int) * (*returnSize));\\n\\n    *returnColumnSizes = returnColSizes;\\n\\n    return paths;\\n}"]]}
{"id": "1904", "ref_c": [["double mincostToHireWorkers(int* quality, int qualitySize, int* wage, int wageSize, int k){\\n    worker_t workers[qualitySize];\\n    int i, sumq = 0, q;\\n    double ans = 1e+9;\\n    min_heap_t *heap = create_min_heap(qualitySize);\\n\\n    for (i=0;i<qualitySize;i++) {\\n        workers[i].quality = quality[i];\\n        workers[i].wage = wage[i];\\n    }"], ["double mincostToHireWorkers(int* quality, int qualitySize, int* wage, int wageSize, int k){\\n    worker_t workers[qualitySize];\\n    int i, sumq = 0, q;\\n    double ans = 1e+9;\\n    min_heap_t *heap = create_min_heap(qualitySize);\\n\\n    for (i=0;i<qualitySize;i++) {\\n        workers[i].quality = quality[i];\\n        workers[i].wage = wage[i];\\n    }"], ["double mincostToHireWorkers(int* quality, int qualitySize, int* wage, int wageSize, int k){\\n    worker_t workers[qualitySize];\\n    int i, sumq = 0, q;\\n    double ans = 1e+9;\\n    min_heap_t *heap = create_min_heap(qualitySize);\\n\\n    for (i=0;i<qualitySize;i++) {\\n        workers[i].quality = quality[i];\\n        workers[i].wage = wage[i];\\n    }"]]}
{"id": "1905", "ref_c": [["int** intervalIntersection(int** firstList, int firstListSize, int* firstListColSize, int** secondList, int secondListSize, int* secondListColSize, int* returnSize, int** returnColumnSizes){\\n    if(firstListSize == 0 || secondListSize == 0){\\n        *returnSize = 0;\\n        *returnColumnSizes = NULL;\\n        return NULL;\\n    }"], ["int** intervalIntersection(int** firstList, int firstListSize, int* firstListColSize, int** secondList, int secondListSize, int* secondListColSize, int* returnSize, int** returnColumnSizes){\\n    if(firstListSize == 0 || secondListSize == 0){\\n        *returnSize = 0;\\n        *returnColumnSizes = NULL;\\n        return NULL;\\n    }"], ["int** intervalIntersection(int** firstList, int firstListSize, int* firstListColSize, int** secondList, int secondListSize, int* secondListColSize, int* returnSize, int** returnColumnSizes){\\n    if(firstListSize == 0 || secondListSize == 0){\\n        *returnSize = 0;\\n        *returnColumnSizes = NULL;\\n        return NULL;\\n    }"]]}
{"id": "1906", "ref_c": [["int shortestPathAllKeys(char ** grid, int gridSize) {\\n\\tstruct state_hash* table = NULL;\\n\\tstruct move_queue todo;\\n\\tmove_queue_init(&todo);\\n\\n\\t/* Find the starting point and the total number of keys required */\\n\\tuint8_t needed_keys = 0;\\n\\tuint8_t cols = strlen(grid[0]);\\n\\tfor (int r = 0; r < gridSize; ++r) {\\n\\t\\tfor (int c = 0; grid[r][c]; ++c) {\\n\\t\\t\\tif (\\'a\\' <= grid[r][c] && grid[r][c] <= \\'z\\') {\\n\\t\\t\\t\\tneeded_keys |= (1 << (grid[r][c] - \\'a\\'));\\n\\t\\t\\t}"], ["int shortestPathAllKeys(char ** grid, int gridSize) {\\n\\tstruct state_hash* table = NULL;\\n\\tstruct move_queue todo;\\n\\tmove_queue_init(&todo);\\n\\n\\t/* Find the starting point and the total number of keys required */\\n\\tuint8_t needed_keys = 0;\\n\\tuint8_t cols = strlen(grid[0]);\\n\\tfor (int r = 0; r < gridSize; ++r) {\\n\\t\\tfor (int c = 0; grid[r][c]; ++c) {\\n\\t\\t\\tif (\\'a\\' <= grid[r][c] && grid[r][c] <= \\'z\\') {\\n\\t\\t\\t\\tneeded_keys |= (1 << (grid[r][c] - \\'a\\'));\\n\\t\\t\\t}"], ["int shortestPathAllKeys(char ** grid, int gridSize) {\\n\\tstruct state_hash* table = NULL;\\n\\tstruct move_queue todo;\\n\\tmove_queue_init(&todo);\\n\\n\\t/* Find the starting point and the total number of keys required */\\n\\tuint8_t needed_keys = 0;\\n\\tuint8_t cols = strlen(grid[0]);\\n\\tfor (int r = 0; r < gridSize; ++r) {\\n\\t\\tfor (int c = 0; grid[r][c]; ++c) {\\n\\t\\t\\tif (\\'a\\' <= grid[r][c] && grid[r][c] <= \\'z\\') {\\n\\t\\t\\t\\tneeded_keys |= (1 << (grid[r][c] - \\'a\\'));\\n\\t\\t\\t}"]]}
{"id": "1907", "ref_c": [["int minRefuelStops(int target, int startFuel, int** stations, int stationsSize, int* stationsColSize){\\n    if (stationsSize == 0){\\n        return startFuel >= target ? 0 : -1;\\n    }"], ["int minRefuelStops(int target, int startFuel, int** stations, int stationsSize, int* stationsColSize){\\n    if (stationsSize == 0){\\n        return startFuel >= target ? 0 : -1;\\n    }"], ["int minRefuelStops(int target, int startFuel, int** stations, int stationsSize, int* stationsColSize){\\n    if (stationsSize == 0){\\n        return startFuel >= target ? 0 : -1;\\n    }"]]}
{"id": "1908", "ref_c": [["int nthMagicalNumber(int n, int a, int b){\\n    int mod = 1e9+7;\\n    long long commonmultiple;\\n    int oneround = 0;\\n    if (a > b){\\n        commonmultiple = Commonmultiple(a, b, &oneround);\\n    }"], ["int nthMagicalNumber(int n, int a, int b){\\n    long temp = a * b/ gcd(a, b), left = 2, right = 1e14, Mod = 1e9 + 7;\\n    while(left < right)\\n    {\\n        long mid = (left + right) / 2;\\n        if(mid/a + mid/b - mid/temp < n)\\n            left = mid + 1;\\n        else right = mid;\\n    }"], ["int nthMagicalNumber(int n, int a, int b){\\n    int mod = 1e9+7;\\n    long long commonmultiple;\\n    int oneround = 0;\\n    if (a > b){\\n        commonmultiple = Commonmultiple(a, b, &oneround);\\n    }"]]}
{"id": "1909", "ref_c": [["int profitableSchemes(int n, int minProfit, int* group, int groupSize, int* profit, int profitSize) {\\n    int MOD = 1e9 + 7;\\n    int dp[101][101];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int k = 0; k < profitSize; ++k) {\\n        int g = group[k];\\n        int p = profit[k];\\n        for (int i = n; i >= 0; --i) {\\n            for (int j = minProfit; j >= 0; --j) {\\n                if (i >= g) {\\n                    dp[i][j] += dp[i - g][max(0, j - p)];\\n                    dp[i][j] %= MOD;\\n                }"], ["int profitableSchemes(int n, int minProfit, int* group, int groupSize, int* profit, int profitSize){\\n  \\n    const int MOD = 1e9 + 7;\\n    int N = groupSize;\\n    int dp[n+1][minProfit+1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 0; i < N; i++) {\\n        for (int j = n; j >= group[i]; j--) {\\n            for (int k = minProfit; k >= 0; k--) {\\n                int p = fmax(0, k-profit[i]);\\n                dp[j][k] = (dp[j][k] + dp[j-group[i]][p]) % MOD;\\n            }"], ["int profitableSchemes(int n, int minProfit, int* group, int groupSize, int* profit, int profitSize) {\\n    int MOD = 1e9 + 7;\\n    int dp[101][101];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int k = 0; k < profitSize; ++k) {\\n        int g = group[k];\\n        int p = profit[k];\\n        for (int i = n; i >= 0; --i) {\\n            for (int j = minProfit; j >= 0; --j) {\\n                if (i >= g) {\\n                    dp[i][j] += dp[i - g][max(0, j - p)];\\n                    dp[i][j] %= MOD;\\n                }"]]}
{"id": "1910", "ref_c": [["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"], ["bool stoneGame(int* piles, int pilesSize){\\n    return true;\\n}"]]}
{"id": "1911", "ref_c": [["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"]]}
{"id": "1912", "ref_c": ["\nchar *longestCommonPrefix(char **strs, int strsSize)\n{\n\tfor(int c=0;; ++c)\n\t{\n\t\tif(strs[0][c] == '\u0000') // the longest common prefix is the first string\n\t\t\treturn strs[0];\n\t\tfor(int s=1; s<strsSize; ++s)\n\t\t{\n\t\t\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\n\t\t\t{\n\t\t\t\tstrs[0][c] = '\u0000'; // replace the current character with '\u0000'\n\t\t\t\treturn strs[0];\n\t\t\t}\n\t\t}\n\t}\n}\n", "\nchar *longestCommonPrefix(char **strs, int strsSize)\n{\n\tfor(int c=0;; ++c)\n\t{\n\t\tif(strs[0][c] == '\u0000') // the longest common prefix is the first string\n\t\t\treturn strs[0];\n\t\tfor(int s=1; s<strsSize; ++s)\n\t\t{\n\t\t\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\n\t\t\t{\n\t\t\t\tstrs[0][c] = '\u0000'; // replace the current character with '\u0000'\n\t\t\t\treturn strs[0];\n\t\t\t}\n\t\t}\n\t}\n}\n", "\nchar *longestCommonPrefix(char **strs, int strsSize)\n{\n\tfor(int c=0;; ++c)\n\t{\n\t\tif(strs[0][c] == '\u0000') // the longest common prefix is the first string\n\t\t\treturn strs[0];\n\t\tfor(int s=1; s<strsSize; ++s)\n\t\t{\n\t\t\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\n\t\t\t{\n\t\t\t\tstrs[0][c] = '\u0000'; // replace the current character with '\u0000'\n\t\t\t\treturn strs[0];\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
{"id": "1914", "ref_c": [["char * orderlyQueue(char * s, int k){\\n    if(k>1)\\n        qsort(s, strlen(s), sizeof(char), cmp);\\n    else{\\n        int len = strlen(s), minIdx = 0;\\n        char* res = (char*)calloc(len*2, sizeof(char));\\n        memcpy(res, s, sizeof(char)*len);\\n        for(int i = 0; i < len; i++){\\n            res[len+i] = s[i];\\n            minIdx = (strncmp(res+minIdx, res+i+1, len) <= 0)? minIdx : i+1; /* str1 < str2 */\\n        }"], ["char * orderlyQueue(char * s, int k){\\n    int* hash=(int*)(malloc(sizeof(int)*35));\\n    if (k==1) {\\n        int i,j,k,k_,min=0;\\n        i=0;\\n        while (s[i]!=0) {\\n            if (s[i]==s[min]) {\\n                j=0;\\n                k=0;\\n                k_=0;\\n                while (((k==0)||(i+j-k<min))&&(s[i+j-k]==s[min+j-k_])) {\\n                    j++;\\n                    if (s[i+j-k]==0) {k=i+j-k;}"], ["char * orderlyQueue(char * s, int k){\\n    if(k>1)\\n        qsort(s, strlen(s), sizeof(char), cmp);\\n    else{\\n        int len = strlen(s), minIdx = 0;\\n        char* res = (char*)calloc(len*2, sizeof(char));\\n        memcpy(res, s, sizeof(char)*len);\\n        for(int i = 0; i < len; i++){\\n            res[len+i] = s[i];\\n            minIdx = (strncmp(res+minIdx, res+i+1, len) <= 0)? minIdx : i+1; /* str1 < str2 */\\n        }"]]}
{"id": "1915", "ref_c": ["\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n", "\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n", "\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n"]}
{"id": "1916", "ref_c": [["int numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }"], ["int numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }"], ["int numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }"]]}
{"id": "1917", "ref_c": [["int searchInsert(int* nums, int numsSize, int target){\\n    int index1 = -1;\\n    int index2 = -1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            index1 = i;\\n            break;\\n        }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"]]}
{"id": "1918", "ref_c": [["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize){\\n    if (returnSize == NULL || n == 0 || edges == NULL)\\n        return NULL;\\n \\n    struct node **depths = calloc(n, sizeof(struct node *));\\n    assert(depths);\\n\\n    assert(edgesSize == (n - 1));\\n\\n    struct node *nodes = calloc(n, sizeof(struct node));\\n    assert(nodes != NULL);\\n  \\n    // Allocate results array\\n    int *result = calloc(n, sizeof(int));\\n    assert(result != NULL);\\n \\n    // Apply each node\\'s label and perform some initializations\\n    for (int i = 0; i < n; i++)\\n    {\\n        nodes[i].label = labels[i];\\n        nodes[i].xparent = (struct node *)(i == 0 ? 0x1 : NULL);\\n        /* The root node\\'s depth must always be 0, for the remaining nodes, the\\n         * depth will be determined when the edge array is parsed.\\n         */\\n        nodes[i].depth = (i == 0 ? 0 : DEPTH_ANY);\\n        nodes[i].sub_tree_alpha_cnt[nodes[i].label - \\'a\\'] = 1;\\n    }"], ["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n;\\n    int *returnArray = malloc(sizeof(int) * n);\\n    int *count = malloc(sizeof(int) * n);\\n    struct Node **root = malloc(sizeof(struct Node *) * n);\\n    struct Node *curNode;\\n\\n    memset(returnArray, 0, sizeof(int) * n);\\n    memset(count, 0, sizeof(int) * n);\\n\\n    for(i = 0; i < edgesSize; i++)\\n    {\\n        count[edges[i][0]] += 1;\\n        count[edges[i][1]] += 1;\\n    }"], ["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize)\\n{\\n    int* count = calloc(26, sizeof(int));\\n    int* ans = malloc(n * sizeof(int));\\n    *returnSize = n;\\n    int** adj = malloc(n * sizeof(int*));\\n    int* adjSize = calloc(n, sizeof(int));\\n    //dynamically allocate and initialize adjacency list\\n    for(int i = 0; i < n - 1; i++)\\n    {\\n        int a = edges[i][0], b = edges[i][1];\\n        if(adjSize[a] == 0)\\n        {\\n            adjSize[a]++;\\n            adj[a] = malloc(sizeof(int));\\n        }"]]}
{"id": "1919", "ref_c": [["int numMusicPlaylists(int n, int goal, int k) {\\n    long long dp[goal + 1][n + 1];\\n    for (int i = 0; i <= goal; i++) {\\n        for (int j = 0; j <= n; j++) {\\n            dp[i][j] = 0;\\n        }"], ["int numMusicPlaylists(int n, int goal, int k){  \\n    int i,j; /*i is the playlist length, j is the number of songs in playlist*/\\n    long **dp = calloc(goal+1, sizeof(long *)); \\n    for(i = 0; i<=goal; i++) \\n        dp[i] = calloc(n+1,sizeof(long));  \\n\\n    dp[0][0] = 1; /*for a playlist of length 0 with 0 songs only empty playlist made*/\\n\\n    for(i = 1; i<=goal; i++) { \\n        int bound = i < n ? i : n;/*since j is num of songs in playlist, we mustn\\'t \\n        allow it to go above the length of the playlist, or we \\n        must stop it when we have used all n songs. Note that the \\n        repeated song case below handles the entirety of repeating after k songs*/ \\n\\n        /*we start at one since 0,0 has been handled and 1,0 and 0,1 are impossiblilities \\n        and we need to reference previous cell without out of bounds*/ \\n\\n        for(j = 1; j <= (i < n ? i : n); j++) {  \\n            /*we seek to have i,j represent the total possible playlist \\n            we may create of a playlist of i length with j songs \\n            the number of playlists is a functiion of two computations: \\n                - the number of songs left from n (n-(j-1)) if the ith\\n                iteration adds a new song to the list (essentially increasing the \\n                playlist length ads a new song) \\n                - the ith song is a song thats been added already. This only happens  \\n                when the number of songs played, the j variable, is above k \\n            we sum these two computations in the i,j pair\\n            */ \\n            dp[i][j] = (dp[i-1][j-1]*(n-j+1)) % RED;   \\n\\n            if(j > k) { \\n                dp[i][j] = (dp[i][j] + /*current value of i,j*/ \\n                             dp[i-1][j] * /*the number of playlist possible of one length shorter with current song*/ \\n                             (j-k)) /*number of songs before k songs, since we can \\n                             only repeat after k songs played, cannot repeat any of k songs*/ \\n                             % RED;\\n            }", "int numMusicPlaylists(int n, int goal, int k){  \\n    int i,j; /*i is the playlist length, j is the number of songs in playlist*/\\n    long **dp = calloc(goal+1, sizeof(long *)); \\n    for(i = 0; i<=goal; i++) {\\n        dp[i] = calloc(n+1, sizeof(long));  \\n        for(j = 0; j<=n; j++) \\n            dp[i][j] = -1;\\n    }"], ["int numMusicPlaylists(int n, int goal, int k) {\\n        vector<vector<long long>> dp(n + 1, vector<long long>(goal + 1, -1));\\n        return helper(n, goal, k, dp);\\n    }"]]}
{"id": "1920", "ref_c": [["int maxValue(int n, int index, int maxSum) {\\n        int l=1,h=maxSum, res=-1;\\n        while(l<=h)\\n        {\\n            int m=l+(h-l)/2;\\n            if(check(n,index,maxSum,m))\\n            {\\n                res=m;\\n                l=m+1;\\n            }"], ["int maxValue(int n, int index, int maxSum) {\\n    int left = 1, right = maxSum;\\n\\n    while (left <= right) {\\n        int mid = (left + right) / 2;\\n        uint64_t total = mid;\\n\\n        // Calculate the sum of the elements on the left side of the index\\n        uint64_t left_sum = 0;\\n        if((mid - 1) < index){\\n            left_sum = (uint64_t)(mid - 1) * (mid - 1 + 1) / 2 + index - (mid - 1);\\n        }"], ["int maxValue(int n, int index, int maxSum) {\\n        int start = 1, end = maxSum, secondstart = 0, secondend = 0;\\n        if (maxSum == n)\\n            return 1;\\n        long mid = 0, sum = 0, lastmid = 0, secondsum = 0;\\n        while (start < end) {\\n            mid = start + (end - start) / 2;\\n            sum = summ(n, index, mid);\\n            if (sum > maxSum) \\n                end = (int) mid - 1;\\n            else if (sum < maxSum) {\\n                start = (int) mid + 1;\\n                lastmid = mid;\\n                secondsum = sum;\\n            }"]]}
{"id": "1921", "ref_c": [["int* threeEqualParts(int* arr, int arrSize, int* returnSize){\\n\\n    *returnSize = 2;\\n    int i,j,k,number_of_ones,found_bits;\\n    int * breakpoints = malloc(2*sizeof(int));\\n\\n    /* Count number of 1s */\\n    number_of_ones = 0;\\n    k = 0;   // Index\\n    while (k<arrSize) {\\n        number_of_ones += arr[k++];\\n    }"], ["int* threeEqualParts(int* arr, int arrSize, int* returnSize){\\n\\n    *returnSize = 2;\\n    int i,j,k,number_of_ones,found_bits;\\n    int * breakpoints = malloc(2*sizeof(int));\\n\\n    /* Count number of 1s */\\n    number_of_ones = 0;\\n    k = 0;   // Index\\n    while (k<arrSize) {\\n        number_of_ones += arr[k++];\\n    }"], ["int* threeEqualParts(int* arr, int arrSize, int* returnSize){\\n\\n    *returnSize = 2;\\n    int i,j,k,number_of_ones,found_bits;\\n    int * breakpoints = malloc(2*sizeof(int));\\n\\n    /* Count number of 1s */\\n    number_of_ones = 0;\\n    k = 0;   // Index\\n    while (k<arrSize) {\\n        number_of_ones += arr[k++];\\n    }"]]}
{"id": "1922", "ref_c": [["int** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes) {\\n    // Sort the array in ascending order\\n    qsort(arr, arrSize, sizeof(int), compare);\\n\\n    int minDiff = INT_MAX;  // Initialize the minimum absolute difference\\n    int pairCount = 0;      // Count of pairs with the minimum absolute difference\\n\\n    // Find the minimum absolute difference\\n    for (int i = 1; i < arrSize; i++) {\\n        int diff = arr[i] - arr[i - 1];\\n        if (diff < minDiff) {\\n            minDiff = diff;\\n            pairCount = 1;  // Reset the pair count\\n        }"], ["int** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes){\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    int **result = (int **)malloc(arrSize*sizeof(int *));\\n    *returnSize = 0;\\n    int min = INT_MAX;\\n    for(int i = 1; i < arrSize; i++)\\n        min = min < arr[i] - arr[i - 1] ? min : arr[i] - arr[i - 1];\\n    (*returnColumnSizes) = (int *)malloc(arrSize*sizeof(int));\\n    for(int i = 1; i < arrSize; i++)\\n        if(arr[i] - arr[i - 1] == min)\\n        {\\n            (*returnColumnSizes)[*returnSize] = 2;\\n            result[*returnSize] = (int *)malloc(2*sizeof(int));\\n            result[*returnSize][0] = arr[i - 1];\\n            result[(*returnSize)++][1] = arr[i]; \\n        }"], ["int** minimumAbsDifference(int* arr, int arrSize, int* returnSize, int** returnColumnSizes){\\n    qsort(arr, arrSize, sizeof(int), compare);\\n    int len = 0;\\n    int** res = calloc(arrSize, sizeof(int*));\\n    *returnColumnSizes = (int*)malloc(arrSize * sizeof(int));\\n    int diff = INT_MAX;\\n    int refer = INT_MAX;\\n    res[0] = (int*)malloc(2 * sizeof(int));\\n    for(int i = 0; i < arrSize - 1; i++){\\n        if(arr[i + 1] - arr[i] < diff){\\n            diff = arr[i + 1] - arr[i];\\n            len = 1;\\n            res[0][0] = arr[i];\\n            res[0][1] = arr[i + 1];\\n            returnColumnSizes[0][0] = 2;\\n            refer = arr[i];\\n        }"]]}
{"id": "1923", "ref_c": [["int* movesToStamp(char * stamp, char * target, int* returnSize) {\\n\\tint* ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\n\\tconst int stamp_len = (int) strlen(stamp);\\n\\tconst int target_len = (int) strlen(target);\\n\\tint prev_right_end = 0;\\n\\n\\t/* Seach for a full stamp match, from left to right. The target must _finish_ with a full stamp. Thus if we have\\n\\t   a full stamp location, we can search backwards for stamps that lead up to the full stamp(s). */\\n\\tfor (int i = 0; i + stamp_len <= target_len; ) {\\n\\t\\tif (0 == memcmp(target + i, stamp, stamp_len)) {\\n\\t\\t\\tadd_move(&ret, returnSize, &cap, i);\\n\\t\\t\\tif (!expand_out(stamp, stamp_len, target, target_len, &ret, returnSize, &cap, i, &prev_right_end)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}"], ["int* movesToStamp(char * stamp, char * target, int* returnSize) {\\n\\tint* ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\n\\tconst int stamp_len = (int) strlen(stamp);\\n\\tconst int target_len = (int) strlen(target);\\n\\tint prev_right_end = 0;\\n\\n\\t/* Seach for a full stamp match, from left to right. The target must _finish_ with a full stamp. Thus if we have\\n\\t   a full stamp location, we can search backwards for stamps that lead up to the full stamp(s). */\\n\\tfor (int i = 0; i + stamp_len <= target_len; ) {\\n\\t\\tif (0 == memcmp(target + i, stamp, stamp_len)) {\\n\\t\\t\\tadd_move(&ret, returnSize, &cap, i);\\n\\t\\t\\tif (!expand_out(stamp, stamp_len, target, target_len, &ret, returnSize, &cap, i, &prev_right_end)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}"], ["int* movesToStamp(char * stamp, char * target, int* returnSize) {\\n\\tint* ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\n\\tconst int stamp_len = (int) strlen(stamp);\\n\\tconst int target_len = (int) strlen(target);\\n\\tint prev_right_end = 0;\\n\\n\\t/* Seach for a full stamp match, from left to right. The target must _finish_ with a full stamp. Thus if we have\\n\\t   a full stamp location, we can search backwards for stamps that lead up to the full stamp(s). */\\n\\tfor (int i = 0; i + stamp_len <= target_len; ) {\\n\\t\\tif (0 == memcmp(target + i, stamp, stamp_len)) {\\n\\t\\t\\tadd_move(&ret, returnSize, &cap, i);\\n\\t\\t\\tif (!expand_out(stamp, stamp_len, target, target_len, &ret, returnSize, &cap, i, &prev_right_end)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}"]]}
{"id": "1924", "ref_c": [["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize){\\n    if (returnSize == NULL || n == 0 || edges == NULL)\\n        return NULL;\\n \\n    struct node **depths = calloc(n, sizeof(struct node *));\\n    assert(depths);\\n\\n    assert(edgesSize == (n - 1));\\n\\n    struct node *nodes = calloc(n, sizeof(struct node));\\n    assert(nodes != NULL);\\n  \\n    // Allocate results array\\n    int *result = calloc(n, sizeof(int));\\n    assert(result != NULL);\\n \\n    // Apply each node\\'s label and perform some initializations\\n    for (int i = 0; i < n; i++)\\n    {\\n        nodes[i].label = labels[i];\\n        nodes[i].xparent = (struct node *)(i == 0 ? 0x1 : NULL);\\n        /* The root node\\'s depth must always be 0, for the remaining nodes, the\\n         * depth will be determined when the edge array is parsed.\\n         */\\n        nodes[i].depth = (i == 0 ? 0 : DEPTH_ANY);\\n        nodes[i].sub_tree_alpha_cnt[nodes[i].label - \\'a\\'] = 1;\\n    }"], ["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n;\\n    int *returnArray = malloc(sizeof(int) * n);\\n    int *count = malloc(sizeof(int) * n);\\n    struct Node **root = malloc(sizeof(struct Node *) * n);\\n    struct Node *curNode;\\n\\n    memset(returnArray, 0, sizeof(int) * n);\\n    memset(count, 0, sizeof(int) * n);\\n\\n    for(i = 0; i < edgesSize; i++)\\n    {\\n        count[edges[i][0]] += 1;\\n        count[edges[i][1]] += 1;\\n    }"], ["int* countSubTrees(int n, int** edges, int edgesSize, int* edgesColSize, char * labels, int* returnSize)\\n{\\n    int* count = calloc(26, sizeof(int));\\n    int* ans = malloc(n * sizeof(int));\\n    *returnSize = n;\\n    int** adj = malloc(n * sizeof(int*));\\n    int* adjSize = calloc(n, sizeof(int));\\n    //dynamically allocate and initialize adjacency list\\n    for(int i = 0; i < n - 1; i++)\\n    {\\n        int a = edges[i][0], b = edges[i][1];\\n        if(adjSize[a] == 0)\\n        {\\n            adjSize[a]++;\\n            adj[a] = malloc(sizeof(int));\\n        }"]]}
{"id": "1925", "ref_c": [["int countCompleteSubarrays(int* nums, int numsSize) {\\n    int hash[2001] = {0}"], ["int countCompleteSubarrays(int* nums, int numsSize){\\n    // First, we count the number of distinct elements\\n    int totalDistinctElements = 0;\\n    int elements[2001] = {0}"], ["int countCompleteSubarrays(int* nums, int numsSize) {\\n    int hash[2001] = {0}"]]}
{"id": "1926", "ref_c": [["int largestComponentSize(int* nums, int numsSize){\\n    int temp[100001] = {0}"], ["int largestComponentSize(int* nums, int numsSize){\\n    int temp[100001] = {0}"], ["int largestComponentSize(int* nums, int numsSize){\\n    int temp[100001] = {0}"]]}
{"id": "1927", "ref_c": [["int tallestBillboard(int* rods, int rodsSize){\\n    int sum = 0;\\n    for(int i = 0; i < rodsSize; ++i){\\n        sum += rods[i];\\n    }"], ["int tallestBillboard(int* rods, int rodsSize) {\\n    int n = rodsSize;\\n    int sum = 0;\\n    for (int i = 0; i < n; i++) {\\n        sum += rods[i];\\n    }"], ["int tallestBillboard(int* rods, int rodsSize){\\n    int sum;\\n    for(int i = 0 ; i < rodsSize; i++){\\n        sum += rods[i];\\n    }"]]}
{"id": "1928", "ref_c": [["int* twoSum(int* nums, int numsSize, int target, int* returnSize){\\n\\n*returnSize=2;// der zu returnende array hat 2 elemente\\n\\nint *array = malloc(2*sizeof(int) ); // Output array max 2 elemente\\n\\nfor (int i=0; i<numsSize;i++)\\n{\\n    for( int j=1+i;j<numsSize;j++)\\n    {\\n        if(nums[i] + nums[j] == target)\\n        {\\n        array[0]=i;\\n        array[1]=j;\\n        return array;\\n        }"], ["int* twoSum(int* nums, int numsSize, int target, int* returnSize) {\\n    int* result = (int*)malloc(2 * sizeof(int)); // Allocate memory for the result array\\n    if (result == NULL) {\\n        *returnSize = 0;\\n        return NULL; // Return NULL if memory allocation fails\\n    }"], ["int* twoSum(int* nums, int numsSize, int target, int* returnSize){\\n\\n*returnSize=2;// der zu returnende array hat 2 elemente\\n\\nint *array = malloc(2*sizeof(int) ); // Output array max 2 elemente\\n\\nfor (int i=0; i<numsSize;i++)\\n{\\n    for( int j=1+i;j<numsSize;j++)\\n    {\\n        if(nums[i] + nums[j] == target)\\n        {\\n        array[0]=i;\\n        array[1]=j;\\n        return array;\\n        }"]]}
{"id": "1929", "ref_c": ["\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n", "\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n", "\nchar * removeDuplicateLetters(const char * const str){\n\tint lastIdxs[26];\n\tmemset( &lastIdxs, -1, sizeof (lastIdxs) );\n\tfor (int i = 0; str[i] != '\u0000'; i += 1){\n\t\tassert(str[i] >= 'a' && str[i] <= 'z');\n\t\tlastIdxs[str[i] - 'a'] = i;\n\t}\n\n\tint typeCnt = 0;\n\tfor (int i = 0; i < 26; i += 1){\n\t\tif (lastIdxs[i] != -1){\n\t\t\ttypeCnt += 1;\n\t\t}\n\t}\n\tassert(typeCnt > 0);\n\n\tchar * const ret = (char *)malloc( sizeof (char) * (typeCnt + 1) );\n\tint retLen = 0;\n\n\tbool visiteds[26];\n\tmemset( &visiteds, 0, sizeof (visiteds) );\n\tfor (int i = 0; 1; ){\n\t\twhile (visiteds[str[i] - 'a']){\n\t\t\ti += 1;\n\t\t}\n\n\t\twhile (\n\t\t\tretLen > 0 &&\n\t\t\tret[retLen - 1] > str[i] &&\n\t\t\tlastIdxs[ret[retLen - 1] - 'a'] > i\n\t\t){\n\t\t\tvisiteds[ret[retLen - 1] - 'a'] = false;\n\t\t\tretLen -= 1;\n\t\t}\n\n\t\tvisiteds[str[i] - 'a'] = true;\n\t\tret[retLen] = str[i];\n\t\tretLen += 1;\n\t\tif (retLen == typeCnt){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret[retLen] = '\u0000';\n\treturn ret;\n}\n"]}
{"id": "1930", "ref_c": [["int minCameraCover(struct TreeNode* root){\\n    int count = 0;\\n    if(dfs(root, &count) == 0) count++;\\n    return count;\\n}"], ["int minCameraCover(struct TreeNode* root){\\n    int count = 0;\\n    if(dfs(root, &count) == 0) count++;\\n    return count;\\n}"], ["int minCameraCover(struct TreeNode* root){\\n    int* n = calloc(1, sizeof(int));\\n    if(status(root, n) == 0){\\n        *n += 1;\\n    }"]]}
{"id": "1931", "ref_c": [["bool isRationalEqual(char * s, char * t){\\n    if (*s==\\'1\\' && *t==\\'9\\') goto edgeCaseSkip;//ie: 1000 and 999.(9)\\n    else if (*t==\\'1\\' && *s==\\'9\\'){//same thing, but swap s and t first\\n        char* temp = s;\\n        s=t;\\n        t=temp;\\n        goto edgeCaseSkip;\\n    }"], ["bool isRationalEqual(char * s, char * t){\\n    if (*s==\\'1\\' && *t==\\'9\\') goto edgeCaseSkip;//ie: 1000 and 999.(9)\\n    else if (*t==\\'1\\' && *s==\\'9\\'){//same thing, but swap s and t first\\n        char* temp = s;\\n        s=t;\\n        t=temp;\\n        goto edgeCaseSkip;\\n    }"], ["bool isRationalEqual(char * s, char * t){\\n    if (*s==\\'1\\' && *t==\\'9\\') goto edgeCaseSkip;//ie: 1000 and 999.(9)\\n    else if (*t==\\'1\\' && *s==\\'9\\'){//same thing, but swap s and t first\\n        char* temp = s;\\n        s=t;\\n        t=temp;\\n        goto edgeCaseSkip;\\n    }"]]}
{"id": "1932", "ref_c": [["int maxChunksToSorted(int* arr, int arrSize){\\n    int max=0,chunk=0;\\n    for(int i=0;i<arrSize;i++)\\n    {    max=(max<arr[i])?arr[i]:max;        \\n        if(i==max) chunk++;    }"], ["int maxChunksToSorted(int* arr, int arrSize){\\n    int max=0,chunk=0;\\n    for(int i=0;i<arrSize;i++)\\n    {    max=(max<arr[i])?arr[i]:max;        \\n        if(i==max) chunk++;    }"], ["int maxChunksToSorted(int* arr, int arrSize){\\n    int max=0,chunk=0;\\n    for(int i=0;i<arrSize;i++)\\n    {    max=(max<arr[i])?arr[i]:max;        \\n        if(i==max) chunk++;    }"]]}
{"id": "1933", "ref_c": [["int uniquePathsIII(int** grid, int gridSize, int* gridColSize){\\n    int startRow = 0, startCol = 0;\\n    int spaces = 1;\\n    int rLimit = gridSize - 1;\\n    int cLimit = *gridColSize - 1;\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j] == 1) {\\n                startRow = i;\\n                startCol = j;\\n            }"], ["int uniquePathsIII(int** grid, int gridSize, int* gridColSize){\\n\\n    /*\\n     * Input:\\n     *  grid,\\n     *  gridSize,\\n     *  gridColSize\\n     */\\n\\n    int x, y, non_empty = 0;\\n\\n    /* \\n     * Find the position of starting square, and total number\\n     * of non empty squares\\n     */\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[0]; j++) {\\n            if (grid[i][j] == 0) {\\n                non_empty++;\\n            }"], ["int uniquePathsIII(int** grid, int gridSize, int* gridColSize) {\\n    uint64_t visited[MAX_ALLOC];  // visited mask\\n    uint8_t cr[MAX_ALLOC];\\n    uint8_t cc[MAX_ALLOC];\\n    int nr = gridSize;\\n    int nc = *gridColSize;\\n    int x = 0;  // Finished path count\\n    int y = 0;  // Possible path insert index\\n\\n    visited[0] = 0;\\n\\n    // Find the start and add obstacles\\n    for (int r = 0; r < nr; ++r) {\\n        for (int c = 0; c < nc; ++c) {\\n            if (grid[r][c] == 1)  { see(&visited[0], bit(r, c, nr, nc)); cr[0] = r; cc[0] = c; }"]]}
{"id": "1934", "ref_c": [["char ** simplifiedFractions(int n, int* returnSize){\\n    char ** res = (char **) malloc(MAX_FRACTIONS * sizeof(char *));\\n    int ptr = 0;\\n\\n    for (int nom = 1; nom <= n; nom++) {\\n        for (int den = 1; den <= n; den++) {\\n            // continue if:\\n            //   - fraction is top heavy\\n            //   - numerator is equal to the denominator\\n            //   - greatest common divisor is not 1 (can be simplified)\\n            if (nom >= den || gcd(nom, den) != 1) {\\n                continue;\\n            }"], ["char ** simplifiedFractions(int n, int* returnSize){\\n    char ** res = (char **) malloc(MAX_FRACTIONS * sizeof(char *));\\n    int ptr = 0;\\n\\n    for (int nom = 1; nom <= n; nom++) {\\n        for (int den = 1; den <= n; den++) {\\n            // continue if:\\n            //   - fraction is top heavy\\n            //   - numerator is equal to the denominator\\n            //   - greatest common divisor is not 1 (can be simplified)\\n            if (nom >= den || gcd(nom, den) != 1) {\\n                continue;\\n            }"], ["char ** simplifiedFractions(int n, int* returnSize){\\n    char ** res = (char **) malloc(MAX_FRACTIONS * sizeof(char *));\\n    int ptr = 0;\\n\\n    for (int nom = 1; nom <= n; nom++) {\\n        for (int den = 1; den <= n; den++) {\\n            // continue if:\\n            //   - fraction is top heavy\\n            //   - numerator is equal to the denominator\\n            //   - greatest common divisor is not 1 (can be simplified)\\n            if (nom >= den || gcd(nom, den) != 1) {\\n                continue;\\n            }"]]}
{"id": "1935", "ref_c": [["int** verticalTraversal(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {\\n  /* Get all the nodes and sort assendingly via col, row, val */\\n  struct Value* values = NULL;\\n  size_t values_size = 0;\\n  size_t values_cap = 0;\\n  vertical_traversal_helper(root, 0, 0, &values, &values_size, &values_cap);\\n  qsort(values, values_size, sizeof(struct Value), &value_cmp);\\n  \\n  /* Extract the single array into multiple arrays of variable lengths */\\n  int** ret = NULL;\\n  *returnColumnSizes = NULL;\\n  *returnSize = -1;\\n  size_t cap = 0;\\n  size_t sub_cap = 0;\\n  int prev_col = INT_MIN;\\n  for (size_t i = 0; i < values_size; ++i) {\\n    if (values[i].col != prev_col) {\\n      ++(*returnSize);\\n      \\n      /* Resize the base array of arrays if required */\\n      if (*returnSize == cap) {\\n        cap = (cap) ? cap * 2 : 4;\\n        ret = realloc(ret, cap * sizeof(int*));\\n        *returnColumnSizes = realloc(*returnColumnSizes, cap * sizeof(int));\\n      }"], ["int** verticalTraversal(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {\\n    top=pri=dep=0;\\n    minPri=1010;\\n    maxPri=-1010;\\n    dfs(root);\\n    qsort(b,top,sizeof(struct node),com);\\n    int**ret= malloc((maxPri-minPri+1)*sizeof(int*));\\n    *returnSize=maxPri-minPri+1;\\n    int* sizes = malloc((maxPri-minPri+1)*sizeof(int));\\n    *returnColumnSizes=sizes;\\n\\n    int index=-1;\\n    for (int i=0;i<top;i++)\\n    {\\n        if (i==0||b[i].pri!=b[i-1].pri) {index++;sizes[index]=1;}"], ["int** verticalTraversal(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {\\n    top=pri=dep=0;\\n    minPri=1010;\\n    maxPri=-1010;\\n    dfs(root);\\n    qsort(b,top,sizeof(struct node),com);\\n    int**ret= malloc((maxPri-minPri+1)*sizeof(int*));\\n    *returnSize=maxPri-minPri+1;\\n    int* sizes = malloc((maxPri-minPri+1)*sizeof(int));\\n    *returnColumnSizes=sizes;\\n\\n    int index=-1;\\n    for (int i=0;i<top;i++)\\n    {\\n        if (i==0||b[i].pri!=b[i-1].pri) {index++;sizes[index]=1;}"]]}
{"id": "1936", "ref_c": [["int* pathInZigZagTree(int label, int* returnSize){\\n    int row=0,power=1;\\n    while(power<=label){\\n        row++;\\n        power*=2;\\n    }"], ["int* pathInZigZagTree(int label, int* returnSize)\\n{\\n    \\n    int label_level = find_row(label);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * label_level);\\n    int ret_arr_index;\\n     *returnSize = label_level;\\n    int row_size = label_level;\\n    \\n    ret_arr[ret_arr_index++] = label;\\n    \\n    if(label == 1)\\n    {\\n        return ret_arr;\\n    }"], ["int* pathInZigZagTree(int label, int* returnSize){\\n    int row=0,power=1;\\n    while(power<=label){\\n        row++;\\n        power*=2;\\n    }"]]}
{"id": "1937", "ref_c": [["int smallestRangeI(int* nums, int numsSize, int k)\\n{\\n    int max = INT_MIN;\\n    int min = INT_MAX;\\n    int ret = 0;\\n    int i=0;\\n    for(i=0; i<numsSize; i++)\\n    {\\n        if(nums[i] <= min)\\n        {\\n            min = nums[i];\\n        }"], ["int smallestRangeI(int* nums, int numsSize, int k) {\\n    int min = nums[0], max = nums[0];\\n    for (int i = 1; i < numsSize; i++) {\\n        min = MIN(min, nums[i]);\\n        max = MAX(max, nums[i]);\\n    }"], ["int smallestRangeI(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    if((nums[numsSize-1] - nums[0]) > 2*k){ return (nums[numsSize-1] - nums[0] - 2*k); }", "int smallestRangeI(int* nums, int numsSize, int k){\\n    int minValue = INT_MAX, maxValue = INT_MIN;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        minValue = MIN(minValue, nums[i]);\\n        maxValue = MAX(maxValue, nums[i]);\\n    }"]]}
{"id": "1938", "ref_c": [["int** updateMatrix(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){\\n    /*\\n     * Input:\\n     *  **mat,\\n     *  matSize\\n     *  matColSize\\n     */\\n    \\n    //  0   0   0\\n    //  0   1   0\\n    //  0   0   0   \\n    //\\n    //\\n    // start from \"0\" cells\\n    // in each recursive function call\\n    //  (1) Get the x, y, and distance of cells\\n    //  (2) Reset the distance if cell equals 0\\n    //  (3) Store the x, y of adjacent element, and increase the distance\\n    //  (4) Enter next recursive function\\n    //  (5) Exit from recursive function when all the elements are visited\\n    //\\n    //  1   1   1       1   1   1       1   1   0       1   0   0       0   0   0\\n    //  1   1   1   =>  1   1   0   =>  1   0   0   =>  0   0   0   =>  0   0   0\\n    //  1   1   0       1   0   0       0   0   0       0   0   0       0   0   0\\n    //\\n\\n    int **ans = (int **)malloc(sizeof(int *) * matSize);\\n    bool **visited = (bool **)malloc(sizeof(bool *) * matSize);\\n\\n    *returnSize = matSize;\\n    *returnColumnSizes = (int *)malloc(sizeof(int) * matSize);\\n\\n    for (int i = 0; i < matSize; i++) {\\n        ans[i] = (int *)malloc(sizeof(int) * matColSize[0]);\\n        visited[i] = (bool *)calloc(1, sizeof(bool) * matColSize[0]);\\n        (*returnColumnSizes)[i] = matColSize[i];\\n    }"], ["int** updateMatrix(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = matSize;\\n    returnColumnSizes[0] = malloc(sizeof(int*) * matSize);\\n    int **distance = malloc(matSize * matColSize[0] * sizeof(int*));\\n    for (int i = 0; i < matSize; i++) {\\n        distance[i] = malloc(*matColSize * sizeof(int));\\n        returnColumnSizes[0][i] = *matColSize;\\n    }"], ["int** updateMatrix(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes){\\n    /*\\n     * Input:\\n     *  **mat,\\n     *  matSize\\n     *  matColSize\\n     */\\n    \\n    //  0   0   0\\n    //  0   1   0\\n    //  0   0   0   \\n    //\\n    //\\n    // start from \"0\" cells\\n    // in each recursive function call\\n    //  (1) Get the x, y, and distance of cells\\n    //  (2) Reset the distance if cell equals 0\\n    //  (3) Store the x, y of adjacent element, and increase the distance\\n    //  (4) Enter next recursive function\\n    //  (5) Exit from recursive function when all the elements are visited\\n    //\\n    //  1   1   1       1   1   1       1   1   0       1   0   0       0   0   0\\n    //  1   1   1   =>  1   1   0   =>  1   0   0   =>  0   0   0   =>  0   0   0\\n    //  1   1   0       1   0   0       0   0   0       0   0   0       0   0   0\\n    //\\n\\n    int **ans = (int **)malloc(sizeof(int *) * matSize);\\n    bool **visited = (bool **)malloc(sizeof(bool *) * matSize);\\n\\n    *returnSize = matSize;\\n    *returnColumnSizes = (int *)malloc(sizeof(int) * matSize);\\n\\n    for (int i = 0; i < matSize; i++) {\\n        ans[i] = (int *)malloc(sizeof(int) * matColSize[0]);\\n        visited[i] = (bool *)calloc(1, sizeof(bool) * matColSize[0]);\\n        (*returnColumnSizes)[i] = matColSize[i];\\n    }"]]}
{"id": "1939", "ref_c": [["int mergeStones(int* stones, int stonesSize, int k){   \\n    /* Each merge reduces the length by k-1. After first merge,\\n     * length is stonesSize - (k-1) After second, length is stonesSize - (k-1) - (k-1).\\n     * After m merges, length = stonesSize - (m * (k-1) ) = 1 \\n     * => stonesSize - 1 = multiple of k-1   \\n     */\\n    if ((stonesSize - 1) % (k - 1) != 0)\\n        return -1;\\n    \\n    int sum = 0;\\n    int i;\\n    int j;\\n    int dp[MAXCOUNT][MAXCOUNT] = {0}"], ["int mergeStones(int* stones, int stonesSize, int k){   \\n    /* Each merge reduces the length by k-1. After first merge,\\n     * length is stonesSize - (k-1) After second, length is stonesSize - (k-1) - (k-1).\\n     * After m merges, length = stonesSize - (m * (k-1) ) = 1 \\n     * => stonesSize - 1 = multiple of k-1   \\n     */\\n    if ((stonesSize - 1) % (k - 1) != 0)\\n        return -1;\\n    \\n    int sum = 0;\\n    int i;\\n    int j;\\n    int dp[MAXCOUNT][MAXCOUNT] = {0}"], ["int mergeStones(int* stones, int stonesSize, int k){   \\n    /* Each merge reduces the length by k-1. After first merge,\\n     * length is stonesSize - (k-1) After second, length is stonesSize - (k-1) - (k-1).\\n     * After m merges, length = stonesSize - (m * (k-1) ) = 1 \\n     * => stonesSize - 1 = multiple of k-1   \\n     */\\n    if ((stonesSize - 1) % (k - 1) != 0)\\n        return -1;\\n    \\n    int sum = 0;\\n    int i;\\n    int j;\\n    int dp[MAXCOUNT][MAXCOUNT] = {0}"]]}
{"id": "1940", "ref_c": [["int dominantIndex(int* nums, int numsSize){\\n    int max = INT_MIN, secondMax = INT_MIN, maxIndex = -1;\\n    for(int i = 0; i < numsSize; i++) {\\n        if(nums[i] > max) {\\n            secondMax = max;\\n            max = nums[i];\\n            maxIndex = i;\\n        }"], ["int dominantIndex(int* nums, int numsSize){\\n    int max = INT_MIN, secondMax = INT_MIN, maxIndex = -1;\\n    for(int i = 0; i < numsSize; i++) {\\n        if(nums[i] > max) {\\n            secondMax = max;\\n            max = nums[i];\\n            maxIndex = i;\\n        }"], ["int dominantIndex(int* nums, int numsSize){\\n    int max = INT_MIN, secondMax = INT_MIN, maxIndex = -1;\\n    for(int i = 0; i < numsSize; i++) {\\n        if(nums[i] > max) {\\n            secondMax = max;\\n            max = nums[i];\\n            maxIndex = i;\\n        }"]]}
{"id": "1941", "ref_c": [["int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof dp);\\n        return n - f(s, s.size(), 1, 0, 1);\\n    }"], ["int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof dp);\\n        return n - f(s, s.size(), 1, 0, 1);\\n    }"], ["int numDupDigitsAtMostN(int n){\\n    const int origN = n;\\n    const int origNumDigits = numberOfDigits(n);\\n    \\n    bool highUsed[10] = { false }"]]}
{"id": "1942", "ref_c": [["struct TreeNode* recoverFromPreorder(char * traversal){\\n    STR = traversal;\\n    return getNode(1); \\n}"], ["struct TreeNode* recoverFromPreorder(char * traversal){\\n    struct TreeNode *root = NULL;\\n    int len=strlen(traversal);\\n    if(len==0) return root;\\n    int index=0;\\n    return dfs(&index,0,traversal,len);;\\n}"], ["struct TreeNode* recoverFromPreorder(char * traversal){\\n    struct TreeNode *root = NULL;\\n    int len=strlen(traversal);\\n    if(len==0) return root;\\n    int index=0;\\n    return dfs(&index,0,traversal,len);;\\n}"]]}
{"id": "1944", "ref_c": [["int minimumPartition(char * s, int k){\\n    int idx = 0, len = strlen(s), ans = 0;\\n    long prev = 0, curr = 0;\\n    while(idx < len){\\n        prev = curr;\\n        curr *= 10;\\n        curr += (s[idx] - \\'0\\');\\n        if(curr > k){\\n            ans++;\\n            curr = (s[idx] - \\'0\\');\\n            if(prev > k || !prev)\\n                return -1;\\n        }"], ["int minimumPartition(char * s, int k){\\n    int idx = 0, len = strlen(s), ans = 0;\\n    long prev = 0, curr = 0;\\n    while(idx < len){\\n        prev = curr;\\n        curr *= 10;\\n        curr += (s[idx] - \\'0\\');\\n        if(curr > k){\\n            ans++;\\n            curr = (s[idx] - \\'0\\');\\n            if(prev > k || !prev)\\n                return -1;\\n        }"], ["int minimumPartition(char * s, int k){\\n    int idx = 0, len = strlen(s), ans = 0;\\n    long prev = 0, curr = 0;\\n    while(idx < len){\\n        prev = curr;\\n        curr *= 10;\\n        curr += (s[idx] - \\'0\\');\\n        if(curr > k){\\n            ans++;\\n            curr = (s[idx] - \\'0\\');\\n            if(prev > k || !prev)\\n                return -1;\\n        }"]]}
{"id": "1945", "ref_c": [["char * longestDupSubstring(char * s){\\n    char* ans = NULL;\\n    char* tmp;\\n    int len = strlen(s);\\n    int l = 1;\\n    int r = len-1;\\n    int m;\\n    while (l <= r) {\\n        m = l+(r-l)/2;\\n        tmp = check(s, len, m);\\n        if (tmp == NULL) {\\n            r = m-1;\\n        }"], ["char * longestDupSubstring(char * s){\\n    char* ans = NULL;\\n    char* tmp;\\n    int len = strlen(s);\\n    int l = 1;\\n    int r = len-1;\\n    int m;\\n    while (l <= r) {\\n        m = l+(r-l)/2;\\n        tmp = check(s, len, m);\\n        if (tmp == NULL) {\\n            r = m-1;\\n        }"], ["char * longestDupSubstring(char * s){\\n    char* ans = NULL;\\n    char* tmp;\\n    int len = strlen(s);\\n    int l = 1;\\n    int r = len-1;\\n    int m;\\n    while (l <= r) {\\n        m = l+(r-l)/2;\\n        tmp = check(s, len, m);\\n        if (tmp == NULL) {\\n            r = m-1;\\n        }"]]}
{"id": "1946", "ref_c": [["int numSubmatrixSumTarget(int** matrix, int matrixSize, int* matrixColSize, int target){\\n\\tint ret = 0, sum;\\n\\tint prefixSum[matrixSize + 1][matrixColSize[0]];\\n\\t\\n    for (int i = 0; i < matrixSize; i++)\\n\\t\\tfor (int j = 0; j < matrixColSize[0]; j++)\\n\\t\\t\\tprefixSum[i + 1][j] = prefixSum[i][j] + matrix[i][j];\\n\\n\\tfor (int i = 0; i < matrixSize; i++) {\\n\\t\\tfor (int j = i + 1; j <= matrixSize; j++) {\\n\\t\\t\\tfor (int k = 0; k < matrixColSize[0]; k++) {\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\tfor (int l = k; l < matrixColSize[0]; l++) {\\n\\t\\t\\t\\t\\tsum += prefixSum[j][l] - prefixSum[i][l];\\n\\t\\t\\t\\t\\tif (sum == target){\\n\\t\\t\\t\\t\\t\\tret++;\\n\\t\\t\\t\\t\\t}"], ["int numSubmatrixSumTarget(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    int** list = malloc(sizeof(int*)*matrixSize);\\n    for (int i = 0 ; i < matrixSize ; i++){\\n        list[i] = calloc((*matrixColSize),sizeof(int));\\n    }"], ["int numSubmatrixSumTarget(int** matrix, int matrixSize, int* matrixColSize, int target){\\n\\tint ret = 0, sum;\\n\\tint prefixSum[matrixSize + 1][matrixColSize[0]];\\n\\t\\n    for (int i = 0; i < matrixSize; i++)\\n\\t\\tfor (int j = 0; j < matrixColSize[0]; j++)\\n\\t\\t\\tprefixSum[i + 1][j] = prefixSum[i][j] + matrix[i][j];\\n\\n\\tfor (int i = 0; i < matrixSize; i++) {\\n\\t\\tfor (int j = i + 1; j <= matrixSize; j++) {\\n\\t\\t\\tfor (int k = 0; k < matrixColSize[0]; k++) {\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\tfor (int l = k; l < matrixColSize[0]; l++) {\\n\\t\\t\\t\\t\\tsum += prefixSum[j][l] - prefixSum[i][l];\\n\\t\\t\\t\\t\\tif (sum == target){\\n\\t\\t\\t\\t\\t\\tret++;\\n\\t\\t\\t\\t\\t}"]]}
{"id": "1947", "ref_c": [["char * shortestCommonSupersequence(char * str1, char * str2){\\n    int maxOvl = min(strlen(str1), strlen(str2));\\n    \\n    for(int length=maxOvl; length>0; length--){\\n        if(commonSequence(str1, str2, length)){\\n            return returnString(str1, str2, length);\\n        }"], ["char * shortestCommonSupersequence(char * str1, char * str2){\\n    int len1 = strlen(str1), len2 = strlen(str2);\\n    struct letters** list = malloc(sizeof(struct letters*)*(len1+1));\\n    for (int i = 0 ; i < len1 ; i++){\\n        list[i] = calloc((len2+1), sizeof(struct letters)); //\\u5C07\\u521D\\u59CB\\u8A2D\\u70BA0 0\\u5C31\\u4EE3\\u8868\\u9084\\u6C92\\u6AA2\\u67E5\\u904E\\n        list[i][len2].len = len1-i+1;                       //\\u525B\\u597D\\u6B64\\u6642\\u7684att\\u4E5F\\u662F0 \\u6240\\u4EE5\\u4E0D\\u7528\\u52A0\\u4EE5\\u4FEE\\u6539\\n    }"], ["char * shortestCommonSupersequence(char * str1, char * str2){\\n    int maxOvl = min(strlen(str1), strlen(str2));\\n    \\n    for(int length=maxOvl; length>0; length--){\\n        if(commonSequence(str1, str2, length)){\\n            return returnString(str1, str2, length);\\n        }"]]}
{"id": "1948", "ref_c": [["int findInMountainArray(int target, MountainArray* mountainArr) {\\n    // Binary Search\\n    // 1. Find the peak index of the mountain array using binary search.\\n    // 2. Perform two binary searches in two sorted subarrays (ascending one and descending one)\\n\\n    // Time complexity: O(logn)\\n    // Space complexity: O(1)\\n\\n    const int n = length(mountainArr);\\n    int middle = 0, left = 0, right = n - 1, peak = -1;\\n    while (left < right) {\\n        middle = left + (right - left) / 2;\\n        if (get(mountainArr, middle) < get(mountainArr, middle + 1)) {\\n            left = middle + 1;\\n        }"], ["int findInMountainArray(int target, MountainArray* mountainArr) {\\n    int len = length(mountainArr), l = 0, r = len - 1;\\n    \\n    while (l < r){\\n        int mid = (l + r) >> 1;\\n        if (get(mountainArr, mid) < get(mountainArr, mid + 1))\\n            l = mid + 1;\\n        else\\n            r = mid;\\n    }"], ["int findInMountainArray(int target, MountainArray* mountainArr) {\\n    int n = length(mountainArr);\\n    if (n < 3)\\n        return -1;\\n\\n    // 1. Find Peak Element.\\n    int part = peak(mountainArr, n);\\n\\n    // 2. Left side search.\\n    int l = bs(0, part, mountainArr, target, 0);\\n\\n    // If the element is present on the left side array.\\n    if (l != -1)\\n        return l;\\n\\n    // If the element is not present on the left, then do the right search.\\n    int r = bs(part, n - 1, mountainArr, target, 1);\\n    return r;\\n}"]]}
{"id": "1949", "ref_c": [["char ** braceExpansionII(char * expression, int* returnSize){\\n    int len = strlen(expression);\\n    int ans_len[4097] = {0}"], ["char ** braceExpansionII(char * expression, int* returnSize){\\n    int len = strlen(expression);\\n    int ans_len[4097] = {0}"], ["char ** braceExpansionII(char * expression, int* returnSize){\\n    int len = strlen(expression);\\n    int ans_len[4097] = {0}"]]}
{"id": "1950", "ref_c": [["int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false}"], ["int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false}"], ["int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false}"]]}
{"id": "1951", "ref_c": [["int* smallestSufficientTeam(char ** req_skills, int req_skillsSize, char *** people, int peopleSize, int* peopleColSize, int* returnSize){\\n    /*\\n     * Input:\\n     *  req_skills,\\n     *  req_skillsSize,\\n     *  people,\\n     *  peopleSize\\n     *  peopleColSize, \\n     */\\n    \\n    node_t trie;\\n    unsigned short team_skill = {0}"], ["int* smallestSufficientTeam(char ** req_skills, int req_skillsSize, char *** people, int peopleSize, int* peopleColSize, int* returnSize){\\n    /*\\n     * Input:\\n     *  req_skills,\\n     *  req_skillsSize,\\n     *  people,\\n     *  peopleSize\\n     *  peopleColSize, \\n     */\\n    \\n    node_t trie;\\n    unsigned short team_skill = {0}"], ["int* smallestSufficientTeam(char ** req_skills, int req_skillsSize, char *** people, int peopleSize, int* peopleColSize, int* returnSize){\\n    /*\\n     * Input:\\n     *  req_skills,\\n     *  req_skillsSize,\\n     *  people,\\n     *  peopleSize\\n     *  peopleColSize, \\n     */\\n    \\n    node_t trie;\\n    unsigned short team_skill = {0}"]]}
{"id": "1952", "ref_c": [["int minimumSize(int* nums, int numsSize, int maxOperations){\\n    int l=1, r=0, m;\\n    for(int i=0;i<numsSize;i++){\\n        r=max(r,nums[i]);\\n    }"], ["int minimumSize(int* nums, int numsSize, int maxOperations){\\n    int l=1, r=0, m;\\n    for(int i=0;i<numsSize;i++){\\n        r=max(r,nums[i]);\\n    }"], ["int minimumSize(int* nums, int numsSize, int maxOperations){\\n    int l=1, r=0, m;\\n    for(int i=0;i<numsSize;i++){\\n        r=max(r,nums[i]);\\n    }"]]}
{"id": "1954", "ref_c": [["char * lastSubstring(char * s){\\n    int n= strlen(s);\\n    int maxIndex = n - 1;\\n\\n        for (int k = n - 1; k >= 0; k--){\\n            if (s[k] > s[maxIndex])\\n                maxIndex = k;\\n\\n            else if (s[k] == s[maxIndex]){\\n                int i = k + 1;\\n                int j = maxIndex + 1;\\n\\n                while (i < maxIndex && j < n && s[i] == s[j]){\\n                    i++;\\n                    j++;\\n                }"], ["char * lastSubstring(char * s){\\n    int n= strlen(s);\\n    int maxIndex = n - 1;\\n\\n        for (int k = n - 1; k >= 0; k--){\\n            if (s[k] > s[maxIndex])\\n                maxIndex = k;\\n\\n            else if (s[k] == s[maxIndex]){\\n                int i = k + 1;\\n                int j = maxIndex + 1;\\n\\n                while (i < maxIndex && j < n && s[i] == s[j]){\\n                    i++;\\n                    j++;\\n                }"], ["char * lastSubstring(char * s) {\\n    char *sl = s, *sr = s + 1;\\n\\t// compare 2 subsrings, left and right, starting from the beggining of the initial string\\n\\t// left subsring should become the greatest\\n    for (int k = 0; ; ++sr, k = 0) {    // increment pointer of right substring\\n        for (; sl[k] == sr[k]; ++k);    // increment k, until symbols match\\n        if (sr[k] == 0) break;          // end of the initial string, return\\n        if (sl[k] < sr[k]) sl = sr;     // right substing is greater, assign to the left\\n    }"]]}
{"id": "1956", "ref_c": [["int* findNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int* returnSize){\\n    *returnSize = puzzlesSize;\\n    int *ret = (int *)malloc(sizeof(int)**returnSize);\\n    uint32_t *bitmap_p = (int *)malloc(sizeof(uint32_t)*puzzlesSize);\\n    for(int i=0; i < puzzlesSize ; i++)\\n    {\\n        ret[i] = 0;\\n        bitmap_p[i] = (1U<<puzzles[i][0]-\\'a\\') | (1U<<puzzles[i][1]-\\'a\\') | (1U<<puzzles[i][2]-\\'a\\') | (1U<<puzzles[i][3]-\\'a\\') | (1U<<puzzles[i][4]-\\'a\\') | (1U<<puzzles[i][5]-\\'a\\') | (1U<<puzzles[i][6]-\\'a\\') | ((puzzles[i][0]-\\'a\\')<<26);\\n    }"], ["int* findNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int* returnSize){\\n    int * result = (int *)calloc(puzzlesSize, sizeof(int));\\n    int * freq = (int *)calloc(68000000, sizeof(int));\\n    for(int i=0; i<wordsSize; i++)\\n    {\\n        int temp = 0, count = 0;\\n        for(int j=0; j<strlen(words[i]); j++)\\n        {\\n            int bit = (1 << (int)(words[i][j] - \\'a\\'));\\n            if(temp & bit) continue;\\n            count++;\\n            if(count > 7) break;\\n            temp |= (1 << (int)(words[i][j] - \\'a\\'));\\n        }"], ["int* findNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int* returnSize){\\n    int * result = (int *)calloc(puzzlesSize, sizeof(int));\\n    int * freq = (int *)calloc(68000000, sizeof(int));\\n    for(int i=0; i<wordsSize; i++)\\n    {\\n        int temp = 0, count = 0;\\n        for(int j=0; j<strlen(words[i]); j++)\\n        {\\n            int bit = (1 << (int)(words[i][j] - \\'a\\'));\\n            if(temp & bit) continue;\\n            count++;\\n            if(count > 7) break;\\n            temp |= (1 << (int)(words[i][j] - \\'a\\'));\\n        }"]]}
{"id": "1957", "ref_c": [["int makeArrayIncreasing(int* arr1, int arr1Size, int* arr2, int arr2Size){\\n    if (arr1Size == 1){\\n        return 0;\\n    }"], ["int makeArrayIncreasing(int* arr1, int arr1Size, int* arr2, int arr2Size){\\n    if (arr1Size == 1){\\n        return 0;\\n    }"], ["int makeArrayIncreasing(int* arr1, int arr1Size, int* arr2, int arr2Size){\\n    if (arr1Size == 1){\\n        return 0;\\n    }"]]}
{"id": "1958", "ref_c": [["int** criticalConnections(int n, int** connections, int connectionsSize, int* connectionsColSize, int* returnSize, int** returnColumnSizes){\\n\\n}"], ["int** criticalConnections(int n, int** connections, int connectionsSize, int* connectionsColSize, int* returnSize, int** returnColumnSizes){\\n\\n}"], ["int** criticalConnections(int n, int** connections, int connectionsSize, int* connectionsColSize, int* returnSize, int** returnColumnSizes){\\n\\n}"]]}
{"id": "1959", "ref_c": [["int* sortItems(int n, int m, int* group, int groupSize, int** beforeItems, int beforeItemsSize, int* beforeItemsColSize, int* returnSize){\\n    R = malloc(sizeof(int) * n);\\n    N = n;\\n\\n    Node items[n];\\n    memset(items, 0, sizeof(Node)*n);\\n\\n    // pre process\\n    for (int i=0; i<n; i++) {\\n        items[i].id = i;\\n        items[i].isVertex = true;\\n        // not belonged to any group, create new group and put it in\\n        if (group[i] == -1) group[i] = m++;\\n    }"], ["int* sortItems(int n, int m, int* group, int groupSize, int** beforeItems, int beforeItemsSize, int* beforeItemsColSize, int* returnSize){\\n    R = malloc(sizeof(int) * n);\\n    N = n;\\n\\n    Node items[n];\\n    memset(items, 0, sizeof(Node)*n);\\n\\n    // pre process\\n    for (int i=0; i<n; i++) {\\n        items[i].id = i;\\n        items[i].isVertex = true;\\n        // not belonged to any group, create new group and put it in\\n        if (group[i] == -1) group[i] = m++;\\n    }"], ["int* sortItems(int n, int m, int* group, int groupSize, int** beforeItems, int beforeItemsSize, int* beforeItemsColSize, int* returnSize){\\n    R = malloc(sizeof(int) * n);\\n    N = n;\\n\\n    Node items[n];\\n    memset(items, 0, sizeof(Node)*n);\\n\\n    // pre process\\n    for (int i=0; i<n; i++) {\\n        items[i].id = i;\\n        items[i].isVertex = true;\\n        // not belonged to any group, create new group and put it in\\n        if (group[i] == -1) group[i] = m++;\\n    }"]]}
{"id": "1961", "ref_c": [["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"], ["bool validateBinaryTreeNodes(int n, int* leftChild, int leftChildSize, int* rightChild, int rightChildSize){\\n    int sum = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(leftChild[i] != -1) sum += leftChild[i];\\n        if(rightChild[i] != -1) sum += rightChild[i];\\n    }"]]}
{"id": "1962", "ref_c": [["int countVowelPermutation(int n) {\\n        long long prevA = 1, prevE = 1, prevI = 1, prevO = 1, prevU = 1;\\n        int mod = 1e9 + 7; // Modulo value to handle large numbers\\n\\n        for (int length = 2; length <= n; length++) {\\n            // Calculate the next values for each vowel following the rules\\n            long long nextA = (prevE + prevU + prevI) % mod; // \\'a\\' can be preceded by \\'e\\', \\'u\\', or \\'i\\'\\n            long long nextE = (prevA + prevI) % mod; // \\'e\\' can be preceded by \\'a\\' or \\'i\\'\\n            long long nextI = (prevE + prevO) % mod; // \\'i\\' can be preceded by \\'e\\' or\\'o\\'\\n            long long nextO = prevI; // \\'o\\' can only be preceded by \\'i\\'\\n            long long nextU = (prevO + prevI) % mod; // \\'u\\' can be preceded by \\'o\\' or \\'i\\'\\n\\n            // Update the previous values for the next iteration\\n            prevA = nextA;\\n            prevE = nextE;\\n            prevI = nextI;\\n            prevO = nextO;\\n            prevU = nextU;\\n        }", "int countVowelPermutation(int n) {\\n        long prevA = 1, prevE = 1, prevI = 1, prevO = 1, prevU = 1;\\n        int mod = 1000000007; // Modulo value to handle large numbers\\n\\n        for (int length = 2; length <= n; length++) {\\n            // Calculate the next values for each vowel following the rules\\n            long nextA = (prevE + prevU + prevI) % mod; // \\'a\\' can be preceded by \\'e\\', \\'u\\', or \\'i\\'\\n            long nextE = (prevA + prevI) % mod; // \\'e\\' can be preceded by \\'a\\' or \\'i\\'\\n            long nextI = (prevE + prevO) % mod; // \\'i\\' can be preceded by \\'e\\' or \\'o\\'\\n            long nextO = prevI; // \\'o\\' can only be preceded by \\'i\\'\\n            long nextU = (prevO + prevI) % mod; // \\'u\\' can be preceded by \\'o\\' or \\'i\\'\\n\\n            // Update the previous values for the next iteration\\n            prevA = nextA;\\n            prevE = nextE;\\n            prevI = nextI;\\n            prevO = nextO;\\n            prevU = nextU;\\n        }", "int countVowelPermutation(int n) {\\n    long long prevA = 1, prevE = 1, prevI = 1, prevO = 1, prevU = 1;\\n    int mod = 1000000007; // Modulo value to handle large numbers\\n\\n    for (int length = 2; length <= n; length++) {\\n        // Calculate the next values for each vowel following the rules\\n        long long nextA = (prevE + prevU + prevI) % mod; // \\'a\\' can be preceded by \\'e\\', \\'u\\', or \\'i\\'\\n        long long nextE = (prevA + prevI) % mod; // \\'e\\' can be preceded by \\'a\\' or \\'i\\'\\n        long long nextI = (prevE + prevO) % mod; // \\'i\\' can be preceded by \\'e\\' or \\'o\\'\\n        long long nextO = prevI; // \\'o\\' can only be preceded by \\'i\\'\\n        long long nextU = (prevO + prevI) % mod; // \\'u\\' can be preceded by \\'o\\' or \\'i\\'\\n\\n        // Update the previous values for the next iteration\\n        prevA = nextA;\\n        prevE = nextE;\\n        prevI = nextI;\\n        prevO = nextO;\\n        prevU = nextU;\\n    }"], ["int countVowelPermutation(int n) {\\n        const int MOD = 1000000007;\\n        long long a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n        for (int len = 2; len <= n; len++) {\\n            long long new_a = (e + u + i) % MOD;\\n            long long new_e = (a + i) % MOD;\\n            long long new_i = (e + o) % MOD;\\n            long long new_o = (i) % MOD;\\n            long long new_u = (o + i) % MOD;\\n\\n            a = new_a;\\n            e = new_e;\\n            i = new_i;\\n            o = new_o;\\n            u = new_u;\\n        }", "int countVowelPermutation(int n) {\\n        final int MOD = 1000000007;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n        for (int len = 2; len <= n; len++) {\\n            long new_a = (e + u + i) % MOD;\\n            long new_e = (a + i) % MOD;\\n            long new_i = (e + o) % MOD;\\n            long new_o = (i) % MOD;\\n            long new_u = (o + i) % MOD;\\n\\n            a = new_a;\\n            e = new_e;\\n            i = new_i;\\n            o = new_o;\\n            u = new_u;\\n        }"], ["int countVowelPermutation(int n) {\\n        // Define the possible vowel transitions in the \\'mp\\' map.\\n        mp[\\'c\\'] = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' }", "int countVowelPermutation(int n) {\\n        mp[\\'c\\'] = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' }", "int countVowelPermutation(int n) {\\n        mp.put(\\'c\\', Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'));\\n        mp.put(\\'a\\', Arrays.asList(\\'e\\'));\\n        mp.put(\\'e\\', Arrays.asList(\\'a\\', \\'i\\'));\\n        mp.put(\\'i\\', Arrays.asList(\\'a\\', \\'e\\', \\'o\\', \\'u\\'));\\n        mp.put(\\'o\\', Arrays.asList(\\'i\\', \\'u\\'));\\n        mp.put(\\'u\\', Arrays.asList(\\'a\\'));\\n\\n        long[][] dp = new long[n + 2][27];\\n        for (long[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }"]]}
{"id": "1963", "ref_c": [["int dieSimulator(int n, int* rollMax, int rollMaxSize){\\n\\n    /*\\n     * Input:\\n     *  n, roll num\\n     *  rollMax, \\n     *  rollMaxSize\\n     */\\n\\n    for (int i = 0; i <= n; i++) {          /* roll */\\n        for (int j = 0; j < 16; j++) {      /* repeat limit */\\n            for (int k = 0; k < 7; k++) {   /* Number selected in previous roll */\\n                dp[i][j][k] = -1;\\n            }"], ["int dieSimulator(int n, int* rollMax, int rollMaxSize){\\n\\n    /*\\n     * Input:\\n     *  n, roll num\\n     *  rollMax, \\n     *  rollMaxSize\\n     */\\n\\n    for (int i = 0; i <= n; i++) {          /* roll */\\n        for (int j = 0; j < 16; j++) {      /* repeat limit */\\n            for (int k = 0; k < 7; k++) {   /* Number selected in previous roll */\\n                dp[i][j][k] = -1;\\n            }"], ["int dieSimulator(int n, int* rollMax, int rollMaxSize){\\n\\n    /*\\n     * Input:\\n     *  n, roll num\\n     *  rollMax, \\n     *  rollMaxSize\\n     */\\n\\n    for (int i = 0; i <= n; i++) {          /* roll */\\n        for (int j = 0; j < 16; j++) {      /* repeat limit */\\n            for (int k = 0; k < 7; k++) {   /* Number selected in previous roll */\\n                dp[i][j][k] = -1;\\n            }"]]}
{"id": "1964", "ref_c": [["int* diffWaysToCompute(char * expression, int* returnSize){\\n    if(strlen(expression) == 1) {\\n        int *result = malloc(sizeof(int));\\n        result[0] = expression[0] - 48;\\n        *returnSize = 1;\\n        return result;\\n    }"], ["int* diffWaysToCompute(char * expression, int* returnSize){\\n    if(strlen(expression) == 1) {\\n        int *result = malloc(sizeof(int));\\n        result[0] = expression[0] - 48;\\n        *returnSize = 1;\\n        return result;\\n    }"], ["int* diffWaysToCompute(char * expression, int* returnSize){\\n    if(strlen(expression) == 1) {\\n        int *result = malloc(sizeof(int));\\n        result[0] = expression[0] - 48;\\n        *returnSize = 1;\\n        return result;\\n    }"]]}
{"id": "1965", "ref_c": [["int jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize){\\n    int n = startTimeSize;\\n\\n    // mergeSort(endTime, startTime, profit, 0, n-1);\\n    insertion_sort(endTime, startTime, profit, n);\\n    int* p;\\n    p = malloc(n * sizeof(int));  \\n    p[0] = 0;\\n    \\n    int dp[n];\\n    dp[0] = profit[0];\\n    int end = endTime[0];\\n    for(int i=1; i<n; i++){\\n        // binary search\\n        int left = 0;\\n        int right = i;\\n        while (left < right) {\\n            int mid = left + (right - left ) / 2;\\n            if (endTime[mid] <= startTime[i]) \\n                left = mid + 1; \\n            else \\n                right = mid;\\n        }"], ["int jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize){\\n    int start[50001];\\n    start[startTimeSize] = 0;\\n    struct list* book = malloc(sizeof(struct list)*startTimeSize);\\n    for (int i = 0 ; i < startTimeSize ; i++){\\n        book[i].start = startTime[i];\\n        book[i].end = endTime[i];\\n        book[i].point = profit[i];\\n    }"], ["int jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize){\\n    int start[50001];\\n    start[startTimeSize] = 0;\\n    struct list* book = malloc(sizeof(struct list)*startTimeSize);\\n    for (int i = 0 ; i < startTimeSize ; i++){\\n        book[i].start = startTime[i];\\n        book[i].end = endTime[i];\\n        book[i].point = profit[i];\\n    }"]]}
{"id": "1966", "ref_c": [["int* decode(int* encoded, int encodedSize, int first, int* returnSize) {\\n    int *arr = (int *)malloc((encodedSize + 1) * sizeof(int));\\n    if (arr == NULL) {\\n        return NULL;\\n    }"], ["int* decode(int* encoded, int encodedSize, int first, int* returnSize) {\\n    int index=0;\\n    int *arr = (int *)malloc((encodedSize+1)*sizeof(int));\\n    arr[index] = first;\\n    index++;\\n    for(int i=0; i<encodedSize; i++){\\n            arr[index] = arr[index-1]^encoded[i];\\n            index++;\\n    }"], ["int* decode(int* encoded, int encodedSize, int first, int* returnSize) {\\n    *returnSize  = encodedSize + 1;\\n    int *arr = (int *)malloc(sizeof(int) * (encodedSize + 1));\\n    arr[0] = first;\\n    for(int i = 0; i < encodedSize; i++){\\n        arr[i + 1] = arr[i] ^ encoded[i];\\n    }"]]}
{"id": "1967", "ref_c": [["struct Node* connect(struct Node* root) {\\n        // Recursive level order traversal\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(n)\\n\\n        if (root == NULL) {\\n            return NULL;\\n        }", "struct Node* connect(struct Node* root) {\\n        // BFS level order traversal\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(n)\\n\\n        if (root == NULL) {\\n            return NULL;\\n        }", "struct Node* connect(struct Node* root) {\\n        // BFS without extra space\\n        // populating the next level while traversing current level.\\n\\n        // Time complexity: O(n)\\n        // Space complexity: O(1)\\n\\n        if (root == NULL) {\\n            return NULL;\\n        }"], ["struct Node* connect(struct Node* root) {\\n    if(root == NULL) {\\n        return NULL;\\n    }"], ["struct Node* connect(struct Node* root) {\\n    if (root == NULL) {\\n        return NULL;\\n    }"]]}
{"id": "1968", "ref_c": ["\nint cmpFunc(const void *a, const void *b)\n{\n    return (*(int*)a - *(int*)b);\n}\n\nint maxIceCream(int* costs, int costsSize, int coins){\n\n    if (costs == NULL || costsSize == 0 || coins == 0)\n    {\n        return 0;\n    }\n    \n    qsort(costs, costsSize, sizeof(int), cmpFunc);\n    int count = 0;\n\n    for (int index  = 0; index < costsSize; index++)\n    {\n        if (coins < costs[index])\n        {\n            return count;\n        }\n        else\n        {\n            coins = coins - costs[index];\n            count++;\n        }\n    }\n\n    return count;\n}\n", "\nint cmpFunc(const void *a, const void *b)\n{\n    return (*(int*)a - *(int*)b);\n}\n\nint maxIceCream(int* costs, int costsSize, int coins){\n\n    if (costs == NULL || costsSize == 0 || coins == 0)\n    {\n        return 0;\n    }\n    \n    qsort(costs, costsSize, sizeof(int), cmpFunc);\n    int count = 0;\n\n    for (int index  = 0; index < costsSize; index++)\n    {\n        if (coins < costs[index])\n        {\n            return count;\n        }\n        else\n        {\n            coins = coins - costs[index];\n            count++;\n        }\n    }\n\n    return count;\n}\n", "\nint cmpFunc(const void *a, const void *b)\n{\n    return (*(int*)a - *(int*)b);\n}\n\nint maxIceCream(int* costs, int costsSize, int coins){\n\n    if (costs == NULL || costsSize == 0 || coins == 0)\n    {\n        return 0;\n    }\n    \n    qsort(costs, costsSize, sizeof(int), cmpFunc);\n    int count = 0;\n\n    for (int index  = 0; index < costsSize; index++)\n    {\n        if (coins < costs[index])\n        {\n            return count;\n        }\n        else\n        {\n            coins = coins - costs[index];\n            count++;\n        }\n    }\n\n    return count;\n}\n"]}
{"id": "1969", "ref_c": [["long long maximumImportance(int n, int** roads, int roadsSize, int* roadsColSize){\\n        long long ret=0;\\n        long long* TimesShown=calloc(n,sizeof(long long));\\n        for (int i=0;i<roadsSize;i++){\\n            for(int j=0;j<2;j++){\\n                TimesShown[roads[i][j]]++;\\n            }"], ["long long maximumImportance(int n, int** roads, int roadsSize, int* roadsColSize){\\n    // Array to keep track of each city data\\n    Help* help = calloc(n, sizeof(Help));\\n\\n    // Array to keep importance of city\\n    int* importance = calloc(n, sizeof(int));\\n    \\n    // Initialize help array\\n    for(int i = 0; i < n; i++){\\n        help[i].node = i;\\n        help[i].roads = 0;\\n    }"], ["long long maximumImportance(int n, int** roads, int roadsSize, int* roadsColSize){\\n    // Array to keep track of each city data\\n    Help* help = calloc(n, sizeof(Help));\\n\\n    // Array to keep importance of city\\n    int* importance = calloc(n, sizeof(int));\\n    \\n    // Initialize help array\\n    for(int i = 0; i < n; i++){\\n        help[i].node = i;\\n        help[i].roads = 0;\\n    }"]]}
{"id": "1970", "ref_c": [["int numWays(int steps, int arrLen) {\\n        int MOD = 1000000007;\\n        int maxPosition = min(steps / 2, arrLen - 1);\\n        vector<long long> dp(maxPosition + 1, 0);\\n        dp[0] = 1;\\n\\n        for (int i = 1; i <= steps; i++) {\\n            vector<long long> new_dp(maxPosition + 1, 0);\\n            for (int j = 0; j <= maxPosition; j++) {\\n                new_dp[j] = dp[j];\\n                if (j > 0)\\n                    new_dp[j] = (new_dp[j] + dp[j - 1]) % MOD;\\n                if (j < maxPosition)\\n                    new_dp[j] = (new_dp[j] + dp[j + 1]) % MOD;\\n            }"], ["int numWays(int steps, int arrLen) {\\n        arrLen = min(arrLen, steps);\\n        this->arrLen = arrLen;\\n        memo = vector(arrLen, vector(steps + 1, -1));\\n        return dp(0, steps);\\n    }", "int numWays(int steps, int arrLen) {\\n    arrLen = arrLen < steps ? arrLen : steps;\\n    memo = (int **)malloc(arrLen * sizeof(int *));\\n    for (int i = 0; i < arrLen; i++) {\\n        memo[i] = (int *)malloc((steps + 1) * sizeof(int));\\n        for (int j = 0; j <= steps; j++) {\\n            memo[i][j] = -1;\\n        }", "int numWays(int steps, int arrLen) {\\n        arrLen = Math.min(arrLen, steps);\\n        this.arrLen = arrLen;\\n        memo = new int[arrLen][steps + 1];\\n        for (int[] row : memo) {\\n            Arrays.fill(row, -1);\\n        }", "int numWays(int steps, int arrLen) {\\n        int MOD = 1e9 + 7;\\n        arrLen = min(arrLen, steps);\\n        vector<vector<int>> dp(arrLen, vector(steps + 1, 0));\\n        dp[0][0] = 1;\\n        \\n        for (int remain = 1; remain <= steps; remain++) {\\n            for (int curr = arrLen - 1; curr >= 0; curr--) {\\n                int ans = dp[curr][remain - 1];\\n                \\n                if (curr > 0) {\\n                    ans = (ans + dp[curr - 1][remain - 1]) % MOD;\\n                }", "int numWays(int steps, int arrLen) {\\n    int MOD = 1000000007;\\n    arrLen = min(arrLen, steps);\\n    int dp[arrLen][steps + 1];\\n    \\n    for (int i = 0; i < arrLen; i++) {\\n        for (int j = 0; j <= steps; j++) {\\n            dp[i][j] = 0;\\n        }", "int numWays(int steps, int arrLen) {\\n        int MOD = (int) 1e9 + 7;\\n        arrLen = Math.min(arrLen, steps);\\n        int[][] dp = new int[arrLen][steps + 1];\\n        dp[0][0] = 1;\\n        \\n        for (int remain = 1; remain <= steps; remain++) {\\n            for (int curr = arrLen - 1; curr >= 0; curr--) {\\n                int ans = dp[curr][remain - 1];\\n                \\n                if (curr > 0) {\\n                    ans = (ans + dp[curr - 1][remain - 1]) % MOD;\\n                }", "int numWays(int steps, int arrLen) {\\n        int MOD = 1e9 + 7;\\n        arrLen = min(arrLen, steps);\\n        vector<int> dp(arrLen, 0);\\n        vector<int> prevDp(arrLen, 0);\\n        prevDp[0] = 1;\\n        \\n        for (int remain = 1; remain <= steps; remain++) {\\n            dp = vector(arrLen, 0);\\n            \\n            for (int curr = arrLen - 1; curr >= 0; curr--) {\\n                int ans = prevDp[curr];\\n                \\n                if (curr > 0) {\\n                    ans = (ans + prevDp[curr - 1]) % MOD;\\n                }", "int numWays(int steps, int arrLen) {\\n    int MOD = 1000000007;\\n    arrLen = arrLen < steps ? arrLen : steps;\\n    \\n    int* dp = (int*)malloc(arrLen * sizeof(int));\\n    int* prevDp = (int*)malloc(arrLen * sizeof(int));\\n    \\n    for (int i = 0; i < arrLen; i++) {\\n        dp[i] = 0;\\n        prevDp[i] = 0;\\n    }", "int numWays(int steps, int arrLen) {\\n        int MOD = (int) 1e9 + 7;\\n        arrLen = Math.min(arrLen, steps);\\n        int[] dp = new int[arrLen];\\n        int[] prevDp = new int[arrLen];\\n        prevDp[0] = 1;\\n        \\n        for (int remain = 1; remain <= steps; remain++) {\\n            dp = new int[arrLen];\\n            \\n            for (int curr = arrLen - 1; curr >= 0; curr--) {\\n                int ans = prevDp[curr];\\n                if (curr > 0) {\\n                    ans = (ans + prevDp[curr - 1]) % MOD;\\n                }"], ["int numWays(int steps, int arrLen){\\n    if (arrLen == 1) return 1;\\n    else if (steps == 1) return 2;\\n    unsigned int dp[2][arrLen];\\n    for (int i=0; i<arrLen; i++){\\n        if (i < 2) dp[0][i] = 1;\\n        else dp[0][i] = 0;\\n    }"]]}
{"id": "1971", "ref_c": [["char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\nint temp;\\nchar *str;\\n*returnSize=namesSize;\\nfor(int i=0;i<namesSize;i++)\\n{\\n  for(int j=i+1;j<namesSize;j++){\\n    if(heights[i]<heights[j])\\n    { \\n      temp=heights[i];\\n      heights[i]=heights[j];\\n      heights[j]=temp;\\n      str=names[i];\\n      names[i]=names[j];\\n      names[j]=str;\\n    }"], ["char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\n    char** ans = (char**)calloc(namesSize, sizeof(char*));\\n    for(int i = 0; i < heightsSize; i++)\\n        heights[i] = (heights[i] << 10) + i;\\n    qsort(heights, heightsSize, sizeof(int), cmp);\\n    for(int i = 0; i < heightsSize; i++)\\n        ans[i] = names[heights[i] & 0x3FF];\\n    *returnSize = heightsSize;\\n    return ans;\\n}"], ["char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\n    char** ans = (char**)calloc(namesSize, sizeof(char*));\\n    for(int i = 0; i < heightsSize; i++)\\n        heights[i] = (heights[i] << 10) + i;\\n    qsort(heights, heightsSize, sizeof(int), cmp);\\n    for(int i = 0; i < heightsSize; i++)\\n        ans[i] = names[heights[i] & 0x3FF];\\n    *returnSize = heightsSize;\\n    return ans;\\n}"]]}
{"id": "1972", "ref_c": [["int minFlips(int** mat, int matSize, int* matColSize){\\n    int head=-1, tail=0, queue_state[600], queue_step[600] ,A[6]={0, 0, 1, 0, -1, 0}"], ["int minFlips(int** mat, int matSize, int* matColSize){\\n    int r=matSize;\\n    int c=*matColSize;\\n\\t\\n    if(zeroMatChecker(mat,r,c))return 0;//checks and return 0 if the given mat is zeroMat \\n\\t\\n    int** visited=malloc(sizeof(int*)*3);\\n    initialize(visited);\\n\\t\\n    int shortest=-1;\\n    findShortestPath(mat,1,visited,&shortest,r,c);\\n\\t\\n    //if no solution is possible -1 remains\\n    \\n\\treturn shortest;\\n}"], ["int minFlips(int** mat, int matSize, int* matColSize){\\n    int r=matSize;\\n    int c=*matColSize;\\n\\t\\n    if(zeroMatChecker(mat,r,c))return 0;//checks and return 0 if the given mat is zeroMat \\n\\t\\n    int** visited=malloc(sizeof(int*)*3);\\n    initialize(visited);\\n\\t\\n    int shortest=-1;\\n    findShortestPath(mat,1,visited,&shortest,r,c);\\n\\t\\n    //if no solution is possible -1 remains\\n    \\n\\treturn shortest;\\n}"]]}
{"id": "1973", "ref_c": [["int minFallingPathSum(int** grid, int gridSize, int* gridColSize) {\\n        // 2D DP method \\n\\n        // Time complexity: O(n^3)\\n        // Space complexity: O(n^2)\\n\\n        const int n = gridSize;\\n        int** dp = (int**)calloc(n, sizeof(int*));\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = (int*)calloc(n, sizeof(int));\\n        }", "int minFallingPathSum(int** grid, int gridSize, int* gridColSize) {\\n        // 1D DP method \\n\\n        // Time complexity: O(n^2)\\n        // Space complexity: O(n)\\n\\n        const int n = gridSize;\\n        int* dp = (int*)malloc(n*sizeof(int));\\n        for (int j = 0; j < n; j++) {\\n            dp[j] = grid[0][j];\\n        }"], ["int minFallingPathSum(int** grid, int gridSize, int* gridColSize) {\\n        // 2D DP method \\n\\n        // Time complexity: O(n^3)\\n        // Space complexity: O(n^2)\\n\\n        const int n = gridSize;\\n        int** dp = (int**)calloc(n, sizeof(int*));\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = (int*)calloc(n, sizeof(int));\\n        }", "int minFallingPathSum(int** grid, int gridSize, int* gridColSize) {\\n        // 1D DP method \\n\\n        // Time complexity: O(n^2)\\n        // Space complexity: O(n)\\n\\n        const int n = gridSize;\\n        int* dp = (int*)malloc(n*sizeof(int));\\n        for (int j = 0; j < n; j++) {\\n            dp[j] = grid[0][j];\\n        }"], ["int minFallingPathSum(int** grid, int gridSize, int* gridColSize){\\n    int n = gridSize;\\n    int DP[n][n];\\n    for (int col = 0; col < n; col++)\\n        DP[0][col] = grid[0][col];\\n        \\n    for (int row = 1; row < n; row++){\\n        for (int col = 0; col < n; col++){\\n            int minValue = INFINITY;\\n            for (int anotherColumn = 0; anotherColumn < n; anotherColumn++){\\n                if (anotherColumn != col)\\n                    minValue = MIN(minValue, DP[row-1][anotherColumn]);\\n            }"]]}
{"id": "1974", "ref_c": [["int shortestPath(int** grid, int gridSize, int* gridColSize, int k) {\\n  const int moves[][2] = {{-1, 0}", "int shortestPath(int** grid, int gridSize, int* gridColSize, int k) {\\n  const int moves[][2] = {{-1, 0}"], ["int shortestPath(int** grid, int gridSize, int* gridColSize, int k) {\\n  const int moves[][2] = {{-1, 0}", "int shortestPath(int** grid, int gridSize, int* gridColSize, int k) {\\n  const int moves[][2] = {{-1, 0}"], ["int shortestPath(int** grid, int gridSize, int* gridColSize, int k) {\\n  const int moves[][2] = {{-1, 0}", "int shortestPath(int** grid, int gridSize, int* gridColSize, int k) {\\n  const int moves[][2] = {{-1, 0}"]]}
{"id": "1975", "ref_c": [["int countNicePairs(int* nums, int numsSize) {\\n    int freq[100000] = {0}", "int countNicePairs(int* nums, int numsSize) {\\n    int* arr = (int*)malloc(numsSize * sizeof(int));\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i] = nums[i] - rev(nums[i]);\\n    }"], ["int countNicePairs(int* nums, int numsSize) {\\n\\n    /*\\n     * Input:\\n     *  *nums\\n     *  numsSize\\n     */\\n\\n    int ans = 0;\\n\\n    /* Calculate nums[i] - rev(nums[i]) */\\n    for (int i = 0; i < numsSize; i++) {\\n        nums[i] = nums[i] - reverse(nums[i]);\\n    }"], ["int countNicePairs(int* nums, int numsSize) {\\n\\n    /*\\n     * Input:\\n     *  *nums\\n     *  numsSize\\n     */\\n\\n    int ans = 0;\\n\\n    /* Calculate nums[i] - rev(nums[i]) */\\n    for (int i = 0; i < numsSize; i++) {\\n        nums[i] = nums[i] - reverse(nums[i]);\\n    }"]]}
{"id": "1976", "ref_c": [["int findShortestSubArray(int* nums, int numsSize){\\n    int freq[50000],beg[50000],end[50000];\\n    memset(freq,0,sizeof(freq));\\n    int n = numsSize;\\n    for(int i=0; i<n; i++){\\n        if(freq[nums[i]]==0){\\n            beg[nums[i]] = i;\\n        }"], ["int findShortestSubArray(int* nums, int numsSize) {\\n\\n    int finaldegree=1;\\n    int finaldistance=1;\\n    int distance;\\n    int spot;\\n    int degree = 0;\\n    int memo[numsSize];\\n    int counter = 0;\\n    bool check;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        spot = nums[i];\\n        distance = 1;\\n        degree = 1;\\n        check = true;\\n        for(int z=0; z<counter;z++)\\n        {\\n            if(nums[i]==memo[z])\\n            {\\n                check = false;\\n            }"], ["int findShortestSubArray(int* nums, int numsSize) {\\n\\n    int finaldegree=1;\\n    int finaldistance=1;\\n    int distance;\\n    int spot;\\n    int degree = 0;\\n    int memo[numsSize];\\n    int counter = 0;\\n    bool check;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        spot = nums[i];\\n        distance = 1;\\n        degree = 1;\\n        check = true;\\n        for(int z=0; z<counter;z++)\\n        {\\n            if(nums[i]==memo[z])\\n            {\\n                check = false;\\n            }"]]}
{"id": "1977", "ref_c": [["int singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize == 1) {\\n        return nums[0];\\n    }"], ["int singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize == 1) {\\n        return nums[0];\\n    }"], ["int singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize == 1) {\\n        return nums[0];\\n    }"]]}
{"id": "1978", "ref_c": ["\nint minInsertions(char * s){\n    int n = strlen(s);\n    int dp[n][n];\n    memset(dp, 0, sizeof(dp));\n    \n    for (int len = 2; len <= n; len++) {\n        for (int i = 0, j = len-1; j < n; i++, j++) {\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i+1][j-1];\n            } else {\n                dp[i][j] = 1 + fmin(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n    }\n    \n    return dp[0][n-1];\n}\n", "\nint minInsertions(char * s){\n    int n = strlen(s);\n    int dp[n][n];\n    memset(dp, 0, sizeof(dp));\n    \n    for (int len = 2; len <= n; len++) {\n        for (int i = 0, j = len-1; j < n; i++, j++) {\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i+1][j-1];\n            } else {\n                dp[i][j] = 1 + fmin(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n    }\n    \n    return dp[0][n-1];\n}\n", "\nint minInsertions(char * s){\n    int n = strlen(s);\n    int dp[n][n];\n    memset(dp, 0, sizeof(dp));\n    \n    for (int len = 2; len <= n; len++) {\n        for (int i = 0, j = len-1; j < n; i++, j++) {\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i+1][j-1];\n            } else {\n                dp[i][j] = 1 + fmin(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n    }\n    \n    return dp[0][n-1];\n}\n"]}
{"id": "1979", "ref_c": [["char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){\\n    qsort(logs, logsSize, sizeof(char *), cmp);\\n    return *returnSize = logsSize, logs;\\n}"], ["char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){\\n    qsort(logs, logsSize, sizeof(char *), cmp);\\n    return *returnSize = logsSize, logs;\\n}"], ["char ** reorderLogFiles(char ** logs, int logsSize, int* returnSize){\\n\\n    merge_sort(logs, 0, logsSize - 1);\\n    \\n    *returnSize = logsSize;\\n    return logs;\\n}"]]}
{"id": "1980", "ref_c": [["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if((n - 1) % 3 == 0){\\n\\n\\n        return true; \\n        }", "bool isPowerOfFour(int n) {\\n    if (n > 0 && (n & (n - 1)) == 0) {\\n        // Check if it\\'s one more than a multiple of 3\\n        if ((n - 1) % 3 == 0) {\\n            return true;\\n        }", "bool isPowerOfFour(int n) {\\n       return n>0 && (n&(n-1))==0 && (n % 10 ==1|| n% 10==4|| n%10==6);\\n    }", "bool isPowerOfFour(int n) {\\n    return n > 0 && (n & (n - 1)) == 0 && (n % 10 == 1 || n % 10 == 4 || n % 10 == 6);\\n}"], ["bool isPowerOfFour(int n) {\\n        // Iterate through powers of 4 from 4^0 to 4^15\\n        for (int i = 0; i <= 15; i++) {\\n            int powerOfFour = pow(4, i);\\n            \\n            // If we find a power of four equal to \\'n\\', return true\\n            if (powerOfFour == n)\\n                return true;\\n            \\n            // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n            if (powerOfFour > n)\\n                return false;\\n        }", "bool isPowerOfFour(int n) {\\n    // Iterate through powers of 4 from 4^0 to 4^15\\n    for (int i = 0; i <= 15; i++) {\\n        int powerOfFour = pow(4, i);\\n\\n        // If we find a power of four equal to \\'n\\', return true\\n        if (powerOfFour == n)\\n            return true;\\n\\n        // If the current power of four is greater than \\'n\\', there\\'s no need to continue\\n        if (powerOfFour > n)\\n            return false;\\n    }", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the logarithm of \\'n\\' with base 4\\n        double logarithmBase4 = log(n) / log(4);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (logarithmBase4 == (int)logarithmBase4);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the logarithm of \\'n\\' with base 4\\n    double logarithmBase4 = log(n) / log(4);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (logarithmBase4 == (int)logarithmBase4);\\n}", "bool isPowerOfFour(int n) {\\n        // If \\'n\\' is 1, it is a power of four\\n        if (n == 1)\\n            return true;\\n        \\n        // If \\'n\\' is non-positive, it cannot be a power of four\\n        if (n <= 0)\\n            return false; \\n        \\n        // Calculate the square root of \\'n\\'\\n        double sqrtN = sqrt(n);\\n\\n        // Take the logarithm base 2 of the square root\\n        double log2SqrtN = log2(sqrtN);\\n        \\n        // Check if the result of the logarithmic operation is an integer\\n        return (log2SqrtN == (int)log2SqrtN);\\n    }", "bool isPowerOfFour(int n) {\\n    // If \\'n\\' is 1, it is a power of four\\n    if (n == 1)\\n        return 1; // True in C is often represented as 1\\n\\n    // If \\'n\\' is non-positive, it cannot be a power of four\\n    if (n <= 0)\\n        return 0; // False in C is often represented as 0\\n\\n    // Calculate the square root of \\'n\\'\\n    double sqrtN = sqrt(n);\\n\\n    // Take the logarithm base 2 of the square root\\n    double log2SqrtN = log2(sqrtN);\\n\\n    // Check if the result of the logarithmic operation is an integer\\n    return (log2SqrtN == (int)log2SqrtN);\\n}"], ["bool isPowerOfFour(int n){\\n\\n    if(n==1)\\n        return true;\\n    return (n&0x55555554) && !(n&n-1);\\n}"]]}
{"id": "1981", "ref_c": [["int minTaps(int n, int* ranges, int rangesSize){\\n    int* taps = calloc(n+1,sizeof(int));\\n    for(int i=0; i<rangesSize; i++){\\n        int left = i-ranges[i]>0?i-ranges[i]:0;\\n        int right = i+ranges[i]>n?n:i+ranges[i];\\n        if(taps[left]<right)\\n            taps[left]=right;\\n    }"], ["int minTaps(int n, int* ranges, int rangesSize){\\n    int* taps = calloc(n+1,sizeof(int));\\n    for(int i=0; i<rangesSize; i++){\\n        int left = i-ranges[i]>0?i-ranges[i]:0;\\n        int right = i+ranges[i]>n?n:i+ranges[i];\\n        if(taps[left]<right)\\n            taps[left]=right;\\n    }"], ["int minTaps(int n, int* ranges, int rangesSize){\\n    int* taps = calloc(n+1,sizeof(int));\\n    for(int i=0; i<rangesSize; i++){\\n        int left = i-ranges[i]>0?i-ranges[i]:0;\\n        int right = i+ranges[i]>n?n:i+ranges[i];\\n        if(taps[left]<right)\\n            taps[left]=right;\\n    }"]]}
{"id": "1982", "ref_c": [["int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false}"], ["int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false}"], ["int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false}"]]}
{"id": "1983", "ref_c": [["int minDifficulty(int* jobDifficulty, int jobDifficultySize, int d){\\n    int maxValue = MAX_LIMIT+1;\\n    int maxDifficulty = 0;      //Maximum difficulty of a job done on particular day \\'day\\'.\\n    if (jobDifficultySize < d){\\n        return -1;\\n    }"], ["int minDifficulty(int* jobDifficulty, int jobDifficultySize, int d) {\\n\\tif (jobDifficultySize < d) {\\n\\t\\treturn -1;\\n\\t}"], ["int minDifficulty(int* jobDifficulty, int jobDifficultySize, int d)\\n{\\n    int dp_cur_day[jobDifficultySize];\\n    int dp_next_day[jobDifficultySize];\\n    int *dp, *dp_next, *tmp;\\n    int jobDifficultyRange[jobDifficultySize][jobDifficultySize];\\n    int i, j, k, day;\\n\\n\\n    if(d > jobDifficultySize)\\n        return -1;\\n\\n    // fill jobDifficultyRange\\n    // jobDifficultyRange[i][j] is difficulty of a job that starts at jobDifficulty[i]\\n    // and ends at jobDifficulty[j] (including)\\n    for(i=0; i<jobDifficultySize; i++) {\\n        jobDifficultyRange[i][i] = jobDifficulty[i];\\n        for(j=i+1; j<jobDifficultySize; j++)\\n            jobDifficultyRange[i][j] = max(jobDifficultyRange[i][j-1], jobDifficulty[j]);\\n    }"]]}
{"id": "1984", "ref_c": [["int* singleNumber(int* nums, int numsSize, int* returnSize){\\n    int res=0,x;\\n    int* arr=(int*)malloc(2*sizeof(int));\\n    arr[0]=0;\\n    arr[1]=0;\\n    for(int i=0;i<numsSize;i++)\\n        res=res^nums[i];\\n    if(res == (-2147483648))\\n        x=0;      \\n    else\\n        x = -res;\\n    int mask=res & x;\\n    for(int i=0;i<numsSize;i++){\\n        if((mask&nums[i])!=0)\\n            arr[0]=arr[0]^nums[i];\\n    }"], ["int* singleNumber(int* nums, int numsSize, int* returnSize) {\\n\\n    int* results = (int *)calloc(2, sizeof(int));\\n    int xorNums = 0;\\n    for(int i=0; i<numsSize; i++){\\n        xorNums ^= nums[i];\\n    }"], ["int* singleNumber(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = 2;\\n    int* result = (int*) malloc(2 * sizeof(int));\\n    \\n    unsigned int xorAll = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        xorAll ^= nums[i];\\n    }"]]}
{"id": "1985", "ref_c": [["int minJumps(int* arr, int arrSize){\\n\\n    if (arrSize <= 1) return 0;\\n\\n    status obj[arrSize];\\n    int visit[arrSize];\\n    memset(visit, 0, arrSize*sizeof(int));\\n    node *hash = NULL, *s;\\n\\n    struct ListNode *tp;\\n\\n    //add all into hash and linked list\\n    for (int i = 0; i < arrSize; i++) {\\n        HASH_FIND_INT(hash, &arr[i], s);\\n        if (!s) {\\n            s = (node*)calloc(1, sizeof(node));\\n            s->key = arr[i];\\n            HASH_ADD_INT(hash, key, s);\\n        }"], ["int minJumps(int* arr, int arrSize){\\n\\n    if (arrSize <= 1) return 0;\\n\\n    status obj[arrSize];\\n    int visit[arrSize];\\n    memset(visit, 0, arrSize*sizeof(int));\\n    node *hash = NULL, *s;\\n\\n    struct ListNode *tp;\\n\\n    //add all into hash and linked list\\n    for (int i = 0; i < arrSize; i++) {\\n        HASH_FIND_INT(hash, &arr[i], s);\\n        if (!s) {\\n            s = (node*)calloc(1, sizeof(node));\\n            s->key = arr[i];\\n            HASH_ADD_INT(hash, key, s);\\n        }"], ["int minJumps(int* arr, int arrSize){\\n\\n    if (arrSize <= 1) return 0;\\n\\n    status obj[arrSize];\\n    int visit[arrSize];\\n    memset(visit, 0, arrSize*sizeof(int));\\n    node *hash = NULL, *s;\\n\\n    struct ListNode *tp;\\n\\n    //add all into hash and linked list\\n    for (int i = 0; i < arrSize; i++) {\\n        HASH_FIND_INT(hash, &arr[i], s);\\n        if (!s) {\\n            s = (node*)calloc(1, sizeof(node));\\n            s->key = arr[i];\\n            HASH_ADD_INT(hash, key, s);\\n        }"]]}
{"id": "1986", "ref_c": [["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n; // since n = number of elements to be returned\\n    char **answer; // the string of strings where the right elements will be copied\\n    char str[5]; // every string contains at most 5 character (max number is 10000 => 5 characters)\\n    \\n    i = 1; // first number we want to return is 1\\n    answer = NULL;\\n    answer = malloc(sizeof(*answer) * n); // our string of strings will have the same number of element than the returning one (n)\\n    if (!answer)\\n        return (answer); // securizing our malloc => returning NULL if something went wrong\\n    while (i <= n)\\n    {\\n        if (i % 15 == 0)\\n            answer[i - 1] = strdup(\"FizzBuzz\"); // NB we need to start duplicating from position 0 => (i - 1)\\n        else if (i % 3 == 0)\\n            answer[i - 1] = strdup(\"Fizz\");\\n        else if (i % 5 == 0)\\n            answer[i - 1] = strdup(\"Buzz\");\\n        else\\n        {\\n            sprintf(str, \"%d\", i); // converting integer i into char and storing it in str\\n            answer[i - 1] = strdup(str);\\n        }"], ["char ** fizzBuzz(int n, int* returnSize){\\n    *returnSize = n;\\n    char **T = (char**)malloc(sizeof(char*)*n);\\n    for(int i=0;i<n;i++){\\n        T[i]=(char*)malloc(9*sizeof(char));\\n        sprintf(T[i], \"%d\", i+1);  // Convert \\'i\\' to char \\n        if( (i+1) % 3 == 0 && (i+1) % 5 == 0){T[i] = \"FizzBuzz\";}"], ["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    char**arr = malloc(n*sizeof(char*));\\n    *returnSize = n;\\n    for(int i=1;i<=n;i++)\\n    {\\n        arr[i - 1] = malloc(9 * sizeof(char));\\n        if(i%15==0)\\n        arr[i-1] = \"FizzBuzz\";\\n        else if(i%3==0)\\n        arr[i-1]=\"Fizz\";\\n        else if(i%5==0)\\n        arr[i-1]=\"Buzz\";\\n        else\\n        sprintf(arr[i-1], \"%d\", i);\\n    }"]]}
{"id": "1987", "ref_c": [["bool isPossible(int* target, int targetSize){\\n    qsort(target, targetSize, sizeof(int), comp);\\n    \\n    int end = targetSize-1;\\n    long long oldsum = 0;\\n    \\n    if (target[end] == 1){\\n        return true;\\n    }"], ["bool isPossible(int* target, int targetSize){\\n    qsort(target, targetSize, sizeof(int), comp);\\n    \\n    int end = targetSize-1;\\n    long long oldsum = 0;\\n    \\n    if (target[end] == 1){\\n        return true;\\n    }"], ["bool isPossible(int* target, int targetSize){\\n    qsort(target, targetSize, sizeof(int), comp);\\n    \\n    int end = targetSize-1;\\n    long long oldsum = 0;\\n    \\n    if (target[end] == 1){\\n        return true;\\n    }"]]}
{"id": "1988", "ref_c": [["int countOrders(int n) {\\n        long[] dp = new long[n + 1];\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i < dp.length; i++) {\\n            long k = i * (i + (i - 1));\\n            dp[i] = (dp[i - 1] * k) % 1000000007;\\n        }", "int countOrders(int n) {\\n        vector<long long> dp(n + 1);\\n        dp[0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            long long k = i * (i + (i - 1));\\n            dp[i] = (dp[i - 1] * k) % 1000000007;\\n        }", "int countOrders(int n)\\n    {\\n        long long dp[502];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        \\n        long long res = 0;\\n        \\n        for(int i = 2; i <= n; i++)\\n        {\\n            long long prev = dp[i-1];\\n            long long pos = 2 + ((i-1) * 2) - 1;\\n            dp[i] = (pos * prev * i) % 1000000007;\\n        }"], ["int countOrders(int n){\\n    long count=1;\\n    for (int i=1; i <= n; i++) {\\n        count *= i;\\n        count *= (i<<1)-1;\\n        count %= 1000000007;\\n    }"], ["int countOrders(int n){\\n\\n    /*\\n     * Input:\\n     *  n\\n     */\\n\\n    int **dp = (int **)malloc(sizeof(int *) * (n + 1));\\n    int ans;\\n\\n    for (int i = 0; i <= n; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * (n + 1));\\n    \\n        for (int j = 0; j <= n; j++) {\\n            dp[i][j] = -1;\\n        }"]]}
{"id": "1989", "ref_c": [["long long maxKelements(int* nums, int numsSize, int k){\\n    long long score = 0;\\n    \\n    buildHeap(nums, numsSize);\\n\\n    while (k--) {\\n        score += nums[0];\\n        nums[0] = ceil(nums[0] / 3.0);\\n        heapify(nums, numsSize, 0);\\n    }"], ["long long maxKelements(int* nums, int numsSize, int k){\\n    long long score = 0;\\n    \\n    buildHeap(nums, numsSize);\\n\\n    while (k--) {\\n        score += nums[0];\\n        nums[0] = ceil(nums[0] / 3.0);\\n        heapify(nums, numsSize, 0);\\n    }"], ["long long maxKelements(int* nums, int numsSize, int k){\\n    long long score = 0;\\n    \\n    buildHeap(nums, numsSize);\\n\\n    while (k--) {\\n        score += nums[0];\\n        nums[0] = ceil(nums[0] / 3.0);\\n        heapify(nums, numsSize, 0);\\n    }"]]}
{"id": "1990", "ref_c": [["int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize){\\n    int * ret = calloc(temperaturesSize, sizeof(int));\\n    *returnSize = temperaturesSize;\\n    int * stk = calloc(temperaturesSize, sizeof(int)); // store indexes\\n    int pt = -1; // stack pointer (point to the top element, \\'-1\\' represent the stack is currently empty)\\n    \\n    // starting from the end of the array\\n    for (int i = temperaturesSize-1; i >= 0; i--){\\n        while(pt != -1 && temperatures[i] >= temperatures[stk[pt]]) pt--; // pop\\n        ret[i] = (pt == -1? 0: stk[pt]-i);\\n        stk[++pt] = i; // push index to stack\\n    }"], ["int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize){\\n    int * ret = calloc(temperaturesSize, sizeof(int));\\n    *returnSize = temperaturesSize;\\n    int * stk = calloc(temperaturesSize, sizeof(int)); // store indexes\\n    int pt = -1; // stack pointer (point to the top element, \\'-1\\' represent the stack is currently empty)\\n    \\n    // starting from the end of the array\\n    for (int i = temperaturesSize-1; i >= 0; i--){\\n        while(pt != -1 && temperatures[i] >= temperatures[stk[pt]]) pt--; // pop\\n        ret[i] = (pt == -1? 0: stk[pt]-i);\\n        stk[++pt] = i; // push index to stack\\n    }"], ["int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize){\\n    int * ret = calloc(temperaturesSize, sizeof(int));\\n    *returnSize = temperaturesSize;\\n    int * stk = calloc(temperaturesSize, sizeof(int)); // store indexes\\n    int pt = -1; // stack pointer (point to the top element, \\'-1\\' represent the stack is currently empty)\\n    \\n    // starting from the end of the array\\n    for (int i = temperaturesSize-1; i >= 0; i--){\\n        while(pt != -1 && temperatures[i] >= temperatures[stk[pt]]) pt--; // pop\\n        ret[i] = (pt == -1? 0: stk[pt]-i);\\n        stk[++pt] = i; // push index to stack\\n    }"]]}
{"id": "1991", "ref_c": [["char * convertToBase7(int num){\\n\\n    int res=0;\\n    int digit=1;\\n\\n    while(num!=0){\\n        res+=digit*(num%7);\\n        num=num/7;\\n        digit*=10;\\n\\n    }"], ["char * convertToBase7(int num){\\n\\n    int res=0;\\n    int digit=1;\\n\\n    while(num!=0){\\n        res+=digit*(num%7);\\n        num=num/7;\\n        digit*=10;\\n\\n    }"], ["char * convertToBase7(int num){\\n\\n    int res=0;\\n    int digit=1;\\n\\n    while(num!=0){\\n        res+=digit*(num%7);\\n        num=num/7;\\n        digit*=10;\\n\\n    }"]]}
{"id": "1992", "ref_c": [["bool checkSubarraySum(int* nums, int numsSize, int k){\\n    if (numsSize == 1) return false;\\n    else if (k == 1) return true;\\n    \\n    bool *map = calloc(k, sizeof(bool)); \\n    // using bool-type would save u some memory\\n    int sum = 0;    \\n\\n    for(int i = 0; i < numsSize; i++){\\n        if (nums[i] % k == 0){  \\n            // return true if encounter at least two conterminous k\\'s multiple\\n            // else we do not do any hashing\\n            if (i < numsSize-1 && nums[i+1] % k == 0) return true;\\n            else continue;\\n        }"], ["bool checkSubarraySum(int* nums, int numsSize, int k){\\n    struct hashTable *map = NULL;\\n    struct hashTable *first;\\n    first = (struct hashTable *)malloc(sizeof(struct hashTable));\\n    nums[0] %= k;\\n    first->key   = nums[0];\\n    first->value = 0;\\n    HASH_ADD_INT(map, key, first);  \\n\\n    for(int i = 1; i < numsSize; i++){\\n        struct hashTable *temp;\\n        nums[i] = (nums[i] + nums[i-1]) % k;\\n        if(nums[i] == 0){\\n            return true;\\n        }"], ["bool checkSubarraySum(int* nums, int numsSize, int k){\\n    struct hashTable *map = NULL;\\n    struct hashTable *first;\\n    first = (struct hashTable *)malloc(sizeof(struct hashTable));\\n    nums[0] %= k;\\n    first->key   = nums[0];\\n    first->value = 0;\\n    HASH_ADD_INT(map, key, first);  \\n\\n    for(int i = 1; i < numsSize; i++){\\n        struct hashTable *temp;\\n        nums[i] = (nums[i] + nums[i-1]) % k;\\n        if(nums[i] == 0){\\n            return true;\\n        }"]]}
{"id": "1993", "ref_c": [["int maxPerformance(int n, int* speed, int speedSize, int* efficiency, int efficiencySize, int k){\\n    long long performance = 0, speedSum = 0;\\n    int module = 1e9 + 7;  \\n    int** tmp = (int**)calloc(n, sizeof(int**));\\n    int* heap = (int*)calloc(k, sizeof(int));\\n    for(int i = 0; i < n; i++){\\n        tmp[i] = (int*)calloc(2, sizeof(int));\\n        tmp[i][0] = speed[i];\\n        tmp[i][1] = efficiency[i];\\n    }"], ["int maxPerformance(int n, int* speed, int speedSize, int* efficiency, int efficiencySize, int k){\\n    struct Data data[speedSize];\\n    long ans = 0, sum = 0;\\n    int heap[k], mod = 1e9+7;\\n\\n    for(int i = 0; i < speedSize; i++)\\n    {\\n        data[i].sp = speed[i];\\n        data[i].eff = efficiency[i];\\n    }"], ["int maxPerformance(int n, int* speed, int speedSize, int* efficiency, int efficiencySize, int k){\\n  /* Add engineers by highest efficiency, then highest speed, descendingly for both */\\n  int (*const engineers)[2] = malloc(n * sizeof(int[2]));\\n  for (int i = 0; i < n; ++i) {\\n    engineers[i][0] = efficiency[i];\\n    engineers[i][1] = speed[i];\\n  }"]]}
{"id": "1994", "ref_c": [["int maxSizeSlices(int* slices, int slicesSize) {\\n    // DP method\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n\\n    const int n = slicesSize, select = n / 3;\\n    int dp1[select + 1][n], dp2[select + 1][n];\\n    memset(dp1, 0, sizeof dp1);\\n    memset(dp2, 0, sizeof dp2);\\n    dp1[1][0] = slices[0];\\n    dp2[1][1] = slices[1];\\n\\n    int max1 = INT_MIN, max2 = INT_MIN;\\n    for (int i = 1; i <= select; i++) {\\n        max1 = dp1[i - 1][0];\\n        max2 = dp2[i - 1][0];\\n        for (int j = 2; j < n; j++) {\\n            dp1[i][j] = max1 + slices[j];\\n            dp2[i][j] = max2 + slices[j];\\n            max1 = max(max1, dp1[i-1][j-1]);\\n            max2 = max(max2, dp2[i-1][j-1]);\\n        }"], ["int maxSizeSlices(int* slices, int slicesSize) {\\n    // DP method\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n\\n    const int n = slicesSize, select = n / 3;\\n    int dp1[select + 1][n], dp2[select + 1][n];\\n    memset(dp1, 0, sizeof dp1);\\n    memset(dp2, 0, sizeof dp2);\\n    dp1[1][0] = slices[0];\\n    dp2[1][1] = slices[1];\\n\\n    int max1 = INT_MIN, max2 = INT_MIN;\\n    for (int i = 1; i <= select; i++) {\\n        max1 = dp1[i - 1][0];\\n        max2 = dp2[i - 1][0];\\n        for (int j = 2; j < n; j++) {\\n            dp1[i][j] = max1 + slices[j];\\n            dp2[i][j] = max2 + slices[j];\\n            max1 = max(max1, dp1[i-1][j-1]);\\n            max2 = max(max2, dp2[i-1][j-1]);\\n        }"], ["int maxSizeSlices(int* slices, int slicesSize) {\\n    // DP method\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n\\n    const int n = slicesSize, select = n / 3;\\n    int dp1[select + 1][n], dp2[select + 1][n];\\n    memset(dp1, 0, sizeof dp1);\\n    memset(dp2, 0, sizeof dp2);\\n    dp1[1][0] = slices[0];\\n    dp2[1][1] = slices[1];\\n\\n    int max1 = INT_MIN, max2 = INT_MIN;\\n    for (int i = 1; i <= select; i++) {\\n        max1 = dp1[i - 1][0];\\n        max2 = dp2[i - 1][0];\\n        for (int j = 2; j < n; j++) {\\n            dp1[i][j] = max1 + slices[j];\\n            dp2[i][j] = max2 + slices[j];\\n            max1 = max(max1, dp1[i-1][j-1]);\\n            max2 = max(max2, dp2[i-1][j-1]);\\n        }"]]}
{"id": "1995", "ref_c": [["int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes){\\n    \\n\\tqsort(people, peopleSize, sizeof(int*), sortFunc);\\n    \\n    *returnSize = peopleSize;\\n    *returnColumnSizes = (int*)malloc(peopleSize*sizeof(int));\\n    \\n    int ** ans = (int**)malloc(peopleSize * sizeof(int*));\\n    \\n    for (int i = 0; i < peopleSize; i++) {\\n        (*returnColumnSizes)[i] = 2;\\n        ans[i] = (int*)malloc(2 * sizeof(int));\\n        \\n        for (int j = i; j > people[i][1]; j--) {\\n            ans[j][0] = ans[j-1][0];\\n            ans[j][1] = ans[j-1][1];\\n        }"], ["int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = peopleSize;\\n    (*returnColumnSizes) = malloc(sizeof(int)*peopleSize);\\n    int** ans = malloc(sizeof(int*)*peopleSize);\\n    for (int i = 0 ; i < peopleSize ; i++){\\n        (*returnColumnSizes)[i] = 2;\\n        ans[i] = malloc(sizeof(int)*2);\\n    }"], ["int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes){\\n    \\n\\tqsort(people, peopleSize, sizeof(int*), sortFunc);\\n    \\n    *returnSize = peopleSize;\\n    *returnColumnSizes = (int*)malloc(peopleSize*sizeof(int));\\n    \\n    int ** ans = (int**)malloc(peopleSize * sizeof(int*));\\n    \\n    for (int i = 0; i < peopleSize; i++) {\\n        (*returnColumnSizes)[i] = 2;\\n        ans[i] = (int*)malloc(2 * sizeof(int));\\n        \\n        for (int j = i; j > people[i][1]; j--) {\\n            ans[j][0] = ans[j-1][0];\\n            ans[j][1] = ans[j-1][1];\\n        }"]]}
{"id": "1996", "ref_c": [["int findGoodStrings(int n, char * s1, char * s2, char * evil){\\n    int el = strlen(evil);\\n    int64_t *dp = (int64_t*)alloca((n + 1) * sizeof(int64_t));\\n    memset(dp, 0, el * sizeof(int64_t));\\n\\n    // KMP algorithm\\n    int k = 0, i = 1;\\n    while (i < el) {\\n        if (evil[k] == evil[i]) dp[i++] = ++k;\\n        else if (k > 0) k = dp[k - 1];\\n        else ++i;\\n    }"], ["int findGoodStrings(int n, char * s1, char * s2, char * evil){\\n    int el = strlen(evil);\\n    int64_t *dp = (int64_t*)alloca((n + 1) * sizeof(int64_t));\\n    memset(dp, 0, el * sizeof(int64_t));\\n\\n    // KMP algorithm\\n    int k = 0, i = 1;\\n    while (i < el) {\\n        if (evil[k] == evil[i]) dp[i++] = ++k;\\n        else if (k > 0) k = dp[k - 1];\\n        else ++i;\\n    }"], ["int findGoodStrings(int n, char * s1, char * s2, char * evil){\\n    int el = strlen(evil);\\n    int64_t *dp = (int64_t*)alloca((n + 1) * sizeof(int64_t));\\n    memset(dp, 0, el * sizeof(int64_t));\\n\\n    // KMP algorithm\\n    int k = 0, i = 1;\\n    while (i < el) {\\n        if (evil[k] == evil[i]) dp[i++] = ++k;\\n        else if (k > 0) k = dp[k - 1];\\n        else ++i;\\n    }"]]}
{"id": "1997", "ref_c": [["int maxSatisfaction(int* satisfaction, int satisfactionSize){\\n  // Step 1\\n  quickSort(satisfaction, 0, satisfactionSize - 1);\\n  int rightSum = 0;\\n  int res = 0;\\n  // Step 2\\n  for (int i = satisfactionSize - 1; i >= 0; i--)\\n  {\\n    if (satisfaction[i] + rightSum > 0)\\n    {\\n      rightSum += satisfaction[i];\\n      res += rightSum;\\n    }"], ["int maxSatisfaction(int* satisfaction, int satisfactionSize) {\\n    //Sort array\\n    for (int i = 0; i < satisfactionSize - 1; i++) {\\n        for (int j = 0; j < satisfactionSize - i - 1; j++) {\\n            if (satisfaction[j] > satisfaction[j + 1]) {\\n                // Swap if the elements are in the wrong order\\n                int temp = satisfaction[j];\\n                satisfaction[j] = satisfaction[j + 1];\\n                satisfaction[j + 1] = temp;\\n            }"], ["int maxSatisfaction(int* satisfaction, int satisfactionSize) {\\n    //Sort array\\n    for (int i = 0; i < satisfactionSize - 1; i++) {\\n        for (int j = 0; j < satisfactionSize - i - 1; j++) {\\n            if (satisfaction[j] > satisfaction[j + 1]) {\\n                // Swap if the elements are in the wrong order\\n                int temp = satisfaction[j];\\n                satisfaction[j] = satisfaction[j + 1];\\n                satisfaction[j + 1] = temp;\\n            }"]]}
{"id": "1998", "ref_c": [["char * stoneGameIII(int* stoneValue, int stoneValueSize){\\n    int dp[MAX_STONE_SIZE] = {0}"], ["char * stoneGameIII(int* stoneValue, int stoneValueSize){\\n    // This can be solved in linear order!\\n    // Amazingly enough this can be solved in O1.\\n    int playerScoreDiff[3] = {0}"], ["char * stoneGameIII(int* stoneValue, int stoneValueSize){\\n    int dp[MAX_STONE_SIZE] = {0}"]]}
{"id": "1999", "ref_c": [["int numOfWays(int n) {\\n\\tif (n == 1) return (6 + 6);\\n\\tif (n == 2) return (6*5 + 6*4);\\n\\tint i = 0;\\n\\tunsigned long long A = 5;\\n\\tunsigned long long B = 4;\\n\\tfor (i = 3; i < n; i++) {\\n\\t\\tunsigned long long tempA = A;\\n\\t\\tunsigned long long tempB = B;\\n\\t\\tA = (tempA * 3 + tempB * 2) % MODULO_CONSTANT;\\n\\t\\tB = (tempA * 2 + tempB * 2) % MODULO_CONSTANT;\\n\\t}"], ["int numOfWays(int n) {\\n\\tif (n == 1) return (6 + 6);\\n\\tif (n == 2) return (6*5 + 6*4);\\n\\tint i = 0;\\n\\tunsigned long long A = 5;\\n\\tunsigned long long B = 4;\\n\\tfor (i = 3; i < n; i++) {\\n\\t\\tunsigned long long tempA = A;\\n\\t\\tunsigned long long tempB = B;\\n\\t\\tA = (tempA * 3 + tempB * 2) % MODULO_CONSTANT;\\n\\t\\tB = (tempA * 2 + tempB * 2) % MODULO_CONSTANT;\\n\\t}"], ["int numOfWays(int n) {\\n\\tif (n == 1) return (6 + 6);\\n\\tif (n == 2) return (6*5 + 6*4);\\n\\tint i = 0;\\n\\tunsigned long long A = 5;\\n\\tunsigned long long B = 4;\\n\\tfor (i = 3; i < n; i++) {\\n\\t\\tunsigned long long tempA = A;\\n\\t\\tunsigned long long tempB = B;\\n\\t\\tA = (tempA * 3 + tempB * 2) % MODULO_CONSTANT;\\n\\t\\tB = (tempA * 2 + tempB * 2) % MODULO_CONSTANT;\\n\\t}"]]}
{"id": "2000", "ref_c": [["int minFlips(int a, int b, int c){\\n    int ai,bi,ci;\\n    int res=0;\\n    while(a>0 || b>0 || c>0){\\n        ai=a%2;bi=b%2;ci=c%2;\\n        if(ci==1 && ai+bi==0)\\n            res++;\\n        else if(ci==0)\\n            res+=ai+bi;\\n        a/=2;b/=2;c/=2;\\n\\n    }"], ["int minFlips(int a, int b, int c){\\n    // 0010 a\\n    // 0110 b\\n    // 0110 a|b\\n    // 0101 c\\n    // 0011 diff of (a|b) and c\\n\\n    int diff = (a|b) ^ c;\\n    int mask = 1;\\n    int ans = 0;\\n    while(diff) {\\n        if (diff & mask) {\\n            if (c & mask) ans += 1;\\n            else {\\n                if (a & mask) ans += 1;\\n                if (b & mask) ans += 1;\\n            }"], ["int minFlips(int a, int b, int c){\\n    int ai,bi,ci;\\n    int res=0;\\n    while(a>0 || b>0 || c>0){\\n        ai=a%2;bi=b%2;ci=c%2;\\n        if(ci==1 && ai+bi==0)\\n            res++;\\n        else if(ci==0)\\n            res+=ai+bi;\\n        a/=2;b/=2;c/=2;\\n\\n    }"]]}
{"id": "2001", "ref_c": [["int numOfArrays(int n, int m, int k) {\\n        long[][][] dp = new long[n][k][m];\\n        long mod = 1000000007;\\n        Arrays.fill(dp[0][0], 1);\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int cost = 0; cost < Math.min(i + 1, k); cost++) {\\n                for (int max = 0; max < m; max++) {\\n                    dp[i][cost][max] = (dp[i][cost][max] + (max + 1) * dp[i - 1][cost][max]) % mod;\\n                    if (cost != 0) {\\n                        long sum = 0;\\n                        for (int prevMax = 0; prevMax < max; prevMax++) {\\n                            sum += dp[i - 1][cost - 1][prevMax];\\n                            sum %= mod;\\n                        }", "int numOfArrays(int n, int m, int k) {\\n        for (int j = 0; j<= m; j++) {\\n            dp[1][j][1] = 1;\\n            pre[1][j][1] = j;\\n        }"], ["int numOfArrays(int n, int m, int k) {\\n        long[][][] dp = new long[n][k][m];\\n        long mod = 1000000007;\\n        Arrays.fill(dp[0][0], 1);\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int cost = 0; cost < Math.min(i + 1, k); cost++) {\\n                for (int max = 0; max < m; max++) {\\n                    dp[i][cost][max] = (dp[i][cost][max] + (max + 1) * dp[i - 1][cost][max]) % mod;\\n                    if (cost != 0) {\\n                        long sum = 0;\\n                        for (int prevMax = 0; prevMax < max; prevMax++) {\\n                            sum += dp[i - 1][cost - 1][prevMax];\\n                            sum %= mod;\\n                        }", "int numOfArrays(int n, int m, int k) {\\n        for (int j = 0; j<= m; j++) {\\n            dp[1][j][1] = 1;\\n            pre[1][j][1] = j;\\n        }"], ["int numOfArrays(int n, int m, int k) {\\n        long[][][] dp = new long[n][k][m];\\n        long mod = 1000000007;\\n        Arrays.fill(dp[0][0], 1);\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int cost = 0; cost < Math.min(i + 1, k); cost++) {\\n                for (int max = 0; max < m; max++) {\\n                    dp[i][cost][max] = (dp[i][cost][max] + (max + 1) * dp[i - 1][cost][max]) % mod;\\n                    if (cost != 0) {\\n                        long sum = 0;\\n                        for (int prevMax = 0; prevMax < max; prevMax++) {\\n                            sum += dp[i - 1][cost - 1][prevMax];\\n                            sum %= mod;\\n                        }", "int numOfArrays(int n, int m, int k) {\\n        for (int j = 0; j<= m; j++) {\\n            dp[1][j][1] = 1;\\n            pre[1][j][1] = j;\\n        }"]]}
{"id": "2002", "ref_c": [["int constrainedSubsetSum(int* nums, int numsSize, int k);\\nMaxHeap* createMaxHeap(int capacity); //external facing\\nvoid freeMaxHeap(MaxHeap* myMaxHeap); //external facing\\nvoid swapNode(HeapNode *a, HeapNode *b); //internal facing\\nvoid maxHeapify(MaxHeap* myMaxHeap, int index); //internal facing\\nvoid insertNode(MaxHeap* myMaxHeap, HeapNode node); //external facing\\nHeapNode extractMax(MaxHeap* myMaxHeap); //external facing\\n\\nint constrainedSubsetSum(int* nums, int numsSize, int k){\\n    MaxHeap* heap = createMaxHeap(numsSize);\\n    DEMAND_MALLOC(heap);\\n\\n    insertNode(heap, (HeapNode){nums[0], 0}"], ["int constrainedSubsetSum(int* nums, int numsSize, int k) {\\n    struct Node {\\n        int value;\\n        int index;\\n    }", "int constrainedSubsetSum(int* nums, int numsSize, int k) {\\n    int* dp = (int*)malloc(numsSize * sizeof(int));\\n    int* window = (int*)malloc((numsSize + 1) * sizeof(int));\\n    memset(window, 0, (numsSize + 1) * sizeof(int));\\n\\n    int maxSum = nums[0];\\n    dp[0] = nums[0];\\n    window[dp[0]] = 1;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        dp[i] = nums[i] + window[maxSum];\\n        window[dp[i]]++;\\n\\n        if (i >= k) {\\n            window[dp[i - k]]--;\\n            if (window[dp[i - k]] == 0) {\\n                window[dp[i - k]] = 0;\\n            }", "int constrainedSubsetSum(int* nums, int numsSize, int k) {\\n    int* dp = (int*)malloc(numsSize * sizeof(int));\\n    int* queue = (int*)malloc(numsSize * sizeof(int));\\n    int front = 0, rear = -1;\\n    int ans = nums[0];\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        while (front <= rear && i - queue[front] > k) {\\n            front++;\\n        }"], ["int constrainedSubsetSum(int* nums, int numsSize, int k);\\nMaxHeap* createMaxHeap(int capacity); //external facing\\nvoid freeMaxHeap(MaxHeap* myMaxHeap); //external facing\\nvoid swapNode(HeapNode *a, HeapNode *b); //internal facing\\nvoid maxHeapify(MaxHeap* myMaxHeap, int index); //internal facing\\nvoid insertNode(MaxHeap* myMaxHeap, HeapNode node); //external facing\\nHeapNode extractMax(MaxHeap* myMaxHeap); //external facing\\n\\nint constrainedSubsetSum(int* nums, int numsSize, int k){\\n    MaxHeap* heap = createMaxHeap(numsSize);\\n    DEMAND_MALLOC(heap);\\n\\n    insertNode(heap, (HeapNode){nums[0], 0}"]]}
{"id": "2003", "ref_c": [["int* sumOfDistancesInTree(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    short sN = n, sEdgesSize = edgesSize;\\n    struct EdgeRecord* apstEdgeRecord[sN];\\n    memset(apstEdgeRecord, NULL, sN*sizeof(struct EdgeRecord*));\\n\\n    // scan edges and store into apstEdgeRecord\\n    while(sEdgesSize-- > 0)\\n    {\\n        // store edges A\\n        struct EdgeRecord* pstNew = (struct EdgeRecord*) malloc(sizeof(struct EdgeRecord));\\n        pstNew->sIndex = (*edges)[1];\\n        pstNew->sIndexCount = 0;\\n        pstNew->nSumDistance = 0;   //default, we will calcate later\\n        pstNew->pstNext = apstEdgeRecord[(*edges)[0]];\\n\\n        apstEdgeRecord[(*edges)[0]] = pstNew;\\n\\n        // store edges B\\n        pstNew = (struct EdgeRecord*) malloc(sizeof(struct EdgeRecord));\\n        pstNew->sIndex = (*edges)[0];\\n        pstNew->sIndexCount = 0;\\n        pstNew->nSumDistance = 0;   //default, we will calcate later\\n        pstNew->pstNext = apstEdgeRecord[(*edges)[1]];\\n\\n        apstEdgeRecord[(*edges)[1]] = pstNew;\\n\\n        // move to next edge\\n        edges++;\\n    }"], ["int* sumOfDistancesInTree(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\\n    short sN = n, sEdgesSize = edgesSize;\\n    struct EdgeRecord* apstEdgeRecord[sN];\\n    memset(apstEdgeRecord, NULL, sN*sizeof(struct EdgeRecord*));\\n\\n    // scan edges and store into apstEdgeRecord\\n    while(sEdgesSize-- > 0)\\n    {\\n        // store edges A\\n        struct EdgeRecord* pstNew = (struct EdgeRecord*) malloc(sizeof(struct EdgeRecord));\\n        pstNew->sIndex = (*edges)[1];\\n        pstNew->sIndexCount = 0;\\n        pstNew->nSumDistance = 0;   //default, we will calcate later\\n        pstNew->pstNext = apstEdgeRecord[(*edges)[0]];\\n\\n        apstEdgeRecord[(*edges)[0]] = pstNew;\\n\\n        // store edges B\\n        pstNew = (struct EdgeRecord*) malloc(sizeof(struct EdgeRecord));\\n        pstNew->sIndex = (*edges)[0];\\n        pstNew->sIndexCount = 0;\\n        pstNew->nSumDistance = 0;   //default, we will calcate later\\n        pstNew->pstNext = apstEdgeRecord[(*edges)[1]];\\n\\n        apstEdgeRecord[(*edges)[1]] = pstNew;\\n\\n        // move to next edge\\n        edges++;\\n    }"], ["int* sumOfDistancesInTree(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize)\\n{\\n    \\n    int x,y;\\n    //memory Allocation\\n    answer = calloc(n,sizeof(int));\\n    child_count=calloc(n,sizeof(int));\\n    connect_list=malloc(n*sizeof(Node*));\\n    count_size=n;\\n    \\n    for(int i=0;i<n;i++){\\n        connect_list[i]=NULL;\\n        child_count[i]=1;\\n    }"]]}
{"id": "2004", "ref_c": [["int kthSmallest(int** mat, int matSize, int* matColSize, int k) {\\n    int res_size = *matColSize;\\n    int res_array_size = res_size > k ? res_size : k;\\n    int *res = (int *)malloc(sizeof(int) * res_array_size);\\n    memset(res, 0, sizeof(int) * res_array_size);\\n    \\n    for (int j = 0; j < res_size; j++) // initialize res[] with 1st row of mat\\n        res[j] = mat[0][j];\\n    \\n    for (int i = 1; i < matSize; i++) {\\n        /* calculate sum from two row */\\n        int tmp_size = res_size * *matColSize; // size of temp array should be\\n        int tmp_cnt = 0;\\n        \\n        q = (struct pq *)malloc(sizeof(struct pq));\\n        memset(q, 0, sizeof(struct pq));\\n        q->heap = (int *)malloc(sizeof(int) * tmp_size);\\n        memset(q->heap, 0, sizeof(int) * tmp_size);\\n        \\n        /* 1. generate temp array from mat[i][] and res[] */\\n        for (int j = 0; j < *matColSize; j++) // O(m * n * k)\\n            for (int k = 0; k < res_size; k++)\\n                q->heap[q->heap_size++] = res[k] + mat[i][j];    \\n        \\n        /* 2. make temp array to heap structure with O(N) */\\n        build_heap(q->heap, q->heap_size); // O(m * k)\\n        \\n        /* 3. save res[] with maximum k size, for calulating with next mat[i + 1][] */\\n        res_size = tmp_size < k ? tmp_size : k; // size of res[] can\\'t be larger than k\\n        for (int idx = 0; idx < res_size; idx++) // O(m * k * log k)\\n            res[idx] = heap_pop(q->heap);\\n        \\n        free(q->heap);\\n        free(q);\\n    }"], ["int kthSmallest(int** mat, int matSize, int* matColSize, int k) {\\n    int res_size = *matColSize;\\n    int res_array_size = res_size > k ? res_size : k;\\n    int *res = (int *)malloc(sizeof(int) * res_array_size);\\n    memset(res, 0, sizeof(int) * res_array_size);\\n    \\n    for (int j = 0; j < res_size; j++) // initialize res[] with 1st row of mat\\n        res[j] = mat[0][j];\\n    \\n    for (int i = 1; i < matSize; i++) {\\n        /* calculate sum from two row */\\n        int tmp_size = res_size * *matColSize; // size of temp array should be\\n        int tmp_cnt = 0;\\n        \\n        q = (struct pq *)malloc(sizeof(struct pq));\\n        memset(q, 0, sizeof(struct pq));\\n        q->heap = (int *)malloc(sizeof(int) * tmp_size);\\n        memset(q->heap, 0, sizeof(int) * tmp_size);\\n        \\n        /* 1. generate temp array from mat[i][] and res[] */\\n        for (int j = 0; j < *matColSize; j++) // O(m * n * k)\\n            for (int k = 0; k < res_size; k++)\\n                q->heap[q->heap_size++] = res[k] + mat[i][j];    \\n        \\n        /* 2. make temp array to heap structure with O(N) */\\n        build_heap(q->heap, q->heap_size); // O(m * k)\\n        \\n        /* 3. save res[] with maximum k size, for calulating with next mat[i + 1][] */\\n        res_size = tmp_size < k ? tmp_size : k; // size of res[] can\\'t be larger than k\\n        for (int idx = 0; idx < res_size; idx++) // O(m * k * log k)\\n            res[idx] = heap_pop(q->heap);\\n        \\n        free(q->heap);\\n        free(q);\\n    }"], ["int kthSmallest(int** mat, int matSize, int* matColSize, int k) {\\n    int res_size = *matColSize;\\n    int res_array_size = res_size > k ? res_size : k;\\n    int *res = (int *)malloc(sizeof(int) * res_array_size);\\n    memset(res, 0, sizeof(int) * res_array_size);\\n    \\n    for (int j = 0; j < res_size; j++) // initialize res[] with 1st row of mat\\n        res[j] = mat[0][j];\\n    \\n    for (int i = 1; i < matSize; i++) {\\n        /* calculate sum from two row */\\n        int tmp_size = res_size * *matColSize; // size of temp array should be\\n        int tmp_cnt = 0;\\n        \\n        q = (struct pq *)malloc(sizeof(struct pq));\\n        memset(q, 0, sizeof(struct pq));\\n        q->heap = (int *)malloc(sizeof(int) * tmp_size);\\n        memset(q->heap, 0, sizeof(int) * tmp_size);\\n        \\n        /* 1. generate temp array from mat[i][] and res[] */\\n        for (int j = 0; j < *matColSize; j++) // O(m * n * k)\\n            for (int k = 0; k < res_size; k++)\\n                q->heap[q->heap_size++] = res[k] + mat[i][j];    \\n        \\n        /* 2. make temp array to heap structure with O(N) */\\n        build_heap(q->heap, q->heap_size); // O(m * k)\\n        \\n        /* 3. save res[] with maximum k size, for calulating with next mat[i + 1][] */\\n        res_size = tmp_size < k ? tmp_size : k; // size of res[] can\\'t be larger than k\\n        for (int idx = 0; idx < res_size; idx++) // O(m * k * log k)\\n            res[idx] = heap_pop(q->heap);\\n        \\n        free(q->heap);\\n        free(q);\\n    }"]]}
{"id": "2005", "ref_c": [["int ways(char ** pizza, int pizzaSize, int k){\\n\\tconst int colLen = strlen(pizza[0]);\\n\\n\\tint * * appleCntsArr = (int * *)malloc(sizeof (int *) * pizzaSize);\\n\\tfor (int i = 0; i < pizzaSize; i += 1){\\n\\t\\tappleCntsArr[i] = (int *)malloc(sizeof (int) * colLen);\\n\\t\\tfor (int j = 0; j < colLen; j += 1){\\n\\t\\t\\tappleCntsArr[i][j] = (pizza[i][j] != \\'.\\');\\n\\t\\t}"], ["int ways(char ** pizza, int pizzaSize, int k){\\n    int*** list = malloc(sizeof(int**)*pizzaSize);\\n    int len = strlen(pizza[0]);\\n    int apple = 0;\\n    for (int i = 0 ; i < pizzaSize ; i++){\\n        list[i] = malloc(sizeof(int*)*len);\\n        for (int j = 0 ; j < len ; j++){\\n            list[i][j] = malloc(sizeof(int)*k);\\n            if (pizza[i][j] == \\'A\\'){\\n                apple++;\\n            }"], ["int ways(char ** pizza, int pizzaSize, int k){\\n\\tconst int colLen = strlen(pizza[0]);\\n\\n\\tint * * appleCntsArr = (int * *)malloc(sizeof (int *) * pizzaSize);\\n\\tfor (int i = 0; i < pizzaSize; i += 1){\\n\\t\\tappleCntsArr[i] = (int *)malloc(sizeof (int) * colLen);\\n\\t\\tfor (int j = 0; j < colLen; j += 1){\\n\\t\\t\\tappleCntsArr[i][j] = (pizza[i][j] != \\'.\\');\\n\\t\\t}"]]}
{"id": "2006", "ref_c": [["long long countPairs(int n, int** edges, int edgesSize, int* edgesColSize){\\n    DSU* dsu = createDSU(n);\\n    int* root = dsu->root;\\n    int* rank = dsu->rank;\\n    int* setSize = dsu->setSize;\\n    //traverse all edges and unite sets.\\n    for(int i = 0; i < edgesSize; i++){\\n        int e1 = edges[i][0];\\n        int e2 = edges[i][1];\\n        setUnion(root, rank, setSize, e1, e2);\\n    }"], ["long long countPairs(int n, int** edges, int edgesSize, int* edgesColSize){\\n    DSU* dsu = createDSU(n);\\n    int* root = dsu->root;\\n    int* rank = dsu->rank;\\n    int* setSize = dsu->setSize;\\n    //traverse all edges and unite sets.\\n    for(int i = 0; i < edgesSize; i++){\\n        int e1 = edges[i][0];\\n        int e2 = edges[i][1];\\n        setUnion(root, rank, setSize, e1, e2);\\n    }"], ["long long countPairs(int n, int** edges, int edgesSize, int* edgesColSize){\\n    \\n    int *roots = (int *)malloc(sizeof(int) * n);\\n    int *sizes = (int *)malloc(sizeof(int) * n);\\n    for (int i = 0; i < n; i ++) {\\n        roots[i] = -1;\\n        sizes[i] = 1;\\n    }"]]}
{"id": "2007", "ref_c": [["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n    int val = 0,prev;\\n    for(int i = 0; s[i]; i++){\\n        prev = val;\\n        val = val ^ (1 << (s[i]-\\'a\\'));\\n        if(val < prev)\\n            return s[i];\\n    }"], ["char repeatedCharacter(char * s){\\n\\n    char a[26]={0}"]]}
{"id": "2008", "ref_c": [["int maxDotProduct(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n\\n    //Initializing the required values globally so we can avoid passing them as function arguments\\n    l1 = nums1Size;\\n    l2 = nums2Size;\\n    nums1Ptr = nums1;\\n    nums2Ptr = nums2;\\n\\n    //Initialzing DP table as needed \\n    for(int i=0;i<nums1Size;i++) {\\n        for(int j=0;j<nums2Size;j++) {\\n            dp[i][j] = 0x80000000;\\n        }"], ["int maxDotProduct(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    nums1Size = nums1Size;\\n    nums2Size = nums2Size;\\n    memset(dp, -1, sizeof(dp));\\n\\n    int firstMax = INT_MIN;\\n    int secondMax = INT_MIN;\\n    int firstMin = INT_MAX;\\n    int secondMin = INT_MAX;\\n\\n    for (int i = 0; i < nums1Size; i++) {\\n        firstMax = firstMax > nums1[i] ? firstMax : nums1[i];\\n        firstMin = firstMin < nums1[i] ? firstMin : nums1[i];\\n    }"], ["int maxDotProduct(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n\\n    //Initializing the required values globally so we can avoid passing them as function arguments\\n    l1 = nums1Size;\\n    l2 = nums2Size;\\n    nums1Ptr = nums1;\\n    nums2Ptr = nums2;\\n\\n    //Initialzing DP table as needed \\n    for(int i=0;i<nums1Size;i++) {\\n        for(int j=0;j<nums2Size;j++) {\\n            dp[i][j] = 0x80000000;\\n        }"]]}
{"id": "2009", "ref_c": [["int cherryPickup(int** grid, int gridSize, int* gridColSize){\\n    memset(dp, -1, sizeof(dp));\\n    return dfs(grid, gridSize, *gridColSize, 0, 0, *gridColSize - 1);\\n}"], ["int cherryPickup(int** grid, int gridSize, int* gridColSize){\\n    memset(dp, -1, sizeof(dp));\\n    return dfs(grid, gridSize, *gridColSize, 0, 0, *gridColSize - 1);\\n}"], ["int cherryPickup(int** grid, int gridSize, int* gridColSize){\\n    // The position in first row is already set and there is no point in letting\\n\\t// a robot go into the same square or cross over to the other side of \\n\\t// another robot, so we can reduce the array size we use here.\\n    int dp[(gridSize - 1) * (gridColSize[0] - 1) * (gridColSize[0] - 1)];\\n    int max = grid[0][0] + grid[0][gridColSize[0] - 1];\\n    \\n    memset(dp, 0xFF, sizeof(dp));\\n    \\n    max += getMax(dp, grid, 1, gridSize, 0, gridColSize[0] - 1, gridColSize[0]);\\n    return max;\\n}"]]}
{"id": "2010", "ref_c": [["struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if (root1 != NULL && root2 != NULL)\\n        root1->val += root2->val;\\n    else if (root1 == NULL)\\n        return root2;\\n    else\\n        return root1;\\n\\n    root1->left = mergeTrees(root1->left, root2->left);\\n    root1->right = mergeTrees(root1->right, root2->right); \\n    return root1;\\n}"], ["struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if (root1 != NULL && root2 != NULL)\\n        root1->val += root2->val;\\n    else if (root1 == NULL)\\n        return root2;\\n    else\\n        return root1;\\n\\n    root1->left = mergeTrees(root1->left, root2->left);\\n    root1->right = mergeTrees(root1->right, root2->right); \\n    return root1;\\n}"], ["struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2)\\n{\\n    if (root1 != NULL && root2 != NULL)\\n        root1->val += root2->val;\\n    else if (root1 == NULL)\\n        return root2;\\n    else\\n        return root1;\\n\\n    root1->left = mergeTrees(root1->left, root2->left);\\n    root1->right = mergeTrees(root1->right, root2->right); \\n    return root1;\\n}"]]}
{"id": "2011", "ref_c": [["int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target){\\n    int dp[m][n][target+1];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int k=1;k<=target;k++)\\n            {\\n                    dp[i][j][k] = INT_MAX; // it means not possible to achive this state\\n                    if(i==0)             //base case\\n                    {\\n                       if(k == 1)\\n                       {\\n                           if(houses[i] == 0)\\n                           dp[i][j][k] = cost[i][j];\\n                           else\\n                           if(houses[i] != 0 && houses[i]-1 == j)\\n                           dp[i][j][k] = 0;\\n                       }"], ["int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target){\\n    int dp[m][n][target+1];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int k=1;k<=target;k++)\\n            {\\n                    dp[i][j][k] = INT_MAX; // it means not possible to achive this state\\n                    if(i==0)             //base case\\n                    {\\n                       if(k == 1)\\n                       {\\n                           if(houses[i] == 0)\\n                           dp[i][j][k] = cost[i][j];\\n                           else\\n                           if(houses[i] != 0 && houses[i]-1 == j)\\n                           dp[i][j][k] = 0;\\n                       }"], ["int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target){\\n    int dp[m][n][target+1];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int k=1;k<=target;k++)\\n            {\\n                    dp[i][j][k] = INT_MAX; // it means not possible to achive this state\\n                    if(i==0)             //base case\\n                    {\\n                       if(k == 1)\\n                       {\\n                           if(houses[i] == 0)\\n                           dp[i][j][k] = cost[i][j];\\n                           else\\n                           if(houses[i] != 0 && houses[i]-1 == j)\\n                           dp[i][j][k] = 0;\\n                       }"]]}
{"id": "2012", "ref_c": [["int rangeSumBST(struct TreeNode* root, int low, int high) {\\n    if (root == NULL) {\\n                return 0;\\n                    }"], ["int rangeSumBST(struct TreeNode* root, int low, int high) {\\n    int sum=0;\\n    if(root == NULL)\\n        return 0;\\n    if(root->val >= low && root->val <= high)\\n        sum+=root->val;\\n     if(root->val > low)\\n        sum+= rangeSumBST(root->left,low,high);\\n     if(root->val < high)\\n        sum+= rangeSumBST(root->right,low,high);\\n    return sum;\\n}"], ["int rangeSumBST(struct TreeNode* root, int low, int high){\\n    if(root==NULL){\\n        return 0;\\n    }"]]}
{"id": "2014", "ref_c": [["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if(!root) return root;\\n    root = DFS(root, val, depth, 1, -1);/* -1:left node, 1: right node */\\n    return root;\\n}"], ["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if (depth == 1){ // case 1, add new root\\n        struct TreeNode* newRoot = malloc(sizeof(struct TreeNode));\\n        newRoot->val = val;\\n        newRoot->left = root;\\n        newRoot->right = NULL;\\n        return newRoot;\\n    }"], ["struct TreeNode* addOneRow(struct TreeNode* root, int val, int depth){\\n    if (depth == 1){ // case 1, add new root\\n        struct TreeNode* newRoot = malloc(sizeof(struct TreeNode));\\n        newRoot->val = val;\\n        newRoot->left = root;\\n        newRoot->right = NULL;\\n        return newRoot;\\n    }"]]}
{"id": "2015", "ref_c": [["int uniqueLetterString(char * s){\\n    int64_t total = 0;\\n    int prev[128] = { 0 }"], ["int uniqueLetterString(char * s){\\n    int64_t total = 0;\\n    int prev[128] = { 0 }"], ["int uniqueLetterString(char * s){\\n    int64_t total = 0;\\n    int prev[128] = { 0 }"]]}
{"id": "2016", "ref_c": [["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"]]}
{"id": "2017", "ref_c": ["\nstruct word {\n    char sorted[256];\n    char s[256];\n    UT_hash_handle hh;\n};\n\nint comp(const void *aa, const void *bb)\n{\n    char a, b;\n    a = *(char *)aa;\n    b = *(char *)bb;\n    \n    if (a < b)\n        return -1;\n    else if (a > b)\n        return 1;\n    else\n        return 0;\n}\n\nchar *sort_string(char *s)\n{\n    char *rs = malloc(strlen(s)+1);\n    assert(rs);\n    strcpy(rs, s);\n    qsort((void *)rs, strlen(rs), 1, comp);\n    return rs;\n}\n\nint word_sort(struct word *a, struct word *b) {\n    return strcmp(a->sorted,b->sorted);\n}\n\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\n    struct word *w, *tmp;\n    int i;\n    struct word *words = NULL;\n    \n    for (i = 0; i < strsSize; i++) {\n        char *sorted = sort_string(strs[i]);\n        w = (struct word *)malloc(sizeof *w);\n        strncpy(w->sorted, sorted, 256);\n        strncpy(w->s, strs[i], 256);\n        HASH_ADD_STR( words, sorted, w );\n        free(sorted);\n    }\n    \n    char ***ret = malloc(strsSize * sizeof(char *));\n    int *retcolsizes = malloc(strsSize * sizeof(int));\n    *returnColumnSizes = retcolsizes;\n    assert(*returnColumnSizes);\n    assert(ret);\n    \n    *returnSize = -1;\n    char *anagram = NULL;\n    \n    /* XXX: what we would like is something like (python):\n     *      return dic.values();\n     * I know its C, but there has to be a better way.\n     */\n    HASH_SORT(words, word_sort);\n    HASH_ITER(hh, words, w, tmp) {\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n        } else {\n            *returnSize += 1;\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\n            assert(ret[*returnSize]);\n            retcolsizes[*returnSize] = 0;\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n            anagram = w->sorted;\n        }\n    }\n    \n    /* XXX: we are leaking a bunch of memory for the struct word's*/\n    *returnSize += 1;\n    return ret;\n}\n", "\nstruct word {\n    char sorted[256];\n    char s[256];\n    UT_hash_handle hh;\n};\n\nint comp(const void *aa, const void *bb)\n{\n    char a, b;\n    a = *(char *)aa;\n    b = *(char *)bb;\n    \n    if (a < b)\n        return -1;\n    else if (a > b)\n        return 1;\n    else\n        return 0;\n}\n\nchar *sort_string(char *s)\n{\n    char *rs = malloc(strlen(s)+1);\n    assert(rs);\n    strcpy(rs, s);\n    qsort((void *)rs, strlen(rs), 1, comp);\n    return rs;\n}\n\nint word_sort(struct word *a, struct word *b) {\n    return strcmp(a->sorted,b->sorted);\n}\n\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\n    struct word *w, *tmp;\n    int i;\n    struct word *words = NULL;\n    \n    for (i = 0; i < strsSize; i++) {\n        char *sorted = sort_string(strs[i]);\n        w = (struct word *)malloc(sizeof *w);\n        strncpy(w->sorted, sorted, 256);\n        strncpy(w->s, strs[i], 256);\n        HASH_ADD_STR( words, sorted, w );\n        free(sorted);\n    }\n    \n    char ***ret = malloc(strsSize * sizeof(char *));\n    int *retcolsizes = malloc(strsSize * sizeof(int));\n    *returnColumnSizes = retcolsizes;\n    assert(*returnColumnSizes);\n    assert(ret);\n    \n    *returnSize = -1;\n    char *anagram = NULL;\n    \n    /* XXX: what we would like is something like (python):\n     *      return dic.values();\n     * I know its C, but there has to be a better way.\n     */\n    HASH_SORT(words, word_sort);\n    HASH_ITER(hh, words, w, tmp) {\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n        } else {\n            *returnSize += 1;\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\n            assert(ret[*returnSize]);\n            retcolsizes[*returnSize] = 0;\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n            anagram = w->sorted;\n        }\n    }\n    \n    /* XXX: we are leaking a bunch of memory for the struct word's*/\n    *returnSize += 1;\n    return ret;\n}\n", "\nstruct word {\n    char sorted[256];\n    char s[256];\n    UT_hash_handle hh;\n};\n\nint comp(const void *aa, const void *bb)\n{\n    char a, b;\n    a = *(char *)aa;\n    b = *(char *)bb;\n    \n    if (a < b)\n        return -1;\n    else if (a > b)\n        return 1;\n    else\n        return 0;\n}\n\nchar *sort_string(char *s)\n{\n    char *rs = malloc(strlen(s)+1);\n    assert(rs);\n    strcpy(rs, s);\n    qsort((void *)rs, strlen(rs), 1, comp);\n    return rs;\n}\n\nint word_sort(struct word *a, struct word *b) {\n    return strcmp(a->sorted,b->sorted);\n}\n\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\n    struct word *w, *tmp;\n    int i;\n    struct word *words = NULL;\n    \n    for (i = 0; i < strsSize; i++) {\n        char *sorted = sort_string(strs[i]);\n        w = (struct word *)malloc(sizeof *w);\n        strncpy(w->sorted, sorted, 256);\n        strncpy(w->s, strs[i], 256);\n        HASH_ADD_STR( words, sorted, w );\n        free(sorted);\n    }\n    \n    char ***ret = malloc(strsSize * sizeof(char *));\n    int *retcolsizes = malloc(strsSize * sizeof(int));\n    *returnColumnSizes = retcolsizes;\n    assert(*returnColumnSizes);\n    assert(ret);\n    \n    *returnSize = -1;\n    char *anagram = NULL;\n    \n    /* XXX: what we would like is something like (python):\n     *      return dic.values();\n     * I know its C, but there has to be a better way.\n     */\n    HASH_SORT(words, word_sort);\n    HASH_ITER(hh, words, w, tmp) {\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n        } else {\n            *returnSize += 1;\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\n            assert(ret[*returnSize]);\n            retcolsizes[*returnSize] = 0;\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc'ed\n            retcolsizes[*returnSize] += 1;\n            anagram = w->sorted;\n        }\n    }\n    \n    /* XXX: we are leaking a bunch of memory for the struct word's*/\n    *returnSize += 1;\n    return ret;\n}\n"]}
{"id": "2018", "ref_c": [["bool winnerSquareGame(int n){\\n    int dp[100001] = {0}"], ["bool winnerSquareGame(int n){\\n    bool flag[n+2];\\n    memset(flag, false, n+2);\\n    for(int i=0; i<=n+1; i++){\\n        if(!flag[i]){\\n            for(int j = 1; j*j+i<=n;j++){\\n                flag[i+j*j] = true;\\n            }"], ["bool winnerSquareGame(int n){\\n    int i,k, *dp = (int*)calloc(sizeof(int), (n+1));\\n    for(i=1; i<=n; ++i)\\n        for(k=1; (k*k)<=i; k++)\\n            if(dp[i - (k*k)] == 0){\\n                dp[i] = 1;\\n                break;\\n            }"]]}
{"id": "2019", "ref_c": [["int tupleSameProduct(int* nums, int numsSize) {\\n    // Brute force\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(100000000)\\n\\n    int result = 0;\\n    int* count = (int*)calloc(100000000, sizeof(int));\\n    for (int i = 0; i < numsSize; ++i) {\\n        for (int j = 0; j < i; ++j) {\\n            const int product = nums[i] * nums[j];\\n            result += (count[product] * 8);\\n            count[product]++;\\n        }"], ["int tupleSameProduct(int* nums, int numsSize) {\\n    // Brute force\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(100000000)\\n\\n    int result = 0;\\n    int* count = (int*)calloc(100000000, sizeof(int));\\n    for (int i = 0; i < numsSize; ++i) {\\n        for (int j = 0; j < i; ++j) {\\n            const int product = nums[i] * nums[j];\\n            result += (count[product] * 8);\\n            count[product]++;\\n        }"], ["int tupleSameProduct(int* nums, int numsSize) {\\n    // Brute force\\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(100000000)\\n\\n    int result = 0;\\n    int* count = (int*)calloc(100000000, sizeof(int));\\n    for (int i = 0; i < numsSize; ++i) {\\n        for (int j = 0; j < i; ++j) {\\n            const int product = nums[i] * nums[j];\\n            result += (count[product] * 8);\\n            count[product]++;\\n        }"]]}
{"id": "2020", "ref_c": [["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"], ["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"], ["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"]]}
{"id": "2021", "ref_c": [["int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = imageSize;\\n    *returnColumnSizes = imageColSize;\\n    for(int i=0; i<imageSize; i++){\\n        for(int j=0; j<*imageColSize/2; j++){\\n            int temp = image[i][j];\\n            image[i][j] = image[i][*imageColSize-j-1];\\n            image[i][*imageColSize-j-1] = temp;\\n        }"], ["int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes) {\\n\\n  int **ret = (int **)malloc(sizeof(int *) * imageSize);\\n\\n  for (int i = 0; i < imageSize; i++) {\\n    ret[i] = (int *)malloc(sizeof(int)*imageSize);\\n  }"], ["int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = imageSize;\\n    *returnColumnSizes = imageColSize;\\n    int temp =0,i,j;\\n\\n    for( i = 0; i < imageSize; i++)\\n    {\\n        for(j = 0; j < *imageColSize / 2; j ++){\\n            temp = image[i][j];\\n            image[i][j] = image[i][*imageColSize - 1 - j];\\n            image[i][*imageColSize - 1 - j] = temp;\\n        }"]]}
{"id": "2022", "ref_c": [["int minNumberOperations(int* target, int targetSize){\\n    int ret = 0;\\n    int prev = -1;\\n    int i;\\n    int check = 0;\\n    for(i=0;i<targetSize;i++){\\n        if(prev == -1)\\n            check = target[0];\\n        else{\\n            if(prev < target[i]){\\n                check = target[i] - prev;\\n            }"], ["int minNumberOperations(int* target, int targetSize){\\n    int count = target[0];                      //minimum operations shall always be \\n                                                //the value of first element in the array\\n    for (int i = 0; i < targetSize-1; i++) {\\n        if(target[i] < target[i+1]) {            //if next elements is greater,\\n            count += target[i+1] - target[i];   //then increment count to its difference \\n                                                //as we shall perform so many operations.\\n        }"], ["int minNumberOperations(int* target, int targetSize){\\n    int count = target[0];                      //minimum operations shall always be \\n                                                //the value of first element in the array\\n    for (int i = 0; i < targetSize-1; i++) {\\n        if(target[i] < target[i+1]) {            //if next elements is greater,\\n            count += target[i+1] - target[i];   //then increment count to its difference \\n                                                //as we shall perform so many operations.\\n        }"]]}
{"id": "2023", "ref_c": [["int sumSubarrayMins(int* arr, int arrSize){\\n    int *stk = calloc(arrSize, sizeof(int));\\n    int *PLE = calloc(arrSize, sizeof(int)); \\n    // store the distance between element arr[i] and its PLE (Previous Less Element)\\n    int *NLE = calloc(arrSize, sizeof(int)); \\n    // store the distance between element arr[i] and its NLE (Next Less Element)\\n    int pt = -1;    // current stack index, \"-1\" means the stack is empty\\n\\n    //initialize\\n    for(int i = 0; i < arrSize; i++){\\n        PLE[i] = i + 1;\\n        NLE[i] = arrSize - i;\\n    }"], ["int sumSubarrayMins(int* arr, int arrSize) {\\n    const int MOD = 1000000007;\\n    int stack[arrSize];\\n    int top = -1;\\n    long long result = 0;\\n\\n    for (int i = 0; i <= arrSize; ++i) {\\n        while (top != -1 && (i == arrSize || arr[i] < arr[stack[top]])) {\\n            int j = stack[top--];\\n            int prev = (top == -1) ? -1 : stack[top];\\n            result += (long long)(i - j) * (j - prev) * arr[j];\\n            result %= MOD;\\n        }"], ["int sumSubarrayMins(int* arr, int arrSize){\\n    int *stk = calloc(arrSize, sizeof(int));\\n    int *PLE = calloc(arrSize, sizeof(int)); \\n    // store the distance between element arr[i] and its PLE (Previous Less Element)\\n    int *NLE = calloc(arrSize, sizeof(int)); \\n    // store the distance between element arr[i] and its NLE (Next Less Element)\\n    int pt = -1;    // current stack index, \"-1\" means the stack is empty\\n\\n    //initialize\\n    for(int i = 0; i < arrSize; i++){\\n        PLE[i] = i + 1;\\n        NLE[i] = arrSize - i;\\n    }"]]}
{"id": "2024", "ref_c": [["char findKthBit(int n, int k) {\\n        int[] arr = { 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072,\\n                262144, 524288 }"], ["char findKthBit(int n, int k) {\\n        int[] arr = { 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072,\\n                262144, 524288 }"], ["char findKthBit(int n, int k) {\\n        int[] arr = { 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072,\\n                262144, 524288 }"]]}
{"id": "2025", "ref_c": [["int findIntegers(int n) {\\n    int dp[31] = {0}"], ["int findIntegers(int n) {\\n    int dp[31] = {0}"], ["int findIntegers(int n) {\\n    int dp[31] = {0}"]]}
{"id": "2026", "ref_c": [["int minCost(int n, int* cuts, int cutsSize){\\n    int dp[cutsSize * cutsSize];\\n    \\n    qsort(cuts, cutsSize, sizeof(int), compare);\\n    \\n    memset(dp, 0xFF, sizeof(dp));\\n    return getMin(dp, cuts, -1, cutsSize, cutsSize, n);\\n}"], ["int minCost(int n, int* cuts, int cutsSize){\\n    int dp[cutsSize * cutsSize];\\n    \\n    qsort(cuts, cutsSize, sizeof(int), compare);\\n    \\n    memset(dp, 0xFF, sizeof(dp));\\n    return getMin(dp, cuts, -1, cutsSize, cutsSize, n);\\n}"], ["int minCost(int n, int* cuts, int cutsSize){\\n    int dp[cutsSize * cutsSize];\\n    \\n    qsort(cuts, cutsSize, sizeof(int), compare);\\n    \\n    memset(dp, 0xFF, sizeof(dp));\\n    return getMin(dp, cuts, -1, cutsSize, cutsSize, n);\\n}"]]}
{"id": "2027", "ref_c": ["\nbool isMatch(char* s, char* p) {\n    int sLen = strlen(s), pLen = strlen(p);\n    bool dp[sLen+1][pLen+1];\n    memset(dp, false, sizeof(dp));\n    dp[sLen][pLen] = true;\n\n    for (int i = sLen; i >= 0; i--){\n        for (int j = pLen - 1; j >= 0; j--){\n            bool first_match = (i < sLen && (p[j] == s[i] || p[j] == '?'));\n            if (p[j] == '*'){\n                dp[i][j] = dp[i][j+1] || (i < sLen && dp[i+1][j]);\n            } else {\n                dp[i][j] = first_match && dp[i+1][j+1];\n            }\n        }\n    }\n    return dp[0][0];\n}\n", "\nbool isMatch(char* s, char* p) {\n    int sLen = strlen(s), pLen = strlen(p);\n    bool dp[sLen+1][pLen+1];\n    memset(dp, false, sizeof(dp));\n    dp[sLen][pLen] = true;\n\n    for (int i = sLen; i >= 0; i--){\n        for (int j = pLen - 1; j >= 0; j--){\n            bool first_match = (i < sLen && (p[j] == s[i] || p[j] == '?'));\n            if (p[j] == '*'){\n                dp[i][j] = dp[i][j+1] || (i < sLen && dp[i+1][j]);\n            } else {\n                dp[i][j] = first_match && dp[i+1][j+1];\n            }\n        }\n    }\n    return dp[0][0];\n}\n", "\nbool isMatch(char* s, char* p) {\n    int sLen = strlen(s), pLen = strlen(p);\n    bool dp[sLen+1][pLen+1];\n    memset(dp, false, sizeof(dp));\n    dp[sLen][pLen] = true;\n\n    for (int i = sLen; i >= 0; i--){\n        for (int j = pLen - 1; j >= 0; j--){\n            bool first_match = (i < sLen && (p[j] == s[i] || p[j] == '?'));\n            if (p[j] == '*'){\n                dp[i][j] = dp[i][j+1] || (i < sLen && dp[i+1][j]);\n            } else {\n                dp[i][j] = first_match && dp[i+1][j+1];\n            }\n        }\n    }\n    return dp[0][0];\n}\n"]}
{"id": "2028", "ref_c": [["int stoneGameV(int* stoneValue, int stoneValueSize)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    if(stoneValueSize == 1)\\n        return 0;\\n        \\n    int i;\\n    int* sumValue = (int*)malloc(sizeof(int) * (stoneValueSize + 1));\\n    sumValue[0] = 0;\\n    sumValue[1] = stoneValue[0];\\n    \\n    for(i = 1; i < stoneValueSize; i++)\\n        sumValue[i + 1] = sumValue[i] + stoneValue[i];\\n    \\n    return playGame(sumValue, stoneValue, 0, stoneValueSize - 1);\\n}"], ["int stoneGameV(int* stoneValue, int stoneValueSize)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    if(stoneValueSize == 1)\\n        return 0;\\n        \\n    int i;\\n    int* sumValue = (int*)malloc(sizeof(int) * (stoneValueSize + 1));\\n    sumValue[0] = 0;\\n    sumValue[1] = stoneValue[0];\\n    \\n    for(i = 1; i < stoneValueSize; i++)\\n        sumValue[i + 1] = sumValue[i] + stoneValue[i];\\n    \\n    return playGame(sumValue, stoneValue, 0, stoneValueSize - 1);\\n}"], ["int stoneGameV(int* stoneValue, int stoneValueSize)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    if(stoneValueSize == 1)\\n        return 0;\\n        \\n    int i;\\n    int* sumValue = (int*)malloc(sizeof(int) * (stoneValueSize + 1));\\n    sumValue[0] = 0;\\n    sumValue[1] = stoneValue[0];\\n    \\n    for(i = 1; i < stoneValueSize; i++)\\n        sumValue[i + 1] = sumValue[i] + stoneValue[i];\\n    \\n    return playGame(sumValue, stoneValue, 0, stoneValueSize - 1);\\n}"]]}
{"id": "2029", "ref_c": ["\nstruct TreeNode** allPossibleFBTHelper(int N, int* returnSize, struct TreeNode ***fbt, int *fbtSize) \n{\n    struct TreeNode **ret = malloc(sizeof(struct TreeNode*));\n    *returnSize = 0;\n\n    if (N == 1) \n    {\n        struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n        ret = realloc(ret, sizeof(struct TreeNode) * ((*returnSize) + 1));\n        ret[*returnSize] = root;\n        *returnSize += 1;\n        return ret;\n    }\n\n    for (int x = 1; x <= N - 2; x += 2) \n    {\n        int lSize = fbtSize[x], rSize = fbtSize[N-x-1];\n        for (int i = 0; i < lSize; i++) \n        {\n            for (int j = 0; j < rSize; j++) \n            {\n                struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n                root->left = fbt[x][i];\n                root->right = fbt[N-x-1][j];\n                ret = realloc(ret, sizeof(struct TreeNode)*((*returnSize) + 1));\n                ret[*returnSize] = root;\n                *returnSize += 1;\n            }\n        }\n    }\n    return ret;    \n}\n\nstruct TreeNode** allPossibleFBT(int N, int* returnSize)\n{\n    if ((N % 2) == 0)\n    {\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    struct TreeNode **fbt[21];\n    int fbtSize[21] = {0};\n    for (int i = 1; i <= N; i+=2)\n    {\n        int tmpSize = 0;\n        fbt[i] = allPossibleFBTHelper(i, &tmpSize, fbt, fbtSize);\n        fbtSize[i] = tmpSize;\n    }\n\n    *returnSize = fbtSize[N];    \n    return fbt[N];\n}\n", "\nstruct TreeNode** allPossibleFBTHelper(int N, int* returnSize, struct TreeNode ***fbt, int *fbtSize) \n{\n    struct TreeNode **ret = malloc(sizeof(struct TreeNode*));\n    *returnSize = 0;\n\n    if (N == 1) \n    {\n        struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n        ret = realloc(ret, sizeof(struct TreeNode) * ((*returnSize) + 1));\n        ret[*returnSize] = root;\n        *returnSize += 1;\n        return ret;\n    }\n\n    for (int x = 1; x <= N - 2; x += 2) \n    {\n        int lSize = fbtSize[x], rSize = fbtSize[N-x-1];\n        for (int i = 0; i < lSize; i++) \n        {\n            for (int j = 0; j < rSize; j++) \n            {\n                struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n                root->left = fbt[x][i];\n                root->right = fbt[N-x-1][j];\n                ret = realloc(ret, sizeof(struct TreeNode)*((*returnSize) + 1));\n                ret[*returnSize] = root;\n                *returnSize += 1;\n            }\n        }\n    }\n    return ret;    \n}\n\nstruct TreeNode** allPossibleFBT(int N, int* returnSize)\n{\n    if ((N % 2) == 0)\n    {\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    struct TreeNode **fbt[21];\n    int fbtSize[21] = {0};\n    for (int i = 1; i <= N; i+=2)\n    {\n        int tmpSize = 0;\n        fbt[i] = allPossibleFBTHelper(i, &tmpSize, fbt, fbtSize);\n        fbtSize[i] = tmpSize;\n    }\n\n    *returnSize = fbtSize[N];    \n    return fbt[N];\n}\n", "\nstruct TreeNode** allPossibleFBTHelper(int N, int* returnSize, struct TreeNode ***fbt, int *fbtSize) \n{\n    struct TreeNode **ret = malloc(sizeof(struct TreeNode*));\n    *returnSize = 0;\n\n    if (N == 1) \n    {\n        struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n        ret = realloc(ret, sizeof(struct TreeNode) * ((*returnSize) + 1));\n        ret[*returnSize] = root;\n        *returnSize += 1;\n        return ret;\n    }\n\n    for (int x = 1; x <= N - 2; x += 2) \n    {\n        int lSize = fbtSize[x], rSize = fbtSize[N-x-1];\n        for (int i = 0; i < lSize; i++) \n        {\n            for (int j = 0; j < rSize; j++) \n            {\n                struct TreeNode *root = calloc(1, sizeof(struct TreeNode));\n                root->left = fbt[x][i];\n                root->right = fbt[N-x-1][j];\n                ret = realloc(ret, sizeof(struct TreeNode)*((*returnSize) + 1));\n                ret[*returnSize] = root;\n                *returnSize += 1;\n            }\n        }\n    }\n    return ret;    \n}\n\nstruct TreeNode** allPossibleFBT(int N, int* returnSize)\n{\n    if ((N % 2) == 0)\n    {\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    struct TreeNode **fbt[21];\n    int fbtSize[21] = {0};\n    for (int i = 1; i <= N; i+=2)\n    {\n        int tmpSize = 0;\n        fbt[i] = allPossibleFBTHelper(i, &tmpSize, fbt, fbtSize);\n        fbtSize[i] = tmpSize;\n    }\n\n    *returnSize = fbtSize[N];    \n    return fbt[N];\n}\n"]}
{"id": "2030", "ref_c": [["int numOfWays(int* nums, int numsSize){\\n  int i, j;\\n\\n  int **combination_table = (int**)malloc(sizeof(int*)*numsSize);\\n  for(i=0;i<numsSize;i++)\\n    combination_table[i] = (int*)malloc(sizeof(int)*numsSize);\\n  \\n  for(i=0;i<numsSize;i++)\\n  {\\n    for(j=0;j<=i;j++)\\n    {\\n      if(j==0 || i==j)\\n        combination_table[i][j] = 1;\\n      else\\n        combination_table[i][j] = (combination_table[i-1][j] + combination_table[i-1][j-1])%MOD;\\n    }"], ["int numOfWays(int* nums, int numsSize){\\n  int i, j;\\n\\n  int **combination_table = (int**)malloc(sizeof(int*)*numsSize);\\n  for(i=0;i<numsSize;i++)\\n    combination_table[i] = (int*)malloc(sizeof(int)*numsSize);\\n  \\n  for(i=0;i<numsSize;i++)\\n  {\\n    for(j=0;j<=i;j++)\\n    {\\n      if(j==0 || i==j)\\n        combination_table[i][j] = 1;\\n      else\\n        combination_table[i][j] = (combination_table[i-1][j] + combination_table[i-1][j-1])%MOD;\\n    }"], ["int numOfWays(int* nums, int numsSize){\\n    // create Pascal\\'s triangle\\n    long long* triangle = createPascalTriangle(numsSize);\\n    // recursively quest for result\\n    long long allWays = numOfWaysRecursive(nums, numsSize, triangle);\\n    // return final result excluding initial array\\n    return allWays - 1;\\n}"]]}
{"id": "2031", "ref_c": [["int countRoutes(int* locations, int locationsSize, int start, int finish, int fuel){\\n    int ans = 0;\\n    int **memo = (int **)malloc(sizeof(int *) * locationsSize);\\n    for(int i = 0; i < locationsSize; i++){\\n        memo[i] = (int *)malloc(sizeof(int) * (fuel + 1));\\n        for(int j = 0; j <= fuel; j++){\\n            memo[i][j] = -1;\\n        }"], ["int countRoutes(int* locations, int locationsSize, int start, int finish, int fuel){\\n    int ans = 0;\\n    int **memo = (int **)malloc(sizeof(int *) * locationsSize);\\n    for(int i = 0; i < locationsSize; i++){\\n        memo[i] = (int *)malloc(sizeof(int) * (fuel + 1));\\n        for(int j = 0; j <= fuel; j++){\\n            memo[i][j] = -1;\\n        }"], ["int countRoutes(int* locations, int locationsSize, int start, int finish, int fuel){\\n    int ans = 0;\\n    int **memo = (int **)malloc(sizeof(int *) * locationsSize);\\n    for(int i = 0; i < locationsSize; i++){\\n        memo[i] = (int *)malloc(sizeof(int) * (fuel + 1));\\n        for(int j = 0; j <= fuel; j++){\\n            memo[i][j] = -1;\\n        }"]]}
{"id": "2032", "ref_c": [["int maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize) {\\n    // e, f, g: # of edges\\n    // b, c, d: # of components\\n    // p, q, r: union-find\\n    int e = 0, f = 0, g = 0, b = n, c = n, d = n;\\n    int *p = malloc(n * sizeof(*p));\\n    int *q = malloc(n * sizeof(*q));\\n    int *r = malloc(n * sizeof(*r));\\n    for (int i = 0; i < n; ++i) {\\n        p[i] = q[i] = r[i] = -1;\\n    }", "int maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize) {\\n    // e[]: # of edges, c[]: # of components, p[]: union-find\\n    // index 0 for type 3\\n    int e[] = {0, 0, 0}"], ["int maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize) {\\n    // e, f, g: # of edges\\n    // b, c, d: # of components\\n    // p, q, r: union-find\\n    int e = 0, f = 0, g = 0, b = n, c = n, d = n;\\n    int *p = malloc(n * sizeof(*p));\\n    int *q = malloc(n * sizeof(*q));\\n    int *r = malloc(n * sizeof(*r));\\n    for (int i = 0; i < n; ++i) {\\n        p[i] = q[i] = r[i] = -1;\\n    }", "int maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize) {\\n    // e[]: # of edges, c[]: # of components, p[]: union-find\\n    // index 0 for type 3\\n    int e[] = {0, 0, 0}"], ["int maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize) {\\n    // e, f, g: # of edges\\n    // b, c, d: # of components\\n    // p, q, r: union-find\\n    int e = 0, f = 0, g = 0, b = n, c = n, d = n;\\n    int *p = malloc(n * sizeof(*p));\\n    int *q = malloc(n * sizeof(*q));\\n    int *r = malloc(n * sizeof(*r));\\n    for (int i = 0; i < n; ++i) {\\n        p[i] = q[i] = r[i] = -1;\\n    }", "int maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize) {\\n    // e[]: # of edges, c[]: # of components, p[]: union-find\\n    // index 0 for type 3\\n    int e[] = {0, 0, 0}"]]}
{"id": "2033", "ref_c": [["bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){\\n    int cmap[2001][PREREQ_MAX]; /* Holds the prerequisites of each course.  */\\n    int cpr[2001]     = { 0 }"], ["bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){\\n    int cmap[2001][PREREQ_MAX]; /* Holds the prerequisites of each course.  */\\n    int cpr[2001]     = { 0 }"], ["bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize) {\\n    int *visited = calloc(sizeof(int), numCourses);\\n    int **graph = malloc(sizeof(int *) * numCourses);\\n    int *map = calloc(sizeof(int), numCourses);\\n\\n    for(int i = 0; i < numCourses; i++) {\\n        *(graph + i) = malloc(sizeof(int) * 100);\\n    }"]]}
{"id": "2034", "ref_c": [["int countTriples(int n) {\\n    int count = 0;\\n\\n    for (int i = 1; i < n; i++) {\\n\\n        // j starting from i+1, because we don\\'t have to check same pairs again\\n        for (int j = i + 1; j <= n; j++) {\\n            double sumSqrt = sqrt(i * i + j * j);\\n\\n            // if sumSqrt starts to exceed n, we can safely break.\\n            if (sumSqrt > n) break;\\n\\n            // if square root is an integer, increment count\\n            // counting two times, because if a^2 + b^2 = c^2, then b^2 + a^2 = c^2\\n            if (sumSqrt == floor(sumSqrt)) count += 2;\\n        }"], ["int countTriples(int n) \\n{\\n    int count_square_triples = 0;\\n    for(int a = 1; a <= n; a++)\\n    {\\n        for(int b = a; b <= n; b++)\\n        {\\n            int c, first = 1, last = n, flag = 0;\\n            while(first <= last)\\n            {\\n                c = (first + last) / 2;\\n                if(a * a + b * b == c * c)\\n                {\\n                    flag = 1;\\n                    break;\\n                }"], ["int countTriples(int n) {\\n        int ans=0;\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            for(int j=i+1; j<=n; j++)\\n            {\\n                int square = i*i + j*j;\\n                int root = sqrt(square);\\n\\n                if(root<=n && root*root==square)\\n                    ans+=2;\\n            }"]]}
{"id": "2035", "ref_c": [["int rob(int* nums, int numsSize) {\\n    if (numsSize == 0)\\n        return 0;\\n    if (numsSize == 1)\\n        return nums[0];\\n\\n    int evenSum = 0;\\n    int oddSum = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i % 2 == 0)\\n            evenSum = fmax(evenSum + nums[i], oddSum);\\n        else\\n            oddSum = fmax(oddSum + nums[i], evenSum);\\n    }"], ["int rob(int* nums, int numsSize){\\n    int dp[110],i;\\n    if(numsSize==1)\\n        return nums[0];\\n    else if (numsSize==2)\\n        return max(nums[0],nums[1]);\\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n    dp[2]=nums[2]+nums[0];\\n    for(i=3;i<(numsSize+2);i++){        \\n        dp[i]=max(dp[i-2],dp[i-3]);\\n        if(i<numsSize)\\n            dp[i]+=nums[i];\\n        printf(\"%d \",dp[i]);\\n    }"], ["int rob(int* nums, int numsSize) {\\n    if (numsSize == 0)\\n        return 0;\\n    if (numsSize == 1)\\n        return nums[0];\\n\\n    int evenSum = 0;\\n    int oddSum = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (i % 2 == 0)\\n            evenSum = fmax(evenSum + nums[i], oddSum);\\n        else\\n            oddSum = fmax(oddSum + nums[i], evenSum);\\n    }"]]}
{"id": "2036", "ref_c": [["int maximumRequests(int n, int** requests, int requestsSize, int* requestsColSize){\\n    int i, moves, maxMoves = 0;\\n    int requestCounter = 1 << requestsSize;\\n    for (i = 0; i < requestCounter; ++i) {\\n        moves = executeRequests(n, requests, i);\\n        if (moves > maxMoves) {\\n            maxMoves = moves;\\n        }"], ["int maximumRequests(int n, int** requests, int requestsSize, int* requestsColSize){\\n    int i, moves, maxMoves = 0;\\n    int requestCounter = 1 << requestsSize;\\n    for (i = 0; i < requestCounter; ++i) {\\n        moves = executeRequests(n, requests, i);\\n        if (moves > maxMoves) {\\n            maxMoves = moves;\\n        }"], ["int maximumRequests(int n, int** requests, int requestsSize, int* requestsColSize){\\n    int i, moves, maxMoves = 0;\\n    int requestCounter = 1 << requestsSize;\\n    for (i = 0; i < requestCounter; ++i) {\\n        moves = executeRequests(n, requests, i);\\n        if (moves > maxMoves) {\\n            maxMoves = moves;\\n        }"]]}
{"id": "2037", "ref_c": [["bool validMountainArray(int* arr, int arrSize)\\n{\\n    if(arrSize < 3)\\n    {\\n        return false;\\n    }"], ["bool validMountainArray(int* arr, int arrSize){\\n    if (arrSize < 3) {return 0;}"], ["bool validMountainArray(int* arr, int arrSize){\\n    if (arrSize < 3) {return 0;}"]]}
{"id": "2038", "ref_c": ["\nint cmp(const void *a, const void *b)\n{\n    const int  x = ((int **)a)[0][1];\n    const int  y = ((int **)b)[0][1];\n    if(x > y)\n        return 1;\n    else if(x < y)\n        return -1;\n    return 0;\n}\n\nint findMinArrowShots(int** points, int pointsSize, int* pointsColSize){\n    qsort(points, pointsSize, sizeof(int *), cmp);\n    int result = 1, min = points[0][1];\n    for(int i = 1; i < pointsSize; i++)\n    {\n        if(points[i][0] > min)\n        {\n            result++;\n            min = points[i][1];\n        }\n        else\n            min = min < points[i][1] ? min : points[i][1];\n    }\n    return result;\n}\n", "\nint cmp(const void *a, const void *b)\n{\n    const int  x = ((int **)a)[0][1];\n    const int  y = ((int **)b)[0][1];\n    if(x > y)\n        return 1;\n    else if(x < y)\n        return -1;\n    return 0;\n}\n\nint findMinArrowShots(int** points, int pointsSize, int* pointsColSize){\n    qsort(points, pointsSize, sizeof(int *), cmp);\n    int result = 1, min = points[0][1];\n    for(int i = 1; i < pointsSize; i++)\n    {\n        if(points[i][0] > min)\n        {\n            result++;\n            min = points[i][1];\n        }\n        else\n            min = min < points[i][1] ? min : points[i][1];\n    }\n    return result;\n}\n", "\nint cmp(const void *a, const void *b)\n{\n    const int  x = ((int **)a)[0][1];\n    const int  y = ((int **)b)[0][1];\n    if(x > y)\n        return 1;\n    else if(x < y)\n        return -1;\n    return 0;\n}\n\nint findMinArrowShots(int** points, int pointsSize, int* pointsColSize){\n    qsort(points, pointsSize, sizeof(int *), cmp);\n    int result = 1, min = points[0][1];\n    for(int i = 1; i < pointsSize; i++)\n    {\n        if(points[i][0] > min)\n        {\n            result++;\n            min = points[i][1];\n        }\n        else\n            min = min < points[i][1] ? min : points[i][1];\n    }\n    return result;\n}\n"]}
{"id": "2039", "ref_c": [["int minimumOneBitOperations(int n) {\\n\\n    // \\n    int digits = 0;\\n    while(n - (1 << digits) >= 0) digits++;\\n\\n    //\\n    int ans = 0;\\n    int positive = 1;\\n    for(int i = digits; i >= 0; i--){\\n        if(n - (1 << i) >= 0){\\n            \\n            //\\n            if(positive == 1){\\n                ans += geometricSeries(i + 1);\\n                positive = 0;\\n            }"], ["int minimumOneBitOperations(int n) {\\n  int t = 32;\\n  while (t /= 2) {\\n    n ^= (n >> t);\\n  }"], ["int minimumOneBitOperations(int n) {\\n        // Initialize variables to keep track of the result and a flag for toggling operations\\n        int ans = 0, f = 0;\\n\\n        // Loop through the bits of the number from the most significant bit to the least significant bit (from left to right)\\n        for (int i = 31; i >= 0; i--) {\\n            // Check if the i-th bit of the number n is set to 1\\n            if (((n >> i) & 1) == 1) {\\n                // If the flag f is 0 (indicating the start of a sequence of 1s)\\n                if (f == 0) {\\n                    // Add the calculated value to ans by left-shifting 1 to (i+1) and subtracting 1\\n                    ans = ans + ((1 << (i + 1))) - 1;\\n\\n                    // Set the flag f to 1 to indicate the start of an alternating sequence of 1s\\n                    f = 1;\\n                }", "int minimumOneBitOperations(int n) {\\n    int ans = 0, f = 0;\\n\\n    for (int i = 31; i >= 0; i--) {\\n        if (((n >> i) & 1) == 1) {\\n            if (f == 0) {\\n                ans = ans + ((1 << (i + 1))) - 1;\\n                f = 1;\\n            }", "int minimumOneBitOperations(int n) {\\n        int ans = 0, f = 0;\\n        \\n        for (int i = 31; i >= 0; i--) {\\n            if (((n >> i) & 1) == 1) {\\n                if (f == 0) {\\n                    ans = ans + ((1 << (i + 1))) - 1;\\n                    f = 1;\\n                }", "int minimumOneBitOperations(int n) {\\n        // Base case: If n is already 0, no operations are needed, return 0\\n        if (n == 0) {\\n            return 0;\\n        }", "int minimumOneBitOperations(int n) {\\n    if (n == 0) {\\n        return 0;\\n    }", "int minimumOneBitOperations(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }", "int minimumOneBitOperations(int n) {\\n        int ans = 0;  // Initialize a variable to store the final result\\n        int k = 0;    // Initialize a variable to keep track of the current bit position\\n        int mask = 1; // Initialize a mask to check each bit of the number\\n        \\n        // Iterate through each bit of the number from right to left\\n        while (mask <= n) {\\n            // Check if the k-th bit of the number n is set (equal to 1)\\n            if ((n & mask) != 0) {\\n                // If the k-th bit is set, update \\'ans\\' using the formula for the number of one-bit operations\\n                ans = (1 << (k + 1)) - 1 - ans;\\n            }", "int minimumOneBitOperations(int n) {\\n    int ans = 0;\\n    int k = 0;\\n    int mask = 1;\\n    \\n    while (mask <= n) {\\n        if ((n & mask) != 0) {\\n            ans = (1 << (k + 1)) - 1 - ans;\\n        }", "int minimumOneBitOperations(int n) {\\n        int ans = 0;\\n        int k = 0;\\n        int mask = 1;\\n        \\n        while (mask <= n) {\\n            if ((n & mask) != 0) {\\n                ans = (1 << (k + 1)) - 1 - ans;\\n            }", "int minimumOneBitOperations(int n) {\\n        int ans = n;  // Initialize ans with the input number n\\n        \\n        // Applying bitwise XOR operations to gradually reduce the number of one-bit operations needed\\n        ans ^= ans >> 16;  // XOR with shifted right value by 16 bits\\n        ans ^= ans >> 8;   // XOR with shifted right value by 8 bits\\n        ans ^= ans >> 4;   // XOR with shifted right value by 4 bits\\n        ans ^= ans >> 2;   // XOR with shifted right value by 2 bits\\n        ans ^= ans >> 1;   // XOR with shifted right value by 1 bit\\n\\n        return ans;  // Return the result containing the minimum number of one-bit operations\\n    }", "int minimumOneBitOperations(int n) {\\n    int ans = n;  // Initialize ans with the input number n\\n    \\n    // Applying bitwise XOR operations to gradually reduce the number of one-bit operations needed\\n    ans ^= ans >> 16;  // XOR with shifted right value by 16 bits\\n    ans ^= ans >> 8;   // XOR with shifted right value by 8 bits\\n    ans ^= ans >> 4;   // XOR with shifted right value by 4 bits\\n    ans ^= ans >> 2;   // XOR with shifted right value by 2 bits\\n    ans ^= ans >> 1;   // XOR with shifted right value by 1 bit\\n\\n    return ans;  // Return the result containing the minimum number of one-bit operations\\n}", "int minimumOneBitOperations(int n) {\\n        int ans = n;\\n        ans ^= ans >> 16;\\n        ans ^= ans >> 8;\\n        ans ^= ans >> 4;\\n        ans ^= ans >> 2;\\n        ans ^= ans >> 1;\\n        return ans;\\n    }"]]}
{"id": "2040", "ref_c": [["char *** partition(char * s, int* returnSize, int** returnColumnSizes){\\n    int str_len = strlen(s);\\n    int all_pos_cnt = 1<<(str_len-1); //Count for all posiible substring\\n    char *** ret = calloc(all_pos_cnt, sizeof(char**));\\n    *returnSize = 0;\\n\\n    (*returnColumnSizes) = calloc(all_pos_cnt, sizeof(int));\\n\\n    for (int sel_bit = 0; sel_bit < all_pos_cnt; sel_bit++){\\n        char **substr = calloc(str_len, sizeof(char*));\\n        int start = 0;\\n        int sub_idx = 0;\\n        int valid = 1;\\n\\n        for(int ith_b = 0; ith_b < (str_len-1); ith_b++){\\n            if ((  (1<<ith_b) &  sel_bit) > 0){\\n                if(is_P(s, start, ith_b) == 1){\\n                    substr[sub_idx] = calloc((ith_b-start+1+1), sizeof(char)); // + 1 for \\'\\\\0\\'\\n                    memcpy(&substr[sub_idx][0], &s[start], (ith_b-start+1) * sizeof(char));\\n                    substr[sub_idx][ith_b-start+1] = \\'\\\\0\\';\\n                    start = ith_b + 1;\\n                    sub_idx++;\\n                }"], ["char *** partition(char * s, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  *s, string\\n     */\\n\\n    node_t *head = NULL, *del;\\n    char *substr_buf[16], ***ans = NULL;\\n    int substr_len[16] = {0}"], ["char *** partition(char * s, int* returnSize, int** returnColumnSizes){\\n\\n    /*\\n     * Input:\\n     *  *s, string\\n     */\\n\\n    node_t *head = NULL, *del;\\n    char *substr_buf[16], ***ans = NULL;\\n    int substr_len[16] = {0}"]]}
{"id": "2042", "ref_c": [["bool* areConnected(int n, int threshold, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int i, j;\\n    bool *res;\\n    int div = 0;\\n    set_union *s = NULL;\\n    \\n    res = calloc(queriesSize, sizeof(bool));\\n    s = calloc(1, sizeof(set_union));\\n    \\n    *returnSize = queriesSize;\\n    \\n    /*\\n     create a disjoint set of all the vertices first\\n     create connection for all the pairs which with the multiples of i, 2*i\\n\\t where i = threshold + 1\\n\\t go through the queries and update the result using union-find\\n    */\\n    \\n    //initialize the set_union\\n    set_union_init(s, n);\\n    connection(s, threshold, n);\\n  \\n    for (i = 0; i < queriesSize; i++, div = 0) {\\n    if (false == res[i]) {\\n            res[i] = same_component(s, queries[i][0], queries[i][1]);\\n        }"], ["bool* areConnected(int n, int threshold, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int i, j;\\n    bool *res;\\n    int div = 0;\\n    set_union *s = NULL;\\n    \\n    res = calloc(queriesSize, sizeof(bool));\\n    s = calloc(1, sizeof(set_union));\\n    \\n    *returnSize = queriesSize;\\n    \\n    /*\\n     create a disjoint set of all the vertices first\\n     create connection for all the pairs which with the multiples of i, 2*i\\n\\t where i = threshold + 1\\n\\t go through the queries and update the result using union-find\\n    */\\n    \\n    //initialize the set_union\\n    set_union_init(s, n);\\n    connection(s, threshold, n);\\n  \\n    for (i = 0; i < queriesSize; i++, div = 0) {\\n    if (false == res[i]) {\\n            res[i] = same_component(s, queries[i][0], queries[i][1]);\\n        }"], ["bool* areConnected(int n, int threshold, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    int i, j;\\n    bool *res;\\n    int div = 0;\\n    set_union *s = NULL;\\n    \\n    res = calloc(queriesSize, sizeof(bool));\\n    s = calloc(1, sizeof(set_union));\\n    \\n    *returnSize = queriesSize;\\n    \\n    /*\\n     create a disjoint set of all the vertices first\\n     create connection for all the pairs which with the multiples of i, 2*i\\n\\t where i = threshold + 1\\n\\t go through the queries and update the result using union-find\\n    */\\n    \\n    //initialize the set_union\\n    set_union_init(s, n);\\n    connection(s, threshold, n);\\n  \\n    for (i = 0; i < queriesSize; i++, div = 0) {\\n    if (false == res[i]) {\\n            res[i] = same_component(s, queries[i][0], queries[i][1]);\\n        }"]]}
{"id": "2043", "ref_c": [["int** matrixRankTransform(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){\\n    hElem *map = NULL, *s, *t;\\n    int n = matrixSize, m = matrixColSize[0];\\n    int *rank = calloc(sizeof(int), n+m);\\n    *returnSize = n;\\n    *returnColumnSizes = calloc(sizeof(int), n);\\n    for(int i = 0; i < n; i++)\\n        (*returnColumnSizes)[i] = matrixColSize[0];\\n    \\n    // add the locations of the cells with same keys to map\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            int *pair = calloc(sizeof(int), 2);\\n            pair[0] = i, pair[1] = j;\\n            HASH_FIND_INT(map, &matrix[i][j], s);\\n            if(!s) {\\n                s = calloc(sizeof(hElem), 1);\\n                s->elem = matrix[i][j]; s->count = 0; s->size = SIZE;                \\n                s->pair = calloc(sizeof(int *), s->size);\\n                s->pair[s->count++] = pair;\\n                HASH_ADD_INT(map, elem, s);\\n            }"], ["int** matrixRankTransform(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){\\n    hElem *map = NULL, *s, *t;\\n    int n = matrixSize, m = matrixColSize[0];\\n    int *rank = calloc(sizeof(int), n+m);\\n    *returnSize = n;\\n    *returnColumnSizes = calloc(sizeof(int), n);\\n    for(int i = 0; i < n; i++)\\n        (*returnColumnSizes)[i] = matrixColSize[0];\\n    \\n    // add the locations of the cells with same keys to map\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            int *pair = calloc(sizeof(int), 2);\\n            pair[0] = i, pair[1] = j;\\n            HASH_FIND_INT(map, &matrix[i][j], s);\\n            if(!s) {\\n                s = calloc(sizeof(hElem), 1);\\n                s->elem = matrix[i][j]; s->count = 0; s->size = SIZE;                \\n                s->pair = calloc(sizeof(int *), s->size);\\n                s->pair[s->count++] = pair;\\n                HASH_ADD_INT(map, elem, s);\\n            }"], ["int** matrixRankTransform(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){\\n    hElem *map = NULL, *s, *t;\\n    int n = matrixSize, m = matrixColSize[0];\\n    int *rank = calloc(sizeof(int), n+m);\\n    *returnSize = n;\\n    *returnColumnSizes = calloc(sizeof(int), n);\\n    for(int i = 0; i < n; i++)\\n        (*returnColumnSizes)[i] = matrixColSize[0];\\n    \\n    // add the locations of the cells with same keys to map\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            int *pair = calloc(sizeof(int), 2);\\n            pair[0] = i, pair[1] = j;\\n            HASH_FIND_INT(map, &matrix[i][j], s);\\n            if(!s) {\\n                s = calloc(sizeof(hElem), 1);\\n                s->elem = matrix[i][j]; s->count = 0; s->size = SIZE;                \\n                s->pair = calloc(sizeof(int *), s->size);\\n                s->pair[s->count++] = pair;\\n                HASH_ADD_INT(map, elem, s);\\n            }"]]}
{"id": "2044", "ref_c": [["int numWays(char ** words, int wordsSize, char * target) \\n{\\n    int t = strlen(target);\\n    int w = strlen(words[0]); // Fixed width of all the words in \\'words\\' pointer\\n\\n    /* Getting memory for a frequency matrix for a specific character in the current column of the words 2 D array. 26 ==> 26 letters in alphabet */\\n    unsigned long long * f = malloc(sizeof(unsigned long long)  * w * 26);\\n\\n    /* Initializing with Zero */\\n    for (int i = 0; i < 26; i++)\\n        for (int j = 0; j < w; j++)\\n            f[(i * w) + j] = 0;\\n\\n    /* Transition matrix */\\n    unsigned long long * trans = malloc(sizeof(unsigned long long) * (t + 1) * (w + 1));\\n    for (int i = 0; i < (w+1); i++)\\n        for (int j = 0; j < (t+1); j++)\\n            trans[(i * (t+1)) + j] = 0;\\n\\n    /* Populate frequence matrix of characters column by column for each word in words*/\\n    for (int j = 0; j < w; j++)\\n        for (int i = 0; i < wordsSize; i++)\\n            f[((words[i][j] - \\'a\\') * w) + j]++;\\n\\n    /* Base case => trans[0][0]. \"1\" way to select nothing */\\n    trans[0] = 1;\\n\\n    for (int i = 0; i <= t; i++)\\n    {\\n        int r = (i * (w + 1)); // Getting the 2 D row index for a 1 D array. \\n\\n        for (int j = 0; j < w; j++)\\n        {\\n            if (i < t)\\n            {\\n                unsigned long long int freq  =   f[ ( ( target[i] - \\'a\\' ) * w ) + j ];\\n                unsigned long long int dp =  trans[r + j];\\n                \\n                /* res = dp * freq */\\n                unsigned long long int res =  ((dp % 1000000007) * (freq % 1000000007)) % 1000000007;\\n\\n                /* trans[i + 1][j + 1] += (trans[i][j] * freq of target[i] char in jth column ) */\\n                trans[ (r + (w+1) ) + (j + 1)] += res ;\\n            }"], ["int numWays(char ** words, int wordsSize, char * target){\\n    int tlen = strlen(target);\\n    int wlen = strlen(words[0]);\\n    long *res = (long*)calloc(tlen+1, sizeof(long));\\n    res[0] = 1;\\n    for(int i=0;i<wlen;i++)\\n    {\\n        int count[26] = {0}"], ["int numWays(char ** words, int wordsSize, char * target){\\n    int tlen = strlen(target);\\n    int wlen = strlen(words[0]);\\n    long *res = (long*)calloc(tlen+1, sizeof(long));\\n    res[0] = 1;\\n    for(int i=0;i<wlen;i++)\\n    {\\n        int count[26] = {0}"]]}
{"id": "2045", "ref_c": [["void duplicateZeros(int* arr, int arrSize) \\n{\\n   int j =0;\\n   int arr2[arrSize+2];\\n\\n    for ( int i=0;i<arrSize;i++)\\n    {       \\n            if ( arr[i]==0 && j <arrSize)\\n             {\\n             arr2[j]=0;\\n             j++;\\n             arr2[j]=0;\\n  \\n            }"], ["void duplicateZeros(int* arr, int arrSize) {\\n    int p=0;\\n    int temp[arrSize+2];\\n    for(int i=0;i<arrSize&&p<arrSize;i++,p++){\\n        if(arr[i]==0){\\n        temp[p]=0;\\n        p++;\\n        temp[p]=0;\\n        }"], ["void duplicateZeros(int* arr, int arrSize) \\n{\\n   int j =0;\\n   int arr2[arrSize+2];\\n\\n    for ( int i=0;i<arrSize;i++)\\n    {       \\n            if ( arr[i]==0 && j <arrSize)\\n             {\\n             arr2[j]=0;\\n             j++;\\n             arr2[j]=0;\\n  \\n            }"]]}
{"id": "2046", "ref_c": [["int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize){\\n    int heightInc=0;\\n    int *row_max = (int *)malloc(gridSize*sizeof(int));\\n    int *col_max = (int *)malloc(gridSize*sizeof(int));\\n    for(int i=0; i<gridSize; i++){\\n        int max_row=0;\\n        int max_col=0;\\n        for(int j=0; j<gridSize; j++){\\n            max_row= max(max_row, grid[i][j]);\\n            max_col = max(max_col, grid[j][i]);\\n        }"], ["int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize) {\\n    int rowMax[gridSize];\\n    int colMax[gridSize];\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        rowMax[i] = colMax[i] = 0;\\n        for (int j = 0; j < gridSize; j++) {\\n            if (grid[i][j] > rowMax[i]) {\\n                rowMax[i] = grid[i][j];\\n            }"], ["int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize) {\\n    int rowMax[gridSize];\\n    int colMax[gridSize];\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        rowMax[i] = colMax[i] = 0;\\n        for (int j = 0; j < gridSize; j++) {\\n            if (grid[i][j] > rowMax[i]) {\\n                rowMax[i] = grid[i][j];\\n            }"]]}
{"id": "2047", "ref_c": [["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"], ["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"], ["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"]]}
{"id": "2048", "ref_c": [["int smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend){\\n    int ans = 0;\\n    int **chair = malloc(timesSize*sizeof(int*));\\n    int **qdata = malloc(timesSize*sizeof(int*));\\n    int *valid = malloc((timesSize+1)*sizeof(int));\\n    int *invalid  = malloc((timesSize+1)*sizeof(int));\\n    int valididx = timesSize;\\n    int invalididx = 0;\\n    for(int i=0;i<timesSize;i++){\\n        qdata[i] = malloc(3*sizeof(int));\\n        qdata[i][0] = times[i][0];\\n        qdata[i][1] = times[i][1];\\n        qdata[i][2] = i;\\n        chair[i] = malloc(3*sizeof(int));\\n        chair[i][0] = i;\\n        chair[i][1] = i;\\n        chair[i][2] = 0;\\n        valid[i+1] = i;\\n    }"], ["int smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend){\\n    int ans = 0;\\n    int **chair = malloc(timesSize*sizeof(int*));\\n    int **qdata = malloc(timesSize*sizeof(int*));\\n    int *valid = malloc((timesSize+1)*sizeof(int));\\n    int *invalid  = malloc((timesSize+1)*sizeof(int));\\n    int valididx = timesSize;\\n    int invalididx = 0;\\n    for(int i=0;i<timesSize;i++){\\n        qdata[i] = malloc(3*sizeof(int));\\n        qdata[i][0] = times[i][0];\\n        qdata[i][1] = times[i][1];\\n        qdata[i][2] = i;\\n        chair[i] = malloc(3*sizeof(int));\\n        chair[i][0] = i;\\n        chair[i][1] = i;\\n        chair[i][2] = 0;\\n        valid[i+1] = i;\\n    }"], ["int smallestChair(int** times, int timesSize, int* timesColSize, int targetFriend){\\n    int ans = 0;\\n    int **chair = malloc(timesSize*sizeof(int*));\\n    int **qdata = malloc(timesSize*sizeof(int*));\\n    int *valid = malloc((timesSize+1)*sizeof(int));\\n    int *invalid  = malloc((timesSize+1)*sizeof(int));\\n    int valididx = timesSize;\\n    int invalididx = 0;\\n    for(int i=0;i<timesSize;i++){\\n        qdata[i] = malloc(3*sizeof(int));\\n        qdata[i][0] = times[i][0];\\n        qdata[i][1] = times[i][1];\\n        qdata[i][2] = i;\\n        chair[i] = malloc(3*sizeof(int));\\n        chair[i][0] = i;\\n        chair[i][1] = i;\\n        chair[i][2] = 0;\\n        valid[i+1] = i;\\n    }"]]}
{"id": "2049", "ref_c": [["int minimumEffort(int** tasks, int tasksSize, int* tasksColSize){\\n    qsort(tasks, tasksSize, sizeof(int*), comp);\\n    int ans = tasks[0][1];\\n    int now = ans;\\n    for (int i = 0 ; i < tasksSize ; i++){\\n        if (now >= tasks[i][1]){\\n            now -= tasks[i][0];\\n        }"], ["int minimumEffort(int** tasks, int tasksSize, int* tasksColSize){\\n    qsort(tasks, tasksSize, sizeof(int*), comp);\\n    int ans = tasks[0][1];\\n    int now = ans;\\n    for (int i = 0 ; i < tasksSize ; i++){\\n        if (now >= tasks[i][1]){\\n            now -= tasks[i][0];\\n        }"], ["int minimumEffort(int** tasks, int tasksSize, int* tasksColSize){\\n    qsort(tasks, tasksSize, sizeof(int*), comp);\\n    int ans = tasks[0][1];\\n    int now = ans;\\n    for (int i = 0 ; i < tasksSize ; i++){\\n        if (now >= tasks[i][1]){\\n            now -= tasks[i][0];\\n        }"]]}
{"id": "2050", "ref_c": [["int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int** ans = (int**)calloc(32768, sizeof(int*));\\n    int* col = (int*)calloc(32768, sizeof(int));\\n    int* q = (int*)calloc(numsSize, sizeof(int));\\n    int ansIdx = 0;\\n    \\n    backtracking(nums, numsSize, ans, col, &ansIdx, q, 0, 0);   \\n    deleteAll(); /* need to free to avoid incorrect behavior when doing next test item */\\n    \\n    *returnSize = ansIdx;\\n    *returnColumnSizes = col;\\n    return ans;\\n}"], ["int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int** ans = (int**)calloc(32768, sizeof(int*));\\n    int* col = (int*)calloc(32768, sizeof(int));\\n    int* q = (int*)calloc(numsSize, sizeof(int));\\n    int ansIdx = 0;\\n    \\n    backtracking(nums, numsSize, ans, col, &ansIdx, q, 0, 0);   \\n    deleteAll(); /* need to free to avoid incorrect behavior when doing next test item */\\n    \\n    *returnSize = ansIdx;\\n    *returnColumnSizes = col;\\n    return ans;\\n}"], ["int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int** ans = (int**)calloc(32768, sizeof(int*));\\n    int* col = (int*)calloc(32768, sizeof(int));\\n    int* q = (int*)calloc(numsSize, sizeof(int));\\n    int ansIdx = 0;\\n    \\n    backtracking(nums, numsSize, ans, col, &ansIdx, q, 0, 0);   \\n    deleteAll(); /* need to free to avoid incorrect behavior when doing next test item */\\n    \\n    *returnSize = ansIdx;\\n    *returnColumnSizes = col;\\n    return ans;\\n}"]]}
{"id": "2051", "ref_c": ["\nvoid checkBigger(int *h, int posi){\n    for(int comp; posi >= 4; posi = comp){\n        comp = (posi>>2<<1)+1;\n        if(h[posi] > h[comp])\n            SWAP(h[posi], h[comp]);\n        else break;\n    }\n}\nvoid checkSmaller(int *h, int posi){\n    for(int comp; posi >= 4; posi = comp){\n        comp = posi>>2<<1;\n        if(h[posi] < h[comp])\n            SWAP(h[posi], h[comp]);\n        else break;\n    }\n}\nvoid insert(int *h, int top, int data){\n    h[top] = data;\n    if(!(top&1)){           //is left\n        if(h[top] > h[top>>1])\n            checkBigger(h,top);\n        else\n            checkSmaller(h,top);\n    }\n    else{                       //is right\n        if(h[top] < h[top-1]){\n            SWAP(h[top], h[top-1]);\n            checkSmaller(h,top-1);\n        }\n        else  checkBigger(h,top);\n    }\n}\n\nvoid deleteMax(int *h, int *top){\n    h[3] = h[(*top)--];\n    int par = 3, chi = 5;\n    while (chi <= (*top)){\n        if(chi+2 <= (*top) && h[chi+2]>h[chi])  //\u9078\u8f03\u5927\u7684\n            chi += 2;\n        if(h[chi] > h[par]){\n            SWAP(h[chi], h[par]);\n            par = chi;\n            chi = (chi<<1)-1;\n        }\n        else break;\n    }\n    if(h[par] < h[par-1])\n        SWAP(h[par], h[par-1]);\n}\n\nint minimumDeviation(int* nums, int size){\n    int h[size+2], top=1, ans;  //heap, the h[0] & h[1] is no number\n    for(int i=0; i<size; i++){\n        if(nums[i]&1)    //is odd\n            nums[i] <<= 1;\n        insert(h, ++top, nums[i]);\n    }\n    \n    ans = h[3]-h[2];\n    while (!(h[3]&1)){    //while the max value is even \n        int t = h[3]>>1;\n        deleteMax(h, &top);\n        insert(h, ++top, t);\n        ans = MIN(ans, h[3]-h[2]);\n    }\n    return ans;\n}\n", "\nvoid checkBigger(int *h, int posi){\n    for(int comp; posi >= 4; posi = comp){\n        comp = (posi>>2<<1)+1;\n        if(h[posi] > h[comp])\n            SWAP(h[posi], h[comp]);\n        else break;\n    }\n}\nvoid checkSmaller(int *h, int posi){\n    for(int comp; posi >= 4; posi = comp){\n        comp = posi>>2<<1;\n        if(h[posi] < h[comp])\n            SWAP(h[posi], h[comp]);\n        else break;\n    }\n}\nvoid insert(int *h, int top, int data){\n    h[top] = data;\n    if(!(top&1)){           //is left\n        if(h[top] > h[top>>1])\n            checkBigger(h,top);\n        else\n            checkSmaller(h,top);\n    }\n    else{                       //is right\n        if(h[top] < h[top-1]){\n            SWAP(h[top], h[top-1]);\n            checkSmaller(h,top-1);\n        }\n        else  checkBigger(h,top);\n    }\n}\n\nvoid deleteMax(int *h, int *top){\n    h[3] = h[(*top)--];\n    int par = 3, chi = 5;\n    while (chi <= (*top)){\n        if(chi+2 <= (*top) && h[chi+2]>h[chi])  //\u9078\u8f03\u5927\u7684\n            chi += 2;\n        if(h[chi] > h[par]){\n            SWAP(h[chi], h[par]);\n            par = chi;\n            chi = (chi<<1)-1;\n        }\n        else break;\n    }\n    if(h[par] < h[par-1])\n        SWAP(h[par], h[par-1]);\n}\n\nint minimumDeviation(int* nums, int size){\n    int h[size+2], top=1, ans;  //heap, the h[0] & h[1] is no number\n    for(int i=0; i<size; i++){\n        if(nums[i]&1)    //is odd\n            nums[i] <<= 1;\n        insert(h, ++top, nums[i]);\n    }\n    \n    ans = h[3]-h[2];\n    while (!(h[3]&1)){    //while the max value is even \n        int t = h[3]>>1;\n        deleteMax(h, &top);\n        insert(h, ++top, t);\n        ans = MIN(ans, h[3]-h[2]);\n    }\n    return ans;\n}\n", "\nvoid checkBigger(int *h, int posi){\n    for(int comp; posi >= 4; posi = comp){\n        comp = (posi>>2<<1)+1;\n        if(h[posi] > h[comp])\n            SWAP(h[posi], h[comp]);\n        else break;\n    }\n}\nvoid checkSmaller(int *h, int posi){\n    for(int comp; posi >= 4; posi = comp){\n        comp = posi>>2<<1;\n        if(h[posi] < h[comp])\n            SWAP(h[posi], h[comp]);\n        else break;\n    }\n}\nvoid insert(int *h, int top, int data){\n    h[top] = data;\n    if(!(top&1)){           //is left\n        if(h[top] > h[top>>1])\n            checkBigger(h,top);\n        else\n            checkSmaller(h,top);\n    }\n    else{                       //is right\n        if(h[top] < h[top-1]){\n            SWAP(h[top], h[top-1]);\n            checkSmaller(h,top-1);\n        }\n        else  checkBigger(h,top);\n    }\n}\n\nvoid deleteMax(int *h, int *top){\n    h[3] = h[(*top)--];\n    int par = 3, chi = 5;\n    while (chi <= (*top)){\n        if(chi+2 <= (*top) && h[chi+2]>h[chi])  //\u9078\u8f03\u5927\u7684\n            chi += 2;\n        if(h[chi] > h[par]){\n            SWAP(h[chi], h[par]);\n            par = chi;\n            chi = (chi<<1)-1;\n        }\n        else break;\n    }\n    if(h[par] < h[par-1])\n        SWAP(h[par], h[par-1]);\n}\n\nint minimumDeviation(int* nums, int size){\n    int h[size+2], top=1, ans;  //heap, the h[0] & h[1] is no number\n    for(int i=0; i<size; i++){\n        if(nums[i]&1)    //is odd\n            nums[i] <<= 1;\n        insert(h, ++top, nums[i]);\n    }\n    \n    ans = h[3]-h[2];\n    while (!(h[3]&1)){    //while the max value is even \n        int t = h[3]>>1;\n        deleteMax(h, &top);\n        insert(h, ++top, t);\n        ans = MIN(ans, h[3]-h[2]);\n    }\n    return ans;\n}\n"]}
{"id": "2052", "ref_c": ["\nstruct Box {\n    int numBoxes;\n    int unitsPerBox;\n};\n\nint compare(const void *a, const void *b) {\n    return ((struct Box *)b)->unitsPerBox - ((struct Box *)a)->unitsPerBox;\n}\n\nint minimum(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize) {\n    int ans = 0;\n    int numOfBoxes = boxTypesSize;\n\n    struct Box* boxes = (struct Box*)malloc(numOfBoxes * sizeof(struct Box));\n\n    // Populate the boxes array\n    for (int i = 0; i < numOfBoxes; ++i) {\n        boxes[i].numBoxes = boxTypes[i][0];\n        boxes[i].unitsPerBox = boxTypes[i][1];\n    }\n\n    qsort(boxes, numOfBoxes, sizeof(struct Box), compare);\n\n    for (int i = 0; i < numOfBoxes; ++i) {\n        ans += minimum(truckSize, boxes[i].numBoxes) * boxes[i].unitsPerBox;\n        truckSize -= minimum(truckSize, boxes[i].numBoxes);\n    }\n\n    free(boxes);\n\n    return ans;\n}\n", "\nstruct Box {\n    int numBoxes;\n    int unitsPerBox;\n};\n\nint compare(const void *a, const void *b) {\n    return ((struct Box *)b)->unitsPerBox - ((struct Box *)a)->unitsPerBox;\n}\n\nint minimum(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize) {\n    int ans = 0;\n    int numOfBoxes = boxTypesSize;\n\n    struct Box* boxes = (struct Box*)malloc(numOfBoxes * sizeof(struct Box));\n\n    // Populate the boxes array\n    for (int i = 0; i < numOfBoxes; ++i) {\n        boxes[i].numBoxes = boxTypes[i][0];\n        boxes[i].unitsPerBox = boxTypes[i][1];\n    }\n\n    qsort(boxes, numOfBoxes, sizeof(struct Box), compare);\n\n    for (int i = 0; i < numOfBoxes; ++i) {\n        ans += minimum(truckSize, boxes[i].numBoxes) * boxes[i].unitsPerBox;\n        truckSize -= minimum(truckSize, boxes[i].numBoxes);\n    }\n\n    free(boxes);\n\n    return ans;\n}\n", "\nstruct Box {\n    int numBoxes;\n    int unitsPerBox;\n};\n\nint compare(const void *a, const void *b) {\n    return ((struct Box *)b)->unitsPerBox - ((struct Box *)a)->unitsPerBox;\n}\n\nint minimum(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize) {\n    int ans = 0;\n    int numOfBoxes = boxTypesSize;\n\n    struct Box* boxes = (struct Box*)malloc(numOfBoxes * sizeof(struct Box));\n\n    // Populate the boxes array\n    for (int i = 0; i < numOfBoxes; ++i) {\n        boxes[i].numBoxes = boxTypes[i][0];\n        boxes[i].unitsPerBox = boxTypes[i][1];\n    }\n\n    qsort(boxes, numOfBoxes, sizeof(struct Box), compare);\n\n    for (int i = 0; i < numOfBoxes; ++i) {\n        ans += minimum(truckSize, boxes[i].numBoxes) * boxes[i].unitsPerBox;\n        truckSize -= minimum(truckSize, boxes[i].numBoxes);\n    }\n\n    free(boxes);\n\n    return ans;\n}\n"]}
{"id": "2053", "ref_c": ["\nchar *largestOddNumber(char *num) {\n    int right = strlen(num) - 1;\n    while (right >= 0) {\n        if ((num[right] - '0') % 2 == 0) {\n            right--;\n        } else {\n            num[right + 1] = '\u0000';\n            return num;\n        }\n    }\n    return \"\";\n}\n", "\nchar *largestOddNumber(char *num) {\n    int right = strlen(num) - 1;\n    while (right >= 0) {\n        if ((num[right] - '0') % 2 == 0) {\n            right--;\n        } else {\n            num[right + 1] = '\u0000';\n            return num;\n        }\n    }\n    return \"\";\n}\n", "\nchar *largestOddNumber(char *num) {\n    int right = strlen(num) - 1;\n    while (right >= 0) {\n        if ((num[right] - '0') % 2 == 0) {\n            right--;\n        } else {\n            num[right + 1] = '\u0000';\n            return num;\n        }\n    }\n    return \"\";\n}\n"]}
{"id": "2054", "ref_c": [["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    int i;\\n    *returnSize = n; // since n = number of elements to be returned\\n    char **answer; // the string of strings where the right elements will be copied\\n    char str[5]; // every string contains at most 5 character (max number is 10000 => 5 characters)\\n    \\n    i = 1; // first number we want to return is 1\\n    answer = NULL;\\n    answer = malloc(sizeof(*answer) * n); // our string of strings will have the same number of element than the returning one (n)\\n    if (!answer)\\n        return (answer); // securizing our malloc => returning NULL if something went wrong\\n    while (i <= n)\\n    {\\n        if (i % 15 == 0)\\n            answer[i - 1] = strdup(\"FizzBuzz\"); // NB we need to start duplicating from position 0 => (i - 1)\\n        else if (i % 3 == 0)\\n            answer[i - 1] = strdup(\"Fizz\");\\n        else if (i % 5 == 0)\\n            answer[i - 1] = strdup(\"Buzz\");\\n        else\\n        {\\n            sprintf(str, \"%d\", i); // converting integer i into char and storing it in str\\n            answer[i - 1] = strdup(str);\\n        }"], ["char ** fizzBuzz(int n, int* returnSize){\\n    *returnSize = n;\\n    char **T = (char**)malloc(sizeof(char*)*n);\\n    for(int i=0;i<n;i++){\\n        T[i]=(char*)malloc(9*sizeof(char));\\n        sprintf(T[i], \"%d\", i+1);  // Convert \\'i\\' to char \\n        if( (i+1) % 3 == 0 && (i+1) % 5 == 0){T[i] = \"FizzBuzz\";}"], ["char ** fizzBuzz(int n, int* returnSize)\\n{\\n    char**arr = malloc(n*sizeof(char*));\\n    *returnSize = n;\\n    for(int i=1;i<=n;i++)\\n    {\\n        arr[i - 1] = malloc(9 * sizeof(char));\\n        if(i%15==0)\\n        arr[i-1] = \"FizzBuzz\";\\n        else if(i%3==0)\\n        arr[i-1]=\"Fizz\";\\n        else if(i%5==0)\\n        arr[i-1]=\"Buzz\";\\n        else\\n        sprintf(arr[i-1], \"%d\", i);\\n    }"]]}
{"id": "2055", "ref_c": [["bool* distanceLimitedPathsExist(int n, int** edgeList, int edgeListSize, int* edgeListColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize = queriesSize;\\n    int i;\\n    //init union set\\n    root = (int*)malloc(sizeof(int)*n);\\n    for (i = 0; i < n; i++)\\n        root[i] = i;\\n    //init answer array\\n    bool* ans = (bool*)malloc(sizeof(bool) * queriesSize);\\n\\n    int idx[queriesSize];//index of queries\\n    for (i = 0; i < queriesSize; ++i)\\n        idx[i] = i;\\n\\n    qcopy = queries;\\n    qsort(idx, queriesSize, sizeof(int), cmp2);//sort the index base on the queries limit length\\n    qsort(edgeList, edgeListSize, sizeof(int*), cmp); //sort by edge distance\\n    \\n    int j=0;\\n    for (i = 0; i < queriesSize; ++i) {\\n        int curr = idx[i];//current queries index in sorted queries\\n        int len = queries[curr][2];//limit length\\n        \\n        //update union set when distance less than limit \\n        while(j < edgeListSize && edgeList[j][2] < len){\\n            int a = find(edgeList[j][0]);\\n            int b = find(edgeList[j][1]);\\n            root[b] = a;\\n            j++;\\n        }"], ["bool* distanceLimitedPathsExist(int n, int** edgeList, int edgeListSize, int* edgeListColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    Edge edges[edgeListSize];\\n    for (int i = 0; i < edgeListSize; i++) {\\n        edges[i].u = edgeList[i][0];\\n        edges[i].v = edgeList[i][1];\\n        edges[i].dis = edgeList[i][2];\\n    }"], ["bool* distanceLimitedPathsExist(int n, int** edgeList, int edgeListSize, int* edgeListColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\\n    Edge edges[edgeListSize];\\n    for (int i = 0; i < edgeListSize; i++) {\\n        edges[i].u = edgeList[i][0];\\n        edges[i].v = edgeList[i][1];\\n        edges[i].dis = edgeList[i][2];\\n    }"]]}
{"id": "2056", "ref_c": [["int matrixScore(int** grid, int gridSize, int* gridColSize) {\\n    for(int i=0;i<gridSize;i++){\\n        if(grid[i][0]==0)\\n        fliprow(grid,i,gridColSize[i]);\\n    }"], ["int matrixScore(int** grid, int gridSize, int* gridColSize){\\n    if(!grid)\\n        return 0;\\n    \\n    int leng = gridColSize[0];\\n    int i, j;\\n    for(i=0;i<gridSize;i++){\\n        if(grid[i][0]==0){\\n            for(j=0;j<leng;j++){\\n                grid[i][j] ^= 1;\\n            }"], ["int matrixScore(int** grid, int gridSize, int* gridColSize){\\n    if(!grid)\\n        return 0;\\n    \\n    int leng = gridColSize[0];\\n    int i, j;\\n    for(i=0;i<gridSize;i++){\\n        if(grid[i][0]==0){\\n            for(j=0;j<leng;j++){\\n                grid[i][j] ^= 1;\\n            }"]]}
{"id": "2057", "ref_c": [["int checkRecord(int n) {\\n        memset(t,-1,sizeof(t));\\n        return solve(n,1,2);\\n    }"], ["int checkRecord(int n) {\\n        memset(t,-1,sizeof(t));\\n        return solve(n,1,2);\\n    }"], ["int checkRecord(int n) {\\n        memset(t,-1,sizeof(t));\\n        return solve(n,1,2);\\n    }"]]}
{"id": "2058", "ref_c": [["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"], ["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"], ["struct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }"]]}
{"id": "2059", "ref_c": [["double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int temp[nums1Size+nums2Size];\\n    int x =0;\\n        for (int i = 0 ; i<nums1Size+nums2Size ; i++){\\n            if (i < nums1Size)\\n               temp[i] = nums1[i];\\n            else\\n                temp[i] = nums2[x++];\\n\\n        }"], ["double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int temp[nums1Size+nums2Size];\\n    int x =0;\\n        for (int i = 0 ; i<nums1Size+nums2Size ; i++){\\n            if (i < nums1Size)\\n               temp[i] = nums1[i];\\n            else\\n                temp[i] = nums2[x++];\\n\\n        }"], ["double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int temp[nums1Size+nums2Size];\\n    int x =0;\\n        for (int i = 0 ; i<nums1Size+nums2Size ; i++){\\n            if (i < nums1Size)\\n               temp[i] = nums1[i];\\n            else\\n                temp[i] = nums2[x++];\\n\\n        }"]]}
{"id": "2060", "ref_c": [["int maxOperations(int* nums, int numsSize, int k){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  k\\n     */\\n\\n    int ans = 0;\\n\\n    /* Sort nums by value in ascending order */\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    /* \\n     * Two pointers point to leftmost and rightmost \\n     * compare the sum of values and move the pointer accordingly\\n     */\\n    for (int i = 0, j = numsSize - 1; i < j; ) {\\n\\n        if (nums[i] + nums[j] > k) {\\n            j--;\\n        }"], ["int maxOperations(int* nums, int numsSize, int k){\\n\\n    /*\\n     * Input:\\n     *  nums,\\n     *  numsSize,\\n     *  k\\n     */\\n\\n    int ans = 0;\\n\\n    /* Sort nums by value in ascending order */\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n\\n    /* \\n     * Two pointers point to leftmost and rightmost \\n     * compare the sum of values and move the pointer accordingly\\n     */\\n    for (int i = 0, j = numsSize - 1; i < j; ) {\\n\\n        if (nums[i] + nums[j] > k) {\\n            j--;\\n        }"], ["int maxOperations(int* nums, int numsSize, int k){\\n\\n  bool *used = calloc(numsSize, sizeof(bool));\\n  bucket **set = calloc(97, sizeof(bucket *));\\n  int count = 0;\\n\\n  for (int i = 0; i < numsSize; i++)\\n  {\\n    if (findDeleteOrInsert(nums[i], set, k)) count++;\\n  }"]]}
{"id": "2061", "ref_c": [["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    int *lucky;\\n    int i,j,k,x,check;\\n    int minRow,maxCol;\\n    coordinates cor[matrixSize];\\n    \\n    lucky = (int *)malloc(sizeof(int) * matrixSize);\\n    \\n    k = 0;\\n    for(i = 0; i < matrixSize; i++){\\n        minRow = INT_MAX;\\n        for(j = 0; j < *matrixColSize; j++){\\n            if(matrix[i][j] < minRow){\\n                minRow = matrix[i][j];\\n                cor[i].row = i;\\n                cor[i].col = j;\\n            }"], ["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\\n     int *ans=malloc(sizeof(int)*50);\\n     int min;\\n     int max;\\n     int idx;\\n     int m=0;\\n     for(int i=0;i<matrixSize;i++)\\n     {\\n         min=1000000;\\n         for(int j=0;j<(*matrixColSize);j++)\\n         {\\n             if(min>matrix[i][j]) \\n             {\\n                 min=matrix[i][j];\\n                 idx=j;\\n             }"], ["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    int* returnValue = (int*)malloc(matrixSize * sizeof(int));\\n    int returnValueIndex = 0;\\n\\n    // for each row...\\n    int columnIndex = 0;\\n    int rowIndex = 0;\\n    for (int row = 0; row < matrixSize; row++) {\\n        // find the minimum value on the row and return it\\'s column index...\\n        columnIndex = matrix_minimum_in_row(matrix, row, *matrixColSize);\\n\\n        // find the maximum value on the column and return it\\'s row index...\\n        rowIndex = matrix_maximum_in_column(matrix, matrixSize, columnIndex);\\n\\n        // ...remember the solutions\\n        if (row == rowIndex) {\\n            returnValue[returnValueIndex] = matrix[rowIndex][columnIndex];\\n            returnValueIndex++;\\n        }"]]}
{"id": "2062", "ref_c": [["int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\\n    int hashSize = nums1Size * nums2Size; int hashBits; __asm__ (\" bsr %1, %0 \\\\n\" : \"+r\" (hashBits) : \"r\" (hashSize));\\n    hashSize = 2 << hashBits; hashBits = 31 - hashBits;\\n    int table[hashSize]; clearints(table, hashSize);\\n    int counts[hashSize]; clearints(counts, hashSize);\\n    hashSize--;\\n    for(int i = 0; i < nums1Size; i++)\\n    {   int ni = nums1[i];\\n        for(int ii = 0; ii < nums2Size; ii++)\\n        {   int sum = ni + nums2[ii];\\n            uint32_t hash = ((uint32_t)(2808820391 * sum)) >> hashBits;\\n            int c;\\n            while((c=counts[hash]))\\n            {\\n                if(table[hash] == sum) goto foundit;\\n                ++hash; hash &= hashSize;\\n            }"], ["int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\\n    int i,j,k,l,r;\\n    int sz = 0;\\n    \\n    int nums5[40000];\\n    int nums5Size = 0;\\n    for (i = 0; i < nums3Size; i=i+1) {\\n        for (j = 0; j < nums4Size; j=j+1) {\\n            nums5[nums5Size++] = nums3[i]+nums4[j];\\n        }"], ["int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size){\\n    int i,j,k,l,r;\\n    int sz = 0;\\n    \\n    int nums5[40000];\\n    int nums5Size = 0;\\n    for (i = 0; i < nums3Size; i=i+1) {\\n        for (j = 0; j < nums4Size; j=j+1) {\\n            nums5[nums5Size++] = nums3[i]+nums4[j];\\n        }"]]}
{"id": "2063", "ref_c": [["int minimumBoxes(int n){\\n    ull wag, wag2, rem;\\n    wag = invtet(n); // approximate\\n    if(tet(wag) > n) wag--;\\n    if(tet(wag) == n) return tri(wag);\\n    rem = n-tet(wag);\\n    wag2 = invtri(rem); // approximate\\n    if((tet(wag) + tri(wag2)) < n) wag2++;\\n    return  (int) (tri(wag) + wag2);\\n}"], ["int minimumBoxes(int n){\\n    ull wag, wag2, rem;\\n    wag = invtet(n); // approximate\\n    if(tet(wag) > n) wag--;\\n    if(tet(wag) == n) return tri(wag);\\n    rem = n-tet(wag);\\n    wag2 = invtri(rem); // approximate\\n    if((tet(wag) + tri(wag2)) < n) wag2++;\\n    return  (int) (tri(wag) + wag2);\\n}"], ["int minimumBoxes(int n){\\n    ull wag, wag2, rem;\\n    wag = invtet(n); // approximate\\n    if(tet(wag) > n) wag--;\\n    if(tet(wag) == n) return tri(wag);\\n    rem = n-tet(wag);\\n    wag2 = invtri(rem); // approximate\\n    if((tet(wag) + tri(wag2)) < n) wag2++;\\n    return  (int) (tri(wag) + wag2);\\n}"]]}
{"id": "2064", "ref_c": [["int longestZigZag(struct TreeNode* root){\\n    if(!root) return 0;\\n    int ans = 0;\\n    DFS(root, 0, 0, &ans);\\n    return ans;\\n}"], ["int longestZigZag(struct TreeNode* root){\\n    if(!root) return 0;\\n    int ans = 0;\\n    DFS(root, 0, 0, &ans);\\n    return ans;\\n}"], ["int longestZigZag(struct TreeNode* root)\\n{\\n    max = 0;\\n\\n    if(root->left == NULL && root->right == NULL)\\n    {\\n        return 0;\\n    }"]]}
{"id": "2065", "ref_c": [["int maxValue(int** events, int eventsSize, int* eventsColSize, int k){\\n    //greedy intuition, or dp problem\\n    //the k amount is one state, the other state is the startdate\\n\\n    qsort(events, eventsSize, sizeof(int *), cmp);\\n    int lastDay = events[eventsSize - 1][1];\\n    //sort the list by start date, and then by value\\n    int **dp = (int **)malloc(sizeof(int *) * (k + 1));\\n    for(int i = 0; i < k + 1; i++){\\n        dp[i] = (int *)calloc(eventsSize + 1, sizeof(int));\\n    }"], ["int maxValue(int** events, int eventsSize, int* eventsColSize, int k){\\n    //greedy intuition, or dp problem\\n    //the k amount is one state, the other state is the startdate\\n\\n    qsort(events, eventsSize, sizeof(int *), cmp);\\n    int lastDay = events[eventsSize - 1][1];\\n    //sort the list by start date, and then by value\\n    int **dp = (int **)malloc(sizeof(int *) * (k + 1));\\n    for(int i = 0; i < k + 1; i++){\\n        dp[i] = (int *)calloc(eventsSize + 1, sizeof(int));\\n    }"], ["int maxValue(int** events, int eventsSize, int* eventsColSize, int k){\\n    //greedy intuition, or dp problem\\n    //the k amount is one state, the other state is the startdate\\n\\n    qsort(events, eventsSize, sizeof(int *), cmp);\\n    int lastDay = events[eventsSize - 1][1];\\n    //sort the list by start date, and then by value\\n    int **dp = (int **)malloc(sizeof(int *) * (k + 1));\\n    for(int i = 0; i < k + 1; i++){\\n        dp[i] = (int *)calloc(eventsSize + 1, sizeof(int));\\n    }"]]}
{"id": "2066", "ref_c": [["char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\nint temp;\\nchar *str;\\n*returnSize=namesSize;\\nfor(int i=0;i<namesSize;i++)\\n{\\n  for(int j=i+1;j<namesSize;j++){\\n    if(heights[i]<heights[j])\\n    { \\n      temp=heights[i];\\n      heights[i]=heights[j];\\n      heights[j]=temp;\\n      str=names[i];\\n      names[i]=names[j];\\n      names[j]=str;\\n    }"], ["char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\n    char** ans = (char**)calloc(namesSize, sizeof(char*));\\n    for(int i = 0; i < heightsSize; i++)\\n        heights[i] = (heights[i] << 10) + i;\\n    qsort(heights, heightsSize, sizeof(int), cmp);\\n    for(int i = 0; i < heightsSize; i++)\\n        ans[i] = names[heights[i] & 0x3FF];\\n    *returnSize = heightsSize;\\n    return ans;\\n}"], ["char ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\n    char** ans = (char**)calloc(namesSize, sizeof(char*));\\n    for(int i = 0; i < heightsSize; i++)\\n        heights[i] = (heights[i] << 10) + i;\\n    qsort(heights, heightsSize, sizeof(int), cmp);\\n    for(int i = 0; i < heightsSize; i++)\\n        ans[i] = names[heights[i] & 0x3FF];\\n    *returnSize = heightsSize;\\n    return ans;\\n}"]]}
{"id": "2067", "ref_c": [["int minTrioDegree(int n, int** edges, int edgesSize, int* edgesColSize){\\n  uint degrees[n];\\n  memset(degrees, 0, n * sizeof(uint));\\n  \\n  char adjacencies[n][n];\\n  memset(adjacencies, 0, n * n * sizeof(char));\\n  \\n  for (int i = 0; i < edgesSize; i++) {\\n    int v1 = edges[i][0] - 1;\\n    int v2 = edges[i][1] - 1;\\n    \\n    adjacencies[v1][v2] = 1;\\n    adjacencies[v2][v1] = 1;\\n    \\n    degrees[v1]++;\\n    degrees[v2]++;\\n  }"], ["int minTrioDegree(int n, int** edges, int edgesSize, int* edgesColSize){\\n  uint degrees[n];\\n  memset(degrees, 0, n * sizeof(uint));\\n  \\n  char adjacencies[n][n];\\n  memset(adjacencies, 0, n * n * sizeof(char));\\n  \\n  for (int i = 0; i < edgesSize; i++) {\\n    int v1 = edges[i][0] - 1;\\n    int v2 = edges[i][1] - 1;\\n    \\n    adjacencies[v1][v2] = 1;\\n    adjacencies[v2][v1] = 1;\\n    \\n    degrees[v1]++;\\n    degrees[v2]++;\\n  }"], ["int minTrioDegree(int n, int** edges, int edgesSize, int* edgesColSize){\\n  uint degrees[n];\\n  memset(degrees, 0, n * sizeof(uint));\\n  \\n  char adjacencies[n][n];\\n  memset(adjacencies, 0, n * n * sizeof(char));\\n  \\n  for (int i = 0; i < edgesSize; i++) {\\n    int v1 = edges[i][0] - 1;\\n    int v2 = edges[i][1] - 1;\\n    \\n    adjacencies[v1][v2] = 1;\\n    adjacencies[v2][v1] = 1;\\n    \\n    degrees[v1]++;\\n    degrees[v2]++;\\n  }"]]}
{"id": "2068", "ref_c": [["int* constructRectangle(int area, int* returnSize){\\n    int* arr = (int*)malloc(2*sizeof(int));\\n    int width = sqrt(area);\\n    while(area % width != 0) \\n      width--;\\n    arr[0] = area/width;\\n    arr[1] = width;\\n    *returnSize = 2;\\n    return arr;\\n}"], ["int* constructRectangle(int area, int* returnSize){\\n    int* arr = (int*)malloc(2*sizeof(int));\\n    int width = sqrt(area);\\n    while(area % width != 0) \\n      width--;\\n    arr[0] = area/width;\\n    arr[1] = width;\\n    *returnSize = 2;\\n    return arr;\\n}"], ["int* constructRectangle(int area, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  area\\n     */\\n\\n    int length = sqrt(area), width = length;\\n    int *ans = (int *)malloc(sizeof(int) * 2);\\n\\n    *returnSize = 2;\\n\\n    /*\\n     * Set length = sqrt(area), width = sqrt(area) \\n     *  if L * W is smaller than area, increase length\\n     *  if L * W is larger than area, decrease width\\n     */\\n    do {\\n        if (length * width < area) {\\n            length++;\\n        }"]]}
{"id": "2069", "ref_c": [["int maximumScore(int* nums, int numsSize, int* multipliers, int multipliersSize)\\n{\\n    int n = numsSize, m=multipliersSize;\\n    register int i, left, k;\\n\\n    int dp[m+1];\\n    for (k=0; k<=m ; k++) dp[k]=0;\\n    \\n    for(i=m-1; i>=0; i--)\\n    {\\n        int nextRow[m+1];\\n        for (register int k=0; k<=m ; k++) nextRow[k]=dp[k];\\n    \\n        for (left=i; left>=0; left--)\\n        {\\n            dp[left] = max (  multipliers[i] * nums[left]               + nextRow[left + 1], \\n                              multipliers[i] * nums[n - 1 - (i - left)] + nextRow[left]       );     \\n        }"], ["int maximumScore(int* nums, int numsSize, int* multipliers, int multipliersSize)\\n{\\n    int n = numsSize, m=multipliersSize;\\n    register int i, left, k;\\n\\n    int dp[m+1];\\n    for (k=0; k<=m ; k++) dp[k]=0;\\n    \\n    for(i=m-1; i>=0; i--)\\n    {\\n        int nextRow[m+1];\\n        for (register int k=0; k<=m ; k++) nextRow[k]=dp[k];\\n    \\n        for (left=i; left>=0; left--)\\n        {\\n            dp[left] = max (  multipliers[i] * nums[left]               + nextRow[left + 1], \\n                              multipliers[i] * nums[n - 1 - (i - left)] + nextRow[left]       );     \\n        }"], ["int maximumScore(int* nums, int numsSize, int* multipliers, int multipliersSize)\\n{\\n    int n = numsSize, m=multipliersSize;\\n    register int i, left, k;\\n\\n    int dp[m+1];\\n    for (k=0; k<=m ; k++) dp[k]=0;\\n    \\n    for(i=m-1; i>=0; i--)\\n    {\\n        int nextRow[m+1];\\n        for (register int k=0; k<=m ; k++) nextRow[k]=dp[k];\\n    \\n        for (left=i; left>=0; left--)\\n        {\\n            dp[left] = max (  multipliers[i] * nums[left]               + nextRow[left + 1], \\n                              multipliers[i] * nums[n - 1 - (i - left)] + nextRow[left]       );     \\n        }"]]}
{"id": "2070", "ref_c": [["int countOperations(int num1, int num2)\\n{\\n    int count = 0;\\n    while(num1>0 && num2>0)\\n    {\\n        if(num1>=num2)\\n        num1 -= num2;\\n        else\\n        num2 -= num1;\\n        count++;\\n    }"], ["int countOperations(int num1, int num2) {\\n        if (num1 == 0 or num2 == 0){ //base case\\n            return count_op;\\n        }"], ["int countOperations(int num1, int num2){\\n    int ops=0;\\n    while(num1 && num2){\\n        if(num1>=num2){\\n            num1-=num2;\\n        }"]]}
{"id": "2071", "ref_c": [["int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    int *dec = calloc(numsSize, sizeof(int));\\n    int *inc = calloc(numsSize, sizeof(int));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }", "int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    *returnSize = 0;\\n\\n    uint32_t *dec = calloc(numsSize, sizeof(uint32_t));\\n    uint32_t *inc = calloc(numsSize, sizeof(uint32_t));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }"], ["int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    int *dec = calloc(numsSize, sizeof(int));\\n    int *inc = calloc(numsSize, sizeof(int));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }", "int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    *returnSize = 0;\\n\\n    uint32_t *dec = calloc(numsSize, sizeof(uint32_t));\\n    uint32_t *inc = calloc(numsSize, sizeof(uint32_t));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }"], ["int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    int *dec = calloc(numsSize, sizeof(int));\\n    int *inc = calloc(numsSize, sizeof(int));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }", "int* goodIndices(int* nums, int numsSize, int k, int* returnSize)\\n{\\n    int *ans = NULL;\\n    *returnSize = 0;\\n\\n    uint32_t *dec = calloc(numsSize, sizeof(uint32_t));\\n    uint32_t *inc = calloc(numsSize, sizeof(uint32_t));\\n\\n    dec[0] = 1;\\n    inc[numsSize - 1] = 1;\\n    \\n    for(int i=1; i<numsSize; i++) {\\n        \\n        dec[i] = 1;\\n        if(nums[i] <= nums[i - 1])\\n            dec[i] += dec[i - 1];\\n        \\n        inc[numsSize - 1 - i] = 1;\\n        if(nums[numsSize - 1 - i] <= nums[numsSize - i])\\n            inc[numsSize - 1 - i] += inc[numsSize - i];            \\n    }"]]}
{"id": "2072", "ref_c": [["int candy(int* ratings, int ratingsSize){\\n    int i, candies_count = ratingsSize;\\n    int* candies = calloc(ratingsSize, sizeof(int));\\n\\n    for(i = 1; i < ratingsSize; i++){\\n        if (ratings[i] > ratings[i - 1])\\n            candies[i] = candies[i - 1] + 1;\\n    }"], ["int candy(int* ratings, int ratingsSize){\\n    int i, candies_count = ratingsSize;\\n    int* candies = calloc(ratingsSize, sizeof(int));\\n\\n    for(i = 1; i < ratingsSize; i++){\\n        if (ratings[i] > ratings[i - 1])\\n            candies[i] = candies[i - 1] + 1;\\n    }"], ["int candy(int* ratings, int ratingsSize){\\n    int i, candies_count = ratingsSize;\\n    int* candies = calloc(ratingsSize, sizeof(int));\\n\\n    for(i = 1; i < ratingsSize; i++){\\n        if (ratings[i] > ratings[i - 1])\\n            candies[i] = candies[i - 1] + 1;\\n    }"]]}
{"id": "2073", "ref_c": [["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"]]}
{"id": "2074", "ref_c": [["int maximumScore(int* nums, int numsSize, int k){\\n    int temp,best,min,i,j;\\n\\n    i=k;\\n    j=k;\\n    min=nums[k];\\n    best=0;\\n    while ((i>0)||(j<numsSize-1)) {\\n        \\n        //move as far as possible without changing min\\n        if (i>0) {\\n            while ((i>0)&&(nums[i]>=min)) {i--;}"], ["int maximumScore(int* nums, int numsSize, int k){\\n    int temp,best,min,i,j;\\n\\n    i=k;\\n    j=k;\\n    min=nums[k];\\n    best=0;\\n    while ((i>0)||(j<numsSize-1)) {\\n        \\n        //move as far as possible without changing min\\n        if (i>0) {\\n            while ((i>0)&&(nums[i]>=min)) {i--;}"], ["int maximumScore(int* nums, int numsSize, int k){\\n    int temp,best,min,i,j;\\n\\n    i=k;\\n    j=k;\\n    min=nums[k];\\n    best=0;\\n    while ((i>0)||(j<numsSize-1)) {\\n        \\n        //move as far as possible without changing min\\n        if (i>0) {\\n            while ((i>0)&&(nums[i]>=min)) {i--;}"]]}
{"id": "2075", "ref_c": [["int maxScore(int* nums, int numsSize){\\n    // memoSize == 2^(numsSize)\\n    int  ans, memoSize = 1<<numsSize;\\n    int* memo = malloc(sizeof(int)*memoSize);\\n    for (int i = 0; i < memoSize; i ++){\\n        memo[i] = -1;\\n    }"], ["int maxScore(int* nums, int numsSize){\\n    // memoSize == 2^(numsSize)\\n    int  ans, memoSize = 1<<numsSize;\\n    int* memo = malloc(sizeof(int)*memoSize);\\n    for (int i = 0; i < memoSize; i ++){\\n        memo[i] = -1;\\n    }"], ["int maxScore(int* nums, int numsSize){\\n    // memoSize == 2^(numsSize)\\n    int  ans, memoSize = 1<<numsSize;\\n    int* memo = malloc(sizeof(int)*memoSize);\\n    for (int i = 0; i < memoSize; i ++){\\n        memo[i] = -1;\\n    }"]]}
{"id": "2076", "ref_c": [["int numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }"], ["int numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }"], ["int numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }"]]}
{"id": "2077", "ref_c": [["int maxNiceDivisors(int primeFactors) {\\n        if (primeFactors <= 3)\\n            return primeFactors;\\n        \\n        int quotient = primeFactors / 3;\\n        int remainder = primeFactors % 3;\\n\\n        if (remainder == 0)\\n            return power(3, quotient) % MOD;\\n        else if (remainder == 1)\\n            return (power(3, quotient - 1) * 4) % MOD;\\n        else\\n            return (power(3, quotient) * 2) % MOD;\\n    }"], ["int maxNiceDivisors(int primeFactors) {\\n        if (primeFactors <= 3)\\n            return primeFactors;\\n        \\n        int quotient = primeFactors / 3;\\n        int remainder = primeFactors % 3;\\n\\n        if (remainder == 0)\\n            return power(3, quotient) % MOD;\\n        else if (remainder == 1)\\n            return (power(3, quotient - 1) * 4) % MOD;\\n        else\\n            return (power(3, quotient) * 2) % MOD;\\n    }"], ["int maxNiceDivisors(int primeFactors) {\\n        if (primeFactors <= 3)\\n            return primeFactors;\\n        \\n        int quotient = primeFactors / 3;\\n        int remainder = primeFactors % 3;\\n\\n        if (remainder == 0)\\n            return power(3, quotient) % MOD;\\n        else if (remainder == 1)\\n            return (power(3, quotient - 1) * 4) % MOD;\\n        else\\n            return (power(3, quotient) * 2) % MOD;\\n    }"]]}
{"id": "2078", "ref_c": [["double calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income) \\n{\\n    // *bracketsColSize == 2\\n    int money = (brackets[0][0] <= income)? brackets[0][0] : income;\\n    double amount = money * brackets[0][1] * 0.01;\\n    income -= money;\\n    int i = 1;\\n    while(i < bracketsSize && income > 0)\\n    {\\n        money = (brackets[i][0] - brackets[i - 1][0] <= income)?\\n                                    brackets[i][0] - brackets[i - 1][0] : income; \\n        amount += money * brackets[i][1] * 0.01;\\n        income -= money;\\n        i++;    \\n    }"], ["double calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income){\\n\\n    int lb = 0;\\n    double r = 0;\\n    \\n    for(int i = 0; i < bracketsSize; ++i)\\n    {\\n        double val = max(0, min(income, *(*(brackets + i))) - lb);\\n        r += (*(*(brackets + i)+1) * val)/100;\\n        lb = *(*(brackets + i));\\n    }"], ["double calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income){\\n\\n    int lb = 0;\\n    double r = 0;\\n    \\n    for(int i = 0; i < bracketsSize; ++i)\\n    {\\n        double val = max(0, min(income, *(*(brackets + i))) - lb);\\n        r += (*(*(brackets + i)+1) * val)/100;\\n        lb = *(*(brackets + i));\\n    }"]]}
{"id": "2079", "ref_c": ["\nchar* removeDuplicates(char* s) {\n    int length = strlen(s);\n    char* output = (char*)malloc((length + 1) * sizeof(char));\n    int top = -1;\n\n    for (int i = i; i<length; i++){\n        if (top == -1){\n            output[++top] = s[i];  \n        }\n        else if(s[i] == output[top]){\n            top --;\n        }\n        else{\n            output[++top] = s[i];  \n        }\n    }\n    output[++top] = '\u0000';\n    return output;\n}\n", "\nchar* removeDuplicates(char* s) {\n    int length = strlen(s);\n    char* output = (char*)malloc((length + 1) * sizeof(char));\n    int top = -1;\n\n    for (int i = i; i<length; i++){\n        if (top == -1){\n            output[++top] = s[i];  \n        }\n        else if(s[i] == output[top]){\n            top --;\n        }\n        else{\n            output[++top] = s[i];  \n        }\n    }\n    output[++top] = '\u0000';\n    return output;\n}\n", "\nchar* removeDuplicates(char* s) {\n    int length = strlen(s);\n    char* output = (char*)malloc((length + 1) * sizeof(char));\n    int top = -1;\n\n    for (int i = i; i<length; i++){\n        if (top == -1){\n            output[++top] = s[i];  \n        }\n        else if(s[i] == output[top]){\n            top --;\n        }\n        else{\n            output[++top] = s[i];  \n        }\n    }\n    output[++top] = '\u0000';\n    return output;\n}\n"]}
{"id": "2081", "ref_c": [["struct ListNode* deleteDuplicates(struct ListNode* head) {\\n    struct ListNode* temp=head;\\n    while (temp&&temp->next)\\n    {\\n        if (temp->next->val==temp->val)\\n        {\\n            temp->next=temp->next->next;\\n            continue;\\n        }"], ["struct ListNode* deleteDuplicates(struct ListNode* head)\\n{\\n    struct ListNode*k=head;\\n    struct ListNode*z;\\n    if(head==NULL)\\n    return head;\\n    int i;\\n    for(i=0;i<5;i++)\\n    {while(k->next!=NULL)\\n    {\\n        z=k;\\n        k=k->next;\\n        if(z->val==k->val)\\n        {\\n            z->next=k->next;\\n        }"], ["struct ListNode* deleteDuplicates(struct ListNode* head){\\n    \\n    struct ListNode* current = head;\\n    struct ListNode* new_list = head;\\n\\n    \\n    while(current !=NULL && current->next!=NULL)\\n    {\\n        if(current->val == current->next->val)\\n        {\\n            current->next = current->next->next;\\n}"]]}
{"id": "2082", "ref_c": ["\nint getXORSum(int* arr1, int arr1Size, int* arr2, int arr2Size){\n   int sum=0,xand=0;\n    for(int j=0;j<arr2Size;j++){\n           xand^=arr2[j];\n       }\n   for (int i=0;i<arr1Size;i++){\n            sum^=arr1[i]&xand;\n   }  \n   return sum;\n}\n", "\nint getXORSum(int* arr1, int arr1Size, int* arr2, int arr2Size){\n   int sum=0,xand=0;\n    for(int j=0;j<arr2Size;j++){\n           xand^=arr2[j];\n       }\n   for (int i=0;i<arr1Size;i++){\n            sum^=arr1[i]&xand;\n   }  \n   return sum;\n}\n", "\nint getXORSum(int* arr1, int arr1Size, int* arr2, int arr2Size){\n   int sum=0,xand=0;\n    for(int j=0;j<arr2Size;j++){\n           xand^=arr2[j];\n       }\n   for (int i=0;i<arr1Size;i++){\n            sum^=arr1[i]&xand;\n   }  \n   return sum;\n}\n"]}
{"id": "2083", "ref_c": [["int minOperations(int n) {\\n       \\n        int t=0;\\n        while(n!=0){\\n             int x=log2(n);\\n        int dif=abs(n-pow(2,x));\\n        int dif2=pow(2,x+1)-n;\\n         n=min(dif,dif2);\\n            t++;\\n            //cout<<n<<\" \";\\n            \\n        }"], ["int minOperations(int n){\\n\\tassert(n >= 0);\\n\\n\\tint opCnt = 0;\\n\\n\\twhile (n > 0){\\n\\t\\twhile ( (n & 1) == 0 ){\\n\\t\\t\\tn >>= 1;\\n\\t\\t}"], ["int minOperations(int n){\\n    int con=0;\\n    int res=0;\\n    while(n!=0){\\n        if(n&1==1){\\n            con++;\\n        }"]]}
{"id": "2084", "ref_c": [["int* movesToStamp(char * stamp, char * target, int* returnSize) {\\n\\tint* ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\n\\tconst int stamp_len = (int) strlen(stamp);\\n\\tconst int target_len = (int) strlen(target);\\n\\tint prev_right_end = 0;\\n\\n\\t/* Seach for a full stamp match, from left to right. The target must _finish_ with a full stamp. Thus if we have\\n\\t   a full stamp location, we can search backwards for stamps that lead up to the full stamp(s). */\\n\\tfor (int i = 0; i + stamp_len <= target_len; ) {\\n\\t\\tif (0 == memcmp(target + i, stamp, stamp_len)) {\\n\\t\\t\\tadd_move(&ret, returnSize, &cap, i);\\n\\t\\t\\tif (!expand_out(stamp, stamp_len, target, target_len, &ret, returnSize, &cap, i, &prev_right_end)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}"], ["int* movesToStamp(char * stamp, char * target, int* returnSize) {\\n\\tint* ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\n\\tconst int stamp_len = (int) strlen(stamp);\\n\\tconst int target_len = (int) strlen(target);\\n\\tint prev_right_end = 0;\\n\\n\\t/* Seach for a full stamp match, from left to right. The target must _finish_ with a full stamp. Thus if we have\\n\\t   a full stamp location, we can search backwards for stamps that lead up to the full stamp(s). */\\n\\tfor (int i = 0; i + stamp_len <= target_len; ) {\\n\\t\\tif (0 == memcmp(target + i, stamp, stamp_len)) {\\n\\t\\t\\tadd_move(&ret, returnSize, &cap, i);\\n\\t\\t\\tif (!expand_out(stamp, stamp_len, target, target_len, &ret, returnSize, &cap, i, &prev_right_end)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}"], ["int* movesToStamp(char * stamp, char * target, int* returnSize) {\\n\\tint* ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\n\\tconst int stamp_len = (int) strlen(stamp);\\n\\tconst int target_len = (int) strlen(target);\\n\\tint prev_right_end = 0;\\n\\n\\t/* Seach for a full stamp match, from left to right. The target must _finish_ with a full stamp. Thus if we have\\n\\t   a full stamp location, we can search backwards for stamps that lead up to the full stamp(s). */\\n\\tfor (int i = 0; i + stamp_len <= target_len; ) {\\n\\t\\tif (0 == memcmp(target + i, stamp, stamp_len)) {\\n\\t\\t\\tadd_move(&ret, returnSize, &cap, i);\\n\\t\\t\\tif (!expand_out(stamp, stamp_len, target, target_len, &ret, returnSize, &cap, i, &prev_right_end)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}"]]}
{"id": "2085", "ref_c": [["void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){\\n    // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n    int i = m - 1;\\n    int j = n -1;\\n    // Create a loop until either of i or j becomes zero...\\n    while(i>=0 && j>=0) {\\n        if(nums1[i] > nums2[j]) {\\n            nums1[i+j+1] = nums1[i];\\n            i--;\\n        }"], ["void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)\\n{\\n    int i = nums1Size-1;\\n    while (n > 0)\\n    {\\n        if (m == 0 || nums2[n-1] > nums1[m-1])\\n        {\\n            nums1[i] = nums2[n-1];\\n            --n;\\n        }"], ["void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){\\n    // Initialize i and j to store indices of the last element of 1st and 2nd array respectively...\\n    int i = m - 1;\\n    int j = n -1;\\n    // Create a loop until either of i or j becomes zero...\\n    while(i>=0 && j>=0) {\\n        if(nums1[i] > nums2[j]) {\\n            nums1[i+j+1] = nums1[i];\\n            i--;\\n        }"]]}
{"id": "2086", "ref_c": [["int largestPathValue(char * colors, int** edges, int edgesSize, int* edgesColSize){\\r\\n    int tamanho=strlen(colors);\\r\\n    graph* plan=(graph*)calloc(tamanho,sizeof(graph));\\r\\n    bool* visited=(bool*)calloc(tamanho,sizeof(bool));\\r\\n    for(int i=0;i<tamanho;i++){\\r\\n        plan[i].color=colors[i];\\r\\n    }"], ["int largestPathValue(char * colors, int** edges, int edgesSize, int* edgesColSize){\\r\\n    int tamanho=strlen(colors);\\r\\n    graph* plan=(graph*)calloc(tamanho,sizeof(graph));\\r\\n    bool* visited=(bool*)calloc(tamanho,sizeof(bool));\\r\\n    for(int i=0;i<tamanho;i++){\\r\\n        plan[i].color=colors[i];\\r\\n    }"], ["int largestPathValue(char * colors, int** edges, int edgesSize, int* edgesColSize){\\r\\n    int tamanho=strlen(colors);\\r\\n    graph* plan=(graph*)calloc(tamanho,sizeof(graph));\\r\\n    bool* visited=(bool*)calloc(tamanho,sizeof(bool));\\r\\n    for(int i=0;i<tamanho;i++){\\r\\n        plan[i].color=colors[i];\\r\\n    }"]]}
{"id": "2087", "ref_c": [["void wiggleSort(int* nums, int numsSize){\\n      int arr[5001];\\n      for(int i=0;i<5001;i++) arr[i]=0;\\n      for(int i=0;i<numsSize;i++){\\n          arr[nums[i]]++;\\n      }"], ["void wiggleSort(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int *temp = malloc(sizeof(int) * numsSize);\\n    for (int i = 0; i < numsSize; i++)\\n        temp[i] = nums[i];\\n    for (int i = 1, j = numsSize - 1; i < numsSize; i+=2, j--)\\n        nums[i] = temp[j];\\n    int isOdd = numsSize % 2 == 1 ? 0 : 1;\\n    for (int i = 0, j = numsSize / 2 - isOdd; i < numsSize; i+=2, j--)\\n        nums[i] = temp[j];\\n}"], ["void wiggleSort(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int *temp = malloc(sizeof(int) * numsSize);\\n    for (int i = 0; i < numsSize; i++)\\n        temp[i] = nums[i];\\n    for (int i = 1, j = numsSize - 1; i < numsSize; i+=2, j--)\\n        nums[i] = temp[j];\\n    int isOdd = numsSize % 2 == 1 ? 0 : 1;\\n    for (int i = 0, j = numsSize / 2 - isOdd; i < numsSize; i+=2, j--)\\n        nums[i] = temp[j];\\n}"]]}
{"id": "2088", "ref_c": [["int rearrangeSticks(int n, int k) {\\n        int mod = pow(10,9)+7;\\n        vector<vector<long long >>dp(n+1,vector<long long>(k+1,-1));\\n        return rec(n,k,dp);\\n        return dp[n][k];\\n    }"], ["int rearrangeSticks(int n, int k) {\\n        int mod = pow(10,9)+7;\\n        vector<vector<long long >>dp(n+1,vector<long long>(k+1,-1));\\n        return rec(n,k,dp);\\n        return dp[n][k];\\n    }"], ["int rearrangeSticks(int n, int k) {\\n        int mod = pow(10,9)+7;\\n        vector<vector<long long >>dp(n+1,vector<long long>(k+1,-1));\\n        return rec(n,k,dp);\\n        return dp[n][k];\\n    }"]]}
{"id": "2089", "ref_c": [["int stoneGameVIII(int* stones, int stonesSize){\\n    int list[100000];\\n    int maxpoint[100000];\\n    list[0] = stones[0];\\n    for (int i = 1 ; i < stonesSize ; i++){\\n        list[i] = stones[i]+list[i-1];\\n    }"], ["int stoneGameVIII(int* stones, int stonesSize){\\n    int list[100000];\\n    int maxpoint[100000];\\n    list[0] = stones[0];\\n    for (int i = 1 ; i < stonesSize ; i++){\\n        list[i] = stones[i]+list[i-1];\\n    }"], ["int stoneGameVIII(int* stones, int stonesSize){\\n    int list[100000];\\n    int maxpoint[100000];\\n    list[0] = stones[0];\\n    for (int i = 1 ; i < stonesSize ; i++){\\n        list[i] = stones[i]+list[i-1];\\n    }"]]}
{"id": "2090", "ref_c": ["\nint** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes) {\n    \n    int totalElements = 0;\n    for (int i = 0; i < matSize; i++) {\n        totalElements += matColSize[i];\n    }\n\n    if (r * c != totalElements) {\n       \n        *returnSize = matSize;\n        *returnColumnSizes = matColSize;\n        return mat;\n    }\n\n    int* temp = (int*)malloc(totalElements * sizeof(int));\n    int k = 0;\n\n    int** newMat = (int**)malloc(r * sizeof(int*));\n\n    for (int i = 0; i < r; i++) {\n        newMat[i] = (int*)malloc(c * sizeof(int));\n    }\n\n    for (int i = 0; i < matSize; i++) {\n        for (int j = 0; j < matColSize[i]; j++) {\n            temp[k++] = mat[i][j];\n        }\n    }\n\n    k = 0;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            newMat[i][j] = temp[k++];\n        }\n    }\n\n    free(temp);\n\n    *returnSize = r;\n    *returnColumnSizes = (int*)malloc(r * sizeof(int));\n\n    for (int i = 0; i < r; i++) {\n        (*returnColumnSizes)[i] = c;\n    }\n\n    return newMat;\n}\n", "\nint** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes) {\n    \n    int totalElements = 0;\n    for (int i = 0; i < matSize; i++) {\n        totalElements += matColSize[i];\n    }\n\n    if (r * c != totalElements) {\n       \n        *returnSize = matSize;\n        *returnColumnSizes = matColSize;\n        return mat;\n    }\n\n    int* temp = (int*)malloc(totalElements * sizeof(int));\n    int k = 0;\n\n    int** newMat = (int**)malloc(r * sizeof(int*));\n\n    for (int i = 0; i < r; i++) {\n        newMat[i] = (int*)malloc(c * sizeof(int));\n    }\n\n    for (int i = 0; i < matSize; i++) {\n        for (int j = 0; j < matColSize[i]; j++) {\n            temp[k++] = mat[i][j];\n        }\n    }\n\n    k = 0;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            newMat[i][j] = temp[k++];\n        }\n    }\n\n    free(temp);\n\n    *returnSize = r;\n    *returnColumnSizes = (int*)malloc(r * sizeof(int));\n\n    for (int i = 0; i < r; i++) {\n        (*returnColumnSizes)[i] = c;\n    }\n\n    return newMat;\n}\n", "\nint** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes) {\n    \n    int totalElements = 0;\n    for (int i = 0; i < matSize; i++) {\n        totalElements += matColSize[i];\n    }\n\n    if (r * c != totalElements) {\n       \n        *returnSize = matSize;\n        *returnColumnSizes = matColSize;\n        return mat;\n    }\n\n    int* temp = (int*)malloc(totalElements * sizeof(int));\n    int k = 0;\n\n    int** newMat = (int**)malloc(r * sizeof(int*));\n\n    for (int i = 0; i < r; i++) {\n        newMat[i] = (int*)malloc(c * sizeof(int));\n    }\n\n    for (int i = 0; i < matSize; i++) {\n        for (int j = 0; j < matColSize[i]; j++) {\n            temp[k++] = mat[i][j];\n        }\n    }\n\n    k = 0;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            newMat[i][j] = temp[k++];\n        }\n    }\n\n    free(temp);\n\n    *returnSize = r;\n    *returnColumnSizes = (int*)malloc(r * sizeof(int));\n\n    for (int i = 0; i < r; i++) {\n        (*returnColumnSizes)[i] = c;\n    }\n\n    return newMat;\n}\n"]}
{"id": "2091", "ref_c": [["bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\\n    if (n == 1) return true;\\n    if (n == 2) return (dislikesSize == 0);\\n    unsigned char * colored = calloc(n, sizeof(unsigned char));\\n    ListEntry* * adjacency = malloc(n * sizeof(ListEntry *));\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency[i] = list_init();\\n    }"], ["bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\\n    if (n == 1) return true;\\n    if (n == 2) return (dislikesSize == 0);\\n    unsigned char * colored = calloc(n, sizeof(unsigned char));\\n    ListEntry* * adjacency = malloc(n * sizeof(ListEntry *));\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency[i] = list_init();\\n    }"], ["bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\\n    if (n == 1) return true;\\n    if (n == 2) return (dislikesSize == 0);\\n    unsigned char * colored = calloc(n, sizeof(unsigned char));\\n    ListEntry* * adjacency = malloc(n * sizeof(ListEntry *));\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency[i] = list_init();\\n    }"]]}
{"id": "2092", "ref_c": [["int removeElement(int* nums, int numsSize, int val){\\n    \\n    int appendIndex = 0;\\n    bool find = false;\\n    int k = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == val && !find) {\\n            appendIndex = i;\\n            find = true;\\n        }"], ["int removeElement(int* nums, int numsSize, int val){\\n    \\n    int appendIndex = 0;\\n    bool find = false;\\n    int k = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == val && !find) {\\n            appendIndex = i;\\n            find = true;\\n        }"], ["int removeElement(int* nums, int numsSize, int val){\\n    \\n    int appendIndex = 0;\\n    bool find = false;\\n    int k = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == val && !find) {\\n            appendIndex = i;\\n            find = true;\\n        }"]]}
{"id": "2093", "ref_c": [["char ** braceExpansionII(char * expression, int* returnSize){\\n    int len = strlen(expression);\\n    int ans_len[4097] = {0}"], ["char ** braceExpansionII(char * expression, int* returnSize){\\n    int len = strlen(expression);\\n    int ans_len[4097] = {0}"], ["char ** braceExpansionII(char * expression, int* returnSize){\\n    int len = strlen(expression);\\n    int ans_len[4097] = {0}"]]}
{"id": "2094", "ref_c": [["char ** buildArray(int* target, int targetSize, int n, int* returnSize) {\\n    // Initialize a vector of strings to store the result.\\n    char **ans = (char **)malloc(2 * n * sizeof(char *));\\n    \\n    int i = 1;  // Initialize an integer \\'i\\' to represent the current number.\\n    int idx = 0;  // Initialize an index to track the position in the \\'ans\\' array.\\n    \\n    // Iterate through each element \\'a\\' in the \\'target\\' array.\\n    for (int j = 0; j < targetSize; j++) {\\n        int a = target[j];\\n        \\n        // Check if \\'i\\' is less than \\'a\\' and perform the following steps if true:\\n        while (i < a) {\\n            ans[idx++] = strdup(\"Push\");  // Simulate pushing the current number onto the stack.\\n            ans[idx++] = strdup(\"Pop\");   // Simulate popping an element from the stack.\\n            i++;  // Move to the next number.\\n        }"], ["char ** buildArray(int* target, int targetSize, int n, int* returnSize) {\\n    // Initialize a vector of strings to store the result.\\n    char **ans = (char **)malloc(2 * n * sizeof(char *));\\n    \\n    int i = 1;  // Initialize an integer \\'i\\' to represent the current number.\\n    int idx = 0;  // Initialize an index to track the position in the \\'ans\\' array.\\n    \\n    // Iterate through each element \\'a\\' in the \\'target\\' array.\\n    for (int j = 0; j < targetSize; j++) {\\n        int a = target[j];\\n        \\n        // Check if \\'i\\' is less than \\'a\\' and perform the following steps if true:\\n        while (i < a) {\\n            ans[idx++] = strdup(\"Push\");  // Simulate pushing the current number onto the stack.\\n            ans[idx++] = strdup(\"Pop\");   // Simulate popping an element from the stack.\\n            i++;  // Move to the next number.\\n        }"], ["char ** buildArray(int* target, int targetSize, int n, int* returnSize) {\\n    // Initialize a vector of strings to store the result.\\n    char **ans = (char **)malloc(2 * n * sizeof(char *));\\n    \\n    int i = 1;  // Initialize an integer \\'i\\' to represent the current number.\\n    int idx = 0;  // Initialize an index to track the position in the \\'ans\\' array.\\n    \\n    // Iterate through each element \\'a\\' in the \\'target\\' array.\\n    for (int j = 0; j < targetSize; j++) {\\n        int a = target[j];\\n        \\n        // Check if \\'i\\' is less than \\'a\\' and perform the following steps if true:\\n        while (i < a) {\\n            ans[idx++] = strdup(\"Push\");  // Simulate pushing the current number onto the stack.\\n            ans[idx++] = strdup(\"Pop\");   // Simulate popping an element from the stack.\\n            i++;  // Move to the next number.\\n        }"]]}
{"id": "2096", "ref_c": [["int maximum69Number (int num) {\\n        string s=to_string(num);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'6\\'){\\n                s[i]=\\'9\\';\\n                break;\\n            }"], ["int maximum69Number (int num){\\n    int diff = 10000 - num;\\n    if (num % 10 == 6) diff--;\\n\\n    int POW10 = 1000;\\n    for (int i = 3; i >= 0; i--) {\\n        if ((diff / POW10) % 10 & 2) return 3 * POW10 + num;\\n        POW10 /= 10;\\n    }"], ["int maximum69Number (int num) {\\nint i;\\nint* arr;\\nint a = ceil(log(num)/log(10));\\narr = malloc(a * sizeof(int));\\nint cpy = num;\\ni = a -1;\\nwhile (cpy > 0) {\\narr[i] = cpy % 10;\\ncpy/=10;\\ni--;\\n}"]]}
{"id": "2097", "ref_c": [["bool canMakeArithmeticProgression(int* arr, int arrSize){\\n    int i, commonDifference, nodePtr = 0;\\n    int min = INT_MAX, max = INT_MIN;\\n    iNode *ht[MOD], nodes[1000];\\n    memset(ht, 0, sizeof(ht));\\n    for (i = 0; i < arrSize; ++i) {\\n        insertht(ht, arr[i], &nodes[nodePtr++]);\\n        if(arr[i] < min) {\\n            min = arr[i];\\n        }"], ["bool canMakeArithmeticProgression(int* arr, int arrSize) {\\n    int firstTerm = arr[0];\\n    // first term of AP which is assumed to be minimum.\\n\\n    /*The first check is if all terms are same*/\\n    bool allEqual = true;\\n    for (int i = 1; i < arrSize; ++i) {\\n        if (firstTerm != arr[i]) {\\n            allEqual = false;\\n            break;\\n        }"], ["bool canMakeArithmeticProgression(int* arr, int arrSize){\\nint temp, i, j, index = 0;\\nfor(int i = 0 ; i <= arrSize - 1 ; i++){\\n    index = i;\\n    for(j = i + 1; j < arrSize ; j++){\\n        if( arr[j] < arr[index]){\\n            index = j;\\n        }"]]}
{"id": "2098", "ref_c": [["int maximumSum(int* nums, int numsSize){\\n    int count[100]={0}"], ["int maximumSum(int* nums, int numsSize) {\\n    // Sorting + Hashtable\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    const int Max = 9 * 9;  // getSum(999999999) := 81\\n    int result = -1;\\n    int count[81 + 1][100000 + 1];\\n    int size[100000 + 1] = {0}"], ["int maximumSum(int* nums, int numsSize){\\n    int count[100]={0}"]]}
{"id": "2099", "ref_c": [["int* largestValues(struct TreeNode* root, int* returnSize) {\\n    if (root == NULL) {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* largestValues(struct TreeNode* root, int* returnSize) {\\n    if (root == NULL) {\\n        *returnSize = 0;\\n        return NULL;\\n    }", "int* largestValues(struct TreeNode* root, int* returnSize) {\\n    ans = NULL;\\n    ansSize = 0;\\n    dfs(root, 0);\\n    *returnSize = ansSize;\\n    return ans;\\n}"], ["int* largestValues(struct TreeNode* root, int* returnSize){\\n    int* result = (int*)malloc(sizeof(int)*10000);\\n    *returnSize = 0;\\n    if(!root){\\n        return result;\\n    }"]]}
{"id": "2100", "ref_c": [["int countOperations(int num1, int num2)\\n{\\n    int count = 0;\\n    while(num1>0 && num2>0)\\n    {\\n        if(num1>=num2)\\n        num1 -= num2;\\n        else\\n        num2 -= num1;\\n        count++;\\n    }"], ["int countOperations(int num1, int num2) {\\n        if (num1 == 0 or num2 == 0){ //base case\\n            return count_op;\\n        }"], ["int countOperations(int num1, int num2){\\n    int ops=0;\\n    while(num1 && num2){\\n        if(num1>=num2){\\n            num1-=num2;\\n        }"]]}
{"id": "2101", "ref_c": [["int* getNoZeroIntegers(int n, int* returnSize)\\n{\\n        *returnSize=2;\\n        int *a=malloc(sizeof(int)*(*returnSize));\\n        int i=1,j=n-1;\\n        while(i<=j)\\n        {\\n                if(check0(i) && check0(j))\\n                {\\n                \\n                        a[0]=i;\\n                        a[1]=j;\\n                        break;\\n                }"], ["int* getNoZeroIntegers(int n, int* returnSize){\\n    int i;\\n    int *output = (int*)malloc(2 * sizeof(int));\\n    *returnSize = 2;\\n    \\n    char s1[6], s2[6];\\n    for(i = 1; i <= n / 2; i++){\\n        // sprintf() can convert any data type to a string. \\n        sprintf(s1, \"%d\", i);\\n        sprintf(s2, \"%d\", n - i);\\n        // strchr(str, ch) returns a pointer to the first ch character (if present) in str. Else, return NULL. \\n        if(!strchr(s1, \\'0\\') && !strchr(s2, \\'0\\')){\\n            output[0] = i;\\n            output[1] = n - i;\\n            break;\\n        }"], ["int* getNoZeroIntegers(int n, int* returnSize){\\n    int i;\\n    int *output = (int*)malloc(2 * sizeof(int));\\n    *returnSize = 2;\\n    \\n    char s1[6], s2[6];\\n    for(i = 1; i <= n / 2; i++){\\n        // sprintf() can convert any data type to a string. \\n        sprintf(s1, \"%d\", i);\\n        sprintf(s2, \"%d\", n - i);\\n        // strchr(str, ch) returns a pointer to the first ch character (if present) in str. Else, return NULL. \\n        if(!strchr(s1, \\'0\\') && !strchr(s2, \\'0\\')){\\n            output[0] = i;\\n            output[1] = n - i;\\n            break;\\n        }"]]}
{"id": "2102", "ref_c": ["\nint* canSeePersonsCount(int* heights, int heightsSize, int* returnSize){\n    int* ans = malloc(sizeof(int)*heightsSize);\n    int farthest[heightsSize];\n    ans[heightsSize-1] = 0;\n    farthest[heightsSize-1] = heightsSize;\n    *returnSize = heightsSize;\n    int j;\n    for (int i = heightsSize-2 ; i >= 0 ; i--){\n        j = i+1;\n        ans[i] = 1;\n        if (heights[i] < heights[j]){\n            farthest[i] = j;\n            continue;\n        }\n        while (1){\n            if (farthest[j] == heightsSize){\n                farthest[i] = heightsSize;\n                break;\n            } else if (heights[farthest[j]] < heights[i]){\n                ans[i]++;\n                j = farthest[j];\n            } else {\n                ans[i]++;\n                farthest[i] = farthest[j];\n                break;\n            }\n        }\n    }\n    return ans;\n}\n", "\nint* canSeePersonsCount(int* heights, int heightsSize, int* returnSize){\n    int* ans = malloc(sizeof(int)*heightsSize);\n    int farthest[heightsSize];\n    ans[heightsSize-1] = 0;\n    farthest[heightsSize-1] = heightsSize;\n    *returnSize = heightsSize;\n    int j;\n    for (int i = heightsSize-2 ; i >= 0 ; i--){\n        j = i+1;\n        ans[i] = 1;\n        if (heights[i] < heights[j]){\n            farthest[i] = j;\n            continue;\n        }\n        while (1){\n            if (farthest[j] == heightsSize){\n                farthest[i] = heightsSize;\n                break;\n            } else if (heights[farthest[j]] < heights[i]){\n                ans[i]++;\n                j = farthest[j];\n            } else {\n                ans[i]++;\n                farthest[i] = farthest[j];\n                break;\n            }\n        }\n    }\n    return ans;\n}\n", "\nint* canSeePersonsCount(int* heights, int heightsSize, int* returnSize){\n    int* ans = malloc(sizeof(int)*heightsSize);\n    int farthest[heightsSize];\n    ans[heightsSize-1] = 0;\n    farthest[heightsSize-1] = heightsSize;\n    *returnSize = heightsSize;\n    int j;\n    for (int i = heightsSize-2 ; i >= 0 ; i--){\n        j = i+1;\n        ans[i] = 1;\n        if (heights[i] < heights[j]){\n            farthest[i] = j;\n            continue;\n        }\n        while (1){\n            if (farthest[j] == heightsSize){\n                farthest[i] = heightsSize;\n                break;\n            } else if (heights[farthest[j]] < heights[i]){\n                ans[i]++;\n                j = farthest[j];\n            } else {\n                ans[i]++;\n                farthest[i] = farthest[j];\n                break;\n            }\n        }\n    }\n    return ans;\n}\n"]}
{"id": "2103", "ref_c": [["char * findLongestWord(char * s, char ** dictionary, int dictionarySize){\\n    \\n    int len = strlen(s);\\n    int i;\\n    int p,q;\\n    int max = INT_MIN;\\n    char *res = (char *)malloc(sizeof(char) * (len+1));\\n    memset(res,0,sizeof(char) * (len+1));\\n    for (i=0; i < dictionarySize; i++)\\n    {\\n        q=0;p=0;\\n        while (s[p] != NULL && dictionary[i][q] != NULL)\\n        {\\n            if (s[p] == dictionary[i][q])\\n            {\\n                p++;q++;\\n            }"], ["char * findLongestWord(char * s, char ** dictionary, int dictionarySize){\\n    \\n    int len = strlen(s);\\n    int i;\\n    int p,q;\\n    int max = INT_MIN;\\n    char *res = (char *)malloc(sizeof(char) * (len+1));\\n    memset(res,0,sizeof(char) * (len+1));\\n    for (i=0; i < dictionarySize; i++)\\n    {\\n        q=0;p=0;\\n        while (s[p] != NULL && dictionary[i][q] != NULL)\\n        {\\n            if (s[p] == dictionary[i][q])\\n            {\\n                p++;q++;\\n            }"], ["char * findLongestWord(char * s, char ** dictionary, int dictionarySize){\\n    \\n    int len = strlen(s);\\n    int i;\\n    int p,q;\\n    int max = INT_MIN;\\n    char *res = (char *)malloc(sizeof(char) * (len+1));\\n    memset(res,0,sizeof(char) * (len+1));\\n    for (i=0; i < dictionarySize; i++)\\n    {\\n        q=0;p=0;\\n        while (s[p] != NULL && dictionary[i][q] != NULL)\\n        {\\n            if (s[p] == dictionary[i][q])\\n            {\\n                p++;q++;\\n            }"]]}
{"id": "2104", "ref_c": [["int minDistance(char * word1, char * word2){\\n    int i, j, len1 = strlen(word1), len2 = strlen(word2);\\n\\n    int **dp = (int**)malloc(sizeof(int*) * (len1 + 1));\\n\\n    for (i = 0; i <= len1; i++) \\n        dp[i] = (int*)calloc(sizeof(int), (len2 + 1));\\n\\n    for (i = 1; i <= len1; i++) {\\n        for (j = 1; j <= len2; j++) {\\n            if (word1[i - 1] == word2[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] + 1;\\n            else {\\n                if (dp[i][j - 1] > dp[i - 1][j])\\n                    dp[i][j] = dp[i][j - 1];\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }"], ["int minDistance(char * word1, char * word2){\\n    int i, j, len1 = strlen(word1), len2 = strlen(word2);\\n\\n    int **dp = (int**)malloc(sizeof(int*) * (len1 + 1));\\n\\n    for (i = 0; i <= len1; i++) \\n        dp[i] = (int*)calloc(sizeof(int), (len2 + 1));\\n\\n    for (i = 1; i <= len1; i++) {\\n        for (j = 1; j <= len2; j++) {\\n            if (word1[i - 1] == word2[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] + 1;\\n            else {\\n                if (dp[i][j - 1] > dp[i - 1][j])\\n                    dp[i][j] = dp[i][j - 1];\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }"], ["int minDistance(char * word1, char * word2){\\n    int i, j, len1 = strlen(word1), len2 = strlen(word2);\\n\\n    int **dp = (int**)malloc(sizeof(int*) * (len1 + 1));\\n\\n    for (i = 0; i <= len1; i++) \\n        dp[i] = (int*)calloc(sizeof(int), (len2 + 1));\\n\\n    for (i = 1; i <= len1; i++) {\\n        for (j = 1; j <= len2; j++) {\\n            if (word1[i - 1] == word2[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] + 1;\\n            else {\\n                if (dp[i][j - 1] > dp[i - 1][j])\\n                    dp[i][j] = dp[i][j - 1];\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n            }"]]}
{"id": "2105", "ref_c": [["char * dayOfTheWeek(int day, int month, int year){\\n    char *ans = malloc(10);\\n    struct tm tm;\\n    char buff[80];\\n    sprintf(buff, \"%d-%02d-%02d\", year, month, day);\\n    strptime(buff, \"%Y-%m-%d\", &tm);\\n    strftime(ans, 10, \"%A\", &tm);\\n    return ans;\\n}"], ["char * dayOfTheWeek(int day, int month, int year){\\n    char *ans = malloc(10);\\n    struct tm tm;\\n    char buff[80];\\n    sprintf(buff, \"%d-%02d-%02d\", year, month, day);\\n    strptime(buff, \"%Y-%m-%d\", &tm);\\n    strftime(ans, 10, \"%A\", &tm);\\n    return ans;\\n}"], ["char * dayOfTheWeek(int day, int month, int year){\\n    char *ans = malloc(10);\\n    struct tm tm;\\n    char buff[80];\\n    sprintf(buff, \"%d-%02d-%02d\", year, month, day);\\n    strptime(buff, \"%Y-%m-%d\", &tm);\\n    strftime(ans, 10, \"%A\", &tm);\\n    return ans;\\n}"]]}
{"id": "2106", "ref_c": [["int* longestObstacleCourseAtEachPosition(int* obstacles, int obstaclesSize, int* returnSize){\\n    int n = obstaclesSize;\\n    *returnSize = n;\\n    int *ans = calloc(n, sizeof(int));\\n    int *lis = malloc(n * sizeof(int));\\n    int lisSize = 0;\\n    for (int i = 0; i < n; i++) {\\n        int idx = 0;\\n        int l = 0, r = lisSize - 1;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n            if (lis[mid] <= obstacles[i]) {\\n                idx = mid + 1;\\n                l = mid + 1;\\n            }"], ["int* longestObstacleCourseAtEachPosition(int* obstacles, int obstaclesSize, int* returnSize){\\n    int n = obstaclesSize;\\n    * returnSize = n;\\n    int *ans = calloc(n, sizeof(int));\\n    /* min_height: keep track of the minimum height \\n    for each obstacle course length */\\n    int *min_height = malloc((n+1)* sizeof(int));\\n    memset(min_height, INT_MAX, n+1);\\n    ans[0] = 1;\\n    min_height[1] =  obstacles[0];\\n    int l = 1, r = 1, mid = 0, max_len = 1;\\n    for(int i = 1; i < n; i++){\\n        int target = obstacles[i];\\n        l = 1, r = max_len;\\n        /* if target value is already larger than the current max_len  \\n        obstacle height, the max_len will simply increase by one */\\n        if(min_height[max_len] <= target){\\n            ans[i] = ++max_len;\\n            min_height[max_len] = target;\\n            continue;\\n        }"], ["int* longestObstacleCourseAtEachPosition(int* obstacles, int obstaclesSize, int* returnSize){\\n    int n = obstaclesSize;\\n    * returnSize = n;\\n    int *ans = calloc(n, sizeof(int));\\n    /* min_height: keep track of the minimum height \\n    for each obstacle course length */\\n    int *min_height = malloc((n+1)* sizeof(int));\\n    memset(min_height, INT_MAX, n+1);\\n    ans[0] = 1;\\n    min_height[1] =  obstacles[0];\\n    int l = 1, r = 1, mid = 0, max_len = 1;\\n    for(int i = 1; i < n; i++){\\n        int target = obstacles[i];\\n        l = 1, r = max_len;\\n        /* if target value is already larger than the current max_len  \\n        obstacle height, the max_len will simply increase by one */\\n        if(min_height[max_len] <= target){\\n            ans[i] = ++max_len;\\n            min_height[max_len] = target;\\n            continue;\\n        }"]]}
{"id": "2107", "ref_c": [["int latestDayToCross(int row, int col, int** cells, int cellsSize, int* cellsColSize){\\n    int left = 0, right = cellsSize-1, mid;\\n    int sizeVisited = row * col;\\n    bool* visited = malloc(sizeVisited * sizeof(bool));\\n    int* queue = malloc(sizeVisited * sizeof(int));\\n    int** grid = calloc(row, sizeof(int*));\\n\\n    for(int i = 0; i < row; i++){\\n        grid[i] = calloc(col, sizeof(int));\\n    }"], ["int latestDayToCross(int row, int col, int** cells, int cellsSize, int* cellsColSize){\\n    int left = 0, right = cellsSize-1, mid;\\n    int sizeVisited = row * col;\\n    bool* visited = malloc(sizeVisited * sizeof(bool));\\n    int* queue = malloc(sizeVisited * sizeof(int));\\n    int** grid = calloc(row, sizeof(int*));\\n\\n    for(int i = 0; i < row; i++){\\n        grid[i] = calloc(col, sizeof(int));\\n    }"], ["int latestDayToCross(int row, int col, int** cells, int cellsSize, int* cellsColSize){\\n  int lo = 0;\\n  int hi = row * col;\\n\\n  /* Start off with the first half of the cells array blocked */\\n  bool grid[row][col];\\n  int mid = lo + (hi - lo) / 2;\\n  for (int i = 0; i < mid; ++i) {\\n    grid[cells[i][0] - 1][cells[i][1] - 1] = true;\\n  }"]]}
{"id": "2108", "ref_c": [["int threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0}"], ["int threeSumMulti(int* arr, int arrSize, int target){\\n    long sum = 0;\\n    long a, b, c;\\n    \\n    for(int i = 0;i <= target;i++)\\n    {\\n        for(int j = i;j <= target;j++)\\n        {\\n            for(int k = j;k <= target;k++)\\n            {\\n                if (i + j + k == target)\\n                {\\n                    a = countInArr(arr, arrSize, i);\\n                    b = countInArr(arr, arrSize, j);\\n                    c = countInArr(arr, arrSize, k);\\n\\n                    if (a != 0 && b != 0 && c != 0)\\n                    {\\n                        if (i != j && i != k && j != k)\\n                            sum += a * b * c;\\n                        else if (i == j && j == k)\\n                            sum += (a * (a - 1) * (a - 2)) / 6;\\n\\n                        else if (i == j)\\n                            sum += ((a * (a - 1)) / 2) * c;\\n \\n                        else if (i == k)\\n                            sum += ((a * (a - 1)) / 2) * b;\\n\\n                        else if (j == k)\\n                            sum += ((b * (b - 1)) / 2) * a;\\n\\n                        sum = sum % 1000000007;\\n                    }"], ["int threeSumMulti(int* arr, int arrSize, int target)\\n{\\n    unsigned long long c = 0;\\n    unsigned long long hash[101] = {0}"]]}
{"id": "2109", "ref_c": [["int* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int *answer=malloc(strlen(s)*sizeof(int));\\n    for(int i=0; s[i]!=\\'\\\\0\\'; i++){\\n        int count=0, flag=0, x=startPos[0], y=startPos[1];\\n        for(int j=i; s[j]!=\\'\\\\0\\'; j++){\\n            switch(s[j]){\\n                case \\'L\\':\\n                    y--;\\n                    if(y<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'R\\':\\n                    y++;\\n                    if(y>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'U\\':\\n                    x--;\\n                    if(x<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'D\\':\\n                    x++;\\n                    if(x>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n            }"], ["int* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int *answer=malloc(strlen(s)*sizeof(int));\\n    for(int i=0; s[i]!=\\'\\\\0\\'; i++){\\n        int count=0, flag=0, x=startPos[0], y=startPos[1];\\n        for(int j=i; s[j]!=\\'\\\\0\\'; j++){\\n            switch(s[j]){\\n                case \\'L\\':\\n                    y--;\\n                    if(y<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'R\\':\\n                    y++;\\n                    if(y>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'U\\':\\n                    x--;\\n                    if(x<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'D\\':\\n                    x++;\\n                    if(x>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n            }"], ["int* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int possible_move=0;\\n    int temp[2] = {startPos[0],startPos[1]}"]]}
{"id": "2110", "ref_c": [["int minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }"], ["int minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }"], ["int minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }"]]}
{"id": "2111", "ref_c": [["char ** braceExpansionII(char * expression, int* returnSize){\\n    int len = strlen(expression);\\n    int ans_len[4097] = {0}"], ["char ** braceExpansionII(char * expression, int* returnSize){\\n    int len = strlen(expression);\\n    int ans_len[4097] = {0}"], ["char ** braceExpansionII(char * expression, int* returnSize){\\n    int len = strlen(expression);\\n    int ans_len[4097] = {0}"]]}
{"id": "2112", "ref_c": [["int commonFactors(int a, int b)\\n{\\n    int c=0;\\n    for(int i=1;i<=(a>b?b:a);i++)\\n    {\\n        if(a%i==0 && b%i==0)\\n        c++;\\n    }"], ["int commonFactors(int a, int b){\\n  int m=0;\\n  int large,small;\\n  if(a<b)\\n  {\\n      small=a;\\n      large=b;\\n  }"], ["int commonFactors(int a, int b){\\n    int no_of_factorials = 0;\\n    for(int i = 1; i<=a; i++)\\n    {\\n        if(a%i == 0 && b%i == 0)\\n        {\\n            no_of_factorials+=1;\\n        }"]]}
{"id": "2113", "ref_c": [["int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }"], ["int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize)\\n{\\n    int en=0,ex=initialExperience,i,h=0,min=0;\\n    for(i=0;i<energySize;i++)\\n    {\\n        en+=energy[i];\\n        if(ex<=experience[i])\\n        {\\n            h+=(experience[i]-ex+1);\\n            ex+=(experience[i]-ex+1);\\n        }"], ["int minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }"]]}
{"id": "2114", "ref_c": [["int minOperations(int* nums, int numsSize) {\\n    // Define the maximum size of the sliding window\\n    int k = numsSize - 1;\\n\\n    // Sort the array in ascending order\\n    qsort(nums, numsSize, sizeof(int), compare);\\n\\n    // Remove adjacent duplicates\\n    int newLen = 1;\\n    for (int i = 1; i < numsSize; ++i) {\\n        if (nums[i] != nums[i - 1]) {\\n            nums[newLen++] = nums[i];\\n        }"], ["int minOperations(int* nums, int numsSize){\\n    \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    \\n    int len = 1;\\n\\n    for (int i = 1; i < numsSize; i++)\\n        if (nums[i] != nums[i - 1])\\n            nums[len++] = nums[i];\\n    \\n    int ans = numsSize;\\n    \\n    for (int i = 0; i < len; i++){\\n        int r = nums[i] + numsSize - 1, temp = binarySearch(r, nums, len);\\n        ans = fmin(ans, numsSize - temp + i);\\n    }"], ["int minOperations(int* nums, int numsSize){\\n    \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    \\n    int len = 1;\\n\\n    for (int i = 1; i < numsSize; i++)\\n        if (nums[i] != nums[i - 1])\\n            nums[len++] = nums[i];\\n    \\n    int ans = numsSize;\\n    \\n    for (int i = 0; i < len; i++){\\n        int r = nums[i] + numsSize - 1, temp = binarySearch(r, nums, len);\\n        ans = fmin(ans, numsSize - temp + i);\\n    }"]]}
{"id": "2115", "ref_c": [["char * largestMerge(char * word1, char * word2){\\n    int i=0, j, L = strlen(word1) + strlen(word2) + 1;\\n    char c, *merge = malloc(L * sizeof(char));\\n    merge[L-1] = \\'\\\\0\\';\\n    while(1) {\\n        if (*word1 == \\'\\\\0\\') {\\n            while(*word2 != \\'\\\\0\\') {\\n                merge[i++] = *word2;\\n                ++word2;\\n            }"], ["char * largestMerge(char * word1, char * word2){\\n    int i=0, j, L = strlen(word1) + strlen(word2) + 1;\\n    char c, *merge = malloc(L * sizeof(char));\\n    merge[L-1] = \\'\\\\0\\';\\n    while(1) {\\n        if (*word1 == \\'\\\\0\\') {\\n            while(*word2 != \\'\\\\0\\') {\\n                merge[i++] = *word2;\\n                ++word2;\\n            }"], ["char * largestMerge(char * word1, char * word2){\\n    int i=0, j, L = strlen(word1) + strlen(word2) + 1;\\n    char c, *merge = malloc(L * sizeof(char));\\n    merge[L-1] = \\'\\\\0\\';\\n    while(1) {\\n        if (*word1 == \\'\\\\0\\') {\\n            while(*word2 != \\'\\\\0\\') {\\n                merge[i++] = *word2;\\n                ++word2;\\n            }"]]}
{"id": "2116", "ref_c": ["\ntypedef struct Node {\n    void *data;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    int cityNum;\n    int visited;\n} City;\n\nNode **buildAdjacencyList(int numCities, int **roads, int roadSize) {\n    int i;\n    City *c;\n    Node *n1, *n2, **cities = malloc((numCities+1) * sizeof(Node*));\n    cities[0] = NULL;\n    for (i = 1; i <= numCities; ++i) {\n        c = malloc(sizeof(City));\n        c->cityNum = i;\n        c->visited = 0;\n        cities[i] = malloc(sizeof(Node));\n        cities[i]->data = (void*) c;\n        cities[i]->next = NULL;\n    }\n    for (i = 0; i < roadSize; ++i) {\n        n1 = malloc(sizeof(Node));\n        n1->data = cities[roads[i][1]]->data;\n        n1->next =  cities[roads[i][0]]->next;\n        n2 = malloc(sizeof(Node));\n        n2->data = cities[roads[i][0]]->data;\n        n2->next = cities[roads[i][1]]->next;\n        cities[roads[i][0]]->next = n1;\n        cities[roads[i][1]]->next = n2;\n\t}\n    return cities;\n}\n\nvoid dfs(int city, Node **adjList) {\n    Node *n = adjList[city];\n    City *c = (City*) n->data;\n    if (!c->visited) {\n        c->visited = 1;\n        n = n->next;\n        while (n != NULL) {\n            c = (City*) n->data;\n            dfs(c->cityNum, adjList);\n            n = n->next;\n        }\n    }\n}\n\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){\n    int i, distance, minDistance = MAX_INT;\n    City *c0, *c1;\n    Node **adjacencyList = buildAdjacencyList(n, roads, roadsSize);\n    dfs(1, adjacencyList);\n    for (i = 0; i < roadsSize; ++i) {\n        c0 = (City*) adjacencyList[roads[i][0]]->data;\n        c1 = (City*) adjacencyList[roads[i][1]]->data;\n        if (c0->visited && c1->visited) {\n            distance = roads[i][2];\n            printf(\"%d\n\", distance);\n            if (distance < minDistance) {\n                minDistance = distance;\n            }\n        }\n    }\n    return minDistance;\n}\n", "\ntypedef struct Node {\n    void *data;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    int cityNum;\n    int visited;\n} City;\n\nNode **buildAdjacencyList(int numCities, int **roads, int roadSize) {\n    int i;\n    City *c;\n    Node *n1, *n2, **cities = malloc((numCities+1) * sizeof(Node*));\n    cities[0] = NULL;\n    for (i = 1; i <= numCities; ++i) {\n        c = malloc(sizeof(City));\n        c->cityNum = i;\n        c->visited = 0;\n        cities[i] = malloc(sizeof(Node));\n        cities[i]->data = (void*) c;\n        cities[i]->next = NULL;\n    }\n    for (i = 0; i < roadSize; ++i) {\n        n1 = malloc(sizeof(Node));\n        n1->data = cities[roads[i][1]]->data;\n        n1->next =  cities[roads[i][0]]->next;\n        n2 = malloc(sizeof(Node));\n        n2->data = cities[roads[i][0]]->data;\n        n2->next = cities[roads[i][1]]->next;\n        cities[roads[i][0]]->next = n1;\n        cities[roads[i][1]]->next = n2;\n\t}\n    return cities;\n}\n\nvoid dfs(int city, Node **adjList) {\n    Node *n = adjList[city];\n    City *c = (City*) n->data;\n    if (!c->visited) {\n        c->visited = 1;\n        n = n->next;\n        while (n != NULL) {\n            c = (City*) n->data;\n            dfs(c->cityNum, adjList);\n            n = n->next;\n        }\n    }\n}\n\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){\n    int i, distance, minDistance = MAX_INT;\n    City *c0, *c1;\n    Node **adjacencyList = buildAdjacencyList(n, roads, roadsSize);\n    dfs(1, adjacencyList);\n    for (i = 0; i < roadsSize; ++i) {\n        c0 = (City*) adjacencyList[roads[i][0]]->data;\n        c1 = (City*) adjacencyList[roads[i][1]]->data;\n        if (c0->visited && c1->visited) {\n            distance = roads[i][2];\n            printf(\"%d\n\", distance);\n            if (distance < minDistance) {\n                minDistance = distance;\n            }\n        }\n    }\n    return minDistance;\n}\n", "\ntypedef struct Node {\n    void *data;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    int cityNum;\n    int visited;\n} City;\n\nNode **buildAdjacencyList(int numCities, int **roads, int roadSize) {\n    int i;\n    City *c;\n    Node *n1, *n2, **cities = malloc((numCities+1) * sizeof(Node*));\n    cities[0] = NULL;\n    for (i = 1; i <= numCities; ++i) {\n        c = malloc(sizeof(City));\n        c->cityNum = i;\n        c->visited = 0;\n        cities[i] = malloc(sizeof(Node));\n        cities[i]->data = (void*) c;\n        cities[i]->next = NULL;\n    }\n    for (i = 0; i < roadSize; ++i) {\n        n1 = malloc(sizeof(Node));\n        n1->data = cities[roads[i][1]]->data;\n        n1->next =  cities[roads[i][0]]->next;\n        n2 = malloc(sizeof(Node));\n        n2->data = cities[roads[i][0]]->data;\n        n2->next = cities[roads[i][1]]->next;\n        cities[roads[i][0]]->next = n1;\n        cities[roads[i][1]]->next = n2;\n\t}\n    return cities;\n}\n\nvoid dfs(int city, Node **adjList) {\n    Node *n = adjList[city];\n    City *c = (City*) n->data;\n    if (!c->visited) {\n        c->visited = 1;\n        n = n->next;\n        while (n != NULL) {\n            c = (City*) n->data;\n            dfs(c->cityNum, adjList);\n            n = n->next;\n        }\n    }\n}\n\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){\n    int i, distance, minDistance = MAX_INT;\n    City *c0, *c1;\n    Node **adjacencyList = buildAdjacencyList(n, roads, roadsSize);\n    dfs(1, adjacencyList);\n    for (i = 0; i < roadsSize; ++i) {\n        c0 = (City*) adjacencyList[roads[i][0]]->data;\n        c1 = (City*) adjacencyList[roads[i][1]]->data;\n        if (c0->visited && c1->visited) {\n            distance = roads[i][2];\n            printf(\"%d\n\", distance);\n            if (distance < minDistance) {\n                minDistance = distance;\n            }\n        }\n    }\n    return minDistance;\n}\n"]}
{"id": "2117", "ref_c": [["int numDecodings(char * s) {\\n  int dp[2] = {1, 0}"], ["int numDecodings(char * s) {\\n  int dp[2] = {1, 0}"], ["int numDecodings(char * s) {\\n  int dp[2] = {1, 0}"]]}
{"id": "2118", "ref_c": [["int* leftRightDifference(int* nums, int numsSize, int* returnSize)\\n{\\n    int *answer = malloc(numsSize * sizeof(int));\\n    if(answer == NULL)\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* leftRightDifference(int* nums, int numsSize, int* returnSize)\\n{\\n    int *answer = malloc(numsSize * sizeof(int));\\n    if(answer == NULL)\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* leftRightDifference(int* nums, int numsSize, int* returnSize){\\n    int *diff = (int *)malloc(numsSize * sizeof(int));\\n\\n    int leftSum[numsSize], rightSum[numsSize];\\n    leftSum[0] = 0;\\n\\n    for(int i = 0; i < numsSize - 1; i++){\\n        leftSum[i + 1] = leftSum[i] + nums[i];\\n    }"]]}
{"id": "2119", "ref_c": [["bool canMakeArithmeticProgression(int* arr, int arrSize){\\n    int i, commonDifference, nodePtr = 0;\\n    int min = INT_MAX, max = INT_MIN;\\n    iNode *ht[MOD], nodes[1000];\\n    memset(ht, 0, sizeof(ht));\\n    for (i = 0; i < arrSize; ++i) {\\n        insertht(ht, arr[i], &nodes[nodePtr++]);\\n        if(arr[i] < min) {\\n            min = arr[i];\\n        }"], ["bool canMakeArithmeticProgression(int* arr, int arrSize) {\\n    int firstTerm = arr[0];\\n    // first term of AP which is assumed to be minimum.\\n\\n    /*The first check is if all terms are same*/\\n    bool allEqual = true;\\n    for (int i = 1; i < arrSize; ++i) {\\n        if (firstTerm != arr[i]) {\\n            allEqual = false;\\n            break;\\n        }"], ["bool canMakeArithmeticProgression(int* arr, int arrSize){\\nint temp, i, j, index = 0;\\nfor(int i = 0 ; i <= arrSize - 1 ; i++){\\n    index = i;\\n    for(j = i + 1; j < arrSize ; j++){\\n        if( arr[j] < arr[index]){\\n            index = j;\\n        }"]]}
{"id": "2120", "ref_c": [["int numRollsToTarget(int n, int k, int target){\\n    /*\\n     * Input:\\n     *  n, numbers of dice\\n     *  k, numbers of faces of a die\\n     *  target, integer\\n     */\\n     \\n    for (int i = 0; i <= n; i++) {\\n        for (int j = 0; j <= target; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int numRollsToTarget(int n, int k, int target) {\\n        // 2D DP\\n\\n        // Time complexity: O(n * k * target)\\n        // Space complexity: O(n * target)\\n\\n        const int Mod = 1e9 + 7;\\n        int** dp = (int**)calloc(n + 1, sizeof(int*));\\n        for (int i = 0; i < n + 1; ++i) {\\n            dp[i] = (int*)calloc(target + 1, sizeof(int));\\n        }", "int numRollsToTarget(int n, int k, int target) {\\n        // 1D DP\\n\\n        // Time complexity: O(n * k * target)\\n        // Space complexity: O(2 * target)\\n\\n        const int Mod = 1e9 + 7;\\n        int* dp = (int*)calloc(target + 1, sizeof(int));\\n        int* temp = (int*)calloc(target + 1, sizeof(int));\\n        \\n        dp[0] = 1;\\n        for (int i = 1; i < n + 1; ++i) {\\n            for (int j = 0; j < target + 1; ++j) {\\n                temp[j] = 0;\\n            }"], ["int numRollsToTarget(int n, int k, int target) {\\n        // Base Case!\\n        if(target < 0) return 0;\\n        if(n == 0 && target == 0) return 1;\\n        if(n == 0 && target != 0) return 0;\\n        if(n != 0 && target == 0) return 0;\\n\\n        int res = 0;\\n        for(int i = 1; i <= k; i++){ // For no. of dice faces.\\n            res = res + numRollsToTarget(n -1, k, target -i);\\n        }", "int numRollsToTarget(int n, int k, int target) {\\n        vector<vector<long long int>> dp(n +1, vector<long long int>(target +1, -1));\\n        return solve(n, k, target, dp);\\n    }", "int numRollsToTarget(int n, int k, int target) {\\n        return solve(n, k, target);\\n    }"]]}
{"id": "2121", "ref_c": [["int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize) {\\n    *returnSize=arr1Size;\\n    int *array,n=0,c=0,m=0;\\n    for(int j=0; j<arr2Size; j++){\\n    for(int i=0; i<arr1Size; i++){\\n        if(arr1[i]==arr2[j]){\\n        c=arr1[i];\\n        arr1[i]=arr1[n];\\n        arr1[n]=c;\\n        n++;\\n        }"], ["int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize) {\\n    *returnSize=arr1Size;\\n    int *array,n=0,c=0,m=0;\\n    for(int j=0; j<arr2Size; j++){\\n    for(int i=0; i<arr1Size; i++){\\n        if(arr1[i]==arr2[j]){\\n        c=arr1[i];\\n        arr1[i]=arr1[n];\\n        arr1[n]=c;\\n        n++;\\n        }"], ["int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize) {\\n    *returnSize=arr1Size;\\n    int *array,n=0,c=0,m=0;\\n    for(int j=0; j<arr2Size; j++){\\n    for(int i=0; i<arr1Size; i++){\\n        if(arr1[i]==arr2[j]){\\n        c=arr1[i];\\n        arr1[i]=arr1[n];\\n        arr1[n]=c;\\n        n++;\\n        }"]]}
{"id": "2122", "ref_c": [["int minimumTime(int n, int** relations, int relationsSize, int* relationsColSize, int* time, int timeSize){\\n\\n    /*\\n     * Input:\\n     *  n,\\n     *  **relations\\n     *  relationsSize\\n     *  relationsColSize\\n     *  *time\\n     *  timeSize\\n     */\\n\\n    node_t *tmp, **adj = (node_t **)calloc(1, sizeof(node_t *) * (n + 1));\\n    int max = INT_MIN, months, *dp = (int *)malloc(sizeof(int) * (n + 1));\\n\\n    for (int i = 0; i <= n; i++) {\\n        dp[i] = -1;\\n    }"], ["int minimumTime(int n, int** relations, int relationsSize, int* relationsColSize, int* time, int timeSize){\\n\\n    /*\\n     * Input:\\n     *  n,\\n     *  **relations\\n     *  relationsSize\\n     *  relationsColSize\\n     *  *time\\n     *  timeSize\\n     */\\n\\n    node_t *tmp, **adj = (node_t **)calloc(1, sizeof(node_t *) * (n + 1));\\n    int max = INT_MIN, months, *dp = (int *)malloc(sizeof(int) * (n + 1));\\n\\n    for (int i = 0; i <= n; i++) {\\n        dp[i] = -1;\\n    }"], ["int minimumTime(int n, int** relations, int relationsSize, int* relationsColSize, int* time, int timeSize){\\n    qsort(relations, relationsSize, sizeof(int*), comp);\\n    \\n    int* Pre_work_count = calloc((n+1),sizeof(int));\\n    int* number_place = malloc(sizeof(int)*(n+1));\\n    \\n    for (int i = 1 ; i <= n ; i++){\\n        number_place[i] = -1;\\n    }"]]}
{"id": "2123", "ref_c": [["int* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=1;i<numsSize;i++)\\n    {\\n        nums[i]+=nums[i-1];\\n    }"], ["int* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=0;i<numsSize;i++)\\n    {\\n       sum=sum+nums[i];\\n        nums[i]=sum;\\n    }"], ["int* runningSum(int* nums, int numsSize, int* returnSize){\\n    // int *result = (int *)calloc(numsSize , sizeof(int));\\n    \\n    for(int i=1; i<numsSize; i++){\\n        nums[i] = nums[i-1] + nums[i];\\n    }"]]}
{"id": "2124", "ref_c": [["int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    (*returnSize) = 0;\\n    (*returnColumnSizes) = (int*) malloc(sizeof(int) * numsSize * numsSize);\\n    int **ret = (int**) malloc(sizeof(int*) * numsSize * numsSize);\\n    for (int i = 0; i < numsSize - 2; i++) {\\n        if (i == 0 || nums[i] != nums[i-1]) {\\n            int l = i + 1;\\n            int r = numsSize - 1;\\n            while (l < r) {\\n                if (nums[i] + nums[l] + nums[r] < 0) {\\n                    l++;\\n                }"], ["int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n\\n    int i,j,k,sum,t,total=64;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    *returnSize=0;\\n    int **q=(int**)malloc(sizeof(int*)*total);\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*total);\\n    for(i=0;i<numsSize-2;i++)\\n    {\\n        if(nums[i]>0||nums[i]+nums[i+1]+nums[i+2]>0)\\n            break;\\n        if(i>0&&nums[i]==nums[i-1])\\n            continue;\\n        j=i+1;\\n        k=numsSize-1;\\n        sum=-nums[i];\\n        while(j<k)\\n        {\\n            t=nums[j]+nums[k];\\n            if(t<sum)\\n                j++;\\n            else if(t>sum)\\n                k--;\\n            else\\n            {\\n                (*returnColumnSizes)[*returnSize]=3;\\n                q[*returnSize]=(int*) malloc(sizeof(int)*3);\\n                q[*returnSize][0]=nums[i];\\n                q[*returnSize][1]=nums[j++];\\n                q[*returnSize][2]=nums[k--];\\n                (*returnSize)++;\\n                while(j<k&&nums[j]==nums[j-1])\\n                    j++;\\n                while(j<k&&nums[k]==nums[k+1])\\n                    k--;\\n                if((*returnSize)==total)\\n                {\\n                    total*=2;\\n                    *returnColumnSizes=(int*)realloc(*returnColumnSizes,sizeof(int)*total);\\n                    q=(int**)realloc(q,sizeof(int*)*total);\\n                }"], ["int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n\\n    int i,j,k,sum,t,total=64;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    *returnSize=0;\\n    int **q=(int**)malloc(sizeof(int*)*total);\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*total);\\n    for(i=0;i<numsSize-2;i++)\\n    {\\n        if(nums[i]>0||nums[i]+nums[i+1]+nums[i+2]>0)\\n            break;\\n        if(i>0&&nums[i]==nums[i-1])\\n            continue;\\n        j=i+1;\\n        k=numsSize-1;\\n        sum=-nums[i];\\n        while(j<k)\\n        {\\n            t=nums[j]+nums[k];\\n            if(t<sum)\\n                j++;\\n            else if(t>sum)\\n                k--;\\n            else\\n            {\\n                (*returnColumnSizes)[*returnSize]=3;\\n                q[*returnSize]=(int*) malloc(sizeof(int)*3);\\n                q[*returnSize][0]=nums[i];\\n                q[*returnSize][1]=nums[j++];\\n                q[*returnSize][2]=nums[k--];\\n                (*returnSize)++;\\n                while(j<k&&nums[j]==nums[j-1])\\n                    j++;\\n                while(j<k&&nums[k]==nums[k+1])\\n                    k--;\\n                if((*returnSize)==total)\\n                {\\n                    total*=2;\\n                    *returnColumnSizes=(int*)realloc(*returnColumnSizes,sizeof(int)*total);\\n                    q=(int**)realloc(q,sizeof(int*)*total);\\n                }"]]}
{"id": "2125", "ref_c": [["int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){\\n    int dist=99999,index=-1;\\n    for(int i=0;i<pointsSize;i++){\\n        if(points[i][0]==x || points[i][1]==y){\\n            if(abs(points[i][0]-x)+abs(points[i][1]-y)<dist){\\n                dist=abs(points[i][0]-x)+abs(points[i][1]-y);\\n                index=i;\\n            }"], ["int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){\\n    int retIndex = -1;\\n    int min = INT_MAX;\\n    for(int i = 0; i < pointsSize; i++){\\n        if(x == points[i][0] || y == points[i][1]){\\n            int dist = abs(x - points[i][0]) + abs(y - points[i][1]);\\n            if(min > dist){\\n                min = dist; \\n                retIndex = i;\\n            }"], ["int nearestValidPoint(int x, int y, int** points, int pointsSize, int* pointsColSize){\\n    int index = -1;\\n    int Manhattan_distance = 0;\\n    int DIstance = 0;\\n    for(int i=0;i<pointsSize;i++)\\n    {\\n        if(points[i][0]==x||points[i][1]==y)\\n        {\\n           DIstance = abs(points[i][0]-x)+abs(points[i][1]-y);\\n           index = i;\\n           break;\\n        }"]]}
{"id": "2126", "ref_c": [["bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\\n\\n    int pmap[101];    \\n    for(int i=0; i<piecesSize; ++i){\\n        int j=0;\\n        while(j<piecesColSize[i]){\\n            if(j-1<0){\\n                // First (and possibly only) value, has no previous neighbour\\n                pmap[pieces[i][j]] = -1;\\n            }"], ["bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\\n    int ans = false;\\n    int* mapping = (int*)calloc(101, sizeof(int));\\n    /* record indx into mapping array */\\n    for(int i = 0; i < arrSize; i++)\\n        mapping[arr[i]] = i + 1;\\n    int startIdx;\\n    /* read the first element of piece then \\n        check the index correct or not*/\\n    for(int i = 0; i < piecesSize; i++){\\n        startIdx = mapping[pieces[i][0]];\\n        if(!startIdx) return false; /* index isn\\'t exist */\\n        for(int j = 0; j < piecesColSize[i]; j++)\\n            if(mapping[pieces[i][j]] != (startIdx + j))\\n                return false;   \\n    }"], ["bool canFormArray(int* arr, int arrSize, int** pieces, int piecesSize, int* piecesColSize){\\n\\n    int pmap[101];    \\n    for(int i=0; i<piecesSize; ++i){\\n        int j=0;\\n        while(j<piecesColSize[i]){\\n            if(j-1<0){\\n                // First (and possibly only) value, has no previous neighbour\\n                pmap[pieces[i][j]] = -1;\\n            }"]]}
{"id": "2127", "ref_c": [["char * removeTrailingZeros(char * num){\\n    int l=strlen(num);\\n    int i;\\n    for(i=l-1;i>=0;i--){\\n        if(num[i]!=\\'0\\')\\n            break;\\n        else{\\n            l--;\\n        }"], ["char * removeTrailingZeros(char * num){\\n   int i;\\n   for(i=strlen(num)-1;i>=0;i--){\\n       if(num[i]-48>0){\\n           num[i+1]=0;\\n           break;\\n       }"], ["char * removeTrailingZeros(char * num){\\n   int i;\\n   for(i=strlen(num)-1;i>=0;i--){\\n       if(num[i]-48>0){\\n           num[i+1]=0;\\n           break;\\n       }"]]}
{"id": "2128", "ref_c": [["int numberOfSteps(int num){\\n    int s=0;\\n    while(num!=0){\\n        if(num%2==0)\\n            num/=2;\\n        else\\n            num-=1;\\n        s++;\\n    }"], ["int numberOfSteps(int num) {\\n        int c=0 ;\\n        return reduce(num ,c) ;\\n        }", "int numberOfSteps(int num) {\\n        int count=0 ;\\n        while(num>0)\\n        {\\n            if(num%2==0)\\n            {\\n                num=num/2 ;\\n                count++ ;\\n            }"], ["int numberOfSteps(int num) {\\n        int c=0 ;\\n        return reduce(num ,c) ;\\n        }", "int numberOfSteps(int num) {\\n        int count=0 ;\\n        while(num>0)\\n        {\\n            if(num%2==0)\\n            {\\n                num=num/2 ;\\n                count++ ;\\n            }"]]}
{"id": "2129", "ref_c": [["char ** findOcurrences(char * text, char * first, char * second, int* returnSize){\\n    char** ans = (char**)calloc(50, sizeof(char*));\\n    int ansIdx = 0, idx = 0, len = strlen(text), fLen = strlen(first), sLen = strlen(second);\\n    int totalLen = fLen + sLen;\\n    int stage = 0;\\n    while(idx < len){\\n        int cIdx = 0;\\n        char* s = (char*)calloc(50, sizeof(char));\\n\\n        while(text[idx]!=\\' \\' && text[idx]!=\\'\\\\0\\')\\n            s[cIdx++] = text[idx++];\\n        \\n        switch(stage){\\n            case 0:\\n                if(cIdx == fLen && !strncmp(s, first, fLen))\\n                    stage = 1;\\n                break;\\n            case 1:\\n                if(cIdx == sLen && !strncmp(s, second, sLen))\\n                    stage = 2;\\n                else {\\n                    stage = 0;\\n                    idx -= (cIdx+1); /* move to the first word to check again */\\n                }"], ["char ** findOcurrences(char * text, char * first, char * second, int* returnSize){\\n    char** out = (char *) malloc(sizeof(out) * 333); // max_text_size / 3 is maximum amount occurences we will need to store\\n    *returnSize = 0;\\n    \\n    char *p, *f, *s;         // current token, first token, second token\\n    p = strtok(text, \" \");  // set current token using strtok() which returns a pointer to word up to delimiter \" \" (space)\\n\\tf = s = NULL;          // set first/second tokens to NULL\\n    while (p)    // while another token in the string exists\\n    {   \\n\\t    // if f and s tokens exist and are equal to first/second cstrings respectively\\n\\t\\t// then store the current token pointer in the last index of pointer array and increment last index (returnSize)\\n        if (stringEqualsToken(first, f) && stringEqualsToken(second, s))\\n            out[(*returnSize)++] = p;    \\n\\t\\t// updates: \\n        f = s;  // firstToken stores old secondToken,\\n\\t\\ts = p; // secondToken stores old current\\n\\t\\tp = strtok(NULL, \" \"); // current is next strtok() value\\n    }", "char ** findOcurrences(char * text, char * first, char * second, int* returnSize){\\n    *returnSize = 0;\\n    char **out = (char *) malloc(sizeof(out) * 333), *p = strtok(text, \" \"), *f  = NULL, *s = NULL;       \\n    while (p) {\\n        if (f && strcmp(first, f) == 0 && s && strcmp(second, s) == 0)\\n           out[(*returnSize)++] = p; \\n        f = s, s = p, p = strtok(NULL, \" \");\\n\\t}"], ["char ** findOcurrences(char * text, char * first, char * second, int* returnSize){\\n    /*\\n     * Input:\\n     *  text, string\\n     *  first, string\\n     *  second, string\\n     */\\n     \\n    char *words[1000];\\n    int wordsSize = 0;\\n    char **ans = (char **)malloc(sizeof(char *) * 1000);\\n    \\n    *returnSize = 0;\\n    \\n    /* \\n     * Extract words from text \\n     *  Dry run: text = \"aaa bb c\"\\n     *      start = 0, end = 0 ~ 3\\n     *          words[0] = \"aaa\"\\n     *      start = 4, end = 6\\n     *          words[1] = \"bb\"\\n     *      start = 7, end = 7,\\n     *          words[2] = ?\\n     */\\n    for (int start = 0, end = 0; ; end++) {\\n        if (text[end] == \\' \\' || text[end] == 0) {\\n            words[wordsSize] = (&text[start]);\\n            wordsSize++;\\n\\n            if (text[end] != 0) {\\n                /* Set termination of this word */\\n                text[end] = 0; \\n                start = end + 1;\\n            }"]]}
{"id": "2130", "ref_c": [["int* findAllPeople(int n, int** meetings, int meetingsSize, int* meetingsColSize, int firstPerson, int* returnSize){\\n    int* list = calloc(n,sizeof(int));\\n    int* ans = malloc(sizeof(int)*n);\\n    int* time = malloc(sizeof(int)*n);\\n    int timecount = 0;\\n    *returnSize = 2;\\n    for (int i = 0 ; i < meetingsSize ; i++){\\n        if (meetings[i][0] > meetings[i][1]) {\\n            int a = meetings[i][1];\\n            meetings[i][1] = meetings[i][0];\\n            meetings[i][0] = a;\\n        }"], ["int* findAllPeople(int n, int** meetings, int meetingsSize, int* meetingsColSize, int firstPerson, int* returnSize){\\n    int* list = calloc(n,sizeof(int));\\n    int* ans = malloc(sizeof(int)*n);\\n    int* time = malloc(sizeof(int)*n);\\n    int timecount = 0;\\n    *returnSize = 2;\\n    for (int i = 0 ; i < meetingsSize ; i++){\\n        if (meetings[i][0] > meetings[i][1]) {\\n            int a = meetings[i][1];\\n            meetings[i][1] = meetings[i][0];\\n            meetings[i][0] = a;\\n        }"], ["int* findAllPeople(int n, int** meetings, int meetingsSize, int* meetingsColSize, int firstPerson, int* returnSize){\\n    int* list = calloc(n,sizeof(int));\\n    int* ans = malloc(sizeof(int)*n);\\n    int* time = malloc(sizeof(int)*n);\\n    int timecount = 0;\\n    *returnSize = 2;\\n    for (int i = 0 ; i < meetingsSize ; i++){\\n        if (meetings[i][0] > meetings[i][1]) {\\n            int a = meetings[i][1];\\n            meetings[i][1] = meetings[i][0];\\n            meetings[i][0] = a;\\n        }"]]}
{"id": "2131", "ref_c": ["\nstatic int calcGcd(int num1, int num2){\n\twhile (num2 != 0){\n\t\tconst int remainder = num1 % num2;\n\n\t\tnum1 = num2;\n\t\tnum2 = remainder;\n\t}\n\treturn num1;\n}\n\nint subarrayGCD(\n\tconst int * const nums,\n\tconst int numsLen,\n\tconst int target\n){\n\tassert(target >= 1);\n\n\tint cnt = 0;\n\n\tint dp[numsLen];\n\tfor (int i = 0; i < numsLen; i += 1){\n\t\tassert(nums[i] >= 1);\n\n\t\tif (!( nums[i] >= target )){\n\t\t\tmemset( dp, -1, sizeof (int) * (1 + i) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp[i] = nums[i];\n\t\tif (dp[i] == target){\n\t\t\tcnt += 1;\n\t\t}\n\n\t\tfor (int j = i - 1; j >= 0; j -= 1){\n\t\t\tif (-1 == dp[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdp[j] = calcGcd(dp[j], nums[i]);\n\t\t\tif (!( dp[j] >= target )){\n\t\t\t\tdp[j] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (dp[j] == target){\n\t\t\t\tcnt += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n", "\nstatic int calcGcd(int num1, int num2){\n\twhile (num2 != 0){\n\t\tconst int remainder = num1 % num2;\n\n\t\tnum1 = num2;\n\t\tnum2 = remainder;\n\t}\n\treturn num1;\n}\n\nint subarrayGCD(\n\tconst int * const nums,\n\tconst int numsLen,\n\tconst int target\n){\n\tassert(target >= 1);\n\n\tint cnt = 0;\n\n\tint dp[numsLen];\n\tfor (int i = 0; i < numsLen; i += 1){\n\t\tassert(nums[i] >= 1);\n\n\t\tif (!( nums[i] >= target )){\n\t\t\tmemset( dp, -1, sizeof (int) * (1 + i) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp[i] = nums[i];\n\t\tif (dp[i] == target){\n\t\t\tcnt += 1;\n\t\t}\n\n\t\tfor (int j = i - 1; j >= 0; j -= 1){\n\t\t\tif (-1 == dp[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdp[j] = calcGcd(dp[j], nums[i]);\n\t\t\tif (!( dp[j] >= target )){\n\t\t\t\tdp[j] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (dp[j] == target){\n\t\t\t\tcnt += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n", "\nstatic int calcGcd(int num1, int num2){\n\twhile (num2 != 0){\n\t\tconst int remainder = num1 % num2;\n\n\t\tnum1 = num2;\n\t\tnum2 = remainder;\n\t}\n\treturn num1;\n}\n\nint subarrayGCD(\n\tconst int * const nums,\n\tconst int numsLen,\n\tconst int target\n){\n\tassert(target >= 1);\n\n\tint cnt = 0;\n\n\tint dp[numsLen];\n\tfor (int i = 0; i < numsLen; i += 1){\n\t\tassert(nums[i] >= 1);\n\n\t\tif (!( nums[i] >= target )){\n\t\t\tmemset( dp, -1, sizeof (int) * (1 + i) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp[i] = nums[i];\n\t\tif (dp[i] == target){\n\t\t\tcnt += 1;\n\t\t}\n\n\t\tfor (int j = i - 1; j >= 0; j -= 1){\n\t\t\tif (-1 == dp[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdp[j] = calcGcd(dp[j], nums[i]);\n\t\t\tif (!( dp[j] >= target )){\n\t\t\t\tdp[j] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (dp[j] == target){\n\t\t\t\tcnt += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n"]}
{"id": "2133", "ref_c": [["int maxTotalFruits(int** fruits, int fruitsSize, int* fruitsColSize, int startPos, int k){\\n    int left = -1;\\n    int right = -1;\\n    \\n    bSearch(fruits, fruitsSize, startPos, &right, &left);\\n    PRINT(\"First Fruit: %d %d\\\\n\", left, right);\\n    \\n    if (right < fruitsSize) {\\n        const int newK = k - (fruits[right][0] - startPos);\\n        if (newK >= 0) {\\n            right = findMaxRight(fruits, fruitsSize, right, newK);\\n        }"], ["int maxTotalFruits(int** fruits, int fruitsSize, int* fruitsColSize, int startPos, int k){\\n    int left = -1;\\n    int right = -1;\\n    \\n    bSearch(fruits, fruitsSize, startPos, &right, &left);\\n    PRINT(\"First Fruit: %d %d\\\\n\", left, right);\\n    \\n    if (right < fruitsSize) {\\n        const int newK = k - (fruits[right][0] - startPos);\\n        if (newK >= 0) {\\n            right = findMaxRight(fruits, fruitsSize, right, newK);\\n        }"], ["int maxTotalFruits(int** fruits, int fruitsSize, int* fruitsColSize, int startPos, int k){\\n    int left = -1;\\n    int right = -1;\\n    \\n    bSearch(fruits, fruitsSize, startPos, &right, &left);\\n    PRINT(\"First Fruit: %d %d\\\\n\", left, right);\\n    \\n    if (right < fruitsSize) {\\n        const int newK = k - (fruits[right][0] - startPos);\\n        if (newK >= 0) {\\n            right = findMaxRight(fruits, fruitsSize, right, newK);\\n        }"]]}
{"id": "2134", "ref_c": [["int kIncreasing(int* arr, int arrSize, int k){\\n    const int dpSize = (arrSize + k - 1)/k;\\n    int count = 0;\\n\\n    for (int i = 0; i < k; i++) {\\n        int size = dpSize;\\n        if ((arrSize % k) != 0 && i >= (arrSize % k)) {\\n            size--;\\n        }"], ["int kIncreasing(int* arr, int arrSize, int k){\\n    const int dpSize = (arrSize + k - 1)/k;\\n    int count = 0;\\n\\n    for (int i = 0; i < k; i++) {\\n        int size = dpSize;\\n        if ((arrSize % k) != 0 && i >= (arrSize % k)) {\\n            size--;\\n        }"], ["int kIncreasing(int* arr, int arrSize, int k){\\n    const int dpSize = (arrSize + k - 1)/k;\\n    int count = 0;\\n\\n    for (int i = 0; i < k; i++) {\\n        int size = dpSize;\\n        if ((arrSize % k) != 0 && i >= (arrSize % k)) {\\n            size--;\\n        }"]]}
{"id": "2135", "ref_c": [["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"], ["int numOfSubarrays(int* arr, int arrSize, int k, int threshold){\\n\\n    int suma        = 0;\\n    int sumofsubarr = 0;\\n\\n    for(int left=0, right=0;right<arrSize;right++){\\n        suma+=arr[right];\\n\\n        if(right-left==k-1)\\n        {\\n            if(suma/k>=threshold) sumofsubarr++;\\n            suma-=arr[left];\\n            left++;\\n        }"]]}
{"id": "2136", "ref_c": [["int* recoverArray(int* nums, int numsSize, int* returnSize){\\n    int *ret = calloc(numsSize/2, sizeof(int));\\n    Hash h = { 0, NULL }"], ["int* recoverArray(int* nums, int numsSize, int* returnSize){\\n    int *ret = calloc(numsSize/2, sizeof(int));\\n    Hash h = { 0, NULL }"], ["int* recoverArray(int* nums, int numsSize, int* returnSize){\\n    int *ret = calloc(numsSize/2, sizeof(int));\\n    Hash h = { 0, NULL }"]]}
{"id": "2137", "ref_c": ["\nbool solve(int mx,int target,int sum,int mask,int first){\n        if(first && sum >= target) return false;\n        if(sum >= target) return true;\n\n        if(dp[first][mask] != -1) return dp[first][mask];\n\n        if(first){\n            for(int i=1; i<=mx; ++i){\n                if(mask&(1 << i)) continue;\n                int newMask = mask | (1 << i);\n                if(solve(mx,target,sum+i,newMask,!first) == true) return dp[first][mask] = true;\n            }\n            return dp[first][mask] = false;\n        }\n        for(int i=1; i<=mx; ++i){\n            if(mask&(1 << i)) continue;\n            int newMask = mask | (1 << i);\n            if(solve(mx,target,sum+i,newMask,!first) == false) return dp[first][mask] = false;\n        }\n        return dp[first][mask] = true;\n    }\n    bool canIWin(int maxChoosableInteger, int desiredTotal){\n        if(desiredTotal == 0) return true;\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\n        dp = vector<vector<int>> (2,vector<int> (1 << maxChoosableInteger + 1, -1));\n        return solve(maxChoosableInteger,desiredTotal,0,0,1);\n    }\n};\n", "\nbool solve(int mx,int target,int sum,int mask,int first){\n        if(first && sum >= target) return false;\n        if(sum >= target) return true;\n\n        if(dp[first][mask] != -1) return dp[first][mask];\n\n        if(first){\n            for(int i=1; i<=mx; ++i){\n                if(mask&(1 << i)) continue;\n                int newMask = mask | (1 << i);\n                if(solve(mx,target,sum+i,newMask,!first) == true) return dp[first][mask] = true;\n            }\n            return dp[first][mask] = false;\n        }\n        for(int i=1; i<=mx; ++i){\n            if(mask&(1 << i)) continue;\n            int newMask = mask | (1 << i);\n            if(solve(mx,target,sum+i,newMask,!first) == false) return dp[first][mask] = false;\n        }\n        return dp[first][mask] = true;\n    }\n    bool canIWin(int maxChoosableInteger, int desiredTotal){\n        if(desiredTotal == 0) return true;\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\n        dp = vector<vector<int>> (2,vector<int> (1 << maxChoosableInteger + 1, -1));\n        return solve(maxChoosableInteger,desiredTotal,0,0,1);\n    }\n};\n", "\nbool solve(int mx,int target,int sum,int mask,int first){\n        if(first && sum >= target) return false;\n        if(sum >= target) return true;\n\n        if(dp[first][mask] != -1) return dp[first][mask];\n\n        if(first){\n            for(int i=1; i<=mx; ++i){\n                if(mask&(1 << i)) continue;\n                int newMask = mask | (1 << i);\n                if(solve(mx,target,sum+i,newMask,!first) == true) return dp[first][mask] = true;\n            }\n            return dp[first][mask] = false;\n        }\n        for(int i=1; i<=mx; ++i){\n            if(mask&(1 << i)) continue;\n            int newMask = mask | (1 << i);\n            if(solve(mx,target,sum+i,newMask,!first) == false) return dp[first][mask] = false;\n        }\n        return dp[first][mask] = true;\n    }\n    bool canIWin(int maxChoosableInteger, int desiredTotal){\n        if(desiredTotal == 0) return true;\n        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;\n        dp = vector<vector<int>> (2,vector<int> (1 << maxChoosableInteger + 1, -1));\n        return solve(maxChoosableInteger,desiredTotal,0,0,1);\n    }\n};\n"]}
{"id": "2138", "ref_c": [["bool possibleToStamp(int** grid, int gridSize, int* gridColSize, int stampHeight, int stampWidth){\\n    int occupied[gridSize][gridColSize[0]];\\n    bool stamps[gridSize][gridColSize[0]];\\n    \\n    // Count number of occupied cells up-left of a cell\\n    memset(occupied, 0, sizeof(occupied));    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            occupied[i][j] = grid[i][j];\\n            if (i > 0) {\\n                occupied[i][j] += occupied[i - 1][j];\\n            }"], ["bool possibleToStamp(int** grid, int gridSize, int* gridColSize, int stampHeight, int stampWidth){\\n    int occupied[gridSize][gridColSize[0]];\\n    bool stamps[gridSize][gridColSize[0]];\\n    \\n    // Count number of occupied cells up-left of a cell\\n    memset(occupied, 0, sizeof(occupied));    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            occupied[i][j] = grid[i][j];\\n            if (i > 0) {\\n                occupied[i][j] += occupied[i - 1][j];\\n            }"], ["bool possibleToStamp(int** grid, int gridSize, int* gridColSize, int stampHeight, int stampWidth){\\n    int occupied[gridSize][gridColSize[0]];\\n    bool stamps[gridSize][gridColSize[0]];\\n    \\n    // Count number of occupied cells up-left of a cell\\n    memset(occupied, 0, sizeof(occupied));    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            occupied[i][j] = grid[i][j];\\n            if (i > 0) {\\n                occupied[i][j] += occupied[i - 1][j];\\n            }"]]}
{"id": "2139", "ref_c": [["int earliestFullBloom(int* plantTime, int plantTimeSize, int* growTime, int growTimeSize) {\\n    // Sorting + Greedy \\n\\n    // Time complexity: O(nlogn)\\n    // Space complexity: O(n)\\n\\n    const int n = plantTimeSize;\\n    int result = 0, all_plant_time = 0;\\n\\n    struct Pair* arr = (struct Pair*)calloc(n, sizeof(struct Pair));\\n\\n    for (int i = 0; i < n; i++) {\\n        arr[i].first = plantTime[i];\\n        arr[i].second = growTime[i];\\n    }"], ["int earliestFullBloom(int* plantTime, int plantTimeSize, int* growTime, int growTimeSize){\\n    struct Plant* list = malloc(sizeof(struct Plant)*plantTimeSize);\\n    for (int i = 0 ; i < plantTimeSize ; i++){\\n        list[i].plant = plantTime[i];\\n        list[i].grow = growTime[i];\\n        list[i].all = plantTime[i] + growTime[i];\\n    }"], ["int earliestFullBloom(int* plantTime, int plantTimeSize, int* growTime, int growTimeSize){\\n\\t\\tstruct pair p[plantTimeSize];\\n\\t\\tfor(int i=0;i<plantTimeSize;i++){\\n\\t\\t\\tp[i].planttime=plantTime[i];\\n\\t\\t\\tp[i].growtime=growTime[i];\\n\\t\\t}"]]}
{"id": "2140", "ref_c": [["long long maxRunTime(int n, int* batteries, int batteriesSize) \\n{\\n    long long total_time = 0;\\n    int bool_computers[n][2]; // bool_computers[x][0] = Verification of on/off\\n                              // bool_computers[x][1] = Battery on usage index\\n    for (int i=0; i< n; i++) bool_computers[i][0] = 0;\\n\\n    for(int i=0; i<n; i++) {\\n        for(int c=0; c<batteriesSize; c++) {\\n            if (bool_computers[i][0] == 0) {\\n                if (batteries[c] > 0) {\\n                    bool_computers[i][0] = 1;\\n                    bool_computers[i][1] = c;\\n                }"], ["long long maxRunTime(int n, int* batteries, int batteriesSize) \\n{\\n    long long total_time = 0;\\n    int bool_computers[n][2]; // bool_computers[x][0] = Verification of on/off\\n                              // bool_computers[x][1] = Battery on usage index\\n    for (int i=0; i< n; i++) bool_computers[i][0] = 0;\\n\\n    for(int i=0; i<n; i++) {\\n        for(int c=0; c<batteriesSize; c++) {\\n            if (bool_computers[i][0] == 0) {\\n                if (batteries[c] > 0) {\\n                    bool_computers[i][0] = 1;\\n                    bool_computers[i][1] = c;\\n                }"], ["long long maxRunTime(int n, int* batteries, int batteriesSize){\\n\\n    long long low = (long long)min(batteries, batteriesSize);\\n    long long high = sum(batteries, batteriesSize)/n;\\n    long long res=1;\\n    long long mid;\\n    while(low<=high){\\n        mid = (low+high)/2;\\n        if(check(mid, batteries, batteriesSize, n)){\\n            res = mid;\\n            low = mid+1;\\n        }"]]}
{"id": "2141", "ref_c": [["int numberOfWays(char * corridor){\\n    // Cache the result of each sub-problem\\n    int cache[strlen(corridor)][3];\\n    memset(cache, -1, sizeof(cache));\\n\\n    // Call the count function\\n    return count(0, 0, corridor, cache);\\n}", "int numberOfWays(char * corridor){\\n    // Store 1000000007 in a variable for convenience\\n    const int MOD = 1e9 + 7;\\n\\n    // Initialize the array to store the result of each sub-problem\\n    int count[strlen(corridor) + 1][3];\\n\\n    // Base cases\\n    count[strlen(corridor)][0] = 0;\\n    count[strlen(corridor)][1] = 0;\\n    count[strlen(corridor)][2] = 1;\\n\\n    // Fill the array in a bottom-up fashion\\n    for (int index = strlen(corridor) - 1; index >= 0; index--) {\\n        if (corridor[index] == \\'S\\') {\\n            count[index][0] = count[index + 1][1];\\n            count[index][1] = count[index + 1][2];\\n            count[index][2] = count[index + 1][1];\\n        }", "int numberOfWays(char * corridor) { \\n    // Initial values of three variables\\n    int zero = 0;\\n    int one = 0;\\n    int two = 1;\\n\\n    // Compute using derived equations\\n    for (int index = 0; index < strlen(corridor); index++) {\\n        if (corridor[index] == \\'S\\') {\\n            zero = one;\\n            swap(&one, &two);\\n        }", "int numberOfWays(char * corridor) {\\n    // Store 1000000007 in a variable for convenience\\n    const int MOD = 1e9 + 7;\\n\\n    // Store indices of S in an array\\n    int indices[strlen(corridor)];\\n    int indicesLength = 0;\\n    for (int index = 0; index < strlen(corridor); index++) {\\n        if (corridor[index] == \\'S\\') {\\n            indices[indicesLength++] = index;\\n        }", "int numberOfWays(char * corridor){\\n    // Store 1000000007 in a variable for convenience\\n    const int MOD = 1e9 + 7;\\n\\n    // Total number of ways\\n    long count = 1;\\n\\n    // Number of seats in the current section\\n    int seats = 0;\\n\\n    // Tracking Index of last S in the previous section\\n    int previousPairLast = -1;\\n\\n    // Keep track of seats in the corridor\\n    for (int index = 0; index < strlen(corridor); index++) {\\n        if (corridor[index] == \\'S\\') {\\n            seats += 1;\\n\\n            // If two seats, then this is the last S in the section\\n            // Update seats for the next section\\n            if (seats == 2) {\\n                previousPairLast = index;\\n                seats = 0;\\n            }"], ["int numberOfWays(char * corridor){\\n    // Cache the result of each sub-problem\\n    int cache[strlen(corridor)][3];\\n    memset(cache, -1, sizeof(cache));\\n\\n    // Call the count function\\n    return count(0, 0, corridor, cache);\\n}", "int numberOfWays(char * corridor){\\n    // Store 1000000007 in a variable for convenience\\n    const int MOD = 1e9 + 7;\\n\\n    // Initialize the array to store the result of each sub-problem\\n    int count[strlen(corridor) + 1][3];\\n\\n    // Base cases\\n    count[strlen(corridor)][0] = 0;\\n    count[strlen(corridor)][1] = 0;\\n    count[strlen(corridor)][2] = 1;\\n\\n    // Fill the array in a bottom-up fashion\\n    for (int index = strlen(corridor) - 1; index >= 0; index--) {\\n        if (corridor[index] == \\'S\\') {\\n            count[index][0] = count[index + 1][1];\\n            count[index][1] = count[index + 1][2];\\n            count[index][2] = count[index + 1][1];\\n        }", "int numberOfWays(char * corridor) { \\n    // Initial values of three variables\\n    int zero = 0;\\n    int one = 0;\\n    int two = 1;\\n\\n    // Compute using derived equations\\n    for (int index = 0; index < strlen(corridor); index++) {\\n        if (corridor[index] == \\'S\\') {\\n            zero = one;\\n            swap(&one, &two);\\n        }", "int numberOfWays(char * corridor) {\\n    // Store 1000000007 in a variable for convenience\\n    const int MOD = 1e9 + 7;\\n\\n    // Store indices of S in an array\\n    int indices[strlen(corridor)];\\n    int indicesLength = 0;\\n    for (int index = 0; index < strlen(corridor); index++) {\\n        if (corridor[index] == \\'S\\') {\\n            indices[indicesLength++] = index;\\n        }", "int numberOfWays(char * corridor){\\n    // Store 1000000007 in a variable for convenience\\n    const int MOD = 1e9 + 7;\\n\\n    // Total number of ways\\n    long count = 1;\\n\\n    // Number of seats in the current section\\n    int seats = 0;\\n\\n    // Tracking Index of last S in the previous section\\n    int previousPairLast = -1;\\n\\n    // Keep track of seats in the corridor\\n    for (int index = 0; index < strlen(corridor); index++) {\\n        if (corridor[index] == \\'S\\') {\\n            seats += 1;\\n\\n            // If two seats, then this is the last S in the section\\n            // Update seats for the next section\\n            if (seats == 2) {\\n                previousPairLast = index;\\n                seats = 0;\\n            }"], ["int numberOfWays(char * corridor){\\n    // Cache the result of each sub-problem\\n    int cache[strlen(corridor)][3];\\n    memset(cache, -1, sizeof(cache));\\n\\n    // Call the count function\\n    return count(0, 0, corridor, cache);\\n}", "int numberOfWays(char * corridor){\\n    // Store 1000000007 in a variable for convenience\\n    const int MOD = 1e9 + 7;\\n\\n    // Initialize the array to store the result of each sub-problem\\n    int count[strlen(corridor) + 1][3];\\n\\n    // Base cases\\n    count[strlen(corridor)][0] = 0;\\n    count[strlen(corridor)][1] = 0;\\n    count[strlen(corridor)][2] = 1;\\n\\n    // Fill the array in a bottom-up fashion\\n    for (int index = strlen(corridor) - 1; index >= 0; index--) {\\n        if (corridor[index] == \\'S\\') {\\n            count[index][0] = count[index + 1][1];\\n            count[index][1] = count[index + 1][2];\\n            count[index][2] = count[index + 1][1];\\n        }", "int numberOfWays(char * corridor) { \\n    // Initial values of three variables\\n    int zero = 0;\\n    int one = 0;\\n    int two = 1;\\n\\n    // Compute using derived equations\\n    for (int index = 0; index < strlen(corridor); index++) {\\n        if (corridor[index] == \\'S\\') {\\n            zero = one;\\n            swap(&one, &two);\\n        }", "int numberOfWays(char * corridor) {\\n    // Store 1000000007 in a variable for convenience\\n    const int MOD = 1e9 + 7;\\n\\n    // Store indices of S in an array\\n    int indices[strlen(corridor)];\\n    int indicesLength = 0;\\n    for (int index = 0; index < strlen(corridor); index++) {\\n        if (corridor[index] == \\'S\\') {\\n            indices[indicesLength++] = index;\\n        }", "int numberOfWays(char * corridor){\\n    // Store 1000000007 in a variable for convenience\\n    const int MOD = 1e9 + 7;\\n\\n    // Total number of ways\\n    long count = 1;\\n\\n    // Number of seats in the current section\\n    int seats = 0;\\n\\n    // Tracking Index of last S in the previous section\\n    int previousPairLast = -1;\\n\\n    // Keep track of seats in the corridor\\n    for (int index = 0; index < strlen(corridor); index++) {\\n        if (corridor[index] == \\'S\\') {\\n            seats += 1;\\n\\n            // If two seats, then this is the last S in the section\\n            // Update seats for the next section\\n            if (seats == 2) {\\n                previousPairLast = index;\\n                seats = 0;\\n            }"]]}
{"id": "2142", "ref_c": [["int countPairs(struct TreeNode* root, int distance){\\n    if(!root) return 0;\\n    int ansCnt = 0, idx = 0;\\n    DFS(root, distance, &ansCnt, &idx);\\n    return ansCnt;\\n}"], ["int countPairs(struct TreeNode* root, int distance)\\n{\\n    total_count = 0;\\n    int arr_index = 0;\\n    int * ret = count(root, distance, &arr_index);\\n    return total_count;\\n}"], ["int countPairs(struct TreeNode* root, int distance)\\n{\\n    total_count = 0;\\n    int arr_index = 0;\\n    int * ret = count(root, distance, &arr_index);\\n    return total_count;\\n}"]]}
{"id": "2143", "ref_c": [["int minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }"], ["int minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }"], ["int minimizeMax(int* nums, int numsSize, int p) {\\n    // Binary search + Greedy\\n\\n    // Time complexity: O(nlog(n) + nlog(nums.max - nums.min))\\n    // Space complexity: O(nlogn)\\n\\n    qsort(nums, numsSize, sizeof(int), ascend);\\n\\n    int left = 0, right = nums[numsSize - 1] - nums[0];\\n    while (left < right) {\\n        const int middle = left + (right - left) / 2;\\n        if (num_pairs(nums, numsSize, middle) >= p) {\\n            right = middle;\\n        }"]]}
{"id": "2144", "ref_c": [["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"], ["bool validPalindrome(char * s)\\n{\\n   for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\\n       if (s[i] != s[j])\\n           return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);\\n   return true;\\n}"]]}
{"id": "2145", "ref_c": [["bool validMountainArray(int* arr, int arrSize)\\n{\\n    if(arrSize < 3)\\n    {\\n        return false;\\n    }"], ["bool validMountainArray(int* arr, int arrSize){\\n    if (arrSize < 3) {return 0;}"], ["bool validMountainArray(int* arr, int arrSize){\\n    if (arrSize < 3) {return 0;}"]]}
{"id": "2146", "ref_c": [["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"], ["int minPartitions(char * n){\\n    char a=\\'0\\';\\n    for(int i=0;i<strlen(n);i++){\\n        if(n[i]>a){\\n            a=n[i];\\n        }"]]}
{"id": "2147", "ref_c": [["int hammingDistance(int x, int y)\\n{\\n    int n,count=0;\\n    n = x^y;\\n    while(n!=0)\\n    {\\n        count++;\\n        n = n&(n-1);\\n    }"], ["int hammingDistance(int x, int y) {\\n        int count=0;\\n\\t\\t\\n\\t\\t//do xor between x and y\\n        int num=x^y;\\n        \\n        while(num!=0){\\n\\t\\t\\t\\n\\t\\t\\t//AND operation is done to check the presence of \\'1\\' bit in num. if no \\'1\\' bit\\'s are there then it will be zero and if condition will become false.  \\n            if((1 & num)!=0)\\n                count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t//Right shift operation to remove the last bit\\n            num=num>>1;\\n        }"], ["int hammingDistance(int x, int y){\\n    int d=0,n=x^y;\\n    while(n){\\n        n&=n-1;\\n        d++;\\n    }"]]}
{"id": "2148", "ref_c": [["int* findingUsersActiveMinutes(int** logs, int logsSize, int* logsColSize, int k, int* returnSize){\\n    qsort(logs, logsSize, sizeof(int*), cmp);\\n    int* ans = (int*)calloc(k, sizeof(int));\\n    int UAM = 0, currTaskId = -1;\\n    for(int i=0; i < logsSize; i++){\\n        if(currTaskId!=logs[i][0]){\\n            if(currTaskId>=0)\\n                ans[UAM-1]++;\\n            UAM = 1;\\n            currTaskId = logs[i][0];\\n        }"], ["int* findingUsersActiveMinutes(int** logs, int logsSize, int* logsColSize, int k, int* returnSize){\\n    qsort(logs, logsSize, sizeof(int*), cmp);\\n    int* ans = (int*)calloc(k, sizeof(int));\\n    int UAM = 0, currTaskId = -1;\\n    for(int i=0; i < logsSize; i++){\\n        if(currTaskId!=logs[i][0]){\\n            if(currTaskId>=0)\\n                ans[UAM-1]++;\\n            UAM = 1;\\n            currTaskId = logs[i][0];\\n        }"], ["int* findingUsersActiveMinutes(int** logs, int logsSize, int* logsColSize, int k, int* returnSize){\\n    qsort(logs, logsSize, sizeof(int*), cmp);\\n    int* ans = (int*)calloc(k, sizeof(int));\\n    int UAM = 0, currTaskId = -1;\\n    for(int i=0; i < logsSize; i++){\\n        if(currTaskId!=logs[i][0]){\\n            if(currTaskId>=0)\\n                ans[UAM-1]++;\\n            UAM = 1;\\n            currTaskId = logs[i][0];\\n        }"]]}
{"id": "2149", "ref_c": [["int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = 1;\\n    for(int i=1; i<=numsSize; i++) (*returnSize) *= i;\\n    *returnColumnSizes = (int*)malloc(*returnSize * sizeof(int)); \\n    *returnSize = 0;\\n    int **arr = (int**)malloc(sizeof(int*));\\n    backtrack(nums, numsSize, &arr, returnSize, returnColumnSizes, 0);\\n    return arr;\\n}"], ["int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\\n    int totalPermutations = 1;\\n    for (int i = 1; i <= numsSize; i++) {\\n        totalPermutations *= i;\\n    }"], ["int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\\n    int totalPermutations = 1;\\n    for (int i = 1; i <= numsSize; i++) {\\n        totalPermutations *= i;\\n    }"]]}
{"id": "2150", "ref_c": [["bool checkPerfectNumber(int num){\\nint sum=0;\\nfor(int i=1;i<=num/2;i++)\\n{\\n         if(num%i==0)\\n         {\\n            sum+=i;\\n         }"], ["bool checkPerfectNumber(int num) {\\n        if(num == 1) return false;\\n        int sum = 1;\\n        for(int i=2; i<=sqrt(num); i++)\\n            if(num%i == 0)\\n                sum+=i + num/i;\\n        return sum == num;\\n    }", "bool checkPerfectNumber(int num){\\n    if(num == 1) return false;\\n    int sum = 1;\\n    for(int i=2; i<=sqrt(num); i++)\\n        if(num%i == 0)\\n            sum+=i + num/i;\\n    return sum == num;\\n}"], ["bool checkPerfectNumber(int num) {\\n    if(num & 1) return false;\\n        else {\\n            int n = num/2;\\n            int sum = 0;\\n            for(int i=1; i<=n; i++) {\\n                if(num%i == 0) {\\n                    sum += i;\\n                }"]]}
{"id": "2151", "ref_c": [["int minMovesToMakePalindrome(char * s){\\n    int len = strlen(s), minMoves = 0, idx = 0;\\n\\n    while(len > 0) {\\n        char  *ret = strchr(s, s[len - 1]);\\n        int pos = ret - s;\\n    \\n        if(pos == len - 1) {\\n            minMoves += pos / 2;\\n        }"], ["int minMovesToMakePalindrome(char * s){\\n    int len = strlen(s), minMoves = 0, idx = 0;\\n\\n    while(len > 0) {\\n        char  *ret = strchr(s, s[len - 1]);\\n        int pos = ret - s;\\n    \\n        if(pos == len - 1) {\\n            minMoves += pos / 2;\\n        }"], ["int minMovesToMakePalindrome(char * s){\\n    int len = strlen(s), minMoves = 0, idx = 0;\\n\\n    while(len > 0) {\\n        char  *ret = strchr(s, s[len - 1]);\\n        int pos = ret - s;\\n    \\n        if(pos == len - 1) {\\n            minMoves += pos / 2;\\n        }"]]}
{"id": "2152", "ref_c": [["int* replaceNonCoprimes(int* nums, int numsSize, int* returnSize)\\n\\t{\\n\\t\\tint j = 0;   // left pointer\\n\\t\\tint g;\\n\\n\\t\\tfor (int i = 1; i < numsSize; ++i)\\n\\t\\t{    \\n\\t\\t\\tg = gcd(nums[j], nums[i]);\\n\\n\\t\\t\\tif (g == 1)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tif (++j != i)\\n\\t\\t\\t\\t\\tnums[j] = nums[i];\\n\\t\\t\\t}"], ["int* replaceNonCoprimes(int* nums, int numsSize, int* returnSize)\\n\\t{\\n\\t\\tint j = 0;   // left pointer\\n\\t\\tint g;\\n\\n\\t\\tfor (int i = 1; i < numsSize; ++i)\\n\\t\\t{    \\n\\t\\t\\tg = gcd(nums[j], nums[i]);\\n\\n\\t\\t\\tif (g == 1)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tif (++j != i)\\n\\t\\t\\t\\t\\tnums[j] = nums[i];\\n\\t\\t\\t}"], ["int* replaceNonCoprimes(int* nums, int numsSize, int* returnSize)\\n\\t{\\n\\t\\tint j = 0;   // left pointer\\n\\t\\tint g;\\n\\n\\t\\tfor (int i = 1; i < numsSize; ++i)\\n\\t\\t{    \\n\\t\\t\\tg = gcd(nums[j], nums[i]);\\n\\n\\t\\t\\tif (g == 1)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tif (++j != i)\\n\\t\\t\\t\\t\\tnums[j] = nums[i];\\n\\t\\t\\t}"]]}
{"id": "2153", "ref_c": [["long long minimumWeight(int n, int** edges, int edgesSize, int* edgesColSize, int src1, int src2, int dest){\\n    if (edgesSize == 0){\\n        return -1;\\n    }"], ["long long minimumWeight(int n, int** edges, int edgesSize, int* edgesColSize, int src1, int src2, int dest){\\n    if (edgesSize == 0){\\n        return -1;\\n    }"], ["long long minimumWeight(int n, int** edges, int edgesSize, int* edgesColSize, int src1, int src2, int dest){\\n    if (edgesSize == 0){\\n        return -1;\\n    }"]]}
{"id": "2154", "ref_c": [["int* recoverArray(int* nums, int numsSize, int* returnSize){\\n    int *ret = calloc(numsSize/2, sizeof(int));\\n    Hash h = { 0, NULL }"], ["int* recoverArray(int* nums, int numsSize, int* returnSize){\\n    int *ret = calloc(numsSize/2, sizeof(int));\\n    Hash h = { 0, NULL }"], ["int* recoverArray(int* nums, int numsSize, int* returnSize){\\n    int *ret = calloc(numsSize/2, sizeof(int));\\n    Hash h = { 0, NULL }"]]}
{"id": "2155", "ref_c": [["int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\\n    /*Merge Sort*/\\n    merge(pairs,0,pairsSize-1);\\n\\n    /*Geedy*/\\n    /*index pevents pairs[i][0] from being between the range of previous nodes*/\\n    int ans=0,index=0;\\n    for(int i=0;i<pairsSize;i++){\\n        if(i==0){\\n            ans++;\\n        }"], ["int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\\n    /*Merge Sort*/\\n    merge(pairs,0,pairsSize-1);\\n\\n    /*Geedy*/\\n    /*index pevents pairs[i][0] from being between the range of previous nodes*/\\n    int ans=0,index=0;\\n    for(int i=0;i<pairsSize;i++){\\n        if(i==0){\\n            ans++;\\n        }"], ["int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){\\n    /*Merge Sort*/\\n    merge(pairs,0,pairsSize-1);\\n\\n    /*Geedy*/\\n    /*index pevents pairs[i][0] from being between the range of previous nodes*/\\n    int ans=0,index=0;\\n    for(int i=0;i<pairsSize;i++){\\n        if(i==0){\\n            ans++;\\n        }"]]}
{"id": "2156", "ref_c": [["int maxValueOfCoins(int** piles, int pilesSize, int* pilesColSize, int k){\\n    int** list = malloc(sizeof(int*)*pilesSize);\\n    for (int i = 0 ; i < pilesSize ; i++){\\n        list[i] = malloc(sizeof(int)*(k+1));\\n    }"], ["int maxValueOfCoins(int** piles, int pilesSize, int* pilesColSize, int k){\\n    int **dp=(int**)malloc(sizeof(int*)*pilesSize);\\n    for(int i=0;i<pilesSize;i++){\\n        dp[i]=calloc(k+1,sizeof(int));\\n    }"], ["int maxValueOfCoins(int** piles, int pilesSize, int* pilesColSize, int k){\\n    int **dp=(int**)malloc(sizeof(int*)*pilesSize);\\n    for(int i=0;i<pilesSize;i++){\\n        dp[i]=calloc(k+1,sizeof(int));\\n    }"]]}
{"id": "2157", "ref_c": [["struct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }"], ["struct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }"], ["struct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }"]]}
{"id": "2159", "ref_c": [["long long maximumBeauty(int* flowers, int flowersSize, long long newFlowers, int target, int full, int partial){\\n    if (flowersSize == 1){\\n        if (flowers[0] + newFlowers >= target){\\n            return full > (long long)(target-1)*partial ? full : (long long)(target-1)*partial;\\n        }"], ["long long maximumBeauty(int* flowers, int flowersSize, long long newFlowers, int target, int full, int partial){\\n    if (flowersSize == 1){\\n        if (flowers[0] + newFlowers >= target){\\n            return full > (long long)(target-1)*partial ? full : (long long)(target-1)*partial;\\n        }"], ["long long maximumBeauty(int* flowers, int flowersSize, long long newFlowers, int target, int full, int partial){\\n    if (flowersSize == 1){\\n        if (flowers[0] + newFlowers >= target){\\n            return full > (long long)(target-1)*partial ? full : (long long)(target-1)*partial;\\n        }"]]}
{"id": "2160", "ref_c": [["int numRollsToTarget(int n, int k, int target){\\n    /*\\n     * Input:\\n     *  n, numbers of dice\\n     *  k, numbers of faces of a die\\n     *  target, integer\\n     */\\n     \\n    for (int i = 0; i <= n; i++) {\\n        for (int j = 0; j <= target; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int numRollsToTarget(int n, int k, int target) {\\n        // 2D DP\\n\\n        // Time complexity: O(n * k * target)\\n        // Space complexity: O(n * target)\\n\\n        const int Mod = 1e9 + 7;\\n        int** dp = (int**)calloc(n + 1, sizeof(int*));\\n        for (int i = 0; i < n + 1; ++i) {\\n            dp[i] = (int*)calloc(target + 1, sizeof(int));\\n        }", "int numRollsToTarget(int n, int k, int target) {\\n        // 1D DP\\n\\n        // Time complexity: O(n * k * target)\\n        // Space complexity: O(2 * target)\\n\\n        const int Mod = 1e9 + 7;\\n        int* dp = (int*)calloc(target + 1, sizeof(int));\\n        int* temp = (int*)calloc(target + 1, sizeof(int));\\n        \\n        dp[0] = 1;\\n        for (int i = 1; i < n + 1; ++i) {\\n            for (int j = 0; j < target + 1; ++j) {\\n                temp[j] = 0;\\n            }"], ["int numRollsToTarget(int n, int k, int target) {\\n        // Base Case!\\n        if(target < 0) return 0;\\n        if(n == 0 && target == 0) return 1;\\n        if(n == 0 && target != 0) return 0;\\n        if(n != 0 && target == 0) return 0;\\n\\n        int res = 0;\\n        for(int i = 1; i <= k; i++){ // For no. of dice faces.\\n            res = res + numRollsToTarget(n -1, k, target -i);\\n        }", "int numRollsToTarget(int n, int k, int target) {\\n        vector<vector<long long int>> dp(n +1, vector<long long int>(target +1, -1));\\n        return solve(n, k, target, dp);\\n    }", "int numRollsToTarget(int n, int k, int target) {\\n        return solve(n, k, target);\\n    }"]]}
{"id": "2161", "ref_c": [["int longestPath(int* parent, int parentSize, char * s)\\n{\\n    int i;\\n    int result = 1;\\n    int *count = malloc(sizeof(int) * parentSize);\\n    int dist[parentSize]; \\n    struct Node **root = malloc(sizeof(struct Node *) * parentSize);\\n    struct Node *curNode;\\n\\n    memset(count, 0, sizeof(int) * parentSize);\\n    memset(dist, 0, sizeof(int) * parentSize);\\n\\n\\n    for(i = 1; i < parentSize; i++)\\n    {\\n        count[parent[i]] += 1;\\n        count[i] += 1;\\n    }"], ["int longestPath(int* parent, int parentSize, char * s)\\n{\\n    int i;\\n    int result = 1;\\n    int *count = malloc(sizeof(int) * parentSize);\\n    int dist[parentSize]; \\n    struct Node **root = malloc(sizeof(struct Node *) * parentSize);\\n    struct Node *curNode;\\n\\n    memset(count, 0, sizeof(int) * parentSize);\\n    memset(dist, 0, sizeof(int) * parentSize);\\n\\n\\n    for(i = 1; i < parentSize; i++)\\n    {\\n        count[parent[i]] += 1;\\n        count[i] += 1;\\n    }"], ["int longestPath(int* parent, int parentSize, char * s)\\n{\\n    int i;\\n    int result = 1;\\n    int *count = malloc(sizeof(int) * parentSize);\\n    int dist[parentSize]; \\n    struct Node **root = malloc(sizeof(struct Node *) * parentSize);\\n    struct Node *curNode;\\n\\n    memset(count, 0, sizeof(int) * parentSize);\\n    memset(dist, 0, sizeof(int) * parentSize);\\n\\n\\n    for(i = 1; i < parentSize; i++)\\n    {\\n        count[parent[i]] += 1;\\n        count[i] += 1;\\n    }"]]}
{"id": "2162", "ref_c": [["int* fullBloomFlowers(int** flowers, int flowersSize, int* flowersColSize, int* people, int peopleSize, int* returnSize){\\n\\n    /*\\n     * Input:\\n     *  flowers,\\n     *  flowersSize,\\n     *  flowersColSize\\n     *  people\\n     *  peopleSize\\n     */\\n\\n    int *start = (int *)malloc(sizeof(int) * flowersSize);\\n    int *end = (int *)malloc(sizeof(int) * flowersSize);\\n    int *ans = (int *)malloc(sizeof(int) * peopleSize);\\n\\n    /*\\n     * Store the bloom start and end time seperately. \\n     * Note that we store start - 1 in array \\n     */\\n    for (int i = 0; i < flowersSize; i++) {\\n        start[i] = flowers[i][0] - 1;\\n        end[i] = flowers[i][1];\\n    }"], ["int* fullBloomFlowers(int** flowers, int flowersSize, int* flowersColSize, int* people, int peopleSize, int* returnSize) {\\n    int* s = (int*)malloc(flowersSize * sizeof(int));\\n    int* e = (int*)malloc(flowersSize * sizeof(int));\\n\\n    for (int i = 0; i < flowersSize; i++) {\\n        s[i] = flowers[i][0];\\n        e[i] = flowers[i][1];\\n    }"], ["int* fullBloomFlowers(int** flowers, int flowersSize, int* flowersColSize, int* people, int peopleSize, int* returnSize) {\\n    int* start = (int*)malloc(flowersSize * sizeof(int));\\n    int* end = (int*)malloc(flowersSize * sizeof(int));\\n    int* res = (int*)malloc(peopleSize * sizeof(int));\\n\\n    for (int i = 0; i < flowersSize; i++) {\\n        start[i] = flowers[i][0];\\n        end[i] = flowers[i][1];\\n    }"]]}
{"id": "2163", "ref_c": [["int maximumMinutes(int** grid, int gridSize, int* gridColSize){\\n    int human = 0;\\n    int hx[10000];\\n    int hy[10000];\\n    \\n    int fire = 0;\\n    int fx[10000];\\n    int fy[10000];\\n    \\n    int human_step = -1;\\n    int fire_stap = 3;\\n\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    int end = 0;\\n    \\n    if (grid[0][1] == 0){\\n        grid[0][1] = human_step;\\n        hx[human] = 0;\\n        hy[human] = 1;\\n        human++;\\n    }"], ["int maximumMinutes(int** grid, int gridSize, int* gridColSize){\\n    int human = 0;\\n    int hx[10000];\\n    int hy[10000];\\n    \\n    int fire = 0;\\n    int fx[10000];\\n    int fy[10000];\\n    \\n    int human_step = -1;\\n    int fire_stap = 3;\\n\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    int end = 0;\\n    \\n    if (grid[0][1] == 0){\\n        grid[0][1] = human_step;\\n        hx[human] = 0;\\n        hy[human] = 1;\\n        human++;\\n    }"], ["int maximumMinutes(int** grid, int gridSize, int* gridColSize){\\n    int human = 0;\\n    int hx[10000];\\n    int hy[10000];\\n    \\n    int fire = 0;\\n    int fx[10000];\\n    int fy[10000];\\n    \\n    int human_step = -1;\\n    int fire_stap = 3;\\n\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    int end = 0;\\n    \\n    if (grid[0][1] == 0){\\n        grid[0][1] = human_step;\\n        hx[human] = 0;\\n        hy[human] = 1;\\n        human++;\\n    }"]]}
{"id": "2164", "ref_c": [["long long appealSum(char * s){\\n    ll res=0;\\n    int n=strlen(s);\\n    int *map=calloc(26,sizeof(int));\\n    for(int i=0;i<n;i++){\\n        res+=(ll)(i+1-map[s[i]-\\'a\\'])*(ll)(n-i);\\n        map[s[i]-\\'a\\']=i+1;\\n    }"], ["long long appealSum(char * s){\\n    ll res=0;\\n    int n=strlen(s);\\n    int *map=calloc(26,sizeof(int));\\n    for(int i=0;i<n;i++){\\n        res+=(ll)(i+1-map[s[i]-\\'a\\'])*(ll)(n-i);\\n        map[s[i]-\\'a\\']=i+1;\\n    }"], ["long long appealSum(char * s){\\n    ll res=0;\\n    int n=strlen(s);\\n    int *map=calloc(26,sizeof(int));\\n    for(int i=0;i<n;i++){\\n        res+=(ll)(i+1-map[s[i]-\\'a\\'])*(ll)(n-i);\\n        map[s[i]-\\'a\\']=i+1;\\n    }"]]}
{"id": "2165", "ref_c": [["bool hasValidPath(char** grid, int gridSize, int* gridColSize){\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    if (grid[x][y] == \\'(\\' || grid[0][0] == \\')\\'  || (x+y) % 2 == 0){\\n        return false;\\n    }"], ["bool hasValidPath(char** grid, int gridSize, int* gridColSize){\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    if (grid[x][y] == \\'(\\' || grid[0][0] == \\')\\'  || (x+y) % 2 == 0){\\n        return false;\\n    }"], ["bool hasValidPath(char** grid, int gridSize, int* gridColSize){\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    if (grid[x][y] == \\'(\\' || grid[0][0] == \\')\\'  || (x+y) % 2 == 0){\\n        return false;\\n    }"]]}
{"id": "2166", "ref_c": [["int largestVariance(char * s){\\n    char c, i, j;\\n    short res = 0, B[26][26][2] = {0}"], ["int largestVariance(char * s){\\n    int *freqCount = (int *)calloc(26, sizeof(int)); \\n    for(int i = 0; i < strlen(s); i++){\\n        freqCount[s[i] - \\'a\\']++; \\n    }", "int largestVariance(char * s){\\n    //Fixed window sliding\\n    //Hashmap, loops through for each slide\\n    int var = 0; \\n    int *hashmap = (int *)calloc(26, sizeof(int));\\n    for(int i = 0; i < strlen(s); i++){\\n        int j;\\n        for(j = 0; j < i + 1; j++){ //initialize sliding window\\n            hashmap[s[j] - \\'a\\']++; \\n        }"], ["int largestVariance(char * s){\\n    int *freqCount = (int *)calloc(26, sizeof(int)); \\n    for(int i = 0; i < strlen(s); i++){\\n        freqCount[s[i] - \\'a\\']++; \\n    }", "int largestVariance(char * s){\\n    //Fixed window sliding\\n    //Hashmap, loops through for each slide\\n    int var = 0; \\n    int *hashmap = (int *)calloc(26, sizeof(int));\\n    for(int i = 0; i < strlen(s); i++){\\n        int j;\\n        for(j = 0; j < i + 1; j++){ //initialize sliding window\\n            hashmap[s[j] - \\'a\\']++; \\n        }"]]}
{"id": "2168", "ref_c": [["int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\t*returnColumnSizes = NULL;\\n\\n\\tstruct word_hash* table = NULL;\\n\\tstruct word_hash* entries = malloc(wordsSize * sizeof(struct word_hash));\\n\\n\\t/* Put all words into a hashtable */\\n\\tint empty_idx = -1;\\n\\tsize_t max_len = 0;\\n\\tfor (int i = 0; i < wordsSize; ++i) {\\n\\t\\tsize_t len = strlen(words[i]);\\n\\t\\tif (!len) {\\n\\t\\t\\tempty_idx = i;\\n\\t\\t\\tcontinue;\\n\\t\\t}", "int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\t/* Allocate word_tries in a large buffer to reduce the number of malloc calls */\\n\\tstruct buffer_list {\\n\\t\\tstruct word_trie buf[128];\\n\\t\\tstruct buffer_list* next;\\n\\t}"], ["int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\t*returnColumnSizes = NULL;\\n\\n\\tstruct word_hash* table = NULL;\\n\\tstruct word_hash* entries = malloc(wordsSize * sizeof(struct word_hash));\\n\\n\\t/* Put all words into a hashtable */\\n\\tint empty_idx = -1;\\n\\tsize_t max_len = 0;\\n\\tfor (int i = 0; i < wordsSize; ++i) {\\n\\t\\tsize_t len = strlen(words[i]);\\n\\t\\tif (!len) {\\n\\t\\t\\tempty_idx = i;\\n\\t\\t\\tcontinue;\\n\\t\\t}", "int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\t/* Allocate word_tries in a large buffer to reduce the number of malloc calls */\\n\\tstruct buffer_list {\\n\\t\\tstruct word_trie buf[128];\\n\\t\\tstruct buffer_list* next;\\n\\t}"], ["int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\tint** ret = NULL;\\n\\t*returnSize = 0;\\n\\tint cap = 0;\\n\\t*returnColumnSizes = NULL;\\n\\n\\tstruct word_hash* table = NULL;\\n\\tstruct word_hash* entries = malloc(wordsSize * sizeof(struct word_hash));\\n\\n\\t/* Put all words into a hashtable */\\n\\tint empty_idx = -1;\\n\\tsize_t max_len = 0;\\n\\tfor (int i = 0; i < wordsSize; ++i) {\\n\\t\\tsize_t len = strlen(words[i]);\\n\\t\\tif (!len) {\\n\\t\\t\\tempty_idx = i;\\n\\t\\t\\tcontinue;\\n\\t\\t}", "int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){\\n\\t/* Allocate word_tries in a large buffer to reduce the number of malloc calls */\\n\\tstruct buffer_list {\\n\\t\\tstruct word_trie buf[128];\\n\\t\\tstruct buffer_list* next;\\n\\t}"]]}
{"id": "2170", "ref_c": [["int minimumObstacles(int** grid, int gridSize, int* gridColSize){\\n    int p = gridSize*(*gridColSize);\\n    int** list = malloc(sizeof(int*)*p);\\n    for (int i = 0 ; i < p ; i++){\\n        list[i] = malloc(sizeof(int)*2);\\n    }"], ["int minimumObstacles(int** grid, int gridSize, int* gridColSize){\\n    int p = gridSize*(*gridColSize);\\n    int** list = malloc(sizeof(int*)*p);\\n    for (int i = 0 ; i < p ; i++){\\n        list[i] = malloc(sizeof(int)*2);\\n    }"], ["int minimumObstacles(int** grid, int gridSize, int* gridColSize){\\n    int p = gridSize*(*gridColSize);\\n    int** list = malloc(sizeof(int*)*p);\\n    for (int i = 0 ; i < p ; i++){\\n        list[i] = malloc(sizeof(int)*2);\\n    }"]]}
{"id": "2172", "ref_c": [["bool matchReplacement(char * s, char * sub, char** mappings, int mappingsSize, int* mappingsColSize){\\n    int s_i = 0, s_len = strlen(s), sub_len = strlen(sub), i = 0, j = 0, k = 0;\\n    hash *map = NULL;\\n    \\n    for (i = 0; i < sub_len; i++) {\\n        for (j = 0; j < mappingsSize; j++) {\\n            hash *tmp = NULL;\\n            if (sub[i] == mappings[j][0]) {\\n                char replace = mappings[j][1];\\n                int bit_mask = 0;\\n                HASH_FIND_INT(map, &i, tmp);\\n                if (NULL == tmp) {\\n                    tmp = (hash*) malloc(sizeof(hash));\\n                    tmp->idx = i;\\n                    memset(tmp->mappings, 0x00, 8);\\n                    HASH_ADD_INT(map, idx, tmp);\\n                }", "bool matchReplacement(char * s, char * sub, char** mappings, int mappingsSize, int* mappingsColSize){\\n    int s_i = 0, s_len = strlen(s), sub_len = strlen(sub), i = 0, j = 0;\\n    hash *map = NULL;\\n    \\n    for (i = 0; i < mappingsSize; i++) {\\n        hash *tmp = NULL;\\n\\t\\tint key = mappings[i][0];\\n        char replace = mappings[i][1];\\n        int bit_mask = 0;\\n        HASH_FIND_INT(map, &key, tmp);\\n        if (NULL == tmp) {\\n            tmp = (hash*) malloc(sizeof(hash));\\n            tmp->key = key;\\n            memset(tmp->mappings, 0x00, 8);\\n            HASH_ADD_INT(map, key, tmp);\\n        }"], ["bool matchReplacement(char * s, char * sub, char** mappings, int mappingsSize, int* mappingsColSize){\\n    int s_i = 0, s_len = strlen(s), sub_len = strlen(sub), i = 0, j = 0, k = 0;\\n    hash *map = NULL;\\n    \\n    for (i = 0; i < sub_len; i++) {\\n        for (j = 0; j < mappingsSize; j++) {\\n            hash *tmp = NULL;\\n            if (sub[i] == mappings[j][0]) {\\n                char replace = mappings[j][1];\\n                int bit_mask = 0;\\n                HASH_FIND_INT(map, &i, tmp);\\n                if (NULL == tmp) {\\n                    tmp = (hash*) malloc(sizeof(hash));\\n                    tmp->idx = i;\\n                    memset(tmp->mappings, 0x00, 8);\\n                    HASH_ADD_INT(map, idx, tmp);\\n                }", "bool matchReplacement(char * s, char * sub, char** mappings, int mappingsSize, int* mappingsColSize){\\n    int s_i = 0, s_len = strlen(s), sub_len = strlen(sub), i = 0, j = 0;\\n    hash *map = NULL;\\n    \\n    for (i = 0; i < mappingsSize; i++) {\\n        hash *tmp = NULL;\\n\\t\\tint key = mappings[i][0];\\n        char replace = mappings[i][1];\\n        int bit_mask = 0;\\n        HASH_FIND_INT(map, &key, tmp);\\n        if (NULL == tmp) {\\n            tmp = (hash*) malloc(sizeof(hash));\\n            tmp->key = key;\\n            memset(tmp->mappings, 0x00, 8);\\n            HASH_ADD_INT(map, key, tmp);\\n        }"], ["bool matchReplacement(char * s, char * sub, char** mappings, int mappingsSize, int* mappingsColSize){\\n    int lens = strlen(s);\\n    int len_sub = strlen(sub);\\n    bool** list = malloc(sizeof(int*)*125);\\n    for (int i = 48 ; i < 125 ; i++){\\n        list[i] = calloc(125,sizeof(int));\\n        list[i][i] = true;\\n    }"]]}
{"id": "2173", "ref_c": [["long long countSubarrays(int* nums, int numsSize, long long k){\\n    long long j = nums[0];\\n    long long count = 1;\\n    int st = 0;\\n    int en = 1;\\n    long long ans = 0; \\n    while (en < numsSize){\\n        if (j*count < k){\\n            ans += count;\\n            j += nums[en];\\n            en++;\\n            count++;\\n            while (j*count < k && en < numsSize){\\n                ans += count;\\n                j += nums[en];\\n                en++;\\n                count++;\\n            }"], ["long long countSubarrays(int* nums, int numsSize, long long k){\\n    long long j = nums[0];\\n    long long count = 1;\\n    int st = 0;\\n    int en = 1;\\n    long long ans = 0; \\n    while (en < numsSize){\\n        if (j*count < k){\\n            ans += count;\\n            j += nums[en];\\n            en++;\\n            count++;\\n            while (j*count < k && en < numsSize){\\n                ans += count;\\n                j += nums[en];\\n                en++;\\n                count++;\\n            }"], ["long long countSubarrays(int* nums, int numsSize, long long k){\\n    long long j = nums[0];\\n    long long count = 1;\\n    int st = 0;\\n    int en = 1;\\n    long long ans = 0; \\n    while (en < numsSize){\\n        if (j*count < k){\\n            ans += count;\\n            j += nums[en];\\n            en++;\\n            count++;\\n            while (j*count < k && en < numsSize){\\n                ans += count;\\n                j += nums[en];\\n                en++;\\n                count++;\\n            }"]]}
{"id": "2174", "ref_c": [["long long distinctNames(char ** ideas, int ideasSize){\\n    printf(\"%d\",ideasSize);\\n    group** words=(group**)calloc(sizeof(group*),26);\\n    group_2** words_tree=(group_2**)calloc(sizeof(group_2*),25);\\n    int* count=(int*)calloc(26,4),i;\\n    int** pairs=(int**)malloc(25*sizeof(int*));\\n    long long ans=0;\\n    for(i=0;i<ideasSize;i++){\\n        int val=ideas[i][0]-\\'a\\';\\n        words[val]=insert_in_list(ideas[i]+1,words[val]);\\n        count[val]++;\\n        if(val) {\\n            val--;\\n            if(words_tree[val]) insert_in_tree(ideas[i]+1,words_tree[val]);\\n            else{\\n                words_tree[val]=(group_2*)calloc(1,sizeof(group_2));\\n                words_tree[val]->word=ideas[i]+1;\\n            }"], ["long long distinctNames(char ** ideas, int ideasSize){\\n    printf(\"%d\",ideasSize);\\n    group** words=(group**)calloc(sizeof(group*),26);\\n    group_2** words_tree=(group_2**)calloc(sizeof(group_2*),25);\\n    int* count=(int*)calloc(26,4),i;\\n    int** pairs=(int**)malloc(25*sizeof(int*));\\n    long long ans=0;\\n    for(i=0;i<ideasSize;i++){\\n        int val=ideas[i][0]-\\'a\\';\\n        words[val]=insert_in_list(ideas[i]+1,words[val]);\\n        count[val]++;\\n        if(val) {\\n            val--;\\n            if(words_tree[val]) insert_in_tree(ideas[i]+1,words_tree[val]);\\n            else{\\n                words_tree[val]=(group_2*)calloc(1,sizeof(group_2));\\n                words_tree[val]->word=ideas[i]+1;\\n            }"], ["long long distinctNames(char ** ideas, int ideasSize){\\n    printf(\"%d\",ideasSize);\\n    group** words=(group**)calloc(sizeof(group*),26);\\n    group_2** words_tree=(group_2**)calloc(sizeof(group_2*),25);\\n    int* count=(int*)calloc(26,4),i;\\n    int** pairs=(int**)malloc(25*sizeof(int*));\\n    long long ans=0;\\n    for(i=0;i<ideasSize;i++){\\n        int val=ideas[i][0]-\\'a\\';\\n        words[val]=insert_in_list(ideas[i]+1,words[val]);\\n        count[val]++;\\n        if(val) {\\n            val--;\\n            if(words_tree[val]) insert_in_tree(ideas[i]+1,words_tree[val]);\\n            else{\\n                words_tree[val]=(group_2*)calloc(1,sizeof(group_2));\\n                words_tree[val]->word=ideas[i]+1;\\n            }"]]}
{"id": "2175", "ref_c": [["long long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize){\\n    long long** list = malloc(sizeof(long long*)*(m+1));\\n    \\n    for (int i = 0 ; i <= m ; i++){\\n        list[i] = calloc((n+1),sizeof(long long));\\n    }"], ["long long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize){\\n    long long** list = malloc(sizeof(long long*)*(m+1));\\n    \\n    for (int i = 0 ; i <= m ; i++){\\n        list[i] = calloc((n+1),sizeof(long long));\\n    }"], ["long long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize){\\n    long long** list = malloc(sizeof(long long*)*(m+1));\\n    \\n    for (int i = 0 ; i <= m ; i++){\\n        list[i] = calloc((n+1),sizeof(long long));\\n    }"]]}
{"id": "2176", "ref_c": [["int removeStones(int** stones, int stonesSize, int* stonesColSize) {\\n\\tstruct stone_hash* set = NULL;\\t\\t\\t/* Set of connected stones */\\n\\tstruct stone_hash* by_row = NULL;\\t\\t/* First stone at each row location */\\n\\tstruct stone_hash* by_col = NULL;\\t\\t/* First stone at each col location */\\n\\tstruct stone_hash* const entries = malloc(stonesSize * sizeof(struct stone_hash));\\n\\n\\tfor (int i = 0; i < stonesSize; ++i) {\\n\\t\\tstruct stone_hash* entry = &entries[i];\\n\\t\\tstruct stone_hash* row_entry;\\n\\t\\tstruct stone_hash* col_entry;\\n\\t\\tHASH_FIND(by_row_hh, by_row, &stones[i][0], sizeof(stones[i][0]), row_entry);\\n\\t\\tHASH_FIND(by_col_hh, by_col, &stones[i][1], sizeof(stones[i][1]), col_entry);\\n\\t\\tif (row_entry && col_entry) {\\n\\t\\t\\tstruct stone_hash* row_parent = find_parent(row_entry);\\n\\t\\t\\tstruct stone_hash* col_parent = find_parent(col_entry);\\n\\t\\t\\t/* Different parents mean we need to link the trees together */\\n\\t\\t\\tif (row_parent != col_parent) {\\n\\t\\t\\t\\tcol_parent->parent = row_parent;\\n\\t\\t\\t\\t/* Since the col_parent is now connected, remove from the main set */\\n\\t\\t\\t\\tHASH_DELETE(set_hh, set, col_parent);\\n\\t\\t\\t}"], ["int removeStones(int** stones, int stonesSize, int* stonesColSize) {\\n\\tstruct stone_hash* set = NULL;\\t\\t\\t/* Set of connected stones */\\n\\tstruct stone_hash* by_row = NULL;\\t\\t/* First stone at each row location */\\n\\tstruct stone_hash* by_col = NULL;\\t\\t/* First stone at each col location */\\n\\tstruct stone_hash* const entries = malloc(stonesSize * sizeof(struct stone_hash));\\n\\n\\tfor (int i = 0; i < stonesSize; ++i) {\\n\\t\\tstruct stone_hash* entry = &entries[i];\\n\\t\\tstruct stone_hash* row_entry;\\n\\t\\tstruct stone_hash* col_entry;\\n\\t\\tHASH_FIND(by_row_hh, by_row, &stones[i][0], sizeof(stones[i][0]), row_entry);\\n\\t\\tHASH_FIND(by_col_hh, by_col, &stones[i][1], sizeof(stones[i][1]), col_entry);\\n\\t\\tif (row_entry && col_entry) {\\n\\t\\t\\tstruct stone_hash* row_parent = find_parent(row_entry);\\n\\t\\t\\tstruct stone_hash* col_parent = find_parent(col_entry);\\n\\t\\t\\t/* Different parents mean we need to link the trees together */\\n\\t\\t\\tif (row_parent != col_parent) {\\n\\t\\t\\t\\tcol_parent->parent = row_parent;\\n\\t\\t\\t\\t/* Since the col_parent is now connected, remove from the main set */\\n\\t\\t\\t\\tHASH_DELETE(set_hh, set, col_parent);\\n\\t\\t\\t}"], ["int removeStones(int** stones, int stonesSize, int* stonesColSize) {\\n\\tstruct stone_hash* set = NULL;\\t\\t\\t/* Set of connected stones */\\n\\tstruct stone_hash* by_row = NULL;\\t\\t/* First stone at each row location */\\n\\tstruct stone_hash* by_col = NULL;\\t\\t/* First stone at each col location */\\n\\tstruct stone_hash* const entries = malloc(stonesSize * sizeof(struct stone_hash));\\n\\n\\tfor (int i = 0; i < stonesSize; ++i) {\\n\\t\\tstruct stone_hash* entry = &entries[i];\\n\\t\\tstruct stone_hash* row_entry;\\n\\t\\tstruct stone_hash* col_entry;\\n\\t\\tHASH_FIND(by_row_hh, by_row, &stones[i][0], sizeof(stones[i][0]), row_entry);\\n\\t\\tHASH_FIND(by_col_hh, by_col, &stones[i][1], sizeof(stones[i][1]), col_entry);\\n\\t\\tif (row_entry && col_entry) {\\n\\t\\t\\tstruct stone_hash* row_parent = find_parent(row_entry);\\n\\t\\t\\tstruct stone_hash* col_parent = find_parent(col_entry);\\n\\t\\t\\t/* Different parents mean we need to link the trees together */\\n\\t\\t\\tif (row_parent != col_parent) {\\n\\t\\t\\t\\tcol_parent->parent = row_parent;\\n\\t\\t\\t\\t/* Since the col_parent is now connected, remove from the main set */\\n\\t\\t\\t\\tHASH_DELETE(set_hh, set, col_parent);\\n\\t\\t\\t}"]]}
{"id": "2177", "ref_c": [["int maximumsSplicedArray(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int front[nums1Size+1];\\n    front[0] = 0;\\n    int sum1 = 0;\\n    int sum2 = 0;\\n    for (int i = 0 ; i < nums1Size ; i++){\\n        sum1 += nums1[i];\\n        sum2 += nums2[i];\\n        front[i+1] = sum1-sum2;\\n    }"], ["int maximumsSplicedArray(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int front[nums1Size+1];\\n    front[0] = 0;\\n    int sum1 = 0;\\n    int sum2 = 0;\\n    for (int i = 0 ; i < nums1Size ; i++){\\n        sum1 += nums1[i];\\n        sum2 += nums2[i];\\n        front[i+1] = sum1-sum2;\\n    }"], ["int maximumsSplicedArray(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    int front[nums1Size+1];\\n    front[0] = 0;\\n    int sum1 = 0;\\n    int sum2 = 0;\\n    for (int i = 0 ; i < nums1Size ; i++){\\n        sum1 += nums1[i];\\n        sum2 += nums2[i];\\n        front[i+1] = sum1-sum2;\\n    }"]]}
{"id": "2178", "ref_c": [["int xorBeauty(int* nums, int numsSize){\\nint i,j,res=0;\\nfor(i=0;i<numsSize;i++)\\nres^=nums[i];\\nreturn res;\\n}"], ["int xorBeauty(int* nums, int numsSize){\\n    int result=0;\\n    for(int i=0; i<numsSize; i++){\\n        result^=nums[i];\\n    }"], ["int xorBeauty(int* nums, int numsSize){\\n    int result=0;\\n    for(int i=0; i<numsSize; i++){\\n        result^=nums[i];\\n    }"]]}
{"id": "2179", "ref_c": [["int countPaths(int** grid, int gridSize, int* gridColSize){\\n    int **seen=(int**)malloc(sizeof(int*)*gridSize);\\n    for(int i=0;i<gridSize;i++){\\n        seen[i]=calloc(*gridColSize,sizeof(int));\\n    }"], ["int countPaths(int** grid, int gridSize, int* gridColSize){\\n    int **dp = (int**)malloc(sizeof(int*) * gridSize);\\n    for(int i = 0;i < gridSize;i++){\\n        dp[i] = (int*)malloc(sizeof(int) * gridColSize[0]);\\n        for(int j = 0;j < gridColSize[0];j++){\\n            dp[i][j] = 0;\\n        }", "int countPaths(int** grid, int gridSize, int* gridColSize){\\n\\n    int result = 0;\\n    int*** dp = (int***)malloc(sizeof(int**) * gridSize);\\n    for(int i = 0;i < gridSize;i++){\\n        dp[i] = (int**)malloc(sizeof(int*) * gridColSize[0]);\\n        for(int j = 0;j < gridColSize[0];j++){\\n            dp[i][j] = (int*)malloc(sizeof(int) * (gridSize * gridColSize[0] + 1));\\n        }"], ["int countPaths(int** grid, int gridSize, int* gridColSize){\\n    int **dp = (int**)malloc(sizeof(int*) * gridSize);\\n    for(int i = 0;i < gridSize;i++){\\n        dp[i] = (int*)malloc(sizeof(int) * gridColSize[0]);\\n        for(int j = 0;j < gridColSize[0];j++){\\n            dp[i][j] = 0;\\n        }", "int countPaths(int** grid, int gridSize, int* gridColSize){\\n\\n    int result = 0;\\n    int*** dp = (int***)malloc(sizeof(int**) * gridSize);\\n    for(int i = 0;i < gridSize;i++){\\n        dp[i] = (int**)malloc(sizeof(int*) * gridColSize[0]);\\n        for(int j = 0;j < gridColSize[0];j++){\\n            dp[i][j] = (int*)malloc(sizeof(int) * (gridSize * gridColSize[0] + 1));\\n        }"]]}
{"id": "2180", "ref_c": [["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    int *lucky;\\n    int i,j,k,x,check;\\n    int minRow,maxCol;\\n    coordinates cor[matrixSize];\\n    \\n    lucky = (int *)malloc(sizeof(int) * matrixSize);\\n    \\n    k = 0;\\n    for(i = 0; i < matrixSize; i++){\\n        minRow = INT_MAX;\\n        for(j = 0; j < *matrixColSize; j++){\\n            if(matrix[i][j] < minRow){\\n                minRow = matrix[i][j];\\n                cor[i].row = i;\\n                cor[i].col = j;\\n            }"], ["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\\n     int *ans=malloc(sizeof(int)*50);\\n     int min;\\n     int max;\\n     int idx;\\n     int m=0;\\n     for(int i=0;i<matrixSize;i++)\\n     {\\n         min=1000000;\\n         for(int j=0;j<(*matrixColSize);j++)\\n         {\\n             if(min>matrix[i][j]) \\n             {\\n                 min=matrix[i][j];\\n                 idx=j;\\n             }"], ["int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    int* returnValue = (int*)malloc(matrixSize * sizeof(int));\\n    int returnValueIndex = 0;\\n\\n    // for each row...\\n    int columnIndex = 0;\\n    int rowIndex = 0;\\n    for (int row = 0; row < matrixSize; row++) {\\n        // find the minimum value on the row and return it\\'s column index...\\n        columnIndex = matrix_minimum_in_row(matrix, row, *matrixColSize);\\n\\n        // find the maximum value on the column and return it\\'s row index...\\n        rowIndex = matrix_maximum_in_column(matrix, matrixSize, columnIndex);\\n\\n        // ...remember the solutions\\n        if (row == rowIndex) {\\n            returnValue[returnValueIndex] = matrix[rowIndex][columnIndex];\\n            returnValueIndex++;\\n        }"]]}
{"id": "2181", "ref_c": [["int maxConsecutive(int bottom, int top, int* special, int specialSize){\\n    qsort(special,specialSize,sizeof(int),cmp);\\n    int ans=fmax(fmax(special[0],bottom)-bottom,fmax(special[specialSize-1],top)-special[specialSize-1]);\\n    for(int i=1;i<specialSize;i++){\\n        ans=fmax(special[i]-special[i-1]-1,ans);\\n    }"], ["int maxConsecutive(int bottom, int top, int* special, int specialSize) {\\n    qsort(special, specialSize, sizeof(int), cmp);\\n    int len = fmax(special[0] - bottom, top - special[specialSize - 1]);\\n    for (int i = 1; i < specialSize; i++) {\\n        if (special[i] - special[i - 1] > 1) len = fmax(special[i] - special[i - 1] - 1, len);\\n    }"], ["int maxConsecutive(int bottom, int top, int* special, int specialSize) {\\n    qsort(special, specialSize, sizeof(int), cmp);\\n    int len = fmax(special[0] - bottom, top - special[specialSize - 1]);\\n    for (int i = 1; i < specialSize; i++) {\\n        if (special[i] - special[i - 1] > 1) len = fmax(special[i] - special[i - 1] - 1, len);\\n    }"]]}
{"id": "2182", "ref_c": [["int minOperations(int* nums, int numsSize, int* numsDivide, int numsDivideSize){\\n    int g = numsDivide[0];\\n    for (int i=0;i<numsDivideSize;i++) {\\n        g = gcd(numsDivide[i],g);\\n    }"], ["int minOperations(int* nums, int numsSize, int* numsDivide, int numsDivideSize){\\n    int g = numsDivide[0];\\n    for (int i=0;i<numsDivideSize;i++) {\\n        g = gcd(numsDivide[i],g);\\n    }"], ["int minOperations(int* nums, int numsSize, int* numsDivide, int numsDivideSize){\\n    int g = numsDivide[0];\\n    for (int i=0;i<numsDivideSize;i++) {\\n        g = gcd(numsDivide[i],g);\\n    }"]]}
{"id": "2183", "ref_c": [["char * decodeString(char * s){\\n    char *save_str= malloc(sizeof(char)*5000);\\n    //char results[5000];\\n    //save_str = results;\\n    char *write_str= malloc(sizeof(char)*1000);\\n    int indexOfsavestr=-1,indexOfwritestr=-1;\\n    int indexOfSearch,indexOfTimes,times;\\n    int i,j,k; // for for loop\\n    for(i=0;i<strlen(s);i++){\\n        if(s[i] == \\']\\'){\\n            //find the stack index for words(\\u5148\\u78BA\\u5B9A\\u8981\\u8F38\\u51FA\\u7684\\u5B57\\u4E32index)\\n            indexOfSearch=indexOfsavestr;\\n            while(save_str[indexOfSearch] != \\'[\\'){indexOfSearch--;}"], ["char * decodeString(char * s){\\n    char *save_str= malloc(sizeof(char)*5000);\\n    //char results[5000];\\n    //save_str = results;\\n    char *write_str= malloc(sizeof(char)*1000);\\n    int indexOfsavestr=-1,indexOfwritestr=-1;\\n    int indexOfSearch,indexOfTimes,times;\\n    int i,j,k; // for for loop\\n    for(i=0;i<strlen(s);i++){\\n        if(s[i] == \\']\\'){\\n            //find the stack index for words(\\u5148\\u78BA\\u5B9A\\u8981\\u8F38\\u51FA\\u7684\\u5B57\\u4E32index)\\n            indexOfSearch=indexOfsavestr;\\n            while(save_str[indexOfSearch] != \\'[\\'){indexOfSearch--;}"], ["char * decodeString(char * s){\\n    char *save_str= malloc(sizeof(char)*5000);\\n    //char results[5000];\\n    //save_str = results;\\n    char *write_str= malloc(sizeof(char)*1000);\\n    int indexOfsavestr=-1,indexOfwritestr=-1;\\n    int indexOfSearch,indexOfTimes,times;\\n    int i,j,k; // for for loop\\n    for(i=0;i<strlen(s);i++){\\n        if(s[i] == \\']\\'){\\n            //find the stack index for words(\\u5148\\u78BA\\u5B9A\\u8981\\u8F38\\u51FA\\u7684\\u5B57\\u4E32index)\\n            indexOfSearch=indexOfsavestr;\\n            while(save_str[indexOfSearch] != \\'[\\'){indexOfSearch--;}"]]}
{"id": "2184", "ref_c": [["int longestCommonSubsequence(char * text1, char * text2){\\n  int m;\\n  int n;\\n  m=strlen(text1);\\n  n=strlen(text2);\\n  int a[m+1][n+1];\\n  int i,j;\\n  for(i=0;i<m+1;i++){\\n      a[i][0]=0;\\n  }"], ["int longestCommonSubsequence(char * text1, char * text2){\\n  int m;\\n  int n;\\n  m=strlen(text1);\\n  n=strlen(text2);\\n  int a[m+1][n+1];\\n  int i,j;\\n  for(i=0;i<m+1;i++){\\n      a[i][0]=0;\\n  }"], ["int longestCommonSubsequence(char * text1, char * text2){\\n  int m;\\n  int n;\\n  m=strlen(text1);\\n  n=strlen(text2);\\n  int a[m+1][n+1];\\n  int i,j;\\n  for(i=0;i<m+1;i++){\\n      a[i][0]=0;\\n  }"]]}
{"id": "2185", "ref_c": [["int longestCycle(int* edges, int edgesSize){\\n    int* used = calloc(edgesSize,sizeof(int));\\n    int max = -1;\\n    int start = 1;\\n    int count = 1;\\n    for (int i = 0 ; i < edgesSize ; i++){\\n        if (used[i] == 0){\\n            used[i] = count;\\n            start = count;\\n            count++;\\n            check(edges, used, start, &count, edges[i], &max);\\n        }"], ["int longestCycle(int* edges, int edgesSize){\\n    int* used = calloc(edgesSize,sizeof(int));\\n    int max = -1;\\n    int start = 1;\\n    int count = 1;\\n    for (int i = 0 ; i < edgesSize ; i++){\\n        if (used[i] == 0){\\n            used[i] = count;\\n            start = count;\\n            count++;\\n            check(edges, used, start, &count, edges[i], &max);\\n        }"], ["int longestCycle(int* edges, int edgesSize){\\n    int* used = calloc(edgesSize,sizeof(int));\\n    int max = -1;\\n    int start = 1;\\n    int count = 1;\\n    for (int i = 0 ; i < edgesSize ; i++){\\n        if (used[i] == 0){\\n            used[i] = count;\\n            start = count;\\n            count++;\\n            check(edges, used, start, &count, edges[i], &max);\\n        }"]]}
{"id": "2186", "ref_c": [["long long minimumReplacement(int* nums, int numsSize){\\n    int div, i, num;\\n    long long res = 0;\\n\\n    num = nums[numsSize - 1];\\n    for (int i = numsSize - 2; i >= 0; i--)\\n    {\\n        if (nums[i] > num)\\n        {\\n            div = nums[i] / num;\\n            if (nums[i] % num > 0)\\n                div++;\\n            res += div - 1;\\n            num = nums[i] / div;\\n        }"], ["long long minimumReplacement(int* nums, int numsSize)\\n{\\n    long long answer=0;\\n        \\n        int max=nums[numsSize-1];\\n        int divisor; \\n\\n        for(int i=numsSize-2; i>=0; i--)\\n        {\\n            if(nums[i]>max)\\n            {\\n                if(nums[i]%max==0)\\n                {\\n                    answer+=(nums[i]/max)-1;\\n                }"], ["long long minimumReplacement(int* nums, int numsSize)\\n{\\n    long long answer=0;\\n        \\n        int max=nums[numsSize-1];\\n        int divisor; \\n\\n        for(int i=numsSize-2; i>=0; i--)\\n        {\\n            if(nums[i]>max)\\n            {\\n                if(nums[i]%max==0)\\n                {\\n                    answer+=(nums[i]/max)-1;\\n                }"]]}
{"id": "2187", "ref_c": [["int countSpecialNumbers(int n){\\n    if (n <= 10){\\n        return n;\\n    }"], ["int countSpecialNumbers(int n){\\n    if (n <= 10){\\n        return n;\\n    }"], ["int countSpecialNumbers(int n){\\n    if (n <= 10){\\n        return n;\\n    }"]]}
{"id": "2188", "ref_c": [["struct TreeNode* bstToGst(struct TreeNode* root) {\\n\\n    int* sum=(int*)malloc(sizeof(int));\\n    *sum=0;\\n    root=inorder(root,sum);\\n    return root;\\n    \\n}"], ["struct TreeNode* bstToGst(struct TreeNode* root) {\\n    // Reversed inorder traversal\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(log(n))\\n\\n    int prefix = 0;\\n    helper(root, &prefix);\\n    return root;\\n}"], ["struct TreeNode* bstToGst(struct TreeNode* root){\\n    int index = 0 ;\\n    int nums[100]={-1}"]]}
{"id": "2189", "ref_c": ["\nint find(int* uf, int i){\n    while(uf[i] != i){\n        i = uf[i];\n    }\n    return i;\n}\n\nvoid merge(int* uf, int i, int j){\n    uf[find(uf, j)] = find(uf, i);\n}\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    int n = strlen(s);\n    int* uf = calloc(n+1, sizeof(int));\n    for(int i = 0; i < n+1; i++){\n        uf[i] = i;\n    }\n\n    for(int i = 0; i < wordDictSize; i++){\n        int m = strlen(wordDict[i]);\n        for(int j = 0; j <= n - m; j++){\n            if(!strncmp(wordDict[i], s+j, m)) {\n                merge(uf, j, j + m);\n            }\n        }\n    }\n\n    bool ret = find(uf, n) == find(uf, 0);\n    free(uf);\n    return ret;\n}\n", "\nint find(int* uf, int i){\n    while(uf[i] != i){\n        i = uf[i];\n    }\n    return i;\n}\n\nvoid merge(int* uf, int i, int j){\n    uf[find(uf, j)] = find(uf, i);\n}\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    int n = strlen(s);\n    int* uf = calloc(n+1, sizeof(int));\n    for(int i = 0; i < n+1; i++){\n        uf[i] = i;\n    }\n\n    for(int i = 0; i < wordDictSize; i++){\n        int m = strlen(wordDict[i]);\n        for(int j = 0; j <= n - m; j++){\n            if(!strncmp(wordDict[i], s+j, m)) {\n                merge(uf, j, j + m);\n            }\n        }\n    }\n\n    bool ret = find(uf, n) == find(uf, 0);\n    free(uf);\n    return ret;\n}\n", "\nint find(int* uf, int i){\n    while(uf[i] != i){\n        i = uf[i];\n    }\n    return i;\n}\n\nvoid merge(int* uf, int i, int j){\n    uf[find(uf, j)] = find(uf, i);\n}\n\nbool wordBreak(char* s, char** wordDict, int wordDictSize) {\n    int n = strlen(s);\n    int* uf = calloc(n+1, sizeof(int));\n    for(int i = 0; i < n+1; i++){\n        uf[i] = i;\n    }\n\n    for(int i = 0; i < wordDictSize; i++){\n        int m = strlen(wordDict[i]);\n        for(int j = 0; j <= n - m; j++){\n            if(!strncmp(wordDict[i], s+j, m)) {\n                merge(uf, j, j + m);\n            }\n        }\n    }\n\n    bool ret = find(uf, n) == find(uf, 0);\n    free(uf);\n    return ret;\n}\n"]}
{"id": "2190", "ref_c": [["int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = imageSize;\\n    *returnColumnSizes = imageColSize;\\n    for(int i=0; i<imageSize; i++){\\n        for(int j=0; j<*imageColSize/2; j++){\\n            int temp = image[i][j];\\n            image[i][j] = image[i][*imageColSize-j-1];\\n            image[i][*imageColSize-j-1] = temp;\\n        }"], ["int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes) {\\n\\n  int **ret = (int **)malloc(sizeof(int *) * imageSize);\\n\\n  for (int i = 0; i < imageSize; i++) {\\n    ret[i] = (int *)malloc(sizeof(int)*imageSize);\\n  }"], ["int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = imageSize;\\n    *returnColumnSizes = imageColSize;\\n    int temp =0,i,j;\\n\\n    for( i = 0; i < imageSize; i++)\\n    {\\n        for(j = 0; j < *imageColSize / 2; j ++){\\n            temp = image[i][j];\\n            image[i][j] = image[i][*imageColSize - 1 - j];\\n            image[i][*imageColSize - 1 - j] = temp;\\n        }"]]}
{"id": "2191", "ref_c": ["\nint maximumRobots(int* chargeTimes, int chargeTimesSize, int* runningCosts, int runningCostsSize,\n                  long long budget){\n  int lut_array[50001];\n  int idx_head = 0;\n  int idx_tail = 0;\n  int ret_len = 0;\n  int curr_len = 0;\n  long long curr_cost = 0;\n  \n  for (int loop_idx=0; loop_idx<chargeTimesSize; loop_idx++) {\n    long long curr_sum;\n    curr_cost += runningCosts[loop_idx];\n    \n    while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\n      idx_head++;\n    }\n    \n    while (idx_head < idx_tail && chargeTimes[lut_array[idx_tail-1]] < chargeTimes[loop_idx]) {\n      idx_tail--;\n    }\n    \n    lut_array[idx_tail++] = loop_idx;\n    \n    curr_sum = chargeTimes[lut_array[idx_head]];\n    curr_sum += (long long) ((++curr_len) * curr_cost);\n    \n    while (curr_len > 0 && curr_sum > budget) {\n      curr_cost -= runningCosts[loop_idx - (--curr_len)];\n      \n      while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\n        idx_head++;\n      }\n      \n      curr_sum = chargeTimes[lut_array[idx_head]];\n      curr_sum += (long long) (curr_len * curr_cost);\n    }\n    \n    if (ret_len < curr_len) {\n      ret_len = curr_len;\n    }\n  }\n  \n  return ret_len;\n}\n", "\nint maximumRobots(int* chargeTimes, int chargeTimesSize, int* runningCosts, int runningCostsSize,\n                  long long budget){\n  int lut_array[50001];\n  int idx_head = 0;\n  int idx_tail = 0;\n  int ret_len = 0;\n  int curr_len = 0;\n  long long curr_cost = 0;\n  \n  for (int loop_idx=0; loop_idx<chargeTimesSize; loop_idx++) {\n    long long curr_sum;\n    curr_cost += runningCosts[loop_idx];\n    \n    while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\n      idx_head++;\n    }\n    \n    while (idx_head < idx_tail && chargeTimes[lut_array[idx_tail-1]] < chargeTimes[loop_idx]) {\n      idx_tail--;\n    }\n    \n    lut_array[idx_tail++] = loop_idx;\n    \n    curr_sum = chargeTimes[lut_array[idx_head]];\n    curr_sum += (long long) ((++curr_len) * curr_cost);\n    \n    while (curr_len > 0 && curr_sum > budget) {\n      curr_cost -= runningCosts[loop_idx - (--curr_len)];\n      \n      while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\n        idx_head++;\n      }\n      \n      curr_sum = chargeTimes[lut_array[idx_head]];\n      curr_sum += (long long) (curr_len * curr_cost);\n    }\n    \n    if (ret_len < curr_len) {\n      ret_len = curr_len;\n    }\n  }\n  \n  return ret_len;\n}\n", "\nint maximumRobots(int* chargeTimes, int chargeTimesSize, int* runningCosts, int runningCostsSize,\n                  long long budget){\n  int lut_array[50001];\n  int idx_head = 0;\n  int idx_tail = 0;\n  int ret_len = 0;\n  int curr_len = 0;\n  long long curr_cost = 0;\n  \n  for (int loop_idx=0; loop_idx<chargeTimesSize; loop_idx++) {\n    long long curr_sum;\n    curr_cost += runningCosts[loop_idx];\n    \n    while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\n      idx_head++;\n    }\n    \n    while (idx_head < idx_tail && chargeTimes[lut_array[idx_tail-1]] < chargeTimes[loop_idx]) {\n      idx_tail--;\n    }\n    \n    lut_array[idx_tail++] = loop_idx;\n    \n    curr_sum = chargeTimes[lut_array[idx_head]];\n    curr_sum += (long long) ((++curr_len) * curr_cost);\n    \n    while (curr_len > 0 && curr_sum > budget) {\n      curr_cost -= runningCosts[loop_idx - (--curr_len)];\n      \n      while (idx_head < idx_tail && lut_array[idx_head] < (loop_idx-curr_len)) {\n        idx_head++;\n      }\n      \n      curr_sum = chargeTimes[lut_array[idx_head]];\n      curr_sum += (long long) (curr_len * curr_cost);\n    }\n    \n    if (ret_len < curr_len) {\n      ret_len = curr_len;\n    }\n  }\n  \n  return ret_len;\n}\n"]}
{"id": "2192", "ref_c": [["int mostBooked(int n, int** meetings, int meetingsSize, int* meetingsColSize){\\n    qsort(meetings,meetingsSize,sizeof(int*),comp);\\n    const number = n;\\n    long long used_time[number];\\n    int used_count[number];\\n    int meet_point = 0;\\n    for (int i = 0 ; i < n ; i++){\\n        used_time[i] = 0;\\n        used_count[i] = 0;\\n    }"], ["int mostBooked(int n, int** meetings, int meetingsSize, int* meetingsColSize){\\n    long long **room = malloc(n*sizeof(long long*));\\n    for(int i=0;i<n;i++){\\n        room[i] = malloc(4*sizeof(long long));\\n        room[i][0] = i;\\n        room[i][1] = i;\\n        room[i][2] = -1;\\n        room[i][3] = 0;\\n    }"], ["int mostBooked(int n, int** meetings, int meetingsSize, int* meetingsColSize){\\n    qsort(meetings,meetingsSize,sizeof(int*),comp);\\n    const number = n;\\n    long long used_time[number];\\n    int used_count[number];\\n    int meet_point = 0;\\n    for (int i = 0 ; i < n ; i++){\\n        used_time[i] = 0;\\n        used_count[i] = 0;\\n    }"]]}
{"id": "2193", "ref_c": [["int lengthOfLIS(int* nums, int numsSize, int k){\\n    struct segment *obj=malloc(sizeof(struct segment));\\n    int maximun=nums[0];\\n    for(int i=1;i<numsSize;i++){\\n        maximun=fmax(maximun,nums[i]);\\n    }"], ["int lengthOfLIS(int* nums, int numsSize, int k){\\n    struct segment *obj=malloc(sizeof(struct segment));\\n    int maximun=nums[0];\\n    for(int i=1;i<numsSize;i++){\\n        maximun=fmax(maximun,nums[i]);\\n    }"], ["int lengthOfLIS(int* nums, int numsSize, int k){\\n    struct segment *obj=malloc(sizeof(struct segment));\\n    int maximun=nums[0];\\n    for(int i=1;i<numsSize;i++){\\n        maximun=fmax(maximun,nums[i]);\\n    }"]]}
{"id": "2194", "ref_c": [["long long minimumMoney(int** transactions, int transactionsSize, int* transactionsColSize){\\n    long long ans = 0;\\n    int mostback = 0;\\n    int makemoney = -1;\\n    for (int i = 0 ; i < transactionsSize ; i++){\\n        if (transactions[i][0] > transactions[i][1]){\\n            ans += transactions[i][0]-transactions[i][1];\\n            if (mostback < transactions[i][1]){\\n                mostback = transactions[i][1];\\n            }"], ["long long minimumMoney(int** transactions, int transactionsSize, int* transactionsColSize){\\n    long long ans = 0;\\n    int mostback = 0;\\n    int makemoney = -1;\\n    for (int i = 0 ; i < transactionsSize ; i++){\\n        if (transactions[i][0] > transactions[i][1]){\\n            ans += transactions[i][0]-transactions[i][1];\\n            if (mostback < transactions[i][1]){\\n                mostback = transactions[i][1];\\n            }"], ["long long minimumMoney(int** transactions, int transactionsSize, int* transactionsColSize){\\n    long long ans = 0;\\n    int mostback = 0;\\n    int makemoney = -1;\\n    for (int i = 0 ; i < transactionsSize ; i++){\\n        if (transactions[i][0] > transactions[i][1]){\\n            ans += transactions[i][0]-transactions[i][1];\\n            if (mostback < transactions[i][1]){\\n                mostback = transactions[i][1];\\n            }"]]}
{"id": "2195", "ref_c": [["int* sumPrefixScores(char ** words, int wordsSize, int* returnSize){\\n    Node* root = NULL;\\n    Node* curr = NULL;\\n    char* word = NULL;\\n    int* ret = NULL;\\n    int subAns = 0;\\n    int idx = 0;\\n    int wordSize = 0;\\n    \\n    *returnSize = wordsSize;\\n    ret = (int*) malloc(sizeof(int) * wordsSize);\\n    if (ret == NULL) {\\n        goto END;\\n    }"], ["int* sumPrefixScores(char ** words, int wordsSize, int* returnSize){\\n    Node* root = NULL;\\n    Node* curr = NULL;\\n    char* word = NULL;\\n    int* ret = NULL;\\n    int subAns = 0;\\n    int idx = 0;\\n    int wordSize = 0;\\n    \\n    *returnSize = wordsSize;\\n    ret = (int*) malloc(sizeof(int) * wordsSize);\\n    if (ret == NULL) {\\n        goto END;\\n    }"], ["int* sumPrefixScores(char ** words, int wordsSize, int* returnSize){\\n    Node* root = NULL;\\n    Node* curr = NULL;\\n    char* word = NULL;\\n    int* ret = NULL;\\n    int subAns = 0;\\n    int idx = 0;\\n    int wordSize = 0;\\n    \\n    *returnSize = wordsSize;\\n    ret = (int*) malloc(sizeof(int) * wordsSize);\\n    if (ret == NULL) {\\n        goto END;\\n    }"]]}
{"id": "2196", "ref_c": [["int numberOfGoodPaths(int* vals, int valsSize, int** edges, int edgesSize, int* edgesColSize) {\\n\\t/* Allocate a single buffer to hold everything */\\n\\tconst size_t required_mem = \\n\\t\\t\\tedgesSize * sizeof(*edges) +\\n\\t\\t\\tvalsSize * sizeof(struct Node);\\n\\tchar* const buf = malloc(required_mem);\\n\\tchar* pos = buf;\\n\\tint** sorted_edges = (int**) pos;\\n\\tpos += edgesSize * sizeof(*edges);\\n\\tstruct Node* nodes = (struct Node*) pos;\\n\\n\\tmemcpy(sorted_edges, edges, edgesSize * sizeof(*edges));\\n\\tsort_edges_by_max_val(sorted_edges, sorted_edges + edgesSize, vals);\\n\\n\\t/* Initialise each node as a tree of just itself */\\n\\tfor (int i = 0; i < valsSize; ++i) {\\n\\t\\tnodes[i].parent = i;\\n\\t\\tnodes[i].max_val = vals[i];\\n\\t\\tnodes[i].count = 1;\\n\\t\\tnodes[i].rank = 0;\\n\\t}"], ["int numberOfGoodPaths(int* vals, int valsSize, int** edges, int edgesSize, int* edgesColSize) {\\n\\t/* Allocate a single buffer to hold everything */\\n\\tconst size_t required_mem = \\n\\t\\t\\tedgesSize * sizeof(*edges) +\\n\\t\\t\\tvalsSize * sizeof(struct Node);\\n\\tchar* const buf = malloc(required_mem);\\n\\tchar* pos = buf;\\n\\tint** sorted_edges = (int**) pos;\\n\\tpos += edgesSize * sizeof(*edges);\\n\\tstruct Node* nodes = (struct Node*) pos;\\n\\n\\tmemcpy(sorted_edges, edges, edgesSize * sizeof(*edges));\\n\\tsort_edges_by_max_val(sorted_edges, sorted_edges + edgesSize, vals);\\n\\n\\t/* Initialise each node as a tree of just itself */\\n\\tfor (int i = 0; i < valsSize; ++i) {\\n\\t\\tnodes[i].parent = i;\\n\\t\\tnodes[i].max_val = vals[i];\\n\\t\\tnodes[i].count = 1;\\n\\t\\tnodes[i].rank = 0;\\n\\t}"], ["int numberOfGoodPaths(int* vals, int valsSize, int** edges, int edgesSize, int* edgesColSize) {\\n\\t/* Allocate a single buffer to hold everything */\\n\\tconst size_t required_mem = \\n\\t\\t\\tedgesSize * sizeof(*edges) +\\n\\t\\t\\tvalsSize * sizeof(struct Node);\\n\\tchar* const buf = malloc(required_mem);\\n\\tchar* pos = buf;\\n\\tint** sorted_edges = (int**) pos;\\n\\tpos += edgesSize * sizeof(*edges);\\n\\tstruct Node* nodes = (struct Node*) pos;\\n\\n\\tmemcpy(sorted_edges, edges, edgesSize * sizeof(*edges));\\n\\tsort_edges_by_max_val(sorted_edges, sorted_edges + edgesSize, vals);\\n\\n\\t/* Initialise each node as a tree of just itself */\\n\\tfor (int i = 0; i < valsSize; ++i) {\\n\\t\\tnodes[i].parent = i;\\n\\t\\tnodes[i].max_val = vals[i];\\n\\t\\tnodes[i].count = 1;\\n\\t\\tnodes[i].rank = 0;\\n\\t}"]]}
{"id": "2197", "ref_c": ["\nchar * modifyString(char * s){\n    for(int i=0;s[i]!='\u0000';i++)\n        if(s[i] == '?') \n            for(s[i]='a'; (i>0 && s[i]==s[i-1]) || (s[i+1]!='\u0000' && s[i]==s[i+1]); s[i]++);      \n    return s;\n}\n", "\nchar * modifyString(char * s){\n    for(int i=0;s[i]!='\u0000';i++)\n        if(s[i] == '?') \n            for(s[i]='a'; (i>0 && s[i]==s[i-1]) || (s[i+1]!='\u0000' && s[i]==s[i+1]); s[i]++);      \n    return s;\n}\n", "\nchar * modifyString(char * s){\n    for(int i=0;s[i]!='\u0000';i++)\n        if(s[i] == '?') \n            for(s[i]='a'; (i>0 && s[i]==s[i-1]) || (s[i+1]!='\u0000' && s[i]==s[i+1]); s[i]++);      \n    return s;\n}\n"]}
{"id": "2198", "ref_c": [["int numberOfArithmeticSlices(int* nums, int numsSize){\\n    if (numsSize <= 2)\\n        return 0;\\n    int lastIndex = 0;\\n    int d = *(nums +1) -*nums;\\n    int answer = 0;\\n    for (int i = 2; i < numsSize; i++) {\\n        if (*(nums +i) -*(nums +i -1) == d) {\\n            int a = i -lastIndex -1;\\n            answer += (a > 0) ? a : 1;\\n        }"], ["int numberOfArithmeticSlices(int* nums, int numsSize){\\n    if (numsSize <= 2)\\n        return 0;\\n    int lastIndex = 0;\\n    int d = *(nums +1) -*nums;\\n    int answer = 0;\\n    for (int i = 2; i < numsSize; i++) {\\n        if (*(nums +i) -*(nums +i -1) == d) {\\n            int a = i -lastIndex -1;\\n            answer += (a > 0) ? a : 1;\\n        }"], ["int numberOfArithmeticSlices(int* nums, int numsSize){\\n    if (numsSize <= 2)\\n        return 0;\\n    int lastIndex = 0;\\n    int d = *(nums +1) -*nums;\\n    int answer = 0;\\n    for (int i = 2; i < numsSize; i++) {\\n        if (*(nums +i) -*(nums +i -1) == d) {\\n            int a = i -lastIndex -1;\\n            answer += (a > 0) ? a : 1;\\n        }"]]}
{"id": "2199", "ref_c": ["\nchar ** printVertically(char * s, int* returnSize){\n\n    // Get the max num of words and max lenght of word\n    int max_word_len = 0; //  = num(spaces) + 1\n    int max_num_words = 0;\n    int num_words = 0;\n\n    for (int i=0;i<=strlen(s); i++)\n    {\n        if (s[i] == ' ' || s[i] == '\u0000')\n        {\n            if (s[i] == ' ')\n            {\n                max_word_len += 1;\n            }\n            max_num_words = num_words > max_num_words ? num_words : max_num_words;\n            num_words = 0;\n        }\n        else\n        {\n            num_words++;\n        }\n    }\n\n    max_word_len += 1;  // not including space for '\u0000'\n    //-----------------------------------------------------\n\n    //Allocate space for return variable ans\n    char** ans = (char**)malloc(sizeof(char*)*max_num_words);\n\n    for (int i=0; i<max_num_words; i++)\n    {\n        ans[i] = (char*)malloc(sizeof(char)*(max_word_len+1));\n    }\n    //-----------------------------------------------------\n\n    // Get vertical words\n    int letter_index = 0;\n    int word_index = 0;\n    int s_index = 0;\n\n    while (true)        // It loops over s sequentially and fills the ans array\n    {\n        if (s[s_index] == '\u0000') \n        {\n            letter_index += 1;\n            \n            for (int i=0; i<max_num_words; i++)\n            {\n                ans[i][letter_index] = '\u0000';\n            }\n            break;\n        } \n        \n        else if ((s[s_index] == ' ') && (word_index == max_num_words))\n        {\n            word_index = 0; // Reset word_index\n            letter_index += 1; // Increment to next position\n        } \n        else if ((s[s_index] == ' ') && (word_index < max_num_words))\n        {\n            ans[word_index][letter_index] = ' ';\n            word_index++;\n            s_index -=1; // To prevent inc under this condition\n        } \n        else\n        {\n            ans[word_index][letter_index] = s[s_index];\n            word_index++;\n        }\n        s_index++;\n    }\n    //-----------------------------------------------------\n\n    // Remove trailing spaces\n    for (int i=0; i<max_num_words; i++)\n    {\n        int l = strlen(ans[i]);\n\n        while (!(isalpha(ans[i][l-1])))\n        {\n            ans[i][l-1] = '\u0000';\n            l--;\n        }\n    }\n    //-----------------------------------------------------\n\n    *returnSize = max_num_words;\n    return ans;\n}\n", "\nchar ** printVertically(char * s, int* returnSize){\n\n    // Get the max num of words and max lenght of word\n    int max_word_len = 0; //  = num(spaces) + 1\n    int max_num_words = 0;\n    int num_words = 0;\n\n    for (int i=0;i<=strlen(s); i++)\n    {\n        if (s[i] == ' ' || s[i] == '\u0000')\n        {\n            if (s[i] == ' ')\n            {\n                max_word_len += 1;\n            }\n            max_num_words = num_words > max_num_words ? num_words : max_num_words;\n            num_words = 0;\n        }\n        else\n        {\n            num_words++;\n        }\n    }\n\n    max_word_len += 1;  // not including space for '\u0000'\n    //-----------------------------------------------------\n\n    //Allocate space for return variable ans\n    char** ans = (char**)malloc(sizeof(char*)*max_num_words);\n\n    for (int i=0; i<max_num_words; i++)\n    {\n        ans[i] = (char*)malloc(sizeof(char)*(max_word_len+1));\n    }\n    //-----------------------------------------------------\n\n    // Get vertical words\n    int letter_index = 0;\n    int word_index = 0;\n    int s_index = 0;\n\n    while (true)        // It loops over s sequentially and fills the ans array\n    {\n        if (s[s_index] == '\u0000') \n        {\n            letter_index += 1;\n            \n            for (int i=0; i<max_num_words; i++)\n            {\n                ans[i][letter_index] = '\u0000';\n            }\n            break;\n        } \n        \n        else if ((s[s_index] == ' ') && (word_index == max_num_words))\n        {\n            word_index = 0; // Reset word_index\n            letter_index += 1; // Increment to next position\n        } \n        else if ((s[s_index] == ' ') && (word_index < max_num_words))\n        {\n            ans[word_index][letter_index] = ' ';\n            word_index++;\n            s_index -=1; // To prevent inc under this condition\n        } \n        else\n        {\n            ans[word_index][letter_index] = s[s_index];\n            word_index++;\n        }\n        s_index++;\n    }\n    //-----------------------------------------------------\n\n    // Remove trailing spaces\n    for (int i=0; i<max_num_words; i++)\n    {\n        int l = strlen(ans[i]);\n\n        while (!(isalpha(ans[i][l-1])))\n        {\n            ans[i][l-1] = '\u0000';\n            l--;\n        }\n    }\n    //-----------------------------------------------------\n\n    *returnSize = max_num_words;\n    return ans;\n}\n", "\nchar ** printVertically(char * s, int* returnSize){\n\n    // Get the max num of words and max lenght of word\n    int max_word_len = 0; //  = num(spaces) + 1\n    int max_num_words = 0;\n    int num_words = 0;\n\n    for (int i=0;i<=strlen(s); i++)\n    {\n        if (s[i] == ' ' || s[i] == '\u0000')\n        {\n            if (s[i] == ' ')\n            {\n                max_word_len += 1;\n            }\n            max_num_words = num_words > max_num_words ? num_words : max_num_words;\n            num_words = 0;\n        }\n        else\n        {\n            num_words++;\n        }\n    }\n\n    max_word_len += 1;  // not including space for '\u0000'\n    //-----------------------------------------------------\n\n    //Allocate space for return variable ans\n    char** ans = (char**)malloc(sizeof(char*)*max_num_words);\n\n    for (int i=0; i<max_num_words; i++)\n    {\n        ans[i] = (char*)malloc(sizeof(char)*(max_word_len+1));\n    }\n    //-----------------------------------------------------\n\n    // Get vertical words\n    int letter_index = 0;\n    int word_index = 0;\n    int s_index = 0;\n\n    while (true)        // It loops over s sequentially and fills the ans array\n    {\n        if (s[s_index] == '\u0000') \n        {\n            letter_index += 1;\n            \n            for (int i=0; i<max_num_words; i++)\n            {\n                ans[i][letter_index] = '\u0000';\n            }\n            break;\n        } \n        \n        else if ((s[s_index] == ' ') && (word_index == max_num_words))\n        {\n            word_index = 0; // Reset word_index\n            letter_index += 1; // Increment to next position\n        } \n        else if ((s[s_index] == ' ') && (word_index < max_num_words))\n        {\n            ans[word_index][letter_index] = ' ';\n            word_index++;\n            s_index -=1; // To prevent inc under this condition\n        } \n        else\n        {\n            ans[word_index][letter_index] = s[s_index];\n            word_index++;\n        }\n        s_index++;\n    }\n    //-----------------------------------------------------\n\n    // Remove trailing spaces\n    for (int i=0; i<max_num_words; i++)\n    {\n        int l = strlen(ans[i]);\n\n        while (!(isalpha(ans[i][l-1])))\n        {\n            ans[i][l-1] = '\u0000';\n            l--;\n        }\n    }\n    //-----------------------------------------------------\n\n    *returnSize = max_num_words;\n    return ans;\n}\n"]}
{"id": "2200", "ref_c": [["int distributeCoins(struct TreeNode* root) {\\n    // DFS method\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    int result = 0;\\n    helper(root, &result);\\n    return result;\\n}"], ["int distributeCoins(struct TreeNode* root){\\n    struct Stack* stack = createStack();\\n    struct TreeNode* current = root;\\n    bool is_root = false;\\n\\n    int num_moves = 0;\\n\\n    while(current){\\n\\n        struct TreeNode* left = current->left;\\n        struct TreeNode* right = current->right;\\n\\n        if(is_root) left = right = NULL;\\n\\n        if(left){\\n            addToStack(stack, current);\\n            current = left;\\n        }"], ["int distributeCoins(struct TreeNode* root)\\n{\\n    int count = 0;\\n    traversal(root, &count);\\n    return count;\\n}"]]}
{"id": "2201", "ref_c": [["long long countSubarrays(int* nums, int numsSize, int minK, int maxK) {\\n\\tlong long ret = 0;\\n\\tint barrier_idx = -1;\\n\\tint min_idx = -1;\\n\\tint max_idx = -1;\\n\\tint idx = -1;\\n\\n\\tfor (int i = 0; i < numsSize; ++i) {\\n\\t\\t/* If a value is outside our valid range, it\\'s a barrier that no subarray can cross */\\n\\t\\tif (minK > nums[i] || nums[i] > maxK) {\\n\\t\\t\\tbarrier_idx = i;\\n\\t\\t\\tcontinue;\\n\\t\\t}"], ["long long countSubarrays(int* nums, int numsSize, int minK, int maxK) {\\n\\tlong long ret = 0;\\n\\tint barrier_idx = -1;\\n\\tint min_idx = -1;\\n\\tint max_idx = -1;\\n\\tint idx = -1;\\n\\n\\tfor (int i = 0; i < numsSize; ++i) {\\n\\t\\t/* If a value is outside our valid range, it\\'s a barrier that no subarray can cross */\\n\\t\\tif (minK > nums[i] || nums[i] > maxK) {\\n\\t\\t\\tbarrier_idx = i;\\n\\t\\t\\tcontinue;\\n\\t\\t}"], ["long long countSubarrays(int* nums, int numsSize, int minK, int maxK){\\n\\n    long long ans = 0;\\n    int lastminK = -1, lastmaxK = -1;\\n    int start = 0;\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] > maxK || nums[i] < minK)\\n            start = i + 1;\\n        if(nums[i] == maxK)\\n            lastmaxK = i;\\n        if(nums[i] == minK)\\n            lastminK = i;\\n\\n        int pos = fmin(lastmaxK, lastminK);\\n        if(start > pos)\\n            continue;\\n        ans += pos - start + 1 ;\\n    }"]]}
{"id": "2202", "ref_c": [["long long minCost(int* nums, int numsSize, int* cost, int costSize) {\\n    long long lo = 1, hi=1e6;\\n    while(lo <= hi)\\n    {\\n        int mid = (lo + hi) / 2;\\n        long long sum1 = getSum(nums, numsSize, cost, mid);\\n        if(lo == hi)\\n            return sum1;\\n        long long sum3 = getSum(nums, numsSize, cost, mid + 1);\\n        long long sum2 = getSum(nums, numsSize, cost, mid - 1);\\n          \\n        if(sum2 >= sum1 && sum1 <= sum3)\\n            return sum1; \\n        if(sum2 < sum1)\\n        {\\n            hi = mid;\\n            continue; \\n        }"], ["long long minCost(int* nums, int numsSize, int* cost, int costSize){\\n    int min = nums[0];\\n    int max = nums[0];\\n\\n    //find the min and max value\\n    for(size_t i = 0; i < numsSize; i++){\\n        if(nums[i] < min){\\n            min = nums[i];\\n        }"], ["long long minCost(int* nums, int numsSize, int* cost, int costSize){\\n  if (numsSize == 1) return 0;\\n  long long weight_sum = 0L;\\n  int *arr = malloc(sizeof(int)*numsSize*2);\\n  for (int i = 0; i < numsSize; i++) {\\n    weight_sum += cost[i];\\n    arr[2*i] = nums[i];\\n    arr[2*i + 1] = cost[i];\\n  }"]]}
{"id": "2203", "ref_c": [["int minAreaRect(int** points, int pointsSize, int* pointsColSize){\\n\\n    if(pointsSize<4)\\n    {\\n        return 0;\\n    }"], ["int minAreaRect(int** points, int pointsSize, int* pointsColSize){\\n\\n    if(pointsSize<4)\\n    {\\n        return 0;\\n    }"], ["int minAreaRect(int** points, int pointsSize, int* pointsColSize){\\n\\n    if(pointsSize<4)\\n    {\\n        return 0;\\n    }"]]}
{"id": "2204", "ref_c": [["int* secondGreaterElement(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    struct unfind* root = malloc(sizeof(struct unfind));\\n    struct unfind* zero = malloc(sizeof(struct unfind));\\n    root->place = numsSize-1;   //Imput the place where must be -1  Just for write freelist();\\n    root->next = zero;\\n    \\n    zero->val = nums[0];\\n    zero->place = 0;\\n    zero->first = false;\\n    zero->next = NULL;\\n    \\n    for (int i = 1 ; i < numsSize ; i++){\\n        struct unfind* this = malloc(sizeof(struct unfind));\\n        this->val = nums[i];\\n        this->place = i;\\n        this->first = false;\\n        check(root, root->next, this, ans);\\n    }"], ["int* secondGreaterElement(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    struct unfind* root = malloc(sizeof(struct unfind));\\n    struct unfind* zero = malloc(sizeof(struct unfind));\\n    root->place = numsSize-1;   //Imput the place where must be -1  Just for write freelist();\\n    root->next = zero;\\n    \\n    zero->val = nums[0];\\n    zero->place = 0;\\n    zero->first = false;\\n    zero->next = NULL;\\n    \\n    for (int i = 1 ; i < numsSize ; i++){\\n        struct unfind* this = malloc(sizeof(struct unfind));\\n        this->val = nums[i];\\n        this->place = i;\\n        this->first = false;\\n        check(root, root->next, this, ans);\\n    }"], ["int* secondGreaterElement(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    struct unfind* root = malloc(sizeof(struct unfind));\\n    struct unfind* zero = malloc(sizeof(struct unfind));\\n    root->place = numsSize-1;   //Imput the place where must be -1  Just for write freelist();\\n    root->next = zero;\\n    \\n    zero->val = nums[0];\\n    zero->place = 0;\\n    zero->first = false;\\n    zero->next = NULL;\\n    \\n    for (int i = 1 ; i < numsSize ; i++){\\n        struct unfind* this = malloc(sizeof(struct unfind));\\n        this->val = nums[i];\\n        this->place = i;\\n        this->first = false;\\n        check(root, root->next, this, ans);\\n    }"]]}
{"id": "2205", "ref_c": [["int* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize)\\n{\\n    * returnSize = 0;\\n\\n    int * answer = malloc(sizeof(int) * queriesSize);\\n    int * hlist  = malloc(sizeof(int) * 100001);\\n    int * comp = malloc(sizeof(int) * 100001);\\n\\n    int h = traverse(root, hlist);\\n\\n    compute(root, comp, hlist, NULL, h, NULL, 0);\\n\\n    for (int i = 0; i < queriesSize; i++)\\n    {\\n        (*returnSize) ++;\\n        answer[i] = comp[queries[i]];\\n    }"], ["int* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize)\\n{\\n  int max = 0;\\n  int* depths = (int*)malloc(1000000 * sizeof(int));\\n  int tree_height = cal_and_store(root, depths, &max);\\n  depths = realloc(depths, max * sizeof(int));\\n  int* results = (int*)malloc(max * sizeof(int));\\n  int max1,max2;\\n  max1 = max2 = -1;\\n  Qnode* head = (Qnode*)malloc(sizeof(Qnode));\\n  head->add = root;\\n  head->val = root->val;\\n  head->next = NULL;\\n  Qnode* tail = head;\\n  int level = 1;\\n  int curr_step_reach = 1;\\n  int next_step_reach = 0;\\n  while(head && tail)\\n  {\\n    max1 = max2 = -1;\\n    Qnode* level_start = head;\\n    for(int i = 0; i < curr_step_reach;i++)\\n    {\\n      node* curr_add = head->add;\\n      int curr_val = head->val;\\n      if(depths[curr_val - 1] > max1)\\n      {\\n        max2 = max1;\\n        max1 = depths[curr_val - 1];\\n      }"], ["int* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize)\\n{\\n    * returnSize = 0;\\n\\n    int * answer = malloc(sizeof(int) * queriesSize);\\n    int * hlist  = malloc(sizeof(int) * 100001);\\n    int * comp = malloc(sizeof(int) * 100001);\\n\\n    int h = traverse(root, hlist);\\n\\n    compute(root, comp, hlist, NULL, h, NULL, 0);\\n\\n    for (int i = 0; i < queriesSize; i++)\\n    {\\n        (*returnSize) ++;\\n        answer[i] = comp[queries[i]];\\n    }"]]}
{"id": "2206", "ref_c": [["long long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize){\\n    qsort(robot, robotSize, sizeof(int), comp);\\n    qsort(factory, factorySize, sizeof(int*), comp_f);\\n    struct Robot* list = malloc(sizeof(struct Robot)*robotSize);\\n    struct Factory* F_list = calloc(factorySize, sizeof(struct Factory));\\n    int point = 0;\\n    for (int i = 0 ; i < robotSize ; i++){\\n        while(point < factorySize && factory[point][0] < robot[i]){\\n            point++;\\n        }"], ["long long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize){\\n    qsort(robot, robotSize, sizeof(int), comp);\\n    qsort(factory, factorySize, sizeof(int*), comp_f);\\n    struct Robot* list = malloc(sizeof(struct Robot)*robotSize);\\n    struct Factory* F_list = calloc(factorySize, sizeof(struct Factory));\\n    int point = 0;\\n    for (int i = 0 ; i < robotSize ; i++){\\n        while(point < factorySize && factory[point][0] < robot[i]){\\n            point++;\\n        }"], ["long long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize){\\n    qsort(robot, robotSize, sizeof(int), comp);\\n    qsort(factory, factorySize, sizeof(int*), comp_f);\\n    struct Robot* list = malloc(sizeof(struct Robot)*robotSize);\\n    struct Factory* F_list = calloc(factorySize, sizeof(struct Factory));\\n    int point = 0;\\n    for (int i = 0 ; i < robotSize ; i++){\\n        while(point < factorySize && factory[point][0] < robot[i]){\\n            point++;\\n        }"]]}
{"id": "2207", "ref_c": [["char ** splitMessage(char * message, int limit, int* returnSize){\\nint min=0,mlen = 0, fmlen = 0,tot = 0,len = strlen(message);\\nint i=0,j=0,id=0;\\nchar **ret=NULL;\\n\\n\\n//Checking message could fit in x or xx or xxx or xxxx or xxxxx\\n\\n  if((limit-5)*9 >= len)\\n  {\\n   // min = (limit-5)*9;\\n    mlen = fmlen = limit-5;\\n    tot = len/fmlen + (len%fmlen ?1:0);\\n    \\n  }"], ["char ** splitMessage(char * message, int limit, int* returnSize){\\nint min=0,mlen = 0, fmlen = 0,tot = 0,len = strlen(message);\\nint i=0,j=0,id=0;\\nchar **ret=NULL;\\n\\n\\n//Checking message could fit in x or xx or xxx or xxxx or xxxxx\\n\\n  if((limit-5)*9 >= len)\\n  {\\n   // min = (limit-5)*9;\\n    mlen = fmlen = limit-5;\\n    tot = len/fmlen + (len%fmlen ?1:0);\\n    \\n  }"], ["char ** splitMessage(char * message, int limit, int* returnSize){\\nint min=0,mlen = 0, fmlen = 0,tot = 0,len = strlen(message);\\nint i=0,j=0,id=0;\\nchar **ret=NULL;\\n\\n\\n//Checking message could fit in x or xx or xxx or xxxx or xxxxx\\n\\n  if((limit-5)*9 >= len)\\n  {\\n   // min = (limit-5)*9;\\n    mlen = fmlen = limit-5;\\n    tot = len/fmlen + (len%fmlen ?1:0);\\n    \\n  }"]]}
{"id": "2208", "ref_c": [["bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\\n    if (n == 1) return true;\\n    if (n == 2) return (dislikesSize == 0);\\n    unsigned char * colored = calloc(n, sizeof(unsigned char));\\n    ListEntry* * adjacency = malloc(n * sizeof(ListEntry *));\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency[i] = list_init();\\n    }"], ["bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\\n    if (n == 1) return true;\\n    if (n == 2) return (dislikesSize == 0);\\n    unsigned char * colored = calloc(n, sizeof(unsigned char));\\n    ListEntry* * adjacency = malloc(n * sizeof(ListEntry *));\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency[i] = list_init();\\n    }"], ["bool possibleBipartition(int n, int** dislikes, int dislikesSize, int* dislikesColSize){\\n    if (n == 1) return true;\\n    if (n == 2) return (dislikesSize == 0);\\n    unsigned char * colored = calloc(n, sizeof(unsigned char));\\n    ListEntry* * adjacency = malloc(n * sizeof(ListEntry *));\\n    for (int i = 0; i < n; i++)\\n    {\\n        adjacency[i] = list_init();\\n    }"]]}
{"id": "2209", "ref_c": [["int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int* ans = (int*)calloc(n, sizeof(int));\\n    int sum = 0, targetSum = mean * (n + rollsSize);\\n    for(int i = 0; i < rollsSize; i++)\\n        sum += rolls[i];\\n    targetSum -= sum;\\n    \\n    *returnSize = n;\\n    if(targetSum < n || targetSum > 6*n){\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int sum = mean * (rollsSize + n);\\n    int rolls_sum = 0;\\n    for (int i = 0; i < rollsSize ; i++){\\n        rolls_sum = rolls_sum + rolls[i];\\n    }"], ["int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int* ans = (int*)calloc(n, sizeof(int));\\n    int sum = 0, targetSum = mean * (n + rollsSize);\\n    for(int i = 0; i < rollsSize; i++)\\n        sum += rolls[i];\\n    targetSum -= sum;\\n    \\n    *returnSize = n;\\n    if(targetSum < n || targetSum > 6*n){\\n        *returnSize = 0;\\n        return NULL;\\n    }"]]}
{"id": "2210", "ref_c": [["int chalkReplacer(int* chalk, int chalkSize, int k){\\n    long int sum=0;\\n\\n    //prefix sum to find sum of all chalks required\\n    for(int n = 0; n<chalkSize; n+=1)\\n    {\\n        sum+=chalk[n];\\n    }"], ["int chalkReplacer(int* chalk, int chalkSize, int k){\\n    if(k<chalk[0]) return 0;\\n    for(int i=1;i<chalkSize;i++){\\n        chalk[i]+=chalk[i-1];\\n        if(chalk[i] > k) return i;\\n    }"], ["int chalkReplacer(int* chalk, int chalkSize, int k){\\n    long sum = 0, temp = 0;\\n    for(int i = 0; i < chalkSize; i++)\\n        sum += chalk[i];\\n    sum = k % sum;\\n    for(int i = 0; i < chalkSize; i++)\\n    {\\n        temp += chalk[i];\\n        if(temp > sum)\\n            return i;\\n    }"]]}
{"id": "2211", "ref_c": [["int countSubarrays(int* nums, int numsSize, int k){\\n    int at;\\n    int appear[200000] = {0}"], ["int countSubarrays(int* nums, int numsSize, int k){\\n    int at;\\n    int appear[200000] = {0}"], ["int countSubarrays(int* nums, int numsSize, int k){\\n    int at;\\n    int appear[200000] = {0}"]]}
{"id": "2212", "ref_c": [["int finalValueAfterOperations(char ** operations, int operationsSize) {\\n    int x = 0;\\n\\n    for (int i = 0; i < operationsSize; i++) {\\n        if (operations[i][0] == \\'-\\' || operations[i][2] == \\'-\\' ) x--;\\n        else x++;\\n    }"], ["int finalValueAfterOperations(char ** operations, int operationsSize) {\\n    int x = 0;\\n\\n    for (int i = 0; i < operationsSize; i++) {\\n        if (operations[i][0] == \\'-\\' || operations[i][2] == \\'-\\' ) x--;\\n        else x++;\\n    }"], ["int finalValueAfterOperations(char ** operations, int operationsSize) {\\n    int x = 0;\\n\\n    for (int i = 0; i < operationsSize; i++) {\\n        if (operations[i][0] == \\'-\\' || operations[i][2] == \\'-\\' ) x--;\\n        else x++;\\n    }"]]}
{"id": "2213", "ref_c": ["\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\n\treturn *p1 - *p2;\n}\n\nint64_t maxStrength(int * const nums, const int numsLen){\n\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\n\n\tbool numUsed = false;\n\tint64_t product = 1;\n\n\t//positive from right\n\tfor (int i = numsLen - 1; i >= 0 && nums[i] > 0; i -= 1){\n\t\tnumUsed = true;\n\t\tproduct *= nums[i];\n\t}\n\t//negative pairs from left\n\tfor (int i = 1; i < numsLen && nums[i] < 0; i += 2){\n\t\tnumUsed = true;\n\t\tproduct *= (int64_t)nums[i - 1] * (int64_t)nums[i];\t\t\n\t}\n\n\treturn numUsed? product : nums[numsLen - 1];\n}\n", "\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\n\treturn *p1 - *p2;\n}\n\nint64_t maxStrength(int * const nums, const int numsLen){\n\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\n\n\tbool numUsed = false;\n\tint64_t product = 1;\n\n\t//positive from right\n\tfor (int i = numsLen - 1; i >= 0 && nums[i] > 0; i -= 1){\n\t\tnumUsed = true;\n\t\tproduct *= nums[i];\n\t}\n\t//negative pairs from left\n\tfor (int i = 1; i < numsLen && nums[i] < 0; i += 2){\n\t\tnumUsed = true;\n\t\tproduct *= (int64_t)nums[i - 1] * (int64_t)nums[i];\t\t\n\t}\n\n\treturn numUsed? product : nums[numsLen - 1];\n}\n", "\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\n\treturn *p1 - *p2;\n}\n\nint64_t maxStrength(int * const nums, const int numsLen){\n\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\n\n\tbool numUsed = false;\n\tint64_t product = 1;\n\n\t//positive from right\n\tfor (int i = numsLen - 1; i >= 0 && nums[i] > 0; i -= 1){\n\t\tnumUsed = true;\n\t\tproduct *= nums[i];\n\t}\n\t//negative pairs from left\n\tfor (int i = 1; i < numsLen && nums[i] < 0; i += 2){\n\t\tnumUsed = true;\n\t\tproduct *= (int64_t)nums[i - 1] * (int64_t)nums[i];\t\t\n\t}\n\n\treturn numUsed? product : nums[numsLen - 1];\n}\n"]}
{"id": "2214", "ref_c": [["int* maxPoints(int** grid, int gridSize, int* gridColSize, int* queries, int queriesSize, int* returnSize){\\n    int nowpoint = 0;\\n    struct list* helper1 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    struct list* helper2 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    int count1 = 0;\\n    int count2 = 0;\\n\\n    struct pp* remake = malloc(sizeof(struct pp)*queriesSize);\\n    for (int i = 0 ; i < queriesSize ; i++){\\n        remake[i].val = queries[i];\\n        remake[i].place = i;\\n    }"], ["int* maxPoints(int** grid, int gridSize, int* gridColSize, int* queries, int queriesSize, int* returnSize){\\n    int nowpoint = 0;\\n    struct list* helper1 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    struct list* helper2 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    int count1 = 0;\\n    int count2 = 0;\\n\\n    struct pp* remake = malloc(sizeof(struct pp)*queriesSize);\\n    for (int i = 0 ; i < queriesSize ; i++){\\n        remake[i].val = queries[i];\\n        remake[i].place = i;\\n    }"], ["int* maxPoints(int** grid, int gridSize, int* gridColSize, int* queries, int queriesSize, int* returnSize){\\n    int nowpoint = 0;\\n    struct list* helper1 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    struct list* helper2 =  malloc(sizeof(struct list)*(gridSize*(*gridColSize)));\\n    int count1 = 0;\\n    int count2 = 0;\\n\\n    struct pp* remake = malloc(sizeof(struct pp)*queriesSize);\\n    for (int i = 0 ; i < queriesSize ; i++){\\n        remake[i].val = queries[i];\\n        remake[i].place = i;\\n    }"]]}
{"id": "2215", "ref_c": [["int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    if(k<=numOnes)\\n        return k;\\n    else if (k<=numOnes+numZeros)\\n        return numOnes;\\n    return numOnes - (k - numOnes - numZeros);\\n}"], ["int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n        vector<int> A;\\n        for(int i=0;i<numOnes;i++)\\n            A.push_back(1);\\n        for(int i=0;i<numZeros;i++)\\n            A.push_back(0);\\n        for(int i=0;i<numNegOnes;i++)\\n            A.push_back(-1);\\n        int S=0;\\n        for(int i=0;i<k;i++)\\n            S+=A[i];\\n        if(S>=k)\\n            return k;\\n        return S;\\n    }", "int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    int S=numOnes+numZeros+numNegOnes;\\n    int A[1000];\\n    if(S==0)\\n        A[1];\\n    else\\n        A[S];\\n    for(int i=0;i<numOnes;i++)\\n        A[i]=1;\\n    for(int i=numOnes;i<numOnes+numZeros;i++)\\n        A[i]=0;\\n    for(int i=numOnes+numZeros;i<numOnes+numZeros+numNegOnes;i++)\\n        A[i]=-1;\\n    int C=0;\\n    for(int i=0;i<k;i++)\\n        C+=A[i];\\n    if(C>=k)\\n        return k;\\n    return C;\\n}", "int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        ArrayList<Integer> A=new ArrayList<Integer>(1000);\\n        for(int i=0;i<numOnes;i++)\\n            A.add(1);\\n        for(int i=numOnes;i<numOnes+numZeros;i++)\\n            A.add(0);\\n        for(int i=numOnes+numZeros;i<numOnes+numZeros+numNegOnes;i++)\\n            A.add(-1);\\n        int S=0;\\n        for(int i=0;i<k;i++)\\n            S+=A.get(i);\\n        if(S>=k)\\n            return k;\\n        return S;\\n    }"], ["int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return Math.min(k, numOnes) - Math.max(0, k - numOnes - numZeros);\\n        \\n    }", "int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    return min(k, numOnes) - max(0, k - numOnes - numZeros);\\n}"]]}
{"id": "2216", "ref_c": [["int* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n  *returnSize = queriesSize;\\n  int* ret = malloc(queriesSize * sizeof(int));\\n  for(int i = 0; i < queriesSize; i++) {\\n    ret[i] = search(queries[i][0], queries[i][1]);\\n  }"], ["int* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n  *returnSize = queriesSize;\\n  int* ret = malloc(queriesSize * sizeof(int));\\n  for(int i = 0; i < queriesSize; i++) {\\n    ret[i] = search(queries[i][0], queries[i][1]);\\n  }"], ["int* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n  *returnSize = queriesSize;\\n  int* ret = malloc(queriesSize * sizeof(int));\\n  for(int i = 0; i < queriesSize; i++) {\\n    ret[i] = search(queries[i][0], queries[i][1]);\\n  }"]]}
{"id": "2217", "ref_c": [["int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101][601] = {0}", "int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101] = {0}"], ["int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101][601] = {0}", "int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101] = {0}"], ["int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101][601] = {0}", "int findMaxForm(char ** strs, int strsSize, int m, int n)\\n{\\n    int memo[101][101] = {0}"]]}
{"id": "2218", "ref_c": [["int* largestValues(struct TreeNode* root, int* returnSize) {\\n    if (root == NULL) {\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* largestValues(struct TreeNode* root, int* returnSize) {\\n    if (root == NULL) {\\n        *returnSize = 0;\\n        return NULL;\\n    }", "int* largestValues(struct TreeNode* root, int* returnSize) {\\n    ans = NULL;\\n    ansSize = 0;\\n    dfs(root, 0);\\n    *returnSize = ansSize;\\n    return ans;\\n}"], ["int* largestValues(struct TreeNode* root, int* returnSize){\\n    int* result = (int*)malloc(sizeof(int)*10000);\\n    *returnSize = 0;\\n    if(!root){\\n        return result;\\n    }"]]}
{"id": "2219", "ref_c": [["int maxChunksToSorted(int* arr, int arrSize){\\n    int max=0,chunk=0;\\n    for(int i=0;i<arrSize;i++)\\n    {    max=(max<arr[i])?arr[i]:max;        \\n        if(i==max) chunk++;    }"], ["int maxChunksToSorted(int* arr, int arrSize){\\n    int max=0,chunk=0;\\n    for(int i=0;i<arrSize;i++)\\n    {    max=(max<arr[i])?arr[i]:max;        \\n        if(i==max) chunk++;    }"], ["int maxChunksToSorted(int* arr, int arrSize){\\n    int max=0,chunk=0;\\n    for(int i=0;i<arrSize;i++)\\n    {    max=(max<arr[i])?arr[i]:max;        \\n        if(i==max) chunk++;    }"]]}
{"id": "2220", "ref_c": [["int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int list[1000001];\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    for (int i = 0 ; i < numsSize ; i++){\\n        list[nums[i]] = i;\\n        ans[i] = nums[i];\\n    }"], ["int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int list[1000001];\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    for (int i = 0 ; i < numsSize ; i++){\\n        list[nums[i]] = i;\\n        ans[i] = nums[i];\\n    }"], ["int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int list[1000001];\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    for (int i = 0 ; i < numsSize ; i++){\\n        list[nums[i]] = i;\\n        ans[i] = nums[i];\\n    }"]]}
{"id": "2221", "ref_c": [["int** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\\n    int i, j;\\n    head = NULL;\\n    tail = NULL;\\n\\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<*isWaterColSize;j++){\\n            if(isWater[i][j])\\n                queue_land(i,j,0);\\n        }"], ["int** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\\n    int i, j;\\n    head = NULL;\\n    tail = NULL;\\n\\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<*isWaterColSize;j++){\\n            if(isWater[i][j])\\n                queue_land(i,j,0);\\n        }"], ["int** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\\n    int i, j;\\n    head = NULL;\\n    tail = NULL;\\n\\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<*isWaterColSize;j++){\\n            if(isWater[i][j])\\n                queue_land(i,j,0);\\n        }"]]}
{"id": "2222", "ref_c": [["void reorderList(struct ListNode* head){\\nstruct ListNode *stack[50000];\\nstruct ListNode *temp=head;\\nint i=0;\\nwhile(temp)\\n{\\n    stack[i]=temp;\\n    temp=temp->next;\\n    i++;\\n}"], ["void reorderList(struct ListNode* head){\\nstruct ListNode *stack[50000];\\nstruct ListNode *temp=head;\\nint i=0;\\nwhile(temp)\\n{\\n    stack[i]=temp;\\n    temp=temp->next;\\n    i++;\\n}"], ["void reorderList(struct ListNode* head){\\nstruct ListNode *stack[50000];\\nstruct ListNode *temp=head;\\nint i=0;\\nwhile(temp)\\n{\\n    stack[i]=temp;\\n    temp=temp->next;\\n    i++;\\n}"]]}
{"id": "2223", "ref_c": [["char ** findItinerary(char *** tickets, int ticketsSize, int* ticketsColSize, int* returnSize){\\n\\n    /*\\n     * Algorithm:\\n     *  (1) Using a hash table for storing \"src->dst\" info.\\n     *      E.g.\\n     *          [[\"JFK\",\"KUL\"],[\"JFK\",\"KUL\"],[\"NRT\",\"JFK\"]]\\n     *          JFK->KUL\\n     *          JFK->NRT\\n     *          NRT->JFK \\n     *\\n     *  (2) Find all the valid itinerary (store in ascending lexical order)\\n     *          JFK->NRT->JFK->KUL   (Used all the tickets)\\n     *          JFK->KUL             (Invalid)\\n     *  (3) Return the answer\\n     */\\n     \\n    /*\\n     * Input:\\n     *  ***tickets, \\n     *  ticketsSize, int\\n     *  *ticketsColSize\\n     */\\n    node_t *trie = NULL;\\n    itinerary_t *itry[100];\\n    char **ans, buf[5000];\\n    int itry_cnt = 0;\\n\\n    *returnSize = 0;\\n    \\n    trie_init(&trie);\\n    \\n    for (int i = 0; i < ticketsSize; i++) {\\n        trie_insert(trie, tickets[i][0], tickets[i][1]);\\n    }"], ["char ** findItinerary(char *** tickets, int ticketsSize, int* ticketsColSize, int* returnSize){\\n\\n    /*\\n     * Algorithm:\\n     *  (1) Using a hash table for storing \"src->dst\" info.\\n     *      E.g.\\n     *          [[\"JFK\",\"KUL\"],[\"JFK\",\"KUL\"],[\"NRT\",\"JFK\"]]\\n     *          JFK->KUL\\n     *          JFK->NRT\\n     *          NRT->JFK \\n     *\\n     *  (2) Find all the valid itinerary (store in ascending lexical order)\\n     *          JFK->NRT->JFK->KUL   (Used all the tickets)\\n     *          JFK->KUL             (Invalid)\\n     *  (3) Return the answer\\n     */\\n     \\n    /*\\n     * Input:\\n     *  ***tickets, \\n     *  ticketsSize, int\\n     *  *ticketsColSize\\n     */\\n    node_t *trie = NULL;\\n    itinerary_t *itry[100];\\n    char **ans, buf[5000];\\n    int itry_cnt = 0;\\n\\n    *returnSize = 0;\\n    \\n    trie_init(&trie);\\n    \\n    for (int i = 0; i < ticketsSize; i++) {\\n        trie_insert(trie, tickets[i][0], tickets[i][1]);\\n    }"], ["char ** findItinerary(char *** tickets, int ticketsSize, int* ticketsColSize, int* returnSize){\\n\\n    /*\\n     * Algorithm:\\n     *  (1) Using a hash table for storing \"src->dst\" info.\\n     *      E.g.\\n     *          [[\"JFK\",\"KUL\"],[\"JFK\",\"KUL\"],[\"NRT\",\"JFK\"]]\\n     *          JFK->KUL\\n     *          JFK->NRT\\n     *          NRT->JFK \\n     *\\n     *  (2) Find all the valid itinerary (store in ascending lexical order)\\n     *          JFK->NRT->JFK->KUL   (Used all the tickets)\\n     *          JFK->KUL             (Invalid)\\n     *  (3) Return the answer\\n     */\\n     \\n    /*\\n     * Input:\\n     *  ***tickets, \\n     *  ticketsSize, int\\n     *  *ticketsColSize\\n     */\\n    node_t *trie = NULL;\\n    itinerary_t *itry[100];\\n    char **ans, buf[5000];\\n    int itry_cnt = 0;\\n\\n    *returnSize = 0;\\n    \\n    trie_init(&trie);\\n    \\n    for (int i = 0; i < ticketsSize; i++) {\\n        trie_insert(trie, tickets[i][0], tickets[i][1]);\\n    }"]]}
{"id": "2224", "ref_c": [["long long putMarbles(int* weights, int weightsSize, int k){\\n    \\n    int* pairs = calloc(weightsSize, sizeof(int));\\n    for (int i = 0; i < weightsSize - 1; i++)\\n        pairs[i] = weights[i] + weights[i + 1];\\n    \\n    qsort(pairs, weightsSize - 1, sizeof(int), cmp);\\n    \\n    long long ret = 0;\\n    for (int i = 0; i < k - 1; i++)\\n        ret += pairs[weightsSize - 2 - i] - pairs[i];\\n\\t\\t\\n    return ret;\\n}"], ["long long putMarbles(int* weights, int weightsSize, int k){\\n    \\n    int* pairs = calloc(weightsSize, sizeof(int));\\n    for (int i = 0; i < weightsSize - 1; i++)\\n        pairs[i] = weights[i] + weights[i + 1];\\n    \\n    qsort(pairs, weightsSize - 1, sizeof(int), cmp);\\n    \\n    long long ret = 0;\\n    for (int i = 0; i < k - 1; i++)\\n        ret += pairs[weightsSize - 2 - i] - pairs[i];\\n\\t\\t\\n    return ret;\\n}"], ["long long putMarbles(int* weights, int weightsSize, int k){\\n    //if there is only one bag or mags equal to size of weights then the min max will be 0\\n    if(k==1 || weightsSize == k){return 0;}"]]}
{"id": "2225", "ref_c": ["\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\n{\n    if (i < 0 || j < 0 || i >= gridSize)\n        return;\n    if (j >= gridColSize[i])\n        return;\n    if (grid[i][j] == '0')\n        return;\n    grid[i][j] = '0';\n    visit(grid, i-1, j, gridSize, gridColSize);\n    visit(grid, i+1, j, gridSize, gridColSize);\n    visit(grid, i, j-1, gridSize, gridColSize);\n    visit(grid, i, j+1, gridSize, gridColSize);\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize){\n    int i, j;\n    int res = 0;\n    \n    for (i = 0; i < gridSize; i++) {\n        for (j = 0; j < gridColSize[i]; j++) {\n            if (grid[i][j] == '1') {\n                visit(grid, i, j, gridSize, gridColSize);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n", "\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\n{\n    if (i < 0 || j < 0 || i >= gridSize)\n        return;\n    if (j >= gridColSize[i])\n        return;\n    if (grid[i][j] == '0')\n        return;\n    grid[i][j] = '0';\n    visit(grid, i-1, j, gridSize, gridColSize);\n    visit(grid, i+1, j, gridSize, gridColSize);\n    visit(grid, i, j-1, gridSize, gridColSize);\n    visit(grid, i, j+1, gridSize, gridColSize);\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize){\n    int i, j;\n    int res = 0;\n    \n    for (i = 0; i < gridSize; i++) {\n        for (j = 0; j < gridColSize[i]; j++) {\n            if (grid[i][j] == '1') {\n                visit(grid, i, j, gridSize, gridColSize);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n", "\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\n{\n    if (i < 0 || j < 0 || i >= gridSize)\n        return;\n    if (j >= gridColSize[i])\n        return;\n    if (grid[i][j] == '0')\n        return;\n    grid[i][j] = '0';\n    visit(grid, i-1, j, gridSize, gridColSize);\n    visit(grid, i+1, j, gridSize, gridColSize);\n    visit(grid, i, j-1, gridSize, gridColSize);\n    visit(grid, i, j+1, gridSize, gridColSize);\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize){\n    int i, j;\n    int res = 0;\n    \n    for (i = 0; i < gridSize; i++) {\n        for (j = 0; j < gridColSize[i]; j++) {\n            if (grid[i][j] == '1') {\n                visit(grid, i, j, gridSize, gridColSize);\n                res++;\n            }\n        }\n    }\n    return res;\n}\n"]}
{"id": "2226", "ref_c": [["long long minCost(int* basket1, int basket1Size, int* basket2, int basket2Size){\\n    // use counting hashmap to match elements from basket1 to basket 2 (count basket1 +, count basket2 -)\\n    // if there are elements with odd counts, either positive or negative, operation is impossible - return -1.\\n    //              (can be done during hashmap build using odd totaller - +1 when count goes from even to odd, -1 when goes from odd to even)\\n    //              (use odds += (((count & 1) << 1) - 1) ... even => -1, odd => 1)\\n   \\n    // lowest cost is by using lowest value items to do all needed swaps,\\n    // unless a double-swap has an item that is lower cost than 2 of the lowest cost items.\\n    // so find minimum item cost, double it, find all items below that cost that need to move, use all of them to move other items, then use lowest \\n    //  cost items to move the rest (do not need to be items that need to move as long as number of moves is even - it must be)\\n    if(basket2Size != basket1Size) return -1;\\n    int hashsize = basket1Size + 100; // minimum extra space in the hashtable\\n    __asm__ volatile (\"     bsr     %1, %0      \\\\n\"         // bit scan reverse\\n                    \"       inc     %0          \\\\n\"         // n+=1 to get last unset bit rather than first set bit\\n                    \"       xor     %1, %1      \\\\n\"         // = 0\\n                    \"       bts     %0, %1      \\\\n\"         //  n\\'th bit set        \\n                    : \"+&r\" (hashbits), \"+&r\" (hashsize) );\\n    int map[hashsize]; // next largest power of two\\n    int count[hashsize]; // next largest power of two\\n    for(int i = 0; i < hashsize; map[i++] = 0) count[i] = 0;\\n    hashsize -= 1; // hash mask\\n    hashbits = 32 - hashbits; // right shift to leave old_hashbits remaining bits\\n\\n    // printf(\"%i, %i, %i\\\\n\", basket1Size, hashsize, hashbits);\\n\\n    int odds = 0; // odd counts counter\\n    int min = 1000000000; // minimum item cost\\n    int uniques = 0; // counting uniques. if total number of unique items goes beyond basketSize, balancing them is impossible.\\n\\n    for(int i = 0; i < basket1Size; i++)\\n    {\\n        int m, e = basket1[i];\\n        if(e < min) min = e;\\n        uint32_t hash = hashfunc(e);\\n        while((m = map[hash]))\\n        {\\n            if(m == e) goto match1;\\n            hash = (hash+1) & hashsize;\\n        }"], ["long long minCost(int* basket1, int basket1Size, int* basket2, int basket2Size){\\n    // use counting hashmap to match elements from basket1 to basket 2 (count basket1 +, count basket2 -)\\n    // if there are elements with odd counts, either positive or negative, operation is impossible - return -1.\\n    //              (can be done during hashmap build using odd totaller - +1 when count goes from even to odd, -1 when goes from odd to even)\\n    //              (use odds += (((count & 1) << 1) - 1) ... even => -1, odd => 1)\\n   \\n    // lowest cost is by using lowest value items to do all needed swaps,\\n    // unless a double-swap has an item that is lower cost than 2 of the lowest cost items.\\n    // so find minimum item cost, double it, find all items below that cost that need to move, use all of them to move other items, then use lowest \\n    //  cost items to move the rest (do not need to be items that need to move as long as number of moves is even - it must be)\\n    if(basket2Size != basket1Size) return -1;\\n    int hashsize = basket1Size + 100; // minimum extra space in the hashtable\\n    __asm__ volatile (\"     bsr     %1, %0      \\\\n\"         // bit scan reverse\\n                    \"       inc     %0          \\\\n\"         // n+=1 to get last unset bit rather than first set bit\\n                    \"       xor     %1, %1      \\\\n\"         // = 0\\n                    \"       bts     %0, %1      \\\\n\"         //  n\\'th bit set        \\n                    : \"+&r\" (hashbits), \"+&r\" (hashsize) );\\n    int map[hashsize]; // next largest power of two\\n    int count[hashsize]; // next largest power of two\\n    for(int i = 0; i < hashsize; map[i++] = 0) count[i] = 0;\\n    hashsize -= 1; // hash mask\\n    hashbits = 32 - hashbits; // right shift to leave old_hashbits remaining bits\\n\\n    // printf(\"%i, %i, %i\\\\n\", basket1Size, hashsize, hashbits);\\n\\n    int odds = 0; // odd counts counter\\n    int min = 1000000000; // minimum item cost\\n    int uniques = 0; // counting uniques. if total number of unique items goes beyond basketSize, balancing them is impossible.\\n\\n    for(int i = 0; i < basket1Size; i++)\\n    {\\n        int m, e = basket1[i];\\n        if(e < min) min = e;\\n        uint32_t hash = hashfunc(e);\\n        while((m = map[hash]))\\n        {\\n            if(m == e) goto match1;\\n            hash = (hash+1) & hashsize;\\n        }"], ["long long minCost(int* basket1, int basket1Size, int* basket2, int basket2Size){\\n    // use counting hashmap to match elements from basket1 to basket 2 (count basket1 +, count basket2 -)\\n    // if there are elements with odd counts, either positive or negative, operation is impossible - return -1.\\n    //              (can be done during hashmap build using odd totaller - +1 when count goes from even to odd, -1 when goes from odd to even)\\n    //              (use odds += (((count & 1) << 1) - 1) ... even => -1, odd => 1)\\n   \\n    // lowest cost is by using lowest value items to do all needed swaps,\\n    // unless a double-swap has an item that is lower cost than 2 of the lowest cost items.\\n    // so find minimum item cost, double it, find all items below that cost that need to move, use all of them to move other items, then use lowest \\n    //  cost items to move the rest (do not need to be items that need to move as long as number of moves is even - it must be)\\n    if(basket2Size != basket1Size) return -1;\\n    int hashsize = basket1Size + 100; // minimum extra space in the hashtable\\n    __asm__ volatile (\"     bsr     %1, %0      \\\\n\"         // bit scan reverse\\n                    \"       inc     %0          \\\\n\"         // n+=1 to get last unset bit rather than first set bit\\n                    \"       xor     %1, %1      \\\\n\"         // = 0\\n                    \"       bts     %0, %1      \\\\n\"         //  n\\'th bit set        \\n                    : \"+&r\" (hashbits), \"+&r\" (hashsize) );\\n    int map[hashsize]; // next largest power of two\\n    int count[hashsize]; // next largest power of two\\n    for(int i = 0; i < hashsize; map[i++] = 0) count[i] = 0;\\n    hashsize -= 1; // hash mask\\n    hashbits = 32 - hashbits; // right shift to leave old_hashbits remaining bits\\n\\n    // printf(\"%i, %i, %i\\\\n\", basket1Size, hashsize, hashbits);\\n\\n    int odds = 0; // odd counts counter\\n    int min = 1000000000; // minimum item cost\\n    int uniques = 0; // counting uniques. if total number of unique items goes beyond basketSize, balancing them is impossible.\\n\\n    for(int i = 0; i < basket1Size; i++)\\n    {\\n        int m, e = basket1[i];\\n        if(e < min) min = e;\\n        uint32_t hash = hashfunc(e);\\n        while((m = map[hash]))\\n        {\\n            if(m == e) goto match1;\\n            hash = (hash+1) & hashsize;\\n        }"]]}
{"id": "2227", "ref_c": ["\nstruct Box {\n    int numBoxes;\n    int unitsPerBox;\n};\n\nint compare(const void *a, const void *b) {\n    return ((struct Box *)b)->unitsPerBox - ((struct Box *)a)->unitsPerBox;\n}\n\nint minimum(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize) {\n    int ans = 0;\n    int numOfBoxes = boxTypesSize;\n\n    struct Box* boxes = (struct Box*)malloc(numOfBoxes * sizeof(struct Box));\n\n    // Populate the boxes array\n    for (int i = 0; i < numOfBoxes; ++i) {\n        boxes[i].numBoxes = boxTypes[i][0];\n        boxes[i].unitsPerBox = boxTypes[i][1];\n    }\n\n    qsort(boxes, numOfBoxes, sizeof(struct Box), compare);\n\n    for (int i = 0; i < numOfBoxes; ++i) {\n        ans += minimum(truckSize, boxes[i].numBoxes) * boxes[i].unitsPerBox;\n        truckSize -= minimum(truckSize, boxes[i].numBoxes);\n    }\n\n    free(boxes);\n\n    return ans;\n}\n", "\nstruct Box {\n    int numBoxes;\n    int unitsPerBox;\n};\n\nint compare(const void *a, const void *b) {\n    return ((struct Box *)b)->unitsPerBox - ((struct Box *)a)->unitsPerBox;\n}\n\nint minimum(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize) {\n    int ans = 0;\n    int numOfBoxes = boxTypesSize;\n\n    struct Box* boxes = (struct Box*)malloc(numOfBoxes * sizeof(struct Box));\n\n    // Populate the boxes array\n    for (int i = 0; i < numOfBoxes; ++i) {\n        boxes[i].numBoxes = boxTypes[i][0];\n        boxes[i].unitsPerBox = boxTypes[i][1];\n    }\n\n    qsort(boxes, numOfBoxes, sizeof(struct Box), compare);\n\n    for (int i = 0; i < numOfBoxes; ++i) {\n        ans += minimum(truckSize, boxes[i].numBoxes) * boxes[i].unitsPerBox;\n        truckSize -= minimum(truckSize, boxes[i].numBoxes);\n    }\n\n    free(boxes);\n\n    return ans;\n}\n", "\nstruct Box {\n    int numBoxes;\n    int unitsPerBox;\n};\n\nint compare(const void *a, const void *b) {\n    return ((struct Box *)b)->unitsPerBox - ((struct Box *)a)->unitsPerBox;\n}\n\nint minimum(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint maximumUnits(int** boxTypes, int boxTypesSize, int* boxTypesColSize, int truckSize) {\n    int ans = 0;\n    int numOfBoxes = boxTypesSize;\n\n    struct Box* boxes = (struct Box*)malloc(numOfBoxes * sizeof(struct Box));\n\n    // Populate the boxes array\n    for (int i = 0; i < numOfBoxes; ++i) {\n        boxes[i].numBoxes = boxTypes[i][0];\n        boxes[i].unitsPerBox = boxTypes[i][1];\n    }\n\n    qsort(boxes, numOfBoxes, sizeof(struct Box), compare);\n\n    for (int i = 0; i < numOfBoxes; ++i) {\n        ans += minimum(truckSize, boxes[i].numBoxes) * boxes[i].unitsPerBox;\n        truckSize -= minimum(truckSize, boxes[i].numBoxes);\n    }\n\n    free(boxes);\n\n    return ans;\n}\n"]}
{"id": "2228", "ref_c": [["int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int* ans = (int*)calloc(n, sizeof(int));\\n    int sum = 0, targetSum = mean * (n + rollsSize);\\n    for(int i = 0; i < rollsSize; i++)\\n        sum += rolls[i];\\n    targetSum -= sum;\\n    \\n    *returnSize = n;\\n    if(targetSum < n || targetSum > 6*n){\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int* ans = (int*)calloc(n, sizeof(int));\\n    int sum = 0, targetSum = mean * (n + rollsSize);\\n    for(int i = 0; i < rollsSize; i++)\\n        sum += rolls[i];\\n    targetSum -= sum;\\n    \\n    *returnSize = n;\\n    if(targetSum < n || targetSum > 6*n){\\n        *returnSize = 0;\\n        return NULL;\\n    }"], ["int* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int* ans = (int*)calloc(n, sizeof(int));\\n    int sum = 0, targetSum = mean * (n + rollsSize);\\n    for(int i = 0; i < rollsSize; i++)\\n        sum += rolls[i];\\n    targetSum -= sum;\\n    \\n    *returnSize = n;\\n    if(targetSum < n || targetSum > 6*n){\\n        *returnSize = 0;\\n        return NULL;\\n    }"]]}
{"id": "2229", "ref_c": [["int searchInsert(int* nums, int numsSize, int target){\\n    int index1 = -1;\\n    int index2 = -1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            index1 = i;\\n            break;\\n        }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"], ["int searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }"]]}
{"id": "2230", "ref_c": [["bool isPossibleDivide(int* nums, int numsSize, int k){\\n\\n    if(numsSize % k != 0)\\n        return false;\\n    \\n    hash_t* hash_table = NULL;\\n    hash_t* el;\\n    int key = 0;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    \\n    for(size_t i = 0 ; i < numsSize; i++)\\n    {\\n        key = nums[i];\\n        HASH_FIND_INT(hash_table,&key,el);\\n        if(el == NULL)\\n        {\\n            el = (hash_t*)malloc(sizeof(hash_t));\\n            el->freq = 1;\\n            el->id = nums[i];\\n            HASH_ADD_INT(hash_table,id,el);\\n        }"], ["bool isPossibleDivide(int* nums, int numsSize, int k){\\n\\n    if(numsSize % k != 0)\\n        return false;\\n    \\n    hash_t* hash_table = NULL;\\n    hash_t* el;\\n    int key = 0;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    \\n    for(size_t i = 0 ; i < numsSize; i++)\\n    {\\n        key = nums[i];\\n        HASH_FIND_INT(hash_table,&key,el);\\n        if(el == NULL)\\n        {\\n            el = (hash_t*)malloc(sizeof(hash_t));\\n            el->freq = 1;\\n            el->id = nums[i];\\n            HASH_ADD_INT(hash_table,id,el);\\n        }"], ["bool isPossibleDivide(int* nums, int numsSize, int k){\\n\\n    if(numsSize % k != 0)\\n        return false;\\n    \\n    hash_t* hash_table = NULL;\\n    hash_t* el;\\n    int key = 0;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    \\n    for(size_t i = 0 ; i < numsSize; i++)\\n    {\\n        key = nums[i];\\n        HASH_FIND_INT(hash_table,&key,el);\\n        if(el == NULL)\\n        {\\n            el = (hash_t*)malloc(sizeof(hash_t));\\n            el->freq = 1;\\n            el->id = nums[i];\\n            HASH_ADD_INT(hash_table,id,el);\\n        }"]]}
{"id": "2231", "ref_c": [["int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\\n    int** ans = malloc(2000 * sizeof(int*));\\n    (*returnColumnSizes) = malloc(2000 * sizeof(int));\\n\\n    if(root == NULL) {\\n        *returnSize = 0;\\n        (*returnColumnSizes)[0] = 0;\\n        return ans;\\n    }"], ["int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\\n    \\n    /*\\n     * Input:\\n     *  root, root of binary tree\\n     */\\n    \\n    int **ans = (int **)calloc(1, sizeof(int *) * 2000);\\n    int tmp;\\n\\n    *returnSize = 0;\\n    *returnColumnSizes = (int *)calloc(1, sizeof(int) * 2000);\\n\\n    dfs(root, returnSize, returnColumnSizes, 0, ans);\\n\\n    /* Reverse the row 1, 3, ... node values of row 1, 3 */\\n    for (int i = 1; i < *returnSize; i+=2) {\\n        for (int j = 0, k = (*returnColumnSizes)[i] - 1; j < k; j++, k--) {\\n            tmp = ans[i][j];\\n            ans[i][j] = ans[i][k];\\n            ans[i][k] = tmp;\\n        }"], ["int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\\n    int** ans = malloc(2000 * sizeof(int*));\\n    (*returnColumnSizes) = malloc(2000 * sizeof(int));\\n\\n    if(root == NULL) {\\n        *returnSize = 0;\\n        (*returnColumnSizes)[0] = 0;\\n        return ans;\\n    }"]]}
{"id": "2232", "ref_c": [["int addMinimum(char * word){\\n    int len=strlen(word);\\n    if(len==1) return 2;\\n    int idx=0;\\n    int ans=0;\\n    while(idx<len){\\n        if(idx==len-1){\\n            ans+=2;\\n            idx++;\\n        }"], ["int addMinimum(char * word){\\n    int len=strlen(word);\\n    if(len==1) return 2;\\n    int idx=0;\\n    int ans=0;\\n    while(idx<len){\\n        if(idx==len-1){\\n            ans+=2;\\n            idx++;\\n        }"], ["int addMinimum(char * word){\\n    int len=strlen(word);\\n    if(len==1) return 2;\\n    int idx=0;\\n    int ans=0;\\n    while(idx<len){\\n        if(idx==len-1){\\n            ans+=2;\\n            idx++;\\n        }"]]}
{"id": "2233", "ref_c": [["long long distinctNames(char ** ideas, int ideasSize){\\n    printf(\"%d\",ideasSize);\\n    group** words=(group**)calloc(sizeof(group*),26);\\n    group_2** words_tree=(group_2**)calloc(sizeof(group_2*),25);\\n    int* count=(int*)calloc(26,4),i;\\n    int** pairs=(int**)malloc(25*sizeof(int*));\\n    long long ans=0;\\n    for(i=0;i<ideasSize;i++){\\n        int val=ideas[i][0]-\\'a\\';\\n        words[val]=insert_in_list(ideas[i]+1,words[val]);\\n        count[val]++;\\n        if(val) {\\n            val--;\\n            if(words_tree[val]) insert_in_tree(ideas[i]+1,words_tree[val]);\\n            else{\\n                words_tree[val]=(group_2*)calloc(1,sizeof(group_2));\\n                words_tree[val]->word=ideas[i]+1;\\n            }"], ["long long distinctNames(char ** ideas, int ideasSize){\\n    printf(\"%d\",ideasSize);\\n    group** words=(group**)calloc(sizeof(group*),26);\\n    group_2** words_tree=(group_2**)calloc(sizeof(group_2*),25);\\n    int* count=(int*)calloc(26,4),i;\\n    int** pairs=(int**)malloc(25*sizeof(int*));\\n    long long ans=0;\\n    for(i=0;i<ideasSize;i++){\\n        int val=ideas[i][0]-\\'a\\';\\n        words[val]=insert_in_list(ideas[i]+1,words[val]);\\n        count[val]++;\\n        if(val) {\\n            val--;\\n            if(words_tree[val]) insert_in_tree(ideas[i]+1,words_tree[val]);\\n            else{\\n                words_tree[val]=(group_2*)calloc(1,sizeof(group_2));\\n                words_tree[val]->word=ideas[i]+1;\\n            }"], ["long long distinctNames(char ** ideas, int ideasSize){\\n    printf(\"%d\",ideasSize);\\n    group** words=(group**)calloc(sizeof(group*),26);\\n    group_2** words_tree=(group_2**)calloc(sizeof(group_2*),25);\\n    int* count=(int*)calloc(26,4),i;\\n    int** pairs=(int**)malloc(25*sizeof(int*));\\n    long long ans=0;\\n    for(i=0;i<ideasSize;i++){\\n        int val=ideas[i][0]-\\'a\\';\\n        words[val]=insert_in_list(ideas[i]+1,words[val]);\\n        count[val]++;\\n        if(val) {\\n            val--;\\n            if(words_tree[val]) insert_in_tree(ideas[i]+1,words_tree[val]);\\n            else{\\n                words_tree[val]=(group_2*)calloc(1,sizeof(group_2));\\n                words_tree[val]->word=ideas[i]+1;\\n            }"]]}
{"id": "2234", "ref_c": [["bool isUnivalTree(struct TreeNode* root) {\\n    printf(\"%d\", root->val);\\n    return isUniValue(root, root->val);\\n}"], ["bool isUnivalTree(struct TreeNode* root) \\n{\\n  if(root->left == NULL && root->right == NULL)\\n  {\\n    return true;\\n  }"], ["bool isUnivalTree(struct TreeNode* root) {\\n    return check(root,root->val);\\n}"]]}
{"id": "2235", "ref_c": [["int furthestBuilding(int* heights, int heightsSize, int bricks, int ladders){\\n\\n    int val;\\n    int diff;\\n\\n    /* Max heap */\\n    heap_init();\\n\\n    /* Scan the buildings */\\n    for (int i = 0; i < heightsSize - 1; i++) {\\n\\n        /* Get height different between current and next building */\\n        diff = heights[i + 1] - heights[i];\\n        \\n        /* Need to put bricks or ladder for higher building */\\n        if (diff > 0) {\\n        \\n            /* Store the height difference in max heap */\\n            heap_push(diff);\\n            bricks -= diff;\\n            \\n            /* If there is no enough brick */\\n            if (bricks < 0) {\\n                \\n                /* Check if we can move to next building by using ladder */\\n                if (ladders > 0) {\\n                    \\n                    /* Swap a ladder to get more bricks if possible */\\n                    if (heap_empty() == false) {\\n                        heap_pop(&val);\\n                        bricks += val;\\n                    }"], ["int furthestBuilding(int* heights, int heightsSize, int bricks, int ladders){\\n\\n    int val;\\n    int diff;\\n\\n    /* Max heap */\\n    heap_init();\\n\\n    /* Scan the buildings */\\n    for (int i = 0; i < heightsSize - 1; i++) {\\n\\n        /* Get height different between current and next building */\\n        diff = heights[i + 1] - heights[i];\\n        \\n        /* Need to put bricks or ladder for higher building */\\n        if (diff > 0) {\\n        \\n            /* Store the height difference in max heap */\\n            heap_push(diff);\\n            bricks -= diff;\\n            \\n            /* If there is no enough brick */\\n            if (bricks < 0) {\\n                \\n                /* Check if we can move to next building by using ladder */\\n                if (ladders > 0) {\\n                    \\n                    /* Swap a ladder to get more bricks if possible */\\n                    if (heap_empty() == false) {\\n                        heap_pop(&val);\\n                        bricks += val;\\n                    }"], ["int furthestBuilding(int* heights, int heightsSize, int bricks, int ladders){\\n\\n    int val;\\n    int diff;\\n\\n    /* Max heap */\\n    heap_init();\\n\\n    /* Scan the buildings */\\n    for (int i = 0; i < heightsSize - 1; i++) {\\n\\n        /* Get height different between current and next building */\\n        diff = heights[i + 1] - heights[i];\\n        \\n        /* Need to put bricks or ladder for higher building */\\n        if (diff > 0) {\\n        \\n            /* Store the height difference in max heap */\\n            heap_push(diff);\\n            bricks -= diff;\\n            \\n            /* If there is no enough brick */\\n            if (bricks < 0) {\\n                \\n                /* Check if we can move to next building by using ladder */\\n                if (ladders > 0) {\\n                    \\n                    /* Swap a ladder to get more bricks if possible */\\n                    if (heap_empty() == false) {\\n                        heap_pop(&val);\\n                        bricks += val;\\n                    }"]]}
{"id": "2236", "ref_c": ["\nbool isPalin(char * s)\n{\n    int i;\n    int l = strlen(s) - 1;\n\n    for (i = 0; i <= l; i++, l--)\n        if (s[i] != s[l])\n            break;\n    if (i > l)\n        return true;\n    return false;\n}\n\nchar * breakPalindrome(char * palindrome)\n{\n    int l = strlen(palindrome);\n\n    if (l == 1)\n        return \"\";\n\n    for (int i = 0; i < l; i++)\n    {\n        if (palindrome[i] != 'a')\n        {\n            char t = palindrome[i];\n            palindrome[i] = 'a';\n            if (!isPalin(palindrome))\n                return palindrome;\n            palindrome[i] = t;\n        }\n    }\n    palindrome[l - 1] = 'b';\n    return palindrome;\n}\n", "\nbool isPalin(char * s)\n{\n    int i;\n    int l = strlen(s) - 1;\n\n    for (i = 0; i <= l; i++, l--)\n        if (s[i] != s[l])\n            break;\n    if (i > l)\n        return true;\n    return false;\n}\n\nchar * breakPalindrome(char * palindrome)\n{\n    int l = strlen(palindrome);\n\n    if (l == 1)\n        return \"\";\n\n    for (int i = 0; i < l; i++)\n    {\n        if (palindrome[i] != 'a')\n        {\n            char t = palindrome[i];\n            palindrome[i] = 'a';\n            if (!isPalin(palindrome))\n                return palindrome;\n            palindrome[i] = t;\n        }\n    }\n    palindrome[l - 1] = 'b';\n    return palindrome;\n}\n", "\nbool isPalin(char * s)\n{\n    int i;\n    int l = strlen(s) - 1;\n\n    for (i = 0; i <= l; i++, l--)\n        if (s[i] != s[l])\n            break;\n    if (i > l)\n        return true;\n    return false;\n}\n\nchar * breakPalindrome(char * palindrome)\n{\n    int l = strlen(palindrome);\n\n    if (l == 1)\n        return \"\";\n\n    for (int i = 0; i < l; i++)\n    {\n        if (palindrome[i] != 'a')\n        {\n            char t = palindrome[i];\n            palindrome[i] = 'a';\n            if (!isPalin(palindrome))\n                return palindrome;\n            palindrome[i] = t;\n        }\n    }\n    palindrome[l - 1] = 'b';\n    return palindrome;\n}\n"]}
{"id": "2237", "ref_c": [["int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int list[1000001];\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    for (int i = 0 ; i < numsSize ; i++){\\n        list[nums[i]] = i;\\n        ans[i] = nums[i];\\n    }"], ["int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int list[1000001];\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    for (int i = 0 ; i < numsSize ; i++){\\n        list[nums[i]] = i;\\n        ans[i] = nums[i];\\n    }"], ["int* arrayChange(int* nums, int numsSize, int** operations, int operationsSize, int* operationsColSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int list[1000001];\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    for (int i = 0 ; i < numsSize ; i++){\\n        list[nums[i]] = i;\\n        ans[i] = nums[i];\\n    }"]]}
{"id": "2238", "ref_c": ["\nint minSwap(int* A, int ASize, int* B, int BSize){\n    int ans = 0;\n    int e = 0; // the max. good index before the current iteration i\n    int curSwaps = 0; // record no. of swaps in the current subproblem\n    for (int i = 1; i < ASize; i++) {\n        if (MIN(A[i], B[i]) > MAX(A[i-1], B[i-1])) { // if i is a good index\n            ans += MIN(curSwaps, i-e-curSwaps); // select min. swaps of the two configurations\n            e = i;\n            curSwaps = 0;\n            continue;\n        }\n        if (A[i-1] >= A[i] || B[i-1] >= B[i]) { // if need to swap i\n            int temp = A[i];\n            A[i] = B[i];\n            B[i] = temp;\n            curSwaps++;\n        }\n    } // end for\n    ans += MIN(curSwaps, ASize-e-curSwaps);\n    return ans;\n}\n", "\nint minSwap(int* A, int ASize, int* B, int BSize){\n    int ans = 0;\n    int e = 0; // the max. good index before the current iteration i\n    int curSwaps = 0; // record no. of swaps in the current subproblem\n    for (int i = 1; i < ASize; i++) {\n        if (MIN(A[i], B[i]) > MAX(A[i-1], B[i-1])) { // if i is a good index\n            ans += MIN(curSwaps, i-e-curSwaps); // select min. swaps of the two configurations\n            e = i;\n            curSwaps = 0;\n            continue;\n        }\n        if (A[i-1] >= A[i] || B[i-1] >= B[i]) { // if need to swap i\n            int temp = A[i];\n            A[i] = B[i];\n            B[i] = temp;\n            curSwaps++;\n        }\n    } // end for\n    ans += MIN(curSwaps, ASize-e-curSwaps);\n    return ans;\n}\n", "\nint minSwap(int* A, int ASize, int* B, int BSize){\n    int ans = 0;\n    int e = 0; // the max. good index before the current iteration i\n    int curSwaps = 0; // record no. of swaps in the current subproblem\n    for (int i = 1; i < ASize; i++) {\n        if (MIN(A[i], B[i]) > MAX(A[i-1], B[i-1])) { // if i is a good index\n            ans += MIN(curSwaps, i-e-curSwaps); // select min. swaps of the two configurations\n            e = i;\n            curSwaps = 0;\n            continue;\n        }\n        if (A[i-1] >= A[i] || B[i-1] >= B[i]) { // if need to swap i\n            int temp = A[i];\n            A[i] = B[i];\n            B[i] = temp;\n            curSwaps++;\n        }\n    } // end for\n    ans += MIN(curSwaps, ASize-e-curSwaps);\n    return ans;\n}\n"]}
{"id": "2241", "ref_c": [["long long pickGifts(int* gifts, int giftsSize, int k){\\n    int i, j, l, max;\\n    long long sum = 0;\\n    for(i=0; i<k; i++){\\n        max = 0;\\n        for(j=0; j<giftsSize; j++){\\n            if(max<gifts[j]){\\n                max = gifts[j];\\n                l = j;\\n            }"], ["long long pickGifts(int* gifts, int giftsSize, int k) {\\n\\n    register unsigned short i, j, x;\\n\\tregister unsigned long long sum = 0;\\n\\tfor(i = 0; i < k; i++) {\\n        register unsigned int largest = 0, index = 0;\\n\\t\\tfor(j = 0; j < giftsSize; j++) {\\n\\t\\t\\tif(gifts[j] > largest) {\\n\\t\\t\\t\\tlargest = gifts[j];\\n\\t\\t\\t\\tindex = j;\\n\\t\\t\\t}"], ["long long pickGifts(int* gifts, int giftsSize, int k) {\\n\\n    register unsigned short i, j, x;\\n\\tregister unsigned long long sum = 0;\\n\\tfor(i = 0; i < k; i++) {\\n        register unsigned int largest = 0, index = 0;\\n\\t\\tfor(j = 0; j < giftsSize; j++) {\\n\\t\\t\\tif(gifts[j] > largest) {\\n\\t\\t\\t\\tlargest = gifts[j];\\n\\t\\t\\t\\tindex = j;\\n\\t\\t\\t}"]]}
{"id": "2243", "ref_c": [["long long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }"], ["long long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }"], ["long long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }"]]}
{"id": "2244", "ref_c": [["char * smallestBeautifulString(char * s, int k) {\\n    int n = strlen(s);\\n    char *ans = malloc((n + 1) * sizeof(char));\\n    strcpy(ans, s);\\n    \\n    for (int i = n - 1; i >= 0; i--) {\\n        for (int j = ans[i] - \\'a\\' + 1; j < k; j++) {\\n            char c = \\'a\\' + j;\\n            if ((i < 1 || c != ans[i - 1]) && (i < 2 || c != ans[i - 2])) {\\n                ans[i] = c;\\n                for (int l = i + 1; l < n; l++) {\\n                    for (int m = 0; m < k; m++) {\\n                        c = \\'a\\' + m;\\n                        if ((l < 1 || c != ans[l - 1]) && (l < 2 || c != ans[l - 2])) {\\n                            ans[l] = c;\\n                            break;\\n                        }"], ["char * smallestBeautifulString(char * s, int k) {\\n    int n = strlen(s);\\n    char *ans = malloc((n + 1) * sizeof(char));\\n    strcpy(ans, s);\\n    \\n    for (int i = n - 1; i >= 0; i--) {\\n        for (int j = ans[i] - \\'a\\' + 1; j < k; j++) {\\n            char c = \\'a\\' + j;\\n            if ((i < 1 || c != ans[i - 1]) && (i < 2 || c != ans[i - 2])) {\\n                ans[i] = c;\\n                for (int l = i + 1; l < n; l++) {\\n                    for (int m = 0; m < k; m++) {\\n                        c = \\'a\\' + m;\\n                        if ((l < 1 || c != ans[l - 1]) && (l < 2 || c != ans[l - 2])) {\\n                            ans[l] = c;\\n                            break;\\n                        }"], ["char * smallestBeautifulString(char * s, int k) {\\n    int n = strlen(s);\\n    char *ans = malloc((n + 1) * sizeof(char));\\n    strcpy(ans, s);\\n    \\n    for (int i = n - 1; i >= 0; i--) {\\n        for (int j = ans[i] - \\'a\\' + 1; j < k; j++) {\\n            char c = \\'a\\' + j;\\n            if ((i < 1 || c != ans[i - 1]) && (i < 2 || c != ans[i - 2])) {\\n                ans[i] = c;\\n                for (int l = i + 1; l < n; l++) {\\n                    for (int m = 0; m < k; m++) {\\n                        c = \\'a\\' + m;\\n                        if ((l < 1 || c != ans[l - 1]) && (l < 2 || c != ans[l - 2])) {\\n                            ans[l] = c;\\n                            break;\\n                        }"]]}
{"id": "2245", "ref_c": [["int sumOfPower(int* nums, int numsSize){\\n\\tint powerSum = 0;\\n\\n\\tqsort(nums, numsSize, sizeof (int), &cmp_int_asc);\\n\\n\\tint prefixSumWithWeight = 0;\\n\\tfor (int i = 0; i < numsSize; i += 1){\\n\\t\\tpowerSum = ( powerSum + ( (int64_t)prefixSumWithWeight + nums[i] ) % MOD * nums[i] % MOD * nums[i] % MOD ) % MOD;\\n\\t\\tprefixSumWithWeight = ( prefixSumWithWeight * 2 % MOD + nums[i] ) % MOD;\\n\\t}"], ["int sumOfPower(int* nums, int numsSize){\\n\\tint powerSum = 0;\\n\\n\\tqsort(nums, numsSize, sizeof (int), &cmp_int_asc);\\n\\n\\tint prefixSumWithWeight = 0;\\n\\tfor (int i = 0; i < numsSize; i += 1){\\n\\t\\tpowerSum = ( powerSum + ( (int64_t)prefixSumWithWeight + nums[i] ) % MOD * nums[i] % MOD * nums[i] % MOD ) % MOD;\\n\\t\\tprefixSumWithWeight = ( prefixSumWithWeight * 2 % MOD + nums[i] ) % MOD;\\n\\t}"], ["int sumOfPower(int* nums, int numsSize){\\n\\tint powerSum = 0;\\n\\n\\tqsort(nums, numsSize, sizeof (int), &cmp_int_asc);\\n\\n\\tint prefixSumWithWeight = 0;\\n\\tfor (int i = 0; i < numsSize; i += 1){\\n\\t\\tpowerSum = ( powerSum + ( (int64_t)prefixSumWithWeight + nums[i] ) % MOD * nums[i] % MOD * nums[i] % MOD ) % MOD;\\n\\t\\tprefixSumWithWeight = ( prefixSumWithWeight * 2 % MOD + nums[i] ) % MOD;\\n\\t}"]]}
{"id": "2246", "ref_c": [["int xorOperation(int n, int start){\\n   int ans[n];\\n    int sum=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        ans[i]=start+2*i;\\n    }"], ["int xorOperation(int n, int start)\\n{\\n    int arr[n],x=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        arr[i] = start + 2*i;\\n        x = x^arr[i];\\n    }"], ["int xorOperation(int n, int start){\\n    int xor = start;\\n    for (int i = 1; i < n; i++){\\n        xor ^= (start + 2 * i);\\n    }"]]}
{"id": "2247", "ref_c": [["int sumOfLeftLeaves(struct TreeNode* root){\\n    if (!root)\\n        return 0;\\n\\n    int sum = 0;\\n    if (root->left && !root->left->left && !root->left->right)\\n        sum += root->left->val;\\n    \\n    sum+=sumOfLeftLeaves(root->left);\\n    sum+=sumOfLeftLeaves(root->right);\\n\\n    return sum;\\n}"], ["int sumOfLeftLeaves(struct TreeNode* root){\\n    if (!root)\\n        return 0;\\n\\n    int sum = 0;\\n    if (root->left && !root->left->left && !root->left->right)\\n        sum += root->left->val;\\n    \\n    sum+=sumOfLeftLeaves(root->left);\\n    sum+=sumOfLeftLeaves(root->right);\\n\\n    return sum;\\n}"], ["int sumOfLeftLeaves(struct TreeNode* root){\\n    if (!root)\\n        return 0;\\n\\n    int sum = 0;\\n    if (root->left && !root->left->left && !root->left->right)\\n        sum += root->left->val;\\n    \\n    sum+=sumOfLeftLeaves(root->left);\\n    sum+=sumOfLeftLeaves(root->right);\\n\\n    return sum;\\n}"]]}
{"id": "2248", "ref_c": [["int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\\n    *returnColumnSizes = (int *)malloc( sizeof (int) * (nums1Size + nums2Size) );\\n    int ** rets = (int **)malloc( sizeof (int *) * (nums1Size + nums2Size) );\\n    *returnSize = 0;\\n\\n    for (int i = 0, j = 0; i < nums1Size || j < nums2Size; ){\\n        (*returnColumnSizes)[*returnSize] = 2;\\n        rets[*returnSize] = (int *)malloc(sizeof (int) * 2);\\n\\n        if (!( j < nums2Size )){\\n            rets[*returnSize][0] = nums1[i][0];\\n            rets[*returnSize][1] = nums1[i][1];\\n            i += 1;\\n        }"], ["int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\\n    *returnColumnSizes = (int *)malloc( sizeof (int) * (nums1Size + nums2Size) );\\n    int ** rets = (int **)malloc( sizeof (int *) * (nums1Size + nums2Size) );\\n    *returnSize = 0;\\n\\n    for (int i = 0, j = 0; i < nums1Size || j < nums2Size; ){\\n        (*returnColumnSizes)[*returnSize] = 2;\\n        rets[*returnSize] = (int *)malloc(sizeof (int) * 2);\\n\\n        if (!( j < nums2Size )){\\n            rets[*returnSize][0] = nums1[i][0];\\n            rets[*returnSize][1] = nums1[i][1];\\n            i += 1;\\n        }"], ["int** mergeArrays(int** nums1, int nums1Size, int* nums1ColSize, int** nums2, int nums2Size, int* nums2ColSize, int* returnSize, int** returnColumnSizes){\\n    *returnColumnSizes = (int *)malloc( sizeof (int) * (nums1Size + nums2Size) );\\n    int ** rets = (int **)malloc( sizeof (int *) * (nums1Size + nums2Size) );\\n    *returnSize = 0;\\n\\n    for (int i = 0, j = 0; i < nums1Size || j < nums2Size; ){\\n        (*returnColumnSizes)[*returnSize] = 2;\\n        rets[*returnSize] = (int *)malloc(sizeof (int) * 2);\\n\\n        if (!( j < nums2Size )){\\n            rets[*returnSize][0] = nums1[i][0];\\n            rets[*returnSize][1] = nums1[i][1];\\n            i += 1;\\n        }"]]}
{"id": "2249", "ref_c": [["int countValidWords(char * sentence){\\n    char tok[2]=\" \";\\n    char* token=strtok(sentence,tok);\\n    int cnt=0;\\n    while(token){\\n        if(isValid(token))cnt++;\\n        token=strtok(NULL,tok);\\n    }"], ["int countValidWords(char * sentence){\\n    char tok[2]=\" \";\\n    char* token=strtok(sentence,tok);\\n    int cnt=0;\\n    while(token){\\n        if(isValid(token))cnt++;\\n        token=strtok(NULL,tok);\\n    }"], ["int countValidWords(char * sentence){\\n    char tok[2]=\" \";\\n    char* token=strtok(sentence,tok);\\n    int cnt=0;\\n    while(token){\\n        if(isValid(token))cnt++;\\n        token=strtok(NULL,tok);\\n    }"]]}
{"id": "2250", "ref_c": [["int* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n\\tconst int colLen = *gridColSize, rowLen = gridSize;\\n\\n\\tfor (int row = 0; row < rowLen; row += 1){\\n\\t\\tbool allZero = true;\\n\\t\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\t\\tif (grid[row][col] != 0){\\n\\t\\t\\t\\tallZero = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}"], ["int* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n\\tconst int colLen = *gridColSize, rowLen = gridSize;\\n\\n\\tfor (int row = 0; row < rowLen; row += 1){\\n\\t\\tbool allZero = true;\\n\\t\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\t\\tif (grid[row][col] != 0){\\n\\t\\t\\t\\tallZero = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}"], ["int* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize){\\n\\tconst int colLen = *gridColSize, rowLen = gridSize;\\n\\n\\tfor (int row = 0; row < rowLen; row += 1){\\n\\t\\tbool allZero = true;\\n\\t\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\t\\tif (grid[row][col] != 0){\\n\\t\\t\\t\\tallZero = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}"]]}
{"id": "2251", "ref_c": [["int* twoSum(int* nums, int numsSize, int target, int* returnSize){\\n\\n*returnSize=2;// der zu returnende array hat 2 elemente\\n\\nint *array = malloc(2*sizeof(int) ); // Output array max 2 elemente\\n\\nfor (int i=0; i<numsSize;i++)\\n{\\n    for( int j=1+i;j<numsSize;j++)\\n    {\\n        if(nums[i] + nums[j] == target)\\n        {\\n        array[0]=i;\\n        array[1]=j;\\n        return array;\\n        }"], ["int* twoSum(int* nums, int numsSize, int target, int* returnSize) {\\n    int* result = (int*)malloc(2 * sizeof(int)); // Allocate memory for the result array\\n    if (result == NULL) {\\n        *returnSize = 0;\\n        return NULL; // Return NULL if memory allocation fails\\n    }"], ["int* twoSum(int* nums, int numsSize, int target, int* returnSize){\\n\\n*returnSize=2;// der zu returnende array hat 2 elemente\\n\\nint *array = malloc(2*sizeof(int) ); // Output array max 2 elemente\\n\\nfor (int i=0; i<numsSize;i++)\\n{\\n    for( int j=1+i;j<numsSize;j++)\\n    {\\n        if(nums[i] + nums[j] == target)\\n        {\\n        array[0]=i;\\n        array[1]=j;\\n        return array;\\n        }"]]}
{"id": "2252", "ref_c": [["int paintWalls(int* cost, int costSize, int* time, int timeSize){\\n\\n    /*\\n     * Input:\\n     *  *cost,\\n     *  costSize,\\n     *  *time,\\n     *  timeSize\\n     */\\n\\n    int ans, **dp = (int **)malloc(sizeof(int *) * costSize);\\n\\n    for (int i = 0; i < costSize; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * costSize);\\n\\n        for (int j = 0; j < costSize; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int paintWalls(int* cost, int costSize, int* time, int timeSize){\\n\\n    /*\\n     * Input:\\n     *  *cost,\\n     *  costSize,\\n     *  *time,\\n     *  timeSize\\n     */\\n\\n    int ans, **dp = (int **)malloc(sizeof(int *) * costSize);\\n\\n    for (int i = 0; i < costSize; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * costSize);\\n\\n        for (int j = 0; j < costSize; j++) {\\n            dp[i][j] = -1;\\n        }"], ["int paintWalls(int* cost, int costSize, int* time, int timeSize){\\n\\n    /*\\n     * Input:\\n     *  *cost,\\n     *  costSize,\\n     *  *time,\\n     *  timeSize\\n     */\\n\\n    int ans, **dp = (int **)malloc(sizeof(int *) * costSize);\\n\\n    for (int i = 0; i < costSize; i++) {\\n        dp[i] = (int *)malloc(sizeof(int) * costSize);\\n\\n        for (int j = 0; j < costSize; j++) {\\n            dp[i][j] = -1;\\n        }"]]}
{"id": "2253", "ref_c": [["int* survivedRobotsHealths(int* positions, int positionsSize, int* healths, int healthsSize, char * directions, int* returnSize){\\n    int **record=malloc(sizeof(int*)*positionsSize);\\n    int *stack=malloc(sizeof(int)*positionsSize),idx=-1;\\n    int *res=malloc(sizeof(int)*positionsSize);\\n    *returnSize=0;\\n    for(int i=0;i<positionsSize;i++){\\n        record[i]=malloc(sizeof(int)*2);\\n        record[i][0]=positions[i];\\n        record[i][1]=i;\\n        if(directions[i]==\\'L\\') healths[i]*=-1;\\n    }"], ["int* survivedRobotsHealths(int* positions, int positionsSize, int* healths, int healthsSize, char * directions, int* returnSize){\\n    int **record=malloc(sizeof(int*)*positionsSize);\\n    int *stack=malloc(sizeof(int)*positionsSize),idx=-1;\\n    int *res=malloc(sizeof(int)*positionsSize);\\n    *returnSize=0;\\n    for(int i=0;i<positionsSize;i++){\\n        record[i]=malloc(sizeof(int)*2);\\n        record[i][0]=positions[i];\\n        record[i][1]=i;\\n        if(directions[i]==\\'L\\') healths[i]*=-1;\\n    }"], ["int* survivedRobotsHealths(int* positions, int positionsSize, int* healths, int healthsSize, char * directions, int* returnSize){\\n    int **record=malloc(sizeof(int*)*positionsSize);\\n    int *stack=malloc(sizeof(int)*positionsSize),idx=-1;\\n    int *res=malloc(sizeof(int)*positionsSize);\\n    *returnSize=0;\\n    for(int i=0;i<positionsSize;i++){\\n        record[i]=malloc(sizeof(int)*2);\\n        record[i][0]=positions[i];\\n        record[i][1]=i;\\n        if(directions[i]==\\'L\\') healths[i]*=-1;\\n    }"]]}
{"id": "2254", "ref_c": [["char ** buildArray(int* target, int targetSize, int n, int* returnSize) {\\n    // Initialize a vector of strings to store the result.\\n    char **ans = (char **)malloc(2 * n * sizeof(char *));\\n    \\n    int i = 1;  // Initialize an integer \\'i\\' to represent the current number.\\n    int idx = 0;  // Initialize an index to track the position in the \\'ans\\' array.\\n    \\n    // Iterate through each element \\'a\\' in the \\'target\\' array.\\n    for (int j = 0; j < targetSize; j++) {\\n        int a = target[j];\\n        \\n        // Check if \\'i\\' is less than \\'a\\' and perform the following steps if true:\\n        while (i < a) {\\n            ans[idx++] = strdup(\"Push\");  // Simulate pushing the current number onto the stack.\\n            ans[idx++] = strdup(\"Pop\");   // Simulate popping an element from the stack.\\n            i++;  // Move to the next number.\\n        }"], ["char ** buildArray(int* target, int targetSize, int n, int* returnSize) {\\n    // Initialize a vector of strings to store the result.\\n    char **ans = (char **)malloc(2 * n * sizeof(char *));\\n    \\n    int i = 1;  // Initialize an integer \\'i\\' to represent the current number.\\n    int idx = 0;  // Initialize an index to track the position in the \\'ans\\' array.\\n    \\n    // Iterate through each element \\'a\\' in the \\'target\\' array.\\n    for (int j = 0; j < targetSize; j++) {\\n        int a = target[j];\\n        \\n        // Check if \\'i\\' is less than \\'a\\' and perform the following steps if true:\\n        while (i < a) {\\n            ans[idx++] = strdup(\"Push\");  // Simulate pushing the current number onto the stack.\\n            ans[idx++] = strdup(\"Pop\");   // Simulate popping an element from the stack.\\n            i++;  // Move to the next number.\\n        }"], ["char ** buildArray(int* target, int targetSize, int n, int* returnSize) {\\n    // Initialize a vector of strings to store the result.\\n    char **ans = (char **)malloc(2 * n * sizeof(char *));\\n    \\n    int i = 1;  // Initialize an integer \\'i\\' to represent the current number.\\n    int idx = 0;  // Initialize an index to track the position in the \\'ans\\' array.\\n    \\n    // Iterate through each element \\'a\\' in the \\'target\\' array.\\n    for (int j = 0; j < targetSize; j++) {\\n        int a = target[j];\\n        \\n        // Check if \\'i\\' is less than \\'a\\' and perform the following steps if true:\\n        while (i < a) {\\n            ans[idx++] = strdup(\"Push\");  // Simulate pushing the current number onto the stack.\\n            ans[idx++] = strdup(\"Pop\");   // Simulate popping an element from the stack.\\n            i++;  // Move to the next number.\\n        }"]]}
{"id": "2255", "ref_c": [["struct TreeNode* convertBST(struct TreeNode* root){\\n    conv(root, 0);\\n\\n    return root;\\n}"], ["struct TreeNode* convertBST(struct TreeNode* root)\\n{\\n    int t=0;\\n    func(root, &t);\\n    return root;\\n}"], ["struct TreeNode* convertBST(struct TreeNode* root){\\n\\t\\tint sum = 0;\\n\\t\\t\\n\\t\\tstruct TreeNode* sol(struct TreeNode* root){\\n\\t\\t\\tif ( root ){\\n\\t\\t\\t\\tsol(root->right);\\n\\t\\t\\t\\tsum = root->val += sum;\\n\\t\\t\\t\\tsol(root->left);\\n\\t\\t\\t}"]]}
{"id": "2256", "ref_c": [["int maxIncreasingGroups(int* usageLimits, int usageLimitsSize){\\n    // Order by limits\\n    qsort(usageLimits , usageLimitsSize , sizeof(int) , sort_int_increasing);\\n\\n    long long number_of_elements = 0;\\n    long long maximum_group_size = 0;\\n    for (size_t i=0 ; i<usageLimitsSize ; i++) {\\n        number_of_elements += usageLimits[i];\\n        if (number_of_elements >= (maximum_group_size+1)*(maximum_group_size+2)/2) {\\n            maximum_group_size++;\\n        }"], ["int maxIncreasingGroups(int* usageLimits, int usageLimitsSize){\\n    // Order by limits\\n    qsort(usageLimits , usageLimitsSize , sizeof(int) , sort_int_increasing);\\n\\n    long long number_of_elements = 0;\\n    long long maximum_group_size = 0;\\n    for (size_t i=0 ; i<usageLimitsSize ; i++) {\\n        number_of_elements += usageLimits[i];\\n        if (number_of_elements >= (maximum_group_size+1)*(maximum_group_size+2)/2) {\\n            maximum_group_size++;\\n        }"], ["int maxIncreasingGroups(int* usageLimits, int usageLimitsSize){\\n    // Order by limits\\n    qsort(usageLimits , usageLimitsSize , sizeof(int) , sort_int_increasing);\\n\\n    long long number_of_elements = 0;\\n    long long maximum_group_size = 0;\\n    for (size_t i=0 ; i<usageLimitsSize ; i++) {\\n        number_of_elements += usageLimits[i];\\n        if (number_of_elements >= (maximum_group_size+1)*(maximum_group_size+2)/2) {\\n            maximum_group_size++;\\n        }"]]}
{"id": "2257", "ref_c": [["long long countPalindromePaths(int* parent, int parentSize, char * s){\\n    int K = 2*parentSize;\\n\\n    int n = parentSize;\\n    unsigned * dp = calloc(n,sizeof(int));\\n    unsigned * filled = calloc(n,sizeof(int));\\n    int * hash_table = calloc(K,sizeof(int));\\n    int * hash_values = malloc(K*sizeof(int));\\n    for (size_t i=0 ; i<K ; i++) {\\n        hash_values[i] = -1;\\n    }"], ["long long countPalindromePaths(int* parent, int parentSize, char * s){\\n    int K = 2*parentSize;\\n\\n    int n = parentSize;\\n    unsigned * dp = calloc(n,sizeof(int));\\n    unsigned * filled = calloc(n,sizeof(int));\\n    int * hash_table = calloc(K,sizeof(int));\\n    int * hash_values = malloc(K*sizeof(int));\\n    for (size_t i=0 ; i<K ; i++) {\\n        hash_values[i] = -1;\\n    }"], ["long long countPalindromePaths(int* parent, int parentSize, char * s){\\n    int K = 2*parentSize;\\n\\n    int n = parentSize;\\n    unsigned * dp = calloc(n,sizeof(int));\\n    unsigned * filled = calloc(n,sizeof(int));\\n    int * hash_table = calloc(K,sizeof(int));\\n    int * hash_values = malloc(K*sizeof(int));\\n    for (size_t i=0 ; i<K ; i++) {\\n        hash_values[i] = -1;\\n    }"]]}
{"id": "2258", "ref_c": [["int countSteppingNumbers(char * low, char * high){\\n    if (x++ == 0) { // Fill DP table in first run ;)\\n        fill_dp();\\n    }"], ["int countSteppingNumbers(char * low, char * high){\\n    if (x++ == 0) { // Fill DP table in first run ;)\\n        fill_dp();\\n    }"], ["int countSteppingNumbers(char * low, char * high){\\n    if (x++ == 0) { // Fill DP table in first run ;)\\n        fill_dp();\\n    }"]]}
{"id": "2259", "ref_c": [["int smallestRangeI(int* nums, int numsSize, int k)\\n{\\n    int max = INT_MIN;\\n    int min = INT_MAX;\\n    int ret = 0;\\n    int i=0;\\n    for(i=0; i<numsSize; i++)\\n    {\\n        if(nums[i] <= min)\\n        {\\n            min = nums[i];\\n        }"], ["int smallestRangeI(int* nums, int numsSize, int k) {\\n    int min = nums[0], max = nums[0];\\n    for (int i = 1; i < numsSize; i++) {\\n        min = MIN(min, nums[i]);\\n        max = MAX(max, nums[i]);\\n    }"], ["int smallestRangeI(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    if((nums[numsSize-1] - nums[0]) > 2*k){ return (nums[numsSize-1] - nums[0] - 2*k); }", "int smallestRangeI(int* nums, int numsSize, int k){\\n    int minValue = INT_MAX, maxValue = INT_MIN;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        minValue = MIN(minValue, nums[i]);\\n        maxValue = MAX(maxValue, nums[i]);\\n    }"]]}
{"id": "2260", "ref_c": [["long long findMaximumElegance(int** items, int itemsSize, int* itemsColSize, int k) {\\n    qsort(items, itemsSize, sizeof(int *), compare);\\n\\n    int categoryCount[itemsSize + 1];\\n    memset(categoryCount, 0, sizeof(categoryCount));\\n\\n    long long totalProfit = 0;\\n    int distinctCategories = 0;\\n\\n    // Initial candidate set\\n    for (int i = 0; i < k; ++i) {\\n        totalProfit += items[i][0];\\n        categoryCount[items[i][1]]++;\\n        if (categoryCount[items[i][1]] == 1) {\\n            distinctCategories++;\\n        }"], ["long long findMaximumElegance(int** items, int itemsSize, int* itemsColSize, int k){\\n  /* Hashtable to hold a count of the number of items in use by each category */\\n  struct category_hash* table = NULL;\\n  struct category_hash entries[itemsSize];\\n  struct category_hash* pos = entries;\\n\\n  /* Build a set of items sorted from highest profit to lowest */\\n  int* sorted[itemsSize];\\n  memcpy(sorted, items, itemsSize * sizeof(*items));\\n  qsort(sorted, itemsSize, sizeof(*sorted), &pair_cmp);\\n\\n  /* Start by choosing all the highest profit items and building a set of the minimal number of categories */\\n  long long curr = 0;\\n  for (int i = 0; i < k; ++i) {\\n    curr += sorted[i][0];\\n    struct category_hash* entry;\\n    HASH_FIND_INT(table, &sorted[i][1], entry);\\n    if (!entry) {\\n      entry = pos++;\\n      entry->category = sorted[i][1];\\n      entry->count = 0;\\n      HASH_ADD_INT(table, category, entry);\\n    }"], ["long long findMaximumElegance(int** items, int itemsSize, int* itemsColSize, int k) {\\n    qsort(items, itemsSize, sizeof(int *), compare);\\n\\n    int categoryCount[itemsSize + 1];\\n    memset(categoryCount, 0, sizeof(categoryCount));\\n\\n    long long totalProfit = 0;\\n    int distinctCategories = 0;\\n\\n    // Initial candidate set\\n    for (int i = 0; i < k; ++i) {\\n        totalProfit += items[i][0];\\n        categoryCount[items[i][1]]++;\\n        if (categoryCount[items[i][1]] == 1) {\\n            distinctCategories++;\\n        }"]]}
{"id": "2261", "ref_c": [["int maximalNetworkRank(int n, int** roads, int roadsSize, int* roadsColSize){\\n    int **matrix = malloc(sizeof(int *) * (n + 1));\\n    for (int i = 0;i <= n; i ++)\\n        matrix[i] = calloc(n, sizeof(int));\\n    for (int i = 0; i < roadsSize; i++)\\n    {\\n        matrix[roads[i][0]][roads[i][1]] += 1;\\n        matrix[roads[i][1]][roads[i][0]] += 1;\\n        matrix[n][roads[i][0]] += 1;\\n        matrix[n][roads[i][1]] += 1;\\n    }"], ["int maximalNetworkRank(int n, int** roads, int roadsSize, int* roadsColSize) {\\n    int adjacencyMatrix[n][n];\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            adjacencyMatrix[i][j] = 0;\\n        }"], ["int maximalNetworkRank(int n, int** roads, int roadsSize, int* roadsColSize){\\n    int **matrix = malloc(sizeof(int *) * (n + 1));\\n    for (int i = 0;i <= n; i ++)\\n        matrix[i] = calloc(n, sizeof(int));\\n    for (int i = 0; i < roadsSize; i++)\\n    {\\n        matrix[roads[i][0]][roads[i][1]] += 1;\\n        matrix[roads[i][1]][roads[i][0]] += 1;\\n        matrix[n][roads[i][0]] += 1;\\n        matrix[n][roads[i][1]] += 1;\\n    }"]]}
